ORIGIN 'astlevel';

INCLUDE '~beta/grammars/beta/betacfl';
INCLUDE '~beta/grammars/beta/betagram';
INCLUDE 'getslotbinding';

BODY 'private/indexbody';


-- astInterfaceLib: Attributes --

AstAsAstIndex:
  (# N: ^AST
  enter N[]
  exit N[]
  #);
  
  
NULL: (#  exit none #);
ASTindex: 
  (# <<SLOT ASTindexLib:attributes>>;
     theAst: ^AST;
     
     asAST: (# exit theAst[] #);
     isNull: (# exit theAst[] = none #);
     theFragmentForm: (#exit theAst.frag[] #);
     nodeId: (# exit theAst.inx #);
     index: (# exit theAst.inx #);
     equal:
       (# anAst: ^AST; B: @boolean
       enter anAst[]
       do (if (anAst[] <> NONE) and (theAST[] <> NONE) then
              theAst[] -> anAST.equal -> B 
          if)
       exit B
       #);
     brother: (# exit theAst.nextBrother #);
     son: (# exit theAst.son[] #);
     sonRef:
       (# S: @ASTindex
       do son -> S
       exit S[]
       #);
     father: (# exit theAST.father #);
     label:
       (#
       enter theAst.symbol
       exit theAst.symbol
       #);
     isSlot: 
       (# B: @boolean
       do theAst.isSlot -> B;
       exit B
       #);
     theSlotName:
       (# sd: ^slotDesc
       do theAst.theSlot->sd[]
       exit sd.name
       #);
     stringLength: 
       (# LX: ^lexemText
       do theAst.son[] -> LX[]
       exit LX.lgth
       #);
     getText:
       (# LT: ^lexemText
       do theAst.son[] -> LT[]
       exit LT.getText
       #);
     textEq: (# t: @text enter t exit (getText->t.equalNCS) #);
     internal: (#  exit (label > 0) #);
     astKind: (#  exit label -> theAst.frag.grammar.kindOfSymbol #);
     nodeClass: (#  exit theAst.frag.grammar.nodeClassArray[label] #);
     start:
       (# exit theAst.start #);
     end:
       (# exit theAst.end #);
     
  enter theAst[]
  exit theAst[]
  #);
addPrefix:
  (* desc must be a descriptor with empty prefix;
   * a non empty prefix node is inserted;
   * the name of the prefix is the empty string;
   * Is used for virtual categories like v::< (# ... #)
   *)
  (# desc: ^expanded;
     f: ^fragmentForm;
     pref: ^expanded;
     napl: ^expanded;
     na: ^nameAppl;
     gram: @grammar;
     astOverflow:< Exception;
  enter desc[]
  do desc.frag[]->f[];
     (gram.Prefix,f[])->grammarTable.default.newAst->pref[];
     (gram.NameApl,f[])->grammarTable.default.newAst->napl[];
     (nameAppl,f[])->grammarTable.default.newAst->na[];
     ''->na.putText;
     na[]->napl.putson1;
     napl[]->pref.putson1;
     pref[]->desc.putson1;
  exit napl[]
  #);
adjustForm:
  (# f: ^fragmentForm; a: ^expanded; gram: @grammar;
     astOverFlow:< Exception;
  enter f[]
  do (if f.root.symbol
      // gram.Attributes (* OLM: was AttributeL in old grammar/index *) then
	 (gram.AttributesForm,f[])->grammarTable.default.newAst->a[];
	 f.root[]->a.putson1;
	 a[]->f.root[]
      // gram.ObjectDescriptor then
	 (gram.DescriptorForm,f[])->grammarTable.default.newAst->a[];
	 f.root[]->a.putson1;
	 a[]->f.root[]
     if)
  #);
less: (#  exit 0 #);
equal: (#  exit 1 #);
greater: (#  exit 2 #);
CMP: (* compare two names *)
  (# res: @integer;
     lowerCaseDoesNotMatter: (#  exit 0xDFDFDFDF #);
     (* the hex-value dfdfdfdf:
      * the bitvalue to be used to mask such that
      * lower and upper case does not matter *)
     N1,N2: ^AST;
     NT1,NT2: ^lexemText;
     c1,c2: @char;
     l1,l2: @integer
  enter(N1[],N2[]) 
  do N1.son[] -> NT1[];
     N2.son[] -> NT2[];
     L:
     (if (NT1.lgth -> l1) = (NT2.lgth -> l2) then
         equal -> res;
         (for i: NT1.lgth repeat
		      NT1.value[i] %band 0xDF -> c1;
			  NT2.value[i] %band 0xDF -> c2;
              (if c1 <> c2 then
                  less -> res;
                  (if c1 > c2 then greater -> res if);
                  leave L
         if)for)
      else
         (if l1 < l2 then
             less -> res
          else
             greater -> res
         if)
     if)
  exit res
  #);
EQS: (* compare two names *)
  (# n1,n2: ^AST
  enter(n1[],n2[])
  exit((n1[],n2[])->CMP) = equal 
  #);
scanList:
  (* scan the elements of the list;
   * currentNode will exit t1, t2, ... Tn+1
   * tail will exit the tail of the list.
   *)
  (# sCurrent: ^AST;
     currentNode: (# exit sCurrent[] #);
     tail: (# exit sCurrent.nextBrother #);
     anAst: ^AST;
     EX: ^expanded;
     symbol: @integer
  enter anAst[]
  do (if (anAst.symbol->symbol) > 0 (* expanded *) then
         (if grammarTable.default.nodeClassArray[symbol] = kinds.list then
             anAst[] -> EX[];    (* we assume expanded here! *)
             EX.scan
             (# 
             do (if current.astkind <> kinds.optional then
                    current[] -> sCurrent[]; 
                    INNER scanList 
                if)
             #)
          else
             anAst[] -> sCurrent[];
             INNER scanList
     if)if)
  #);
prettyPrinter: 
  (# st: ^stream;
     a: ^ast;
     level: @integer;
     editorMode: @boolean
  enter (a[],st[],level,editorMode)
  <<SLOT PrettyPrinterBody: doPart>>
  #);

---fragmentFormLib: attributes---
theGSForm: (# exit root[] #)

---slotDescLib: attributes---
theNode: (# exit father #)

