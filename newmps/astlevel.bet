ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/basiclib/texthash';
INCLUDE 'propertylist';
INCLUDE '~beta/sysutils/pathhandler';

BODY 'private/treelevelbody';
BODY 'private/astbody';
BODY 'private/fragbody';



-- lib: attributes --

ContainerList: List
  (#
  #);

     
AstInterface:
  (# <<SLOT AstInterfaceLib: attributes>>;
     astLevelInit:<
       (#
       do thePathHandler.init;
		 	 TOP.grouptable.init;
          INNER;
       #);
	 
     AST:
       (# <<SLOT ASTLib: attributes>>;
          astkind: @int8u;
          status: @int8u;
          symbol: @int16;
		  b: @boolean;
          com: ^Comment;
          son: ^AST;
          brother: ^AST;
		  
		  NodeClass: (# exit grammartable.beta.nodeClassArray[symbol]  #);
		  
		  nextBrother:
		    (# next: ^AST;
			<<SLOT ASTNextBrother: doPart>>
			exit next[]
			#);
		  frag:
		    (# ff: ^FragmentForm;
			<<SLOT ASTFrag: doPart>>
			exit ff[]
			#);
		  father:
		    (* Returns the father of this(AST), or NONE if 
			 * this(AST) is root.
			 *)
		    (# theFather: ^AST;
			<<SLOT ASTFather: doPart>>
			exit theFather[]
			#);
		  equal:
		    (# other: ^AST;
			enter other[]
			exit (other[] = THIS(AST)[])
			#);
		  index:
		    (#
			exit -1
			#);
		  hasSemanticError:
		    (# 
			enter b
			exit b
			#);
		  semanticError:
		    (# error: @integer;
			enter error
			do (if error <> 0 then
			      'setting error: ' -> puttext;
			      error -> putint;
			      ' of ' -> puttext;
			      symbol -> grammartable.beta.symbolToName -> putline;
				  
				  exception (# #);
			    if);
			exit error
			#);
          dump:<
            (# level: @integer;
               output: ^stream;
			   gram: ^Treelevel;
            enter (level, output[], gram[])
            <<SLOT ASTDump: doPart>>
            #);
       #);
     
     Expanded: AST
       (# noOfsons:
            (# sons: @integer;
            <<SLOT ExpandedNoOfSons: doPart>>
            exit sons
            #);
          get:
            (# inx: @integer;
               as: ^AST;
            enter inx
            <<SLOT ExpandedGet: doPart>>
            exit as[]
            #);
          put:
            (# inx: @integer;
               as: ^AST;
            enter (inx, as[])
            <<SLOT ExpandedPut: doPart>>
            #);
		  scan:
		    (# current: ^AST;
			   currentSonNo: @integer;
			<<SLOT ExpandedScan: doPart>>
			#);
          suffixWalk:
            (# current: ^AST;
               cutIf:<
                 (# prod: @integer;toCut: @boolean
                 enter prod
                 do false->toCut; INNER
                 exit toCut
                 #);
            <<SLOT ExpandedSuffixWalk: doPart>>
            #);
          suffixWalkForProd:
            (# scanCat:< AST;
               current: ^scanCat;
               cutIf:<
                 (# prod: @integer;toCut: @boolean
                 enter prod
                 do false->toCut; INNER
                 exit toCut
                 #);
               prod: @integer;
            enter prod
            <<SLOT ExpandedsuffixWalkForProd: doPart>>
            #);
          getSon1: (# exit son[] #);
          getSon2: (# exit 2 -> get #);
          getSon3: (# exit 3 -> get #);
          getSon4: (# exit 4 -> get #);
          getSon5: (# exit 5 -> get #);
          getSon6: (# exit 6 -> get #);
          getSon7: (# exit 7 -> get #);
          getSon8: (# exit 8 -> get #);
          getSon9: (# exit 9 -> get #);
          putson1: (# a: ^ast enter a[] do (1,a[])->put #);
          putson2: (# a: ^ast enter a[] do (2,a[])->put #);
          putson3: (# a: ^ast enter a[] do (3,a[])->put #);
          putson4: (# a: ^ast enter a[] do (4,a[])->put #);
          putson5: (# a: ^ast enter a[] do (5,a[])->put #);
          putson6: (# a: ^ast enter a[] do (6,a[])->put #);
          putson7: (# a: ^ast enter a[] do (7,a[])->put #);
          putson8: (# a: ^ast enter a[] do (8,a[])->put #);
          putson9: (# a: ^ast enter a[] do (9,a[])->put #);
          dump::<
            (# <<SLOT ExpandedDump: doPart>> #);
       #);
     Cons: Expanded
       (# dump::<
            (# <<SLOT ConsDump: doPart>> #);
       #);
     List: Expanded
       (# SonCat:< AST;
          dump::<
            (# <<SLOT ListDump: doPart>> #);
       #);
     
     UnExpanded: AST
       (# (* value: ^text; *)
	      <<SLOT UnExpandedLib: attributes>>;
	      theSlot:
		    (#  aSlot: ^SlotDesc;
			enter aSlot[]
			exit aSlot[]
			#);
		  isSlot:
		    (# b: @boolean;
			enter b
			exit b
			#);
          dump::<
            (# <<SLOT UnExpandedDump: doPart>> #);
       #);
     Optional: AST
       (# dump::<
            (# <<SLOT OptionalDump: doPart>> #);
       #);
     SlotDesc: AST
       (# <<SLOT SlotDescLib: attributes>>;
	      value: [0] @char;
		  lgth: @integer;
	      name:
		    (# t: ^Text;
			do &Text[] -> t[];
			   value[1: lgth] -> t;
			exit t[]
			#);
		  category: @integer;
		  isBound: @boolean;
	      dump::<
            (# <<SLOT SlotDescDump: doPart>> #);
	   exit prodNo.slotDesc
       #);

     Lexem: AST
       (# dump::<
            (# <<SLOT LexemDump: doPart>> #);
       #);
     LexemText: Lexem
       (# value: [0] @char;
          lgth: @integer;
          getText:
            (# t: ^Text;
            do &Text[] -> t[];
               value -> t;
            exit t[]
            #);
		  putText:
		    (# t: ^Text;
		    enter t[]
			do t.T[1: t.lgth] -> value;
			   t.lgth -> lgth;
			#);
          dump::<
            (# <<SLOT LexemTextDump: doPart>> #);
       #);
     NameDecl: LexemText
       (# dump::<
            (# <<SLOT NameDeclDump: doPart>> #);
	   exit prodNo.nameDecl
       #);
     NameAppl: LexemText
       (# dump::<
            (# <<SLOT NameApplDump: doPart>> #);  
	   exit prodNo.nameAppl
       #);
     String: LexemText
       (# dump::<
            (# <<SLOT StringDump: doPart>> #); 
	   exit prodNo.string
       #);
     Comment: LexemText
       (# position: @int16;
          breaks: @int16;
          dump::<
            (# <<SLOT CommentDump: doPart>> #); 
	   exit prodNo.comment
       #);
     Const: LexemText
       (# dump::<
            (# <<SLOT ConstDump: doPart>> #);   
			
	   exit prodNo.const
       #);
     
     kinds: @
       (# interior: (#  exit 1 #);
          unExpanded: (#  exit 2 #);
          optional: (#  exit 3 #);
          nameAppl: (#  exit 4 #);
          nameDecl: (#  exit 5 #);
          string: (#  exit 6 #);
          const: (#  exit 7 #);
          comment: (#  exit 8 #);
          slotDesc: (#  exit 9 #);
          list: (#  exit 117 #);
          cons: (#  exit 118 #);
		  dummy: (# exit 119 #);
       #);
     
	 prodNo: @
	   (# unExpanded: (#  exit - 1 #);
		  optional: (#  exit - 2 #);
		  nameAppl: (#  exit - 3 #);
		  nameDecl: (#  exit - 4 #);
		  const: (#  exit - 5 #);
		  string: (#  exit - 6 #);
		  comment: (#  exit - 7 #);
		  slotDesc: (#  exit - 8 #)
	   #);
     formType: (#  exit 0 #);
     groupType: (#  exit 1 #);
     Fragment:
       (# name:
            (#
            enter nameT[]
            exit nameT[]
            #);
          fullname:
            (#
            enter fullnameT[]
            exit fullnameT[]
            #);
          father:
            (#
            enter fatherR[]
            exit fatherR[]
            #);
          type:
            (#
            exit fragType
            #);
	      category:
            (# sy: @integer;
			do '-- fragment.category' -> putline;
            exit sy
            #);
		  reset:< (# do INNER #);
		  bindToOrigin:
		    (# f: ^FragmentForm;
			   op: ^SlotDesc;
			enter f[]
			do '-- bindToOrigin' -> putline;
			exit op[]
			#);
          init:<
            (# do INNER #);
				
			 pack:<
			   (# output: ^Stream;
				enter output[]
				do INNER;
				#);
			 unPack:<
			 	(# input: ^Stream;
				enter input[]
				do INNER;
				#);
				
				
		  
          prop: ^PropertyList;
          nameT, fullnameT: ^text;
          fatherR: ^FragmentGroup;
          fragType: @integer;
       do INNER;
       #);
     newFragmentForm: (* returns a new instance of fragmentForm *)
       (# g: ^treeLevel; f: ^fragmentForm
       enter g[]
       do &fragmentForm[]->f[]; g[]->f.grammar[]; f.init;
       exit f[]
       #);
     FragmentForm: Fragment
       (# <<SLOT FragmentFormLib: attributes>>;
	      root: ^AST;
		  binding: ^slotDesc;
		  open:
		    (#
			exit THIS(FragmentForm)[]
			#);
          category:
            (# sy: @integer;
            <<SLOT FragmentFormCategory: doPart>>
            exit sy
            #);
		  fragNode:
		    (* This is a strange operation used by the compiler *)
		    (#
			exit (0, this(FragmentForm)[])
			#);
          grammar: ^treeLevel
       #);
     newFragmentGroup:
       (* returns a new instance of fragmentGroup *)
       (# g: ^fragmentGroup do &fragmentGroup[]->g[]; g.init;  exit g[] #);
     FragmentGroup: Fragment
       (# <<SLOT FragmentGroupLib: attributes>>;
	      origin:
            (#
            enter originR[]
            exit originR[]
            #);
          scan:
            (# current: ^Fragment;
            <<SLOT FragmentGroupScan: doPart>>
            #);
          setupOrigin:
            (# error: ^Stream;
            enter error[]
            <<SLOT FragmentGroupSetupOrigin: doPart>>
            #);
          scanIncludes:
            (# current: ^Include;
            <<SLOT FragmentGroupScanIncludes: doPart>>
            #);
		 
		  bind:
		    (# f: ^FragmentForm;
			   op: ^SlotDesc;
			enter f[]
			do '-- bind' -> putline;
			exit op[]
			#);
		  scanSlots:
	        (# current: ^slotDesc;
			do '-- scanSlots' -> putline;
			   (if false then
			      INNER;
			   if);
	        #);
		  markAsChanged: protect
		    (# #);
		  realOpen: protect
		    (# #);
	      modtime: integerValue (# #);
          Include:
            (# linkname: ^text;
               fullname:
                 (# theFullName: ^text;
                 <<SLOT FragmentGroupIncludeFullName: doPart>>
                 exit theFullName[]
                 #);
            #);
          loadIncludes:
            (# <<SLOT FragmentGroupLoadIncludes: doPart>> #);
		 save:
			(# filename: ^Text;
				failure:< Exception
					(# what: ^Text;
					enter what[]
					<<SLOT FragmentGroupSaveFailure: doPart>>
					#);
			enter filename[]
			<<SLOT FragmentGroupSave: doPart>>
			#);
		 load:
		   (# filename: ^Text;
				failure:< Exception
					(# what: ^Text;
					enter what[]
					<<SLOT FragmentGroupLoadFailure: doPart>>
					#);
			enter filename[]
			<<SLOT FragmentGroupLoad: doPart>>
			#);
		 pack::
		   (# <<SLOT FragmentGroupPack: doPart>> #);
		 unPack::
		   (# <<SLOT FragmentGroupUnpack: doPart>> #);
          includes: @ContainerList
            (# Element:: Include;
            #);
          fragmentList: @ContainerList
            (# element:: FragmentForm;
            #);
          originR: ^FragmentGroup;
          controller: @
            (# status: @integer;
            #);
		  isRealOpen: @boolean;
       #);
     
     thePathHandler: @PathHandler;
     stripPathName:
       (* Strips last filename from a path specification in order to
        * conform with the new pathHandler.
        *)
       (# PN,newPN: ^text; ix: @integer;
       enter PN[]
       do directoryChar->PN.findAll(#  do inx->ix #);
          (if ix=0 then
              none ->newPN[]
           else
              (* terminating directoryChar is not removed due to 'strange'
               * behavior in localPath
               *)
              (1,ix)->PN.sub->newPN[]
          if)
       exit newPN[]
       #);
     expandToFullPath:
       (# name: ^text;
       enter name[]
       exit (name[],currentDirectory)->thePathHandler.convertFilePath
       #);
     TOP: @
       (# open:
            (# name: ^Text;
               error: ^Stream;
               group: ^FragmentGroup;
            enter (name[], error[])
            <<SLOT AstInterfaceTopOpen: doPart>>
            exit group[]
            #);
          grouptable: @HashTable
            (# Element:: FragmentGroup;
					rangeInitial:: (# do 500 -> value #);
					H:  @HoneyMan;
					hashfunction::
						(# fullname: ^Text;
						do (e.fullname).copy -> fullname[];
							fullname.makeLC;
							fullname[] -> H.hash -> value;
						#);
					equal::
						(#
						do left.fullname -> (right.fullname).equalNCS;
						#);
					init::
						(#
						do H.init;
						#);
            #);
       #);
     grammarTable: @
       (# beta: ^treeLevel;
       #);
     TreeLevel:
       (# <<SLOT TreeLevelLib: attributes>>;
          grammarIdentification:< (* the grammar name *)
            (# theGrammarName: ^text
            do INNER;
            exit theGrammarName[]
            #);
          version:< IntegerValue;
          suffix:<
            (# theSuffix: ^Text;
            do &Text[] -> theSuffix[];
               INNER;
            exit theSuffix[]
            #);
          maxproductions:< IntegerValue;
          init:<
            (# tableFileName: ^Text;
            enter tableFileName[]
            <<SLOT TreeLevelInit: doPart>> 
            #);
          
          symbolToAst:
            (# symbol: @int16;
               theAst: ^AST;
            enter symbol
            <<SLOT TreeLevelSymbolToAst: doPart>>
            exit theAst[]
            #);
          symbolToName:
            (# symbol: @int16;
               name: ^text;
            enter symbol
            <<SLOT TreeLevelSymbolToName: doPart>>
            exit name[]
            #);
          kindOfSymbol:
		    (# symbol: @int16;
			   kind: @int8;
			enter symbol
			<<SLOT TreeLevelKindOfSymbol: doPart>>
			exit kind
			#);
          newUnExpanded:
            (# symbol: @int16;
               theAst: ^UnExpanded;
            enter symbol
            <<SLOT TreeLevelNewUnexpanded: doPart>>
            exit theAst[]
            #);
	      newAst:
		    (# frag: ^FragmentForm;
			   symbol: @int16;
			   new: ^AST;
			enter (symbol, frag[])
			<<SLOT TreeLevelNewAst: doPart>>
			exit new[]
			#);
			
          pretty:
            (# node: ^AST;
               output: ^Stream;
            enter (node[], output[])
            <<SLOT TreeLevelPretty: doPart>>
            #);
          
          parser: @
            (# <<SLOT parserLib: attributes>>;
               init:
                 (# tableFileName: ^text;
                 enter tableFileName[]
                 <<SLOT parserInit: doPart>> 
                 #);
               parse:
                 (# goal: @integer;
                    input: ^Stream;
                    root: ^AST;
                 enter (goal, input[])
                 <<SLOT parserParse: doPart>>
                 exit root[]
                 #);
               trace: @boolean;
               private: @<<SLOT parserPrivate: descriptor>>;
            #);
          kindArray: [0] @int8u;
          roomArray: [0] @int8u;
          sonArray: [0] @int8u;
          nodeClassArray: [0] @int8u;
          genRefArray: [0] ##AST;
       #);
	   
	   
	 astInterfaceException: Exception
	   (#
	   do INNER;
	   #);
	 protect:
       (* This operation is used to protect a MPS operation (or
        * sequence of MPS operations agains the dynamically generated
        * MPS exceptions.
        *)
       (# astOverflow:< astInterfaceException;
          startingParsing:< (#  do INNER #);
          fragmentNotExisting:< astInterfaceException
            (# do true->continue; INNER #);
          grammarNotFound:< astInterfaceException;
          badFormat:< astInterfaceException;
          parseErrors:< astInterfaceException;
          fatalParseError:< astInterfaceException
            (# errNo: @integer enter errNo do INNER #);
          doubleFormDeclaration:< astInterfaceException;
          readAccessError:< astInterfaceException;
          writeAccessError:< astInterfaceException;
          writeAccessOnLstFileError:< astInterfaceException;
          EOSError:< astInterfaceException;
          noSuchFileError:< astInterfaceException;
          fileExistsError:< astInterfaceException;
          noSpaceLeftError:< astInterfaceException;
          otherFileError:< astInterfaceException;
       do INNER;
       #);
	   
     Trace: @
	   (# fragmentOpen: (#  exit 1 #);
		  onParse: (#  exit 2 #);
		  topOpen: (#  exit 3 #);
		  fragmentClose: (#  exit 4 #);
		  topClose: (#  exit 4 #);
		  compactOpen: (#  exit 10 #);
		  grammars: (#  exit 20 #);
		  parsingComments: (#  exit 30 #);
		  getnextComment: (#  exit 31 #);
		  editingComments: (#  exit 32 #);
		  parser: (#  exit 50 #);
		  getBinding: (#  exit 90 #);
		  getBindingMark: (#  exit 91 #);
		  
		  set:
	        (# n: @integer;
			   on: @boolean;
			enter (n, on)
			do on -> switch[n];
			#);
		  call:
		    (# n: @integer;
			enter n
			do (if switch[n] then
			     INNER;
			   if);
			#);
		  switch: [100] @boolean;
	   #);
  do AstLevelInit;
     INNER;
  #);
