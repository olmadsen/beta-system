ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/basiclib/texthash';
INCLUDE 'propertylist';
INCLUDE '~beta/sysutils/pathhandler';

BODY 'private/treelevelbody';
BODY 'private/astbody';
BODY 'private/fragbody';



-- lib: attributes --

ContainerList: List
  (#
  #);

     
AstInterface:
  (# <<SLOT AstInterfaceLib: attributes>>;
     astLevelInit:<
       (#
       do thePathHandler.init;
		 	 TOP.grouptable.init;
          INNER;
       #);
	 
     AST:
       (# <<SLOT ASTLib: attributes>>;
          kind: @int8u;
          status: @int8u;
          symbol: @int16u;
          com: ^Comment;
          son: ^AST;
          brother: ^AST;
		  
		  father:
		    (* Returns the father of this(AST), or NONE if 
			 * this(AST) is root.
			 *)
		    (# theFather: ^AST;
			<<SLOT ASTFather: doPart>>
			exit theFather[]
			#);
		  
          dump:<
            (# level: @integer;
               output: ^stream;
			   gram: ^Treelevel;
            enter (level, output[], gram[])
            <<SLOT ASTDump: doPart>>
            #);
       #);
     
     Expanded: AST
       (# noOfsons:
            (# sons: @integer;
            <<SLOT ExpandedNoOfSons: doPart>>
            exit sons
            #);
          get:
            (# inx: @integer;
               as: ^AST;
            enter inx
            <<SLOT ExpandedGet: doPart>>
            exit as[]
            #);
          put:
            (# inx: @integer;
               as: ^AST;
            enter (inx, as[])
            <<SLOT ExpandedPut: doPart>>
            #);
          
          suffixWalk:
            (# current: ^AST;
               cutIf:<
                 (# prod: @integer;toCut: @boolean
                 enter prod
                 do false->toCut; INNER
                 exit toCut
                 #);
            <<SLOT ExpandedSuffixWalk: doPart>>
            #);
          suffixWalkForProd:
            (# scanCat:< AST;
               current: ^scanCat;
               cutIf:<
                 (# prod: @integer;toCut: @boolean
                 enter prod
                 do false->toCut; INNER
                 exit toCut
                 #);
               prod: @integer;
            enter prod
            <<SLOT ExpandedsuffixWalkForProd: doPart>>
            #);
          getSon1: (# exit son[] #);
          getSon2: (# exit 2 -> get #);
          getSon3: (# exit 3 -> get #);
          getSon4: (# exit 4 -> get #);
          getSon5: (# exit 5 -> get #);
          getSon6: (# exit 6 -> get #);
          getSon7: (# exit 7 -> get #);
          getSon8: (# exit 8 -> get #);
          getSon9: (# exit 9 -> get #);
          putson1: (# a: ^ast enter a[] do (1,a[])->put #);
          putson2: (# a: ^ast enter a[] do (2,a[])->put #);
          putson3: (# a: ^ast enter a[] do (3,a[])->put #);
          putson4: (# a: ^ast enter a[] do (4,a[])->put #);
          putson5: (# a: ^ast enter a[] do (5,a[])->put #);
          putson6: (# a: ^ast enter a[] do (6,a[])->put #);
          putson7: (# a: ^ast enter a[] do (7,a[])->put #);
          putson8: (# a: ^ast enter a[] do (8,a[])->put #);
          putson9: (# a: ^ast enter a[] do (9,a[])->put #);
          dump::<
            (# <<SLOT ExpandedDump: doPart>> #);
       #);
     Cons: Expanded
       (# dump::<
            (# <<SLOT ConsDump: doPart>> #);
       #);
     List: Expanded
       (# SonCat:< AST;
          dump::<
            (# <<SLOT ListDump: doPart>> #);
       #);
     
     UnExpanded: AST
       (# (* value: ^text; *)
          dump::<
            (# <<SLOT UnExpandedDump: doPart>> #);
       #);
     Optional: UnExpanded
       (# dump::<
            (# <<SLOT OptionalDump: doPart>> #);
       #);
     SlotDesc: AST
       (# dump::<
            (# <<SLOT SlotDescDump: doPart>> #);
       #);
     
     
     Lexem: AST
       (# dump::<
            (# <<SLOT LexemDump: doPart>> #);
       #);
     LexemText: Lexem
       (# value: [0] @char;
          lgth: @integer;
          getText:
            (# t: ^Text;
            do &Text[] -> t[];
               value -> t;
            exit t[]
            #);
          dump::<
            (# <<SLOT LexemTextDump: doPart>> #);
       #);
     NameDecl: LexemText
       (# dump::<
            (# <<SLOT NameDeclDump: doPart>> #);
       #);
     NameAppl: LexemText
       (# dump::<
            (# <<SLOT NameApplDump: doPart>> #);                
       #);
     String: LexemText
       (# dump::<
            (# <<SLOT StringDump: doPart>> #);  
       #);
     Comment: LexemText
       (# position: @int16;
          breaks: @int16;
          dump::<
            (# <<SLOT CommentDump: doPart>> #); 
       #);
     Const: LexemText
       (# dump::<
            (# <<SLOT ConstDump: doPart>> #);   
       #);
     
     kinds: @
       (# interior: (#  exit 1 #);
          unExpanded: (#  exit 2 #);
          optional: (#  exit 3 #);
          nameAppl: (#  exit 4 #);
          nameDecl: (#  exit 5 #);
          string: (#  exit 6 #);
          const: (#  exit 7 #);
          comment: (#  exit 8 #);
          slotDesc: (#  exit 9 #);
          list: (#  exit 117 #);
          cons: (#  exit 118 #);
       #);
     
     formType: (#  exit 0 #);
     groupType: (#  exit 1 #);
     Fragment:
       (# name:
            (#
            enter nameT[]
            exit nameT[]
            #);
          fullname:
            (#
            enter fullnameT[]
            exit fullnameT[]
            #);
          father:
            (#
            enter fatherR[]
            exit fatherR[]
            #);
          type:
            (#
            exit fragType
            #);
          init:<
            (# do INNER #);
				
			 pack:<
			   (# output: ^Stream;
				enter output[]
				do INNER;
				#);
			 unPack:<
			 	(# input: ^Stream;
				enter input[]
				do INNER;
				#);
          prop: ^PropertyList;
          nameT, fullnameT: ^text;
          fatherR: ^FragmentGroup;
          fragType: @integer;
       do INNER;
       #);
     newFragmentForm: (* returns a new instance of fragmentForm *)
       (# g: ^treeLevel; f: ^fragmentForm
       enter g[]
       do &fragmentForm[]->f[]; g[]->f.grammar[]; f.init;
       exit f[]
       #);
     FragmentForm: Fragment
       (# root: ^AST;
          category:
            (# sy: @integer;
            <<SLOT FragmentFormCategory: doPart>>
            exit sy
            #);
          grammar: ^treeLevel
       #);
     newFragmentGroup:
       (* returns a new instance of fragmentGroup *)
       (# g: ^fragmentGroup do &fragmentGroup[]->g[]; g.init;  exit g[] #);
     FragmentGroup: Fragment
       (# origin:
            (#
            enter originR[]
            exit originR[]
            #);
          scan:
            (# current: ^Fragment;
            <<SLOT FragmentGroupScan: doPart>>
            #);
          setupOrigin:
            (# error: ^Stream;
            enter error[]
            <<SLOT FragmentGroupSetupOrigin: doPart>>
            #);
          scanIncludes:
            (# current: ^Include;
            <<SLOT FragmentGroupScanIncludes: doPart>>
            #);
          Include:
            (# linkname: ^text;
               fullname:
                 (# theFullName: ^text;
                 <<SLOT FragmentGroupIncludeFullName: doPart>>
                 exit theFullName[]
                 #);
            #);
          loadIncludes:
            (# <<SLOT FragmentGroupLoadIncludes: doPart>> #);
			 save:
			 	(# filename: ^Text;
					failure:< Exception
						(# what: ^Text;
						enter what[]
						<<SLOT FragmentGroupSaveFailure: doPart>>
						#);
				enter filename[]
				<<SLOT FragmentGroupSave: doPart>>
				#);
			 load:
			   (# filename: ^Text;
					failure:< Exception
						(# what: ^Text;
						enter what[]
						<<SLOT FragmentGroupLoadFailure: doPart>>
						#);
				enter filename[]
				<<SLOT FragmentGroupLoad: doPart>>
				#);
			 pack::
			   (# <<SLOT FragmentGroupPack: doPart>> #);
			 unPack::
			   (# <<SLOT FragmentGroupUnpack: doPart>> #);
          includes: @ContainerList
            (# Element:: Include;
            #);
          fragmentList: @ContainerList
            (# element:: Fragment;
            #);
          originR: ^FragmentGroup;
          controller: @
            (# status: @integer;
            #);
       #);
     
     thePathHandler: @PathHandler;
     stripPathName:
       (* Strips last filename from a path specification in order to
        * conform with the new pathHandler.
        *)
       (# PN,newPN: ^text; ix: @integer;
       enter PN[]
       do directoryChar->PN.findAll(#  do inx->ix #);
          (if ix=0 then
              none ->newPN[]
           else
              (* terminating directoryChar is not removed due to 'strange'
               * behavior in localPath
               *)
              (1,ix)->PN.sub->newPN[]
          if)
       exit newPN[]
       #);
     expandToFullPath:
       (# name: ^text;
       enter name[]
       exit (name[],currentDirectory)->thePathHandler.convertFilePath
       #);
     TOP: @
       (# open:
            (# name: ^Text;
               error: ^Stream;
               group: ^FragmentGroup;
            enter (name[], error[])
            <<SLOT AstInterfaceTopOpen: doPart>>
            exit group[]
            #);
          grouptable: @HashTable
            (# Element:: FragmentGroup;
					rangeInitial:: (# do 500 -> value #);
					H:  @HoneyMan;
					hashfunction::
						(# fullname: ^Text;
						do (e.fullname).copy -> fullname[];
							fullname.makeLC;
							fullname[] -> H.hash -> value;
						#);
					equal::
						(#
						do left.fullname -> (right.fullname).equalNCS;
						#);
					init::
						(#
						do H.init;
						#);
            #);
       #);
     grammarTable: @
       (# beta: ^treeLevel;
       #);
     TreeLevel:
       (# <<SLOT TreeLevelLib: attributes>>;
          grammarIdentification:< (* the grammar name *)
            (# theGrammarName: ^text
            do INNER;
            exit theGrammarName[]
            #);
          version:< IntegerValue;
          suffix:<
            (# theSuffix: ^Text;
            do &Text[] -> theSuffix[];
               INNER;
            exit theSuffix[]
            #);
          maxproductions:< IntegerValue;
          init:<
            (# tableFileName: ^Text;
            enter tableFileName[]
            <<SLOT TreeLevelInit: doPart>> 
            #);
          
          symbolToAst:
            (# symbol: @int16;
               theAst: ^AST;
            enter symbol
            <<SLOT TreeLevelSymbolToAst: doPart>>
            exit theAst[]
            #);
          symbolToName:
            (# symbol: @int16;
               name: ^text;
            enter symbol
            <<SLOT TreeLevelSymbolToName: doPart>>
            exit name[]
            #);
          
          newUnExpanded:
            (# symbol: @int16;
               theAst: ^UnExpanded;
            enter symbol
            <<SLOT TreeLevelNewUnexpanded: doPart>>
            exit theAst[]
            #);
          pretty:
            (# node: ^AST;
               output: ^Stream;
            enter (node[], output[])
            <<SLOT TreeLevelPretty: doPart>>
            #);
          
          parser: @
            (# <<SLOT parserLib: attributes>>;
               init:
                 (# tableFileName: ^text;
                 enter tableFileName[]
                 <<SLOT parserInit: doPart>> 
                 #);
               parse:
                 (# goal: @integer;
                    input: ^Stream;
                    root: ^AST;
                 enter (goal, input[])
                 <<SLOT parserParse: doPart>>
                 exit root[]
                 #);
               trace: @boolean;
               private: @<<SLOT parserPrivate: descriptor>>;
            #);
          kindArray: [0] @int8u;
          roomArray: [0] @int8u;
          sonArray: [0] @int8u;
          nodeClassArray: [0] @int8u;
          genRefArray: [0] ##AST;
       #);
  #);
