ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/basiclib/texthash';
INCLUDE 'propertylist';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '~beta/basiclib/file';


BODY 'private/treelevelbody';
BODY 'private/astbody';
BODY 'private/fragbody';



-- lib: attributes --

ContainerList: List
  (#
  #);


AstInterface:
  (# <<SLOT AstInterfaceLib: attributes>>;
     theCatcher: ^Object;
     offendingFormName: ^Text;
     doRealOpen: @boolean;
     Visitor:
       (* super pattern for Visitor design pattern  *)
       (# do inner #);
     
     astLevelInit:<
       (#
       do thePathHandler.init;
          TOP.grouptable.init;
          true -> doRealOpen;
          INNER;
       #);
     
     AST:
       (# <<SLOT ASTLib: attributes>>;
          astkind: @int8u;
          status: @int8u;
          symbol: @int16;
          inx: @integer;
          frag: ^FragmentForm;
          (*** com: ^Comment; ***)
          son: ^AST;
          brother: ^AST;
          AstVisitor:< Visitor;
          NodeClass: (# exit frag.grammar.nodeClassArray[symbol]  #);
          
          nextBrother:
            (# next: ^AST;
            <<SLOT ASTNextBrother: doPart>>
            exit next[]
            #);
          father:
            (* Returns the father of this(AST), or NONE if 
             * this(AST) is root.
             *)
            (# theFather: ^AST;
            <<SLOT ASTFather: doPart>>
            exit theFather[]
            #);
          equal:
            (# other: ^AST;
            enter other[]
            exit (other[] = THIS(AST)[])
            #);
          isSlot: booleanValue
            (# <<SLOT ASTIsSlot: doPart>> #);
          theSlot:
            (# slot: ^SlotDesc;
            <<SLOT ASTtheSlot: doPart>>
            exit slot[]
            #);
          index:
            (#
            exit -1
            #);
          b: @boolean;
          hasSemanticError:
            (#  
            enter b
            exit b
            #);
          error: @integer;
          semanticError:
            (#  
            enter (# enter  error do (if error > 0 then true -> hasSemanticError; else false -> hasSemanticError if); #)
            exit error
            #);
          pack:<
            (# output: ^Stream;
               putValue:
                 (# value: @integer;
                 enter value
                 <<SLOT ASTPackPutValue: doPart>>
                 #);
               putAstRef:
                 (# ref: ^AST;
                 enter ref[]
                 <<SLOT AstPackPutAstRef: doPart>>
                 #);
            enter output[]
            <<SLOT AstPack: doPart>>
            #);
          unPack:<
            (# input: ^Stream;
               inx: @integer;
               getValue:
                 (# value: @integer;
                 <<SLOT AstUnPackGetValue: doPart>>
                 exit value
                 #);
               getAstRef:
                 (# ref: ^AST;
                    inx: @integer;
                 <<SLOT AstUnPackGetAstRef: doPart>>
                 exit ref[]
                 #);
            enter input[]
            <<SLOT AstUnPack: doPart>>
            #);
          dump:<
            (# level: @integer;
               output: ^stream;
               gram: ^Treelevel;
            enter (level, output[], gram[])
            <<SLOT ASTDump: doPart>>
            #);
          accept:<
            (* acceptor for Visitor design pattern *)
            (# V: ^AstVisitor
            enter V[]
            do INNER
            #);
       #);
     
     UnExpanded: AST
       (# <<SLOT UnExpandedLib: attributes>>;
          dump::<
            (#
            <<SLOT UnExpandedDump: doPart>>
            #);
       #);
     
     Expanded: UnExpanded
       (# noOfsons:
            (# sons: @integer;
            <<SLOT ExpandedNoOfSons: doPart>>
            exit sons
            #);
          get:
            (# inx: @integer;
               as: ^AST;
            enter inx
            <<SLOT ExpandedGet: doPart>>
            exit as[]
            #);
          put:
            (# inx: @integer;
               as: ^AST;
            enter (inx, as[])
            <<SLOT ExpandedPut: doPart>>
            #);
          scan:
            (# current: ^AST;
               currentSonNo: @integer;
            <<SLOT ExpandedScan: doPart>>
            #);
          suffixWalk:
            (# current: ^AST;
               cutIf:<
                 (# prod: @integer;toCut: @boolean
                 enter prod
                 do false->toCut; INNER
                 exit toCut
                 #);
            <<SLOT ExpandedSuffixWalk: doPart>>
            #);
          suffixWalkForProd:
            (# scanCat:< AST;
               current: ^scanCat;
               cutIf:<
                 (# prod: @integer;toCut: @boolean
                 enter prod
                 do false->toCut; INNER
                 exit toCut
                 #);
               prod: @integer;
            enter prod
            <<SLOT ExpandedsuffixWalkForProd: doPart>>
            #);
          getSon1: (# exit son[] #);
          getSon2: (# exit 2 -> get #);
          getSon3: (# exit 3 -> get #);
          getSon4: (# exit 4 -> get #);
          getSon5: (# exit 5 -> get #);
          getSon6: (# exit 6 -> get #);
          getSon7: (# exit 7 -> get #);
          getSon8: (# exit 8 -> get #);
          getSon9: (# exit 9 -> get #);
          putson1: (# a: ^ast enter a[] do (1,a[])->put #);
          putson2: (# a: ^ast enter a[] do (2,a[])->put #);
          putson3: (# a: ^ast enter a[] do (3,a[])->put #);
          putson4: (# a: ^ast enter a[] do (4,a[])->put #);
          putson5: (# a: ^ast enter a[] do (5,a[])->put #);
          putson6: (# a: ^ast enter a[] do (6,a[])->put #);
          putson7: (# a: ^ast enter a[] do (7,a[])->put #);
          putson8: (# a: ^ast enter a[] do (8,a[])->put #);
          putson9: (# a: ^ast enter a[] do (9,a[])->put #);
          dump::<
            (# <<SLOT ExpandedDump: doPart>> #);
       #);
     Cons: Expanded
       (# dump::<
            (# <<SLOT ConsDump: doPart>> #);
       #);
     List: Expanded
       (# SonCat:< AST;
          
          newScan:
            (# predefined:< (# current: ^Ast enter current[] do INNER #);
               a: ^ast;
	       current: ^sonCat;
	       currentSonNo: @integer;
            do 'new-scan is not implemented' -> putline;
               INNER;
            #);
          dump::<
            (# <<SLOT ListDump: doPart>> #);
       #);
     
     Optional: AST
       (# dump::<
            (# <<SLOT OptionalDump: doPart>> #);
       #);
     SlotDesc: AST
       (# <<SLOT SlotDescLib: attributes>>;
          value: [0] @char;
          lgth: @integer;
          nextSlot: ^SlotDesc;
          origin: ^AST;
          nextLib: ^AST;
          name:
            (# set:
                 (# t: ^Text;
                 enter t[]
                 do t -> value;
                    value.range -> lgth;
                 #);
               get:
                 (# t: ^Text;
                 do &Text[] -> t[];
                    value[1: lgth] -> t;
                 exit t[]
                 #);
            enter set
            exit get
            #);
          category: @integer;
          isBound: @boolean;
          
          pack::
            (#
            <<SLOT SlotDescPack: doPart>>
            #);
          unPack::
            (#
            <<SLOT SlotDescUnPack: doPart>>
            #);
          dump::<
            (# <<SLOT SlotDescDump: doPart>> #);
       exit prodNo.slotDesc
       #);

     Lexem: AST
       (# dump::<
            (# <<SLOT LexemDump: doPart>> #);
       #);
     LexemText: Lexem
       (# value: [0] @char;
          lgth: @integer;
          getText:
            (# t: ^Text;
            do &Text[] -> t[];
               value -> t;
            exit t[]
            #);
          putText:
            (# t: ^Text;
            enter t[]
            do t.T[1: t.lgth] -> value;
               t.lgth -> lgth;
            #);
          pack::<
            (# <<SLOT LexemTextPack: doPart>> #);
          unpack::<
            (# <<SLOT LexemTextUnPack: doPart>> #);
          dump::<
            (# <<SLOT LexemTextDump: doPart>> #);
       #);
     NameDecl: LexemText
       (# dump::<
            (# <<SLOT NameDeclDump: doPart>> #);
       exit prodNo.nameDecl
       #);
     NameAppl: LexemText
       (# dump::<
            (# <<SLOT NameApplDump: doPart>> #);  
       exit prodNo.nameAppl
       #);
     String: LexemText
       (# dump::<
            (# <<SLOT StringDump: doPart>> #); 
       exit prodNo.string
       #);
     Comment: LexemText
       (# position: @int16;
          breaks: @int16;
          dump::<
            (# <<SLOT CommentDump: doPart>> #); 
       exit prodNo.comment
       #);
     Const: LexemText
       (# dump::<
            (# <<SLOT ConstDump: doPart>> #);
          getValue:
            (# val: @integer;
            do 'const.getvalue is not implemented' -> putline;
            exit val
            #);
       exit prodNo.const
       #);
     
     kinds: @
       (# interior: (#  exit 1 #);
          unExpanded: (#  exit 2 #);
          optional: (#  exit 3 #);
          nameAppl: (#  exit 4 #);
          nameDecl: (#  exit 5 #);
          string: (#  exit 6 #);
          const: (#  exit 7 #);
          comment: (#  exit 8 #);
          slotDesc: (#  exit 9 #);
          list: (#  exit 117 #);
          cons: (#  exit 118 #);
          dummy: (# exit 119 #);
       #);
     
     prodNo: @
       (# unExpanded: (#  exit - 1 #);
          optional: (#  exit - 2 #);
          nameAppl: (#  exit - 3 #);
          nameDecl: (#  exit - 4 #);
          const: (#  exit - 5 #);
          string: (#  exit - 6 #);
          comment: (#  exit - 7 #);
          slotDesc: (#  exit - 8 #)
       #);
     formType: (#  exit 0 #);
     groupType: (#  exit 1 #);
     Fragment:
       (# name:
            (#
            enter nameT[]
            exit nameT.copy
            #);
          fullname:
            (#
            enter fullnameT[]
            exit fullnameT.copy
            #);
          father:
            (#
            enter fatherR[]
            exit fatherR[]
            #);
          type:
            (# exit fragType #);
          category:
            (# sy: @integer;
            do '-- fragment.category' -> putline;
            exit sy
            #);
          reset:< (# do INNER #);
          bindToOrigin:
            (# f: ^FragmentForm;
               op: ^SlotDesc;
            enter f[]
            do (*** unused ***)
            exit op[]
            #);
          init:<
            (# do INNER #);
          
          pack:<
            (# output: ^Stream;
            enter output[]
            do INNER;
            #);
          unPack:<
            (# input: ^File;
            enter input[]
            do INNER;
            #);
          close:< (# do INNER #); 
          
          checkDiskRepresentation: (# do INNER #);
          prop: ^PropertyList;
          nameT, fullnameT: ^text;
          fatherR: ^FragmentGroup;
          originR: ^FragmentGroup;
          fragType: @integer;
       do INNER;
       #);
     newFragmentForm: (* returns a new instance of fragmentForm *)
       (# g: ^treeLevel; f: ^fragmentForm
       enter g[]
       do &fragmentForm[]->f[]; g[]->f.grammar[]; f.init;
       exit f[]
       #);
     FragmentForm: Fragment
       (# <<SLOT FragmentFormLib: attributes>>;
          root: ^AST;
          binding: ^slotDesc;
          firstSlot: ^SlotDesc;
          open:
            (#
            exit THIS(FragmentForm)[]
            #);
          form:
            (#
            exit THIS(FragmentForm)[]
            #);
          formname: (# exit name #);
          category:
            (# sy: @integer;
            <<SLOT FragmentFormCategory: doPart>>
            exit sy
            #);
          scanSlots:
            (# current: ^SlotDesc;
            <<SLOT FragmentFormScanSlots: doPart>>
            #);
          fragNode:
            (* This is a strange operation used by the compiler *)
            (#
            exit (0, this(FragmentForm)[])
            #);
          pack::
            (#
            <<SLOT FragmentFormPack: doPart>>
            #);
          unPack::
            (#
            <<SLOT FragmentFormUnpack: doPart>>
            #);
          init::< (# do FormType -> fragtype; INNER #);
          
          register:
            (# frag: ^FragmentForm;
               index: @integer;
            enter frag[]
            <<SLOT FragmentFormRegister: doPart>>
            exit index
            #);
          lookup:
            (# frag: ^FragmentForm;
               index: @integer;
            enter index
            <<SLOT FragmentFormLookup: doPart>>
               
            exit frag[]
            #);


          bindSemanticInfo:
	    (#
	    <<SLOT FragmentFormBindSemanticInfo: doPart>>
	    #);

          import: [1] ^FragmentForm;
          importtop: @integer;
	  
	  info: ^Text;
	  header: ^Text;
          table: [0] ^Ast;
          grammar: ^treeLevel;
          cat: @integer;
       #);
     newFragmentGroup:
       (* returns a new instance of fragmentGroup *)
       (# g: ^fragmentGroup do &fragmentGroup[]->g[]; g.init;  exit g[] #);
     FragmentGroup: Fragment
       (# <<SLOT FragmentGroupLib: attributes>>;
          origin:
            (#
            enter originR[]
            exit originR[]
            #);
          scan:
            (# current: ^Fragment;
            <<SLOT FragmentGroupScan: doPart>>
            #);
          setupOrigin:
            (# error: ^Stream;
            enter error[]
            <<SLOT FragmentGroupSetupOrigin: doPart>>
            #);
          scanIncludes:
            (# current: ^Include;
            <<SLOT FragmentGroupScanIncludes: doPart>>
            #);
          bind:
            (# f: ^FragmentForm;
               op: ^SlotDesc;
            enter f[]
            <<SLOT FragmentGroupBind: doPart>>
            exit op[]
            #);
          scanSlots:
            (# current: ^slotDesc;
            <<SLOT FragmentGroupScanSlots: doPart>>
            #);
          markAsChanged: protect
            (# do save #);
          realOpen: protect
            (# <<SLOT FragmentGroupRealOpen: doPart>>  #);
          modtime: @integer;
          Include:
            (# linkname: ^text;
               fullname:
                 (# theFullName: ^text;
                 <<SLOT FragmentGroupIncludeFullName: doPart>>
                 exit theFullName[]
                 #);
            #);
          loadIncludes:
            (# <<SLOT FragmentGroupLoadIncludes: doPart>> #);
          save:
            (# failure:< Exception
                 (# what: ^Text;
                 enter what[]
                 <<SLOT FragmentGroupSaveFailure: doPart>>
                 #);
            <<SLOT FragmentGroupSave: doPart>>
            #);
          load:
            (# failure:< Exception
                 (# what: ^Text;
                 enter what[]
                 <<SLOT FragmentGroupLoadFailure: doPart>>
                 #);
               name: ^Text;
            enter name[]
            <<SLOT FragmentGroupLoad: doPart>>
            #);
          textFileName:
            (# path: ^Text;
            do (fullname).copy -> path[];
               '.bet' -> path.puttext;
            exit path[]
            #);
          diskFileName:
            (# path: ^Text;
            do (fullname).copy -> path[];
               '.ast' -> path.puttext;
            exit path[]
            #);
          init::<
            (# do GroupType -> fragType; &PropertyList[] -> prop[]; INNER #);
          close::
            (#
            <<SLOT FragmentGroupClose: doPart>>
            #);
          pack::
            (# <<SLOT FragmentGroupPack: doPart>> #);
          unPack::
            (# <<SLOT FragmentGroupUnpack: doPart>> #);
          unPackSemanticInfo:
            (# <<SLOT FragmentGroupUnPackSemanticInfo: doPart>> #);
          includes: @ContainerList
            (# Element:: Include;
            #);
          fragmentList: @ContainerList
            (# element:: FragmentForm;
               addFragment:
                 (# frag: ^FragmentForm;
                 enter frag[]
                 do frag[] -> append;
                    THIS(FragmentGroup)[] -> frag.father;
                 #);
            #);
          controller: @
            (# status: @integer;
               ancestorTime: @integer;
               ancestorsChecked: @boolean;
               doneCheck: @boolean;
               groupT: @Integer;
               printName: ^Text;
            #);
          isRealOpen: @boolean;
          mark: @integer;
       #);
     
     thePathHandler: @PathHandler;
     stripPathName:
       (* Strips last filename from a path specification in order to
        * conform with the new pathHandler.
        *)
       (# PN,newPN: ^text; ix: @integer;
       enter PN[]
       do directoryChar->PN.findAll(#  do inx->ix #);
          (if ix=0 then
              none ->newPN[]
           else
              (* terminating directoryChar is not removed due to 'strange'
               * behavior in localPath
               *)
              (1,ix)->PN.sub->newPN[]
          if)
       exit newPN[]
       #);
     astFileExtension: (# exit '.ast' #);
     expandToFullPath:
       (# name: ^text;
       enter name[]
       exit (name[],thePathHandler.currentDirectory)->thePathHandler.convertFilePath
       #);
     TOP: @
       (# open: protect
            (# name: ^Text;
               error: ^Stream;
               group: ^FragmentGroup;
            enter (name[], error[])
            <<SLOT AstInterfaceTopOpen: doPart>>
            exit group[]
            #);
          grouptable: @HashTable
            (# Element:: FragmentGroup;
               rangeInitial:: (# do 500 -> value #);
               H:  @HoneyMan;
               hashfunction::
                 (# fullname: ^Text;
                 do (e.fullname).copy -> fullname[];
                    fullname.makeLC;
                    fullname[] -> H.hash -> value;
                 #);
               equal::
                 (#
                 do left.fullname -> (right.fullname).equalNCS -> value;
                 #);
               init::
                 (#
                 do H.init;
                 #);
            #);
       #);
     grammarTable: @
       (# default: ^TreeLevel;
          beta: ^TreeLevel;
          meta: ^TreeLevel;
          register:
            (# grammar: ^TreeLevel;
            enter grammar[]
            <<SLOT AstInterfaceGrammarTableRegister: doPart>>
            #);
          lookup:
            (# name: ^Text;
               grammar: ^TreeLevel;
            enter name[]
            <<SLOT AstInterfaceGrammarTableLookup: doPart>>
            exit grammar[]
            #);
          grammars: @ContainerList
            (# element:: TreeLevel;
            #);
       #);
     TreeLevel:
       (# <<SLOT TreeLevelLib: attributes>>;
          treeLevelVisitor:< Visitor;
          grammarIdentification:< (* the grammar name *)
            (# theGrammarName: ^text
            do &Text[] -> theGrammarName[];
               INNER;
            exit theGrammarName[]
            #);
          version:< IntegerValue;
          suffix:<
            (# theSuffix: ^Text;
            do &Text[] -> theSuffix[];
               INNER;
            exit theSuffix[]
            #);
          maxproductions:< IntegerValue;
          init:<
            (# tableFileName: ^Text;
            enter tableFileName[]
            <<SLOT TreeLevelInit: doPart>> 
            #);
          
          symbolToAst:
            (# symbol: @int16;
               theAst: ^AST;
            enter symbol
            <<SLOT TreeLevelSymbolToAst: doPart>>
            exit theAst[]
            #);
          symbolToName:
            (# symbol: @int16;
               name: ^text;
            enter symbol
            <<SLOT TreeLevelSymbolToName: doPart>>
            exit name[]
            #);
          nameToSymbol:
            (# name: ^Text;
               symbol: @int16;
            enter name[]
            <<SLOT TreeLevelNameToSymbol: doPart>>
            exit symbol
            #);
          kindOfSymbol:
            (# symbol: @int16;
               kind: @int8;
            enter symbol
            <<SLOT TreeLevelKindOfSymbol: doPart>>
            exit kind
            #);
          newUnExpanded:
            (# symbol: @int16;
               theAst: ^UnExpanded;
            enter symbol
            <<SLOT TreeLevelNewUnexpanded: doPart>>
            exit theAst[]
            #);
          newAst:
            (# frag: ^FragmentForm;
               symbol: @int16;
               new: ^AST;
            enter (symbol, frag[])
            <<SLOT TreeLevelNewAst: doPart>>
            exit new[]
            #);
          
          pretty:
            (# node: ^AST;
               output: ^Stream;
            enter (node[], output[])
            <<SLOT TreeLevelPretty: doPart>>
            #);
          
          parser: @
            (# <<SLOT parserLib: attributes>>;
               init:
                 (# tableFileName: ^text;
                 enter tableFileName[]
                 <<SLOT parserInit: doPart>> 
                 #);
               parse:
                 (# goal: @integer;
                    input: ^Stream;
                    root: ^AST;
                    frag: ^FragmentForm;
                 enter (goal, input[], frag[])
                 <<SLOT parserParse: doPart>>
                 exit root[]
                 #);
               trace: @boolean;
               lastCH: @char;
               private: @<<SLOT parserPrivate: descriptor>>;
            #);
          kindArray: [0] @int8u;
          roomArray: [0] @int8u;
          sonArray: [0] @int8u;
          nodeClassArray: [0] @int8u;
          genRefArray: [0] ##AST;
       #);
     
     
     astInterfaceException: Exception
       (#
       do INNER;
       #);
     protect:
       (* This operation is used to protect a MPS operation (or
        * sequence of MPS operations agains the dynamically generated
        * MPS exceptions.
        *)
       (# astOverflow:< astInterfaceException;
          startingParsing:< (#  do INNER #);
          fragmentNotExisting:< astInterfaceException
            (# do true->continue; INNER #);
          grammarNotFound:< astInterfaceException;
          badFormat:< astInterfaceException;
          parseErrors:< astInterfaceException;
          fatalParseError:< astInterfaceException
            (# errNo: @integer enter errNo do INNER #);
          doubleFormDeclaration:< astInterfaceException;
          readAccessError:< astInterfaceException;
          writeAccessError:< astInterfaceException;
          writeAccessOnLstFileError:< astInterfaceException;
          EOSError:< astInterfaceException;
          noSuchFileError:< astInterfaceException;
          fileExistsError:< astInterfaceException;
          noSpaceLeftError:< astInterfaceException;
          otherFileError:< astInterfaceException;
       do INNER;
       #);
     
     Trace: @
       (# fragmentOpen: (#  exit 1 #);
          onParse: (#  exit 2 #);
          topOpen: (#  exit 3 #);
          fragmentClose: (#  exit 4 #);
          topClose: (#  exit 4 #);
          compactOpen: (#  exit 10 #);
          grammars: (#  exit 20 #);
          parsingComments: (#  exit 30 #);
          getnextComment: (#  exit 31 #);
          editingComments: (#  exit 32 #);
          parser: (#  exit 50 #);
          getBinding: (#  exit 90 #);
          getBindingMark: (#  exit 91 #);
          
          set:
            (# n: @integer;
               on: @boolean;
            enter (n, on)
            do on -> switch[n];
            #);
          call:
            (# n: @integer;
            enter n
            do (if switch[n] then
                   INNER;
               if);
            #);
          switch: [100] @boolean;
       #);
     
     GrammarFinder:
       (#
       #);
     defaultGrammarFinder:< GrammarFinder;
     FindGrammar: GrammarFinder
       (#
       #);
     private: @<<SLOT AstInterfacePrivate: descriptor>>;
     
  do AstLevelInit;
     INNER;
  #);
