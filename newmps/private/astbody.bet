ORIGIN '../astlevel';

-- astLib: attributes --

setLastBrother:
	(# value: @boolean;
	enter value
	do (if value then
		  status %bor lastBrotherMask -> status;
	   else
		  status %band (%bnot lastBrotherMask) -> status;
	   if);
	#);
getLastBrother:
	(# value: @boolean;
	do (status %band lastBrotherMask) = lastBrotherMask -> value;
	exit value
	#);

lastBrotherMask: (# exit 1 #);


scan:
  (# current: ^AST;
  do son[] -> current[];
     loop:
       (if (current[] <> NONE) then  
		   INNER;
		   (if current.status <> 1 then
			   current.brother[] -> current[];
			   restart loop;
		   if);
       if);
  #);
scanComments:
  (# current: ^Comment;
  do com[] -> current[];
     loop1:
       (if current[] <> NONE then
           INNER;
           current.brother[] -> current[];
           restart loop1;
       if);
  #);

printComments:
  (# output: ^Stream;
     position: @integer;
  enter output[]
  do scanComments
     (#
     do ' ' -> output.put;
        (if current.position <> position then
            current.position -> position;
            position -> output.putInt;
            ' ' -> output.put;
        if);
        '(*' -> output.puttext;
          current.getText -> output.puttext;
          '*)' -> output.puttext;
     #);
  #);
  
-- ASTFather: doPart --
do THIS(AST)[] -> theFather[];
   loop:
   (if theFather[] <> NONE then
      (if theFather.status = 1 then
	     theFather.brother[] -> theFather[];
	  else
	     theFather.brother[] -> theFather[];
		 restart loop;
      if);
   if);

-- ASTDump: doPart --
do INNER;

-- ExpandedNoOfSons: doPart --
do 

-- ExpandedGet: doPart --
do son[] -> as[];
   (for inx - 1 repeat
        as.brother[] -> as[];
   for);

-- ExpandedPut: doPart --
do 

-- ExpandedSuffixWalk: doPart --
do (# cutter: @cutIf;
      top: @integer;
      stack: [16] ^AST;
   do THIS(Expanded)[] -> current[];
      stackLoop:
        (if TRUE then
            sonLoop:
              (if current[] <> NONE then
                  (if NOT (current.symbol -> cutter) then 
                      INNER suffixWalk;
					  (if current.status <> 1 then
						  (if current.brother[] <> NONE then
							  top + 1 -> top;
							  (if top > stack.range then
								  top -> stack.extend;
							  if);
							  current.brother[] -> stack[top][];
						  if);
					  if);
                      current.son[] -> current[];
                      restart sonLoop;
                  if);
              if);
            (if top <> 0 then
                stack[top][] -> current[];
                top - 1 -> top;
                restart stackLoop;
            if);
        if);

   #)
   
-- ExpandedsuffixWalkForProd: doPart --
do (# cutter: @cutIf;
      top: @integer;
      stack: [16] ^AST;
      a: ^AST;
   do THIS(Expanded)[] -> a[];
      stackLoop:
        (if TRUE then
            sonLoop:
              (if a[] <> NONE then
                  (if NOT (a.symbol -> cutter) then
                      (if a.symbol = prod then
                          a[] -> current[];
                          INNER suffixWalkForProd;
                      if);
					  (if a.status <> 1 then
						  (if a.brother[] <> NONE then
							  top + 1 -> top;
							  (if top > stack.range then
								  top -> stack.extend;
							  if);
							  a.brother[] -> stack[top][];
						  if);
					  if);
                      a.son[] -> a[];
                      restart sonLoop;
                  if);
              if);
            (if top <> 0 then
                stack[top][] -> a[];
                top - 1 -> top;
                restart stackLoop;
            if);
        if);

   #)
-- ExpandedDump: doPart --
do INNER;

-- ConsDump: doPart --
do '(' -> output.put;
   symbol -> gram.symbolToName -> output.puttext;
   output[] -> printComments;
   scan
   (#
   do output.newline;
      (for level repeat
           '  ' -> output.puttext;
      for);
      (level+1, output[], gram[]) -> current.dump;
   #);
   INNER;
   ')' -> output.put;

-- ListDump: doPart --
do '[' -> output.put;
   symbol -> gram.symbolToName -> output.puttext;
   output[] -> printComments;
   scan
   (#
   do output.newline;
      (for level repeat
           '  ' -> output.puttext;
      for);
      (level+1, output[], gram[]) -> current.dump;
   #);
   
   INNER;
   ']' -> output.put;


-- UnExpandedDump: doPart --
do '<<' -> output.puttext;
   symbol -> gram.symbolToName -> output.puttext;
   (* value[] -> output.puttext; *)
    '>>' -> output.puttext;
   INNER;

-- OptionalDump: doPart --
do INNER;

-- SlotDescDump: doPart --
do INNER;

-- LexemDump: doPart --
do INNER;

-- LexemTextDump: doPart --
do INNER;

-- NameDeclDump: doPart --
do ':' -> output.put;
   getText -> output.puttext;
   INNER;

-- NameApplDump: doPart --
do '^' -> output.put;
   getText  -> output.puttext;
   INNER;

-- StringDump: doPart --
do '\'' -> output.put;
   getText  -> output.puttext;
   '\'' -> output.put;
   INNER;

-- CommentDump: doPart --
do INNER;

-- ConstDump: doPart --
do getText  -> output.puttext;
   INNER;

