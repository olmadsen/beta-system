ORIGIN '../astlevel';
INCLUDE '../bytestream';

-- astLib: attributes --

setLastBrother:
  (# value: @boolean;
  enter value
  do (if value then
         status %bor lastBrotherMask -> status;
      else
         status %band (%bnot lastBrotherMask) -> status;
     if);
  #);
getLastBrother:
  (# value: @boolean;
  do (status %band lastBrotherMask) = lastBrotherMask -> value;
  exit value
  #);

lastBrotherMask: (# exit 1 #);


scanit:
  (# current: ^AST;
  do son[] -> current[];
     loop:
       (if (current[] <> NONE) then  
           INNER;
           (if current.status <> 1 then
               current.brother[] -> current[];
               restart loop;
           if);
       if);
  #);
scanComments:
  (# current: ^Comment;
  do com[] -> current[];
     loop1:
       (if current[] <> NONE then
           INNER;
           current.brother[] -> current[];
           restart loop1;
       if);
  #);

printComments:
  (# output: ^Stream;
     position: @integer;
  enter output[]
  do scanComments
     (#
     do ' ' -> output.put;
        (if current.position <> position then
            current.position -> position;
            position -> output.putInt;
            ' ' -> output.put;
        if);
        '(*' -> output.puttext;
          current.getText -> output.puttext;
          '*)' -> output.puttext;
     #);
  #);

-- ASTFrag: doPart --
do 

-- ASTNextBrother: doPart --
do (if status <> 1 then
       brother[] -> next[];
    else
       NONE -> next[];
   if);
   
-- ASTFather: doPart --
do THIS(AST)[] -> theFather[];
   loop:
     (if theFather[] <> NONE then
         (if theFather.status = 1 then
             theFather.brother[] -> theFather[];
          else
             theFather.brother[] -> theFather[];
             restart loop;
         if);
     if);
-- ASTIsSlot: doPart --
do (if son[] <> NONE then
       son.astKind = kinds.slotDesc -> value;
    else
       false -> value;
   if);

-- ASTtheSlot: doPart --
do (if son[] <> NONE then
       (if son.astKind = kinds.slotDesc then
           son[] -> slot[];
       if);
   if);
   
   
-- ASTPackPutValue: doPart --
do value -> output.putInt32u;

-- AstPackPutAstRef: doPart --
do (if ref[] = NONE then
       0 -> output.putInt16u;
       0 -> output.putInt32u;
    else
       (if ref.form[] = form[] then
           0 -> output.putInt16u;
        else
           ref.form[] -> form.register -> output.putInt16u;
       if);
       ref.inx -> output.putInt32u;
   if);

-- AstUnPackGetValue: doPart --
do input.getInt32u -> value;

-- AstUnPackGetAstRef: doPart --
do input.getInt16u -> inx;
   (if inx = 0 then
       input.getInt32u -> inx;
       (if (inx > 0) AND (inx <= form.table.range) then
           form.table[inx][] -> ref[];
       if);
    else
       (# frag: ^FragmentForm;
       do inx -> form.lookup -> frag[];
          input.getInt32u -> inx;
          (if frag[] <> NONE then
              frag.table[inx][] -> ref[];
          if);
       #);
   if);
   

-- AstPack: doPart --
do (if symbol = 0 then
       THIS(AST)[] -> getPatternName -> putline;
   if);
   astkind -> output.putInt8u;
   status -> output.putInt8u;
   (if son[] = NONE then
       0 -> output.putInt32u;
    else
       son.inx -> output.putInt32u;
   if);
   (if brother[] = NONE then
       0 -> output.putInt32u;
    else
       brother.inx -> output.putInt32u;
   if);
   INNER;
   
-- AstUnPack: doPart --
do input.getInt8u -> astKind;
   input.getInt8u -> status;
   input.getInt32u -> inx;
   (if inx > 0 then
       (if Inx <= form.table.range then
           form.table[inx][] -> son[];
           (if son.symbol = prodNo.SlotDesc then
               prodNo.unExpanded -> symbol;
           if);
        else
           'index error (son): ' -> puttext;
           inx -> putint;
           ' range = ' -> puttext;
           form.table.range -> putint;
           newline;
       if);
   if);
   input.getInt32u -> inx;
   (if inx > 0 then
       (if inx <= form.table.range then
           form.table[inx][] -> brother[];
        else
           'index error (brother): ' -> puttext;
           inx -> putint;
           ' range = ' -> puttext;
           form.table.range -> putint;
           newline;
       if);
   if);
   INNER;

-- ASTDump: doPart --
do INNER;

-- ExpandedNoOfSons: doPart --
do 

-- ExpandedGet: doPart --
do son[] -> as[];
   (for inx - 1 repeat
        as.brother[] -> as[];
   for);

-- ExpandedPut: doPart --
do (if inx = 1 then
       (if son[] = NONE then
           as[] -> son[];
           1 -> son.status;
           THIS(AST)[] -> son.brother[];
        else
           (if son.status = 1 then
               1 -> as.status;
           if);
           son.brother[] -> as.brother[];
           as[] -> son[];
       if);
    else
       (# prev: ^AST;
       do son[] -> prev[];
          (for inx-2 repeat
               prev.brother[] -> prev[];
          for);
          (if prev.brother.status = 1 then
              1 -> as.status;
          if);
          prev.brother.brother[] -> as.brother[];
          as[] -> prev.brother[];
       #);
   if);


   
-- ExpandedScan: doPart --
do son[] -> current[];
   loop:
     (if (current[] <> NONE) then  
         INNER;
         (if current.status <> 1 then
             current.brother[] -> current[];
             restart loop;
         if);
     if);

-- ExpandedSuffixWalk: doPart --
do (# cutter: @cutIf;
      top: @integer;
      stack: [16] ^AST;
   do THIS(Expanded)[] -> current[];
      stackLoop:
        (if TRUE then
            sonLoop:
              (if current[] <> NONE then
                  (if NOT (current.symbol -> cutter) then 
                      INNER suffixWalk;
                      (if current.status <> 1 then
                          (if current.brother[] <> NONE then
                              top + 1 -> top;
                              (if top > stack.range then
                                  top -> stack.extend;
                              if);
                              current.brother[] -> stack[top][];
                          if);
                      if);
                      current.son[] -> current[];
                      restart sonLoop;
                  if);
              if);
            (if top <> 0 then
                stack[top][] -> current[];
                top - 1 -> top;
                restart stackLoop;
            if);
        if);

   #)
   
-- ExpandedsuffixWalkForProd: doPart --
do (# cutter: @cutIf;
      top: @integer;
      stack: [16] ^AST;
      a: ^AST;
   do THIS(Expanded)[] -> a[];
      stackLoop:
        (if TRUE then
            sonLoop:
              (if a[] <> NONE then
                  (if NOT (a.symbol -> cutter) then
                      (if a.symbol = prod then
                          a[] -> current[];
                          INNER suffixWalkForProd;
                      if);
                      (if a.status <> 1 then
                          (if a.brother[] <> NONE then
                              top + 1 -> top;
                              (if top > stack.range then
                                  top -> stack.extend;
                              if);
                              a.brother[] -> stack[top][];
                          if);
                      if);
                      a.son[] -> a[];
                      restart sonLoop;
                  if);
              if);
            (if top <> 0 then
                stack[top][] -> a[];
                top - 1 -> top;
                restart stackLoop;
            if);
        if);

   #)
-- ExpandedDump: doPart --
do INNER;

-- ConsDump: doPart --
do '(' -> output.put;
   symbol -> gram.symbolToName -> output.puttext;
   output[] -> printComments;
   
   (if isSlot then
       (level+1, output[], gram[]) -> (theSlot).dump;
    else
       scanit
       (#
       do output.newline;
          (for level repeat
               '  ' -> output.puttext;
          for);
          (level+1, output[], gram[]) -> current.dump;
       #);
   if);
   INNER;
   ')' -> output.put;

-- ListDump: doPart --
do '[' -> output.put;
   symbol -> gram.symbolToName -> output.puttext;
   output[] -> printComments;
   scanit
   (#
   do output.newline;
      (for level repeat
           '  ' -> output.puttext;
      for);
      (level+1, output[], gram[]) -> current.dump;
   #);
   
   INNER;
   ']' -> output.put;


-- UnExpandedDump: doPart --
do INNER;

-- OptionalDump: doPart --
do INNER;

-- SlotDescDump: doPart --
do '<<SLOT ' -> output.puttext;
   name -> output.puttext;
   '>>' -> output.puttext;
   INNER;

-- SlotDescPack: doPart --
do name -> output.putBinText;
   category -> output.putInt32u;
   nextSlot[] -> putAstRef;
   origin[] -> putAstRef;
   
-- SlotDescUnPack: doPart --
do (# txt: ^Text;
   do input.getBinText -> txt[];
      txt ->  value;
      txt.lgth -> lgth;
      input.getInt32u -> category;
      getAstRef -> nextSlot[];
      getAstRef -> origin[];
   #);

-- LexemDump: doPart --
do INNER;


-- LexemTextPack: doPart --
do gettext -> output.putBinText;
   INNER;
   
-- LexemTextUnPack: doPart --
do input.getBinText -> putText;
   INNER;
-- LexemTextDump: doPart --
do INNER;

-- NameDeclDump: doPart --
do ':' -> output.put;
   getText -> output.puttext;
   INNER;

-- NameApplDump: doPart --
do '^' -> output.put;
   getText  -> output.puttext;
   INNER;

-- StringDump: doPart --
do '\'' -> output.put;
   getText  -> output.puttext;
   '\'' -> output.put;
   INNER;

-- CommentDump: doPart --
do INNER;

-- ConstDump: doPart --
do getText  -> output.puttext;
   INNER;


