ORIGIN '../astlevel';
INCLUDE '../propertyparser';
INCLUDE '~beta/basiclib/binfile';
INCLUDE '../bytestream';


-- AstInterfaceLib: attributes --


groupMagicNumber1: (# exit 0x79657321 #);
groupMagicNumber2: (# exit 0x6173742E #);
groupVersion: (# exit 3 #);


Log: Stream
  (# output: @file;
     
     init:
       (#
       do 'log.txt' -> output.name;
          output.openWrite;
       #);
     
     put::
       (#
       do ch -> output.put;
       #);
     puttext::
       (#
       do txt[] -> output.puttext;
          output.flush;
       #);
  #);

getLog: objectPool.get
  (# Type:: Log;
     init::
       (#
       do obj.init;
       #);
  #);
DefaultErrorReporter: ErrorReporter
  (# forEachError::
       (#
          l: @text;
          lastPos: @integer;
          t,cd: ^text;
          tabCount: @integer;
          ch: @char
       do
          0->errorLines.pos;
          loop:
            (#
            do
               '#'->errorStream.put;
               startLineNo
                 ->errorStream.putInt
               (# format::  (#  do 4->width #) #);
               ' '->errorStream.put;
               startLineNo+1->startLineNo;
               errorLines.pos->lastPos;
               &text[]->t[];
               L:
                 (if errorLines.eos then
                     leave L
                  else
                     (if ((errorLines.get->ch) <> ascii.newLine) then
                         ch->t.put; restart L
                     if)
                 if);
               t[]->errorStream.putLine;
               (if not errorLines.eos then restart loop if)
            #);
          0->tabCount;
          ascii.ht->t.findAll (#  do 1+tabCount->tabCount #);
          '# ****'->errorStream.putText;
          (for tabCount repeat ascii.ht->errorStream.put for);
          (for errorPos-lastPos-3-tabCount repeat '*'->errorStream.put for);
          '  ^'->errorStream.putLine;
          '#  Expected symbol'->errorStream.putText;
          (if legalSymbols.terminals.range = 1 then
              ': '->errorStream.putText;
           else
              's: '->errorStream.putText
          if);
          (for i: legalSymbols.terminals.range repeat
               legalSymbols.terminals[i][]->errorStream.putText;
               (if (i <> legalSymbols.terminals.range) then
                   ' '->errorStream.put
               if)
          for);
          errorStream.newLine;
          (if frag.fatherR[] = none then
              (* we have a stand alone fragmentForm.  Do not write file and
               * line-number information
               *)
              
           else
              ' File "'->errorStream.putText;
              frag.textFileName->t[];
              currentDirectory->cd[];
              (frag.textFileName,currentDirectory)
                ->thePathHandler.convertFilePath->errorStream.putText;
              '"; Line '->errorStream.putText;
              startLineNo-1->errorStream.putInt;
              errorStream.newLine;
              
          if);
          
       #);
  #);

-- FragmentFormLib: attributes --

scanImport:
  (# current: ^FragmentForm;
  do (for inx: importtop repeat
          import[inx][] -> current[];
          INNER scanImport;
     for);
  #);

packSemantics:
  (# header: ^Text;
     info: ^Text;
     output: ^Stream;
  enter output[]
  do &Text[] -> header[];
     &Text[] -> info[];
     (header[], info[]) -> packSemanticInfo;
     header[] -> output.putBinText;
     info[] -> output.putBinText;
  #);
unPackSemantics:
  (# input: ^Stream;
  enter input[]
  do input.getBinText -> header[];
     input.getBinText -> info[];
  #);
packAst:
  (# output: ^Stream;
     table: @ContainerList
       (# element:: Ast;
       #);
     index: @integer;
     exp: ^Expanded;
  enter output[]
  do root[] -> exp[];
     exp.suffixWalk
     (#
     do index + 1 -> index;
        index -> current.inx;
        current[] -> table.append;
     #);
     index -> THIS(FragmentForm).table.new;
     table.scan
     (# 
     do current[] -> THIS(FragmentForm).table[current.inx][];
     #);
     
     index -> output.putInt32u;
     
     table.scan
     (# slot: ^SlotDesc;
     do (if current.symbol = prodNo.unExpanded then
            (if current.isSlot then
                current.theSlot -> slot[];
                slot.category -> output.putInt16u;
             else
                prodNo.unExpanded -> output.putInt16u;
            if);
         else
            current.symbol -> output.putInt16u;
        if);
     #);
     table.scan
     (# theLexemText: ^LexemText;
        slot: ^SlotDesc;
     do current.astkind -> output.putInt8u;
        current.status -> output.putInt8u;
        current.start -> output.putInt32u;
        current.end -> output.putInt32u;
        (if current.son[] = NONE then
            0 -> output.putInt32u;
         else
            current.son.inx -> output.putInt32u;
        if);
        (if current.brother[] = NONE then
            0 -> output.putInt32u;
         else
            current.brother.inx -> output.putInt32u;
        if);
        
        (if current.symbol < 0 then
            (if current.symbol
             //prodNo.nameAppl
             //prodNo.nameDecl
             //prodNo.string
             //prodNo.const then
                current[] -> theLexemText[];
                theLexemText.getText -> output.putBinText;
             //prodNo.slotDesc then
                current[] -> slot[];
                slot.name -> output.putBinText;
            if);
        if);
     #);
     
     (if firstSlot[] = NONE then
         0 -> output.putInt32u;
      else
         firstSlot.inx -> output.putInt32u;
     if);
     
  #);
unPackAst:
  (# size: @integer;
     symbol: @int16;
     input: ^Text;
     index: @integer;
     current: ^AST;
     
     symbolToAst: ^treelevel.symbolToAst;
     
     theLexemText: ^LexemText;
     pos: @integer;
     
     
     getInt8u: @
       (# value: @int8u;
       do input.T[pos] -> value;
          pos + 1 -> pos;
       exit value
       #);
     getInt16u: @
       (# value: @int16u;
       do (input.T[pos] %sll 8) %bor input.T[pos+1] -> value;
          pos + 2 -> pos;
       exit value
       #);
     getInt32u: @
       (# value: @int32u;
       do (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> value;
          pos + 4 -> pos;
       exit value
       #);
      theSlot: ^SlotDesc;
  enter input[]
  do &grammar.symbolToAst[] -> symbolToAst[];
     1 -> pos;
     (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> size;
     
     
     pos + 4 -> pos;
     size -> table.new;
     
     (for inx: size repeat
	  (input.T[pos] %sll 8) %bor input.T[pos+1] -> symbol;
          pos + 2 -> pos;
          symbol -> symbolToAst -> table[inx][];
          THIS(FragmentForm)[] -> table[inx].frag[];
          inx -> table[inx].inx;
     for);
     
     (for inx: size repeat
          table[inx][] -> current[];
	  input.T[pos] -> current.astKind;
          pos + 1 -> pos;
	  input.T[pos] -> current.status;
          pos + 1 -> pos;
          (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> current.start;
          pos + 4 -> pos;
          (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> current.end;
          pos + 4 -> pos;
          
	  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> index;
          pos + 4 -> pos;
          (if index > 0 then
              (if index <= table.range then
                  table[index][] -> current.son[];
                  (if current.son.symbol = prodNo.SlotDesc then
		      current.son[] -> theSlot[];
		      current.symbol -> theSlot.category;
                      (if false then
                          
                      if);
                      prodNo.unExpanded -> current.symbol;
                  if);
              if);
          if);
	  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> index;
          pos + 4 -> pos;
          (if index > 0 then
              (if index <= table.range then
                  table[index][] -> current.brother[];
              if);
          if);
          (if current.symbol < 0 then
              (if current.symbol
               //prodNo.nameAppl
               //prodNo.nameDecl
               //prodNo.string
               //prodNo.const then
                  current[] -> theLexemText[];
		  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> theLexemText.lgth;
                  pos + 4 -> pos;
		  theLexemText.lgth -> theLexemText.value.new;
		  (for inx: theLexemText.lgth repeat
		     input.T[pos] -> theLexemText.value[inx];
                     pos + 1 -> pos;
		  for);
               //prodNo.slotDesc then
                  current[] -> theSlot[];
                  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] 
                    -> theSlot.lgth;
                  pos + 4 -> pos;
                  theSlot.lgth -> theSlot.value.new;
                  (for inx: theSlot.lgth repeat
                       input.T[pos] -> theSlot.value[inx];
                       pos + 1 -> pos;
                  for);
              if);
          if);
     for);
     table[1][] -> root[];
     (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> index;
     pos + 4 -> pos;
     (if index > 0 then
         table[index][] -> firstSlot[];
     if);
     
  #);

packSemanticInfo:
  (# header: ^Text;
     info: ^Text;
     current: ^AST;
     
     fraginx: @integer;
     form: ^FragmentForm;
     out: ^Stream;
     local:
       (# path: ^Text;
       enter path[]
       do (path[], '~beta') -> thePathHandler.localPath -> path[];
       exit path[]
       #);
  enter (header[], info[])
  do 
     (for inx: table.range repeat
          table[inx][] -> current[];
          info[] -> current.pack;
     for);
     importtop -> header.putInt32u;
     (for inx: importtop repeat
          import[inx][] -> form[];
          (form.father).fullname -> local -> header.putBinText;
          form.name -> header.putBinText;
     for);
  #);
unPackSemanticInfo:
  (# header, info: ^Text;
     pos: @integer;
     current: ^AST;
     
     unPackImport:
       (# header: ^Text;
          group: ^FragmentGroup;
          fullname: ^Text;
          name: ^Text;
       enter header[]
       do header.reset;
          header.getInt32u -> importtop -> import.new;
          (for inx: importtop repeat
               header.getBinText -> fullname[];
               header.getBinText -> name[];
               (fullname[], screen[]) -> top.open -> group[];
               (if group[] <> NONE then
                   search: group.scan
                     (#
                     do (if name[] -> (current.name).equalNCS then
                            current[] -> import[inx][];
                            leave search;
                        if);
                     #);
                   group.realopen;
               if);
          for);
       #);
     
     lex: ^LexemText;
  enter (header[], info[])
  do 
     info.reset;
     1 -> pos;
     (if header[] <> NONE then
         header[] -> unPackImport;
     if);
     (for inx: table.range repeat
          table[inx][] -> current[];
          info[] -> current.unPack;
     for);
  #);

-- FragmentGroupLib: Attributes --

findslot:
  (# name: ^Text;
     op: ^SlotDesc;
  enter name[]
  do 
     search: scanSlots
     (#
     do (if current.name -> name.equalNCS then
            current[] -> op[];
            leave search;
        if);
     #);
  exit op[]
  #);

-- FragmentFormCategory: doPart --
do (if root[] = NONE then
       cat -> sy;
    else
       root.symbol -> sy;
   if);

-- FragmentFormScanSlots: doPart --
do firstSlot[] -> current[];
   loop:
     (if current[] <> NONE then
         INNER;
         current.nextSlot[] -> current[];
         restart loop; 
     if);
   
-- FragmentFormPack: doPart --
do (# data: ^Text;
   do &Text[] -> data[];
      data[] -> packAst;
      data[] -> output.putBinText;
   #);
   
-- FragmentFormUnpack: doPart --
do (# data: ^Text;
   do input.getBinText -> data[];
      data.reset;
      data[] -> unPackAst;
   #);
   
   
-- FragmentFormRegister: doPart --
do search:
     (#
     do  
        (for inx: importtop repeat
             (if frag[] = import[inx][] then
                 inx -> index;
                 leave search;
             if);
        for);
        importtop + 1 -> importtop;
        (if importtop = import.range then
            importtop -> import.extend;
        if);
        frag[] -> import[importtop][];
        importtop -> index;
     #);
-- FragmentFormLookup: doPart --
do (if (index > 0) AND (index <= importtop) then
       import[index][] -> frag[];
   if);
-- FragmentFormBindSemanticInfo: doPart --
do (header[], info[]) -> unPackSemanticInfo;
   
-- FragmentGroupScan: doPart --
do fragmentlist.scan
   (#
   do current[] -> this(scan).current[];
      INNER scan;
   #);
   
   
   
-- FragmentGroupSetupOrigin: doPart --
do
   FindOrigin: THIS(fragment).prop.ScanProp
     (#
        doProp::
          (#
          do
             prop.makelc;
             (if 'origin'->prop.equal then
                 ScanParameters
                 (#
                    doString::
                      (# t: ^Text;
                      do
                         THIS(fragment).fullName->stripPathName->t[];
                         (if t[] = none then
                             ((S.copy,currentDirectory)
                               ->thePathHandler.convertFilePath,error[])
                               ->top.open->THIS(fragmentgroup).origin
                          else
                             ((S.copy,t[])->thePathHandler.convertFilePath,
                             error[])->top.open->THIS(fragmentgroup).origin
                         if);
                         leave FindOrigin;
                         
                      #)
                 #)
             if)
          #)
     #)

-- FragmentGroupScanIncludes: doPart --
do (if includes.empty then
       loadIncludes;
   if);
   includes.scan
   (#
   do current[] -> THIS(ScanIncludes).current[];
      inner scanIncludes;
   #);
   
-- FragmentGroupBind: doPart --
do (# 
   do (if false then
          (if controller.status = 7 then
              scan
              (# frag: ^FragmentForm;
              do current[] -> frag[];
                 NONE -> frag.header[];
              #);
          if);
          scan
          (# frag: ^FragmentForm;
          do current[] -> frag[];
             (if frag.info[] <> NONE then
                 (frag.header[], frag.info[]) -> frag.unPackSemanticInfo;
                 NONE -> frag.header[];
                 NONE -> frag.info[];
             if);
          #);
      if);
      f.name -> findslot -> op[] -> f.binding[];
      
      (if OP[] = NONE then
          (if origin = NONE then
              setupOrigin;
          if);
          (if origin <> NONE then
              f[] -> (origin).bind -> op[];
          if);
       else
          false -> op.isBound;
      if);
   #);
   
-- FragmentGroupScanSlots: doPart --
do scan
   (# frag: ^FragmentForm;
   do current[] -> frag[];
      frag.scanSlots
      (#
      do current[] -> THIS(ScanSlots).current[];
         inner ScanSlots;
      #);
   #);
-- FragmentGroupRealOpen: doPart --
do (if not isRealOpen then
       (# astfile: @file (# binary:: (# do true -> value #); #);
          position: @integer;
       do diskFileName -> astfile.name;
          astfile.openRead;
          (mark, frombeginning) -> astfile.setpos;
          astfile.getInt32u -> position;
          (if mark = position then
              fragmentlist.scan
              (#
              do astfile[] -> current.unPack;
              #);
              fragmentlist.scan
              (#
              do astfile[] -> current.unPackSemantics;
              #);
              
          if);
          astfile.close;
       #);
       true -> isRealOpen;
       unPackSemanticInfo;
   if);
   
-- FragmentGroupIncludeFullName: doPart --
do (# t: ^Text;
   do THIS(fragment).fullName->stripPathName->t[];
      (if t[] = NONE then
          (linkname[], currentDirectory) 
            -> thePathHandler.convertFilePath 
            -> theFullName[];
       else
          (linkname[], t[]) 
            -> thePathHandler.convertFilePath 
            -> theFullName[];
      if);
   #);

-- FragmentGroupLoadIncludes: doPart --
do includes.clear;
   prop.scanProp
   (# doProp::
        (#
        do (if 'include'->prop.equalNCS then
               scanParameters
               (# doString::
                    (# l: ^Include;
                    do &Include[]->l[];
                       s.copy->l.linkName[];
                       l[] -> includes.append;
                    #)
               #);
           if);
        #);
   #)

-- FragmentGroupSaveFailure: doPart --
do INNER;

-- FragmentGroupSave: doPart --
do saving:
     (# output: @File
          (# binary:: (# do true -> value #);
          #);
        filename: ^Text;
     do
        (fullname).copy -> filename[];
        '.ast' -> filename.append;
        
        
        filename[] -> output.name;
        output.openWrite;
        output[] -> pack;
        output.close;
        output.entry.modtime (# error:: (# do true -> continue #) #) -> modtime;
     #);

-- FragmentGroupLoadFailure: doPart --
do 

-- FragmentGroupLoad: doPart --
do loading:
     (# input: @File
          (# binary:: (# do true -> value #);
          #);
        filename: ^Text;
        
        stripExtension:
          (# path: ^text;
             stripped: ^text;
             dotPos: @integer;
             slashPos: @integer;
             
          enter path[]
          do (if path[] <> NONE then
                 (if path.length > 0 then
                     directoryChar -> path.findAll
                     (#
                     do inx -> slashPos;
                     #);
                     '.' -> path.findAll
                     (#
                     do inx -> dotPos;
                     #);
                     (if dotPos > slashPos then
                         (1, dotpos -1) -> path.sub -> stripped[];
                      else
                         path.copy -> stripped[]
                     if);
                     
                 if);
             if);
          exit stripped[]
          #);
        fullname: ^Text;
     do name[] -> expandToFullPath -> fullname[];
        fullname[] -> stripExtension -> fullname[];
        fullname.copy -> filename[];
        '.ast' -> filename.append;
        filename[] -> input.name;
        fullname.copy -> THIS(FragmentGroup).fullname;
        fullname.copy -> THIS(FragmentGroup).name;
        input.openRead;
        input[] -> unpack;
        input.close;
        input.entry.modtime (# error:: (# do true -> continue #) #) -> modtime;
     #);
   
-- FragmentGroupClose: doPart --
do fragmentlist.scan
   (#
   do NONE -> current.root[];
   #);
   fragmentlist.clear;
   THIS(FragmentGroup)[] -> top.grouptable.delete;
   
-- FragmentGroupPack: doPart --
do (#
   do groupMagicNumber1 -> output.putInt32u;
      groupMagicNumber2 -> output.putInt32u;
      groupVersion -> output.putInt32u;
      output[] -> prop.pack;
      fragmentlist.size -> output.putInt32u;
      fragmentlist.scan
      (#
      do current.grammar.grammarIdentification -> output.putBinText;
         current.grammar.version -> output.putInt32u;
         current.name -> output.putBinText;
         current.category -> output.putInt16u;
         
      #);
      output.position -> output.putInt32u;
      fragmentlist.scan
      (#
      do output[] -> current.pack;
      #);
      fragmentlist.scan
      (#
      do output[] -> current.packSemantics;
      #);
   #);

-- FragmentGroupUnpack: doPart --
do unpacking:
     (# magic1, magic2: @int32u;
        version: @int32u;
        no: @integer;
        frag: ^fragmentForm;
        data: ^Text;
        grammarName: ^Text;
        gram: ^TreeLevel;
        grammarVersion: @integer;
     do 
        input.getInt32u -> magic1;
        (if magic1 <> groupMagicNumber1 then
            leave unpacking;
        if);
        input.getInt32u -> magic2;
        (if magic2 <> groupMagicNumber2 then
            leave unpacking;
        if);
        input.getInt32u -> version;
        (if version <> groupVersion then
            leave unpacking;
        if);
        &PropertyList[] -> prop[];
        input[] -> prop.unPack;
        input.getInt32u -> no;
        (for no repeat
             input.getBinText -> grammarName[];
             grammarName[] -> grammartable.lookup -> gram[];
             input.getInt32u -> grammarVersion;
             (if gram.version <> grammarVersion then
                 fragmentList.clear;
                 leave unpacking;
             if);
             gram[] -> newFragmentForm -> frag[];
             input.getBinText -> frag.nameT[];
             frag[] -> fragmentList.append;
             THIS(FragmentGroup)[] -> frag.father;
             fullnameT.copy -> frag.fullnameT[];
             '-' -> frag.fullnameT.append;
             frag.nameT[] -> frag.fullnameT.append;
             input.getInt16u -> frag.cat;
             
        for);
        input.getInt32u -> mark;
        (if doRealOpen then
            fragmentlist.scan
            (#
            do input[] -> current.unPack;
            #);
            fragmentlist.scan
            (#
            do input[] -> current.unPackSemantics;
            #);
            true -> isRealOpen;
        if);
        true -> OK;
     #);
   
-- FragmentGroupUnPackSemanticInfo: doPart --
do (if controller.status = 7 then
       scan
       (# frag: ^FragmentForm;
       do current[] -> frag[];
          NONE -> frag.header[];
       #);
   if);
   scan
   (# frag: ^FragmentForm;
   do current[] -> frag[];
      (if frag.info[] <> NONE then
          (frag.header[], frag.info[]) -> frag.unPackSemanticInfo;
          NONE -> frag.header[];
          NONE -> frag.info[];
      if);
   #);
   
-- AstInterfaceTopOpen: doPart --
do opengroup:
     (# parse: @PropertyParser
          (# syntaxerror::
               (#
               do msg.newline;
                  'while parsing: "' -> msg.puttext;
                  fullname[] -> msg.puttext;
                  '"' -> msg.puttext;
                  msg[] -> putline;
                  '' -> parseErrors;
               #);
          #);
        gram: ^TreeLevel;
        frag: ^FragmentForm;
        fragname, cat: ^text;
        fullname: ^text;
        betFileName: ^text;
        killImps:
          (# exp: ^expanded;
          enter exp[]
          do 31 -> exp.suffixWalkForProd
             (#
             do NONE -> current.son[];
             #);
          #);
        dummy: @fragmentgroup;

        stripExtension:
          (# path: ^text;
             stripped: ^text;
             dotPos: @integer;
             slashPos: @integer;
             
          enter path[]
          do (if path[] <> NONE then
                 (if path.length > 0 then
                     directoryChar -> path.findAll
                     (#
                     do inx -> slashPos;
                     #);
                     '.' -> path.findAll
                     (#
                     do inx -> dotPos;
                     #);
                     (if dotPos > slashPos then
                         (1, dotpos -1) -> path.sub -> stripped[];
                      else
                         path.copy -> stripped[]
                     if);
                     
                 if);
             if);
          exit stripped[]
          #);
        
        astfile: @file (# binary:: (# do true -> value #); #);
        textfile: @file;
        sym: @integer;
        grammarName: ^Text;
        
        
        parseCode:
          (# gram: ^TreeLevel;
             name: ^Text;
             category: ^Text;
             frag: ^FragmentForm;
             symbol: @integer;
             getGoalSymbol:
               (# gram: ^Treelevel;
                  cat: ^Text;
                  symbol: @integer;
               enter (gram[], cat[])
               do (if true
                   //'attributes' -> cat.equalNCS then
                      1 -> symbol;
                   //'descriptor' -> cat.equalNCS then
                      1 -> symbol;
                   else
                      cat[] -> gram.nameToSymbol -> symbol;
                      (if symbol = 0 then
                          1 -> symbol;
                      if);
                  if);
               exit symbol
               #);
             report:
               (#
               do textfile.reset;
                  (textfile[], error[]) -> gram.parser.errorReport;
               #);
          enter (gram[], name[], category[])
          do (if gram[] = NONE then
                 'grammar missing!' -> putline;
             if);
             parse.inputpos -> gram.parser.initialpos;
             false -> gram.parser.trace;
             gram[] -> newFragmentForm -> frag[];
             fragname[] -> frag.name;
             fragname.copy -> fragname[];
             '-' -> fragname.prepend;
             fullname[] -> fragname.prepend;
             fragname[] -> frag.fullname;
             group[] -> frag.father;
             (gram[], cat[]) -> getGoalSymbol -> symbol;
             
             (symbol, textfile[], frag[]) -> gram.parser.parse -> frag.root[];
             (if frag.root[] = NONE then
                 'PARSE ERRORS' -> putline;
                 report;
                 NONE -> frag[];
             if);
          exit frag[]
          #);
        OK: @Boolean;
     do name[] -> expandToFullPath -> fullname[];
        fullname[] -> stripExtension -> fullname[];
        
       
        fullname[] -> dummy.fullname;
        dummy[]->grouptable.hashfunction
          ->grouptable.findIndexed
        (# predicate::  (#  do fullname[]->(current.fullname).equalNCS->value #);
        do current[] -> group[];
        #);
        (if group[] <> NONE then
            leave openGroup;
        if);
        
        newFragmentGroup -> group[];
        fullname.copy -> group.name;
        fullname.copy -> group.fullname;
        group[] -> grouptable.insert;
        
        
        '.ast' -> (fullname.copy).append -> astfile.name;
        
        
        identifyTextFile:
          (# test:
               (# ext: ^Text;
               enter ext[]
               do ext[] -> (fullname.copy).append -> textfile.name;
                  (if textfile.entry.exists then
                      leave identifyTextFile;
                  if);
               #);
          do '.bet' -> test;
             '.text' -> test;
             grammartable.grammars.scan
             (#
             do current.suffix -> test;
             #);
          #);
        
        
        (if astfile.entry.exists then
            (if astfile.entry.modtime > textfile.entry.modtime then
                astfile.openRead;
                astfile[] -> group.unPack -> OK;
                astfile.close;
                
                (if OK then
                    astfile.entry.modtime -> group.modtime;
                    leave openGroup;
                if);
            if);
        if);
        
        
        (if NOT textfile.entry.exists then
            otherFileError;
        if);
        
        'Parsing: \'' -> puttext;
        textfile.name -> puttext;
        '\'' -> putline;
        
        grammarTable.default[] -> gram[];
        
        (if gram[] = NONE then
            'default grammar missing' -> putline;
        if);
        textfile.openRead;
        (textfile[], error[]) -> parse.init;
        parse.parsePropertyList -> group.prop[];
        parse.advance;
        loop:
          (if parse.token = parse.tokens.name then
              parse.lex.gettext -> fragname[];
              parse.advance;
              (if parse.token = parse.tokens.colon then
                  parse.advance;
                  (if parse.token = parse.tokens.name then
                      parse.lex.gettext -> cat[];
                      parse.advance;
                      (if parse.token = parse.tokens.colon then
                          parse.advance;
                          (if parse.token = parse.tokens.name then
                              parse.lex.gettext -> grammarName[];
                              grammarName[] -> grammarTable.lookup -> gram[];
                              parse.advance;
                          if);
                      if);
                      (if parse.token = parse.tokens.dash then
                          (gram[], fragname[], cat[]) -> parseCode -> frag[];
                          (if frag[] <> NONE then
                              frag[] -> group.fragmentList.append;
                              group[] -> frag.father;
                              gram.parser.lastCH -> parse.lex.ch;
                              gram.parser.initialpos -> parse.inputpos;
                              parse.advance;
                              restart loop;
                           else
                              NONE -> group[];
                          if);
                      if);
                  if);
              if);
          if);
        textfile.close;
        (if group[] <> NONE then
            
            group.save;
        if);
     #);
   
-- AstInterfaceGrammarTableRegister: doPart --
do grammar[] -> grammars.append;
   
-- AstInterfaceGrammarTableLookup: doPart --
do search: grammars.scan
   (#
   do (if current.grammarIdentification -> name.equalNCS then
          current[] -> grammar[];
          leave search;
      if);
   #);
   
-- AstInterfacePrivate: descriptor --
(# debug: @boolean;
   debuga: @boolean;
   
#)

-- AstInterfaceAstLevelInit: doPart --
do thePathHandler.init;
   TOP.grouptable.init;
   true -> doRealOpen;
   &DefaultErrorReporter[] -> theErrorReporter[];
   INNER;
   
