ORIGIN '../astlevel';
INCLUDE '../propertyparser';
INCLUDE '~beta/basiclib/file';
INCLUDE '../bytestream';
INCLUDE '../donecheck';


-- AstInterfaceLib: attributes --


groupMagicNumber1: (# exit 0x79657321 #);
groupMagicNumber2: (# exit 0x6173742E #);
groupVersion: (# exit 1 #);


-- FragmentFormLib: attributes --


packAst:
  (# output: ^Stream;
     table: @ContainerList
       (# element:: Ast;
       #);
     index: @integer;
     exp: ^Expanded;
  enter output[]
  do root[] -> exp[];
     exp.suffixWalk
     (#
     do index + 1 -> index;
        index -> current.inx;
        current[] -> table.append;
     #);
     index -> output.putInt32u;
     table.scan
     (# slot: ^SlotDesc;
     do (if current.symbol = prodNo.unExpanded then
            (if current.isSlot then
                current.theSlot -> slot[];
                slot.category -> output.putInt16u;
             else
                prodNo.unExpanded -> output.putInt16u;
            if);
         else
            current.symbol -> output.putInt16u;
        if);
     #);
     table.scan
     (# theLexemText: ^LexemText;
     do current.astkind -> output.putInt8u;
        current.status -> output.putInt8u;
        (if current.son[] = NONE then
            0 -> output.putInt32u;
         else
            current.son.inx -> output.putInt32u;
        if);
        (if current.brother[] = NONE then
            0 -> output.putInt32u;
         else
            current.brother.inx -> output.putInt32u;
        if);
        
        (if current.symbol < 0 then
            (if current.symbol
             //prodNo.nameAppl
             //prodNo.nameDecl
             //prodNo.string
             //prodNo.const then
                current[] -> theLexemText[];
                theLexemText.getText -> output.putBinText;
            if);
        if);
     #);
     (if firstSlot[] = NONE then
         0 -> output.putInt32u;
      else
         firstSlot.inx -> output.putInt32u;
     if);
  #);
unPackAst:
  (# size: @integer;
     symbol: @int16;
     input: ^Stream;
     index: @integer;
     current: ^AST;
     
     symbolToAst: ^treelevel.symbolToAst;
     getInt16u: ^Stream.getInt16u;
     getInt32u: ^Stream.getInt32u;
     getInt8u: ^Stream.getInt8u;
     theLexemText: ^LexemText;
  enter input[]
  do  &grammartable.beta.symbolToAst[] -> symbolToAst[];
     &input.getInt16u[] -> getInt16u[];
     &input.getInt32u[] -> getInt32u[];
     &input.getInt8u[] -> getInt8u[];
     getInt32u -> size;
     size -> table.new;
     (for inx: size repeat
          getInt16u -> symbol;
          symbol -> symbolToAst -> table[inx][];
          THIS(FragmentForm)[] -> table[inx].form[];
          inx -> table[inx].inx;
     for);
     
     (for inx: size repeat
          table[inx][] -> current[];
          getInt8u -> current.astKind;
          getInt8u -> current.status;
          getInt32u -> index;
          (if index > 0 then
              (if index <= table.range then
                  table[index][] -> current.son[];
                  (if current.son.symbol = prodNo.SlotDesc then
                      prodNo.unExpanded -> current.symbol;
                  if);
              if);
          if);
          getInt32u -> index;
          (if index > 0 then
              (if index <= table.range then
                  table[index][] -> current.brother[];
              if);
          if);
          (if current.symbol < 0 then
              (if current.symbol
               //prodNo.nameAppl
               //prodNo.nameDecl
               //prodNo.string
               //prodNo.const then
                  current[] -> theLexemText[];
                  input.getBinText -> theLexemText.puttext;
              if);
          if);
     for);
     table[1][] -> root[];
     getInt32u -> index;
     (if index > 0 then
         table[index][] -> firstSlot[];
     if);
  #);
-- FragmentFormCategory: doPart --
do root.symbol -> sy;

-- FragmentFormScanSlots: doPart --
do firstSlot[] -> current[];
   loop:
     (if current[] <> NONE then
         INNER;
         current.nextSlot[] -> current[];
         restart loop; 
     if);
   
-- FragmentFormPack: doPart --
do (# data: ^Text;
      groupID: ^Text;
   do &Text[] -> data[];
      data[] -> packAst;
      importtop -> output.putInt32u;
      (for inx: importtop repeat
           (THIS(AstInterface)[], import[inx].father) -> getGroupIDProperty -> groupID[];
           
           (import[inx].father).fullname -> output.putBinText;
           import[inx].name -> output.putBinText;
           groupID[] -> output.putBinText;
      for);
      data[] -> output.putBinText;
   #);
   
-- FragmentFormUnpack: doPart --
do (# fullname: ^Text;
      name: ^Text;
      data: ^Text;
      group: ^astInterface.FragmentGroup;
      groupID: ^TEXT;
      value: ^Text;
      clear: @boolean;
   do input.getInt32u -> importtop;
      importtop + 1 -> import.new;
      (for inx: importtop repeat
           input.getBinText -> fullname[];
           input.getBinText -> name[];
           input.getBinText -> groupID[];
           (fullname[], screen[]) -> top.open  -> group[];
           (if group[] <> NONE then
               (THIS(AstInterface)[], group[]) -> getGroupIDProperty -> value[];
               (if value[] <> NONE then
                   (if groupID[] -> value.equal then
                       search: group.scan
                         (#
                         do (if current.name -> name.equalNCS then
                                current[] -> import[inx][];
                                leave search;
                            if);
                         #);
                   if);
               if);
           if);
           
      for);
      
      (for inx: importtop repeat
           (if import[inx][] = NONE then
               true -> clear;
           if);
      for);
      (if clear then
          1 -> import.new;
          0 -> importtop;
      if);
      input.getBinText -> data[];
      data.reset;
      data[] -> unPackAst;
   #);
   
   
-- FragmentFormRegister: doPart --
do search:
     (#
     do  
        (for inx: importtop repeat
             (if frag[] = import[inx][] then
                 inx -> index;
                 leave search;
             if);
        for);
        importtop + 1 -> importtop;
        (if importtop = import.range then
            importtop -> import.extend;
        if);
        frag[] -> import[importtop][];
        importtop -> index;
     #);
-- FragmentFormLookup: doPart --
do (if (index > 0) AND (index <= importtop) then
       import[index][] -> frag[];
   if);
   
   
-- FragmentGroupScan: doPart --
do fragmentlist.scan
   (#
   do current[] -> this(scan).current[];
      INNER scan;
   #);
   
   
   
-- FragmentGroupSetupOrigin: doPart --
do
   FindOrigin: THIS(fragment).prop.ScanProp
     (#
        doProp::
          (#
          do
             prop.makelc;
             (if 'origin'->prop.equal then
                 ScanParameters
                 (#
                    doString::
                      (# t: ^Text;
                      do
                         THIS(fragment).fullName->stripPathName->t[];
                         (if t[] = none then
                             ((S.copy,currentDirectory)
                               ->thePathHandler.convertFilePath,error[])
                               ->top.open->THIS(fragmentgroup).origin
                          else
                             ((S.copy,t[])->thePathHandler.convertFilePath,
                             error[])->top.open->THIS(fragmentgroup).origin
                         if);
                         leave FindOrigin;
                         
                      #)
                 #)
             if)
          #)
     #)

-- FragmentGroupScanIncludes: doPart --
do (if includes.empty then
       loadIncludes;
   if);
   includes.scan
   (#
   do current[] -> THIS(ScanIncludes).current[];
      inner scanIncludes;
   #);
   
-- FragmentGroupBindToOrigin: doPart --
do 
   (if origin = NONE then
       setupOrigin;
   if);
   (if origin <> NONE then
       f[] -> (origin).bind -> op[];
       (if op[] = NONE then
           f[] -> (origin).bindToOrigin -> op[];
       if);
   if);
-- FragmentGroupBind: doPart --
do search: scanSlots
     (#
     do  
        (if current.name -> (f.name).equalNCS then
            current[] -> op[] -> f.binding[];
            leave search;
        if);
     #);
   (if OP[] = NONE then
       (if origin = NONE then
           setupOrigin;
       if);
       (if origin <> NONE then
           f[] -> (origin).bind -> op[];
       if);
   if);
   
-- FragmentGroupScanSlots: doPart --
do scan
   (# frag: ^FragmentForm;
   do current[] -> frag[];
      frag.scanSlots
      (#
      do current[] -> THIS(ScanSlots).current[];
         inner ScanSlots;
      #);
   #);

-- FragmentGroupIncludeFullName: doPart --
do (# t: ^Text;
   do THIS(fragment).fullName->stripPathName->t[];
      (if t[] = NONE then
          (linkname[], currentDirectory) 
            -> thePathHandler.convertFilePath 
            -> theFullName[];
       else
          (linkname[], t[]) 
            -> thePathHandler.convertFilePath 
            -> theFullName[];
      if);
   #);

-- FragmentGroupLoadIncludes: doPart --
do includes.clear;
   prop.scanProp
   (# doProp::
        (#
        do (if 'include'->prop.equalNCS then
               scanParameters
               (# doString::
                    (# l: ^Include;
                    do &Include[]->l[];
                       s.copy->l.linkName[];
                       l[] -> includes.append;
                    #)
               #);
           if);
        #);
   #)

-- FragmentGroupSaveFailure: doPart --
do 

-- FragmentGroupSave: doPart --
do saving:
     (# output: @File
          (# binary:: (# do true -> value #);
          #);
        filename: ^Text;
     do (fullname).copy -> filename[];
        '.byt' -> filename.append;
        filename[] -> output.name;
        output.openWrite;
        output[] -> pack;
        output.close;
        output.entry.modtime (# error:: (# do true -> continue #) #) -> modtime;
     #);

-- FragmentGroupLoadFailure: doPart --
do 

-- FragmentGroupLoad: doPart --
do loading:
     (# input: @File
          (# binary:: (# do true -> value #);
          #);
        filename: ^Text;
        
        stripExtension:
          (# path: ^text;
             stripped: ^text;
             dotPos: @integer;
             slashPos: @integer;
             
          enter path[]
          do (if path[] <> NONE then
                 (if path.length > 0 then
                     directoryChar -> path.findAll
                     (#
                     do inx -> slashPos;
                     #);
                     '.' -> path.findAll
                     (#
                     do inx -> dotPos;
                     #);
                     (if dotPos > slashPos then
                         (1, dotpos -1) -> path.sub -> stripped[];
                      else
                         path.copy -> stripped[]
                     if);
                     
                 if);
             if);
          exit stripped[]
          #);
        fullname: ^Text;
     do name[] -> expandToFullPath -> fullname[];
        fullname[] -> stripExtension -> fullname[];
        fullname.copy -> filename[];
        '.byt' -> filename.append;
        filename[] -> input.name;
        fullname.copy -> THIS(FragmentGroup).fullname;
        fullname.copy -> THIS(FragmentGroup).name;
        input.openRead;
        input[] -> unpack;
        input.close;
        input.entry.modtime (# error:: (# do true -> continue #) #) -> modtime;
     #);


-- FragmentGroupPack: doPart --
do (#
   do groupMagicNumber1 -> output.putInt32u;
      groupMagicNumber2 -> output.putInt32u;
      groupVersion -> output.putInt32u;
      output[] -> prop.pack;
      fragmentlist.size -> output.putInt32u;
      fragmentlist.scan
      (#
      do current.name -> output.putBinText;
         output[] -> current.pack;
      #);
      
   #);

-- FragmentGroupUnpack: doPart --
do unpacking:
     (# magic1, magic2: @int32u;
        version: @int32u;
        no: @integer;
        frag: ^fragmentForm;
        data: ^Text;
     do input.getInt32u -> magic1;
        (if magic1 <> groupMagicNumber1 then
            'wrong magic' -> putline;
            leave unpacking;
        if);
        input.getInt32u -> magic2;
        (if magic2 <> groupMagicNumber2 then
            'wrong magic' -> putline;
            leave unpacking;
        if);
        input.getInt32u -> version;
        (if version > groupVersion then
            'wrong version' -> putline;
            leave unpacking;
        if);
        &PropertyList[] -> prop[];
        input[] -> prop.unPack;
        input.getInt32u -> no;
        (for no repeat
             grammartable.beta[] -> newFragmentForm -> frag[];
             input.getBinText -> frag.nameT[];
             input[] -> frag.unPack;
             frag[] -> fragmentList.append;
             THIS(FragmentGroup)[] -> frag.father;
             fullnameT.copy -> frag.fullnameT[];
             '-' -> frag.fullnameT.append;
             frag.nameT[] -> frag.fullnameT.append;
        for);
     #);
   
-- AstInterfaceTopOpen: doPart --
do opengroup:
     (# input: @File;
        parse: @PropertyParser
          (# syntaxerror::
               (#
               do msg.newline;
                  'while parsing: "' -> msg.putline;
                  fullname[] -> msg.puttext;
                  '"' -> msg.puttext;
               #);
          #);
        beta: ^TreeLevel;
        frag: ^FragmentForm;
        fragname, cat: ^text;
        fullname: ^text;
        betFileName: ^text;
        killImps:
          (# exp: ^expanded;
          enter exp[]
          do 31 -> exp.suffixWalkForProd
             (#
             do NONE -> current.son[];
             #);
          #);
        compact: (# exit false #);
        dummy: @fragmentgroup;

        stripExtension:
          (# path: ^text;
             stripped: ^text;
             dotPos: @integer;
             slashPos: @integer;
             
          enter path[]
          do (if path[] <> NONE then
                 (if path.length > 0 then
                     directoryChar -> path.findAll
                     (#
                     do inx -> slashPos;
                     #);
                     '.' -> path.findAll
                     (#
                     do inx -> dotPos;
                     #);
                     (if dotPos > slashPos then
                         (1, dotpos -1) -> path.sub -> stripped[];
                      else
                         path.copy -> stripped[]
                     if);
                     
                 if);
             if);
          exit stripped[]
          #);
        
        bytfile: @file;
     do  name[] -> expandToFullPath -> fullname[];
        fullname[] -> stripExtension -> fullname[];
        
        
        fullname[] -> dummy.fullname;
        dummy[]->grouptable.hashfunction
          ->grouptable.findIndexed
        (# predicate::  (#  do fullname[]->(current.fullname).equalNCS->value #);
        do current[] -> group[];
        #);
        (if group[] <> NONE then
            leave openGroup;
        if);
        
        
        
        
        newFragmentGroup -> group[];
        fullname.copy -> group.name;
        fullname.copy -> group.fullname;
        
        group[] -> grouptable.insert;
        
        
        '.byt' -> (fullname.copy).append -> bytfile.name;
        
        (if bytfile.entry.exists then
            bytfile.openRead;
            bytfile[] -> group.unPack;
            bytfile.close;
            bytfile.entry.modtime -> group.modtime;
            leave openGroup;
        if);
        
        grammarTable.beta[] -> beta[];
        '.bet' -> (fullname.copy).append -> input.name;
        input.openRead;
        input[] -> parse.init;
        parse.parsePropertyList -> group.prop[];
        false -> beta.parser.trace;
        parse.advance;
        loop:
          (if parse.token = parse.tokens.name then
              parse.lex.gettext -> fragname[];
              parse.advance;
              (if parse.token = parse.tokens.colon then
                  parse.advance;
                  (if parse.token = parse.tokens.name then
                      parse.lex.gettext -> cat[];
                      parse.advance;
                      (if parse.token = parse.tokens.dash then
                          beta[] -> newFragmentForm -> frag[];
                          fragname[] -> frag.name;
                          fragname.copy -> fragname[];
                          '-' -> fragname.prepend;
                          fullname[] -> fragname.prepend;
                          fragname[] -> frag.fullname;
                          (if true
                           //'dopart' -> cat.equalNCS then
                              (31, input[], frag[]) -> beta.parser.parse -> frag.root[];
                           //'mainpart' -> cat.equalNCS then
                              (5, input[], frag[]) -> beta.parser.parse -> frag.root[];
                           else  
                              (1, input[], frag[]) -> beta.parser.parse -> frag.root[];
                          if);
                          (if frag.root[] <> NONE then
                              (if compact then
                                  frag.root[] -> killImps;
                              if);
                              frag[] -> group.fragmentList.append;
                              group[] -> frag.father;
                              beta.parser.lastCH -> parse.lex.ch;
                              parse.advance;
                              restart loop;
                          if);
                      if);
                  if);
              if);
          if);
        input.close;
        group.save;
     #);
-- AstInterfacePrivate: descriptor --
(#
   errMsg: @
     (# msg: [10] ^text;
        isWarn: [10] @ boolean;
        top: @integer;
        clear: 
          (# 
          do 0 -> top;
             (for i: isWarn.range repeat false -> isWarn[i] for)
          #);
        addMsg:
          (# m: ^text
          enter m[]
          do (if (top+1 -> top) > msg.range then
                 msg.range -> msg.extend;
                 isWarn.range -> isWarn.extend;
             if);
             m[] -> msg[top][];
             inner addMsg
          exit  top
          #);
        addErrorMsg:  addMsg(##);
        addWarning: addMsg(# do true -> isWarn[top] #);
        getMsg:
          (# no: @integer; m: ^text
          enter no
          do (if (0<no) and (no <= top) then
                 msg[no][] -> m[]
             if)
          exit m[]
          #);
        isWarning: booleanValue
          (# no: @integer
          enter no
          do 
             (if (0<no) and (no<=top) then
                 isWarn[no] -> value
             if)
          #);
     #)
#)

