ORIGIN '../astlevel';
INCLUDE '../propertyparser';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/basiclib/binfile';

INCLUDE '../bytestream';
INCLUDE '../donecheck';
INCLUDE '../betacfl';


-- AstInterfaceLib: attributes --


groupMagicNumber1: (# exit 0x79657321 #);
groupMagicNumber2: (# exit 0x6173742E #);
groupVersion: (# exit 1 #);


-- FragmentFormLib: attributes --


packAst:
  (# output: ^Stream;
     table: @ContainerList
       (# element:: Ast;
       #);
     index: @integer;
     exp: ^Expanded;
  enter output[]
  do root[] -> exp[];
     exp.suffixWalk
     (#
     do index + 1 -> index;
        index -> current.inx;
        current[] -> table.append;
     #);
     index -> THIS(FragmentForm).table.new;
     table.scan
     (# 
     do current[] -> THIS(FragmentForm).table[current.inx][];
     #);
     
     index -> output.putInt32u;
     
     table.scan
     (# slot: ^SlotDesc;
     do (if current.symbol = prodNo.unExpanded then
            (if current.isSlot then
                current.theSlot -> slot[];
                slot.category -> output.putInt16u;
             else
                prodNo.unExpanded -> output.putInt16u;
            if);
         else
            current.symbol -> output.putInt16u;
        if);
     #);
     table.scan
     (# theLexemText: ^LexemText;
     do current.astkind -> output.putInt8u;
        current.status -> output.putInt8u;
        (if current.son[] = NONE then
            0 -> output.putInt32u;
         else
            current.son.inx -> output.putInt32u;
        if);
        (if current.brother[] = NONE then
            0 -> output.putInt32u;
         else
            current.brother.inx -> output.putInt32u;
        if);
        
        (if current.symbol < 0 then
            (if current.symbol
             //prodNo.nameAppl
             //prodNo.nameDecl
             //prodNo.string
             //prodNo.const then
                current[] -> theLexemText[];
                theLexemText.getText -> output.putBinText;
            if);
        if);
     #);
     (if firstSlot[] = NONE then
         0 -> output.putInt32u;
      else
         firstSlot.inx -> output.putInt32u;
     if);
  #);
unPackAst:
  (# size: @integer;
     symbol: @int16;
     input: ^Text;
     index: @integer;
     current: ^AST;
     
     symbolToAst: ^treelevel.symbolToAst;
     
     theLexemText: ^LexemText;
     pos: @integer;
     
     
     getInt8u: @
       (# value: @int8u;
       do input.T[pos] -> value;
          pos + 1 -> pos;
       exit value
       #);
     getInt16u: @
       (# value: @int16u;
       do (input.T[pos] %sll 8) %bor input.T[pos+1] -> value;
          pos + 2 -> pos;
       exit value
       #);
     getInt32u: @
       (# value: @int32u;
       do (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> value;
          pos + 4 -> pos;
       exit value
       #);
      theSlot: ^SlotDesc;
  enter input[]
  do &grammartable.beta.symbolToAst[] -> symbolToAst[];
     1 -> pos;
     (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> size;
     
     
     pos + 4 -> pos;
     size -> table.new;
     
     (for inx: size repeat
	  (input.T[pos] %sll 8) %bor input.T[pos+1] -> symbol;
          pos + 2 -> pos;
          symbol -> symbolToAst -> table[inx][];
          THIS(FragmentForm)[] -> table[inx].form[];
          inx -> table[inx].inx;
     for);
     
     (for inx: size repeat
          table[inx][] -> current[];
	  input.T[pos] -> current.astKind;
          pos + 1 -> pos;
	  input.T[pos] -> current.status;
          pos + 1 -> pos;
	  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> index;
          pos + 4 -> pos;
          (if index > 0 then
              (if index <= table.range then
                  table[index][] -> current.son[];
                  (if current.son.symbol = prodNo.SlotDesc then
		      current.son[] -> theSlot[];
		      current.symbol -> theSlot.category;
                      prodNo.unExpanded -> current.symbol;
                  if);
              if);
          if);
	  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> index;
          pos + 4 -> pos;
          (if index > 0 then
              (if index <= table.range then
                  table[index][] -> current.brother[];
              if);
          if);
          (if current.symbol < 0 then
              (if current.symbol
               //prodNo.nameAppl
               //prodNo.nameDecl
               //prodNo.string
               //prodNo.const then
                  current[] -> theLexemText[];
		  (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> theLexemText.lgth;
                  pos + 4 -> pos;
		  theLexemText.lgth -> theLexemText.value.new;
		  (for inx: theLexemText.lgth repeat
		     input.T[pos] -> theLexemText.value[inx];
                     pos + 1 -> pos;
		  for);
              if);
          if);
     for);
     table[1][] -> root[];
     (input.T[pos] %sll 24) %bor (input.T[pos+1] %sll 16) %bor (input.T[pos+2] %sll 8) %bor input.T[pos+3] -> index;
     pos + 4 -> pos;
     (if index > 0 then
         table[index][] -> firstSlot[];
     if);
  #);

packSemanticInfo:
  (# header: ^Text;
     info: ^Text;
     current: ^AST;
     nameApl: ^beta.NameApl;
     nameDcl: ^beta.NameDcl;
     import: [1] ^FragmentForm;
     top: @integer;
     
     fraginx: @integer;
     betagram: ^beta;
     form: ^FragmentForm;
     
  enter (header[], info[])
  do grammartable.beta[] -> betagram[];
     (for inx: table.range repeat
          table[inx][] -> current[];
          (if current## = betagram.nameApl## then
              current[] -> nameApl[];
              nameApl.dclref[] -> nameDcl[];
              (if nameDcl[] = NONE then
                  0 -> info.putInt32u;
                  0 -> info.putInt32u;
               else
                  nameDcl.form[] -> form[];
                  (if form[] = current.form[] then
                      0 -> info.putInt32u;
                   else
                      0 -> fraginx;
                      search:
                        (#
                        do (for inx: top repeat
                                (if import[inx][] = form[] then
                                    inx -> fraginx;
                                    leave search;
                                if);
                           for);
                           top + 1 -> top;
                           (if top > import.range then
                               import.range -> import.extend;
                           if);
                           top -> fraginx;
                           form[] -> import[top][];
                        #);
                      fraginx -> info.putInt32u;
                  if);
                  nameDcl.inx -> info.putInt32u;
              if);
          if);
     for);
     top -> header.putInt32u;
     (for inx: top repeat
          import[inx][] -> form[];
          (form.father).fullname -> header.putBinText;
          form.name -> header.putBinText;
     for);
  #);
unPackSemanticInfo:
  (# header, info: ^Text;
     import: [0] ^FragmentForm;
     nameApl: ^beta.nameApl;
     current: ^AST;
     betagram: ^beta;
     forminx, dclinx: @integer;
     top: @integer;
     fullname: ^Text;
     name: ^Text;
     group: ^FragmentGroup;
  enter (header[], info[])
  do grammartable.beta[] -> betagram[];
     header.reset;
     info.reset;
     header.getInt32u -> top;
     top -> import.new;
     (for inx: top repeat
          header.getBinText -> fullname[];
          header.getBinText -> name[];
          (fullname[], screen[]) -> THIS(astinterface).top.open -> group[];
          (if group[] <> NONE then
              search: group.scan
                (#
                do (if name[] -> (current.name).equalNCS then
                       current[] -> import[inx][];
                       leave search;
                   if);
                #);
          if);
     for);
     (for inx: table.range repeat
          table[inx][] -> current[];
          (if current## = betagram.nameApl## then
              current[] -> nameApl[];
              info.getInt32u -> forminx;
              info.getInt32u -> dclinx;
              (if forminx = 0 then
                  (if dclinx <> 0 then
                      table[dclinx][] -> nameApl.dclref[];
                  if);
               else
                  import[forminx].table[dclinx][] -> nameApl.dclref[];
              if);
          if);
     for);
  #);

-- FragmentFormCategory: doPart --
do root.symbol -> sy;

-- FragmentFormScanSlots: doPart --
do firstSlot[] -> current[];
   loop:
     (if current[] <> NONE then
         INNER;
         current.nextSlot[] -> current[];
         restart loop; 
     if);
   
-- FragmentFormPack: doPart --
do (# data: ^Text;
      groupID: ^Text;
      header: ^Text;
      info: ^Text;
   do 'pack: ' -> puttext;
      fullname -> putline;
      
      &Text[] -> data[];
      data[] -> packAst;
      data[] -> output.putBinText;
      &Text[] -> header[];
      &Text[] -> info[];
      'A' -> put;
      (header[], info[]) -> packSemanticInfo;
      'B' -> put;
      header[] -> output.putBinText;
      info[] -> output.putBinText;
      'C' -> put;
      newline;
   #);
   
-- FragmentFormUnpack: doPart --
do (# data: ^Text;
      size: @integer;
      header, info: ^Text;
      getBytes: @input.getBytes;
   do 'unpack: ' -> puttext;
      '???' -> putline;
      fullname -> putline;
      input.getInt32u -> size;
      &Text[] -> data[];
      size -> data.T.new;
      (@@data.T[1], size) -> getBytes;
      size -> data.lgth;
      data.reset;
      data[] -> unPackAst;
      'A' -> put;
      input.getBinText -> header[];
      input.getBinText -> info[];
      'B' -> put;
      (header[], info[]) -> unPackSemanticInfo;
      'C' -> put;
      newline;
   #);
   
   
-- FragmentFormRegister: doPart --
do search:
     (#
     do  
        (for inx: importtop repeat
             (if frag[] = import[inx][] then
                 inx -> index;
                 leave search;
             if);
        for);
        importtop + 1 -> importtop;
        (if importtop = import.range then
            importtop -> import.extend;
        if);
        frag[] -> import[importtop][];
        importtop -> index;
     #);
-- FragmentFormLookup: doPart --
do (if (index > 0) AND (index <= importtop) then
       import[index][] -> frag[];
   if);
   
   
-- FragmentGroupScan: doPart --
do fragmentlist.scan
   (#
   do current[] -> this(scan).current[];
      INNER scan;
   #);
   
   
   
-- FragmentGroupSetupOrigin: doPart --
do
   FindOrigin: THIS(fragment).prop.ScanProp
     (#
        doProp::
          (#
          do
             prop.makelc;
             (if 'origin'->prop.equal then
                 ScanParameters
                 (#
                    doString::
                      (# t: ^Text;
                      do
                         THIS(fragment).fullName->stripPathName->t[];
                         (if t[] = none then
                             ((S.copy,currentDirectory)
                               ->thePathHandler.convertFilePath,error[])
                               ->top.open->THIS(fragmentgroup).origin
                          else
                             ((S.copy,t[])->thePathHandler.convertFilePath,
                             error[])->top.open->THIS(fragmentgroup).origin
                         if);
                         leave FindOrigin;
                         
                      #)
                 #)
             if)
          #)
     #)

-- FragmentGroupScanIncludes: doPart --
do (if includes.empty then
       loadIncludes;
   if);
   includes.scan
   (#
   do current[] -> THIS(ScanIncludes).current[];
      inner scanIncludes;
   #);
   
-- FragmentGroupBindToOrigin: doPart --
do 
   (if origin = NONE then
       setupOrigin;
   if);
   (if origin <> NONE then
       f[] -> (origin).bind -> op[];
       (if op[] = NONE then
           f[] -> (origin).bindToOrigin -> op[];
       if);
   if);
-- FragmentGroupBind: doPart --
do search: scanSlots
     (#
     do  
        (if current.name -> (f.name).equalNCS then
            current[] -> op[] -> f.binding[];
            leave search;
        if);
     #);
   (if OP[] = NONE then
       (if origin = NONE then
           setupOrigin;
       if);
       (if origin <> NONE then
           f[] -> (origin).bind -> op[];
       if);
   if);
   
-- FragmentGroupScanSlots: doPart --
do scan
   (# frag: ^FragmentForm;
   do current[] -> frag[];
      frag.scanSlots
      (#
      do current[] -> THIS(ScanSlots).current[];
         inner ScanSlots;
      #);
   #);

-- FragmentGroupIncludeFullName: doPart --
do (# t: ^Text;
   do THIS(fragment).fullName->stripPathName->t[];
      (if t[] = NONE then
          (linkname[], currentDirectory) 
            -> thePathHandler.convertFilePath 
            -> theFullName[];
       else
          (linkname[], t[]) 
            -> thePathHandler.convertFilePath 
            -> theFullName[];
      if);
   #);

-- FragmentGroupLoadIncludes: doPart --
do includes.clear;
   prop.scanProp
   (# doProp::
        (#
        do (if 'include'->prop.equalNCS then
               scanParameters
               (# doString::
                    (# l: ^Include;
                    do &Include[]->l[];
                       s.copy->l.linkName[];
                       l[] -> includes.append;
                    #)
               #);
           if);
        #);
   #)

-- FragmentGroupSaveFailure: doPart --
do INNER;

-- FragmentGroupSave: doPart --
do saving:
     (# output: @File
          (# binary:: (# do true -> value #);
          #);
        filename: ^Text;
     do (fullname).copy -> filename[];
        '.byt' -> filename.append;
        filename[] -> output.name;
        output.openWrite;
        output[] -> pack;
        output.close;
        output.entry.modtime (# error:: (# do true -> continue #) #) -> modtime;
     #);

-- FragmentGroupLoadFailure: doPart --
do 

-- FragmentGroupLoad: doPart --
do loading:
     (# input: @File
          (# binary:: (# do true -> value #);
          #);
        filename: ^Text;
        
        stripExtension:
          (# path: ^text;
             stripped: ^text;
             dotPos: @integer;
             slashPos: @integer;
             
          enter path[]
          do (if path[] <> NONE then
                 (if path.length > 0 then
                     directoryChar -> path.findAll
                     (#
                     do inx -> slashPos;
                     #);
                     '.' -> path.findAll
                     (#
                     do inx -> dotPos;
                     #);
                     (if dotPos > slashPos then
                         (1, dotpos -1) -> path.sub -> stripped[];
                      else
                         path.copy -> stripped[]
                     if);
                     
                 if);
             if);
          exit stripped[]
          #);
        fullname: ^Text;
     do name[] -> expandToFullPath -> fullname[];
        fullname[] -> stripExtension -> fullname[];
        fullname.copy -> filename[];
        '.byt' -> filename.append;
        filename[] -> input.name;
        fullname.copy -> THIS(FragmentGroup).fullname;
        fullname.copy -> THIS(FragmentGroup).name;
        input.openRead;
        input[] -> unpack;
        input.close;
        input.entry.modtime (# error:: (# do true -> continue #) #) -> modtime;
     #);


-- FragmentGroupPack: doPart --
do (#
   do groupMagicNumber1 -> output.putInt32u;
      groupMagicNumber2 -> output.putInt32u;
      groupVersion -> output.putInt32u;
      output[] -> prop.pack;
      fragmentlist.size -> output.putInt32u;
      fragmentlist.scan
      (#
      do current.name -> output.putBinText;
         output[] -> current.pack;
      #);
      
   #);

-- FragmentGroupUnpack: doPart --
do unpacking:
     (# magic1, magic2: @int32u;
        version: @int32u;
        no: @integer;
        frag: ^fragmentForm;
        data: ^Text;
     do input.getInt32u -> magic1;
        (if magic1 <> groupMagicNumber1 then
            'wrong magic' -> putline;
            leave unpacking;
        if);
        input.getInt32u -> magic2;
        (if magic2 <> groupMagicNumber2 then
            'wrong magic' -> putline;
            leave unpacking;
        if);
        input.getInt32u -> version;
        (if version > groupVersion then
            'wrong version' -> putline;
            leave unpacking;
        if);
        &PropertyList[] -> prop[];
        input[] -> prop.unPack;
        input.getInt32u -> no;
        (for no repeat
             grammartable.beta[] -> newFragmentForm -> frag[];
             input.getBinText -> frag.nameT[];
             input[] -> frag.unPack;
             frag[] -> fragmentList.append;
             THIS(FragmentGroup)[] -> frag.father;
             fullnameT.copy -> frag.fullnameT[];
             '-' -> frag.fullnameT.append;
             frag.nameT[] -> frag.fullnameT.append;
        for);
     #);
   
-- AstInterfaceTopOpen: doPart --
do opengroup:
     (# input: @File;
        parse: @PropertyParser
          (# syntaxerror::
               (#
               do msg.newline;
                  'while parsing: "' -> msg.putline;
                  fullname[] -> msg.puttext;
                  '"' -> msg.puttext;
               #);
          #);
        beta: ^TreeLevel;
        frag: ^FragmentForm;
        fragname, cat: ^text;
        fullname: ^text;
        betFileName: ^text;
        killImps:
          (# exp: ^expanded;
          enter exp[]
          do 31 -> exp.suffixWalkForProd
             (#
             do NONE -> current.son[];
             #);
          #);
        compact: (# exit false #);
        dummy: @fragmentgroup;

        stripExtension:
          (# path: ^text;
             stripped: ^text;
             dotPos: @integer;
             slashPos: @integer;
             
          enter path[]
          do (if path[] <> NONE then
                 (if path.length > 0 then
                     directoryChar -> path.findAll
                     (#
                     do inx -> slashPos;
                     #);
                     '.' -> path.findAll
                     (#
                     do inx -> dotPos;
                     #);
                     (if dotPos > slashPos then
                         (1, dotpos -1) -> path.sub -> stripped[];
                      else
                         path.copy -> stripped[]
                     if);
                     
                 if);
             if);
          exit stripped[]
          #);
        
        bytfile: @file (# binary:: (# do true -> value #); #);
     do  name[] -> expandToFullPath -> fullname[];
        fullname[] -> stripExtension -> fullname[];
        
        
        fullname[] -> dummy.fullname;
        dummy[]->grouptable.hashfunction
          ->grouptable.findIndexed
        (# predicate::  (#  do fullname[]->(current.fullname).equalNCS->value #);
        do current[] -> group[];
        #);
        (if group[] <> NONE then
            leave openGroup;
        if);
        
        
        
        
        newFragmentGroup -> group[];
        fullname.copy -> group.name;
        fullname.copy -> group.fullname;
        
        group[] -> grouptable.insert;
        
        
        '.byt' -> (fullname.copy).append -> bytfile.name;
        
        (if bytfile.entry.exists then
            bytfile.openRead;
            bytfile[] -> group.unPack;
            bytfile.close;
            bytfile.entry.modtime -> group.modtime;
            leave openGroup;
        if);
        
        grammarTable.beta[] -> beta[];
        '.bet' -> (fullname.copy).append -> input.name;
        input.openRead;
        input[] -> parse.init;
        parse.parsePropertyList -> group.prop[];
        false -> beta.parser.trace;
        parse.advance;
        loop:
          (if parse.token = parse.tokens.name then
              parse.lex.gettext -> fragname[];
              parse.advance;
              (if parse.token = parse.tokens.colon then
                  parse.advance;
                  (if parse.token = parse.tokens.name then
                      parse.lex.gettext -> cat[];
                      parse.advance;
                      (if parse.token = parse.tokens.dash then
                          beta[] -> newFragmentForm -> frag[];
                          fragname[] -> frag.name;
                          fragname.copy -> fragname[];
                          '-' -> fragname.prepend;
                          fullname[] -> fragname.prepend;
                          fragname[] -> frag.fullname;
                          (if true
                           //'dopart' -> cat.equalNCS then
                              (31, input[], frag[]) -> beta.parser.parse -> frag.root[];
                           //'mainpart' -> cat.equalNCS then
                              (5, input[], frag[]) -> beta.parser.parse -> frag.root[];
                           else  
                              (1, input[], frag[]) -> beta.parser.parse -> frag.root[];
                          if);
                          (if frag.root[] <> NONE then
                              (if compact then
                                  frag.root[] -> killImps;
                              if);
                              frag[] -> group.fragmentList.append;
                              group[] -> frag.father;
                              beta.parser.lastCH -> parse.lex.ch;
                              parse.advance;
                              restart loop;
                          if);
                      if);
                  if);
              if);
          if);
        input.close;
        group.save;
     #);
-- AstInterfacePrivate: descriptor --
(#
   errMsg: @
     (# msg: [10] ^text;
        isWarn: [10] @ boolean;
        top: @integer;
        clear: 
          (# 
          do 0 -> top;
             (for i: isWarn.range repeat false -> isWarn[i] for)
          #);
        addMsg:
          (# m: ^text
          enter m[]
          do (if (top+1 -> top) > msg.range then
                 msg.range -> msg.extend;
                 isWarn.range -> isWarn.extend;
             if);
             m[] -> msg[top][];
             inner addMsg
          exit  top
          #);
        addErrorMsg:  addMsg(##);
        addWarning: addMsg(# do true -> isWarn[top] #);
        getMsg:
          (# no: @integer; m: ^text
          enter no
          do (if (0<no) and (no <= top) then
                 msg[no][] -> m[]
             if)
          exit m[]
          #);
        isWarning: booleanValue
          (# no: @integer
          enter no
          do 
             (if (0<no) and (no<=top) then
                 isWarn[no] -> value
             if)
          #);
     #)
#)

