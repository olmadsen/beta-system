ORIGIN '../dependency';
INCLUDE '../arch';
INCLUDE '~beta/containers/list';
INCLUDE 'xmisk';


-- astInterfaceLib: attributes --

getmodtime:
  (# t: ^Text;
     m: @integer;
  enter t[]
  do '-- getmodtime' -> putline;
  exit m
  #);


-- DependencyGraphLib: attributes --

PrintFN:
  (# fg: ^FragmentGroup;
  enter fg[]
  do fg.fullname -> putline;
  #);
  
Groups: ContainerList
  (# Element:: FragmentGroup;
  #);
  
FunnyGroups: ContainerList
  (# Element:: FunnyElement;
     findGroup:
	    (# name: ^Text;
		    fg: ^FragmentGroup;
		 enter name[]
		 do search: scan
		      (#
				do (if current.g.name -> name.equal then
				      current.g[] -> fg[];
						leave search;
				   if);
				#);
		 exit fg[]
		 #);
  #);
FunnyElement:
   (# g: ^FragmentGroup;
	#);

-- scanNonCompiledLib: attributes --

InsertSubDir:
  (* Inserts the directory name TargetDirectory immedidately before the
   * base name of the entered path name. E.g. if TargetDirectory='sun3'
   * and path='/home/frede/beta/system/v3.9/control' then the result will
   * be:      '/home/frede/beta/system/v3.9/sun3/control'.
   * Another example:  path='fusk' will result in: 'sun3/fusk'.
   *)
  (# path: ^text; dirCh: @text;
     lastSlash,L: @integer;
     asmDir: @boolean
  enter(path[],asmDir)
  do thePathHandler.DirectoryChar -> path.findAll(# do inx -> lastSlash #);
     thePathHandler.DirectoryChar -> dirCh.put;
     (if b2c then
         (# T: @text
         do 'b2c'->T; 3->L;
            (T[],lastSlash+1) -> path.insert;
            (if not asmDir then
                T.clear;
                thePathHandler.DirectoryChar->T.put;
                (T[],lastSlash+4)->path.insert;
                (TargetDirectory[],lastSlash+5) -> path.insert;
                4+TargetDirectory.length->L;
         if)#)
      else
         TargetDirectory.length->L;
         (TargetDirectory[],lastSlash+1) -> path.insert;
     if);
     (dirCh[],lastSlash+1+L)-> path.insert;
     inner;
  exit path[]
  #);

CreateAsmFileName: 
  (# g: ^FragmentGroup; T: ^text
  enter g[]
  do (* nti places the assembler files in the object directory and should
      * therefore send 'false' as asmDir parameter to InsertSubDir. Other
      * platforms should use 'true' as asmDir parameter (especially b2c).
      *)
     (g.NameT.copy,(not nti))
       -> InsertSubDir(#do AsmExt[]->path.append #)
       -> T[]
  exit T[]
  #);
CreateObjFileName: 
  (# g: ^FragmentGroup; T: ^text
  enter g[]
  do (g.NameT.copy,false)
       -> InsertSubDir(# do BinExt[] -> path.append #)
       -> T[]
  exit T[]
  #);



-- scannerLib: attributes --

CloseGroup:
  (# g: ^fragmentGroup
  do INNER;
  exit this(closeGroup)[]
  #);
  

ProcessGroupByName:
  (# name: ^Text;
     fg: ^FragmentGroup;
  enter name[]
  do (name[], screen[]) -> top.open -> fg[];
	  (if fg[] <> NONE then
		  fg[] -> ProcessGroup;
	  if);
  #);
ProcessGroup:
  (# fg: ^FragmentGroup;
  enter fg[]
  do (if fg.controller.status < ProcessMark then
        fg[] -> beforeGroup;
        ExamineMark -> fg.controller.status;
        (if fg.origin = NONE then
		      fg.setupOrigin;
		  if);
		  (if fg.origin <> NONE then
		      fg.origin -> &ProcessGroup;
	     if);
		  fg.scanIncludes
		    (#
		    do current.fullname -> ProcessGroupByName;
			 #);
		  ProcessMark -> fg.controller.status;
		  (if (fg[] -> afterGroup) then
		    fg[] -> addTranslate;
		  if);
		  fg[] -> ProcessProperties;
		  
     if);
  #);
ProcessProperties:
  (# fg: ^FragmentGroup;
  enter fg[]
  do fg.prop.scanProp
			(#
				doProp::
				  (# t: ^text;
					  on: @boolean;
				  do prop.makelc;
					  (if true
						//'body' -> prop.equal then
							
							fg.fullname -> stripPathName -> t[];
							(if t[] = NONE then
								 currentDirectory -> t[];
							if);
							scanParameters
							(# doString::
								  (#
								  do (s[], t[]) -> thePathHandler.convertFilePath -> ProcessBodyByName;
								  #)
							#);
							
						//'mdbody' -> prop.equal then
							fg.fullname -> stripPathName -> t[];
							false -> on;
							scanParameters
							(# doName::
								  (#
								  do (if TargetMachine[] -> n.equal then
											true -> on;
										else
											false -> on;
									  if);
								  #);
								doString::
								  (#
								  do (if on then
											(s[], t[]) -> thePathHandler.convertFilePath -> ProcessBodyByName;
									  if);
								  #)
							#);
					  if);
				  #);
			#);
  #);
ProcessBodyByName:
  (# name: ^Text;
     fg: ^FragmentGroup;
  enter name[]
  do (name[], screen[]) -> top.open -> fg[];
	  (if fg[] <> NONE then
		  (if fg.controller.status <> ProcessMark then
		     fg[] -> DGP.bodyqueue.append;
		  if);
	  if);
  #);


-- DependencyGraphPrivate: descriptor --
(# bodyqueue: @Groups;
   translist: @Groups;
	grouplist: @FunnyGroups;
	hasProgramSlot: @boolean;
#)

-- DependencyGraphInit: doPart --
do current_machine -> TargetMachine[] -> TargetDirectory[];
   (if infoStream[] = NONE then
		screen[] -> infoStream[];
	if);
	(if messageStream[] = NONE then
		screen[] -> messageStream[];
	if);
	(if traceStream[] = NONE then
		screen[] -> traceStream[];
	if);
	(if errorStream[] = NONE then
		screen[] -> errorStream[];
	if);
	INNER;
			
-- DependencyGraphScanNonCompiledAddTranslate: doPart --
do fg[] -> DGP.translist.append;
   INNER;

-- DependencyGraphScanNonCompiled: doPart --
do root[] -> ProcessGroupByName;
   loop:
       (if not DGP.bodyqueue.empty then
           (DGP.bodyqueue.head -> DGP.bodyqueue.delete).elm[] -> ProcessGroup;
           restart loop;
       if);
	DGP.translist.scan
	  (#
	  do current[] -> translate;
	     current[] -> THIS(ScanNonCompiled).current[];
        INNER ScanNonCompiled;
		#);
   DGP.translist.clear;
