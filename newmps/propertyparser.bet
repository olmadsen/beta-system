ORIGIN 'astlevel';
INCLUDE 'propertylist';


-- AstInterfaceLib: Attributes --

PropertyParser:
  (* Recursive-descend parser for the grammar:
   * 
   *   <group> ::= <propertyList>;
   *   <propertyList> ::= <property> {';' property}* ;
   *   <property> ::| <predefined property>
   *                | <auxilary property> ;
   *   <predefined property> ::| <origin property> | <include property>
   *                           | <body property> | <mdbody property> ;
   *   <origin property>  ::= 'ORIGIN'  STRING                     ;
   *   <include property> ::= 'INCLUDE' STRING      {STRING}*      ;
   *   <body property>    ::= 'BODY'    STRING      {STRING}*      ;
   *   <mdbody property>  ::= 'MDBODY'  NAME STRING {NAME STRING}* ;
   *   <auxilary property>::= <propertyName> {NAME | STRING | CONST}* | EMPTY ;
   *   
   * Lexical tokens: --(-)* [[ ]] ; : NAME STRING CONST EOF
   * 
   *)
  (# token: @integer;
     syntaxError:< exception
       (# what: ^text;
       enter what[]
       do (if what[] <> NONE then
              what[] -> msg.append;
              msg.newline;
              'looking at: "' -> msg.puttext;
              lex.ch -> msg.put;
              '"' -> msg.put;
          if);
          INNER;
       #);
     inputpos, lastOKpos: @integer;
     
     
     markError:
       (# whatToBeExpected: ^Text;
          noOfTerminals: @integer;
       enter (whatToBeExpected[], noOfTerminals)
       do (# N: @integer;
             beforeText: @Text;
             get: @input.get;
             ch: @char;
             print, oldPrint: @boolean;
             startLineNo, lineNo: @integer;
             pos, first, beforePos: @integer;
             constructLegals:
               (# symb: ^ParseSymbolDescriptor; 
               do &ParseSymbolDescriptor[] -> symb[];
                  noOfTerminals -> symb.terminals.new;
                  whatToBeExpected.reset;
                  (for i: NoOfTerminals repeat
                       whatToBeExpected.getAtom -> symb.terminals[i][]; 
                  for)
               exit symb[]
               #);
          do input.reset;
             error[] -> theErrorReporter.errorstream[];
             &FragmentForm[] -> theErrorReporter.frag[];
             theErrorReporter.beforeFirstError;
             1 -> lineNo;
             1 -> N;
             
              Loop: (if (N <= 1) then
                        print -> oldPrint;
                        (lastOkPos-100) <= pos -> print;
                        
                        (if print then
                            (if oldPrint then
                                (if (beforeText.length > 100) then
                                    startLineNo + 1 -> startLineNo;
                                    test: ascii.newLine -> beforeText.findAll
                                    (# 
                                    do inx + beforePos -> beforePos;
                                       (1,inx) -> beforeText.delete; 
                                       leave test 
                                    #);
                                if)          
                             else
                                beforeText.clear; 
                                pos -> beforePos;
                                lineNo -> startLineNo;
                            if);
                        if); 
                        lineNo+1->lineNo; pos->first;
                        readLine:
                          (# 
                          do (if input.eos then ch=ascii.newline; leave readLine if);
                             pos+1->pos;
                             get->ch;
                             (if print then ch -> beforeText.put if);
                             (if ch=ascii.newline then leave readLine if);
                             restart readLine;
                          #);
                        
                        (if print then
                            mark:
                              (if (lastokpos <= pos) then 
                                  (lastokpos, startLineNo, beforeText,
                                  lastokpos - beforePos, constructLegals)
                                    -> theErrorReporter.forEachError;
                                  N+1 -> N;
                              if);
                        if);
                        restart Loop
                    if);
             
             theErrorReporter.afterLastError;
             syntaxError;
          #);
       #);
       
     lexer:
       (# inputget: ^stream.get;
          inputeos: ^stream.eos;
          ch: @char;
          
          
          buffer: [256] @char;
          buffertop: @integer;
          put: @
            (#
            do buffertop + 1 -> buffertop;
               (if buffertop = buffer.range then
                   buffertop -> buffer.extend;
               if);
               ch -> buffer[buffertop];
            #);
          scan:
            (# ch: @char;
            do (for inx: buffertop repeat
                    buffer[inx] -> ch;
                    inner;
               for);
            #);
          getText: 
            (# value: ^text;
            do &Text[] -> value[];
               scan
               (#
               do ch -> value.put;
               #);
            exit value[]
            #);
          
          nextch: @
            (#
            do (if inputeos then
                   ascii.fs -> ch;
                else
                   inputget -> ch;
                   inputpos + 1 -> inputpos;
               if);
            #);
          init:
            (# input: ^stream;
            enter input[]
            do &input.get[] -> inputget[];
               &input.eos[] -> inputeos[];
               nextch;
            #);
          token: @integer;
       do 0 -> buffertop;
          tokens.UNKNOWN -> token;
          getToken:
            (#
            do  skip:
                 (if ch -> ascii.isSpace then
                     nextch;
                     restart skip;
                 if);
               inputpos -> lastokpos;
               (if ch
                //'(' then
                   nextch;
                   (if ch = '*' then
                       (* Read comment *)
                       readComment:
                         (if ch = '*' then
                             nextch;
                             (if ch = ')' then
                                 nextch;
                                 restart getToken;
                              else
                                 restart readComment;
                             if);
                          else
                             nextch;
                             restart readComment;
                         if);
                   if);
                   
                //'\'' then
                   (* read string *)
                   nextch;
                   readString:
                     (if ch
                      //'\'' then
                         nextch;
                         leave readstring;
                      //ascii.newline then
                         ('End-of-line is not allowed in strings', 6) -> markError;
                      //ascii.fs then
                         ('End-of-line is not allowed in strings', 6) -> markError;
                      else
                         put;
                         nextch;
                         restart readstring;
                     if);
                   tokens.string -> token;
                //'-' then
                   (* read dashes *)
                   readDashes:
                     (if ch = '-' then
                         nextch;
                         restart readDashes;
                     if);
                   tokens.dash -> token;
                //';' then
                   nextch;
                   tokens.semicolon -> token;
                //':' then
                   nextch;
                   tokens.colon -> token;
                //ascii.fs then
                   tokens.EOS -> token;
                else
                   (if ch -> ascii.isLetter then
                       (* read  name *)
                       put;
                       nextch;
                       readName:
                         (if (ch -> ascii.isLetter) or (ch -> ascii.isDigit) or (ch = '_') then
                             put;
                             nextch;
                             restart readName;
                         if);
                       tokens.name -> token;
                    else
                       (if ch -> ascii.isdigit then
                           (* read const *)
                           put;
                           nextch;
                           readConst:
                             (if (ch -> ascii.isDigit) then
                                 put;
                                 nextch;
                                 restart readConst;
                             if);
                           tokens.const -> token;
                       if);
                   if);
               if);
            #);
       exit token
       #);
     tokens: @
       (# name: (# exit 1 #);
          string: (# exit 2 #);
          const: (# exit 3 #);
          dash: (# exit 4 #);
          semicolon: (# exit 5 #);
          EOS: (# exit 6 #);
          colon: (# exit 7 #);
          UNKNOWN: (# exit 8 #);
       #);
     
     lex: @lexer;
     advance: @
       (#
       do lex -> token;
       #);
     Parser:
       (# 
          
          
          init:
            (# input: ^Stream;
            enter input[]
            do input[] -> lex.init;
               advance;
            #);
          
          ParseProperty:
            (# prop: ^Property;
               name: ^text;
               parseOrigin:
                 (#
                 do (if token = tokens.string then
                        lex.getText -> prop.addString;
                        advance;
                        (if token
                         //tokens.EOS
                         //tokens.semicolon
                         //tokens.dash then
                            (** fine **)
                         else
                            (';', 1)  -> markError;
                        if);
                     else
                        ('STRING', 1) -> markError;
                    if);
                 #);
            do &Property[] -> prop[];
               lex.getText -> name[];
               name[] -> prop.name[];
               advance;
               
               (if true
                //'ORIGIN' -> name.equalNCS then
                   parseOrigin;
                else
                   loop:
                     (if token
                      //tokens.name then
                         lex.getText -> prop.addName;
                         advance;
                         restart loop;
                      //tokens.string then
                         lex.getText -> prop.addString;
                         advance;
                         restart loop;
                      //tokens.const then
                         lex.getText -> prop.addConst;
                         advance;
                         restart loop;
                      //tokens.semicolon then
                         leave loop;
                      //tokens.dash then
                         leave loop;
                     if);
               if);
            exit prop[]
            #);
          ParsePropertyList:
            (# prop: ^PropertyList;
            do &PropertyList[] -> prop[];
               loop:
                 (if token
                  //tokens.name then
                     ParseProperty -> prop.properties.append;
                     restart loop;
                  //tokens.semicolon then
                     advance;
                     restart loop;
                  //tokens.dash then
                     leave loop;
                  //tokens.EOS then
                     leave loop;
                 if);
            exit prop[]
            #);
       #);
     parse: @parser;
     input: ^Stream;
     error: ^Stream;
     init:
       (#
       enter (input[], error[])
       do input[] -> parse.init;
       #);
     ParsePropertyList:
       (# prop: ^PropertyList;
       do parse.parsePropertyList -> prop[];
       exit prop[]
       #);
  #);
