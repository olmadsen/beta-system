ORIGIN 'astlevel';
INCLUDE '~beta/basiclib/file';


BODY 'private/dependencybody';


-- astInterfaceLib: attributes --


(* 
 * This a new implementation of DependencyGraph-building using real syntax
 * trees.
 *
 * NOTE: There are two versions of scanning the dependencygraph.
 *
 *       - The first version is "scanNonCompiled" this is used by
 *         the compiler and will only process the part of the
 *         the dependencygraph that needs attention by the compiler.
 *
 *       - The second version is "scanExtent" + "scanDomain". This
 *         processes the entire dependency graph and is used by tools.
 *         
 *       This fragment only implements the compilerversion.
 *)
DependencyGraph:
  (# <<SLOT DependencyGraphLib: attributes>>;
     TargetDirectory, TargetMachine: ^text;
     infoStream, messageStream, traceStream, errorStream: ^Stream;
	  
	  init:<
	    (#
		 enter (infoStream[], messageStream[], traceStream[], errorStream[])  
		 <<SLOT DependencyGraphInit: doPart>>
		 
		 #);
	  
	  scanNonCompiled: scanner
	    (# <<SLOT scanNonCompiledLib: attributes>>;
		    translate:<
		      (# fg: ^fragmentGroup
				enter fg[]
				do INNER
				#);
			 addTranslate::<
			   (#
				<<SLOT DependencyGraphScanNonCompiledAddTranslate: doPart>>
				#);
			 afterGroup::<
			   (#
				do true -> insert;
				   doCheck -> fg.controller.status;
				   INNER;
				#);
			 theGroup: ^fragmentGroup;
		 <<SLOT DependencyGraphScanNonCompiled: doPart>>
		 #);
	   
	  scanner:
	    (# <<SLOT scannerLib: attributes>>;
		    giveDomain:< BooleanValue; 
		    init:<
			    (# 
				 do root[] -> rootFragment[];
				    INNER 
			    #);
			 beforeGroup:<
			   (* Called before the group is beeing processed. *)
			   (# fg: ^FragmentGroup;
				enter fg[]
				do INNER;
				#);
			 afterGroup:<
			   (* Called after the group has been processed. 
			    * If "insert" is true, the group will be
				 * added to a list of groups needing translation.
				 *)
			   (# fg: ^FragmentGroup;
				   insert: @boolean;
				enter fg[]
				do INNER;
				exit insert
				#);
		    addGroup:<
			   (# fg: ^FragmentGroup;
				enter fg[]
				do INNER;
				#);
		    addTranslate:<
			   (# fg: ^FragmentGroup;
				enter fg[]
				do INNER;
				#);
		    
			 buildProperty:<
			   (# objFile,directory,command: ^text; dependencies: [0]^text;
			   enter (objFile[], directory[], dependencies, command[])
			   do INNER
			   #);
			 currentProperty:<
			   (# propKind: @integer; arg: ^text
	         enter (propKind, arg[])
				do INNER;
				#);
			 
			 
			 isFile:< notification
				 (# F: @file
				 enter F.name
				 do (if not F.entry.exists then
					'*** Warning! Files does not exist: ' -> msg;
					F.name -> msg.puttext;
					INNER
					 if)
				 exit F.name
				 #);
			  DoubleFormException:< exception
				 (# n: ^text
				 enter n[]
				 do INNER
				 #);
			  transAccessException:< exception
				 (# FN: ^text
				 enter FN[]
				 do INNER;
				 #);
			  circularDependencyException:< exception
				 (# fg: ^fragmentGroup
				 enter fg[]
				 do INNER
				 #);
			  unknownPropertyException:< exception
				 (# n: ^text
				 enter n[]
				 do INNER
				 #);
			  emptyFragmentException:< exception
				 (# fg: ^fragmentGroup
				 enter fg[]
				 do INNER
				 #);
			  reloadingNotification:< notification
				 (# doReload: @boolean
				 do true->doReload;
					 INNER
				 exit doReload
				 #);
			  startingParsingNotification:< notification
				 (# FullFN: ^text
				 enter FullFN[]
				 do INNER
				 #);
			  parseException:< exception
				 (# FullFN: ^text
				 enter FullFN[]
				 do INNER;
				 #);
			  transCreateDirException:< exception
				 (# FN: ^text
				 enter FN[]
				 do INNER;
				 #);
			  MPSexception:< exception
				 (# T: ^text;
				 enter T[]
				 do INNER
				 #);
			  notExistingException:< exception
				 (# FullFN: ^text
				 enter FullFN[]
				 do INNER;
				 #);
			  noSpaceException:< exception(#do INNER #);
			  fragmentException:< Exception
				 (# FG: ^fragmentGroup;
					 FF: ^fragmentForm;
					 slot: ^slotDesc;
					 errNo: @integer;
					 errMsg: ^text;
					 CloseGroup: ^object;
				 enter(FG[],FF[],slot[],errNo,errMsg[],CloseGroup[])
				 do INNER
				 #);
			  propertyException:< exception
				 (# FG: ^fragmentGroup;
					 p,t: ^text;
					 n: @integer;
					 CloseGroup: ^Object;
					 warning: @boolean
				 enter(FG[],p[],t[],n,CloseGroup[])
				 do inner
				 #);
			  (* just for the compiler - but odd:-) *)
			  addVirtualSuper:<
				 (# FG: ^FragmentGroup
				 enter fg[]
				 do inner
				 #);
				 
		    asmExt: ^Text;
			 binExt: ^Text;
			 b2c: @boolean;
			 nti: @boolean;
			 xVerboseLevel: @integer;
			 current: ^FragmentGroup;
	       root: ^Text;
	    enter root[]
		 do init;
		    INNER;
		 #);
		 
		 
    (*
	  * The following is the marks used to mark what has been done
	  * to a group.
	  *)
	  
	 OpenMark: (# exit 0 #);     (* The group has just been openend *)
	 ExamineMark: (# exit 2 #);  (* The group is beeing examined *)
	 ProcessMark: (# exit 3 #);  (* The group has been processed (translated) *)
	 
	 rootFragment: ^text;
	  (* Argument values for CurrentPropery *)
     makeProperty: (#exit 1 #);
     objfileProperty: (#exit 2 #);
     libfileProperty: (#exit 3 #);
     linkoptProperty: (#exit 4 #);
     betarunProperty: (#exit 5 #);
     resourceProperty: (#exit 6 #);

     (* FragmentGroup controller.status *)
     doParse: (# exit 8 #);
     doCheck: (# exit 7 #);
     doCodeGen: (# exit 6 #);
     doAsm: (# exit 5 #);
     doNothing: (# exit 4 #);
     doneTranslate: (# exit 3 #);
     beingExamined: (# exit 2 #);
     isOpen: (# exit 1 #);  (* marked as open and in the list of fragments *)
     justOpen: (# exit 0 #); (* initial value; open for the first time *)
     (* A negative values means that the FragmentGroup is
      * not used in last graphs and could be GC'ed.
      *)
		
		
	 useCompact: @boolean;
	 checkAll: @boolean;
	 genAll: @boolean;
	 useFullNAme: @boolean;
	 switch: [20] @boolean;
    DGP: @<<SLOT DependencyGraphPrivate: descriptor>>;
	 
  #);
  