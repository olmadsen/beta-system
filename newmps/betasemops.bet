ORIGIN 'index';
INCLUDE '~beta/sysutils/objinterface';



(* Sematic operations for BETA; extracted from index.bet in order
 * to make it easier to distinguish index.bet from mps/astlevel.bet.
 * 
 * 
 * NOTE: The following description is not up to date:
 *
 * The number of semantic attributes for the differect syntactic 
 * categories of beta as defined in '~beta/betaast/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *        virtSize     4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    onForThis    3 bits 16-31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point 
 * to an ast in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *

 *)
---ASTindexLib:attributes---

getAttribute:
  (# inx: @integer;
     v: @integer;
  enter inx
  do '--[old] getting attribute ' -> puttext;
     inx -> putInt;
     ' of ' -> puttext;
     (if theAst.symbol > 0 then
         theAst.symbol -> theAst.frag.grammar.symbolToName -> putline;
      else
         ' predefined ' -> puttext;
         theAst.symbol -> putint;
         newline;
     if);
  exit v
  #);
putAttribute:
  (# inx: @integer;
     v: @integer;
  enter (v, inx)
  do '--[old] putting attribute ' -> puttext;
     inx -> putInt;
     ' of ' -> puttext;
     (if theAst.symbol > 0 then
         theAst.symbol -> theAst.frag.grammar.symbolToName -> putline;
      else
         ' predefined ' -> puttext;
         theAst.symbol -> putint;
         newline;
     if);
  #);

semanticAttribute:
  (* This is part of reverseengineering of attributes *)
  (#
     access:
       (#
       do '-- attribute: "' -> puttext;
          this(semanticAttribute)[] -> getPatternName -> puttext;
          ' accessed in ' -> puttext;
          (if theAst.symbol > 0 then
              theAst.symbol -> theAst.frag.grammar.symbolToName -> putline;
           else
              ' predefined ' -> puttext;
              theAst.symbol -> putint;
              newline;
          if);
          INNER;
       #);
  #);

descNo:
  (# v: @integer;
     desc: ^beta.DescriptorForm;
     objdesc: ^beta.ObjectDescriptor;
     attr: ^beta.AttributesForm;
     dopart: ^beta.DoPart;
     mainPart: ^beta.MainPart;
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol
           //gram.objectDescriptor then
              theAst[] -> objdesc[];
              v -> objdesc.descno;
           //gram.AttributesForm then
              theAst[] -> attr[];
              v -> attr.descno;
           //gram.DoPart then
              theAst[] -> dopart[];
              v -> dopart.descNo;
           //gram.MainPart then
              theAst[] -> mainPart[];
              v -> mainPart.descNo;
           else
              theAst[] -> desc[];
              v -> desc.descNo;
          if);
       #);
     get: @
       (# gram: @grammar
       do (if theAst.symbol
           //gram.objectDescriptor then
              theAst[] -> objdesc[];
              objdesc.descno -> v;
           //gram.AttributesForm then
              theAst[] -> attr[];
              attr.descno -> v;
           //gram.DoPart then
              theAst[] -> dopart[];
              dopart.descNo -> v;
           //gram.MainPart then
              theAst[] -> mainPart[];
              mainPart.descNo -> v;
           else
              theAst[] -> desc[];
              desc.descNo -> v;
          if);
       exit v
       #);
  enter set
  exit get
  #);

descID:
  (# desc: ^beta.DescriptorForm;
     dopart: ^beta.DoPart;
     objdesc: ^beta.ObjectDescriptor;
     mainpart: ^beta.MainPart;
     set: @
       (# inx: @integer;
          f: ^FragmentForm;
          gram: @grammar;
       enter ((inx, f[]), descNO)
       do (if theAst.symbol = gram.objectDescriptor then
              theAst[] -> objdesc[];
              f[] -> objdesc.frag[];
           else
              theAst[] -> desc[];
              f[] -> desc.frag[];
          if);
       #);
     get: @
       (# t: ^text;
          fg: ^FragmentGroup;
          form: ^FragmentForm;
          p: @integer;
          gram: @grammar;
       do &text[]->t[];
          (if theAst.symbol
           //gram.objectDescriptor then
              theAst[] -> objdesc[];
              objdesc.frag[] -> form[];
           //gram.doPart then
              theAst[] -> dopart[];
              dopart.frag[] -> form[];
           //gram.mainPart then
              theAst[] -> mainpart[];
              mainpart.frag[] -> form[];
           else
              theAst[] -> desc[];
              desc.frag[] -> form[];
          if);
          (if form.root.symbol = gram.attributesForm then
              form.father -> fg[];
              fg.name -> t[];
              thePathHandler.directoryChar -> t.FindAll (# do inx->P #);
              (P+1,t.length) -> t.sub -> t[];
           else
              (form.name).copy -> t[];
          if)
       exit (t[], descNO)
       #);
  enter set
  exit get
  #);
origin: 
  (# v: ^AST;
     objdesc: ^beta.ObjectDescriptor;
     nameapl: ^beta.NameApl;
     forimp: ^beta.ForImp;
     labelled: ^beta.LabelledImp;
     repetitionDecl: ^beta.repetitionDecl;
     
     set: @
       (# gram: @grammar;
       enter v[]
       do (if theAst.symbol
           //gram.objectdescriptor then
              theAst[] -> objdesc[];
              v[] -> objdesc.origin[];
           //gram.nameapl then
              theAst[] -> nameapl[];
              v[] -> nameapl.origin[];
           //gram.forimp then
              theAst[] -> forimp[];
              v[] -> forimp.origin[];
           //gram.LabelledImp then
              theAst[] -> labelled[];
              v[] -> labelled.origin[];
           //gram.repetitionDecl then
              theAst[] -> repetitionDecl[];
              v[] -> repetitionDecl.origin[];
          if);
       #);
     get: @
       (#  gram: @grammar;
       do (if theAst.symbol
           //gram.objectdescriptor then
              theAst[] -> objdesc[];
              objdesc.origin[] -> v[];
           //gram.nameapl then
              theAst[] -> nameapl[];
              nameapl.origin[]  -> v[];
           //gram.forimp then
              theAst[] -> forimp[];
              forimp.origin[]  -> v[];
           //gram.LabelledImp then
              theAst[] -> labelled[];
              labelled.origin[] -> v[];
           //gram.repetitionDecl then
              theAst[] -> repetitionDecl[];
              repetitionDecl.origin[] -> v[];
          if);
       exit v[]
       #);
  enter set
  exit get
  #);
slotOrigin:
  (# v: ^AST;
     slot: ^SlotDesc;
     set: @
       (# 
       enter v[]
       do theAst.theSlot -> slot[];
          v[] -> slot.origin[];
       #);
     get: @
       (#
       do theAst.theSlot -> slot[];
          slot.origin[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
Xorigin:
  (# v: ^AST;
     desc: ^beta.DescriptorForm;
     attr: ^beta.AttributesForm;
     doPart: ^beta.DoPart;
     mainPart: ^beta.MainPart;
     
     set: @
       (# gram: @grammar;
       enter v[]
       do (if theAst.symbol
           //gram.descriptorForm then
              theAst[] -> desc[];
              v[] -> desc.xorigin[];
           //gram.DoPart then
              theAst[] -> doPart[];
              v[] -> doPart.xorigin[];
           //gram.MainPart then
              theAst[] -> mainPart[];
              v[] -> mainPart.xorigin[];
           else
              theAst[] -> attr[];
              v[] -> attr.xorigin[];
          if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol
           //gram.descriptorForm then
              theAst[] -> desc[];
              desc.xorigin[] -> v[];
           //gram.DoPart then
              theAst[] -> doPart[];
              doPart.xorigin[] -> v[];
           //gram.MainPart then
              theAst[] -> mainPart[];
              mainPart.xorigin[] -> v[];
           else
              theAst[] -> attr[];
              attr.xorigin[] -> v[];
          if);
       exit v[]
       #);
  enter set
  exit get
  #);
size:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.size;
       #);
     get: @
       (# 
       do theAst[] -> objdesc[];
          objdesc.size -> v;
       exit v
       #);
  enter set
  exit get
  #);
foroff:
  (# v: @integer;
     forimp: ^beta.ForImp;
     set: @
       (#
       enter v
       do theAst[] -> forimp[];
          v -> forimp.off;
       #);
     get: @
       (#
       do theAst[] -> forimp[];
          forimp.off -> v;
       exit v
       #);
  enter set
  exit get
  #);
attSize:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.attSize;
       #);
     get: @
       (# 
       do theAst[] -> objdesc[];
          objdesc.attSize -> v;
       exit v
       #);
  enter set
  exit get
  #);
virtSize:
  (* Shares space with attSize *)
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.attSize;
       #);
     get: @
       (# 
       do theAst[] -> objdesc[];
          objdesc.attSize -> v;
       exit v
       #);
  enter set
  exit get
  #);
mark:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     
     set: @
       (# gram: @grammar;
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.mark;
       #);
     get: @
       (# gram: @grammar;
       do theAst[] -> objdesc[];
          objdesc.mark -> v;
       exit v
       #);
  enter set
  exit get
  #);
kind:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     
     set: @
       (# gram: @grammar;
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.kind;
       #);
     get: @
       (# gram: @grammar;
       do theAst[] -> objdesc[];
          objdesc.kind -> v;
       exit v
       #);
  enter set
  exit get
  #);
type:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     
     set: @
       (# gram: @grammar;
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.type;
       #);
     get: @
       (# gram: @grammar;
       do theAst[] -> objdesc[];
          objdesc.type -> v;
       exit v
       #);
  enter set
  exit get
  #);
dclRoot:
  (# v: ^AST;
     objdesc: ^beta.ObjectDescriptor;
     attr: ^beta.AttributesForm;
     
     set: @
       (# gram: @grammar;
       enter v[]
       do (if theAst.symbol = gram.attributesForm then
              theAst[] -> attr[];
              v[] -> attr.dclroot[];
           else
              theAst[] -> objdesc[];
              v[] -> objdesc.dclroot[];
          if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.attributesForm then
              theAst[] -> attr[];
              attr.dclroot[] -> v[];
           else
              theAst[] -> objdesc[];
              objdesc.dclroot[] -> v[];
          if);
       exit v[]
       #);
  enter set
  exit get
  #);
lib:
  (# v: ^AST;
     objdesc: ^beta.ObjectDescriptor;
     attr: ^beta.AttributesForm;
     
     set: @
       (# gram: @grammar;
       enter v[]
       do (if theAst.symbol = gram.attributesForm then
              theAst[] -> attr[];
              v[] -> attr.lib[];
           else
              theAst[] -> objdesc[];
              v[] -> objdesc.lib[];
          if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.attributesForm then
              theAst[] -> attr[];
              attr.lib[] -> v[];
           else
              theAst[] -> objdesc[];
              objdesc.lib[] -> v[];
          if);
       exit v[]
       #);
  enter set
  exit get
  #);
next:
  (# v: ^AST;
     slot: ^SlotDesc;
     set: @
       (#
       enter v[]
       do (if theAst.isSlot then
              theAst.theSlot -> slot[];
              v[] -> slot.nextLib[];
           else
              exception
              (#
              do '-- next accessed in ' -> msg.puttext;
                 theAst.symbol -> msg.putint;
              #);
          if);
       #);
     get: @
       (#
       do (if theAst.isSlot then
              theAst.theSlot -> slot[];
              slot.nextLib[] -> v[];
           else
              exception
              (#
              do '-- next accessed in ' -> msg.puttext;
                 theAst.symbol -> msg.putint;
              #);
          if);
       exit v[]
       #);
  enter set
  exit get
  #);
originOff:
  (# v: @int16;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (#
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.originOff;
       #);
     get: @
       (#
       do theAst[] -> objdesc[];
          objdesc.originOff -> v;
       exit v
       #);
  enter set
  exit get
  #);
returnOff:
  (# v: @int16;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (#
       enter v
       do theAst[] -> objdesc[];
          v -> objdesc.returnOff;
       #);
     get: @
       (#
       do theAst[] -> objdesc[];
          objdesc.returnOff -> v;
       exit v
       #);
  enter set
  exit get
  #);
sort:
  (# v: ^AST;
     get:@
       (# gram: @grammar;
       do theAst.father -> v[];
          (if v.symbol <> gram.labelledImp then
              v.father -> v[];
          if);
       exit v[]
       #);
  enter v[]
  exit get
  #);
evalKind:
  (# v: @integer;
     obj: ^beta.ObjectDenotation;
     rep: ^beta.RepetitionSlice;
     
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol = gram.RepetitionSlice then
              theAst[] -> rep[];
              v -> rep.evalKind;
           else
              theAst[] -> obj[];
              v -> obj.evalkind;
          if);
       #);
     get: @
       (#  gram: @grammar;
       do (if theAst.symbol = gram.RepetitionSlice then
              theAst[] -> rep[];
              rep.evalKind -> v;
           else
              theAst[] -> obj[];
              obj.evalkind -> v;
          if);
       exit v
       #);
  enter set
  exit get
  #);
insOff:
  (# v: @integer;
     insertedItem: ^beta.InsertedItem;
     set: @
       (# 
       enter v
       do theAst[] -> insertedItem[];
          v -> insertedItem.insOff;
       #);
     get: @
       (# 
       do theAst[] -> insertedItem[];
          insertedItem.insOff -> v;
       exit v
       #);
  enter set
  exit get
  #);
NXoff: 
  (# v: @integer;
     enterpart: ^beta.EnterPart;
     exitpart: ^beta.ExitPart;
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol = gram.enterPart then
              theAst[] -> enterpart[];
              v -> enterpart.NXoff;
           else
              theAst[] -> exitpart[];
              v -> exitpart.NXoff;
          if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.enterPart then
              theAst[] -> enterpart[];
              enterpart.NXoff -> v;
           else
              theAst[] -> exitpart[];
              exitpart.NXoff -> v;
          if);
       exit v
       #);
  enter set
  exit get
  #);
NXsize: 
  (# v: @integer;
     enterpart: ^beta.EnterPart;
     exitpart: ^beta.ExitPart;
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol = gram.enterPart then
              theAst[] -> enterpart[];
              v -> enterpart.NXsize;
           else
              theAst[] -> exitpart[];
              v -> exitpart.NXsize;
          if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.enterPart then
              theAst[] -> enterpart[];
              enterpart.NXsize -> v;
           else
              theAst[] -> exitpart[];
              exitpart.NXsize -> v;
          if);
       exit v
       #);
  enter set
  exit get
  #);
access:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
          v -> namedcl.access;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.access -> v;
       exit v
       #);
  enter set
  exit get
  #);
off:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
          v -> namedcl.off;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.off -> v;
       exit v
       #);
  enter set
  exit get
  #);
left:
  (# v: ^beta.NameDcl;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v[]
       do theAst[] -> namedcl[];
          v[] -> namedcl.left[];
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.left[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
right:
  (# v: ^beta.NameDcl;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v[]
       do theAst[] -> namedcl[];
          v[] -> namedcl.right[];
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.right[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
virtDcl:
  (# v: ^beta.NameDcl;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v[]
       do theAst[] -> namedcl[];
          v[] -> namedcl.virtDcl[];
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.virtDcl[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
restartAdr:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
          v -> namedcl.restartAdr;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.restartAdr -> v;
       exit v
       #);
  enter set
  exit get
  #);
leaveAdr:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
          v -> namedcl.leaveAdr;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
          namedcl.leaveAdr -> v;
       exit v
       #);
  enter set
  exit get
  #);
dclRef:
  (# v: ^AST;
     nameapl: ^beta.NameApl;
     set: @
       (#
       enter v[]
       do theAst[] -> nameapl[];
          v[] -> nameapl.dclref[];
       #);
     get: @
       (#
       do theAst[] -> nameapl[];
          nameapl.dclref[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
on:
  (# v: @integer;
     nameapl: ^beta.NameApl;
     set: @
       (# 
       enter v
       do theAst[] -> nameapl[];
          v -> nameapl.on;
       #);
     get: @
       (# 
       do theAst[] -> nameapl[];
          nameapl.on -> v;
       exit v
       #);
  enter set
  exit get
  #);
pn: 
  (# v: @integer;
     nameapl: ^beta.NameApl;
     set: @
       (# 
       enter v
       do theAst[] -> nameapl[];
          v -> nameapl.pn;
       #);
     get: @
       (# 
       do theAst[] -> nameapl[];
          nameapl.pn -> v;
       exit v
       #);
  enter set
  exit get
  #);
onForThis:
  (* to put/get recomputed on for this(p) *)
  (# v: @integer;
     nameapl: ^beta.NameApl;
     set: @
       (# 
       enter v
       do theAst[] -> nameapl[];
          v -> nameapl.onForThis;
       #);
     get: @
       (# 
       do theAst[] -> nameapl[];
          nameapl.onForThis -> v;
       exit v
       #);
  enter set
  exit get
  #);
descRef:
  (# v: ^AST;
     nameapl: ^beta.NameApl;
     set: @
       (#
       enter v[]
       do theAst[] -> nameapl[];
          v[] -> nameApl.descref[];
       #);
     get: @
       (#
       do theAst[] -> nameapl[];
          nameApl.descref[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);

eval1:
  (# v: @integer;
     exp: ^beta.Expression;
     set: @
       (# 
       enter v
       do theAst[] -> exp[];
          v -> exp.eval1;
       #);
     get: @
       (# 
       do theAst[] -> exp[];
          exp.eval1 -> v;
       exit v
       #);
  enter set
  exit get
  #);
eval2:
  (# v: @integer;
     exp: ^beta.Expression;
     set: @
       (# 
       enter v
       do theAst[] -> exp[];
          v -> exp.eval2;
       #);
     get: @
       (# 
       do theAst[] -> exp[];
          exp.eval2 -> v;
       exit v
       #);
  enter set
  exit get
  #);

inSameFragment:
  (# N: ^AST
  enter N[]
  exit theAst.frag[] = N.frag[]
  #)
