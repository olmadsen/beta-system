ORIGIN 'newindex';
INCLUDE '~beta/sysutils/objinterface';



(* Sematic operations for BETA; extracted from index.bet in order
 * to make it easier to distinguish index.bet from mps/astlevel.bet.
 * 
 * 
 * NOTE: The following description is not up to date:
 *
 * The number of semantic attributes for the differect syntactic 
 * categories of beta as defined in '~beta/betaast/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *        virtSize     4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    onForThis    3 bits 16-31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point 
 * to an ast in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *

 *)
---ASTindexLib:attributes---

getAttribute:
  (# inx: @integer;
     v: @integer;
  enter inx
  do '-- getting attribute ' -> puttext;
     inx -> putInt;
	  ' of ' -> puttext;
	   (if theAst.symbol > 0 then
			      theAst.symbol -> grammartable.beta.symbolToName -> putline;
			  else
			      ' predefined ' -> puttext;
					theAst.symbol -> putint;
					newline;
			  if);
  exit v
  #);
putAttribute:
  (# inx: @integer;
     v: @integer;
  enter (v, inx)
  do '-- putting attribute ' -> puttext;
     inx -> putInt;
	  ' of ' -> puttext;
	   (if theAst.symbol > 0 then
			      theAst.symbol -> grammartable.beta.symbolToName -> putline;
			  else
			      ' predefined ' -> puttext;
					theAst.symbol -> putint;
					newline;
			  if);
  #);

semanticAttribute:
  (* This is part of reverseengineering of attributes *)
  (#
		access:
		  (#
		  do '-- attribute: "' -> puttext;
		     this(semanticAttribute)[] -> getPatternName -> puttext;
			  ' accessed in ' -> puttext;
			  (if theAst.symbol > 0 then
			      theAst.symbol -> grammartable.beta.symbolToName -> putline;
			  else
			      ' predefined ' -> puttext;
					theAst.symbol -> putint;
					newline;
			  if);
			  INNER;
		  #);
  #);

descNo:
  (# v: @integer;
     desc: ^beta.DescriptorForm;
	  objdesc: ^beta.ObjectDescriptor;
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol = gram.objectDescriptor then
		       theAst[] -> objdesc[];
				 v -> objdesc.descno;
		    else
		    	 theAst[] -> desc[];
		       v -> desc.descNo;
			 if);
       #);
     get: @
       (# gram: @grammar
       do (if theAst.symbol = gram.objectDescriptor then
		       theAst[] -> objdesc[];
				 objdesc.descno -> v;
		    else
		    	 theAst[] -> desc[];
		       desc.descNo -> v;
			 if);
       exit v
       #);
  enter set
  exit get
  #);
  
descID:
  (# inx1: @integer;
     f: ^fragment;
     t: ^text;
  enter ((inx1, f[]), descNo)
  do 'TSTENV' -> t[];
	  descNo -> t.putint;
  exit (t[], descNO)
  #);
origin: 
  (# v: ^AST;
     objdesc: ^beta.ObjectDescriptor;
	  nameapl: ^beta.NameApl;
	  forimp: ^beta.ForImp;
	  labelled: ^beta.LabelledImp;
	  repetitionDecl: ^beta.repetitionDecl;
	  
     set: @
       (# gram: @grammar;
       enter v[]
       do (if theAst.symbol
		 		//gram.objectdescriptor then
				   theAst[] -> objdesc[];
				   v[] -> objdesc.origin[];
				//gram.nameapl then
				  theAst[] -> nameapl[];
				  v[] -> nameapl.origin[];
				//gram.forimp then
				  theAst[] -> forimp[];
				  v[] -> forimp.origin[];
				//gram.LabelledImp then
				  theAst[] -> labelled[];
				  v[] -> labelled.origin[];
				//gram.repetitionDecl then
				   theAst[] -> repetitionDecl[];
				  v[] -> repetitionDecl.origin[];
		    if);
       #);
     get: @
       (#  gram: @grammar;
       do (if theAst.symbol
		 		//gram.objectdescriptor then
				   theAst[] -> objdesc[];
				   objdesc.origin[] -> v[];
				//gram.nameapl then
				  theAst[] -> nameapl[];
				  nameapl.origin[]  -> v[];
				//gram.forimp then
				  theAst[] -> forimp[];
				  forimp.origin[]  -> v[];
				//gram.LabelledImp then
				  theAst[] -> labelled[];
				  labelled.origin[] -> v[];
				//gram.repetitionDecl then
				   theAst[] -> repetitionDecl[];
				  repetitionDecl.origin[] -> v[];
		    if);
       exit v[]
       #);
  enter set
  exit get
  #);
slotOrigin: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
Xorigin:
  (# v: ^AST;
     desc: ^beta.DescriptorForm;
	  attr: ^beta.DescriptorForm;
     set: @
       (# gram: @grammar;
       enter v[]
       do (if theAst.symbol = gram.descriptorForm then
		       theAst[] -> desc[];
		       v[] -> desc.xorigin[];
		    else
			    theAst[] -> attr[];
				 v[] -> attr.xorigin[];
		    if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.descriptorForm then
		       theAst[] -> desc[];
		       desc.xorigin[] -> v[];
		    else
			    theAst[] -> attr[];
				 attr.xorigin[] -> v[];
		    if);
       exit v[]
       #);
  enter set
  exit get
  #);
size:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
		    v -> objdesc.size;
       #);
     get: @
       (# 
       do theAst[] -> objdesc[];
		    objdesc.size -> v;
       exit v
       #);
  enter set
  exit get
  #);
foroff:
  (# v: @integer;
     forimp: ^beta.ForImp;
	  set: @
	    (#
		 enter v
		 do theAst[] -> forimp[];
		    v -> forimp.off;
		 #);
	  get: @
	    (#
		 do theAst[] -> forimp[];
		    forimp.off -> v;
			 exit v
		 #);
  enter set
  exit get
  #);
attSize:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
		    v -> objdesc.attSize;
       #);
     get: @
       (# 
       do theAst[] -> objdesc[];
		    objdesc.attSize -> v;
       exit v
       #);
  enter set
  exit get
  #);
virtSize:
  (* Shares space with attSize *)
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
		    v -> objdesc.attSize;
       #);
     get: @
       (# 
       do theAst[] -> objdesc[];
		    objdesc.attSize -> v;
       exit v
       #);
  enter set
  exit get
  #);
kind:
  (# v: @integer;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (# 
       enter v
       do theAst[] -> objdesc[];
		    v -> objdesc.kind;
       #);
     get:
       (# 
       do theAst[] -> objdesc[];
		    objdesc.kind -> v;
       exit v
       #);
  enter set
  exit get
  #);
dclRoot:
  (# v: ^AST;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (#
       enter v[]
       do theAst[] -> objdesc[];
		    v[] -> objdesc.dclroot[];
       #);
     get: @
       (#
       do theAst[] -> objdesc[];
		    objdesc.dclroot[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
lib:
  (# v: ^AST;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (#
       enter v[]
       do theAst[] -> objdesc[];
		    v[] -> objdesc.lib[];
       #);
     get: @
       (#
       do theAst[] -> objdesc[];
		    objdesc.lib[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
next: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
originOff:
  (# v: @int16;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (#
       enter v
       do theAst[] -> objdesc[];
		    v -> objdesc.originOff;
       #);
     get: @
       (#
       do theAst[] -> objdesc[];
		    objdesc.originOff -> v;
       exit v
       #);
  enter set
  exit get
  #);
returnOff:
  (# v: @int16;
     objdesc: ^beta.ObjectDescriptor;
     set: @
       (#
       enter v
       do theAst[] -> objdesc[];
		    v -> objdesc.returnOff;
       #);
     get: @
       (#
       do theAst[] -> objdesc[];
		    objdesc.returnOff -> v;
       exit v
       #);
  enter set
  exit get
  #);
sort:
  (# v: ^AST;
     get:@
       (# gram: @grammar;
       do theAst.father -> v[];
		    (if v.symbol <> gram.labelledImp then
			    v.father -> v[];
			 if);
       exit v[]
       #);
  enter v[]
  exit get
  #);
evalKind:
  (# v: @integer;
     obj: ^beta.ObjectDenotation;
     set: @
       (# 
       enter v
       do theAst[] -> obj[];
		    v -> obj.evalkind;
       #);
     get: @
       (# 
       do theAst[] -> obj[];
		    obj.evalkind -> v;
       exit v
       #);
  enter set
  exit get
  #);
insOff:
  (# v: @integer;
     insertedItem: ^beta.InsertedItem;
     set: @
       (# 
       enter v
       do theAst[] -> insertedItem[];
		    v -> insertedItem.insOff;
       #);
     get: @
       (# 
       do theAst[] -> insertedItem[];
		    insertedItem.insOff -> v;
       exit v
       #);
  enter set
  exit get
  #);
NXoff: 
  (# v: @integer;
     enterpart: ^beta.EnterPart;
	  exitpart: ^beta.ExitPart;
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol = gram.enterPart then
		       theAst[] -> enterpart[];
				 v -> enterpart.NXoff;
			 else
			    theAst[] -> exitpart[];
				 v -> exitpart.NXoff;
		    if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.enterPart then
		       theAst[] -> enterpart[];
				 enterpart.NXoff -> v;
			 else
			    theAst[] -> exitpart[];
				 exitpart.NXoff -> v;
		    if);
		 exit v
       #);
  enter set
  exit get
  #);
NXsize: 
  (# v: @integer;
     enterpart: ^beta.EnterPart;
	  exitpart: ^beta.ExitPart;
     set: @
       (# gram: @grammar;
       enter v
       do (if theAst.symbol = gram.enterPart then
		       theAst[] -> enterpart[];
				 v -> enterpart.NXsize;
			 else
			    theAst[] -> exitpart[];
				 v -> exitpart.NXsize;
		    if);
       #);
     get: @
       (# gram: @grammar;
       do (if theAst.symbol = gram.enterPart then
		       theAst[] -> enterpart[];
				 enterpart.NXsize -> v;
			 else
			    theAst[] -> exitpart[];
				 exitpart.NXsize -> v;
		    if);
	    exit v
       #);
  enter set
  exit get
  #);
access:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
		    v -> namedcl.access;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.access -> v;
       exit v
       #);
  enter set
  exit get
  #);
off:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
		    v -> namedcl.off;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.off -> v;
       exit v
       #);
  enter set
  exit get
  #);
left:
  (# v: ^beta.NameDcl;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v[]
       do theAst[] -> namedcl[];
		    v[] -> namedcl.left[];
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.left[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
right:
  (# v: ^beta.NameDcl;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v[]
       do theAst[] -> namedcl[];
		    v[] -> namedcl.right[];
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.right[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
virtDcl:
  (# v: ^beta.NameDcl;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v[]
       do theAst[] -> namedcl[];
		    v[] -> namedcl.virtDcl[];
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.virtDcl[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
restartAdr:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
		    v -> namedcl.restartAdr;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.restartAdr -> v;
       exit v
       #);
  enter set
  exit get
  #);
leaveAdr:
  (# v: @integer;
     namedcl: ^beta.NameDcl;
     set: @
       (#
       enter v
       do theAst[] -> namedcl[];
		    v -> namedcl.leaveAdr;
       #);
     get: @
       (#
       do theAst[] -> namedcl[];
		    namedcl.leaveAdr -> v;
       exit v
       #);
  enter set
  exit get
  #);
dclRef:
  (# v: ^AST;
     nameapl: ^beta.NameApl;
     set: @
       (#
       enter v[]
       do theAst[] -> nameapl[];
		    v[] -> nameapl.dclref[];
       #);
     get: @
       (#
       do theAst[] -> nameapl[];
		    nameapl.dclref[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
on:
  (# v: @integer;
     nameapl: ^beta.NameApl;
     set: @
       (# 
       enter v
       do theAst[] -> nameapl[];
		    v -> nameapl.on;
       #);
     get: @
       (# 
       do theAst[] -> nameapl[];
		    nameapl.on -> v;
       exit v
       #);
  enter set
  exit get
  #);
pn: 
  (# v: @integer;
     nameapl: ^beta.NameApl;
     set: @
       (# 
       enter v
       do theAst[] -> nameapl[];
		    v -> nameapl.pn;
       #);
     get: @
       (# 
       do theAst[] -> nameapl[];
		    nameapl.pn -> v;
       exit v
       #);
  enter set
  exit get
  #);
onForThis:
  (* to put/get recomputed on for this(p) *)
  (# v: @integer;
     nameapl: ^beta.NameApl;
     set: @
       (# 
       enter v
       do theAst[] -> nameapl[];
		    v -> nameapl.onForThis;
       #);
     get: @
       (# 
       do theAst[] -> nameapl[];
		    nameapl.onForThis -> v;
       exit v
       #);
  enter set
  exit get
  #);
descRef:
  (# v: ^AST;
     nameapl: ^beta.NameApl;
     set: @
       (#
       enter v[]
       do theAst[] -> nameapl[];
		    v[] -> nameApl.descref[];
       #);
     get: @
       (#
       do theAst[] -> nameapl[];
		    nameApl.descref[] -> v[];
       exit v[]
       #);
  enter set
  exit get
  #);
  
  
eval1:
  (# v: @integer;
     minusExp: ^beta.MinusExp;
	  plusExp: ^beta.PlusExp;
	  intDivExp: ^beta.IntDivExp;
	  ltExp: ^beta.LtExp;
	  modExp: ^beta.modExp;
	  set: @
	    (# gram: @grammar;
		 enter v
		 do (if theAst.symbol
		       //gram.minusExp then
				    theAst[] -> minusExp[];
					 v -> minusExp.eval1;
				 //gram.plusExp then
				    theAst[] -> plusExp[];
					 v -> plusExp.eval1;
				 //gram.intDivExp then
				    theAst[] -> intDivExp[];
					 v -> intDivExp.eval1;
				 //gram.ltExp then
				    theAst[] -> ltExp[];
					 v -> ltExp.eval1;
				 //gram.modExp then
				    theAst[] -> modExp[];
					 v -> modExp.eval1;
			 else
			    '-- setting eval1 of: ' -> puttext;
				 theAst.symbol -> grammartable.beta.symbolToName -> putline;
		    if);
		 #);
	  get: @
	    (# gram: @grammar;
		 do (if theAst.symbol
		       //gram.minusExp then
				    theAst[] -> minusExp[];
					 minusExp.eval1 -> v;
				 //gram.plusExp then
				    theAst[] -> plusExp[];
					 plusExp.eval1 -> v;
				 //gram.intDivExp then
				    theAst[] -> intDivExp[];
					 intDivExp.eval1 -> v;
				 //gram.ltExp then
				    theAst[] -> ltExp[];
					 ltExp.eval1 -> v;
				 //gram.modExp then
				    theAst[] -> modExp[];
					 modExp.eval1 -> v;
			 else
			    '-- getting eval1 of: ' -> puttext;
				 theAst.symbol -> grammartable.beta.symbolToName -> putline;
		    if);
		 exit v
		 #);
  enter set
  exit get
  #);
eval2:
  (# v: @integer;
     minusExp: ^beta.MinusExp;
	  plusExp: ^beta.PlusExp;
	  intDivExp: ^beta.IntDivExp;
	  ltExp: ^beta.LtExp;
	  modExp: ^beta.modExp;
	  set: @
	    (# gram: @grammar;
		 enter v
		 do (if theAst.symbol
		       //gram.minusExp then
				    theAst[] -> minusExp[];
					 v -> minusExp.eval2;
				 //gram.plusExp then
				    theAst[] -> plusExp[];
					 v -> plusExp.eval2;
				 //gram.intDivExp then
				    theAst[] -> intDivExp[];
					 v -> intDivExp.eval2;
				 //gram.ltExp then
				    theAst[] -> ltExp[];
					 v -> ltExp.eval2;
				 //gram.modExp then
				    theAst[] -> modExp[];
					 v -> modExp.eval2;
				 else
			       '-- setting eval2 of: ' -> puttext;
				    theAst.symbol -> grammartable.beta.symbolToName -> putline;
		    if);
		 #);
	  get: @
	    (# gram: @grammar;
		 do (if theAst.symbol
		       //gram.minusExp then
				    theAst[] -> minusExp[];
					 minusExp.eval2 -> v;
				 //gram.plusExp then
				    theAst[] -> plusExp[];
					 plusExp.eval2 -> v;
				 //gram.intDivExp then
				    theAst[] -> intDivExp[];
					 intDivExp.eval2 -> v;
				 //gram.ltExp then
				    theAst[] -> ltExp[];
					 ltExp.eval2 -> v;
				 //gram.modExp then
				    theAst[] -> modExp[];
					 modExp.eval2 -> v;
			 else
			    '-- getting eval2 of: ' -> puttext;
				 theAst.symbol -> grammartable.beta.symbolToName -> putline;
		    if);
		 exit v
		 #);
  enter set
  exit get
  #);

inSameFragment:
  (# N: ^AST
  enter N[]
  exit theAst.frag = N.frag
  #)
