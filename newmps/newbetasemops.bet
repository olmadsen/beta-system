ORIGIN 'newindex';
INCLUDE '~beta/sysutils/objinterface';



(* Sematic operations for BETA; extracted from index.bet in order
 * to make it easier to distinguish index.bet from mps/astlevel.bet.
 * 
 * 
 * NOTE: The following description is not up to date:
 *
 * The number of semantic attributes for the differect syntactic 
 * categories of beta as defined in '~beta/betaast/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    onForThis    3 bits 16-31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point 
 * to an ast in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *

 *)
---ASTindexLib:attributes---


semanticAttribute:
  (* This is part of reverseengineering of attributes *)
  (#
		access:
		  (#
		  do '-- attribute: "' -> puttext;
		     this(semanticAttribute)[] -> getPatternName -> puttext;
			  ' accessed in ' -> puttext;
			  (if theAst.symbol > 0 then
			      theAst.symbol -> grammartable.beta.symbolToName -> putline;
			  else
			      ' predefined ' -> puttext;
					theAst.symbol -> putint;
					newline;
			  if);
			  INNER;
		  #);
  #);

descNo: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
  
descID:
  (# inx1: @integer;
     f: ^fragment;
     t: ^text;
  enter ((inx1, f[]), descNo)
  do '-- ASTindexLib: descID' -> putline;
     'UNKNOW descId' -> t[];
  exit (t[], descNO)
  #);
origin: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
slotOrigin: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
Xorigin: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
size: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
attSize: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
virtSize: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
kind: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
dclRoot: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
lib: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
next: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
originOff: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
returnOff: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
sort: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
evalKind: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
insOff: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
NXoff: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
NXsize: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
access: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
off: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
left: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
right: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
virtDcl: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
restartAdr: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
leaveAdr: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
dclRef: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
on: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
pn: semanticAttribute
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
onForThis: semanticAttribute
  (* to put/get recomputed on for this(p) *)
  (# v: @integer;
     set: access
       (# 
       enter v
       do 
       #);
     get: access
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
descRef: semanticAttribute
  (# v: ^AST;
     set: access
       (#
       enter v[]
       do 
       #);
     get: access
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);

inSameFragment:
  (# N: ^AST
  enter N[]
  exit theAst.frag = N.frag
  #)
