ORIGIN 'newindex'
(* Sematic operations for BETA; extracted from index.bet in order
 * to make it easier to distinguish index.bet from mps/astlevel.bet.
 * 
 * 
 * NOTE: The following description is not up to date:
 *
 * The number of semantic attributes for the differect syntactic 
 * categories of beta as defined in '~beta/betaast/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    onForThis    3 bits 16-31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point 
 * to an ast in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *

 *)
---ASTindexLib:attributes---
descNo:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
  
descID:
  (# inx1: @integer;
     f: ^fragment;
     t: ^text;
  enter ((inx1, f[]), descNo)
  do '-- ASTindexLib: descID' -> putline;
     'UNKNOW descId' -> t[];
  exit (t[], descNO)
  #);
origin:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
slotOrigin:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
Xorigin:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
size:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
attSize: (* must be eliminated *)
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
virtSize:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
kind:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
dclRoot:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
lib:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
next:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
originOff:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
returnOff:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
sort:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
evalKind: (* att no. 1!! *)
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
insOff: (* att no. 2 !! *)
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
NXoff:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
NXsize:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
access:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
off:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
left:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
right:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
virtDcl:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
restartAdr:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
leaveAdr:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
dclRef:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);
on:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
pn:
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
onForThis:
  (* to put/get recomputed on for this(p) *)
  (# v: @integer;
     set: @
       (# 
       enter v
       do 
       #);
     get: @
       (# 
       do 
       exit v
       #);
  enter set
  exit get
  #);
descRef:
  (# v: ^AST;
     set: @
       (#
       enter v[]
       do 
       #);
     get: @
       (#
       do 
       exit v[]
       #);
  enter set
  exit get
  #);

inSameFragment:
  (# N: ^AST
  enter N[]
  exit theAst.frag = N.frag
  #)
