ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list';
INCLUDE 'bytestream';

-- lib: attributes --
ConstValue: (# exit 1 #);
NameValue: (# exit 2 #);
StringValue: (# exit 3 #);

ParameterList: List
  (# element:: Parameter;
     pack:
       (# output: ^Stream;
       enter output[]
       do size -> output.putInt32u;
          scan
	    (#
	    do output[] -> current.pack;
	    #);
       #);
     unPack:
       (# input: ^Stream;
          no: @integer;
	  par: ^Parameter;
       enter input[]
       do input.getInt32u -> no;
          (for no repeat
	      &Parameter[] -> par[];
	      input[] -> par.unPack;
	      par[] -> append;
	  for);
       #);
  #);
Property:
  (# name: ^text;
     parameters: @ParameterList;
     
     pack:
       (# output: ^Stream;
       enter output[]
       do name[] -> output.putBinText;
          output[] -> parameters.pack;
       #);
     
     unPack:
       (# input: ^Stream;
       enter input[]
       do input.getBinText -> name[];
          input[] -> parameters.unPack;
       #);
     addParameter:
       (# par: ^Parameter;
          value: ^Text;
       enter value[]
       do &Parameter[] -> par[];
          INNER;
          value[] -> par.value[];
          par[] -> parameters.append;
       exit par[]
       #);
     addString: addParameter
       (#
       do StringValue -> par.type;
       #);
     addName: addParameter
       (#
       do NameValue -> par.type;
       #);
     addConst: addParameter
       (#
       do ConstValue -> par.type;
       #);
     
     print:
       (#
       do name[] -> puttext;
          parameters.scan
          (#
          do ' ' -> put;
             current.print;
          #);
          
       #);
     
  #);
Parameter:
  (# value: ^text;
     type: @integer;
     
     pack:
       (# output: ^Stream;
       enter output[]
       do type -> output.putInt8u;
          value[] -> output.putBinText;
       #);
     unPack:
       (# input: ^Stream;
       enter input[]
       do input.getInt8u -> type;
          input.getBinText -> value[];
       #);
     print:
       (#
       do (if type
           //StringValue then
              '\'' -> put;
              value[] -> puttext;
              '\'' -> put;
           else
              value[] -> puttext;
          if);
       #);
  #);
PropertyList:
  (# properties: @list
       (# element:: Property;
       #);
       
     pack:
       (# output: ^Stream;
       enter output[]
       do properties.size -> output.putInt32u;
          properties.scan
	    (#
	    do output[] -> current.pack;
	    #);
       #);
     unPack:
       (# input: ^Stream;
          size: @integer;
	  prop: ^Property;
       enter input[]
       do input.getInt32u -> size;
          (for size repeat
	     &Property[] -> prop[];
	     input[] -> prop.unPack;
	     prop[] -> properties.append;
	  for);
       #);
     addProp:
       (# name: ^Text;
          prop: ^Property;
		  
		  addString:
		    (# s: ^Text;
			enter s[]
			do s[] -> prop.addstring;
			#);
	      addConst:
		    (# c: @integer;
			   s: ^Text;
			enter c
			do &text[] -> s[];
			   c -> s.putint;
			   s[] -> prop.addConst;
			#);
		  addName:
		    (# n: ^Text;
			enter n[]
			do n[] -> prop.addName;
			#);
       enter name[]
       do &Property[] -> prop[];
          name[] -> prop.name[];
          prop[] -> properties.append;
		  INNER;
       exit prop[]
       #);
     deleteProp:
       (# name: ^Text;
          prop: ^Property;
       enter name[]
       do search: properties.scan
            (#
            do (if current.name[] -> name.equalNCS then
                   current[] -> prop[];
                   leave search;
               if);
            #);
          (if prop[] <> NONE then
              prop[] -> properties.at -> properties.delete;
          if);
       #);
     scanProp:
       (# currentParList: ^ParameterList;
          doProp:< 
            (# prop: ^text;
               getName: 
                 (# notAName:< (# do INNER #);
                    name: ^text;
                 do 
                 exit name[]
                 #);
               getConst: 
                 (# notAConst:< (# do INNER #);
                    const: @integer
                 do 
                 exit const
                 #);
               getString: 
                 (# notAString:< (# do INNER #);
                    string: ^text
                 do 
                 exit string[]
                 #);
               scanParameters: 
                 (# doConst:< (# c: @integer enter c do INNER #);
                    doString:< (# s: ^text enter s[] do INNER #);
                    doName:< (# n: ^text enter n[] do INNER #);
                 do currentParList.scan
                    (#
                    do (if current.type
                        //ConstValue then
                           current.value.asInt -> doConst;
                        //StringValue then
                           current.value.copy -> doString;
                        //NameValue then
                           current.value.copy -> doName;
                       if);
                    #);
                 #)
               
            enter prop[]
            do INNER
            #);
       do properties.scan
          (#
          do current.parameters[] -> currentParList[];
             current.name.copy -> doProp;
          #);
       #);
     print:
       (#
       do properties.scan
          (#
          do current.print;
             ';' -> putline;
          #);
       #);
  #);
