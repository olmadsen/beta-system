ORIGIN '~beta/dependency/scanNonCompiled';
INCLUDE '~beta/newmps/betacfl';
INCLUDE '~beta/newmps/private/fragbody';
INCLUDE '../grammarinit';

-- program: descriptor --
(# root: ^Text;
   
   mps: @astInterface;
   beta: @mps.beta;
   dep: @mps.dependencyGraph;
   
   GroupList: List
     (# element:: mps.FragmentGroup;
     #);
   groups: ^GroupList;
   
   prepare:
     (#
     do mps.astLevelInit;
        ('~beta/grammars/beta/beta','beta',screen[])
          ->beta.betagrammarInit
        (#
           MPSerror::
             (# do (failure,msg[])->stop #);
           noParserAvailable:: 
             (# do (failure,msg[])->stop #)
        #); 
        dep.init;
        true -> dep.nti;
        machine_type -> dep.targetmachine[];
        machine_type -> dep.targetdirectory[];
     #);
   collect:
     (#
     do &GroupList[] -> groups[];
        root[] -> dep.scanNonCompiled
        (# translate::
             (#
             do fg[] -> groups.append;
             #);
        do '.' -> put;
        #);
        newline;
     #);
   print:
     (#
     do groups.scan
        (#
        do current.fullname -> puttext;
           '!' -> putline;
        #);
     #);
   realOpen:
     (# countNameDcls:
          (# frag: ^astInterface.FragmentForm;
             exp: ^astInterface.Expanded;
             count: @integer;
          enter frag[]
          do frag.root[] -> exp[];
             beta.nameDcl -> exp.suffixWalkForProd
             (#
             do count + 1 -> count;
             #);
             frag.fullname -> puttext;
             ' : ' -> puttext;
             count -> putint;
             newline;
          #);
     do groups.scan
        (# 
        do current.realopen;
           current.scan
           (#
           do current[] -> countNameDcls;
           #);
           current.close;
        #);
     #);
   semanticOpen:
     (# unpack:
          (# frag: ^astInterface.FragmentForm;
          enter frag[]
          do (if frag.header[] <> NONE then
                 frag.fullname -> puttext;
                 ': ' -> puttext;
                 'semantic!' -> putline;
                 (frag.header[], frag.info[]) -> frag.unPackSemanticInfo;
             if);
          #);
     do groups.scan
        (#
        do current.realopen;
           current.scan
           (#
           do current[] -> unpack;
           #);
           (*** current.close; ***)
        #);
     #);
   work:
     (#
     do collect;
        print;
        semanticOpen;
     #);
do (if NoOfArguments = 2 then
       2 -> arguments -> root[];
    else
       '~beta/compiler/TST/tst' -> root[];
   if);
   prepare;
   work;
#)
