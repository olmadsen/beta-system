ORIGIN '../astlevel';
INCLUDE '../betacfl';
INCLUDE '../grammarinit';
INCLUDE '../dependency';
INCLUDE '~beta/sysutils/objinterface';

-- program: descriptor --
(#
   mps: @astInterface;
   beta: @mps.beta;
	dep: @mps.dependencyGraph;
	
	GroupList: List
	  (# element:: mps.FragmentGroup;
	  #);
	groups: ^GroupList;
	result: ^AstRefList;
	
	prepare:
	  (#
	  do mps.astLevelInit;
	     ('~beta/grammars/beta/beta','beta',screen[])
			  ->beta.betagrammarInit
					(#
						MPSerror::
						  (# do (failure,msg[])->stop #);
						noParserAvailable:: 
						  (# do (failure,msg[])->stop #)
					#); 
		  dep.init;
	  #);
	welcome:
	  (#
	  do '    This is a simple tool that can search the dependencygraph of' -> putline;
	     '    a beta sourcefile for the declarations of a particular name.' -> putline;
		  '    Use the command help for a list of commands.' -> putline;
		  newline;
		  newline;
	  #);
	commandLoop:
	  (# Prompt:
	       (#
			 do '>> ' -> screen.puttext;
			 #);
		  GetCommand:
		    (# command: ^text;
			 do keyboard.getline -> command[];
			 exit command[]
			 #);
		  DoCommand:
		    (# command: ^text;
			    op: ^text;
				 arg: ^text;
			 enter command[]
			 do command.reset;
			    command.getAtom -> op[];
			    (if true 
			      //'quit' -> op.equal then
					   true -> done;
					//'build' -> op.equal then
						command.getAtom -> arg[];
						(if arg.length > 0 then
						   arg[] -> Build;
					   if);
					//'ls' -> op.equal then
					   listFiles;
				   //'find' -> op.equal then
					   command.getAtom -> arg[];
						(if arg.length > 0 then
						   arg[] -> find -> result[];
					   if);
				   //'show' -> op.equal then
					  show;
					//'dump' -> op.equal then
					  dump;
			    else
				   'invalid command name "' -> puttext;
					op[] -> puttext;
					'"' -> putline;
			    if);
			 #);
		  done: @boolean;
	  do loop:
	       (if not done then
			    Prompt;
				 GetCommand -> DoCommand;
				 restart loop;
			 if);
	  #);
	  
	build:
	  (# name: ^text;
	  enter name[]
	  do &GroupList[] -> groups[];
	     name[] -> dep.scanNonCompiled
			 (# beforeGroup::
					(#
					do fg[] -> groups.append;
					#);
			 #);
	  #);
	listFiles:
	  (#
	  do (if groups[] <> NONE then
	        groups.scan
			    (#
				 do current.name -> putline;
				 #);
		  if);
	  #);
	  
	AstRef:
	  (# frag: ^astInterface.fragmentForm;
	     node: ^astInterface.AST;
	  #);
	AstRefList: List
	  (# element:: AstRef;
	  #);
	find:
	  (# name: ^text;
	     result: ^AstRefList;
		  add:
		    (# frag: ^astInterface.fragmentForm;
			    node: ^astInterface.AST;
				 new: ^AstRef;
			 enter (frag[], node[])
			 do &AstRef[] -> new[];
			    frag[] -> new.frag[];
				 node[] -> new.node[];
				 new[] -> result.append;
			 #);
		  findInGroup:
		    (# group: ^astInterface.fragmentGroup;
			 enter group[]
			 do group.scan
			      (#
					do current[] -> findInFragment;
					#);
			 #);
		 findInFragment:
		   (# frag: ^astInterface.fragmentForm;
			   exp: ^astInterface.expanded;
			enter frag[]
			do frag.root[] -> exp[];
			   exp.suffixWalk
				  (# lexem: ^astInterface.LexemText;
				  do (if current## <= mps.NameDecl## then
				        current[] -> lexem[];
						  (if lexem.getText -> name.equalNCS then
						     (frag[], lexem[]) -> add;
						  if);
					  if);
				  #);
			#);
	  enter name[]
	  do &AstRefList[] -> result[];
	     (if groups[] <> NONE then
	        groups.scan
			     (#
				  do current[] -> findInGroup;
				  #);
	     if);
	  exit result[]
	  #);
	  
	getDecl:
	  (# nameDecl: ^astInterface.nameDecl;
	     nameDcl: ^astInterface.beta.nameDcl;
		  names: ^astInterface.beta.names;
		  attributeDecl: ^astInterface.beta.attributeDecl;
	  enter nameDecl[]
	  do nameDecl.father -> nameDcl[];
	     nameDcl.father -> names[];
		  names.father -> attributeDecl[];
	  exit attributeDecl[]
	  #);
	show:
	  (#
	  do (if result[] <> NONE then
	        result.scan
			    (# attributeDecl: ^astInterface.beta.attributeDecl;
				 do current.frag.fullname -> screen.putline;
				    current.node[] -> getDecl -> attributeDecl[];
					 (attributeDecl[], screen[]) -> beta.pretty;
					 screen.newline;
				 #);
	     if);
	  #);
	dump:
	  (#
	  do (if result[] <> NONE then
	        result.scan
			     (#
				  do screen.newline;
				     (1, screen[], beta[]) -> (((current.node.father).father).father).dump;
					  screen.newline;
				  #);
		  if);
	  #);
do prepare;
   welcome;
   commandLoop;
#)

