ORIGIN '../astlevel';
INCLUDE '../betacfl';
INCLUDE '../grammarinit';
INCLUDE '../dependency';
INCLUDE '~beta/sysutils/objinterface';

-- program: descriptor --
(#
   mps: @astInterface;
   beta: @mps.beta;
   dep: @mps.dependencyGraph;
   
   GroupList: List
     (# element:: mps.FragmentGroup;
     #);
   groups: ^GroupList;
   result: ^AstRefList;
   
   
   
   prepare:
     (#
     do mps.astLevelInit;
        ('~beta/grammars/beta/beta','beta',screen[])
          ->beta.betagrammarInit
        (#
           MPSerror::
             (# do (failure,msg[])->stop #);
           noParserAvailable:: 
             (# do (failure,msg[])->stop #)
        #); 
        dep.init;
		symboltable.init;
     #);
   welcome:
     (#
     do '    This is a simple tool that can search the dependencygraph of' -> putline;
        '    a beta sourcefile for the declarations of a particular name.' -> putline;
        '    Use the command help for a list of commands.' -> putline;
        newline;
        newline;
     #);
   commandLoop:
     (# Prompt:
          (#
          do '>> ' -> screen.puttext;
          #);
        GetCommand:
          (# command: ^text;
          do keyboard.getline -> command[];
          exit command[]
          #);
        DoCommand:
          (# command: ^text;
             op: ^text;
             arg: ^text;
          enter command[]
          do command.reset;
             command.getAtom -> op[];
             (if true 
              //'quit' -> op.equal then
                 true -> done;
              //'build' -> op.equal then
                 command.getAtom -> arg[];
                 (if arg.length > 0 then
                     arg[] -> Build;
                 if);
              //'ls' -> op.equal then
                 listFiles;
              //'find' -> op.equal then
                 command.getAtom -> arg[];
                 (if arg.length > 0 then
                     arg[] -> find -> result[];
                 if);
              //'show' -> op.equal then
                 show;
              //'dump' -> op.equal then
                 dump;
			  //'save' -> op.equal then
                 save;
			  //'semantic' -> op.equal then
                 semantic;
		      //'symbols' -> op.equal then
                 buildSymbolTable;
			  //'print' -> op.equal then
                 print;
			  //'bind' -> op.equal then
                 bindNames;
			  //'stress' -> op.equal then
                 stress;
			  //'stress-names' -> op.equal then
                 stress_names;
		      //'stress-honey' -> op.equal then
                 stress_honey;
			  //'stress-expand' -> op.equal then
                 stress_expand;
			  //'stress-current' -> op.equal then
                 stress_current;
			  //'stress-makelc' -> op.equal then
                 stress_makelc;
			  //'stress-lookup' -> op.equal then
                 stress_lookup;
			  //'stat' -> op.equal then
                 mps.top.grouptable.statistics
				   (#
				   do screen[] -> print;
				   #);
              else
                 'invalid command name "' -> puttext;
                 op[] -> puttext;
                 '"' -> putline;
             if);
          #);
        done: @boolean;
     do loop:
          (if not done then
              Prompt;
              GetCommand -> DoCommand;
              restart loop;
          if);
     #);
   
   
   operation:
     (# GetTickCount: external
          (# milli: @integer;
          do 'getmilisectimestamp' -> callc;;
          exit milli
          #);
        before: @integer;
        after: @integer;
     do GetTickCount -> before;
        INNER;
        GetTickCount -> after;
        'ellapsed: ' -> puttext;
        after - before -> putint;
        newline;
     #);
   build: operation
     (# name: ^text;
     enter name[]
     do &GroupList[] -> groups[];
        name[] -> MPS.expandToFullPath -> dep.scanNonCompiled
        (# beforeGroup::
             (#
             do fg[] -> groups.append;
             #);
        #);
     #);
   stress: operation
     (# name: ^Text;
	 do 'Underworld:beta:r5.3:compiler:TST:tst' -> name[];
	    (for 1000 repeat
	       (name[], screen[]) -> mps.top.open;
		for);
	 #);
   stress_names: operation
     (# name: ^Text;
	    other: ^Text;
	 do 'Underworld:beta:r5.3:compiler:TST:tst' -> name[];
	    'Underworld:beta:r5.3:compiler:TST:tst' -> other[];
		(for 1000 repeat
	       name[] -> other.equalNCS;
		for);
	 #);
   stress_honey: operation
     (# H: @HoneyMan;
	    name: ^Text;
		value: @integer;
	 do H.init;
	    'Underworld:beta:r5.3:compiler:TST:tst' -> name[];
		(for 1000 repeat
		   name[] -> H.hash -> value;
		for);
	 #);
   stress_makelc: operation
     (# name: ^Text;
	    other: ^Text;
	 do 'Underworld:beta:r5.3:compiler:TST:tst' -> name[];
	    (for 1000 repeat
		   name.copy -> other[];
		   other.makeLC;
		for);
	 #);
   stress_lookup: operation
     (# name: ^Text;
	    other: ^Text;
		dummy: ^MPS.fragmentgroup;
		value: @integer;
		group: ^astInterface.FragmentGroup;
	 do 'Underworld:beta:r5.3:compiler:TST:tst' -> name[];
	    (name[], screen[]) -> mps.top.open;
	    (for 1000 repeat
		   &MPS.fragmentgroup[] -> dummy[];
		   name[] -> dummy.fullname;
		   dummy[] -> mps.top.grouptable.hashfunction -> value;
		   value -> mps.top.grouptable.findIndexed
		     (# predicate::  (#  do name[] -> (current.fullname).equalNCS -> value #);
			 do current[] -> group[];
			 #);
		for);
	 #);
   stress_current: operation
     (# name: ^Text;
	 do (for 1000 repeat
	       CurrentDirectory -> name[];
		for);
	 #);
   stress_expand: operation
     (# name, fullname: ^Text;
	 do '~beta/compiler/TST/tst' -> name[];
	    (for 1000 repeat
	       name[] -> MPS.expandToFullPath -> fullname[];
		for);
	 #);
   semantic: operation
     (#
	 do (if groups[] <> NONE then
            groups.scan
            (#
            do current.fragmentlist.scan
			     (#
				 do current.bindSemanticInfo;
				 #);
            #);
        if);
	 #);
   listFiles:
     (#
     do (if groups[] <> NONE then
            groups.scan
            (#
            do current.name -> putline;
            #);
        if);
     #);
   save: operation
     (#
     do (if groups[] <> NONE then
            groups.scan
            (#
            do current.markAsChanged;
            #);
        if);
     #);
   AstRef:
     (# frag: ^astInterface.fragmentForm;
        node: ^astInterface.AST;
     #);
   AstRefList: List
     (# element:: AstRef;
     #);
	 
	 
   Symbol:
     (# name: ^Text;
	    nameDcl: ^astInterface.beta.nameDcl;
	 #);
	 
   symboltable: @HashTable
            (# Element:: Symbol;
               rangeInitial:: (# do 1000 -> value #);
               H:  @HoneyMan;
               hashfunction::
                 (# 
                 do e.name[] -> H.hash -> value;
                 #);
               equal::
                 (#
                 do left.name[] -> right.name.equalNCS;
                 #);
               init::
                 (#
                 do H.init;
                 #);
				lookup:
				  (# name: ^Text;
				     dummy: @Element;
					 sym: ^Symbol;
				  enter name[]
				  do name[] -> dummy.name[];
				     search: dummy[] 
					          -> hashfunction
                              -> findIndexed
                                  (# predicate::  (#  do name[]->current.name.equalNCS->value #);
                                  do current[] -> sym[];
								     leave search;
                                  #);
			      exit sym[]
				  #);
            #);
   find: operation
     (# name: ^text;
        result: ^AstRefList;
        add:
          (# frag: ^astInterface.fragmentForm;
             node: ^astInterface.AST;
             new: ^AstRef;
          enter (frag[], node[])
          do &AstRef[] -> new[];
             frag[] -> new.frag[];
             node[] -> new.node[];
             new[] -> result.append;
          #);
        findInGroup:
          (# group: ^astInterface.fragmentGroup;
          enter group[]
          do group.scan
             (#
             do current[] -> findInFragment;
             #);
          #);
        findInFragment:
          (# frag: ^astInterface.fragmentForm;
             exp: ^astInterface.expanded;
          enter frag[]
          do frag.root[] -> exp[];
             exp.suffixWalk
             (# lexem: ^astInterface.LexemText;
			    nameApl: ^astInterface.beta.nameApl;
             do (if current## <= beta.NameApl## then
			        current[] -> nameApl[];
                    nameApl.getNameAppl -> lexem[];
					
                    (if lexem.getText -> name.equalNCS then
                        (frag[], nameApl[]) -> add;
                    if);
                if);
             #);
          #);
     enter name[]
     do &AstRefList[] -> result[];
        (if groups[] <> NONE then
            groups.scan
            (#
            do current[] -> findInGroup;
            #);
        if);
     exit result[]
     #);
   buildSymbolTable: operation
     (# add:
          (# name: ^Text;
             nameDcl: ^astInterface.beta.nameDcl;
             new: ^Symbol;
          enter (name[], nameDcl[])
          do &Symbol[] -> new[];
		     name.makeLC;
             name[] -> new.name[];
             nameDcl[] -> new.nameDcl[];
             new[] -> symbolTable.insert;
          #);
        processGroup:
          (# group: ^astInterface.fragmentGroup;
          enter group[]
          do group.scan
             (#
             do current[] -> processFragment;
             #);
          #);
        processFragment:
          (# frag: ^astInterface.fragmentForm;
             exp: ^astInterface.expanded;
          enter frag[]
          do frag.root[] -> exp[];
             beta.nameDcl -> exp.suffixWalkForProd
             (# scanCat:: beta.NameDcl;
			    nameDecl: ^astInterface.NameDecl;
				name: ^Text;
             do current.getNameDecl -> nameDecl[];
			    nameDecl.getText -> name[];
				(name[], current[]) -> add;
             #);
          #);
     do symboltable.clear;
        (if groups[] <> NONE then
            groups.scan
            (#
            do current[] -> processGroup;
            #);
        if);
     #);
   bindNames: operation
     (# 
        bind:
          (# name: ^Text;
             nameApl: ^astInterface.beta.nameApl;
             sym: ^Symbol;
          enter (name[], nameApl[])
          do name.makeLC;
		     name[] -> symbolTable.lookup -> sym[];
			 (if sym[] <> NONE then
			     sym.nameDcl[] -> nameApl.dclRef[];
			 if);
          #);
        processGroup:
          (# group: ^astInterface.fragmentGroup;
          enter group[]
          do group.scan
             (#
             do current[] -> processFragment;
             #);
          #);
        processFragment:
          (# frag: ^astInterface.fragmentForm;
             exp: ^astInterface.expanded;
          enter frag[]
          do frag.root[] -> exp[];
             beta.nameApl -> exp.suffixWalkForProd
             (# scanCat:: beta.NameApl;
			    nameAppl: ^astInterface.nameAppl;
				name: ^Text;
             do current.getNameAppl -> nameAppl[];
			    nameAppl.getText -> name[];
				(name[], current[]) -> bind;
             #);
          #);
     do (if groups[] <> NONE then
            groups.scan
            (#
            do current[] -> processGroup;
            #);
        if);
     #);
   getDecl:
     (# nameDecl: ^astInterface.nameDecl;
        nameDcl: ^astInterface.beta.nameDcl;
        names: ^astInterface.beta.names;
        attributeDecl: ^astInterface.beta.attributeDecl;
     enter nameDecl[]
     do nameDecl.father -> nameDcl[];
        nameDcl.father -> names[];
        names.father -> attributeDecl[];
     exit attributeDecl[]
     #);
   show1:
     (#
     do (if result[] <> NONE then
            result.scan
            (# attributeDecl: ^astInterface.beta.attributeDecl;
            do current.frag.fullname -> screen.putline;
               current.node[] -> getDecl -> attributeDecl[];
               (attributeDecl[], screen[]) -> beta.pretty;
               screen.newline;
            #);
        if);
     #);
   show:
     (#
	 do  (if result[] <> NONE then
            result.scan
            (# nameApl: ^astInterface.beta.nameApl;
			   nameDcl: ^astInterface.beta.nameDcl;
			   nameAppl: ^astInterface.nameAppl;
			   attributeDecl: ^astInterface.beta.attributeDecl;
            do current.node[] -> nameApl[];
			   nameApl.dclref[] -> nameDcl[];
			   nameApl.form.fullname -> putline;
               nameApl.getNameAppl -> nameAppl[];
			   nameAppl.getText -> putText;
			   ' = ' -> puttext;
			   (if nameDcl[] = NONE then
			      'NONE' -> putline;
			    else
				   'BOUND' -> putline;
				   nameDcl.getNameDecl -> getDecl -> attributeDecl[];
				   (attributeDecl[], screen[]) -> beta.pretty;
				   newline;
				if);
			   
            #);
        if);
	 #);
   
   print:
     (#
	 do symboltable.scan
	      (#
		  do current.name[] -> putline;
		  #);
	 #);
   dump:
     (#
     do (if result[] <> NONE then
            result.scan
            (#
            do screen.newline;
               (1, screen[], beta[]) -> (((current.node.father).father).father).dump;
               screen.newline;
            #);
        if);
     #);
do prepare;
   welcome;
   commandLoop;
#)

