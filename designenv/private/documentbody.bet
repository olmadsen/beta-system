ORIGIN '../designenv'
[[

---- INCLUDE '../designenvutils'

---- NewDocument: descriptor ----
     (# newPage: ^Page;
     do (* prevent the callback from New *)
	disable.MenuEventCallBack;
	disable.PostMenuEventCallBack;
	(menuID.fileMenu,menuID.fileMenu.New) -> CallOAMenu; 
	        (* create a new document just by simulating New in File menu *)
	THIS(Document)[] -> theDocument[];
	onInit ->  newPage[];
	(if newPage[]//NONE then
	    &DesignPage[] -> newPage[]; 
	    (* new document makes a new page automatically *)
	if);
	DSStrGetCurPage -> newPage.onInit;  (* init page with id *)
	newPage[] -> CurrentPage; (* allow onInit to create other pages *)
	
	(* allow the callback from New *)
	enable.MenuEventCallBack;
	enable.PostMenuEventCallBack;
     #)

---- DocumentPrivatePart: descriptor ----
     (#
	currentPageID: @Integer;
	coarsening: @Integer; (* no os pages currently made by coarsening
	                       * but not yet made as beta object *)
	doingCoarse: @Boolean;
	
	InteractiveCreatedObject: ^Object;
	
	hackw,hackh: @Integer;
     #)     

---- DocumentID: descriptor ----
     (#
     do DSStrGetDocID -> i;
     #)

---- DocModified: descriptor ----
     (#
     do b -> DSStrSetDiagModified;
     #)

---- SetPage: descriptor ----
     (#
     do
	(if p.ID -> DSStrSetCurPage
 	 // true then
	    p.ID -> privatepart.currentPageID;
	 else
	    'SetPage failed; error ID: ' -> putline;
	if);
     #)

---- GetPage: descriptor ----
     (#  
     do
	(* test whether current is the same page *)
	(if (DSStrGetCurPage -> pid) <> privatepart.currentPageID
 	 // true then
	    (* no find the new page *)
	    pid -> theObjectList.Find -> p[];
       	    pid -> privatepart.currentPageID;
	if);
	(if p[]//NONE then 'GetPage: page is none' -> putline if);
     #)

---- GetPages: descriptor ----
     (# count: @ShortRef;
	listRef: @IntegerRef;
     do (* get the pages from design/oa and make a list... *)
	(count[],listRef[]) -> DSStrGetPageList;
 	(count,listRef) -> GetIntList -> theObjectList.NodeIDsToList -> pagelist[];
     #)
(*************************** GLOBAL **********************************)

---- MaxGroupSize: descriptor ----
     (#
     do DSRdAttrGetMaxGroupSize -> size;
     #)

---- PolyGetSide: descriptor ----
     (# sidesRef: ^shortRef;
	orientRef: ^integerRef;
     do (sidesRef[],orientRef[]) -> DSRdAttrPolyDefaults;
	sidesRef -> side;
     #)

---- PolySetSide: descriptor ----
     (# sidesRef: ^shortRef;
	orientRef: ^integerRef;
     do 
	(sidesRef[],orientRef[]) -> DSRdAttrPolyDefaults;
	(if (side,orientRef) -> DSWtAttrRegularPolyInfo
	 // false then 'PolySetSide: could not set' -> putline;
	if);
     #)

---- PolyGetOrient: descriptor ----
     (# sidesRef: ^shortRef;
	orientRef: ^integerRef;
     do (sidesRef[],orientRef[]) -> DSRdAttrPolyDefaults;
	orientRef -> orient;
     #)

---- PolySetOrient: descriptor ----
     (# sidesRef: ^shortRef;
	orientRef: ^integerRef;
     do 
	(sidesRef[],orientRef[]) -> DSRdAttrPolyDefaults;
	(if (sidesRef,orient) -> DSWtAttrRegularPolyInfo
	 // false then 'PolySetOrient: could not set' -> putline;
	if);
     #)



(*********** CURSOR HANDLING ***********)

---- SetCursor: descriptor ----
     (#
     do ID -> DSUIChangeCursor -> oldCurs;
     #)

---- RestoreCursor: descriptor ----
     (#
     do oldCurs -> DSUIChangeCursor;
     #)

---- ResetCursor: descriptor ----
     (#
     do CrossHair -> set;
     #)

---- SetStatusBar: descriptor ----
     (#
     do msg ->  DSUISetStatusBarMessage;
     #)

---- ResetStatusBar: descriptor ----
     (#
     do DSUIRestoreStatusBar;
     #)

----]]

