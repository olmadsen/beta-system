ORIGIN '../designenv';
(*************************** ATTRIBUTES *******************************)
INCLUDE 'documentbody'
        'userdatabody'
        '~beta/basiclib/v1.4/file';
-- DesignAttributes: Descriptor --
(#
   fill,line,thick: @Integer;
   visual: @Boolean;
   SetVisuals:
     (# 
     do
        (if (ID,line,thick,fill,visual)->DSWtAttrObjectVisuals
         // false then 'ObjectSetVis: could not set'->putline
        if);
        
     #);
   GetVisuals:
     (# lineRef,thickRef,fillRef,visualRef: @IntegerRef; 
     do
        (ID,lineRef[],thickRef[],fillRef[],visualRef[])->DSRdAttrObjectVisuals;
        (lineRef,thickRef,fillRef,visualRef)->(line,thick,fill,visual);
        
     #);
   
#)
(************************* INITIALIZE OBJECTS *****************************)  

-- InitObject: Descriptor --
(# 
do
   (if userDataVerbose then
       'onInit called on id='->puttext; id->putint; newline
   if);
   THIS(DesignObject)[]->theObjectList.insert;
   IDUserDataAttributes.init;
   oldIDUserDataAttributes.init;
   UserDataStart->UserDataAttributes;
   IDUserDataAttributes->oldIDUserDataAttributes;
   IDUserDataStart->IDUserDataAttributes;
   UserDataID.init;
   (if userDataVerbose then
       'Reading UserDataID: '->puttext; UserDataID->putint; newline
   if);
   (UserDataID,ID)->UserDataIDMap.putID;
   (*toby 28-10-94:
    Update map of old id's to new id's and
    updata UserDataID to new ID.*)
   ID->UserDataID
#)  

-- RemoveObject: Descriptor --
(#  do THIS(DesignObject)[]->theDocument.theObjectList.delete;  #)  

-- NewObject: DoPart --
do
   disable.CreateObjectCallBack;
   (* we don't like Design/OA to call us when we have created the object *)
   (* DSRdAttrSelectableFlag -> Selectable.s; CANNOT CALL THIS??? *)
   true->Selectable.s;
   INNER ;
   enable.CreateObjectCallBack;
     

-- NodeNew: Descriptor --
(# 
do
   (if false then
       '******** designobjectbody-NodeNew ********'->putline;
   'x: '->putText;
   x->putint;
   newLine;
   'y: '->putText;
   y->putint;
   newLine;
   'w: '->putText;
   w->putint;
   newLine;
   'h: '->putText;
   h->putint;
       newLine;
   if);
   (if not doneInInner then
       (if shape // 0 then rectangle->shape if);
       (THIS(Page).ID,x->wcoord,y->wcoord,w->wcoord,h->wcoord,shape)
         ->DSStrCreateNode->onInit
   if);
   (* calling MakeNode in callback...*)
   
#)  

-- NewConn: Descriptor --
(#  do (THIS(Page).ID,node1.ID,node2.ID)->DSStrCreateConn->onInit;  #)  

-- NewLabel: Descriptor --
(# 
do
   (THIS(Page).ID,x->wcoord,y->wcoord,w->wcoord,h->wcoord,txt)->DSStrCreateLabel
     ->onInit;
   
#)  

-- NewPolygon: Descriptor --
(# worldPoints: [0] @Integer; 
do
   points.range->worldPoints.extend;
   (for i: points.range repeat points[i]->wcoord->worldPoints[i] for);
   (THIS(Page).ID,worldpoints.range,@@ worldpoints[1])->DSStrCreatePolygon
     ->onInit;
   
#)  

-- NewRegPoly: Descriptor --
(#  do 'NewRegPoly object: NYI'->putline #)  

-- NewLine: Descriptor --
(#  do 'NewLine object: NYI'->putline #) (* INTERACTIVE CREATE *)  

-- ObjectInteractiveNew: Descriptor --
(# 
do
   (if msg.empty // false then msg->statusbar.set if);
   CursorFormat;
   (if curs <> 0 // true then curs->cursor.set;  if);
   INNER InteractiveNew;
   (* Set up DesignObjectDesc in further bindings *)
   THIS(DesignObject)[]->theDocument.PrivatePart.InteractiveCreatedObject[];
   
#)  

-- NodeInteractiveNew: Descriptor --
(# menu: @Integer; 
do
   DesignNode##->DesignObjectDesc##;
   (if true
    // (THIS(Node).struc <= GenericNode##) then
       (if shape
        // Rectangle then
           menuID.createMenu.box->menu; 
        // Ellipse then
           menuID.createMenu.ellipse->menu; 
        // Polygon then
           menuID.createMenu.poly->menu; 
        // RndRect then
           menuID.createMenu.round->menu; 
        // Wedge then
           menuID.createMenu.wedge->menu; 
        // Picture then
           menuID.createMenu.picture->menu; 
        else
           'else 1'->screen.putLine; 
       if);
       
    // (THIS(Node).struc <= RectNode##) then
       menuID.createMenu.box->menu; 
    // (THIS(Node).struc <= EllipseNode##) then
       menuID.createMenu.ellipse->menu; 
    // (THIS(Node).struc <= PolygonNode##) then
       menuID.createMenu.poly->menu; 
    // (THIS(Node).struc <= RndRectNode##) then
       menuID.createMenu.round->menu; 
    // (THIS(Node).struc <= WedgeNode##) then
       menuID.createMenu.wedge->menu; 
    // (THIS(Node).struc <= PictureNode##) then
       menuID.createMenu.picture->menu; 
    else
       'else 2'->screen.putLine; 
   if);
   (menuID.createMenu,menu)->CallOAMenu;
   (*(menu,curs) -> DSUIMenuExecuteModalWithCursor;*)
   
#)  

-- ConnInteractiveNew: Descriptor --
(# 
do
   DesignConnector##->DesignObjectDesc##;
   (menuID.createMenu,menuID.createMenu.conn)->CallOAMenu;
   
#)  

-- PolygonInteractiveNew: Descriptor --
(# 
do
   DesignPolygon##->DesignObjectDesc##;
   (menuID.createMenu,menuID.createMenu.poly)->CallOAMenu;
   
#)  

-- RegPolyInteractiveNew: Descriptor --
(# 
do DesignRegPoly##->DesignObjectDesc##; 'RegPoly object: NYI'->putline; 
#)  

-- LineInteractiveNew: Descriptor --
(# 
do DesignLine##->DesignObjectDesc##; 'Line object: NYI'->putline; 
#)
(***********)  

-- RedrawDesignObject: Descriptor --
(# 
do ID->DSUIRedraw; 
#)
(******************************** GEOMETRIC  *******************************)  

-- ObjectGetCenter: Descriptor --
(# xref,yref: @IntegerRef; 
do
   (ID,xref[],yref[])->DSRdAttrGetObjectCenter;
   xref->DSUtilWorldToPoints->x;
   yref->DSUtilWorldToPoints->y;
   
#)  

-- ObjectSetCenter: Descriptor --
(# 
do
   (if (ID,x->wcoord,y->wcoord)->DSWtAttrObjectPosition
    // false then 'Setcenter: error '->putline
   if);
   
#)  

-- ObjectGetSize: Descriptor --
(# wref,href: @IntegerRef; 
do
   (ID,wref[],href[])->DSRdAttrGetObjectSize;
   wref->DSUtilWorldToPoints->w;
   href->DSUtilWorldToPoints->h;
   
#)  

-- ObjectSetSize: Descriptor --
(# 
do
   (if (ID,w->wcoord,h->wcoord)->DSWtAttrAdjustObjectSize
    // false then 'SetSize: error'->putline; 
   if);
   
#)  

-- ObjectSetGeometry: Descriptor --
(# 
do
   (if (ID,x->wcoord,y->wcoord)->DSWtAttrObjectPosition
    // false then 'SetGeometry Center: error '->putline
   if);
   (if (ID,w->wcoord,h->wcoord)->DSWtAttrAdjustObjectSize
    // false then 'SetGeometry Size: error'->putline
   if);
   
#)  

-- ObjectGetGeometry: Descriptor --
(# xref,yref,wref,href: @IntegerRef; 
do
   (ID,xref[],yref[])->DSRdAttrGetObjectCenter;
   (ID,wref[],href[])->DSRdAttrGetObjectSize;
   xref->DSUtilWorldToPoints->x;
   yref->DSUtilWorldToPoints->y;
   wref->DSUtilWorldToPoints->w;
   href->DSUtilWorldToPoints->h;
   
#)  

-- ObjectSetSelectable: Descriptor --
(# MaskFlag: (#  exit 2 #); 
do
   (if (ID,MaskFlag,not s)->DSWtAttrObjectFlags
    // false then 'SetSelectable: could not set'->putline
   if);
   
#)  

-- Move: Descriptor --
(# 
do
   (if (ID,x->wcoord,y->wcoord)->DSWtAttrObjectPosition
    // false then 'ObjectMove: could not move object'->putline
   if);
   
#)
(*********************** VISUAL OPERATIONS **************************)  

-- SetLineThickness: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetLineThickness; ID is 0'->screen.putline; 
    else
       DesignAttributes.GetVisuals;
       thick->DesignAttributes.thick;
       DesignAttributes.SetVisuals;
       
   if);
   
#)  

-- GetLineThickness: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.thick->thick;  #)  

-- SetLineType: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetLineType; ID is 0'->screen.putline; 
    else
       (if (ID,line)->DSWtAttrLineType
        // false then 'SetLineType: could not set type'->putline
       if)
   if);
   
#)  

-- GetLineType: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.line->line;  #)  

-- SetFillType: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetFill; ID is 0'->screen.putline; 
    else
       DesignAttributes.GetVisuals;
       fill->DesignAttributes.fill;
       DesignAttributes.SetVisuals;
       
   if);
   
#)  

-- GetFillType: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.fill->fill;  #)  

-- SetBorderVisible: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetBorder; ID is 0'->screen.putline; 
    else
       DesignAttributes.GetVisuals;
       b->DesignAttributes.visual;
       DesignAttributes.SetVisuals;
       
   if);
   
#)  

-- GetBorderVisible: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.visual->b;  #)  

-- IndicateSelection: Descriptor --
(# 
do
   (if ID
    // 0 then 'IndicateSelection; ID is 0'->screen.putline; 
    else
       (ID,on)->DSUIIndicateObject; 
   if);
   
#)  

-- BringForward: Descriptor --
(# 
do
   (if target[]
    // none then 'BringForward failed, target is none'->screen.putline; 
    else
       (if (ID,target.ID)->DSUIBringForward
        // false then
           'BringForward failed, ID, target.ID: '->screen.putText;
           ID->screen.putInt;
           ', '->screen.putText;
           target.ID->screen.putInt;
           screen.newLine;
           
       if)
   if)
#)
(*********************** QUERY OPERATIONS **************************)  

-- ObjectGetSubPage: Descriptor --
(#  do ID->DSRdAttrGetObjectSubPage->theObjectList.Find->p[];  #)  

-- ObjectGetParent: Descriptor --
(# 
do
   ID->DSStrGetParent->theObjectList.Find->p[];
   (if p[] // none then 'GetParent: parent is none'->putline if);
   
#)  

-- ObjectGetTopParent: Descriptor --
(# 
do
   ID->DSStrGetTopParent->theObjectList.Find->p[];
   (if p[] // none then 'GetTopParent: parent is none'->putline if);
   
#)  

-- GetRegionList: Descriptor --
(# count: @ShortRef; listRef: @IntegerRef; 
do
   (ID,count[],listRef[])->DSStrGetObjectRegionList;
   (count,listRef)->getIntList->theObjectList.NodeIDsToList->theList[];
   
#)  

-- ObjectCreateRegion: Descriptor --
(# 
do (*disable.MakeRegionGrammarCallBack;*)
   (if (ID,parent.ID)->DSStrMakeNodeIntoRgn
    // false then
       'CreateRegion: can''t create region'->putline;
       (*else
        (NONE,NONE) -> onInitRegion;*)
       
   if);
   (*enable.MakeRegionGrammarCallBack;*)
   
#)  

-- ObjectUnMakeRegion: Descriptor --
(# 
do (*disable.UnMakeRegionGrammarCallBack;*)
   (if ID->DSStrMakeRgnIntoNode
    // false then 'UnMakeRegion: can''t unmake region'->putline; 
   if);
   (*false -> isRegion;
    enable.UnMakeRegionGrammarCallBack;*)
   
#)  

-- SetRegionType: Descriptor --
(# 
do
   (if isRegion
    // true then
       (if (ID,type)->DSWtAttrRegionId
        // false then 'SetRegionType: can''t set'->putline
       if);
       
   if);
   
#)  

-- ObjectGetConnectors: Descriptor --
(# count: @ShortRef; listRef: @IntegerRef; 
do
   (ID,count[],listRef[])->DSStrGetObjectConnList;
   (count,listRef)->getIntList->theObjectList.NodeIDsToList->theList[];
   
#)  

-- GetObjectsConnected: Descriptor --
(# inCount,outCount: @ShortRef; inListRef,outListRef: @IntegerRef; 
do
   (ID,inCount[],inListRef[],outCount[],outListRef[])->DSStrGetObjectInOutLists;
   ((inCount,inListRef)->getIntList)->theObjectList.NodeIDsToList->inList[];
   ((outCount,outListRef)->getIntList)->theObjectList.NodeIDsToList->outList[];
   
#)  

-- ObjectFitToText: Descriptor --
(# 
do (if ID->DSUIFitBoxToText // false then 'FitText failed'->putline;  if); 
#)  

-- DeleteObject: Descriptor --
(# 
do
   (if objectverbose
    // true then
       'DesignEnv: delete object ID: '->screen.puttext;
       ID->screen.putint;
       screen.newline;
       
   if);
   (if ID->DSStrDeleteObject
    // false then
       'DeleteObject: can''t delete object'->screen.puttext;
       ID->screen.putint;
       screen.newline;
       
   if);
   
#)  

-- ObjectInitRegion: Descriptor --
(# 
do true->isRegion
#)
(******************** DESIGNTEXT *******************)  

-- DesignTextPrivate: Descriptor --
(#
   font,size,style,just: @Integer;
   scBar: @Boolean;
   GetVal:
     (# fontRef,sizeRef,styleRef,justRef: @ShortRef; scBarRef: @IntegerRef; 
     do
        (if size
         // 0 then (* first time get default values *)
            (fontRef[],sizeRef[],styleRef[],justRef[],scBarRef[])
              ->DSRdAttrGetTextDefaults;
            (fontRef,sizeRef,styleRef,justRef,scBarRef)
              ->(font,size,style,just,scBar);
            
        if);
        
     #);
   
#)  

-- DesignTextSet: Descriptor --
(#  do (ID,t)->DSTextPut #)  

-- DesignTextGet: Descriptor --
(# aStr: [64] @char; count: @ShortRef; 
do
   256->count;
   (ID,@@ aStr[1],count[])->DSTextGet;
   @@ aStr[1]->cStringToCharRep->t;
   
#)  

-- DesignTextClear: Descriptor --
(#  do (ID,'')->DSTextPut #)  

-- DesignTextLength: Descriptor --
(# lref: @Shortref;  do (ID,lref[])->DSTextGetLength; lref->l;  #)  

-- DesignTextParent: Descriptor --
(# textID: @Integer;  do ID->DSTExtGetTextParent->textID;  #)  

-- DesignTextIsModeOn: Descriptor --
(#  do DSTextIsModeOn->b;  #)  

-- DesignTextModeOn: Descriptor --
(#  do (if OKToEnter then True->DSTextSetMode if);  #)  

-- DesignTextModeOff: Descriptor --
(#  do (if OKtoExit then False->DSTextSetMode;  if);  #)  

-- DesignTextMaxLineLength: Descriptor --
(#  do (* ID -> DSTextMaxLineLength -> m; *) 0->m;  #)  

-- DesignTextFont: Descriptor --
(# 
do
   private.getval;
   (ID,f,private.size,private.style,private.just)->DSTextSetAttr;
   f->private.font;
   
#)  

-- DesignTextSize: Descriptor --
(# 
do
   private.getval;
   (ID,private.font,s,private.style,private.just)->DSTextSetAttr;
   s->private.size;
   
#)  

-- DesignTextStyle: Descriptor --
(# 
do
   private.getval;
   (ID,private.font,private.size,s,private.just)->DSTextSetAttr;
   s->private.style;
   
#)  

-- DesignTextJust: Descriptor --
(# 
do
   private.getval;
   (ID,private.font,private.size,private.style,j)->DSTextSetAttr;
   j->private.just;
   
#)  

-- DesignTextWrap: Descriptor --
(#  do (ID,not b)->DSTextSetNoWrap;  #)  

-- DesignTextGetLength: Descriptor --
(# s: @shortRef;  do (ID,s[])->DSTextGetLength; s->len;  #)  

-- DesignTextSetDefaultFont: Descriptor --
(#  do f->DSTExtSetDefaultFont;  #)  

-- DesignTextSetDefaultJust: Descriptor --
(#  do j->DSTextSetDefaultJust;  #)  

-- DesignTextSetDefaultSize: Descriptor --
(#  do s->DSTextSetDefaultSize;  #)  

-- DesignTexSetDefaultStyle: Descriptor --
(# 
do s->DSTextSetDefaultStyle; 
#)
(********************************** NODE *********************************)  

-- NodeAttributes: Descriptor --
(#
   oldPosition: @Point;
   (* to prevent drags *)
   w,h: @Integer;
   (* to prevent resizes *)
   
#)  

-- NodeInit: Descriptor --
(# 
do
   Geometry
     ->
       (NodeAttributes.oldPosition.x,NodeAttributes.oldPosition.y,
        NodeAttributes.w,NodeAttributes.h);
   true->moveable;
   
#)  

-- NodeMove: Descriptor --
(#  do Center->NodeAttributes.oldPosition;  #)  

-- NodeDrag: Descriptor --
(# regions: ^ObjectList; 
do
   (if moveable
    // false then
       (if CurrentObject
        // THIS(Node)[] then
        (* I am the only selected object; and I cannot be moved:
         * move back to old pos *)
           NodeAttributes.oldPosition->Move; 
        else
       (* ok to move; get new position *)
           Center->NodeAttributes.oldPosition; 
       if)
    else
   (* ok to move; get new position *)
       Center->NodeAttributes.oldPosition; 
   if);
   (* check the regions (which is also dragged) of this node *)
   GetRegionList->regions[];
   (if regions[] <> none
    // true then
       regions.scan
         (# aNode: ^Node;  do current[]->aNode[]; aNode.onDrag;  #);
       
   if);
   
#)  

-- NodeSizeable: Descriptor --
(# NoSizingFlag: (#  exit 0x80 #); 
do
   (if (ID,NoSizingFlag,not b)->DSWtAttrObjectFlags
    // false then 'NodeSizeable: could not change'->screen.putline; 
   if);
   
#)  

-- GetRndRectRoundness: Descriptor --
(# wRef,hRef: @IntegerRef; 
do
   (if (ID,wRef[],hRef[])->DSRdAttrBoxRoundness
    // false then 'RndRectRoundness: could not read roundness'->putline; 
   if);
   wRef->w;
   hRef->h;
   
#)  

-- SetRndRectRoundness: Descriptor --
(# 
do
   (if (ID,w,h)->DSWtAttrSetBoxRoundness
    // false then 'RndRectRoundness: could not set roundness'->putline; 
   if);
   
#)  

-- GetWedgeAngles: Descriptor --
(# startRef,endRef: @IntegerRef; 
do
   (if (ID,startRef[],endRef[])->DSRdAttrWedgeAngles
    // false then 'WedgeAngles: could not read angles'->putline; 
   if);
   startRef->start;
   endRef->end;
   
#)  

-- SetWedgeAngles: Descriptor --
(# 
do
   (if (ID,start,end)->DSWtAttrSetWedgeAngles
    // false then 'WedgeAngles: could not set angles'->putline; 
   if);
   
#)
(*********************  POLYGON  *******************)  

-- PolyNoOfPoints: Descriptor --
(# count: @ShortRef; 
do (ID,count[])->DSRdAttrPolyPointCount; count->no; 
#)  

-- PolyPoints: Descriptor --
(# 
do (ID,@@ p[1])->DSRdAttrPolyPoints; 
#)
(********************* CONNECTOR *******************)  

-- ConnVisProps: Descriptor --
(#
   headwidth,headheight,textw,texth,shape: @Integer;
   SetProps:
     (# 
     do
        (if (ID,headwidth,headheight,shape,textw,texth)->DSWtAttrConnVisuals
         // false then 'SetConnProps: could not set'->putline
        if);
        
     #);
   GetProps:
     (#
        headwidthRef,headheightRef,shapeRef: @IntegerRef;
        textwRef,texthRef: @ShortRef;
        
     do
        (ID,headwidthRef[],headheightRef[],shapeRef[],textwRef[],texthRef[])
          ->DSRdAttrConnProps;
        (headwidthRef,headheightRef,shapeRef,textwRef,texthRef)
          ->(headwidth,headheight,shape,textw,texth)
     #);
   
#)  

-- ConnGetArrowHead: Descriptor --
(#  do (ID,end)->DSRdAttrArrowHeadType->end #)  

-- ConnGetOrient: Descriptor --
(#  do ID->DSRdAttrConnOrient->o;  #)  

-- ConnSetOrient: Descriptor --
(#  do (ID,o)->DSWtAttrConnOrient;  #)  

-- ConnGetPoints: Descriptor --
(#
   fisk: @integer;
   count: @ShortRef;
   list: [122] @Integer (* 2*MAXPOINTS(=61) *)
do
   (ID,count[],@@ list[1])->DSRdAttrConnPoints;
   count->fisk;
   fisk->thePoints.extend;
   (for i: fisk repeat list[i]->DSUtilWorldToPoints->thePoints[i] for);
   
#)  

-- ConnSetPoints: Descriptor --
(# 
do
   (for i: thePoints.range repeat thePoints[i]->wcoord->thePoints[i] for);
   (ID,thePoints.range div 2,@@ thePoints[1])->DSWtAttrSetConnPoints;
   
#)  

-- ConnSetHeadW: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   w->VisualAttributes.headwidth;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetHeadW: Descriptor --
(#  do VisualAttributes.GetProps; VisualAttributes.headwidth->w;  #)  

-- ConnSetHeadH: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   h->VisualAttributes.headheight;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetHeadH: Descriptor --
(#  do VisualAttributes.GetProps; VisualAttributes.headheight->h;  #)  

-- ConnSetShape: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   s->VisualAttributes.shape;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetShape: Descriptor --
(#  do VisualAttributes.GetProps; VisualAttributes.shape->s;  #)  

-- ConnSetBox: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   w->VisualAttributes.textw;
   h->VisualAttributes.texth;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetBox: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   VisualAttributes.texth->h;
   VisualAttributes.textw->w;
   
#)  

-- ConnGetEnds: Descriptor --
(# nd1,nd2: @IntegerRef; 
do
   (if (ID,rgn,nd1[],nd2[])->DSRdAttrGetConnEnds
    // true then
       nd1->theObjectList.Find->node1[]; nd2->theObjectList.Find->node2[]; 
    else
       'GetEnds failed connector ID: '->puttext; ID->putint; newline; 
   if);
   
#)  

-- ConnSetEnds: Descriptor --
(# 
do
   (if (ID,node1.ID,node1Rgn.ID,node2.ID,node2Rgn.ID)->DSWtAttrConnEndIDs
    // false then 'ConnSetEnds error'->putline
   if);
   
#)  

-- ConnGetCurvature: Descriptor --
(#  do ID->DSRdAttrSegmentCurvature->curv;  #)  

-- ConnSetCurvature: Descriptor --
(#  do (ID,curv)->DSWtAttrConnCurvature;  #)  

-- designEnvPrivate: Descriptor --
(#  #)  

-- designEnvInit: Descriptor --
(#  do (if verbose // true then 'DesignEnv 1.2'->putline if);  #)  

