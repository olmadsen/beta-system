ORIGIN '../designenv';
INCLUDE '~beta/basiclib/file'
        '~beta/basiclib/formatio'
        '~beta/bifrost/Bifrost'
        '~beta/bifrost/ColorNames'
        '~beta/bifrost/PredefinedGO'
        '~beta/bifrost/RasterGrays'
        '~beta/containers/hashTable'
        '~beta/containers/sets'
        '~beta/guienv/controls'
        '~beta/guienv/fields'
        '~beta/guienv/scrolllists'
        '~beta/guienv/stddialogs'
        '~beta/guienv/utils/guienvadds'
        '~beta/guienv/utils/scrolleradds'
        '~beta/sysutils/objinterface'
        'alignlib'
        'bifrostdesigndebug'
        'designutils';
BODY 'bifrostobjectbody'
     'menubody'
     'pagebody'
     'documentbody'
     'userdatabody'
     'zoomDialogBody';
-- UI: Descriptor --
(#
   theGUI: ^guienv;
   window: theGUI.window (#  #);
   terminate: theGUI.terminate (#  #);
   myMenuBarType: theGUI.menuBar
     (#
	dontUpdate: @booleanValue(# <<SLOT bifrostMenuDontUpdate: doPart>> #);
        checkMenuBar: (#  <<SLOT bifrostPageCheckMenuBar: doPart>> #);
        extraMenu: @theGUI.menu
          (#
             rougeTextItem: @menuItem
               (#
                  open:: 
                    (# 
                    do
                       'Search for rouge text'->name
                    #);
                  eventHandler:: 
                    (# onSelect::  (#  do currentBifrostPage.rougeText #)
                    #)
               #);
             quitItem: @menuItem
               (#
                  open::  (#  do 'Abort'->name #);
                  eventHandler::  (# onSelect::  (#  do terminate #) #)
               #);
             kukkukItem: @menuItem
               (#
                  open::  (#  do 'Output debug mark'->name #);
                  eventHandler:: 
                    (# onSelect::  (#  <<SLOT kukkuk:DoPart>> #) #)
               #);
             visibilityAllPages: menuItem
               (#
                  shown:< booleanValue;
                  eventHandler::< 
                    (#
                       onSelect::< 
                         (# 
                         do
                            (if theDocument[] <> none
                             then
                                (theDocument.getPages).scan
                                  (# apage: ^theDocument.page
                                  do current[]->apage[]; shown->apage.visible; 
                                  #);
                                
                             else
                                'Should have been disabled'->putLine; 
                            if)
                         #)
                    #)
               #);
             showAllPages: @visibilityAllPages
               (#
                  shown::  (#  do true->value #);
                  open::  (#  do 'Show all pages'->name #)
               #);
             hideAllPages: @visibilityAllPages
               (# open::  (#  do 'Hide all pages'->name #) #);
             verboseItem: @menuItem
               (#
                  open::  (#  do 'verbose'->name; verbose->checked #);
                  eventHandler:: 
                    (#
                       onSelect:: 
                         (#  do not verbose->verbose; verbose->checked #)
                    #)
               #);
             veryVerboseItem: @menuItem
               (#
                  open:: 
                    (#  do 'Very verbose'->name; veryVerbose->checked #);
                  eventHandler:: 
                    (#
                       onSelect:: 
                         (# 
                         do not veryVerbose->veryVerbose; veryVerbose->checked
                         #)
                    #)
               #);
             menuVerboseItem: @menuItem
               (#
                  open:: 
                    (#  do 'Menu verbose'->name; menuVerbose->checked #);
                  eventHandler:: 
                    (#
                       onSelect:: 
                         (# 
                         do not menuVerbose->menuVerbose; menuVerbose->checked
                         #)
                    #)
               #);
             extremelyVerboseItem: @menuItem
               (#
                  open:: 
                    (# 
                    do 'Extremely verbose'->name; extremelyVerbose->checked
                    #);
                  eventHandler:: 
                    (#
                       onSelect:: 
                         (# 
                         do
                            not extremelyVerbose->extremelyVerbose;
                            extremelyVerbose->checked
                         #)
                    #)
               #);
             dumpAll: @menuItem
               (#
                  open::  (#  do 'dumpAll'->name #);
                  eventHandler:: 
                    (# onSelect::  (#  <<SLOT dumpAll:DoPart>> #) #)
               #);
             open:: 
               (# sep: ^separator
               do
                  'Extras'->name;
                  rougeTextItem.open;
                  rougeTextItem[]->append;
                  showAllPages.open;
                  showAllPages[]->append;
                  hideAllPages.open;
                  hideAllPages[]->append;
                  kukkukItem.open;
                  kukkukItem[]->append;
                  &separator[]->sep[];
                  sep.open;
                  sep[]->append;
                  verboseItem.open;
                  verboseItem[]->append;
                  veryVerboseItem.open;
                  veryVerboseItem[]->append;
                  menuVerboseItem.open;
                  menuVerboseItem[]->append;
                  extremelyVerboseItem.open;
                  extremelyVerboseItem[]->append;
                  &separator[]->sep[];
                  sep.open;
                  sep[]->append;
                  dumpAll.open;
                  dumpAll[]->append;
                  &separator[]->sep[];
                  sep.open;
                  sep[]->append;
                  quitItem.open;
                  quitItem[]->append
               #)
          #);
        open:: 
          (# 
          do extraMenu.open; extraMenu[]->append
          #)
     #);
   currentBifrostPage: ^bifrostPage;
   pageList: @set (# element:: integerObject #);
   getPageList:
     (# pages: [0] @Integer; i: @integer
     do
        pageList.size->pages.new;
        0->i;
        pageList.scan
          (#  do i+1->i; current->pages[i] #)
     exit pages
     #);
   lookupDesignPicture:
     (#
        bifid: ^IDBifrost;
        thePage: ^bifrostPage;
        theObject: ^objectDesc;
        objectDesc:< thePage.designPicture;
        UD: ^userData;
        ID: @integer
     enter ID
     do
        bifrostObjectList.rep[ID][]->bifid[];
        (if bifid[]
         // none then 'bifid[] // NONE'->putLine
        else
            bifid.page[]->thePage[];
           (if thePage[]
            // none then 'thePage[] // NONE'->putLine
            if);
            bifid.IO[]->theObject[];
            (if theObject[]
             // none then 'theObject[] // NONE'->putLine
            if);
            bifid.UD[]->UD[];
            INNER
        if);
     #);
   lookUpUserDataObject:
     (#
        bifid: ^IDBifrost;
        thePage: ^bifrostPage;
        theObject: ^thePage.designPicture;
        ID: @integer
     enter ID
     do
        bifrostObjectList.rep[ID][]->bifid[];
        (if bifid[]
         // none then
            'bifid[] is NONE, %d has probably been deleted.\n'
              ->putFormat (#  do ID->d #);
            leave lookUpUserDataObject
        if);
        bifid.page[]->thePage[];
        (if thePage[]
         // none then
            'thePage[] is NONE, %d is probably a document.\n'
              ->putFormat (#  do ID->d #);
            leave lookUpUserDataObject
        if);
        (if bifid.IO[]
         // none then
            'theObject[] is NONE for %d.  THIS IS BAD!!!\n'
              ->putFormat (#  do ID->d #);
            leave lookUpUserDataObject
        if);
        bifid.IO[]->theObject[];
        INNER
     #);
   userData:
     (#
        dataType:
          (# type: @integer; intdata: @integer; textdata: ^text #);
        dataset: @hashTable
          (#
             element:: dataType;
             rangeInitial::  (#  do 23->value #);
             equal::  (#  do (left.type = right.type)->value #);
             hashFunction::  (#  do e.type->value #)
          #);
        read:
          (# attributeID: @Integer; newElm: ^dataType; finder: @dataType
          enter attributeID
          do
             attributeID->finder.type;
             scanner:
             finder[]->dataSet.hashFunction
               ->dataSet.scanIndexed
                 (# 
                 do
                    (if current.type
                     // attributeID then current[]->newElm[]; leave scanner
                    if)
                 #);
             INNER
          #);
        write: read
          (# 
          do
             (if newElm[]
              // none then
                 &dataType[]->newElm[];
                 attributeID->newElm.type;
                 newElm[]->dataset.insert;
                 
             if);
             INNER
          #);
        WriteInt: write
          (# data: @Integer enter data do data->newElm.intdata;  #);
        WriteText: write
          (# data: ^Text; 
          enter data[]
          do &text[]->newElm.textdata[]; data[]->newElm.textdata.putText
          #);
        ReadInt: read
          (# data: @integer; ok: @boolean
          do
             (if newElm[] <> none then
                 true->ok; newElm.intdata->data
              else
                 (if UI.verbose then
                     'Warning: readInt found no userdata'->putLine
                 if)
             if)
          exit (data,ok)
          #);
        ReadText: read
          (# data: ^text; ok: @boolean
          do
             (if newElm[] <> none then
                 true->ok; &text[]->data[]; newElm.textdata[]->data.putText
              else
                 (if UI.verbose then
                     'Warning: readText found no userdata'->putLine
                 if)
             if)
          exit (data[],ok)
          #);
        DeleteType: read
          (# 
          do
             (if newElm[] <> none then
                 newElm[]->dataset.delete
              else
                 (if UI.verbose then 'newElm[] is NONE'->putLine if)
             if)
          #);
        save:
          (# ud: ^stream
          enter ud[]
          do
             ' %d'->ud.putFormat (#  do dataset.size->d #);
             dataset.scan
               (# ts: @integer; td: ^text; ch: @char
               do
                  (if current.textdata[]
                   // none then - 1->ts; &text[]->td[]
                   else
                      &text[]->td[];
                      (for i: current.textdata.length repeat
                        i->current.textdata.inxGet->ch;
                        (if ch
                         // '\\' then '\\'->td.put; '\\'->td.putInt
                         else
                            (if (('A' <= ch) and (ch <= 'z')) or (ch = ' ') then
                            (* FIXME? assumes that newline isn't a
                             * char between A and z (like ascii)
                             *)
                                ch->td.put
                             else
                                '\\'->td.put; ch->td.putInt
                            if)
                        if)
                      for);
                      current.textdata.length->ts;
                      
                  if);
                  ' %d %d %s %d'
                    ->ud.putFormat
                      (# 
                      do current.type->d; ts->d; td[]->s; current.intData->d
                      #)
               #)
          #);
        load:
        (* load userdata from td, set place td.position right after
         * last read char
         *)
          (# td: ^stream; ch: @char; k,j: @Integer; ud: ^dataType
          enter td[]
          do
             dataset.clear;
             td.getInt->k;
             (for i1: k repeat
               &dataType[]->ud[];
               td.getint->ud.type;
               td.getint->j;
               (if j
                // - 1 then none ->ud.textdata[]
                else
                   td.get;
                   (* eat one space *)
                   &text[]->ud.textdata[];
                   (for i2: j repeat
                     td.get->ch;
                     (if ch // '\\' then td.getInt->ch if);
                     ch->ud.textdata.put;
                     
                   for)
               if);
               td.getInt->ud.intdata;
               ud[]->dataset.insert
             for)
          #)
     #);
   IDBifrost:
     (#
        page: ^bifrostPage;
        IO: ^page.designPicture;
        ID: @Integer;
        UD: @userData;
        init:
          (# 
          enter (page[],IO[],ID)
          do UD.dataset.init; THIS(IDBifrost)[]->bifrostObjectList.insert
          #)
     #);
   repetionContainer:
     (#
        rep: [100] ^IDBifrost;
        newID: @integerValue
          (# steal: (# i: @Integer enter i do (i,value)->max->value #)
          do value+1->value
          #);
        init: (#  do 1->newID.value #);
        insert:
          (# bi: ^IDBifrost
          enter bi[]
          do
             (if UI.veryVerbose then
                 'bifrostObjectList.insert: %d\n'
                   ->putFormat (#  do bi.ID->d #)
             if);
             (if bi.ID > rep.range then
                 (if UI.verbose then
                     'extending objectlist for %d with %d\n'
                       ->putFormat
                         (# 
                         do bi.ID->d; (bi.ID-rep.range,rep.range)->max->d
                         #)
                 if);
                 (bi.ID-rep.range,rep.range)->max->rep.extend
             if);
             bi[]->rep[bi.ID][];
             (if (bi.IO[] = none ) and UI.verbose then
                 'Warning: theObject is NONE'->putLine
             if)
          #);
        findID:
          (# IO: ^Object; ID: @integer
          enter IO[]
          do
             (if UI.veryVerbose then 'bifrostObjectList.findID'->putLine if);
             - 1->ID;
             (for inx: rep.range repeat
               (if rep[inx][] <> none then
                   (if rep[inx].IO[] // IO[] then inx->ID; leave findID if)
               if)
             for);
             'not found'->putLine
          exit ID
          #)
     #);
   bifrostObjectList: @repetionContainer;
   getApage: lookupDesignPicture (#  do INNER exit thePage[] #);
   getContentsOfPage: lookupDesignPicture
     (# theContents: ^window.windowItem
     do
        (if thePage[] <> none then
            thePage.theScroller.contents[]->theContents[]; INNER
        if)
     exit theContents[]
     #);
   letter: (#  exit (8500,11000) #);
   legal: (#  exit (8500,14000) #);
   A4: (#  exit (8300,11700) #);
   B5: (#  exit (7200,10000) #);
   B4: (#  exit (10125,14313) #);
   tabloid: (#  exit (11000,17000) #);
   bifrost2gui: (* revisit - constants *)
     (# x,y: @Integer enter (x,y) exit (x,10000-y) #);
   design2bifrost: (* revisit - constants *)
     (# x,y: @Integer enter (x,y) exit (x+5000,5000-y) #);
   bifrost2design: (* revisit - constants *)
     (# x,y: @Integer enter (x,y) exit (x-5000,5000-y) #);
   betapoint: point (#  #);
   defaultPageSize: @point;
   defaultCanvasSize: @point;
   dontRepair: @boolean;
   repairLevel: @Integer;
   bifrostPage: window
     (# (* attributes *)
        interactiveState: @integer;
        currentPageSize: @point;
        visible: @boolean;
        pageno: @integer;
        border: ^rect;
        bordervis: @boolean;
        nodelist,connlist: @set (# element:: integerObject #);
        autoPanObject: ^designObject;
        (* constants *)
        justification: @
          (#
             default: (#  exit 0 #);
             left: (#  exit 1 #);
             right: (#  exit 2 #);
             center: (#  exit 3 #)
          #);
        iaDisabled: (#  exit - 1 #);
        iaNormal: (#  exit 0 #);
        iaConn: (* designConnector *) (#  exit 1 #);
        iaRect: (* designRect *) (#  exit 2 #);
        iaEllipse: (* designEllipse *) (#  exit 3 #);
        iaRndRect: (* designRndRect *) (#  exit 4 #);
        iaWedge: (* designWedge *) (#  exit 5 #);
        iaPoly: (* designPolygon *) (#  exit 6 #);
        iaLine: (* designLine *) (#  exit 7 #);
        iaLabel: (* designLabel *) (#  exit 8 #);
        iaPicture: (* designPicture *) (#  exit 9 #);
        (* other stuff *)
        menubartype:: myMenuBarType;
        updateMenuBar: (#  <<SLOT bifrostPageUpdateMenuBar:DoPart>> #);
        cleanUp:
         <<SLOT bifrostPageCleanUp:Descriptor>>;
        repair:
          (# dontUpdateGroup: @boolean
          enter dontUpdateGroup
          <<SLOT bifrostPageRepair:DoPart>>
          #);
        load:
          (# psfile: ^file
          enter psfile[]
          do
             &
                <<SLOT bifrostPageLoad:Descriptor>>
          #);
        save:
          (# fileName: ^text; scaled,scaleToFit: @boolean; scale: @integer
          enter (fileName[],scaled,scaleToFit,scale)
          do &<<SLOT bifrostPageSave:Descriptor>>
          #);
        print:
          (# out: ^stream
          enter out[]
          do
             &
                <<SLOT bifrostPagePrint:Descriptor>>
          #);
        reattachConnectors: <<SLOT bifrostPageReattachConnectors:Descriptor>>;
        (* The following aliases are used when loading *)
        designObjectText: graphicText (#  #);
        designRectShape: Rect (# #);
        designRectFilledShape: Rect (#  #);
        designEllipseShape: ellipse (#  #);
        designEllipseFilledShape: ellipse (#  #);
        designPolyShape: multiLine (#  #);
        designPolyFilledShape: graphicalObject (#  #);
        designConnLine: multiLine (#  #);
        designConnFatLine: multiLine (#  #);
        currentReadPicture: ^designPicture;
        designSelection: @
          (#
             theObject: ^designObject;
             set:
               (#  enter theObject[] <<SLOT bifrostSelectionSet:DoPart>> #);
             get:
               (# 
               <<SLOT bifrostSelectionGet:DoPart>>
               exit theObject[]
               #)
          enter set
          exit get
          #);
        designGroup: @
          (#
             theObject: ^designObject;
             rep: [0] @integer;
             toggle: (* shift click *)
               (#  enter theObject[] <<SLOT bifrostGroupToggle:DoPart>> #);
             click: (* normal click *)
               (# 
               enter theObject[]
               <<SLOT bifrostGroupClick:DoPart>>
               #);
             init: (#  <<SLOT bifrostGroupInit:DoPart>> #);
             isEmpty: booleanValue
               (# 
               <<SLOT bifrostGroupIsEmpty:DoPart>>
               #);
             clear: (#  <<SLOT bifrostGroupClear:DoPart>> #);
             setGroup:
               (# 
               enter rep
               <<SLOT bifrostGroupSet:DoPart>>
               #);
             getGroup: (#  <<SLOT bifrostGroupGet:DoPart>> exit rep #);
             update:
               (# 
               <<SLOT bifrostGroupUpdate:DoPart>>
               #);
             private: @<<SLOT bifrostGroupPrivate:Descriptor>>
          enter setGroup
          exit getGroup
          #);
        rectUnion:
          (#
             r1,r2: @rectangle;
             tlx,tly,brx,bry: @integer
          enter (r1,r2)
          do
             (r1.x,r2.x)->min->tlx;
             (r1.y,r2.y)->max->tly;
             (r1.x+r1.width,r2.x+
              r2.width)->max->brx;
             (r1.y-r1.height,r2.y-
              r2.height)->min->bry
          exit (tlx,tly,brx-tlx,tly-bry)
          #);
        damage: @
          (# damaged,rct: @rectangle; 
          enter rct
          <<SLOT bifrostPageDamage:DoPart>>
          #);
        updateInfoBar:
          (# 
          <<SLOT bifrostPageUpdateInfoBar:DoPart>>
          #);
	zoom:
	  (#
	     setZoom:
	       (#
		  newzoom: @vector
	       enter newzoom
	       <<SLOT bifrostPageSetZoom: doPart>>
               #);
	     getZoom:
	       (#
		  v: @vector
	       <<SLOT bifrostPageGetZoom: doPart>>
	       exit v
               #)
	  enter setZoom
	  exit getZoom
	  #);
        blowup: (# <<SLOT bifrostPageBlowup:DoPart>> #);
        reduce: (# <<SLOT bifrostPageReduce:DoPart>> #);
        connSet: set (# element:: designConn #);
        designPicture: Picture
          (#
             ID: @Integer;
             load_prevPicture: ^designPicture;
             isRegion: @Boolean;
             grpPos: ^object;
             (* used by designGroup *)
             (* userdata *)
             userDataMethod:
               (#
                  bifid: ^IDBifrost;
                  att: @integer;
                  ok: @boolean;
                  UD: ^userData
               enter att
               do
                  true->ok;
                  bifrostObjectList.rep[ID][]->bifid[];
                  (if bifid[]
                   // none then
                      '%d: bifid[] is NONE - %s\n'
                        ->putFormat
                          (# 
                          do ID->d; 'indicates that this object is deleted'->s
                          #);
                      false->ok
                  if);
                  bifid.UD[]->UD[];
                  (if bifid[]
                   // none then
                      '%d: bifid.UD[] is NONE - SERIOUS ERROR\n'
                        ->putFormat (#  do ID->d #);
                      false->ok
                  if);
                  (if ok then INNER if)
               exit ok
               #);
             writeInt: userDataMethod
               (# data: @Integer enter data do (att,data)->UD.writeInt #);
             writeText: userDataMethod
               (# data: ^text
               enter data[]
               do (att,data[])->UD.writeText
               #);
             readInt: userDataMethod
               (# data: @integer
               do att->UD.readInt->(data,ok)
               exit data
               #);
             readText: userDataMethod
               (# data: ^text
               do att->UD.readText->(data[],ok)
               exit data[]
               #);
             deleteType: userDataMethod (#  do att->UD.deleteType #);
             writeUserData::< 
               (# bi: ^IDBifrost
               do
                  (if userDataVerbose then
                      '%d: write userdata\n'->putFormat (#  do ID->d #)
                  if);
                  bifrostObjectList.rep[ID][]->bi[];
                  '%% %d'->userdata.putFormat (#  do ID->d #);
                  userdata[]->bi.UD.save;
                  (if userDataVerbose then
                      ('\'%s\'\n')->putFormat (#  do userdata[]->s #)
                  if);
                  INNER ;
                  userdata.newline
               #);
             readUserData::<
               (#
                  bi: ^IDBifrost;
                  k,j: @integer;
                  ud: ^bi.UD.dataType;
                  ch: @char
               do
                  (if userDataVerbose then
                      'userdata: \'%s\''->putFormat (#  do userdata[]->s #)
                  if);
                  (* needed to keep track of the current designPicture *)
                  load_prevPicture[]->currentReadPicture[];
                  (* setup for reading userdata *)
                  0->userdata.pos;
                  userdata.get;
                  userdata.get;
                  (* '% ' *)
                  (* create ID <-> GO mapping *)
                  (* FIXME?? toby:
                   inserted remapping of ID if ID is already in use.
                   Used when loading graphics pages on the fly!
                   
                   userdata.getInt [* read ID from file *] ->ID;
                   (if (ID > bifrostObjectList.rep.range) or
                   (bifrostObjectList.rep[ID][] <> none ) then
                   >>1>> bifrostObjectList.newID->ID; 
                   else
                   ID [* make sure that this ID isn't used again *]
                   ->bifrostObjectList.newID.steal;
                   
                   if); *)
                  (* original pahe code: *)
                  userdata.getInt (* read ID from file *)
                    ->ID (* and make sure that this ID isn't used again *)
                    ->bifrostObjectList.newID.steal;
                  &IDBifrost[]->bi[];
                  (THIS(bifrostPage)[],THIS(designPicture)[],ID)->bi.init;
                  (if load_prevPicture[] <> none then
                      (if theMainPicture[] <> load_prevPicture[] then
                          true->isRegion
                      if)
                  if);
                  (* restore userdata *)
                  userdata[]->bi.UD.load;
                  INNER
               #);
             scanRegions: scanGOsReverse
               (# dp: ^designObject
               do
                  (if go## <= designPicture## then
                      go[]->dp[]; INNER scanRegions; 
                  if)
               #);
             scanSubRegions: scanGOsReverse
               (# dp: ^designObject
               do
                  (if go## <= designPicture## then
                      go[]->dp[];
                      INNER scanSubRegions;
                      &dp.scanSubRegions
                        (#  do INNER scanSubRegions #)
                  if)
               #);
             dump:< Object;
             interactiveMove::< 
               (# <<SLOT designPictureInteractiveMove: dopart>> #)
          #);
        showAllDesignPictures: window
          (# 
             myscroll:@textscrolllist
               (# 
                  text2coord:
                    (# 
                       t: ^text;
                       x,y:@integer;
                    enter t[]
                    do t.reset; t.get; t.getint->x; t.get; t.getint->y;
                    exit (x,y)
                    #);
                  eventhandler::
                    (# 
                       onSelect::
                         (# 
                         do item->gettext->text2coord->theScroller.theScroll;
                         #);
                    #);
                  itemlist:@list
                    (# element::text #);
                  boundsToText:
                    (# 
                       r: @rectangle;
                       t: ^text;
                    enter r
                    do
                       '('->t[]; r.x->t.putint; ','->t.put; 
                       r.y->t.putint; ','->t.put; 
                       r.width->t.putint; ','->t.put; 
                       r.height->t.putint; ')'->t.put;
                    exit t[]
                    #);
                  open::
                    (# 
                    do
                       (5,5)->position;
                       (180,280)->size;
                       true->bindLeft; true->bindBottom;
                       true->bindTop; true->bindRight;
                       itemlist.init;
                       scanDesignPictures
                       (# 
                       do 
                          (if bifrostObjectList.rep[inx].IO## <= designNode## then
                              bifrostObjectList.rep[inx].IO.getbounds->boundsToText->itemlist.append;
                          if);
                       #);
                       itemlist.size->append;
                       itemlist.scanFrom
                       (# 
                          i:@integer;
                       do i+1->i;
                          (i,current[])->setText;
                       #);
                    #);
               #);
             open::
               (# 
               do (100,100)->position;
                  (200,300)->size;
                  myscroll.open; 
               #);
          #);
        scanDesignPictures:
          (# inx: @integer
          do
             (for i:
             bifrostObjectList.rep.
               range repeat
               (if bifrostObjectList.rep[i][] <> none then
                   (if bifrostObjectList.rep[i].page[]
                    // THIS(bifrostPage)[] then i->inx; INNER
                   if)
               if)
             for)
          #);
        getNodes:
          (# ol: [0] @integer; cnt: @integer
          do
             scanDesignPictures
               (# 
               do
                  (if bifrostObjectList.rep[inx].IO## <= designNode## then
                      cnt+1->cnt; 
                  if)
               #);
             cnt->ol.new;
             scanDesignPictures
               (# 
               do
                  (if bifrostObjectList.rep[inx].IO## <= designNode## then
                      bifrostObjectList.rep[inx].IO.ID->ol[cnt]; cnt-1->cnt; 
                  if)
               #)
          exit ol
          #);
        getConnectors:
          (# ol: [0] @integer; cnt: @integer
          do
             scanDesignPictures
               (# 
               do
                  (if bifrostObjectList.rep[inx].IO## <= designConn## then
                      cnt+1->cnt; 
                  if)
               #);
             cnt->ol.new;
             scanDesignPictures
               (# 
               do
                  (if bifrostObjectList.rep[inx].IO## <= designConn## then
                      bifrostObjectList.rep[inx].IO.ID->ol[cnt]; cnt-1->cnt; 
                  if)
               #)
          exit ol
          #);
        designObject: designPicture
          (# (* attributes *)
             color: ^solidColor;
             selectable: @boolean;
             borderHidden: @boolean;
             groupHilight: ^abstractGraphicalObject;
             moveable,initialized: @boolean;
             (* methods *)
             writeUserData::< 
               (# sd,bhd: @integer
               do
                  (if selectable then 1->sd else 0->sd if);
                  (if borderHidden then 1->bhd else 0->bhd if);
                  ' %d %d '->userdata.putFormat (#  do sd->d; bhd->d #);
                  INNER
               #);
             readUserData::< 
               (# io: ^integerObject
               do
                  &integerObject[]->io[];
                  ID->io;
                  (if userdata.getInt
                   // 0 then false->selectable
                   else
                      true->selectable
                  if);
                  (if userdata.getInt
                   // 0 then false->borderhidden
                   else
                      true->borderhidden
                  if);
                  (* FIXME - color information should be saved
                   * - how about picture.getpaint?
                   *)
                  &solidColor[]->color[];
                  color.init;
                  black->color.RGBValues;
                  INNER ;
                  (* call pagecallback.makeDesignObject *)
                  
               #);
             initRegion:< (#  do true->isRegion; INNER #);
             unmakeRegion:< (#  do false->isRegion; INNER #);
             hideSelection:
               (# 
               do
                  (if designSelection <> none then
                      (designSelection).unhilite
                  if);
                  getBounds->damage;
                  INNER ;
                  getBounds->damage;
                  (if designSelection <> none then
                      (designSelection).hilite
                  if)
               #);
             modify:
               (# oldrepair: @boolean
               do
                  dontRepair->oldrepair;
                  true->dontRepair;
                  (if designSelection <> none then
                      (designSelection).unhilite
                  if);
                  getBounds->damage;
                  INNER ;
                  getBounds->damage;
                  (if designSelection <> none then
                      (designSelection).hilite
                  if);
                  oldrepair->dontRepair;
                  repair
               #);
             removeGroupHilight:< hideSelection
               (# doneInInner: @Boolean
               <<SLOT bifrostObjectRemoveGroupHilight:DoPart>>
               #);
             addGroupHilight:<
              hideSelection
               (# doneInInner: @Boolean
               <<SLOT bifrostObjectAddGroupHilight:DoPart>>
               #);
             getSize:<
               (# sz: @point
               do INNER
               exit sz
               #);
             setSize:<
               (# sz: @point
               enter sz
               do INNER
               #);
             getMyObject:
               (#
                  thePage:
                    ^theDocument.
                       page;
                  theObject: ^thePage.DesignObject;
                  
               <<SLOT bifrostObjectGetMyObject:DoPart>>
               #);
             onDoubleClick:<
              getMyObject (#  <<SLOT bifrostObjectOnDoubleClick:DoPart>> #);
             onTextModeOn:<
              getMyObject (#  <<SLOT bifrostObjectOnTextModeOn:DoPart>> #);
             onTextModeOff:<
              getMyObject (# <<SLOT bifrostObjectOnTextModeOff:DoPart>> #);
             onDrag:< getMyObject (# <<SLOT bifrostObjectOnDrag:DoPart>> #);
             onRightMouseDown:< getMyObject
               (# mousePos: @point
               enter MousePos
               <<SLOT bifrostObjectOnRightMouseDown:DoPart>>
               #);
             setColor:< modify
               (#
                  newColor: ^paint
               enter newColor[]
               <<SLOT bifrostObjectSetColor:DoPart>>
               #);
             setAbstractColor:
               (# newColor: ^solidColor
               do
                  &solidColor[]->newColor[];
                  newColor.init;
                  INNER ;
                  newColor[]->setColor
               #);
             new:<
               (#
                  bifid: ^IDBifrost;
                  c: (* Center coordinates *) @point;
                  t: (* Text to display *) ^text
               enter (c,t[])
               <<SLOT bifrostObjectNew:DoPart>>
               exit ID
               #);
             init::< 
               (# 
               <<SLOT bifrostObjectInit:DoPart>>
               #);
             hideBorder:< modify (#  do INNER ; true->borderHidden #);
             showBorder:< modify (#  do INNER ; false->borderHidden #);
             getCenter:<
               (# r: @Rectangle; c: @Point; doneInInner: @boolean
               <<SLOT bifrostObjectGetCenter:DoPart>>
               exit c
               #);
             setCenter:<
             (* FIXME: change modified status? *)
               (# r: @Rectangle; c: @Point; doneInInner: @boolean
               enter c
               <<SLOT bifrostObjectSetCenter:DoPart>>
               #);
             autoPanned: @Boolean;
             autoPan:<
               (#
                  vtl: @point;
                  (* view top left *)
                  vbr: @point;
                  (* view bottom right *)
                  stl: @point;
                  (* shape top left *)
                  sbr: @point;
                  (* shape bottom right *)
                  vs: @point;
                  (* viewSize *)
                  r: @Rectangle;
                  p: @point;
                  s: @point;
               <<SLOT bifrostObjectAutoPan:DoPart>>
               #);
             findSmallestHit:
               (#
                  canv: ^canvas;
                  mousepos: @point;
                  hitObject: ^designObject;
                  
               enter (canv[],mousepos)
               do
                  <<SLOT bifrostObjectFindSmallestHit:Descriptor>>;
                  
               exit hitObject[]
               #);
             hiliteLevel: @Integer;
             hiliteReset: (#  do 0->hiliteLevel #);
             hilite:<
               (# doneInInner: @boolean
               <<SLOT bifrostObjectHilite:DoPart>>
               #);
             unhilite:<
               (# doneInInner: @boolean
               <<SLOT bifrostObjectUnhilite:DoPart>>
               #);
             onSelect:< getMyObject
               (#  <<SLOT bifrostObjectOnSelect:DoPart>> #);
             remove:< modify
               (#
                  bifid: ^IDBifrost;
                  bnd: @rectangle
               <<SLOT bifrostObjectRemove:DoPart>>
               #);
             shapeBounds:<
               (# bnd: @rectangle do getBounds->bnd; INNER exit bnd #);
             shapeContainsPoint:< BooleanValue
               (# cv: ^bifrostCanvas; pt: @point
               enter (cv[],pt)
               do (cv[],pt)->containsPoint->value; INNER
               #);
             dumpSub: (#  <<SLOT bifrostObjectDumpSub:DoPart>> #);
             setLineThickness:< modify
               (# thick: @integer
               enter thick
               do INNER
               #);
             getLineThickness:<
               (# thick: @integer
               do INNER
               exit thick
               #);
             bringToFront: modify
               (# 
               <<SLOT bifrostObjectBringToFront:DoPart>>
               #);
             sendToBack: modify
               (#  <<SLOT bifrostObjectSendToBack:DoPart>> #);
             dump::< 
               (# 
               <<SLOT bifrostObjectDump:DoPart>>
               #)
          #);
        designConn: designObject
          (# (* attributes *)
             textToDelete: (* for backwards compatibility *) ^graphicText;
             connPrivate: @<<SLOT bifrostConnPrivate:Descriptor>>;
             end,begin: @point;
             (* methods *)
             writeUserData::< 
               (# 
               <<SLOT bifrostConnWrite:DoPart>>
               #);
             readUserData::<  (#  <<SLOT bifrostConnRead:DoPart>> #);
             getEnds:
               (# node1,node2: @integer
               <<SLOT bifrostConnGetEnds:DoPart>>
               exit (node1,node2)
               #);
             setEnds: modify
               (# node1,node2: @integer
               enter (node1,node2)
               <<SLOT bifrostConnSetEnds:DoPart>>
               #);
             orient:
               (#
                  o: @Integer;
                  getOrient:
                   <<SLOT bifrostConnGetOrient:Descriptor>>;
                  setOrient: <<SLOT bifrostConnSetOrient:Descriptor>>
               enter
                 (# 
                 enter o
                 do setOrient
                 #)
               exit
                 (# 
                 do getOrient
                 exit o
                 #)
               #);
             shapeDesc:: 
               (#
                  getBounds:: 
                    (# 
                    <<SLOT designConnShapeDescGetBounds:DoPart>>
                    #)
               #);
             setend: (#  enter end <<SLOT bifrostConnSetend:DoPart>> #);
             setbegin:
               (# 
               enter begin
               <<SLOT bifrostConnSetbegin:DoPart>>
               #);
             getCenter::  (#  <<SLOT bifrostConnGetCenter:DoPart>> #);
             setCenter:: 
               (# 
               <<SLOT bifrostConnSetCenter:DoPart>>
               #);
             hideBorder::  (#  <<SLOT bifrostConnHideBorder:DoPart>> #);
             showBorder:: 
               (# 
               <<SLOT bifrostConnShowBorder:DoPart>>
               #);
             new:: 
               (# start,end: @point; node1,node2: ^designNode
               enter (start,end,node1[],node2[])
               <<SLOT bifrostConnNew:DoPart>>
               #);
             init:: 
               (# 
               <<SLOT bifrostConnInit:DoPart>>
               #);
             hilite::<  (#  <<SLOT bifrostConnHilite:DoPart>> #);
             unhilite::< 
               (# 
               <<SLOT bifrostConnUnhilite:DoPart>>
               #);
             remove::<  (#  <<SLOT bifrostConnRemove:DoPart>> #);
             setPoints:
               (# pts: [0] @integer
               enter pts
               <<SLOT bifrostConnSetPoints:DoPart>>
               #);
             shapeContainsPoint::< 
               (#  <<SLOT bifrostConnShapeContainsPoint:DoPart>> #);
             setLineThickness::< 
               (# 
               <<SLOT bifrostConnSetLineThickness:DoPart>>
               #);
             getLineThickness::< 
               (#  <<SLOT bifrostConnGetLineThickness:DoPart>> #);
             dump:: 
               (#
                  bounds: @rectangle
               <<SLOT bifrostConnDump:DoPart>>
               #);
             moveRegions:
               (# oc,nc: @Point (* Old and New Center *)
               enter (oc,nc)
               <<SLOT bifrostConnMoveRegions:DoPart>>
               #)
          #);
        designNode: (* abstract *)
         designObject
          (# (* attributes *)
             nodePrivate: @<<SLOT bifrostNodePrivate:Descriptor>>;
             theText: ^graphicText;
             nodeCenter: @point;
             shDesc:<
              abstractGraphicalObject;
             filledShapeDesc:< abstractGraphicalObject;
             shape: ^shDesc;
             filledShape: ^filledShapeDesc;
             shapeColor: ^solidColor;
             filledShapeColor: ^paint;
             sizeable: @boolean;
             isDragged: @boolean;
             (* methods *)
             writeUserData::< 
               (# md,sd: @integer
               do
                  (if moveable then 1->md else 0->md if);
                  (if sizeable then 1->sd else 0->sd if);
                  ' %d %d %d %d '
                    ->userdata.putFormat
                      (# 
                      do md->d; sd->d; nodecenter.x->d; nodecenter.y->d
                      #);
                  INNER
               #);
             readUserData::< 
               (# pt: ^paint
               do
                  io[]->nodelist.insert;
                  (if userdata.getInt
                   // 0 then false->moveable
                   else
                      true->moveable
                  if);
                  (if userdata.getInt
                   // 0 then false->sizeable
                   else
                      true->sizeable
                  if);
                  userdata.getInt->nodecenter.x;
                  userdata.getInt->nodecenter.y;
                  shape.getPaint->pt[];
                  (if pt## <= solidColor## then
                      pt[]->shapeColor[]; 
                   else
                      color.copy->shapeColor[]
                  if);
                  filledShape.getPaint->filledShapeColor[];
                  &filledShape.theShape.hiliteDesc[]->filledShape.theShape.ho[];
                  INNER
               #);
             repositionText:< modify
               (# sb: (* shape bounds *) @rectangle
               <<SLOT bifrostNodeRepostionText:DoPart>>
               #);
             textJust: @
               (#
                  tj: @Integer;
                  set:
                    (# 
                    enter tj
                    <<SLOT bifrostNodeTextJustSet:DoPart>>
                    #)
               enter set
               exit tj
               #);
             textSize:
               (# bnd: @rectangle
               <<SLOT bifrostNodeTextSize:DoPart>>
               exit
               (bnd.width+4,bnd.height+4)
               #);
             setColor::< 
               (# 
               <<SLOT bifrostNodeSetColor:DoPart>>
               #);
             hideBorder::<  (#  <<SLOT bifrostNodeHideBorder:DoPart>> #);
             showBorder::< 
               (# 
               <<SLOT bifrostNodeShowBorder:DoPart>>
               #);
             getcenter::<  (#  <<SLOT bifrostNodeGetcenter:DoPart>> #);
             setCenter::< 
               (# 
               <<SLOT bifrostNodeSetCenter:DoPart>>
               #);
             startConnectors: @set (# element:: designConn #);
             endConnectors: @set (# element:: designConn #);
             new::< 
               (# textCoordinates:< (# p: @point do INNER exit p #)
               <<SLOT bifrostNodeNew:DoPart>>
               #);
             moveConnectors:
               (#
                  parent: ^designNode;
                  offset: @point
               enter (parent[],offset)
               <<SLOT bifrostNodeMoveConnectors:DoPart>>
               #);
             move::<  (#  <<SLOT bifrostNodeMove:DoPart>> #);
             interactivemove:: 
               (# hitNode: ^designNode
               <<SLOT bifrostNodeInteractivemove:DoPart>>
               #);
             shapeDesc::< 
               (#
                  hiliteOutLine::< (* see ~beta/bifrost/design/designlib *) 
                    (#  <<SLOT bifrostNodeHiliteOutLine:DoPart>> #)
               #);
             hilite::< 
               (# 
               <<SLOT bifrostNodeHilite:DoPart>>
               #);
             unhilite::<  (#  <<SLOT bifrostNodeUnhilite:DoPart>> #);
             remove::< 
               (# 
               <<SLOT bifrostNodeRemove:DoPart>>
               #);
             shapeBounds::<  (#  do shape.getBounds->bnd; INNER #);
             shapeContainsPoint::< 
               (# 
               do
                  (((cv[],pt)->shape.containsPoint) or
                   ((cv[],pt)->theText.containsPoint))->value;
                  (if filledShape[] <> none then
                      (value or ((cv[],pt)->filledShape.containsPoint))->value
                  if);
                  INNER
               #);
             onSize:< getMyObject (#  <<SLOT bifrostNodeOnSize:DoPart>> #);
             dump::< 
               (# t: @text; 
               <<SLOT bifrostNodeDump:DoPart>>
               #);
             textEdit:< (#  <<SLOT bifrostNodeTextEdit:DoPart>> #)
          #);
        designRect: designNode
          (#
             shDesc::< rect;
             filledShapeDesc::< rect;
             new::< 
               (#
                  textCoordinates:: 
                    (# 
                    <<SLOT bifrostRectTextCoordinates:DoPart>>
                    #);
                  sx,sy: @Integer;
                  (* Shape coordinates *)
                  w,h: @Integer;
                  (* Rect dimensions (width and height) *)
                  aRect,fs: ^rect;
                  
               enter (w,h)
               <<SLOT bifrostRectNew:DoPart>>
               #);
             initRegion::< 
               (# 
               <<SLOT bifrostRectInitRegtion:DoPart>>
               #);
             unmakeRegion::<  (#  <<SLOT bifrostRectUnmakeRegion:DoPart>> #);
             getSize::<  (#  do (shape.width,shape.height)->sz; INNER #);
             setSize::<  (#  do sz->(shape.width,shape.height); INNER #);
             setLineThickness::< 
               (#  <<SLOT bifrostRectSetLineThickness:DoPart>> #);
             getLineThickness::< 
               (# 
               <<SLOT bifrostRectGetLineThickness:DoPart>>
               #);
             dump:: 
               (# p: @point; aRect: ^rect; bounds: @rectangle; 
               <<SLOT bifrostRectDump:DoPart>>
               #)
          #);
        designEllipse: designNode
          (#
             new::< 
               (#
                  w,h: @Integer;
                  theEllipse: ^ellipse;
                  fs: ^ellipse
               enter (w,h)
               <<SLOT bifrostEllipseNew:DoPart>>
               #);
             containsPoint::< 
               (# 
               do
                  (if UI.extremelyVerbose then
                      '%d: contains point called\n'
                        ->putFormat (#  do ID->d #);
                      thePoint->putPoint;
                      newline;
                      getBounds->putBounds;
                      newline;
                      newline;
                      
                  if);
                  (theCanvas[],thePoint)->filledShape.containsPoint->value
                    ->doneInInner
               #);
             setLineThickness::< 
               (#  <<SLOT bifrostEllipeseSetLineThickness:DoPart>> #);
             getLineThickness::<
               (#  <<SLOT bifrostEllipeseGetLineThickness:DoPart>> #);
             dump:: 
               (# 
               <<SLOT bifrostEllipseDump:DoPart>>
               #)
          #);
        designPoly: designNode
          (#
             shDesc::< designPolyShape;
             filledShapeDesc::< designPolyFilledShape;
             setCenter::  (#  <<SLOT bifrostPolySetCenter:DoPart>> #);
             new:: 
               (# pl: [0] @Integer
               enter pl
               <<SLOT bifrostPolyNew:DoPart>>
               #);
             setLineThickness::< 
               (#  <<SLOT bifrostPolySetLineThickness:DoPart>> #);
             getLineThickness::< 
               (# 
               <<SLOT bifrostPolyGetLineThickness:DoPart>>
               #);
             dump::  (# bnd: @rectangle;  <<SLOT bifrostPolyDump:DoPart>> #)
          #);
        designLabel: designRect
          (#
             showBorder::  (#  <<SLOT bifrostLabelShowBorder:DoPart>> #);
             new:: 
               (# 
               <<SLOT bifrostLabelNew:DoPart>>
               #);
             setLineThickness::< 
               (#  <<SLOT bifrostLabelSetLineThickness:DoPart>> #);
             getLineThickness::< 
               (# 
               <<SLOT bifrostLabelGetLineThickness:DoPart>>
               #)
          #);
        theMainPicture: ^mainPicture;
        groupPicture: Picture
          (#
             interactivemove:: 
               (#  <<SLOT groupPictureInteractivemove:DoPart>> #);
             move:: 
               (# 
               <<SLOT groupPictureMove:DoPart>>
               #)
          #);
        mainPicture: designPicture
          (#
             plotPoint:
               (#
                  p: @point;
                  theText: ^graphicText;
                  color: ^solidColor;
                  t: ^text;
                  plotLine:
                    (# l: ^line; pb,pe: @point
                    enter (pb,pe)
                    do
                       &line[]->l[];
                       l.init;
                       color->l.setPaint;
                       pb->l.begin;
                       pe->l.end;
                       1->l.width;
                       capButt->l.cap;
                       (* l[] -> theScroller.contents.draw; *)
                       l[]->debugPicture.add
                    #)
               enter p
               do
                  &text[]->t[];
                  '%dx%d'
                    ->t.putFormat
                      (# 
                      do THIS(plotPoint).p.x->d; THIS(plotPoint).p.y->d
                      #);
                  p->design2bifrost->p;
                  40->solidGray->color[];
                  ((p.x-5,p.y),(p.x+5,p.y))->plotLine;
                  ((p.x,p.y-5),(p.x,p.y+5))->plotLine;
                  &graphicText[]->theText[];
                  theText.init;
                  color[]->theText.setPaint;
                  ((p.x+2,p.y+2),Courier,Plain,8,false,t[])->theText.initText;
                  (* theText[] -> theScroller.contents.draw; *)
                  theText[]->debugPicture.add
               #);
             debugPicture: ^Picture;
             group: ^groupPicture;
             readUserData:: 
               (# io: ^integerObject; ln: @integer; tl: ^text
               do
                  &integerObject[]->io[];
                  ID->io;
                  io[]->UI.pageList.insert;
                  userdata.getint->ln;
                  &text[]->tl[];
                  userdata.get;
                  (* eat one space *)
                  (for i: ln repeat userdata.get->tl.put for);
                  tl[]->THIS(bifrostPage).title;
                  reattachConnectors
               #);
             writeUserData::
             (* FIXME maybe.  Assumes that newline isn't in a valid
              * page name
              *) 
               (# tl: ^text
               do
                  THIS(bifrostPage).title->tl[];
                  ' %d %s '
                    ->userdata.putFormat (#  do tl.length->d; tl[]->s #)
               #);
             init:: 
               (# s,o,p: @point; color: ^solidColor
               do
                  &groupPicture[]->group[];
                  group.init;
                  &Picture[]->debugPicture[];
                  debugPicture.init;
                  &SolidColor[]->color[];
                  black->color.RGBvalues;
                  (* scale and center the "border" on the canvas *)
                  theScroller.contents.size->s;
                  (* scale the page to fit the screen *)
                  (currentPageSize.x div 15,currentPageSize.y div 15)->p;
                  (* center the page on the canvas *)
                  ((s.x-p.x) div 2,(s.y-p.y) div 2)->o;
                  (o.x-5,o.y-5)->theScroller.theScroll;
                  (* FIXME: border won't survive save/load if visible? *)
                  &rect[]->border[];
                  border.init;
                  color[]->border.setPaint;
                  true->border.theShape.stroked;
                  (* convert Bifrost CCS to guienv coordinates *)
                  (o.x,defaultCanvasSize.v-o.y)->border.theShape.upperLeft;
                  p.x->border.theShape.width;
                  p.y->border.theShape.height;
                  (if bordervis then border[]->add if);
                  (if UI.verbose then (* plot coordinates *)
                      (300,100)->plotPoint;
                      (300,200)->plotPoint;
                      (300,300)->plotPoint;
                      (300,400)->plotPoint;
                      (300,500)->plotPoint;
                      (300,600)->plotPoint;
                      (300,700)->plotPoint;
                      (300,800)->plotPoint;
                      (300,900)->plotPoint
                  if)
               #)
          #);
        eventHandler:: 
          (#
             onAboutToClose:: 
               (# aPage: ^theDocument.page
               do
                  false->okToClose;
                  theMainPicture.ID->theDocument.theObjectList.find->aPage[];
                  false->aPage.visible
               #);
             onActivate::  (#  <<SLOT bifrostPageOnActivate:DoPart>> #)
          #);
        theScroller: @scroller
          (#
             contentsType:: bifrostCanvas
               (#
                  ready: @boolean;
                  open:: 
                    (# 
                    do
                       defaultCanvasSize->size;
                       (* mannan: paper_A4 ->size; *)
                       &mainPicture[]->theMainPicture[];
                       theMainPicture.init
                    #);
                  eventHandler:: 
                    (#
                       onOpen::
                         (#
                         do
                            theMainPicture.debugPicture[]->draw;
                            theMainPicture[]->draw;
                            theMainPicture.group[]->draw;
                            true -> ready;
                            true -> menuBar.update
                         #);
                       onMouseDown:: 
                         (# 
                         do &<<SLOT bifrostPageOnMouseDown:Descriptor>>
                         #);
                       onKeyDown:: 
                         (# 
                         do
                            &
                               <<SLOT bifrostPageOnKeyDown:Descriptor>>
                         #);
                       onFatalError::
                         (# 
                         do 
                         #);
                    #)
               #);
             open:: 
               (# vs: @point
               do
                  defaultCanvasSize->contents.size;
                  theScroller.viewSize->vs;
                  (defaultCanvasSize.h div 2+vs.x div 2,defaultCanvasSize.v div
                   2+vs.y div 2)->theScroller.theScroll
               #)
          #);
        infoBar: @staticText
          (#
             open:: 
               (# 
               do
                  false->bindTop;
                  true->bindLeft;
                  true->bindBottom;
                  true->bindRight;
                  'Info:'->label
               #)
          #);
	zoomOption: @optionButton
	  (#
             zoomDialog: <<SLOT zoomDialogDesc: descriptor>>;
	     aMenu: @theGUI.menu;
	     fitToPageWidth: @aMenu.menuItem
	       (#
		  open:: (# do 'Pagewidth' -> name #);
		  eventHandler::
		    (# onSelect::
                         (#
                            vs,cs: @point;
                            cz,nz: @vector;
                         do 
                            theScroller.viewSize->vs;
                            theScroller.contents.size->cs;
                            zoom->cz;
                            cs.x/cz.x->cs.x;
                            vs.x/cs.x->nz.x;
                            (*
                            cs.y/cz.y->cs.y;
                            vs.y/cs.y->nz.y;
                            *)
                            (nz.x,nz.x)->zoom;
                         #)
                    #)
               #);
	     fitToPageHeight: @aMenu.menuItem
	       (#
		  open:: (# do 'Pageheight' -> name #);
		  eventHandler::
		    (# onSelect::
                         (#
                            vs,cs: @point;
                            cz,nz: @vector;
                         do 
                            theScroller.viewSize->vs;
                            theScroller.contents.size->cs;
                            zoom->cz;
                            cs.y/cz.y->cs.y;
                            vs.y/cs.y->nz.y;
                            (nz.y,nz.y)->zoom;
                         #)
                    #)
               #);
	     zoom033: @aMenu.menuItem
	       (#
		  open:: (# do '33%' -> name #);
		  eventHandler::
		    (# onSelect:: (# do (0.33,0.33) -> zoom #) #)
               #);
	     zoom075: @aMenu.menuItem
	       (#
		  open:: (# do '75%' -> name #);
		  eventHandler::
		    (# onSelect:: (# do (0.75,0.75) -> zoom #) #)
               #);
	     zoom100: @aMenu.menuItem
	       (#
		  open:: (# do '100%' -> name #);
		  eventHandler::
		    (# onSelect:: (# do (1.0,1.0) -> zoom #) #)
               #);
	     zoom125: @aMenu.menuItem
	       (#
		  open:: (# do '125%' -> name #);
		  eventHandler::
		    (# onSelect:: (# do (1.25,1.25) -> zoom #) #)
               #);
	     zoom150: @aMenu.menuItem
	       (#
		  open:: (# do '150%' -> name #);
		  eventHandler::
		    (# onSelect:: (# do (1.5,1.5) -> zoom #) #)
               #);
	     zoom200: @aMenu.menuItem
	       (#
		  open:: (# do '200%' -> name #);
		  eventHandler::
		    (# onSelect:: (# do (2.0,2.0) -> zoom #) #)
               #);
	     userdefine: @aMenu.menuItem
	       (#
		  open:: (# do 'Set to..' -> name #);
		  eventHandler::
		    (# onSelect:: (# do &zoomDialog; #)
                    #)
               #);
             
	     open::
               (#
		  def: @Integer
	       do
		  'Zoom' -> label;
                  false->bindTop;
                  false->bindLeft;
                  true->bindBottom;
                  true->bindRight;
		  aMenu.open;
		  fitToPageWidth.open; fitToPageWidth[] -> aMenu.append;
		  fitToPageHeight.open; fitToPageHeight[] -> aMenu.append;
		  zoom033.open; zoom033[] -> aMenu.append;
		  zoom075.open; zoom075[] -> aMenu.append;
		  zoom100.open; zoom100[] -> aMenu.append;
		  aMenu.noOfMenuitems -> def;
		  zoom125.open; zoom125[] -> aMenu.append;
		  zoom150.open; zoom150[] -> aMenu.append;
		  zoom200.open; zoom200[] -> aMenu.append;
		  userdefine.open; userdefine[] -> aMenu.append;
		  aMenu[] -> popupMenu;
		  def -> currentItem
               #)
          #);
        open::
          (# p, pp: @betapoint; pt: @point; left,top,bottom,right: @integer
          do
             nodelist.init;
             connlist.init;
             designGroup.init;
             defaultPageSize->currentPageSize;
             theScroller.open;
             theScroller.preferredSize->size->p;
             theScroller.viewSize->p.subtract;
             true->theScroller.bindTop;
             true->theScroller.bindLeft;
             true->theScroller.bindBottom;
             true->theScroller.bindRight;
             ((currentPageSize.x div 15+10,currentPageSize.y div 15+10),p)
               ->addPoints->size;
             (defaultCanvasSize,p)->addPoints->maxSize;
             (p.h+50,p.v+50)->minSize;
             true->visible;
             false->theScroller.bindBottom;
             (size,(0,50))->addPoints->pt->size;
             true->theScroller.bindBottom;
	     (* begin zoom option *)
	     zoomOption.open;
	     zoomOption.size -> p;
             (  pt.x - 2 - p.h,
		pt.y - 25 - ( p.v div 2 )
	      ) -> zoomOption.position;
	     (* end zoom option *)
             (* begin info bar *)
             infobar.open;
	     infobar.preferredSize -> pp;
             ( 2, pt.y - 25 - ( pp.v div 2 ) ) -> infobar.position;
	     ( pt.x - 4 - p.h , pp.v ) -> infobar.size;
             (* end info bar *)
             theGUI.screenRectangle->((left,top),(right,bottom));
             (((right-left) div 3)*2,((bottom-top) div 7)*4)->size;
             INNER
          #);
        rougeText: <<SLOT bifrostPageRougeText:Descriptor>>;
	pagePrivate: @<<SLOT bifrostPagePrivatePart: descriptor>>
     #);
   align:
     (#
        ar: ^cp.alignRects;
        cp: ^bifrostPage
     <<SLOT align:DoPart>>
     #);
   alignLeft:
    <<SLOT alignLeft:Descriptor>>;
   alignRight: <<SLOT alignRight:Descriptor>>;
   alignTop: <<SLOT alignTop:Descriptor>>;
   alignBottom:
    <<SLOT alignBottom:Descriptor>>;
   alignVertical: <<SLOT alignVertical:Descriptor>>;
   alignHorizontal:
    <<SLOT alignHorizontal:Descriptor>>;
   alignSpacing: <<SLOT alignSpacing:Descriptor>>;
   graphics:
     (# ar: ^cp.alignRects; cp: ^bifrostPage
     <<SLOT graphics:DoPart>>
     #);
   graphicsConn:
    <<SLOT graphicsConn:Descriptor>>;
   graphicsRect: <<SLOT graphicsRect:Descriptor>>;
   graphicsRndRect:
    <<SLOT graphicsRndRect:Descriptor>>;
   graphicsEllipse: <<SLOT graphicsEllipse:Descriptor>>;
   graphicsWedge:
    <<SLOT graphicsWedge:Descriptor>>;
   graphicsPoly: <<SLOT graphicsPoly:Descriptor>>;
   graphicsLine:
    <<SLOT graphicsLine:Descriptor>>;
   graphicsLabel: <<SLOT graphicsLabel:Descriptor>>;
   graphicsPicture:
    <<SLOT graphicsPicture:Descriptor>>;
   interactiveNewObject: ^object;
   interactiveNewConn: @boolean;
   veryVerbose: @boolean;
   extremelyVerbose: @boolean;
   menuVerbose: @boolean;
   warnDanger: @boolean;
   debugMark: @integer;
   verbose: @boolean;
   designPlatformExtentions: @<<SLOT designPlatformExtentions:Descriptor>>;
   getCVSinfo:
     (# msg: ^text
     do
        &text[]->msg[];
        '$Id: designobjectbody.bet,v 1.42 1999-08-27 07:49:17 toby Exp $'
          ->msg.putLine;
        <<SLOT bifrostobjectbodyCVSINFO:Descriptor>>;
        <<SLOT menubodyCVSINFO:Descriptor>>;
        <<SLOT pagebodyCVSINFO:Descriptor>>;
        <<SLOT documentbodyCVSINFO:Descriptor>>;
        <<SLOT userdatabodyCVSINFO:Descriptor>>
     exit msg[]
     #);
   getCVSinfoPS:
     (# PS: @text; op: @PS.putLine; ot: @PS.putText; cvs: ^text
     do
        PS.clear;
        '%%BeginResource: procset pahe-cvs-info 1.0 0'->op;
        UI.getCVSinfo->cvs[];
        cvs.reset;
        cvsloop:
          (# tmp: ^text
          do
             cvs.getLine->tmp[];
             (if tmp.length > 0 then '% '->ot; tmp[]->op; restart cvsloop if)
          #);
        '%%EndResource'->op;
        
     exit PS[]
     #)
enter theGUI[]
do
   (if bifrostDesignDebug then
       'UI dopart'->putLine; true->UI.verbose; true->theGUI.displayWarnings;
    else
   (* otherwise multiline complains all the time *)
       false->theGUI.displayWarnings
   if);
   (if theGUI[] = none then (failure,'theGUI = NONE')->stop if);
   bifrostObjectList.init;
   A4->defaultPageSize;
   (10000,10000)->defaultCanvasSize;
   pageList.init;
   designPlatformExtentions;
   (if UI.verbose then UI.getCVSinfo->putText;  if)
#)  

-- DesignAttributes: Descriptor --
(# (* revisit *)
   size,position: @point;
   update:
     (# 
     do
        (if THIS(designobject).ID <> 0 then
        (* The object is shown on screen, and needs to be updated *)
            INNER
        if)
     #);
   borderVisible: @Boolean;
   (* regionList: @objectList; *)
   (* parent: ^designObject; *)
   lookup:
     (# thePage: ^UI.bifrostPage
     do
        THIS(page).ID->UI.getApage->thePage[];
        (if thePage[]
         // none then
            '%d: can\'t lookup page #%d\n'
              ->putFormat (#  do ID->d; THIS(page).ID->d #);
            stop
        if);
        INNER
     #);
   lookupObject: lookup
     (#
        noSuchObject:< exception
          (# 
          do
             'Failed to lookup object with id %d\n'
               ->msg.putFormat (#  do ID->d #);
             INNER
          #);
        type:< thePage.designObject;
        theObject: ^type
     do
        (if UI.bifrostObjectList.rep[ID][]
         // none then noSuchObject
         else
            UI.bifrostObjectList.rep[ID].IO[]->theObject[]; INNER lookupObject
        if)
     #);
   lineThickness: @integer;
   setAutoPan: lookupObject
     (# v: @boolean enter v do v->theObject.autoPanned #);
   autoPan: lookupObject (#  do theObject.autoPan #);
   interactiveConn: @boolean;
   ic: ^Node
#)  

-- DesignenvOnInit: DoPart --
do (* This dopart is empty - revisit *)
   INNER oninit

-- InitObject: Descriptor --
(# 
do
   (if ID // 0 then 'initObject: ID // 0'->putLine if);
   (if UI.verbose then
       '%d: InitObject:descriptor called!\n'->putFormat (#  do ID->d #)
   if);
   ID
     ->UI.lookupDesignPicture
       (# objectDesc:: thePage.designObject
       do
          (if theObject.initialized then
              (if UI.warnDanger then
                  'InitObject %d called twice !#$@!*#!\n'
                    ->putFormat (#  do ID->d #)
              if)
          if);
          true->theObject.initialized;
          (* text init was here *)
          theObject.getSize->designAttributes.size;
          not theObject.borderHidden
            ->THIS(designObject).designAttributes.borderVisible
       #);
   (if userDataVerbose then
       'onInit called on id='->puttext; id->putint; newline
   if);
   THIS(DesignObject)[]->theObjectList.insert;
   IDUserDataAttributes.init;
   oldIDUserDataAttributes.init;
   UserDataStart->UserDataAttributes;
   IDUserDataAttributes->oldIDUserDataAttributes;
   IDUserDataStart->IDUserDataAttributes;
   UserDataID.init;
   (if userDataVerbose then
       'Reading UserDataID: '->puttext; UserDataID->putint; newline
   if);
   (UserDataID,ID)->UserDataIDMap.putID;
   (*toby 28-10-94:
    Update map of old id's to new id's and
    updata UserDataID to new ID.*)
   ID->UserDataID
#)  

-- NewObject: DoPart --
do
   (if UI.verbose then
       THIS(designObject)[]->getPatternName->putText;
       ' (NewObject:dopart) called!\n'->putText
   if);
   designAttributes.lookup
     (# dontRepair: @Boolean
     do (* THIS(page).ID->UI.getApage(# do aPage[] -> thePage[] #); *)
        UI.dontRepair->dontRepair;
        true->UI.dontRepair;
        true->THIS(designObject).designAttributes.borderVisible;
        INNER new;
        designAttributes.lookupObject
          (# 
          do designAttributes.lineThickness->theObject.setLineThickness
          #);
        ID->onInit;
        dontRepair->UI.dontRepair;
        thePage.repair;
        
     #)  

-- NodeNew: Descriptor --
(#
   newID: @Integer;
   createNode: designAttributes.lookup
     (#
        theObject: ^thePage.designNode; newID,ID,x,y,w,h,shape,dummy: @Integer
     enter (ID,x,y,w,h,shape)
     do
        ID->UI.getApage->thePage[];
        (if UI.verbose then
            'createNode called'->putLine;
            'ID: '->putText;
            ID->putInt;
            '\nx: '->putText;
            x->putInt;
            '\ny: '->putText;
            y->putInt;
            '\nw: '->putText;
            w->putInt;
            '\nh: '->putText;
            h->putInt;
            '\nshape: '->putText;
            shape->putInt;
            '\npagename: \''->putText;
            thePage.title->putText;
            '\''->putLine;
            
        if);
        (x,y)->THIS(designObject).designAttributes.position;
        (w,h)->THIS(designObject).designAttributes.size;
        (if shape
         // THIS(document).shape.rndRect // THIS(document).shape.rectangle then
              (# theRect: ^thePage.designRect; 
              do
                 &thePage.designRect[]->theObject[]->theRect[];
                 ((x,y)->UI.design2bifrost,theText.private.theText[],w,h)
                   ->theRect.new->newID
              #)
         // THIS(document).shape.ellipse then
              (# theEllipse: ^thePage.designEllipse; 
              do
                 &thePage.designEllipse[]->theObject[]->theEllipse[];
                 ((x,y)->UI.design2bifrost,theText.private.theText[],w,h)
                   ->theEllipse.new->newID
              #)
         // THIS(document).shape.polygon then
            'The polygon shape is not implemented yet!'->putLine
         // THIS(document).shape.wedge then
            'The wedge shape is not implemented yet!'->putLine
         // THIS(document).shape.picture then
            'The picture shape is not implemented yet!'->putLine
         // THIS(document).shape.line then
            'The line shape is not implemented yet!'->putLine
         // THIS(document).shape.straightConn then
            'The straightConn shape is not implemented yet!'->putLine
         // THIS(document).shape.curveTopConn then
            'The curveTopConn shape is not implemented yet!'->putLine
         // THIS(document).shape.curveSideConn then
            'The curveSideConn shape is not implemented yet!'->putLine
         else
            'The %d shape is not implemented yet!\n'
              ->putFormat (#  do shape->d #)
        if)
     exit newID
     #)
do
   (if UI.verbose then 'NodeNew:descriptor called!'->putLine if);
   (if not doneInInner then
       (if shape // 0 then THIS(Document).shape.rectangle->shape if);
       (THIS(Page).ID,x,y,w,h,shape)->createNode->ID
   if)
#)  

-- NewPolygon: Descriptor --
(# thePage: ^UI.bifrostPage; thePoly: ^thePage.designPoly
do
   (if UI.verbose then 'NewPolygon:descriptor called!'->putLine if);
   true->doneInInner;
   THIS(page).ID->UI.getApage->thePage[];
   &thePage.designPoly[]->thePoly[];
   ((x,y)->UI.design2bifrost,theText.private.theText[],points)->thePoly.new->ID
#)  

-- NewRegPoly: Descriptor --
(# 
do (if UI.verbose then 'NewRegPoly:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- NewLine: Descriptor --
(#  do (if UI.verbose then 'NewLine:descriptor called, but not implemented yet!'->putLine; if);  #)  

-- ObjectInteractiveNew: Descriptor --
(# 
do
   (if UI.verbose then
       'ObjectInteractiveNew:descriptor called! (%s)\n'
         ->putFormat (#  do msg[]->s #)
   if);
   THIS(designObject)[]->UI.interactiveNewObject[];
   INNER InteractiveNew;
   msg[]->UI.currentBifrostPage.infoBar.label
#)  

-- NodeInteractiveNew: Descriptor --
(# 
do (if UI.verbose then 'NodeInteractiveNew:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnInteractiveNew: Descriptor --
(# 
do
   (if UI.verbose then
       'ConnInteractiveNew:descriptor called!\n'->putFormat (#  do  #)
   if);
   (if ''->msg.equal then
       'Left click on the start node; then right click on end node'->msg.putText
   if);
   true->UI.interactiveNewConn;
   UI.currentBifrostPage.iaConn->UI.currentBifrostPage.interactiveState
#)  

-- PolygonInteractiveNew: Descriptor --
(# 
do (if UI.verbose then 'PolygonInteractiveNew:descriptor called, but not implemented yet!'->putLine if);
#)  

-- RegPolyInteractiveNew: Descriptor --
(# 
do
   (if UI.verbose then 'RegPolyInteractiveNew:descriptor called, but not implemented yet!'->putLine; if);
   
#)  

-- LineInteractiveNew: Descriptor --
(# 
do (if UI.verbose then 'LineInteractiveNew:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- RedrawDesignObject: Descriptor --
(# 
do (if UI.verbose then 'RedrawDesignObject:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ObjectSetSelectable: Descriptor --
designAttributes.lookupObject
  (# 
  do
     (if UI.verbose then
         THIS(designObject).ID->putInt;
         ': ObjectSetSelectable:descriptor called!'->putLine
     if);
     s->theObject.selectable;
     thePage.repair
  #)  

-- SetLineThickness: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: SetLineThickness: thick: %d!\n'
         ->putFormat (#  do ID->d; thick->d #)
   if);
   designAttributes.lookupObject
     (#
        noSuchObject:: 
          (#  do thick->designAttributes.lineThickness; true->continue #)
     do thick->theObject.setLineThickness
     #)
#)  

-- GetLineThickness: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: GetLineThickness:'->putFormat (#  do ID->d #)
   if);
   designAttributes.lookupObject
     (#
        noSuchObject:: 
          (#  do designAttributes.lineThickness->thick; true->continue #)
     do theObject.getLineThickness->thick
     #);
   (if UI.verbose then 'thick: %d!\n'->putFormat (#  do thick->d #) if)
#)  

-- SetLineType: Descriptor --
(# 
do (if UI.verbose then 'SetLineType:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- GetLineType: Descriptor --
(# 
do (if UI.verbose then 'GetLineType:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- SetBorderVisible: Descriptor --
designAttributes.lookupObject
  (# 
  do
     (if UI.verbose then
         THIS(designObject).ID->putInt;
         ': SetBorderVisible:descriptor called!'->putLine
     if);
     (if THIS(designObject).designAttributes.borderVisible then
         (if not b then theObject.hideBorder if)
      else
         (if b then theObject.showBorder if)
     if);
     b->THIS(designObject).designAttributes.borderVisible;
     thePage.repair
  #)  

-- GetBorderVisible: Descriptor --
(# 
do
   (if UI.verbose then
       ID->putInt; ': GetBorderVisible:descriptor called!'->putLine
   if);
   THIS(designObject).designAttributes.borderVisible->b
#)  

-- BringToFront: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: BringToFront\n'->putFormat (#  do ID->d #)
   if);
   designAttributes.lookupObject
     (# noSuchObject::  (#  do true->continue #)
     do theObject.bringToFront
     #)
#)  

-- SendToBack: Descriptor --
(# 
do
   (if UI.verbose then '%d: SendToBack\n'->putFormat (#  do ID->d #) if);
   designAttributes.lookupObject
     (# noSuchObject::  (#  do true->continue #)
     do theObject.sendToBack
     #)
#)  

-- BringForward: Descriptor --
(# 
do (if UI.verbose then 'BringForward:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ObjectGetSubPage: Descriptor --
(# 
do (if UI.verbose then 'ObjectGetSubPage:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ObjectGetParent: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: ObjectGetParent:descriptor called,'->putFormat (#  do ID->d #)
   if);
   l:
   ID
     ->UI.lookupDesignPicture
       (# 
       do
          none ->p[];
          (if not theObject.isRegion then
              (if UI.verbose then ' but isn\'t a region'->putText if); leave l
          if);
          (if theObject.load_prevPicture[]
           // none then
              (if UI.verbose then ' load_prevPicture[] is NONE'->putText if);
              leave l
          if);
          (if not (theObject.load_prevPicture## <= thePage.designObject##) then
              (if UI.verbose then
                  ' parent isn\'t a designObject'->putText
              if);
              leave l
          if);
          theObject.load_prevPicture.ID->theObjectList.find->p[];
          (if UI.verbose then
              (if p[]
               // none then ' p[] is NONE'->putText
               else
                  ' parent ID: %d'
                    ->putFormat (#  do theObject.load_prevPicture.ID->d #)
              if)
           else
              (if p[]
               // none then
                  'p[] is NONE in getParentObject: SHOULD NOT HAPPEN!!!'
                    ->putLine
              if)
          if)
       #);
   (if UI.verbose then '.'->putLine if);
   
#)  

-- ObjectGetTopParent: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: ObjectGetTopParent:descriptor called!\n'
         ->putFormat (#  do ID->d #)
   if);
   ID
     ->UI.lookupDesignPicture
       (# 
       do
          (if theObject.load_prevPicture[] <> none then
              (if theObject.load_prevPicture## <= thePage.designObject## then
                  theObject.load_prevPicture.ID->theObjectList.find->p[];
                  (if p.getParent <> none then p.getTopParent->p[] if)
              if)
          if)
       #)
#)  

-- SetRegionType: Descriptor --
(#
(* see ~beta/betaast/v5.2/betacfl-astInterfaceLib
 * beta.PatternDecl and beta.SimpleDecl
 *) 
do
   (if UI.verbose then
       'SetRegionType:descriptor called, but not implemented yet.\ntype: %d.\n'
         ->putFormat (#  do type->d #)
   if)
#)  

-- GetRegionIDs: DoPart --
do
   (if UI.verbose then
       '%d: GetRegionIDs:dopart called!\n'->putFormat (#  do ID->d #)
   if);
   ID
     ->UI.lookupDesignPicture
       (# 
       do
          theObject.scanRegions
            (#  do 1->regions.extend; dp.ID->regions[regions.range] #)
       #);
   (if UI.verbose then
       (for j: regions.range repeat
         '%d '->putFormat (#  do regions[j]->d #)
       for);
       (if regions.range > 0 then newline if)
   if)  

-- GetObjectsConnected: Descriptor --
(# 
do (if UI.verbose then 'GetObjectsConnected:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ObjectFitToText: Descriptor --
(# 
do (if UI.verbose then 'ObjectFitToText:descriptor called!'->putLine;  if); 
#)  

-- ObjectInitRegion: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: ObjectInitRegion:descriptor called!\n'
         ->putFormat (#  do ID->d #)
   if)
#)  

-- DesignTextPrivate: Descriptor --
(#
   theText: ^text;
   font,style,size: @Integer;
   underline: @Boolean;
   update:
     (#
        thePage: ^UI.bifrostPage;
        theObject: ^thePage.designObject;
        theNode: ^thePage.designNode
     do
        (if THIS(designobject).ID <> 0 then
        (* The object is shown on screen, and needs to be updated *)
            THIS(page).ID->UI.getApage->thePage[];
            UI.bifrostObjectList.rep[ID].IO[]->theObject[];
            (if theObject## <= thePage.designNode## then
                theObject[]->theNode[];
                theNode.modify
                  (#  do INNER update #)
             else
                'Connectors have no text'->putLine
            if)
        if)
     #);
   updateText: update (#  do theText[]->theNode.theText.theText #);
   updateFont: update (#  do font->theNode.theText.theFontName #);
   updateStyle: update (#  do style->theNode.theText.theStyle #);
   updateSize: update (#  do size->theNode.theText.size #);
   updateUnderline: update (#  do underline->theNode.theText.underline #)
#)  

-- DesignTextSet: Descriptor --
(# x,y: @Integer; ch: @char
do
   (if UI.verbose then
       ID->putInt;
       ': DesignTextSet:descriptor called! '->putText;
       '\''->putText;
       t[]->putText;
       '\', stripped: '->putText
   if);
   &text[]->private.theText[];
   t.reset;
   (for inx: t.length repeat
     t.get->ch; (if true (*ch >= ascii.sp*) then ch->private.theText.put if)
   for);
   (if UI.verbose then
       '\''->putText; private.theText[]->putText; '\''->putLine
   if);
   private.updateText
#)  

-- DesignTextGet: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: DesignTextGet:descriptor called!(%s)\n'
         ->putFormat (#  do ID->d; THIS(designText).private.theText[]->s #)
   if);
   t.clear;
   private.theText[]->t.putText
#)  

-- DesignTextClear: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: DesignTextClear:descriptor called!\n'->putFormat (#  do ID->d #)
   if);
   ''->private.theText[];
   private.updateText
#)  

-- DesignTextLength: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: DesignTextLength:descriptor called!\n'
         ->putFormat (#  do ID->d #)
   if);
   (if private.theText[] <> none then private.theText.length->l else 0->l if)
#)  

-- DesignTextParent: Descriptor --
(# 
do (if UI.verbose then 'DesignTextParent:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- DesignTextIsModeOn: Descriptor --
(# 
do
   (if UI.verbose then
       'DesignTextIsModeOn:descriptor called, but not implemented yet!'->putLine
   if)
#)  

-- DesignTextModeOn: Descriptor --
(# 
do 'DesignTextModeOn:descriptor called, but not implemented yet!'->putLine
#)  

-- DesignTextModeOff: Descriptor --
(# 
do (if UI.verbose then 'DesignTextModeOff:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- DesignTextMaxLineLength: Descriptor --
(# 
do
   (if UI.verbose then 'DesignTextMaxLineLength:descriptor called, but not implemented yet!'->putLine; if);
   
#)  

-- DesignTextFont: Descriptor --
(# 
do
   (if UI.verbose then
       ID->putInt; ': DesignTextFont:descriptor called!'->putLine; 
   if);
   f->private.font;
   private.updateFont
#)  

-- DesignTextStyle: Descriptor --
(# 
do
   (if UI.verbose then
       ID->putInt; ': DesignTextStyle:descriptor called!'->putLine; 
   if);
   s->private.style;
   private.updateStyle;
   
#)  

-- designTextSetSize: Descriptor --
(# 
do
   (if UI.verbose then
       ID->putInt; ': designTextSetSize:descriptor called!'->putLine; 
   if);
   s->private.size;
   private.updateSize;
   
#)  

-- designTextGetSize: Descriptor --
(# 
do
   (if UI.verbose then
       ID->putInt; ': designTextGetSize:descriptor called!'->putLine; 
   if);
   private.size->s;
   
#)  

-- DesignTextJust: Descriptor --
designAttributes.lookupObject
  (# theNode: ^thePage.designNode
  do
     (if UI.verbose then
         ID->putInt; ': DesignTextJust:descriptor called!'->putLine
     if);
     (if theObject## <= thePage.designNode## then
         theObject[]->theNode[];
         (if j
          // 0 then
             thePage.justification.default->theNode.textJust
          // THIS(document).textJust.LeftJustification then
             thePage.justification.left->theNode.textJust
          // THIS(document).textJust.Centered then
             thePage.justification.center->theNode.textJust
          // THIS(document).textJust.RightJustification then
             thePage.justification.right->theNode.textJust
         if);
         thePage.repair
     if)
  #)  

-- DesignTextWrap: Descriptor --
(# 
do
   (if UI.verbose then
       ID->putInt; ': DesignTextWrap:descriptor called!'->putLine; 
   if);
   (if b then
       (if UI.verbose then 'Wrapping is not implemented yet.'->putLine if)
   if)
#)  

-- getTextAttr: DoPart --
do 'getTextAttr:dopart called, but not implemented yet!'->putLine; INNER ;   

-- setTextAttr: DoPart --
do 'setTextAttr:dopart called, but not implemented yet!'->putLine; INNER ;   

-- DesignTextGetLength: Descriptor --
(# 
do (if UI.verbose then 'DesignTextGetLength:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- DesignTextSetDefaultFont: Descriptor --
(# 
do
   (if UI.verbose then 'DesignTextSetDefaultFont:descriptor called, but not implemented yet!'->putLine; if);
   
#)  

-- DesignTextSetDefaultJust: Descriptor --
(# 
do
   (if UI.verbose then 'DesignTextSetDefaultJust:descriptor called, but not implemented yet!'->putLine; if);
   
#)  

-- DesignTextSetDefaultSize: Descriptor --
(# 
do
   (if UI.verbose then 'DesignTextSetDefaultSize:descriptor called, but not implemented yet!'->putLine; if);
   
#)  

-- DesignTexSetDefaultStyle: Descriptor --
(# 
do
   (if UI.verbose then 'DesignTexSetDefaultStyle:descriptor called, but not implemented yet!'->putLine; if);
   
#)  

-- DesignTextSetSelection: DoPart --
do
   'DesignTextSetSelection:dopart called, but not implemented yet!'->putLine;
   INNER ;
     

-- DesignTextGetSelection: DoPart --
do
   'DesignTextGetSelection:dopart called, but not implemented yet!'->putLine;
   INNER ;
     

-- onTextModeOff: DoPart --
do 'onTextModeOff:dopart called, but not implemented yet!'->putLine; INNER ;   

-- onTextModeOn: DoPart --
do 'onTextModeOn:dopart called, but not implemented yet!'->putLine; INNER ;   

-- NodeAttributes: Descriptor --
(# 
do (if UI.verbose then 'NodeAttributes:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- NodeInit: Descriptor --
(# 
do
   (if UI.verbose then 'NodeInit:descriptor called!'->putLine if);
   ID
     ->UI.lookupDesignPicture
       (# objectDesc:: thePage.designNode
       do
          (if theText.private.theText[] = none then
              (if theObject.theText[] <> none then
                  theObject.theText.theText->theText.private.theText[]
               else
                  &text[]->theText.private.theText[]; 
              if)
          if)
       #);
   true->moveable;
   true->sizeable
#)  

-- NodeFitToText: DoPart --
do
   (if UI.verbose then 'NodeFitToText:dopart called!'->putLine if);
   THIS(designObject).designAttributes.update
     (# 
     do
        designAttributes.lookupObject
          (# type::< thePage.designNode
          do theObject.textSize->size; thePage.repair
          #)
     #)  

-- NodeMove: Descriptor --
(#  #)  

-- NodeSetGeometry: DoPart --
do 'NodeSetGeometry:dopart called, but not implemented yet!'->putLine; INNER  

-- NodeSetSize: DoPart --
do 'NodeSetSize:dopart called, but not implemented yet!'->putLine; INNER  

-- NodeOnSize: DoPart --
do 'NodeOnSize:dopart called, but not implemented yet!'->putLine; INNER  

-- GetRndRectRoundness: Descriptor --
(# 
do (if UI.verbose then 'GetRndRectRoundness:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- SetRndRectRoundness: Descriptor --
(# 
do (if UI.verbose then 'SetRndRectRoundness:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- GetWedgeAngles: Descriptor --
(# 
do (if UI.verbose then 'GetWedgeAngles:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- SetWedgeAngles: Descriptor --
(# 
do (if UI.verbose then 'SetWedgeAngles:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- PolyNoOfPoints: Descriptor --
(# 
do (if UI.verbose then 'PolyNoOfPoints:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- PolyPoints: Descriptor --
(# 
do (if UI.verbose then 'PolyPoints:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnVisProps: Descriptor --
(# initInteractive: ^object
do (failure,'ConnVisProps:descriptor called!')->stop
#)  

-- ConnGetArrowHead: Descriptor --
(# 
do (if UI.verbose then 'ConnGetArrowHead:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnGetOrient: Descriptor --
designAttributes.lookupObject
  (# type:: thePage.designConn
  do
     (if UI.verbose then
         '%i: ConnGetOrient:descriptor called!\n'->putFormat (#  do ID->i #)
     if);
     theObject.orient->o
  #)  

-- ConnSetOrient: Descriptor --
designAttributes.lookupObject
  (# type:: thePage.designConn
  do
     (if UI.verbose then
         '%i: ConnSetOrient: o: %i!\n'
           ->putFormat (#  do ID->i; THIS(orient).o->i #)
     if);
     o->theObject.orient;
     
  #)  

-- ConnGetPoints: Descriptor --
(# 
do (if UI.verbose then 'ConnGetPoints:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnSetPoints: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: ConnSetPoints:descriptor called!\n'->putFormat (#  do ID->d #); 
   if);
   ID
     ->UI.lookupDesignPicture
       (# objectDesc:: thePage.designConn
       do thePoints->theObject.setPoints
       #)
#)  

-- ConnSetHeadW: Descriptor --
(# 
do (if UI.verbose then 'ConnSetHeadW:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnGetHeadW: Descriptor --
(# 
do (if UI.verbose then 'ConnGetHeadW:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnSetHeadH: Descriptor --
(# 
do (if UI.verbose then 'ConnSetHeadH:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnGetHeadH: Descriptor --
(# 
do (if UI.verbose then 'ConnGetHeadH:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnSetShape: Descriptor --
(# 
do (if UI.verbose then 'ConnSetShape:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnGetShape: Descriptor --
(# 
do (if UI.verbose then 'ConnGetShape:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnSetBox: Descriptor --
(# 
do (if UI.verbose then 'ConnSetBox:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnGetBox: Descriptor --
(# 
do (if UI.verbose then 'ConnGetBox:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnGetEnds: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: ConnGetEnds:descriptor called!\n'->putFormat (#  do ID->d #)
   if);
   ID
     ->UI.lookupDesignPicture
       (# objectDesc:: thePage.designConn; n1,n2: @integer
       do
          theObject.getEnds->(n1,n2);
          n1->theDocument.theObjectList.Find->node1[];
          n2->theDocument.theObjectList.Find->node2[]
       #)
#)  

-- ConnSetEnds: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: ConnSetEnds:descriptor called! n1: %d r1: %d n2: %d r2: %d\n'
         ->putFormat
           (# 
           do
              ID->d;
              (if node1[] // none then - 1->d else node1.ID->d if);
              (if node1Rgn[] // none then - 1->d else node1Rgn.ID->d if);
              (if node2[] // none then - 1->d else node2.ID->d if);
              (if node2Rgn[] // none then - 1->d else node2Rgn.ID->d if)
           #)
   if);
   ID
     ->UI.lookupDesignPicture
       (# objectDesc:: thePage.designConn
       do
	  (node1Rgn.ID,node2Rgn.ID)->theObject.setEnds
       #)
#)  

-- ConnGetCurvature: Descriptor --
(# 
do (if UI.verbose then 'ConnGetCurvature:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnSetCurvature: Descriptor --
(# 
do (if UI.verbose then 'ConnSetCurvature:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ConnOnReattach: DoPart --
do
   (if UI.verbose then
       '%d: ConnOnReattach:dopart called!\n'->putFormat (#  do ID->d #)
   if);
   INNER  

-- designPaste: Descriptor --
(# 
do (if UI.verbose then 'designPaste:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- worldToPoints: DoPart --
do 'worldToPoints:dopart called, but not implemented yet!'->putLine; INNER ;   

-- designUtilsCallOAMenu: DoPart --
do
   'designUtilsCallOAMenu:dopart called, but not implemented yet!'->putLine;
   INNER ;
     

-- DesignenvOnInitTheGUI: DoPart --
do
   (if UI.verbose then 'DesignenvOnInitTheGUI:dopart called!'->putLine if);
   (if aGUI[] <> none then aGUI[]->UI else UI.theGui[]->aGUI[] if)  

-- designenvDoPart: DoPart --
do
   (if UI.verbose then 'designenvDoPart:DoPart called!'->putLine if);
   INNER ;
   onInit  

-- designEnvPrivate: Descriptor --
(# 
do (if UI.verbose then 'designEnvPrivate:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- nodeSetMoveable: Descriptor --
(# thePage: ^UI.bifrostPage; theNode: ^thePage.designNode; 
do
   (if UI.verbose then
       THIS(node).ID->putInt; ': nodeSetMoveable:descriptor called!'->putLine
   if);
   THIS(page).ID->UI.getApage->thePage[];
   UI.bifrostObjectList.rep[THIS(node).ID].IO[]->theNode[];
   b->theNode.moveable
#)  

-- nodeGetMoveable: Descriptor --
(# thePage: ^UI.bifrostPage; theNode: ^thePage.designNode; 
do
   (if UI.verbose then
       THIS(node).ID->putInt; ': nodeGetMoveable:descriptor called!'->putLine
   if);
   THIS(page).ID->UI.getApage->thePage[];
   UI.bifrostObjectList.rep[THIS(node).ID].IO[]->theNode[];
   theNode.moveable->b
#)  

-- nodeSetSizeable: Descriptor --
(# thePage: ^UI.bifrostPage; theNode: ^thePage.designNode; 
do
   (if UI.verbose then
       THIS(node).ID->putInt; ': nodeSetSizeable:descriptor called!'->putLine
   if);
   THIS(page).ID->UI.getApage->thePage[];
   UI.bifrostObjectList.rep[THIS(node).ID].IO[]->theNode[];
   b->theNode.sizeable
#)  

-- nodeGetSizeable: Descriptor --
(# thePage: ^UI.bifrostPage; theNode: ^thePage.designNode; 
do
   (if UI.verbose then
       THIS(node).ID->putInt; ': nodeGetSizeable:descriptor called!'->putLine
   if);
   THIS(page).ID->UI.getApage->thePage[];
   UI.bifrostObjectList.rep[THIS(node).ID].IO[]->theNode[];
   theNode.sizeable->b
#)  

-- NewConn: Descriptor --
(#
   createConn:
     (#
        newID,ID: @Integer;
        thePage: ^UI.bifrostPage;
        bifNode1,bifNode2: ^thePage.designNode;
        bifConn: ^thePage.designConn;
        
     enter ID
     do
        ID->UI.getApage->thePage[];
        UI.bifrostObjectList.rep[node1.ID].IO[]->bifNode1[];
        UI.bifrostObjectList.rep[node2.ID].IO[]->bifNode2[];
        &thePage.designConn[]->bifConn[];
        (* revisit - nodeX.center now unnecessary *)
        ((0,0),'',node1.center,node2.center,bifNode1[],bifNode2[])->bifConn.new
          ->newID->THIS(connector).ID;
        bifConn[]->bifNode1.startConnectors.insert;
        bifConn[]->bifNode2.endConnectors.insert
     exit newID
     #)
do
   (if UI.verbose then
       'NewConn:descriptor called! %d %d\n'
         ->putFormat (#  do node1.ID->d; node2.ID->d #)
   if);
   THIS(page).ID->createConn;
   (if visualAttributes.initInteractive[] <> none then
       visualAttributes.initInteractive
   if)
#)  

-- NewLabel: Descriptor --
(# thePage: ^UI.bifrostPage; theLabel: ^thePage.designLabel; 
do
   (if UI.verbose then 'NewLabel:descriptor called!'->putLine if);
   THIS(page).ID->UI.getApage->thePage[];
   &thePage.designLabel[]->theLabel[];
   &text[]->theText.private.theText[];
   txt[]->theText.private.theText.putText;
   ((x,y)->UI.design2bifrost,theText.private.theText[],10,10)->theLabel.new->ID;
   theLabel.textSize->size;
   false->theLabel.sizeable
#)  

-- SetFillType: Descriptor --
designAttributes.lookupObject
  (# 
  do
     (if UI.verbose then
           (# red,green,blue: @integer
           do
              (r,g,b)->(red,green,blue);
              '%d: RGB: (%d,%d,%d). SetFillType:descriptor called.\n'
                ->putFormat (#  do ID->d; (red,green,blue)->(d,d,d) #)
           #)
     if);
     (if r < 0 (* no fill *) then
         &thePage.paint[]->theObject.setColor
      else
         theObject.setAbstractColor (#  do (r,g,b)->newColor.RGBValues #)
     if)
  #)  

-- GetFillType: Descriptor --
(# 
do (if UI.verbose then 'GetFillType:descriptor called, but not implemented yet!'->putLine; if); 
#)  

-- ObjectGetConnectors: Descriptor --
(# theObject: ^designObject; regionList: ^objectList
do
   (if UI.verbose then
       '%d: ObjectGetConnectors:descriptor called!\n'
         ->putFormat (#  do ID->d #);
       (if UI.veryVerbose then UI.bifrostObjectList.rep[ID].IO.dump if)
   if);
   &objectList[]->theList[];
   ID
     ->UI.lookupDesignPicture
       (# dn: ^thePage.designNode
       do
          (if theObject## <= thePage.designNode## then
              theObject[]->dn[];
              dn.startConnectors.scan
                (# 
                do
                   current.ID->theObjectList.find->theList.insert;
                   (if UI.verbose then
                       'start: %d\n'->putFormat (#  do current.ID->d #)
                   if)
                #);
              dn.endConnectors.scan
                (# 
                do
                   current.ID->theObjectList.find->theList.insert;
                   (if UI.verbose then
                       'end: %d\n'->putFormat (#  do current.ID->d #)
                   if)
                #)
           else
              (if UI.verbose then 'This is an connector it self'->putLine if)
          if)
       #);
   GetRegionIDs->theObjectList.nodeIDsToList->regionList[];
   (if regionList[] <> none then
       regionList.scan
         (# subList: ^ObjectList
         do
            (if UI.verbose then
                '%d: region connectors\n'->putFormat (#  do ID->d #); 
            if);
            current[]->theObject[];
            theObject.getConnectors->subList[];
            (if subList[] <> none then
                sublist.scan (#  do current[]->theList.insert #)
            if)
         #);
       
   if);
   (if UI.verbose then 'Subconnectors '->putText; theList.dumpList if);
   (if theList.noOfElements // 0 then none ->theList[] if)
#)  

-- IndicateSelection: Descriptor --
(# 
do
   (if UI.verbose then
       '%d: IndicateSelection:descriptor called! (%s)\n'
         ->putFormat
           (#  do ID->d; (if on then 'true'->s else 'false'->s if) #)
   if);
   THIS(designObject).designAttributes.update
     (# thePage: ^UI.bifrostPage; theObject: ^thePage.designObject
     do
        THIS(page).ID->UI.getApage->thePage[];
        UI.bifrostObjectList.rep[THIS(designObject).ID].IO[]->theObject[];
        (if on then (* hilite go *)
            (if thePage.designSelection <> none then
                (thePage.designSelection).unhilite;
                (thePage.designSelection).hiliteReset
            if);
            theObject.hiliteReset;
            theObject.hilite
         else
        (* unhilite go if it is the selection - revisit semantics *)
            (if thePage.designSelection
             // theObject[] then
                (thePage.designSelection).unhilite;
                (thePage.designSelection).hiliteReset
            if)
        if);
        thePage.repair
     #)
#)  

-- setRepair: DoPart --
do
     (# currentPage: ^UI.bifrostPage
     do
        (theDocument.currentPage).ID->UI.getApage->currentPage[];
        (if b then
            UI.repairLevel-1->UI.repairLevel;
            (* 'repairLevel: %d ' -> putFormat(# do UI.repairLevel -> d #); *)
            (if UI.repairLevel <= 0 then (* '(do repair)' -> putLine; *)
                false->UI.dontRepair;
                (if currentPage.designSelection <> none then
                    (currentPage.designSelection).hiliteReset;
                    (currentPage.designSelection).hilite
                if);
                currentPage.repair;
                (if UI.repairLevel < 0 then
                    'repairLevel below zero - resetting'->putLine;
                    0->UI.repairLevel
                if)
             else
            (* newline *)
                
            if)
         else
            UI.repairLevel+1->UI.repairLevel;
            (if (UI.repairLevel = 1) and (currentPage.designSelection <> none )
             then
                (currentPage.designSelection).unhilite
            if);
            true->UI.dontRepair;
            (* 'repairLevel: %d (don\'t repair)\n' *)
            (* -> putFormat(# do UI.repairLevel -> d #); *)
            
        if)
     #)  

-- BasicMenuAtt: Descriptor --
(#
   name: @text;
   menuType: UI.theGUI.menu
     (# open::  (#  do itemList.scan (#  do current.insert #) #) #);
   menu: ^UI.theGUI.menu;
   (* no doPart *)
   
#)  

-- BasicMenuItemAtt: Descriptor --
(#
   name: @text;
   menuItemType: THIS(basicMenu).att.menu.menuItem
     (#
        eventHandler:: 
          (#
             onSelect::  (#  do hit #);
             onStatus::  (#  do (not disabled) and THIS(basicItem).OnStatus ->value #)
          #)
     #);
   menuItem: ^THIS(basicMenu).att.menu.menuItem;
   submenuIsOpen: @Boolean;
   submenu: ^UI.theGUI.menu;
   disabled: @boolean;
   (* no doPart *)
   
#)  

-- designDocumentOnInit: DoPart --
do
   'DesignDocument onInit!'->putline;
   DocEditMenu.init;
   DocCreateMenu.init;
   DocMakeupMenu.init;
   DocPageMenu.init;
   DocGroupMenu.init;
   DocTextMenu.init;
   DocAlignMenu.init;
   INNER  

-- designOAInit: DoPart --
do (* DocFileMenu.init; *) INNER  

