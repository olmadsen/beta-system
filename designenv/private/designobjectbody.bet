ORIGIN '../designenv';
BODY 'callbackbody';
INCLUDE '../designenvutils'
        '~beta/basiclib/v1.5/file'
        '~beta/sysutils/v1.5/endian'
        '~beta/designlib/v2.2/designlib';
(*OBJFILE default '$/ctextattr.o';*)
(*************************** ATTRIBUTES *******************************)
(*--lib:attributes--
 CSetTextAttr: external
 (# obj: @integer;
 font, size, style, just: @shortint;
 enter (obj, font, size, style, just)
 #);
 CGetTextAttr: external
 (# obj: @integer;
 size: @integer;
 enter obj
 exit size
 #);
 *)
(*OBJFILE default '$/ctextattr.o';*)
(*************************** ATTRIBUTES *******************************)
(*--lib:attributes--
 CSetTextAttr: external
 (# obj: @integer;
 font, size, style, just: @shortint;
 enter (obj, font, size, style, just)
 #);
 CGetTextAttr: external
 (# obj: @integer;
 size: @integer;
 enter obj
 exit size
 #);
 *)
(*OBJFILE default '$/ctextattr.o';*)
(*************************** ATTRIBUTES *******************************)
(*--lib:attributes--
 CSetTextAttr: external
 (# obj: @integer;
 font, size, style, just: @shortint;
 enter (obj, font, size, style, just)
 #);
 CGetTextAttr: external
 (# obj: @integer;
 size: @integer;
 enter obj
 exit size
 #);
 *)
(*OBJFILE default '$/ctextattr.o';*)
(*************************** ATTRIBUTES *******************************)
(*--lib:attributes--
 CSetTextAttr: external
 (# obj: @integer;
 font, size, style, just: @shortint;
 enter (obj, font, size, style, just)
 #);
 CGetTextAttr: external
 (# obj: @integer;
 size: @integer;
 enter obj
 exit size
 #);
 *)
-- UI: Descriptor --
designlib
  (#
     callback:: 
       (#
          initialize::< 
            (# 
            do
               <<SLOT EnableCallBacks:Descriptor>>;
               <<SLOT InitMenus:Descriptor>>;
               cursor.CrossHair->cursor.id;
               onInit;
               
            #);
          Abort::<  (#  do <<SLOT CallBackAbort:Descriptor>> #);
          MenuEvent::< 
            (# 
            do
               <<SLOT CallBackMenuEvent:Descriptor>>
            #);
          PostMenuEvent::< 
            (#  do <<SLOT CallBackPostMenuEvent:Descriptor>> #);
          PostPageChanged::< 
            (# 
            do
               <<SLOT CallBackPageChanged:Descriptor>>
            #);
          MouseDown::<  (#  do <<SLOT CallBackMouseDown:Descriptor>>;  #);
          Attach::< 
            (# 
            do
               <<SLOT CallBackAttach:Descriptor>>
            #);
          Coarsen::<  (#  do <<SLOT CallBackCoarsen:Descriptor>> #);
          Refine::< 
            (# 
            do
               <<SLOT CallBackRefine:Descriptor>>
            #);
          CreateObject::< 
            (#  do <<SLOT CallBackCreateObject:Descriptor>> #);
          ConnEndsGrammar::< 
            (#
               thePage:
                 ^theDocument.Page;
               theObject,theNode:
                 ^thePage.DesignObject;
               theConn:
                 ^thePage.connector
            <<SLOT CallBackConnEndsGrammar:DoPart>>
            #);
          ConnGrammar::<  (#  do <<SLOT CallBackConnGrammar:Descriptor>> #);
          PreDeleteNode::< 
            (#  do <<SLOT CallBackDelNodeGrammar:Descriptor>> #);
          PreDeleteRegion::< 
            (# 
            do
               <<SLOT CallBackDelRegionGrammar:Descriptor>>
            #);
          DelConnGram::< 
            (#  do <<SLOT CallBackDelConnGrammar:Descriptor>> #);
          Duplicate::< 
            (# 
            do
               <<SLOT CallBackDuplicate:Descriptor>>
            #);
          KbdEvent::< 
            (# L,A: [1] @integer <<SLOT CallBackKbdEvent:DoPart>> #);
          PostObjectSelect::< 
            (# 
            do
               <<SLOT CallBackPostObjectSelect:Descriptor>>
            #);
          PostObjectSize::< 
            (#  do <<SLOT CallBackPostObjectSize:Descriptor>> #);
          DoubleClick::< 
            (# 
            do
               <<SLOT CallBackDoubleClick:Descriptor>>
            #);
          ProcessDrag::<  (#  do <<SLOT CallBackDrag:Descriptor>> #);
          MakeRegionGrammar::< 
            (#  do <<SLOT CallBackMakeRgnGrammar:Descriptor>> #);
          UnMakeRegionGrammar::< 
            (# 
            do
               <<SLOT CallBackUnmakeRegionGrammar:Descriptor>>
            #);
          PaletteClick::< 
            (#  do <<SLOT CallbackPaletteClick:Descriptor>> #);
          TitleBarClicked::< 
            (#  do abortCommand #);
          
       #)
  do INNER
  #)  

-- DesignAttributes: Descriptor --
(#
   fill,line,thick: @Integer;
   visual: @Boolean;
   SetVisuals:
     (# 
     do
        (if (ID,line,thick,fill,visual)->UI.DSWtAttrObjectVisuals
         // false then 'ObjectSetVis: could not set'->putline
        if);
        
     #);
   GetVisuals:
     (# lineRef,thickRef,fillRef,visualRef: @IntegerRef; 
     do
        (ID,lineRef[],thickRef[],fillRef[],visualRef[])
          ->UI.DSRdAttrObjectVisuals;
        (lineRef,thickRef,fillRef,visualRef)->(line,thick,fill,visual);
        
     #);
   
#)
(************************* INITIALIZE OBJECTS *****************************)  

-- DesignenvOnInit: DoPart --
do UI.menuID.fileMenu->UI.DSMenuDeleteMenu; INNER onInit  

-- InitObject: Descriptor --
(# 
do
   (if userDataVerbose then
       'onInit called on id='->puttext; id->putint; newline
   if);
   THIS(DesignObject)[]->theObjectList.insert;
   IDUserDataAttributes.init;
   oldIDUserDataAttributes.init;
   UserDataStart->UserDataAttributes;
   IDUserDataAttributes->oldIDUserDataAttributes;
   IDUserDataStart->IDUserDataAttributes;
   UserDataID.init;
   (if userDataVerbose then
       'Reading UserDataID: '->puttext; UserDataID->putint; newline
   if);
   (UserDataID,ID)->UserDataIDMap.putID;
   (*toby 28-10-94:
    Update map of old id's to new id's and
    updata UserDataID to new ID.*)
   ID->UserDataID
#)  

-- RemoveObject: Descriptor --
(#  do THIS(DesignObject)[]->theDocument.theObjectList.delete;  #)  

-- NewObject: DoPart --
do
   UI.disable.CreateObjectCallBack;
   (* we don't like Design/OA to call us when we have created the object *)
   (* DSRdAttrSelectableFlag -> Selectable.s; CANNOT CALL THIS??? *)
   true->Selectable.s;
   INNER ;
   UI.enable.CreateObjectCallBack;
     

-- NodeNew: Descriptor --
(# 
do
(* (if true then
 '******** designobjectbody-NodeNew ********'->putline;
 'x: '->putText;
 x->putint;
 newLine;
 'y: '->putText;
 y->putint;
 newLine;
 'w: '->putText;
 w->putint;
 newLine;
 'h: '->putText;
 h->putint;
 newLine;
 
 if);*)
   (if not doneInInner then
       (if shape // 0 then THIS(Document).shape.rectangle->shape if);
       (THIS(Page).ID,x->wcoord,y->wcoord,w->wcoord,h->wcoord,shape)
         ->UI.DSStrCreateNode->onInit
   if);
   (* calling MakeNode in callback...*)
   
#)  

-- NewConn: Descriptor --
(#  do (THIS(Page).ID,node1.ID,node2.ID)->UI.DSStrCreateConn->onInit;  #)  

-- NewLabel: Descriptor --
(# 
do
   (THIS(Page).ID,x->wcoord,y->wcoord,w->wcoord,h->wcoord,txt)
     ->UI.DSStrCreateLabel->onInit;
   INNER new;
   
#)  

-- NewPolygon: Descriptor --
(# 
do
   (for i: points.range repeat points[i]->wcoord->points[i] for);
   (THIS(Page).ID,points.range div 2,@@ points[1])->UI.DSStrCreatePolygon
     ->onInit;
   (x,y)->move;
   true->doneInInner;
   
#)  

-- NewRegPoly: Descriptor --
(#  do 'NewRegPoly object: NYI'->putline #)  

-- NewLine: Descriptor --
(#  do 'NewLine object: NYI'->putline #) (* INTERACTIVE CREATE *)  

-- ObjectInteractiveNew: Descriptor --
(# 
do
   (if msg.empty // false then msg->statusbar.set if);
   CursorFormat;
   (if curs <> 0 // true then curs->cursor.set;  if);
   INNER InteractiveNew;
   (* Set up DesignObjectDesc in further bindings *)
   THIS(DesignObject)[]->theDocument.PrivatePart.InteractiveCreatedObject[];
   
#)  

-- NodeInteractiveNew: Descriptor --
(# menu: @Integer; 
do
   DesignNode##->DesignObjectDesc##;
   (if true
    // (THIS(Node)## <= GenericNode##) then
       (if shape
        // THIS(Document).shape.Rectangle then
           UI.menuID.createMenu.box->menu; 
        // THIS(Document).shape.Ellipse then
           UI.menuID.createMenu.ellipse->menu; 
        // THIS(Document).shape.Polygon then
           UI.menuID.createMenu.poly->menu; 
        // THIS(Document).shape.RndRect then
           UI.menuID.createMenu.round->menu; 
        // THIS(Document).shape.Wedge then
           UI.menuID.createMenu.wedge->menu; 
        // THIS(Document).shape.Picture then
           UI.menuID.createMenu.picture->menu; 
        else
           'else 1'->screen.putLine; 
       if);
       
    // (THIS(Node)## <= RectNode##) then
       UI.menuID.createMenu.box->menu; 
    // (THIS(Node)## <= EllipseNode##) then
       UI.menuID.createMenu.ellipse->menu; 
    // (THIS(Node)## <= PolygonNode##) then
       UI.menuID.createMenu.poly->menu; 
    // (THIS(Node)## <= RndRectNode##) then
       UI.menuID.createMenu.round->menu; 
    // (THIS(Node)## <= WedgeNode##) then
       UI.menuID.createMenu.wedge->menu; 
    // (THIS(Node)## <= PictureNode##) then
       UI.menuID.createMenu.picture->menu; 
    else
       'else 2'->screen.putLine; 
   if);
   (UI.menuID.createMenu,menu)->designUtils.CallOAMenu;
   (*(menu,curs) -> DSUIMenuExecuteModalWithCursor;*)
   
#)  

-- ConnInteractiveNew: Descriptor --
(# 
do
   DesignConnector##->DesignObjectDesc##;
   (UI.menuID.createMenu,UI.menuID.createMenu.conn)->designUtils.CallOAMenu;
   
#)  

-- PolygonInteractiveNew: Descriptor --
(# 
do
   DesignPolygon##->DesignObjectDesc##;
   (UI.menuID.createMenu,UI.menuID.createMenu.poly)->designUtils.CallOAMenu;
   
#)  

-- RegPolyInteractiveNew: Descriptor --
(# 
do DesignRegPoly##->DesignObjectDesc##; 'RegPoly object: NYI'->putline; 
#)  

-- LineInteractiveNew: Descriptor --
(# 
do DesignLine##->DesignObjectDesc##; 'Line object: NYI'->putline; 
#)
(***********)  

-- RedrawDesignObject: Descriptor --
(# 
do ID->UI.DSUIRedraw; 
#)
(******************************** GEOMETRIC  *******************************)  

-- ObjectGetCenter: Descriptor --
(# xref,yref: @IntegerRef; 
do
   (ID,xref[],yref[])->UI.DSRdAttrGetObjectCenter;
   xref->UI.DSUtilWorldToPoints->x;
   yref->UI.DSUtilWorldToPoints->y;
   
#)  

-- ObjectSetCenter: Descriptor --
(# 
do
   (if (ID,x->wcoord,y->wcoord)->UI.DSWtAttrObjectPosition
    // false then 'Setcenter: error '->putline
   if);
   
#)  

-- ObjectGetSize: Descriptor --
(# wref,href: @IntegerRef; 
do
   (ID,wref[],href[])->UI.DSRdAttrGetObjectSize;
   wref->UI.DSUtilWorldToPoints->w;
   href->UI.DSUtilWorldToPoints->h;
   INNER GetSize
#)  

-- ObjectSetSize: Descriptor --
(# 
do
   (if (ID,w->wcoord,h->wcoord)->UI.DSWtAttrAdjustObjectSize
    // false then 'SetSize: error'->putline; 
   if);
   INNER SetSize
#)  

-- ObjectSetGeometry: Descriptor --
(# 
do
   (if (ID,x->wcoord,y->wcoord)->UI.DSWtAttrObjectPosition
    // false then 'SetGeometry Center: error '->putline
   if);
   (if (ID,w->wcoord,h->wcoord)->UI.DSWtAttrAdjustObjectSize
    // false then 'SetGeometry Size: error'->putline
   if);
   INNER SetGeometry;
   
#)  

-- ObjectGetGeometry: Descriptor --
(# xref,yref,wref,href: @IntegerRef; 
do
   (ID,xref[],yref[])->UI.DSRdAttrGetObjectCenter;
   (ID,wref[],href[])->UI.DSRdAttrGetObjectSize;
   xref->UI.DSUtilWorldToPoints->x;
   yref->UI.DSUtilWorldToPoints->y;
   wref->UI.DSUtilWorldToPoints->w;
   href->UI.DSUtilWorldToPoints->h;
   INNER GetGeometry
#)  

-- ObjectSetSelectable: Descriptor --
(# MaskFlag: (#  exit 2 #); 
do
   (if (ID,MaskFlag,not s)->UI.DSWtAttrObjectFlags
    // false then 'SetSelectable: could not set'->putline
   if);
   
#)  

-- Move: Descriptor --
(# 
do
   (if (ID,x->wcoord,y->wcoord)->UI.DSWtAttrObjectPosition
    // false then 'ObjectMove: could not move object'->putline
   if);
   
#)
(*********************** VISUAL OPERATIONS **************************)  

-- SetLineThickness: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetLineThickness; ID is 0'->screen.putline; 
    else
       DesignAttributes.GetVisuals;
       thick->DesignAttributes.thick;
       DesignAttributes.SetVisuals;
       
   if);
   
#)  

-- GetLineThickness: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.thick->thick;  #)  

-- SetLineType: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetLineType; ID is 0'->screen.putline; 
    else
       (if (ID,line)->UI.DSWtAttrLineType
        // false then 'SetLineType: could not set type'->putline
       if)
   if);
   
#)  

-- GetLineType: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.line->line;  #)  

-- SetFillType: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetFill; ID is 0'->screen.putline; 
    else
       DesignAttributes.GetVisuals;
       fill->DesignAttributes.fill;
       DesignAttributes.SetVisuals;
       
   if);
   
#)  

-- GetFillType: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.fill->fill;  #)  

-- SetBorderVisible: Descriptor --
(# 
do
   (if ID
    // 0 then 'SetBorder; ID is 0'->screen.putline; 
    else
       b->DesignAttributes.visual; DesignAttributes.SetVisuals; 
   if);
   
#)  

-- GetBorderVisible: Descriptor --
(#  do DesignAttributes.GetVisuals; DesignAttributes.visual->b;  #)  

-- IndicateSelection: Descriptor --
(# 
do
   (if ID
    // 0 then 'IndicateSelection; ID is 0'->screen.putline; 
    else
       (ID,on)->UI.DSUIIndicateObject; 
   if);
   
#)  

-- BringForward: Descriptor --
(# 
do
   (if target[]
    // none then 'BringForward failed, target is none'->screen.putline; 
    else
       (if (ID,target.ID)->UI.DSUIBringForward
        // false then
           'BringForward failed, ID, target.ID: '->screen.putText;
           ID->screen.putInt;
           ', '->screen.putText;
           target.ID->screen.putInt;
           screen.newLine;
           
       if)
   if)
#)
(*********************** QUERY OPERATIONS **************************)  

-- ObjectGetSubPage: Descriptor --
(#  do ID->UI.DSRdAttrGetObjectSubPage->theObjectList.Find->p[];  #)  

-- ObjectGetParent: Descriptor --
(# 
do
   ID->UI.DSStrGetParent->theObjectList.Find->p[];
   (if p[] // none then 'GetParent: parent is none'->putline if);
   
#)  

-- ObjectGetTopParent: Descriptor --
(# 
do
   ID->UI.DSStrGetTopParent->theObjectList.Find->p[];
   (if p[] // none then 'GetTopParent: parent is none'->putline if);
   
#)  

-- GetRegionList: Descriptor --
(# count: @ShortRef; listRef: @IntegerRef; 
do
   (ID,count[],listRef[])->UI.DSStrGetObjectRegionList;
   (count,listRef)->getIntList->theObjectList.NodeIDsToList->theList[];
   
#)  

-- ObjectCreateRegion: Descriptor --
(# 
do (*disable.MakeRegionGrammarCallBack;*)
   (if (ID,parent.ID)->UI.DSStrMakeNodeIntoRgn
    // false then
       'CreateRegion: can''t create region'->putline;
       (*else
        (NONE,NONE) -> onInitRegion;*)
       
   if);
   (*enable.MakeRegionGrammarCallBack;*)
   
#)  

-- ObjectUnMakeRegion: Descriptor --
(# 
do (*disable.UnMakeRegionGrammarCallBack;*)
   (if ID->UI.DSStrMakeRgnIntoNode
    // false then 'UnMakeRegion: can''t unmake region'->putline; 
   if);
   (*false -> isRegion;
    enable.UnMakeRegionGrammarCallBack;*)
   
#)  

-- SetRegionType: Descriptor --
(# 
do
   (if isRegion
    // true then
       (if (ID,type)->UI.DSWtAttrRegionId
        // false then 'SetRegionType: can''t set'->putline
       if);
       
   if);
   
#)  

-- GetRegionIDs: DoPart --
do
     (# count: @ShortRef; listRef: @IntegerRef; 
     do
        (ID,count[],listRef[])->UI.DSStrGetObjectRegionList;
        (if count > 0 then (count,listRef)->getIntList->regions if);
        
     #)  

-- ObjectGetConnectors: Descriptor --
(# count: @ShortRef; listRef: @IntegerRef; 
do
   (ID,count[],listRef[])->UI.DSStrGetObjectConnList;
   (count,listRef)->getIntList->theObjectList.NodeIDsToList->theList[];
   
#)  

-- GetObjectsConnected: Descriptor --
(# inCount,outCount: @ShortRef; inListRef,outListRef: @IntegerRef; 
do
   (ID,inCount[],inListRef[],outCount[],outListRef[])
     ->UI.DSStrGetObjectInOutLists;
   ((inCount,inListRef)->getIntList)->theObjectList.NodeIDsToList->inList[];
   ((outCount,outListRef)->getIntList)->theObjectList.NodeIDsToList->outList[];
   
#)  

-- ObjectFitToText: Descriptor --
(# 
do
   (if ID->UI.DSUIFitBoxToText
    // false then 'FitText failed'->putline; 
   if);
   
#)  

-- DeleteObject: Descriptor --
(# 
do
   (if objectverbose
    // true then
       'DesignEnv: delete object ID: '->screen.puttext;
       ID->screen.putint;
       screen.newline;
       
   if);
   (if ID->UI.DSStrDeleteObject
    // false then
       'DeleteObject: can''t delete object'->screen.puttext;
       ID->screen.putint;
       screen.newline;
       
   if);
   
#)  

-- ObjectInitRegion: Descriptor --
(# 
do true->isRegion
#)
(******************** DESIGNTEXT *******************)  

-- DesignTextPrivate: Descriptor --
(#
   font,size,style,just: @shortint;
   (*@Integer;*)
   scBar: @integer;
   (* @Boolean; *)
   GetVal:
     (# fontRef,sizeRef,styleRef,justRef: @ShortRef; scBarRef: @IntegerRef; 
     do
        (if size
         // 0 then (* first time get default values *)
            (fontRef[],sizeRef[],styleRef[],justRef[],scBarRef[])
              ->UI.DSRdAttrGetTextDefaults;
            (*  'DEFAULT:'->putline;
             'fontref: '->puttext;
             fontref.r[1]->putint;
             newline;
             'styleref: '->puttext;
             styleref.r[1]->putint;
             newline;
             'sizeref: '->puttext;
             sizeref.r[1]->putint;
             newline;
             'justref: '->puttext;
             justref.r[1]->putint;
             newline;
             'scbarref: '->puttext;
             scbarref.r[1]->putint;
             newline;
             * *)
            (fontRef,sizeRef,styleRef,justRef,scBarRef)
              ->(font,size,style,just,scBar);
            
        if);
        
     #);
   
#)  

-- DesignTextSet: Descriptor --
(#  do (ID,t)->UI.DSTextPut #)  

-- DesignTextGet: Descriptor --
(# (*aStr: [64] @char;*) count: @ShortRef; 
do
(*  256->count;
 (ID,@@ aStr[1],count[])->UI.DSTextGet;
 @@ aStr[1]->cStringToCharRep->t;*)
   1000->t.extend;
   999->count;
   (if (ID,@@ t.T[1],count[])->UI.DSTextGet then
       
    else
       'UI.DSTextGet failed'->putline
   if);
   count->T.pos->T.lgth;
   
#)  

-- DesignTextClear: Descriptor --
(#  do (ID,'')->UI.DSTextPut #)  

-- DesignTextLength: Descriptor --
(# lref: @Shortref;  do (ID,lref[])->UI.DSTextGetLength; lref->l;  #)  

-- DesignTextParent: Descriptor --
(# textID: @Integer;  do ID->UI.DSTExtGetTextParent->textID;  #)  

-- DesignTextIsModeOn: Descriptor --
(#  do UI.DSTextIsModeOn->b;  #)  

-- DesignTextModeOn: Descriptor --
(#  do (if OKToEnter then True->UI.DSTextSetMode; onTextModeOn;  if) #)  

-- DesignTextModeOff: Descriptor --
(#  do (if OKtoExit then False->UI.DSTextSetMode; onTextModeOff;  if);  #)  

-- DesignTextMaxLineLength: Descriptor --
(#  do (* ID -> UI.DSTextMaxLineLength -> m; *) 0->m;  #)  

-- DesignTextFont: Descriptor --
(# fo: @shortint; 
do
   f->fo;
   private.getval;
   (ID,fo,private.size,private.style,private.just)->UI.DSTextSetAttr;
   f->private.font;
   
#)  

-- DesignTextStyle: Descriptor --
(# st: @shortInt
do
   s->st;
   private.getval;
   (ID,private.font,private.size,st,private.just)->UI.DSTextSetAttr;
   s->private.style
#)  

-- designTextSetSize: Descriptor --
(# (* i,f,si,st,ju: @shortint; *) 
do
(* (if true then
 'DesignTextSetSize callled with: '->putText; s->putInt; newLine
 if);*)
   private.getval;
   (ID,private.font,s,private.style,private.just)->UI.DSTextSetAttr;
   (*(if true then
    'private.font: '->putText;
    private.font->putInt;
    newLine;
    'private.size: '->putText;
    private.size->putInt;
    newLine;
    'private.style: '->putText;
    private.style->putInt;
    newLine;
    'private.just: '->putText;
    private.just->putInt;
    newLine;
    's: '->puttext;
    s->putint;
    newline;
    
    if);*)
   (* ID->i;
    private.font->f;
    s->si;
    private.style->st;
    private.just->ju;
    (i,f,si,st,ju)-> [*CSetTextAttr;*] UI.DSTextSetAttr; *)
   (* (if true then 'getting the size: '->putLine; getSize->putInt; newLine;  if)*)
   s->private.size
#)  

-- designTextGetSize: Descriptor --
(#
   OK: @boolean;
   fontRef,sizeRef,styleRef,justRef,heightRef,scBarRef: @ShortRef;
   font,style,just,height: @integer;
   
do
(*'Getting size via C:'->putline;
 id -> CGetTextAttr -> putint; newline;
 'Getting via BETA' -> putline;*)
   (ID,fontRef[],sizeRef[],styleRef[],justRef[],heightRef[],scBarRef[])
     ->UI.DSTextGetAttr->OK;
   (fontRef,sizeRef,styleRef,justRef,heightRef)->(font,s,style,just,height);
   (if OK then
   (*  (if true then
    'font: '->putText;
    font->putInt;
    newLine;
    'size: '->putText;
    s->putInt;
    newLine;
    'style: '->putText;
    style->putInt;
    newLine;
    'just: '->putText;
    just->putInt;
    newLine;
    'height: '->putText;
    height->putInt;
    newLine;
    
    if)*)
       
    else
       'Failed to read attributes: UI.DSTextGetAttr'->putLine
   if)
#)  

-- DesignTextJust: Descriptor --
(# ju: @shortint; 
do
   private.getval;
   j->ju;
   (ID,private.font,private.size,private.style,ju)->UI.DSTextSetAttr;
   j->private.just;
   
#)  

-- DesignTextWrap: Descriptor --
(#  do (ID,not b)->UI.DSTextSetNoWrap;  #)  

-- getTextAttr: DoPart --
do
     (# fontRef,sizeRef,styleRef,justRef,heightRef,scBarRef: @ShortRef
     do
        (ID,fontRef[],sizeRef[],styleRef[],justRef[],heightRef[],scBarRef[])
          ->UI.DSTextGetAttr;
        (fontRef,sizeRef,styleRef,justRef)->(font,size,style,just);
        INNER getAttributes
     #)  

-- setTextAttr: DoPart --
do (ID,font,size,style,just)->UI.DSTextSetAttr; INNER setAttributes  

-- DesignTextGetLength: Descriptor --
(# s: @shortRef;  do (ID,s[])->UI.DSTextGetLength; s->len;  #)  

-- DesignTextSetDefaultFont: Descriptor --
(#  do f->UI.DSTExtSetDefaultFont;  #)  

-- DesignTextSetDefaultJust: Descriptor --
(#  do j->UI.DSTextSetDefaultJust;  #)  

-- DesignTextSetDefaultSize: Descriptor --
(#  do s->UI.DSTextSetDefaultSize #)  

-- DesignTexSetDefaultStyle: Descriptor --
(# 
do s->UI.DSTextSetDefaultStyle; 
#)
(********************************** NODE *********************************)  

-- DesignTextSetSelection: DoPart --
do (ID,start,end)->UI.DSTextSetSelection  

-- DesignTextGetSelection: DoPart --
do
     (# startRef,endRef: ^integerRef
     do
        (ID,startRef[],endRef[])->UI.DSTextGetSelection;
        (startRef,endRef)->(start,end)
     #)  

-- onTextModeOff: DoPart --
do INNER  

-- onTextModeOn: DoPart --
do INNER  

-- NodeAttributes: Descriptor --
(#
   oldPosition: @Point;
   (* to prevent drags *)
   w,h: @Integer;
   (* to prevent resizes *)
   
#)  

-- NodeInit: Descriptor --
(# 
do
   Geometry
     ->
       (NodeAttributes.oldPosition.x,NodeAttributes.oldPosition.y,
        NodeAttributes.w,NodeAttributes.h);
   true->moveable;
   true->sizeable;
   
#)  

-- NodeFitToText: DoPart --
do
   geometry
     ->
       (NodeAttributes.oldPosition.x,NodeAttributes.oldPosition.y,
        NodeAttributes.w,NodeAttributes.h)  

-- NodeMove: Descriptor --
(# regions: ^ObjectList
do
   Center->NodeAttributes.oldPosition;
   GetRegionList->regions[];
   (if regions[] <> none
    // true then
       regions.scan
         (# aNode: ^Node; 
         do
            (if current## <= Node## then
                current[]->aNode[];
                aNode.Center->aNode.NodeAttributes.oldPosition
            if);
            
         #);
       
   if);
   
#)  

-- NodeSetGeometry: DoPart --
do
   (x,y)->NodeAttributes.oldPosition; (w,h)->(NodeAttributes.w,NodeAttributes.h)  

-- NodeSetSize: DoPart --
do
     (# regions: ^ObjectList
     do
        geometry
          ->
            (NodeAttributes.oldPosition.x,NodeAttributes.oldPosition.y,
             NodeAttributes.w,NodeAttributes.h);
        GetRegionList->regions[];
        (if regions[] <> none
         // true then
            regions.scan
              (# aNode: ^Node; 
              do
                 (if current## <= Node## then
                     current[]->aNode[];
                     geometry
                       ->
                         (aNode.NodeAttributes.oldPosition.x,
                          aNode.NodeAttributes.oldPosition.y,
                          aNode.NodeAttributes.w,aNode.NodeAttributes.h)
                 if)
              #);
            
        if)
     #)  

-- NodeOnSize: DoPart --
do
     (# regions: ^ObjectList
     do
        (if not sizeable then
            (NodeAttributes.oldPosition.x,NodeAttributes.oldPosition.y,
             NodeAttributes.w,NodeAttributes.h)->geometry
         else
        (* ok to resize; get new size *)
            geometry
              ->
                (NodeAttributes.oldPosition.x,NodeAttributes.oldPosition.y,
                 NodeAttributes.w,NodeAttributes.h);
            
        if);
        (* check the regions (which are also resized) of this node *)
        GetRegionList->regions[];
        (if regions[] <> none
         // true then
            regions.scan
              (# anObject: ^DesignObject; 
              do current[]->anObject[]; anObject.onSize; 
              #);
            
        if);
        INNER onSize
     #)  

-- NodeDrag: Descriptor --
(# regions: ^ObjectList; 
do
   (if moveable
    // false then
       (if CurrentObject
        // THIS(Node)[] then
        (* I am the only selected object; and I cannot be moved:
         * move back to old pos *)
           NodeAttributes.oldPosition->Move; 
        else
       (* ok to move; get new position *)
           Center->NodeAttributes.oldPosition; 
       if)
    else
   (* ok to move; get new position *)
       Center->NodeAttributes.oldPosition; 
   if);
   (* check the regions (which is also dragged) of this node *)
   GetRegionList->regions[];
   (if regions[] <> none
    // true then
       regions.scan
         (# aNode: ^Node; 
         do
            (if current## <= Node## then current[]->aNode[]; aNode.onDrag if);
            
         #);
       
   if);
   
#)
(*TOBY: sizeable should work like moveable, therefore
 changed to simple Boolean attribute.
 
 -- NodeSizeable: Descriptor --
 (# 
 
 NoSizingFlag: (#  exit 0x80 #); 
 do
 (if (ID,NoSizingFlag,not b)->UI.DSWtAttrObjectFlags
 // false then 'NodeSizeable: could not change'->screen.putline; 
 if);
 
 #)  
 *)  

-- GetRndRectRoundness: Descriptor --
(# wRef,hRef: @IntegerRef; 
do
   (if (ID,wRef[],hRef[])->UI.DSRdAttrBoxRoundness
    // false then 'RndRectRoundness: could not read roundness'->putline; 
   if);
   wRef->w;
   hRef->h;
   
#)  

-- SetRndRectRoundness: Descriptor --
(# 
do
   (if (ID,w,h)->UI.DSWtAttrSetBoxRoundness
    // false then 'RndRectRoundness: could not set roundness'->putline; 
   if);
   
#)  

-- GetWedgeAngles: Descriptor --
(# startRef,endRef: @IntegerRef; 
do
   (if (ID,startRef[],endRef[])->UI.DSRdAttrWedgeAngles
    // false then 'WedgeAngles: could not read angles'->putline; 
   if);
   startRef->start;
   endRef->end;
   
#)  

-- SetWedgeAngles: Descriptor --
(# 
do
   (if (ID,start,end)->UI.DSWtAttrSetWedgeAngles
    // false then 'WedgeAngles: could not set angles'->putline; 
   if);
   
#)
(*********************  POLYGON  *******************)  

-- PolyNoOfPoints: Descriptor --
(# count: @ShortRef; 
do (ID,count[])->UI.DSRdAttrPolyPointCount; count->no; 
#)  

-- PolyPoints: Descriptor --
(# count: @ShortRef
do
   (ID,count[])->UI.DSRdAttrPolyPointCount;
   (if count > 0 then
       2*count->p.extend;
       (ID,@@ p[1])->UI.DSRdAttrPolyPoints;
       (for i: 2*count repeat p[i]->UI.DSUtilWorldToPoints->p[i] for)
   if);
   
#)
(********************* CONNECTOR *******************)  

-- ConnVisProps: Descriptor --
(#
   headwidth,headheight,textw,texth,shape: @Integer;
   SetProps:
     (# 
     do
        (if (ID,headwidth,headheight,shape,textw,texth)->UI.DSWtAttrConnVisuals
         // false then 'SetConnProps: could not set'->putline
        if);
        
     #);
   GetProps:
     (#
        headwidthRef,headheightRef,shapeRef: @IntegerRef;
        textwRef,texthRef: @ShortRef;
        
     do
        (ID,headwidthRef[],headheightRef[],shapeRef[],textwRef[],texthRef[])
          ->UI.DSRdAttrConnProps;
        (headwidthRef,headheightRef,shapeRef,textwRef,texthRef)
          ->(headwidth,headheight,shape,textw,texth)
     #);
   
#)  

-- ConnGetArrowHead: Descriptor --
(#  do (ID,end)->UI.DSRdAttrArrowHeadType->end #)  

-- ConnGetOrient: Descriptor --
(#  do ID->UI.DSRdAttrConnOrient->o;  #)  

-- ConnSetOrient: Descriptor --
(#  do (ID,o)->UI.DSWtAttrConnOrient;  #)  

-- ConnGetPoints: Descriptor --
(#
   fisk: @integer;
   count: @ShortRef;
   list: [122] @Integer (* 2*MAXPOINTS(=61) *)
do
   (ID,count[],@@ list[1])->UI.DSRdAttrConnPoints;
   count->fisk;
   2*fisk->thePoints.extend;
   (for i: thePoints.range repeat
     list[i]->UI.DSUtilWorldToPoints->thePoints[i]
   for);
   
#)  

-- ConnSetPoints: Descriptor --
(# 
do
   (for i: thePoints.range repeat thePoints[i]->wcoord->thePoints[i] for);
   (ID,thePoints.range div 2,@@ thePoints[1])->UI.DSWtAttrSetConnPoints;
   
#)  

-- ConnSetHeadW: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   w->VisualAttributes.headwidth;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetHeadW: Descriptor --
(#  do VisualAttributes.GetProps; VisualAttributes.headwidth->w;  #)  

-- ConnSetHeadH: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   h->VisualAttributes.headheight;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetHeadH: Descriptor --
(#  do VisualAttributes.GetProps; VisualAttributes.headheight->h;  #)  

-- ConnSetShape: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   s->VisualAttributes.shape;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetShape: Descriptor --
(#  do VisualAttributes.GetProps; VisualAttributes.shape->s;  #)  

-- ConnSetBox: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   w->VisualAttributes.textw;
   h->VisualAttributes.texth;
   VisualAttributes.SetProps;
   
#)  

-- ConnGetBox: Descriptor --
(# 
do
   VisualAttributes.GetProps;
   VisualAttributes.texth->h;
   VisualAttributes.textw->w;
   
#)  

-- ConnGetEnds: Descriptor --
(# nd1,nd2: @IntegerRef; 
do
   (if (ID,rgn,nd1[],nd2[])->UI.DSRdAttrGetConnEnds
    // true then
       nd1->theObjectList.Find->node1[]; nd2->theObjectList.Find->node2[]; 
    else
       'GetEnds failed connector ID: '->puttext; ID->putint; newline; 
   if);
   
#)  

-- ConnSetEnds: Descriptor --
(# 
do
   (if (ID,node1.ID,node1Rgn.ID,node2.ID,node2Rgn.ID)->UI.DSWtAttrConnEndIDs
    // false then 'ConnSetEnds error'->putline
   if);
   
#)  

-- ConnGetCurvature: Descriptor --
(#  do ID->UI.DSRdAttrSegmentCurvature->curv;  #)  

-- ConnSetCurvature: Descriptor --
(#  do (ID,curv)->UI.DSWtAttrConnCurvature;  #)  

-- ConnOnReattach: DoPart --
do true->ok; INNER onReattach  

-- DocumentPrivatePart: Descriptor --
(#
   currentPageID: @Integer;
   coarsening: @Integer;
   (* no os pages currently made by coarsening
    * but not yet made as beta object *)
   doingCoarse: @Boolean;
   InteractiveCreatedObject: ^Object;
   hackw,hackh: @Integer;
   
#)  

-- designPaste: Descriptor --
(#
   help: ^text;
   theObject,theRegionObject: ^DesignObject;
   group,connectorsInGroup,connectorsInRegion: [0] @Integer;
   regions: [0] @Integer;
   theRegions: @ObjectList;
   count,connectorCount,regionConnectorCount: @ShortRef;
   list,connectorList,regionConnectorList: @IntegerRef;
   isGroup: @Boolean;
   ID: @integer;
   theIDObject: ^IDObject;
   theRegionIDMap: ^regionIDMap;
   regionIDMap: (* Same as UserDataIDMap - should be generalized! *)
     (#
        impl: [0] @Integer;
        putID:
          (# oldID,newID: @integer
          enter (oldID,newID)
          do
             (if oldID <> 0 then
                 (if oldID > impl.range then
                     oldID+impl.range->impl.extend
                 if);
                 newID->impl[oldID]
             if)
          #);
        getID: (# oldID: @integer enter oldID exit impl[oldID] #)
     #);
   visualizeObject:
     (#
        theObject: ^DesignObject;
        theNode,node1,node2: ^Node;
        theRndRectNode: ^RndRectNode;
        theWedgeNode: ^WedgeNode;
        thePolygonNode: ^PolygonNode;
        theRegPolyNode: ^RegPolyNode;
        theLabel: ^LabelNode;
        theConn: ^connector;
        t: @Text;
        x,y,w,h,selectable,lineThickness,lineType,fillType,borderVisible,wRound,
          hRound,start,end,orient,HeadHeight,HeadWidth,shape,textBoxW,textBoxH,
          curvature: @integer;
        font,size,style,just: @shortInt;
        nd1,nd2: @IntegerRef;
        points: [0] @Integer;
        getConnVisuals:
          (# 
          do
             theConn.orient->orient;
             theConn.Points->Points;
             theConn.HeadWidth->HeadWidth;
             theConn.HeadHeight->HeadHeight;
             theConn.shape->shape;
             theConn.TextBox->(textBoxW,textBoxH);
             theConn.Curvature->curvature
          #);
        setConnVisuals:
          (# 
          do
             orient->theConn.orient;
             (for i: points.range repeat points[i]+5->points[i] for);
             points->theConn.Points;
             HeadWidth->theConn.HeadWidth;
             HeadHeight->theConn.HeadHeight;
             shape->theConn.shape;
             (textBoxW,textBoxH)->theConn.TextBox;
             curvature->theConn.Curvature
          #);
        getVisuals:
          (# 
          do
             theObject.LineThickness->lineThickness;
             theObject.LineType->lineType;
             theObject.FillType->fillType;
             theObject.BorderVisible->borderVisible
          #);
        setVisuals:
          (# 
          do
             lineThickness->theObject.LineThickness;
             lineType->theObject.LineType;
             fillType->theObject.FillType;
             borderVisible->theObject.BorderVisible
          #);
        getText:
          (# 
          do
             (if theObject.theText.length > 0 then
                 theObject.theText.get->t;
                 theObject.theText.getAttributes->(font,size,style,just)
             if)
          #);
        setText:
          (# 
          do
             (if t.length > 0 then
                 t->theObject.theText.set;
                 (font,size,style,just)->theObject.theText.setAttributes
             if)
          #);
        moveDelta:
          (# x,y,w,h: @integer enter (x,y,w,h) exit (x+5,y+5,w,h) #)
     enter theObject[]
     do
        (if true
         // theObject## <= Rectnode## // theObject## <= EllipseNode## then
            theObject[]->theNode[];
            getVisuals;
            getText;
            theNode.geometry->moveDelta->theNode.new;
            setVisuals;
            setText
         // theObject## <= RndRectNode## then
            theObject[]->theRndRectNode[];
            getVisuals;
            getText;
            theRndRectNode.Roundness->(wRound,hRound);
            theRndRectNode.geometry->moveDelta->theRndRectNode.new;
            (wRound,hRound)->theRndRectNode.Roundness;
            setVisuals;
            setText
         // theObject## <= WedgeNode## then
            theObject[]->theWedgeNode[];
            getVisuals;
            getText;
            theWedgeNode.Angles->(start,end);
            start->designUtils.worldToPoints->start;
            (if start <> 0 then start div 2->start if);
            end->designUtils.worldToPoints->end;
            (if end <> 0 then end div 2->end if);
            theWedgeNode.geometry->moveDelta->theWedgeNode.new;
            (start,end)->theWedgeNode.Angles;
            setVisuals;
            setText
         // theObject## <= PolygonNode## then
            theObject[]->thePolygonNode[];
            getVisuals;
            getText;
            thePolygonNode.Points->points;
            (if points.range > 0 then
                thePolygonNode.geometry->moveDelta->(x,y,w,h);
                (x,y,w,h,points)->thePolygonNode.new;
                setVisuals;
                setText
             else
                'Trying to paste line - not yet implemented'->help[];
                help->UI.DSUIUserAckMessage
            if)
         // theObject## <= RegPolyNode## then
            theObject[]->theRegPolyNode[];
            getVisuals;
            getText;
            2*theRegPolyNode.NoOfPoints->points.extend;
            theRegPolyNode.Points->points;
            (if points.range > 0 then
                theRegPolyNode.geometry->moveDelta->(x,y,w,h);
                (x,y,w,h,points)->theRegPolyNode.new;
                setVisuals;
                setText
             else
                'Trying to paste line - not yet implemented'->help[];
                help->UI.DSUIUserAckMessage
            if)
         // theObject## <= LabelNode## then
            theObject[]->theLabel[];
            getVisuals;
            getText;
            theLabel.geometry->moveDelta->(x,y,w,h);
            (x,y,w,h,t)->theLabel.new;
            setVisuals;
            setText
         else
            (if theObject## <= Connector## then
                theObject[]->theConn[];
                getConnVisuals;
                getVisuals;
                getText;
                true->theConn.getEnds->(node1[],node2[]);
                (if (node1[] = none ) and (node2[] = none ) then
                (* iff node1 and node2 none then a single connector is on the clipboard *)
                    docEditMenu.pasteItem.execute
                 else
                    node1.ID->theRegionIDMap.getID->theObjectList.find->node1[];
                    node2.ID->theRegionIDMap.getID->theObjectList.find->node2[];
                    (node1[],node2[])->theConn.new;
                    setConnVisuals;
                    setVisuals;
                    setText
                if)
             else
                'Trying to paste unknown type of node'->help[];
                help->UI.DSUIUserAckMessage
            if)
        if)
     #);
   makeRegions:
     (#
        ID: @integer;
        count: @ShortRef;
        list: @IntegerRef;
        regions: [0] @Integer;
        theObject,theDesignObject,returnObject: ^DesignObject;
        theRegions: @ObjectList
     enter ID
     do
        (if (ID,count[],list[])->UI.DSStrGetObjectRegionList then
            (if count > 0 then
                (count,list)->GetIntList->regions;
                (for i: regions.range repeat
                  regions[i]->makeRegions->returnObject[];
                  returnObject[]->theRegions.insert;
                  
                for);
                
            if)
        if);
        ID->PageCallBack.MakeDesignObject->theObject[]->visualizeObject;
        (ID,theObject.ID)->theRegionIDMap.putID;
        theRegions.scan
          (# 
          do
             current[]->theDesignObject[];
             theObject[]->theDesignObject.createRegion
          #)
     exit theObject[]
     #)
do
   UI.DSStrGetCutOrCopiedObject->ID;
   (ID,count[],list[])->UI.DSStrGetNodeList;
   &RegionIDMap[]->theRegionIDMap[];
   (if count > 0 then
       (count,list)->GetIntList->group;
       (@@ group[1],count,connectorList[],connectorCount[])
         ->UI.DSStrGetInternalConnList;
       (connectorCount,connectorList)->GetIntList->connectorsInGroup;
       (for i: group.range repeat
         (@@ group[i],1,regionConnectorList[],regionConnectorCount[])
           ->UI.DSStrGetInternalConnList;
         (regionConnectorCount,regionConnectorList)->GetIntList
           ->connectorsInRegion;
         group[i]->makeRegions->theObject[];
         theObject.ID->group[i];
         (theObject.ID,theObject.ID)->theRegionIDMap.putID;
         (for i: connectorsInRegion.range repeat
           connectorsInRegion[i]->PageCallBack.MakeDesignObject->visualizeObject
         for)
       for);
       (for i: connectorsInGroup.range repeat
         connectorsInGroup[i]->PageCallBack.MakeDesignObject->visualizeObject
       for);
       group.range->count;
       (count,@@ group[1])->UI.DSStrSetCurGroup;
       
    else
       (if ID <> 0 then
           (@@ ID,1,regionConnectorList[],regionConnectorCount[])
             ->UI.DSStrGetInternalConnList;
           (regionConnectorCount,regionConnectorList)->GetIntList
             ->connectorsInRegion;
           ID->makeRegions->theObject[];
           (theObject.ID,theObject.ID)->theRegionIDMap.putID;
           (for i: connectorsInRegion.range repeat
             connectorsInRegion[i]->PageCallBack.MakeDesignObject
               ->visualizeObject
           for)
       if);
       (* theObject[]->currentObject *)
       
   if)
#)  

-- worldToPoints: DoPart --
do world->UI.DSUtilWorldToPoints->result  

-- designUtilsCreatePolygon: DoPart --
do (pageID,count,pointlist)->UI.DSStrCreatePolygon->polyID;   

-- designUtilsCallOAMenu: DoPart --
do
   item->UI.DSUIMenuExecute->ok;
   (if ok
    // 0 then
       'CallOAMenu failed: '->screen.puttext;
       item->screen.putint;
       screen.newline;
       
   if);
     

-- designEnvPrivate: Descriptor --
(#  #)  

-- designenvDoPart: DoPart --
do INNER designenv; UI  

