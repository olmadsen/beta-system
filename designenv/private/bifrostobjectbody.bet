ORIGIN 'designobjectbody';
INCLUDE '~beta/bifrost/EPSfile'
        '~beta/bifrost/RasterGrays'
	'aligndialog'
        '~beta/guienv/controls'
        '~beta/bifrost/private/Impl/GoImpl'
	'computeCenter'
        '~beta/bifrost/private/PS/EPSread';
MDBODY nti     'bifrostdesignNTbody'
       default 'bifrostdesignX11body';
-- bifrostobjectbodyCVSINFO:descriptor--
(#
do
   '$Id: bifrostobjectbody.bet,v 1.15 1998-07-28 15:16:53 toby Exp $'
     -> msg.putLine;
   <<SLOT bifrostobjectbodymdbodyCVSINFO:descriptor>>
#)

-- lib: attributes --
distanceToLine: (* algorithm from Graphical Gems II, p. 10-13 *)
  (# A, B, P: @point;
     idist: (* algorithm from Graphical Gems, p. 427-431 *)
       (# X, Y: @point; res: @integer
       enter (X, Y)
       do Y.h-X.h->abs->Y.h;
          Y.v-X.v->abs->Y.v;
          Y.h+Y.v-(((Y.h,Y.v)->min) div 2)->res;
       exit res
       #);
     d1: (* algorithm from Graphical Gems II, p. 10-13 *)
       (# a2: @integer; res: @integer
       do (P.v-A.v)*(B.h-A.h)-(P.h-A.h)*(B.v-A.v)->abs->a2;
          (((B.h-A.h)->abs)+((B.v-A.v)->abs)
	     -((((B.h-A.h)->abs,(B.v-A.v)->abs)->min) div 2))->res;
	  (if res <> 0 then a2 div res->res if)
       exit res
       #);
     d2: @integer;
  enter (A, B, P)
  do (if (P.h-A.h)*(B.h-A.h) + (P.v-A.v)*(B.v-A.v)<0 then
         (A,P)->idist->d2
      else
         (if (B.h-P.h)*(B.h-A.h) + (B.v-P.v)*(B.v-A.v)<0 then
             (B,P)->idist->d2
          else
             d1->d2
         if)
     if)
  exit d2
  #)

-- bifrostObjectGetMyObject: DoPart --
do
   theDocument.currentPage->thePage[];
   ID->theDocument.theObjectList.Find->theObject[];
   INNER

-- bifrostObjectOnDoubleClick: DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find double click object '->puttext; ID->putint; newline
    else
       theObject.onDoubleClick
   if)

-- bifrostObjectOnDrag: DoPart --
do
   (if theObject[]
    // none then 'Can\'t find dragged object '->puttext; ID->putint; newline
    else
       theObject.onDrag
   if)

-- bifrostObjectSetColor: dopart --
do
   INNER

-- bifrostNodeSetColor: dopart --
do
   (if filledShape[] <> NONE then
       newcolor[] -> filledShapeColor[] -> filledShape.setPaint;
   if);
   INNER

-- bifrostObjectNew: DoPart --
do
   (* create ID to GO mapping *)
   &IDBifrost[]->bifid[];
   (THIS(bifrostPage)[],THIS(designObject)[],bifrostObjectList.newID->ID)
     -> bifid.init;

   (* create a color, which is to be used by the specializations *)
   &solidColor[]->color[];
   color.init;
   black->color.RGBValues;

   init;
   INNER;

   c->setCenter;

   (* finally add this entity to the global community *)
   THIS(designObject)[]->THIS(bifrostpage).theMainPicture.add;
   THIS(designObject).getBounds -> THIS(bifrostpage).damage;
   (* THIS(bifrostpage).theScroller.contents.repair *)
   (* Update screen - revisit *)
   (* THIS(bifrostpage).theScroller.contents.update *)

-- bifrostObjectInit: DoPart --
do
   true->selectable;
   INNER

-- bifrostObjectGetCenter: DoPart --
do
   getbounds->r;
   INNER ;
   (if not doneInInner then
       r.x+r.width div 2->c.x; r.y-r.height div 2->c.y
   if)

-- bifrostObjectSetCenter: doPart --
do
   (#
      oldrepair: @boolean
   do
      dontRepair -> oldrepair;
      true -> dontRepair;
      (if designSelection <> NONE then (designSelection).unhilite if);
      getbounds->r;
      INNER setCenter;
      (if not doneInInner then
	  (if UI.verbose then
	      'Center to set c: %dx%d\n' -> putFormat
		(#  do THIS(setCenter).c.x->d; THIS(setCenter).c.y->d #);
	      'Shape bounds r: %dx%d\n' -> putFormat
		(#  do THIS(setCenter).r.x->d; THIS(setCenter).r.y->d #)
	  if);

	  c.x-r.width div 2->c.x;
	  c.y+r.height div 2->c.y;
	  (if THIS(bifrostPage).designSelection <> NONE then
	      (THIS(bifrostPage).designSelection).unHilite;
	      (c.x-r.x,c.y-r.y)->move;
	      (THIS(bifrostPage).designSelection).hilite
	   else
	      (c.x-r.x,c.y-r.y)->move;
	  if);

	  (if UI.verbose then
	      getbounds->r;
	      'Picture bounds r: %dx%d\n' -> putFormat
		(#  do THIS(setCenter).r.x->d; THIS(setCenter).r.y->d #)
	  if)
      if);
      (if autoPanned then autopan if);
      getBounds -> damage;
      (if designSelection <> NONE then (designSelection).hilite if);
      oldrepair -> dontRepair;
      repair
   #)

-- bifrostNodeRepostionText: doPart --
do
   shape.getBounds->sb;
   INNER repositionText;
   (#
      tc: (* text upperleft *) @point;
      tr: (* text bounds *) @rectangle
   do
      (if theText[] <> NONE then
	  getcenter -> tc;
	  theText.getBounds -> tr;
	  sb.y -> tc.y;

	  <<SLOT repositionTextAdjust: descriptor>>;

	  (if textJust
	   // justification.default
	   // justification.left then
	      tc.x - sb.width div 2 + 2 -> tc.x
	   // justification.right then
	      tc.x + sb.width div 2 - 2 -> tc.x
	   // justification.center then
	      tc.x - tr.width div 2     -> tc.x
	   else
	      (if UI.verbose then
		  '%d: unknown text justification %d\n'
		    -> putFormat(# do id -> d; textJust -> d #)
	      if)
	  if);
	  (tc.x-tr.x,tc.y-tr.y) -> theText.move
      if)
   #)

-- bifrostNodeTextJustSet:doPart --
do
   (if tj // justification.default then
       justification.left -> tj		(* revisit - default setting *)
   if);
   repositionText

-- bifrostObjectBringToFront: doPart --
do 
   THIS(designObject)[] -> theMainPicture.bringForward

-- bifrostObjectSendToBack: doPart --
do 
   THIS(designObject)[] -> theMainPicture.sendBehind

-- bifrostObjectDump: DoPart --
do
   'Start graphicalObject dump '->putText;
   (if isRegion then
       '(region)' -> putLine
    else
       '(top)' -> putLine
   if);
   'ID: '->putText; ID->putInt; newline;
   INNER ;
   'End graphicalObject dump.'->putLine

-- bifrostConnGetCenter: DoPart --
do
   true->doneInInner;
   connPrivate.theLine.TM -> connPrivate.theLine.theShape.computeCenter -> c

-- bifrostConnSetCenter: DoPart --
do
   true->doneInInner

-- bifrostConnSetend : doPart --
do
   (end,connPrivate.thePoints.npoints) -> connPrivate.thePoints.setPoint;
   connPrivate.setPoints

-- bifrostConnSetbegin : doPart --
do
   (begin,1) -> connPrivate.thePoints.setPoint;
   connPrivate.setPoints

-- bifrostConnWrite:doPart --
do
   ' %d %d %d %d %d %d %d ' -> userdata.putFormat
     (#
     do
	end -> (d,d); begin -> (d,d);
	connPrivate.orient -> d;
	connPrivate.node1.ID -> d;
	connPrivate.node2.ID -> d;
     #);
   INNER

-- bifrostConnRead:doPart --
do
   (userdata.getInt,userdata.getInt) -> end;
   (userdata.getInt,userdata.getInt) -> begin;
   userdata.getInt -> connPrivate.orient;
   userdata.getInt -> connPrivate.node1ID;
   userdata.getInt -> connPrivate.node2ID;
   io[] -> connlist.insert;
   &solidColor[] -> connPrivate.fatLineDebugColor[];
   connPrivate.fatLineDebugColor.init;
   orchid -> connPrivate.fatLineDebugColor.RGBValues;
   connPrivate.theLine.points -> connPrivate.thePoints[];
   INNER

-- bifrostPageReattachConnectors: descriptor--
connList.scan
  (#
  do
     (if UI.verbose then
	 'bifrostPage.reattachConnectors' -> putLine
     if);
     current -> lookupDesignPicture
       (#
	  objectDesc:: thePage.designConn;
	  bi: ^IDBifrost
       do
	  bifrostObjectList.rep[theObject.connPrivate.node1ID][] -> bi[];
	  bi.IO[] -> theObject.connPrivate.node1[];
	  theObject[] -> theObject.connPrivate.node1.startConnectors.insert;
	  bifrostObjectList.rep[theObject.connPrivate.node2ID][] -> bi[];
	  bi.IO[] -> theObject.connPrivate.node2[];
	  theObject[] -> theObject.connPrivate.node2.endConnectors.insert
       #)
  #)

-- bifrostConnGetEnds:doPart --
do
   connPrivate.node1.ID -> node1;
   connPrivate.node2.ID -> node2

-- bifrostConnSetEnds:doPart--
do
   this(designConn)[] -> connPrivate.node1.startConnectors.delete;
   this(designConn)[] -> connPrivate.node2.endConnectors.delete;

   bifrostObjectList.rep[node1].IO[] -> connPrivate.node1[];
   bifrostObjectList.rep[node2].IO[] -> connPrivate.node2[];

   this(designConn)[]->connPrivate.node1.startConnectors.insert;
   this(designConn)[]->connPrivate.node2.endConnectors.insert;
   connPrivate.setup

-- bifrostConnPrivate:descriptor --
(#
   (* attributes *)
   theLine: ^designConnLine;
   theFatLine: ^designConnFatLine;
   thePoints: ^pointArray;
   orient: @Integer;
   theArrow: ^bifrostConnArrow;
   node1,node2: ^designNode;
   node1ID,node2ID: @integer;
   fatLineDebugColor: ^solidColor;
   firstConnectPoint, lastConnectPoint: @point;
   (* methods *)
   movePoints:
     (#
	off: @point
     enter off
     do
	thePoints.scanPoints
	  (#
	  do
	     ((current,off) -> addPoints,inx) -> thePoints.setPoint
          #);
	setPoints;
	connect
     #);
   setPoints:
     (#
     enter thePoints[]
     do
	thePoints[] -> theLine.points;
	thePoints[] -> theFatLine.points;
	setConnectPoints
     #);
   setConnectPointsOrient:
     (#
     do (if thePoints.npoints>2 then
	    (if orient
	     // 0 (* No arrows *)
	     // 1 (* Arrow head at node 2 *)
	     // 3 (* Arrow head at both ends *) then
		thePoints.npoints-1 -> thePoints.getPoint->lastConnectPoint
	     // 2 (* Arrow head at node 1 *) then
		2->thePoints.getPoint->lastConnectPoint
	    if)
	 else
	    (if orient
	     // 0 (* No arrows *)
	     // 1 (* Arrow head at node 2 *)
	     // 3 (* Arrow head at both ends *) then
		node1.getCenter->lastConnectPoint
	     // 2 (* Arrow head at node 1 *) then
		node2.getCenter->lastConnectPoint
	    if)
	if);
	(if orient
	 // 0 (* No arrows *)
	 // 1 (* Arrow head at node 2 *)
	 // 3 (* Arrow head at both ends *) then
	    2 -> thePoints.getPoint -> firstConnectPoint
	 // 2 (* Arrow head at node 1 *) then
	    thePoints.npoints-1 -> thePoints.getPoint -> firstConnectPoint
	if)
     #);
   setConnectPoints:
     (#
     do (if thePoints.npoints>2 then
	    2->thePoints.getPoint->lastConnectPoint
	 else
	    node2.getCenter->lastConnectPoint
	if);
	thePoints.npoints-1 -> thePoints.getPoint -> firstConnectPoint
     #);
   bifrostConnArrow_USERDEF: graphicalObject
     (#
	drawme:
	  (#
	  do
	     (0,0) -> theShape.open;
	     (-10,-5) -> theShape.lineTo;
	     (-10, 5) -> theShape.lineTo;
	     (1,capButt,joinMiter) -> theShape.stroke;
	     theShape.close;
	     (-10,0) -> connectPoint
	  #);
	connectPoint: @point;
	position:
	  (# pt, pos: @point; a, cos_a, sin_a: @real;
	     PTM: @Matrix
	  enter (pt,pos)
	  do (pt.x,pt.y,pos.x,pos.y)->circleAngle->(a, cos_a, sin_a);
	     (cos_a, sin_a, -sin_a, cos_a, pos.x, pos.y)->PTM.set;
	     PTM[]->TM;
	     (-10,0)->(TM).transformPoint->connectPoint;
	  #);
     #);
   bifrostConnArrow: multiLine
     (#
	drawme:
	  (#
	  do
	     (0,0) -> theShape.addPoint;
	     (-10,-5) -> theShape.addPoint;
	     (-10, 5) -> theShape.addPoint;
	     (0,0) -> theShape.addPoint;
	     0 -> theShape.width;
	     capButt -> theShape.cap;
	     joinMiter -> theShape.join;

	     (-10,0)->connectPoint;
	  #);
	connectPoint: @point;
	position:
	  (# pt, pos: @point; a, cos_a, sin_a: @real;
	     PTM: @Matrix
	  enter (pt,pos)
	  do (pt.x,pt.y,pos.x,pos.y)->circleAngle->(a, cos_a, sin_a);
	     (cos_a, sin_a, -sin_a, cos_a, pos.x, pos.y)->PTM.set;
	     PTM[]->TM;
	     (-10,0)->(TM).transformPoint->connectPoint;
	  #);
     #);
   determinant:
     (# a, b, c, d: @integer
     enter (a, b, c, d)
     exit a*d-c*b
     #);
   intersect:
     (# x11,y11,x12,y12,x21,y21,x22,y22: @integer;
	a1,b1,c1,a2,b2,c2,d1,d2,d3,d4: @integer;
	res1, res2: @integer
     enter (((x11,y11),(x12,y12)),((x21,y21),(x22,y22)))
     do (-y11+y12)->a1; (x11-x12)->b1; -(x12*y11-y12*x11)->c1;
	(-y21+y22)->a2; (x21-x22)->b2; -(x22*y21-y22*x21)->c2;
	(c1,b1,c2,b2)->determinant->d1; (a1,c1,a2,c2)->determinant->d2;
	(a1,b1,a2,b2)->determinant->d3; (a1,b1,a2,b2)->determinant->d4;
	(if d3 <> 0 then
	    d1/d3  -> res1
	 else
	    maxint -> res1
        if);
	(if d4 <> 0 then
	    d2/d4 -> res2
	 else
	    maxint -> res2
        if)
     exit (res1,res2)
     #);
   connectPoint:
     (# b: @rectangle; p1,p2: @point; cp: @point;
	pl1,pl2,pl3,pl4: @point;
     enter (b,p1,p2)
     do (if (p1,p2)->equalPoint then
	    p1->cp;
	    leave connectPoint
	if);
	(if true
	 // (p2.y>b.y) then (* p2 above b *)
	    (b.x,b.y)->pl1;
	    (b.x+b.width,b.y)->pl2;
	 // (p2.y<b.y-b.height) then (* p2 below b *)
	    (b.x,b.y-b.height)->pl1;
	    (b.x+b.width,b.y-b.height)->pl2;
	 // (p2.x<b.x) then (* p2 left-of b *)
	    (b.x,b.y)->pl1;
	    (b.x,b.y-b.height)->pl2;
	 // (p2.x>b.x+b.width) then (* p2 right-to b *)
	    (b.x+b.width,b.y)->pl1;
	    (b.x+b.width,b.y-b.height)->pl2;
	 else (* p2 inside b *)
	    (if true
	     // (p2.y<b.y-(b.height div 2)) then (* p2 below b.center *)
		(b.x,b.y)->pl1;
		(b.x+b.width,b.y)->pl2;
	     // (p2.y>b.y-(b.height div 2)) then (* p2 above b.center *)
		(b.x,b.y-b.height)->pl1;
		(b.x+b.width,b.y-b.height)->pl2;
	     else (* p2 at b.center *)
		(if p2.x<>b.x then
		    (b.x,b.y)->pl1;
		    (b.x+b.width,b.y-b.height)->pl2;
		 else
		    (b.x+b.width,b.y)->pl1;
		    (b.x+b.width,b.y-b.height)->pl2;
		if)
	    if);
	if);
	((pl1,pl2),(p1,p2))->intersect->cp;
	(if true
	 // cp.x<pl1.x
	 // cp.x>pl2.x then
	    (if p1.x<p2.x then
		(b.x+b.width,b.y)->pl1;
		(b.x+b.width,b.y-b.height)->pl2;
	     else
		(b.x,b.y)->pl1;
		(b.x,b.y-b.height)->pl2;
	    if);
	    ((pl1,pl2),(p1,p2))->intersect->cp;
	if);
     exit cp
     #);
   connectOrient:
     (#
	b1,b2: @rectangle;
	p1,p2,pb,pe: @point
     do
 	(if orient
 	 // 0 (* No arrows *)
 	 // 1 (* Arrow head at node 2 *) then
	    node1.shape.getBounds->b2;
	    node2.shape.getBounds->b1;
	    node1.getCenter->p2;
	    node2.getCenter->p1;
 	    (if orient // 0 then &paint[] -> theArrow.setPaint if)
 	 // 2 (* Arrow head at node 1 *) then
	    node1.shape.getBounds->b1;
	    node2.shape.getBounds->b2;
	    node1.getCenter->p1;
	    node2.getCenter->p2;
 	 // 3 (* Arrow head at both ends *) then
	    node1.shape.getBounds->b2;
	    node2.shape.getBounds->b1;
	    node1.getCenter->p2;
	    node2.getCenter->p1;
 	    (* FIXME *)
	    'Arrowheads at both ends not implemented yet!' -> putLine
	if);
	INNER
     #);
   connect: connectOrient
     (#
	tp1,tp2: @point;
     do
	setConnectPoints;
	(if thePoints.npoints>2 then
	    lastConnectPoint->tp2
	 else
	    (b2,p2,p1)->connectPoint->tp2;
	if);
	(b1,p1,tp2)->connectPoint->pb;
	(tp2,pb)->theArrow.position;

	(if thePoints.npoints>2 then
	    firstConnectPoint->tp1;
	    p2 -> tp2
	 else
	    p1 -> tp1
        if);
	(b2,tp2,tp1)->connectPoint->pe;
	(if orient // 0 then
	    pb->setbegin
	 else
	    theArrow.connectPoint->setbegin
        if);
	pe->setend
     #);
   setup: connectOrient
     (#
     do
	(b1,p1,p2)->connectPoint->pb;
	(b2,p2,p1)->connectPoint->pe;
	(pe,pb)->theArrow.position;
	&pointArray[]->connPrivate.thePoints[];
	theArrow.connectPoint -> connPrivate.thePoints.addPoint;
	pe -> connPrivate.thePoints.addPoint;
	connPrivate.setPoints
     #);
   normalize:
     (* currently not used anywhere *)
     (* calculates the lower left, which is used for text-coordinates.
      * This is necessary for printing
      *)
     (#
	b1,b2: @rectangle; p1,p2: @point
     enter (b1,b2,p1,p2)
     do
	(b1.x,b2.x) -> min -> op.x;
	(b1.y,b2.y) -> min -> op.y;
     exit (b1,b2,p1,p2)
     #);
   op: @point;
   isEndPoint: booleanValue
     (#
	pt1,pt2: @point; whichEnd: @boolean
     enter pt1
     do
	1 -> thePoints.getPoint -> pt2;
	(if (pt1.x = pt2.x) and (pt1.y = pt2.y) then
	    true -> value; true -> whichEnd
	if);
	thePoints.npoints -> thePoints.getPoint -> pt2;
	(if (pt1.x = pt2.x) and (pt1.y = pt2.y) then true -> value if)
     exit whichEnd
     #);
   damaged:
     (#
     do
	theArrow.getBounds -> damage;
	theLine.getBounds -> damage;
	thefatLine.getBounds -> damage
     #)
#)

-- designConnShapeDescGetBounds: dopart --
do
   (bound,(connPrivate.theArrow.getShape).getBounds)->rectUnion->bound;
   (bound,(connPrivate.theLine.getShape).getBounds)->rectUnion->bound

-- bifrostConnNew: DoPart --
do
   (if UI.verbose then
       ID->putInt; ': designConn.new called!'->putLine
   if);
   (node1[],node2[]) -> (connPrivate.node1[],connPrivate.node2[]);

   &designConnLine[]->connPrivate.theLine[];
   connPrivate.theLine.init;
   color[]->connPrivate.theLine.setPaint;
   CapRounded->connPrivate.theLine.theShape.cap;
   1->connPrivate.theLine.width;
   capButt -> connPrivate.theLine.cap;

   (* a fat line makes it easier to hit the connector *)
   &solidColor[] -> connPrivate.fatLineDebugColor[];
   connPrivate.fatLineDebugColor.init;
   orchid -> connPrivate.fatLineDebugColor.RGBValues;

   &designConnFatLine[]->connPrivate.theFatLine[];
   connPrivate.theFatLine.init;
   connPrivate.fatLineDebugColor[]->connPrivate.theFatLine.setPaint;
   7->connPrivate.theFatLine.width;
   capButt -> connPrivate.theFatLine.cap;

   1 (* arrow at node 2 *) -> connPrivate.orient;
   &connPrivate.bifrostConnArrow[] -> connPrivate.theArrow[];
   connPrivate.theArrow.init;
   connPrivate.theArrow.drawme;
   color[]->connPrivate.theArrow.setPaint;

   connPrivate.theFatLine[]->THIS(designConn).add;
   connPrivate.theLine[]->THIS(designConn).add;
   connPrivate.theArrow[]->THIS(designConn).add;
   connPrivate.setup;

   (* this seems to work better *)
   &paint[]->connPrivate.theFatLine.setPaint

-- bifrostConnInit: DoPart --
do
   (* FIXME - empty doPart *)

-- bifrostConnDump: DoPart --
do 'This is a connector'->putLine;
   getBounds->bounds;
   'Bounds: '->putText;
   bounds.x->putInt;
   'x'->putText;
   bounds.y->putInt;
   ' width: '->putText;
   bounds.width->putInt;
   ',height: '->putText;
   bounds.height->putInt;
   newline;
   'Points: '-> putText;
   connPrivate.thePoints.scanPoints
     (# do current -> putPoint #);
   newline

-- bifrostConnHideBorder:DoPart --
do
   &paint[] -> connPrivate.theLine.setPaint;
   &paint[] -> connPrivate.theArrow.setPaint

-- bifrostConnShowBorder:DoPart --
do
   color[] -> connPrivate.theLine.setPaint;
   color[] -> connPrivate.theArrow.setPaint

-- bifrostNodeHideBorder: DoPart --
do
   &paint[] -> shape.setPaint;
   (if filledShape[] <> NONE then &paint[] -> filledShape.setPaint if);
   &shape.theShape.hiliteDesc[] -> shape.theShape.ho[];
   INNER

-- bifrostNodeShowBorder: DoPart --
do
   shapeColor[]->shape.setPaint;
   (if filledShape[] <> NONE then
       filledShapeColor[] -> filledShape.setPaint
   if);
   &shape.theShape.hiliteOutline[] -> shape.theShape.ho[];
   (* don't make the filledShape outline visible, as this might
    * interfere with the shapes outline
    *)
   INNER

-- bifrostLabelShowBorder:DoPart --
do
   &paint[] -> shape.setPaint

-- bifrostNodeGetcenter: DoPart --
do
   shape.getbounds->r; INNER

-- bifrostNodeSetCenter: DoPart --
do
   (*'nodesetcenter'->putline;*)
   c->nodeCenter;
   startConnectors.scan
     (#
     do
	current.connPrivate.damaged;
	current.connPrivate.connect;
	current.connPrivate.damaged
     #);
   endConnectors.scan
     (#
     do
	current.connPrivate.damaged;
	current.connPrivate.connect;
	current.connPrivate.damaged
     #);
   shape.getbounds->r;
   INNER

-- bifrostNodeNew: DoPart --
do
   (if UI.verbose then
       ID->putInt;
       ': designNode.new: \''->putText;
       t[]->putText;
       '\' '->putText
   if);
   true->moveable->sizeable;
   startConnectors.init;
   endConnectors.init;
   nodePrivate.regionConnectors.init;
   color.copy->shapeColor[];
   &paint[] -> filledShapeColor[];

   (* This is located here, because designLabel, needs to
    * copy theText in INNER.
    *)
   &designObjectText[]->theText[];

   INNER ;

   (* create Text *)
   theText.init;
   color[]->theText.setPaint;
   (textCoordinates,Helvetica,Plain,12,false,t[])->theText.initText;
   theText[]->THIS(designObject).add;
   &<<SLOT hideTextOutline:descriptor>>;

   (if filledShape[] <> NONE then
       (* The filledShape is most likely to interfere with the shape.
	* So lets not draw the outline.
	*)
       &filledShape.theShape.hiliteDesc[] -> filledShape.theShape.ho[]
   if);
   (if UI.verbose then newline if);

-- bifrostNodeMoveConnectors: DoPart --
do
   (#
      hitNode: ^designNode;
      theCanvas: ^bifrostCanvas;
      oc,nc: @Point
   do
      (if UI.extremelyVerbose then
	  'moveconnectors %d\n' -> putFormat(# do id -> d #)
      if);
      theScroller.contents[]->theCanvas[];
      getCenter->nodeCenter;
      nodePrivate.regionConnectors.scan
	(#
	do
	   (if not parent.nodePrivate.alreadyMoved[current.ID] then
	       true -> parent.nodePrivate.alreadyMoved[current.ID];
	       (if UI.extremelyVerbose then
		   'region moving %d\n' -> putFormat(# do current.id -> d #)
	       if);
	       current.connPrivate.damaged;
	       (* get old mass center *)
	       current.connPrivate.theLine.TM
		 -> current.connPrivate.theLine.theShape.computeCenter -> oc;

	       (* move the connector *)
	       offset -> current.connPrivate.movePoints;

	       (* get new mass center *)
	       current.connPrivate.theLine.TM
		 -> current.connPrivate.theLine.theShape.computeCenter -> nc;

	       (oc,nc) -> current.moveRegions;

	       current.connPrivate.damaged
	    else
	       (if UI.extremelyVerbose then
		   'region not moving %d\n'
		     -> putFormat(# do current.id -> d #)
	       if)
	   if)
	#);
      startConnectors.scan
	(#
	do
	   (if not parent.nodePrivate.alreadyMoved[current.ID] then
	       (if UI.extremelyVerbose then
		   'start moving %d\n' -> putFormat(# do current.id -> d #)
	       if);
	       current.connPrivate.damaged;
	       (* get old mass center *)
	       current.connPrivate.theLine.TM
		 -> current.connPrivate.theLine.theShape.computeCenter -> oc;

	       current.connPrivate.connect;

	       (* get new mass center *)
	       current.connPrivate.theLine.TM
		 -> current.connPrivate.theLine.theShape.computeCenter -> nc;

	       (oc,nc) -> current.moveRegions;

	       current.connPrivate.damaged
	    else
	       (if UI.extremelyVerbose then
		   'start not moving %d\n' -> putFormat(# do current.id -> d #)
	       if)
	   if)
	#);
      endConnectors.scan
	(#
	do
	   (if not parent.nodePrivate.alreadyMoved[current.ID] then
	       (if UI.extremelyVerbose then
		   'end moving %d\n' -> putFormat(# do current.id -> d #)
	       if);
	       current.connPrivate.damaged;
	       (* get old mass center *)
	       current.connPrivate.theLine.TM
		 -> current.connPrivate.theLine.theShape.computeCenter -> oc;

	       current.connPrivate.connect;

	       (* get new mass center *)
	       current.connPrivate.theLine.TM
		 -> current.connPrivate.theLine.theShape.computeCenter -> nc;

	       (oc,nc) -> current.moveRegions;

	       current.connPrivate.damaged
	    else
	       (if UI.extremelyVerbose then
		   'end not moving %d\n' -> putFormat(# do current.id -> d #)
	       if)
	   if)
	#);
      ScanGOsReverse
	(#
	do
	   (if go## <= designNode## then
	       go[]->hitNode[];
	       (parent[],offset) -> hitNode.moveConnectors
	   if)
	#)
   #)

-- bifrostNodePrivate:descriptor --
(#
   (* FIXME: maybe connset should be implemented using a repetion to
    * speed up things?
    *)
   startConnectorsToMove,endConnectorsToMove: ^connset;
   regionConnectors: @connSet;
   alreadyMoved:[0]@boolean;
   interactiveMove: @boolean;
   interactiveTM: ^matrix;
   getSubConnectors:
     (#
	startConns,endConns: ^connset; hitNode: ^designNode
     enter (startConns[],endConns[])
     do
	startConnectors.scan(# do current[] -> startConns.insert #);
	endConnectors.scan(# do current[] -> endConns.insert #);
	ScanGOsReverse
	  (#
	  do
	     (if go## <= designNode## then
		 go[] -> hitNode[];
		 (startConns[],endConns[])
		   -> hitNode.nodePrivate.getSubConnectors
	     if)
	  #)
     #);
   transform:
     (#
	nc: @point
     enter nc
     do
	(if interactiveTM[]=none then
	   (* No transformation *)
         else
	    nc -> interactiveTM.transformpoint -> nc
        if)
     exit nc
     #);
   transformRect:
     (#
	r: @rectangle;
     enter r
     do
	(if interactiveTM[]=none then
	    (* No transformation *)
	 else
	    (r.x,r.y) -> interactiveTM.transformpoint -> (r.x,r.y)
	if)
     exit r
     #);
   transformedNodeBounds:
     (# exit shape.getBounds->transformRect #);
   transformedNodeCenter:
     (#
     exit nodecenter->transform
     #);
#)

-- bifrostNodeMove: DoPart --
do
   (#
      pt: @point;
   do
      (if nodePrivate.interactiveMove then
	  false -> nodePrivate.interactiveMove;
	  offset -> pt
       else
	  (0,0) -> pt
      if);
      UI.bifrostObjectList.newID.value -> nodePrivate.alreadyMoved.new;
      (THIS(designNode)[],pt) ->  moveConnectors; false->isDragged;
      0 -> (* release the memory used by alreadyMoved*)
	nodePrivate.alreadyMoved.new
   #)

-- groupPictureMove:DoPart --
do
   ScanGOsReverse
     (#
	hitObject: ^designNode
     do
	(if go## <= designNode## then
	    go[] -> hitObject[];
	    UI.bifrostObjectList.newID.value
	      -> hitObject.nodePrivate.alreadyMoved.new;
	    (hitObject[],offset) -> hitObject.moveConnectors;
	    false->hitObject.isDragged
        if)
     #)

-- groupPictureInteractivemove:DoPart --
do
   &(#
       ccs1,ccs: (* common connectors *)
	 [bifrostObjectList.newID.value]@Boolean;
       scs,ecs: (* start,end connectors *) ^connSet
    do
       &connSet[] -> scs[]; scs.init;
       &connSet[] -> ecs[]; ecs.init;

       (* First determine which connectors are common, ie. has both
	* ends in a node (or region) in the group selection.  ccs1 is
	* used to mark the first end we meet.
	*)

       ScanGOsReverse
	 (#
	    dn: ^designNode
	 do
	    (if go## <= designNode## then
		go[]->dn[];
		scs.clear; ecs.clear;
		(scs[], ecs[]) -> dn.nodePrivate.getSubConnectors;
		scs.scan
		  (#
		  do
		     (if ccs1[current.ID] then
			 true -> ccs[current.ID]
		      else
			 true -> ccs1[current.ID]
		     if)
		  #);
		ecs.scan
		  (#
		  do
		     (if ccs1[current.ID] then
			 true -> ccs[current.ID]
		      else
			 true -> ccs1[current.ID]
		     if)
		  #)
	    if)
	 #);
       (* ccs[i] <=> connector i has both ends in the group selection *)

       (* setup startConnectorsToMove and endConnectorsToMove for all
	* nodes (and regions) in the group selection.  If ccs[i] is
	* true then should be put in regionConnectors of the first
	* node, which knows about it.  Use ccs1 to make sure that a
	* given connector is added to exactly one regionConnectors.
	*)

       bifrostObjectList.newID.value -> ccs1.new;
       ScanGOsReverse
	 (#
	    hitObject: ^designNode
	 do
	    (if go## <= designNode## then
		go[]->hitObject[];
		true -> hitObject.isDragged;
		&connset[] -> hitObject.nodePrivate.startConnectorsToMove[];
		&connset[] -> hitObject.nodePrivate.endConnectorsToMove[];

		hitObject.nodePrivate.startConnectorsToMove.init;
		hitObject.nodePrivate.endConnectorsToMove.init;

		(hitObject.nodePrivate.startConnectorsToMove[],
		   hitObject.nodePrivate.endConnectorsToMove[])
		  -> hitObject.nodePrivate.getSubConnectors;
		hitObject.nodePrivate.startConnectorsToMove.scan
		  (#
		  do
		     (if ccs[current.ID] then
			 current[] ->
			   hitObject.nodePrivate.startConnectorsToMove.delete;
			 (if not ccs1[current.ID] then
			     true -> ccs1[current.ID];
			     current[]
			       -> hitObject.nodePrivate.regionConnectors.insert
                         if)
		     if)
		  #);
		hitObject.nodePrivate.endConnectorsToMove.scan
		  (#
		  do
		     (if ccs[current.ID] then
			 current[] ->
			   hitObject.nodePrivate.endConnectorsToMove.delete;
			 (if not ccs1[current.ID] then
			     true -> ccs1[current.ID];
			     current[]
			       -> hitObject.nodePrivate.regionConnectors.insert
                         if)
		     if)
		  #)
	    if)
	 #)
    #)

-- bifrostNodeInteractivemove: DoPart --
do
   true->isDragged;
   true->nodePrivate.interactiveMove;

   (* The following creates a list of all the connectors connected to
    * this node. This is used by hiliteOutline.
    *)

   &connset[] -> nodePrivate.startConnectorsToMove[];
   &connset[] -> nodePrivate.endConnectorsToMove[];
   nodePrivate.startConnectorsToMove.init;
   nodePrivate.endConnectorsToMove.init;
   (nodePrivate.startConnectorsToMove[],nodePrivate.endConnectorsToMove[])
     ->nodePrivate.getSubConnectors;
   (#
      bothConn:[0]@boolean
   do
      UI.bifrostObjectList.newID.value -> bothConn.new;
      nodePrivate.regionConnectors.clear;
      nodePrivate.startConnectorsToMove.scan
	(#
	do
	   true -> bothConn[current.ID]
	#);
      nodePrivate.endConnectorsToMove.scan
	(#
	do
	   (if bothConn[current.ID] then
	       (if UI.veryVerbose then
		   'inserting %d in regionconnectors\n'
		     -> putFormat(# do current.ID -> d#)
               if);
	       current[] -> nodePrivate.regionConnectors.insert;
           if)
	#);
      nodePrivate.regionConnectors.scan
	(#
	do
	   current[] -> nodePrivate.startConnectorsToMove.delete;
	   current[] -> nodePrivate.endConnectorsToMove.delete;
        #)
   #)

-- bifrostNodeHiliteOutLine: DoPart --
do
   TM[] ->
     (* could be that this is not enough - it depends on
      * hiliteOutLine (of the node for which isDragged is true)
      * to be called as the last.
      * Furthermore there can be old interactiveTM's hanging around
      * which may or may not have the correct values.
      *)
     nodePrivate.interactiveTM[];
   (* FIXME: move this to connPrivate to avoid "dotting" in to
    * current.connprivate
    *)
   (if isDragged then
       nodePrivate.startConnectorsToMove.scan
	 (# b1, b2: @rectangle; p1, p2: @point;
	 do
	    current.connPrivate.setConnectPointsOrient;
	    current.connPrivate.node1.nodePrivate.transformedNodeBounds->b1;
	    current.connPrivate.node1.nodePrivate.transformedNodeCenter->p1;
	    (if current.connPrivate.thePoints.npoints>2 then
		current.connPrivate.lastConnectPoint->p2
	     else
		current.connPrivate.node2.nodePrivate.transformedNodeBounds
		  ->b2;
		current.connPrivate.node2.nodePrivate.transformedNodeCenter
		  ->p2;
		(b2,p2,p1)->current.connPrivate.connectPoint->p2;
	    if);
	    (b1,p1,p2)->current.connPrivate.connectPoint->p1;
	    p1->theScroller.contents.CanvasToDevice->p1;
	    p2->theScroller.contents.CanvasToDevice->p2;
	    (p1,p2)->theScroller.contents.immediateline;
	 #);
       nodePrivate.endConnectorsToMove.scan
	 (# b1, b2: @rectangle; p1, p2: @point;
	 do
	    current.connPrivate.setConnectPointsOrient;
	    current.connPrivate.node2.nodePrivate.transformedNodeBounds->b2;
	    current.connPrivate.node2.nodePrivate.transformedNodeCenter->p2;
	    (if current.connPrivate.thePoints.npoints>2 then
		current.connPrivate.firstConnectPoint->p1
	     else
		current.connPrivate.node1.nodePrivate.transformedNodeBounds
		  ->b1;
		current.connPrivate.node1.nodePrivate.transformedNodeCenter
		  ->p1;
		(b1,p1,p2)->current.connPrivate.connectPoint->p1;
	    if);
	    (b2,p2,p1)->current.connPrivate.connectPoint->p2;
	    p1->theScroller.contents.CanvasToDevice->p1;
	    p2->theScroller.contents.CanvasToDevice->p2;
	    (p1,p2)->theScroller.contents.immediateline;
	 #);
       nodePrivate.regionConnectors.scan
	 (#
	 do
	    (theCanvas[],draw,TM[])
	      -> current.connPrivate.theLine.theShape.hiliteOutLine
	 #)
   if)

-- bifrostNodeDump: DoPart --
do
   INNER ; 'Text: \''->putText; theText.theText->t; t[]->putText; '\''->putLine

-- bifrostRectTextCoordinates: DoPart --
do
   (sx+(h div 3),- (h div 3))->p

-- bifrostRectNew: DoPart --
do
   (if UI.verbose then 'rect shape'->putText if);
   0-(w div 2)->sx;
   (h div 2)->sy;
   (* creates aRect *)
   &designRectShape[]->aRect[]; &designRectFilledShape[]->fs[];
   aRect.init; fs.init;
   shapeColor[]->aRect.setPaint; filledShapeColor[] -> fs.setPaint;
   true->aRect.theShape.stroked;
   (sx,sy)->aRect.upperLeft; (sx,sy) -> fs.upperleft;
   w->aRect.theShape.width; w->fs.theShape.width;
   h->aRect.theShape.height; h->fs.theShape.height;
   fs[]->THIS(designRect).filledShape[] -> THIS(designRect).add;
   aRect[]->THIS(designRect).shape[] -> THIS(designRect).add;
   INNER

-- bifrostRectDump: DoPart --
do
   'This is a designRect\nUpperLeft: '->putText;
   shape[]->aRect[];
   aRect.upperLeft->p;
   p.x->putInt;
   'x'->putText;
   p.y->putInt;
   ' width: '->putText;
   aRect.width->putInt;
   ',height: '->putText;
   aRect.height->putInt;
   newline;
   getBounds->bounds;
   'Bounds: '->putText;
   bounds.x->putInt;
   'x'->putText;
   bounds.y->putInt;
   ' width: '->putText;
   bounds.width->putInt;
   ',height: '->putText;
   bounds.height->putInt;
   newline

-- bifrostPolySetCenter: DoPart --
do

-- bifrostPolyNew: DoPart --
do
   (if UI.verbose then 'poly shape'->putText if);
   (#
      fs: ^graphicalObject; sh: ^multiLine
   do
      &designPolyFilledShape[]->fs[]; &designPolyShape[] -> sh[];
      fs.init; sh.init;
      shapeColor[] -> sh.setPaint;
      filledShapeColor[] -> fs.setPaint;
      (pl[1],- pl[2])->fs.theShape.open;
      sh.theShape.open;
      (pl[1],- pl[2])-> sh.theShape.addPoint;
      (if UI.verbose then
	  ' %dx%d'->putFormat (#  do pl[1]->d; pl[2]->d #)
      if);
      (for inx: (pl.range div 2)-1 repeat
	   (pl[inx*2+1],- pl[inx*2+2])->fs.theShape.lineTo;
	   (pl[inx*2+1],- pl[inx*2+2])->sh.theShape.addPoint;
	   (if UI.verbose then
	       ' %dx%d'->putFormat (#  do pl[inx*2+1]->d; pl[inx*2+2]->d #)
	   if)
      for);
      (pl[1],- pl[2]) -> sh.theShape.addPoint;
      fs.theShape.close;
      0 -> sh.width;
      capButt -> sh.cap;
      joinMiter -> sh.join;
      sh[] -> shape[] -> add;
      fs[] -> filledShape[] -> add
   #)

-- bifrostPolyDump: DoPart --
do
   shape.getBounds->bnd;
   'This is a designPoly. Bounds: %dx%d width: %d, height: %d\n'
     ->putFormat (#  do bnd.x->d; bnd.y->d; bnd.width->d; bnd.height->d #)

-- bifrostLabelNew: DoPart --
do
   hideborder

-- bifrostPageOnMouseDown: descriptor --
(#
   hitNode: ^designNode;
   hitConn: ^designConn;
   hitObject: ^designObject;
   cp: ^point; (* control point *)
   exactPos: ^point;
   moved: @boolean;
   dontRepairGroup: @boolean;
   doMove: delay
     (#
     do
	true -> moved;
	(if true
	 // (not designGroup.isEmpty) then
	    designGroup.private.implList.scan
	      (#
		 cnt: @point
	      do
		 current.getCenter -> cnt;
		 (if current.load_prevPicture[] <> NONE then
		     current[] -> current.load_prevPicture.delete
		 if);
		 current[] -> theMainPicture.group.add;
		 cnt -> current.setCenter;
	      #);
	    (theMainPicture.group[],mousepos,noModifier) -> interactivemove;
	    designGroup.private.implList.scan
	      (#
		 cnt: @point
	      do
		 current.getCenter -> cnt;
		 current[] -> theMainPicture.group.delete;
		 (if current.load_prevPicture[] <> NONE then
		     current[] -> current.load_prevPicture.add
		 if);
		 cnt -> current.setCenter;
	      #);

	    (* toby says that onDrag should be called on all nodes in
	     * group selection
	     *)

	    designGroup.private.implList.scan(# do current.onDrag #)
	 // hitObject## <= designNode## then
	    hitObject[] -> hitNode[];
	    (if hitNode.moveable then
		(hitNode[],mousepos,noModifier)
		  ->interactivemove;
		hitNode.onDrag
	    if)
	 // hitObject## <= designConn## then
	    'Should not happen: doMove hitObject## <= designConn##' -> putLine
	 else
	    'dont know how to move this kind of object' -> putLine
	if)
     #);
   buttonOne:
     (#
     do
	(if hitObject.selectable then
	    (if true
	     // (shiftModified and (not (hitObject## <= designConn##))) then
		(if UI.verbose then 'toggle group selection' -> putLine if);
		hitObject[] -> designGroup.toggle;
		true -> dontRepairGroup
	     // doubleClick then
		(if UI.verbose then 'doubleClick'->putLine if);
		designGroup.clear;
		hitObject.onDoubleClick
	     else
		hitObject[] -> THIS(bifrostPage).designSelection;
		hitObject[] -> designGroup.click
	    if)
	if)
     #);
   interactiveMoveConn:
     (#
	whichEnd: (* node1 is true *) @boolean;
	isEnd: @boolean;
	npl: (* new point list *) ^pointArray;
	newPos: @point;
	tc, oc, nc: @Point; (* Text, Old, New Center *)
	newAttach: ^designObject
     do
	hitObject[]->hitConn[];
	(if THIS(bifrostPage).designSelection<>NONE then
	    (THIS(bifrostPage).designSelection).unhilite
	if);
	hitConn.connPrivate.damaged;
	hitConn.connPrivate.theLine.TM
	  -> hitConn.connPrivate.theLine.theShape.computeCenter -> oc;
	(if true
	 // (exactpos[] <> NONE) and doubleclick then
	    (* doubleclicked on a control point - delete it *)
	    (if (hitConn.connPrivate.theLine.points).npoints > 2 then
		(* if we end up with less than 2 points we're in trouble *)
		exactPos -> hitConn.connPrivate.theLine.deletePoint;
		hitConn.connPrivate.theLine.points
		  -> hitConn.connPrivate.setPoints;
		hitConn.connPrivate.connect
            if)

	 // doubleclick then
	    (* doubleclicked (not on controlpoint) - insert a new point *)
	    (mousePos,
	       mousePos -> hitConn.connPrivate.theLine.closestLineSegment)
	      ->hitConn.connPrivate.thePoints.insertPoint;
	    hitConn.connPrivate.setPoints

	 // (exactpos[] <> NONE) then
	    (* clicked on a control point - move it *)
	    exactPos -> hitConn.connPrivate.isEndPoint -> (isEnd,whichEnd);
	    (hitConn.connPrivate.theLine[], exactPos, noModifier)
	      -> interactiveReshape;

	    (if isEnd then
		(* move end point to another node *)
		(if UI.verbose then 'Hit end point' -> putLine if);
		hitConn.connPrivate.theLine.points -> npl[];
		(if whichEnd then
		    1 -> npl.getPoint -> newPos
		 else
		    npl.npoints -> npl.getPoint -> newPos
		if);
		(newpos,hitConn[]) -> findHitObject -> newAttach[];
		(if newAttach[] <> NONE then
		    (if UI.verbose then newAttach.dump if);
		    (if newAttach## <= designConn## then
			(if UI.verbose then
			    'Oh silly. you can\'t expect that to work'
			      -> putLine
			if)
		     else
			hitConn.getMyObject
			  (#
			     dc: ^thePage.connector;
			     ok: @boolean;
			     theNew: ^object
			  do
			     theObject[] -> dc[];
			     newAttach.ID -> theDocument.theObjectList.Find
			       -> theNew[];
			     (theNew[],whichEnd) -> dc.onReattach -> ok;
			     (if ok and UI.verbose then 'OK' -> putLine if)
			  #)
		    if)
		if)
	    if);
	    hitConn.connPrivate.theLine.points
	      ->hitConn.connPrivate.setPoints;
	    hitConn.connPrivate.connect
	if);
	hitConn.connPrivate.theLine.TM
	  -> hitConn.connPrivate.theLine.theShape.computeCenter -> nc;

	(oc,nc) -> hitConn.moveRegions;

	hitConn.connPrivate.damaged;
	hitObject[] ->THIS(bifrostPage).designSelection;
	hitObject.hilite
     #);
   normalIA:
     (#
     do
	NONE -> exactpos[];
	(if designSelection <> NONE then
	    designSelection -> hitObject[];
	    (if true
	     // hitObject## <= designNode## then
		hitObject[] -> hitNode[];
		(hitNode.shape[], mousePos) -> HitControl -> exactpos[]
	     // hitObject## <= designConn## then
		hitObject[] -> hitConn[];
		(hitConn.connPrivate.theLine[], mousePos)
		  -> HitControl -> exactpos[]
	    if)
	if);
	(if exactpos[] // NONE then
	    (mousepos,NONE) -> findHitObject -> hitObject[]
	 else
	    (if UI.extremelyVerbose then
		'got exact pos' -> putLine
            if)
        if);
	(if hitObject[] <> none then
	    (if buttonState
	     // 1 then
		(if designSelection <> NONE then
		    (designSelection).unhilite;
		    (THIS(bifrostPage).designSelection).hiliteReset
		if);
		(if hitObject## <= designConn## then
		    interactiveMoveConn
		 else
		    false -> moved;
		    (if exactpos[] <> NONE then
			(* we are CERTAIN that hitNode[] <> NONE *)
			designGroup.clear;
			(if hitNode.sizeable then
			    (hitNode.shape[],exactPos,shiftModifier)
			      -> theScroller.contents.interactiveReshape;
			    hitNode.onSize
                        if);
			hitNode[] -> THIS(bifrostPage).designSelection
		      else
			buttonOne;
			(* FIXME - what is a good value to use for
			 * delay (doMove)
			 *)
			20 -> doMove;
		    if)
		if);
		(if designSelection <> NONE then
		    (designSelection).hiliteReset; (designSelection).hilite
		if)
	     // 2 then
		(if UI.verbose then hitObject.dump if)
             // 3 (* right click *) then
                localPosition->hitObject.onRightMouseDown
	    if)
	 else
	    designGroup.clear;
	    (if UI.verbose then
		mousepos -> putPoint; newline
	    if)
	if)
     #);
   connIA:
     (#
	ml: ^multiline;
	dp: ^theDocument.page; dc: ^dp.designConnector;
	pa: ^pointArray;
	n1,n2: ^designNode;
	ho: ^designObject;
	pts:[0]@integer;
	initialiser: @object
	  (#
	  do
	     pts -> dc.points;
	     true -> dc.selectable;
	     true -> dc.borderVisible;
	     dc[] -> dp.CurrentObject
          #)
     do
	(mousepos,NONE) -> findHitObject -> ho[];
	(if ho[] // NONE then leave connIA if);
	(if ho## <= designNode## then
	    ho[] -> n1[];
	    (if ho## <= designLabel## then
		leave connIA
	    if)
	 else
	    leave connIA
	if);

	(* 'Left click to insert point.  Right click on a node to finish. Hold shift down to get rigth angles' -> infoBar.label; *)

	&multiline[] -> ml[];
	ml.init;
	(ml[],mousepos,shiftModifier)
	  -> theScroller.contents.interactiveCreateShape;
	ml.getBounds -> damage;

	ml.points -> pa[];
	(if pa.npoints < 2 then leave connIA if);
	(pa.npoints -> pa.getPoint,NONE) -> findHitObject -> ho[];

	(if ho[] // NONE then leave connIA if);
	(if ho[] // n1[] then leave connIA if);
	(if ho## <= designNode## then
	    ho[] -> n2[];
	    (if ho## <= designLabel## then
		leave connIA
	    if)
	 else
	    leave connIA
	if);

	pa.npoints*2 -> pts.new;
	pa.scanPoints
	  (#
	  do
	     current -> bifrost2design -> (pts[inx*2-1],pts[inx*2])
          #);

 	this(bifrostPage).theMainPicture.ID
	  -> theDocument.theObjectList.Find -> dp[];
	(if UI.interactiveNewConn then
	    UI.interactiveNewObject[] -> dc[];
	    false -> UI.interactiveNewConn
	 else
	    &dp.designConnector[] -> dc[]
        if);
	initialiser[] -> dc.visualAttributes.initInteractive[];
	(if designSelection <> NONE then (designSelection).unhilite if);
 	(n1.ID -> theDocument.theObjectList.Find,
	   n2.ID -> theDocument.theObjectList.Find) -> dc.new;
	NONE -> dc.visualAttributes.initInteractive[]
     #);
   EllipseIA:
     (#
	el: ^ellipse;
	dp: ^theDocument.page; de: ^dp.designEllipse;
	cnt,dim: @point
     do
	&ellipse[] -> el[];
	el.init;
	(* 'Left click to finish. Hold shift down for circle.' -> infoBar.label; *)
	(el[],mousepos, shiftModifier)
	  -> theScroller.contents.interactiveCreateShape;
	el.center -> bifrost2design -> cnt;
	el.horizontalRadius * 2 -> dim.x;
	el.verticalRadius * 2 -> dim.y;

	this(bifrostPage).theMainPicture.ID
	  -> theDocument.theObjectList.Find -> dp[];
	&dp.designEllipse[] -> de[];
	(cnt.x,cnt.y,dim.x,dim.y) -> de.new;
	true -> de.selectable;
	true -> de.borderVisible;
	true -> de.moveable;
	true -> de.sizeable;
	de[] -> dp.CurrentObject
     #);
   RndRectIA: (# do rectIA #);
   WedgeIA:
     (#
     do
	'interactive new Wedge not implemented yet!' -> putLine
     #);
   polyIA:
     (#
	ml: ^multiline;
	dp: ^theDocument.page; dpoly: ^dp.designPolygon;
	pa: ^pointArray;
	pts:[0]@integer;
	bnd: @rectangle
     do
	&multiline[] -> ml[];
	ml.init;
	(* 'Left click to insert point.  Right click to finish. Hold shift down to get rigth angles' -> infoBar.label; *)
	(ml[],mousepos,shiftModifier)
	  -> theScroller.contents.interactiveCreateShape;
	ml.getBounds -> damage;

	ml.getBounds -> bnd;
	bnd.x + bnd.width div 2 -> bnd.x;
	bnd.y - bnd.height div 2 -> bnd.y;
	(bnd.x,bnd.y) -> bifrost2design -> (bnd.x,bnd.y);

	ml.points -> pa[];
	(if pa.npoints < 2 then leave polyIA if);

	pa.npoints*2 -> pts.new;
	pa.scanPoints
	  (#
	  do
	     current -> bifrost2design -> (pts[inx*2-1],pts[inx*2])
          #);

 	this(bifrostPage).theMainPicture.ID
	  -> theDocument.theObjectList.Find -> dp[];
	&dp.designPolygon[] -> dpoly[];
	(bnd.x,bnd.y,0,0,pts) -> dpoly.new;
	true -> dpoly.selectable;
	true -> dpoly.borderVisible;
	true -> dpoly.moveable;
	false -> dpoly.sizeable;
	dpoly[] -> dp.CurrentObject
     #);
   LineIA:
     (#
     do
	'interactive new Line not implemented yet!' -> putLine
     #);
   LabelIA:
     (#
	txt: ^graphicText;
	dp: ^theDocument.page; dl: ^dp.designLabel;
	bnd: @rectangle; t: @text
     do
	&graphicText[] -> txt[];
	txt.init;
	(* 'Type in text.  Press enter when done.' -> infoBar.label; *)
	(txt[],mousepos, noModifier)
	  -> theScroller.contents.interactiveCreateShape;
	txt.getBounds -> bnd;
	bnd.x + bnd.width div 2 -> bnd.x;
	bnd.y - bnd.height div 2 -> bnd.y;
	(bnd.x,bnd.y) -> bifrost2design -> (bnd.x,bnd.y);
	txt.theText -> t;

	this(bifrostPage).theMainPicture.ID
	  -> theDocument.theObjectList.Find -> dp[];
	&dp.designLabel[] -> dl[];
	(bnd.x,bnd.y,bnd.width,bnd.height,t) -> dl.new;
	true -> dl.selectable;
	false -> dl.borderVisible;
	dl[] -> dp.CurrentObject
     #);
   PictureIA:
     (#
     do
	'interactive new Picture not implemented yet!' -> putLine
     #);
   rectIA:
     (#
	rct: ^rect; bnd: @rectangle;
	dp: ^theDocument.page; dr: ^dp.designRect
     do
	&rect[] -> rct[];
	rct.init;
	(* 'Left click to finish.  Hold shift down for square.' -> infoBar.label; *)
	(rct[],mousepos, shiftModifier)
	  -> theScroller.contents.interactiveCreateShape;
	rct.getBounds -> bnd;
	bnd.x + bnd.width div 2 -> bnd.x;
	bnd.y - bnd.height div 2 -> bnd.y;
	(bnd.x,bnd.y) -> bifrost2design -> (bnd.x,bnd.y);

	this(bifrostPage).theMainPicture.ID
	  -> theDocument.theObjectList.Find -> dp[];
	&dp.designRect[] -> dr[];
	bnd -> dr.new;
	true -> dr.selectable;
	true -> dr.borderVisible;
	true -> dr.moveable;
	true -> dr.sizeable;
	dr[] -> dp.CurrentObject
     #);
   findHitObject:
     (#
	hitObject: ^designObject;
	mousepos: @point;
	butNotThis: ^Object
     enter (mousepos,butNotThis[])
     do
	scan: theMainPicture.ScanGOsReverse
	  (#
	  do
	     (if go## <= designObject## then
		 go[]->hitObject[];
		 (if UI.extremelyVerbose then
		     'top level:' -> putLine; hitObject.dump
                 if);
		 (if (THIS(BifrostCanvas)[],mousepos)
		       -> hitObject.containsPoint then
		     (if UI.extremelyVerbose then
			 'containspoint' -> putLine
                     if);
		     (if go[] <> butNotThis[] then
			 (THIS(BifrostCanvas)[],mousepos)
			   -> hitObject.findSmallestHit
			   -> hitObject[];
			 (if hitObject[] <> none then
			     leave scan
			  else
			     (if UI.extremelyVerbose then
				 go[]->hitObject[];
				 hitObject.dump;
				 'no regions' -> putLine
                             if)
                         if)
                     if)
		 if);
		 NONE -> hitObject[]
	     if)
	  #)
     exit hitObject[]
     #)
do
   (if UI.verbose then
       (if controlModified then 'controlModified '->putText if);
       (if metaModified then 'metaModified '->putText if);
       (if shiftModified then 'shiftModified '->putText if);
       (if controlModified or metaModified or shiftModified then newline if)
   if);

   mousepos -> devicetocanvas -> mousepos;

   false -> dontRepairGroup;
   (if interactiveState
    // iaDisabled then (* do nothing *)
    // iaNormal then
       normalIA;
       updateInfoBar
    // iaConn then
       connIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaRect then
       rectIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaEllipse then
       ellipseIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaRndRect then
       rndRectIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaWedge then
       wedgeIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaPoly then
       polyIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaLine then
       lineIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaLabel then
       labelIA;
       iaNormal -> interactiveState;
       updateInfoBar
    // iaPicture then
       pictureIA;
       iaNormal -> interactiveState;
       updateInfoBar
    else
       'Warning: internal problem in bifrostobjectbody-bifrostPageOnMouseDown'
	 -> putLine;
       'this is not serious. Please send a bug report to support@mjolner.dk'
	 -> putLine;
       iaNormal -> interactiveState;
       updateInfoBar
   if);

   false -> dontRepair;
   dontRepairGroup -> this(bifrostPage).repair;

   (* According to Lennert Sloth the following is needed to be able
    * to get keyEvents.  This could be a problem like the problem with
    * Sif when the freja diagram is changed
    *)
   theScroller.contents[] -> target
#)

-- bifrostObjectFindSmallestHit: descriptor --
(#
do
   scan: THIS(designObject).scanGOsReverse
     (#
     do
	(if go## <= designObject## then
	    go[]->hitObject[];
	    (if UI.extremelyVerbose then
		'looking at %d in section findSmallestHit of %d\n' -> putFormat
		  (# do hitObject.ID -> d; ID -> d #)
            if);
	    (if (canv[],mousepos) -> hitObject.containsPoint then
		(canv[],mousepos) -> hitObject.findSmallestHit
		  -> hitObject[];
		(if hitObject[] <> NONE then
		    (if UI.extremelyVerbose then
			'found %d in section 1\n' -> putFormat
			  (# do hitObject.ID -> d #)
		    if);
		    leave scan
		 else
		    (if UI.extremelyVerbose then
			go[]->hitObject[];
			hitObject.dump;
			'no regions' -> putLine
                    if)
		if)
	    if);
	    NONE -> hitObject[]
	if)
     #);
   (if hitObject[] // NONE then
       (if ((canv[],mousepos) -> shapeContainsPoint) and selectable then
	   THIS(designObject)[] -> hitObject[];
	   (if UI.extremelyVerbose then
	       'found %d in section 2\n' -> putFormat
		 (# do hitObject.ID -> d #)
	   if)
       if)
   if)
#)
(*
 * do
 *    scan: THIS(designObject).scanGOsReverse
 * 	(#
 * 	do
 * 	   (if go## <= designObject## then
 * 	       go[]->hitObject[];
 * 	       (if UI.extremelyVerbose then
 * 		   hitObject.ID -> putInt; newline
 * 	       if);
 * 	       (if (canv[],mousepos) -> hitObject.shapeContainsPoint then
 * 		   (if hitObject.selectable then
 * 		       leave scan
 * 		    else
 * 		       (if UI.extremelyVerbose then
 * 			   hitObject.dump; 'not selectable' -> putLine
 * 		       if)
 * 		   if)
 * 	       if);
 * 	       (if (canv[],mousepos) -> hitObject.containsPoint then
 * 		   (canv[],mousepos) -> hitObject.findSmallestHit
 * 		     -> hitObject[];
 * 		   (if hitObject[] <> NONE then
 * 		       leave scan
 * 		    else
 * 		       (if UI.extremelyVerbose then
 * 			   go[]->hitObject[];
 * 			   hitObject.dump;
 * 			   'no regions' -> putLine
 * 		       if)
 * 		   if)
 * 	       if);
 * 	       NONE -> hitObject[]
 * 	   if)
 * 	#);
 *    (if hitObject[] // NONE then
 * 	  (if ((canv[],mousepos) -> shapeContainsPoint) and selectable then
 * 	      THIS(designObject)[] -> hitObject[]
 * 	  if)
 *    if)
 *)

-- move: descriptor --
(#
do
   THIS(designObject).ID->putInt; ': move:descriptor called!'->putLine;
   '    Why not call center?' -> putLine;
   (x,y) -> center
#)

-- ObjectGetCenter: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': ObjectGetCenter:descriptor called!'->putText
   if);
   (if UI.verbose then
       THIS(designObject).designAttributes.position -> (x,y);
       'Stored position: %dx%d '
	 -> putFormat(# do THIS(center).x -> d; THIS(center).y -> d #)
   if);
   THIS(designObject).designAttributes.update
     (#
	thePage: ^UI.bifrostPage; theObject: ^thePage.designObject
     do
	THIS(page).ID -> UI.getApage -> thePage[];
	(if thePage[] // NONE then 'getcenter1' -> putLine if);	      
	(if UI.bifrostObjectList.rep[THIS(designObject).ID][] // NONE then
	    'getcenter2' -> putLine
	if);
	UI.bifrostObjectList.rep[THIS(designObject).ID].IO[] -> theObject[];
	(if theObject[] // NONE then 'getcenter3' -> putLine if);	      
	(if UI.verbose then
	    theObject.getCenter -> (x,y);
	    '%dx%d '
	      -> putFormat(# do THIS(center).x -> d; THIS(center).y -> d #)
	if);
	theObject.getCenter -> UI.bifrost2design
	  -> THIS(designObject).designAttributes.position;
     #);
   THIS(designObject).designAttributes.position -> (x,y);
   (if UI.verbose then
       '%dx%d\n' -> putFormat(# do THIS(center).x -> d; THIS(center).y -> d #)
   if)
#)

-- ObjectSetCenter: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': ObjectSetCenter:descriptor called!'->putLine
   if);
   (x,y)->THIS(designObject).designAttributes.position;
   THIS(designObject).designAttributes.update
     (#
	thePage: ^UI.bifrostPage; theObject: ^thePage.designObject
     do
        THIS(page).ID -> UI.getApage -> thePage[];
	UI.bifrostObjectList.rep[THIS(designObject).ID].IO[] -> theObject[];
	theObject.modify
	  (* This is necessary, because setcenter dosn't damage the
	   * old position (this is needed in bifrostObjectNew)
	   *)
	  (#
	  do
	     (x,y) -> UI.design2bifrost -> theObject.setCenter
          #)
     #)
#)

-- NodeDrag: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': NodeDrag:descriptor called!'->putLine
   if)
#)

-- ObjectGetSize: Descriptor --
(#
do
   THIS(designObject).designAttributes.size->(w,h);
   (if UI.verbose then
       '%d: ObjectGetSize:descriptor called! %dx%d\n'
	 ->putFormat(# do ID -> d; w -> d; h -> d #)
   if)
#)

-- ObjectSetSize: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': ObjectSetSize:descriptor called!'->putLine;
   if);
   (w,h)->THIS(designObject).designAttributes.size;
   THIS(designObject).designAttributes.update
     (#
        aGO: ^aPage.abstractGraphicalObject;
        aNode: ^aPage.designNode;
        aRect: ^aPage.rect;
        aPage: ^UI.bifrostPage;
	p: @point;

     do
        THIS(page).ID->UI.getApage->aPage[];
        UI.bifrostObjectList.rep[THIS(designObject).ID].IO[] -> aNode[];
        aNode.shape[]->aGO[];
	aNode.getBounds -> aPage.damage;
        (if true
         // aGO## <= aPage.rect## then
            aGO[]->aRect[];
            THIS(designObject).center -> p;
            w->aRect.theShape.width;
            h->aRect.theShape.height;
	    aNode.filledShape[] -> aRect[];
            w->aRect.theShape.width;
            h->aRect.theShape.height;
            (* Needs to be updated because coordinates is relative
             * to center
             *)
	    p -> THIS(designObject).center;
         else
	    (if UI.verbose then
		aGO -> getPatternName -> putText;
		' resize is not implemented yet!'->putLine
            if)
        if);
	aNode.repositionText;
	aPage.repair
     #)
#)

-- ObjectSetGeometry: Descriptor --
(#
do
   (w,h)->THIS(designObject).size;
   (x,y)->THIS(designObject).center
#)

-- ObjectGetGeometry: Descriptor --
(#
do
   THIS(designObject).size->(w,h);
   THIS(designObject).center->(x,y)
#)

-- GetRegionList: Descriptor --
(#
do
   (if UI.verbose then
       '%d: GetRegionList:descriptor called!\n' -> putFormat(# do ID -> d #)
   if);
   GetRegionIDs -> theObjectList.nodeIDsToList -> theList[];
   (if (theList[] <> NONE) and UI.verbose then theList.dumpList if)
#)

-- ObjectCreateRegion: Descriptor --
(#
   aPage: ^UI.bifrostPage;
   aObject: ^aPage.designObject;
   parentObject: ^aPage.designObject;
   p: @point;
do
   (if not isRegion then
       (if UI.verbose then
	   ID->putInt;
	   ': ObjectCreateRegion:descriptor called, parent ID: '->putText;
	   parent.ID->putInt;
	   newline
       if);
       THIS(designObject).center -> p;
       THIS(page).ID->UI.getApage->aPage[];
       UI.bifrostObjectList.rep[THIS(designObject).ID].IO[] -> aObject[];
       aObject.initRegion; (* FIXME: more stuff should be moved to initRegion*)
       UI.bifrostObjectList.rep[parent.ID].IO[] -> parentObject[];
       aObject[]->aPage.theMainPicture.delete;
       aObject[]->parentObject.add;
       parentObject[] -> aObject.load_prevPicture[];
       (* Needs to be updated because coordinates is relative
	* to parent picture
	*)
       p -> THIS(designObject).center;
       (parent[],parent.getConnectors) -> onInitRegion;
       aPage.repair
    else
       (if UI.warnDanger then
	   ID->putInt;
	   ': ObjectCreateRegion:descriptor called, parent ID: '->putText;
	   parent.ID->putInt;
	   newline;
	   'Hey wait! I am a region already' -> putLine
       if)
   if)
#)

-- ObjectUnMakeRegion: Descriptor --
(#
   aPage: ^UI.bifrostPage;
   aObject: ^aPage.designObject;
   parentObject: ^aPage.designObject;
   cp: @point;
   oldrepair: @Boolean
do
   UI.dontRepair -> oldrepair;
   true -> UI.dontRepair;
   THIS(page).ID->UI.getApage->aPage[];
   UI.bifrostObjectList.rep[THIS(designObject).ID].IO[] -> aObject[];
   aObject.load_prevPicture[] -> parentObject[];
   NONE -> aObject.load_prevPicture[];
   (if parentObject[] // none then
       ID -> putInt;
       (failureTrace,': unmakeRegion: This object has no parent')->stop
   if);
   (if UI.verbose then
       ID->putInt;
       ': ObjectUnMakeRegion:descriptor called, parent ID: '->putText;
       parentObject.ID->putInt;
       newline
   if);
   aObject.unmakeRegion; (* FIXME: more stuff should be moved to unmakeRegion*)
   center -> (* FIXME: HACK *) cp;
   aObject[]->parentObject.delete;
   aObject[]->aPage.theMainPicture.add;
   cp -> (* FIXME: HACK *) center;
   oldrepair -> UI.dontRepair;
   aPage.repair
#)

-- designUtilsCreatePolygon: DoPart --
do
   (if UI.verbose then
       'designUtilsCreatePolygon:dopart called!'->putLine
   if);
   (#
      thePage: ^UI.bifrostPage;
      thePoly: ^thePage.designPoly
   do
      pageID -> UI.getApage -> thePage[];
      &thePage.designPoly[] -> thePoly[];
      (UI.design2bifrost,'',pointList)->thePoly.new->polyID
   #);
   (if UI.verbose then
       'designUtilsCreatePolygon:dopart done!' -> putLine
   if)

-- bifrostObjectHilite:DoPart --
do
   hiliteLevel + 1 -> hiliteLevel;
   (if UI.extremelyVerbose then
       '%d: hilite controls, level: %d\n'
	 -> putFormat(# do ID -> d; hiliteLevel -> d #)
   if);
   (if (not dontRepair) and (hiliteLevel = 1) then
       (* '%d: hilite\n' -> putFormat(# do ID -> d #); *)
       INNER;
       (if not doneInInner then
	   this(designObject)[] -> theScroller.contents.hilite
       if)
   if)

-- bifrostObjectUnhilite:DoPart --
do
   hiliteLevel - 1 -> hiliteLevel;
   (if UI.extremelyVerbose then
       '%d: unhilite controls, level: %d\n'
	 -> putFormat(# do ID -> d; hiliteLevel -> d #)
   if);
   (if (not dontRepair) and (hiliteLevel = 0) then
       (* '%d: unhilite\n' -> putFormat(# do ID -> d #); *)
       INNER;
       (if not doneInInner then
	   this(designObject)[] -> theScroller.contents.unhilite
       if)
   if)

-- bifrostObjectOnSelect:doPart --
do
   (if theObject[]
    // none then
       'Can\'t find selected object '->puttext; ID->putint; newline
    else
       theObject.onSelect
   if)

-- bifrostNodeUnhilite: doPart --
do
   INNER;
   (if not doneInInner then
       true -> doneInInner;
       shape[] -> theScroller.contents.unhilite
   if)

-- bifrostNodeHilite: doPart --
do
   INNER;
   (if not doneInInner then
       true -> doneInInner;
       shape[] -> THIS(designNode).bringForward;
       shape[] -> theScroller.contents.hilite
   if)

-- bifrostConnUnhilite: doPart --
do
   INNER;
   (if not doneInInner then
       true -> doneInInner;
       connPrivate.theLine[] -> theScroller.contents.unhilite
   if)

-- bifrostConnHilite: doPart --
do
   INNER;
   (if not doneInInner then
       true -> doneInInner;
       connPrivate.theLine[] -> theScroller.contents.hilite
   if)

-- bifrostSelectionSet:doPart --
do

-- bifrostSelectionGet:doPart --
do
   (* empty doPart - revisit *)

-- DeleteObject: Descriptor --
(* designOAobject.delete *)
designAttributes.lookupObject
  (#
     noSuchObject::
       (#
       do
	  true -> continue;
	  'WOW! Hey! you have already deleted ID %d!\n'
	    -> putFormat(# do ID -> d #)
       #);
     oldrepair: @Boolean
  do
     UI.dontRepair -> oldrepair;
     true -> UI.dontRepair;
     (if UI.verbose then
	 '%d: DeleteObject:descriptor called!\n'
	   -> putFormat(# do ID -> d #)
     if);
     theObject.remove;
     oldrepair -> UI.dontRepair;
     thePage.repair
  #)

-- RemoveObject: Descriptor --
(* designOAobject.onRemove *)
(#
do (if UI.verbose then
       '%d: RemoveObject: Descriptor called!\n' -> putFormat(# do ID -> d #)
   if);
   (if isRegion then unMakeRegion if);
   THIS(IDObject)[]->theObjectList.delete
#)

-- bifrostObjectRemove:doPart --
do
   (if this(designObject)[] // designSelection then
       NONE -> designSelection
   if);

   THIS(designObject).getBounds -> damage;
   INNER;

   getMyObject(# do theObject.onRemove #);

   scanGOsReverse
     (#
	hitObject: ^designObject
     do (if go## <= designObject## then go[]->hitObject[]; hitObject.remove if)
     #);

   (* remove ID to GO mapping *)
   bifrostObjectList.rep[ID][] -> bifid[];
   NONE -> bifid.page[];
   NONE -> bifid.io[];
   NONE -> bifrostObjectList.rep[ID][];

   (* erase from screen *)
   THIS(designObject)[] -> theMainPicture.delete;
   (if theScroller.contents.ready then
       (* THIS(designObject)[] -> theScroller.contents.erase *)
   if);
   THIS(bifrostPage).repair

-- bifrostConnRemove:doPart --
do
   INNER;

   (if UI.verbose then
       '%d: removeConn\n' -> putFormat(# do ID -> d #);
       (if this(designConn)[] -> connPrivate.node1.startConnectors.has then
	   'This(connector) is node1(%d).startConnectors before delete\n'
	     -> putFormat(# do connPrivate.node1.ID -> d #)
       if);
       (if this(designConn)[] -> connPrivate.node2.endConnectors.has then
	   'This(connector) is in node2(%d).endConnectors before delete\n'
	     -> putFormat(# do connPrivate.node2.ID -> d #)
       if)
   if);

   this(designConn)[] -> connPrivate.node1.startConnectors.delete;
   this(designConn)[] -> connPrivate.node2.endConnectors.delete;

   (if UI.verbose then
       (if this(designConn)[] -> connPrivate.node1.startConnectors.has then
	   'This(connector) is in node1(%d).startConnectors\n'
	     -> putFormat(# do connPrivate.node1.ID -> d #)
       if);
       (if this(designConn)[] -> connPrivate.node2.endConnectors.has then
	   'This(connector) is in node2(%d).endConnectors\n'
	     -> putFormat(# do connPrivate.node2.ID -> d #)
       if)
   if)

-- bifrostNodeRemove:doPart --
do
   INNER;

   (if UI.verbose then
       '%d: removeNode\n' -> putFormat(# do ID -> d #)
   if);

   startConnectors.scan(# do current.remove #);
   endConnectors.scan(# do current.remove #)

-- bifrostEllipseNew:doPart --
do
   (if UI.verbose then 'ellipse shape'->putText if);
   (* 0-(w div 2)->sx; *)
   (* (h div 2)->sy; *)

   (* create an ellipse *)
   &designEllipseShape[] -> theEllipse[]; &designEllipseFilledShape[] -> fs[];
   theEllipse.init; fs.init;
   shapeColor[]->theEllipse.setPaint; filledShapeColor[] -> fs.setPaint;
   true->theEllipse.theShape.stroked;
   ((0,0),h div 2,w div 2)->theEllipse.geometry;
   ((0,0),h div 2,w div 2)->fs.geometry;
   theEllipse[]->THIS(designEllipse).add;
   fs[] -> filledShape[] ->THIS(designEllipse).add;
   theEllipse[]->THIS(designEllipse).shape[];
   INNER

-- bifrostEllipseDump:doPart --
do
   'This is an ellipse'->putLine;
   INNER

-- bifrostNodeTextSize:doPart --
do
   theText.getBounds -> bnd

-- bifrostConnGetOrient: descriptor --
(#
do
   connPrivate.orient -> o
#)

-- bifrostConnSetOrient: descriptor --
modify
  (#
  do
     o -> connPrivate.orient;
     connPrivate.connect
  #)

-- bifrostObjectAutoPan: doPart --
do
   (if not dontRepair then
       getbounds->r;
       INNER;
       theScroller.contents.size -> s;
       theScroller.viewSize -> vs;
       (r.x,s.y - r.y) -> stl;
       (stl,(r.width,r.height)) -> addPoints -> sbr;

       theScroller.theScroll -> vtl;
       (vtl,vs) -> addPoints -> vbr;

       (if designSelection <> NONE then
	   (designSelection).unhilite
       if);

       (if true
	// stl.x < vtl.x then
	   (if UI.verbose then 'stl.x < vtl.x' -> putLine if);
	   (stl.x-10,vtl.y-10) -> theScroller.theScroll -> vtl;
	   (vtl,vs) -> addPoints -> vbr
	// sbr.x > vbr.x then
	   (if UI.verbose then 'sbr.x > vbr.x' -> putLine if);
	   (sbr.x - vs.x, vtl.y)
	     -> theScroller.theScroll -> vtl;
	   (vtl,vs) -> addPoints -> vbr
       if);

       (if true
	// stl.y < vtl.y then
	   (if UI.verbose then 'stl.y < vtl.y' -> putLine if);
	   (vtl.x-10,stl.y-10) -> theScroller.theScroll -> vtl;
	   (vtl,vs) -> addPoints -> vbr
	// sbr.y > vbr.y then
	   (if UI.verbose then 'sbr.y > vbr.y' -> putLine if);
	   (vtl.x, sbr.y - vs.y)
	     -> theScroller.theScroll -> vtl
       if);

       (if designSelection <> NONE then
	   (designSelection).hilite
       if)
    else
       (* Let repair do the work later *)
       THIS(designObject)[] -> autoPanObject[]
   if)

-- bifrostNodeTextEdit:DoPart --
do
   (#
      edit: ^nodeEditor; t: ^text;
      bnd: @rectangle; pos: @point;
      nodeEditor: editText
	(#
	   eventHandler::
	     (#
		onKeyDown::
		  (#
		  do
		     (if ch
		      // ascii.nl
		      // ascii.cr
		      // ascii.newline then
			 &text[] -> t[]; contents -> t.putText;
			 t[] -> theText.theText; repositionText;
			 this(nodeEditor).close
		      // ascii.esc then
			 this(nodeEditor).close;
		     if)
                  #)
	     #);
	   open::
	     (#
	     do
		pos -> edit.position;
		(bnd.width,bnd.height+16) -> edit.size;
		t[] -> edit.contents
             #);
	   close::
	     (#
	     do 'Close' -> putLine;
		onTextModeOff
	     #)
        #);
   do
      onTextModeOn;
      getCenter -> bifrost2gui -> pos;
      shape.getBounds->bnd;
      (if (bnd.width = 0) or (bnd.height = 0) then
	  'Strange size - can\'t edittext' -> putLine
       else
	  pos.x - bnd.width div 2 -> pos.x;
	  pos.y - bnd.height div 2 - 8 -> pos.y;
	  &text[] -> t[]; theText.theText -> t;
	  &nodeEditor[] -> edit[]; theScroller.contents[] -> edit.open;
      if)
   #)

-- bifrostObjectOnTextModeOn:DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find \'onTextModeOn\' object '->puttext; ID->putint; newline
    else
       theObject.theText.onTextModeOn
   if)

-- bifrostObjectOnTextModeOff:DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find \'onTextModeOff\' object '->puttext; ID->putint; newline
    else
       theObject.theText.onTextModeOff
   if)

-- bifrostPageOnKeyDown:descriptor --
(#
do
   (if theDocument[] <> NONE then
       (* Alt keys does not work in win32, so lets cheat a bit *)
       &<<SLOT bifrostPageKeyDown:descriptor>>
   if)
#)

-- bifrostPagePrint:descriptor--
(#
   rct: @rectangle
do
   (* FIXME: the group selection should not be lost when printing *)
   designGroup.clear;

   theMainPicture.getbounds->rct;
   (if UI.verbose then rct -> putBounds; newLine if);
   '%d %d translate\n' -> out.putFormat
     (#
     do
	-rct.x -> d; rct.height-rct.y -> d
	(* 30-rct.x -> d; 30+rct.height-rct.y -> d *)
     #);
   'Begin'->out.putline;
   out[] -> theMainPicture.writePS;
   'End'->out.putline;
#)

-- bifrostPageSave:descriptor--
(#
   out: @file;
   rct: @rectangle;
   realscale,hscale,vscale: @real;
   rotate: @boolean;
   op: @out.putLine; on: @out.newline; ot: @out.putText;
   bu: @point
do
   (* open file *)
   fileName[]->out.name;
   out.openWrite;

   theMainPicture.getbounds->rct;

   (if true
    // scaled then scale / 100.0 -> realscale
    // scaleToFit then
       (if rct.height < rct.width then true -> rotate if);
       (if rotate then
	   (* 11 inches in 1/72 of an inch
	    * .5 inch top and bottom margin
	    *)
	   (792 - 72) / rct.width -> vscale;
	   (* 8 inches in 1/72 of an inch
	    * .5 inch right and left margin
	    *)
	   (576 - 72) / rct.height -> hscale
	else
	   (* 11 inches in 1/72 of an inch
	    * .5 inch top and bottom margin
	    *)
	   (792 - 72) / rct.height -> vscale;
	   (* 8 inches in 1/72 of an inch
	    * .5 inch right and left margin
	    *)
	   (576 - 72) / rct.width -> hscale
       if);
       (if vscale < hscale then
	   vscale -> realscale
	else
	   hscale -> realscale
       if);
       (if realscale > 1.0 then
	   1.0 -> realscale
       if)
    else
       1.0 -> realscale
   if);

   '%!PS-Adobe-3.0'->out.putline;
   out.startEPSfile;

   '%%Pages: 1' -> op;
   '%%%%BoundingBox: %d %d %d %d\n%%%%EndComments\n' -> out.putFormat
     (#
     do
	36 -> d; 36 -> d;
	(if rotate then
	    ((rct.height * realscale) -> bu.x) + 36  -> d;
	    ((rct.width * realscale) -> bu.y) + 36 -> d
	 else
	    ((rct.width * realscale) -> bu.x) + 36 -> d;
	    ((rct.height * realscale) -> bu.y) + 36 -> d
        if)
     #);
   '%%BeginProlog' -> op;
   UI.getCVSinfoPS -> out.putLine;
   '%%BeginResource: procset Mjolner-Bifrost-StandardMacros 1.0 0' -> op;
   out.writeMacros;
   '%%EndResource' -> op;
   on;

   '%%BeginResource: procset pahe-bbox 1.0 0' -> op;
   '/pahe-bbox' -> op;
   '{ exch 0 0 moveto' -> op;
   '  dup' -> op;
   '  0 lineto' -> op;
   '  exch dup 3 1 roll lineto' -> op;
   '  0 exch lineto' -> op;
   '  0 0 lineto' -> op;
   '  stroke } def' -> op;
   '%%EndResource' -> op;
   on;

   '%%EndProlog' -> op;
   on;

   '%%Page: (' -> ot;
   THIS(bifrostPage).title -> ot;
   ') 1' -> op;
   '%%BeginPageSetup' -> op;
   '/pgsave save def' -> op;
   '%%EndPageSetup' -> op;
   on;

   'gsave' -> op;
   '36 36 translate' -> op;
   'newpath' -> op;
   '0 setlinewidth' -> op;
   '[4 4] 4 setdash' -> op;
   (if not UI.verbose then '% ' -> ot if);
   '%d %d pahe-bbox\n' -> out.putFormat(# do bu.x -> d; bu.y -> d #);
   'grestore' -> op;
   on;

   '36 36 translate % 0.5 inch margin' -> op;
   '%% vscale %f hscale %f \n'
     -> out.putFormat(# do vscale -> f; hscale -> f #);
   '%f %f scale\n' -> out.putFormat(# do realscale -> f; realscale -> f #);
   (if rotate then
       '90 rotate' -> op;
       '0 -%d translate\n' -> out.putFormat(# do rct.height -> d #)
   if);

   out[] -> print;

   (* showpage only by public demand /pahe *)
   'pgsave restore' -> op;
   'showpage' -> op;
   '%%Trailer' -> op;
   '%%EOF' -> op;
   out.close
#)

-- bifrostPageLoad: descriptor --
(#
   oldRepair: @boolean
do
   dontRepair -> oldRepair;
   true -> dontRepair;
   psfile[] -> loadPicture
     (#
	createGO::
	  (#
	     dp: ^designPicture; dobj: ^designObject;
	     dn: ^designNode; dc: ^designConn
	  do
	     (if true
	      // 'designconn' -> patternName.equalNCS then
		 &designConn[] -> GO[]
	      // 'designrect' -> patternName.equalNCS then
		 &designRect[] -> GO[]
	      // 'designellipse' -> patternName.equalNCS then
		 &designEllipse[] -> GO[]
	      // 'designpoly' -> patternName.equalNCS then
		 &designPoly[] -> GO[]
	      // 'designlabel' -> patternName.equalNCS then
		 &designLabel[] -> GO[]
	      // 'mainPicture' -> patternName.equalNCS then
		 &mainPicture[] -> theMainPicture[] -> GO[];
		 (* aliases for shapes *)
	      // 'designObjectText' -> patternName.equalNCS then
		 currentReadPicture[] -> dobj[];
		 &designObjectText[] -> GO[];
		 (if true
		  // dobj## <= designNode## then
		     dobj[] -> dn[];
		     GO[] -> dn.theText[];
		  // dobj## <= designConn## then
		     (* for backwards compatibility *)
		     dobj[] -> dc[];
		     GO[] -> dc.textToDelete[]
		  else
		     'Error during load - text object on unknown object type'
		       -> putLine
                 if)
	      // 'designRectShape' -> patternName.equalNCS then
		 currentReadPicture[] -> dn[];
		 &designRectShape[] -> dn.shape[] -> GO[];
	      // 'designRectFilledShape' -> patternName.equalNCS then
		 currentReadPicture[] -> dn[];
		 &designRectFilledShape[] -> dn.filledShape[] -> GO[];
	      // 'designEllipseShape' -> patternName.equalNCS then
		 currentReadPicture[] -> dn[];
		 &designEllipseShape[] -> dn.shape[] -> GO[];
	      // 'designEllipseFilledShape' -> patternName.equalNCS then
		 currentReadPicture[] -> dn[];
		 &designEllipseFilledShape[] -> dn.filledShape[] -> GO[];
	      // 'designPolyShape' -> patternName.equalNCS then
		 currentReadPicture[] -> dn[];
		 &designPolyShape[] -> dn.shape[] -> GO[];
	      // 'designPolyFilledShape' -> patternName.equalNCS then
		 currentReadPicture[] -> dn[];
		 &designPolyFilledShape[] -> dn.filledShape[] -> GO[];
	      // 'designConnLine' -> patternName.equalNCS then
		 currentReadPicture[] -> dc[];
		 &designConnLine[] -> dc.connPrivate.theLine[] -> GO[];
	      // 'designConnFatLine' -> patternName.equalNCS then
		 currentReadPicture[] -> dc[];
		 &designConnFatLine[] -> dc.connPrivate.theFatLine[] -> GO[];
	      // 'bifrostConnArrow' -> patternName.equalNCS then
		 currentReadPicture[] -> dc[];
		 &dc.connPrivate.bifrostConnArrow[]
		   -> dc.connPrivate.theArrow[] -> GO[]
	      else
		 'Unknown shape: %s\n'
		   -> putFormat(# do patternName[] -> s #)
	     if);
             (if GO## <= designPicture## then
		 GO[] -> dp[];
		 currentReadPicture[] -> dp.load_prevPicture[];
		 dp[] -> currentReadPicture[]
             if);
	     (if GO## <= designNode## then
		 GO[] -> dn[];
		 dn.startConnectors.init; dn.endConnectors.init
             if)
	  #)
     do
	(if UI.verbose then screen[] -> private.debug[] if)
     #);
   rougeText;
   &<<SLOT bifrostPageLoadDrawMaybe: descriptor>>;
   oldRepair -> dontRepair
#)

-- bifrostPageOnActivate: doPart --
do
   (if THIS(bifrostPage)[] <> currentBifrostPage[] then
       THIS(bifrostPage)[] -> currentBifrostPage[];
       (currentBifrostPage.theMenuBar).checkMenuBar
   if)

-- bifrostPageUpdateMenuBar: doPart --
do
   (#
      fileMenuSeen: @boolean
   do
      (theMenuBar).clear;
      (if bifrostDesignDebug then
	  (theMenuBar).extraMenu[] -> (theMenuBar).append
      if);
      THIS(designEnv).menuBar.scan
   	(#
   	   t: ^text
   	do
   	   (if current.att.menu[] <> NONE then
   	       current.att.menu.name -> t[];
   	       (if
		   (* This is a hack for windows (may it fry in hell) *)
		   'file' -> t.equalNCS then
                   (if not fileMenuSeen then
   		       current.att.menu[] -> (theMenuBar).append;
                       true -> fileMenuSeen
                   if)
                else
   		   current.att.menu[] -> (theMenuBar).append
   	       if)
   	   if)
   	#)
   #)

-- bifrostGroupSet:doPart --
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupSet:doPart' -> putLine
   if)

-- bifrostGroupGet:doPart --
do
   (#
      i: @integer
   do
      (if UI.verbose then
	  'bifrostobjectbody-bifrostGroupGet:doPart' -> putLine
      if);
      private.implList.size -> rep.new; 1 -> i;
      private.implList.scan(# do current.ID -> rep[i]; 1 + i -> i #)
   #)

-- bifrostGroupToggle:doPart--
do
   (if theObject.grpPos[] <> NONE then
       (if UI.verbose then
	   'bifrostobjectbody-bifrostGroupToggle: delete' -> putLine
       if);
       theObject.grpPos[] -> private.implList.delete;
       theObject.removeGroupHilight;
       NONE -> theObject.grpPos[];
       (if isEmpty then false -> private.modeOn if)
    else
       (if not (theObject[] -> private.parentInGroup) then
	   (if UI.verbose then
	       'bifrostobjectbody-bifrostGroupToggle: insert' -> putLine
	   if);
	   (if theObject.moveable then
	       theObject[] -> private.implList.insertRR;
	       theObject.addGroupHilight;
	       true -> private.modeOn
           if)
	else
	   (if UI.verbose then
	       'bifrostobjectbody-bifrostGroupToggle: parentInGroup' -> putLine
	   if)
       if)
   if)

-- bifrostGroupInit:doPart--
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupInit:doPart' -> putLine
   if);
   private.implList.init; false -> private.modeOn

-- bifrostGroupClear:doPart--
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupClear:doPart' -> putLine
   if);
   private.implList.scan
     (#
     do
	current.removeGroupHilight;
	NONE -> current.grpPos[]
     #);
   false -> private.modeOn;
   private.implList.clear

-- bifrostGroupUpdate:DoPart--
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupUpdate:doPart' -> putLine
   if);
   (if dontRepair then
       (failureTrace,'designGroup.update is for internal use only!')
	 -> stop
   if);
   true -> dontRepair;
   private.implList.scan
     (#
     do
	current.removeGroupHilight;
	current.addGroupHilight
     #);
   false -> dontRepair

-- bifrostGroupPrivate: descriptor --
(#
   parentInGroup: booleanValue
     (#
	tp: ^designObject;
     enter tp[]
     do
	loop:
	  (#
	  do
	     (if tp.grpPos[] <> NONE then true -> value if);
	     (if (tp.load_prevPicture[] <> NONE)
		   and (tp.load_prevPicture## <= designObject##) then
		 tp.load_prevPicture[] -> tp[];
		 restart loop
	     if)
	  #)
     #);
   implList: @list
     (#
	element:: designObject; (* of the bifrost kind *)
	insertRR: (* insert and Remove Regions *)
	  (#
	     elm: ^element;
	     pos: ^theCellType
	  enter elm[]
	  do
	     (if not empty then
		 elm.scanSubRegions
		   (#
		   do
		      (if dp.grpPos[] <> NONE then
			  dp.grpPos[] -> delete;
			  dp.removeGroupHilight;
			  NONE -> dp.grpPos[]
                      if)
		   #)
             if);
	     elm[] -> prepend -> elm.grpPos[]
	  #)
     #);
   modeOn: @boolean;
   updateInfoBar:
     (#
	t: @text
     do
	t.clear;
	(if modeOn then
	    'Info: Group of %d object%s selected' -> t.putFormat
	      (#
	      do
		 implList.size -> d;
		 (if implList.size = 1 then
		     '' -> s
		  else
		     's' -> s
                 if)
              #);
	    t[] -> infoBar.label
        if)
     #)
#)

-- bifrostObjectAddGroupHilight: doPart --
do
   (if UI.veryVerbose then
       '%d: add group highlight\n' -> putFormat(# do ID -> d #)
   if);
   INNER;
   (#
      bnd: @rectangle; rct: ^rect
   do
      (if not doneInInner then
	  &rect[] -> rct[] -> groupHilight[];
	  rct.init; 50 -> rasterGrays -> rct.setPaint;
	  true -> rct.theShape.stroked; 2 -> rct.theShape.strokeWidth;
	  getBounds -> bnd;
	  (bnd.x,bnd.y) -> rct.upperLeft;
	  bnd.width -> rct.width;
	  bnd.height -> rct.height;
	  rct[] -> theScroller.contents.draw;
	  rct[] -> theMainPicture.group.add
      if)
   #)

-- bifrostObjectRemoveGroupHilight: doPart --
do
   (if UI.veryVerbose then
       '%d: remove group highlight\n' -> putFormat(# do ID -> d #)
   if);
   INNER;
   (if not doneInInner then
       (if groupHilight[] // NONE then
	   'bifrostobjectbody-bifrostObjectRemoveGroupHilight:' -> putLine;
	   '  groupHilight[] is NONE...' -> putLine
	else
	   groupHilight[] -> theMainPicture.group.delete;
	   groupHilight[] -> theScroller.contents.erase
       if)
   if)

-- bifrostGroupIsEmpty:DoPart --
do
   private.implList.empty -> value

-- bifrostGroupClick:DoPart --
do
   (if (not private.modeOn) or (theObject## <= designConn##) then
       clear; false -> private.modeOn;
       theObject.onSelect
    else
       (if theObject.grpPos[] // NONE then
	   clear;
	   toggle
       if)
   if)

-- bifrostConnSetPoints:doPart --
do
   (#
      pa: ^pointArray; pt: @point; i: @integer
   do
      (if theScroller.contents.ready then
	  (* this(designConn)[] -> theScroller.contents.erase; *)
	  connPrivate.damaged
      if);
      &pointArray[] -> pa[]; (pts.range div 2) -> pa.initPoints;

      connPrivate.theLine.theShape.firstPoint -> pa.addPoint;
      connPrivate.theLine.theShape.lastPoint -> pa.addPoint;

      (for inx: (pts.range div 2) - 2 repeat
	   (pts[inx*2+1], pts[inx*2+2]) -> pt;
	   (if UI.verbose then
	       pt -> putPoint; pt -> design2bifrost -> putPoint; newLine
	   if);
	   (if UI.veryVerbose (* FIXME: introduce a new verbose? *) then
	       pt -> theMainPicture.plotPoint
	   if);
	   (if orient
	    // 0 (* No arrows *)
	    // 1 (* Arrow head at node 2 *)
	    // 3 (* Arrow head at both ends *) then
	       1 -> i
	    // 2 (* Arrow head at node 1 *) then
	       inx -> i
	   if);
	   (pt -> design2bifrost,i)-> pa.insertPoint
      for);
      pa[] -> connPrivate.thePoints[];
      connPrivate.setPoints; connPrivate.connect;
      (if theScroller.contents.ready then
          (* FIXME: should draw be called or not *)
	  (* this(designConn)[] -> theScroller.contents.draw; *)
	  connPrivate.damaged
      if);
      THIS(bifrostpage).repair
   #)

-- bifrostRectInitRegtion:DoPart --
do

-- bifrostRectUnmakeRegion:DoPart --
do

-- align: doPart--
do
   (#
      dcp: ^theDocument.page;
      dobj: ^dcp.DesignObject;
      bobj: ^cp.designObject;
      gos: [0]@integer;
      cnt: ^cp.point;
      oldrepair: @boolean
   do
      dontRepair -> oldrepair;
      true -> dontRepair;
      theDocument.currentPage->dcp[];
      (theDocument.currentPage).ID -> UI.getApage -> cp[];
      &cp.alignRects[] -> ar[];
      cp.designGroup.getGroup -> gos;
      (for inx:gos.range repeat
	   UI.bifrostObjectList.rep[gos[inx]].IO[] -> bobj[];
	   (if UI.verbose then
	       '%d: align shapeBounds ' -> putFormat(# do gos[inx] -> d #);
	       bobj.shapeBounds -> putBounds; newline
           if);
	   bobj.shapeBounds -> ar.insert
      for);
      INNER align;
      (for inx:gos.range repeat
	   &cp.point[] -> cnt[];
	   ar.impl[inx].x + ar.impl[inx].width div 2 -> cnt.x;
	   ar.impl[inx].y - ar.impl[inx].height div 2 -> cnt.y;
	   gos[inx] -> theDocument.theObjectList.Find -> dobj[];
	   cnt -> bifrost2design -> dobj.center;
      for);
      oldrepair -> dontRepair;
      cp.repair
   #)

-- alignLeft: descriptor --
align(# do (cp.designSelection).shapeBounds -> ar.alignLeft #)

-- alignRight: descriptor --
align(# do (cp.designSelection).shapeBounds -> ar.alignRight #)

-- alignTop: descriptor --
align(# do (cp.designSelection).shapeBounds -> ar.alignTop #)

-- alignBottom: descriptor --
align(# do (cp.designSelection).shapeBounds -> ar.alignBottom #)

-- alignVertical: descriptor --
align(# do (cp.designSelection).shapeBounds -> ar.alignVertical #)

-- alignHorizontal: descriptor --
align(# do (cp.designSelection).shapeBounds -> ar.alignHorizontal #)

-- alignSpacing: descriptor --
align
  (#
     ad: @theGUI.alignDialog
       (#
	  onOK::
	    (#
	    do
	       close;
	       ((cp.designSelection).shapeBounds,
		  vdist,hdist,
		  vertical,horizontal)
		 -> ar.spacing
	    #);
	  onCancel::(# do close #)
       #)
  do
     ad.open; ad.showModal
  #)

-- ObjectGetIsRegion:dopart --
do
   UI.bifrostObjectList.rep[ID].IO.isRegion -> value

-- graphics: doPart --
do
   INNER

-- graphicsConn: descriptor --
graphics
  (#
  do
     'Left click on a node to create a new connector'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaConn -> currentBifrostPage.interactiveState
  #)

-- graphicsRect: descriptor --
graphics
  (#
  do
     'Left click to create a new rectangle'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaRect -> currentBifrostPage.interactiveState
  #)

-- graphicsRndRect: descriptor --
graphics
  (#
  do
     'Left click to create a new rounded rectangle (not yet implemented)'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaRndRect -> currentBifrostPage.interactiveState
  #)

-- graphicsEllipse: descriptor --
graphics
  (#
  do
     'Left click to create a new ellipse'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaEllipse -> currentBifrostPage.interactiveState
  #)

-- graphicsWedge: descriptor --
graphics
  (#
  do
     'Left click to create a new wedge'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaWedge -> currentBifrostPage.interactiveState
  #)

-- graphicsPoly: descriptor --
graphics
  (#
  do
     'Left click to create a new polygon'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaPoly -> currentBifrostPage.interactiveState
  #)

-- graphicsLine: descriptor --
graphics
  (#
  do
     'Left click to create a new line'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaLine -> currentBifrostPage.interactiveState
  #)

-- graphicsLabel: descriptor --
graphics
  (#
  do
     'Left click to create a new text label'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaLabel -> currentBifrostPage.interactiveState
  #)

-- graphicsPicture: descriptor --
graphics
  (#
  do
     'Do something to create a new picture'
       -> currentBifrostPage.infoBar.label;
     currentBifrostPage.iaPicture -> currentBifrostPage.interactiveState
  #)

-- bifrostObjectDumpSub:DoPart --
do
   scanGOsReverse
   (#
      dp: ^designObject
   do
      (if go## <= designObject## then
          go[] -> dp[];
          dp.dump;
          dp.dumpSub
      if)
   #)

-- dumpAll: doPart --
do
   currentBifrostPage.theMainPicture.scanGOsReverse
   (#
      dp: ^currentBifrostPage.designObject
   do
      (if go## <= currentBifrostPAge.designObject## then
          go[] -> dp[];
          dp.dump;
          dp.dumpSub
      if)
   #)

-- bifrostNodeOnSize:DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find size click object '->puttext; ID->putint; newline
    else
       theObject.onSize
   if)

-- bifrostConnShapeContainsPoint:DoPart --
do
   (cv[],pt) -> connPrivate.theFatLine.containsPoint -> value;
   INNER

-- kukkuk:doPart --
do
   debugMark + 1 -> debugMark;
   '\n\n\n\n\n<<-- %05d -->>\n' -> putFormat(# do debugMark -> d #)

-- bifrostPageUpdateInfoBar:doPart--
do
   (#
      obj: ^designObject
   do
      (if designSelection // NONE then
	  'Info:' -> infoBar.label
       else
	  designSelection -> obj[];
	  (if true
	   // obj## <= designNode## then
	      'Info: one node selected' -> infoBar.label
	   // obj## <= designConn## then
	      'Info: one connector selected'
		-> infoBar.label
	   else
	      'Info: one object selected'
		-> infoBar.label
	  if)
      if);
      designGroup.private.updateInfoBar
   #)

-- bifrostConnSetLineThickness: doPart --
do
   thick -> connPrivate.theLine.width

-- bifrostRectSetLineThickness: doPart --
do
   thick -> shape.theShape.strokeWidth

-- bifrostEllipeseSetLineThickness: doPart --
do
   (* thick -> shape.theShape.strokeWidth *)

-- bifrostPolySetLineThickness: doPart --
do
   thick -> shape.width

-- bifrostLabelSetLineThickness: doPart --
do
   (* NOTHING *)

-- bifrostConnGetLineThickness: doPart --
do
   connPrivate.theLine.width -> thick

-- bifrostRectGetLineThickness: doPart --
do
   shape.theShape.strokeWidth -> thick

-- bifrostEllipeseGetLineThickness: doPart --
do
   (* shape.theShape.strokeWidth -> thick *)

-- bifrostPolyGetLineThickness: doPart --
do
   shape.width -> thick

-- bifrostLabelGetLineThickness: doPart --
do
   (* NOTHING *)

-- bifrostPageDamage: doPart--
do
   (if UI.extremelyVerbose then
       'damaged: r ' -> putText; rct -> putBounds
   if);
   (if damaged.width // 0 then
       (if UI.extremelyVerbose then ' d -' -> putText if);
       rct -> damaged
    else
       (if UI.extremelyVerbose then
	   ' d ' -> putText; damaged -> putBounds
       if);
       (rct,damaged) -> rectUnion -> damaged
   if);
   (if UI.extremelyVerbose then
       ' d\' ' -> putText; damaged -> putBounds; newline
   if)

-- bifrostPageCheckMenuBar: doPart --
do
   check:
     (#
	currentMenus: [0]^theGUI.menu;
	menuInx: @integer;
	extraName: @text;
     do
        (if currentBifrostPage[] // NONE then leave check if);
	(if UI.verbose then
	    '%d: bifrostPageCheckMenuBar-bifrostobjectbody\n'
	      -> putFormat(# do currentBifrostPage.theMainPicture.ID -> d #)
	if);
	'Extras' -> extraName;
	scan
	  (#
	  do
	     (if not (current.name -> extraName.equal) then
		 menuInx + 1 -> menuInx
             if)
	  #);
	menuInx -> currentMenus.new;
	0 -> menuInx;
	scan
	  (#
	  do
	     (if not (current.name -> extraName.equal) then
		 menuInx + 1 -> menuInx;
		 current[] -> currentMenus[menuInx][]
             if)
	  #);
	0 -> menuInx;
	(if currentMenus.range <> THIS(designenv).menuBar.size then
	    currentBifrostPage.updateMenuBar;
	    leave check
        if);
	THIS(designenv).menuBar.scan
	  (#
	     theMenu: ^theGUI.menu;
	     currentMenuItems: [0]^theMenu.menuItem;
	     itemInx: @integer
	  do
	     menuInx + 1 -> menuInx;
	     currentMenus[menuInx][] -> theMenu[];
	     (if UI.menuVerbose then
		 '%d: %s\n' -> putFormat
		   (# do current.ID -> d; current.att.name[] -> s #)
	     if);
	     (if not (current## <= THIS(designenv).designMenu##) then
		 (if not (theMenu.name -> current.att.name.equal) then
		     theMenu.name -> putLine;
		     currentBifrostPage.updateMenuBar;
		     leave check
		 if);
		 (if theMenu.noOfMenuitems <> current.itemList.size then
		     currentBifrostPage.updateMenuBar;
		     leave check
		 if);
		 theMenu.noOfMenuitems -> currentMenuItems.new;
		 0 -> itemInx;
		 theMenu.scan
		   (#
		   do
		      itemInx + 1 -> itemInx;
		      current[] -> currentMenuItems[itemInx][]
		   #);
		 0 -> itemInx;
		 current.itemList.scan
		   (#
		      txt: @text
		   do
		      itemInx + 1 -> itemInx;
		      (if UI.menuVerbose then
			  ' %d: %s %s\n' -> putFormat
			    (#
			    do
			       current.itemNumber -> d;
			       currentMenuItems[itemInx].name -> s;
			       current.att.name[] -> s
			    #)
		      if);
		      txt.clear;
		      0 -> current.att.name.pos;
		      (if current.att.name.peek
		       // '\\' then
			  current.att.name.get;
			  current.att.name.get;
			  current.att.name.getLine -> txt.putText
		       // '-' then
			  'separator' -> txt.putText
		       else
			  current.att.name[] -> txt.putText
		      if);
		      (if not (currentMenuItems[itemInx].name -> txt.equal)
			    then
			  currentBifrostPage.updateMenuBar;
			  leave check
		      if)
		   #)
             if)
	  #)
     #)

-- bifrostPageRepair: doPart --
do
   (if (not dontRepair) and (damage.damaged.width <> 0) then
       (if designSelection <> NONE then
	   (designSelection).unhilite
       if);
       (if not dontUpdateGroup then designGroup.update if);
       damage.damaged -> theScroller.contents.damaged;
       theScroller.contents.repair;
       (if UI.warnDanger then
	   'repair just called' -> putLine
       if);
       0 -> damage.damaged.width;
       (if designSelection <> NONE then
	   (designSelection).hilite
       if);
       (if autoPanObject[] <> NONE then autoPanObject.autoPan if);
       updateInfoBar
   if)

-- bifrostPageBlowup:doPart --
do
   (#
      PTM: @Matrix
   do
      (* (2.0, 0.0, 0.0, 2.0, 0.0, 0.0)->PTM.set; *)
      (* PTM[]->theMainPicture.transform; *)
      'blowup not implemented yet' -> putLine
   #)

-- bifrostPageReduce:doPart --
do
   (#
      PTM: @Matrix
   do
      (* (0.5, 0.0, 0.0, 0.5, 0.0, 0.0)->PTM.set; *)
      (* PTM[]->theMainPicture.transform; *)
      'reduce not implemented yet' -> putLine
   #)

-- bifrostObjectOnRightMouseDown: DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find right mousedown object '->puttext; ID->putint; newline
    else
       mousePos->theObject.onRightMouseDown
   if)

-- designObjectOnRightMouseDown: DoPart --
do
   THIS(page).ID->UI.getContentsOfPage->inWindow[];
   (if inWindow[] <> none then INNER onRightMouseDown if)

-- bifrostPageCleanUp: descriptor --
(#
do
   true -> theScroller.contents.update
#)

-- designPictureInteractiveMove: doPart --
do
   INNER;
   (* TAKEN from bifrost/private/Impl/GoImpl.bet cvs ver 1.4 *)
   (if not doneInInner then
       thecanvas.InteractionHandler
         (#
            mousePoint: @Point;
            stopinteraction: @boolean;
            mm: @MoveMatrix;
            offset: @Point;
            myabs: @abs;
	    vs: (* View Size*) @Point;
	    cs: (* Canvas Size *) @Point;
	    oldoff: (* old offset *) @Point;
	    vtl: (* view top left *) @Point;
	    vbr: (* view bottom right *) @Point;
	    xscroll: (# exit 10 #);
	    yscroll: (# exit 10 #);
	    everScrolled: @boolean;
            Initialize::<
              (#
              do (* Erase original highlight *)
                 (if private.hilited then
                     (theCanvas[],false,none )->theshape.drawhilite;
                 if);
                 (* Highlight outline *)
                 (theCanvas[],true,none )->theshape.ho;
                 startPoint->mousePoint;

		 theCanvas.size -> cs;
		 theScroller.viewSize -> vs;
              #);
            Motion::<
              (#
		 scrolled: @Boolean
              do (* erase outline at old position *)
                 offset->oldoff->mm;
                 (theCanvas[],false,mm[])->theshape.ho;
                 (* Find new offset and draw outline *)
                 GetPointerLocation->thecanvas.DeviceToCanvas->mousePoint;
                 (mousePoint.x-startpoint.x,mousePoint.y-startpoint.y)->offset;
                 (if themodifier->isModifierOn then
		     (* Constrain to orthogonal movements *)
                     (if (offset.y->myabs) > (offset.x->myabs) then
			 (* 90 degrees *)
                         0->offset.x;
                      else
			 (* 0 degrees *)
                         0->offset.y;
                     if)
                 if);


		 theScroller.theScroll -> vtl;
		 (vtl,vs) -> addPoints -> vbr;

		 (if true
		  // (vbr.x < mousepoint.x) and (offset.x > oldoff.x) then
		     (* scroll right *)
		     (vtl.x+xscroll,vtl.y) -> theScroller.theScroll;
 		     (vbr.x,vbr.y,xscroll,vs.y) -> theCanvas.damaged;
		     true -> scrolled
		  // (vtl.x-500 < mousepoint.x) (* FIXME: HACK *)
		       and (mousepoint.x < vtl.x)
		       and (offset.x < oldoff.x) then
		     (* scroll left *)
		     (vtl.x-xscroll,vtl.y) -> theScroller.theScroll;
 		     (vtl.x-xscroll,vbr.y,xscroll,vs.y) -> theCanvas.damaged;
		     true -> scrolled
                 if);

 		 (if true
		  // ((cs.y-vtl.y) < mousepoint.y)
		       and (mousepoint.y < (cs.y-vtl.y)+500) (* FIXME: HACK *)
		       and (offset.y > oldoff.y) then
		     (* scroll up *)
		     (vtl.x,vtl.y-yscroll) -> theScroller.theScroll;
 		     (vtl.x,cs.y-vtl.y+yscroll,vs.x,yscroll)
		       -> theCanvas.damaged;
		     true -> scrolled
 		  // (mousepoint.y < (cs.y-vbr.y))
		       and (offset.y < oldoff.y) then
		     (* scroll down *)
		     (vtl.x,vtl.y+yscroll) -> theScroller.theScroll;
 		     (vtl.x,cs.y-vbr.y,vs.x,yscroll) -> theCanvas.damaged;
		     true -> scrolled
		 if);

		 (if scrolled then true -> everScrolled; theCanvas.repair if);

                 offset->mm;
                 (theCanvas[],true,mm[])->theshape.ho
              #);
            ButtonRelease::<  (#  do true->stopinteraction #);
            TerminateCondition::<  (#  do stopinteraction->value;  #);
            Terminated::<
              (# GB: @GetBounds;
              do (* Erase outline highlight *)
                 (theCanvas[],false,none )->theshape.ho;
                 (if (offset.x <> 0) or (offset.y <> 0) then
                     GB->thecanvas.damaged;
                     offset->move;
                     GB->thecanvas.damaged;

                 if);
		 (if everScrolled then cleanUp if);
                 (* Restore original highlight *)
                 (if private.hilited then
                     (theCanvas[],false,none )->theshape.drawHilite
                 if);

              #)
         #);
       thecanvas.repair;
       true->doneInInner
   if)

-- bifrostConnMoveRegions:doPart --
do
   (#
      tc: @Point
   do
      ScanGOsReverse
	(#
	   dobj: ^designObject
	do
	   (if GO## <= designObject## then
	       GO[] -> dobj[];
	       dobj.getCenter -> tc;
	       ((tc,oc) -> subPoints,nc) -> addPoints -> tc;
	       dobj.modify(# do tc -> dobj.setCenter #)
	   if)
	#);
   #)

-- bifrostPageRougeText:descriptor --
(#
   (* Removes text from connectors - for backwards compatibility only *)
do
   theMainPicture.scanGOsReverse
     (#
	dc: ^designConn
     do
	(if go## <= designConn## then
	    go[] -> dc[];
	    (if dc.textToDelete[] <> NONE then
		'Note: removing text from connector with id=%d\n'
		  -> putFormat(# do dc.ID -> d #);
		dc.textToDelete[] -> dc.delete;
		NONE -> dc.textToDelete[]
            if)
	if)
     #)
#)
