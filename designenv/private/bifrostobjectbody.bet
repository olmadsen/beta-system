ORIGIN 'designobjectbody';
INCLUDE '~beta/bifrost/EPSfile'
	'~beta/bifrost/RasterGrays'
	'aligndialog'
	'~beta/guienv/controls'
	'~beta/bifrost/private/Impl/GoImpl'
	'computeCenter'
	'~beta/bifrost/private/PS/EPSread';
LIB_ITEM 'designenv';
MDBODY nti 'bifrostdesignNTbody'
       ppcmac 'bifrostdesignmac'
       default 'bifrostdesignX11body';
-- bifrostobjectbodyCVSINFO: Descriptor --
(#
do
   '$Id: bifrostobjectbody.bet,v 1.38 2001-01-05 15:27:05 ess Exp $'
     ->msg.putLine;
   <<SLOT bifrostobjectbodymdbodyCVSINFO:Descriptor>>
#)

-- lib: Attributes --
point2text:
  (# p: @point; t: ^text;
  enter p
  do 'x:'->t[]; p.h->t.putint; ' y:'->t.puttext; p.v->t.putint;
  exit t[]
  #);
distanceToLine: (* algorithm from Graphical Gems II, p. 10-13 *)
  (#
     A,B,P: @point;
     idist: (* algorithm from Graphical Gems, p. 427-431 *)
       (# X,Y: @point; res: @integer
       enter (X,Y)
       do
	  Y.h-X.h->abs->Y.h;
	  Y.v-X.v->abs->Y.v;
	  Y.h+Y.v-(((Y.h,Y.v)->min) div 2)->res;

       exit res
       #);
     d1: (* algorithm from Graphical Gems II, p. 10-13 *)
       (# a2: @integer; res: @integer
       do
	  (P.v-A.v)*(B.h-A.h)-(P.h-A.h)*(B.v-A.v)->abs->a2;
	  (((B.h-A.h)->abs)+((B.v-A.v)->abs)-
	   ((((B.h-A.h)->abs,(B.v-A.v)->abs)->min) div 2))->res;
	  (if res <> 0 then a2 div res->res if)
       exit res
       #);
     d2: @integer;

  enter (A,B,P)
  do
     (if (P.h-A.h)*(B.h-A.h)+(P.v-A.v)*(B.v-A.v) < 0 then
	 (A,P)->idist->d2
      else
	 (if (B.h-P.h)*(B.h-A.h)+(B.v-P.v)*(B.v-A.v) < 0 then
	     (B,P)->idist->d2
	  else
	     d1->d2
	 if)
     if)
  exit d2
  #)

-- bifrostObjectGetMyObject: DoPart --
do
   theDocument.currentPage->thePage[];
   ID->theDocument.theObjectList.Find->theObject[];
   INNER

-- bifrostObjectOnDoubleClick: DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find double click object '->puttext; ID->putint; newline
    else
       theObject.onDoubleClick
   if)

-- bifrostObjectOnDrag: DoPart --
do
   INNER ;
   (if theObject[]
    // none then 'Can\'t find dragged object '->puttext; ID->putint; newline
    else
       theObject.onDrag
   if)

-- bifrostObjectSetColor: DoPart --
do INNER

-- bifrostNodeSetColor: DoPart --
do
   (if filledShape[] <> none then
       newcolor[]->filledShapeColor[]->filledShape.setPaint;
   if);
   INNER

-- bifrostObjectNew: DoPart --
do (* create ID to GO mapping *)
   &IDBifrost[]->bifid[];
   (THIS(bifrostPage)[],THIS(designObject)[],bifrostObjectList.newID->ID)
     ->bifid.init;
   (* create a color, which is to be used by the specializations *)
   &solidColor[]->color[];
   color.init;
   black->color.RGBValues;
   init;
   INNER ;
   c->setCenter;
   (* finally add this entity to the global community *)
   THIS(designObject)[]->THIS(bifrostpage).theMainPicture.add;
   THIS(designObject).getBounds->THIS(bifrostpage).damage;
   (* THIS(bifrostpage).theScroller.contents.repair *)
   (* Update screen - revisit *)
   (* THIS(bifrostpage).theScroller.contents.update *)


-- bifrostObjectInit: DoPart --
do true->selectable; INNER

-- bifrostObjectGetCenter: DoPart --
do
   getbounds->r;
   INNER ;
   (if not doneInInner then
       r.x+r.width div 2->c.x; r.y-r.height div 2->c.y
   if)

-- bifrostObjectSetCenter: DoPart --
do
     (# oldrepair: @boolean
     do
	dontRepair->oldrepair;
	true->dontRepair;
	(if designSelection <> none then (designSelection).unhilite if);
	getbounds->r;
	INNER setCenter;
	(if not doneInInner then
	    (if UI.verbose then
		'Center to set c: %dx%d\n'
		  ->putFormat
		    (#
		    do THIS(setCenter).c.x->d; THIS(setCenter).c.y->d
		    #);
		'Shape bounds r: %dx%d\n'
		  ->putFormat
		    (#  do THIS(setCenter).r.x->d; THIS(setCenter).r.y->d #)
	    if);
	    c.x-r.width div 2->c.x;
	    c.y+r.height div 2->c.y;
	    (if THIS(bifrostPage).designSelection <> none then
		(THIS(bifrostPage).designSelection).unHilite;
		(c.x-r.x,c.y-r.y)->move;
		(THIS(bifrostPage).designSelection).hilite
	     else
		(c.x-r.x,c.y-r.y)->move;
	    if);
	    (if UI.verbose then
		getbounds->r;
		'Picture bounds r: %dx%d\n'
		  ->putFormat
		    (#  do THIS(setCenter).r.x->d; THIS(setCenter).r.y->d #)
	    if)
	if);
	(if autoPanned then autopan if);
	getBounds->damage;
	(if designSelection <> none then (designSelection).hilite if);
	oldrepair->dontRepair;
	repair
     #)

-- bifrostNodeRepostionText: DoPart --
do
   shape.getBounds->sb;
   INNER repositionText;
     (# tc: (* text upperleft *) @point; tr: (* text bounds *) @rectangle
     do
	(if theText[] <> none then
	    getcenter->tc;
	    theText.getBounds->tr;
	    sb.y->tc.y;
	    <<SLOT repositionTextAdjust:Descriptor>>;
	    (if textJust
	     // justification.default
	     // justification.left then
		tc.x-sb.width div 2+2->tc.x
	     // justification.right then
		tc.x+sb.width div 2-2->tc.x
	     // justification.center then
		tc.x-tr.width div 2->tc.x
	     else
		(if UI.verbose then
		    '%d: unknown text justification %d\n'
		      ->putFormat (#  do id->d; textJust->d #)
		if)
	    if);
	    (tc.x-tr.x,tc.y-tr.y)->theText.move
	if)
     #)

-- bifrostNodeTextJustSet: DoPart --
do
   (if tj
    // justification.default then
       justification.left->tj (* revisit - default setting *)
   if);
   repositionText

-- bifrostObjectBringToFront: DoPart --
do THIS(designObject)[]->theMainPicture.bringForward

-- bifrostObjectSendToBack: DoPart --
do THIS(designObject)[]->theMainPicture.sendBehind

-- bifrostObjectDump: DoPart --
do
   'Start graphicalObject dump '->putText;
   (if isRegion then '(region)'->putLine else '(top)'->putLine if);
   'ID: '->putText;
   ID->putInt;
   newline;
   INNER ;
   'End graphicalObject dump.'->putLine

-- bifrostConnGetCenter: DoPart --
do
   true->doneInInner;
   connPrivate.theLine.TM->connPrivate.theLine.theShape.computeCenter->c

-- bifrostConnSetCenter: DoPart --
do true->doneInInner

-- bifrostConnSetend: DoPart --
do
   (end,connPrivate.thePoints.npoints)->connPrivate.thePoints.setPoint;
   connPrivate.thePoints[]->connPrivate.setPoints

-- bifrostConnSetbegin: DoPart --
do
   (begin,1)->connPrivate.thePoints.setPoint;
   connPrivate.thePoints[]->connPrivate.setPoints

-- bifrostConnWrite: DoPart --
do
   ' %d %d %d %d %d %d %d '
     ->userdata.putFormat
       (#
       do
	  end->(d,d);
	  begin->(d,d);
	  connPrivate.orient->d;
	  connPrivate.node1.ID->d;
	  connPrivate.node2.ID->d
       #);
   INNER

-- bifrostPageReattachConnectors: Descriptor --
connList.scan
  (#
  do
     (if UI.verbose then 'bifrostPage.reattachConnectors'->putLine if);
     current
       ->lookupDesignPicture
	 (# objectDesc:: thePage.designConn; bi: ^IDBifrost
	 do
	    bifrostObjectList.rep[theObject.connPrivate.node1ID][]->bi[];
	    bi.IO[]->theObject.connPrivate.node1[];
	    theObject[]->theObject.connPrivate.node1.startConnectors.insert;
	    bifrostObjectList.rep[theObject.connPrivate.node2ID][]->bi[];
	    bi.IO[]->theObject.connPrivate.node2[];
	    theObject[]->theObject.connPrivate.node2.endConnectors.insert
	 #)
  #)

-- bifrostConnGetEnds: DoPart --
do connPrivate.node1.ID->node1; connPrivate.node2.ID->node2

-- bifrostConnSetEnds: DoPart --
do
   THIS(designConn)[]->connPrivate.node1.startConnectors.delete;
   THIS(designConn)[]->connPrivate.node2.endConnectors.delete;
   bifrostObjectList.rep[node1].IO[]->connPrivate.node1[];
   bifrostObjectList.rep[node2].IO[]->connPrivate.node2[];
   THIS(designConn)[]->connPrivate.node1.startConnectors.insert;
   THIS(designConn)[]->connPrivate.node2.endConnectors.insert;
   connPrivate.setup

-- bifrostConnPrivate: Descriptor --
(# (* attributes *)
   theLine: ^designConnLine;
   theFatLine: ^designConnFatLine;
   thePoints: ^pointArray;
   orient: @Integer;
   theArrow: ^bifrostConnArrow;
   node1,node2: ^designNode;
   node1ID,node2ID: @integer;
   fatLineDebugColor: ^solidColor;
   firstConnectPoint,lastConnectPoint: @point;
   (* methods *)
   movePoints:
     (# off: @point
     enter off
     do
	thePoints.scanPoints
	  (#  do ((current,off)->addPoints,inx)->thePoints.setPoint #);
	thePoints[]->setPoints;
	connect
     #);
   setPoints:
     (#
     enter thePoints[]
     do
	thePoints[]->theLine.points;
	thePoints[]->theFatLine.points;
	setConnectPoints
     #);
   setConnectPointsOrient:
     (#
     do
	(if thePoints.npoints > 2 then
	    (if orient
	     // 0 (* No arrows *) // 1 (* Arrow head at node 2 *)
	     // 3 (* Arrow head at both ends *) then
		thePoints.npoints-1->thePoints.getPoint->lastConnectPoint
	     // 2 (* Arrow head at node 1 *) then
		2->thePoints.getPoint->lastConnectPoint
	    if)
	 else
	    (if orient
	     // 0 (* No arrows *) // 1 (* Arrow head at node 2 *)
	     // 3 (* Arrow head at both ends *) then
		node1.getCenter->lastConnectPoint
	     // 2 (* Arrow head at node 1 *) then
		node2.getCenter->lastConnectPoint
	    if)
	if);
	(if orient
	 // 0 (* No arrows *) // 1 (* Arrow head at node 2 *)
	 // 3 (* Arrow head at both ends *) then
	    2->thePoints.getPoint->firstConnectPoint
	 // 2 (* Arrow head at node 1 *) then
	    thePoints.npoints-1->thePoints.getPoint->firstConnectPoint
	if)
     #);
   setConnectPoints:
     (#
     do
	(if thePoints.npoints > 2 then
	    2->thePoints.getPoint->lastConnectPoint
	 else
	    node2.getCenter->lastConnectPoint
	if);
	thePoints.npoints-1->thePoints.getPoint->firstConnectPoint
     #);
   bifrostConnArrow_USERDEF: graphicalObject
     (#
	drawme:
	  (#
	  do
	     (0,0)->theShape.open;
	     (- 10,- 5)->theShape.lineTo;
	     (- 10,5)->theShape.lineTo;
	     (1,capButt,joinMiter)->theShape.stroke;
	     theShape.close;
	     (- 10,0)->connectPoint
	  #);
	connectPoint: @point;
	position:
	  (# pt,pos: @point; a,cos_a,sin_a: @real; PTM: @Matrix
	  enter (pt,pos)
	  do
	     (pt.x,pt.y,pos.x,pos.y)->circleAngle->(a,cos_a,sin_a);
	     (cos_a,sin_a,- sin_a,cos_a,pos.x,pos.y)->PTM.set;
	     PTM[]->TM;
	     (- 10,0)->(TM).transformPoint->connectPoint;

	  #);

     #);
   bifrostConnArrow: multiLine
     (#
	drawme:
	  (#
	  do
	     (0,0)->theShape.addPoint;
	     (- 10,- 5)->theShape.addPoint;
	     (- 10,5)->theShape.addPoint;
	     (0,0)->theShape.addPoint;
	     0->theShape.width;
	     capButt->theShape.cap;
	     joinMiter->theShape.join;
	     (- 10,0)->connectPoint;

	  #);
	connectPoint: @point;
	position:
	  (# pt,pos: @point; a,cos_a,sin_a: @real; PTM: @Matrix
	  enter (pt,pos)
	  do
	     (pt.x,pt.y,pos.x,pos.y)->circleAngle->(a,cos_a,sin_a);
	     (cos_a,sin_a,- sin_a,cos_a,pos.x,pos.y)->PTM.set;
	     PTM[]->TM;
	     (- 10,0)->(TM).transformPoint->connectPoint;

	  #);

     #);
   determinant: (# a,b,c,d: @real enter (a,b,c,d) exit a*d-c*b #);
   intersect:
     (#
	x11,y11,x12,y12,x21,y21,x22,y22: @real;
	a1,b1,c1,a2,b2,c2,d1,d2,d3,d4: @real;
	res1,res2: @integer
     enter (((x11,y11),(x12,y12)),((x21,y21),(x22,y22)))
     do
	(- y11+y12)->a1;
	(x11-x12)->b1;
	- (x12*y11-y12*x11)->c1;
	(- y21+y22)->a2;
	(x21-x22)->b2;
	- (x22*y21-y22*x21)->c2;
	(c1,b1,c2,b2)->determinant->d1;
	(a1,c1,a2,c2)->determinant->d2;
	(a1,b1,a2,b2)->determinant->d3;
	(a1,b1,a2,b2)->determinant->d4;
	(if d3 <> 0 then
	    (d1 / d3)->res1
	 else
	    0 (*maxint: FP error on sgi*) ->res1
	if);
	(if d4 <> 0 then
	    (d2 / d4)->res2
	 else
	    0 (*maxint: FP error on sgi*) ->res2
	if)
     exit (res1,res2)
     #);
   connectPoint:
     (# b: @rectangle; p1,p2: @point; cp: @point; pl1,pl2,pl3,pl4: @point;
     enter (b,p1,p2)
     do
	(if (p1,p2)->equalPoint then p1->cp; leave connectPoint if);
	(if true
	 // (p2.y > b.y) then (* p2 above b *)
	    (b.x,b.y)->pl1; (b.x+b.width,b.y)->pl2;
	 // (p2.y < b.y-b.height) then (* p2 below b *)
	    (b.x,b.y-b.height)->pl1; (b.x+b.width,b.y-b.height)->pl2;
	 // (p2.x < b.x) then (* p2 left-of b *)
	    (b.x,b.y)->pl1; (b.x,b.y-b.height)->pl2;
	 // (p2.x > b.x+b.width) then (* p2 right-to b *)
	    (b.x+b.width,b.y)->pl1; (b.x+b.width,b.y-b.height)->pl2;
	 else
	(* p2 inside b *)
	    (if true
	     // (p2.y < b.y-(b.height div 2)) then (* p2 below b.center *)
		(b.x,b.y)->pl1; (b.x+b.width,b.y)->pl2;
	     // (p2.y > b.y-(b.height div 2)) then (* p2 above b.center *)
		(b.x,b.y-b.height)->pl1; (b.x+b.width,b.y-b.height)->pl2;
	     else
	    (* p2 at b.center *)
		(if p2.x <> b.x then
		    (b.x,b.y)->pl1; (b.x+b.width,b.y-b.height)->pl2;
		 else
		    (b.x+b.width,b.y)->pl1; (b.x+b.width,b.y-b.height)->pl2;
		if)
	    if);

	if);
	((pl1,pl2),(p1,p2))->intersect->cp;
	(if true
	 // cp.x < pl1.x // cp.x > pl2.x then
	    (if p1.x < p2.x then
		(b.x+b.width,b.y)->pl1; (b.x+b.width,b.y-b.height)->pl2;
	     else
		(b.x,b.y)->pl1; (b.x,b.y-b.height)->pl2;
	    if);
	    ((pl1,pl2),(p1,p2))->intersect->cp;

	if);

     exit cp
     #);
   connectOrient:
     (# b1,b2: @rectangle; p1,p2,pb,pe: @point
     do
	(if orient
	 // 0 (* No arrows *) // 1 (* Arrow head at node 2 *) then
	    node1.shape.getBounds->b2;
	    node2.shape.getBounds->b1;
	    node1.getCenter->p2;
	    node2.getCenter->p1;
	    (if orient // 0 then &paint[]->theArrow.setPaint if)
	 // 2 (* Arrow head at node 1 *) then
	    node1.shape.getBounds->b1;
	    node2.shape.getBounds->b2;
	    node1.getCenter->p1;
	    node2.getCenter->p2;

	 // 3 (* Arrow head at both ends *) then
	    node1.shape.getBounds->b2;
	    node2.shape.getBounds->b1;
	    node1.getCenter->p2;
	    node2.getCenter->p1;
	    (* FIXME *)
	    'Arrowheads at both ends not implemented yet!'->putLine
	if);
	INNER
     #);
   connect: connectOrient
     (# tp1,tp2: @point;
     do
	setConnectPoints;
	(if thePoints.npoints > 2 then
	    lastConnectPoint->tp2
	 else
	    (b2,p2,p1)->connectPoint->tp2;
	if);
	(b1,p1,tp2)->connectPoint->pb;
	(tp2,pb)->theArrow.position;
	(if thePoints.npoints > 2 then
	    firstConnectPoint->tp1; p2->tp2
	 else
	    p1->tp1
	if);
	(b2,tp2,tp1)->connectPoint->pe;
	(if orient
	 // 0 then pb->setbegin
	 else
	    theArrow.connectPoint->setbegin
	if);
	pe->setend
     #);
   setup: connectOrient
     (#
     do
	(b1,p1,p2)->connectPoint->pb;
	(b2,p2,p1)->connectPoint->pe;
	(pe,pb)->theArrow.position;
	&pointArray[]->thePoints[];
	theArrow.connectPoint->thePoints.addPoint;
	pe->thePoints.addPoint;
	thePoints[]->setPoints
     #);
   normalize: (* currently not used anywhere *)
   (* calculates the lower left, which is used for text-coordinates.
    * This is necessary for printing
    *)
     (# b1,b2: @rectangle; p1,p2: @point
     enter (b1,b2,p1,p2)
     do (b1.x,b2.x)->min->op.x; (b1.y,b2.y)->min->op.y;
     exit (b1,b2,p1,p2)
     #);
   op: @point;
   isEndPoint: booleanValue
     (# pt1,pt2: @point; whichEnd: @boolean
     enter pt1
     do
	1->thePoints.getPoint->pt2;
	(if (pt1.x = pt2.x) and (pt1.y = pt2.y) then
	    true->value; true->whichEnd
	if);
	thePoints.npoints->thePoints.getPoint->pt2;
	(if (pt1.x = pt2.x) and (pt1.y = pt2.y) then true->value if)
     exit whichEnd
     #);
   damaged:
     (#
     do
	theArrow.getBounds->damage;
	theLine.getBounds->damage;
	thefatLine.getBounds->damage
     #);
   moveStartConn:
     (# b1,b2: @rectangle; p1,p2: @point
     do
	setConnectPointsOrient;
	node1.nodePrivate.transformedNodeBounds->b1;
	node1.nodePrivate.transformedNodeCenter->p1;
	(if thePoints.npoints > 2 then
	    lastConnectPoint->p2
	 else
	    node2.nodePrivate.transformedNodeBounds->b2;
	    node2.nodePrivate.transformedNodeCenter->p2;
	    (b2,p2,p1)->connectPoint->p2
	if);
	(b1,p1,p2)->connectPoint->p1;
	p1->theScroller.contents.CanvasToDevice->p1;
	p2->theScroller.contents.CanvasToDevice->p2;
	(p1,p2)->theScroller.contents.immediateline
     #);
   moveEndConn:
     (# b1,b2: @rectangle; p1,p2: @point
     do
	setConnectPointsOrient;
	node2.nodePrivate.transformedNodeBounds->b2;
	node2.nodePrivate.transformedNodeCenter->p2;
	(if thePoints.npoints > 2 then
	    firstConnectPoint->p1
	 else
	    node1.nodePrivate.transformedNodeBounds->b1;
	    node1.nodePrivate.transformedNodeCenter->p1;
	    (b1,p1,p2)->connectPoint->p1
	if);
	(b2,p2,p1)->connectPoint->p2;
	p1->theScroller.contents.CanvasToDevice->p1;
	p2->theScroller.contents.CanvasToDevice->p2;
	(p1,p2)->theScroller.contents.immediateline
     #)
#)

-- designConnShapeDescGetBounds: DoPart --
do
   (bound,(connPrivate.theArrow.getShape).getBounds)->rectUnion->bound;
   (bound,(connPrivate.theLine.getShape).getBounds)->rectUnion->bound

-- bifrostConnNew: DoPart --
do
   (if UI.verbose then ID->putInt; ': designConn.new called!'->putLine if);
   (node1[],node2[])->(connPrivate.node1[],connPrivate.node2[]);
   &designConnLine[]->connPrivate.theLine[];
   connPrivate.theLine.init;
   color[]->connPrivate.theLine.setPaint;
   CapRounded->connPrivate.theLine.theShape.cap;
   1->connPrivate.theLine.width;
   capSquare->connPrivate.theLine.cap;
   WindingRule->connPrivate.theLine.theShape.fillRule;
   (* a fat line makes it easier to hit the connector *)
   &solidColor[]->connPrivate.fatLineDebugColor[];
   connPrivate.fatLineDebugColor.init;
   orchid->connPrivate.fatLineDebugColor.RGBValues;
   &designConnFatLine[]->connPrivate.theFatLine[];
   connPrivate.theFatLine.init;
   connPrivate.fatLineDebugColor[]->connPrivate.theFatLine.setPaint;
   7->connPrivate.theFatLine.width;
   capButt->connPrivate.theFatLine.cap;
   1 (* arrow at node 2 *) ->connPrivate.orient;
   &connPrivate.bifrostConnArrow[]->connPrivate.theArrow[];
   connPrivate.theArrow.init;
   connPrivate.theArrow.drawme;
   color[]->connPrivate.theArrow.setPaint;
   connPrivate.theFatLine[]->THIS(designConn).add;
   connPrivate.theLine[]->THIS(designConn).add;
   connPrivate.theArrow[]->THIS(designConn).add;
   connPrivate.setup;
   (* this seems to work better *)
   &paint[]->connPrivate.theFatLine.setPaint

-- bifrostConnInit: DoPart --
do (* FIXME - empty doPart *)

-- bifrostConnDump: DoPart --
do
   'This is a connector'->putLine;
   getBounds->bounds;
   'Bounds: '->putText;
   bounds.x->putInt;
   'x'->putText;
   bounds.y->putInt;
   ' width: '->putText;
   bounds.width->putInt;
   ',height: '->putText;
   bounds.height->putInt;
   newline;
   'Points: '->putText;
   connPrivate.thePoints.scanPoints
     (#  do current->putPoint #);
   newline

-- bifrostConnHideBorder: DoPart --
do
   &paint[]->connPrivate.theLine.setPaint;
   &paint[]->connPrivate.theArrow.setPaint

-- bifrostConnShowBorder: DoPart --
do
   color[]->connPrivate.theLine.setPaint;
   (if connPrivate.orient <> 0 then color[]->connPrivate.theArrow.setPaint if)

-- bifrostNodeHideBorder: DoPart --
do
   &paint[]->shape.setPaint;
   (if filledShape[] <> none then &paint[]->filledShape.setPaint if);
   &shape.theShape.hiliteDesc[]->shape.theShape.ho[];
   INNER

-- bifrostNodeShowBorder: DoPart --
do
   shapeColor[]->shape.setPaint;
   (if filledShape[] <> none then
       filledShapeColor[]->filledShape.setPaint
   if);
   &shape.theShape.hiliteOutline[]->shape.theShape.ho[];
   (* don't make the filledShape outline visible, as this might
    * interfere with the shapes outline
    *)
   INNER

-- bifrostLabelShowBorder: DoPart --
do &paint[]->shape.setPaint

-- bifrostNodeGetcenter: DoPart --
do shape.getbounds->r; INNER

-- bifrostNodeSetCenter: DoPart --
do (*'nodesetcenter'->putline;*)
   c->nodeCenter;
   startConnectors.scan
     (#
     do
	current.connPrivate.damaged;
	current.connPrivate.connect;
	current.connPrivate.damaged
     #);
   endConnectors.scan
     (#
     do
	current.connPrivate.damaged;
	current.connPrivate.connect;
	current.connPrivate.damaged
     #);
   shape.getbounds->r;
   INNER

-- bifrostNodeNew: DoPart --
do
   (if UI.verbose then
       ID->putInt; ': designNode.new: \''->putText; t[]->putText; '\' '->putText
   if);
   true->moveable->sizeable;
   startConnectors.init;
   endConnectors.init;
   nodePrivate.regionConnectors.init;
   color.copy->shapeColor[];
   &paint[]->filledShapeColor[];
   (* This is located here, because designLabel, needs to
    * copy theText in INNER.
    *)
   &designObjectText[]->theText[];
   INNER ;
   (* create Text *)
   theText.init;
   color[]->theText.setPaint;
   (textCoordinates,Helvetica,Plain,12,false,t[])->theText.initText;
   theText[]->THIS(designObject).add;
   &<<SLOT hideTextOutline:Descriptor>>;
   (if filledShape[] <> none then
   (* The filledShape is most likely to interfere with the shape.
    * So lets not draw the outline.
    *)
       &filledShape.theShape.hiliteDesc[]->filledShape.theShape.ho[]
   if);
   (if UI.verbose then newline if);


-- bifrostNodeMoveConnectors: DoPart --
do
     (# hitNode: ^designNode; theCanvas: ^bifrostCanvas; oc,nc: @Point
     do
	(if UI.extremelyVerbose then
	    'moveconnectors %d\n'->putFormat (#  do id->d #)
	if);
	theScroller.contents[]->theCanvas[];
	getCenter->nodeCenter;
	nodePrivate.regionConnectors.scan
	  (#
	  do
	     (if not parent.nodePrivate.alreadyMoved[current.ID] then
		 true->parent.nodePrivate.alreadyMoved[current.ID];
		 (if UI.extremelyVerbose then
		     'region moving %d\n'->putFormat (#  do current.id->d #)
		 if);
		 current.connPrivate.damaged;
		 (* get old mass center *)
		 current.connPrivate.theLine.TM
		   ->current.connPrivate.theLine.theShape.computeCenter->oc;
		 (* move the connector *)
		 offset->current.connPrivate.movePoints;
		 (* get new mass center *)
		 current.connPrivate.theLine.TM
		   ->current.connPrivate.theLine.theShape.computeCenter->nc;
		 (oc,nc)->current.moveRegions;
		 current.connPrivate.damaged
	      else
		 (if UI.extremelyVerbose then
		     'region not moving %d\n'
		       ->putFormat (#  do current.id->d #)
		 if)
	     if)
	  #);
	startConnectors.scan
	  (#
	  do
	     (if not parent.nodePrivate.alreadyMoved[current.ID] then
		 (if UI.extremelyVerbose then
		     'start moving %d\n'->putFormat (#  do current.id->d #)
		 if);
		 current.connPrivate.damaged;
		 (* get old mass center *)
		 current.connPrivate.theLine.TM
		   ->current.connPrivate.theLine.theShape.computeCenter->oc;
		 current.connPrivate.connect;
		 (* get new mass center *)
		 current.connPrivate.theLine.TM
		   ->current.connPrivate.theLine.theShape.computeCenter->nc;
		 (oc,nc)->current.moveRegions;
		 current.connPrivate.damaged
	      else
		 (if UI.extremelyVerbose then
		     'start not moving %d\n'
		       ->putFormat (#  do current.id->d #)
		 if)
	     if)
	  #);
	endConnectors.scan
	  (#
	  do
	     (if not parent.nodePrivate.alreadyMoved[current.ID] then
		 (if UI.extremelyVerbose then
		     'end moving %d\n'->putFormat (#  do current.id->d #)
		 if);
		 current.connPrivate.damaged;
		 (* get old mass center *)
		 current.connPrivate.theLine.TM
		   ->current.connPrivate.theLine.theShape.computeCenter->oc;
		 current.connPrivate.connect;
		 (* get new mass center *)
		 current.connPrivate.theLine.TM
		   ->current.connPrivate.theLine.theShape.computeCenter->nc;
		 (oc,nc)->current.moveRegions;
		 current.connPrivate.damaged
	      else
		 (if UI.extremelyVerbose then
		     'end not moving %d\n'
		       ->putFormat (#  do current.id->d #)
		 if)
	     if)
	  #);
	ScanGOsReverse
	  (#
	  do
	     (if go## <= designNode## then
		 go[]->hitNode[]; (parent[],offset)->hitNode.moveConnectors
	     if)
	  #)
     #)

-- bifrostNodePrivate: Descriptor --
(#
(* FIXME: maybe connset should be implemented using a repetion to
 * speed up things?
 *)
   startConnectorsToMove,endConnectorsToMove: ^connset;
   regionConnectors: @connSet;
   alreadyMoved: [0] @boolean;
   interactiveMove: @boolean;
   isMoved: (* if this object is being moved *) @boolean;
   getSubConnectors:
     (# startConns,endConns: ^connset; hitNode: ^designNode
     enter (startConns[],endConns[])
     do
	startConnectors.scan
	  (#  do current[]->startConns.insert #);
	endConnectors.scan
	  (#  do current[]->endConns.insert #);
	ScanGOsReverse
	  (#
	  do
	     (if go## <= designNode## then
		 go[]->hitNode[];
		 (startConns[],endConns[])->hitNode.nodePrivate.getSubConnectors
	     if)
	  #)
     #);
   transform:
     (# nc: @point
     enter nc
     do (if isMoved then nc->pagePrivate.interactionTM.transformpoint->nc if)
     exit nc
     #);
   transformRect:
     (# r: @rectangle;
     enter r
     do
	(if isMoved then
	    (r.x,r.y)->pagePrivate.interactionTM.transformpoint->(r.x,r.y)
	if)
     exit r
     #);
   transformedNodeBounds: (#  exit shape.getBounds->transformRect #);
   transformedNodeCenter: (#  exit nodecenter->transform #)
#)

-- bifrostNodeMove: DoPart --
do
     (# pt: @point;
     do
	(if nodePrivate.interactiveMove then
	    false->nodePrivate.interactiveMove; offset->pt
	 else
	    (0,0)->pt
	if);
	UI.bifrostObjectList.newID.value->nodePrivate.alreadyMoved.new;
	(THIS(designNode)[],pt)->moveConnectors;
	false->isDragged;
	0
	  -> (* release the memory used by alreadyMoved*)
	    nodePrivate.alreadyMoved.new
     #)

-- groupPictureMove: DoPart --
do
   ScanGOsReverse
     (# hitObject: ^designNode
     do
	(if go## <= designNode## then
	    go[]->hitObject[];
	    UI.bifrostObjectList.newID.value
	      ->hitObject.nodePrivate.alreadyMoved.new;
	    (hitObject[],offset)->hitObject.moveConnectors;
	    false->hitObject.isDragged
	if)
     #)

-- groupPictureInteractivemove: DoPart --
do
   &
     (#
	ccs1,ccs: (* common connectors *) [bifrostObjectList.newID.value]
	@Boolean;
	scs,ecs: (* start,end connectors *) ^connSet
     do
	&connSet[]->scs[];
	scs.init;
	&connSet[]->ecs[];
	ecs.init;
	(* First determine which connectors are common, ie. has both
	 * ends in a node (or region) in the group selection.  ccs1 is
	 * used to mark the first end we meet.
	 *)
	ScanGOsReverse
	  (# dn: ^designNode
	  do
	     (if go## <= designNode## then
		 go[]->dn[];
		 scs.clear;
		 ecs.clear;
		 (scs[],ecs[])->dn.nodePrivate.getSubConnectors;
		 scs.scan
		   (#
		   do
		      (if ccs1[current.ID] then
			  true->ccs[current.ID]
		       else
			  true->ccs1[current.ID]
		      if)
		   #);
		 ecs.scan
		   (#
		   do
		      (if ccs1[current.ID] then
			  true->ccs[current.ID]
		       else
			  true->ccs1[current.ID]
		      if)
		   #)
	     if)
	  #);
	(* ccs[i] <=> connector i has both ends in the group selection *)
	(* setup startConnectorsToMove and endConnectorsToMove for all
	 * nodes (and regions) in the group selection.  If ccs[i] is
	 * true then should be put in regionConnectors of the first
	 * node, which knows about it.  Use ccs1 to make sure that a
	 * given connector is added to exactly one regionConnectors.
	 *)
	bifrostObjectList.newID.value->ccs1.new;
	ScanGOsReverse
	  (# hitObject: ^designNode
	  do
	     (if go## <= designNode## then
		 go[]->hitObject[];
		 true->hitObject.isDragged;
		 &connset[]->hitObject.nodePrivate.startConnectorsToMove[];
		 &connset[]->hitObject.nodePrivate.endConnectorsToMove[];
		 hitObject.nodePrivate.startConnectorsToMove.init;
		 hitObject.nodePrivate.endConnectorsToMove.init;
		 (hitObject.nodePrivate.startConnectorsToMove[],
		  hitObject.nodePrivate.endConnectorsToMove[])
		   ->hitObject.nodePrivate.getSubConnectors;
		 hitObject.nodePrivate.startConnectorsToMove.scan
		   (#
		   do
		      (if ccs[current.ID] then
			  current[]
			    ->
			      hitObject.nodePrivate.startConnectorsToMove.
				delete;
			  (if not ccs1[current.ID] then
			      true->ccs1[current.ID];
			      current[]
				->hitObject.nodePrivate.regionConnectors.insert
			  if)
		      if)
		   #);
		 hitObject.nodePrivate.endConnectorsToMove.scan
		   (#
		   do
		      (if ccs[current.ID] then
			  current[]
			    ->hitObject.nodePrivate.endConnectorsToMove.delete;
			  (if not ccs1[current.ID] then
			      true->ccs1[current.ID];
			      current[]
				->hitObject.nodePrivate.regionConnectors.insert
			  if)
		      if)
		   #)
	     if)
	  #)
     #)

-- bifrostNodeInteractivemove: DoPart --
do
   true->isDragged;
   true->nodePrivate.interactiveMove;
   (* The following creates a list of all the connectors connected to
    * this node. This is used by hiliteOutline.
    *)
   &connset[]->nodePrivate.startConnectorsToMove[];
   &connset[]->nodePrivate.endConnectorsToMove[];
   nodePrivate.startConnectorsToMove.init;
   nodePrivate.endConnectorsToMove.init;
   (nodePrivate.startConnectorsToMove[],nodePrivate.endConnectorsToMove[])
     ->nodePrivate.getSubConnectors;
     (# bothConn: [0] @boolean
     do
	UI.bifrostObjectList.newID.value->bothConn.new;
	nodePrivate.regionConnectors.clear;
	nodePrivate.startConnectorsToMove.scan
	  (#  do true->bothConn[current.ID] #);
	nodePrivate.endConnectorsToMove.scan
	  (#
	  do
	     (if bothConn[current.ID] then
		 (if UI.veryVerbose then
		     'inserting %d in regionconnectors\n'
		       ->putFormat (#  do current.ID->d #)
		 if);
		 current[]->nodePrivate.regionConnectors.insert;

	     if)
	  #);
	nodePrivate.regionConnectors.scan
	  (#
	  do
	     current[]->nodePrivate.startConnectorsToMove.delete;
	     current[]->nodePrivate.endConnectorsToMove.delete;

	  #)
     #)

-- bifrostNodeHiliteOutLine: DoPart --
do
   (if TM[] <> none then TM[]->pagePrivate.interactionTM[] if);
   (if not nodePrivate.isMoved then
       true->nodePrivate.isMoved;
       THIS(designNode)[]->pagePrivate.interactionNodes.insert
   if);
   (if isDragged then
       nodePrivate.startConnectorsToMove.scan
	 (#  do current.connPrivate.moveStartConn #);
       nodePrivate.endConnectorsToMove.scan
	 (#  do current.connPrivate.moveEndConn #);
       nodePrivate.regionConnectors.scan
	 (#
	 do
	    (theCanvas[],draw,TM[])
	      ->current.connPrivate.theLine.theShape.hiliteOutLine
	 #)
   if)

-- bifrostNodeDump: DoPart --
do INNER ; 'Text: \''->putText; theText.theText->putText; '\''->putLine

-- bifrostRectTextCoordinates: DoPart --
do (sx+(h div 3),- (h div 3))->p

-- bifrostRectNew: DoPart --
do
   (if UI.verbose then 'rect shape'->putText if);
   0-(w div 2)->sx;
   (h div 2)->sy;
   (* creates aRect *)
   &designRectShape[]->aRect[];
   &designRectFilledShape[]->fs[];
   aRect.init;
   fs.init;
   shapeColor[]->aRect.setPaint;
   filledShapeColor[]->fs.setPaint;
   true->aRect.theShape.stroked;
   (sx,sy)->aRect.upperLeft;
   (sx,sy)->fs.upperleft;
   w->aRect.theShape.width;
   w->fs.theShape.width;
   h->aRect.theShape.height;
   h->fs.theShape.height;
   fs[]->THIS(designRect).filledShape[]->THIS(designRect).add;
   aRect[]->THIS(designRect).shape[]->THIS(designRect).add;
   INNER

-- bifrostRectDump: DoPart --
do
   'This is a designRect\nUpperLeft: '->putText;
   shape[]->aRect[];
   aRect.upperLeft->p;
   p.x->putInt;
   'x'->putText;
   p.y->putInt;
   ' width: '->putText;
   aRect.width->putInt;
   ',height: '->putText;
   aRect.height->putInt;
   newline;
   getBounds->bounds;
   'Bounds: '->putText;
   bounds.x->putInt;
   'x'->putText;
   bounds.y->putInt;
   ' width: '->putText;
   bounds.width->putInt;
   ',height: '->putText;
   bounds.height->putInt;
   newline

-- bifrostPolySetCenter: DoPart --
do

-- bifrostPolyNew: DoPart --
do
   (if UI.verbose then 'poly shape'->putText if);
     (# fs: ^graphicalObject; sh: ^multiLine
     do
	&designPolyFilledShape[]->fs[];
	&designPolyShape[]->sh[];
	fs.init;
	sh.init;
	shapeColor[]->sh.setPaint;
	filledShapeColor[]->fs.setPaint;
	(pl[1],- pl[2])->fs.theShape.open;
	sh.theShape.open;
	(pl[1],- pl[2])->sh.theShape.addPoint;
	(if UI.verbose then
	    ' %dx%d'->putFormat (#  do pl[1]->d; pl[2]->d #)
	if);
	(for inx: (pl.range div 2)-1 repeat
	  (pl[inx*2+1],- pl[inx*2+2])->fs.theShape.lineTo;
	  (pl[inx*2+1],- pl[inx*2+2])->sh.theShape.addPoint;
	  (if UI.verbose then
	      ' %dx%d'->putFormat (#  do pl[inx*2+1]->d; pl[inx*2+2]->d #)
	  if)
	for);
	(pl[1],- pl[2])->sh.theShape.addPoint;
	fs.theShape.close;
	0->sh.width;
	capButt->sh.cap;
	joinMiter->sh.join;
	sh[]->shape[]->add;
	fs[]->filledShape[]->add
     #)

-- bifrostPolyDump: DoPart --
do
   shape.getBounds->bnd;
   'This is a designPoly. Bounds: %dx%d width: %d, height: %d\n'
     ->putFormat (#  do bnd.x->d; bnd.y->d; bnd.width->d; bnd.height->d #)

-- bifrostLabelNew: DoPart --
do hideborder

-- bifrostPageOnMouseDown: Descriptor --
(#
   hitNode: ^designNode;
   hitConn: ^designConn;
   hitObject: ^designObject;
   cp: ^point;
   (* control point *)
   exactPos: ^point;
   moved: @boolean;
   dontRepairGroup: @boolean;
   doMove:
     (#
     do
	true->moved;
	(if true
	 // (not designGroup.isEmpty) then
	    designGroup.private.implList.scan
	      (# cnt: @point
	      do
		 current.getCenter->cnt;
		 (if current.load_prevPicture[] <> none then
		     current[]->current.load_prevPicture.delete
		 if);
		 current[]->theMainPicture.group.add;
		 cnt->current.setCenter
	      #);
	    IDMatrix->pagePrivate.interactionTM[];
	    pagePrivate.interactionNodes.init;
	    (theMainPicture.group[],mousepos,noModifier)->interactivemove;
	    IDMatrix->pagePrivate.interactionTM[];
	    (for i: pagePrivate.interactionNodes.size repeat
	      false->pagePrivate.interactionNodes.list[i].nodePrivate.isMoved
	    for);
	    pagePrivate.interactionNodes.release;
	    designGroup.private.implList.scan
	      (# cnt: @point
	      do
		 current.getCenter->cnt;
		 current[]->theMainPicture.group.delete;
		 (if current.load_prevPicture[] <> none then
		     current[]->current.load_prevPicture.add
		 if);
		 cnt->current.setCenter
	      #);
	    (* toby says that onDrag should be called on all nodes in
	     * group selection
	     *)
	    designGroup.private.implList.scan
	      (#  do current.onDrag #)
	 // hitObject## <= designNode## then
	    hitObject[]->hitNode[];
	    (if hitNode.moveable then
		IDMatrix->pagePrivate.interactionTM[];
		pagePrivate.interactionNodes.init;
		(hitNode[],mousepos,noModifier)->interactivemove;
		IDMatrix->pagePrivate.interactionTM[];
		(for i: pagePrivate.interactionNodes.size repeat
		  false
		    ->pagePrivate.interactionNodes.list[i].nodePrivate.isMoved
		for);
		pagePrivate.interactionNodes.release;
		hitNode.onDrag
	    if)
	 // hitObject## <= designConn## then
	    'Should not happen: doMove hitObject## <= designConn##'->putLine
	 else
	    'dont know how to move this kind of object'->putLine
	if)
     #);
   buttonOne:
     (#
     do
	(if hitObject.selectable then
	    (if true
	     // (shiftModified and (not (hitObject## <= designConn##))) then
		(if UI.verbose then 'toggle group selection'->putLine if);
		hitObject[]->designGroup.toggle;
		true->dontRepairGroup
	     // doubleClick then
		(if UI.verbose then
		    '%d: doubleClick\n'->putFormat (#  do hitObject.ID->d #)
		if);
		designGroup.clear;
		hitObject.onDoubleClick
	     else
		hitObject[]->THIS(bifrostPage).designSelection;
		hitObject[]->designGroup.click
	    if)
	if)
     #);
   interactiveMoveConn:
     (#
	whichEnd: (* node1 is true *) @boolean;
	isEnd: @boolean;
	npl: (* new point list *) ^pointArray;
	newPos: @point;
	tc,oc,nc: @Point;
	(* Text, Old, New Center *)
	newAttach: ^designObject
     do
	hitObject[]->hitConn[];
	(if THIS(bifrostPage).designSelection <> none then
	    (THIS(bifrostPage).designSelection).unhilite
	if);
	hitConn.connPrivate.damaged;
	hitConn.connPrivate.theLine.TM
	  ->hitConn.connPrivate.theLine.theShape.computeCenter->oc;
	(if true
	 // (exactpos[] <> none ) and doubleclick then
	 (* doubleclicked on a control point - delete it *)
	    (if (hitConn.connPrivate.theLine.points).npoints > 2 then
	    (* if we end up with less than 2 points we're in trouble *)
		exactPos->hitConn.connPrivate.theLine.deletePoint;
		hitConn.connPrivate.theLine.points
		  ->hitConn.connPrivate.setPoints;
		hitConn.connPrivate.connect
	    if)
	 // doubleclick then
	 (* doubleclicked (not on controlpoint) - insert a new point *)
	    (mousePos,mousePos->hitConn.connPrivate.theLine.closestLineSegment)
	      ->hitConn.connPrivate.thePoints.insertPoint;
	    hitConn.connPrivate.thePoints[]->hitConn.connPrivate.setPoints
	 // (exactpos[] <> none ) then
	 (* clicked on a control point - move it *)
	    exactPos->hitConn.connPrivate.isEndPoint->(isEnd,whichEnd);
	    (hitConn.connPrivate.theLine[],exactPos,noModifier)
	      ->interactiveReshape;
	    (if isEnd then (* move end point to another node *)
		(if UI.verbose then 'Hit end point'->putLine if);
		hitConn.connPrivate.theLine.points->npl[];
		(if whichEnd then
		    1->npl.getPoint->newPos
		 else
		    npl.npoints->npl.getPoint->newPos
		if);
		(newpos,hitConn[])->findHitObject->newAttach[];
		(if newAttach[] <> none then
		    (if UI.verbose then newAttach.dump if);
		    (if newAttach## <= designConn## then
			(if UI.verbose then
			    'Oh silly. you can\'t expect that to work'->putLine
			if)
		     else
			hitConn.getMyObject
			  (#
			     dc: ^thePage.connector;
			     ok: @boolean;
			     theNew: ^object
			  do
			     theObject[]->dc[];
			     newAttach.ID->theDocument.theObjectList.Find
			       ->theNew[];
			     (theNew[],whichEnd)->dc.onReattach->ok;
			     (if ok and UI.verbose then 'OK'->putLine if)
			  #)
		    if)
		if)
	    if);
	    hitConn.connPrivate.theLine.points->hitConn.connPrivate.setPoints;
	    hitConn.connPrivate.connect
	if);
	hitConn.connPrivate.theLine.TM
	  ->hitConn.connPrivate.theLine.theShape.computeCenter->nc;
	(oc,nc)->hitConn.moveRegions;
	hitConn.connPrivate.damaged;
	hitObject[]->THIS(bifrostPage).designSelection;
	hitObject.hilite
     #);
   normalIA:
     (#
	x,y: @integer;
	leftBtn,middleBtn,rightBtn: @boolean;
	dp: ^theDocument.page
     do
	none ->exactpos[];
	(if designSelection <> none then
	    designSelection->hitObject[];
	    (if true
	     // hitObject## <= designNode## then
		hitObject[]->hitNode[];
		(hitNode.shape[],mousePos)->HitControl->exactpos[]
	     // hitObject## <= designConn## then
		hitObject[]->hitConn[];
		(hitConn.connPrivate.theLine[],mousePos)->HitControl->exactpos[]
	    if)
	if);
	(if exactpos[] = none then
	    (if UI.extremelyVerbose then
		'NormalIA: Mousepos %dx%d\n'
		  ->putformat (#  do mousepos.x->d; mousepos.y->d #)
	    if);
	    (mousepos,none )->findHitObject->hitObject[]
	 else
	    (if UI.extremelyVerbose then 'got exact pos'->putLine if)
	if);
	(if hitObject[] <> none then
	    (if buttonState
	     // 1 then
		(if designSelection <> none then
		    (designSelection).unhilite;
		    (THIS(bifrostPage).designSelection).hiliteReset
		if);
		(if hitObject## <= designConn## then
		    interactiveMoveConn
		 else
		    false->moved;
		    (if exactpos[] <> none then
		    (* we are CERTAIN that hitNode[] <> NONE *)
			designGroup.clear;
			(if hitNode.sizeable then
			    (hitNode.shape[],exactPos,shiftModifier)
			      ->theScroller.contents.interactiveReshape;
			    hitNode.onSize
			if);
			hitNode[]->THIS(bifrostPage).designSelection
		     else
			buttonOne;
			interactionhandler
			  (#
			     terminateInteraction: @boolean;
			     idle::
			       (#
			       do (if theGUI.mouse.buttonState = 0 then
				      true -> terminateInteraction
                                  if)
                               #);
			     motion::
			       (#
			       do true -> terminateInteraction;
				  doMove
                               #);
			     buttonRelease:: (# do true->terminateInteraction #);
			     terminateCondition::
			       (# do terminateInteraction -> value #);
			     keyRelease::
			       (#
			       do (if ch = ascii.esc then
				      true -> terminateInteraction
                                  if)
                               #)
                          #)
		    if)
		if);
		(if designSelection <> none then
		    (designSelection).hiliteReset; (designSelection).hilite
		if)
	     // 2 then
		(if UI.verbose then hitObject.dump if)
	     // 3 (* right click *) then
		localPosition->hitObject.onRightMouseDown
	    if)
	 else
	    designGroup.clear;
	    (if UI.verbose then mousepos->putPoint; newline if)
	if);
	localPosition->(x,y);
	(if buttonState
	 // 1 then
	    true->leftBtn
	 // 2 then
	    true->middleBtn
	 // 3 then
	    true->rightBtn
	if);
	THIS(bifrostPage).theMainPicture.ID->theDocument.theObjectList.Find
	  ->dp[];
	(x,y,leftBtn,middleBtn,rightBtn,shiftModified,controlModified,
	 metaModified, (* shiftLockKey? *) false)->dp.onMouseDown
     #);
   connIA:
     (#
	ml: ^multiline;
	dp: ^theDocument.page;
	dc: ^dp.designConnector;
	pa: ^pointArray;
	n1,n2: ^designNode;
	ho: ^designObject;
	pts: [0] @integer;
	bnd: @rectangle;
	initialiser: @object
	  (#
	  do
	     pts->dc.points;
	     true->dc.selectable;
	     true->dc.borderVisible;
	     dc[]->dp.CurrentObject
	  #)
     do
	(mousepos,none )->findHitObject->ho[];
	(if ho[] // none then leave connIA if);
	(if ho## <= designNode## then
	    ho[]->n1[]; (if ho## <= designLabel## then leave connIA if)
	 else
	    leave connIA
	if);
	(* 'Left click to insert point.  Right click on a node to finish. Hold shift down to get rigth angles' -> infoBar.label; *)
	&multiline[]->ml[];
	ml.init;
	(ml[],mousepos,shiftModifier)
	  ->theScroller.contents.interactiveCreateShape;
	ml.getBounds->damage;
	ml.points->pa[];
	(if pa.npoints < 2 then leave connIA if);
	(pa.npoints->pa.getPoint,none )->findHitObject->ho[];
	(if ho[] // none then leave connIA if);
	(if ho## <= designNode## then
	    ho[]->n2[]; (if ho## <= designLabel## then leave connIA if)
	 else
	    leave connIA
	if);
	(if ho[]
	 // n1[] then
	    (if pa.npoints
	     // 2 then
		n1.shape.getBounds->bnd;
		2->pa.deletePoint;
		1->pa.deletePoint;
		(bnd.x+(bnd.width div 2),bnd.y-(bnd.height div 2))->pa.addPoint;
		(bnd.x+bnd.width+30,bnd.y-(bnd.height div 2))->pa.addPoint;
		(bnd.x+bnd.width+30,bnd.y+30)->pa.addPoint;
		(bnd.x+(bnd.width div 2),bnd.y+30)->pa.addPoint;
		1->pa.getPoint->pa.addPoint
	    if)
	if);
	pa.npoints*2->pts.new;
	pa.scanPoints
	  (#  do current->bifrost2design->(pts[inx*2-1],pts[inx*2]) #);
	THIS(bifrostPage).theMainPicture.ID->theDocument.theObjectList.Find
	  ->dp[];
	(if UI.interactiveNewConn then
	    UI.interactiveNewObject[]->dc[]; false->UI.interactiveNewConn
	 else
	    &dp.designConnector[]->dc[]
	if);
	initialiser[]->dc.visualAttributes.initInteractive[];
	(if designSelection <> none then (designSelection).unhilite if);
	(n1.ID->theDocument.theObjectList.Find,
	 n2.ID->theDocument.theObjectList.Find)->dc.new;
	none ->dc.visualAttributes.initInteractive[]
     #);
   EllipseIA:
     (#
	el: ^ellipse;
	dp: ^theDocument.page;
	de: ^dp.designEllipse;
	cnt,dim: @point
     do
	&ellipse[]->el[];
	el.init;
	(* 'Left click to finish. Hold shift down for circle.' -> infoBar.label; *)
	(el[],mousepos,shiftModifier)
	  ->theScroller.contents.interactiveCreateShape;
	el.center->bifrost2design->cnt;
	el.horizontalRadius*2->dim.x;
	el.verticalRadius*2->dim.y;
	THIS(bifrostPage).theMainPicture.ID->theDocument.theObjectList.Find
	  ->dp[];
	&dp.designEllipse[]->de[];
	(cnt.x,cnt.y,dim.x,dim.y)->de.new;
	true->de.selectable;
	true->de.borderVisible;
	true->de.moveable;
	true->de.sizeable;
	de[]->dp.CurrentObject
     #);
   RndRectIA: (#  do rectIA #);
   WedgeIA:
     (#  do 'interactive new Wedge not implemented yet!'->putLine #);
   polyIA:
     (#
	ml: ^multiline;
	dp: ^theDocument.page;
	dpoly: ^dp.designPolygon;
	pa: ^pointArray;
	pts: [0] @integer;
	bnd: @rectangle
     do
	&multiline[]->ml[];
	ml.init;
	(* 'Left click to insert point.  Right click to finish. Hold shift down to get rigth angles' -> infoBar.label; *)
	(ml[],mousepos,shiftModifier)
	  ->theScroller.contents.interactiveCreateShape;
	ml.getBounds->damage;
	ml.getBounds->bnd;
	bnd.x+bnd.width div 2->bnd.x;
	bnd.y-bnd.height div 2->bnd.y;
	(bnd.x,bnd.y)->bifrost2design->(bnd.x,bnd.y);
	ml.points->pa[];
	(if pa.npoints < 2 then leave polyIA if);
	pa.npoints*2->pts.new;
	pa.scanPoints
	  (#  do current->bifrost2design->(pts[inx*2-1],pts[inx*2]) #);
	THIS(bifrostPage).theMainPicture.ID->theDocument.theObjectList.Find
	  ->dp[];
	&dp.designPolygon[]->dpoly[];
	(bnd.x,bnd.y,0,0,pts)->dpoly.new;
	true->dpoly.selectable;
	true->dpoly.borderVisible;
	true->dpoly.moveable;
	false->dpoly.sizeable;
	dpoly[]->dp.CurrentObject
     #);
   LineIA: (#  do 'interactive new Line not implemented yet!'->putLine #);
   LabelIA:
     (#
	txt: ^graphicText;
	dp: ^theDocument.page;
	dl: ^dp.designLabel;
	bnd: @rectangle;
	t: ^text
     do
	&graphicText[]->txt[];
	txt.init;
	(* 'Type in text.  Press enter when done.' -> infoBar.label; *)
	(txt[],mousepos,noModifier)
	  ->theScroller.contents.interactiveCreateShape;
	txt.getBounds->bnd;
	bnd.x+bnd.width div 2->bnd.x;
	bnd.y-bnd.height div 2->bnd.y;
	(bnd.x,bnd.y)->bifrost2design->(bnd.x,bnd.y);
	txt.theText->t[];
	THIS(bifrostPage).theMainPicture.ID->theDocument.theObjectList.Find
	  ->dp[];
	&dp.designLabel[]->dl[];
	(bnd.x,bnd.y,bnd.width,bnd.height,t)->dl.new;
	true->dl.selectable;
	false->dl.borderVisible;
	dl[]->dp.CurrentObject
     #);
   PictureIA:
     (#  do 'interactive new Picture not implemented yet!'->putLine #);
   rectIA:
     (#
	rct: ^rect;
	bnd: @rectangle;
	dp: ^theDocument.page;
	dr: ^dp.designRect
     do
	&rect[]->rct[];
	rct.init;
	(* 'Left click to finish.  Hold shift down for square.' -> infoBar.label; *)
	(rct[],mousepos,shiftModifier)
	  ->theScroller.contents.interactiveCreateShape;
	rct.getBounds->bnd;
	bnd.x+bnd.width div 2->bnd.x;
	bnd.y-bnd.height div 2->bnd.y;
	(bnd.x,bnd.y)->bifrost2design->(bnd.x,bnd.y);
	THIS(bifrostPage).theMainPicture.ID->theDocument.theObjectList.Find
	  ->dp[];
	&dp.designRect[]->dr[];
	bnd->dr.new;
	true->dr.selectable;
	true->dr.borderVisible;
	true->dr.moveable;
	true->dr.sizeable;
	dr[]->dp.CurrentObject
     #);
   findHitObject:
     (# hitObject: ^designObject; mousepos: @point; butNotThis: ^Object
     enter (mousepos,butNotThis[])
     do
	scan: theMainPicture.ScanGOsReverse
	  (#
	  do
	     (if go## <= designObject## then
		 go[]->hitObject[];
		 (if UI.extremelyVerbose then
		     'top level:'->putLine; hitObject.dump
		 if);
		 (if (THIS(BifrostCanvas)[],mousepos)->hitObject.containsPoint
		  then
		     (if UI.extremelyVerbose then
			 '\ncontains point!!!'->putLine
		     if);
		     (if go[] <> butNotThis[] then
			 (THIS(BifrostCanvas)[],mousepos)
			   ->hitObject.findSmallestHit->hitObject[];
			 (if hitObject[] <> none then
			     leave scan
			  else
			     (if UI.extremelyVerbose then
				 go[]->hitObject[];
				 hitObject.dump;
				 'no regions'->putLine
			     if)
			 if)
		     if)
		  else
		     (if UI.extremelyVerbose then
			 '\nDo not contains point!!!'->putLine
		     if);

		 if);
		 none ->hitObject[]
	     if)
	  #)
     exit hitObject[]
     #)
do
   (if UI.verbose then
       (if controlModified then 'controlModified '->putText if);
       (if metaModified then 'metaModified '->putText if);
       (if shiftModified then 'shiftModified '->putText if);
       (if controlModified or metaModified or shiftModified then newline if)
   if);
   mousepos->devicetocanvas->mousepos;
   false->dontRepairGroup;
   (if not SifIsInEditMode then
       (if interactiveState
	// iaDisabled then (* do nothing *)

	// iaNormal then
	   normalIA; updateInfoBar
	// iaConn then
	   connIA; iaNormal->interactiveState; updateInfoBar
	// iaRect then
	   rectIA; iaNormal->interactiveState; updateInfoBar
	// iaEllipse then
	   ellipseIA; iaNormal->interactiveState; updateInfoBar
	// iaRndRect then
	   rndRectIA; iaNormal->interactiveState; updateInfoBar
	// iaWedge then
	   wedgeIA; iaNormal->interactiveState; updateInfoBar
	// iaPoly then
	   polyIA; iaNormal->interactiveState; updateInfoBar
	// iaLine then
	   lineIA; iaNormal->interactiveState; updateInfoBar
	// iaLabel then
	   labelIA; iaNormal->interactiveState; updateInfoBar
	// iaPicture then
	   pictureIA; iaNormal->interactiveState; updateInfoBar
	else
	   'Warning: internal problem in bifrostobjectbody-bifrostPageOnMouseDown'
	     ->putLine;
	   'this is not serious. Please send a bug report to support@mjolner.dk'
	     ->putLine;
	   iaNormal->interactiveState;
	   updateInfoBar
       if);

    else
       'Info: cannot change focus while sif is in texteditmode.'->InfoBar.label;

   if);
   false->dontRepair;
   dontRepairGroup->THIS(bifrostPage).repair;
   (* According to Lennert Sloth the following is needed to be able
    * to get keyEvents.  This could be a problem like the problem with
    * Sif when the freja diagram is changed
    *)
   theScroller.contents[]->target
#)

-- bifrostObjectFindSmallestHit: Descriptor --
(#
do
   scan: THIS(designObject).scanGOsReverse
     (#
     do
	(if go## <= designObject## then
	    go[]->hitObject[];
	    (if UI.extremelyVerbose then
		'looking at %d in section findSmallestHit of %d\n'
		  ->putFormat (#  do hitObject.ID->d; ID->d #)
	    if);
	    (if (canv[],mousepos)->hitObject.containsPoint then
		(canv[],mousepos)->hitObject.findSmallestHit->hitObject[];
		(if hitObject[] <> none then
		    (if UI.extremelyVerbose then
			'found %d in section 1\n'
			  ->putFormat (#  do hitObject.ID->d #)
		    if);
		    leave scan
		 else
		    go[]->hitObject[];
		    (if UI.extremelyVerbose then
			hitObject.dump; 'no regions'->putLine
		    if);
		    (if hitObject.selectable then leave scan if)
		if)
	    if);
	    none ->hitObject[]
	if)
     #);
   (if hitObject[]
    // none then
       (if ((canv[],mousepos)->shapeContainsPoint) and selectable then
	   THIS(designObject)[]->hitObject[];
	   (if UI.extremelyVerbose then
	       'found %d in section 2\n'
		 ->putFormat (#  do hitObject.ID->d #)
	   if)
       if)
   if)
#)
(*
 * do
 *    scan: THIS(designObject).scanGOsReverse
 * 	(#
 * 	do
 * 	   (if go## <= designObject## then
 * 	       go[]->hitObject[];
 * 	       (if UI.extremelyVerbose then
 * 		   hitObject.ID -> putInt; newline
 * 	       if);
 * 	       (if (canv[],mousepos) -> hitObject.shapeContainsPoint then
 * 		   (if hitObject.selectable then
 * 		       leave scan
 * 		    else
 * 		       (if UI.extremelyVerbose then
 * 			   hitObject.dump; 'not selectable' -> putLine
 * 		       if)
 * 		   if)
 * 	       if);
 * 	       (if (canv[],mousepos) -> hitObject.containsPoint then
 * 		   (canv[],mousepos) -> hitObject.findSmallestHit
 * 		     -> hitObject[];
 * 		   (if hitObject[] <> NONE then
 * 		       leave scan
 * 		    else
 * 		       (if UI.extremelyVerbose then
 * 			   go[]->hitObject[];
 * 			   hitObject.dump;
 * 			   'no regions' -> putLine
 * 		       if)
 * 		   if)
 * 	       if);
 * 	       NONE -> hitObject[]
 * 	   if)
 * 	#);
 *    (if hitObject[] // NONE then
 * 	  (if ((canv[],mousepos) -> shapeContainsPoint) and selectable then
 * 	      THIS(designObject)[] -> hitObject[]
 * 	  if)
 *    if)
 *)

-- move: Descriptor --
(#
do
   THIS(designObject).ID->putInt;
   ': move:descriptor called!'->putLine;
   '    Why not call center?'->putLine;
   (x,y)->center
#)

-- ObjectGetCenter: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': ObjectGetCenter:descriptor called!'->putText
   if);
   (if UI.verbose then
       THIS(designObject).designAttributes.position->(x,y);
       'Stored position: %dx%d '
	 ->putFormat (#  do THIS(center).x->d; THIS(center).y->d #)
   if);
   THIS(designObject).designAttributes.update
     (# thePage: ^UI.bifrostPage; theObject: ^thePage.designObject
     do
	THIS(page).ID->UI.getApage->thePage[];
	(if thePage[] // none then 'getcenter1'->putLine if);
	(if UI.bifrostObjectList.rep[THIS(designObject).ID][]
	 // none then 'getcenter2'->putLine
	if);
	UI.bifrostObjectList.rep[THIS(designObject).ID].IO[]->theObject[];
	(if theObject[] // none then 'getcenter3'->putLine if);
	(if UI.verbose then
	    theObject.getCenter->(x,y);
	    '%dx%d '
	      ->putFormat (#  do THIS(center).x->d; THIS(center).y->d #)
	if);
	theObject.getCenter->UI.bifrost2design
	  ->THIS(designObject).designAttributes.position;

     #);
   THIS(designObject).designAttributes.position->(x,y);
   (if UI.verbose then
       '%dx%d\n'->putFormat (#  do THIS(center).x->d; THIS(center).y->d #)
   if)
#)

-- ObjectSetCenter: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': ObjectSetCenter:descriptor called!'->putLine
   if);
   (x,y)->THIS(designObject).designAttributes.position;
   THIS(designObject).designAttributes.update
     (# thePage: ^UI.bifrostPage; theObject: ^thePage.designObject
     do
	THIS(page).ID->UI.getApage->thePage[];
	UI.bifrostObjectList.rep[THIS(designObject).ID].IO[]->theObject[];
	theObject.modify
	(* This is necessary, because setcenter dosn't damage the
	 * old position (this is needed in bifrostObjectNew)
	 *)
	  (#  do (x,y)->UI.design2bifrost->theObject.setCenter #)
     #)
#)

-- NodeDrag: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': NodeDrag:descriptor called!'->putLine
   if)
#)

-- ObjectGetSize: Descriptor --
(#
do
   THIS(designObject).designAttributes.size->(w,h);
   (if UI.verbose then
       '%d: ObjectGetSize:descriptor called! %dx%d\n'
	 ->putFormat (#  do ID->d; w->d; h->d #)
   if)
#)

-- ObjectSetSize: Descriptor --
(#
do
   (if UI.verbose then
       ID->putInt; ': ObjectSetSize:descriptor called!'->putLine;
   if);
   (w,h)->THIS(designObject).designAttributes.size;
   THIS(designObject).designAttributes.update
     (#
	aGO: ^aPage.abstractGraphicalObject;
	aNode: ^aPage.designNode;
	aRect: ^aPage.rect;
	aPage: ^UI.bifrostPage;
	p: @point;

     do
	THIS(page).ID->UI.getApage->aPage[];
	UI.bifrostObjectList.rep[THIS(designObject).ID].IO[]->aNode[];
	aNode.shape[]->aGO[];
	aNode.getBounds->aPage.damage;
	(if true
	 // aGO## <= aPage.rect## then
	    aGO[]->aRect[];
	    THIS(designObject).center->p;
	    w->aRect.theShape.width;
	    h->aRect.theShape.height;
	    aNode.filledShape[]->aRect[];
	    w->aRect.theShape.width;
	    h->aRect.theShape.height;
	    (* Needs to be updated because coordinates is relative
	     * to center
	     *)
	    p->THIS(designObject).center;

	 else
	    (if UI.verbose then
		aGO->getPatternName->putText;
		' resize is not implemented yet!'->putLine
	    if)
	if);
	aNode.repositionText;
	aPage.repair
     #)
#)

-- ObjectSetGeometry: Descriptor --
(# mx,my: @integer;
do
   (if x > 5000 then
       5000->x;
       x->mx;
       y->my;
       'Warning: Diagram was thrown out of visible area: \n (w,h),(x,y)=(%d, %d), (%d, %d) \n '
	 ->putFormat (#  do w->d; h->d; mx->d; my->d;  #);

   if);
   (w,h)->THIS(designObject).size;
   (x,y)->THIS(designObject).center
#)

-- ObjectGetGeometry: Descriptor --
(#  do THIS(designObject).size->(w,h); THIS(designObject).center->(x,y) #)

-- GetRegionList: Descriptor --
(#
do
   (if UI.verbose then
       '%d: GetRegionList:descriptor called!\n'->putFormat (#  do ID->d #)
   if);
   GetRegionIDs->theObjectList.nodeIDsToList->theList[];
   (if (theList[] <> none ) and UI.verbose then theList.dumpList if)
#)

-- ObjectCreateRegion: Descriptor --
(#
   aPage: ^UI.bifrostPage;
   aObject: ^aPage.designObject;
   parentObject: ^aPage.designObject;
   p: @point;

do
   (if not isRegion then
       (if UI.verbose then
	   ID->putInt;
	   ': ObjectCreateRegion:descriptor called, parent ID: '->putText;
	   parent.ID->putInt;
	   newline
       if);
       THIS(designObject).center->p;
       THIS(page).ID->UI.getApage->aPage[];
       UI.bifrostObjectList.rep[THIS(designObject).ID].IO[]->aObject[];
       aObject.initRegion;
       (* FIXME: more stuff should be moved to initRegion*)
       UI.bifrostObjectList.rep[parent.ID].IO[]->parentObject[];
       aObject[]->aPage.theMainPicture.delete;
       aObject[]->parentObject.add;
       parentObject[]->aObject.load_prevPicture[];
       (* Needs to be updated because coordinates is relative
	* to parent picture
	*)
       p->THIS(designObject).center;
       (parent[],parent.getConnectors)->onInitRegion;
       aPage.repair
    else
       (if UI.warnDanger then
	   ID->putInt;
	   ': ObjectCreateRegion:descriptor called, parent ID: '->putText;
	   parent.ID->putInt;
	   newline;
	   'Hey wait! I am a region already'->putLine
       if)
   if)
#)

-- ObjectUnMakeRegion: Descriptor --
(#
   aPage: ^UI.bifrostPage;
   aObject: ^aPage.designObject;
   parentObject: ^aPage.designObject;
   cp: @point;
   oldrepair: @Boolean
do
   UI.dontRepair->oldrepair;
   true->UI.dontRepair;
   THIS(page).ID->UI.getApage->aPage[];
   UI.bifrostObjectList.rep[THIS(designObject).ID].IO[]->aObject[];
   aObject.load_prevPicture[]->parentObject[];
   none ->aObject.load_prevPicture[];
   (if parentObject[]
    // none then
       ID->putInt;
       (failureTrace,': unmakeRegion: This object has no parent')->stop
   if);
   (if UI.verbose then
       ID->putInt;
       ': ObjectUnMakeRegion:descriptor called, parent ID: '->putText;
       parentObject.ID->putInt;
       newline
   if);
   aObject.unmakeRegion;
   (* FIXME: more stuff should be moved to unmakeRegion*)
   center-> (* FIXME: HACK *) cp;
   aObject[]->parentObject.delete;
   aObject[]->aPage.theMainPicture.add;
   cp-> (* FIXME: HACK *) center;
   oldrepair->UI.dontRepair;
   aPage.repair
#)

-- designUtilsCreatePolygon: DoPart --
do
   (if UI.verbose then 'designUtilsCreatePolygon:dopart called!'->putLine if);
     (# thePage: ^UI.bifrostPage; thePoly: ^thePage.designPoly
     do
	pageID->UI.getApage->thePage[];
	&thePage.designPoly[]->thePoly[];
	(UI.design2bifrost,'',pointList)->thePoly.new->polyID
     #);
   (if UI.verbose then 'designUtilsCreatePolygon:dopart done!'->putLine if)

-- bifrostObjectHilite: DoPart --
do
   hiliteLevel+1->hiliteLevel;
   (if UI.extremelyVerbose then
       '%d: hilite controls, level: %d\n'
	 ->putFormat (#  do ID->d; hiliteLevel->d #)
   if);
   (if (not dontRepair) and (hiliteLevel = 1) then
   (* '%d: hilite\n' -> putFormat(# do ID -> d #); *)
       INNER ;
       (if not doneInInner then
	   THIS(designObject)[]->theScroller.contents.hilite
       if)
   if)

-- bifrostObjectUnhilite: DoPart --
do
   hiliteLevel-1->hiliteLevel;
   (if UI.extremelyVerbose then
       '%d: unhilite controls, level: %d\n'
	 ->putFormat (#  do ID->d; hiliteLevel->d #)
   if);
   (if (not dontRepair) and (hiliteLevel = 0) then
   (* '%d: unhilite\n' -> putFormat(# do ID -> d #); *)
       INNER ;
       (if not doneInInner then
	   THIS(designObject)[]->theScroller.contents.unhilite
       if)
   if)

-- bifrostObjectOnSelect: DoPart --
do
   (if theObject[]
    // none then 'Can\'t find selected object '->puttext; ID->putint; newline
    else
       theObject.onSelect
   if)

-- bifrostNodeUnhilite: DoPart --
do
   INNER ;
   (if not doneInInner then
       true->doneInInner; shape[]->theScroller.contents.unhilite
   if)

-- bifrostNodeHilite: DoPart --
do
   INNER ;
   (if not doneInInner then
       true->doneInInner;
       shape[]->THIS(designNode).bringForward;
       shape[]->theScroller.contents.hilite
   if)

-- bifrostConnUnhilite: DoPart --
do
   INNER ;
   (if not doneInInner then
       true->doneInInner; connPrivate.theLine[]->theScroller.contents.unhilite
   if)

-- bifrostConnHilite: DoPart --
do
   INNER ;
   (if not doneInInner then
       true->doneInInner; connPrivate.theLine[]->theScroller.contents.hilite
   if)

-- bifrostSelectionSet: DoPart --
do

-- bifrostSelectionGet: DoPart --
do (* empty doPart - revisit *)

-- DeleteObject: Descriptor --
(* designOAobject.delete *) designAttributes.lookupObject
  (#
     noSuchObject::
       (#
       do
	  true->continue;
	  'WOW! Hey! you have already deleted ID %d!\n'
	    ->putFormat (#  do ID->d #)
       #);
     oldrepair: @Boolean
  do
     UI.dontRepair->oldrepair;
     true->UI.dontRepair;
     (if UI.verbose then
	 '%d: DeleteObject:descriptor called!\n'->putFormat (#  do ID->d #)
     if);
     theObject.remove;
     oldrepair->UI.dontRepair;
     thePage.repair
  #)

-- RemoveObject: Descriptor --
(* designOAobject.onRemove *)
  (#
  do
     (if UI.verbose then
	 '%d: RemoveObject: Descriptor called!\n'->putFormat (#  do ID->d #)
     if);
     (if isRegion then unMakeRegion if);
     THIS(IDObject)[]->theObjectList.delete
  #)

-- bifrostObjectRemove: DoPart --
do
   (if THIS(designObject)[]
    // designSelection then none ->designSelection
   if);
   THIS(designObject).getBounds->damage;
   INNER ;
   getMyObject
     (#  do theObject.onRemove #);
   scanGOsReverse
     (# hitObject: ^designObject
     do
	(if go## <= designObject## then
	    go[]->hitObject[]; hitObject.remove
	if)
     #);
   (* remove ID to GO mapping *)
   bifrostObjectList.rep[ID][]->bifid[];
   none ->bifid.page[];
   none ->bifid.io[];
   none ->bifrostObjectList.rep[ID][];
   (* erase from screen *)
   THIS(designObject)[]->theMainPicture.delete;
   (if theScroller.contents.ready then
   (* THIS(designObject)[] -> theScroller.contents.erase *)

   if);
   THIS(bifrostPage).repair

-- bifrostConnRemove: DoPart --
do
   INNER ;
   (if UI.verbose then
       '%d: removeConn\n'->putFormat (#  do ID->d #);
       (if THIS(designConn)[]->connPrivate.node1.startConnectors.has then
	   'This(connector) is node1(%d).startConnectors before delete\n'
	     ->putFormat (#  do connPrivate.node1.ID->d #)
       if);
       (if THIS(designConn)[]->connPrivate.node2.endConnectors.has then
	   'This(connector) is in node2(%d).endConnectors before delete\n'
	     ->putFormat (#  do connPrivate.node2.ID->d #)
       if)
   if);
   THIS(designConn)[]->connPrivate.node1.startConnectors.delete;
   THIS(designConn)[]->connPrivate.node2.endConnectors.delete;
   (if UI.verbose then
       (if THIS(designConn)[]->connPrivate.node1.startConnectors.has then
	   'This(connector) is in node1(%d).startConnectors\n'
	     ->putFormat (#  do connPrivate.node1.ID->d #)
       if);
       (if THIS(designConn)[]->connPrivate.node2.endConnectors.has then
	   'This(connector) is in node2(%d).endConnectors\n'
	     ->putFormat (#  do connPrivate.node2.ID->d #)
       if)
   if)

-- bifrostNodeRemove: DoPart --
do
   INNER ;
   (if UI.verbose then '%d: removeNode\n'->putFormat (#  do ID->d #) if);
   startConnectors.scan
     (#  do current.remove #);
   endConnectors.scan
     (#  do current.remove #)

-- bifrostEllipseNew: DoPart --
do
   (if UI.verbose then 'ellipse shape'->putText if);
   (* 0-(w div 2)->sx; *)
   (* (h div 2)->sy; *)
   (* create an ellipse *)
   &designEllipseShape[]->theEllipse[];
   &designEllipseFilledShape[]->fs[];
   theEllipse.init;
   fs.init;
   shapeColor[]->theEllipse.setPaint;
   filledShapeColor[]->fs.setPaint;
   true->theEllipse.theShape.stroked;
   ((0,0),h div 2,w div 2)->theEllipse.geometry;
   ((0,0),h div 2,w div 2)->fs.geometry;
   theEllipse[]->THIS(designEllipse).add;
   fs[]->filledShape[]->THIS(designEllipse).add;
   theEllipse[]->THIS(designEllipse).shape[];
   INNER

-- bifrostEllipseDump: DoPart --
do 'This is an ellipse'->putLine; INNER

-- bifrostEllipseContainsPoint: DoPart --
do
   (if UI.extremelyVerbose then
       '%d: contains point called\n'->putFormat (#  do ID->d #);
       thePoint->putPoint;
       getBounds->putRect
   if);
   (if shape.horizontalRadius = shape.verticalRadius then
       (((nodeCenter.x-thePoint.x)*(nodeCenter.x-thePoint.x)+
	 (nodeCenter.y-thePoint.y)*(nodeCenter.y-thePoint.y)) <=
	shape.horizontalRadius*shape.horizontalRadius)->value->doneInInner;
       (if value and UI.extremelyVerbose then
	   '%d: HACK! contained point\n'->putFormat (#  do ID->d #)
       if)
    else
       (theCanvas[],thePoint)->filledShape.containsPoint->value->doneInInner
   if)

-- bifrostNodeTextSize: DoPart --
do theText.getBounds->bnd

-- bifrostConnGetOrient: Descriptor --
(#  do connPrivate.orient->o #)

-- bifrostConnSetOrient: Descriptor --
modify (#  do o->connPrivate.orient; connPrivate.connect #)

-- bifrostObjectAutoPan: DoPart --
do
   (if UI.Verbose then 'bifrostObjectAutoPan: DoPart called!'->putLine if);
   (if not dontRepair then
       none (* we don't want it to autoPan more than once! *) ->autoPanObject[];
       getbounds->r;
       INNER ;
       (* take the zoom factor into account *)
	 (# zoom: @vector
	 do
	    theScroller.contents.ZoomFactor->zoom;
	    (if UI.verbose then
		r->putBounds;
		putLine;
		'zoom factor: %f %f\n'->putFormat (#  do zoom->(f,f) #);

	    if);
	    zoom.x*r.x->r.x;
	    zoom.x*r.width->r.width;
	    zoom.y*r.y->r.y;
	    zoom.y*r.height->r.height;
	    (if UI.verbose then r->putBounds; putLine if)
	 #);
       theScroller.contents.size->s;
       theScroller.viewSize->vs;
       (r.x,s.y-r.y)->stl;
       (stl,(r.width,r.height))->addPoints->sbr;
       theScroller.theScroll->vtl;
       (vtl,vs)->addPoints->vbr;
       (if designSelection <> none then (designSelection).unhilite if);
       (if true
	// stl.x < vtl.x then
	   (if UI.verbose then 'stl.x < vtl.x'->putLine if);
	   (stl.x-10,vtl.y-10)->theScroller.theScroll->vtl;
	   (vtl,vs)->addPoints->vbr
	// sbr.x > vbr.x then
	   (if UI.verbose then 'sbr.x > vbr.x'->putLine if);
	   (sbr.x-vs.x,vtl.y)->theScroller.theScroll->vtl;
	   (vtl,vs)->addPoints->vbr
       if);
       (if true
	// stl.y < vtl.y then
	   (if UI.verbose then 'stl.y < vtl.y'->putLine if);
	   (vtl.x-10,stl.y-10)->theScroller.theScroll
	// sbr.y > vbr.y then
	   (if UI.verbose then 'sbr.y > vbr.y'->putLine if);
	   (vtl.x,sbr.y-vs.y)->theScroller.theScroll
       if);
       (if designSelection <> none then (designSelection).hilite if)
    else
   (* Let repair do the work later *)
       THIS(designObject)[]->autoPanObject[]
   if)

-- bifrostNodeTextEdit: DoPart --
do
     (#
	edit: ^nodeEditor;
	t: ^text;
	bnd: @rectangle;
	pos: @point;
	nodeEditor: editText
	  (#
	     eventHandler::
	       (#
		  onKeyDown::
		    (#
		    do
		       (if ch
			// ascii.nl // ascii.cr // ascii.newline then
			   &text[]->t[];
			   contents->t.putText;
			   t[]->theText.theText;
			   repositionText;
			   THIS(nodeEditor).close
			// ascii.esc then
			   THIS(nodeEditor).close;
		       if)
		    #)
	       #);
	     open::
	       (#
	       do
		  pos->edit.position;
		  (bnd.width,bnd.height+16)->edit.size;
		  t[]->edit.contents
	       #);
	     close::  (#  do 'Close'->putLine; onTextModeOff #)
	  #);

     do
	onTextModeOn;
	getCenter->bifrost2gui->pos;
	shape.getBounds->bnd;
	(if (bnd.width = 0) or (bnd.height = 0) then
	    'Strange size - can\'t edittext'->putLine
	 else
	    pos.x-bnd.width div 2->pos.x;
	    pos.y-bnd.height div 2-8->pos.y;
	    theText.theText->t[];
	    &nodeEditor[]->edit[];
	    theScroller.contents[]->edit.open;

	if)
     #)

-- bifrostObjectOnTextModeOn: DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find \'onTextModeOn\' object '->puttext; ID->putint; newline
    else
       theObject.theText.onTextModeOn
   if)

-- bifrostObjectOnTextModeOff: DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find \'onTextModeOff\' object '->puttext; ID->putint; newline
    else
       theObject.theText.onTextModeOff
   if)

-- bifrostPageOnKeyDown: Descriptor --
(#
do
   (if theDocument[] <> none then
   (* Alt keys does not work in win32, so lets cheat a bit *)
       &<<SLOT bifrostPageKeyDown:Descriptor>>
   if)
#)

-- bifrostPagePrint: Descriptor --
(# rct: @rectangle
do (* FIXME: the group selection should not be lost when printing *)
   designGroup.clear;
   theMainPicture.getbounds->rct;
   (if UI.verbose then rct->putBounds; newLine if);
   '%d %d translate\n'
     ->out.putFormat
       (#
       do
	  - rct.x->d;
	  rct.height-rct.y->d (* 30-rct.x -> d; 30+rct.height-rct.y -> d *)
       #);
   'Begin'->out.putline;
   out[]->theMainPicture.writePS;
   'End'->out.putline;

#)

-- bifrostPageSave: Descriptor --
(#
   out: @text;
   rct: @rectangle;
   realscale,hscale,vscale: @real;
   rotate: @boolean;
   op: @out.putLine;
   on: @out.newline;
   ot: @out.putText;
   bu: @point
do
   thisOp:
     (#
	diag: @file
	  (#
	     cleanUp:
	       (# msg: ^text
	       enter msg[]
	       do (none ,msg[],'Warning')->theGUI.alertUser; leave thisOp
	       #);
	     accessError::  (#  do msg[]->cleanup #);
	     writeError::  (#  do msg[]->cleanup #);
	     readError::  (#  do msg[]->cleanup #);
	     EOSerror::  (#  do msg[]->cleanup #);
	     noSuchFileError::  (#  do msg[]->cleanup #);
	     fileExistsError::  (#  do msg[]->cleanup #);
	     noSpaceError::  (#  do msg[]->cleanup #);
	     otherError::  (#  do msg[]->cleanup #);

	  #);

     do (* open file *) (* fileName[]->out.name;
			 out.openWrite;*)
	theMainPicture.getbounds->rct;
	(if true
	 // scaled then
	    scale / 100.0->realscale
	 // scaleToFit then
	    (if rct.height < rct.width then true->rotate if);
	    (if rotate then
	    (* 11 inches in 1/72 of an inch
	     * .5 inch top and bottom margin
	     *)
		(792-72) / rct.width->vscale;
		(* 8 inches in 1/72 of an inch
		 * .5 inch right and left margin
		 *)
		(576-72) / rct.height->hscale
	     else
	    (* 11 inches in 1/72 of an inch
	     * .5 inch top and bottom margin
	     *)
		(792-72) / rct.height->vscale;
		(* 8 inches in 1/72 of an inch
		 * .5 inch right and left margin
		 *)
		(576-72) / rct.width->hscale
	    if);
	    (if vscale < hscale then
		vscale->realscale
	     else
		hscale->realscale
	    if);
	    (if realscale > 1.0 then 1.0->realscale if)
	 else
	    1.0->realscale
	if);
	'%!PS-Adobe-3.0'->out.putline;
	out.startEPSfile;
	'%%Pages: 1'->op;
	'%%%%BoundingBox: %d %d %d %d\n%%%%EndComments\n'
	  ->out.putFormat
	    (#
	    do
	       36->d;
	       36->d;
	       (if rotate then
		   ((rct.height*realscale)->bu.x)+36->d;
		   ((rct.width*realscale)->bu.y)+36->d
		else
		   ((rct.width*realscale)->bu.x)+36->d;
		   ((rct.height*realscale)->bu.y)+36->d
	       if)
	    #);
	'%%BeginProlog'->op;
	UI.getCVSinfoPS->out.putLine;
	'%%BeginResource: procset Mjolner-Bifrost-StandardMacros 1.0 0'->op;
	out.writeMacros;
	'%%EndResource'->op;
	on;
	'%%BeginResource: procset pahe-bbox 1.0 0'->op;
	'/pahe-bbox'->op;
	'{ exch 0 0 moveto'->op;
	'  dup'->op;
	'  0 lineto'->op;
	'  exch dup 3 1 roll lineto'->op;
	'  0 exch lineto'->op;
	'  0 0 lineto'->op;
	'  stroke } def'->op;
	'%%EndResource'->op;
	on;
	'%%EndProlog'->op;
	on;
	'%%Page: ('->ot;
	THIS(bifrostPage).title->ot;
	') 1'->op;
	'%%BeginPageSetup'->op;
	'/pgsave save def'->op;
	'%%EndPageSetup'->op;
	on;
	'gsave'->op;
	'36 36 translate'->op;
	'newpath'->op;
	'0 setlinewidth'->op;
	'[4 4] 4 setdash'->op;
	(if not UI.verbose then '% '->ot if);
	'%d %d pahe-bbox\n'->out.putFormat (#  do bu.x->d; bu.y->d #);
	'grestore'->op;
	on;
	'36 36 translate % 0.5 inch margin'->op;
	'%% vscale %f hscale %f \n'
	  ->out.putFormat (#  do vscale->f; hscale->f #);
	'%f %f scale\n'->out.putFormat (#  do realscale->f; realscale->f #);
	(if rotate then
	    '90 rotate'->op;
	    '0 -%d translate\n'->out.putFormat (#  do rct.height->d #)
	if);
	out[]->print;
	(* showpage only by public demand /pahe *)
	'pgsave restore'->op;
	'showpage'->op;
	'%%Trailer'->op;
	'%%EOF'->op;
	fileName[]->diag.name;
	diag.openWrite;
	out[]->diag.puttext;
	diag.close (* out.close *)
     #)
#)

-- bifrostPageLoad: Descriptor --
(# oldRepair: @boolean
do
   dontRepair->oldRepair;
   true->dontRepair;
   psfile[]
     ->loadPicture
       (#
	  parseError::  (#  do msg[]->THIS(load).parseError #);
	  createGO::
	    (#
	       dp: ^designPicture;
	       dobj: ^designObject;
	       dn: ^designNode;
	       dc: ^designConn
	    do
	       (if true
		// 'designconn'->patternName.equalNCS then
		   &designConn[]->GO[]
		// 'designrect'->patternName.equalNCS then
		   &designRect[]->GO[]
		// 'designellipse'->patternName.equalNCS then
		   &designEllipse[]->GO[]
		// 'designpoly'->patternName.equalNCS then
		   &designPoly[]->GO[]
		// 'designlabel'->patternName.equalNCS then
		   &designLabel[]->GO[]
		// 'mainPicture'->patternName.equalNCS then
		   &mainPicture[]->theMainPicture[]->GO[];
		   (* aliases for shapes *)

		// 'designObjectText'->patternName.equalNCS then
		   currentReadPicture[]->dobj[];
		   &designObjectText[]->GO[];
		   (if true
		    // dobj## <= designNode## then
		       dobj[]->dn[]; GO[]->dn.theText[];
		    // dobj## <= designConn## then
		    (* for backwards compatibility *)
		       dobj[]->dc[]; GO[]->dc.textToDelete[]
		    else
		       'Error during load - text object on unknown object type'
			 ->putLine
		   if)
		// 'designRectShape'->patternName.equalNCS then
		   currentReadPicture[]->dn[];
		   &designRectShape[]->dn.shape[]->GO[];

		// 'designRectFilledShape'->patternName.equalNCS then
		   currentReadPicture[]->dn[];
		   &designRectFilledShape[]->dn.filledShape[]->GO[];

		// 'designEllipseShape'->patternName.equalNCS then
		   currentReadPicture[]->dn[];
		   &designEllipseShape[]->dn.shape[]->GO[];

		// 'designEllipseFilledShape'->patternName.equalNCS then
		   currentReadPicture[]->dn[];
		   &designEllipseFilledShape[]->dn.filledShape[]->GO[];

		// 'designPolyShape'->patternName.equalNCS then
		   currentReadPicture[]->dn[];
		   &designPolyShape[]->dn.shape[]->GO[];

		// 'designPolyFilledShape'->patternName.equalNCS then
		   currentReadPicture[]->dn[];
		   &designPolyFilledShape[]->dn.filledShape[]->GO[];

		// 'designConnLine'->patternName.equalNCS then
		   currentReadPicture[]->dc[];
		   &designConnLine[]->dc.connPrivate.theLine[]->GO[];

		// 'designConnFatLine'->patternName.equalNCS then
		   currentReadPicture[]->dc[];
		   &designConnFatLine[]->dc.connPrivate.theFatLine[]->GO[];

		// 'bifrostConnArrow'->patternName.equalNCS then
		   currentReadPicture[]->dc[];
		   &dc.connPrivate.bifrostConnArrow[]->dc.connPrivate.theArrow[]
		     ->GO[]
		else
		   'Unknown shape: %s\n'
		     ->putFormat (#  do patternName[]->s #)
	       if);
	       (if GO## <= designPicture## then
		   GO[]->dp[];
		   currentReadPicture[]->dp.load_prevPicture[];
		   dp[]->currentReadPicture[]
	       if);
	       (if GO## <= designNode## then
		   GO[]->dn[]; dn.startConnectors.init; dn.endConnectors.init
	       if)
	    #)
       do (if UI.verbose then screen[]->private.debug[] if)
       #);
   rougeText;
   &<<SLOT bifrostPageLoadDrawMaybe:Descriptor>>;
   oldRepair->dontRepair
#)

-- bifrostPageOnActivate: DoPart --
do
   (if THIS(bifrostPage)[] <> currentBifrostPage[] then
       THIS(bifrostPage)[]->currentBifrostPage[];
       (if (theDocument[] <> none ) and
       (currentBifrostPage.theMainPicture[] <> none ) and
       (currentBifrostPage.theMainPicture.ID <> 0) then
	   currentBifrostPage.theMainPicture.ID->theDocument.theObjectList.find
	     ->theDocument.currentPage
	else
	   THIS(bifrostPage)[]->currentBifrostPage[];
	   (currentBifrostPage.theMenuBar).checkMenuBar
       if)
   if);


-- bifrostPageUpdateMenuBar: DoPart --
do
     (# fileMenuSeen: @boolean
     do
	(theMenuBar).clear;
	(if bifrostDesignDebug then
	    (theMenuBar).extraMenu[]->(theMenuBar).append
	if);
	THIS(designEnv).menuBar.scan
	  (# t: ^text
	  do
	     (if current.att.menu[] <> none then
		 current.att.menu.name->t[];
		 (if (* This is a hack for windows *) 'file'->t.equalNCS then
		     (if not fileMenuSeen then
			 current.att.menu[]->(theMenuBar).append;
			 true->fileMenuSeen
		     if)
		  else
		     current.att.menu[]->(theMenuBar).append
		 if)
	     if)
	  #)
     #)

-- bifrostGroupSet: DoPart --
do
   (if UI.verbose then 'bifrostobjectbody-bifrostGroupSet:doPart'->putLine if)

-- bifrostGroupGet: DoPart --
do
     (# i: @integer
     do
	(if UI.verbose then
	    'bifrostobjectbody-bifrostGroupGet:doPart'->putLine
	if);
	private.implList.size->rep.new;
	1->i;
	private.implList.scan
	  (#  do current.ID->rep[i]; 1+i->i #)
     #)

-- bifrostGroupToggle: DoPart --
do
   (if theObject.grpPos[] <> none then
       (if UI.verbose then
	   'bifrostobjectbody-bifrostGroupToggle: delete'->putLine
       if);
       theObject.grpPos[]->private.implList.delete;
       theObject.removeGroupHilight;
       none ->theObject.grpPos[];
       (if isEmpty then false->private.modeOn if)
    else
       (if not (theObject[]->private.parentInGroup) then
	   (if UI.verbose then
	       'bifrostobjectbody-bifrostGroupToggle: insert'->putLine;
	   if);
	   (if theObject.moveable then
	       theObject[]->private.implList.insertRR;
	       theObject.addGroupHilight;
	       true->private.modeOn
	   if)
	else
	   (if UI.verbose then
	       'bifrostobjectbody-bifrostGroupToggle: parentInGroup'->putLine
	   if)
       if)
   if)

-- bifrostGroupInit: DoPart --
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupInit:doPart'->putLine
   if);
   private.implList.init;
   false->private.modeOn

-- bifrostGroupClear: DoPart --
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupClear:doPart'->putLine
   if);
   private.implList.scan
     (#  do current.removeGroupHilight; none ->current.grpPos[] #);
   false->private.modeOn;
   private.implList.clear

-- bifrostGroupUpdate: DoPart --
do
   (if UI.verbose then
       'bifrostobjectbody-bifrostGroupUpdate:doPart'->putLine
   if);
   (if dontRepair then
       (failureTrace,'designGroup.update is for internal use only!')->stop
   if);
   (* true->dontRepair;
    private.implList.scan
    (#  do current.removeGroupHilight; current.addGroupHilight;  #);
   false->dontRepair *)

-- bifrostGroupPrivate: Descriptor --
(#
   parentInGroup: booleanValue
     (# tp: ^designObject;
     enter tp[]
     do
	loop:
	  (#
	  do
	     (if tp.grpPos[] <> none then true->value if);
	     (if (tp.load_prevPicture[] <> none ) and
	     (tp.load_prevPicture## <= designObject##) then
		 tp.load_prevPicture[]->tp[]; restart loop
	     if)
	  #)
     #);
   implList: @list
     (#
	element:: designObject;
	(* of the bifrost kind *)
	insertRR: (* insert and Remove Regions *)
	  (# elm: ^element; pos: ^theCellType
	  enter elm[]
	  do
	     (if not empty then
		 elm.scanSubRegions
		   (#
		   do
		      (if dp.grpPos[] <> none then
			  dp.grpPos[]->delete;
			  dp.removeGroupHilight;
			  none ->dp.grpPos[]
		      if)
		   #)
	     if);
	     elm[]->prepend->elm.grpPos[]
	  #)
     #);
   modeOn: @boolean;
   updateInfoBar:
     (# t: @text
     do
	t.clear;
	(if modeOn then
	    'Info: Group of %d object%s selected'
	      ->t.putFormat
		(#
		do
		   implList.size->d;
		   (if implList.size = 1 then ''->s else 's'->s if)
		#);
	    t[]->infoBar.label
	if)
     #)
#)

-- bifrostObjectAddGroupHilight: DoPart --
do
   (if UI.veryVerbose then
       '%d: add group highlight\n'->putFormat (#  do ID->d #)
   if);
   INNER ;
     (# bnd: @rectangle; rct: ^rect
     do
	(if not doneInInner then
	    &rect[]->rct[]->groupHilight[];
	    rct.init;
	    50->rasterGrays->rct.setPaint;
	    true->rct.theShape.stroked;
	    2->rct.theShape.strokeWidth;
	    getBounds->bnd;
	    (bnd.x,bnd.y)->rct.upperLeft;
	    bnd.width->rct.width;
	    bnd.height->rct.height;
	    rct[]->theScroller.contents.draw;
	    rct[]->theMainPicture.group.add
	if)
     #)

-- bifrostObjectRemoveGroupHilight: DoPart --
do
   (if UI.veryVerbose then
       '%d: remove group highlight\n'->putFormat (#  do ID->d #)
   if);
   INNER ;
   (if not doneInInner then
       (if groupHilight[]
	// none then
               'bifrostobjectbody-bifrostObjectRemoveGroupHilight:'->putLine;
	       '  groupHilight[] is NONE...'->putLine
	else
	   groupHilight[]->theMainPicture.group.delete;
	   groupHilight[]->theScroller.contents.erase
       if)
   if)

-- bifrostGroupIsEmpty: DoPart --
do private.implList.empty->value

-- bifrostGroupClick: DoPart --
do
   (if (not private.modeOn) or (theObject## <= designConn##) then
       clear; false->private.modeOn; theObject.onSelect
    else
       (if theObject.grpPos[] // none then clear; toggle if)
   if)

-- bifrostConnSetPoints: DoPart --
do
     (#
	pa: ^pointArray;
	pt: @point;
	i: @integer;
	newpts: [pts.range] @integer
     do (* Sanity check *)
	(if pts.range mod 2
	 // 1 then (failureTrace,'Odd number of coordinates')->stop;
	if);
	(* Point i and point i+1 must not be the same *)
	(if pts.range > 1 then
	    pts[1]->newpts[1]->pt.x; pts[2]->newpts[2]->pt.y; 2->i
	if);
	(for inx: (pts.range div 2)-1 repeat
	  (if not ((pts[inx*2+1] = pt.x) and (pts[inx*2+2] = pt.y)) then
	      pts[inx*2+1]->newpts[i+1]; pts[inx*2+2]->newpts[i+2]; i+2->i
	  if);
	  (pts[inx*2+1],pts[inx*2+2])->pt
	for);
	newpts[1:i]->pts;
	(if theScroller.contents.ready then
	(* this(designConn)[] -> theScroller.contents.erase; *)
	    connPrivate.damaged
	if);
	(* insert the points into the connector *)
	(* Note that the first and last points cannot be changed, as *)
	(* they are calculated by the attached nodes *)
	&pointArray[]->pa[];
	(pts.range div 2)->pa.initPoints;
	connPrivate.theLine.theShape.firstPoint->pa.addPoint;
	connPrivate.theLine.theShape.lastPoint->pa.addPoint;
	(for inx: (pts.range div 2)-2 repeat
	  (pts[inx*2+1],pts[inx*2+2])->pt;
	  (if UI.verbose then
	      pt->putPoint; pt->design2bifrost->putPoint; newLine
	  if);
	  (if UI.veryVerbose (* FIXME: introduce a new verbose? *) then
	      pt->theMainPicture.plotPoint
	  if);
	  (if orient
	   // 0 (* No arrows *) // 1 (* Arrow head at node 2 *)
	   // 3 (* Arrow head at both ends *) then
	      1->i
	   // 2 (* Arrow head at node 1 *) then
	      inx->i
	  if);
	  (pt->design2bifrost,i)->pa.insertPoint
	for);
	pa[]->connPrivate.thePoints[];
	connPrivate.thePoints[]->connPrivate.setPoints;
	connPrivate.connect;
	(if theScroller.contents.ready then
	(* FIXME: should draw be called or not *)
	(* this(designConn)[] -> theScroller.contents.draw; *)
	    connPrivate.damaged
	if);
	THIS(bifrostpage).repair
     #)

-- bifrostRectInitRegtion: DoPart --
do

-- bifrostRectUnmakeRegion: DoPart --
do

-- align: DoPart --
do
     (#
	dcp: ^theDocument.page;
	dobj: ^dcp.DesignObject;
	bobj: ^cp.designObject;
	gos: [0] @integer;
	cnt: ^cp.point;
	oldrepair: @boolean
     do
	dontRepair->oldrepair;
	true->dontRepair;
	theDocument.currentPage->dcp[];
	(theDocument.currentPage).ID->UI.getApage->cp[];
	&cp.alignRects[]->ar[];
	cp.designGroup.getGroup->gos;
	(for inx: gos.range repeat
	  UI.bifrostObjectList.rep[gos[inx]].IO[]->bobj[];
	  (if UI.verbose then
	      '%d: align shapeBounds '->putFormat (#  do gos[inx]->d #);
	      bobj.shapeBounds->putBounds;
	      newline
	  if);
	  bobj.shapeBounds->ar.insert
	for);
	INNER align;
	(for inx: gos.range repeat
	  &cp.point[]->cnt[];
	  ar.impl[inx].x+ar.impl[inx].width div 2->cnt.x;
	  ar.impl[inx].y-ar.impl[inx].height div 2->cnt.y;
	  gos[inx]->theDocument.theObjectList.Find->dobj[];
	  cnt->bifrost2design->dobj.center;

	for);
	oldrepair->dontRepair;
	cp.repair
     #)

-- alignLeft: Descriptor --
align (# s: ^cp.designObject
      do cp.designSelection -> s[];
         (if s[]<>NONE then
             s.shapeBounds->ar.alignLeft;
         if);
      #)

-- alignRight: Descriptor --
align (# s: ^cp.designObject 
      do cp.designSelection -> s[];
         (if s[]<>NONE then
             s.shapeBounds->ar.alignRight;
         if)
      #)

-- alignTop: Descriptor --
align (# s: ^cp.designObject 
      do cp.designSelection -> s[];
         (if s[]<>NONE then
             s.shapeBounds->ar.alignTop;
         if);
      #)

-- alignBottom: Descriptor --
align (# s: ^cp.designObject 
      do cp.designSelection -> s[];
         (if s[]<>NONE then
             s.shapeBounds->ar.alignBottom;
         if)
      #)

-- alignVertical: Descriptor --
align (# s: ^cp.designObject 
      do cp.designSelection -> s[];
         (if s[]<>NONE then
             s.shapeBounds->ar.alignVertical;
         if);
      #)

-- alignHorizontal: Descriptor --
align (# s: ^cp.designObject
      do cp.designSelection -> s[];
         (if s[]<>NONE then
             s.shapeBounds->ar.alignHorizontal;
         if)
      #)

-- alignSpacing: Descriptor --
align
  (#
     ad: @theGUI.alignDialog
       (#
	  onOK::
	    (# s: ^cp.designObject
	    do
	       close;
               cp.designSelection -> s[];
	       (if s[]<>NONE then
                   (s.shapeBounds,vdist,hdist,vertical,horizontal)->ar.spacing
               if)
	    #);
	  onCancel::  (#  do close #)
       #)
  do ad.open; ad.showModal
  #)

-- ObjectGetIsRegion: DoPart --
do UI.bifrostObjectList.rep[ID].IO.isRegion->value

-- graphics: DoPart --
do INNER

-- graphicsConn: Descriptor --
graphics
  (#
  do
     'Left click on a node to create a new connector'
       ->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaConn->currentBifrostPage.interactiveState
  #)

-- graphicsRect: Descriptor --
graphics
  (#
  do
     'Left click to create a new rectangle'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaRect->currentBifrostPage.interactiveState
  #)

-- graphicsRndRect: Descriptor --
graphics
  (#
  do
     'Left click to create a new rounded rectangle (not yet implemented)'
       ->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaRndRect->currentBifrostPage.interactiveState
  #)

-- graphicsEllipse: Descriptor --
graphics
  (#
  do
     'Left click to create a new ellipse'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaEllipse->currentBifrostPage.interactiveState
  #)

-- graphicsWedge: Descriptor --
graphics
  (#
  do
     'Left click to create a new wedge'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaWedge->currentBifrostPage.interactiveState
  #)

-- graphicsPoly: Descriptor --
graphics
  (#
  do
     'Left click to create a new polygon'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaPoly->currentBifrostPage.interactiveState
  #)

-- graphicsLine: Descriptor --
graphics
  (#
  do
     'Left click to create a new line'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaLine->currentBifrostPage.interactiveState
  #)

-- graphicsLabel: Descriptor --
graphics
  (#
  do
     'Left click to create a new text label'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaLabel->currentBifrostPage.interactiveState
  #)

-- graphicsPicture: Descriptor --
graphics
  (#
  do
     'Do something to create a new picture'->currentBifrostPage.infoBar.label;
     currentBifrostPage.iaPicture->currentBifrostPage.interactiveState
  #)

-- bifrostObjectDumpSub: DoPart --
do
   scanGOsReverse
     (# dp: ^designObject
     do (if go## <= designObject## then go[]->dp[]; dp.dump; dp.dumpSub if)
     #)

-- dumpAll: DoPart --
do
   currentBifrostPage.theMainPicture.scanGOsReverse
     (# dp: ^currentBifrostPage.designObject
     do
	(if go## <= currentBifrostPAge.designObject## then
	    go[]->dp[]; dp.dump; dp.dumpSub
	if)
     #)

-- bifrostNodeOnSize: DoPart --
do
   startConnectors.scan
     (#  do current.getEnds->current.setEnds #);
   endConnectors.scan
     (#  do current.getEnds->current.setEnds #);
   (if theObject[]
    // none then
       'Can\'t find size click object '->puttext; ID->putint; newline
    else
       theObject.onSize
   if)

-- bifrostConnShapeContainsPoint: DoPart --
do (cv[],pt)->connPrivate.theFatLine.containsPoint->value; INNER

-- kukkuk: DoPart --
do
   debugMark+1->debugMark;
   '\n\n\n\n\n<<-- %05d -->>\n'->putFormat (#  do debugMark->d #)

-- bifrostPageUpdateInfoBar: DoPart --
do
     (# obj: ^designObject
     do
	(if designSelection
	 // none then 'Info:'->infoBar.label
	 else
	    designSelection->obj[];
	    (if true
	     // obj## <= designNode## then
		'Info: one node selected'->infoBar.label
	     // obj## <= designConn## then
		'Info: one connector selected'->infoBar.label
	     else
		'Info: one object selected'->infoBar.label
	    if)
	if);
	designGroup.private.updateInfoBar
     #)

-- bifrostConnSetLineThickness: DoPart --
do thick->connPrivate.theLine.width

-- bifrostRectSetLineThickness: DoPart --
do thick->shape.theShape.strokeWidth

-- bifrostEllipeseSetLineThickness: DoPart --
do (* thick -> shape.theShape.strokeWidth *)

-- bifrostPolySetLineThickness: DoPart --
do thick->shape.width

-- bifrostLabelSetLineThickness: DoPart --
do (* NOTHING *)

-- bifrostConnGetLineThickness: DoPart --
do connPrivate.theLine.width->thick

-- bifrostRectGetLineThickness: DoPart --
do shape.theShape.strokeWidth->thick

-- bifrostEllipeseGetLineThickness: DoPart --
do (* shape.theShape.strokeWidth -> thick *)

-- bifrostPolyGetLineThickness: DoPart --
do shape.width->thick

-- bifrostLabelGetLineThickness: DoPart --
do (* NOTHING *)

-- bifrostPageDamage: DoPart --
do
   (if UI.extremelyVerbose then 'damaged: r '->putText; rct->putBounds if);
   (if damaged.width
    // 0 then (if UI.extremelyVerbose then ' d -'->putText if); rct->damaged
    else
       (if UI.extremelyVerbose then ' d '->putText; damaged->putBounds if);
       (rct,damaged)->rectUnion->damaged
   if);
   (if UI.extremelyVerbose then
       ' d\' '->putText; damaged->putBounds; newline
   if)

-- bifrostPageCheckMenuBar: DoPart --
do
   check:
     (#
	currentMenus: [0] ^theGUI.menu; menuInx: @integer; extraName: @text;
     do
	(if dontUpdate then leave check if);
	(if currentBifrostPage[] // none then leave check if);
	(if not currentBifrostPage.theScroller.contents.ready then
	    leave check
	if);
	(if UI.verbose then
	    '%d: bifrostPageCheckMenuBar-bifrostobjectbody\n'
	      ->putFormat (#  do currentBifrostPage.theMainPicture.ID->d #)
	if);
	'Extras'->extraName;
	scan
	  (#
	  do
	     (if not (current.name->extraName.equal) then
		 menuInx+1->menuInx
	     if)
	  #);
	menuInx->currentMenus.new;
	0->menuInx;
	scan
	  (#
	  do
	     (if not (current.name->extraName.equal) then
		 menuInx+1->menuInx; current[]->currentMenus[menuInx][]
	     if)
	  #);
	0->menuInx;
	(if currentMenus.range <> THIS(designenv).menuBar.size then
	    currentBifrostPage.updateMenuBar; leave check
	if);
	THIS(designenv).menuBar.scan
	  (#
	     theMenu: ^theGUI.menu;
	     currentMenuItems: [0] ^theMenu.menuItem;
	     itemInx: @integer
	  do
	     menuInx+1->menuInx;
	     currentMenus[menuInx][]->theMenu[];
	     (if UI.menuVerbose then
		 '%d: %s\n'
		   ->putFormat
		     (#  do current.ID->d; current.att.name[]->s #)
	     if);
	     (if not (current## <= THIS(designenv).designMenu##) then
		 (if not (theMenu.name->current.att.name.equal) then
		     currentBifrostPage.updateMenuBar; leave check
		 if);
		 (if theMenu.noOfMenuitems <> current.itemList.size then
		     (if current.att.menu.noOfMenuitems <>
		     theMenu.noOfMenuitems
		     (*
		      * This check is not necessary, but someone
		      * is by-passing the designenv menu
		      * interface somehow. The `Windows' menu in
		      * freja is an example of this.
		      * /pahe
		      *) then
			 currentBifrostPage.updateMenuBar; leave check
		     if)
		 if);
		 theMenu.noOfMenuitems->currentMenuItems.new;
		 0->itemInx;
		 theMenu.scan
		   (#
		   do
		      itemInx+1->itemInx; current[]->currentMenuItems[itemInx][]
		   #);
		 0->itemInx;
		 current.itemList.scan
		   (# txt: @text
		   do
		      itemInx+1->itemInx;
		      (if UI.menuVerbose then
			  ' %d: %s %s\n'
			    ->putFormat
			      (#
			      do
				 current.itemNumber->d;
				 currentMenuItems[itemInx].name->s;
				 current.att.name[]->s
			      #)
		      if);
		      txt.clear;
		      0->current.att.name.pos;
		      (if current.att.name.peek
		       // '\\' then
			  current.att.name.get;
			  current.att.name.get;
			  current.att.name.getLine->txt.putText
		       // '-' then
			  'separator'->txt.putText
		       else
			  current.att.name[]->txt.putText
		      if);
		      (if not (currentMenuItems[itemInx].name->txt.equal) then
			  currentBifrostPage.updateMenuBar; leave check
		      if)
		   #)
	     if)
	  #)
     #)

-- bifrostPageRepair: DoPart --
do
   (if (not dontRepair) and (damage.damaged.width <> 0) then
       (if designSelection <> none then (designSelection).unhilite if);
       (if not dontUpdateGroup then designGroup.update if);
       damage.damaged->theScroller.contents.damaged;
       theScroller.contents.repair;
       (if UI.warnDanger then 'repair just called'->putLine if);
       0->damage.damaged.width;
       (if designSelection <> none then (designSelection).hilite if);
       (if autoPanObject[] <> none then autoPanObject.autoPan if);
       updateInfoBar
   if)

-- bifrostPageSetZoom: DoPart --
do
     (#
	putPoint:
	  (# px,py: @Integer
	  enter (px,py)
	  do '(%d,%d)'->putFormat (#  do px->d; py->d #)
	  #);
	oldzoom: @vector;
	scroll: @point
     do
	theScroller.contents.ZoomFactor->oldzoom;
	(if UI.verbose then
	    'new zoom factor: %f %f\n'->putFormat (#  do newzoom->(f,f) #);
	    'old zoom factor: %f %f\n'->putFormat (#  do oldzoom->(f,f) #);

	if);
	theScroller.theScroll->scroll;
	newzoom->theScroller.contents.ZoomFactor;
	(if UI.verbose then scroll->putPoint if);
	scroll.x / oldzoom.x->scroll.x;
	scroll.y / oldzoom.y->scroll.y;
	(if UI.verbose then scroll->putPoint if);
	scroll.x*newzoom.x->scroll.x;
	scroll.y*newzoom.y->scroll.y;
	(if UI.verbose then scroll->putPoint if);
	scroll->theScroller.theScroll
     #);
   (*
    (if (theDocument.currentPage).currentObject<>NONE then
    'curent is not none'->putline;
    (theDocument.currentPage).currentObject -> (theDocument.currentPage).scrollIntoView;
    'curent is not none 2'->putline;
    else

    if);
    *)


-- bifrostPageGetZoom: DoPart --
do theScroller.contents.ZoomFactor->v

-- bifrostPageBlowup: DoPart --
do
     (# oldzoom: @vector
     do zoom->oldzoom; (oldzoom.x+0.25,oldzoom.y+0.25)->zoom
     #)

-- bifrostPageReduce: DoPart --
do
     (# oldzoom: @vector
     do zoom->oldzoom; (oldzoom.x-0.25,oldzoom.y-0.25)->zoom
     #)

-- bifrostObjectOnRightMouseDown: DoPart --
do
   (if theObject[]
    // none then
       'Can\'t find right mousedown object '->puttext; ID->putint; newline
    else
       mousePos->theObject.onRightMouseDown
   if)

-- designObjectOnRightMouseDown: DoPart --
do
   THIS(page).ID->UI.getContentsOfPage->inWindow[];
   (if inWindow[] <> none then INNER onRightMouseDown if)

-- bifrostPageCleanUp: Descriptor --
(#  do true->theScroller.contents.update #)

-- designPictureInteractiveMove: DoPart --
do
   INNER ;
   (if not doneInInner then
       thecanvas.InteractionHandler
	 (# (* When to stop *)
	    stopInteraction: (* user released button *) @boolean;
	    abortInteraction: (* user pressed `Esc' *) @boolean;
	    (* These are share between doIdle, doMotion or doTerminate *)
	    mm: @MoveMatrix;
	    offset: (* the movement *) @Point;
	    vtl: (* view top left *) @Point;
	    vbr: (* view bottom right *) @Point;
	    gloPtr: (* mouse pos relative to the Screen (Xroot) *) @Point;
	    moved: (* used byt doIdle and doMove *) @boolean;
	    everScrolled: (* if the canvas has been scrolled *) @boolean;
	    (* These are initialized for efficiency *)
	    vs: (* View Size *) @Point;
	    zvs: (* View Size with zoom factor *) @Point;
	    cs: (* Canvas Size *) @Point;
	    frame: (* the frame of the view *) @Rectangle;
	    zoom: (* canvas zoomfactor *) @vector;
	    myPointInRect: @
	      (# p: @Point; r: @Rectangle
	      enter (p,r)
	      exit
	      ((r.x <= p.x) and (p.x <= r.x+r.width) and (r.y <= p.y) and
	       (p.y <= r.y+r.height))
	      #);
	    setVTL: @
	      (#
	      do
		 theScroller.theScroll->vtl;
		 (* correct for zoom *)
		 vtl.x / zoom.x->vtl.x;
		 (* Bifrost y coordinates are reversed *)
		 (cs.y-vtl.y) / zoom.y->vtl.y
	      #);
	    Initialize::<
	      (#
	      do (* Erase original highlight *)
		 (if private.hilited then
		     (theCanvas[],false,none )->theshape.drawhilite
		 if);
		 (* Highlight outline *)
		 (theCanvas[],true,none )->theshape.ho;
		 (* Initialize mm - this is needed in the special case *)
		 (* where doMotion isn't called *)
		 offset->mm;
		 (* Used in doIdle *)
		 theCanvas.size->cs;
		 theScroller.viewSize->vs;
		 (* used in both doIdle and doMotion *)
		 THIS(bifrostPage).frame
		   ->((frame.x,frame.y),(frame.width,frame.height));
		 frame.width-frame.x->frame.width;
		 frame.height-frame.y->frame.height;
		 theCanvas.ZoomFactor->zoom;
		 vs.x / zoom.x->zvs.x;
		 vs.y / zoom.y->zvs.y;

	      #);
	    idle::<  (#  do doIdle #);
	    doIdle: @
	      (#
		 scrolled: @Boolean;
		 scrolloffset: @point;
		 theScroll: @point;
		 vdamage,hdamage: @rectangle;
		 absscroll: @Integer
	      do (* leave if `doMotion' hasn't been called, we let *)
	      (* `doMotion' set gloPtr for efficiency *)
		 (if not moved then leave doIdle if);
		 (* Check that pointer is outside the window *)
		 (if ((gloPtr,frame)->myPointInRect) then leave doIdle if);
		 (* Initalize local variables *)
		 false->scrolled;
		 (0,0)->scrolloffset;
		 0->vdamage.width->hdamage.width;
		 setVTL;
		 vtl.x+zvs.x->vbr.x;
		 vtl.y-zvs.y->vbr.y;
		 (* Horizontal scrolls *)
		 (if true
		  // gloPtr.x <= frame.x then (* scroll left *)
		     ((gloPtr.x-frame.x) div 2)->scrolloffset.x;
		     ((- scrolloffset.x) / zoom.x)->absscroll;
		     (vtl.x-absscroll,vtl.y,absscroll,zvs.y)->hdamage
		  // frame.x+frame.width <= gloPtr.x then (* scroll right *)
		     ((gloPtr.x-frame.x-frame.width) div 2)->scrolloffset.x;
		     (scrolloffset.x / zoom.x)->absscroll;
		     (vbr.x,vtl.y,absscroll,zvs.y)->hdamage
		 if);
		 (* Vertical scrolls *)
		 (if true
		  // gloPtr.y <= frame.y then (* scroll up *)
		     ((gloPtr.y-frame.y) div 2)->scrolloffset.y;
		     ((- scrolloffset.y) / zoom.y)->absscroll;
		     (vtl.x,vtl.y+absscroll,zvs.x,absscroll)->vdamage
		  // frame.y+frame.height <= gloPtr.y then (* scroll down *)
		     ((gloPtr.y-frame.y-frame.height) div 2)->scrolloffset.y;
		     (scrolloffset.y / zoom.y)->absscroll;
		     (vtl.x,vbr.y,zvs.x,absscroll)->vdamage
		 if);
		 (if (scrolloffset.x <> 0) or (scrolloffset.y <> 0) then
		     true->everScrolled;
		     (* Do the scrolling *)
		     (scrolloffset,theScroller.theScroll)->addPoints->theScroll;
		     (* don't exceed the scrollers boundaries *)
		     (if theScroll.x < 0 then 0->theScroll.x if);
		     (if theScroll.x+vs.x > cs.x then
			 cs.x-vs.x->theScroll.x
		     if);
		     (if theScroll.y < 0 then 0->theScroll.y if);
		     (if theScroll.y+vs.y > cs.y then
			 cs.y-vs.y->theScroll.y
		     if);
		     theScroll->theScroller.theScroll;
		     (* repair the canvas *)
		     (if vdamage.width <> 0 then
			 vdamage->theCanvas.damaged
		     if);
		     (if hdamage.width <> 0 then
			 hdamage->theCanvas.damaged
		     if);
		     theCanvas.repair
		 if)
	      #);
	    Motion::<  (#  do doMotion #);
	    doMotion: @
	      (#
		 myabs: (* for efficiency *) @abs;
		 outside: (* mouse is outside window *) @boolean;
		 mousePoint: @Point
	      do
		 getGlobalPointerLocation->gloPtr;
		 true-> (* used in doIdle *) moved;
		 (if (gloPtr,frame)->myPointInRect then
		 (* Inside the view - erase outline *)
		     offset->mm;
		     (if not outside then (* FIXME: error in ho? - see below *)
		     (* erase outline at old position *)
			 (theCanvas[],false,mm[])->theshape.ho;
		     if);
		     false->outside
		  else
		 (* outside the view - erase outline *)
		     (if not outside then
		     (* FIXME: there seems to be an error in ho -
		      * the outside variable shouldn't be necessary and
		      * we should be able to use false (erase) ...
		      *)
			 (theCanvas[],true,mm[])->theshape.ho
		     if);
		     true->outside;
		     leave doMotion;

		 if);
		 (* Get mouse location *)
		 GetPointerLocation->thecanvas.DeviceToCanvas->mousePoint;
		 (*
		  * Find new offset and draw outline
		  *)
		 (mousePoint.x-startpoint.x,mousePoint.y-startpoint.y)->offset;
		 (if themodifier->isModifierOn then
		 (* Constrain to orthogonal movements *)
		     (if (offset.y->myabs) > (offset.x->myabs) then
		     (* 90 degrees *)
			 0->offset.x;
		      else
		     (* 0 degrees *)
			 0->offset.y;
		     if)
		 if);
		 (* draw outline *)
		 offset->mm;
		 (theCanvas[],true,mm[])->theshape.ho
	      #);
	    ButtonRelease::<  (#  do true->stopInteraction #);
	    keyPress::<
	      (#
	      do (if ch // ascii.esc then true->abortInteraction if)
	      #);
	    TerminateCondition::<
	      (#  do (stopInteraction or abortInteraction)->value #);
	    Terminated::<  (#  do doTerminate #);
	    doTerminate:
	      (#
	      do (* Erase outline *)
		 (theCanvas[],false,mm[])->theshape.ho;
		 (if ((offset.x <> 0) or (offset.y <> 0)) and
		 (not (* user pressed `Esc' *) abortInteraction) then
		     (if not everScrolled then
		     (* Repair parts of the view area *)
			 getBounds->thecanvas.damaged
		     if);
		     (* Do the actual move *)
		     offset->move;
		     (if not everScrolled then
		     (* Repair parts of the view area *)
			 getBounds->thecanvas.damaged
		     if)
		 if);
		 (if everScrolled then (* Repair the entire view area *)
		     setVTL; (vtl.x,vtl.y,zvs.x,zvs.y)->theCanvas.damaged
		 if);
		 (* Restore original highlight *)
		 (if private.hilited then
		     (theCanvas[],false,none )->theshape.drawHilite
		 if)
	      #)
	 #);
       thecanvas.repair;
       true->doneInInner
   if)

-- bifrostConnMoveRegions: DoPart --
do
     (# tc: @Point
     do
	ScanGOsReverse
	  (# dobj: ^designObject
	  do
	     (if GO## <= designObject## then
		 GO[]->dobj[];
		 dobj.getCenter->tc;
		 ((tc,oc)->subPoints,nc)->addPoints->tc;
		 dobj.modify
		   (#  do tc->dobj.setCenter #)
	     if)
	  #);

     #)

-- bifrostPageRougeText: Descriptor --
(# (* Removes text from connectors - for backwards compatibility only *)
do
   theMainPicture.scanGOsReverse
     (# dc: ^designConn
     do
	(if go## <= designConn## then
	    go[]->dc[];
	    (if dc.textToDelete[] <> none then
		'Note: removing text from connector with id=%d\n'
		  ->putFormat (#  do dc.ID->d #);
		dc.textToDelete[]->dc.delete;
		none ->dc.textToDelete[]
	    if)
	if)
     #)
#)

-- bifrostPagePrivatePart: Descriptor --
(#
(*
 * The following patterns are used when interactively moving
 * designNodes (moveStartConn and moveEndConn in
 * bifrostConnPrivate: Descriptor)
 *)
   interactionTM: (* used by designNode.nodePrivate.transform *) ^matrix;
   interactionNodes: (* list of designNodes beeing moved interactively *) @
     (#
	initialSize: (* initial size of the list *) (#  exit 1 #);
	list: (* implemetation of the list *) [0] ^designNode;
	size: (* number of elements in the list *) @integer;
	init: (* reset the list *)
	  (#  do initialSize->list.new; 0->size #);
	insert: (* insert an element in the list *)
	  (# elm: ^designNode;
	  enter elm[]
	  do
	     (if list.range // size then list.range->list.extend if);
	     size+1->size;
	     elm[]->list[size][];

	  #);
	release: (* release the memory used by the list *)
	  (#  do 0->list.new; 0->size #)
     #)
#)

-- designPictureReadUserdata: DoPart --
do
   thisOp:
     (#
	bi: ^IDBifrost;
	k,j: @integer;
	ud: ^bi.UD.dataType;
	ch: @char;
	gi: userdata.getInt
	  (#
	     syntaxError::<
	       (#  do true->continue; parseError; leave thisOp #)
	  #)
     do
	(if userDataVerbose then
	    'userdata: \'%s\''->putFormat (#  do userdata[]->s #)
	if);
	(* needed to keep track of the current designPicture *)
	load_prevPicture[]->currentReadPicture[];
	(* setup for reading userdata *)
	0->userdata.pos;
	userdata.get;
	userdata.get;
	(* '% ' *)
	(* create ID <-> GO mapping *)
	(* FIXME?? toby:
	 inserted remapping of ID if ID is already in use.
	 Used when loading graphics pages on the fly!

	 userdata.getInt [* read ID from file *] ->ID;
	 (if (ID > bifrostObjectList.rep.range) or
	 (bifrostObjectList.rep[ID][] <> none ) then
	 >>1>> bifrostObjectList.newID->ID;
	 else
	 ID [* make sure that this ID isn't used again *]
	 ->bifrostObjectList.newID.steal;

	 if); *)
	(* original pahe code: *)
	gi (* read ID from file *)
	  ->ID (* and make sure that this ID isn't used again *)
	  ->bifrostObjectList.newID.steal;
	&IDBifrost[]->bi[];
	(THIS(bifrostPage)[],THIS(designPicture)[],ID)->bi.init;
	(if load_prevPicture[] <> none then
	    (if theMainPicture[] <> load_prevPicture[] then true->isRegion if)
	if);
	(* restore userdata *)
	(if not (userdata[]->bi.UD.load) then parseError; leave thisOp if);
	INNER readUserData
     #)

-- designObjectReadUserdata: DoPart --
do
   thisOp:
     (#
	gi: userdata.getInt
	  (#
	     syntaxError::<
	       (#  do true->continue; parseError; leave thisOp #)
	  #)
     do
	&integerObject[]->io[];
	ID->io;
	(if gi // 0 then false->selectable else true->selectable if);
	(if gi // 0 then false->borderhidden else true->borderhidden if);
	(* FIXME - color information should be saved
	 * - how about picture.getpaint?
	 *)
	&solidColor[]->color[];
	color.init;
	black->color.RGBValues;
	INNER readUserData
     #)

-- designConnReadUserdata: DoPart --
do
   thisOp:
     (#
	gi: userdata.getInt
	  (#
	     syntaxError::<
	       (#  do true->continue; parseError; leave thisOp #)
	  #)
     do
	(gi,gi)->end;
	(gi,gi)->begin;
	gi->connPrivate.orient;
	gi->connPrivate.node1ID;
	gi->connPrivate.node2ID;
	io[]->connlist.insert;
	&solidColor[]->connPrivate.fatLineDebugColor[];
	connPrivate.fatLineDebugColor.init;
	orchid->connPrivate.fatLineDebugColor.RGBValues;
	connPrivate.theLine.points->connPrivate.thePoints[];
	INNER readUserData
     #)

-- designNodeReadUserdata: DoPart --
do
   thisOp:
     (#
	pt: ^paint;
	gi: userdata.getInt
	  (#
	     syntaxError::<
	       (#  do true->continue; parseError; leave thisOp #)
	  #)
     do
	io[]->nodelist.insert;
	(if gi // 0 then false->moveable else true->moveable if);
	(if gi // 0 then false->sizeable else true->sizeable if);
	gi->nodecenter.x;
	gi->nodecenter.y;
	shape.getPaint->pt[];
	(if pt## <= solidColor## then
	    pt[]->shapeColor[]
	 else
	    color.copy->shapeColor[]
	if);
	filledShape.getPaint->filledShapeColor[];
	&filledShape.theShape.hiliteDesc[]->filledShape.theShape.ho[];
	INNER readUserData
     #)

-- mainPictureReadUserdata: DoPart --
do
   thisOp:
     (#
	io: ^integerObject;
	ln: @integer;
	tl: ^text;
	gi: userdata.getInt
	  (#
	     syntaxError::<
	       (#  do true->continue; parseError; leave thisOp #)
	  #)
     do
	&integerObject[]->io[];
	ID->io;
	io[]->UI.pageList.insert;
	gi->ln;
	&text[]->tl[];
	userdata.get;
	(* eat one space *)
	(for i: ln repeat userdata.get->tl.put for);
	tl[]->THIS(bifrostPage).title;
	reattachConnectors
     #)
