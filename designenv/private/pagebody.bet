ORIGIN '../designenv';
(********************************** PAGE ************************************)
INCLUDE 'documentbody';
-- InitPage: Descriptor --
(# (* to initialize a page DesignOA already have created *)
   x,y,h,w: @Integer; 
do
   DesignObject##->DesignObjectDesc##;
   THIS(Page)[]->theObjectList.insert;
   THIS(Page)[]->CurrentPage.p[];
   (* THIS(page) is current page now *)
   geometry->(x,y,w,h);
   w->privatePart.hackw;
   h->privatePart.hackh;
   (if verbose
    // true then
       'Init Page '->puttext;
       ID->putint;
       newline;
       'Size: '->puttext;
       w->putint;
       ' '->put;
       h->putint;
       newline;
       
   if);
   nextPageNo->PageNo;
   (*'nextPageNo : '->screen.putText; nextPageNo.no->screen.putInt; screen.newLine;
    'getPageNo : '->screen.putText; PageNo->screen.putInt; screen.newLine;*)
   
#)  

-- PostInitpage: Descriptor --
(# 
do
   activate;
   (* activate the page: e.g. make the menus visible *)
   DSMenuShowMenuBar;
   (* update the menubar *)
   
#)  

-- NewPage: Descriptor --
(# (* to make a new page from user program *) 
do
   Rectangle->DSStrNewPage->onInit;
   (if verbose // true then 'New Page  '->puttext; ID->putint; newline if);
   
#)  

-- PositionNewPage: Descriptor --
(# (* to make a new page from user program *) 
do
   (Rectangle,true,true,x,y,w,h)->DSStrNewPageAndWindow->onInit;
   (if verbose
    // true then 'New PageAndWindow '->puttext; ID->putint; newline
   if);
   
#)  

-- InvisibleNewPage: Descriptor --
(# (* to make a new page from user program *) Invisible: (#  exit 1 #); 
do
   (Rectangle,Invisible)->DSStrNewPageWithFlags->onInit;
   (if verbose
    // true then 'New PageWithFlags '->puttext; ID->putint; newline
   if);
   
#)  

-- CleanUpPage: Descriptor --
(# theNodes: ^ObjectList; count: @ShortRef; list: @IntegerRef; 
do (* actually: we must delete all objects *)
   (if (THIS(Page).ID,count[],list[])->DSStrGetNodeList
    // true then
       (count,list)->GetIntList->theObjectList.NodeIDsToList->theNodes[]; 
   if);
   (if theNodes[] <> none
    // true then theNodes.scan (#  do current.ID->DSStrDeleteObject #); 
   if);
   
#)  

-- ScrollPage: Descriptor --
(#  do (THIS(Page).ID,xtop,ytop)->DSUIScrollPage;  #)  

-- ClosePage: Descriptor --
(# 
do
   (if ID->DSStrClosePage
    // false then 'ClosePage: could not close page'->putline
   if)
#)  

-- PageActivateBody: Descriptor --
(# (* here we must insert the page specific menus *) 
do
   (if verbose // true then 'activating page'->putline if);
   PageMenuBar.scan
     (#  do current[]->MenuBar.insert #);
   THIS(Page)[]->theDocument.CurrentPage.p[];
   
#)  

-- PageDeactivateBody: Descriptor --
(# (* here we must delete the page specific menus *) 
do
   (if verbose // true then 'deactivating page'->putline if);
   PageMenuBar.scan
     (#  do current[]->MenuBar.remove #);
   
#)  

-- RedrawPage: Descriptor --
(# 
do
   (if THIS(Page)[] <> theDocument.CurrentPage.p[]
    // true then
       (if verbose
        // true then RedrawPage: 'THIS(Page) is not current!'->putline; 
       if);
       
    else
       DSUIUpDateCurrentPage; 
   if);
   
#)  

-- SetVisible: Descriptor --
(# num,w,h,vis: @IntegerRef; nameStr: [64] @char; 
do
   (if v
    // true then (ID,true)->DSUIMakePageVisible; 
    else
       (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
        // true then
           (if (ID,nameStr,num,w,h,v)->DSWtAttrPageInfo
            // false then 'SetVisible: write failed'->putline
           if);
           
       if)
   if);
   
#)  

-- GetVisible: Descriptor --
(# num,w,h,vis: @IntegerRef; nameStr: [64] @char; 
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then vis->v; 
   if);
   
#)  

-- SetPageTitle: Descriptor --
(# num,w,h,vis: @IntegerRef; nameStr: [64] @char; 
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then
       (if (ID,t,num,w,h,vis)->DSWtAttrPageInfo
        // false then 'SetTitle: write failed'->putline
       if);
       
   if);
   
#)  

-- GetPageTitle: Descriptor --
(# num,w,h,vis: @IntegerRef; nameStr: [64] @char; 
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then @@ nameStr[1]->cStringToCharRep->t; 
   if);
   
#)  

-- SetPageNo: Descriptor --
(#
   num,w,h,vis: @shortRef;
   nameStr: [64] @char;
   DSRdAttrGetPageAttr: external
     (# ok: @boolean; pageID,stringP: @integer; num,w,h,vis: ^shortRef; 
     enter (pageID,stringP,num[],w[],h[],vis[])
     do 'DSRdAttr_GetPageAttr'->callC; 
     exit ok
     #);
   DSWtAttrPageInfo: external
     (#
        ok,vis: @boolean;
        pageID: @integer;
        name: [1] @char;
        num,w,h: @shortInt;
        
     enter (pageID,name,num,w,h,vis)
     do 'DSWtAttr_PageInfo'->callC
     exit ok
     #);
   
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then
       (if (ID,nameStr,no,w,h,vis)->DSWtAttrPageInfo
        // false then 'SetNo: write failed'->putline
       if);
       
   if);
   
#)  

-- GetPageNo: Descriptor --
(#
   num,w,h,vis: @shortRef;
   nameStr: [64] @char;
   DSRdAttrGetPageAttr: external
     (# ok: @boolean; pageID,stringP: @integer; num,w,h,vis: ^shortRef; 
     enter (pageID,stringP,num[],w[],h[],vis[])
     do 'DSRdAttr_GetPageAttr'->callC; 
     exit ok
     #);
   
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then num->no; 
   if);
   
#)  

-- SetBorder: Descriptor --
(# num,w,h,vis: @IntegerRef; nameStr: [64] @char; t: [1] @Char; 
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then
       @@ nameStr[1]->cStringToCharRep->t;
       (if (ID,t,num,w,h,b)->DSWtAttrPageInfo
        // false then 'SetBorder: write failed'->putline
       if);
       
   if);
   
#)  

-- GetBorder: Descriptor --
(# num,w,h,vis: @IntegerRef; nameStr: [64] @char; 
do
   (if (ID,@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
    // true then vis->b; 
    else
       'GetBorder: read failed'->putline
   if);
   
#)  

-- IsOpen: Descriptor --
(# resRef: @IntegerRef; 
do
   (if (ID,resref[])->DSStrIsPageOpen
    // false then false->res; 
    else
       resRef->res; 
   if);
   
#)  

-- Coarsen: Descriptor --
(# ids: [0] @Integer; failed: @Boolean; 
do
   (if verbose // true then 'Coarsen'->putline if);
   (if theNodeList[] <> none
    // true then theNodeList.ListToNodeIDs->ids
   if);
   (ID,ids.range,@@ ids[1],theNode.ID)->DSStrCoarsen->id;
   (if id = 0 // false then id->theObjectList.find->subPage[] if);
   
#)  

-- GetDesignObject: Descriptor --
(# curID: @Integer; 
do DSStrGetCurObject->curID; curID->theObjectList.Find->theObject[]; 
#)  

-- SetDesignObject: Descriptor --
(# 
do
   (if theObject.ID->DSStrSetCurObject
    // false then 'SetDesignObject: Could not select object'->putline; 
   if);
   
#)  

-- SetObjectAutoPan: Descriptor --
(# 
do (if autoPan // true then (theObject.ID,false)->DSUIAutoPan;  if); 
#)  

-- GetDesignGroup: Descriptor --
(# count: @ShortRef; list: @IntegerRef; 
do
   (if (count[],list[])->DSStrGetCurGroup
    // true then
       (count,list)->GetIntList->theObjectList.NodeIDsToList->theList[]; 
    else
       'GetDesignGroup: Could not get group'->putline; 
   if);
   
#)  

-- SetDesignGroup: Descriptor --
(# list: [0] @Integer; 
do
   theList.ListToNodeIDs->list;
   (if (list.range,@@ list[1])->DSStrSetCurGroup
    // false then 'SetDesignGroup: Could not set group'->putline; 
   if);
   
#)  

-- GetNodes: Descriptor --
(# count: @ShortRef; list: @IntegerRef; 
do
   (if (THIS(Page).ID,count[],list[])->DSStrGetNodeList
    // true then
       (count,list)->GetIntList->theObjectList.NodeIDsToList->theNodes[]; 
   if);
   
#)  

-- PageGetConnectors: Descriptor --
(# count: @ShortRef; list: @IntegerRef; 
do
   (if (THIS(Page).ID,count[],list[])->DSStrGetPageConnList
    // true then
       (count,list)->GetIntList->theObjectList.NodeIDsToList->theList[]; 
   if);
   
#)  

-- GetInternalConnectors: Descriptor --
(# count: @ShortRef; list: @IntegerRef; nodeList: [0] @Integer; 
do
   theNodeList.ListToNodeIDs->nodeList;
   (if
   (@@ nodelist[1],nodeList.range,list[],count[])->DSStrGetInternalConnList
    // true then
       (count,list)->GetIntList->theObjectList.NodeIDsToList->theConnList[]; 
   if);
   
#)  

-- PageGetParent: Descriptor --
(# 
do
   THIS(Page).ID->DSRdAttrGetParentNode->theObjectList.Find->p[];
   (if verbose
    // true then
       (if p[] // none then 'GetParent: parent is none'->putline;  if); 
   if);
   
#)  

-- PageAttachToNode: Descriptor --
(# m,r: [0] @Integer; 
do
   (if matchNodes[] <> none // true then matchNodes.ListToNodeIDs->m if);
   (if repNodes[] <> none // true then repNodes.ListToNodeIDs->r if);
   (if
   (theNode.ID,THIS(Page).ID,r.range,@@ m[1],@@ r[1])->DSStrAttachPageToNode
    // false then 'AttachToNode: failed'->putline
   if);
   
#)  

-- MakeDesignObject: Descriptor --
(# 
do
   (if ID->DSRdAttrGetShape
    // Rectangle then
       &DesignRect[]->theObject[]; 
    // Ellipse then
       &DesignEllipse[]->theObject[]; 
    // Polygon then
       &DesignPolygon[]->theObject[]; 
    // RndRect then
       &DesignRndRect[]->theObject[]; 
    // Wedge then
       &DesignWedge[]->theObject[]; 
    // Picture then
       &DesignPicture[]->theObject[]; 
    // StraightConn // CurveTopConn // CurveSideConn then
       &DesignConnector[]->theObject[]; 
    else
       'MakeDesignObject: '->puttext;
       ID->putint;
       ' '->put;
       ID->DSRdAttrGetShape->putint;
       ' unknown type '->putline;
       
   if);
   INNER MakeDesignObject (*toby 25-10-94*) ;
   (if theObject[] <> none
    // true then
       ID->theObject.onInit;
       (* is it itself a region?? *)
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion; 
       if);
       (* check for regions connected *)
       (if (ID,count[],list[])->DSStrGetObjectRegionList
        // true then
           (if count > 0
            // true then
               (count,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if)
   if)
#)  

-- MakeObjectsFromList: DoPart --
do (for j: list.range repeat list[j]->MakeDesignObject;  for);   

-- MakeDescObject: DoPart --
do
   (if verbose // true then 'MakeDescObject'->puttext if);
   (if theDocument.privatePart.InteractiveCreatedObject[]
    // none then &DesignObjectDesc[]->theObject[]; 
    else
   (* we have already instantiated the object *)
       theDocument.privatePart.InteractiveCreatedObject[]->theObject[];
       none ->theDocument.privatePart.InteractiveCreatedObject[];
       (* and we only make it once *)
       (* make an ABORT to Design/OA *)
       DSUIAbortCommand;
       
   if);
   theID->theObject.onInit;
   (if verbose
    // true then
       ' ID: '->puttext;
       theID->putint;
       ' type: '->puttext;
       theID->DSRdAttrGetObjectType->putint;
       newline;
       
   if);
     

-- MakeCoarse: DoPart --
do
   'MakeCoarse'->putline;
   (if nodeList[] <> none
    // true then
       nodeList.scan
         (# (* remove this node from old page *) 
         do
            (if current[] <> theNode[]
             // true then
                current[]->theObjectList.delete;
                (if verbose
                 // true then
                    'Remove Node: '->puttext; current.ID->putint; newline; 
                if);
                
             else
                (if verbose
                 // true then
                    'MakeCoarse: Not deleting coarse node'->putline; 
                if);
                
            if)
         #);
       
   if);
   (if connList[] <> none
    // true then
       connList.scan
         (# (* remove this conn from old page *) 
         do
            (if verbose
             // true then
                'Remove Connector: '->puttext; current.ID->putint; newline; 
            if);
            current[]->theObjectList.delete;
            
         #);
       
   if);
   (if crossList[] <> none
    // true then
       crossList.scan
         (# (* remove this conn from old page *) 
         do
            (if verbose
             // true then
                'Remove CrossConn: '->puttext;
                current.conn.ID->putint;
                newline;
                
            if);
            current.conn[]->theObjectList.delete;
            
         #);
       
   if);
   'MakeCoarse END'->putline;
     

-- PageGetCenter: Descriptor --
(# xref,yref: @IntegerRef; 
do
   (if (THIS(Page).ID,xref[],yref[])->DSRdAttrGetObjectCenter
    // true then xref->DSUtilWorldToPoints->x; yref->DSUtilWorldToPoints->y; 
    else
       'PageGetCenter: error '->putline
   if);
   
#)  

-- PageSetCenter: Descriptor --
(# 
do
   (if (THIS(Page).ID,x->wcoord,y->wcoord)->DSWtAttrObjectPosition
    // false then 'PageSetCenter: could not set pos'->putline
   if);
   
#)  

-- PageSetGeometry: Descriptor --
(# 
do
   (if (THIS(Page).ID,x->wcoord,y->wcoord)->DSWtAttrObjectPosition
    // false then 'PageSetGeo: could not set pos'->putline
   if);
   (if (THIS(Page).ID,w,h)->DSWtAttrAdjustObjectSize
    // false then 'PageSetGeo: could not set size'->putline
   if);
   
#)  

-- PageGetGeometry: Descriptor --
(# xref,yref: @IntegerRef; 
do
   (if (THIS(Page).ID,xref[],yref[])->DSRdAttrGetObjectCenter
    // true then xref->DSUtilWorldToPoints->x; yref->DSUtilWorldToPoints->y; 
    else
       'PageGetGeometry Center: error '->putline
   if);
   (if (THIS(Page).ID,xref[],yref[])->DSRdAttrGetObjectSize
    // true then
       xref->DSUtilWorldToPoints->w;
       yref->DSUtilWorldToPoints->h;
       (if w // 0 then privatePart.hackw->w; privatePart.hackh->h;  if);
       
    else
       'PageGetGeometry Size: error'->putline; 
   if);
   
#)  

-- PageReadDiagram: Descriptor --
(* called when we read in a page from disk*)
  (#
     nodes,conns: [0] @Integer;
     theObject: ^DesignObject;
     count: @ShortRef;
     list: @IntegerRef;
     
  do (* Get all Nodes for this page*)
     (if (THIS(Page).ID,count[],list[])->DSStrGetNodeList
      // true then
         (count,list)->GetIntList->nodes;
         (if verbose
          // true then 'NoOfNodes: '->puttext; nodes.range->putint; newline; 
         if);
         nodes->PageCallBack.MakeObjectsFromList;
         (* Get all connectors for this page *)
         (if (THIS(Page).ID,count[],list[])->DSStrGetPageConnList
          // true then
             (count,list)->GetIntList->conns;
             (if verbose
              // true then
                 'NoOfConns: '->puttext; conns.range->putint; newline; 
             if);
             conns->PageCallBack.MakeObjectsFromList;
             
         if);
         
     if);
     INNER OnReadDiagram;
     
  #)
  (************************* PALETTE ******************************)  

-- PaletteInit: Descriptor --
(#  do (ID,true)->DSStrSetPaletteOption;  #)  

