ORIGIN 'designobjectbody';
-- WriteUserData: Descriptor --
(#  do INNER WriteUserData #)  

-- ReadUserData: Descriptor --
(#  do INNER ReadUserData #)  

-- WriteReferenceUserData: Descriptor --
(# l: @integer
do
   (if dataElement[] <> none then
       false->isNone;
       (if (ID <> 0) and (attributeId <> 0) then
           (if dataType## <= IDObject## then
               dataElement[]->theIDObject[];
               theIDObject.ID->IDdata;
               (Id,attributeId,@@ IDdata,4)->UI.UDWriteType->ok;
               (if ok then
                   (if userDataVerbose then
                       'Write IDObject data for id: '->puttext;
                       id->putint;
                       ' with attributeId: '->puttext;
                       attributeId->putint;
                       ' succeed:'->puttext;
                       IDData->putint;
                       newline
                   if)
                else
                   (if userDataVerbose then
                       'Write IDObject data for id: '->puttext;
                       id->putint;
                       ' with attributeId: '->puttext;
                       attributeId->putint;
                       ' fail'->putline
                   if)
               if)
           if);
           (if dataType## <= Text## then
               dataElement[]->theText[];
               theText.length->l;
               (Id,attributeId,@@ theText.T[1],l)->UI.UDWriteType->ok;
               (if ok then
                   (if userDataVerbose then
                       'Write Text data succeed'->putline
                   if)
                else
                   (if userDataVerbose then
                       'Write Text data fail'->putline
                   if)
               if)
           if);
           INNER WriteUserData
       if)
    else
       true->isNone
   if);
   
#)  

-- ReadReferenceUserData: Descriptor --
(# b: @boolean; textSize: ^integerRef
do
   isNone->b;
   (if not b then
       (if (ID <> 0) and (attributeID <> 0) then
           (if dataType## <= IDObject## then
               (Id,attributeId,@@ IDdata)->UI.UDReadType->ok;
               (if ok then
                   (if userDataVerbose then
                       'Read IDObject data for id: '->puttext;
                       id->putint;
                       ' with attributeId: '->puttext;
                       attributeId->putint;
                       ' succeed: '->puttext;
                       IDdata->putint;
                       newline
                   if);
                   IDdata->theObjectList.find->dataElement[]
                else
                   (if userDataVerbose then
                       'Read IDObject data for id: '->puttext;
                       id->putint;
                       ' with attributeId: '->puttext;
                       attributeId->putint;
                       ' fail'->putline
                   if)
               if)
           if);
           (if dataType## <= Text## then
               &Text[]->theText[];
               &integerRef[]->textSize[];
               (id,attributeId,textSize[])->UI.UDTypeSize->ok;
               (if ok then
                   (if textSize > TextData.range then
                       textSize+1->TextData.extend
                   if);
                   (Id,attributeId,@@ TextData[1])->UI.UDReadType->ok;
                   (if ok then
                       (if userDataVerbose then
                           'Read Text data succeed'->putline
                       if);
                       (for i: textSize repeat TextData[i]->theText.put for);
                       theText[]->dataElement[]
                    else
                       (if userDataVerbose then
                           'Read Text data fail'->putline
                       if)
                   if)
                else
                   (if userDataVerbose then
                       'Read Text data: get User data TypeSize fail!'->putline
                   if)
               if)
           if);
           INNER ReadUserData
       if)
   if);
   
#)  

-- getIDReferenceUserData: Descriptor --
(# ok: @Boolean; b: @boolean
do
   isNone->b;
   (if not b then
       (if (ID <> 0) and (attributeID <> 0) then
           (if dataType## <= IDObject## then
               (Id,attributeId,@@ theID)->UI.UDReadType->ok;
               (if ok then
                   (if userDataVerbose then
                       'getID for id: '->puttext;
                       id->putint;
                       ' with attributeId: '->puttext;
                       attributeId->putint;
                       ' succeed: '->puttext;
                       theID->putint;
                       newline
                   if)
                else
                   (if userDataVerbose then
                       'getID for id: '->puttext;
                       id->putint;
                       ' with attributeId: '->puttext;
                       attributeId->putint;
                       ' fail'->putline
                   if)
               if)
           if);
           INNER getID
       if)
   if)
#)  

-- InitReferenceUserData: Descriptor --
(# 
do
   &Type[]->DataType[];
   isNone.init;
   (if dataType## <= IDObject## then
       IDUserDataAttributes+1->IDUserDataAttributes->attributeId;
       (if userDataVerbose then
           'Initialising IDObject reference user data for id: '->puttext;
           id->putint;
           ' ;attributeID: '->puttext;
           attributeID->putint;
           newline
       if)
    else
       INNER Init;
       (if not attrIDalreadyInit then
           UserDataAttributes+1->UserDataAttributes->attributeId;
           (if userDataVerbose then
               'Initialising (other) reference user data for id: '->puttext;
               id->putint;
               ' ;attributeID: '->puttext;
               attributeID->putint;
               newline
           if)
       if)
   if);
   (if dataElement[] <> none then
       (if userDataVerbose then
           'Init: dataElement was not none. Writing user data!'->putline
       if);
       dataElement[]->WriteUserData
   if)
#)  

-- WriteIntegerUserData: Descriptor --
(# 
do
   (if (ID <> 0) and (attributeID <> 0) then
       (Id,attributeId,@@ integerData,4)->UI.UDWriteType->ok;
       (if ok then
           (if userDataVerbose then
               'Write integer data: '->puttext;
               integerData->putint;
               ' succeed'->putline
           if)
        else
           (if userDataVerbose then 'Write integer data fail'->putline if)
       if)
   if)
#)  

-- ReadIntegerUserData: Descriptor --
(# 
do
   (if ID <> 0 then
       (Id,attributeId,@@ integerData)->UI.UDReadType->ok;
       (if ok then
           (if userDataVerbose then 'Read integer data succeed'->putline if); 
        else
           (if userDataVerbose then 'Read integer data fail'->putline if)
       if)
   if)
#)  

-- InitIntegerUserData: Descriptor --
(# 
do
   INNER Init;
   (if not specialData then
       UserDataAttributes+1->UserDataAttributes->attributeId;
       (if userDataVerbose then
           'Initialising integer user data for id='->puttext;
           id->putint;
           ' ;attributeID: '->puttext;
           attributeID->putint;
           newline
       if)
   if);
   (if IntegerData <> 0 then IntegerData->WriteUserData if)
#)  

-- WriteBooleanUserData: Descriptor --
(# 
do
   (if (ID <> 0) and (attributeID <> 0) then
       (if BooleanData then 1->integerData else 0->integerData if);
       (Id,attributeId,@@ integerData,4)->UI.UDWriteType->ok;
       (if ok then
           (if userDataVerbose then
               'Write boolean data: '->puttext;
               integerData->putint;
               ' succeed'->putline
           if)
        else
           (if userDataVerbose then 'Write boolean data fail'->putline if)
       if)
   if)
#)  

-- ReadBooleanUserData: Descriptor --
(# 
do
   (if ID <> 0 then
       (Id,attributeId,@@ integerData)->UI.UDReadType->ok;
       (if integerData = 1 then
           true->BooleanData
        else
           (if integerData = 0 then false->BooleanData if)
       if);
       (if ok then
           (if userDataVerbose then 'Read Boolean data succeed'->putline if); 
        else
           (if userDataVerbose then 'Read Boolean data fail'->putline if)
       if)
   if)
#)  

-- InitBooleanUserData: Descriptor --
(# 
do
   INNER Init;
   (if not specialData then
       UserDataAttributes+1->UserDataAttributes->attributeId;
       (if userDataVerbose then
           'Initialising Boolean user data for id='->puttext;
           id->putint;
           ' ;attributeID: '->puttext;
           attributeID->putint;
           newline
       if)
   if);
   (if BooleanData <> false then BooleanData->WriteUserData if)
#)  

-- UserDataInit: Descriptor --
(# 
do
   (if userDataVerbose then
       'Initialising user data for id='->puttext; id->putint; newline
   if);
   (Id,20000,@@ Type,4)->UI.UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'User data initialization succeed'->putline
       if)
    else
       (if userDataVerbose then 'User data initialization fail'->putline if)
   if);
   
#)  

-- updateUserDataIDs: Descriptor --
(# oldIDUserdataAttributes: @integer; ok: @Boolean
do
   theObjectList.scan
     (# 
     do
        IDUserDataStart->rangeStart;
        IDUserDataEnd->rangeEnd;
        (current.ID,IDUserDataEnd-1,@@ oldIDUserDataAttributes)->UI.UDReadType
          ->ok;
        (IDUserDataStart,oldIDUserDataAttributes,current.ID)->update;
        current[]->myCurrent[];
        INNER updateUserDataIDs
     #)
#)  

-- designenvDoUpdate: Descriptor --
(# 
do
   (theID,rangeEnd,@@ count)->UI.UDReadType->ok;
   (if ok then
       count-RangeStart->count;
       (if userDataVerbose then
           'FindRange ok: '->puttext; count->putint; newline
       if);
       (if count = 0 then
           (if oldCount <> 0 then
               oldCount-RangeStart->count;
               (if userDataVerbose then
                   'Trying oldCount: '->puttext; count->putint; newline
               if)
           if)
       if);
       (for i: count repeat
         (theID,UDStart+i,@@ oldID)->UI.UDReadType->ok;
         (if userDataVerbose then
             'On current.ID: '->puttext;
             theID->putint;
             ' for attributeID: '->puttext;
             UDStart+i->putint;
             
         if);
         (if ok then
             (if oldID <> 0 then
                 oldID->UserDataIDMap.getID->newID;
                 (if userDataVerbose then
                     ' updating oldID='->puttext;
                     oldID->putint;
                     ' to newID='->puttext;
                     newID->putint;
                     newline
                 if);
                 (theID,UDStart+i,@@ newID,4)->UI.UDWriteType->ok;
                 (if not ok then
                     (if userDataVerbose then 'Write new ID fail'->putline if)
                 if)
              else
                 (if userDataVerbose then 'oldID was 0!'->putline if)
             if)
          else
             (if userDataVerbose then 'Read old ID fail!'->putline if)
         if)
       for)
    else
       (if userDataVerbose then
           'ID: '->puttext;
           theID->putint;
           ' User data FindRange fail: '->puttext;
           rangeStart->putint;
           ' - '->puttext;
           rangeEnd->putint;
           newline
       if)
   if)
#)  

-- UserDataIDMapPutID: DoPart --
do
   (if userDataVerbose then
       'Mapping UserdataID='->puttext;
       UserDataID->putint;
       ' to ID='->puttext;
       ID->putint;
       newline
   if);
   (if UserDataID <> 0 then
       (if UserDataID > private.impl.range then
           UserDataID+private.impl.range->private.impl.extend
       if);
       ID->private.impl[UserDataID]
    else
       (if ID > private.impl.range then
           ID+private.impl.range->private.impl.extend
       if);
       ID->private.impl[ID] (*newly created object: ID=UserDataID.*)
   if)  

-- UserDataIDMapGetID: DoPart --
do private.impl[oldID]->newID  

-- UserDataIDMap: Descriptor --
(# impl: [1000] @Integer #)  

-- getNodeType: Descriptor --
(# 
do
   (Id,20000,@@ Type)->UI.UDReadType->ok;
   (if ok then
       (if userDataVerbose then 'Read node type data succeed'->putline if)
    else
       (if userDataVerbose then 'Read node type data fail'->putline if)
   if)
#)  

-- readTextUserData: DoPart --
do
     (# textSize: ^integerRef; TextData: [0] @char; ok: @boolean
     do
        &integerRef[]->textSize[];
        (ID,type,textSize[])->UI.UDTypeSize->ok;
        (if ok then
            (if textSize > TextData.range then
                textSize+1->TextData.extend
            if);
            (ID,type,@@ TextData[1])->UI.UDReadType->ok;
            (if ok then
                &text[]->t[]; (for i: textSize repeat TextData[i]->t.put for)
            if)
        if)
     #)  

-- writeTextUserData: DoPart --
do
   (if t[] <> none then
       t.length->l; (ID,type,@@ t.T[1],l)->UI.UDWriteType
   if)  

-- DocumentReadIntegerUserData: DoPart --
do (ID,type,@@ i)->UI.UDReadType  

-- DocumentWriteIntegerUserData: DoPart --
do (ID,type,@@ i,4)->UI.UDWriteType  

-- deleteUserDataType: DoPart --
do (ID,type)->UI.UDDeleteType  

