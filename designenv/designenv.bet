ORIGIN '~beta/designlib/v2.0/designlib';
BODY 'private/designobjectbody'
     'private/menubody'
     'private/callbackbody'
     'private/pagebody'
     'private/documentbody'
     'private/userdatabody';
INCLUDE 'private/designlist'
        '~beta/containers/v1.4/list';
-- LIB: Attributes --
designenv: designlib
(* DesignEnv: Object-oriented interface and environment for
 * Design/OA
 *)
  (#
     <<SLOT DesignEnvAttributes:Attributes>>;
     onInit:< Object;
     (* called after Design/OA is initialized: to set up e.g. menus *)
     DesignOAInit:< (#  do (* DocFileMenu.init *) ; INNER #);
     (* make the document menu avaliable *)
     theDocument: ^Document;
     (* Refers to the current and ONLY document in the
      * application *)
     DesignDocument:< Document
     (* Standard design document.
      * A DesignDocument is by default created when the user makes a new document
      * from the new or open menu
      *)
       (#
          onInit::< (* make all the standard Design/OA menus *) 
            (# 
            do
               DocEditMenu.init;
               DocCreateMenu.init;
               DocMakeupMenu.init;
               DocPageMenu.init;
               DocGroupMenu.init;
               DocTextMenu.init;
               DocAlignMenu.init;
               INNER
            #);
          
       #);
     Document:
       (#
          New:<
          (* call to create a new document. Same as hitting New item in File menu *)
          (#  do <<SLOT NewDocument:Descriptor>>; INNER #);
          (* callback *)
          onInit:<
            (# newPage: ^Page; 
            do
               INNER ;
               (* set up document dependent menus; also Design/OA menus *)
               <<SLOT CheckDesignOAMenus:Descriptor>>;
               
            exit newPage[]
            #);
          Close:< Object;
          docID: (* returns the id of this document *)
            (# i: @Integer do <<SLOT DocumentID:Descriptor>> exit i #);
          Modified:<
          (* marks this document as modified: it will be saved *)
            (# b: @Boolean
            enter b
            do <<SLOT DocModified:Descriptor>>; INNER
            #);
          UserDataIDMap:
            @<<SLOT UserDataIDMap:Descriptor>>
          (*toby 31-10-94:
           Map from saved ID's to corresp. new ID's (on reopen).*) ;
          updateUserDataIDs:<
            (#
               rangeStart: @integer;
               rangeEnd: @integer;
               count: @integer;
               ok: @boolean;
               oldID,newID,IDdata: @integer;
               update:
                 (# UDStart,oldCount,theID: @integer
                 enter (UDStart,oldCount,theID)
                 do <<SLOT designenvDoUpdate:Descriptor>>; 
                 #);
               myCurrent: ^IDObject
            do
               <<SLOT updateUserDataIDs:Descriptor>>
            #);
          UserDataStart: (#  exit 1 #);
          IDUserDataStart: (#  exit 1000 #);
          IDUserDataEnd: (#  exit 4000 #);
          theObjectList: @ObjectList;
          (* list containing all objects on this document:
           * e.g pages, nodes, connectors etc.
           *)
          CurrentPage: @ (* sets or gets the current page in this document *)
            (#
               p: ^Page;
               SetPage: (#  enter p[] do <<SLOT SetPage:Descriptor>> #);
               GetPage:
                 (# pid: @Integer
                 do <<SLOT GetPage:Descriptor>>
                 exit p[]
                 #);
               
            enter SetPage
            exit GetPage
            #);
          (* Not yet implemented *)
          NewPageWithFlags: (#  #);
          PortNodesToPage: (#  #);
          GetPages:<
            (# pageList: ^ObjectList
            do <<SLOT GetPages:Descriptor>>; INNER
            exit pageList[]
            #);
          MaxGroup: (#  #);
          (******************** PAGE **************************)
          DesignPage:< Page;
          (* default design page: the page that is created when user
           *  hits new inFile or Page menu 
           *)
          nextPageNo: @ (# no: @integer do no+1->no exit no #);
          Page: IDObject
          (* Page is an IDObject: it has a Design/OA ID to be used in theObjectList *)
            (#
               New:< (* create a new page (init is automatically called) *)
                 (#  do <<SLOT NewPage:Descriptor>>; INNER #);
               PositionNew:<
                 (# x,y,w,h: @Integer; 
                 enter (x,y,w,h)
                 do
                    <<SLOT PositionNewPage:Descriptor>>;
                    INNER ;
                    
                 #);
               InvisibleNew:<
                 (#  do <<SLOT InvisibleNewPage:Descriptor>>; INNER #);
               Close:<
               (* closes this page *)
                 (#  do <<SLOT ClosePage:Descriptor>>; INNER #);
               IsOpen:<
               (* returns true if this page is open *)
                 (# res: @Boolean
                 do <<SLOT IsOpen:Descriptor>>; INNER
                 exit res
                 #);
               Activate:<
               (* activate this page, i.e. activate the page dependent menus *)
                (#  do <<SLOT PageActivateBody:Descriptor>>; INNER #);
               Deactivate:<
               (* deactivate this page *)
                 (#  do <<SLOT PageDeactivateBody:Descriptor>>; INNER #);
               Redraw:<
               (* redraws entire page *)
                 (#  do <<SLOT RedrawPage:Descriptor>>; INNER ;  #);
               CleanUp:<
               (* deletes all objects on this page *)
                 (#  do <<SLOT CleanUpPage:Descriptor>>; INNER #);
               Scroll:<
               (* Scrolls page so that (xtop,ytop) is 
                * at the upper left hand coner of the window 
                *)
                 (# xtop,ytop: @Integer; 
                 enter (xtop,ytop)
                 do <<SLOT ScrollPage:Descriptor>>; INNER ; 
                 #);
               (* VISUAL ATTRIBUTES *)
               Visible:
                 (#
                    SetVisible:
                      (# v: @boolean
                      enter v
                      do <<SLOT SetVisible:Descriptor>>
                      #);
                    GetVisible:
                      (# v: @boolean
                      do
                         <<SLOT GetVisible:Descriptor>>
                      exit v
                      #);
                    
                 enter SetVisible
                 exit GetVisible
                 #);
               PageTitle:
                 (#
                    SetPageTitle:
                      (# t: @Text
                      enter t
                      do <<SLOT SetPageTitle:Descriptor>>
                      #);
                    GetPageTitle:
                      (# t: @Text
                      do
                         <<SLOT GetPageTitle:Descriptor>>
                      exit t
                      #);
                    
                 enter SetPageTitle
                 exit GetpageTitle
                 #);
               PageNo:
                 (#
                    SetPageNo:
                      (# no: @integer
                      enter no
                      do <<SLOT SetPageNo:Descriptor>>
                      #);
                    GetPageNo:
                      (# no: @integer
                      do
                         <<SLOT GetPageNo:Descriptor>>
                      exit no
                      #);
                    
                 enter SetPageNo
                 exit GetpageNo
                 #);
               BorderVisible:
                 (#
                    SetBorder:
                      (# b: @Boolean
                      enter b
                      do <<SLOT SetBorder:Descriptor>>
                      #);
                    GetBorder:
                      (# b: @Boolean
                      do
                         <<SLOT GetBorder:Descriptor>>
                      exit b
                      #);
                    
                 enter SetBorder
                 exit GetBorder
                 #);
               (*** COORDINATES ***)
               Center:
                 (#
                    x,y: @Integer;
                    GetCenter:
                      (# 
                      do <<SLOT PageGetCenter:Descriptor>>
                      exit (x,y)
                      #);
                    SetCenter:
                      (# 
                      enter (x,y)
                      do
                         <<SLOT PageSetCenter:Descriptor>>
                      #);
                    
                 enter SetCenter
                 exit GetCenter
                 #);
               Geometry:
                 (#
                    x,y,w,h: @Integer;
                    SetGeometry:
                      (# 
                      enter (x,y,w,h)
                      do <<SLOT PageSetGeometry:Descriptor>>
                      #);
                    GetGeometry:
                      (# 
                      do
                         <<SLOT PageGetGeometry:Descriptor>>
                      exit (x,y,w,h)
                      #);
                    
                 enter SetGeometry
                 exit GetGeometry
                 #);
               (****** SETTING AND GETTING OBJECTS **********)
               CurrentObject:
               (* sets or gets the current node or connector on this page *)
                 (#
                    autoPan: @Boolean;
                    theObject: ^DesignObject;
                    GetObject:
                      (# 
                      do <<SLOT GetDesignObject:Descriptor>>
                      exit theObject[]
                      #);
                    SetObject:
                      (# 
                      enter theObject[]
                      do
                         <<SLOT SetDesignObject:Descriptor>>
                      #);
                    
                 enter SetObject
                 do INNER ; <<SLOT SetObjectAutoPan:Descriptor>>
                 exit GetObject
                 #);
               CurrentGroup:
               (* sets og gets the current group on this page *)
                 (#
                    GetGroup:
                      (# theList: ^ObjectList; 
                      do <<SLOT GetDesignGroup:Descriptor>>; 
                      exit theList[]
                      #);
                    SetGroup:
                      (#
                         theList:
                           ^ObjectList;
                         
                      enter theList[]
                      do
                         <<SLOT SetDesignGroup:Descriptor>>;
                         
                      #)
                 enter SetGroup
                 exit GetGroup
                 #);
               GetNodes: (* returns all nodes on this page *)
                 (# theNodes: ^ObjectList
                 do <<SLOT GetNodes:Descriptor>>
                 exit theNodes[]
                 #);
               GetConnectors:
               (* returns all connectors on this page *)
                 (# theList: ^ObjectList
                 do <<SLOT PageGetConnectors:Descriptor>>
                 exit theList[]
                 #);
               GetInternalConnectors:
               (* returns all connectors between the nodes
                * in theNodeList *)
                 (# theNodeList,theConnList: ^ObjectList; 
                 enter theNodeList[]
                 do <<SLOT GetInternalConnectors:Descriptor>>; INNER
                 exit theConnList[]
                 #);
               GetParent:
                 (# p: ^Page
                 do
                    <<SLOT PageGetParent:Descriptor>>
                 exit p[]
                 #);
               AttachToNode:
                 (# theNode: ^Node; matchNodes,repNodes: ^ObjectList; 
                 enter (theNode[],matchNodes[],repNodes[])
                 do <<SLOT PageAttachToNode:Descriptor>>
                 #);
               Coarsen:
               (* perform a coarse on this page *)
                 (#
                    theNodeList: ^ObjectList;
                    theNode: ^Node;
                    subPage: ^Page;
                    
                 enter (theNodeList[],theNode[])
                 do <<SLOT Coarsen:Descriptor>>
                 exit subPage[]
                 #);
               (* Cross connectors for coarsening pages *)
               CrossConnector: IDObject
                 (#
                    conn: ^Connector;
                    end1: @Boolean;
                    exNode: ^Node;
                    inNode: ^Node;
                    
                 #);
               CrossConnectorList: ObjectList
                 (# element::< CrossConnector #);
               PageCallBacks:<
                 (#
                    specialNode: @Boolean;
                    MakeDesignObject:<
                    (* make an object of type design tells us.
                     toby 25-10-94: declared virtual *)
                      (#
                         ID: @Integer;
                         theObject: ^DesignObject;
                         regions: [0] @Integer;
                         count: @ShortRef;
                         list: @IntegerRef;
                         specialNode: @Boolean;
                         
                      enter ID
                      do <<SLOT MakeDesignObject:Descriptor>>
                      exit theObject[]
                      #);
                    MakeObjectsFromList:
                      (#
                         list: [0] @Integer;
                         
                      enter list
                      <<SLOT MakeObjectsFromList:DoPart>>
                      #);
                    MakeDescObject:
                    (* make an object of type designObjectDesc *)
                      (# theObject: ^DesignObject; theID: @Integer; 
                      enter theID
                      <<SLOT MakeDescObject:DoPart>>
                      exit theObject[]
                      #);
                    MakeCoarse:
                    (* called when designOA has made a coarsening *)
                      (#
                         theNode: ^Node;
                         nodeList,connList: ^ObjectList;
                         crossList: ^CrossConnectorList;
                         
                      enter (theNode[],nodeList[],connList[],crossList[])
                      <<SLOT MakeCoarse:DoPart>>
                      #);
                    
                 #);
               PageCallBack: @PageCallBacks (*toby 25-10-94toby 25-10-94*) ;
               (*** PAGE CALLBACK ***)
               (* called automatically when the user does the corresponding action 
                * in the design application
                *)
               (* Private callback procedures *)
               onInit:<
               (* to initialize a page DesignOA already have created 
                * never called from user program; use new instead
                *)
                 (# 
                 enter ID
                 do
                    <<SLOT InitPage:Descriptor>>;
                    INNER ;
                    <<SLOT PostInitpage:Descriptor>>;
                    
                 #);
               onReadDiagram:< (* called when we read in a page from disk *)
                 (#  do <<SLOT PageReadDiagram:Descriptor>> #);
               getNodeType:
                 (#
                    ID: @integer;
                    Type: @integer;
                    ok: @Boolean
                 enter ID
                 do
                    <<SLOT getNodeType:Descriptor>>
                 exit Type
                 #);
               (************************ OBJECTS **************************)
               DesignObject: IDObject
               (* abstract superpattern for all objects on
                * design page *)
                 (#
                    DesignAttributes: @<<SLOT DesignAttributes:Descriptor>>;
                    UserDataID:
                      @IntegerUserData
                    (*toby 28-10-94:
                     ID is saved to make it possible to
                     update references when the node is given a
                     new ID.*) ;
                    UserDataAttributes: @integer
                    (*toby 28-10-94:
                     keeps track of the number of attributes
                     made persistent in this DesignObject
                     (except: see below!).*) ;
                    IDUserDataAttributes: @integerUserData
                      (#
                         init::< 
                           (# 
                           do IDUserDataEnd->attributeID; true->specialData
                           #)
                      #);
                    oldIDUserDataAttributes: @integerUserData
                      (#
                         init::< 
                           (# 
                           do IDUserDataEnd-1->attributeID; true->specialData
                           #)
                      #);
                    UserData:
                      (#
                         attributeId: @Integer;
                         WriteUserData:<
                           (# ok: @Boolean
                           do <<SLOT WriteUserData:Descriptor>>
                           #);
                         ReadUserData:<
                           (# ok: @Boolean; 
                           do
                              <<SLOT ReadUserData:Descriptor>>
                           #);
                         Init:< (#  do INNER #)
                      enter WriteUserData
                      exit ReadUserData
                      #);
                    ReferenceUserData: UserData
                      (#
                         Type:< Object;
                         dataElement: ^Type;
                         dataType: ^Type
                         (*only used for recognizing the type of the dataElement.
                          Initialized in Init.*) ;
                         isNone: @BooleanUserData;
                         WriteUserData::< 
                           (#
                              theIDObject: ^IDObject;
                              theText: ^Text;
                              IDdata: @integer
                           enter dataElement[]
                           do <<SLOT WriteReferenceUserData:Descriptor>>
                           #);
                         ReadUserData::< 
                           (#
                              IDdata: @integer;
                              TextData: [32] @char;
                              theText: ^Text;
                              textSize: ^integerRef
                           do <<SLOT ReadReferenceUserData:Descriptor>>
                           exit
                           dataElement[]
                           #);
                         getID:<
                           (# theID: @Integer
                           do <<SLOT getIDReferenceUserData:Descriptor>>; 
                           exit theID
                           #);
                         Init::< 
                           (# attrIDalreadyInit: @Boolean
                           do <<SLOT InitReferenceUserData:Descriptor>>
                           #)
                      #);
                    IntegerUserData:
                     UserData
                      (#
                         Integerdata: @integer;
                         WriteUserData::< 
                           (# ok: @Boolean
                           enter integerData
                           do <<SLOT WriteIntegerUserData:Descriptor>>
                           #);
                         ReadUserData::<
                          
                           (# ok: @Boolean
                           do <<SLOT ReadIntegerUserData:Descriptor>>
                           exit
                           integerdata
                           #);
                         Init::< 
                           (# specialData: @Boolean
                           do <<SLOT InitIntegerUserData:Descriptor>>
                           #)
                      #);
                    BooleanUserData:
                     UserData
                      (#
                         BooleanData: @boolean;
                         IntegerData: @integer;
                         WriteUserData::< 
                           (# ok: @Boolean
                           enter BooleanData
                           do <<SLOT WriteBooleanUserData:Descriptor>>
                           #);
                         ReadUserData::<
                          
                           (# ok: @Boolean
                           do <<SLOT ReadBooleanUserData:Descriptor>>
                           exit
                           Booleandata
                           #);
                         Init::< 
                           (# specialData: @Boolean
                           do <<SLOT InitBooleanUserData:Descriptor>>
                           #)
                      #);
                    UserDataInit:<
                      (#
                         Type: @integer;
                         ok: @Boolean
                      enter Type
                      do
                         <<SLOT UserDataInit:Descriptor>>
                      #);
                    TypeCheck:
                      (#
                         count: @integer;
                         type: @integer;
                         ptr: ^integerRef;
                         size1: ^integerRef;
                         size2: ^integerRef;
                         ok: @boolean;
                         listPP: ^integerRef;
                         sizeP: ^integerRef;
                         
                      do (*kald af UDCountAllTypes*)
                         'Test  UDCountAllTypes'->putLine;
                         id->UDCountAllTypes->count;
                         'Count All Types suceed'->putline;
                         count->putint;
                         ' '->putline;
                         'Test  UDFindAllTypes'->putLine;
                         &integerRef[]->listPP[];
                         &integerRef[]->sizeP[];
                         (id,listPP[],sizeP[])->UDFindAllTypes->ok;
                         (if ok
                          // TRUE then
                             'Find all Types succeed'->putline;
                             'ListPP'->putline;
                             listPP->putint;
                             ' '->putline;
                             'sizeP'->putline;
                             sizeP->putint;
                             ' '->putline;
                             
                         if);
                         'Test  UDTypeSize'->putLine;
                         200->type;
                         &integerRef[]->ptr[];
                         &integerRef[]->size1[];
                         (id,type,size1[])->UDTypeSize->ok;
                         (if ok
                          // TRUE then
                             'TypeSize succeed'->putline;
                             'Size'->putline;
                             size1->putint;
                             ' '->putline;
                             
                         if);
                         'Test  UDTypePointer'->putLine;
                         &integerRef[]->size2[];
                         (id,type,ptr[],size2[])->UDTypePointer->ok;
                         (if ok
                          // TRUE then
                             'Get Pointer suceed'->putline;
                             'Pointer'->putline;
                             ptr->putint;
                             ' '->putline;
                             'size'->putline;
                             size2->putint;
                             ' '->putline;
                             
                         if);
                         
                      #);
                    FindRangeUserdata:
                      (#
                         rangeStart: @integer;
                         rangeEnd: @integer;
                         rangeH: ^integerRef;
                         count: ^shortRef;
                         ok: @boolean;
                         
                      do (*kald af UDFindRange*)
                         'Test  UDFindRange'->putLine;
                         &integerRef[]->rangeH[];
                         &shortRef[]->count[];
                         100->rangeStart;
                         300->rangeEnd;
                         (id,rangeStart,rangeEnd,count[],rangeH[])->UDFindRange
                           ->ok;
                         (if ok
                          // TRUE then
                             'Find Range succeed'->putline;
                             'rangeStart'->putline;
                             rangeStart->putint;
                             ' '->putline;
                             'rangeEnd'->putline;
                             rangeEnd->putint;
                             ' '->putline;
                             'rangeH'->putline;
                             rangeH->putint;
                             ' '->putline;
                             'count'->putline;
                             count->putint;
                             ' '->putline;
                             
                          // false then
                             'Find Range not succeed'->putline; 
                         if);
                         
                      #);
                    DeleteUserData:
                      (# type: @integer; ok: @boolean; 
                      do
                         'Test Delete'->putLine;
                         200->type;
                         (id,type)->UDDeleteType->ok;
                         (if ok
                          // TRUE then 'Delete data suceed'->putline; 
                         if);
                         
                      #);
                    New:<
                    (* to create a DesignObject; calls init after creation *)
                      (#  <<SLOT NewObject:DoPart>> #);
                    InteractiveNew:<
                    (* Let the user create a new object by changing the cursor to
                     * curs and by showing msg in status bar
                     *)
                      (#
                         msg: @Text;
                         curs: @Integer;
                         CursorFormat:< (#  do 0->curs; INNER #)
                      enter msg
                      do <<SLOT ObjectInteractiveNew:Descriptor>>; 
                      #);
                    Move:<
                    (* moves this designobject to the specified point *)
                      (# x,y: @Integer
                      enter (x,y)
                      do <<SLOT Move:Descriptor>>; INNER
                      #);
                    Delete:<
                    (* deletes this designobject on this page *)
                      (#  do <<SLOT Deleteobject:Descriptor>>; INNER #);
                    isRegion: @Boolean;
                    (* true if the node is a region *)
                    CreateRegion:
                    (* convert this designobject to a region of 'parent' *)
                      (# parent: ^DesignObject; 
                      enter parent[]
                      do <<SLOT ObjectCreateRegion:Descriptor>>
                      #);
                    UnMakeRegion:
                      (# 
                      do
                         <<SLOT ObjectUnMakeRegion:Descriptor>>
                      #);
                    SetRegionType:
                      (# type: @Integer
                      enter type
                      do <<SLOT SetRegionType:Descriptor>>; 
                      #);
                    Redraw:<
                    (* redraws THIS(DesignObject) *)
                      (# 
                      do <<SLOT RedrawDesignObject:Descriptor>>; INNER
                      #);
                    (* GEOMETRIC PROPERTIES of OBJECTS *)
                    Center:
                      (#
                         x,y: @Integer;
                         GetCenter: (* returns center of this designobject *)
                           (# 
                           do <<SLOT ObjectGetCenter:Descriptor>>
                           exit (x,y)
                           #);
                         SetCenter:
                         (* sets center of this designobject *)
                           (# 
                           enter (x,y)
                           do <<SLOT ObjectSetCenter:Descriptor>>
                           #);
                         
                      enter SetCenter
                      exit GetCenter
                      #);
                    Size:
                      (#
                         w,h: @Integer;
                         GetSize:
                         (* returns size of this designobject *)
                           (# 
                           do <<SLOT ObjectGetSize:Descriptor>>
                           exit (w,h)
                           #);
                         SetSize:
                         (* sets size of this designobject *)
                           (# 
                           enter (w,h)
                           do <<SLOT ObjectSetSize:Descriptor>>
                           #);
                         
                      enter SetSize
                      exit GetSize
                      #);
                    Geometry:
                    (* sets or gets the center and the size of this designobject*)
                      (#
                         x,y,w,h: @Integer;
                         SetGeometry:
                           (# 
                           enter (x,y,w,h)
                           do <<SLOT ObjectSetGeometry:Descriptor>>
                           #);
                         GetGeometry:
                           (# 
                           do
                              <<SLOT ObjectGetGeometry:Descriptor>>
                           exit (x,y,w,h)
                           #);
                         
                      enter SetGeometry
                      exit GetGeometry
                      #);
                    Selectable: @
                    (*sets/gets the selectable property of this designobject*)
                      (#
                         s: @Boolean;
                         SetSelectable:
                           (# 
                           enter s
                           do <<SLOT ObjectSetSelectable:Descriptor>>
                           #);
                         
                      enter
                      SetSelectable
                      exit s
                      #);
                    (* VISUAL PROPERTIES of OBJECTS *)
                    LineThickNess:
                      (#
                         thick: @Integer;
                         SetThickNess:
                           (# 
                           enter thick
                           do <<SLOT SetLineThickness:Descriptor>>
                           #);
                         GetThickness:
                           (# 
                           do
                              <<SLOT GetLineThickness:Descriptor>>
                           exit thick
                           #);
                         
                      enter SetThickness
                      exit GetThickness
                      #);
                    LineType:
                      (#
                         line: @Integer;
                         SetLineType:
                           (# 
                           enter line
                           do <<SLOT SetLineType:Descriptor>>
                           #);
                         GetLineType:
                           (# 
                           do
                              <<SLOT GetLineType:Descriptor>>
                           exit line
                           #);
                         
                      enter SetLineType
                      exit GetLineType
                      #);
                    FillType:
                      (#
                         fill: @Integer;
                         SetFillType:
                           (# 
                           enter fill
                           do <<SLOT SetFillType:Descriptor>>
                           #);
                         GetFillType:
                           (# 
                           do
                              <<SLOT GetFillType:Descriptor>>
                           exit fill
                           #);
                         
                      enter SetFillType
                      exit GetFillType
                      #);
                    BorderVisible:
                      (#
                         b: @Boolean;
                         SetBorderVisible:
                           (# 
                           enter b
                           do <<SLOT SetBorderVisible:Descriptor>>
                           #);
                         GetBorderVisible:
                           (# 
                           do
                              <<SLOT GetBorderVisible:Descriptor>>
                           exit b
                           #);
                         
                      enter SetBorderVisible
                      exit GetBorderVisible
                      #);
                    IndicateSelection:
                      (# on: @boolean; 
                      enter on
                      do <<SLOT IndicateSelection:Descriptor>>; 
                      #);
                    BringForward:
                      (#
                         target:
                           ^DesignObject
                      enter target[]
                      do <<SLOT BringForward:Descriptor>>
                      #);
                    (* QUERY OPERATIONS on OBJECTS *)
                    GetParent: (* returns parent of this designobject *)
                      (# p: ^Object; 
                      do <<SLOT ObjectGetParent:Descriptor>>
                      exit p[]
                      #);
                    GetTopParent: (* returns top parent of this designobject *)
                      (# p: ^DesignObject; 
                      do <<SLOT ObjectGetTopParent:Descriptor>>
                      exit p[]
                      #);
                    GetSubPage:
                    (* returns subpage of this designobject *)
                      (# p: ^Page; 
                      do <<SLOT ObjectGetSubPage:Descriptor>>
                      exit p[]
                      #);
                    GetRegionList:
                    (* returns region list of this designobject *)
                      (# theList: ^ObjectList; 
                      do <<SLOT GetRegionList:Descriptor>>
                      exit theList[]
                      #);
                    GetConnectors:
                      (#
                         theNode: ^Node;
                         theList: ^ObjectList;
                         
                      do
                         <<SLOT ObjectGetConnectors:Descriptor>>
                      exit theList[]
                      #);
                    GetObjectsConnected:
                      (# theNode: ^Node; inList,outList: ^ObjectList; 
                      enter theNode[]
                      do <<SLOT GetObjectsConnected:Descriptor>>
                      exit
                      (inList[],
                       outList[])
                      #);
                    FitToText:
                      (# 
                      do
                         <<SLOT ObjectFitToText:Descriptor>>
                      #);
                    (* TEXT HANDLING of OBJECTS *)
                    theText: @DesignText;
                    DesignText:<
                      (#
                         private: @<<SLOT DesignTextPrivate:Descriptor>>;
                         Set:<
                           (# t: @Text; 
                           enter t
                           do
                              INNER ;
                              <<SLOT DesignTextSet:Descriptor>>
                           #);
                         Get:<
                           (# t: @Text; 
                           do <<SLOT DesignTextGet:Descriptor>>; INNER
                           exit t
                           #);
                         Clear:<
                           (# 
                           do
                              <<SLOT DesignTextClear:Descriptor>>;
                              INNER
                           #);
                         Length:<
                           (# l: @Integer; 
                           do INNER ; <<SLOT DesignTextLength:Descriptor>>
                           exit l
                           #);
                         Parent:<
                           (#
                              p:
                                ^DesignObject;
                              
                           do INNER ; <<SLOT DesignTextParent:Descriptor>>
                           exit p[]
                           #);
                         IsModeOn:<
                           (#
                              b: @Boolean; 
                           do
                              INNER ;
                              <<SLOT DesignTextIsModeOn:Descriptor>>
                           exit b
                           #);
                         ModeOn:<
                           (# OKToEnter: @Boolean
                           do
                              true->OKToEnter;
                              INNER ;
                              <<SLOT DesignTextModeOn:Descriptor>>
                           #);
                         ModeOff:<
                           (#
                              OKtoExit:
                                @boolean
                           do
                              true->OKtoExit;
                              INNER ;
                              <<SLOT DesignTextModeOff:Descriptor>>
                           #);
                         MaxLineLength:<
                           (#
                              m: @Integer;
                              
                           do
                              INNER ;
                              <<SLOT DesignTextMaxLineLength:Descriptor>>
                           exit m
                           #);
                         Font:<
                           (# f: @Integer; 
                           enter f
                           do INNER ; <<SLOT DesignTextFont:Descriptor>>
                           #);
                         Size:
                           (#
                              s: @Integer;
                              setSize:
                                (# 
                                enter s
                                do
                                   <<SLOT designTextSetSize:Descriptor>>;
                                   
                                #);
                              getSize:
                                (# 
                                do <<SLOT designTextGetSize:Descriptor>>; 
                                exit s
                                #);
                              
                           enter setSize
                           exit getSize
                           #);
                         Style:<
                           (#
                              s: @Integer;
                              
                           enter s
                           do
                              INNER ;
                              <<SLOT DesignTextStyle:Descriptor>>
                           #);
                         Just:<
                           (# j: @Integer; 
                           enter j
                           do INNER ; <<SLOT DesignTextJust:Descriptor>>
                           #);
                         Wrap:<
                           (# b: @Boolean; 
                           enter b
                           do
                              INNER ;
                              <<SLOT DesignTextWrap:Descriptor>>
                           #);
                         GetLength:<
                           (# len: @Integer; 
                           do INNER ; <<SLOT DesignTextGetLength:Descriptor>>
                           exit len
                           #);
                         SetDefaultFont:<
                           (# f: @Integer; 
                           enter f
                           do
                              INNER ;
                              <<SLOT DesignTextSetDefaultFont:Descriptor>>
                           #);
                         SetDefaultJust:<
                           (# j: @Integer; 
                           enter j
                           do
                              INNER ;
                              <<SLOT DesignTextSetDefaultJust:Descriptor>>
                           #);
                         SetDefaultSize:<
                           (# s: @Integer; 
                           enter s
                           do
                              INNER ;
                              <<SLOT DesignTextSetDefaultSize:Descriptor>>
                           #);
                         SetDefaultStyle:<
                           (# s: @Integer; 
                           enter s
                           do
                              INNER ;
                              <<SLOT DesignTexSetDefaultStyle:Descriptor>>
                           #);
                         onTextModeOff:<
                           (#  <<SLOT onTextModeOff:DoPart>> #);
                         
                      #);
                    (************* CALLBACKS ***************)
                    (* the following procedure paterns are called automatically when
                     * the user does the corresponding action in the design application
                     *)
                    onInit:<
                    (* to initialize an already created DesignObject
                     * never called from user program but called
                     * when the user has created one by interaction
                     *)
                      (# 
                      enter id
                      do <<SLOT InitObject:Descriptor>>; INNER
                      #);
                    onRemove:<
                    (* called after the user calls 'Delete' or 
                     * removes the object by pressing CMD-X or <Delete> or <Clear>
                     * never called from user program directly
                     *)
                      (#  do <<SLOT RemoveObject:Descriptor>>; INNER #);
                    onInitRegion:<
                    (* called when this designobject is converted to a region
                     * never called from user program
                     *)
                      (# parent: ^DesignObject; connList: ^ObjectList
                      enter (parent[],connList[])
                      do <<SLOT ObjectInitRegion:Descriptor>>; INNER
                      #);
                    onSelect:< Object;
                    onSize:< Object;
                    onDoubleClick:<
                      (#
                         proceed: @Boolean;
                         
                      do
                         false->proceed;
                         INNER
                      exit proceed
                      #);
                    onDrag:< Object;
                    (* Not yet implemented *)
                    OwnedValue: (#  #);
                    Flags: (#  #);
                    IsValid: (#  #);
                    
                 do INNER ; 
                 #);
               (* end DesignObject *)
               (* In the following all the default design nodes are defined using the
                * strategy:
                * - the node is defined as a simple subpattern of NODE called <subnode>
                * - for each <subnode> a virtual subpattern called Design<subnode> is defined.
                * - When the user creates a <subnode> by using the default create menu of
                * - Design/OA, then it is the corresponding virtual pattern that is used i.e.
                * - Design<subnode>.
                * - By using this strategy it is possible for the user to further bind the
                * - <subnode>, i.e Design<subnode>, and thereby introduce special handling of
                * - these objects without the need of special menus and special objects.
                * - On the other hand it is also possible to define special objects simply by
                * - defining subpatterns of the <subnode> and then make a special create menu.
                *
                * The chosen strategy makes it possible to use both default objects and user
                * defined objects in the same application.
                *)
               (* Shapes for the Node *)
               Rectangle: (#  exit 1 #);
               Ellipse: (#  exit 2 #);
               Polygon: (#  exit 3 #);
               RndRect: (#  exit 4 #);
               Wedge: (#  exit 5 #);
               Picture: (#  exit 6 #);
               DesignNode:< Node;
               Node: DesignObject
               (* the design object node
                * with the property that it can be connected to
                *  another node by a connector 
                *)
                 (#
                    shape: @Integer;
                    NodeAttributes: @<<SLOT NodeAttributes:Descriptor>>;
                    moveable: @Boolean;
                    sizeable:
                      (# b: @Boolean; 
                      enter b
                      do
                         <<SLOT NodeSizeable:Descriptor>>
                      #);
                    New::< 
                      (# x,y,w,h: @integer; doneInInner: @boolean; 
                      enter (x,y,w,h)
                      do INNER ; <<SLOT NodeNew:Descriptor>>; 
                      #);
                    InteractiveNew::< 
                      (# 
                      do <<SLOT NodeInteractiveNew:Descriptor>>; INNER
                      #);
                    Move::< 
                      (# 
                      do
                         <<SLOT NodeMove:Descriptor>>;
                         INNER
                      #);
                    onSize::<  (#  do INNER #);
                    onDrag::< 
                      (#  do <<SLOT NodeDrag:Descriptor>>; INNER #);
                    onInit::< 
                      (# 
                      do
                         <<SLOT NodeInit:Descriptor>>;
                         INNER
                      #);
                    MakePicture: (#  #);
                    ConnSubGraph: (#  #);
                    
                 do INNER ; 
                 #);
               (*  A Node with any shape *)
               GenericNode: Node
                 (#
                    New::<  (#  enter shape do INNER #);
                    InteractiveNew::<  (#  enter shape do INNER #);
                    
                 #);
               DesignRect:< RectNode;
               RectNode: Node
                 (# New::<  (#  do Rectangle->shape; INNER #);  #);
               DesignEllipse:< EllipseNode;
               EllipseNode: Node
                 (# New::<  (#  do Ellipse->shape; INNER #);  #);
               DesignRndRect:< RndRectNode;
               RndRectNode: Node
                 (#
                    New::<  (#  do RndRect->shape; INNER #);
                    Roundness:
                      (#
                         w,h: @Integer;
                         GetRndRectRoundness:
                           (# 
                           do <<SLOT GetRndRectRoundness:Descriptor>>
                           exit (w,h)
                           #);
                         SetRndRectRoundness:
                           (# 
                           enter (w,h)
                           do <<SLOT SetRndRectRoundness:Descriptor>>
                           #)
                      enter
                      SetRndRectRoundness
                      exit GetRndRectRoundness
                      #);
                    
                 #);
               DesignWedge:< WedgeNode;
               WedgeNode: Node
                 (#
                    New::<  (#  do Wedge->shape; INNER #);
                    Angles:
                      (#
                         start,end: @Integer;
                         GetWedgeAngles:
                           (# 
                           do <<SLOT GetWedgeAngles:Descriptor>>
                           exit (start,end)
                           #);
                         SetWedgeAngles:
                           (# 
                           enter (start,end)
                           do
                              <<SLOT SetWedgeAngles:Descriptor>>
                           #)
                      enter SetWedgeAngles
                      exit GetWedgeAngles
                      #);
                    
                 #);
               Poly: Node
                 (#
                    NoOfPoints:<
                      (# no: @Integer; 
                      do <<SLOT PolyNoOfPoints:Descriptor>>; INNER
                      exit no
                      #);
                    Points:<
                      (# p: [0] @Integer; 
                      do
                         <<SLOT PolyPoints:Descriptor>>;
                         INNER
                      exit p
                      #);
                    
                 #);
               DesignPolygon:< PolygonNode;
               PolygonNode: Poly
                 (#
                    New::< 
                      (# points: [0] @Integer; 
                      enter points
                      do <<SLOT NewPolygon:Descriptor>>; INNER
                      #);
                    InteractiveNew::< 
                      (# 
                      do
                         <<SLOT PolygonInteractiveNew:Descriptor>>;
                         INNER
                      #);
                    
                 #);
               DesignRegPoly:< RegPolyNode;
               RegPolyNode: Poly
                 (#
                    New::< 
                      (# points: [0] @Integer; 
                      enter points
                      do <<SLOT NewRegPoly:Descriptor>>; INNER
                      #);
                    InteractiveNew::< 
                      (# 
                      do
                         <<SLOT RegPolyInteractiveNew:Descriptor>>;
                         INNER
                      #);
                    
                 #);
               DesignLine:< PolygonNode;
               LineNode: Node
                 (#
                    New::< 
                      (# x,y: @integer; 
                      enter (x,y)
                      do <<SLOT NewLine:Descriptor>>; INNER
                      #);
                    InteractiveNew::< 
                      (# 
                      do
                         <<SLOT LineInteractiveNew:Descriptor>>;
                         INNER
                      #);
                    
                 #);
               DesignLabel:< LabelNode;
               LabelNode: DesignObject
                 (#
                    New::< 
                      (# txt: @Text; x,y,w,h: @Integer; 
                      enter (x,y,w,h,txt)
                      do <<SLOT NewLabel:Descriptor>>; INNER
                      #);
                    
                 #);
               DesignPicture:< PictureNode;
               PictureNode: Node
                 (#
                    New::<  (#  #);
                    InteractiveNew::<  (#  #);
                    
                 #);
               DesignConnector:< Connector;
               Connector: DesignObject
                 (#
                    VisualAttributes:
                      @<<SLOT ConnVisProps:Descriptor>>;
                    New::< 
                      (# node1,node2: ^Node; 
                      enter (node1[],node2[])
                      do <<SLOT NewConn:Descriptor>>; INNER
                      #);
                    InteractiveNew::< 
                      (# 
                      do
                         <<SLOT ConnInteractiveNew:Descriptor>>;
                         INNER
                      #);
                    GetArrowHead:
                      (# end: @Boolean; type: @Integer; 
                      enter end
                      do <<SLOT ConnGetArrowHead:Descriptor>>
                      exit type
                      #);
                    Orient:
                      (#
                         o: @Integer;
                         SetOrient:
                           (# 
                           enter o
                           do
                              <<SLOT ConnSetOrient:Descriptor>>
                           #);
                         GetOrient:
                           (# 
                           do <<SLOT ConnGetOrient:Descriptor>>
                           exit o
                           #);
                         
                      enter SetOrient
                      exit GetOrient
                      #);
                    Points:
                      (#
                         thePoints: [0]
                         @Integer;
                         SetPoints:
                           (# 
                           enter thePoints
                           do <<SLOT ConnSetPoints:Descriptor>>
                           #);
                         GetPoints:
                           (# 
                           do <<SLOT ConnGetPoints:Descriptor>>
                           exit thePoints
                           #);
                         
                      enter SetPoints
                      exit GetPoints
                      #);
                    HeadWidth:
                      (#
                         w: @Integer;
                         SetHW:
                           (# 
                           enter w
                           do
                              <<SLOT ConnSetHeadW:Descriptor>>
                           #);
                         GetHW:
                           (# 
                           do <<SLOT ConnGetHeadW:Descriptor>>
                           exit w
                           #);
                         
                      enter SetHW
                      exit GetHW
                      #);
                    HeadHeight:
                      (#
                         h: @Integer;
                         SetHH:
                           (# 
                           enter h
                           do
                              <<SLOT ConnSetHeadH:Descriptor>>
                           #);
                         GetHH:
                           (# 
                           do <<SLOT ConnGetHeadH:Descriptor>>
                           exit h
                           #);
                         
                      enter SetHH
                      exit GetHH
                      #);
                    Shape:
                      (#
                         s: @Integer;
                         SetShape:
                           (# 
                           enter s
                           do
                              <<SLOT ConnSetShape:Descriptor>>
                           #);
                         GetShape:
                           (# 
                           do <<SLOT ConnGetShape:Descriptor>>
                           exit s
                           #);
                         
                      enter SetShape
                      exit GetShape
                      #);
                    TextBox:
                      (#
                         w,h: @Integer;
                         SetBox:
                           (# 
                           enter (w,h)
                           do
                              <<SLOT ConnSetBox:Descriptor>>
                           #);
                         GetBox:
                           (# 
                           do <<SLOT ConnGetBox:Descriptor>>
                           exit (w,h)
                           #);
                         
                      enter SetBox
                      exit GetBox
                      #);
                    GetEnds:<
                      (#
                         rgn: @Boolean;
                         node1,node2: ^Node;
                         
                      enter rgn
                      (* true means return region attachment name *)
                      do <<SLOT ConnGetEnds:Descriptor>>; INNER
                      exit (node1[],node2[])
                      #);
                    SetEnds:
                      (#
                         rgn: @Boolean;
                         node1,node2,node1Rgn,
                           node2Rgn: ^Node;
                         
                      enter (node1[],node1Rgn[],node2[],node2Rgn[])
                      do <<SLOT ConnSetEnds:Descriptor>>
                      #);
                    Curvature:
                      (#
                         curv: @Integer;
                         SetCurvature:
                           (# 
                           enter curv
                           do
                              <<SLOT ConnSetCurvature:Descriptor>>
                           #);
                         GetCurvature:
                           (# 
                           do <<SLOT ConnGetCurvature:Descriptor>>
                           exit curv
                           #);
                         
                      enter SetCurvature
                      exit SetCurvature
                      #);
                    GetOtherEnd:
                      (#  #);
                    
                 #);
               DesignObjectDesc:
                 ##DesignObject;
               (* pattern variable describing which
                * designobject is created next time.
                * Set by the create menu
                *)
               (***************** PAGE DEPENDENT MENUS *****************)
               PageMenuBar: @MenuList;
               (* list contaning the page specific menus *)
               (* we need a reference to all the page menus,
                * we can remove them when the page is deactivated,
                * and insert them when the page is activated
                *)
               PageMenu: UserMenu
                 (#
                    init::< 
                      (# 
                      do THIS(PageMenu)[]->PageMenuBar.append; INNER
                      #);
                    
                 #);
               (* Not yet implemented on page *)
               GetRegions: (#  #);
               Attr: (#  #);
               DefaultValues: (#  #);
               MoveNodesToPage: (#  #);
               (*toby 25-10-94toby 25-10-94*)
               
            do INNER ; 
            #);
          (* end page *)
          Palette: Page
            (#
               onInit::< 
                 (#  do <<SLOT PaletteInit:Descriptor>>; INNER #);
               onSelect:<
                 (# theObject: ^DesignObject; 
                 enter theObject[]
                 do INNER
                 #);
               
            #);
          (************ Document dependent menus **************)
          DocEditMenu: @EditMenu;
          EditMenu:< DesignMenu
            (#
               iUndo:< BasicItem;
               iCut:< BasicItem;
               iCopy:< BasicItem;
               iPaste:< BasicItem
                 (#
                    hit::< 
                      (#  do <<SLOT PasteItem:Descriptor>>; INNER #);
                    init::< 
                      (# 
                      do false->PreCall; INNER
                      #);
                    
                 #);
               iClear:< BasicItem;
               iSelect:< BasicItem;
               iShow:< BasicItem;
               iStatus:< BasicItem;
               UndoItem: @iUndo;
               CutItem: @iCut;
               CopyItem: @iCopy;
               PasteItem: @iPaste;
               ClearItem: @iClear;
               SelectItem: @iSelect;
               ShowItem: @iShow;
               StatusItem: @iStatus;
               Init::< 
                 (# 
                 do
                    <<SLOT InitEditMenu:Descriptor>>;
                    INNER
                 #);
               
            #);
          DocCreateMenu: @CreateMenu;
          CreateMenu:< DesignMenu
            (#
               myItem: BasicItem
               (* special item to be used in create menu:
                * provides easy acces to the current page
                *)
                 (#
                    hit::< 
                      (# p: ^Page; 
                      do
                         theDocument.currentpage.p[]->p[];
                         (if theDocument.currentpage.p[] <> none
                          // true then
                             theDocument.currentpage.p[]->p[]; INNER ; 
                          else
                             'CreateMenu hit: NO CURRENT PAGE'->putline; 
                         if);
                         
                      #);
                    
                 #);
               iConn:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignConnector##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iRect:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignRect##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iRndRect:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignRndRect##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iEllipse:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignEllipse##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iPolygon:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignPolygon##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iRegularPolygon:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignRegPoly##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iWedge:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignWedge##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iLine:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignLine##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iLabel:< myItem
                 (#
                    hit::< 
                      (# 
                      do p.DesignLabel##->p.DesignObjectDesc##; INNER
                      #)
                 #);
               iRegion:< BasicItem;
               iUnmakeRegion:< BasicItem;
               iSetAttr:< BasicItem;
               iSetCAttr:< BasicItem;
               iSetWedge:< BasicItem;
               iSetPoly:< BasicItem;
               iAutoPalette:< BasicItem;
               ConnItem: @iConn;
               RectItem: @iRect;
               RndRectItem: @iRndRect;
               EllipseItem: @iEllipse;
               PolygonItem: @iPolygon;
               RegularPolygonItem: @iRegularPolygon;
               WedgeItem: @iWedge;
               LineItem: @iLine;
               LabelItem: @iLabel;
               RegionItem: @iRegion;
               UnmakeRegionItem: @iUnmakeRegion;
               SetAttrItem: @iSetAttr;
               SetCAttrItem: @iSetCAttr;
               SetWedgeItem: @iSetWedge;
               SetPolyItem: @iSetPoly;
               AutoPaletteItem: @iAutoPalette;
               Init::< 
                 (#  do <<SLOT InitCreateMenu:Descriptor>>; INNER #)
            #);
          DocMakeupMenu: @MakeupMenu;
          MakeupMenu:< DesignMenu
            (#
               iSelect:< BasicItem;
               iAdjust:< BasicItem;
               iChangeShape:< BasicItem;
               iDrag:< BasicItem;
               iDisplace:< BasicItem;
               iMoveTo:< BasicItem;
               iHideSubStructure:< BasicItem;
               iShowSubStructure:< BasicItem;
               iForward:< BasicItem;
               iBackward:< BasicItem;
               iToFront:< BasicItem;
               iMergeAttr:< BasicItem;
               iMerge:< BasicItem;
               SelectItem: @iSelect;
               AdjustItem: @iAdjust;
               ChangeShapeItem:
                 @iChangeShape;
               DragItem: @iDrag;
               DisplaceItem: @iDisplace;
               MoveToItem: @iMoveTo;
               HideSubStructureItem:
                 @iHideSubStructure;
               ShowSubStructureItem: @IShowSubStructure;
               ForwardItem: @iForward;
               BackwardItem: @iBackward;
               ToFrontItem: @iToFront;
               MergeAttrItem: @iMergeAttr;
               MergeItem: @iMerge;
               Init::< 
                 (#  do <<SLOT InitMakeUpMenu:Descriptor>>; INNER #);
               
            #);
          DocPageMenu: @PageMenu;
          PageMenu:< DesignMenu
            (#
               iShow:< BasicItem;
               iBlowUp:< BasicItem;
               iReduce:< BasicItem;
               iNew:< BasicItem
                 (#
                    hit::< 
                      (# 
                      do
                         <<SLOT NewPageItem:Descriptor>>;
                         INNER
                      #);
                    init::<  (#  do false->PreCall; INNER #);
                    
                 #);
               iDelete:< BasicItem;
               iClosePage:< BasicItem;
               iChangeFatts:< BasicItem;
               iChild:< BasicItem;
               iParent:< BasicItem;
               iStrTree:< BasicItem;
               iDefault:< BasicItem;
               iCleanUp:< BasicItem;
               ShowItem: @iShow;
               BlowUpItem: @iBlowUp;
               ReduceItem: @iReduce;
               NewItem: @iNew;
               DeleteItem: @iDelete;
               ClosePageItem: @iClosePage;
               ChangeFattsItem: @iChangeFatts;
               ChildItem: @iChild;
               ParentItem: @iParent;
               StrTreeItem: @iStrTree;
               DefaultItem: @iDefault;
               CleanUpItem: @iCleanUp;
               init::<  (#  do <<SLOT InitPageMenu:Descriptor>>; INNER #);
               
            #);
          DocGroupMenu: @GroupMenu;
          GroupMenu:< DesignMenu
            (#
               iEnable:< BasicItem;
               iForm:< BasicItem;
               iSum:< BasicItem;
               iCopyDr:< BasicItem;
               iSpread:< BasicItem;
               iCoarsen:< BasicItem
                 (#
                    init::<  (#  do false->PreCall; INNER #);
                    hit::< 
                      (#  do <<SLOT CoarsenItemHit:Descriptor>>; INNER #);
                    
                 #);
               iRefine:< BasicItem;
               iAttach:< BasicItem;
               iDetach:< BasicItem;
               iMorph:< BasicItem;
               iDomain:< BasicItem;
               iDeskForm:< BasicItem;
               iShift:< BasicItem;
               EnableItem: @iEnable;
               FormItem: @iForm;
               SumItem: @iSum;
               CopyDrItem: @iCopyDr;
               SpreadItem: @iSpread;
               CoarsenItem: @iCoarsen;
               RefineItem: @iRefine;
               AttachItem: @iAttach;
               DetachItem: @iDetach;
               MorphItem: @iMorph;
               DomainItem: @iDomain;
               DeskFormItem: @iDeskForm;
               ShiftItem: @iShift;
               init::< 
                 (#  do <<SLOT InitGroupMenu:Descriptor>>; INNER #);
               
            #);
          DocTextMenu: @TextMenu;
          TextMenu:< DesignMenu
            (#
               iEnable:< BasicItem;
               iFitBox:< BasicItem;
               iTextAttr:< BasicItem;
               iSelBracket:< BasicItem;
               iSelString:< BasicItem;
               iScrollString:< BasicItem;
               iSrcNext:< BasicItem;
               iSrcZero:< BasicItem;
               EnableItem: @iEnable;
               FitBoxItem: @iFitBox;
               TextAttrItem: @iTextAttr;
               SelBracketItem: @iSelBracket;
               SelStringItem: @iSelString;
               ScrollStringItem:
                 @iScrollString;
               SrcNextItem: @iSrcNext;
               SrcZeroItem: @iSrcZero;
               init::<  (#  do <<SLOT InitTextMenu:Descriptor>>; INNER #);
               
            #);
          DocAlignMenu: @AlignMenu;
          AlignMenu:< DesignMenu
            (#
               iHor:< BasicItem;
               iVer:< BasicItem;
               iLeftLeft:< BasicItem;
               iLeftRight:< BasicItem;
               iRightLeft:< BasicItem;
               iRightRight:< BasicItem;
               iTopTop:< BasicItem;
               iTopBot:< BasicItem;
               iBotTop:< BasicItem;
               iBotBot:< BasicItem;
               iCent:< BasicItem;
               iBetw:< BasicItem;
               iProj:< BasicItem;
               iRadial:< BasicItem;
               iPickNode:< BasicItem;
               HorItem: @iHor;
               VerItem: @iVer;
               LeftLeftItem: @iLeftLeft;
               LeftRightItem: @iLeftRight;
               RightLeftItem: @iRightLeft;
               RightRightItem: @iRightRight;
               TopTopItem: @iTopTop;
               TopBotItem: @iTopBot;
               BotTopItem: @iBotTop;
               BotBotItem: @iBotBot;
               CentItem: @iCent;
               BetwItem: @iBetw;
               ProjItem: @iProj;
               RadialItem: @iRadial;
               PickNodeItem: @iPickNode;
               init::< 
                 (#  do <<SLOT InitAlignMenu:Descriptor>>; INNER #);
               
            #);
          (************************ General inquries ******************)
          MaxGroupSize:<
            (# size: @Integer; 
            do <<SLOT MaxGroupSize:Descriptor>>; INNER
            exit size
            #);
          RegularPolySides:<
            (#
               GetSide:<
                 (# side: @Integer
                 do <<SLOT PolyGetSide:Descriptor>>; INNER
                 exit side
                 #);
               SetSide:<
                 (# side: @Integer
                 enter side
                 do
                    <<SLOT PolySetSide:Descriptor>>;
                    INNER
                 #);
               
            enter SetSide
            exit GetSide
            #);
          RegularPolyOrient:<
            (#
               GetOrient:<
                 (# orient: @Integer
                 do <<SLOT PolyGetOrient:Descriptor>>; INNER
                 exit orient
                 #);
               SetOrient:<
                 (# orient: @Integer
                 enter orient
                 do
                    <<SLOT PolySetOrient:Descriptor>>;
                    INNER
                 #);
               
            enter SetOrient
            exit GetOrient
            #);
          Point: (# x,y: @Integer enter (x,y) exit (x,y) #);
          privatePart: @<<SLOT DocumentPrivatePart:Descriptor>>;
          
       do INNER ; 
       #);
     (* end document *)
     (*************** MENUS *******************)
     (* The design of the menus resembles the menus of MacEnv *)
     MenuList: List (* list containing menus *)
       (#
          element::< BasicMenu;
          findMenu:
            (# id: @integer; m: ^element; 
            enter id
            do
               find
                 (# predicate::<  (#  do (current.id = id)->value #) #)->m[]
            exit m[]
            #);
          insert:<
            (# e: ^element;  enter e[] do e[]->append; INNER ;  #);
          remove:<
            (# e: ^element;  enter e[] do e[]->at->delete; INNER ;  #);
          
       #);
     MenuBar: @MenuList (* contains the actual menus of the application *)
       (#
          insert::<  (#  do <<SLOT MenuBarInsert:Descriptor>> #);
          remove::< 
            (# 
            do
               <<SLOT MenuBarDelete:Descriptor>>
            #);
          
       #);
     BasicMenu:
       (#
          ID: @Integer;
          Enable:< (#  do <<SLOT MenuEnable:Descriptor>>; INNER #);
          Disable:<
            (# 
            do
               <<SLOT MenuDisable:Descriptor>>;
               INNER
            #);
          BasicItem:
            (#
               hit:< Object;
               itemNumber: @Integer;
               Enable:<
                 (#  do <<SLOT MenuItemEnable:Descriptor>>; INNER #);
               Disable:<
                 (# 
                 do
                    <<SLOT MenuItemDisable:Descriptor>>;
                    INNER
                 #);
               Check:<
                 (# checked: @Boolean; 
                 enter checked
                 do <<SLOT MenuItemCheck:Descriptor>>; INNER ; 
                 #);
               init:<
                 (# 
                 enter itemNumber
                 do
                    THIS(BasicItem)[]
                      ->ItemList.append;
                    True->PreCall;
                    True->proceed;
                    INNER ;
                    
                 #);
               insert:< Object;
               delete:< Object;
               proceed: @Boolean;
               PreCall: @Boolean;
               att:
                 @<<SLOT BasicMenuItemAtt:Descriptor>>;
               
            #);
          ItemList: @List (* the list contaning the items of this BasicMenu *)
            (#
               element::< BasicItem;
               findItem: find
                 (#
                    itemNo: @Integer;
                    predicate::< 
                      (#  do (current.itemNumber = itemNo)->value #);
                    
                 enter itemNo
                 #)
            #);
          Init:<
            (#  enter id do INNER ; THIS(BasicMenu)[]->MenuBar.Insert #);
          Insert:< Object;
          Delete:< Object;
          Seperator:
            (# sepID: @Integer; 
            enter sepID
            do <<SLOT MenuSeperator:Descriptor>>; 
            #);
          
       #);
     DesignMenu: BasicMenu
       (#
          Item: BasicItem
            (#
               name: @Text;
               init::<
               (* the item must be added to a designmenu
                * initialize the item by (itemID,'name') -> theItem.init*) 
                 (#  enter name do INNER #);
               insert::< 
                 (#  do <<SLOT DesignMenuInsertItem:Descriptor>> #);
               delete::< 
                 (# 
                 do
                    <<SLOT DesignMenuDeleteItem:Descriptor>>
                 #);
               rename:
                 (# 
                 enter name
                 do <<SLOT DesignMenuItemRename:Descriptor>>
                 #);
               
            #);
          Insert::<
          (* called by MenuBar.insert when we like the menu to show up *) 
            (#  do <<SLOT DesignMenuInsert:Descriptor>>; INNER #);
          Delete::<
          (* called by MenuBar.delete when we like the menu to disappear *) 
            (#  do <<SLOT DesignMenuDelete:Descriptor>>; INNER #);
          
       #);
     UserMenu: BasicMenu
       (#
          name: @Text;
          BeforeMenuID: @Integer;
          Item: BasicItem
            (#
               name: @Text;
               init::<
               (* the item must be added to design
                * initialize the item by (itemID,'name') -> theItem.init *) 
                 (#  enter name do INNER #);
               insert::<  (#  do <<SLOT UserMenuInsertItem:Descriptor>> #);
               delete::<  (#  do <<SLOT UserMenuDeleteItem:Descriptor>> #);
               rename:
                 (# 
                 enter name
                 do <<SLOT UserMenuItemRename:Descriptor>>
                 #);
               
            #);
          DisabledItem: Item
            (#
               init::< 
                 (# 
                 do Disable; INNER
                 #)
            #);
          Init::<
          (* initialize the menu by (menuID,'name') -> theMenu.init *) 
            (# 
            enter name
            do INNER ; (* create the items in specialization *) 
            #);
          Insert::<
          (* called by MenuBar.insert when we like the menu to show up *) 
            (#  do <<SLOT UserMenuInsert:Descriptor>>; INNER #);
          Delete::<
          (* called by MenuBar.delete when we like the menu to disappear *) 
            (#  do <<SLOT UserMenuDelete:Descriptor>>; INNER #);
          InsertBefore:
            (# 
            enter BeforeMenuID
            do
               <<SLOT UserMenuInsertBefore:Descriptor>>
            #);
          
       #);
     (********************* FILE MENU: *****************
      * new, open, quit etc. item enabled with no document
      *)
     DocFileMenu: @FileMenu;
     FileMenu:< DesignMenu
       (#
          iNew:< BasicItem
            (#
               hit::<  (#  do INNER ; <<SLOT NewItem:Descriptor>> #);
               init::< 
                 (# 
                 do false->PreCall; INNER
                 #);
               
            #);
          iOpen:< BasicItem
            (#
               hit::< 
                 (# 
                 do
                    INNER ;
                    <<SLOT OpenItem:Descriptor>>
                 #);
               init::<  (#  do false->PreCall; INNER #);
               
            #);
          iClose:< BasicItem
            (#
               hit::<  (#  do INNER ; <<SLOT CloseItem:Descriptor>> #);
               init::< 
                 (# 
                 do false->PreCall; INNER
                 #);
               
            #);
          iSave:< BasicItem
          (* (#
           hit::<  (# do INNER ; #);
           init::<  (# do false->PreCall; INNER #);
           #)*) ;
          iSaveAs:< BasicItem;
          iRevert:< BasicItem;
          iGetInfo:< BasicItem;
          iPageSetup:< BasicItem;
          iPrintPage:< BasicItem;
          iPrintPreview:< BasicItem;
          iPreferences:< BasicItem;
          iLoadtext:< BasicItem;
          iSaveText:< BasicItem;
          iLoadPage:< BasicItem
            (#
               hit::<  (#  do <<SLOT LoadPageItem:Descriptor>>; INNER #);
               init::<  (#  do false->PreCall; INNER #);
               
            #);
          iSavePage:< BasicItem;
          iQuit:< BasicItem;
          NewItem: @iNew;
          OpenItem: @iOpen;
          CloseItem: @iClose;
          SaveItem: @iSave;
          SaveAsItem: @iSaveAs;
          RevertItem: @iRevert;
          GetInfoItem: @iGetInfo;
          PageSetupItem: @iPageSetup;
          PrintPageItem: @iPrintPage;
          PrintPreviewItem: @iPrintPreview;
          PreferencesItem: @iPreferences;
          LoadTextItem: @iLoadText;
          SaveTextItem: @iSaveText;
          LoadPageItem: @iLoadPage;
          SavePageItem: @iSavePage;
          QuitItem: @iQuit;
          Init::<  (#  do <<SLOT InitFileMenu:Descriptor>>; INNER #);
          
       #);
     Cursor: @
       (#
          id,oldCurs: @Integer;
          Null: (#  exit 0 #);
          Arrow: (#  exit 1 #);
          Box: (#  exit 2 #);
          Connector: (#  exit 3 #);
          Crosshair: (#  exit 4 #);
          Drag: (#  exit 5 #);
          Ellipse: (#  exit 6 #);
          Fingers: (#  exit 7 #);
          FormGroup: (#  exit 8 #);
          Group: (#  exit 9 #);
          Label: (#  exit 10 #);
          Palette: (#  exit 11 #);
          Picture: (#  exit 12 #);
          Polygon: (#  exit 13 #);
          RegularPolygon: (#  exit 14 #);
          RoundedBox: (#  exit 15 #);
          Text: (#  exit 16 #);
          Wait: (#  exit 17 #);
          Wedge: (#  exit 18 #);
          IBeam: (#  exit 19 #);
          Cute: (#  exit 20 #);
          System: (#  exit 21 #);
          Line: (#  exit 22 #);
          set:
            (# 
            enter id
            do <<SLOT SetCursor:Descriptor>>
            #);
          get:
            (# 
            exit
            id
            #);
          restore: (#  do <<SLOT RestoreCursor:Descriptor>> #);
          reset:
            (# 
            do <<SLOT ResetCursor:Descriptor>>
            #);
          
       #);
     StatusBar: @
       (#
          msg: @Text;
          set: (#  enter msg do <<SLOT SetStatusBar:Descriptor>> #);
          reset:
            (# 
            do
               <<SLOT ResetStatusBar:Descriptor>>
            #);
          
       #);
     (************** VARIOUS **************)
     WCOORD: @ (# i: @Integer enter i exit i %sll 15 #);
     emptyList: [0] @Integer;
     (* an empty list to be used in calls where an empty
      * list may be given as argument, e.g. page.Coarse *)
     Clipboard:
       (#
          ToBuffer: (#  #);
          BufferToClipboard: (#  #);
          GetObject: (#  #);
          
       #);
     verbose: @Boolean;
     (* if true then log messages *)
     objectVerbose: @Boolean;
     (* if true then log DesignObject messages *)
     callBackVerbose: @Boolean;
     (* if true then log callback messages *)
     userDataVerbose: @Boolean;
     (* if true then log user data messages *)
     DesignEnvException: Exception (* print t on screen and stop *)
       (# t: @Text
       enter t
       do 'DesignEnv exception: '->t.prepend; t->msg; t[]->putline; INNER
       #);
     (*************** GENERAL CALLBACK ***************)
     (***************     PRIVATE      ***************)
     callBack::< 
       (#
          initialize::< 
            (# 
            do
               <<SLOT EnableCallBacks:Descriptor>>;
               <<SLOT InitMenus:Descriptor>>;
               cursor.CrossHair->cursor.id;
               onInit;
               
            #);
          Abort::<  (#  do <<SLOT CallBackAbort:Descriptor>> #);
          MenuEvent::< 
            (# 
            do
               <<SLOT CallBackMenuEvent:Descriptor>>
            #);
          PostMenuEvent::< 
            (#  do <<SLOT CallBackPostMenuEvent:Descriptor>> #);
          PostPageChanged::< 
            (# 
            do
               <<SLOT CallBackPageChanged:Descriptor>>
            #);
          MouseDown::< 
            (# locked: @boolean
            do <<SLOT CallBackMouseDown:Descriptor>>; 
            #);
          Attach::< 
            (# 
            do
               <<SLOT CallBackAttach:Descriptor>>
            #);
          Coarsen::<  (#  do <<SLOT CallBackCoarsen:Descriptor>> #);
          Refine::< 
            (# 
            do
               <<SLOT CallBackRefine:Descriptor>>
            #);
          CreateObject::< 
            (#  do <<SLOT CallBackCreateObject:Descriptor>> #);
          ConnGrammar::< 
            (# 
            do
               <<SLOT CallBackConnGrammar:Descriptor>>
            #);
          PreDeleteNode::< 
            (#  do <<SLOT CallBackDelNodeGrammar:Descriptor>> #);
          PreDeleteRegion::< 
            (# 
            do
               <<SLOT CallBackDelRegionGrammar:Descriptor>>
            #);
          DelConnGram::< 
            (#  do <<SLOT CallBackDelConnGrammar:Descriptor>> #);
          Duplicate::< 
            (# 
            do
               <<SLOT CallBackDuplicate:Descriptor>>
            #);
          PostObjectSelect::< 
            (#  do <<SLOT CallBackPostObjectSelect:Descriptor>> #);
          PostObjectSize::< 
            (# 
            do
               <<SLOT CallBackPostObjectSize:Descriptor>>
            #);
          oldObjectID,oldObjectID2,oldLocked2: @integer;
          oldLocked: @Boolean;
          DoubleClick::< 
            (# locked: @boolean
            do <<SLOT CallBackDoubleClick:Descriptor>>
            #);
          ProcessDrag::< 
            (# 
            do
               <<SLOT CallBackDrag:Descriptor>>
            #);
          MakeRegionGrammar::< 
            (#  do <<SLOT CallBackMakeRgnGrammar:Descriptor>> #);
          UnMakeRegionGrammar::< 
            (# 
            do
               <<SLOT CallBackUnmakeRegionGrammar:Descriptor>>
            #);
          PaletteClick::< 
            (#  do <<SLOT CallbackPaletteClick:Descriptor>> #);
          
       #);
     UserMenu1: (#  exit 10000 #);
     (* resource hacks to make user defined menus *)
     UserMenu2: (#  exit 11000 #);
     UserMenu3: (#  exit 12000 #);
     UserMenu4: (#  exit 13000 #);
     UserMenu5: (#  exit 14000 #);
     UserMenu6: (#  exit 15000 #);
     UserMenu7: (#  exit 16000 #);
     UserMenu8: (#  exit 17000 #);
     UserMenu9: (#  exit 18000 #);
     UserMenu10: (#  exit 19000 #);
     designenvPrivate: @<<SLOT designEnvPrivate:Descriptor>>;
     
  do
     INNER ;
     <<SLOT designEnvInit:Descriptor>>
  #)  

