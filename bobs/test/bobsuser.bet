ORIGIN '~beta/basiclib/v1.5/betaenv';
INCLUDE '../bobs';
INCLUDE '~beta/basiclib/v1.5/numberio';
--------------------
PROGRAM: descriptor
---------------------
(# B: @BOBS;
   minCh:(#exit 32 #);
   putInt6: screen.putInt(# format::<(#do 6->width #)#);

   TstTab:
   (# sy: @integer;

      PrLx:
      (# ch: @char; NP,HP,inx: @integer;

      enter ch
      do ch->put; ':' ->put;
         (ch->B.Btab.chInx->inx)->putInt6;
(*         (inx->B.BTab.lxCH)->putInt6;
         (inx->B.BTab.lxTV)->putInt6;
         (inx->B.BTab.lxNP->NP)->putInt6;
 (inx->B.BTab.lxHP->HP)->putInt6; newline;*)
      #);
      
      dumpTab:
        (# V: @integer;
        do (for i: B.bTab.T.R.range repeat
                (if i mod 16 // 0 then
                    newline; i->putInt; ':'->put; ' '->put
                if);
                B.bTab.T.R[i]->V;
                (16,V->TOS'%getByte[0]')->putBased(#do true->noBasePrefix #); 
                (16,V->TOS'%getByte[1]')->putBased(#do true->noBasePrefix #); 
                (16,V->TOS'%getByte[2]')->putBased(#do true->noBasePrefix #); 
                (16,V->TOS'%getByte[3]')->putBased(#do true->noBasePrefix #); 
                ','->put
           for)
        #)
      
   do dumpTab;
      (for i: 30 repeat (B.BTab.T.R[i])->putInt; newline for);
      'Entry:'->putText; newline;
      (B.base.entry)->putInt; newline;
      (for i: 5 repeat
           (for j: 4 repeat
                (B.Btab.T.R[B.base.entry+(minCh+i-1)*4+j])->putInt6
           for); newline
      for);

      'LX:'->putText; newline;
      (B.base.lx)->putInt; newline;
      (for i: 5 repeat
           (for j: 4 repeat
                (B.Btab.T.R[B.base.LX+(i-1)*4+j])->putInt6
           for); newline
      for);

      'n'->PrLx;
      'a'->PrLX;
      'm'->prLx;
      'e'->Prlx;


      'LR:'->putText; newline;
      (B.base.lr)->putInt; newline;
      (for i: 4  repeat
           (for j: 5 repeat
                (B.BTab.T.R[B.base.lr+(i-1)*5+j])->putInt6;
           for); 
           newline
      for);

      'Prod:'->putText; newline;
     
      (for p: B.BTab.prodMax repeat
           (if ((p<11) or ((B.Btab.prodMax-11)<p)) // true then
               (B.BTab.T.R[B.base.LHS+p]->sy)->putInt6;
               sy->B.scanSymb(#do ch->put #); 
               ' ::= '->putText;
               p->B.scanProd(#do sy->B.scanSymb(#do ch->put #)#);
               ' : '-> puttext;
               p->B.ScanLabel(#do ch->put #); newline
      if)for);
      
      
   #);


   Init:
     (# TableFileName: ^text; 
        isEos,docParser,dashInNames,newlineIsCommentEnd,caseSensitive: @boolean
     do true->B.TT.trace;
        'Parse tables: '->puttext; KeyBoard.GetAtom->TableFileName[];
        'Is -- eos?[yn]'->PutText; (keyBoard.getnonBlank='y')->isEos;
        'Is - allowed in names?[yn]'->puttext; 
        (keyboard.getNonBlank='y')->dashInNames;
        'Is end-of-line comment terminator?[yn]'->puttext;
        (keyboard.getNonBlank='y')->newlineIsCommentEnd;
        'Are reserved words case sensitive?[yn]'->puttext;
        (keyboard.getNonBlank='y')->caseSensitive;
        'Documentparser?[ny]'->Puttext; (keyBoard.getnonBlank='y')->docParser;
        'TableFileName is:'->puttext; TableFileName[]->putline;
        (TableFileName[],True,isEos,docParser,dashInNames,newlineIsCommentEnd
        ,caseSensitive)->B.init; 
        (if isEos//true then
            'Eos-symbol is: '->puttext;
            (for i:2 repeat B.eosCh->put for);
            newline
        if);
        'Test tables?[yn]'->puttext;
        (if keyboard.getNonBlank='y' //true then tstTab if);
        ('exp','fooExp')->B.defineNonTAlias;
        ('primary','prim')->B.defineNonTAlias;
        'Alias: fooExp == exp, prim == primary'->puttext; newline;
        ('objectdescriptor','descriptor')->B.defineNonTAlias;
        ('attributedecl','attributes')->B.defineNonTAlias;
        'Alias: descriptor == ObjectDescriptor, attributeDecl == attributes\n'
          ->puttext; 

   #);

   Parse:
   (# Poss: [100] @ integer; legalss: [100] ^Text; Etop: @integer;

      Tparse: B.Parse
      (# 

         Shift::<
         (#  
         do 'Lexem: '->puttext;
            (if isTerminal
             // true then
                (if symb
                // nameVal then scan(#do ch->put #);
                // stringVal then scan(#do ch->put #);
                // constVal then 
                   (# 
                   do scan(#do ch->screen.put #)
                   #)
                 else scan(#do ch->screen.put #)
               if);
             // false then scan(#do ch->put #);
                ' '->put; symb->putint
            if); 
            newline
         #);

         Reduce::<
           (#
           do 'Prod:'->puttext; (prodNo)->putInt6; ' '->put;
              prodNo->B.PrintProd; newline
           #);

         Comment::<(#do 'Comment:'->puttext; scan(#do ch->put #); newline #);

         MarkError::<
         (# 
         do (if ((Etop+1->Etop) < Poss.range) // true then 
                pos->Poss[Etop];
		&text[]->legalss[Etop][];
	        LegalSymbs.scan
		 (#do thisSymbText->legalss[Etop].putText;
		      ' ' ->legalss[Etop].put #)if)
	 #);

	 FatalError::<
	   (#
	   do 'BobsUser error'->msg.putLine;
	      msg[]->puttext; true->continue
	   #);
      #); (* Tparse *)

     skipRestOfLine:
       (#
       do skip:
          Cycle(# ch: @char 
               do (if (get->ch) // ascii.newline then leave skip if)#)
       #);
      input: ^Stream; lst: @file; ok: @boolean
   do
      L:
         Cycle
         (# F: @file; T: ^text; Goal: @integer; isFile: @boolean
         do 0->Etop;
	    'Nonterminal (by text or value) or label goal?[tvlq]'->puttext;
            (if getNonBlank
             // 'q' then leave L
             // 't' then
		'Type a nonterminal as text:'->puttext; skipRestOfline;
		keyboard.getLine->T[];
	        T[]->B.getNonTindex->goal;
	        T[]->puttext; '.'->put; goal->putint; newline
             // 'v' then
                'Type nonterminal symbol value[0,1,'-> puttext;
                (B.bTab.nontstart)->putInt; '-'->put;
                (B.bTab.symbMax)->putInt; ']'->put;
                getInt->Goal;
                (if ((Goal<B.bTab.nontStart) or (B.bTab.symbMax<Goal))
                 // true then 0->Goal
                if)
             // 'l' then
                'Type production label (positive integer)' ->puttext;
                getInt->B.labLHS->Goal
             else restart L
             if);
             'Parse from file or keyboard[fk]'->puttext;
             (if getNonBlank
              // 'f' then 
                 True->isFile;
                 'Type Input file name: '->putText;
                 F.name.read; F.openRead;
                 F[]->input[]
              // 'k' then
                 False->isFile; skipRestofLine;
                 'Type a line of text to be parsed:'->puttext; newline;
                 keyBoard.getLine->T[];
                 'Parsing: '->puttext; T[]->puttext; newline;
                 ascii.newline->T.put;
                 0->T.setPos;
                 T[]->input[]
             else restart L
             if);
         'Goal symbol is '-> puttext;
         (if ((B.bTab.nontStart<goal) and (goal<=B.bTab.symbMax))
          //true then goal->B.ScanSymb(#do ch->put #);
         else 'Top goal symbol' ->puttext; 0->goal
         if);
         newline;
         (Goal,input[]) ->Tparse->ok; 
         (if isFile//true then F.close if);
         (if ok 
          // true then
             newline;
             'Parsing terminated by: '->PutText;
             (if B.lastCh // ascii.fs then 'end-ofstream'->PutText
              else B.eosCh->put; B.eosCh->put; B.lastCh->put
             if);
             newline;
             'No. of chars read: '->Puttext; B.noOfCharRead->PutInt;newline
          // false then
             (if isFile 
              // true then
                 F.openRead;
                 'elst'->lst.name;
                 lst.openWrite;
                 (F[],lst[],false,Poss,Legalss,Etop)->BobsErrorReport ;
                 F.close; lst.close;
                 'Syntax error(s) in input. See file ''elst'''->Puttext;
                 newline;
              // false then
                 0->T.setPos;
                 (T[],screen[],false,Poss,Legalss,Etop)->BobsErrorReport
         if)if)
      #)
   #);
do Init; 
   newline;
   '\nStarting parsing:\n'->putText;
   Parse; 
#)
