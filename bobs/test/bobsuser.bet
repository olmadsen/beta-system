ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../bobs';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/basiclib/numberio';
--------------------
PROGRAM: descriptor
  ---------------------
(# B: @BOBS;
   minCh:(#exit 32 #);
   putInt4: screen.putInt(# format::<(#do 4->width #)#);
   putInt6: screen.putInt(# format::<(#do 6->width #)#);
   TstTab:
     (# sy: @integer;

        PrLx:
          (# ch: @char; NP,HP,inx: @integer;

          enter ch
          do ch->put; ':' ->put;
             (ch->B.Btab.chInx->inx)->putInt6;
             (*         (inx->B.BTab.lxCH)->putInt6;
              (inx->B.BTab.lxTV)->putInt6;
              (inx->B.BTab.lxNP->NP)->putInt6;
              (inx->B.BTab.lxHP->HP)->putInt6; newline;*)
          #);
        
        dumpTab:
          (# V: @integer;
          do (for i: B.bTab.T.R.range repeat
                  (if i mod 16 // 0 then
                      newline; i->putInt; ':'->put; ' '->put
                  if);
                  B.bTab.T.R[i]->V;
                  (16,(0->V.%getByte))->putBased(#do true->noBasePrefix #); 
                  (* Above line tos_converted from: (16,V->TOS'%getByte[0]')->putBased(#do true->noBasePrefix #); *)
                  (16,(1->V.%getByte))->putBased(#do true->noBasePrefix #); 
                  (* Above line tos_converted from: (16,V->TOS'%getByte[1]')->putBased(#do true->noBasePrefix #); *)
                  (16,(2->V.%getByte))->putBased(#do true->noBasePrefix #); 
                  (* Above line tos_converted from: (16,V->TOS'%getByte[2]')->putBased(#do true->noBasePrefix #); *)
                  (16,(3->V.%getByte))->putBased(#do true->noBasePrefix #); 
                  (* Above line tos_converted from: (16,V->TOS'%getByte[3]')->putBased(#do true->noBasePrefix #); *)
                  ','->put
             for)
          #)
        
     do dumpTab;
        (for i: 30 repeat (B.BTab.T.R[i])->putInt; newline for);
        'Entry:'->putText; newline;
        (B.base.entry)->putInt; newline;
        (for i: 5 repeat
             (for j: 4 repeat
                  (B.Btab.T.R[B.base.entry+(minCh+i-1)*4+j])->putInt6
             for); newline
        for);

        'LX:'->putText; newline;
        (B.base.lx)->putInt; newline;
        (for i: 5 repeat
             (for j: 4 repeat
                  (B.Btab.T.R[B.base.LX+(i-1)*4+j])->putInt6
             for); newline
        for);

        'n'->PrLx;
        'a'->PrLX;
        'm'->prLx;
        'e'->Prlx;


        'LR:'->putText; newline;
        (B.base.lr)->putInt; newline;
        (for i: 4  repeat
             (for j: 5 repeat
                  (B.BTab.T.R[B.base.lr+(i-1)*5+j])->putInt6;
             for); 
             newline
        for);

        'Prod:'->putText; newline;
        
        (for p: B.BTab.prodMax repeat
             (if ((p<11) or ((B.Btab.prodMax-11)<p)) then
                 (B.BTab.T.R[B.base.LHS+p]->sy)->putInt6;
                 sy->B.scanSymb(#do ch->put #); 
                 ' ::= '->putText;
                 p->B.scanProd(#do sy->B.scanSymb(#do ch->put #)#);
                 ' : '-> puttext;
                 p->B.ScanLabel(#do ch->put #); newline
        if)for);
        
        
     #);


   Init:
     (# TableFileName: ^text; 
        isEos,docParser,dashInNames,newlineIsCommentEnd
        ,caseSensitive,stringSplit: @boolean;
        SkipToNl:
          (# ch: @char
          do L: (if (keyboard.get -> ch) <> ascii.nl then
                    restart L
                if)
          #);
        response:
          (# ch: @char
          do getCh:
               (#
               do keyboard.get -> ch;
                  (if ch = ascii.nl then 'n' -> ch
                   else
                      (if ch <= 32 then
                          restart getCh
                      if);
                      SkipToNl;
                  if);
               #);
          exit ch
          #);
     do 'Parse tables: '->puttext; KeyBoard.GetAtom->TableFileName[]; SkipToNl;
        
        'Is -- eos?[yn]'->PutText; response = 'y' -> isEos;
        
        'Is - allowed in names?[yn]'->puttext; response = 'y' -> dashInNames;
        
        'Is end-of-line comment terminator?[yn]' -> puttext; 
        response = 'y' ->newlineIsCommentEnd;
        
        'Are reserved words case sensitive?[yn]'->puttext; response = 'y' -> caseSensitive;
        
        (*'Documentparser?[yn]'->Puttext; response = 'y' -> docParser;*)

        'Allow split of strings?[yn]'->puttext; response='y' -> stringSplit;
        
        'Trace?[yn]'->puttext; response='y'->B.TT.trace;        
        
        'TableFileName is:'->puttext; TableFileName[]->putline;
        
        (TableFileName[],True,isEos,docParser,dashInNames,newlineIsCommentEnd
        ,caseSensitive,stringSplit)->B.init; 
        (if isEos then
            'Eos-symbol is: '->puttext;
            (for i:2 repeat B.eosCh->put for);
            newline
        if);
        'Test tables?[yn]'->puttext;
        (if response = 'y'  then tstTab if);
        ('exp','fooExp')->B.defineNonTAlias;
        ('primary','prim')->B.defineNonTAlias;
        'Alias: fooExp == exp, prim == primary'->puttext; newline;
        ('objectdescriptor','descriptor')->B.defineNonTAlias;
        ('attributedecl','attributes')->B.defineNonTAlias;
        'Alias: descriptor == ObjectDescriptor, attributeDecl == attributes\n'
          ->puttext; 

     #);

   Parse:
     (# Poss: [100] @ integer; legalss: [100] ^Text; Etop: @integer;

        Tparse: B.Parse
          (# 

             Shift::<
               (#  
               do 'Lexem: '->puttext;
                  (if isTerminal then
                      (if symb
                       // nameVal then scan(#do ch->put #);
                       // stringVal then scan(#do ch->put #);
                       // constVal then scan(#do ch->screen.put #)
                       else scan(#do ch->screen.put #)
                      if);
                   else
                      scan(#do ch->put #);
                      ' '->put; symb->putint;
                      ' prodSy: '->puttext; symb -> b.prodsy -> putint;
                      ' labelNo: ' -> puttext;  
                      symb -> b.prodsy -> b.labelNo -> putint;
                  if); 
                  newline
               #);

             Reduce::<
               (#
               do 'Prod:'->puttext; (prodNo)->putInt4; ' '->put;
                  ' pos: '->puttext; startPos->putint4;
                  ' end: '->puttext; endPos->putint4; ' '->put;
                  prodNo->B.PrintProd; newline
               #);

             Comment::< 
               (#do 'Comment:'->puttext; scan(#do ch->put #); newline #);

             MarkError::<
               (# 
               do (if ((Etop+1->Etop) < Poss.range) then 
                      pos->Poss[Etop];
		      &text[]->legalss[Etop][];
	              LegalSymbs.scan
		      (#do thisSymbText->legalss[Etop].putText;
                         ' ' ->legalss[Etop].put 
                  #)if)
	       #);

	     FatalError::<
	       (#
	       do 'BobsUser error'->msg.putLine;
	          msg[]->puttext; true->continue
	       #);
          #); (* Tparse *)

        skipRestOfLine:
          (#
          do skip:
               Cycle(# ch: @char 
                    do (if (get->ch) // ascii.newline then leave skip if)#)
          #);
        input: ^Stream; lst: @file; ok: @boolean
     do
        L:
          Cycle
          (# F: @file; T: ^text; Goal: @integer; isFile: @boolean
          do 0->Etop;
	     'Nonterminal (by text or value) or label goal?[tvlq]'->puttext;
             (if getNonBlank
              // 'q' then leave L
              // 't' then
		 'Type a nonterminal as text:'->puttext; skipRestOfline;
		 keyboard.getLine->T[];
	         T[]->B.getNonTindex->goal;
	         T[]->puttext; '.'->put; goal->putint; newline
              // 'v' then
                 'Type nonterminal symbol value[0,1,'-> puttext;
                 (B.bTab.nontstart)->putInt; '-'->put;
                 (B.bTab.symbMax)->putInt; ']'->put;
                 getInt->Goal;
                 (if ((Goal<B.bTab.nontStart) or (B.bTab.symbMax<Goal)) then
                     0->Goal
                 if)
              // 'l' then
                 'Type production label (positive integer)' ->puttext;
                 getInt->B.labLHS->Goal
              else restart L
             if);
             'Parse from file or keyboard[fk]'->puttext;
             (if getNonBlank
              // 'f' then 
                 True->isFile;
                 'Type Input file name: '->putText;
                 F.name.read; F.openRead;
                 F[]->input[]
              // 'k' then
                 False->isFile; skipRestofLine;
                 'Type a line of text to be parsed:'->puttext; newline;
                 keyBoard.getLine->T[];
                 'Parsing: '->puttext; T[]->puttext; newline;
                 ascii.newline->T.put;
                 0->T.setPos;
                 T[]->input[]
              else restart L
             if);
             'Goal symbol is '-> puttext;
             (if ((B.bTab.nontStart<goal) and (goal<=B.bTab.symbMax))
                 then goal->B.ScanSymb(#do ch->put #);
              else 'Top goal symbol' ->puttext; 0->goal
             if);
             newline;
             (Goal,input[]) ->Tparse->ok; 
             (if isFile then F.close if);
             (if ok then
                 newline;
                 'Parsing terminated by: '->PutText;
                 (if B.lastCh // ascii.fs then 'end-ofstream'->PutText
                  else B.eosCh->put; B.eosCh->put; B.lastCh->put
                 if);
                 newline;
                 'No. of chars read: '->Puttext; B.noOfCharRead->PutInt;newline
              else
                 (if isFile then
                     F.openRead;
                     'elst'->lst.name;
                     lst.openWrite;
                     (F[],lst[],false,Poss,Legalss,Etop)->BobsErrorReport ;
                     F.close; lst.close;
                     'Syntax error(s) in input. See file \'elst\''->Puttext;
                     newline;
                  else 
                     0->T.setPos;
                     (T[],screen[],false,Poss,Legalss,Etop)->BobsErrorReport
             if)if)
          #)
     #);
do Init; 
   newline;
   '\nStarting parsing:\n'->putText;
   Parse; 
#)
