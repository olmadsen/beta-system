ORIGIN '~beta/guienv/v1.6/guienvsystemenv';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
BODY 'private/valhallabody';
BODY 'private/breakpointMenus';

INCLUDE 'processInterface';
INCLUDE 'processCommCodes';
INCLUDE 'breakpoints';

INCLUDE 'UI/valhallaGUI';
INCLUDE 'UI/GUIprocess';
INCLUDE 'UI/stackview';
INCLUDE 'UI/stackbrowser';
INCLUDE 'UI/objectviewadds';
INCLUDE 'UI/enveditor';
INCLUDE '~beta/guienv/v1.6/utils/promptForArgs';

INCLUDE '~beta/objectbrowser/v2.2/systemenvcompspawner';
INCLUDE '~beta/objectbrowser/v2.2/UI/moveable';

INCLUDE '~beta/guienv/v1.6/stddialogs';
INCLUDE '~beta/guienv/v1.6/utils/simplemenu';

INCLUDE '~beta/process/v1.6/systemComm';

--- lib:attributes ---

DEFAULT_RECTANGLE: (# exit ((0,0),(250,250)) #);

--- program:descriptor ---
systemenv
(# <<SLOT valhallalib: attributes>>;
   
   windowEnvType:: valhallaGUI;
   setWindowEnv:: (# do gui[]->theWindowEnv[] #);
   
   thespawner: @systemenvspawner;
   
   debuggee: ^gui.GUIprocess; (* The process being debugged. *)
   
   theEnveditor: ^enveditType; (* Environment editor. *)
   enveditType: gui.envEditor (# onClose:: (# do NONE->theEnveditor[] #)#);
   
   debuggeeIsRunning: BooleanValue
     (# 
     do (if debuggee[]<>NONE then 
            (debuggee.running) and (not debuggee.terminated)->value 
         else FALSE->value
        if);
     #);
   debuggeeIsReady: BooleanValue
     (# 
     do (if debuggee[]<>NONE then 
            (not debuggee.running) and (not debuggee.terminated)->value 
         else FALSE->value
        if);
     #);
   ensureKilled:
     (# 
     do (if debuggee[]<>NONE then
            (if not debuggee.terminated then
                debuggee.kill; gui.onTerminate;
            if);
        if);
     #);
   
   getFrame:
     (# done:<
          (# result: @rectangle;
          enter result
          do INNER
          #);
     do 
        (if dragOutlineOnOpen->gui.getOption then
            DEFAULT_RECTANGLE->gui.main.objworld.getOutline
            (# done:: (# do result->THIS(getFrame).done #)#)
         else
            DEFAULT_RECTANGLE->done;
        if);   
     #);
   
   newExecName:
     (# execName: ^Text;
     do gui.main[]->gui.fileSelectionDialog
        (#
        do 'Debug executable:'->label[];
        #)->execName[];
        (if execName[]<>NONE then execName[]->setEXECNAMEparam if);
     exit execName[]
     #);
   
   runNewDebuggee:
     (# success: @Boolean;
        rerun: @Boolean;
     enter rerun
     do <<SLOT runnewdebuggee:descriptor>>
     exit success
     #);
   
   setStepIntoBreaks:
     (# uss: @debuggee.userSingleStepBreaker
          (# init::<
               (# cancelled:: (# do TRUE->continue #);
                  unknownCode::
                    (#
                    do ('Missing debug info. Cannot step.','Warning')
                         ->gui.alertInfo;
                       TRUE->continue;
                    #);
               #);
          #);
     exit not uss.init
     #);

   setStepOverBreaks:
     (# uss: @debuggee.userStepOverBreaker
          (# init::<
               (# cancelled:: (# do TRUE->continue #);
                  unknownCode::
                    (#
                    do ('Missing debug info. Cannot step.','Warning')
                         ->gui.alertInfo;
                       TRUE->continue;
                    #);
               #);
          #);
     exit not uss.init
     #);

   doStepOver:
     (#
     do (if debuggeeIsReady then 
            (if setStepOverBreaks then doContinue if)
        if);
     #);
   doStepInto: 
     (# 
     do (if debuggeeIsReady then 
            (if setStepIntoBreaks then doContinue if)
        if);
     #);
   doContinue:
     (#
     do debuggee.processComm.continue;
        'Running'->gui.putpinfo;
        waitersem.V;
     #);
   doStop:
     (# 
     do (if debuggeeIsRunning then 
            TRUE->stopped; debuggee.processComm.stop 
        if)
     #);
   
   stopped: @Boolean; (*  TRUE if doStop was called. *)
   
   (* procwaiter
    * ==========
    * 
    * procwaiter is a coroutine doing the job of waiting for the debuggee
    * to stop. Using a separate coroutine for this job allows valhalla to
    * handle user-events while waiting.
    * 
    * procwaiter blocks on waitersem until it should wait for the debuggee
    * to stop. Then it blocks on a call to debuggee.processComm.wait. *)
   
   waitersem: @semaphore; 
   procwaiter: @|System (# do <<SLOT procwaiter:descriptor>> #);
   
   mystackbrowser: gui.main.stackbrowser
     (# stackbrowserEncloserType::
          (# openNewCodeView::
               (# 
               do cast[]->newcodemoveable
                  (# acceptFound::
                       (#
                       do contents.browser.codePane.codeViews.find
                          (# predicate:: (# do (found[]=current[])->value #) 
                          do true->value
                          #)
                       #)
                  #);
               #);
             openNewObjectView:: 
               (# 
               do bo[]->newobjectmoveable
                  (# acceptFound::
                       (#
                       do true->value;
                          contents.browser.objectPane.objectViews.find
                          (# predicate::
                               (# do (found[]=current.sov.contents[])->value #)
                          do false->value
                          #)
                       #)
                  #);
               #);
             selectCodeView:: (# <<SLOT selectCodeView: dopart>> #);
             selectObjectView:: (# <<SLOT selectObjectView: dopart>> #);
             alertInfo:: (# do (inf[],title[])->gui.alertInfo #);
          #);
     #);
   
   mystackview: gui.main.stackviewmoveable
     (# listEncloserType::
          (# openNewCodeView:: (# do cast[]->newcodemoveable #);
             openNewObjectView:: 
               (# 
               do (bo[],true)->gui.main.OpenMoveableObjectView
                  (# getFather:: (# do gui.main.objworld[]->father[]#)#)
               #);
             alertInfo:: (# do (inf[],title[])->gui.alertInfo #);
          #);
     #);
   
   mycodeview: gui.main.myCodemoveable
     (# private: @<<SLOT mycodeviewPrivate: descriptor>>;
        wriggle::<
          (# <<SLOT mycodeviewWriggle: dopart>> #);
        selectNode:<
          (# node: ^astInterface.ast 
          enter node[]
          <<SLOT mycodeviewSelectNode: dopart>>
          #);
        open::
          (# <<SLOT mycodeviewopen: dopart>> #);
     #);
   
   lastEditor: ^gui.window.codemoveableEditor;
   newcodemoveable: 
     (# openIfNotFound:< BooleanValue (# do true->value; INNER #);
        wriggleIfFound:< BooleanValue
          (# found: ^gui.main.codemoveableEditor;
          enter found[]
          do true->value; INNER
          #);
        acceptFound:< BooleanValue
          (# found: ^gui.main.codemoveableEditor;
          enter found[]
          do found.isolated->value; INNER
          #);
        cast: ^astInterface.ast;
     enter cast[]
     <<SLOT newcodemoveable:dopart>>
     #);
   newobjectmoveable: 
     (# openIfNotFound:< BooleanValue (# do true->value; INNER #);
        wriggleIfFound:< BooleanValue
          (# found: ^gui.main.objectView
          enter found[]
          do true->value; INNER
          #);
        acceptFound:< BooleanValue
          (# found: ^gui.main.objectView
          enter found[]
          do INNER
          #);
        bo: ^betaObject;
     enter bo[]
     <<SLOT newobjectmoveable:dopart>>
     #);
   
   cmdlineprompt: @gui.promptForArgs
     (# okCalled: @Boolean;
        epdb: ^executableParamDB;
        ok::
          (# 
          do TRUE->okCalled;
             epdb.clear;
             (for i:argc repeat
                  argv[i][]->epdb.append;
             for);
          #);
        cancel:: (# do FALSE->okCalled #);
        doPopup:
          (# defaultTxt: @Text;
             prompt: ^text;
             de: @diskEntry;
          do getExecutableParamDB->epdb[];
             epdb.scan
             (# 
             do findSpace: 
                  (# 
                  do ' '->current.findAll 
                     (# 
                     do '"'->defaultTxt.append;
                        current[]->defaultTxt.append;
                        '"'->defaultTxt.append;
                        ' '->defaultTxt.append;
                        leave findSpace;
                     #);
                     current[]->defaultTxt.append;
                     ' '->defaultTxt.append;
                  #);
             #);
             getEXECNAMEparam->de.path;
             de.path.name->prompt[];
             'Enter parameters for `' -> prompt.prepend;
             ''':' -> prompt.append;
             (gui.main[], 'Command Line Editor', prompt[],defaultTxt[])->popup;
          exit okCalled
          #)
     #);
   
   rereadprompt: gui.noteUser
     (# t: @Text;
     do 'Executable `%s'' changed on disk'->t.putFormat
        (# de: @diskEntry;
        do getEXECNAMEparam->de.path;
           de.path.name->s;
        #);
        gui.main[]->owner[];
        'Executable Changed'->Title[];
        t[]->message[];
     #);   
   
   doEditCommandLine:
     (# 
     do cmdlineprompt.doPopup;
     #);
   
   newstackview:
     (# comp: ^processInterface.remoteBetaObject;
     enter comp[]
     <<SLOT newstackviewbody:dopart>>
     #);
   
   newstackbrowser:
     (# comp: ^processInterface.remoteBetaObject;
     enter comp[]
     <<SLOT newstackbrowserbody:dopart>>
     #);
   
   sockgen: @socketGenerator;
   
   gui: @valhallaGUI
     (# newCodeView::
          (# do cast[]->newcodemoveable #);
        ymerBrowserWindow::<
          (# <<SLOT debuggerBrowserWindowLib: attributes>>;
             browserType::<
               (# editorEncloserType::< 
                    (# tryclose::< (# do false->okToClose #) #)
               #);
             workspace::
               (# menubarType::
                    (# open::
                         (# <<SLOT workspaceMenubarOpen: dopart>> #)
                    #)
               #);
             codeViewWindow::
               (# menubarType::
                    (# open::
                         (# <<SLOT codeViewWindowMenubarOpen: dopart>> #)
                    #)
               #);
             onCodeViewOpen::
               (# <<SLOT onCodeViewOpen: dopart>> #);
             onTerminateApplication::
               (# do false->okToTerminate; hide #);
             quit:: (# do false->okToClose; hide #);
             eventhandler::<
               (# onAboutToClose:: (# do false->okToClose; hide #) #);
             menubarType::
               (# open:: (# <<SLOT guiMenubarTypeOpen: dopart>> #) #);
             open::
               (# 
               do THIS(ymerBrowserWindow).hide; 
               #);
          #);
        
        (* The following final bound virtuals are declared in valhallaGUI,
         * and called by menus and buttons in the user-interface. *)
        
        newDebuggee::
          (# changedOutside, otherError: @boolean
          do (if newExecName<>NONE then
                 ensureKilled; 
                 doEditCommandLine;
                 FALSE->runNewDebuggee;
                 (if debuggee[]<>NONE then
                     ('program',debuggee.MPS.BETA.DescriptorForm)
                       ->debuggee.DBmanager.slotnameToGroups
                     (# do current[]->loadSources #);
                 if)
             if)
          #);
        debuggeeStatus::
          (# do debuggeeIsReady->value #);
        debuggeeRerun::
          (# 
          do (if rerunStatus then
                 ensureKilled;
                 TRUE->runNewDebuggee
             if)
          #);
        rerunStatus::
          (# 
          do (if debuggee[]<>NONE then
                 debuggeeIsReady or debuggee.terminated ->value;
              else
                 TRUE->value;
             if);
             value and (getEXECNAMEparam<>NONE)->value;
          #);
        
        killDebuggee::
          (#
          do (if debuggeeIsReady then ensureKilled; 'Killed'->putpinfo if)
          #);
        killStatus:: debuggeeIsReady (# #);
                       
        source:: 
          (# x,y: @integer
          do sources.position->(x,y);
             (if (x=0) and (y=0) then
                 gui.main.position->(x,y);
                 (x+10,y+10)->sources.position
             if);
             sources.show;
             sources.wriggle
          #);
        sourceStatus:: (# do true->value #);
        
        
        editenv::
          (# 
          do (if theEnveditor[]<>NONE then theEnveditor.wriggle;
              else &envedittype[]->theEnveditor[]; theEnveditor.open;
             if);
          #);
        editenvStatus:: TrueObject;
        
        editcmdline::
          (# 
          do doEditCommandLine;
          #);
        editcmdlineStatus:: TrueObject;
        
        quit:: 
          (# 
          do (if debuggeeIsReady and (debuggee[]<>none) then
                 debuggee.kill; onTerminate
             if)
          #);
        
        debuggeeContinue:: (# do (if continueStatus then doContinue if) #);
        continueStatus:: debuggeeIsReady (# #);
        
        debuggeeStepOver:: (# do doStepOver #);
        stepOverStatus:: debuggeeIsReady (# #);
        
        debuggeeStepInto::
          (# 
          do doStepInto;
          #);
        stepIntoStatus:: debuggeeIsReady;
        
        debuggeeStop:: (# do doStop #);
        stopStatus:: debuggeeIsRunning (# #);
        
        debuggeeActiveStack:: 
          (# 
          do (if activeStackStatus then
                 debuggee.currentRemoteComponent->newstackview
             if);
          #);
        activeStackStatus::
          (# 
          do (if (debuggeeIsReady->value) then
                 (debuggee.curComp<>0)->value 
             if);
          #);
        debuggeeStackBrowser:: 
          (# 
          do (if stackBrowserStatus then
                 debuggee.currentRemoteComponent->newstackbrowser
             if);
          #);
        stackBrowserStatus::
          (# 
          do (if (debuggeeIsReady->value) then
                 (debuggee.curComp<>0)->value 
             if);
          #);
        
        debuggeeCurObj::
          (# 
          do (if curObjStatus then
                 (debuggee.currentRemoteBetaObject,FALSE)
                   ->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if);
          #);
        curObjStatus::
          (# 
          do (if (debuggeeIsReady->value) then (debuggee.curObj<>0)->value if);
          #);
        
        debuggeeCurCode:: (# do <<SLOT debuggeeCurCode:descriptor>> #);
        curCodeStatus::
          (# 
          do debuggeeIsReady->value;
             (if value then
                 (debuggee.pc<>0) ->value;
             if);
          #);
        
        debuggeeCurComp::
          (# 
          do (if curCompStatus then
                 (debuggee.currentRemoteComponent,FALSE)
                   ->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if);
          #);
        curCompStatus::
          (# 
          do (if (debuggeeIsReady->value) then (debuggee.curComp<>0)->value if)
          #);
        
        onTerminate:: 
          (#
          do main.status.setenabling;
             0->setPIDparam; 
             objectviews.newscan (# do cur.encl.tryclose #);
             stackviews.newscan (# do cur.encl.tryclose #);
          #);
        
        onMoveablesInsert:: (# #);
        
        codeviews: @codemoveableEditorList;
        stackviews: @stackviewlistlist;
        objectviews: @objectviewList
          (# onInsert::
               (# addItemMenuItems: 
                    theObjectView.addObjectViewItemMenuItems
                    (# show:: (# do comp[]->newstackview #);
                       showC:: (# do ast[]->newcodemoveable; #);
                    #); 
                  
                  addmovItems: 
                    movo.addObjectViewactionedMenuItems
                    (# show:: (# do comp[]->newstackview #);
                       showC:: (# do ast[]->newcodemoveable; #);
                    #);
                  
                  mov: ^main.moveable;
                  movo: ^main.moveableObjectView;
               do 
                  theObjectView.encl.getMoveable->mov[];
                  (if mov[]<>NONE then
                      (if mov##<=main.moveableObjectView## then
                          mov[]->movo[];
                          addmovItems##->movo.movMenu.onOpen.appendAction;
                      if);
                  if);
                  addItemMenuItems##
                    ->theObjectView.itemMenu.onOpen.appendAction;
               #);
             onDelete::
               (# 
               #);
          #);
        mainType::
          (# menubarType::
               (# open:: (# <<SLOT mainTypeMenubarTypeOpen: dopart>> #) #)
          #);
        init:: (* gui.init *)
          (#  
          do stackviews.init; stackviews[]->objectPool.put;
             codeviews.init; codeviews[]->objectPool.put;
             objectviews.init; objectviews[]->objectPool.put;
          #)
     #);
   loadSources:
     (# exec: ^text
     enter exec[]
     do exec[]
          ->gui.mps.ast.expandToFullPath
          ->gui.sources.appendProject;
        gui.sources.appendDone

     #);
do thespawner.init; thespawner[]->objectPool.put;
   0->sockgen.port; sockgen.bind; sockgen[]->objectPool.put;
   gui.init;
   parseValhallaParams;
   procwaiter[]->fork;
   (if getEXECNAMEparam<>NONE then
       FALSE->runNewDebuggee;
       (if debuggee[]<>NONE then
           ('program',debuggee.MPS.BETA.DescriptorForm)
             ->debuggee.DBmanager.slotnameToGroups
           (# do current[]->loadSources #);
       if)
   if)
#)

