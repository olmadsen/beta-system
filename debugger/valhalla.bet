ORIGIN '~beta/guienv/v1.3.1/guienvsystemenv';
BODY 'private/valhallabody';

INCLUDE 'processInterface';
INCLUDE 'processCommCodes';
INCLUDE 'breakpoints';

INCLUDE 'UI/valhallaGUI';
INCLUDE 'UI/GUIprocess';
INCLUDE 'UI/stackview';
INCLUDE 'UI/objectviewadds';
INCLUDE 'UI/codemoveable';
INCLUDE 'UI/grouplist';
INCLUDE 'UI/enveditor';
INCLUDE '~beta/guienv/v1.3.1/utils/promptForArgs';

INCLUDE '~beta/objectbrowser/v2.0/systemenvcoroutinespawner';
INCLUDE '~beta/objectbrowser/v2.0/UI/moveable';

INCLUDE '~beta/guienv/v1.3.1/stddialogs';

INCLUDE '~beta/process/v1.4/systemComm';

(*OBJFILE default '~beta/debugger/v2.0/betarun/$/C/valhallaFIFOS.o';*)

--- lib:attributes ---

DEFAULT_RECTANGLE: (# exit ((0,0),(250,250)) #);

--- program:descriptor ---
systemenv
(# windowEnvType:: valhallaGUI;
   setWindowEnv:: (# do gui[]->theWindowEnv[] #);
   
   thespawner: @systemenvspawner;
   
   debuggee: ^gui.GUIprocess; (* The process being debugged. *)
   sources: ^sourcesType;     (* source browser for debuggee. *)
   
   sourcesType: gui.sourceBrowser
     (# onClose:: (# do NONE->sources[] #);
        openCodeView:: 
          (#
          do a[]->newcodemoveable 
             (# acceptFound::
                  (# 
                  do (found[]<>sbcodeview[])->value
                  #);
             #);
          #);
        codeViewExists::
          (# 
          do ff.root[]->newcodemoveable
             (# openIfNotFound:: 
                  (# 
                  do FALSE->value->THIS(codeViewExists).value
                  #);
                wriggleIfFound::
                  (# 
                  do gui.main.bringToFront;
                     TRUE->value->THIS(codeViewExists).value
                  #);
                acceptFound::
                  (# 
                  do (found[]<>sbcodeview[])->value
                  #);
             #);
          #);
        generalInfo:: (# do inf[]->gui.putinfo #);
        errorInfo:: (# do (inf[],'ERROR!')->gui.alertInfo #);
        continue:: (# do (if debuggeeIsReady then doContinue if) #);
        processIsReady:: (# do debuggeeIsReady->value #);
     #);
   
   theEnveditor: ^enveditType; (* Environment editor. *)
   enveditType: gui.envEditor (# onClose:: (# do NONE->theEnveditor[] #)#);
   
   debuggeeIsRunning: BooleanValue
     (# 
     do (if debuggee[]<>NONE then 
            (debuggee.running) and (not debuggee.terminated)->value 
         else FALSE->value
        if);
     #);
   debuggeeIsReady: BooleanValue
     (# 
     do (if debuggee[]<>NONE then 
            (not debuggee.running) and (not debuggee.terminated)->value 
         else FALSE->value
        if);
     #);
   ensureKilled:
     (# 
     do (if debuggee[]<>NONE then
            (if not debuggee.terminated then
                debuggee.kill; gui.onTerminate;
            if);
        if);
     #);
   
   getFrame:
     (# done:<
          (# result: @rectangle;
          enter result
          do INNER
          #);
     do 
        (if dragOutlineOnOpen->gui.getOption then
            DEFAULT_RECTANGLE->gui.main.objworld.getOutline
            (# done:: (# do result->THIS(getFrame).done #)#)
         else
            DEFAULT_RECTANGLE->done;
        if);   
     #);
   
   newExecName:
     (# execName: ^Text;
     do gui.main[]->gui.fileSelectionDialog
        (#
        do 'Debug executable:'->label[];
        #)->execName[];
        (if execName[]<>NONE then execName[]->setEXECNAMEparam if);
     exit execName[]
     #);
   
   runNewDebuggee:
     (# success: @Boolean;
        rerun: @Boolean;
     enter rerun
     do <<SLOT runnewdebuggee:descriptor>>
     exit success
     #);
   
   setStepIntoBreaks:
     (# uss: @debuggee.userSingleStepBreaker
          (# init::<
               (# cancelled:: (# do TRUE->continue #);
                  unknownCode::
                    (#
                    do ('Missing debug info. Cannot step.','Warning')
                         ->gui.alertInfo;
                       TRUE->continue;
                    #);
               #);
          #);
     exit not uss.init
     #);

   setStepOverBreaks:
     (# uss: @debuggee.userStepOverBreaker
          (# init::<
               (# cancelled:: (# do TRUE->continue #);
                  unknownCode::
                    (#
                    do ('Missing debug info. Cannot step.','Warning')
                         ->gui.alertInfo;
                       TRUE->continue;
                    #);
               #);
          #);
     exit not uss.init
     #);

   doStepOver:
     (#
     do (if debuggeeIsReady then 
            (if setStepOverBreaks then doContinue if)
        if);
     #);
   doStepInto: 
     (# 
     do (if debuggeeIsReady then 
            (if setStepIntoBreaks then doContinue if)
        if);
     #);
   doContinue:
     (#
     do debuggee.processComm.continue;
        'Running'->gui.putpinfo;
        waitersem.V;
     #);
   doStop:
     (# 
     do (if debuggeeIsRunning then 
            TRUE->stopped; debuggee.processComm.stop 
        if)
     #);
   
   stopped: @Boolean; (*  TRUE if doStop was called. *)
   
   (* procwaiter
    * ==========
    * 
    * procwaiter is a coroutine doing the job of waiting for the debuggee
    * to stop. Using a separate coroutine for this job allows valhalla to
    * handle user-events while waiting.
    * 
    * procwaiter blocks on waitersem until it should wait for the debuggee
    * to stop. Then it blocks on a call to debuggee.processComm.wait. *)
   
   waitersem: @semaphore; 
   procwaiter: @|System (# do <<SLOT procwaiter:descriptor>> #);
   
   mystackview: gui.main.stackviewmoveable
     (# listEncloserType::
          (# openNewCodeView:: (# do cast[]->newcodemoveable #);
             openNewObjectView:: 
               (# 
               do (bo[],force)->gui.main.OpenMoveableObjectView
                  (# getFather:: (# do gui.main.objworld[]->father[]#)#)
               #);
             alertInfo:: (# do (inf[],title[])->gui.alertInfo #);
          #);
     #);
   
   mycodeview: gui.main.codemoveable
     (# editorEncloserType::
          (# continue:: (# do (if debuggeeIsReady then doContinue if) #);
             processIsReady:: (# do debuggeeIsReady->value #);
             newCodeView:: (# do node[]->newcodemoveable #);
             generalInfo:: (# do inf[]->gui.putinfo #);
             errorInfo:: (# do (inf[],'Error!')->gui.alertInfo #);
          #);
     #);
   
   lastEditor: ^gui.main.codemoveableEditor;
   newcodemoveable: 
     (# openIfNotFound:< BooleanValue (# do true->value; INNER #);
        wriggleIfFound:< BooleanValue
          (# found: ^gui.main.codemoveableEditor;
          enter found[]
          do true->value; INNER
          #);
        acceptFound:< BooleanValue
          (# found: ^gui.main.codemoveableEditor;
          enter found[]
          do true->value; INNER
          #);
        cast: ^astInterface.ast;
     enter cast[]
     <<SLOT newcodemoveable:dopart>>
     #);
   
   cmdlineprompt: @gui.promptForArgs
     (# okCalled: @Boolean;
        epdb: ^executableParamDB;
        ok::
          (# 
          do TRUE->okCalled;
             epdb.clear;
             (for i:argc repeat
                  argv[i][]->epdb.append;
             for);
          #);
        cancel:: (# do FALSE->okCalled #);
        doPopup:
          (# defaultTxt: @Text;
          do getExecutableParamDB->epdb[];
             epdb.scan
             (# 
             do findSpace: 
                  (# 
                  do ' '->current.findCh 
                     (# 
                     do '"'->defaultTxt.append;
                        current[]->defaultTxt.append;
                        '"'->defaultTxt.append;
                        ' '->defaultTxt.append;
                        leave findSpace;
                     #);
                     current[]->defaultTxt.append;
                     ' '->defaultTxt.append;
                  #);
             #);
             (gui.main[],'Command Line Editor',
             'Enter parameters:',defaultTxt[])->popup;
          exit okCalled
          #)
     #);
   
   rereadprompt: gui.noteUser
     (# t: @Text;
     do 'Executable "%s" changed on disk'->t.putFormat
        (# de: @diskEntry;
        do getEXECNAMEparam->de.path;
           de.path.name->s;
        #);
        gui.main[]->owner[];
        'Executable Changed'->Title[];
        t[]->message[];
     #);   
   
   doEditCommandLine:
     (# 
     do cmdlineprompt.doPopup;
     #);
   
   newstackview:
     (# comp: ^processInterface.remoteBetaObject;
     enter comp[]
     <<SLOT newstackviewbody:dopart>>
     #);
   
   sockgen: @socketGenerator;
   
   gui: @valhallaGUI
     (# 
        (* The following final bound virtuals are declared in valhallaGUI,
         * and called by menus and buttons in the user-interface. *)
        
        newDebuggee::
          (# 
          do (if newExecName<>NONE then ensureKilled; FALSE->runNewDebuggee if)
          #);
        
        debuggeeRerun::
          (# 
          do (if rerunStatus then ensureKilled; TRUE->runNewDebuggee if)
          #);;
        rerunStatus::
          (# 
          do (if debuggee[]<>NONE then
                 debuggeeIsReady or debuggee.terminated ->value;
              else
                 TRUE->value;
             if);
             value and (getEXECNAMEparam<>NONE)->value;
          #);
        
        killDebuggee::
          (#
          do (if debuggeeIsReady then ensureKilled; 'Killed'->putpinfo if)
          #);
        killStatus:: debuggeeIsReady (# #);
                       
        source:: 
          (#
          do (if debuggeeIsReady then
                 (if sources[]<>NONE then sources.wriggle;
                  else  &sourcesType[]->sources[]; debuggee[]->sources.open;
                 if);
             if)
          #);
        sourceStatus:: debuggeeIsReady (# #);
        
        
        editenv::
          (# 
          do (if theEnveditor[]<>NONE then theEnveditor.wriggle;
              else &envedittype[]->theEnveditor[]; theEnveditor.open;
             if);
          #);
        editenvStatus:: TrueObject;
        
        editcmdline::
          (# 
          do doEditCommandLine;
          #);
        editcmdlineStatus:: TrueObject;
        
        quit:: 
          (# 
          do (if debuggeeIsReady then debuggee.kill; onTerminate if)
          #);
        
        debuggeeContinue:: (# do (if continueStatus then doContinue if) #);
        continueStatus:: debuggeeIsReady (# #);
        
        debuggeeStepOver:: (# do doStepOver #);
        stepOverStatus:: debuggeeIsReady (# #);
        
        debuggeeStepInto::
          (# 
          do doStepInto;
          #);
        stepIntoStatus:: debuggeeIsReady;
        
        debuggeeStop:: (# do doStop #);
        stopStatus:: debuggeeIsRunning (# #);
        
        debuggeeActiveStack:: 
          (# 
          do (if activeStackStatus then
                 debuggee.currentRemoteComponent->newstackview
             if);
          #);
        activeStackStatus::
          (# 
          do (if (debuggeeIsReady->value) then
                 (debuggee.curComp<>0)->value 
             if);
          #);
        
        debuggeeCurObj::
          (# 
          do (if curObjStatus then
                 (debuggee.currentRemoteBetaObject,FALSE)
                   ->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if);
          #);
        curObjStatus::
          (# 
          do (if (debuggeeIsReady->value) then (debuggee.curObj<>0)->value if);
          #);
        
        debuggeeCurCode:: (# do <<SLOT debuggeeCurCode:descriptor>> #);
        curCodeStatus::
          (# 
          do debuggeeIsReady->value;
             (if value then
                 (debuggee.pc<>0) ->value;
             if);
          #);
        
        debuggeeCurComp::
          (# 
          do (if curCompStatus then
                 (debuggee.currentRemoteComponent,FALSE)
                   ->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if);
          #);
        curCompStatus::
          (# 
          do (if (debuggeeIsReady->value) then (debuggee.curComp<>0)->value if)
          #);
        
        onTerminate:: 
          (#
          do main.status.setenabling;
             0->setPIDparam; 
             objectviews.newscan (# do cur.encl.tryclose #);
             stackviews.newscan (# do cur.encl.tryclose #);
          #);
        
        onMoveablesInsert:: (# #);
        
        codeviews: @codemoveableEditorList
          (# onInsert::
               (# 
               #);
             onDelete::
               (# 
               #);
          #);
        stackviews: @stackviewlistlist
          (# onInsert::
               (# 
               #);
             onDelete::
               (# 
               #);
          #);
        objectviews: @objectviewList
          (# onInsert::
               (# addItemMenuItems: 
                    theObjectView.addObjectViewItemMenuItems
                    (# show:: (# do comp[]->newstackview #)#); 
                  
                  addmovItems: 
                    movo.addObjectViewactionedMenuItems
                    (# show:: (# do comp[]->newstackview #)#);
                  
                  mov: ^main.moveable;
                  movo: ^main.moveableObjectView;
               do 
                  theObjectView.encl.getMoveable->mov[];
                  (if mov[]<>NONE then
                      (if mov##<=main.moveableObjectView## then
                          mov[]->movo[];
                          addmovItems##->movo.movMenu.onOpen.appendAction;
                      if);
                  if);
                  addItemMenuItems##
                    ->theObjectView.itemMenu.onOpen.appendAction;
               #);
             onDelete::
               (# 
               #);
          #);
                  
        mainType::
          (# menuBarType::
               (# breakPointMenu: @bettermenu
                    (# breakPointItem: item
                         (# onSelect::
                              (# 
                              do (if bm.impi[]<>NONE then
                                     bm.impi.cast[]->newcodemoveable
                                 if);
                              #);
                            bm: ^processInterface.breakManager;
                            newBreak: new (# enter bm[] #);
                         #);
                       eventHandler::<
                         (# onSelect::<
                              (# bml: ^processInterface.breakManagerList;
                              do clear;
                                 (if debuggeeIsReady then
                                     debuggee.getBreakManagerList->bml[];
                                     (if bml.size=0 then
                                         'No Breakpoints'->(&item[]).new;
                                      else
                                         bml.scan
                                         (# bpi: ^breakPointItem; num: @Text;
                                         do &breakPointItem[]->bpi[];
                                            num.clear; current.number->num.putInt;
                                            (if current.impi[]<>NONE then
                                                ': '->num.append;
                                                current.impi.cast.frag.name
                                                  ->num.append;
                                            if);
                                            (num[],current[])->bpi.newBreak;
                                         #);
                                     if)
                                  else
                                     'No Process'->(&item[]).new;
                                 if);
                              #);
                         #)
                    #);
                  open::
                    (# 
                    do 'Breakpoints'->breakpointMenu.new; 
                       breakpointMenu[]->append;
                    #);
               #);
          #);
        init:: (* gui.init *)
          (#  
          do stackviews.init; stackviews[]->objectPool.put;
             codeviews.init; codeviews[]->objectPool.put;
             objectviews.init; objectviews[]->objectPool.put;
          #)
     #);
do thespawner.init; thespawner[]->objectPool.put;
   0->sockgen.port; sockgen.bind; sockgen[]->objectPool.put;
   gui.init;
   parseValhallaParams;
   procwaiter[]->fork;
   (if getEXECNAMEparam<>NONE then FALSE->runNewDebuggee if);
#)

