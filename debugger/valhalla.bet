ORIGIN '~beta/guienv/guienvsystemenv' (*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
;
INCLUDE 'processInterface'
        'processCommCodes'
        'breakpoints'
        'UI/valhallaGUI'
        'UI/GUIprocess'
        'UI/stackview'
        'UI/stackbrowser'
        'UI/objectviewadds'
        'UI/enveditor'
        '~beta/guienv/utils/promptForArgs'
        '~beta/toollibs/utils/options'
        '~beta/toollibs/utils/systemenvcompspawner'
        '~beta/guienv/stddialogs'
        '~beta/guienv/utils/simplemenu'
        '~beta/process/systemcomm'
        '~beta/objectbrowser/UI/evaluatormoveable'
        '~beta/compiler/DYN/dynlib'
        '~beta/compiler/DYN/AstOfObject'
        '~beta/compiler/DYN/treelib'
        '~beta/pretty/astviewer';
BODY 'private/valhallabody';
BODY 'private/breakpointMenus';
-- lib: Attributes --
DEFAULT_SIZE: (#  exit (250,250) #);   

-- program: Descriptor --
systemenv
  (#
     <<SLOT valhallalib:Attributes>>;
     windowEnvType:: valhallaGUI;
     setWindowEnv:: 
       (#  do gui[]->theWindowEnv[] #);
     thespawner: @systemenvspawner;
     debuggee: ^gui.GUIprocess;
     (* The process being debugged. *)
     theEnveditor: ^enveditType;
     (* Environment editor. *)
     enveditType: gui.envEditor
       (#
          onClose:: 
            (#  do none ->theEnveditor[] #)
       #);
     debuggeeIsRunning: BooleanValue
       (# 
       do
          (if debuggee[] <> none then
              (debuggee.running) and
              (not debuggee.terminated)->value
           else
              FALSE->value
          if);
          
       #);
     debuggeeIsReady: BooleanValue
       (# 
       do
          (if debuggee[] <> none then
              (not debuggee.running) and (not debuggee.terminated)->value
           else
              FALSE->value
          if);
          
       #);
     ensureKilled:
       (# 
       do
          (if debuggee[] <> none then
              (if not debuggee.terminated then
                  debuggee.kill; gui.onTerminate; 
              if);
              
          if);
          
       #);
     getFrame:
       (#
          done:< (# result: @rectangle;  enter result do INNER #);
          pos: @point;
          res: @rectangle;
          h,v: @integer
       do
          gui.main.objworld.size->(h,v);
          'DEFAULT_H'
            ->gui.globalOptions.getIntegerOption
              (# found::  (#  do value->pos.h #) #);
          (if pos.h > h-50 then 0->pos.h if);
          ('DEFAULT_H',15+pos.h)->gui.globalOptions.setIntegerOption;
          'DEFAULT_V'
            ->gui.globalOptions.getIntegerOption
              (# found::  (#  do value->pos.v #) #);
          (if pos.v > v-50 then 0->pos.v if);
          ('DEFAULT_V',15+pos.v)->gui.globalOptions.setIntegerOption;
          DEFAULT_SIZE->res.size;
          pos->res.offset;
          (if dragOutlineOnOpen->gui.getOption then
              res
                ->gui.main.objworld.getOutline
                  (# done::  (#  do result->THIS(getFrame).done #) #)
           else
              res->done; 
          if);
          
       #);
     newExecName:
       (# execName: ^Text; 
       do
          gui.main[]
            ->gui.fileSelectionDialog
              (#  do 'Debug executable:'->label[];  #)->execName[];
          (if execName[] <> none then execName[]->setEXECNAMEparam if);
          
       exit execName[]
       #);
     runNewDebuggee:
       (# success: @Boolean; rerun: @Boolean; 
       enter rerun
       do <<SLOT runnewdebuggee:Descriptor>>
       exit success
       #);
     setStepIntoBreaks:
       (#
          uss:
            @debuggee.userSingleStepBreaker
            (#
               init::< 
                 (#
                    cancelled:: 
                      (# 
                      do TRUE->continue
                      #);
                    unknownCode:: 
                      (# 
                      do
                         ('Missing debug info. Cannot step.','Warning')
                           ->gui.alertInfo;
                         TRUE->continue;
                         
                      #);
                    
                 #);
               
            #);
          
       exit not uss.init
       #);
     setStepOverBreaks:
       (#
          uss: @debuggee.userStepOverBreaker
            (#
               init::< 
                 (#
                    cancelled::  (#  do TRUE->continue #);
                    unknownCode:: 
                      (# 
                      do
                         ('Missing debug info. Cannot step.','Warning')
                           ->gui.alertInfo;
                         TRUE->continue;
                         
                      #);
                    
                 #);
               
            #);
          
       exit not uss.init
       #);
     doStepOver:
       (# 
       do
          (if debuggeeIsReady then
              (if setStepOverBreaks then doContinue if)
          if);
          
       #);
     doStepInto:
       (# 
       do
          (if debuggeeIsReady then
              (if setStepIntoBreaks then doContinue if)
          if);
          
       #);
     doContinue:
       (# 
       do debuggee.processComm.continue; 'Running'->gui.putpinfo; waitersem.V; 
       #);
     doStop:
       (# 
       do
          (if debuggeeIsRunning then
              TRUE->stopped; debuggee.processComm.stop
          if)
       #);
     stopped: @Boolean;
     (*  TRUE if doStop was called. *)
     (* procwaiter
      * ==========
      * 
      * procwaiter is a coroutine doing the job of waiting for the debuggee
      * to stop. Using a separate coroutine for this job allows valhalla to
      * handle user-events while waiting.
      * 
      * procwaiter blocks on waitersem until it should wait for the debuggee
      * to stop. Then it blocks on a call to debuggee.processComm.wait. *)
     waitersem: @semaphore;
     procwaiter: @|System (#  do <<SLOT procwaiter:Descriptor>> #);
     mystackbrowser: gui.main.stackbrowser
       (#
          stackbrowserEncloserType:: 
            (#
               openNewCodeView:: 
                 (# 
                 do
                    cast[]
                      ->newcodemoveable
                        (#
                           acceptFound:: 
                             (# 
                             do
                                contents.browser.
                                  codePane.codeViews.find
                                  (#
                                     predicate:: 
                                       (# 
                                       do (found[] = current[])->value
                                       #)
                                  do true->value
                                  #)
                             #)
                        #);
                    
                 #);
               openNewObjectView:: 
                 (# 
                 do
                    bo[]
                      ->newobjectmoveable
                        (#
                           acceptFound:: 
                             (# 
                             do
                                true->value;
                                contents.browser.objectPane.objectViews.find
                                  (#
                                     predicate:: 
                                       (# 
                                       do
                                          (found[] = current.sov.contents[])
                                            ->value
                                       #)
                                  do false->value
                                  #)
                             #)
                        #);
                    
                 #);
               selectCodeView::  (#  <<SLOT selectCodeView:DoPart>> #);
               selectObjectView::  (#  <<SLOT selectObjectView:DoPart>> #);
               alertInfo:: 
                 (# 
                 do
                    (inf[],title[])
                      ->gui.alertInfo
                 #);
               
            #);
          
       #);
     mystackview: gui.main.stackviewmoveable
       (#
          listEncloserType:: 
            (#
               openNewCodeView:: 
                 (# 
                 do cast[]->newcodemoveable
                 #);
               openNewObjectView:: 
                 (# 
                 do
                    (bo[],true)
                      ->
                        gui.main.
                          OpenMoveableObjectView
                        (#
                           getFather:: 
                             (#  do gui.main.objworld[]->father[] #)
                        #)
                 #);
               alertInfo::  (#  do (inf[],title[])->gui.alertInfo #);
               
            #);
          
       #);
     mycodeview: gui.main.myCodemoveable
       (#
          private: @<<SLOT mycodeviewPrivate:Descriptor>>;
          wriggle::< 
            (# 
            <<SLOT mycodeviewWriggle:DoPart>>
            #);
          selectNode:<
            (# node: ^astInterface.ast
            enter node[]
            <<SLOT mycodeviewSelectNode:DoPart>>
            #);
          open:: 
            (# 
            <<SLOT mycodeviewopen:DoPart>>
            #);
          
       #);
     lastEditor: ^gui.window.codemoveableEditor;
     newcodemoveable:
       (#
          openIfNotFound:< BooleanValue (#  do true->value; INNER #);
          wriggleIfFound:< BooleanValue
            (# found: ^gui.main.codemoveableEditor; 
            enter found[]
            do true->value; INNER
            #);
          acceptFound:< BooleanValue
            (# found: ^gui.main.codemoveableEditor; 
            enter found[]
            do found.isolated->value; INNER
            #);
          cast: ^astInterface.ast;
          
       enter cast[]
       <<SLOT newcodemoveable:DoPart>>
       #);
     newobjectmoveable:
       (#
          openIfNotFound:< BooleanValue
            (#  do true->value; INNER #);
          wriggleIfFound:< BooleanValue
            (# found: ^gui.main.objectView
            enter found[]
            do true->value; INNER
            #);
          acceptFound:< BooleanValue
            (# found: ^gui.main.objectView
            enter found[]
            do INNER
            #);
          bo: ^betaObject;
          
       enter bo[]
       <<SLOT newobjectmoveable:DoPart>>
       #);
     cmdlineprompt: @gui.promptForArgs
       (#
          okCalled: @Boolean;
          epdb: ^executableParamDB;
          ok:: 
            (# 
            do
               TRUE->okCalled;
               epdb.clear;
               (for i: argc repeat argv[i][]->epdb.append;  for);
               
            #);
          cancel::  (#  do FALSE->okCalled #);
          doPopup:
            (# defaultTxt: @Text; prompt: ^text; de: @diskEntry; 
            do
               getExecutableParamDB->epdb[];
               epdb.scan
                 (# 
                 do
                    findSpace:
                      (# 
                      do
                         ' '
                           ->current.findAll
                             (# 
                             do
                                '"'->defaultTxt.append;
                                current[]->defaultTxt.append;
                                '"'->defaultTxt.append;
                                ' '->defaultTxt.append;
                                leave findSpace;
                                
                             #);
                         current[]->defaultTxt.append;
                         ' '->defaultTxt.append;
                         
                      #);
                    
                 #);
               getEXECNAMEparam->de.path;
               de.path.name->prompt[];
               'Enter parameters for `'->prompt.prepend;
               ''':'->prompt.append;
               (gui.main[],'Command Line Editor',prompt[],defaultTxt[])->popup;
               
            exit okCalled
            #)
       #);
     rereadprompt: gui.noteUser
       (# t: @Text; 
       do
          'Executable `%s'' changed on disk'
            ->t.putFormat
              (# de: @diskEntry; 
              do getEXECNAMEparam->de.path; de.path.name->s; 
              #);
          gui.main[]->owner[];
          'Executable Changed'->Title[];
          t[]->message[];
          
       #);
     doEditCommandLine: (#  do cmdlineprompt.doPopup;  #);
     newstackview:
       (# comp: ^processInterface.remoteBetaObject; 
       enter comp[]
       <<SLOT newstackviewbody:DoPart>>
       #);
     newstackbrowser:
       (#
          comp:
            ^processInterface.remoteBetaObject;
          
       enter comp[]
       <<SLOT newstackbrowserbody:DoPart>>
       #);
     sockgen: @socketGenerator;
     gui: @valhallaGUI
       (#
          dc: @MPS.AST.valhallaDynamicCompiler;
          dynamicCodeCounter: @integer;
          initCompiler: @
            (# initialised,error: @boolean
            do
               (if not initialised then
                   dc.initDyn;
                   (* screen[]->DC.NT.traceStream[];
                    * screen[]->DC.NT.infoStream[];
		    *)
                   (getEXECNAMEparam,true)->DC.NT.init;
                   'Initialising Dynamic Compiler... '->putText;
                   (getEXECNAMEparam,none ,none )->dc.dynamicTranslate->error;
                   (if error then
                       'The initialisation of the dynamic compiler failed'
                         ->putLine;
                       stop
                    else
                       'done'->putLine
                   if);
                   true->initialised
               if)
            #);
          newCodeView::  (#  do cast[]->newcodemoveable #);
          ymerBrowserWindow::< 
            (#
               <<SLOT debuggerBrowserWindowLib:Attributes>>;
               browserType::< 
                 (#
                    editorEncloserType::< 
                      (# tryclose::<  (#  do false->okToClose #) #)
                 #);
               workspace:: 
                 (#
                    menubarType:: 
                      (# open::  (#  <<SLOT workspaceMenubarOpen:DoPart>> #)
                      #)
                 #);
               codeViewWindow:: 
                 (#
                    menubarType:: 
                      (#
                         open:: 
                           (#  <<SLOT codeViewWindowMenubarOpen:DoPart>> #)
                      #)
                 #);
               onCodeViewOpen:: 
                 (# 
                 <<SLOT onCodeViewOpen:DoPart>>
                 #);
               onTerminateApplication:: 
                 (#  do false->okToTerminate; hide #);
               quit::  (#  do false->okToClose; hide #);
               eventhandler::< 
                 (# onAboutToClose::  (#  do false->okToClose; hide #)
                 #);
               menubarType:: 
                 (# open::  (#  <<SLOT guiMenubarTypeOpen:DoPart>> #) #);
               open::  (#  do THIS(ymerBrowserWindow).hide;  #);
               
            #);
          (* The following final bound virtuals are declared in valhallaGUI,
           * and called by menus and buttons in the user-interface. *)
          newDebuggee:: 
            (# changedOutside,otherError: @boolean
            do
               (if newExecName <> none then
                   ensureKilled;
                   doEditCommandLine;
                   FALSE->runNewDebuggee;
                   (if debuggee[] <> none then
                       ('program',debuggee.MPS.BETA.DescriptorForm)
                         ->debuggee.DBmanager.slotnameToGroups
                           (#  do current[]->loadSources #);
                       
                   if)
               if)
            #);
          debuggeeStatus::  (#  do debuggeeIsReady->value #);
          debuggeeRerun:: 
            (# 
            do (if rerunStatus then ensureKilled; TRUE->runNewDebuggee if)
            #);
          rerunStatus:: 
            (# 
            do
               (if debuggee[] <> none then
                   debuggeeIsReady or debuggee.terminated->value; 
                else
                   TRUE->value; 
               if);
               value and (getEXECNAMEparam <> none )->value;
               
            #);
          killDebuggee:: 
            (# 
            do (if debuggeeIsReady then ensureKilled; 'Killed'->putpinfo if)
            #);
          killStatus:: debuggeeIsReady (#  #);
          source:: 
            (# x,y: @integer
            do
               sources.position->(x,y);
               (if (x = 0) and (y = 0) then
                   gui.main.position->(x,y); (x+10,y+10)->sources.position
               if);
               sources.show;
               sources.wriggle
            #);
          sourceStatus::  (#  do true->value #);
          editenv:: 
            (# 
            do
               (if theEnveditor[] <> none then
                   theEnveditor.wriggle; 
                else
                   &envedittype[]->theEnveditor[]; theEnveditor.open; 
               if);
               
            #);
          editenvStatus:: TrueObject;
          editcmdline::  (#  do doEditCommandLine;  #);
          editcmdlineStatus:: TrueObject;
          quit:: 
            (# 
            do
               (if debuggeeIsReady and (debuggee[] <> none ) then
                   debuggee.kill; onTerminate
               if)
            #);
          debuggeeContinue:: 
            (#  do (if continueStatus then doContinue if) #);
          continueStatus:: debuggeeIsReady (#  #);
          debuggeeStepOver::  (#  do doStepOver #);
          stepOverStatus:: debuggeeIsReady (#  #);
          debuggeeStepInto::  (#  do doStepInto;  #);
          stepIntoStatus:: debuggeeIsReady;
          debuggeeStop::  (#  do doStop #);
          stopStatus:: debuggeeIsRunning (#  #);
          debuggeeActiveStack:: 
            (# 
            do
               (if activeStackStatus then
                   debuggee.currentRemoteComponent->newstackview
               if);
               
            #);
          activeStackStatus:: 
            (# 
            do
               (if (debuggeeIsReady->value) then
                   (debuggee.curComp <> 0)->value
               if);
               
            #);
          debuggeeStackBrowser:: 
            (# 
            do
               (if stackBrowserStatus then
                   debuggee.currentRemoteComponent->newstackbrowser
               if);
               
            #);
          stackBrowserStatus:: 
            (# 
            do
               (if (debuggeeIsReady->value) then
                   (debuggee.curComp <> 0)->value
               if);
               
            #);
          debuggeeCurObj:: 
            (# 
            do
               (if curObjStatus then
                   (debuggee.currentRemoteBetaObject,FALSE)
                     ->gui.main.OpenMoveableObjectView
                       (#
                          moveableObjectViewType::
                           gui.main.moveableObjectViewEvaluator
                            (#
                               openEvaluatorMenuEntry::< 
                                 (# 
                                 do 'DynamicCompilation'->getOption->value
                                 #);
                               onEvaluateButton::< 
                                 (#
                                    originFGname,evaluatorCode,dynamicFGname:
                                      ^text;
                                    aRemoteBetaObject:
                                      ^debuggee.remoteBetaObject;
                                    FF: ^MPS.AST.fragmentForm;
                                    FG,originFG: ^MPS.AST.fragmentGroup;
                                    im: ^imagePair;
                                    error: @boolean;
                                    constructUniqueID:
                                      (#
                                         T: @Text;
                                         timeSec,timeMiliSec: @integer;
                                         timeInMiliSec: @real
                                      do
                                         preciseTime->(timeSec,timeMiliSec);
                                         timeSec->timeInMiliSec;
                                         timeInMiliSec*1000000->timeInMiliSec;
                                         timeInMiliSec+timeMiliSec
                                           ->timeInMiliSec;
                                         timeInMiliSec
                                           ->t.putReal
                                             (#  do 0->precision #)
                                      exit t.copy
                                      #);
                                    aPTI: ^debuggee.prototypeInfo;
                                    anOD: ^MPS.BETACFL.objectDescriptor;
                                    anIndex: @MPS.AST.index;
                                    dataAreaStart,codeAreaStart: @integer;
                                    allocateMemory:
                                      (#
                                         allocationFailed:< exception
                                           (#  do INNER #);
                                         anImage: ^image;
                                         allocatedAreaStart: @integer
                                      enter anImage[]
                                      do
                                         (if anImage.buffer_ptr <> 0 then
                                             'Normal externally allocated data buffer'
                                               ->putLine;
                                             'Buffer size: %i\n'
                                               ->putFormat
                                                 (# 
                                                 do anImage.buffer_size->i
                                                 #);
                                             'Still needs to be implemented'
                                               ->putLine;
                                             stop
                                          else
                                             anImage.LIP
                                               ->
                                                 debuggee.processComm.
                                                   processData.allocateMemory
                                               ->allocatedAreaStart;
                                             (if allocatedAreaStart = 0 then
                                                 allocationFailed
                                             if)
                                         if)
                                      exit allocatedAreaStart
                                      #);
                                    strucAddress,objectAddress: @integer;
                                    trace: @boolean;
                                    dumpMemoryArea:
                                      (#
                                         address,length: @integer;
                                         memoryContents: @integer;
                                         adr,con: @text
                                      enter (address,length)
                                      do
                                         'Address\t\tContents'->putLine;
                                         (for g: length repeat
                                           address+(g-1)*4
                                             ->adr.putHex
                                               (#
                                                  format::< 
                                                    (# 
                                                    do
                                                       true->zeroPadding;
                                                       true->uppercase
                                                    #)
                                               #);
                                           '0x'->adr.prepend;
                                           address+(g-1)*4
                                             ->
                                               debuggee.processComm.processData.
                                                 peekLong
                                             ->con.putHex
                                               (#
                                                  format::< 
                                                    (# 
                                                    do
                                                       true->zeroPadding;
                                                       true->uppercase
                                                    #)
                                               #);
                                           '0x'->con.prepend;
                                           '%s\t%s\n'
                                             ->putFormat
                                               (#  do adr[]->s; con[]->s #);
                                           adr.clear;
                                           con.clear
                                         for)
                                      #);
                                    originObjectAddress,dynamicProtoAddress,
                                      originObjectProtoAddress: @integer;
                                    nameOfDynamicPattern: @text;
                                    theCexternalEntry:
                                      ^MPS.BETACFL.ObjectDenotation;
                                    theAttributes: ^MPS.BETACFL.attributes
                                 do
                                    initCompiler;
                                    debuggee.currentRemoteBetaObject
                                      ->aRemoteBetaObject[];
                                    aRemoteBetaObject.protoAdr
                                      ->
                                        debuggee.utilities.
                                          protoAddressToPrototypeInfo->aPTI[];
                                    aPTI.ofi.groupName[]->originFGname[];
                                    originFGname[]
                                      ->MPS.BETACFL.openBETAfragmentGroup
                                      ->originFG[];
                                    aPTI.objdesc[]->anOD[];
                                    (anOD.index,anOD.frag[])->anIndex;
                                    contents.evaluator.editor.contents.contents
                                      ->evaluatorCode[];
                                    'dynamicPattern'
                                      ->nameOfDynamicPattern.append;
                                    dynamicCodeCounter
                                      ->nameOfDynamicPattern.putInt;
                                    ': external '->evaluatorCode.prepend;
                                    nameOfDynamicPattern[]
                                      ->evaluatorCode.prepend;
                                    'dynamicCode'
                                      ->MPS.BETACFL.makeBETAfragmentForm->FF[];
                                    (MPS.BETACFL.ObjectDenotation,
                                     'cExternalEntry',FF[])
                                      ->MPS.BETACFL.parseText
                                      ->theCexternalEntry[];
                                    (MPS.BETA.attributes,evaluatorCode[],FF[])
                                      ->MPS.BETACFL.parseText->theAttributes[];
                                    MPS.BETACFL.doPart
                                      ->theAttributes.suffixWalkForProd
                                        (#
                                           theImperatives:
                                             ^MPS.BETACFL.imperatives;
                                           aDoPart: ^MPS.BETACFL.doPart
                                        do
                                           current[]->aDoPart[];
                                           aDoPart.getImperatives
                                             ->theImperatives[];
                                           (1,theCexternalEntry[])
                                             ->theImperatives.insert
                                        #);
                                    constructUniqueID->dynamicFGname[];
                                    dynamicFGname[]
                                      ->MPS.BETACFL.openBETAfragmentGroup->FG[];
                                    FF.name->FG.fragmentList.deleteLocalName;
                                    FF[]->FG.fragmentList.addFragment;
                                    (if (FG.prop[] <> none ) then
                                        'ORIGIN'
                                          ->FG.prop.addProp
                                            (# 
                                            do originFGname[]->addString
                                            #);
                                        'doneCheck'
                                          ->FG.prop.addProp
                                            (#  do 0->addConst #);
                                        
                                     else
                                        'Prop[] is none'->putLine; stop
                                    if);
                                    FG.markAsChanged;
                                    (FG.name,anIndex[],originFG[])
                                      ->dc.dynamicTranslate->error;
                                    (if not error then
                                        true->dc.getImagePair->IM[];
                                        (if false then
                                            dc.imageList.scan (#  #)
                                        if);
                                        (if 'DebugDynamic'->getOption then
                                            true->trace;
                                            true->IM.trace;
                                            newLine;
                                            newLine;
                                            'ALLOCATION:'->putLine
                                        if);
                                        allocation:
                                          (# 
                                          do
                                             IM.xData.im[]
                                               ->allocateMemory
                                                 (#
                                                    allocationFailed::< 
                                                      (# 
                                                      do
                                                         'data: Allocation failed'
                                                           ->msg.append
                                                      #)
                                                 #)->dataAreaStart;
                                             IM.xCode.im[]
                                               ->allocateMemory
                                                 (#
                                                    allocationFailed::< 
                                                      (# 
                                                      do
                                                         'code: Allocation failed'
                                                           ->msg.append
                                                      #)
                                                 #)->codeAreaStart
                                          #);
                                        (if 'DebugDynamic'->getOption then
                                            'Allocation Succeed'->putLine;
                                            'Datasegment buffer: %s\tCode-segment buffer: %s\n\n'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   dataAreaStart
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s;
                                                   st.clear;
                                                   codeAreaStart
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s
                                                #);
                                            newLine;
                                            newLine;
                                            'RELOCATION:'->putLine
                                        if);
                                        relocation:
                                          (# 
                                          do
                                             (dataAreaStart,codeAreaStart)
                                               ->IM.xAllocImage;
                                             dc.NT[]->IM.xCollectEntries;
                                             dc.NT[]->IM.xRelocate
                                          #);
                                        (if 'DebugDynamic'->getOption then
                                            'Relocation Succeed'->putLine;
                                            newLine;
                                            newLine;
                                            'WRITING RELOCATED SEGMENTS TO DEBUGGEE:'
                                              ->putLine
                                        if);
                                        writeToDebuggee:
                                          (# 
                                          do
                                             IM.xTransferImage
                                               (# 
                                               do
                                                  (outProcessAdr,item)
                                                    ->
                                                      debuggee.processComm.
                                                        processData.pokeLong
                                                      (#
                                                         accessFailure::< 
                                                           (# 
                                                           do
                                                              'writeToDebuggee: Failed to move segments'
                                                                ->msg.append
                                                           #)
                                                      #)
                                               #)
                                          #);
                                        (if 'DebugDynamic'->getOption then
                                            'writeToDebuggee Succeed'->putLine;
                                            newLine;
                                            newLine;
                                            'ADDING GROUP TO DEBUGGEE'->putLine
                                        if);
                                        addingGroup:
                                          (# 
                                          do
                                             IM.dataStart
                                               ->
                                                 debuggee.processComm.
                                                   processData.addGroup
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'AddGroup failed'
                                                           ->msg.append
                                                      #)
                                                 #)
                                          #);
                                        (if 'DebugDynamic'->getOption then
                                            'addingGroup Succeed'->putLine;
                                            'Adding header located at: %s\n\n'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   IM.dataStart
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s
                                                #);
                                            newLine;
                                            newLine;
                                            'CONSTRUCTING STRUC IN DEBUGGEE'
                                              ->putLine
                                        if);
                                        constructStrucInDebuggee:
                                          (# 
                                          do
                                             24
                                               ->
                                                 debuggee.processComm.
                                                   processData.allocateMemory
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'constrcutStrucInDebuggee: Allocating room for struc object failed'
                                                           ->msg.append
                                                      #)
                                                 #)->strucAddress;
                                             (strucAddress,StructurePTValue)
                                               ->
                                                 debuggee.processComm.
                                                   processData.pokeLong
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'constrcutStrucInDebuggee: Setting type of prototype failed'
                                                           ->msg.append
                                                      #)
                                                 #);
                                             (strucAddress+4,0)
                                               ->
                                                 debuggee.processComm.
                                                   processData.pokeLong
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'constrcutStrucInDebuggee: Setting ?? failed'
                                                           ->msg.append
                                                      #)
                                                 #);
                                             (if aRemoteBetaObject.isComp then
                                                 aRemoteBetaObject.getAddress+24
                                                   ->objectAddress
                                              else
                                                 aRemoteBetaObject.getAddress
                                                   ->objectAddress
                                             if);
                                             (strucAddress+8,objectAddress)
                                               ->
                                                 debuggee.processComm.
                                                   processData.pokeLong
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'constrcutStrucInDebuggee: Setting origin failed'
                                                           ->msg.append
                                                      #)
                                                 #);
                                             (strucAddress+12,
                                              (1->IM.indexedOff))
                                               ->
                                                 debuggee.processComm.
                                                   processData.pokeLong
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'constrcutStrucInDebuggee: Setting address of object prototype in struc failed'
                                                           ->msg.append
                                                      #)
                                                 #)
                                          #);
                                        (if 'DebugDynamic'->getOption then
                                            'constructStrucInDebuggee Succeed'
                                              ->putLine;
                                            'StructObjectAddress: %s\n'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   strucAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   st[]->s
                                                #);
                                            'The information in the struc: %s\t%s\t%s\t%s\n'
                                              ->putFormat
                                                (# j: @integer; st: @text
                                                do
                                                   strucAddress
                                                     ->
                                                       debuggee.processComm.
                                                         processData.peeklong
                                                       (#
                                                          accessFailure::< 
                                                            (# 
                                                            do
                                                               'Peeking for 1st value in struc failed'
                                                                 ->msg.append
                                                            #)
                                                       #)
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s;
                                                   st.clear;
                                                   strucAddress+4
                                                     ->
                                                       debuggee.processComm.
                                                         processData.peeklong
                                                       (#
                                                          accessFailure::< 
                                                            (# 
                                                            do
                                                               'Peeking for 2st value in struc failed'
                                                                 ->msg.append
                                                            #)
                                                       #)
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s;
                                                   st.clear;
                                                   strucAddress+8
                                                     ->
                                                       debuggee.processComm.
                                                         processData.peeklong
                                                       (#
                                                          accessFailure::< 
                                                            (# 
                                                            do
                                                               'Peeking for 3rd value in struc failed'
                                                                 ->msg.append
                                                            #)
                                                       #)->originObjectAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s;
                                                   st.clear;
                                                   strucAddress+12
                                                     ->
                                                       debuggee.processComm.
                                                         processData.peeklong
                                                       (#
                                                          accessFailure::< 
                                                            (# 
                                                            do
                                                               'Peeking for 4th value in struc failed'
                                                                 ->msg.append
                                                            #)
                                                       #)->dynamicProtoAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   st[]->s;
                                                   st.clear;
                                                   
                                                #);
                                            newLine;
                                            newLine;
                                            'ORIGIN OBJECT'->putLine;
                                            'Located at: %s\n'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   originObjectAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s
                                                #);
                                            'Dump of memory:'->putLine;
                                            (originObjectAddress,8)
                                              ->dumpMemoryArea;
                                            newLine;
                                            newLine;
                                            'ORIGIN PROTOTYPE'->putLine;
                                            'Located at: %s\n'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   originObjectAddress
                                                     ->
                                                       debuggee.processComm.
                                                         processData.peeklong
                                                       (#
                                                          accessFailure::< 
                                                            (# 
                                                            do
                                                               'Peeking for originObjectProtoAddress'
                                                                 ->msg.append
                                                            #)
                                                       #)
                                                     ->originObjectProtoAddress;
                                                   originObjectProtoAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s
                                                #);
                                            'Dump of memory:'->putLine;
                                            (originObjectProtoAddress,8)
                                              ->dumpMemoryArea;
                                            newLine;
                                            newLine;
                                            'DYNAMIC PROTOTYPE'->putLine;
                                            'Located at: %s\n'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   dynamicProtoAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   '0x'->st.prepend;
                                                   st[]->s
                                                #);
                                            'Dump of memory:'->putLine;
                                            (dynamicProtoAddress,8)
                                              ->dumpMemoryArea;
                                            newline;
                                            newline;
                                            'EXECUTE OBJECT'->putLine
                                        if);
                                        executeObjectInDebuggee:
                                          (# 
                                          do
                                             strucAddress
                                               ->
                                                 debuggee.processComm.
                                                   processData.executeObject
                                                 (#
                                                    accessFailure::< 
                                                      (# 
                                                      do
                                                         'executeObjectInDebuggee: failed'
                                                           ->msg.append
                                                      #)
                                                 #)
                                          #);
                                        (if 'DebugDynamic'->getOption then
                                            'executeObjectInDebuggee Succeed'
                                              ->putLine;
                                            'Executing struc located at: %s'
                                              ->putFormat
                                                (# st: @text
                                                do
                                                   strucAddress
                                                     ->st.putHex
                                                       (#
                                                          format::< 
                                                            (# 
                                                            do
                                                               true
                                                                 ->zeroPadding;
                                                               true->uppercase
                                                            #)
                                                       #);
                                                   st[]->s
                                                #)
                                        if);
                                        (*
                                         *  Dumping the inf in the struc
                                         *)
                                        main.refresh
                                     else
                                        'An error happend during compilation'
                                          ->putLine
                                    if);
                                    
                                 #)
                            #);
                          getFather:: 
                            (#  do gui.main.objworld[]->father[] #)
                       #)
               if);
               
            #);
          curObjStatus:: 
            (# 
            do
               (if (debuggeeIsReady->value) then
                   (debuggee.curObj <> 0)->value
               if);
               
            #);
          debuggeeCurCode::  (#  do <<SLOT debuggeeCurCode:Descriptor>> #);
          curCodeStatus:: 
            (# 
            do
               debuggeeIsReady->value;
               (if value then
                   (debuggee.pc <> 0)->value;
                   
               if);
               
            #);
          debuggeeCurComp:: 
            (# 
            do
               (if curCompStatus then
                   (debuggee.currentRemoteComponent,FALSE)
                     ->gui.main.OpenMoveableObjectView
                       (#
                          getFather:: 
                            (#  do gui.main.objworld[]->father[] #)
                       #)
               if);
               
            #);
          curCompStatus:: 
            (# 
            do
               (if (debuggeeIsReady->value) then
                   (debuggee.curComp <> 0)->value
               if)
            #);
          onTerminate:: 
            (# 
            do
               main.status.setenabling;
               0->setPIDparam;
               objectviews.newscan
                 (#  do cur.encl.tryclose #);
               stackviews.newscan
                 (#  do cur.encl.tryclose #);
               
            #);
          onMoveablesInsert::  (#  #);
          codeviews: @codemoveableEditorList;
          stackviews: @stackviewlistlist;
          objectviews: @objectviewList
            (#
               onInsert:: 
                 (#
                    addItemMenuItems: theObjectView.addObjectViewItemMenuItems
                      (#
                         show::  (#  do comp[]->newstackview #);
                         showC::  (#  do ast[]->newcodemoveable;  #);
                         
                      #);
                    addmovItems: movo.addObjectViewactionedMenuItems
                      (#
                         show::  (#  do comp[]->newstackview #);
                         showC::  (#  do ast[]->newcodemoveable;  #);
                         
                      #);
                    mov: ^main.moveable;
                    movo: ^main.moveableObjectView;
                    
                 do
                    theObjectView.encl.getMoveable->mov[];
                    (if mov[] <> none then
                        (if mov## <= main.moveableObjectView## then
                            mov[]->movo[];
                            addmovItems##->movo.movMenu.onOpen.appendAction;
                            
                        if);
                        
                    if);
                    addItemMenuItems##
                      ->theObjectView.itemMenu.onOpen.appendAction;
                    
                 #);
               onDelete::  (#  #);
               
            #);
          mainType:: 
            (#
               menubarType:: 
                 (# open::  (#  <<SLOT mainTypeMenubarTypeOpen:DoPart>> #)
                 #)
            #);
          init:: (* gui.init *) 
            (# 
            do
               stackviews.init;
               stackviews[]
                 ->objectPool.put;
               codeviews.init;
               codeviews[]
                 ->objectPool.put;
               objectviews.init;
               objectviews[]
                 ->objectPool.put;
               
            #)
       #);
     loadSources:
       (# exec: ^text
       enter exec[]
       do
          exec[]
            ->
              gui.mps.ast.
                expandToFullPath->gui.sources.appendProject;
          gui.sources.appendDone
       #);
     
  do
     thespawner.init;
     thespawner[]->objectPool.put;
     0->sockgen.port;
     sockgen.bind;
     sockgen[]->objectPool.put;
     gui.init;
     parseValhallaParams;
     procwaiter[]->fork;
     (if getEXECNAMEparam <> none then
         FALSE->runNewDebuggee;
         (if debuggee[] <> none then
             ('program',debuggee.MPS.BETA.DescriptorForm)
               ->debuggee.DBmanager.slotnameToGroups
                 (#  do current[]->loadSources #);
             
         if)
     if)
  #)  

