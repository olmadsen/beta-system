ORIGIN '~beta/guienv/v1.2/guienvsystemenv';
BODY 'private/valhallabody';

INCLUDE 'processInterface';
INCLUDE 'processCommCodes';
INCLUDE 'breakpoints';

INCLUDE 'UI/valhallaGUI';
INCLUDE 'UI/GUIprocess';
INCLUDE 'UI/stackview';
INCLUDE 'UI/objectviewadds';
INCLUDE 'UI/codemoveable';
INCLUDE 'UI/grouplist';
INCLUDE 'UI/enveditor';

INCLUDE '~beta/objectbrowser/v2.0/systemenvcoroutinespawner';
INCLUDE '~beta/objectbrowser/v2.0/UI/moveable';

INCLUDE '~beta/guienv/v1.2/stddialogs';

BETARUN default '~beta/debugger/v2.0/betarun/$/betarunv.o';
(*OBJFILE default '~beta/debugger/v2.0/betarun/$/C/valhallaFIFOS.o';*)

--- lib:attributes ---

DEFAULT_RECTANGLE: (# exit ((0,0),(250,250)) #);

--- program:descriptor ---
systemenv
(# windowEnvType:: valhallaGUI;
   setWindowEnv:: (# do gui[]->theWindowEnv[] #);
   
   thespawner: @systemenvspawner;
   
   debuggee: ^gui.GUIprocess; (* The process being debugged. *)
   sources: ^sourcesType;     (* source browser for debuggee. *)
   
   sourcesType: gui.sourceBrowser
     (# onClose:: (# do NONE->sources[] #);
        openCodeView:: (# do ff.root[]->newcodemoveable #);
        codeViewExists::
          (# 
          do ff.root[]->newcodemoveable
             (# openIfNotFound:: 
                  (# 
                  do FALSE->value->THIS(codeViewExists).value
                  #);
                wriggleIfFound::
                  (# 
                  do gui.main.bringToFront;
                     TRUE->value->THIS(codeViewExists).value
                  #);
             #);
          #);
        generalInfo:: (# do inf[]->gui.putinfo #);
        errorInfo:: (# do (inf[],'ERROR!')->gui.alertInfo #);
        continue:: (# do (if debuggeeIsReady then doContinue if) #);
        processIsReady:: (# do debuggeeIsReady->value #);
     #);
   
   theEnveditor: ^enveditType; (* Environment editor. *)
   enveditType: gui.envEditor (# onClose:: (# do NONE->theEnveditor[] #)#);
   
   debuggeeIsRunning: BooleanValue
     (# 
     do (if debuggee[]<>NONE then 
            (debuggee.running) and (not debuggee.terminated)->value 
         else FALSE->value
        if);
     #);
   debuggeeIsReady: BooleanValue
     (# 
     do (if debuggee[]<>NONE then 
            (not debuggee.running) and (not debuggee.terminated)->value 
         else FALSE->value
        if);
     #);
   ensureKilled:
     (# 
     do (if debuggee[]<>NONE then
            (if not debuggee.terminated then
                debuggee.kill; gui.onTerminate;
            if);
        if);
     #);
   
   olmDummy2: @getFrame;
   getFrame:
     (# done:<
          (# result: @rectangle;
          enter result
          do INNER
          #);
        olmDummy: @done
     do 
        (if dragOutlineOnOpen->gui.getOption then
            DEFAULT_RECTANGLE->gui.main.objworld.getOutline
            (# done:: (# do result->THIS(getFrame).done #)#)
         else
            DEFAULT_RECTANGLE->done;
        if);   
     #);
   
   newExecName:
     (# execName: ^Text;
     do gui.main[]->gui.fileSelectionDialog->execName[];
        (if execName[]<>NONE then
            execName[]->setEXECNAMEparam;
        if);
     exit execName[]
     #);
   
   runNewDebuggee:
     (# success: @Boolean;
        rerun: @Boolean;
     enter rerun
     do <<SLOT runnewdebuggee:descriptor>>
     exit success
     #);
   
   setStepIntoBreaks:
     (# uss: @debuggee.userSingleStepBreaker
          (# init::<
               (# cancelled:: (# do TRUE->continue #);
                  unknownCode::
                    (#
                    do ('Missing debug info. Cannot step.','Warning')
                         ->gui.alertInfo;
                       TRUE->continue;
                    #);
               #);
          #);
     exit not uss.init
     #);

   setStepOverBreaks:
     (# uss: @debuggee.userStepOverBreaker
          (# init::<
               (# cancelled:: (# do TRUE->continue #);
                  unknownCode::
                    (#
                    do ('Missing debug info. Cannot step.','Warning')
                         ->gui.alertInfo;
                       TRUE->continue;
                    #);
               #);
          #);
     exit not uss.init
     #);

   doStepOver:
     (#
     do (if debuggeeIsReady then 
            (if setStepOverBreaks then doContinue if)
        if);
     #);
   doStepInto: 
     (# 
     do (if debuggeeIsReady then 
            (if setStepIntoBreaks then doContinue if)
        if);
     #);
   doContinue:
     (#
     do debuggee.processComm.continue;
        'Running'->gui.putpinfo;
        waitersem.V;
     #);
   doStop:
     (# 
     do (if debuggeeIsRunning then 
            TRUE->stopped; debuggee.processComm.stop 
        if)
     #);
   
   stopped: @Boolean; (*  TRUE if doStop was called. *)
   
   (* procwaiter
    * ==========
    * 
    * procwaiter is a coroutine doing the job of waiting for the debuggee
    * to stop. Using a separate coroutine for this job allows valhalla to
    * handle user-events while waiting.
    * 
    * procwaiter blocks on waitersem until it should wait for the debuggee
    * to stop. Then it blocks on a call to debuggee.processComm.wait. *)
   
   waitersem: @semaphore; 
   procwaiter: @|System (# do <<SLOT procwaiter:descriptor>> #);
   
   
   mystackview: gui.main.stackviewmoveable
     (# listEncloserType::
          (# openNewCodeView:: (# do cast[]->newcodemoveable #);
             openNewObjectView:: 
               (# 
               do (bo[],force)->gui.main.OpenMoveableObjectView
                  (# getFather:: (# do gui.main.objworld[]->father[]#)#)
               #);
             alertInfo:: (# do (inf[],title[])->gui.alertInfo #);
          #);
     #);
   
   mycodeview: gui.main.codemoveable
     (# editorEncloserType::
          (# continue:: (# do (if debuggeeIsReady then doContinue if) #);
             processIsReady:: (# do debuggeeIsReady->value #);
             newCodeView:: (# do node[]->newcodemoveable #);
             generalInfo:: (# do inf[]->gui.putinfo #);
             errorInfo:: (# do (inf[],'Error!')->gui.alertInfo #);
          #);
     #);
   
   lastEditor: ^gui.main.codemoveableEditor;
   newcodemoveable: 
     (# openIfNotFound:< BooleanValue (# do true->value; INNER #);
        wriggleIfFound:< BooleanValue
          (# found: ^gui.main.codemoveableEditor;
          enter found[]
          do true->value; INNER
          #);
        cast: ^astInterface.ast;
     enter cast[]
     <<SLOT newcodemoveable:dopart>>
     #);
   
   newstackview:
     (# comp: ^processInterface.remoteBetaObject;
     enter comp[]
     <<SLOT newstackviewbody:dopart>>
     #);
   
   gui: @valhallaGUI
     (# 
        (* The following final bound virtuals are declared in valhallaGUI,
         * and called by menus and buttons in the user-interface. *)
        
        newDebuggee::
          (# 
          do (if newExecName<>NONE then ensureKilled FALSE->runNewDebuggee if)
          #);
        
        debuggeeRerun::
          (# 
          do (if rerunStatus then ensureKilled; TRUE->runNewDebuggee if)
          #);;
        rerunStatus::
          (# 
          do (if debuggee[]<>NONE then
                 debuggeeIsReady or debuggee.terminated ->value;
              else
                 TRUE->value;
             if);
             value and (getEXECNAMEparam<>NONE)->value;
          #);
        
        killDebuggee::
          (#
          do (if debuggeeIsReady then ensureKilled; 'Killed'->putpinfo if)
          #);
        killStatus:: debuggeeIsReady;
                       
        source:: 
          (#
          do (if debuggeeIsReady then
                 (if sources[]<>NONE then sources.wriggle;
                  else  &sourcesType[]->sources[]; debuggee[]->sources.open;
                 if);
             if)
          #);
        sourceStatus:: debuggeeIsReady;
        
        
        editenv::
          (# 
          do (if theEnveditor[]<>NONE then theEnveditor.wriggle;
              else &envedittype[]->theEnveditor[]; theEnveditor.open;
             if);
          #);
        editenvStatus:: TrueObject;
        
        quit:: 
          (# 
          do (if debuggeeIsReady then debuggee.kill; onTerminate if)
          #);
        
        debuggeeContinue:: (# do (if continueStatus then doContinue if) #);
        continueStatus:: debuggeeIsReady;
        
        debuggeeStepOver:: (# do doStepOver #);
        stepOverStatus:: debuggeeIsReady;
        
        debuggeeStepInto::
          (# 
          do doStepInto;
          #);
        stepIntoStatus:: debuggeeIsReady;
        
        debuggeeStop:: (# do doStop #);
        stopStatus:: debuggeeIsRunning;
        
        debuggeeActiveStack:: 
          (# 
          do (if activeStackStatus then
                 debuggee.currentRemoteComponent->newstackview
             if);
          #);
        activeStackStatus::
          (# 
          do (if (debuggeeIsReady->value) then
                 (debuggee.curComp<>0)->value 
             if);
          #);
        
        debuggeeCurObj::
          (# 
          do (if curObjStatus then
                 (debuggee.currentRemoteBetaObject,FALSE)
                   ->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if);
          #);
        curObjStatus::
          (# 
          do (if (debuggeeIsReady->value) then (debuggee.curObj<>0)->value if);
          #);
        
        debuggeeCurCode:: (# do <<SLOT debuggeeCurCode:descriptor>> #);
        curCodeStatus::< debuggeeIsReady;
        
        debuggeeCurComp::
          (# 
          do (if curCompStatus then
                 (debuggee.currentRemoteComponent,FALSE)
                   ->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if);
          #);
        curCompStatus::
          (# 
          do (if (debuggeeIsReady->value) then (debuggee.curComp<>0)->value if)
          #);
        
        onTerminate:: 
          (#
          do 0->setPIDparam; 
             main.objectviews.scan (# do current.encl.tryclose #);
             main.stackviews.scan (# do current.encl.tryclose #);
          #);
        
        onMoveablesInsert:: (# #);
        
        mainType::
          (# stackviews: @stackviewlistlist
               (# onInsert::
                    (# 
                    #);
                  onDelete::
                    (# 
                    #);
               #);
             codeviews: @codemoveableEditorList
               (#  onInsert::
                    (# 
                    #);
                  onDelete::
                    (# 
                    #);
               #);
             objectviews: @objectviewList
               (# onInsert::
                    (# addItemMenuItems: 
                         theObjectView.addObjectViewItemMenuItems
                         (# show:: (# do comp[]->newstackview #)#); 
                       
                       addmovItems: 
                         movo.addObjectViewactionedMenuItems
                         (# show:: (# do comp[]->newstackview #)#);
                       
                       mov: ^moveableObjectView;
                       movo: ^moveableObjectView;
                    do 
                       theObjectView.encl.getMoveable->mov[];
                       (if mov[]<>NONE then
                           (if mov##<=moveableObjectView## then
                               mov[]->movo[];
                               addmovItems##->movo.movMenu.onOpen.appendAction;
                           if);
                       if);
                       addItemMenuItems##
                         ->theObjectView.itemMenu.onOpen.appendAction;
                    #);
                  onDelete::
                    (# 
                    #);
               #);
             
             menuBarType::
               (# breakPointsMenu: @bettermenu
                    (# breakPointItem: item
                         (# onSelect::
                              (# 
                              do (if bm.impi[]<>NONE then
                                     bm.impi.cast[]->newcodemoveable
                                 if);
                              #);
                            bm: ^processInterface.breakManager;
                            newBreak: new (# enter bm[] #);
                         #);
                       eventHandler::<
                         (# onSelect::<
                              (# bml: ^processInterface.breakManagerList;
                              do clear;
                                 debuggee.getBreakManagerList->bml[];
                                 (if bml.size=0 then
                                     'No Breakpoints'->(&item[]).new;
                                  else
                                     bml.scan
                                     (# bpi: ^breakPointItem; num: @Text;
                                     do &breakPointItem[]->bpi[];
                                        num.clear; current.number->num.putInt;
                                        (if current.impi[]<>NONE then
                                            ': '->num.append;
                                            current.impi.cast.frag.name
                                              ->num.append;
                                        if);
                                        (num[],current[])->bpi.newBreak;
                                     #);
                                 if)
                              #);
                         #)
                    #);
                  open::
                    (# 
                    do 'BreakPoints'->breakpointMenu.new; 
                       breakpointMenu[]->append;
                    #);
               #);
             open::
               (# 
               do stackviews.init; stackviews[]->objectPool.put;
                  codeviews.init; codeviews[]->objectPool.put;
                  objectviews.init; objectviews[]->objectPool.put;
               #);
          #);
     #);
do thespawner.init; thespawner[]->objectPool.put;
   gui.init;
   parseValhallaParams;
   procwaiter[]->fork;
   (if getEXECNAMEparam<>NONE then FALSE->runNewDebuggee if);
#)

