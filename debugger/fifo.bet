ORIGIN '~beta/basiclib/v1.4/betaenv';

--- include '~beta/unixlib/v1.4/unixinterface'

(* fifo.bet
 * ========
 * 
 * Part of valhalla, v2.0.
 * 
 * On UNIX, Communication with the debugged process is done over a pair of 
 * named pipes. The naming conventions are "/tmp/betadebugToPID" and 
 * "/tmp/BetaDebugFromPID" where PID is the process ID of the debugged 
 * process or the process ID of valhalla, depending on who started who. 
 * The first fifo is used for communication from valhalla to the debugged 
 * process. The second fifo is used for communication in
 * the opposite direction. *)

--- lib:attributes ---

(* FIFO externals
 * ==============
 * 
 * fromName, toName, createFIFOS and openFIFOS are declared in 
 * private/external/valhallaComm.c *)

fromName: external
  (# pid: @Integer; name: [1]@Char
  enter pid
  exit name
  #);
toName: external
  (# pid: @Integer; name: [1]@Char
  enter pid
  exit name
  #);
createFIFOS: external
  (# pid: @Integer;
  enter pid
  #);
openFIFOS: external
  (# pid: @Integer;
     fromStreamAdr,toStreamAdr: @Integer;
  enter (pid,fromStreamAdr,toStreamAdr)
  #);
deleteFIFOS: external
  (# pid: @Integer;
  enter pid
  #);

fifo:
  (# init: (# enter unixStream #);
     binPutInt:
       (# val: @Integer;
          error:< Exception;
       enter val
       do (if (@@val,4) -> binPutBytes //4 then else error if);
       #);
     binGetInt:
       (# error:< Exception;
          val: @Integer;
          ok: @Boolean;
       do (if (@@val,4) -> binGetBytes //4 then else error if)
       exit val
       #);
     binGetBytes: @
       (# repAdr: @Integer; (* Address of buffer *)
          length: @Integer; (* In bytes *)
       enter (repAdr,length)
       do (repAdr,1,length,unixStream) -> fread -> length;
       exit length
       #);
     binPutBytes: @
       (# repAdr: @Integer; (* Address of buffer *)
          length: @Integer; (* In bytes *)
       enter (repAdr,length)
       do (repAdr,1,length,unixStream) -> fwrite -> length;
       exit length
       #);
     getLine:
       (# t: ^Text;
       do &Text[] -> t[];
          (unixStream,TRUE) -> GetTextFromStream -> t;
       exit t[]
       #);
     close: (# do unixStream -> fclose; 0 -> unixStream #);
     flush: (# do unixStream -> fflush #);
     unixStream: @Integer;
  #)
