ORIGIN '~beta/basiclib/v1.4/betaenv';

INCLUDE '~beta/basiclib/v1.4/basicsystemenv';
INCLUDE '~beta/unixlib/v1.4/iostate';

--- include '~beta/unixlib/v1.4/unixinterface'

(* fifo.bet
 * ========
 * 
 * Part of valhalla, v2.0.
 * 
 * On UNIX, Communication with the debugged process is done over a pair of 
 * named pipes. The naming conventions are "/tmp/betadebugToPID" and 
 * "/tmp/BetaDebugFromPID" where PID is the process ID of the debugged 
 * process or the process ID of valhalla, depending on who started who. 
 * The first fifo is used for communication from valhalla to the debugged 
 * process. The second fifo is used for communication in
 * the opposite direction. *)

--- lib:attributes ---

(* FIFO externals
 * ==============
 * 
 * fromName, toName, createFIFOS and openFIFOS are declared in 
 * ~betarun/$/C/valhallaFIFOS.c *)

fromName: external
  (# pid: @Integer; name: [1]@Char
  enter pid
  exit name
  #);
toName: external
  (# pid: @Integer; name: [1]@Char
  enter pid
  exit name
  #);
createFIFOS: external
  (# pid: @Integer;
  enter pid
  #);
openFIFOS: external
  (# pid: @Integer;
     fromStreamAdr,toStreamAdr: @Integer;
  enter (pid,fromStreamAdr,toStreamAdr)
  #);
deleteFIFOS: external
  (# pid: @Integer;
  enter pid
  #);
getfileno: external
  (# stream: @Integer;
     fd: @Integer;
  enter stream
  exit fd
  #);

(* readyBytes
 * ==========
 * 
 * From ~beta/basiclib/v1.4/private/external/systemenvExt.c.
 * 
 * Returns the number of *unbuffered* bytes ready to read from 
 * filedescriptor fd. *)

readyBytes: external 
  (# fd, count: @Integer; 
  enter fd 
  exit count 
  #);

fifo:
  (# readyCount: @Integer;
     ios: ^senv.IOstate;
     senv: ^systemEnv;
     init: 
       (# 
       enter unixStream
       do (* getSystemEnv->senv[]; &senv.IOstate[]->ios[];
           * unixStream->getfileno->ios.init; *)
       #);
     binPutInt:
       (# val: @Integer;
          error:< Exception;
       enter val
       do (if (@@val,4) -> binPutBytes //4 then else error if);
       #);
     binGetInt:
       (# error:< Exception;
          val: @Integer;
          ok: @Boolean;
       do (if (@@val,4) -> binGetBytes //4 then else error if)
       exit val
       #);
     binGetBytes: @
       (# repAdr: @Integer; (* Address of buffer *)
          length: @Integer; (* In bytes *)
       enter (repAdr,length)
       do (repAdr,1,length,unixStream)->fread->length
       exit length
       #);
     binPutBytes: @
       (# repAdr: @Integer; (* Address of buffer *)
          length: @Integer; (* In bytes *)
       enter (repAdr,length)
       do (repAdr,1,length,unixStream) -> fwrite -> length;
       exit length
       #);
     getText:
       (# len: @Integer;
          t: ^Text;
       do binGetInt->len;
          &Text[]->t[]; len+1->t.T.new;
          (@@t.T[1],len+1)->binGetBytes;
          len->t.lgth;
       exit t[]
       #);
     close: (# do unixStream -> fclose; 0 -> unixStream #);
     flush: (# do unixStream -> fflush #);
     unixStream: @Integer;
  #)
