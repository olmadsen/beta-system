ORIGIN '~beta/basiclib/v1.4/betaenv';

--- include '../processInterface'

--- program:descriptor ---
(# pi: @processInterface;
   execParams: [0]^Text;
   execEnv: [0]^Text;
   valhallaParams: [1]^Text;
do 
   noOfArguments - 1 -> valhallaParams.new;
   (for i: NoOfArguments repeat
        (if i//1 then else
            i -> Arguments -> valhallaParams[i-1][];
        if);
   for);
   
   (execParams,execEnv,valhallaParams) -> pi.init
   (# doingExpensiveRead::< (# do 'doingExpensiveRead' -> putLine #);
      doingCheapRead::< (# do 'doingCheapRead' -> putLine #);
      createFragInfo::< (# do 'createFragInfo' -> putLine; true -> value #);
      creationFailed::< (# do 'creationFailed' -> putLine #);
      execNotFound::< (# do 'execNotFound' -> putLine #);
      DBstatus::<
        (# 
        do (if status 
            //DBFILE_OK then
               'Reading ' -> putText; dbName[] -> putLine;
            //DBFILE_NOTFOUND then
               'Could not find ' -> putText; dbName[] -> putLine;
            //DBFILE_NEWER then
               dbName[] -> putText; ' newer than executable' -> putLine;
           if);
        #);
   #);
   
   pi.scanObjectFileInfos
   (# fi: ^current.fragmentInfo;
      dp: ^pi.dopartInfo;
   do current[] -> pi.processComm.loadProtoTable;
      current.groupName[] -> screen.putText;
      ': protoCount = ' -> screen.putText;
      current.protoCount -> screen.putInt;
      screen.newline;
      
      'loadLevel ' -> putText; current.loadLevel -> putInt; newline; newline;
      
      (for i:current.fragments.range repeat
           current.fragments[i][] -> fi[];
           'fragment: ' -> putText;
           fi.fragmentName[] -> putLine;
           '(infoFirst,infoLast) = (' -> putText;
           fi.infoFirst -> putInt; ',' -> put;
           fi.infoLast -> putInt; ')' -> putLine; newline;
           (for j:fi.doparts.range repeat
                fi.doparts[j][] -> dp[];
                'dopart ast index = (astRef,fragRef) = (' -> putText;
                dp.astRef -> putInt; ',' -> put; 
                dp.fragRef -> putInt; ')' -> putLine;
                'Imperatives = (impAdr,astRef): ' -> putLine;
                (for k:dp.impAddresses.range repeat
                     '(' -> put; dp.impAddresses[k] -> putInt;
                     ',' -> put; dp.impAstRefs[k] -> putInt;
                     ')' -> putLine;
                for);
           for);
           newline; newline;
      for);
   #);
   
   pi.Kill;
#)
   
