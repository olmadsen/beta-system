ORIGIN '~beta/basiclib/v1.4/betaenv';

INCLUDE 'processInterface';
INCLUDE '~beta/objectbrowser/v2.0/objectdumper';
INCLUDE '~beta/objectbrowser/v2.0/objectdb';

INCLUDE '~beta/sysutils/v1.4/objinterface';

--- lib: attributes ---

getRemoteObjectDB: getObjectDB (# type:: remoteObjectDB #);

remoteObjectDB: objectDB
  (# betaObjectType:: remoteBetaObject;
     betaPatternType:: remoteBetaPattern;
  #);

remotedumper: objectdumper
  (# pi: ^processInterface;
     betaObjectType:: remoteBetaObject;
     betaPatternType:: remoteBetaPattern;
     
     (* Dummy owners keeping the objects in the remoteObjectDB until they
      * are explicitly deleted: *)
     DOTobjectOwner: @objectOwner (# #);
     DOTpatternOwner: @patternOwner (# #);
     
     (* BetaObject instances used to represent NONE refs: *)
     NONEobject: ^remoteBetaObject;
     NONEpattern: ^remoteBetaPattern;
     
     betaObjectObjectDescriptor::
       (# pti: ^pi.PrototypeInfo;
       do bo.protoadr->pi.utilities.ProtoAddressToPrototypeInfo->pti[];
          (if pti[]//NONE then
              'betaObjectObjectDescriptor: pti was NONE' -> putLine;
           else
              pti.objdesc[]->value[]
          if);
       #);
     
     betaPatternObjectDescriptor:: 
       (# pti: ^pi.PrototypeInfo;
       do bp.protoadr->pi.utilities.ProtoAddressToPrototypeInfo->pti[];
          (if pti[]//NONE then
              'betaPatternObjectDescriptor: pti was NONE' -> putLine;
           else
              pti.objdesc[]->value[]
          if);
       #);
     
     init::
       (#
       enter pi[]
       do
          &remoteBetaObject[]->NONEobject[];
          (NONE,0,0,0)->NONEobject.init;
          &remoteBetaPattern[]->NONEpattern[];
          (NONE,0,0)->NONEpattern.init;
       #);
  #);

newRemoteObject:
  (# bo: ^remoteBetaObject;
     address,dotinx,objsize: @Integer;
     rd: ^remotedumper;
     objects: ^remoteObjectDB;
  enter (address,rd[])
  do address->rd.pi.processComm.canonify->address;
     lookup:
       (if address<>0 then
           getRemoteObjectDB->objects[];
           address->rd.pi.processComm.DOT.addressToInx->dotinx;
           (if dotinx=-1 then
               (* Not found. Insert the object in the DOT table. *)
               address->rd.pi.processComm.DOT.insert->(dotinx,objsize);
            else
               (* We should be able to find the object in the objectDB: *)
               objects.scanObjects
               (# 
               do (if current.bo.dotinx=dotinx then
                      current.bo[]->bo[]; leave lookup;
                  if);
               #);
               
               (failure,'FATAL: Object in DOT not found in remoteObjectDB')
                 ->stop;
           if);
        else
           rd.NONEobject[]->bo[];
       if);
     (if bo[]=NONE then
         &remoteBetaObject[]->bo[];
         (rd[],address,dotinx,objsize)->bo.init;
         (bo[],rd.DOTobjectOwner[])->objects.addObjectOwner;
         (* Ensure that only a single representative of this object is
          * created, by registering it in the objects table. *)
     if);
     bo.touch;
  exit bo[]
  #);

newRemotePattern:
  (# bp: ^remoteBetaPattern;
     address,dotinx,objsize: @Integer;
     rd: ^remotedumper;
     objects: ^remoteObjectDB;
  enter (address,rd[])
  do 
     lookup:
       (if address<>0 then
           getRemoteObjectDB->objects[];
           address->rd.pi.processComm.DOT.addressToInx->dotinx;
           (if dotinx=-1 then
               (* Not found. Insert the object in the DOT table. *)
               address->rd.pi.processComm.DOT.insert->(dotinx,objsize);
            else
               (* We should be able to find the object in the objectDB: *)
               objects.scanPatterns
               (# 
               do (if current.bp.dotinx=dotinx then
                      current.bp[]->bp[]; leave lookup;
                  if);
               #);
               (failure,'FATAL: Pattern in DOT not found in remoteObjectDB')
                 ->stop;
           if);
        else
           rd.NONEpattern[]->bp[];
       if);
     (if bp[]=NONE then
         &remoteBetaPattern[]->bp[];
         (rd[],address,dotinx)->bp.init;
         (* Ensure that only a single representative of this pattern is
          * created, by registering it in the objects table. *)
         (bp[],rd.DOTpatternOwner[])->objects.addPatternOwner;
     if);
     bp.touch;
  exit bp[]
  #);


remoteBetaPattern: BetaPattern
  (# betaPatternType:: remoteBetaPattern;
     betaObjectType:: remoteBetaObject;
     objectDumperType:: remotedumper;
     
     dotinx: @Integer;
     address: @Integer;
     state: [2]@Integer;
     
     lastwaitcount: @Integer; (* dumper.pi.waitcount when state was read. *)
     
     ensurestate: @
       (# 
       do
          (if lastwaitcount<>dumper.pi.waitcount then
              dotinx->dumper.pi.processComm.DOT.inxToAddress->address;
              (address+8,2)
                ->dumper.pi.processComm.processData.peekMemoryLongs
              (# 
              do @@state[1]->repAdr;
              #);
              dumper.pi.waitcount->lastwaitcount;
          if)
       #);
     
     
     isNone:: (# do (dotinx=-1) -> value #);
     
     init::
       (#
       enter (address,dotinx) 
       do -1->lastwaitcount;
          (if address=0 then -1->dotinx if);
       #);
     
     equal:: (# do (other.dotinx = dotinx) -> value #);
     
     protoAdr:
       (# value: @Integer;
       do ensurestate; state[2]->value;
       exit value
       #);
     
     origin::
       (#
       do ensurestate; (state[1],dumper[])->newRemoteObject->value[];
       #); 
  #);

remoteBetaObject: betaObject
  (# betaPatternType:: remoteBetaPattern;
     betaObjectType:: remoteBetaObject;
     objectDumperType:: remotedumper;
     
     dotinx: @Integer; (* Index in DOT table. -1 if this is a NONE ref. *)
     iscomp: @Boolean; (* Whether this object is a component. *)
     
     objectsize: @Integer; (* Size in longs. *)
     state: [0]@Integer;
     lastwaitcount: @Integer; (* dumper.pi.waitcount when state was read. *)
     
     address: @Integer;
     (* Address of component header if this is a component. *)
     
     getAddress:
       (# 
       do ensurestate; 
       exit address
       #);
     
     ensurestate: @
       (# adr: @Integer;
       do
          (if lastwaitcount<>dumper.pi.waitcount then
              (if state.range<objectsize then objectsize->state.new if);
              dotinx->dumper.pi.processComm.DOT.inxToAddress->address;
              (if iscomp then 24+address->adr else address->adr if);
              (adr,objectsize)
                ->dumper.pi.processComm.processData.peekMemoryLongs
              (# 
              do @@state[1]->repAdr;
              #);
              dumper.pi.waitcount->lastwaitcount;
          if)
       #);
     
     protoAdr: @Integer;
     
     isComponentObject:: (# do iscomp->value #);
     init::
       (* If this betaObject is NONE, address=0 and the remaining
        * enter parameters are undefined. If it is a component object,
        * address will point to the component header, and so will all
        * addresses returned by DOT.inxToAddresse. *)
       (# address: @Integer; objects: ^remoteObjectDB;
       enter (address,dotinx,objectsize)
       do 
          -1->lastwaitcount;
          (if address<>0 then
              address->dumper.pi.processComm.processData.peekLong->protoAdr;
              (protoAdr=ComponentPTValue)->iscomp;
              (if iscomp then
                  address+24
                    ->dumper.pi.processComm.processData.peekLong->protoAdr
              if);
           else
              -1->dotinx;
          if);
       #);
     Equal::
       (# 
       do (other.dotinx=dotinx) -> value;
       #);
     IsNone:: 
       (# 
       do (dotinx=-1) -> value;
       #);
     CharAttr::
       (#
       do ensurestate;
          offset->state.%getByte->value;
       #);
     BooleanAttr::
       (# 
       do ensurestate;
          offset->state.%getByte->value;
       #);
     ShortIntAttr:: 
       (#  
       do ensurestate;
          offset->state.%getShort->value;
       #);
     IntegerAttr::
       (# 
       do ensurestate;
          state[(offset div 4)+1]->value;
       #);
     RealAttr::
       (# 
       do ensurestate;
          (state[(offset div 4)+1]) %putLongAt (@@value);
          (state[(offset div 4)+2]) %putLongAt (@@value+4);
       #);
     ReferenceAttr::
       (#
       do ensurestate;
          (state[(offset div 4)+1],dumper[])->newRemoteObject->value[];
       #);
     PartObject::
       (* A negative offset means that the part object requested 
        * is offline allocated. In that case partObject should 
        * effectively do the same as referenceValue. *)
       (#
       do ensurestate;
          (if offset < 0 then
              (state[((-offset) div 4)+1],dumper[])->newRemoteObject->value[];
           else
              (if iscomp then 24+offset->offset if);
              (address+offset,dumper[])->newRemoteObject->value[];
          if);
       #);
     Range::
       (#
       do ensurestate;
          (state[(offset div 4)+1]+8,2) 
            -> dumper.pi.processComm.processData.peekMemoryLongs
          (# 
          do @@low->repAdr;
          #);
       #);
     CharRepAttr::
       (#
       do ensurestate;
          to-from+1 -> value.new;
          (state[(offset div 4)+1]+16+from-1,to-from+1)
            -> dumper.pi.processComm.processData.peekMemoryBytes
          (# 
          do @@value[1]->repAdr
          #);
       #);
     BooleanRepAttr::
       (# 
       do ensurestate;
          to-from+1 -> value.new;
          (state[(offset div 4)+1]+16+from-1,to-from+1)
            -> dumper.pi.processComm.processData.peekMemoryBytes
          (# 
          do @@value[1]->repAdr
          #);
       #);
     ShortIntRepAttr::
       (# 
       do ensurestate;
          to-from+1 -> value.new;
          (state[(offset div 4)+1]+16+2*(from-1),2*(to-from+1))
            -> dumper.pi.processComm.processData.peekMemoryBytes
          (# 
          do @@value[1]->repAdr
          #);
       #);
     IntegerRepAttr::
       (# 
       do ensurestate;
          to-from+1 -> value.new;
          (state[(offset div 4)+1]+16+4*(from-1),to-from+1)
            -> dumper.pi.processComm.processData.peekMemoryLongs
          (# 
          do @@value[1]->repAdr
          #);
       #);
     RealRepAttr::
       (#  
       do ensurestate;
          to-from+1 -> value.new;
          (state[(offset div 4)+1]+16+8*(from-1),2*(to-from+1))
            -> dumper.pi.processComm.processData.peekMemoryLongs
          (# 
          do @@value[1]->repAdr
          #);
       #);
     ReferenceRepAttr::
       (# adrs: [0]@Integer;
       do ensurestate;
          to-from+1 -> value.new; to-from+1 -> adrs.new;
          (state[(offset div 4)+1]+16+4*(from-1),to-from+1)
            -> dumper.pi.processComm.processData.peekMemoryLongs
          (# 
          do @@adrs[1]->repAdr
          #);
          (for i:to-from+1 repeat
               (adrs[i],dumper[])->newRemoteObject->value[i][];
          for);
       #);
     PatRefRepAttr::
       (# adrs: [0]@Integer;
       do ensurestate;
          to-from+1 -> value.new; to-from+1 -> adrs.new;
          (state[(offset div 4)+1]+16+4*(from-1),to-from+1)
            -> dumper.pi.processComm.processData.peekMemoryLongs
          (# 
          do @@adrs[1]->repAdr
          #);
          (for i:to-from+1 repeat
               (adrs[i],dumper[])->newRemotePattern->value[i][];
          for);
       #);
     PatternAttr::
       (# 
       do ensurestate;
          (state[(offset div 4)+1],dumper[])->newRemotePattern->value[];
       #);
  #);
