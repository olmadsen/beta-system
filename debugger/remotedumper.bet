ORIGIN 'processInterface';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
INCLUDE '~beta/objectbrowser/v2.1.x/objectdumper';
INCLUDE '~beta/objectbrowser/v2.1.x/objectdb';

INCLUDE '~beta/sysutils/v1.5/objinterface';

--- processInterfaceRemoteDumper:descriptor ---
remotedumper (# #)

--- processInterfaceLib:attributes ---
remotedumper: objectdumper
  (# betaObjectType:: remoteBetaObject;
     betaPatternType:: remoteBetaPattern;
     
     (* Dummy owners keeping the objects in the remoteObjectDB until they
      * are explicitly deleted: *)
     DOTobjectOwner: @objectOwner (# #);
     DOTpatternOwner: @patternOwner (# #);
     
     (* BetaObject instances used to represent NONE refs: *)
     NONEobject: ^remoteBetaObject;
     NONEpattern: ^remoteBetaPattern;
     
     betaObjectObjectDescriptor::
       (# pti: ^PrototypeInfo;
       do bo.protoadr->utilities.ProtoAddressToPrototypeInfo->pti[];
          (if pti[]=NONE then
              'betaObjectObjectDescriptor: '->screen.puttext;
              bo.protoadr->screen.putint; screen.newline;
              'betaObjectObjectDescriptor: pti was NONE' -> putLine;
           else
              pti.objdesc[]->value[]
          if);
       #);
     
     betaPatternObjectDescriptor:: 
       (# pti: ^PrototypeInfo;
       do bp.protoadr->utilities.ProtoAddressToPrototypeInfo->pti[];
          (if pti[]=NONE then
              'betaPatternObjectDescriptor: pti was NONE' -> putLine;
           else
              pti.objdesc[]->value[]
          if);
       #);
     
     init::
       (#
       do mps.AST[]->AST[];
          mps.BETACFL[]->BETACFL[];
          &remoteBetaObject[]->NONEobject[];
          (NONE,0,0,0)->NONEobject.init;
          &remoteBetaPattern[]->NONEpattern[];
          (NONE,0,0)->NONEpattern.init;
       #);
  do init
  #);

newRemoteObject:
  (# bo: ^remoteBetaObject;
     address,dotinx,objsize: @Integer;
     objects: ^remoteObjectDB;
  enter address
  do address->processComm.canonify->address;
     lookup:
       (if address<>0 then
           getRemoteObjectDB->objects[];
           address->processComm.DOT.addressToInx->dotinx;
           (if dotinx=-1 then
               (* Not found. Insert the object in the DOT table. *)
               address->processComm.DOT.insert->(dotinx,objsize);
            else
               (* We should be able to find the object in the objectDB: *)
               objects.scanObjects
               (# 
               do (if current.bo.dotinx=dotinx then
                      current.bo[]->bo[]; leave lookup;
                  if);
               #);
               
               (failure,'FATAL: Object in DOT not found in remoteObjectDB')
                 ->stop;
           if);
        else
           rd.NONEobject[]->bo[];
       if);
     (if bo[]=NONE then
         &remoteBetaObject[]->bo[];
         (rd[],address,dotinx,objsize)->bo.init;
         (bo[],rd.DOTobjectOwner[])->objects.addObjectOwner;
         (* Ensure that only a single representative of this object is
          * created, by registering it in the objects table. *)
     if);
     bo.touch;
  exit bo[]
  #);

newRemotePattern:
  (# bp: ^remoteBetaPattern;
     address,dotinx,objsize: @Integer;
     objects: ^remoteObjectDB;
  enter address
  do 
     lookup:
       (if address<>0 then
           getRemoteObjectDB->objects[];
           address->processComm.DOT.addressToInx->dotinx;
           (if dotinx=-1 then
               (* Not found. Insert the object in the DOT table. *)
               address->processComm.DOT.insert->(dotinx,objsize);
            else
               (* We should be able to find the object in the objectDB: *)
               objects.scanPatterns
               (# 
               do (if current.bp.dotinx=dotinx then
                      current.bp[]->bp[]; leave lookup;
                  if);
               #);
               (failure,'FATAL: Pattern in DOT not found in remoteObjectDB')
                 ->stop;
           if);
        else
           rd.NONEpattern[]->bp[];
       if);
     (if bp[]=NONE then
         &remoteBetaPattern[]->bp[];
         (rd[],address,dotinx)->bp.init;
         (* Ensure that only a single representative of this pattern is
          * created, by registering it in the objects table. *)
         (bp[],rd.DOTpatternOwner[])->objects.addPatternOwner;
     if);
     bp.touch;
  exit bp[]
  #);

currentRemoteBetaObject: (# exit curObj->newRemoteObject #);
currentRemoteComponent: (# exit curComp->newRemoteObject #);
currentRemoteCode:
  (# impi: ^ImperativeInfo;
  do getit: PC->utilities.codeAddressToImperative
     (# onGentry:: (# do leave getit #); 
        onPartialMinfo:: (# do leave getit #);
        notBetaCode:: (# do leave getit #);
     #)->impi[];
  exit impi[]
  #);

remoteBetaPattern: BetaPattern
  (# betaPatternType:: remoteBetaPattern;
     betaObjectType:: remoteBetaObject;
     objectDumperType:: remotedumper;
     
     dotinx: @Integer;
     address: @Integer;
     state: [2]@Integer;
     
     lastwaitcount: @Integer; (* waitcount when state was read. *)
     
     ensurestate: @
       (# 
       do
          (if lastwaitcount<>waitcount then
              dotinx->processComm.DOT.inxToAddress->address;
              (address+8,2)
                ->processComm.processData.peekMemoryLongs
              (# 
              do @@state[1]->repAdr;
              #);
              waitcount->lastwaitcount;
          if)
       #);
     
     
     isNone:: (# do (dotinx=-1) -> value #);
     
     init::
       (#
       enter (address,dotinx) 
       do -1->lastwaitcount;
          (if address=0 then -1->dotinx if);
       #);
     
     equal:: (# do (other.dotinx = dotinx) -> value #);
     
     protoAdr:
       (# value: @Integer;
       do ensurestate; state[2]->value;
       exit value
       #);
     
     origin::
       (#
       do ensurestate; state[1]->newRemoteObject->value[];
       #); 
  #);

remoteBetaObject: betaObject
  (# betaPatternType:: remoteBetaPattern;
     betaObjectType:: remoteBetaObject;
     objectDumperType:: remotedumper;
     
     dotinx: @Integer; (* Index in DOT table. -1 if this is a NONE ref. *)
     iscomp: @Boolean; (* Whether this object is a component. *)
     isdopart: @Boolean; (* Whether this object is a dopart object. *)
     
     objectsize: @Integer; (* Size in longs. *)
     state: [0]@Integer;
     lastwaitcount: @Integer; (* waitcount when state was read. *)
     
     address: @Integer;
     (* Address of component header if this is a component. *)
     
     getAddress:
       (# 
       do ensurestate; 
       exit address
       #);
     
     ensurestate: @
       (# adr: @Integer;
       do
          (if lastwaitcount<>waitcount then
              (if state.range<objectsize then objectsize->state.new if);
              dotinx->processComm.DOT.inxToAddress->address;
              (if iscomp then 24+address->adr else address->adr if);
              (adr,objectsize)
                ->processComm.processData.peekMemoryLongs
              (# 
              do @@state[1]->repAdr;
              #);
              waitcount->lastwaitcount;
          if)
       #);
     
     protoAdr: @Integer;
     
     init::
       (* If this betaObject is NONE, address=0 and the remaining
        * enter parameters are undefined. If it is a component object,
        * address will point to the component header, and so will all
        * addresses returned by DOT.inxToAddresse. *)
       (# address: @Integer; objects: ^remoteObjectDB;
       enter (address,dotinx,objectsize)
       do 
          -1->lastwaitcount;
          (if address<>0 then
              address->processComm.processData.peekLong->protoAdr;
              (protoAdr=ComponentPTValue)->iscomp;
              (protoAdr=DopartObjectPTValue)->isdopart;
              (if iscomp then
                  address+24
                    ->processComm.processData.peekLong->protoAdr
              if);
           else
              -1->dotinx;
          if);
       #);
     Equal:: (# do (other.dotinx=dotinx) -> value #);
     IsNone:: (# do (dotinx=-1) -> value #);
     IsDopartObject:: (# do isdopart->value #);
     isComponentObject:: (# do iscomp->value #);
     CharAttr::
       (#
       do ensurestate;
          offset->state.%getByte->value;
       #);
     BooleanAttr::
       (# 
       do ensurestate;
          offset->state.%getByte->value;
       #);
     ShortIntAttr:: 
       (#
       do ensurestate;
          offset div 2->state.%getShort->value;
       #);
     IntegerAttr::
       (# 
       do ensurestate;
          offset div 4->state.%getLong->value;
       #);
     RealAttr::
       (# 
       do ensurestate;
          (offset div 4->state.%getLong) %putLongAt (@@value);
          ((offset div 4)+1->state.%getLong) %putLongAt (@@value+4);
       #);
     ReferenceAttr::
       (#
       do ensurestate;
          offset div 4->state.%getLong->newRemoteObject->value[];
       #);
     PartObject::
       (* A negative offset means that the part object requested 
        * is offline allocated. In that case partObject should 
        * effectively do the same as referenceValue. *)
       (#
       do ensurestate;
          (if offset < 0 then
              (-offset) div 4->state.%getLong->newRemoteObject->value[];
           else
              (if iscomp then 24+offset->offset if);
              address+offset->newRemoteObject->value[];
          if);
       #);
     Range::
       (#
       do ensurestate;
          ((offset div 4->state.%getLong)+8,2)
            ->processComm.processData.peekMemoryLongs
          (# do @@low->repAdr #);
       #);
     CharRepAttr::
       (#
       do ensurestate;
          to-from+1 -> value.new;
          ((offset div 4->state.%getLong)+16+from-1,to-from+1)
            -> processComm.processData.peekMemoryBytes
          (# 
          do @@value[1]->repAdr
          #);
       #);
     BooleanRepAttr::
       (# 
       do ensurestate;
          to-from+1 -> value.new;
          ((offset div 4->state.%getLong)+16+from-1,to-from+1)
            -> processComm.processData.peekMemoryBytes
          (# 
          do @@value[1]->repAdr
          #);
       #);
     ShortIntRepAttr::
       (# 
       do ensurestate;
          to-from+1 -> value.new;
          ((offset div 4->state.%getLong)+16+2*(from-1),2*(to-from+1))
            -> processComm.processData.peekMemoryBytes
          (# 
          do @@value[1]->repAdr
          #);
       #);
     IntegerRepAttr::
       (# 
       do ensurestate;
          to-from+1 -> value.new;
          ((offset div 4->state.%getLong)+16+4*(from-1),to-from+1)
            -> processComm.processData.peekMemoryLongs
          (# 
          do @@value[1]->repAdr
          #);
       #);
     RealRepAttr::
       (#  
       do ensurestate;
          to-from+1 -> value.new;
          ((offset div 4->state.%getLong)+16+8*(from-1),2*(to-from+1))
            -> processComm.processData.peekMemoryLongs
          (# 
          do @@value[1]->repAdr
          #);
       #);
     ReferenceRepAttr::
       (# adrs: [0]@Integer;
       do ensurestate;
          to-from+1 -> value.new; to-from+1 -> adrs.new;
          ((offset div 4->state.%getLong)+16+4*(from-1),to-from+1)
            -> processComm.processData.peekMemoryLongs
          (# 
          do @@adrs[1]->repAdr
          #);
          (for i:to-from+1 repeat
               adrs[i]->newRemoteObject->value[i][];
          for);
       #);
     StatObjectRepAttr::
       (# adrs: [0]@Integer;
       do ensurestate;
          to-from+1 -> value.new; to-from+1 -> adrs.new;
          ((offset div 4->state.%getLong)+24+4*(from-1),to-from+1)
            -> processComm.processData.peekMemoryLongs
          (# 
          do @@adrs[1]->repAdr
          #);
          (for i:to-from+1 repeat
               adrs[i]->newRemoteObject->value[i][];
          for);
       #);
     PatRefRepAttr::
       (# adrs: [0]@Integer;
       do ensurestate;
          to-from+1 -> value.new; to-from+1 -> adrs.new;
          ((offset div 4->state.%getLong)+16+4*(from-1),to-from+1)
            ->processComm.processData.peekMemoryLongs
          (# 
          do @@adrs[1]->repAdr
          #);
          (for i:to-from+1 repeat
               adrs[i]->newRemotePattern->value[i][];
          for);
       #);
     PatternAttr::
       (# 
       do ensurestate;
          (offset div 4->state.%getLong)->newRemotePattern->value[];
       #);
  #);

getRemoteObjectDB: getObjectDB (# type:: remoteObjectDB #);

remoteObjectDB: objectDB
  (# betaObjectType:: remoteBetaObject;
     betaPatternType:: remoteBetaPattern;
  #);

DopartObjectPTValue: (# exit -9 #);
