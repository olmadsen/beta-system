ORIGIN 'UI/valhallaGUI' (*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-99
 *   All rights reserved.
 *)
;
INCLUDE '~beta/sourcebrowser/codemoveable'
        'breakpoints'
        '~beta/toollibs/utils/mpsinterface'
        '~beta/toollibs/utils/mpsutils'
        '~beta/editor/codeeditor'
        '~beta/guienv/utils/prompts'
        '~beta/pretty/pplib'
        '~beta/basiclib/formatio';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- valhallaGUIlib: Attributes --
BreakpointController:
  (#
     getFocus:< (# node: ^astInterface.ast do INNER exit node[] #);
     getCfe:< (# fe: ^codeEditor do INNER exit fe[] #);
     infoMsg:< (# msg: ^text enter msg[] do INNER #);
     newCodeView:< (# node: ^astInterface.ast enter node[] do INNER #);
     valhallaMenu: gui.menu
       (#
          item: menuitem
            (#
               new:
                 (# t: ^text
                 enter t[]
                 do open; t[]->name; THIS(item)[]->append
                 #);
               newkey:
                 (# t: ^text; c: @char
                 enter (t[],c)
                 do open; t[]->name; c->key; THIS(item)[]->append
                 #);
               newSpecialKey:
                 (# t: ^text;key:@integer;shift,ctrl,alt:@boolean
                 enter (t[],key,shift,ctrl,alt)
                 do open; t[]->name; (key,shift,ctrl,alt)->specialKey
                 #)
            #);
          newseparator:
            (# sep: ^separator
            do &separator[]->sep[]; sep.open; sep[]->append
            #);
          
       #);
     valhallaControlMenu: valhallaMenu
       (#
          citem: item
            (#
               eventhandler::< 
                 (#
                    onStatus::< 
                      (# 
                      do
                         (debuggee[] <> none ) and debuggeeStatus->value;
                         INNER
                      #);
                    onSelect::< 
                      (#  do (if debuggeeStatus then INNER if) #);
                    
                 #);
               
            #);
          ccitem: citem
            (#
               eventhandler::< 
                 (#
                    onStatus::< 
                      (#  do value and (getCfe <> none )->value #)
                 #)
            #);
          icontinue: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do debuggeeContinue #);
                    onStatus::  (#  do continueStatus->value #);
                    
                 #);
               
            #);
          istepo: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do debuggeeStepOver #);
                    onStatus::  (#  do stepOverStatus->value #);
                    
                 #);
               
            #);
          istepi: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do debuggeeStepInto #);
                    onStatus::  (#  do stepIntoStatus->value #);
                    
                 #);
               
            #);
          istop: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do debuggeeStop #);
                    onStatus::  (#  do stopStatus->value #);
                    
                 #);
               
            #);
          irerun: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do debuggeeRerun #);
                    onStatus::  (#  do rerunStatus->value #);
                    
                 #);
               
            #);
          ikill: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do killDebuggee #);
                    onStatus::  (#  do killStatus->value #);
                    
                 #);
               
            #);
          iStopD: @item
            (#
               eventhandler::< 
                 (#
                    onSelect::  (#  do stopDebugging #);
                    onStatus::  (#  do true->value #);
                    
                 #);
               
            #);
          iuntil: @citem
            (# eventhandler::  (# onSelect::  (#  do doStepUntil #) #)
            #);
          ibreak: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do (getFocus,FALSE,debuggee[])->setStandardBreakpoint
                      #)
                 #)
            #);
          ioneshot: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do (getFocus,FALSE,debuggee[])->setOneShotBreakpoint
                      #)
                 #)
            #);
          ibreakafter: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do (getFocus,TRUE,debuggee[])->setStandardBreakpoint
                      #)
                 #)
            #);
          ioneshotafter: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do (getFocus,TRUE,debuggee[])->setOneShotBreakpoint
                      #)
                 #)
            #);
          isdtrace:@ccitem
            (# 
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do setSDTracePoints
                      #)
                 #)
            #);
          itrace: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do (getFocus,FALSE,debuggee[],none )->setTracepoint
                      #)
                 #)
            #);
          itraceafter: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do (getFocus,TRUE,debuggee[],none )->setTracepoint
                      #)
                 #)
            #);
          iclear: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (#  do (getFocus,FALSE,debuggee[])->clearBreakPoint #)
                 #)
            #);
          iclearafter: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (#  do (getFocus,TRUE,debuggee[])->clearBreakPoint #)
                 #)
            #);
          iintobreaks: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do
                         debuggee[]
                           ->setStepIntoBreaks
                             (#
                                forEachNode::  (#  do node[]->newCodeView #)
                             #)
                      #)
                 #)
            #);
          ioverbreaks: @ccitem
            (#
               eventhandler:: 
                 (#
                    onSelect:: 
                      (# 
                      do
                         debuggee[]
                           ->setStepOverBreaks
                             (#
                                forEachNode::  (#  do node[]->newCodeView #)
                             #)
                      #)
                 #)
            #);
          breakPointListMenu: @gui.menu
            (#
               breakPointItem: menuitem
                 (#
                    eventhandler:: 
                      (#
                         onSelect:: 
                           (# 
                           do
                              (if bm.impi[] <> none then
                                  bm.impi.cast[]->newCodeView
                              if);
                              
                           #);
                         
                      #);
                    bm: ^processInterface.breakManager;
                    
                 #);
               newItem:
                 (# mi: ^menuitem; num: ^text; 
                 enter num[]
                 do &menuitem[]->mi[]; mi.open; mi[]->append; num[]->mi.name; 
                 #);
               newBreak:
                 (#
                    bpi: ^breakPointItem;
                    num: ^text;
                    bm: ^processInterface.breakManager;
                    
                 enter (num[],bm[])
                 do
                    &breakPointItem[]->bpi[];
                    bpi.open;
                    bpi[]->append;
                    num[]->bpi.name;
                    bm[]->bpi.bm[]
                 #);
               eventHandler::< 
                 (#
                    onSelect::< 
                      (#
                         bml: ^processInterface.breakManagerList;
                         bm: ^processInterface.breakManager;
                         
                      do
                         clear;
                         (if debuggeeStatus then
                             (debuggee[]).getBreakManagerList->bml[];
                             (if bml.size = 0 then
                                 'No Breakpoints'->newItem; 
                              else
                                 bml.scan
                                   (# bps: @Text; 
                                   do
                                      current[]->bm[];
                                      bm.scan
                                        (# i: @integer
                                        do
                                           bps.clear;
                                           bm.number->bps.putint;
                                           (if bm.breaks.range > 1 then
                                               '.'->bps.put;
                                               i+1->i->bps.putint;
                                               
                                           if);
                                           (if bm.impi[] <> none then
                                               ': '->bps.append;
                                               bm.impi.cast.frag.name
                                                 ->bps.append;
                                               
                                           if);
                                           (if current## = debuggee.traceBreak##
                                            then
                                                 (# tb: ^debuggee.traceBreak
                                                 do
                                                    current[]->tb[];
                                                    ' "'->bps.append;
                                                    (1,10)->tb.message.sub
                                                      ->bps.puttext;
                                                    '"'->bps.put
                                                 #);
                                               
                                           if);
                                           (bps[],bm[])->newBreak;
                                           
                                        #)
                                   #)
                             if)
                          else
                             'No Process'->newItem; 
                         if);
                         
                      #);
                    
                 #);
               
            #);
          iBreakpoints: @menuItem
            (#
               open:: 
                 (# 
                 do 'Breakpoint list'->name; breakpointListMenu[]->submenu
                 #)
            #);
          iBreakpointSave: @Item
            (#
               eventHandler::< 
                 (#
                    onSelect::< 
                      (#
                         fn: ^text;
                         f: @file;
                         bml: ^processInterface.breakManagerList;
                         bm: ^processInterface.breakManager;
                         
                      do
                         save:
                         (if debuggeeStatus then
                             getEXECNAMEparam->f.name;
                             gui.fileCreationDialog
                               (# 
                               do
                                  'Breakpoints Database: Save'->label[];
                                  f.entry.path.head->path[];
                                  '.*'->((f.entry.path.name).copy).append
                                    ->filter[];
                                  
                               #)->fn[];
                             (if fn[] = none then leave save if);
                             fn[]->f.name;
                             f.openWrite;
                             (debuggee[]).getBreakManagerList->bml[];
                             bml.scan
                               (# bps: @Text; i: @integer
                               do
                                  current[]->bm[];
                                  bm.scan
                                    (# 
                                    do
                                       bps.clear;
                                       (if bm.impi[] <> none then
                                           i+1->i->bps.putint;
                                           ' : '->bps.append;
                                           (bm.impi.cast.frag.father).fullname
                                             ->bps.puttext;
                                           ' : '->bps.append;
                                           (bm.impi.cast.frag.father).modtime
                                             ->bps.putint;
                                           ' : '->bps.append;
                                           bm.impi.cast.frag.name->bps.append;
                                           ' : '->bps.append;
                                           bm.impi.cast.index->bps.putint;
                                           
                                        else
                                           - 1->bps.putint; 
                                       if);
                                       ' : '->bps.append;
                                       (if current##
                                        // debuggee.standardBreak## then
                                           'standardBreak : '->bps.append
                                        // debuggee.userOneShotBreak## then
                                           'userOneShotBreak : '->bps.append
                                        // debuggee.traceBreak## then
                                           'traceBreak : '->bps.append;
                                             (# tb: ^debuggee.traceBreak
                                             do
                                                current[]->tb[];
                                                tb.message[]->bps.puttext
                                             #);
                                           
                                        else
                                           'UNKNOWN : '->bps.puttext
                                       if);
                                       ' : '->bps.append;
                                       bps[]->f.putline
                                    #)
                               #);
                             f.close;
                             
                         if)
                      #)
                 #)
            #);
          iBreakpointLoad: @Item
            (#
               eventHandler::< 
                 (#
                    onSelect::< 
                      (#
                         fn,l,fgName,ffName,breakType,message: ^text;
                         f: @file;
                         i,modtime,index: @integer
                      do
                         getEXECNAMEparam->f.name;
                         gui.fileSelectionDialog
                           (# 
                           do
                              'Breakpoints Database: Load'->label[];
                              f.entry.path.head->path[];
                              '.*'->((f.entry.path.name).copy).append->filter[];
                              
                           #)->fn[];
                         (if fn[] <> none then
                             fn[]->f.name;
                             f.openRead;
                             loop:
                             (if not f.eos then
                                 f.getline->l[];
                                 l.reset;
                                 l.getint->i;
                                 (if i > 0 then
                                     l.getAtom;
                                     l.getAtom->fgName[];
                                     l.getAtom;
                                     l.getint->modtime;
                                     l.getAtom;
                                     l.getAtom->ffName[];
                                     l.getAtom;
                                     l.getInt->index;
                                     l.getAtom;
                                     l.getAtom->breakType[];
                                     (if true
                                      // 'standardBreak'->breakType.equalNCS
                                      then
                                         
                                      // 'userOneShotBreak'->breakType.equalNCS
                                      then
                                         
                                      // 'traceBreak'->breakType.equalNCS then
                                         l.getAtom; l.getAtom->message[]; 
                                      // 'UNKNOWN'->breakType.equalNCS then
                                         
                                     if);
                                     (* all info read *)
                                     (fgname[],modtime,ffName[],index,
                                      breakType[],message[])->setBreak;
                                     restart loop;
                                     
                                 if)
                             if);
                             f.close;
                             
                         if)
                      #)
                 #)
            #)
       #);
     setBreak:
       (#
          fgName,ffName,breakType,message,t: ^text;
          modtime,index: @integer;
          fg: ^mps.ast.fragmentGroup;
          ff: ^mps.ast.fragmentForm;
          cast: ^mps.ast.ast;
          
       enter (fgname[],modtime,ffName[],index,breakType[],message[])
       do
          fgname[]->debuggee.mps.fragmentGroupTable.getFragmentGroup->fg[];
          setbr:
          (if fg.modtime <> modtime then
              'Fragment:\n     '->t[];
              fg.fullname->t.putline;
              'has been modified.  Ignoring breakpoint'->t.puttext;
              (t[],'Set breakpoint')->alertinfo;
              leave setbr
           else
              &text[]->t[];
              (ffName[],t[])->fg.open->ff[];
              (if t.length > 0 then
                  (t[],'MPS messages during setBreak')->alertinfo
              if);
              index
                ->ff.indexToNode
                  (#
                     indexOutOfRange:: 
                       (# t: ^text
                       do
                          'AST index unknown.\n'->t[];
                          msg[]->t.puttext;
                          (t[],'Set breakpoint')->alertinfo;
                          leave setbr
                       #);
                     noSuchSymbol:: 
                       (# t: ^text
                       do
                          'AST symbol unknown.\n'->t[];
                          msg[]->t.puttext;
                          (t[],'Set breakpoint')->alertinfo;
                          leave setbr
                       #);
                     grammarGenRefArrayError:: 
                       (# t: ^text
                       do
                          'Grammar problem.\n'->t[];
                          msg[]->t.puttext;
                          (t[],'Set breakpoint')->alertinfo;
                          leave setbr
                       #);
                     
                  #)->cast[];
              (if true
               // 'standardBreak'->breakType.equalNCS then
                  (cast[],FALSE,debuggee[])->setStandardBreakpoint
               // 'userOneShotBreak'->breakType.equalNCS then
                  (cast[],FALSE,debuggee[])->setOneShotBreakpoint
               // 'traceBreak'->breakType.equalNCS then
                  (cast[],FALSE,debuggee[],message[])->setTracepoint
               // 'UNKNOWN'->breakType.equalNCS then
                  ('UNKNOWN BREAKPOINT TYPE - IGNORED','WARNING')->alertinfo
              if)
          if)
       #);
     controlMenu: valhallaControlMenu
       (#
          open::< 
            (# 
            do
               'Go'->icontinue.new;
               'Step'->istepi.new;
               'Step Over'->istepo.new;
               'Stop'->istop.new;
               newseparator;
               'Rerun'->irerun.new;
               'Kill'->ikill.new;
               newseparator;
               'Insert SD Tracepoints'->isdtrace.new
            #)
       #);
     breakPulldownMenu: valhallaControlMenu
       (#
          open:: 
            (# 
            do
               ('Go Until Mark',gui.specKeys.F9,false,false,false)->iuntil.newSpecialKey;
               newseparator;
               'Set Break'->ibreak.new;
               'Set OneShot'->ioneshot.new;
               'Set Trace...'->itrace.new;
               newseparator;
               'Set Break After'->ibreakafter.new;
               'Set OneShot After'->ioneshotafter.new;
               'Set Trace After...'->itraceafter.new;
               newseparator;
               'Erase Break'->iclear.new;
               'Erase Break After'->iclearafter.new;
               (if (getObjectPrefs).getBoolean
                 (#  do 'debugValhalla'->name[] #) then
                   newseparator;
                   'Set and Show Step Breaks'->iintobreaks.new;
                   'Set and Show Step Over Breaks'->ioverbreaks.new;
                   
               if);
               newseparator;
               breakpointListMenu.open;
               'Breakpoints'->breakpointListMenu.name;
               iBreakpoints.open;
               iBreakpoints[]->append;
               'Breakpoints: Save'->iBreakpointSave.new;
               'Breakpoints: Load'->iBreakpointLoad.new;
               
            #)
       #);
     breakPopupMenu: valhallaControlMenu
       (#
          open:: 
            (# 
            do
               'Go'->icontinue.new;
               'Step'->istepi.new;
               'Step Over'->istepo.new;
               'Stop'->istop.new;
               newseparator;
               'Rerun'->irerun.new;
               'Kill'->ikill.new;
               'Stop Debugging'->iStopD.new;
               newseparator;
               'Go Until Mark'->iuntil.new;
               newseparator;
               'Set Break'->ibreak.new;
               'Set OneShot'->ioneshot.new;
               'Set Trace...'->itrace.new;
               newseparator;
               'Set Break After'->ibreakafter.new;
               'Set OneShot After'->ioneshotafter.new;
               'Set Trace After...'->itraceafter.new;
               newseparator;
               'Erase Break'->iclear.new;
               'Erase Break After'->iclearafter.new;
               (if (getObjectPrefs).getBoolean
                 (#  do 'debugValhalla'->name[] #) then
                   newseparator;
                   'Set and Show Step Breaks'->iintobreaks.new;
                   'Set and Show Step Over Breaks'->ioverbreaks.new;
                   
               if);
               newseparator;
               breakpointListMenu.open;
               'Breakpoints'->breakpointListMenu.name;
               iBreakpoints.open;
               iBreakpoints[]->append;
               
            #)
       #);
     breakpointClearer:
       (#
          node: ^astInterface.ast;
          pos: @Integer;
          onBreakpointClear:
            (# 
            do
               (node[],pos)->clearBreakPointMarker;
               (* (if node.hasComment then ('',pos,1)->node.setSubcomment if);
                * noComment->node.typeOfComment;
                *)
               node[]->updateViews;
               
            #);
          
       enter (node[],pos)
       exit onBreakPointClear##
       #);
     updateViews:
       (#
          node,contractionNode: ^astInterface.ast;
          cel: ^gui.codemoveableEditorList;
          inContr: @Boolean;
          
       enter node[]
       do
          gui.getcodemoveableEditorList->cel[];
          (* Update views showing the fragment containing cleared breakpoint. *)
          cel.newscan
            (# 
            do
               (if cur.frag[] <> none then
                   (if cur.frag.root[]->node.frag.root.equal then
                       node[]->cur.SifViewer.inContraction
                         ->(inContr,contractionNode[]);
                       (if inContr then
                       (* The node is not visible, so there is no need to 
                        * update the view. *)
                           
                        else
                           (node[],node[])->cur.SifViewer.astView.pp.update;
                           cur.SifViewer.cs->cur.SifViewer.setFocus;
                           
                       if)
                   if);
                   
               if);
               
            #);
          
       #);
     showBreakPoint:
       (#
          node: ^astInterface.ast;
          bm: ^processInterface.breakManager;
          debuggee: ^processInterface;
          pos: @Integer;
          marker: @Text;
          before:< object;
          after:< object;
          
       enter (node[],bm[],debuggee[])
       do
          (if node.symbol = debuggee.MPS.BETA.Imperatives then
              before;
              node[]->debuggee.mps.lastInList->node[];
              (node[],marker.copy)->setBreakpointAfterMarker->pos
           else
              after; 
              (node[],marker.copy)->setBreakPointBeforeMarker->pos
          if);
          (node[],pos)->breakpointClearer->bm.clearActions.appendAction;
          node[]->updateViews
       #);
     showBreak: showBreakPoint
       (#
          before:: 
            (#  do '<<%d<<'->marker.putformat (#  do bm.number->d #) #);
          after:: 
            (#  do '>>%d>>'->marker.putformat (#  do bm.number->d #) #)
       #);
     showOneShot: showBreakPoint
       (#
          before:: 
            (#  do '<<%d<<'->marker.putformat (#  do bm.number->d #) #);
          after:: 
            (#  do '>>%d>>'->marker.putformat (#  do bm.number->d #) #);
          
       #);
     showTrace: showBreakPoint
       (#
          before:: 
            (# 
            do
               '<<%d:"%10s"<<'
                 ->marker.putformat (#  do bm.number->d; m[]->s #)
            #);
          after:: 
            (# 
            do
               '>>%d:"%10s">>'
                 ->marker.putformat (#  do bm.number->d; m[]->s #)
            #);
          m: ^text
       enter m[]
       #);
     showSDTrace: showBreakPoint
       (# isExitToTxt:
            (# t:^text;
            do (if not isExit then 'Entry'->t[] else 'Exit'->t[] if)
            exit t[]
            #);
         (* before:: 
            (# 
            do
               '<SD %d:"%10s%s">'
                 ->marker.putformat (#  do bm.number->d; m[]->s; isExitToTxt->s #)
            #);
          after:: 
            (# 
            do
               '<SD %d:"%10s%s">'
                 ->marker.putformat (#  do bm.number->d; m[]->s; isExitToTxt->s #)
          #);*)
          m: ^text;
          isExit:@boolean
       enter (m[],isExit)
       #);
     setbreakprefix:
       (#
          impi: ^processInterface.ImperativeInfo;
          bm: ^processInterface.breakManager;
          node,originalnode,breaknode: ^astInterface.ast;
          listnode: ^astInterface.list;
          debuggee: ^processInterface;
          ok,after: @Boolean;
          afterError:< (#  do false->ok; INNER ;  #);
          error:< Object;
          
       enter (node[],after,debuggee[])
       do node[]->originalnode[];
          TRUE->ok;
          (if node.symbol = debuggee.mps.BETA.ObjectDescriptor then
              (node[]->qua (# as:: debuggee.mps.BETACFL.ObjectDescriptor #)).
              getMainPart->node[];
              
          if);
          (if node.symbol = debuggee.mps.BETA.MainPart then
              (node[]->qua (# as:: debuggee.mps.BETACFL.MainPart #)).
              getActionPart->node[];
              
          if);
          (if node.symbol = debuggee.mps.BETA.ActionPart then
              (node[]->qua (# as:: debuggee.mps.BETACFL.ActionPart #)).
              getDoPartOpt->node[];
              
          if);
          (if node.symbol = debuggee.mps.BETA.DoPart then
              (node[]->qua (# as:: debuggee.mps.BETACFL.DoPart #)).
              getImperatives->node[];
              
          if);
          (if node.symbol = debuggee.mps.BETA.Imperatives then
              node[]->listnode[];
              (if after then
                  listnode.noOfsons->listnode.get->node[];
                  (if node.symbol = debuggee.mps.ast.prodNo.optional then
                  (* EMPTY IMPERATIVE, following last ';' *)
                      listnode.noOfsons-1->listnode.get->node[]
                  if)
               else
                  1->listnode.get->node[]
              if)
          if);
          getimpi:
          node[]
            ->debuggee.ImperativeToCodeAddress
              (# noEnclosingDoPart::  (#  do leave getimpi #);  #)->impi[];
          (if impi[] = none then
              error; FALSE->ok; 
           else
              (if after then
                  impi.cast[]->debuggee.mps.nextbrother->breaknode[];
                  (if breaknode[] = none then
                      impi.cast.father->breaknode[];
                      (* was: node.father...*)
                      (if breaknode.symbol <> debuggee.mps.BETA.Imperatives then
                          afterError; leave setbreakprefix; 
                      if)
                  if);
                  getimpi:
                  breaknode[]
                    ->debuggee.ImperativeToCodeAddress
                      (# noEnclosingDoPart::  (#  do leave getimpi #); 
                      #)->impi[];
                  (if impi[] = none then
                      afterError; leave setbreakprefix; 
                  if);
                  
              if);
              (impi.start,MNGR_NEWNUMBER)->debuggee.ensureBreakManager->bm[];
              impi[]->bm.impi[];
              INNER ;
              
          if);
          
       exit ok
       #);
     Setstandardbreakpoint: setbreakprefix
       (#
          sb: ^processInterface.standardBreak;
          msg: @Text;
          afterError:: 
            (#  do 'ERROR - Cannot set breakpoint after'->infoMsg;  #);
          error:: 
            (# 
            do 'ERROR - Cannot set breakpoint at selected node'->infoMsg; 
            #);
          
       do
          checkPresence: bm.scan
            (# 
            do
               (if current## = debuggee.standardBreak## then
                   current[]->sb[]; leave checkPresence; 
               if);
               
            #);
          (if sb[] = none then
              bm[]->(&debuggee.standardBreak[]).init;
              'Breakpoint %d set'->msg.putformat (#  do bm.number->d #);
              msg[]->infoMsg;
              (impi.cast[],bm[],debuggee[])->showBreak;
              
           else
              'Breakpoint already set'->infoMsg; 
          if);
          
       #);
     SetTracepoint: setbreakprefix
       (#
          tb: ^processInterface.traceBreak;
          msg: @Text;
          afterError:: 
            (#  do 'ERROR - Cannot set tracepoint after'->infoMsg #);
          error:: 
            (# 
            do 'ERROR - Cannot set tracepoint at selected node'->infoMsg
            #);
          traceMessage: ^Text;
          
       enter traceMessage[]
       do
          (if traceMessage[] = none then
              (none ,'Tracepoint','Trace message','')
                ->gui.promptForText
                  (#
                     ok:: (#  do usertext.copy->traceMessage[] #);
                     cancel::
                       (# 
                       do
                          'Tracepoint cancelled'->infoMsg; none ->traceMessage[]
                       #)
                  #)
          if);
          (if traceMessage[] <> none then
              checkPresence: bm.scan
                (# 
                do
                   (if current## = debuggee.traceBreak## then
                       current[]->tb[]; leave checkPresence; 
                   if);
                   
                #);
              (if tb[] = none then
                  (bm[],traceMessage[])->(&debuggee.traceBreak[]).init;
                  'Tracepoint %d set'->msg.putformat (#  do bm.number->d #);
                  msg[]->infoMsg;
                  (impi.cast[],bm[],debuggee[],traceMessage[])->showTrace;
                  (impi.cast[],0,0,0)->(getCfe).setFocus;
                  
               else
                  'Tracepoint already set'->infoMsg; 
              if)
          if)
       #);
     SetSDTracepoint: setbreakprefix
       (#
          stb: ^processInterface.sdTraceBreak;
          msg: @Text;
          afterError:: 
            (#  do 'FGCA ERROR - Cannot set SDtracepoint after'->infoMsg;
               (node.father,3)->debuggee.doPrettyPrint->putline;
            #);
          error:: 
            (# 
            do 'FGC ERROR - Cannot set SDtracepoint at selected node'->infoMsg;
               (originalnode.father,-1)->debuggee.doPrettyPrint->putline;
            #);
          entryDesc: ^Text;
          isEnter,noExit:@boolean;
          od:^astinterface.ast;
       enter (entryDesc[],isEnter,od[],noExit)
       do
          (if true and ( entryDesc[] <> none ) then
              checkPresence: bm.scan
                (# 
                do
                   (if current## = debuggee.sdTraceBreak## then
                       current[]->stb[]; leave checkPresence
                   if)
                #);
              (if stb[] = none then
                  (bm[],entryDesc[],isEnter,od[],noExit)->(&debuggee.sdTraceBreak[]).init;
                  'SDTracepoint %d set'->msg.putformat (#  do bm.number->d #);
                  msg[]->infoMsg;
                  (* (impi.cast[],bm[],debuggee[],entryDesc[],isEnter)->showSDTrace; *)
                  (* (impi.cast[],0,0,0)->(getCfe).setFocus *)
               else
                  'SDTracepoint already set'->infoMsg; 
              if)
          if)
       #);
     setOneShotBreakPoint: setbreakprefix
       (#
          osb: ^processInterface.userOneShotBreak;
          msg: @Text;
          afterError:: 
            (#  do 'ERROR - Cannot set breakpoint after'->infoMsg;  #);
          error:: 
            (# 
            do 'ERROR - Cannot set breakpoint at selected node'->infoMsg; 
            #);
          
       do
          checkPresence: bm.scan
            (# 
            do
               (if current## = debuggee.userOneShotBreak## then
                   current[]->osb[]; leave checkPresence; 
               if);
               
            #);
          (if osb[] = none then
              bm[]->(&debuggee.userOneShotBreak[]).init;
              'One-shot breakpoint %d set'
                ->msg.putformat (#  do bm.number->d #);
              msg[]->infoMsg;
              (impi.cast[],bm[],debuggee[])->showOneShot;
              
           else
              'Breakpoint already set'->infoMsg; 
          if);
          
       #);
     setStepIntoBreaks:
       (#
          forEachNode:<
            (# node: ^astInterface.ast;  enter node[] do INNER ;  #);
          value: @Boolean;
          debuggee: ^processInterface;
          ussBreaker: debuggee.userSingleStepBreaker
            (#
               init::< 
                 (#
                    cancelled::  (#  do TRUE->continue #);
                    unknownCode:: 
                      (# 
                      do
                         'ERROR - Missing debug info. Cannot step.'->infoMsg;
                         TRUE->continue;
                         
                      #);
                    forEachImpNode:: 
                      (# 
                      do
                         (impi.cast[],bm[],debuggee[])->showBreak;
                         impi.cast[]->forEachNode;
                         
                      #);
                    
                 #);
               
            #);
          uss: ^ussBreaker;
          
       enter debuggee[]
       do &ussBreaker[]->uss[]; not uss.init->value
       exit value
       #);
     setStepOverBreaks:
       (#
          forEachNode:<
            (# node: ^astInterface.ast;  enter node[] do INNER ;  #);
          value: @Boolean;
          debuggee: ^processInterface;
          ussBreaker: debuggee.userStepOverBreaker
            (#
               init::< 
                 (#
                    cancelled::  (#  do TRUE->continue #);
                    unknownCode:: 
                      (# 
                      do
                         'ERROR - Missing debug info. Cannot step.'->infoMsg;
                         TRUE->continue;
                         
                      #);
                    forEachImpNode:: 
                      (# 
                      do
                         (impi.cast[],bm[],debuggee[])->showBreak;
                         impi.cast[]->forEachNode;
                         
                      #);
                    
                 #);
               
            #);
          uss: ^ussBreaker;
          
       enter debuggee[]
       do &ussBreaker[]->uss[]; not uss.init->value
       exit value
       #);
     doStepOver:
       (# 
       do
          (if debuggeeStatus then
              (if debuggee[]->setStepOverBreaks then debuggeeContinue if); 
          if);
          
       #);
     doStepInto:
       (# 
       do
          (if debuggeeStatus then
              (if debuggee[]->setStepIntoBreaks then debuggeeContinue if); 
          if);
          
       #);
     doStepUntil:
       (# 
       do
          (if debuggeeStatus then
              (if (getFocus,FALSE,debuggee[])->setOneShotBreakpoint then
                  debuggeeContinue
              if)
          if);
          
       #);
     clearBreakPoint: setbreakprefix
       (#
          sb: ^processInterface.breakPoint;
          msg: @Text;
          afterError:: 
            (#  do 'ERROR - Cannot clear breakpoint after'->infoMsg;  #);
          error:: 
            (# 
            do 'ERROR - Cannot clear breakpoint at selected node'->infoMsg; 
            #);
          
       do
          impi.start->debuggee.findBreakManager->bm[];
          (if bm[] <> none then
              clearAll: bm.scan (#  do current[]->sb[]; sb.doclear;  #); 
          if);
          (if sb[] = none then
              (if after then
                  'No breakpoint after selected node'->infoMsg; 
               else
                  'No breakpoint at selected node'->infoMsg; 
              if);
              
           else
              'Breakpoint %d cleared'->msg.putformat (#  do bm.number->d #);
              msg[]->infoMsg;
              
          if);
          
       #);
     setBreakPointBeforeMarker:
       (#
          node: ^astInterface.ast;
          theText: ^text;
          pos: @integer;
          commentAST: ^astInterface.comment;
          theComment: ^text
       enter (node[],theText[])
       do
          (if not node.hasComment then
              node[]->astView.pp.CreateEmptyComment->theComment[];
              (mps.ast.comment,0,node.frag[])->node.frag.grammar.newlexemText
                ->commentAST[];
              theComment[]->commentAST.putText;
              commentAST[]->node.addComment
          if);
          (theText[],1,1)->node.setSubcomment;
          astView.pp.breakPointComment->node.typeOfComment;
          
       exit 1
       #);
     setBreakPointAfterMarker:
       (#
          node: ^astInterface.ast;
          pos: @integer;
          theText: ^text;
          commentAST: ^astInterface.comment;
          theComment: ^text;
          noOfSons: @integer
       enter (node[],theText[])
       do
          (if not node.hasComment then
              node[]->astView.pp.CreateEmptyComment->theComment[];
              (mps.ast.comment,0,node.frag[])->node.frag.grammar.newlexemText
                ->commentAST[];
              theComment[]->commentAST.putText;
              commentAST[]->node.addComment
           else
              node.getComment->commentAst[]; commentAST.getText->theComment[]
          if);
          mps.ast.commentSeparator1
            ->theComment.findAll (#  do inx->noOfSons #);
          (theText[],noOfSons+2,1)->node.setSubcomment;
          astView.pp.breakPointComment->node.typeOfComment;
          
       exit noOfSons+2
       #);
     clearBreakPointMarker:
       (# node: ^astInterface.ast; pos: @integer
       enter (node[],pos)
       do
          (if node.hasComment then ('',pos,1)->node.setSubcomment if);
          astView.pp.normalComment->node.typeOfComment;
          
       #);
     astView: @mps.ast.astViewer;
     init:
       (# fg: ^astInterface.fragment; help: ^text; 
       do
          none ->astView.out[];
          mps.ast.grammarTable.beta.grammarAst.father->fg[];
          (fg.fullName).copy->help[];
          (help.length-4,help.length)->help.delete;
          help[]->astView.pp.init;
          true->astView.pp.abstractPresentation;
          true->astView.pp.editorMode;
          
       #);
     setSdTracePoints:
       (# editorAst,dopart:^astInterface.ast;
          exp:^astInterface.expanded;
          objdesc:^astInterface.BETA.objectdescriptor;
          mp:^mps.betacfl.mainpart;
          ap:^mps.betacfl.actionpart;
          imps:^mps.betacfl.imperatives;
          patdecl:^astInterface.BETA.PatternDecl;
          names:^astInterface.BETA.names;
          firstname:^astInterface.BETA.nameDcl;
          dp:^astInterface.BETA.dopart;
       do 'Setting SDtracepoints'->putline;
          sources.cfe.editorroot[]->editorAst[];
          editorAst.symbol->putint;
          editorAst[]->exp[];
          (* exp = descriptorform *)
          (* now find patterndecl herein *)
          11->exp.suffixWalkForProd
          (# 
          do current[]->exp[]; (* exp is p:(# ... #) *);
             exp.getson1->names[];
             exp.getson2->objdesc[];
             'found : %d\n'->putformat(# do objdesc.index->d #);
             names.newscan(# do current[]->firstname[] #); (* actually lastname!! *)
           
          
             
                             (* test for v:(# #) og vv:(# do #) *)
             
             objdesc.getMainPart->mp[];
             mp.getActionpart->ap[];
             ap.getdopartOpt->dopart[];
             (if dopart.kind=MPS.AST.kinds.optional then (* v *)
                 'found v'->putline;
                 
                 (objdesc[],FALSE (* before *),debuggee[],
                 firstname.getText,false,objdesc[],true)->setSdTracepoint;
              else
                 dopart[]->dp[];
                 dp.getImperatives->imps[];
                 (if imps.noOfsons=1 then
                     'found vv'->putline;
                     
                     (objdesc[],FALSE (* before *),debuggee[],
                     firstname.getText,false,objdesc[],true)->setSdTracepoint;
                  else
                     (objdesc[],FALSE (* before *),debuggee[],
                     firstname.getText,false,objdesc[],false)->setSdTracepoint;
                     
                     (* this has dopart with imperatives, insert exit breakpoint *)
                     (objdesc[],true (* after *),debuggee[],
                     firstname.getText,TRUE,objdesc[],false)->setSdTracepoint;

                 if)
             if);
                 
             
          #)
       #)

  #)  

