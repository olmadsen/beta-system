ORIGIN '../stackview';

--- stackviewlistlib:attributes ---

getObj:
  (# objAdr: @Integer;
     bo: ^processInterface.remoteBetaObject;
  enter objAdr
  do objAdr->debuggee.newRemoteObject->bo[];
  exit bo[]
  #);

getType: 
  (# bo: ^processInterface.remoteBetaObject;
     type: ^Text;
  enter bo[]
  do ((shorttitle,numbernames)->bo.description).copy->type[]
  exit type[]
  #);

getLabel:
  (# codeAdr: @Integer;
     label: ^Text; value: @Integer;
  enter codeAdr
  do codeAdr->debuggee.executable.labelAddressToName->(label[],value);
     (if label[]<>NONE then
         label.copy->label[];
         '+'->label.append;
         codeAdr-value->label.putInt;
      else
         '??? ('->label[];
         codeAdr->label.putInt;
         ') dynlink?'->label.append;
     if);
  exit label[]
  #);

showSelectedCode:
  (# inx: @Integer;
     impi: ^processInterface.ImperativeInfo;
  do (if svprivate.curItem//0 then leave showSelectedCode if);
     
     findEntry:
       (for i:lastStack.last repeat
            (if lastStack.viewIndex[i]//svprivate.curItem then
                i->inx;
                leave findEntry;
            if);
       for);
     
     (if lastStack.codeTypes[inx]//betaCode then
         lastStack.returnAdrs[inx]
           ->debuggee.utilities.codeAddressToImperative
         (# onPartialMinfo::
              (# tmp: @Text; pti: ^processInterface.prototypeInfo;
              do 
                 (if dp[]<>NONE then
                     (* Ok, at least we can show the dopart. *)
                     ('Unknown imperative. Showing surrounding dopart','Missing debug info')->encl.alertInfo;
                     dp[]->encl.openNewCodeView;
                  else
                     (* Show ObjectDescriptor whose dopart should contain
                      * the code address. *)
                     protoAdr
                       ->debuggee.utilities.ProtoAddressToPrototypeInfo
                       ->pti[];
                     (if pti[]//NONE then
                         ('Unknown ObjectDescriptor. Unable to show code.','Missing debug info')->encl.alertInfo;
                      else
                         ('Unknown imperative. Showing surrounding ObjectDescriptor','Missing debug info')->encl.alertInfo;
                         pti.objdesc[]->encl.openNewCodeView;
                     if);
                 if);
              #);
         #)->impi[]; 
         (if impi[]<>NONE then
             impi.cast[]->encl.openNewCodeView;
         if);
     if);
  #);

popupItemMenu:
  (# inx: @Integer; (* Index into lastStack of item currently selected. *)
     menupos: @Point;
     popupin: ^windowitem;
  enter (menupos, popupin[]) (* localposition from mouse event *)
  do 
     (if svprivate.curItem//0 then leave popupItemMenu if);
     
     svprivate.itemmenu.clear;
     
     findEntry:
       (for i:lastStack.last repeat
            (if lastStack.viewIndex[i]//svprivate.curItem then
                i->inx;
                leave findEntry;
            if);
       for);
     
     (if lastStack.codeTypes[inx]
      //unknownCode then   
      //betaCode then
         (# bo: ^processInterface.remoteBetaObject;
            t: ^Text;
         do 
            (* Show menu containing a single entry which is the object
             * corresponding to this return address. *)
            (lastStack.returnObjs[inx]->getObj->bo[]->getType).copy->t[];
            (if bo.isComponentObject then
                'COMP: '->t.prepend;
             else
                'OBJ: '->t.prepend;
            if);
            (t[],inx,svprivate.itemMenu.onObjectItemSelect##)
              ->svprivate.itemMenu.appendItemMenuItem;
         #);         
      //Gcode then
         'Gcode'->putLine;
      //Ccode then
         (# onSelect: svprivate.itemMenu.onSelectAction
              (# 
              do 
              #);
         do 'Ccode'->putLine;
         #)
      //attCode then
         'attCode'->putLine;
     if);
     
     (1,menupos,popupin[])->svprivate.itemMenu.popup;
  #);

updateList: 
  (# 
  do (if not svprivate.isGarbage then getStack->showStack if);
  #);

getStack:
  (# s: ^stackViewStack;
     lineCount: @Integer;   (* Total number of lines to show *)
     firstUnchanged: @Integer; (* Index of first entry unchanged since the
                                * last stack fetched. *)
     ninx,linx: @Integer;
     lastWasC: @Boolean; cskipped: @Integer;
  do  
     component.getAddress->debuggee.getStack
     (# theStackType:: stackViewStack #)->s[];
     
     s.last->s.codeTypes.new;
     s.last->s.viewIndex.new;
     s.last->s.viewText.new;
     
     (if debug then
         'stackviewbody:getStack: s.last=%d\n'->putformat
         (#
         do THIS(getStack).s.last->d;
         #)
     if);
     
     (* Calculate the number of stack entries that will not
      * be shown due to contraction of external parts: *)
     (for inx:s.last repeat
          (if s.returnObjs[inx]//0 then
              (if lastWasC then 
                  cskipped+1->cskipped;
               else
                  (if inx>1 then
                      (* Last entry was code generated by BETA compiler
                       * to handle a callback. Since we are not able to
                       * correctly map this code into BETA imperatives
                       * anyway, we might as well handle that code as
                       * C code. Do so by marking it as Ccode: *)
                         Ccode->s.codeTypes[inx-1];
                      cskipped+1->cskipped;
                  if);
              if);
              Ccode->s.codeTypes[inx];
              true->lastWasC;
           else
              false->lastWasC;
          if);
     for);
     
     s.last-cskipped->s.lineCount;
     s.last+1->firstUnchanged;
     (if lastStack[]<>NONE then
         s.last->ninx;
         lastStack.last->linx;
         loop:
           (if (ninx>0) and (linx>0) then
               (if s.returnAdrs[ninx]=lastStack.returnAdrs[linx] then
                   firstUnchanged-1->firstUnchanged;
                   ninx-1->ninx;
                   linx-1->linx;
                   restart loop;
               if);
           if);
     if);
     
  exit (s[],firstUnchanged)
  #);

showstack:
  (# s: ^stackviewStack;
     firstUnchanged: @Integer;
     lastoffset: @Integer; (* Difference in stack heigths *)
     tmp: ^Text;
     impi: ^processInterface.ImperativeInfo;
     pti: ^processInterface.prototypeInfo;
     lastwasC: @Boolean;
     viewIndex: @Integer;
  enter (s[],firstUnchanged)
  do 
     (if true
      //(numberOfItems>s.lineCount) then
         numberOfItems-s.lineCount->deleteFirst;
      //(numberOfItems<s.lineCount) then
         s.lineCount-numberOfItems->prepend;
     if);
     
     (if lastStack[]<>NONE then
         lastStack.last-s.last->lastoffset;
     if);
     
     1->viewIndex;
     (for inx:s.last repeat
          (if s.codeTypes[inx]=Ccode then
              (if not lastWasC then
                  ViewIndex->s.viewIndex[inx];
                  '<<External Stack Part>>'->s.viewText[inx][];
                  viewIndex+1->viewIndex;
              if);
              true->lastWasC;
           else
              (if inx>=firstUnchanged then
                  (* Reuse codeTypes and viewText from old stack. *)
                  lastStack.codeTypes[lastoffset+inx]
                    ->s.codeTypes[inx];
                  lastStack.viewText[lastoffset+inx][]
                    ->s.viewText[inx][]
               else
                  s.returnAdrs[inx]->debuggee.utilities.codeAddressToImperative
                  (# onGentry::
                       (# tmp: @Text; 
                       do 'G code for '->tmp.putText;
                          protoAdr->debuggee.utilities.ProtoAddressToPrototypeInfo
                            ->pti[];
                          (if pti[]//NONE then
                              '??? (%d)'->tmp.putFormat
                              (# 
                              do codeAdr->d;
                              #);                              
                           else
                              (pti.objdesc[],shortnames)->debuggee.rd.dumpAstPath
                                ->tmp.putText;
                          if);
                          '+'->tmp.putText;offset->tmp.putInt;
                          tmp.copy->s.viewText[inx][];
                          Gcode->s.codeTypes[inx];
                       #);
                     onPartialMinfo::
                       (# tmp: ^Text; 
                       do protoAdr
                            ->debuggee.utilities.ProtoAddressToPrototypeInfo
                            ->pti[];
                          
                          (if pti[]<>NONE then
                              (if pti.objdesc[]<>NONE then
                                  (pti.objdesc.frag.name).copy->tmp[];
                               else
                                  pti.ofi.groupName.copy->tmp[];
                              if);
                              ': UNKNOWN IMPERATIVE'->tmp.append;
                              ' in dopart of '->tmp.append;
                              (pti.objdesc[],shortnames)
                                ->debuggee.rd.dumpAstPath
                                ->tmp.append;
                           else
                              '??? (%d)'->tmp.putFormat
                              (# 
                              do codeAdr->d;
                              #);       
                          if);
                          tmp[]->s.viewText[inx][];
                          betaCode->s.codeTypes[inx];
                       #);
                  #)->impi[];
                  (if impi[]<>NONE then
                      (impi.cast.frag.name).copy->tmp[]; 
                      ': '->tmp.append;
                      ((impi.cast[],shortnames)->debuggee.rd.dumpAstPath).copy
                        ->tmp.append;
                      (if s.returnAdrs[inx]<>impi.start then
                          '+'->tmp.putText;
                          s.returnAdrs[inx]-impi.start->tmp.putInt;
                      if);
                      (if debug then
                          ' ('->tmp.append;
                          s.returnAdrs[inx]->tmp.putInt;
                          '='->tmp.append;
                          s.returnAdrs[inx]
                            ->getLabel
                            ->tmp.append;
                          ')'->tmp.append;
                      if);
                      tmp[]->s.viewText[inx][];
                      betaCode->s.codeTypes[inx];
                   else
                      (if s.viewText[inx][]=NONE then
                          (if inx=s.last then
                              'Attach'->s.viewText[inx][];
                              attCode->s.codeTypes[inx];
                           else
                              '???'->s.viewText[inx][];
                              unknownCode->s.codeTypes[inx];
                          if);
                      if);
                  if);
              if);
              viewIndex->s.viewIndex[inx];
              viewIndex+1->viewIndex;
              false->lastWasC;
          if);
     for);
     (for inx:s.last repeat
          (if s.viewText[inx][]<>NONE then
              (s.viewIndex[inx],s.viewText[inx][])->setText;
          if);
     for);
     s[]->lastStack[];
  #);

--- stackviewopen:descriptor ---
(# 
#)

--- stackviewlistdoupdate:dopart ---
do (if iconified then
       TRUE->updateDeferred
    else
       updateList;
   if);
   
--- stackviewlistclose:descriptor ---
(# sll: ^stackViewListList;
do svprivate.owner[]->objects.removeObjectOwner;
   svprivate.itemMenu.close;
   getstackviewlistList->sll[];
   THIS(stackViewList)[]->sll.at->sll.delete;
   THIS(stackViewList)[]->sll.onDelete;
#)

--- StackViewListOnDeIconify:dopart --
do
   (if updateDeferred then
       updateList;
       FALSE->updateDeferred;
   if)

--- stackviewlistopen:dopart ---
do 
   (# type: ^Text; sll: ^stackViewListList;
   do 
      getEncloser;
      encl.gettarget->(debuggee[],component[]);
      
      getOptionDB->odb[]; getObjectDB->objects[];
      
      INNER open; 
      
      'ShortObjectTitles'->odb.getBooleanOption
      (# found:: (# do value->shorttitle #)#);
      
      'ShortCodeNames'->odb.getBooleanOption
      (# found:: (# do value->shortnames #)#);
      
      'DebugValhalla'->odb.getBooleanOption
      (# found:: (# do value->debug #)#);
      
      'NumberObjects'->odb.getBooleanOption
      (# found:: (# do value->numbernames #);
         notfound:: (# do FALSE->numbernames #);
      #);
      
      ((shorttitle,numbernames)->component.description).copy->type[];
      (component[],svprivate.owner[])->objects.addObjectOwner;
      
      'Component stack: '->type.prepend;
      type[]->encl.settitle;
      
      svprivate.itemMenu.open;
      
      updateList;
      getstackviewlistList->sll[];
      THIS(stackViewList)[]->sll.onInsert;
      THIS(stackViewList)[]->sll.append;
   #);
   

--- stackviewOnMouseDown:descriptor ---
(# 
do Selection.first->svprivate.curItem;
   (if TRUE 
    //svPrivate.isGarbage then
       (* Do nothing *)
    else
       (if (buttonState=1) and doubleClick then
           (* Left mouse double-click. If possible, show the code of 
            * the selected stack item in a code viewer. *)
           showSelectedCode;
        else
           (if buttonState=3 then
               (localPosition, this(stackviewlist)[])->popupItemMenu;
           if);
       if);
   if)
#)

--- stackViewPrivate:descriptor ---
(# isGarbage: @Boolean;
   curItem: @Integer;
   
   onGarbage:
     (# type: ^Text;
     do disable;
        ((shorttitle,numbernames)->component.description).copy->type[];
        'GARBAGE component stack: '->type.prepend;
        type[]->encl.settitle;
        TRUE->isGarbage;
     #);
   
   owner: @objectOwner
     (# onObjectIsGarbage::
          (* Called if a betaObject is found to have become garbage in the
           * debugged process. The owner SHOULD NOT deregister itself
           * as a response to this call. That is done automatically!! *)
          (# 
          do onGarbage;
          #);
     #);
   
   itemMenu: @menu 
     (# appendItemMenuItem:
          (# itemtitle: ^Text; inx: @Integer; onSelect: ##onSelectAction;
             mi: ^itemMenuItem;
          enter (itemtitle[],inx,onSelect##)
          do &itemMenuItem[]->mi[];
             (itemtitle[],inx,onSelect##)->mi.open;
          #);
        
        onSelectAction:
          (# mi: ^itemMenuItem;
          enter mi[]
          do INNER
          #);

        onObjectItemSelect: onSelectAction
          (# 
          do (lastStack.returnObjs[mi.inx]->getObj,FALSE)
               ->encl.openNewObjectView
          #);

        onBetaCodeItemSelect: onSelectAction
          (# 
          do (*...*)
          #);

        itemMenuItem: menuItem
          (# onSelect: ##onSelectAction;
             inx: @Integer;
             open:: 
               (# itemtitle: ^Text;
               enter (itemtitle[],inx,onSelect##)
               do THIS(itemMenuItem)[]->append; itemtitle[]->name;
               #);
             eventHandler:: 
               (# onSelect:: 
                    (#
                    do THIS(itemMenuItem)[]->THIS(itemMenuItem).onSelect 
                    #)
               #);
          #);
     #);
#)
