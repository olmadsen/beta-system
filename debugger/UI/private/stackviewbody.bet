ORIGIN '../stackview';

--- stackviewlib:attributes ---

getObj:
  (# objAdr: @Integer;
     bo: ^remoteBetaObject;
  enter objAdr
  do (objAdr,debuggee.rd[])->newRemoteObject->bo[];
  exit bo[]
  #);

getType: 
  (# bo: ^remoteBetaObject;
     type: ^Text;
  enter bo[]
  do (shortnames->bo.description).copy->type[]
  exit type[]
  #);

getLabel:
  (# codeAdr: @Integer;
     label: ^Text; value: @Integer;
  enter codeAdr
  do codeAdr->debuggee.executable.labelAddressToName->(label[],value);
     (if label[]<>NONE then
         label.copy->label[];
         '+'->label.append;
         codeAdr-value->label.putInt;
      else
         '??? ('->label[];
         codeAdr->label.putInt;
         ') dynlink?'->label.append;
     if);
  exit label[]
  #);

showSelectedCode:
  (# inx: @Integer;
     impi: ^debuggee.ImperativeInfo;
  do (if svprivate.curItem//0 then leave showSelectedCode if);
     
     findEntry:
       (for i:lastStack.last repeat
            (if lastStack.viewIndex[i]//svprivate.curItem then
                i->inx;
                leave findEntry;
            if);
       for);
     
     (if lastStack.codeTypes[inx]//betaCode then
         lastStack.returnAdrs[inx]
           ->debuggee.utilities.codeAddressToImperative
         (# onPartialMinfo::
              (# tmp: @Text; pti: ^debuggee.prototypeInfo;
              do 
                 (if dp[]<>NONE then
                     (* Ok, at least we can show the dopart. *)
                     ('Unknown imperative. Showing surrounding dopart','Missing debug info')->alertInfo;
                     dp[]->openNewCodeView;
                  else
                     (* Show ObjectDescriptor whose dopart should contain
                      * the code address. *)
                     protoAdr
                       ->debuggee.utilities.ProtoAddressToPrototypeInfo
                       ->pti[];
                     (if pti[]//NONE then
                         ('Unknown ObjectDescriptor. Unable to show code.','Missing debug info')->alertInfo;
                      else
                         ('Unknown imperative. Showing surrounding ObjectDescriptor','Missing debug info')->alertInfo;
                         pti.objdesc[]->openNewCodeView;
                     if);
                 if);
              #);
         #)->impi[]; 
         (if impi[]<>NONE then
             impi.cast[]->openNewCodeView;
         if);
     if);
  #);

popupItemMenu:
  (# inx: @Integer; (* Index into lastStack of item currently selected. *)
     menupos: @Point;
  enter menupos (* localposition from mouse event *)
  do 
     (if svprivate.curItem//0 then leave popupItemMenu if);
     
     svprivate.itemmenu.clear;
     
     findEntry:
       (for i:lastStack.last repeat
            (if lastStack.viewIndex[i]//svprivate.curItem then
                i->inx;
                leave findEntry;
            if);
       for);
     
     'viewIndex='->putText; inx->putInt; newline;
     
     (if lastStack.codeTypes[inx]
      //unknownCode then   
      //betaCode then
         (# bo: ^remoteBetaObject;
            t: ^Text;
         do 
            (* Show menu containing a single entry which is the object
             * corresponding to this return address. *)
            (lastStack.returnObjs[inx]->getObj->bo[]->getType).copy->t[];
            (if bo.isComponentObject then
                'COMP: '->t.prepend;
             else
                'OBJ: '->t.prepend;
            if);
            (t[],inx,svprivate.itemMenu.onObjectItemSelect##)
              ->svprivate.itemMenu.appendItemMenuItem;
         #);         
      //Gcode then
         'Gcode'->putLine;
      //Ccode then
         (# onSelect: svprivate.itemMenu.onSelectAction
              (# 
              do 
              #);
         do 'Ccode'->putLine;
         #)
      //attCode then
         'attCode'->putLine;
     if);
     
     THIS(stackView).itemPos->menupos.add;
     (1,menupos,THIS(window)[])->svprivate.itemMenu.popup;
  #);

--- stackviewListLib:attributes ---

updateList: 
  (# 
  do (if not svprivate.isGarbage then getStack->showStack if);
  #);

getStack:
  (# newStack: ^compStack;
     lineCount: @Integer;   (* Total number of lines to show *)
     firstUnchanged: @Integer; (* Index of first entry unchanged since the
                                * last stack fetched. *)
     ninx,linx: @Integer;
  do  
     component.getAddress->debuggee.processComm.scanStack
     (# lastWasC: @Boolean; cskipped: @Integer;
     do
        &compstack[]->newStack[];
        returnObjs->newStack.returnObjs;
        returnAdrs->newStack.returnAdrs;
        returnObjs.range->newStack.codeTypes.new;
        returnObjs.range->newStack.viewIndex.new;
        returnObjs.range->newStack.viewText.new;
        last->newStack.last;
        
        (* Calculate the number of stack entries that will not
         * be shown due to contraction of external parts: *)
        (for inx:last repeat
             (if returnObjs[inx]//0 then
                 (if lastWasC then 
                     cskipped+1->cskipped;
                  else
                     (if inx>1 then
                         (* Last entry was code generated by BETA compiler
                          * to handle a callback. Since we are not able to
                          * correctly map this code into BETA imperatives
                          * anyway, we might as well handle that code as
                          * C code. Do so by marking it as Ccode: *)
                         Ccode->newStack.codeTypes[inx-1];
                         cskipped+1->cskipped;
                     if);
                 if);
                 Ccode->newStack.codeTypes[inx];
                 true->lastWasC;
              else
                 false->lastWasC;
             if);
        for);
        
        last-cskipped->newStack.lineCount;
     #);
     
     newStack.last+1->firstUnchanged;
     (if lastStack[]<>NONE then
         newStack.last->ninx;
         lastStack.last->linx;
         loop:
           (if (ninx>0) and (linx>0) then
               (if newStack.returnAdrs[ninx]=lastStack.returnAdrs[linx] then
                   firstUnchanged-1->firstUnchanged;
                   ninx-1->ninx;
                   linx-1->linx;
                   restart loop;
               if);
           if);
     if);
     
  exit (newStack[],firstUnchanged)
  #);

showstack:
  (# newStack: ^compstack;
     firstUnchanged: @Integer;
     lastoffset: @Integer; (* Difference in stack heigths *)
     tmp: ^Text;
     impi: ^debuggee.ImperativeInfo;
     pti: ^debuggee.prototypeInfo;
     lastwasC: @Boolean;
     viewIndex: @Integer;
  enter (newStack[],firstUnchanged)
  do 
     (if true
      //(numberOfItems>newStack.lineCount) then
         numberOfItems-newStack.lineCount->deleteFirst;
      //(numberOfItems<newStack.lineCount) then
         newStack.lineCount-numberOfItems->prepend;
     if);
     
     (if lastStack[]<>NONE then
         lastStack.last-newStack.last->lastoffset;
     if);
     
     1->viewIndex;
     (for inx:newStack.last repeat
          (if newStack.codeTypes[inx]=Ccode then
              (if not lastWasC then
                  ViewIndex->newStack.viewIndex[inx];
                  '<<External Stack Part>>'->newStack.viewText[inx][];
                  viewIndex+1->viewIndex;
              if);
              true->lastWasC;
           else
              (if inx>=firstUnchanged then
                  (* Reuse codeTypes and viewText from old stack. *)
                  lastStack.codeTypes[lastoffset+inx]
                    ->newStack.codeTypes[inx];
                  lastStack.viewText[lastoffset+inx][]
                    ->newStack.viewText[inx][]
               else
                  newStack.returnAdrs[inx]->debuggee.utilities.codeAddressToImperative
                  (# onGentry::
                       (# tmp: @Text; 
                       do 'G code for '->tmp.putText;
                          protoAdr->debuggee.utilities.ProtoAddressToPrototypeInfo
                            ->pti[];
                          (if pti[]//NONE then
                              '???'->tmp.putText;
                           else
                              (pti.objdesc[],shortnames)->debuggee.rd.dumpAstPath
                                ->tmp.putText;
                          if);
                          '+'->tmp.putText;offset->tmp.putInt;
                          tmp.copy->newStack.viewText[inx][];
                          Gcode->newStack.codeTypes[inx];
                       #);
                     onPartialMinfo::
                       (# tmp: ^Text; 
                       do protoAdr
                            ->debuggee.utilities.ProtoAddressToPrototypeInfo
                            ->pti[];
                          
                          (if pti[]<>NONE then
                              (if pti.objdesc[]<>NONE then
                                  (pti.objdesc.frag.name).copy->tmp[];
                               else
                                  pti.ofi.groupName.copy->tmp[];
                              if);
                              ': UNKNOWN IMPERATIVE'->tmp.append;
                              ' in dopart of '->tmp.append;
                              (pti.objdesc[],shortnames)
                                ->debuggee.rd.dumpAstPath
                                ->tmp.append;
                           else
                              '???'->tmp[];
                          if);
                          tmp[]->newStack.viewText[inx][];
                          betaCode->newStack.codeTypes[inx];
                       #);
                  #)->impi[];
                  (if impi[]<>NONE then
                      (impi.cast.frag.name).copy->tmp[]; 
                      ': '->tmp.append;
                      ((impi.cast[],shortnames)->debuggee.rd.dumpAstPath).copy
                        ->tmp.append;
                      (if newStack.returnAdrs[inx]<>impi.start then
                          '+'->tmp.putText;
                          newStack.returnAdrs[inx]-impi.start->tmp.putInt;
                      if);
                      (if debug then
                          ' ('->tmp.append;
                          newStack.returnAdrs[inx]
                            ->getLabel
                            ->tmp.append;
                          ')'->tmp.append;
                      if);
                      tmp[]->newStack.viewText[inx][];
                      betaCode->newStack.codeTypes[inx];
                   else
                      (if newStack.viewText[inx][]=NONE then
                          (if inx=newStack.last then
                              'Attach'->newStack.viewText[inx][];
                              attCode->newStack.codeTypes[inx];
                           else
                              '???'->newStack.viewText[inx][];
                              unknownCode->newStack.codeTypes[inx];
                          if);
                      if);
                  if);
              if);
              viewIndex->newStack.viewIndex[inx];
              viewIndex+1->viewIndex;
              false->lastWasC;
          if);
     for);
     (for inx:newStack.last repeat
          (if newStack.viewText[inx][]<>NONE then
              (newStack.viewIndex[inx],newStack.viewText[inx][])->setText;
          if);
     for);
     newStack[]->lastStack[];
  #);

--- stackviewopen:descriptor ---
(# type: ^Text;
do 
   getOptionDB->odb[]; getObjectDB->objects[];
   
   INNER open; 
   
   'ShortObjectTitles'->odb.getBooleanOption
   (# found:: (# do value->shorttitle #)#);
   
   'ShortCodeNames'->odb.getBooleanOption
   (# found:: (# do value->shortnames #)#);
   
   'DebugGroupsInfo'->odb.getBooleanOption
   (# found:: (# do value->debug #)#);
   
   (shorttitle->component.description).copy->type[];
   (component[],svprivate.owner[])->objects.addObjectOwner;
   
   'Component stack: '->type.prepend;
   type[]->title;
   
   svprivate.itemMenu.open;
#)

--- stackviewdoupdate:dopart ---
do (if iconified then
       TRUE->updateDeferred
    else
       contents.list.updateList;
   if);
   
--- stackviewclose:descriptor ---
(#
do svprivate.owner[]->objects.removeObjectOwner;
   svprivate.itemMenu.close;
#)

--- StackViewOnDeIconify:dopart --
do
   (if updateDeferred then
       contents.list.updateList;
       FALSE->updateDeferred;
   if)

--- stackviewlistopen:dopart ---
do updateList;

--- stackviewOnMouseDown:descriptor ---
(# 
do Selection.first->svprivate.curItem;
   (if TRUE 
    //svPrivate.isGarbage then
       (* Do nothing *)
    //not doubleClick then
       (if buttonState=3 then localPosition->popupItemMenu if);
    else
       (if buttonState=1 then
           (* Left mouse double-click. If possible, show the code of 
            * the selected stack item in a code viewer. *)
           showSelectedCode;
       if);
   if);
   
#)

--- stackViewPrivate:descriptor ---
(# isGarbage: @Boolean;
   curItem: @Integer;
   
   onGarbage:
     (# type: ^Text;
     do contents.list.disable;
        (shorttitle->component.description).copy->type[];
        'GARBAGE component stack: '->type.prepend;
        type[]->title;
        TRUE->isGarbage;
     #);
   
   owner: @objectOwner
     (# onObjectIsGarbage::
          (* Called if a betaObject is found to have become garbage in the
           * debugged process. The owner SHOULD NOT deregister itself
           * as a response to this call. That is done automatically!! *)
          (# 
          do onGarbage;
          #);
     #);
   
   itemMenu: @menu 
     (# appendItemMenuItem:
          (# itemtitle: ^Text; inx: @Integer; onSelect: ##onSelectAction;
             mi: ^itemMenuItem;
          enter (itemtitle[],inx,onSelect##)
          do &itemMenuItem[]->mi[];
             (itemtitle[],inx,onSelect##)->mi.open;
          #);
        
        onSelectAction:
          (# mi: ^itemMenuItem;
          enter mi[]
          do INNER
          #);

        onObjectItemSelect: onSelectAction
          (# 
          do (lastStack.returnObjs[mi.inx]->getObj,FALSE)->openNewObjectView
          #);

        onBetaCodeItemSelect: onSelectAction
          (# 
          do (*...*)
          #);

        itemMenuItem: menuItem
          (# onSelect: ##onSelectAction;
             inx: @Integer;
             open:: 
               (# itemtitle: ^Text;
               enter (itemtitle[],inx,onSelect##)
               do THIS(itemMenuItem)[]->append; itemtitle[]->name;
               #);
             eventHandler:: 
               (# onSelect:: 
                    (#
                    do THIS(itemMenuItem)[]->THIS(itemMenuItem).onSelect 
                    #)
               #);
          #);
     #);
#)
