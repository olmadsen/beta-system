ORIGIN 'valhallaGUI';
INCLUDE '~beta/basiclib/v1.4/formatio';
INCLUDE '../processInterface';
INCLUDE '../remotedumper';
INCLUDE '../objectPoolAdditions';
INCLUDE '../breakpoints';
INCLUDE '~beta/objectbrowser/v2.0/betagrammarinit';

INCLUDE '~beta/guienv/v1.3.1/stddialogs';

--- valhallaGUIlib:attributes ---

GUIprocess: processInterface
  (# remoteObjects: @remoteObjectDB;
     bml: @breakManagerList;
     running: @Boolean;
     notifyUserOnStop: @Boolean;
     (* Set to TRUE if the process stop should be reported to the user.
      * Set to FALSE if process stop was due to a skipBreak or a conditional
      * breakpoint that evaluated to FALSE. In these cases, the process should
      * continue at once. *)
     rerun:: 
       (# 
       do remoteObjects.clear;
          FALSE->running;
          (* Reset breakpoints. *)
          bml.scan (# do current.reinstall #);
       #);
     init::
       (#
       do remoteObjects.init; remoteObjects[]->newObjectPoolPut
          (# alreadyThere:: (# do true->continue #)#);
          bml.init; bml[]->newObjectPoolPut
          (# alreadyThere:: (# do true->continue #)#);
          betaGrammarInit;
          INNER;
       #);
     onOpenGroup::
       (# t: @Text;
       do 'Opening %s'->t.putFormat (# do groupName[]->s #);
          t[]->putinfo;
       #);
     onOpenGroupDone::
       (# 
       do ''->putinfo;
       #);
     onOldGroup::
       (# t: @Text;
       do '"%s.%s" is older than "%s.%s"'->t.putFormat
          (# 
          do groupName[]->s; AST.astFileExtension->s;
             groupName[]->s; 'bet'->s;
          #);
          (t[],'Debug Info Error: Recompilation required')->alertInfo;
          true->continue;
       #);
     onNewGroup::
       (# t: @Text;
       do '"%s.%s" is newer than executable'->t.putFormat
          (# 
          do groupName[]->s; AST.astFileExtension->s;
          #);
          (t[],'Debug Info Error: Recompilation required')->alertInfo;
          true->continue;
       #);
     onUncheckedGroup::
       (#  t: @Text;
       do '"%s.%s" has not been checked by compiler'->t.putFormat
          (# 
          do groupName[]->s; AST.astFileExtension->s;
          #);
          (t[],'Debug Info Error: Recompilation required')->alertInfo;
          true->continue;
       #);
     onGroupNotFound::
       (# t: @Text;
       do 'ERROR: "%s.%s" not found !!!' -> t.putFormat
          (# 
          do groupName[]->s; AST.astFileExtension->s;
          #);
          (t[],'Debug Info Error')->alertInfo;
          true->continue;
       #);
     DBstatus::
       (# t: @Text;
       do (if status 
           //DBFILE_OK then
              (* 'Reading ' -> t.append; dbName[]->t.append; *)
           //DBFILE_NOTFOUND then
              'Could not find ' -> t.append; dbName[]->t.append;
              (t[],'Debug Info Error')->alertInfo;
           //DBFILE_NEWER then
              dbName[]->t.append; ' newer than executable'->t.append;
              (t[],'Debug Info Error')->alertInfo;
          if);
       #);
     dbLoadFailed::
       (# t: @Text; title: ^Text;
       do 
          dbfilename->t;
          (if dbstatus
           //DBFILE_NOTFOUND then
              ' not found'->t.putText;
           //DBFILE_NEWER then
              ' newer than executable'->t.putText;
          if);
          (t[],'Debug Info Error')->alertInfo;
          TRUE->continue;
       #);
     onProcessFork::
       (# t: @Text;
       do 'Forking `%s'' process'->t.putFormat
          (#de: @diskEntry;
          do getEXECNAMEparam->de.path;
             de.path.name->s;
          #);
          t[]->putinfo;
       #);
     onProcessForkDone::
       (#
       do (* ''->putinfo; *)
       #);
     onDataSegmentScan::
       (# 
       do 'Scanning data segments of debugged process'->putinfo;
       #);
     onDataSegmentScanDone::
       (# 
       do (* ''->putinfo; *)
       #);
     onLabelRead::
       (# 
       do 'Reading labels from executable'->putinfo;
          cursors.watch[]->mouse.busyCursor;
       #);
     onLabelReadDone::
       (# 
       do ''->putinfo;
          NONE->mouse.busyCursor;
       #);
     groupsInfoTableType::
       (# onScan::
            (# t: @Text;
            do 'Scanning ObjectDescriptors in %s'->t.putFormat
               (# do groupName[]->s #);
               t[]->putinfo;
            #);
          onScanDone::
            (# 
            do ''->putinfo;
            #);
       #);
     utilitiesFailure::
       (# 
       do (errormsg[],'ERROR!!')->alertinfo; true->continue;
       #);
     unknownImpFailure::
       (# 
       do ('Failed to set breakpoint','WARNING!!')->alertinfo; true->continue;
       #);
     beforeContinue::
       (# 
       do processComm.DOT.scan
          (# 
          do lookup:
               (# 
               do remoteObjects.scanObjects
                  (# 
                  do (if current.bo.dotinx=dotinx then
                         (* Delete the object from DOT (delete) and
                          * from the remoteObjectDB (deleteObject)
                          * unless it has been touched since the
                          * last time wait returned or has more than
                          * one owner. *)
                         
                         (current.bo.timestamp<>rd.now) 
                         and (current.refCount=1)->delete->deleteObject;
                         leave lookup;
                     if);
                  #);
                  remoteObjects.scanPatterns
                  (# 
                  do (if current.bp.dotinx=dotinx then
                         (* Same comment as above *)
                         (current.bp.timestamp<>rd.now)
                         and (current.refCount=1)->delete->deletePattern;
                         leave lookup
                     if);
                  #);
                  'Unexpected: DOT element not found in remoteObjectDB'
                    -> putLine;
               #);
          #);
          TRUE->running;
       #);
        
     afterWait::
       (#
       do FALSE->running;
          TRUE->notifyUserOnStop;
          (if terminated then
              onTerminate;
           else
              rd.incTime;
              
              (* Check whether the user should be notified, or the process just
               * stopped due to a skipbreak. *)
              
              (if bml.skipBreakHit then
                  (* Only notify user if a userBreak was hit at the same time
                   * or some runtime error occurred. *)
                  (if bml.userBreakHit=MNGR_NONUMBER then
                      FALSE->notifyUserOnStop;
                      leave afterWait;
                  if);
              if);
              
              (* Find objects and pattern that have become garbage, 
               * and notify the owners: *)
          
              remoteObjects.scanObjects
              (# adr: @Integer; curObj: ^remoteObjects.betaObjectType;
              do current.bo.dotinx->processComm.DOT.inxToAddress->adr;
                 (if adr=0 then
                     (* This object has become garbage. Notify the owners
                      * and delete them from the objects table. *)
                     current.bo[]->curObj[];
                     current.scanOwners
                     (# 
                     do curObj[]->current.onObjectIsGarbage;
                        TRUE->delete;
                     #);
                 if);
              #);
              
              remoteObjects.scanPatterns
              (# adr: @Integer; curPat: ^remoteObjects.betaPatternType;
              do current.bp.dotinx->processComm.DOT.inxToAddress->adr;
                 (if adr=0 then
                     (* This pattern has become garbage. Notify the owners
                      * and delete them from the objects table. *)
                     current.bp[]->curPat[];
                     current.scanOwners
                     (# 
                     do curPat[]->current.onPatternIsGarbage;
                        TRUE->delete;
                     #);
                 if);
              #);
              
              main.moveables.scan (# do current.doUpdate #);
              
          if);
       #);
     
     mypretty: @rd.prettyPrinter; myprettyinitialized: @Boolean;
     doPrettyPrint::
       (# 
       do (if not myprettyinitialized then mypretty.init if);
          (a[],level)->mypretty->pp[];
       #);
  #)
