ORIGIN 'valhallaGUI';
INCLUDE '~beta/basiclib/v1.4/formatio';
INCLUDE '../processInterface';
INCLUDE '../remotedumper';
INCLUDE '../objectPoolAdditions';
INCLUDE '~beta/objectbrowser/v2.0/betagrammarinit';

INCLUDE '~beta/guienv/v1.2/stddialogs';

--- valhallaGUIlib:attributes ---

GUIprocess: processInterface
  (# rd: @remoteDumper;
     remoteObjects: @remoteObjectDB;
     running: @Boolean;
     rerun:: 
       (# 
       do remoteObjects.clear;
          (AST[],BETACFL[],THIS(GUIprocess)[])->rd.init;
          FALSE->running;
       #);
     init::
       (#
       do
          remoteObjects.init; remoteObjects[]->newObjectPoolPut
          (# alreadyThere:: (# do true->continue #)#);
          
          (AST[],BETACFL[],THIS(GUIprocess)[])->rd.init; 
          betaGrammarInit;
          INNER
       #);
     onOpenGroup::
       (# t: @Text;
       do 'Opening %s'->t.putFormat (# do groupName[]->s #);
          t[]->putinfo;
       #);
     onOpenGroupDone::
       (# 
       do ''->putinfo;
       #);
     onOldGroup::
       (# t: @Text;
       do '"%s.%s" is older than "%s.%s"'->t.putFormat
          (# 
          do groupName[]->s; AST.astFileExtension->s;
             groupName[]->s; 'bet'->s;
          #);
          (t[],'Debug Info Error: Recompilation required')->alertInfo;
          true->continue;
       #);
     onGroupNotFound::
       (# t: @Text;
       do 'ERROR: "%s.%s" not found !!!' -> t.putFormat
          (# 
          do groupName[]->s; AST.astFileExtension->s;
          #);
          (t[],'Debug Info Error')->alertInfo;
          true->continue;
       #);
     DBstatus::
       (# t: @Text;
       do (if status 
           //DBFILE_OK then
              (* 'Reading ' -> t.append; dbName[]->t.append; *)
           //DBFILE_NOTFOUND then
              'Could not find ' -> t.append; dbName[]->t.append;
              t[]->putinfo;
           //DBFILE_NEWER then
              dbName[]->t.append; ' newer than executable'->t.append;
              t[]->putinfo;
          if);
       #);
     dbLoadFailed::
       (# t: @Text; title: ^Text;
       do 
          dbfilename->t;
          (if dbstatus
           //DBFILE_NOTFOUND then
              ' not found'->t.putText;
           //DBFILE_NEWER then
              ' newer than executable'->t.putText;
          if);
          (t[],'Debug Info Error')->alertInfo;
          TRUE->continue;
       #);
     onProcessFork::
       (# t: @Text;
       do 'Forking %s process'->t.putFormat(# do getEXECNAMEparam->s #);
          t[]->putinfo;
       #);
     onProcessForkDone::
       (#
       do (* ''->putinfo; *)
       #);
     onDataSegmentScan::
       (# 
       do 'Scanning data segments of debugged process'->putinfo;
       #);
     onDataSegmentScanDone::
       (# 
       do (* ''->putinfo; *)
       #);
     onLabelRead::
       (# 
       do 'Reading labels from executable'->putinfo;
       #);
     onLabelReadDone::
       (# 
       do ''->putinfo;
       #);
     groupsInfoTableType::
       (# onScan::
            (# t: @Text;
            do 'Scanning ObjectDescriptors in %s'->t.putFormat
               (# do groupName[]->s #);
               t[]->putinfo;
            #);
          onScanDone::
            (# 
            do ''->putinfo;
            #);
       #);
     utilitiesFailure::
       (# 
       do errormsg[]->putinfo; true->continue;
       #);
        
     beforeContinue::
       (# 
       do processComm.DOT.scan
          (# 
          do lookup:
               (# 
               do remoteObjects.scanObjects
                  (# 
                  do (if current.bo.dotinx=dotinx then
                         (* Delete the object from DOT (delete) and
                          * from the remoteObjectDB (deleteObject)
                          * unless it has been touched since the
                          * last time wait returned or has more than
                          * one owner. *)
                         
                         (current.bo.timestamp<>rd.now) 
                         and (current.refCount=1)->delete->deleteObject;
                         leave lookup;
                     if);
                  #);
                  remoteObjects.scanPatterns
                  (# 
                  do (if current.bp.dotinx=dotinx then
                         (* Same comment as above *)
                         (current.bp.timestamp<>rd.now)
                         and (current.refCount=1)->delete->deletePattern;
                         leave lookup
                     if);
                  #);
                  'Unexpected: DOT element not found in remoteObjectDB'
                    -> putLine;
               #);
          #);
          TRUE->running;
       #);
        
     afterWait::
       (# 
       do FALSE->running;
          rd.incTime;
          (if terminated then
              onTerminate;
           else      
              (* Find objects and pattern that have become garbage, 
               * and notify the owners: *)
          
              remoteObjects.scanObjects
              (# adr: @Integer; curObj: ^remoteObjects.betaObjectType;
              do current.bo.dotinx->processComm.DOT.inxToAddress->adr;
                 (if adr=0 then
                     (* This object has become garbage. Notify the owners
                      * and delete them from the objects table. *)
                     current.bo[]->curObj[];
                     current.scanOwners
                     (# 
                     do curObj[]->current.onObjectIsGarbage;
                        TRUE->delete;
                     #);
                 if);
              #);
              
              remoteObjects.scanPatterns
              (# adr: @Integer; curPat: ^remoteObjects.betaPatternType;
              do current.bp.dotinx->processComm.DOT.inxToAddress->adr;
                 (if adr=0 then
                     (* This pattern has become garbage. Notify the owners
                      * and delete them from the objects table. *)
                     current.bp[]->curPat[];
                     current.scanOwners
                     (# 
                     do curPat[]->current.onPatternIsGarbage;
                        TRUE->delete;
                     #);
                 if);
              #);
              
              main.moveables.scan (# do current.doUpdate #);
              
          if);
       #);
  #)
