ORIGIN 'valhallaGUI';
INCLUDE '~beta/basiclib/v1.6/formatio';
INCLUDE '../processInterface';
INCLUDE '../remotedumper';
INCLUDE '../objectPoolAdditions';
INCLUDE '../breakpoints';

INCLUDE '~beta/guienv/v1.6/stddialogs';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- valhallaGUIlib:attributes ---

GUIprocess: processInterface
  (# remoteObjects: @remoteObjectDB;
     bml: @breakManagerList;
     running: @Boolean;
     notifyUserOnStop: @Boolean;
     (* Set to TRUE if the process stop should be reported to the user.
      * Set to FALSE if process stop was due to a skipBreak or a conditional
      * breakpoint that evaluated to FALSE. In these cases, the process should
      * continue at once. *)
     changedSources:
       (* tests if the sources of this(GUIprocess) have been changed
        * since last compilation
        *)
       (# changed: @boolean;
          execModtime: @integer;
          Report:
            (#
            do true->changed;
               msg.newLine;
               'Quit immediately (and recompile) to be able to continue debugging'
                 ->msg.puttext;
               (msg[],'Warning')->alertInfo
            #);
          msg: @text;
       do msg.clear;
          false->changed;
          executable.modtime->execModtime;
          'Checking for changed fragments...'->putinfo;
          scan:
            scanObjectFileInfos
            (# diskfile,textfile: @file;
               t: @text;
            do current.groupName->t;
               MPS.AST.astFileExtension->t.append; t[]->diskfile.name;
               current.groupName->t;
               '.bet'->t.append; t[]->textfile.name;
               (if textfile.entry.exists and
                   (textfile.entry.modTime > execModtime) then
                   'Source file: '->msg.puttext;
                   textfile.name->msg.putline;
                   '   has been changed since last compilation of the executable!'->msg.putline;
                else
                   (if diskfile.entry.exists then
                       (if (diskfile.entry.modTime > execModtime) then
                           'Group file: '->msg.puttext;
                           diskfile.name->msg.putline;
                           '   has been changed since last compilation of the executable!'->msg.putline;
                       if)
                    else
                       'Group file: '->msg.puttext;
                       diskfile.name->msg.putline;
                       '   has been deleted!'->msg.putline;
                   if)
               if)
            #);
          (if msg.length>0 then Report if);
          ''->putinfo;
       exit changed   
       #);
     rerun:: 
       (# success: @boolean
       do remoteObjects.clear;
          FALSE->running;
          (* Reset breakpoints. *)
          bml.scan (# do current.reinstall #);
          not changedSources->success
       exit success
       #);
     init::
       (# success: @boolean
       do remoteObjects.init; remoteObjects[]->newObjectPoolPut
          (# alreadyThere:: (# do true->continue #)#);
          bml.init; bml[]->newObjectPoolPut
          (# alreadyThere:: (# do true->continue #)#);
          not changedSources->success;
          INNER;
       exit success
       #);
     DBstatus::
       (# t: @Text;
       do (if status 
           //DBFILE_OK then
              (* 'Reading ' -> t.append; dbName[]->t.append; *)
           //DBFILE_NOTFOUND then
              'Could not find ' -> t.append; dbName[]->t.append;
              (t[],'Debug Info Error')->alertInfo;
           //DBFILE_NEWER then
              dbName[]->t.append; ' newer than executable'->t.append;
              (t[],'Debug Info Error')->alertInfo;
          if);
       #);
     dbLoadFailed::
       (# t: @Text; title: ^Text;
       do 
          dbfilename->t;
          (if dbstatus
           //DBFILE_NOTFOUND then
              ' not found'->t.putText;
           //DBFILE_NEWER then
              ' newer than executable'->t.putText;
          if);
          (t[],'Debug Info Error')->alertInfo;
          TRUE->continue;
       #);
     onProcessFork::
       (# t: @Text;
       do 'Forking `%s'' process'->t.putFormat
          (# de: @diskEntry;
          do getEXECNAMEparam->de.path;
             de.path.name->s;
          #);
          t[]->putinfo;
       #);
     onProcessForkDone::
       (#
       do (* ''->putinfo; *)
       #);
     onDataSegmentScan::
       (# 
       do 'Scanning data segments of debugged process'->putinfo;
       #);
     onDataSegmentScanDone::
       (# 
       do (* ''->putinfo; *)
       #);
     onLabelRead::
       (# 
       do 'Reading labels from executable'->putinfo;
          cursors.watch[]->mouse.busyCursor;
       #);
     onLabelReadDone::
       (# 
       do ''->putinfo;
          NONE->mouse.busyCursor;
       #);
     groupsInfoTableType::
       (# onScan::
            (# t: @Text;
            do 'Scanning ObjectDescriptors in %s'->t.putFormat
               (# do groupName[]->s #);
               t[]->putinfo;
            #);
          onScanDone::
            (# 
            do ''->putinfo;
            #);
       #);
     utilitiesFailure::
       (# 
       do (errormsg[],'ERROR!!')->alertinfo; true->continue;
       #);
     unknownImpFailure::
       (# 
       do ('Failed to set breakpoint','WARNING!!')->alertinfo; true->continue;
       #);
     otherError::
       (#
       do (msg[],'WARNING!!')->alertinfo;
          true->continue;
       #);
     commError::
       (#
       do 'Communication error on request type ' -> msg.putText;
          commCode -> msg.putInt;
          (msg[],'WARNING!!')->alertinfo;
          true->continue;
       #);
     stepfailure::
       (#
       do ('Failed to step into (or step over) due to missing debug information','WARNING!!')->alertinfo;
          true->continue;
       #);
     breakfailure::
       (#
       do (if set then
              ('Failed to set breakpoint','WARNING!!')->alertinfo
           else
              ('Failed to unset breakpoint','WARNING!!')->alertinfo
          if);
          true->continue;
       #);
     beforeContinue::
       (# 
       do processComm.DOT.scan
          (# 
          do lookup:
               (# 
               do remoteObjects.scanObjects
                  (# 
                  do (if current.bo.dotinx=dotinx then
                         (* Delete the object from DOT (delete) and
                          * from the remoteObjectDB (deleteObject)
                          * unless it has been touched since the
                          * last time wait returned or has more than
                          * one owner. *)
                         
                         (current.bo.timestamp<>rd.now) 
                         and (current.refCount=1)->delete->deleteObject;
                         leave lookup;
                     if);
                  #);
                  remoteObjects.scanPatterns
                  (# 
                  do (if current.bp.dotinx=dotinx then
                         (* Same comment as above *)
                         (current.bp.timestamp<>rd.now)
                         and (current.refCount=1)->delete->deletePattern;
                         leave lookup
                     if);
                  #);
                  'Unexpected: DOT element not found in remoteObjectDB'
                    -> otherError
               #);
          #);
          TRUE->running;
       #);
        
     afterWait::
       (#
       do FALSE->running;
          TRUE->notifyUserOnStop;
          (if terminated then
              onTerminate;
           else
              rd.incTime;
              
              (* Check whether the user should be notified, or the process just
               * stopped due to a skipbreak. *)
              
              (if bml.skipBreakHit or bml.traceBreakHit then
                  (* Only notify user if a userBreak was hit at the same time
                   * or some runtime error occurred. *)
                  (if bml.userBreakHit=MNGR_NONUMBER then
                      FALSE->notifyUserOnStop;
                      leave afterWait;
                  if);
              if);
              
              (* Find objects and pattern that have become garbage, 
               * and notify the owners: *)
          
              remoteObjects.scanObjects
              (# adr: @Integer; curObj: ^remoteObjects.betaObjectType;
              do current.bo.dotinx->processComm.DOT.inxToAddress->adr;
                 (if adr=0 then
                     (* This object has become garbage. Notify the owners
                      * and delete them from the objects table. *)
                     current.bo[]->curObj[];
                     current.scanOwners
                     (# 
                     do curObj[]->current.onObjectIsGarbage;
                        TRUE->delete;
                     #);
                 if);
              #);
              
              remoteObjects.scanPatterns
              (# adr: @Integer; curPat: ^remoteObjects.betaPatternType;
              do current.bp.dotinx->processComm.DOT.inxToAddress->adr;
                 (if adr=0 then
                     (* This pattern has become garbage. Notify the owners
                      * and delete them from the objects table. *)
                     current.bp[]->curPat[];
                     current.scanOwners
                     (# 
                     do curPat[]->current.onPatternIsGarbage;
                        TRUE->delete;
                     #);
                 if);
              #);
              
              main.moveables.scan (# do current.doUpdate #);
              
          if);
       #);
     
     mypretty: @rd.prettyPrinter; myprettyinitialized: @Boolean;
     doPrettyPrint::
       (# 
       do (if not myprettyinitialized then mypretty.init if);
          (a[],level)->mypretty->pp[];
       #);
  #)
