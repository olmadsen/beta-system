ORIGIN '~beta/basiclib/basicsystemenv';
INCLUDE '~beta/guienv/stddialogs'
        '~beta/guienv/utils/pane'
        '~beta/guienv/utils/simplemenu'
        '~beta/toollibs/utils/options'
        '~beta/toollibs/utils/optionlist'
        '~beta/objectbrowser/UI/objectview'
        '~beta/toollibs/UI/moveable'
        '~beta/sourcebrowser/codemoveable'
        '~beta/toollibs/UI/icons'
        '~beta/toollibs/UI/iconlist'
        '~beta/guienv/utils/labelled'
        '~beta/sourcebrowser/ymerInterface'
        'seticon'
        '../valhallaoptionlist'
        '../valhallaiconlist'
        '../processInterface'
        '~beta/sysutils/envstring'
        '~beta/compiler/DYN/UI/evaluator';
(*
 * COPYRIGHT
 *   Copyright (C) Aarhus University
 *   All rights reserved.
 *)
-- lib: Attributes --
(* valhallaApplication:valhallaGUI(# do inner #); *)
valhallaGUI:
  (#
     <<SLOT valhallaGUIlib:Attributes>>;
     gui: ^guienv;
     mps: ^ymermps;
     IsStandAloneValhalla: @boolean;
     IsDebugging: @boolean;
     sources: ^ymerBrowserInterface;
     (* FGC, @ *)
     newCodeView:<
       (# cast: ^astInterface.ast
       enter cast[]
       do INNER
       #);
     (* mpsType:: 
      (#
      onOpenGroup:: 
      (# t: @Text; 
      do
      (if main.opened then
      'Opening %s'
      ->t.putFormat
      (# 
      do groupName[]->s
      #);
      t[]->putinfo;
      
      if);
      
      #);
      onOpenGroupDone:: 
      (# 
      do
      (if main.opened then
      ''->putinfo;
      (if not fg.isRealOpen then
      fg.realOpen
      if);
      
      if);
      
      #);
      onOldGroup:: 
      (# t: @Text; 
      do
      (if main.opened and isDebugging
      then
      '"%s%s" is older than "%s.%s"'
      ->t.putFormat
      (# 
      do
      groupName[]->s;
      MPS.AST.astFileExtension->s;
      groupName[]->s;
      'bet'->s;
      
      #);
      (t[],'Debug Info Error: Recompilation required')->alertInfo;
      false->allowParsing;
      true->continue;
      true->doneInInner;
      
      else
      true->allowParsing
      if);
      
      #);
      onNewGroup:: 
      (# t: @Text; 
      do
      (if main.opened and isdebugging then
      '"%s%s" is newer than executable'
      ->t.putFormat
      (# 
      do groupName[]->s; MPS.AST.astFileExtension->s; 
      #);
      (t[],'Debug Info Error: Recompilation required')->alertInfo;
      true->continue;
      
      if);
      
      #);
      onUncheckedGroup:: 
      (# t: @Text; 
      do
      (if main.opened and isdebugging then
      '"%s%s" has not been checked by compiler'
      ->t.putFormat
      (# 
      do groupName[]->s; MPS.AST.astFileExtension->s; 
      #);
      (t[],'Debug Info Error: Recompilation required')->alertInfo;
      false->allowChecking;
      true->continue;
      
      if);
      
      #);
      modtimeOk:: 
      (# 
      do
      (if main.opened then
      (if debuggee[] <> none then
      (modtime < debuggee.executable.modtime)->value
      else
      true->value
      if)
      if);
      
      #);
      
      #); *)
     initialMAINsize: @point;
     editMode:< BooleanValue (#  do true->value; INNER #);
     (*FGC, readOnlyMode; *)
     (* ymerBrowserWindow::<  (# <<SLOT debuggerBrowserLib:Attributes>> #); *)
     debuggeeInterface:< processInterface;
     debuggee: ^debuggeeInterface;
     valhallaIconDB: gui.iconDB
       (#
          movIcon,stackIcon,codeIcon,stackBIcon: ^gui.pixmap;
          getIcon:: 
            (# 
            do
               (if TRUE
                // ObjectViewIcon->name.equalNCS then
                   (if movIcon[] = none then
                       &gui.pixmap[]->movIcon[];
                       'ObjectViewIcon'->movIcon.read;
                       
                   if);
                   movIcon[]->theIcon[];
                   
                // StackViewIcon->name.equalNCS then
                   (if stackIcon[] = none then
                       &gui.pixmap[]->stackIcon[];
                       'StackViewIcon'->stackIcon.read;
                       
                   if);
                   stackIcon[]->theIcon[];
                   
                // CodeViewIcon->name.equalNCS then
                   (if codeIcon[] = none then
                       &gui.pixmap[]->codeIcon[];
                       'CodeViewIcon'->codeIcon.read;
                       
                   if);
                   codeIcon[]->theIcon[];
                   
                // StackBrowserIcon->name.equalNCS then
                   (if stackBIcon[] = none then
                       &gui.pixmap[]->stackBIcon[];
                       'StackBrowserIcon'->stackBIcon.read;
                       
                   if);
                   stackBIcon[]->theIcon[];
                   
               if);
               
            #);
          
       #);
     icons: ^valhallaIconDB;
     globalOptions: @optionDB;
     getOption: globalOptions.getBooleanOption
       (# optvalue: @Boolean; found::  (#  do value->optvalue #); 
       exit optvalue
       #);
     setOption: globalOptions.setBooleanOption (#  #);
     putinfo:
       (# t: ^Text; 
       enter t[]
       do
          t[]->main.status.info.vinfo.contents.label;
          true->main.status.info.vinfo.contents.update;
          
       #);
     putpinfo:
       (# t: ^Text; 
       enter t[]
       do
          t[]->main.status.info.pinfo.contents.label;
          true->main.status.info.pinfo.contents.update;
          
       #);
     alertInfo:
       (# t: ^Text; title: ^Text; 
       enter (t[],title[])
       do (main[],t[],title[])->gui.alertUser; 
       #);
     onMoveablesInsert:<
       (# theMoveable: ^main.moveable; 
       enter theMoveable[]
       do INNER ; 
       #);
     onMoveablesDelete:<
       (# theMoveable: ^main.moveable; 
       enter theMoveable[]
       do INNER ; 
       #);
     onTerminate:< Object;
     newDebuggee:< Object;
     debuggeeStatus:< BooleanValue;
     debuggeeRerun:< Object;
     rerunStatus:< BooleanValue;
     killDebuggee:< Object;
     killStatus:< BooleanValue;
     StopDebugging:< Object;
     source:< Object;
     sourceStatus:< BooleanValue;
     quit:< (#  do INNER ; gui.Terminate #);
     debuggeeContinue:< Object;
     continueStatus:< BooleanValue;
     debuggeeGoUntilMark:< Object;
     GoUntilMarkStatus:< BooleanValue;
     debuggeeStepOver:< Object;
     stepOverStatus:< BooleanValue;
     debuggeeStepInto:< Object;
     stepIntoStatus:< BooleanValue;
     debuggeeFinish:< Object;
     FinishStatus:< BooleanValue;
     debuggeeStop:< Object;
     stopStatus:< BooleanValue;
     debuggeeActiveStack:< Object;
     activeStackStatus:< BooleanValue;
     debuggeeStackBrowser:< Object;
     stackBrowserStatus:< BooleanValue;
     debuggeeCurObj:< Object;
     curObjStatus:< BooleanValue;
     debuggeeCurCode:< Object;
     curCodeStatus:< BooleanValue;
     debuggeeCurComp:< Object;
     curCompStatus:< BooleanValue;
     editenv:< Object;
     editenvStatus:< BooleanValue;
     editcmdline:< Object;
     editcmdlineStatus:< BooleanValue;
     main: ^ValhallaMainWindow;
     ValhallaMainWindow:< gui.window
       (#
          thiswindow: ^gui.window;
          <<SLOT valhallaMainLib:Attributes>>;
          myCodemoveable: codemoveable
            (#
               contentsType::< 
                 (#
                    editorType::< 
                      (#
                         selectNode::< 
                           (# t: ^text
                           do
                              (if true
                               //
                               (theEditorRoot
                                .frag.root[]->theEditorRoot.equal)
                               and
                               separate then
                                  node[]->newCodeView
                               //
                               (theEditorRoot.frag.root[]->theEditorRoot.equal)
                               and
                               not
                               separate then
                                  node[]->newCodeView
                               //
                               (not
                                (theEditorRoot.frag.root[]
                                   ->theEditorRoot.equal))
                               and
                               separate then
                                  node[]->newCodeView
                               else
                                  'myview.contents.editor.selectnode: theEditorRoot[]<> theEditorRoot.frag.root[] and not separate'
                                    ->putLine
                              if)
                           #)
                      #)
                 #);
               moveableMenu::< 
                 (#
                    DetailMenuAction: actionedMenuItemAction
                      (# 
                      do contents.editor.sifviewer.doDetailRecursively; 
                      #);
                    ShowCodeInSifMenuAction: actionedMenuItemAction
                      (# 
                      do contents.editor.editorroot[]->sources.findAndSelect; 
                      #);
                    open::< 
                      (# mi: ^actionedMenuItem; 
                      do
                         &actionedMenuItem[]->mi[];
                         (DetailMenuAction##,none ,none ,'Detail')->mi.open;
                         &actionedMenuItem[]->mi[];
                         (ShowCodeInSifMenuAction##,none ,none ,
                          'Open in SourceBrowser')->mi.open;
                         INNER ;
                         
                      #);
                    
                 #);
               
            #);
          eventHandler::<  (# onAboutToClose::<  (#  do false->OKtoClose; stopDebugging; (*quit;*)  #);  #);
          closeMoveables:
            (# sml: ^selectedMoveablesList; 
            do
               getSelectedMoveablesList->sml[];
               (if sml[] <> none then
                   sml.scan (#  do current.close #); sml.clear; 
               if);
               
            #);
          closeMoveablesStatus: BooleanValue
            (# sml: ^selectedMoveablesList; 
            do
               getSelectedMoveablesList->sml[];
               (if sml[] <> none then
                   sml.size > 0->value; 
                else
                   FALSE->value
               if);
               
            #);
          refresh:
            (# 
            do moveables.scan (#  do current.doUpdate #); objworld.update
            #);
          doHide:
            (#  do true->hided; onHide; THIS(ValhallaMainWindow).hide; sources.updateToolbar #);
          moveables: @moveableList
            (#
               onInsert:: 
                 (# 
                 do
                    theMoveable[]->onMoveablesInsert;
                    theMoveable[]->mainMenubar.windowMenu.appendMoveable;
                    
                 #);
               onDelete:: 
                 (# 
                 do
                    theMoveable[]->onMoveablesDelete;
                    theMoveable[]->mainMenuBar.windowMenu.deleteMoveable;
                    
                 #);
               
            #);
          mainMenuBar: ^menuBarType;
          menuBarType::< 
            (#
               fileMenu: @fileMenuType;
               fileMenuType:< simplemenu
                 (#
                    iopen: @item
                      (# onSelect::  (#  do newDebuggee #) #);
                    isource: @item
                      (#
                         onSelect::  (#  do source #);
                         onStatus::  (#  do sourceStatus->enabled #)
                      #);
                    iquit: @item
                      (#
                         onSelect:: 
                           (# 
                           do
                              (if isStandAloneValhalla then
                                  quit
                               else
                                  doHide
                              if);
                              
                           #)
                      #);
                    open::< 
                      (# 
                      do
                         INNER ;
                         (if isStandAloneValhalla then
                             ('Open...','o')->iOpen.newkey; 
                         if);
                         ('Source Browser...')->isource.new;
                         (if isStandAloneValhalla then
                             ('Quit','q')->iquit.newkey; 
                          else
                             ('Close','q')->iquit.newkey; 
                         if)
                      #)
                 #);
               editMenu: @editMenuType;
               editMenuType:< simplemenu
                 (#
                    ienv: @item
                      (#
                         onSelect::  (#  do editenv #);
                         onStatus::  (#  do editenvStatus->enabled #);
                         
                      #);
                    icmdline: @item
                      (#
                         onSelect::  (#  do editcmdline #);
                         onStatus::  (#  do editcmdlineStatus->enabled #)
                      #);
                    irefresh: @item (# onSelect::  (#  do refresh #) #);
                    iclose: @item
                      (#
                         onSelect::  (#  do closeMoveables #);
                         onStatus:: 
                           (#  do closeMoveablesStatus->enabled #);
                         
                      #);
                    open::< 
                      (# 
                      do
                         'Command Line...'->icmdline.new;
                         'Environment...'->ienv.new;
                         ('Refresh')->irefresh.new;
                         ('Close','w')->iclose.newkey;
                         INNER ;
                         
                      #);
                    
                 #);
               windowMenu: @windowMenuType;
               windowMenuType:< simplemenu
                 (#
                    icurobj: @item
                      (#
                         onSelect::  (#  do debuggeeCurObj #);
                         onStatus::  (#  do curObjStatus->enabled->value #);
                         
                      #);
                    icurcode: @item
                      (#
                         onSelect::  (#  do debuggeeCurCode #);
                         onStatus:: 
                           (#  do curCodeStatus->enabled->value #);
                         
                      #);
                    icurcomp: @item
                      (#
                         onSelect::  (#  do debuggeeCurComp #);
                         onStatus:: 
                           (#  do curCompStatus->enabled->value #);
                         
                      #);
                    iactivestack: @item
                      (#
                         onSelect::  (#  do debuggeeActiveStack #);
                         onStatus:: 
                           (#  do activeStackStatus->enabled->value #)
                      #);
                    istackbrowser: @item
                      (#
                         onSelect::  (#  do debuggeeStackBrowser #);
                         onStatus:: 
                           (#  do stackBrowserStatus->enabled->value #)
                      #);
                    iprintdot:@item
                      (# onselect::(# do  debuggee.processcomm.dot.printOut #)
                      #);
                    open::< 
                      (# 
                      do
                         ('Current Code')->icurcode.new;
                         ('Current Object')->icurobj.new;
                         false->icurobj.enabled;
                         ('Current Component')->icurcomp.new;
                         ('Active Stack')->iactivestack.new;
                         ('Stack Browser')->istackbrowser.new;
                         (* ('print dot')->iprintdot.new; *)
                      #);
                    appendMoveable:
                      (# theMoveable: ^moveable; 
                      enter theMoveable[]
                      do 
                      #);
                    deleteMoveable:
                      (# theMoveable: ^moveable;  enter theMoveable[] #);
                    
                 #);
               oldoptionsMenu: @optionsMenuType;
               optionsMenuType:< simplemenu
                 (#
                    optionitem: toggleitem
                      (#
                         option: ^Text;
                         defaultvalue: @Boolean;
                         newopt: new
                           (# 
                           enter (option[],defaultvalue)
                           do
                              option[]
                                ->getOption
                                  (#
                                     notfound:: 
                                       (# 
                                       do
                                          (option[],defaultvalue->optvalue)
                                            ->setOption;
                                          
                                       #)
                                  #)->checked;
                              
                           #);
                         onSelect:: 
                           (#  do (option[],checked)->setOption #);
                         onStatus:: 
                           (# 
                           do
                              option[]
                                ->getOption
                                  (#
                                     notfound:: 
                                       (#  do defaultvalue->optvalue #)
                                  #)->checked;
                              
                           #);
                         
                      #);
                    open::< 
                      (# 
                      do
                         scanoptions
                           (# 
                           do
                           (* inserted by void Wed Jul 23 13:22:19 MET DST 1997 *)
                              (if (dragOutlineOnOpen->current.equalNCS) = true
                               then
                                  FALSE->default; 
                              if);
                              (description[],current[],default)
                                ->(&optionitem[]).newopt;
                              
                           #);
                         scanvalhallaoptions
                           (# 
                           do
                              (description[],current[],default)
                                ->(&optionitem[]).newopt;
                              
                           #);
                         INNER ;
                         
                      #);
                    
                 #);
               open::< 
                 (# 
                 do
                    'File'->fileMenu.new;
                    fileMenu[]->append;
                    'Edit'->editMenu.new;
                    editMenu[]->append;
                    INNER ;
                    'Windows'->windowMenu.new;
                    windowMenu[]
                      ->append
                      (*  'Preferences'->optionsMenu.new;
                       optionsMenu[]->append *)
                 #)
            #);
          maxButtonText: @Text;
          opened: @boolean;
          hided: @boolean;
          onHide:< Object;
          onShow:< Object;
          AfterDebuggeeOpened:< Object;
          open::< 
            (# 
            do
               moveables[]
                 ->objectPool.put
                   (# alreadythere::  (#  do true->continue #);  #);
               'Step Over'->maxButtonText;
                 (#
                    tst: @pushButton
                      (#
                         width: @integer;
                         open:: 
                           (# ts: ^gui.textStyle; buttonWidth: @integer
                           do
                              hide;
                              maxButtonText[]->label;
                              style->ts[];
                              maxButtonText[]->ts.widthOfText->width
                           #)
                      #);
                    
                 do
                    (610,400)->initialMAINsize;
                    tst.open;
                    tst.close;
                    (10*(tst.width+9)+20+3,400)->initialMAINsize;
                    
                 #);
               setValhallaIcon;
               initialMAINsize->size;
               'Valhalla: Mjolner Source-level Debugger'->title;
               contents->status.open;
               contents->objworld.open;
               INNER ;
               true->opened;
               (if not isStandAloneValhalla then hide if);
               
            #);
          close::< 
            (# 
            do false->opened; objworld.close; status.close; INNER close
            #);
          objworld: @Canvas
            (#
               open:: 
                 (# sz: @Point; tmp: @Point; 
                 do
                    initialMAINsize->sz;
                    true->border.visible;
                    gui.borderStyles.etchedIn->border.style;
                    status.size->tmp;
                    sz.v-tmp.v->sz.v;
                    sz->size;
                    TRUE->bindLeft->bindRight->bindBottom->bindTop;
                    installSelectHandlers;
                    
                 #);
               
            #);
          status: @Canvas
            (#
               setenabling:
                 (# 
                 do
                    ccodeButton.setenabling;
                    cobjButton.setenabling;
                    cstackButton.setenabling;
                    goButton.setenabling;
                    (* goUntilMButton.setenabling; *)
                    stepButton.setenabling;
                    overButton.setenabling;
                    finishButton.setenabling;
                    stopButton.setenabling;
                    rerunButton.setenabling;
                    
                 #);
               info: @pane
                 (#
                    infoText: labelled
                      (#
                         contentsType::< staticText
                           (# open::<  (#  do ''->label; INNER ;  #); 
                           #);
                         open::< 
                           (# sz: @Point; 
                           do
                              initialMAINsize->sz;
                              2*labelHeight+3->sz.v;
                              (sz.h-9) div 2->sz.h;
                              sz->size;
                              INNER ;
                              
                           #);
                         
                      #);
                    pinfo: @infoText
                      (#
                         contentsType:: 
                           (# open::  (#  do 'No Process'->label #); 
                           #);
                         open::  (#  do 'Process Info'->label #);
                         
                      #);
                    vinfo: @infoText
                      (# open::  (#  do 'Valhalla Info'->label #);  #);
                    open:: 
                      (# 
                      do
                         FALSE->verticalStacking;
                         3->panewidth;
                         10->minsize;
                         pinfo.open;
                         vinfo.open;
                         pinfo[]->appendMember;
                         vinfo[]->appendMember;
                         appendsDone;
                         (3,3)->position;
                         
                      #);
                    close::  (#  do pinfo.close; vinfo.close;  #);
                    dobind:
                      (# 
                      do
                         TRUE->bindRight->bindLeft->bindTop; FALSE->bindBottom; 
                      #);
                    
                 #);
               shortcutButton: pushButton
                 (#
                    onSelect: ##Object;
                    enabled: ##BooleanValue;
                    setenabling:
                      (# 
                      do (if enabled then enable else disable if); 
                      #);
                    open:: 
                      (#
                         prev: ^shortcutButton;
                         fr,pfr: @rectangle;
                         sz: @Point;
                         h,v: @Integer;
                         name: ^Text;
                         ts: ^gui.textStyle;
                         prevOffset:< IntegerValue;
                         
                      enter (prev[],name[],onSelect##,enabled##)
                      do
                         father.size->sz;
                         sz.v-3->fr.bottom;
                         (if prev[] = none then
                             3->fr.left; 
                          else
                             prev.frame->pfr; pfr.right+3+prevOffset->fr.left; 
                         if);
                         style->ts[];
                         fr.left+(maxButtonText[]->ts.widthOfText)+6->fr.right;
                         fr.bottom-ts.lineHeight-6->fr.top;
                         fr->frame;
                         name[]->label;
                         TRUE->bindLeft->bindBottom;
                         FALSE->bindRight->bindTop;
                         INNER ;
                         
                      #);
                    eventHandler::< 
                      (#
                         onMouseUp:: 
                           (# 
                           do
                              (if enabled then
                                  THIS(shortcutButton).onSelect
                              if);
                              
                           #);
                         
                      #);
                    
                 #);
               ccodeButton,cobjButton,cstackButton: @shortcutButton;
               goButton,goUntilMButton,stepButton,overButton,finishButton,
                 stopButton,rerunButton: @shortcutButton;
               open:: 
                 (# pos,sz: @Point; 
                 do
                    TRUE->bindRight->bindLeft->bindBottom;
                    FALSE->bindTop;
                    TRUE->border.visible;
                    gui.borderstyles.etchedIn->border.style;
                    info.open;
                    (none ,none ,'Code',debuggeeCurCode##,curcodeStatus##)
                      ->ccodeButton.open;
                    (none ,ccodeButton[],'Object',debuggeeCurObj##,
                     curObjStatus##)->cobjButton.open;
                    (none ,cobjButton[],'Stack',debuggeeActiveStack##,
                     ActiveStackStatus##)->cstackButton.open;
                    (none ,cstackButton[],'Go',debuggeeContinue##,
                     continueStatus##)
                      ->goButton.open
                        (# prevOffset::  (#  do 20->value #) #);
                    (none ,goButton[],'Step',debuggeeStepInto##,
                     StepIntoStatus##)->stepButton.open;
                    (none ,stepButton[],'Step Over',debuggeeStepOver##,
                     stepOverStatus##)->overButton.open;
                    (none ,overButton[],'Step Out',debuggeeFinish##,
                     finishStatus##)->finishButton.open;
                    (none ,finishButton[],'Stop',debuggeeStop##,stopStatus##)
                      ->stopButton.open;
                    (none ,stopButton[],'Rerun',debuggeeRerun##,rerunStatus##)
                      ->rerunButton.open;
                    ccodeButton.size->sz.add;
                    info.size->sz.add;
                    (0,9)->sz.add;
                    sz->size;
                    initialMAINsize->pos;
                    size->pos.subtract;
                    0->pos.h;
                    pos->position;
                    info.dobind;
                    setenabling;
                    
                 #);
               close::  (#  do info.close;  #);
               
            #);
          
       #);
     init:<
       (# 
       do (*FGC, globalOptions.init; *)
       (*FGC, globalOptions[]->objectPool.put; *)
          (if gui[] = none then 'guinone'->screen.putline;  if);
          &valhallaMainWindow[]->main[];
          &valhallaIconDB[]->icons[];
          icons[]->objectPool.put;
          (*FGC, main.open; *)
          INNER ;
          (*FGC main.theMenuBar->main.mainMenuBar[]; *)
          (*FGC, sources.open; *)
          (*FGC, 
           (if sources[]<>none then
           &ymerCall
           (#
           getFragmentGroup:: 
           (# 
           do name[]->mps.fragmentGroupTable.getFragmentGroup->fg[]
           #);
           machineType::  (#  do machine_type->t[] #);
           
           #)[]->sources.edenv.ymerCallback[];
           sources.loadSettings;
           if);
           *)
          
       #);
     resetDebugger:< Object
  do INNER ; 
  #);
  

