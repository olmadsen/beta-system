ORIGIN '~beta/objectbrowser/v2.1/mpsinterface';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

INCLUDE '~beta/objectbrowser/v2.1/groupsinfo';

INCLUDE '~beta/sysutils/v1.5/pathhandler';

INCLUDE 'valhallaparams';
INCLUDE 'environment';

BODY 'private/processinterfacebody';
BODY 'private/processcommbody';
BODY 'private/executablebody';
BODY 'private/utilitiesbody';
BODY 'private/dbmanagerbody';

--- lib:attributes ---

(* LOAD LEVELS
 * =========== 
 * 
 * Load levels of ObjectFileInfos *)

LL_INITIAL:  (# exit 0 #);
(* GroupName+codeStart+codeEnd+dataStart+dataEnd *)

LL_FULL:     (# exit 1 #);
(* LL_INITIAL+protoCount+Tentries+Mentries+Gentries+astRefs+fragments *)

LL_NODBINFO: (# exit 2 #);
(* Like LL_FULL, but no dopart info due to missing ..db file. *)

printLoadLevel:
  (# level: @Integer; s:^stream;
  enter (level,s[])
  do (if level
      //LL_INITIAL then
         'LL_INITIAL'->s.putText;
      //LL_FULL then
         'LL_FULL'->s.putText;
      //LL_NODBINFO then
         'LL_NODBINFO'->s.putText;
     if);
  #);

(* STATUS OF DBFILES
 * =================
 * 
 * These values are given as the status parameter to DBstatus virtuals. *)

DBFILE_OK:       (# exit 0 #); 
DBFILE_NOTFOUND: (# exit 1 #); (* The ..db file does not exist. *)
DBFILE_NEWER:    (# exit 2 #); (* The ..db file exists, but is newer than the
                                * executable. *)

printDBstatus:
  (# status: @Integer; s: ^stream;
  enter (status,s[])
  do (if status
      //DBFILE_OK then
         'DBFILE_OK'->s.putText;
      //DBFILE_NOTFOUND then
         'DBFILE_NOTFOUND'->s.putText;
      //DBFILE_NEWER then
         'DBFILE_NEWER'->s.putText;
     if)
  #);

actionList: List 
  (# element:: (# action: ##Object #);
     newAction: 
       (# new: ^element;
          action: ##Object;
       enter action##
       do &element[]->new[];
          action##->new.action##;
          INNER;
       #);
     appendAction: newAction (# do new[]->append #);
     prependAction: newAction (# do new[]->prepend #);
     execute: scan (# do current.action #);
     deleteAction:
       (# action: ##Object;
       enter action##
       do find: iterate
            (# 
            do (if current.elm.action##=action## then
                   current[]->delete;
                   leave find
               if);
            #);
       #);
  #);

processInterface:
  (#      
     <<SLOT processInterfaceLib:attributes>>;
     
     mps: ^mpsInterface;
     
     (* Shortcuts: *)
     
     terminated: processComm.status.terminated (# #);
     curObj: processComm.status.curObj (# #);
     curComp: processComm.status.curComp (# #);
     PC: processComm.status.PC (# #);
     SP: processComm.status.SP (# #);
     signal: processComm.status.signal (# #);
     error: processComm.status.error (# #);
       
     waitcount: @Integer; 
     (* Number of times the process has been stopped. Incremented each
      * time processComm.wait returns. *)
     
     beforeContinueActions: @actionList;
     (* actions in beforeContinue are executed before allowing the remote
      * process to continue after a stop.*)
     beforeContinue:<
       (# 
       do INNER; beforeContinueActions.execute;
       #);
     
     afterWaitActions: @actionList;
     (* actions in afterWait are executed immediately before wait returns. *)
     afterWait:<
       (# 
       do afterWaitActions.execute; INNER;
       #);
     
     steppingActions: @actionList;
     (* actions to be executed if a CBFA callback, a SUSPEND or an ATTACH
      * caused the process to stop. If this list is empty, these situations
      * will not cause the debugged process to stop. In situations where the
      * actions registered in steppingActions are executed, PC will return
      * the BETA code address where control is about to be transferred. *)
     
     
     (* INIT
      * ====
      * 
      * Initializes this(processInterface). Information about the process to
      * start is found in the global databases defined in environment.bet and
      * valhallaparams.bet.
      * 
      * doingExpensiveRead is called if dbManager is about to scan through
      * all ..db files to get fragment information.
      * 
      * doingCheapRead is called if dbManager is about to read fragment 
      * information from cached file.
      * 
      * createFragInfo is called to query whether fragment info should be
      * cached for faster startup the next time.
      * 
      * creationFailed is called if it was not possible to create the cache
      * file.
      * 
      * execNotFound is raised if the executable could not be found. It is 
      * ok to leave init on this occation.
      * 
      * forkFailed is raised if it was not possible to fork the process. 
      * It is ok to leave init on this occation.
      * mdInitFailed is raised if machine specifik initialization failed.
      * connectionTimedOut is raised if the process did not connect after
      * 10 seconds. Return TRUE to retry, and FALSE to give up. In the latter
      * case, forkFailed is subsequently raised.
      * 
      * Calls INNER when all other initialization has finished. *)
     
     init:<
       (# doingExpensiveRead:< Notification
            (# dbName: ^Text;
            enter dbName[]
            do INNER
            #);
          doingCheapRead:< Notification
            (# dbName: ^Text;
            enter dbName[]
            do INNER
            #);
          createFragInfo:< BooleanObject;
          creationFailed:< Exception
            (# dbName: ^Text;
            enter dbName[]
            do INNER
            #);
          execNotFound:< executableException;
          forkFailed:< Exception;
          wrongBetarunVersion:< Notification;
          connectionTimedOut:< BooleanValue;
       enter mps[]
       <<SLOT processInterfaceInit:dopart>>
       #);
     
     rerun:<
       (# execNotFound:< executableException;
          forkFailed:< Exception;
          modtimeChanged:< executableException;
          notTerminated:< Exception;
       <<SLOT processInterfaceRerun:dopart>>
       #);
     
     
     (* KILL
      * ====
      * 
      * Should be called to kill the process being debugged. Works only
      * when process is currently stopped but not terminated. *)
     
     kill: 
       (# 
       <<SLOT processInterfaceKill:dopart>>
       #);
     
     
     (* processPathHandler
      * ==================
      * 
      * Used to convert objectFileInfo.groupNames into full path names. *)
     
     processPathHandler: @pathhandler;
     
     
     (* PROCESSCOMM
      * ===========
      * 
      * The process communicator communicates with the debugged process to get
      * information about the state of the process. It implements low-level 
      * details such as how the communication with the process is actually
      * handled.
      * 
      * processData and processCode can be used to read and write the
      * memory of the process. 
      * 
      * DOT describes itself.
      * 
      * init initializes this processCommunicator. Information is found in
      * the global databases defined in "environment.bet" and 
      * valhallaparams.bet.
      * 
      * scanGroups scans through the objectfiles that are statically linked 
      * into the executable. FormatError is raised if the answer from the
      * debugged process does not have the right format.
      * 
      * loadProtoTable loads the prototype table of the ObjectFileInfo entered
      * as parameter by filling out protoCount, Tentries, Mentries, Gentries
      * and astReafs of the ObjectFileInfo. loadProtoTable should only be 
      * called by BasicObjectFileInfo.ensureMaxLoadLevel.*)

     processComm: @
       (# 
          <<SLOT processCommLib:attributes>>;
          
          init:
            (# forkFailed:< Exception;
               mdInitFailed:< Exception;
               wrongBetarunVersion:< Notification;
               connectionTimedOut:< BooleanValue;
            <<SLOT processCommInit:dopart>>
            #);
          
          kill: (# <<SLOT processCommKill:dopart>> #);
          
          scanGroups:
            (# formatError:< Exception;
               dataStart, dataEnd, codeStart, codeEnd: @Integer;
               groupNameHash,checkTime: @Integer;
               groupName: ^Text;
            do <<SLOT processCommScanGroups:descriptor>>
            #);
     
          loadProtoTable:
            (# accessFailure:< exception;
               ofi: ^ObjectFileInfo;
            enter ofi[]
            <<SLOT processCommLoadProtoTable:dopart>>
            #);
          
          MachineType: @
            (# name: ^Text;
            <<SLOT processCommMachineType:dopart>>
            exit name[]
            #);
          
          (* STATUS
           * ======
           * 
           * May be used to query the state of the process if it is
           * stopped. *)
          
          status: @
            (# statusValue: IntegerValue 
                 (# running:< Exception;
                 <<SLOT StatusValue:dopart>>
                 #);
               curObj: StatusValue (# <<SLOT StatusCurObj:dopart>> #);
               curComp: StatusValue (# <<SLOT StatusCurComp:dopart>> #);
               PC: StatusValue (# <<SLOT StatusPC:dopart>> #);
               SP: StatusValue (# <<SLOT StatusSP:dopart>> #);
               signal: StatusValue
                 (# sigtext: ^Text;
                 <<SLOT StatusSignal:dopart>>
                 exit sigtext[]
                 #);
               error: StatusValue
                 (# errorText: ^Text;
                 <<SLOT StatusError:dopart>>
                 exit errorText[]
                 #);
               statusBooleanValue: BooleanValue
                 (# running:< Exception;
                 <<SLOT statusBooleanValue:dopart>>
                 #);
               terminated: statusBooleanValue
                 (# 
                 <<SLOT StatusTerminated:dopart>>
                 #);
               AttachCallback: StatusBooleanValue
                 (* TRUE if last process stop was due to coroutine attach callback. *)
                 (# 
                 <<SLOT StatusAttachCallback:dopart>>
                 #);
               GCcallback: StatusBooleanValue
                 (* TRUE if last process stop was due to a GC callback. *)
                 (# 
                 <<SLOT StatusGCcallback:dopart>>
                 #);
               CBFAcallback: StatusBooleanValue
                 (* TRUE if last process stop was due to a CBFA callback. *)
                 (# 
                 <<SLOT StatusCBFAcallback:dopart>>
                 #);
               statusPrivate: @<<SLOT StatusPrivate:descriptor>>
            #);
          
          (* RTSprocAdr
           * ==========
           * 
           * Returns memory addresses of RTS procedures. The RTproc parameter 
           * must be one of the constants defined in RTSprocedures.bet *)
          
          RTSprocAdr:
            (# RTproc: @Integer;
               procAddr: @Integer;
            enter RTproc
            <<SLOT RTSprocAdr:dopart>>
            exit procAddr
            #);
          
     
          (* MEMORY ACCESS
           * ============= *)
          
          acc: (* Super pattern for memory access operations *)
            (# accessFailure:< Exception;
               address: @Integer 
            enter address 
            do INNER 
            #);
          
          processData: @
            (# peekDouble: acc 
                 (# value: @Real;
                 <<SLOT doProcessDataPeekDouble:dopart>>
                 exit value     
                 #);
               peekLong: acc
                 (# value: @Integer;
                 <<SLOT doProcessDataPeekLong:dopart>>
                 exit value
                 #);
               peekShort: acc 
                 (# value: @ShortInt;
                 <<SLOT doProcessDataPeekShort:dopart>>
                 exit value 
                 #);
               peekByte: acc
                 (# value: @Char;
                 <<SLOT doProcessDataPeekByte:dopart>>
                 exit value    
                 #);
               
               (* peekMemoryLongs and peekMemoryBytes calls INNER to obtain 
                * the address of the first element in a repetition with the 
                * required space. This address should be put into repAdr. *)
               peekMemoryBytes: acc 
                 (# length: @Integer; (* Length in bytes. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessDataPeekMemoryBytes:dopart>>
                 #);
               peekMemoryLongs: acc 
                 (# length: @Integer; (* Length in longs. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessDataPeekMemoryLongs:dopart>>
                 #);
               
               pokeDouble: acc 
                 (# value: @Real enter value 
                 <<SLOT doProcessDataPokeDouble:dopart>>
                 #);
               pokeLong: acc 
                 (# value: @Integer 
                 enter value 
                 <<SLOT doProcessDataPokeLong:dopart>>
                 #);
               pokeShort: acc 
                 (# value: @ShortInt 
                 enter value 
                 <<SLOT doProcessDataPokeShort:dopart>>
                 #);
               pokeByte: acc  
                 (# value: @Char 
                 enter value 
                 <<SLOT doProcessDataPokeByte:dopart>> 
                 #);
            #);
          
          processCode: @
            (# peekDouble: acc 
                 (# value: @Real;
                 <<SLOT doProcessTextPeekDouble:dopart>>
                 exit value     
                 #);
               peekLong: acc
                 (# value: @Integer;
                 <<SLOT doProcessTextPeekLong:dopart>>
                 exit value
                 #);
               peekShort: acc 
                 (# value: @ShortInt;
                 <<SLOT doProcessTextPeekShort:dopart>>
                 exit value 
                 #);
               peekByte: acc
                 (# value: @Char;
                 <<SLOT doProcessTextPeekByte:dopart>>
                 exit value    
                 #);
               (* peekMemoryLongs and peekMemoryBytes calls INNER to obtain 
                * the address of the first element in a repetition with the 
                * required space. This address should be put into repAdr. *)
               peekMemoryBytes: acc 
                 (# length: @Integer; (* Length in bytes. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessTextPeekMemoryBytes:dopart>>
                 #);
               peekMemoryLongs: acc 
                 (# length: @Integer; (* Length in longs. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessTextPeekMemoryLongs:dopart>>
                 #);
               
               setBreakpoint: acc
                 (# oldcode: @Integer;
                 <<SLOT doProcessTextSetBreakpoint:dopart>>
                 exit oldcode
                 #);
               unsetBreakpoint: acc
                 (# oldcode: @Integer;
                 enter oldcode
                 <<SLOT doProcessTextUnsetBreakpoint:dopart>>
                 #);
            #);
          
          
          (* COMMANDS
           * ========
           * 
           * Continue and Stop only initiates the corresponding
           * actions. Wait blocks the calling coroutine until the debugged 
           * process has stopped and is ready for communication.
           * failure is raised if communication with the debugged process
           * failed. *)
          
          UnlessTerminated:
            (# terminated:< Exception;
            do (if not status.terminated then
                   INNER
                else
                   terminated;
               if);
            #);
          
          Continue: UnlessTerminated
            (* Continue the process after a breakpoint or signal. *)
            (# failure:< Exception; 
            do <<SLOT ContinueBody:descriptor>>
            #);
          
          Stop: UnlessTerminated
            (* Stop the process if it is running. *)
            (# failure:< Exception;
            <<SLOT processCommStop:dopart>>
            #);
          
          Wait: UnlessTerminated
            (* Wait for the process to stop. wrongMessage is raised if the 
             * first message received from the process was not VOP_STOPPED. *)
            (# wrongMessage:< Exception;
               failure:< Exception;
            do <<SLOT processCommWait:descriptor>>
            #);
          
          (* DOT (Debugger Object Table)
           * ===========================
           * 
           * Used to keep track of objects through garbage collections.
           * Objects traced by the debugger are inserted into the table.
           * 
           * Insert returns an index to be used to get the current address
           * of the object. objsize is the size of the object in longs.
           * 
           * inxToAddress returns the current address of the object with
           * the DOT index given. If 0 is returned, the object has been 
           * garbage collected, and the index deleted from the table. 
           * 
           * addressToInx returns the DOT index corresponding to objAdr.
           * If objAdr is not found in the table, -1 is returned. 
           *
           * Each time the process stops, all indices should be checked
           * to see whether they have become garbage since the last stop.
           * As soon as insert is called, old indices may get reused!! *)
          
          DOT: @
            (# insert:
                 (# objAdr: @Integer;
                    inx,objsize: @Integer;
                 enter objAdr
                 <<SLOT piDOTinsert:dopart>>
                 exit (inx,objsize)
                 #);
               
               inxToAddress:
                 (# inx: @Integer;
                    objAdr: @Integer;
                 enter inx
                 <<SLOT piDOTinxToAddress:dopart>>
                 exit objAdr
                 #);
               
               addressToInx: 
                 (# objAdr: @Integer;
                    inx: @Integer;
                 enter objAdr
                 <<SLOT piDOTaddressToInx:dopart>>
                 exit inx
                 #);
               
               scan:
                 (# dotinx,adr: @Integer;
                    delete: @Boolean; 
                    (* If set to TRUE, current element should be deleted. *)
                 <<SLOT piDOTscan:dopart>>
                 #);
               
               init: <<SLOT piDOTinit: descriptor>>;
               
               dotPrivate: @<<SLOT piDOTprivate:descriptor>>;
            #);
          
          canonify:
            (* Canonifies the object address entered by ensuring, that if
             * the object referred is really a component, then the address
             * of the component header is returned. Otherwise, the address
             * entered is returned without change. *)
            (# objAdr: @Integer;
            enter objAdr
            <<SLOT processCommCanonify:dopart>>   
            exit objAdr
            #);
          
          scanStack:
            (* Scans the stak of the component whose address is given
             * as parameter. Calls INNER once with returnAdrs and
             * returnObjs filled out. If returnObjs[i]=0, returnAdrs[i] is 
             * a C return address. stacktype is set to the current state of
             * the component stack. See processCommCodes.bet for a list
             * of possible values (CS_* constants).
             * 
             * returnAdrs[i] is expected to be the address where the component
             * is going to continue execution. I.e., if the component is the
             * active component, returnAdrs[i] should equal the value returned
             * from status.PC.
             * 
             * noStack is raised if the component has not yet been attached,
             * and thus has not been assigned a stack object.
             * 
             *)
            (# compAdr: @Integer;   (* Address of a component object. *)
               noStack:< Notification;
               returnObjs: [20]@Integer;
               returnAdrs: [20]@Integer;
               last: @Integer; 
               (* last valid index into returnObjs and returnAdrs. *)
               stacktype: @Integer; (* One of CS_* from processCommCodes.bet *)
               (*private*)tmp: @Integer;
            enter compAdr
            <<SLOT processCommScanStack:dopart>>
            #);
          
          pcPrivate: @<<SLOT processCommPrivate:descriptor>>;
          pcmdPrivate: @<<SLOT processCommMDprivate:descriptor>>;

       #);
     
     (* EXECUTABLE
      * ==========
      * 
      * Implements access to information that can only be found in the
      * executable. Currently this only includes labels, and is needed only 
      * if we fail to locate the information otherwise.
      * 
      * If the option readLabelsOnStartUp is TRUE, init will fork a nm
      * process to read and sort the labels in the execuatable. The
      * result is read from that process when finishInit is called. *)

     executable: @
       (# init:
            (# notFound:< executableException;
            <<SLOT executableInit:dopart>>
            #);
          finishInit:
            (# 
            <<SLOT executableFinishInit:dopart>>
            #);
          
          reinit:
            (# modtimeChanged:< executableException;
               notfound:< executableException;
            <<SLOT executableReInit:dopart>>   
            #);
          
          kill: (# <<SLOT executableKill:dopart>> #);
          
          (* Label handling
           * ============== *)
          
          labelNameToAddress:
            (# name: ^Text;
               address: @Integer;
            enter name[]
            <<SLOT labelNameToAddress:dopart>>
            exit address
            #);
          
          labelAddressToName:
            (# address: @Integer;
               name: ^Text; value: @Integer;
            enter address
            <<SLOT labelAddressToName:dopart>>
            exit (name[],value)
            #);
          
          modTime: @Integer; (* modTime of the executable. *)
          
          execPrivate: @<<SLOT executablePrivate:descriptor>>;
       #);     
     
     (* GROUPSINFO
      * ==========
      * 
      * Table performing the mapping from the prototype number in the
      * to data segment to the corresponding  ObjectDescriptor. *)
     
     groupsInfoTableType:< mps.groupsInfoTable;
     groupsInfo: ^groupsInfoTableType;
     
     
     
     (* REMOTEDUMPER
      * ============
      * 
      * Specialization of objectdumper from ~objectbrowser/objectdumper.
      * Able to initialize itself simply by being executed. This is 
      * done from processInterface.init. *)
     
     rd: @<<SLOT processInterfaceRemoteDumper:descriptor>>;
     
     

     (* OBJECTFILEINFO, BASICOBJECTFILEINFO
      * ===================================
      * 
      * Type of object containing diverse information on BETA object-files
      * linked into the debugged process. *)
     
     ObjectFileInfo:< BasicObjectFileInfo;
     BasicObjectFileInfo:
       (# 
          (* LL_INITIAL INFORMATION
           * ======================
           * 
           * Upper part of BasicObjectFileInfo is initialized when connection 
           * to the debugged process is established. The rest is loaded from 
           * debugged process and ..db file on demand. *)
          
          groupName: ^Text;
          (* Groupname string as saved by compiler in datasegment. *)
          
          groupNameHash: @Integer; (* group_header.hash from object.h *)
          checkTime: @Integer;     (* group_header.modtime from object.h *)
          
          codeStart, codeEnd: @Integer; 
          (* Address of codepart of this objectfile in memory.
           * codeEnd is the address of the first code *after* the
           * code described by this(BETAgroupFile). *)
          
          dataStart, dataEnd: @Integer;
          (* Address of datasegment of this objectfile in memory.
           * dataStart is the address of the length field of the
           * prototype table. dataEnd is the address of the following
           * dataSegment. *)
          
          loadLevel: @Integer; 
          
          ensureMaxLoadLevel: @ (# <<SLOT OFIensureMaxLoadLevel:dopart>> #);
          
          (* LL_ENTRIES INFORMATION
           * ======================
           * 
           * Information below has been loaded if loadLevel is LL_ENTRIES.
           * Corresponding indices in repetitions contain diverse info on the
           * same prototype. *)
          
          protoCount: @Integer;  (* Number of prototypes in objectfile.   *)
          Tentries: [0]@Integer; (* Prototype addresses. Corresponding to *
                                  * prototype table in object file and loaded
                                  * on demand from debugged process. *)
          Mentries: [0]@Integer; (* Loaded from debugged process. *)
          Gentries: [0]@Integer; (* Loaded from debugged process. *)
          
          (* OBSOLETE: astRefs is currently only used for debugging of
           * ~beta/objectbrowser/v2.0/groupsinfo.bet. The result returned
           * from groupsinfotable is compared with the information pulled
           * out of the prototype. See debugGroupsInfo in utilitiesbody.
           * Should be removed when groupsinfo is trusted, and certainly
           * when FormIndex,AstIndex is removed from the prototype format.
           * Notice that this requires a change in the debuggee/valhalla
           * protocol (See VOP_GETPROTOINFO in processCommCodes.bet) *)
          astRefs: [0]@Integer;  (* (FormIndex,AstIndex as contained in the
                                  * prototype. Loaded from debugged process. *)
          
          doparts: [0]^dopartInfo;(* dopartInfo for prototype  is cached *
                                   * here when it first becomes known.   *)
          
          
          (* LL_DBINFO INFORMATION
           * =====================
           * 
           * Information below has been loaded if loadLevel is LL_DBINFO. 
           * Number of fragments equals fragments.range. *)
          
          fragments: [0]^FragmentInfo; 
          scanFragments:
            (# current: ^FragmentInfo; index: @Integer;
            do (for i:fragments.range repeat
                    i->index; fragments[i][]->current[];
                    INNER;
               for);
            #);
          
          findFragmentInfo:
            (* Locates the fragment named fragmentName of type fragmentType
             * in this group. *)
            (# fragmentName: ^Text; fragmentType: @Integer;
               fi: ^fragmentInfo;
            enter (fragmentName[],fragmentType)
            <<SLOT findFragmentInfo:dopart>>
            exit fi[]
            #);
          
          ScanVisibleGroups:
            (* Scans the names of the fragment groups that are visible from
             * this one. *)
            (# current: ^Text; 
            <<SLOT visibleGroups:dopart>> 
            #);
          
          fg: ^mps.AST.fragmentGroup;
          originOfi: ^ObjectFileInfo; (* ObjectFileInfo of origin group. *)
          fgLoadFailed: @Boolean; (* Set to true if load of fg failed. *)
       #);
     
     
     (* SCANOBJECTFILEINFOS
      * =================== 
      * 
      * Scans through all ObjectFileInfos. *)
     
     scanObjectFileInfos:
       (# current: ^ObjectFileInfo;
       do <<SLOT scanObjectFileInfos:descriptor>>
       #);
     
     
     (* CODEADDRESSTOOBJECTFILEINFO
      * ===========================
      * 
      * Locate the ObjectFileInfo containing the code address entered. *)
     
     codeAddressToObjectFileInfo:
       (# adr: @Integer; ofi: ^ObjectFileInfo;
       enter adr
       <<SLOT codeAddressToObjectFileInfo:dopart>>
       exit ofi[]
       #);
     
     
     (* DATAADDRESSTOOBJECTFILEINFO
      * ===========================
      * 
      * Locate the ObjectFileInfo containing the data address entered. *)
     
     dataAddressToObjectFileInfo:
       (# adr: @Integer; ofi: ^ObjectFileInfo;
       enter adr
       <<SLOT dataAddressToObjectFileInfo:dopart>>
       exit ofi[]
       #);
     
     
     (* GROUPNAMETOOBJECTFILEINFO
      * =========================
      * 
      * Locate the ObjectFileInfo of the name entered. *)
     
     groupnameToObjectFileInfo:
       (# groupName: ^Text; ofi: ^ObjectFileInfo;
       enter groupName[]
       <<SLOT groupNameToObjectFileInfo:dopart>>
       exit ofi[]
       #);
     
     (* UNIQUEGROUPIDTOOBJECTFILEINFO
      * =============================
      * 
      * Locate the ObjectFileInfo with the unique ID entered. *)
     
     uniqueGroupIDToObjectFileInfo:
       (# groupNameHash,checkTime: @Integer;
          ofi: ^ObjectFileInfo;
       enter (groupNameHash,checkTime)
       <<SLOT uniqueGroupIDToObjectFileInfo:dopart>>
       exit ofi[]
       #);
     
     (* FGFULLLNAMETOOFINAME
      * ====================
      * 
      * Converts a groupname as returned by astInterface.fragment.fullname 
      * into a string that can be given as parameter to 
      * groupNameToObjectFileInfo. *)
     
     fgFullNameToOFIname:
       (# fullName: ^Text;
       enter fullName[]
       <<SLOT  fgFullNameToOFIname:dopart>>
       exit fullName[]
       #);
     
     
     (* FRAGMENTINFO
      * ============ *)
          
     FragmentInfo:
       (# fragmentName: ^Text;
          fragmentType: @shortInt;
          
          frag: ^mps.AST.fragmentForm; (* Cached here when first found. *)
          
          (* doparts in fragment
           * ===================
           * 
           * "doparts" contains an element for each dopart in this 
           * fragment. There is no trivial connection to the prototypes
           * of the fragment since dopart SLOTS mess up everything. *)
          
          dopartCount: @Integer;     (* Number of doparts in fragment. *)
          doparts: [0]^dopartInfo;
          
          findDopartInfo:
            (# astRef: @Integer; dpi: ^dopartInfo;
            enter astRef
            <<SLOT findDopartInfo:dopart>>
            exit dpi[]
            #);
       #);
     
     
     
     (* DOPARTINFO
      * ==========
      * 
      * Information corresponding to a dopart. *)
     
     dopartInfo: 
       (# astRef: @ShortInt;         (* Ast index of dopart.              *)
          fragRef: @ShortInt;        (* Fragment index.                   *)
          
          impAddresses: [0]@Integer; (* Imperative memory addresses.      *
                                      * Relative to M entry point.        *)
          impAstRefs: [0]@ShortInt;  (* Imperative ast indices.           *)
          
          Mentry: @Integer;          (* Mentry point of this dopart. *)
          odofi: ^ObjectFileInfo;    (* ObjectFileInfo of fragment group 
                                      * containing the ObjectDescriptor
                                      * enclosing this dopart. *)
          ptinx: @Integer;           (* Index in odofi repetitions of
                                      * information on the prototype whose
                                      * objectDescriptor encloses this dopart. 
                                      *)
          dp: ^mps.BETACFL.doPart;       (* The ast itself. *)
          (* Mentry, odofi[], ptinx and dp are filled out by 
           * utilities.codeAddressToImperative or 
           * utilities.codeAstToImperative before caching this dopartInfo 
           * in the doparts attribute of the ObjectFileInfo containing the 
           * prototype whose dopart is this dopartInfo. *)
          
       #);
     
     
     (* IMPERATIVEINFO
      * ==============
      *
      * Information corresponding to an imperative. *)
     
     ImperativeInfo:
       (# dpi: ^dopartInfo;     (* Info on enclosing dopart.                 *)
          inx: @Integer;        (* Index in dpi.impAddresses and impAstRefs. *)
          cast: ^mps.AST.ast;       (* Imperative ast.                           *)
          start: (# exit dpi.impAddresses[inx] + dpi.Mentry #);
       #);
     
     
     (* PROTOTYPEINFO
      * ============= 
      * 
      * Information corresponding to a ProtoType/ObjectDescriptor. *)
     
     ProtoTypeInfo:
       (# ofi: ^ObjectFileInfo;
          inx: @Integer;     (* Index in ofi repetitions. *)
          objdesc: ^mps.BETACFL.objectDescriptor; 
       #);
     
     
     
     (* DBMANAGER
      * =============
      * 
      * Used to manage the part of the debug information kept in the
      * auxiliary ..db files generated by the compiler. *)
     
     DBManager: @
       (#
          (* INIT
           * ====
           * 
           * Init checks whether fragment information has been generated and 
           * saved in a ..db file prefixed with the name of the executable. 
           * If so, and if it is up-to-date, this file is read and cached in 
           * an internal table. If not, all ..db files are scanned to read 
           * fragment information and save it in a new ..db file. *)
          
          init:
            (# doingExpensiveRead:< Object
                 (# dbName: ^Text;
                 enter dbName[]
                 do INNER
                 #);
               doingCheapRead:<
                 (# dbName: ^Text;
                 enter dbName[]
                 do INNER
                 #);
               createFragInfo:< BooleanObject;
               creationFailed:<
                 (# dbName: ^Text;
                 enter dbName[]
                 do INNER
                 #);
            <<SLOT DBManagerInit:dopart>>
            #);
          
          
          (* READDB 
           * ======
           * 
           * Should only be called by BasicObjectFileInfo.ensureMaxLoadLevel.
           * 
           * readDB fills in ofi with the information in the corresponding 
           * ..db file, assuming that all other information in ofi has 
           * already been initialized.
           * 
           * If the ..db file could not be found or is newer than the 
           * executable, ofi.loadLevel is set to LL_NODBINFO. 
           * Otherwise the information is loaded and ofi.loadLevel is 
           * set to LL_FULL. DBstatus is called in any case.
           *)
          
          readDB:
            (# ofi: ^ObjectFileInfo;
            enter ofi[]
            <<SLOT DBManagerReadDB:dopart>>
            #);
          
          
          (* slotNameToGroups
           * ================
           * 
           * Given a SLOT name and a SLOT type, scans over the names of the 
           * fragment groups containing fragments of the name and type given.
           * 
           * Currently slotType is either descriptorForm, attributesForm
           * or dopart. For absolute values, see ~beta/betaast/v4.9/gram.bet.
           *)
          
          slotNameToGroups:
            (# slotName: ^Text; slotType: @Integer;
               current: ^Text; groupNameHash,checkTime: @Integer;
            enter (slotName[],slotType)
            <<SLOT DBManagerSlotNameToGroups:dopart>>
            #);
          
          dbmprivate: @<<SLOT DBManagerprivate:descriptor>>;
       #);


     (* UTILITIES
      * ========= *)
     
     Utilities: @
       (# <<SLOT utilitiesLib:attributes>>;
          
          init: (# <<SLOT utilitiesInit:dopart>> #);
          
          
          (* ProtoAddressToPrototypeInfo
           * ===========================
           * 
           * Maps a prototype address to the corresponding ProtoTypeInfo.
           * 
           * Returns NONE in case we failed to convert the prototype address
           * into a protoTypeInfo. *)
          
          ProtoAddressToPrototypeInfo:
            (# ptAdr: @Integer;
               pti: ^PrototypeInfo;
            enter ptAdr
            <<SLOT ProtoAddressToPrototypeInfo:dopart>>
            exit pti[]
            #);
          
          
                    
          (* codeAddressToImperative
           * =======================
           * 
           * Maps a code address (codeAdr) to information on the corresponding
           * BETA imperative.
           * 
           * If the code address corresponds to a G entry, the onGentry virtual
           * is called with information on the prototype whose Gentry contains
           * codeAdr.
           * 
           * If some error occurs during the mapping (e.g. some ..db file
           * was not found), but the codeAdr still seems to correspond to
           * some BETA code address, information on the prototype whose dopart
           * contains the code address is still available. In that case, 
           * onPartialMinfo is called with the prototype whose Mentry contains
           * codeAdr.
           * 
           * notBetaCode is called if codeAdr does not correspond to a BETA
           * code address.
           * 
           * Returns NONE in case of failure. *)
          
          codeAddressToImperative:
            (# onGentry:< 
                 (* Called if a G entry is found. *)
                 (# protoAdr: @Integer; 
                    (* Address of prototype whose Gpart contains codeAdr *)
                    offset: @Integer;
                    (* Offset from Gentry point to codeAdr. *)
                 enter (protoAdr,offset)
                 do INNER
                 #);
               onPartialMinfo:<
                 (# protoAdr: @Integer;
                    (* Address of prototype whose Mpart contains codeAdr *)
                    offset: @Integer;
                    (* Offset from Mentry to codeAdr. *)
                    dp: ^mps.BETACFL.doPart;
                    (* Dopart containing protoAdr, if known. *)
                 enter (protoAdr,offset,dp[])
                 do INNER
                 #);
               notBetaCode:<
                 (# errormsg: ^Text;
                 enter errormsg[]
                 do INNER
                 #);
               codeAdr: @Integer;
               impi: ^ImperativeInfo;
            enter codeAdr
            <<SLOT codeAddressToImperativ:dopart>>
            exit impi[]
            #);
          
          (* codeAstToImperative
           * ===================
           * 
           * noEnclosingDopart is called if the ast entered is not enclosed
           * by a dopart locally to the enclosing fragment. This can only
           * happen if cast is actually not an imperative. 
           * notFound is called if no imperative info could be found on
           * the imperative entered. *)
          
          codeAstToImperative:
            (# cast: ^mps.AST.ast;
               impi: ^ImperativeInfo;
               noEnclosingDopart:< Exception;
               notFound:< Exception;
            enter cast[]
            <<SLOT codeAstToImperative:dopart>>
            exit impi[]
            #);
          
          (* objectDescriptorToDopart
           * ========================
           * 
           * Given an objectDescriptor, returns the dopartInfo corresponding
           * to that objectDescriptor. *)
          
          objectDescriptorToDopart:
            (# noDopart:< Exception; (* od has no dopart *)
               notFound:< Exception; (* Missing debug info. *)
               onPartialMinfo:<
                 (# dp: ^mps.BETACFL.doPart; (* The dopart AST. *)
                    ofi: ^ObjectFileInfo; (* ObjectFile containing the od. *)
                    ptinx: @Integer; (* Index of od in ofi.Tentries *)
                 enter (dp[],ofi[],ptinx)
                 do INNER
                 #);
               od: ^mps.BETACFL.ObjectDescriptor;
               dpi: ^dopartInfo;
            enter od[]
            do <<SLOT objectDescriptorToDopartInfo:descriptor>>
            exit dpi[]
            #);
          
          (* SLOTtoFragment
           * ==============
           * 
           * Converts a SLOT descriptor into the corresponding fragment, if possible. *)
          
          SLOTtoFragment:
            (# theSLOT: ^mps.AST.slotDesc;
               ff: ^mps.AST.fragmentForm;
               ofi: ^ObjectFileInfo;
            enter theSLOT[]
            do <<SLOT SLOTtoFragment:descriptor>>
            exit (ff[],ofi[])
            #);
          
         utprivate: @<<SLOT utilitiesPrivate:descriptor>>
       #);  
     
     (* onProcessFork, onWaitForConnection, and onProcessForkDone
      * =============  ===================      =================
      * Called before process fork, before waiting for forked process to connect,
      * and when connection has been established. *)
     
     onProcessFork:< Object;
     onWaitForConnection:< Object;
     onProcessForkDone:< Object;
     
     
     
     
     
     
     (* onDataSegmentScan and onDataSegmentScanDone
      * =================     =====================
      * Called before and after the initial scan of the data segments
      * in debugged process. *)
     
     onDataSegmentScan:< Object;
     onDataSegmentScanDone:< Object;
     
     
     (* onLabelRead, and onLabelReadDone
      * ===========      ===============
      * Called before and after reading the code labels in the executable. *)
     
     onLabelRead:< Object;
     onLabelReadDone:< Object;
     
     executableException: Exception 
       (# execName: ^Text
       enter execName[]
       do INNER
       #);
     
     commError:< Exception
       (* Called in case of communication errors with the debugged process
        * that are not handled otherwise. *)
       (# commCode: @Integer
       enter commCode
       do INNER;
          (if not continue then
              'Communication error on request type ' -> msg.putText;
              commCode -> msg.putInt;
          if);
       #);
     
     dbLoadFailed:< Exception
       (* Called in case demand load of extra info from ..db file for an 
        * ObjectFileInfo has failed. *)
       (# ofi: ^ObjectFileInfo; 
          dbfilename: ^Text;
          dbstatus: @Integer;
       enter (ofi[],dbfilename[],dbstatus)
       do INNER;
          (if not continue then
              dbfilename[]->msg.putText;
              (if dbstatus
               //DBFILE_NOTFOUND then
                  ' not found'->msg.putText;
               //DBFILE_NEWER then
                  ' newer than executable'->msg.putText;
              if);
          if);
       #);
     
     utilitiesFailure:< Exception
       (* Called with an error message if utilities failed to perform
        * one of its mappings. *)
       (# errormsg: ^Text;
       enter errormsg[]
       do INNER;
          (if not continue then
              errormsg[]->msg.putText
          if);
       #);
     
     stepfailure:< Exception
       (* Called with a warning message if a step into or step over may not
        * behave as expected due to missing debug information. If TRUE
        * is returned, the step operation i performed anyway. Otherwise
        * it is cancelled. *)
       (# errormsg: ^Text; stepanyway: @Boolean;
       enter errormsg[]
       do TRUE->stepanyway;
          INNER;
          (if not continue then
              errormsg[]->msg.putText
          if);
       exit stepanyway
       #);
     
     breakfailure:< Exception
       (* Raised from breakManager.init (breakpoints.bet) if a breakpoint set
        * or unset failed due to an access failure. *)
       (# set: @Boolean;
       enter set
       do INNER;
       #);
     
     unknownImpFailure:< Exception;
     (* Raised from setBreakPoint (breakpoints.bet) if no debugging info
      * on the imperative entered could be found. In that case, it is
      * not possible to set the required breakpoint. *)
     
     DBstatus:<
       (# dbName: ^Text;
          status: @Integer; (* One of DBFILES_ *)
       enter (dbName[],status)
       do INNER
       #);
     
     doPrettyPrint:< (* Called for debugging purposes *)
       (# a: ^mps.AST.ast; level: @Integer; pp: ^Text;
       enter (a[],level)
       do INNER
       exit pp[]
       #);
     
     piPrivate: @<<SLOT processInterfacePrivate:descriptor>>;
  #)
