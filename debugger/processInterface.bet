ORIGIN '~beta/objectbrowser/v2.0/mpsinterface';

INCLUDE '~beta/objectbrowser/v2.0/groupsinfo';

INCLUDE '~beta/sysutils/v1.4/pathhandler';

INCLUDE 'valhallaparams';
INCLUDE 'environment';

BODY 'private/processInterfaceBody';
BODY 'private/processCommBody';
BODY 'private/executableBody';
BODY 'private/utilitiesBody';
BODY 'private/dbmanagerBody';

--- lib:attributes ---

(* LOAD LEVELS
 * =========== 
 * 
 * Load levels of ObjectFileInfos *)

LL_INITIAL:  (# exit 0 #);
(* GroupName+codeStart+codeEnd+dataStart+dataEnd *)

LL_FULL:     (# exit 1 #);
(* LL_INITIAL+protoCount+Tentries+Mentries+Gentries+astRefs+fragments *)

LL_NODBINFO: (# exit 2 #);
(* Like LL_FULL, butNo dopart info due to missing ..db file. *)

printLoadLevel:
  (# level: @Integer; s:^stream;
  enter (level,s[])
  do (if level
      //LL_INITIAL then
         'LL_INITIAL'->s.putText;
      //LL_FULL then
         'LL_FULL'->s.putText;
      //LL_NODBINFO then
         'LL_NODBINFO'->s.putText;
     if);
  #);

(* STATUS OF DBFILES
 * =================
 * 
 * These values are given as the status parameter to DBstatus virtuals. *)

DBFILE_OK:       (# exit 0 #); 
DBFILE_NOTFOUND: (# exit 1 #); (* The ..db file does not exist. *)
DBFILE_NEWER:    (# exit 2 #); (* The ..db file exists, but is newer than the
                                * executable. *)

printDBstatus:
  (# status: @Integer; s: ^stream;
  enter (status,s[])
  do (if status
      //DBFILE_OK then
         'DBFILE_OK'->s.putText;
      //DBFILE_NOTFOUND then
         'DBFILE_NOTFOUND'->s.putText;
      //DBFILE_NEWER then
         'DBFILE_NEWER'->s.putText;
     if)
  #);

processInterface: mpsinterface
  (# 
     <<SLOT processInterfaceLib:attributes>>;
     
     (* Shortcuts: *)
     
     terminated: processComm.status.terminated (# #);
     curObj: processComm.status.curObj (# #);
     curComp: processComm.status.curComp (# #);
     PC: processComm.status.PC (# #);
     SP: processComm.status.SP (# #);
     signal: processComm.status.signal (# #);
     error: processComm.status.error (# #);
       
     waitcount: @Integer; 
     (* Number of times the process has been stopped. Incremented each
      * time processComm.wait returns. *)
     
     beforeContinue:< Object;
     (* beforeContinue is executed before allowing the remote
      * process to continue after a stop. It should be used to remove 
      * elements from DOT that have no owners. i.e. elements that are 
      * no longer on display. *)
     
     afterWait:< Object;
     (* afterWait is executed immediately before wait returns. It 
      * should be used to scan all known objects (objectDB) to check 
      * if they have become garbage *)
     
     (* INIT
      * ====
      * 
      * Initializes this(processInterface). Information about the process to
      * start is found in the global databases defined in environment.bet and
      * valhallaparams.bet.
      * 
      * doingExpensiveRead is called if dbManager is about to scan through
      * all ..db files to get fragment information.
      * 
      * doingCheapRead is called if dbManager is about to read fragment 
      * information from cached file.
      * 
      * createFragInfo is called to query whether fragment info should be
      * cached for faster startup the next time.
      * 
      * creationFailed is called if it was not possible to create the cache
      * file.
      * 
      * execNotFound is raised if the executable could not be found. It is ok to leave
      * init on this occation.
      * 
      * forkFailed is raised if it was not possible to fork the process. 
      * It is ok to leave init on this occation.
      * 
      * Calls INNER when all other initialization has finished. *)
     
     init::<
       (# doingExpensiveRead:< Notification
            (# dbName: ^Text;
            enter dbName[]
            do INNER
            #);
          doingCheapRead:< Notification
            (# dbName: ^Text;
            enter dbName[]
            do INNER
            #);
          createFragInfo:< BooleanObject;
          creationFailed:< Exception
            (# dbName: ^Text;
            enter dbName[]
            do INNER
            #);
          execNotFound:< executableException;
          forkFailed:< Exception;
       <<SLOT processInterfaceInit:dopart>>
       #);
     
     rerun:
       (# execNotFound:< executableException;
          forkFailed:< Exception;
          modtimeChanged:< executableException;
       <<SLOT processInterfaceRerun:dopart>>
       #);
     
     
     (* KILL
      * ====
      * 
      * Should be called to kill the process being debugged. Works only
      * when process is currently stopped but not terminated. *)
     
     kill: 
       (# 
       <<SLOT processInterfaceKill:dopart>>
       #);
     
     
     (* processPathHandler
      * ==================
      * 
      * Used to convert objectFileInfo.groupNames into full path names. *)
     
     processPathHandler: @pathhandler;
     
     
     (* PROCESSCOMM
      * ===========
      * 
      * The process communicator communicates with the debugged process to get
      * information about the state of the process. It implements low-level 
      * details such as how the communication with the process is actually
      * handled.
      * 
      * processData and processCode can be used to read and write the
      * memory of the process. 
      * 
      * DOT describes itself.
      * 
      * init initializes this processCommunicator. Information is found in
      * the global databases defined in "environment.bet" and 
      * valhallaparams.bet.
      * 
      * scanGroups scans through the objectfiles that are statically linked 
      * into the executable. FormatError is raised if the answer from the
      * debugged process does not have the right format.
      * 
      * loadProtoTable loads the prototype table of the ObjectFileInfo entered
      * as parameter by filling out protoCount, Tentries, Mentries, Gentries
      * and astReafs of the ObjectFileInfo. loadProtoTable should only be 
      * called by BasicObjectFileInfo.ensureMaxLoadLevel.*)

     processComm: @
       (# 
          <<SLOT processCommLib:attributes>>;
          
          init:
            (# forkFailed:< Exception;
            <<SLOT processCommInit:dopart>>
            #);
          
          kill: (# <<SLOT processCommKill:dopart>> #);
          
          scanGroups:
            (# formatError:< Exception;
               dataStart, dataEnd, codeStart, codeEnd: @Integer;
               groupName: ^Text;
            do <<SLOT processCommScanGroups:descriptor>>
            #);
     
          loadProtoTable:
            (# accessFailure:< exception;
               ofi: ^ObjectFileInfo;
            enter ofi[]
            <<SLOT processCommLoadProtoTable:dopart>>
            #);
          
          MachineType: @
            (# name: ^Text;
            <<SLOT processCommMachineType:dopart>>
            exit name[]
            #);
          
          (* STATUS
           * ======
           * 
           * May be used to query the state of the process if it is
           * stopped. *)
          
          status: @
            (# curObj: StatusValue (# <<SLOT StatusCurObj:dopart>> #);
               curComp: StatusValue (# <<SLOT StatusCurComp:dopart>> #);
               PC: StatusValue (# <<SLOT StatusPC:dopart>> #);
               SP: StatusValue (# <<SLOT StatusSP:dopart>> #);
               signal: StatusValue
                 (# sigtext: ^Text;
                 <<SLOT StatusSignal:dopart>>
                 exit sigtext[]
                 #);
               statusValue: IntegerValue 
                 (# running:< Exception 
                 <<SLOT StatusValue:dopart>>
                 #);
               error: StatusValue
                 (# errorText: ^Text;
                 <<SLOT StatusError:dopart>>
                 exit errorText[]
                 #);
               terminated: BooleanValue
                 (# 
                 <<SLOT StatusTerminated:dopart>>
                 #);
               statusPrivate: @<<SLOT StatusPrivate:descriptor>>
            #);
          
          (* RTSprocAdr
           * ==========
           * 
           * Returns memory addresses of RTS procedures. The RTproc parameter 
           * must be one of the constants defined in RTSprocedures.bet *)
          
          RTSprocAdr:
            (# RTproc: @Integer;
               procAddr: @Integer;
            enter RTproc
            <<SLOT RTSprocAdr:dopart>>
            exit procAddr
            #);
          
     
          (* MEMORY ACCESS
           * ============= *)
          
          acc: (* Super pattern for memory access operations *)
            (# accessFailure:< Exception;
               address: @Integer 
            enter address 
            do INNER 
            #);
          
          processData: @
            (# peekDouble: acc 
                 (# value: @Real;
                 <<SLOT doProcessDataPeekDouble:dopart>>
                 exit value     
                 #);
               peekLong: acc
                 (# value: @Integer;
                 <<SLOT doProcessDataPeekLong:dopart>>
                 exit value
                 #);
               peekShort: acc 
                 (# value: @ShortInt;
                 <<SLOT doProcessDataPeekShort:dopart>>
                 exit value 
                 #);
               peekByte: acc
                 (# value: @Char;
                 <<SLOT doProcessDataPeekByte:dopart>>
                 exit value    
                 #);
               
               (* peekMemoryLongs and peekMemoryBytes calls INNER to obtain 
                * the address of the first element in a repetition with the 
                * required space. This address should be put into repAdr. *)
               peekMemoryBytes: acc 
                 (# length: @Integer; (* Length in bytes. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessDataPeekMemoryBytes:dopart>>
                 #);
               peekMemoryLongs: acc 
                 (# length: @Integer; (* Length in longs. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessDataPeekMemoryLongs:dopart>>
                 #);
               
               pokeDouble: acc 
                 (# value: @Real enter value 
                 <<SLOT doProcessDataPokeDouble:dopart>>
                 #);
               pokeLong: acc 
                 (# value: @Integer 
                 enter value 
                 <<SLOT doProcessDataPokeLong:dopart>>
                 #);
               pokeShort: acc 
                 (# value: @ShortInt 
                 enter value 
                 <<SLOT doProcessDataPokeShort:dopart>>
                 #);
               pokeByte: acc  
                 (# value: @Char 
                 enter value 
                 <<SLOT doProcessDataPokeByte:dopart>> 
                 #);
            #);
          
          processCode: @
            (# peekDouble: acc 
                 (# value: @Real;
                 <<SLOT doProcessTextPeekDouble:dopart>>
                 exit value     
                 #);
               peekLong: acc
                 (# value: @Integer;
                 <<SLOT doProcessTextPeekLong:dopart>>
                 exit value
                 #);
               peekShort: acc 
                 (# value: @ShortInt;
                 <<SLOT doProcessTextPeekShort:dopart>>
                 exit value 
                 #);
               peekByte: acc
                 (# value: @Char;
                 <<SLOT doProcessTextPeekByte:dopart>>
                 exit value    
                 #);
               (* peekMemoryLongs and peekMemoryBytes calls INNER to obtain 
                * the address of the first element in a repetition with the 
                * required space. This address should be put into repAdr. *)
               peekMemoryBytes: acc 
                 (# length: @Integer; (* Length in bytes. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessTextPeekMemoryBytes:dopart>>
                 #);
               peekMemoryLongs: acc 
                 (# length: @Integer; (* Length in longs. *)
                    repAdr: @Integer; (* Repetition address. Set it when INNER
                                       * is called. *)
                 enter length
                 <<SLOT doProcessTextPeekMemoryLongs:dopart>>
                 #);
               
               setBreakpoint: acc
                 (# oldcode: @Integer;
                 <<SLOT doProcessTextSetBreakpoint:dopart>>
                 exit oldcode
                 #);
               unsetBreakpoint: acc
                 (# oldcode: @Integer;
                 enter oldcode
                 <<SLOT doProcessTextUnsetBreakpoint:dopart>>
                 #);
            #);
          
          
          (* COMMANDS
           * ========
           * 
           * Continue, SingleStep and Stop only initiates the corresponding
           * actions. Wait blocks the calling coroutine until the debugged 
           * process has stopped and is ready for communication.
           * failure is raised if communication with the debugged process
           * failed. *)
          
          UnlessTerminated:
            (# terminated:< Exception;
            do (if not status.terminated then
                   INNER
                else
                   terminated;
               if);
            #);
          
          Continue: UnlessTerminated
            (* Continue the process after a breakpoint or signal. *)
            (# failure:< Exception; 
            <<SLOT ContinueBody:dopart>>
            #);
          
          SingleStep: UnlessTerminated
            (* Singlestep the process. *)
            (# failure:< Exception;
            <<SLOT SinglestepBody:dopart>>
            #);
          
          Stop: UnlessTerminated
            (* Stop the process if it is running. *)
            (# failure:< Exception;
            <<SLOT processCommStop:dopart>>
            #);
          
          Wait: UnlessTerminated
            (* Wait for the process to stop. wrongMessage is raised if the 
             * first message received from the process was not VOP_STOPPED. *)
            (# wrongMessage:< Exception;
               failure:< Exception;
            do <<SLOT processCommWait:descriptor>>
            #);
          
          (* DOT (Debugger Object Table)
           * ===========================
           * 
           * Used to keep track of objects through garbage collections.
           * Objects traced by the debugger are inserted into the table.
           * 
           * Insert returns an index to be used to get the current address
           * of the object. objsize is the size of the object in longs.
           * 
           * inxToAddress returns the current address of the object with
           * the DOT index given. If 0 is returned, the object has been 
           * garbage collected, and the index deleted from the table. 
           * 
           * addressToInx returns the DOT index corresponding to objAdr.
           * If objAdr is not found in the table, -1 is returned. 
           *
           * Each time the process stops, all indices should be checked
           * to see whether they have become garbage since the last stop.
           * As soon as insert is called, old indices may get reused!! *)
          
          DOT: @
            (# insert:
                 (# objAdr: @Integer;
                    inx,objsize: @Integer;
                 enter objAdr
                 <<SLOT piDOTinsert:dopart>>
                 exit (inx,objsize)
                 #);
               
               inxToAddress:
                 (# inx: @Integer;
                    objAdr: @Integer;
                 enter inx
                 <<SLOT piDOTinxToAddress:dopart>>
                 exit objAdr
                 #);
               
               addressToInx: 
                 (# objAdr: @Integer;
                    inx: @Integer;
                 enter objAdr
                 <<SLOT piDOTaddressToInx:dopart>>
                 exit inx
                 #);
               
               scan:
                 (# dotinx,adr: @Integer;
                    delete: @Boolean; 
                    (* If set to TRUE, current element should be deleted. *)
                 <<SLOT piDOTscan:dopart>>
                 #);
               
               init: <<SLOT piDOTinit: descriptor>>;
               
               dotPrivate: @<<SLOT piDOTprivate:descriptor>>;
            #);
          
          canonify:
            (# objAdr: @Integer;
            enter objAdr
            <<SLOT processCommCanonify:dopart>>   
            exit objAdr
            #);
          
          scanStack:
            (* Scans the stak of the component whose address is given
             * as parameter. Calls INNER once with returnAdrs and
             * returnObjs filled out. If returnObjs[i]=0, returnAdrs[i] is 
             * a C return address. stacktype is set to the current state of
             * the component stack. See processCommCodes.bet for a list
             * of possible values (CS_* constants).
             * 
             * noStack is raised if the component has not yet been attached,
             * and thus has not been assigned a stack object. *)
            (# compAdr: @Integer;   (* Address of a component object. *)
               noStack:< Notification;
               returnObjs: [20]@Integer;
               returnAdrs: [20]@Integer;
               last: @Integer; 
               (* last valid index into returnObjs and returnAdrs. *)
               stacktype: @Integer; (* One of CS_* from processCommCodes.bet *)
               (*private*)tmp: @Integer;
            enter compAdr
            <<SLOT processCommScanStack:dopart>>
            #);
          
          pcPrivate: @<<SLOT processCommPrivate:descriptor>>;
          pcmdPrivate: @<<SLOT processCommMDprivate:descriptor>>;

       #);
     
     (* EXECUTABLE
      * ==========
      * 
      * Implements access to information that can only be found in the
      * executable. Currently this only includes labels, and is needed only 
      * if we fail to locate the information otherwise.
      * 
      * If the option readLabelsOnStartUp is TRUE, init will fork a nm
      * process to read and sort the labels in the execuatable. The
      * result is read from that process when finishInit is called. *)

     executable: @
       (# init:
            (# notFound:< executableException;
            <<SLOT executableInit:dopart>>
            #);
          finishInit:
            (# 
            <<SLOT executableFinishInit:dopart>>
            #);
          
          reinit:
            (# modtimeChanged:< executableException;
               notfound:< executableException;
            <<SLOT executableReInit:dopart>>   
            #);
          
          kill: (# <<SLOT executableKill:dopart>> #);
          
          (* Label handling
           * ============== *)
          
          labelNameToAddress:
            (# name: ^Text;
               address: @Integer;
            enter name[]
            <<SLOT labelNameToAddress:dopart>>
            exit address
            #);
          
          labelAddressToName:
            (# address: @Integer;
               name: ^Text; value: @Integer;
            enter address
            <<SLOT labelAddressToName:dopart>>
            exit (name[],value)
            #);
          
          modTime: @Integer; (* modTime of the executable. *)
          
          execPrivate: @<<SLOT executablePrivate:descriptor>>;
       #);
     
     
     (* GROUPSINFO
      * ==========
      * 
      * Table performing the mapping from the prototype number in the
      * to data segment to the corresponding  ObjectDescriptor. *)
     
     groupsInfoTableType:< groupsInfoTable;
     groupsInfo: @groupsInfoTableType;
     
     
     (* OBJECTFILEINFO, BASICOBJECTFILEINFO
      * ===================================
      * 
      * Type of object containing diverse information on BETA object-files
      * linked into the debugged process. *)
     
     ObjectFileInfo:< BasicObjectFileInfo;
     BasicObjectFileInfo:
       (# 
          (* LL_INITIAL INFORMATION
           * ======================
           * 
           * Upper part of BasicObjectFileInfo is initialized when connection 
           * to the debugged process is established. The rest is loaded from 
           * debugged process and ..db file on demand. *)
          
          groupName: ^Text;
          (* Groupname string as saved by compiler in datasegment. *)
          
          codeStart, codeEnd: @Integer; 
          (* Address of codepart of this objectfile in memory.
           * codeEnd is the address of the first code *after* the
           * code described by this(BETAgroupFile). *)
          
          dataStart, dataEnd: @Integer;
          (* Address of datasegment of this objectfile in memory.
           * dataStart is the address of the length field of the
           * prototype table. dataEnd is the address of the following
           * dataSegment. *)
          
          loadLevel: @Integer; 
          
          ensureMaxLoadLevel: @ (# <<SLOT OFIensureMaxLoadLevel:dopart>> #);
          
          (* LL_ENTRIES INFORMATION
           * ======================
           * 
           * Information below has been loaded if loadLevel is LL_ENTRIES.
           * Corresponding indices in repetitions contain diverse info on the
           * same prototype. *)
          
          protoCount: @Integer;  (* Number of prototypes in objectfile.   *)
          Tentries: [0]@Integer; (* Prototype addresses. Corresponding to *
                                  * prototype table in object file and loaded
                                  * on demand from debugged process. *)
          Mentries: [0]@Integer; (* Loaded from debugged process. *)
          Gentries: [0]@Integer; (* Loaded from debugged process. *)
          astRefs: [0]@Integer;  (* (FormIndex,AstIndex as contained in the
                                  * prototype. Loaded from debugged process. *)
          
          doparts: [0]^dopartInfo;(* dopartInfo for prototype  is cached *
                                   * here when it first becomes known.   *)
          
          
          (* LL_DBINFO INFORMATION
           * =====================
           * 
           * Information below has been loaded if loadLevel is LL_DBINFO. 
           * Number of fragments equals fragments.range. *)
          
          fragments: [0]^FragmentInfo; 
          scanFragments:
            (# current: ^FragmentInfo; index: @Integer;
            do (for i:fragments.range repeat
                    i->index; fragments[i][]->current[];
                    INNER;
               for);
            #);
          
          findFragmentInfo:
            (# fragmentName: ^Text; fragmentType: @Integer;
               fi: ^fragmentInfo;
            enter (fragmentName[],fragmentType)
            <<SLOT findFragmentInfo:dopart>>
            exit fi[]
            #);
          
          ScanVisibleGroups:
            (* Scans the names of the fragment groups that are visible from
             * this one. *)
            (# current: ^Text; 
            <<SLOT visibleGroups:dopart>> 
            #);
          
          fg: ^AST.fragmentGroup;
          originOfi: ^ObjectFileInfo; (* ObjectFileInfo of origin group. *)
          fgLoadFailed: @Boolean; (* Set to true if load of fg failed. *)
       #);
     
     
     (* SCANOBJECTFILEINFOS
      * =================== 
      * 
      * Scans through all ObjectFileInfos. *)
     
     scanObjectFileInfos:
       (# current: ^ObjectFileInfo;
       <<SLOT scanObjectFileInfos:dopart>>
       #);
     
     
     (* CODEADDRESSTOOBJECTFILEINFO
      * ===========================
      * 
      * Locate the ObjectFileInfo containing the code address entered. *)
     
     codeAddressToObjectFileInfo:
       (# adr: @Integer;
          ofi: ^ObjectFileInfo;
       enter adr
       <<SLOT codeAddressToObjectFileInfo:dopart>>
       exit ofi[]
       #);
     
     
     (* DATAADDRESSTOOBJECTFILEINFO
      * ===========================
      * 
      * Locate the ObjectFileInfo containing the data address entered. *)
     
     dataAddressToObjectFileInfo:
       (# adr: @Integer;
          ofi: ^ObjectFileInfo;
       enter adr
       <<SLOT dataAddressToObjectFileInfo:dopart>>
       exit ofi[]
       #);
     
     
     (* FRAGMENTINFO
      * ============ *)
          
     FragmentInfo:
       (# fragmentName: ^Text;
          fragmentType: @shortInt;
          
          frag: ^AST.fragmentForm; (* Cached here when first found. *)
          
          (* doparts in fragment
           * ===================
           * 
           * "doparts" contains an element for each dopart in this 
           * fragment. There is no trivial connection to the prototypes
           * of the fragment since dopart SLOTS mess up everything. *)
          
          dopartCount: @Integer;     (* Number of doparts in fragment. *)
          doparts: [0]^dopartInfo;
          
          findDopartInfo:
            (# astRef: @Integer; dpi: ^dopartInfo;
            enter astRef
            <<SLOT findDopartInfo:dopart>>
            exit dpi[]
            #);
       #);
     
     
     
     (* DOPARTINFO
      * ==========
      * 
      * Information corresponding to a dopart. *)
     
     dopartInfo: 
       (# astRef: @ShortInt;         (* Ast index of dopart.              *)
          fragRef: @ShortInt;        (* Fragment index.                   *)
          
          impAddresses: [0]@Integer; (* Imperative memory addresses.      *
                                      * Relative to M entry point.        *)
          impAstRefs: [0]@ShortInt;  (* Imperative ast indices.           *)
          
          Mentry: @Integer;          (* Mentry point of this dopart. *)
          ofi: ^ObjectFileInfo;      (* ObjectFileInfo of fragment group
                                      * containing this dopart. *)
          dp: ^BETACFL.doPart;      (* The ast itself. *)
          (* Mentry, ofi and dp are filled out by 
           * utilities.codeAddressToImperative before caching this dopartInfo 
           * in the doparts attribute of the ObjectFileInfo containing the 
           * prototype whose dopart is this dopartInfo. *)
          
       #);
     
     
     (* IMPERATIVEINFO
      * ==============
      *
      * Information corresponding to an imperative. *)
     
     ImperativeInfo:
       (# dpi: ^dopartInfo;     (* Info on enclosing dopart.                 *)
          inx: @Integer;        (* Index in dpi.impAddresses and impAstRefs. *)
          cast: ^AST.ast;       (* Imperative ast.                           *)
          start: (# exit dpi.impAddresses[inx] + dpi.Mentry #);
          (* after: 
           *             (# value: @Integer;
           *             do (if (inx < dpi.impAddresses.range) //true then
           *                    dpi.impAddresses[inx+1] + dpi.Mentry -> value
           *                 else
           *                    0 -> value
           *                if)
           *             exit value
           *             #);
           *)
       #);
     
     
     (* PROTOTYPEINFO
      * ============= 
      * 
      * Information corresponding to a ProtoType/ObjectDescriptor. *)
     
     ProtoTypeInfo:
       (# ofi: ^ObjectFileInfo;
          inx: @Integer;     (* Index in ofi repetitions. *)
          objdesc: ^BETACFL.objectDescriptor; 
       #);
     
     
     
     (* DBMANAGER
      * =============
      * 
      * Used to manage the part of the debug information kept in the
      * auxiliary ..db files generated by the compiler. *)
     
     DBManager: @
       (#
          (* INIT
           * ====
           * 
           * Init checks whether fragment information has been generated and 
           * saved in a ..db file prefixed with the name of the executable. 
           * If so, and if it is up-to-date, this file is read and cached in 
           * an internal table. If not, all ..db files are scanned to read 
           * fragment information and save it in a new ..db file. *)
          
          init:
            (# doingExpensiveRead:< Object
                 (# dbName: ^Text;
                 enter dbName[]
                 do INNER
                 #);
               doingCheapRead:<
                 (# dbName: ^Text;
                 enter dbName[]
                 do INNER
                 #);
               createFragInfo:< BooleanObject;
               creationFailed:<
                 (# dbName: ^Text;
                 enter dbName[]
                 do INNER
                 #);
            <<SLOT DBManagerInit:dopart>>
            #);
          
          
          (* READDB 
           * ======
           * 
           * Should only be called by BasicObjectFileInfo.ensureMaxLoadLevel.
           * 
           * readDB fills in ofi with the information in the corresponding 
           * ..db file, assuming that all other information in ofi has 
           * already been initialized.
           * 
           * If the ..db file could not be found or is newer than the 
           * executable, ofi.loadLevel is set to LL_NODBINFO. 
           * Otherwise the information is loaded and ofi.loadLevel is 
           * set to LL_FULL. DBstatus is called in any case.
           *)
          
          readDB:
            (# ofi: ^ObjectFileInfo;
            enter ofi[]
            <<SLOT DBManagerReadDB:dopart>>
            #);
          
          
          (* slotNameToGroups
           * ================
           * 
           * Given a SLOT name and a SLOT type, scans over the names of the 
           * fragment groups containing fragments of the name and type given.
           * 
           * Currently slotType is either descriptorForm, attributesForm
           * or dopart. For absolute values, see ~beta/betaast/v4.9/gram.bet.
           *)
          
          slotNameToGroups:
            (# slotName: ^Text; slotType: @Integer;
               current: ^Text;
            enter (slotName[],slotType)
            <<SLOT DBManagerSlotNameToGroups:dopart>>
            #);
          
          dbmprivate: @<<SLOT DBManagerprivate:descriptor>>;
       #);


     (* UTILITIES
      * ========= *)
     
     Utilities: @
       (#
          init: (# <<SLOT utilitiesInit:dopart>> #);
   
          (* NameToObjectFileInfo
           * ====================
           * 
           * Returns information on the objectfile requested. *)
          
          NameToObjectFileInfo:
            (# groupName: ^Text;
               ofi: ^ObjectFileInfo;
            enter groupName[]
            <<SLOT NameToObjectFileInfo:dopart>>
            exit ofi[]
            #);
     
     
          (* ProtoAddressToPrototypeInfo
           * ===========================
           * 
           * Maps a prototype address to the corresponding ProtoTypeInfo.
           * 
           * Returns NONE in case we failed to convert the prototype address
           * into a protoTypeInfo. *)
          
          ProtoAddressToPrototypeInfo:
            (# ptAdr: @Integer;
               pti: ^PrototypeInfo;
            enter ptAdr
            <<SLOT ProtoAddressToPrototypeInfo:dopart>>
            exit pti[]
            #);
          
          (* codeAddressToImperative
           * =======================
           * 
           * Maps a code address to information on the corresponding BETA 
           * imperative.
           * 
           * Returns NONE in case of failure. *)
          
          codeAddressToImperative:
            (# onGentry:< 
                 (* Called if a G entry is found. *)
                 (# protoAdr: @Integer; 
                    (* Address of prototype whose Gpart contains address *)
                    offset: @Integer;
                    (* Offset from Gentry point to address. *)
                 enter (protoAdr,offset)
                 do INNER
                 #);
               codeAdr: @Integer;
               imp: ^ImperativeInfo;
            enter codeAdr
            <<SLOT codeAddressToImperativ:dopart>>
            exit imp[]
            #);
          
          (* codeAstToImperativ
           * =================== *)
          
          codeAstToImperative:
            (# cast: ^AST.ast;
               imp: ^ImperativeInfo;
            enter cast[]
            <<SLOT codeAstToImperativ:dopart>>
            exit imp[]
            #);
          
         utprivate: @<<SLOT utilitiesPrivate:descriptor>>
       #);  
     
     (* onProcessFork and onProcessForkDone
      * =============     =================
      * Called before and after process fork. *)
     
     onProcessFork:< Object;
     onProcessForkDone:< Object;
     
     
     
     (* onDataSegmentScan and onDataSegmentScanDone
      * =================     =====================
      * Called before and after the initial scan of the data segments
      * in debugged process. *)
     
     onDataSegmentScan:< Object;
     onDataSegmentScanDone:< Object;
     
     
     (* onLabelRead, and onLabelReadDone
      * ===========      ===============
      * Called before and after reading the code labels in the executable. *)
     
     onLabelRead:< Object;
     onLabelReadDone:< Object;
     
     executableException: Exception 
       (# execName: ^Text
       enter execName[]
       do INNER
       #);
     
     commError:< Exception
       (* Called in case of communication errors with the debugged process
        * that are not handled otherwise. *)
       (# commCode: @Integer
       enter commCode
       do INNER;
          (if not continue then
              'Communication error on request type ' -> msg.putText;
              commCode -> msg.putInt;
          if);
       #);
     
     infoLoadFailed:< Exception
       (* Called in case demand load of extra info for an ObjectFileInfo
        * has failed. *)
       (# ofi: ^ObjectFileInfo; 
          nodbfile: @Boolean; (* TRUE if it was dbManager.readDB that failed.
                               * FALSE if it was processComm.loadProtoTable 
                               * that failed. *)
       enter (ofi[],nodbfile)
       do INNER;
          (if not continue then
              'Failed to load debug info from '->msg.putText;
              (if nodbfile then
                  'DBFILE'-> msg.putText
               else
                  'PROCESS'->msg.putText
              if);
              ' for '->msg.putText;
              ofi.groupName[]->msg.putText;
          if);
       #);
     
     DBstatus:<
       (# dbName: ^Text;
          status: @Integer; (* One of DBFILES_ *)
       enter (dbName[],status)
       do INNER
       #);
     
     piPrivate: @<<SLOT processInterfacePrivate:descriptor>>;
  #)
