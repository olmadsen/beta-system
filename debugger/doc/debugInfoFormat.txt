
   FORMAT OF DB FILES GENERATED BY COMPILER
   ========================================

   <DBfile>                ::= <GroupInfo> 
			       <DopartsInfo>

   <GroupInfo>             ::= <FragmentCount> 
			       <FragmentInfoListSize> 
			       <FragmentInfoList>
   <FragmentInfoList>      ::* <FragmentInfo> ;
   <FragmentInfo>          ::= <FragmentName> <FragmentType>

   <DoPartsInfo>           ::+ <DopartsInFragmentInfo> ;
   <DopartsInFragmentInfo> ::= <DopartCount> <DopartInfoList>
   <DopartInfoList>        ::+ <DopartInfo> ;
   <DopartInfo>            ::= <AstIndex> <ImperativeInfoList> '(short) -1'
   <ImperativeInfoList>    ::+ <ImperativeInfo> ;
   <ImperativeInfo>        ::= <CodeOffset> <AstIndex>

   <FragmentCount>         ::= (short) Number of fragments in the group 
			       and the length of <FragmentInfoList>

   <FragmentInfoListSize>  ::= (long) Size in bytes of fragment names 
			       and types, i.e.\ the total size of 
			       <FragmentInfoList>

   <CodeSize>              ::= (long)  Size in bytes of code fragment 
   <FragmentName>          ::= (asciiz) Fragment name
   <FragmentType>          ::= (short)  descriptorForm, attributesForm
			       or dopartType
   <AstIndex>              ::= (short)  ast index of prototype, dopart or
			       imperative. For <AstIndex> in <DopartInfo>,
                               it is the ast index of the <Imperatives>
                               node inside the dopart.
   <DopartCount>           ::= (short) number of doparts in fragment and
			       the length of <DopartInfoList>
   <CodeOffset>            ::= (short) offset from previous imperative



ImperativeInfo<imp> beskriver indholdet af ..db filen genereret
fra <imp>. Dette er nedenfor beskrevet gensidigt rekursivt
med de relevante dele af BETA grammatikken. Der benyttes
endvidere folgende notation:

    Offset<imp> betegner kode-offset'et fra den omgivende doparts
                M-entry point til *foerste* maskin-instruktion i
                koden genereret for <imp>.

    OffsetAfter<imp> betegner kode-offset'et fra den omgivende doparts
                M-entry point til foerste maskin-instruktion *efter*
                koden genereret for <imp>.

    astIndex<imp> betegner ast indexet for "imp".


Beskrivelse af ImperativeInfo<imp>:

   <DoPart>      ::= 'do' <Imperatives>;
   ImperativeInfo<Dopart> ::= 
        ImperativeInfo<Imperatives>


   <Imperatives> ::+ <ImpOpt> ';' ; 
   ImperativeInfo<Imperatives> ::+
        ImperativeInfo<ImpOpt> astIndex<Imperatives> OffsetAfter<Imperatives>

   <ImpOpt>      ::? <Imp>;
   ImperativeInfo<ImpOpt> ::? ImperativeInfo<Imp>

   <LabelledImp> ::= <NameDcl> ':' <Imp>;
   ImperativeInfo<LabelledImp> ::= 
        Offset<LabelledImp> astIndex<LabelledImp>
        ImperativeInfo<Imp>
        OffsetAfter<LabelledImp> astIndex<Imp>

   <ForImp> ::= '(' 'for' <Index> 'repeat' <Imperatives> 'for' ')';
   ImperativeInfo<ForImp> ::=
        Offset<ForImp> astIndex<ForImp> ImperativeInfo<Imperatives>

   <SimpleIfImp> ::= 
        '(' 'if' <Evaluation> 'then' <Imperatives> <ElsePartOpt> 'if' ')';
   ImperativeInfo<SimpleIfImp> ::=
	Offset<SimpleIfImp> astIndex<SimpleIfImp> 
	ImperativeInfo<Imperatives>
	ImperativeInfo<ElsePartOpt>

   <GeneralIfImp> ::= '(' 'if' <Evaluation> <Alternatives> <ElsePartOpt> 'if' ')';
   ImperativeInfo<GeneralIfImp> ::=
	Offset<GeneralIfImp> astIndex<GeneralIfImp>
	ImperativeInfo<Alternatives>
	ImperativeInfo<ElsePartOpt>

   <Alternatives> ::+ <Alternative> ;
   ImperativeInfo<Alternatives> ::+   ImperativeInfo<Alternative>
   ImperativeInfo<Alternative>  ::=   
	      ImperativeInfo<Selections> ImperativeInfo<Imperatives>

   <Selections>::+ <Selection> ;
   ImperativeInfo<Selections>   ::+   ImperativeInfo<Selection>

   <Selection> ::| <CaseSelection> ;
   ImperativeInfo<Selection> ::| ImperativeInfo<CaseSelection>

   <CaseSelection> ::= '//' <evaluation>;
   ImperativeInfo<CaseSelection> ::=   ImperativeInfo<Evaluation>

   <ElsePartOpt>  ::? <ElsePart>;
   ImperativeInfo<ElsePartOpt> ::? ImperativeInfo<ElsePart>

   <ElsePart>    ::= 'else' <Imperatives>;
   ImperativeInfo<ElsePart> ::= ImperativeInfo<Imperatives>

   ImperativeInfo<LeaveImp>::= Offset<LeaveImp> astIndex<LeaveImp>
   ImperativeInfo<RestartImp>::= Offset<RestartImp> astIndex<RestartImp>
   ImperativeInfo<InnerImp> ::= Offset<InnerImp> astIndex<InnerImp>
   ImperativeInfo<SuspendImp> ::= Offset<SuspendImp> astIndex<SuspendImp>
   ImperativeInfo<Evaluation> ::= Offset<Evaluation> astIndex<Evaluation>
   
BEMAERKNINGER:

   Offset<ForImp>: SP: Er dette offset'et for det sted hvortil koden hopper tilbage
                       for hver iteration, eller er det offset'et for koden der 
                       initialiserer for-loekken?
                   SV: Det er offset for koden der initialiserer for-loekken.

   Offset<LabelledImp>: 
                   SP: Er dette offset'et for koden der gemmer SP i det 
                       omgivende objekt, eller er det offset'et for koden hvortil 
                       en "restart" hopper. Jeg antager det foerste (hvis der 
                       ellers er forskel).
                   SV: Det er offset for koden der gemmer SP i det omgivende
                       objekt.
    
   OffsetAfter<Imperatives>: 
                   Dette er OffsetAfter<det sidste imp i listen>. Kan fx. bruges
                   til at saette breakpoints *efter* "bodyen" af en for-loekke, 
                   men inden index variablen blev talt op.
                   Hvad det saa ellers skulle goere godt for.


Jeg ved stadig ikke om code-offsets er regnet korrekt ud, og jeg ved heller
ikke lige hvordan jeg skal checke det. Men det kommer jeg vel til...

  -- Soren






Bemaerk: valhallaFindComp benytter sig af "isCode" til at checke om en vaerdi paa
stakken faktisk er en kode-adresse. Dette virker (ifoelge Peter) ikke paa alle
platforme. Paa saadanne platforme kan man benytte sig af nextGroup i stedet.
Ioevrigt er valhallaFindComp under alle omstaendigheder extremt maskin-afhaengig.

stepover en leave fra et pattern antager at der blot laves en simpel return. Hvis
dette aendrer sig skal stepover tilpasses. En mulighed bestaar simpelthen i at
saette et breakpoint paa samtlige return-addresser fundet paa stakken. Haardt
men beskidt...