(* Loading a new executable for debugging:
 * 
 * For each objectfile statically linked with the execuable, an
 * instance of ObjectFileInfo is created and filled in with the
 * information that is initially necessary:
 * 
 *    groupName, codeStart, codeEnd, dataStart and dataEnd, 
      groupNameHash, checkTime attributes.
 * 
 * This information corresponds to the ObjectFileInfo.loadLevel value
 * LL_INITIAL.
 * 
 * The rest of the information in a ObjectFileInfo is loaded on demand. 
 * Demand loaded information is:
 * 
 *    1. From debugged process: protoCount, Tentries, Mentries and Gentries
 *       and astRefs for prototypes.  Notice that astRef are really not needed 
 *       anymore. They are currently only used to debug 
 *       ~beta/objectbrowser/v2.0/groupsinfo.bet, by comparing
 *       astRefs loaded from the debugged process with astRefs found by scanning
 *       the fragmentGroup. 
 *    2. From ..db file: FragmentInfos are created while reading information
 *       in ..db file. The information read in ..db file is the fragmentName, 
 *       dopartCount and dopart information.
 *    3. From MPS: fg.
 * 
 * This information corresponds to  the ObjectFileInfo.loadLevel value
 * LL_FULL. If no ..db file was found, or if it was outdated, the loadLevel
 * is set to LL_NODBINFO, and information from the ..db file will be missing.
 *)


(* Locating the ast node corresponding to a memory code address, caddr:
 * The description below is implemented by utilities.codeAddressToImperative.
 * Once an imperativeInfo corresponding to caadr has been located, it is 
 * cached in the impInfoTable (utilitiesBody.bet) for fast future lookup.
 * 
 *    1.  Locate nearest M og G entry point. The ObjectFileInfo in question
 *        is quickly located using the codeStart and codeEnd attributes.
 *        It is now necessary to fully load the ObjectFileInfo's corresponding
 *        to caadr *and* the ObjectFileInfos corresponding to all fragment
 *        groups in its origin chain. 
 * 
 *           Invariant maintained by ensureMaxLoadLevel: 
 *                  If an ObjectFileInfo is fully loaded, all ObjectFileInfos 
 *                  in its origin chain have been fully loaded too.
 * 
 *        However, notice that this invariant can currently only be maintained
 *        if all .ast files in the origin chain can be found and opened. If 
 *        not, the origin chain of ObjectFileInfo's is broken at the group 
 *        that could not be opened.       
 * 
 *    2.  Search through Mentries and Gentries of the ObjectFileInfo and all
 *        its origins to locate largest Mentry (or Gentry) less than caddr.
 *        NOTICE THAT the ObjectFileInfo whose code segment contains the Mentry 
 *        is known from step 1, but, due to dopart SLOTS, the ObjectFileInfo
 *        containing the corresponding Tentry may be found in any of the origin 
 *        groups as well!!
 * 
 *    3.  If it is a G entry point, we are done at this level. The user
 *        should be given the information that the code address corresponds 
 *        to the code generating an instance of the prototype.
 * 
 *    4a. If it is a M entry point, and the dopart has been seen before, the
 *        dopartInfo is cached in the doparts repetition. Otherwise 
 * 
 *    4b. If the M entry point has *not* been seen before, we now need to 
 *        locate the ObjectDescriptor corresponding to the M entry found.
 *        Since we know the index of the prototype, the groupsInfoTable
 *        (~beta/objectbrowser/v2.0/groupsinfo) is able to locate the
 *        corresponding ObjectDescriptor. From the ObjectDescriptor, the
 *        dopart can be found. If the dopart is contained in a dopart 
 *        SLOT, the fragment group containing the dopart fragment is 
 *        the ObjectFileInfo found in (1). Given the dopart fragment and
 *        ast index, we can build the doPartInfo. If the dopart is contained
 *        directly in the same ast as the ObjectDescriptor, the fragment
 *        group is known as well. For future lookups, the doPartInfo is cached 
 *        in the doparts table in the ObjectFileInfo of the prototype.
 * 
 *     5. Subtract the M entry value from the original code address to 
 *        get the offset from the M entry. Using impAddresses of the 
 *        dopartInfo, the imperative ast index can be found in impAstRefs.
 * 
 * Locating the code address given an imperative ast index:
 * 
 *     1. The ObjectFileInfo is easily found using the groupName of the 
 *        AST containing the imperative. If it has not been fully loaded,
 *        load it and its origins.
 * 
 *     2. As the fragment is known, we can immediately select the correct
 *        FragmentInfo and scan for the ast index of the imperative in the
 *        impAstRefs repetition. This gives us the offset from the M entry
 *        point to the beginning of the code for the imperative.
 * 
 *     3. To find the M entry point, lookup the prototype in the 
 *        AstRefs repetition of the ObjectFileInfo corresponding to the 
 *        fragment containing the ObjectDescriptor.
 * 
 *     4. Adding these two numbers gives the memory address of the 
 *        imperative.
 *          
 * 
 * Locating the prototype given a T entry point. This is implemented by 
 * "utilities.ProtoAddressToPrototypeInfo".
 * 
 *     1. By using the dataStart and dataEnd attributes of 
 *        ObjectFileInfos, the correct ObjectFileInfo is easily located.
 *        Ensure that it has been fully loaded.
 * 
 *     2. The Tentry is looked up in the Tentries repetition of the 
 *        ObjectFileInfo. Using the index in Tentries, the groupsInfo
 *        table is able to locate the corresponding prototype. *)

