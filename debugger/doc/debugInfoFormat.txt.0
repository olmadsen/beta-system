
Kim og Ole.

Naerlaes (!) venligst nedenstaaende og lad mig hoere Jeres kommentarer.
Det drejer sig om ..db filer og mine kommentarer efter at have kigget dem
grundigt efter i soemmene.

Det nuvaerende format for ..db filer er beskrevet af grammatikken nedenfor.
Visse af oplysningerne er blevet overflodige efter aendringer i prototyper,
og efter tilfoejelsen af codeStart og codeEnd til data-segment headerne.

   (OLD!!!) FORMAT OF DB FILES GENERATED BY COMPILER
   =================================================

   <DBfile>                ::= <GroupInfo> 
			       <PrototypeInfo> 
			       <DopartsInfo>

   <GroupInfo>             ::= <FragmentCount> 
			       <FragmentInfoListSize> 
			       <FragmentInfoList>
			       <CodeSize>
   <FragmentInfoList>      ::* <FragmentInfo> ;
   <FragmentInfo>          ::= <FragmentName> <FragmentType>

   <ProtoTypeInfo>         ::* <AstIndexList> ;
   <AstIndexList>          ::= <AstIndices> '(short) 0'
   <AstIndices>            ::* <AstIndex> ;

   <DoPartsInfo>           ::+ <DopartsInFragmentInfo> ;
   <DopartsInFragmentInfo> ::= <DopartCount> <DopartInfoList>
   <DopartInfoList>        ::+ <DopartInfo> ;
   <DopartInfo>            ::= <AstIndex> <ImperativeInfoList> '(short) -1'
   <ImperativeInfoList>    ::+ <ImperativeInfo> ;
   <ImperativeInfo>        ::= <CodeOffset> <AstIndex>

   <FragmentCount>         ::= (short) Number of fragments in the group 
			       and the length of <FragmentInfoList>

   <FragmentInfoListSize>  ::= (long) Size in bytes of fragment names 
			       and types, i.e.\ the total size of 
			       <FragmentInfoList>

   <CodeSize>              ::= (long)  Size in bytes of code fragment 
   <FragmentName>          ::= (asciiz) Fragment name
   <FragmentType>          ::= (short)  descriptorForm, attributesForm
			       or dopartType
   <AstIndex>              ::= (short)  ast index of prototype, dopart or
			       imperative
   <DopartCount>           ::= (short) number of doparts in fragment and
			       the length of <DopartInfoList>
   <CodeOffset>            ::= (short) offset from previous imperative

Den overfloedige information er foelgende:

  1. <CodeSize> benyttes ikke
  2. <PrototypeInfo> er ikke noedvendig da den kan loades fra den debuggede
     process paa samme maade som objectbrowseren goer det.

Fjernes disse fra ..db fil grammatikken bliver den i stedet:

   (NEW!) FORMAT OF DB FILES GENERATED BY COMPILER
   ===============================================

   <DBfile>                ::= <GroupInfo> 
			       <DopartsInfo>

   <GroupInfo>             ::= <FragmentCount> 
			       <FragmentInfoListSize> 
			       <FragmentInfoList>
   <FragmentInfoList>      ::* <FragmentInfo> ;
   <FragmentInfo>          ::= <FragmentName> <FragmentType>

   <DoPartsInfo>           ::+ <DopartsInFragmentInfo> ;
   <DopartsInFragmentInfo> ::= <DopartCount> <DopartInfoList>
   <DopartInfoList>        ::+ <DopartInfo> ;
   <DopartInfo>            ::= <AstIndex> <ImperativeInfoList> '(short) -1'
   <ImperativeInfoList>    ::+ <ImperativeInfo> ;
   <ImperativeInfo>        ::= <CodeOffset> <AstIndex>

   <FragmentCount>         ::= (short) Number of fragments in the group 
			       and the length of <FragmentInfoList>

   <FragmentInfoListSize>  ::= (long) Size in bytes of fragment names 
			       and types, i.e.\ the total size of 
			       <FragmentInfoList>

   <CodeSize>              ::= (long)  Size in bytes of code fragment 
   <FragmentName>          ::= (asciiz) Fragment name
   <FragmentType>          ::= (short)  descriptorForm, attributesForm
			       or dopartType
   <AstIndex>              ::= (short)  ast index of prototype, dopart or
			       imperative
   <DopartCount>           ::= (short) number of doparts in fragment and
			       the length of <DopartInfoList>
   <CodeOffset>            ::= (short) offset from previous imperative

Det maa een af Jer (Kim eller Ole) meget gerne goere. Og fortaelle mig det
saa snart compileren er opdateret.

Endvidere har jeg naerlaest de ..db filer compileren genererer.
Resultatet er foelgende  "reverse engineering" af indholdet af
<ImperativeInfoList> i ..db grammatikken. Beskrivelsen
nedenfor er altsaa som <ImperativeInfoList> faktisk ser ud, og 
ikke noedvendigvis som den boer se ud. Rettelser og spoergsmaal 
foelger efter den reverse engineerede definition.

ImperativeInfo<imp> beskriver indholdet af ..db filen genereret
fra <imp>. Dette er nedenfor beskrevet gensidigt rekursivt
med de relevante dele af BETA grammatikken. Der benyttes
endvidere folgende notation:

    Offset<imp> betegner kode-offset'et fra den omgivende doparts
                M-entry point til *foerste* maskin-instruktion i
                koden genereret for <imp>.

    OffsetAfter<imp> betegner kode-offset'et fra den omgivende doparts
                M-entry point til foerste maskin-instruktion *efter*
                koden genereret for <imp>.

    astIndex<imp> betegner ast indexet for "imp".


Reverse engineered beskrivelse af ImperativeInfo<imp>:

   <DoPart>      ::= 'do' <Imperatives>;
   ImperativeInfo<Dopart> ::= 
        ImperativeInfo<Imperatives>
        OffsetAfter<Imperatives> astIndex<Dopart>


   <Imperatives> ::+ <ImpOpt> ';' ;
   ImperativeInfo<Imperatives> ::+ 
        ImperativeInfo<ImpOpt> astIndex<Imperatives> OffsetAfter<Imperatives>

   <ImpOpt>      ::? <Imp>;
   ImperativeInfo<ImpOpt> ::? ImperativeInfo<Imp>

   <LabelledImp> ::= <NameDcl> ':' <Imp>;
   ImperativeInfo<LabelledImp> ::= 
        Offset<LabelledImp> astIndex<LabelledImp>
        ImperativeInfo<Imp>
        OffsetAfter<LabelledImp> astIndex<Imp>

   <ForImp> ::= '(' 'for' <Index> 'repeat' <Imperatives> 'for' ')';
   ImperativeInfo<ForImp> ::=
        Offset<ForImp> astIndex<ForImp> ImperativeInfo<Imperatives>

   <SimpleIfImp> ::= 
        '(' 'if' <Evaluation> 'then' <Imperatives> <ElsePartOpt> 'if' ')';
   ImperativeInfo<SimpleIfImp> ::=
        Offset<SimpleIfImp> astIndex<SimpleIfImp> 
        ImperativeInfo<Imperatives>
        ImperativeInfo<ElsePartOpt>

   <GeneralIfImp> ::= '(' 'if' <Evaluation> <Alternatives> <ElsePartOpt> 'if' ')';
   ImperativeInfo<GeneralIfImp> ::=
        Offset<GeneralIfImp> astIndex<GeneralIfImp>
        ImperativeInfo<Alternatives>
        ImperativeInfo<ElsePartOpt>

   <Alternatives> ::+ <Alternative> ;
   ImperativeInfo<Alternatives> ::+   ImperativeInfo<Alternative>

   <Alternative> ::= <Selections> 'then' <Imperatives>;
   ImperativeInfo<Alternative>  ::=   ImperativeInfo<Imperatives>
   
   <ElsePartOpt>  ::? <ElsePart>;
   ImperativeInfo<ElsePartOpt> ::? ImperativeInfo<ElsePart>

   <ElsePart>    ::= 'else' <Imperatives>;
   ImperativeInfo<ElsePart> ::= ImperativeInfo<Imperatives>

   ImperativeInfo<LeaveImp>::= Offset<LeaveImp> astIndex<LeaveImp>
   ImperativeInfo<RestartImp>::= Offset<RestartImp> astIndex<RestartImp>
   ImperativeInfo<InnerImp> ::= Offset<InnerImp> astIndex<InnerImp>
   ImperativeInfo<SuspendImp> ::= Offset<SuspendImp> astIndex<SuspendImp>
   ImperativeInfo<Evaluation> ::= Offset<Evaluation> astIndex<Evaluation>
   
BEMAERKNINGER:

   1. For <GeneralIfImp>, <Alternative> og <SimpleIfImp> bliver der ikke genereret
      debug info for hhv. <Evaluation>, <Selections> og <Evaluation>, medmindre
      altsaa der er nestede ObjectDescriptors hvis doparts saa vil vaere beskrevet
      i en anden liste. 

      Dette har umiddelbart den ulempe at det goer det umuligt at saette 
      breakpoints paa de enkelte evalueringer i en if, og i vaerste fald 
      kan det betyde at valhalla er ude af stand til at afbilde kode-addresser 
      korrekt til astIndices!

      Derfor boer ImperativeInfo<GeneralIfImp>, ImperativeInfo<SimpleIfImp> og
      ImperativeInfo<Alternative> i stedet defineres som foelger:

	 ImperativeInfo<GeneralIfImp> ::=
	      Offset<GeneralIfImp> astIndex<GeneralIfImp>
	      ImperativeInfo<Evaluation>
	      ImperativeInfo<Alternatives>
	      ImperativeInfo<ElsePartOpt>

	 ImperativeInfo<Alternatives> ::+   ImperativeInfo<Alternative>
	 ImperativeInfo<Alternative>  ::=   
	      ImperativeInfo<Selections> ImperativeInfo<Imperatives>

	 <Selections>::+ <Selection> ;
	 ImperativeInfo<Selections>   ::+   ImperativeInfo<Selection>

	 <Selection> ::| <CaseSelection> ;
         ImperativeInfo<Selection> ::| ImperativeInfo<CaseSelection>

	 <CaseSelection> ::= '//' <evaluation>;
	 ImperativeInfo<CaseSelection> ::=   ImperativeInfo<Evaluation>

	 ImperativeInfo<SimpleIfImp> ::=
	      Offset<SimpleIfImp> astIndex<SimpleIfImp> 
	      ImperativeInfo<Evaluation>
	      ImperativeInfo<Imperatives>
	      ImperativeInfo<ElsePartOpt>


   2. DER ER EN BUG (eller inkonsistens) OMKRING IF:

      Denne bug er ikke afspejlet ovenfor, men visse if-konstruktioner 
      resulterer i en ImperativeInfo med astIndex=0.
     
      F.eks. giver foelgende if:

            (if (a=0)//TRUE then b;c if);

      Anledning til:
        
             8 astIndex<(if (a = 0) // TRUE then b; c if)>
             80 astIndex<b>
             92 astIndex<c>
             104 astIndex<b;c>
             104 0

      Hvorimod folgende

             (if (a = 0) then b; c if)

      giver:

             8 astIndex<(if (a = 0) then b; c if)>
             80 astIndex<b>
             92 astIndex<c>
             104 astIndex<b;c>

      Jeg kan ikke lige gennemskue hvilke if'er der forarsaager problemet, men
      den sidste linie skal FJERNES!
 

SPOERGSMAAL

   Offset<ForImp>: Er dette offset'et for det sted hvortil koden hopper tilbage
                   for hver iteration, eller er det offset'et for koden der 
                   initialiserer for-loekken?

   Offset<LabelledImp>: Er dette offset'et for koden der gemmer SP i det omgivende
                   objekt, eller er det offset'et for koden hvortil en "restart"
                   hopper. Jeg antager det foerste (hvis der ellers er forskel).
    
   OffsetAfter<Imperatives>: Hvad er dette? Kigger man paa de absolutte vaerdier
                   ser det ud til (paa SPARC) at vaere Offset for foerste imperativ
               	   i listen +4 !???? Hvad er logikken? Jeg kunne forstaa det hvis
                   det var OffsetAfter<det sidste imp i listen>, men det er det
                   altsaa ikke!! Dette tal kunne jeg ellers evt bruge til at saette
                   breakpoints *efter* "bodyen" af en for-loekke, men inden index
                   variablen blev talt op. Hvad det saa ellers skulle goere godt
                   for.


Jeg ved stadig ikke om code-offsets er regnet korrekt ud, og jeg ved heller
ikke lige hvordan jeg skal checke det. Men det kommer jeg vel til...

  -- Soren