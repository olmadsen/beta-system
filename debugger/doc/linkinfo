
Valhalla2 er nu efter min bedste overbevisning ved at vaere klar til
alfa test. 

Hvis I vil "se" den, kan I koere den paa enten

  ~beta/debugger/v2.0/test/codemaptest

eller

  ~beta/debugger/v2.0/test/veu

Skriv valhalla2.0 -exec <en af ovenstaaende>, og I er i luften.
Alternativt kan i skrive valhalla2.0, vaelge "New" i "Files" menuen,
og derefter aabne en af ovennaevnte executables.

Der er naturligvis stadig et antal kendte fejl og mangler,
men meget af det ligger i guienv, og en del kan sagtens vente til 
jeg har faaet nogle kommentarer fra "test-teamet".

En enkelt tilfoejelse mangler dog, nemlig som tidligere naevnt callbacks
fra runtime system til valhalla i foelgende situationer:

 a. Lige foer en component attaches. Callback'et skal inkludere
    information om PC for attach.

 b. Lige foer et C til BETA callback effektueres. Callback'et skal
    inkludere information om BETA kode-addressen som skal kaldes,
    evt. blot en struktur eller objekt reference.

Det burde dog vaere en mindre opgave, som sikkert er loest inden de
oevrige problemer naevnt nedenfor er paa plads.

Saa nu handler det altsaa om at faa den i brug. I oejeblikket findes
den kun paa sun4s, men skulle uden videre kunne oversaette paa sun4.

MEN hvis Devise folket skal bruge valhalla2, og det er jo nok det mest
naerliggende, er der nogle udestaaender som er eksterne til valhalla, og
som skal loeses. Dem jeg kan komme i tanker om er beskrevet nedenfor
(Paa engelsk. Det startede som noget der skulle med i den tekniske
dokumentation.).

Laes det venligst igennem, og tag stilling. Valhalla2 kommer ikke i brug
af andre end mig foer de er klaret.

Endvidere skal der jo nok skrives en mini-manual som folk kan bruge til
at komme i gang med.

  -- Soren



Missing aspects that should be handled before launching valhalla2 alpha test.

  1. Consistent Object and Debug info files.
  2. Turn the runtime system into a library.
  3. Semi-frosen compiler and RTS used by alpha testers.
  4. Create a new version of the distribution library.

These aspects are considered in turn below.

1. Consistent Object and Debug info files.

  Valhalla2 depends on debug info (..db) files containing information 
  needed in addition to what can be found from other sources.

  Since the current compiler (beta5.1) generates code different from the
  beta5.0 compiler used to compile MBS release 3.0, debug info files generated
  by beta5.1 are not consistent with the object files generated by beta5.0.

  Alpha testing therefore depends on a full re-codegeneration of release
  3.0. Since alpha-testing in the first place will be done by the Devise
  group at daimi, we could handle this problem in different ways:

     a. Create a release 3.01 with the only difference that it is compiled
        with the newest beta5.1. 
     b. Recompile the MBS release 3.0 installation in /users/beta with beta5.1
        and make a version of beta5.1 the default compiler for this
        installation (see section 3 and 4 for needed changes to beta5.1 before
        this is possible).

  The first solution is not recommendable since people simply do not have
  the time to move their applications to a new release. So, the second
  solution seems to be the only choice available.

  If we do not recompile, but continue using the object files compiled with
  beta5.0, valhalla2 will be working with wrong debug information, resulting
  in strange behaviour in a number of situations. I am not willing to debug
  valhalla2 under these circumstances, since a lot of possible bugs may turn
  out to be caused by debug info inconsistencies and thus debugging them 
  would be a waste of time.

  Furthermore, it would be helpful if the debug info file contained some
  information that made it possible to check that it was indeed generated
  for the object file linked into the executable being debugged. This could
  be done by putting a timestamp into the objectfile (or assembler file), and
  the same timestamp into the debug info file. Below, a new version of the 
  debug info file syntax including a timestamp field. Where to put the 
  timestamp in the objectfile is described as well.

  1.1 Timestamping of debug info files.
  
    The timestamp used could simply be the current systemtime at the
    beginning of the code-generation for some fragment group.

       T_debugstamp = systemtime at code-generation start.

    T_debugstamp should be saved in the object file. In the beginning
    of the data-segment, the BETA_data* labels are defined as follows
    (SPARC):

	.align 8
	BETA_data1:.word BETA_data1
	.word BETA_data2
	.word BETA_data3
	.word BETA_code1
	.word BETA_code2

    By extending this list with T_debugstamp, it would look as follows:

	.align 8
	BETA_data1:.word BETA_data1
	.word BETA_data2
	.word BETA_data3
	.word BETA_code1
	.word BETA_code2
        .word T_debugstamp

    Later, when unique group ID's (making it possible for distribution and
    persistence to check compatibility of databases and executables) are 
    added, it can be appended to this list.

    In the debug info file, T_debugstamp should be included as indicated
    by the following (updated) syntax:


       FORMAT OF DB FILES GENERATED BY COMPILER 
       ========================================

       <DBfile>                ::= <DebugStamp>
			           <GroupInfo> 
				   <DopartsInfo>

       <GroupInfo>             ::= <FragmentCount> 
				   <FragmentInfoListSize> 
				   <FragmentInfoList>
       <FragmentInfoList>      ::* <FragmentInfo> ;
       <FragmentInfo>          ::= <FragmentName> <FragmentType>

       <DoPartsInfo>           ::+ <DopartsInFragmentInfo> ;
       <DopartsInFragmentInfo> ::= <DopartCount> <DopartInfoList>
       <DopartInfoList>        ::+ <DopartInfo> ;
       <DopartInfo>            ::= <AstIndex> <ImperativeInfoList> '(short) -1'
       <ImperativeInfoList>    ::+ <ImperativeInfo> ;
       <ImperativeInfo>        ::= <CodeOffset> <AstIndex>

       <DebugStamp>	       ::= (long) System time when generation of this
                                   debug info file (and corresponding object
                                   file) was initiated.
       <FragmentCount>         ::= (short) Number of fragments in the group 
				   and the length of <FragmentInfoList>

       <FragmentInfoListSize>  ::= (long) Size in bytes of fragment names 
				   and types, i.e.\ the total size of 
				   <FragmentInfoList>

       <CodeSize>              ::= (long)  Size in bytes of code fragment 
       <FragmentName>          ::= (asciiz) Fragment name
       <FragmentType>          ::= (short)  descriptorForm, attributesForm
				   or dopartType
       <AstIndex>              ::= (short)  ast index of prototype, dopart or
				   imperative. For <AstIndex> in <DopartInfo>,
				   it is the ast index of the <Imperatives>
				   node inside the dopart.
       <DopartCount>           ::= (short) number of doparts in fragment and
				   the length of <DopartInfoList>
       <CodeOffset>            ::= (short) offset from previous imperative

    This approach implies that it is impossible (or very difficult) to create 
    a debug info file corresponding to a previously generated object file.
    If this is needed, the object file must be recreated too, leading to
    a re-link of the application before debugging possible. I'm not sure
    whether this is a problem, but I think that possible inconsistencies 
    between debug info and object files is a greater problem.

2. Turn the runtime system into a library.

  An application being debugged with valhalla2.0 must be linked with a version
  of the BETA runtime system compiled with the RTVALHALLA symbol defined. That
  is, an application must be linked with either:

    betarunv.o    (Normal runtime system enhanced with valhalla specifics.)
    betarun.debug (debug runtime system always includes valhalla specifics.)

  Apart from the usual betarun object files, valhalla runtime systems are 
  linked with the following (new) object files:

    betarun/C/dot.o
   
      dot.o (compiled from C/dot.c) implements the debugger object table, a
      table used by the debugger to keep track of objects when moved during
      garbage collections.

    betarun/C/valhallaComm.o

      valhallaComm.o (compiled from C/valhallaComm.c) implements communication 
      between the debugged process and valhalla itself.

    betarun/C/valhallaFIFOS.o

      valhallaFIFOS.o (compiled from C/valhallaFIFOS.c) implements a number of
      simple operations on FIFO's, used for opening, creating and closing the 
      FIFO's through which valhalla and the debugged process communicate.

    betarun/C/valhallaFindComp.o

      valhallaFindComp.o (compiled from C/valhallaFincComp.c) implements stack
      analysation.
 
   The last three object files pose no special problems, since they are only
   used for this special purpose. However, dot.o is also needed in applications
   using the distribution library, since the DOT table (see C/dot.h) is used to
   keep track of proxy objects without preventing these from being garbage
   collected.

   Thus, when linking with a runtime system including the valhalla specifics,
   the result could be multiply defined symbols, in the case of a program using
   the distribution library.

   This problem can by circumvented by changing the way the runtime system
   is linked. Instead of prelinking the runtime-system into an object-file,
   it should be linked as a library, including the 4 object files
   (dot.o,valhallaComm.o,valhallaFIFOS.o,valhallaFindComp.o). 
   By making the runtime system a library, we ensure that these files are
   only linked in when necessary, and without the compiler worrying about
   it. 

   However, turning the runtime system into a library will probably
   create problems for "NextGroup" (C/outpattern.c). The reason is
   that NextGroup requires the runtime system to be linked in last in 
   order to use the label BETA_end to recognize the end of the chain
   of BETA data segments. BETA_end is defined in C/end.c, and the
   corresponding object file, end.o, should therefore NOT be part of
   the library, but should be explicitly linked into the executable where
   betarun.o is currently linked in, i.e. at the end of the list of BETA
   object files.


3. Semi-frosen compiler used by alpha testers.

Of course a version of the compiler newer than 5.0 must be used by
alpha-testers. The version used must include the changes implied above.

That is:

  a. Timestamping of debug info files and object files.
  b. The runtime system should be a library and the end.o object file
     should be linked in immediately after BETA object files.
  c. Debug info files should be created by default. That is, option
     41 must be default.

The valhalla runtime system is based on betarun/v2.7, and thus the compiler
should link with betarun/v2.7 runtime systems. However, first the changes 
implied in the previous section should be carried out. Furthermore, at least 
one known bug in betarun/v2.7 currently exists (parameters to callback 
procedures). This bug must be corrected.

4. Create a new version of the distribution library.

  As mentioned in section 2, the distribution library is a client of the DOT
  table as is valhalla2. Unfortunately, the versions used are different and
  incompatible. The problem is that they access a single shared resource, 
  namely the DOT table scanned by the garbage collector. Thus, in order to 
  debug distributed BETA programs (e.g. the OODB and Hypermedia) with 
  valhalla2, a new version of the distribution library must be created. The 
  only difference needed is the use of a new dot.o.
