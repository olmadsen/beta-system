s> 
> 
> Jeg fix en saadan
> 
> # Beta execution aborted: Text parameter to C routine too big (max. 1000 bytes).
> # Look at 'valhalla.dump'
> 

  Den direkte aarsag til dette problem er en guienv "uhensigtmaessighed" som
  nu er blevet rettet. Den indirekte aarsag er formentlig at du har forsoegt
  at vise en kaempe char repetition. Jeg skal paa passende vis have sikret
  at der er en oevre graense for hvor meget valhalla forsoeger at vise ad gangen 
  paa een linie i en scroll list. Man kunne maaske forestille sig at afhjaelpe
  problemet ved at tillade at der simpelthen aabnes en text editor paa text
  objekter. Er paa (den lange) liste.

Det boer vaere muligt at saette breakpoints selvom der ikke er nogen
process.

Step into komplicerede enter/exit parts.

Haandtering af objekt attributter allokeret til for-loekker og labelled
imps... Findes ved at scanne doparten.

getReturnAddress boer fejle hvis retur-addressen ligger i Attach
runtime rutinen. Dette tilfaelde fanges i stedet af Attach callbacks.

Der er ikke noget der forhindrer browsing i object views selvom processen koerer.
Dette skal indfoeres paa passende vis.

Kan man eksplicit saette target til en editor?? Problemet er at codeviews
ikke faar tastetryk selvom musen er over dem. Det er ski'e traels.

Hvorfor bipper editoren hver gang en tast trykkes ned? Kan det laves om? (Det har
formentlig at goere med at editering ikke tillades, men jeg benytter selv
taste-trykkene, og er ikke interesseret i at der bippes.

Problematisk markering af stop sted naar der er tale om enden af en Imperatives
list. I saa fald selekteres hele Imperatives listen, hvilket er saerdeles
forvirrende. Hvordan/hvad selekteres noget fornuftigt for at vise dette?

Overvej at gemme codeviews mens de updates. Det ser dumt ud med den sorte
selektion...

codeviewere har en reference til debuggee. Af den grund skal man huske at
lukke codeviewere hvis der skiftes til en ny debuggee. Det kan ske enten
ved at man eksplicit aabner en ny debuggee, eller der laves rerun. I sidste
tilfaelde skulle codeviewere gerne gen-aabnes, men med nye AST'er.
Hvad med breakpoints i den situation? Alternativt kunne man soerge for at codeviewere
_ikke_ havde en ref til debugge. Det skulle ikke vaere saa svaert at undgaa hvis 
"encloserType" udvides passende...

Mangler debug information paa <ForImp>.<Index> (Compiler)

dopart objekter. Ok, men object-viewere har indtil videre ikke styr paa dem!!

textField.defaultStyle er ikke implementeret (returnerer NONE)

guienv.window: Hvordan 

  -- afgoeres om et vindue er ikoniseret
  -- aabnes et ikoniseret vindue
  -- aendres ikonet anvendt af window manageren

Er det muligt at faa et callback naar en menu poppes ned?

GUIENV mangler:

  1. Keyboard acceleratorer er meget ustabile. I mange tilfaelde hjaelper 
     det hvis man lige popper den relaterede menu op, og derefter popper 
     den ned igen.
      
  3. En BringBack paa window items.

  4. Naar textScrollList.mouseDown kaldes, er selection.first endnu ikke sat.
     Det er altsaa ikke muligt at udfoere noget selektions-specifikt paa
     andet end dobbelt-click eller mouseUp.

Noget doer med "reference is NONE" hvis betaObjectObjectDescriptor returnerer
NONE. Der skal i stedet rejses en exception om at man ikke kender typen
af et givet objekt.

  1. betaObject.description skriver nu "UNKNOWN" hvis 
     betaObjectObjectDescriptor fejler.

  2. Et ObjectView skal aendres saa det viser noget low-level
     information hvis et objekts type ikke er kendt. Dette kan fx.
     goeres ved at bede objektet beskrive sig selv via et "scanLowLevelDesc"
     interface. Evt. kan hver low-level linie forbindes med en "onSelect"
     action, saa det kan tillades at dobbelt-clicke ogsaa paa saadanne
     linier og faa mere info. Dette low-level view kan ogsaa bruges som
     "alternativt view" paa et objekt, der angiver addresse, hvor objektet
     "bor" (AOA eller IOA), prototype addresse i low-level termer, navnet
     paa gruppen som prototypen stammer fra, prototype nummer i denne 
     gruppe, T label for prototypen, objektets stoerrelse i bytes, ...

Dialog til indstilling af preferencer (i stedet for nuvaerende menu).

Keyboard aekvivalenter paa "Go Back", "Close", ... i objekt viewere.

DisplayBetaStack i outpattern.c skal kalde valhalla funktion der skal afgoere
hvad der skal ske:

  1. Hvis processen allerede debugges skal der kommunikeres med valhalla.
  2. Hvis processen ikke debugges skal brugeren spoerges om valhalla skal
     startes og/eller kontaktes.


   >
   >
   > Er det helt umuligt for Valhalla, at kunne udpege denne reference ?
   > Det ville v{re en utrolig rar facilitet.
   >
   > --- jlk
   >

   Skal spoergsmaalet forstaas saadan at du i generel forstand vil have
   valhalla til at udpege hvilken reference attribut der var NONE?

   I saa fald er svaret nok noget i stil med *naesten*.

   Naar der opstaar en "Reference is NONE" fejl er PC og current object
   de eneste oplysninger valhalla har at arbejde med. Man kunne saa godt
   forestille sig at den scannede det fejlende imperativ for at lokalisere
   "remote"'s paa dynamiske referencer, og derefter checkede vaerdien af
   disse referencer. Hvis een af dem var NONE (der kan jo vaere nogen stykker)
   kunne den jo foreslaas som synderen.

   Men der er jo lige en del tilfaelde at tage hoejde for... De fleste kan
   klares med en fortolkning af expressions, men generelt computed remote er
   nok ikke lige inden for raekkevidde.

   OLE: Kan der siges noget om implementationen af Computed Remote der goer
   at det maaske alligevel er muligt?

   Saa vi kommer nok ikke naermere end en 90% loesning. Det er jo som regel
   ogsaa godt nok.


guienv.questions (fra ~debugger/v2.0/test):


Advarsel: Under motif skal man i visse situationer huske at appende et
          menuitem til sin menu inden man forsoeger at saette navnet
          paa dette menuitem. Vist nok isaer hvis menuen har vaeret clearet,
          og man derefter appender nye menuitems til den.

Mangel: system.wait er ikke implementeret. Jeg skal bruge den til noget
        visuelt feedback!!! Indtil videre bruger jeg sleep fra unixinterface,
        men det holder jo ikke i laengden.

Fejl:  Naar textscrolllist.singleSelection har vaeret sat til FALSE, og
       derefter saettes tilbage til TRUE, vil hvert andet click paa en
       indgang vaelge og hvert andet click afvaelge denne indgang.
       Dette er ikke tilfaeldet foer singleSelection har vaeret
       aendret. Det giver anledning at der til tider ikke er nogen selection
       under haandtering af dobbelt-click.


From Ole.Madsen@eng.sun.com Sun Feb 26 20:30:28 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA19807
  (5.67b8/IDA-1.5); Sun, 26 Feb 1995 20:30:04 +0100
Received: from Eng.Sun.COM (engmail2.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA02024; Sun, 26 Feb 95 11:29:05 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (5.x/SMI-5.3)
	id AA02468; Sun, 26 Feb 1995 11:29:02 -0800
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA27175; Sun, 26 Feb 1995 11:29:02 +0800
Date: Sun, 26 Feb 1995 11:29:02 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9502261929.AA27175@det.Eng.Sun.COM>
To: datpete@mjolner.dk, ess@daimi.aau.dk, jacobse@daimi.aau.dk,
        jlk@daimi.aau.dk, kjm@mjolner.dk, Ole.Madsen@eng.sun.com,
        pjs@mjolner.dk, pryberg@mjolner.dk, sbrandt@daimi.aau.dk
Subject: Memory leak experience
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

							Palo Alto  Feb. 1995
Experience from finding a memory leak:-(
----------------------------------------

Folks

Here is a description of the technique I used to find the compiler
memory leak, and some suggestions for new routines/new fragment and
changes in sysutils.

It was a real pain searching for this bug and I really think that we
need support for this in Valhalla. I am aware that there is no time
for this currently, but put it on the list!  Even with Valhalla
support, it might be useful to have heap analysis fragment.


1. Suggestions for improvements to printobject

   * should print the head-object for components also

   * for each printed object print its memory address

   * for each dynamic reference : s ^T, print the memory address
     of the object being referred.

   * For each part-object print its memory addres or offset

   This will make it easier to find out which references that refer
   a given object. 

   The printing of addresses could be controlled by a boolean.

   Print object should still print the whole object on one line,
   since this will make it easier to use grep for extracting
   interessant stuff.

2. Add the pattern GetLoc (see below) to objinterface

3. Perhaps add patterns like HasRefToObj

4. Perhaps the pattern collector

5. Perhaps some of these 'memory-leak' patterns should be in a special
   file in sysutils. This file could then also include 
   the pattern EmptyHeaps. It would of course be better with a direct
   call to som GC routine, but in lack of this EmptyHeaps  is better
   than nothing.

6. An operation  'scanroots' that scan all roots to the various heaps

7. An operation 'scanRootChain' that gives all paths (modulos cycles)
   from a root to a given object.

8. It is a problem sometimes (often) to use scanaoa on selected objects
   since it may not be possible to denote the pattern of the
   critical object for qualifying 'root' in scanaoa. A critical object
   is one that survyes the GCs for some reason.

   To handle such situations one might insert a pattern like the following
   in a critical object:

      criticalObj:
           (#	 ...
              dumpy: trueObject
                (#
                do '------------CriticalObj:'->putLine;
		   (* code for printing stuff from criticalObject *)
                #);
               dum: ^dumpy;
            do &dumpy[]->dum[]; 
               ...
            #)

   If CriticalObj does not have a do-part, it is usually possible to
   insert the generation of 'dumpy' at another place.

   One may now use scanaoa to get a callback on 'trueObject'. And then
   execute such objects. This will then print the stuff specified in
   the do-part of dumpy.

   The choice of 'trueObject' as a super-pattern is of course arbitrary.
   It was choosen, since it is available, visible everywhere and
   normally not used.

   There could of course be a special pattern for this in a possible
   heap analysis fragment.


I enclose the fragment I used in the compiler. It was inserted in a slot
at the end of the do-part of pattern control in control.bet.

---olm

ORIGIN 'controlbody';
INCLUDE 'itemevval';
INCLUDE 'docheck';
INCLUDE 'check';
INCLUDE 'sematt';
INCLUDE '~beta/sysutils/v1.4.1/objinterface';
INCLUDE '~beta/sysutils/v1.4.1/scanobjects';
INCLUDE 'machinebody'

---analyzeHeap:descriptor--
(#   
   EmptyHeaps:
     (* execution of this pattern will trigger a number
      * of IOA,AOA and LVAR garbage collections. This
      * implies that all live objects before this call
      * will be moved to AOA, just as all dead objects will
      * be removed from AOA/IOA/LVRA
      *)
     (# AbeKat: 
          (# q,w,e,r,t,y,u,i,o,p,a,s,d,f,g,h,j,k: @real; 
             next: ^AbeKat;
             new:
               (# n: @integer; 
               enter n
               do (if n>0 then
                      &Abekat[]->next[];
                      n-1->next.new
               if)#);
          #);
        Hest: (# Fisk: [50000] @integer #);
        head: ^abeKat
     do '\n\n*******Empty heaps:'->putLine;
        (for i: 10 repeat
             &AbeKat[]->head[];
             5000->head.new;
             &Hest
        for);
     #);
   GetLoc: 
     (* returns a reference to the location of obj.
      * Location is defined for part objects and none for
      * other objects. In
      *    A: (# ...; X: @T  ... #)
      *    X[]->GetLoc->s[]
      * will return the address of the enclosing A-object
      *)
     (# obj,loc: ^object;
        adrToObj: @addressToObject;
        adr,gcf: @integer;
        getGCF: @getGCfield;
     enter obj[]
     do none->loc[];
        (if obj[]->isComponent then 'isComponent'->putline 
         else
            obj[]->getGCF->gcf; (*the gc-field=location offset*)
            (if gcf < 0 (* ? *) then
                gcf*4->gcf;     (* convert to byte-offset *)
                @@obj->tos'%AdrGetLong'->adr; (*adr of object referred by obj*)
                adr+gcf -> adrToObj->loc[];  (*location of obj*)
        if)if)
     exit loc[]
     #);
   PrintThisAndLocs:
     (* exit ref to top loc *)
     (# obj,loc: ^object
     enter obj[]
     do obj[]->loc[];
        L:
          (if loc[]<>none then
              loc[]->obj[];
              (obj[],none)->printObject;
              obj[]->getLoc->loc[];
              restart L
          if)
     exit obj[]
     #);
   Collector:
     (#
        collect:
          (# f: ##object
          enter F##
          do scanaoa
             (# callback::
                  (#
                  do (if (XXtop+1->XXtop) <=XX.range then 
                         obj[]->XX[XXtop][]
                      else
                         'XX overflow' -> putLine
                  if)#)
             do F##->root##
          #)#);
        XX: [1000] ^object; XXtop: @integer;
        printCollect:
          (#
          do scanaoa
             (# callBack::
                  (#
                  do (for i: XXtop repeat
                          (XX[i][],obj[])->hasRefToObject;
          for)#)#)#);
     #);
   col: @collector;
   HasRefToObject:
     (# obj,s,ref: ^object;
        P: @prototype;
        GP: @getProtoType;
        putT: @screen.puttext;
        putI: @screen.putInt;
        a2r: @addressToObject;
     enter(obj[],s[])
     do 
        (if s[]<>none then
            s[]->GP->P;
            P.scanRefs
            (#
            do (if not isStatic then
                   (@@s->TOS'%AdrGetLong')+thisOffset
                     ->TOS'%AdrGetLong'->a2r->ref[];
                   (if ref[]=obj[] then
                       '++++++++++++++++'->putLine;
                       (obj[],none)->printObject;
                       (if obj## = ast.index## then
                           (obj[],screen[],12)->thePP;
                       if);
                       'Ref at: '->putT; thisOffSet->putI; 
                       ' in: '->putT; 
                       (s[],none)->printObject;
                       s[]->save2[save2top+1->save2top][]
                   if)
               if)
        #)if)
     #);
   save2: [1000] ^object; save2Top: @integer
     
do (if switch[291] then EmptyHeaps if);
   (if switch[292] then 
       '\n\n********Heap content:\n'->putline;
       scanAOA(#do true->printVisited->printSize->printOrigin; #);
       (* ---not implemented 
        * scanLVRA(#do true->printVisited->printSize->printOrigin #);
        *)
   if);
   (if switch[293] then
       '\n\n*****Print selected objects'->putline;
       (if true then
           scanaoa
           (# callBack::<
                (# t: ^ trueObject
                do obj[]->t[];
                   t;
                #);
           do trueObject##->root##;
           #);
       if);
       'index'->putLine;
       AST.index##->col.collect;
       'SuperChain'->putline;
       sematt.BV.superChain##->col.collect;
       col.printCollect
   if)
#)

