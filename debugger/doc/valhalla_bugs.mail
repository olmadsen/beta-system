From sbrandt@daimi.aau.dk Fri Jun  2 10:09:40 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA01360
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Fri, 2 Jun 1995 10:09:39 +0200
Received: (from sbrandt@localhost) by quercus.daimi.aau.dk (8.6.11/8.6.11) id KAA10641; Fri, 2 Jun 1995 10:09:27 +0200
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199506020809.KAA10641@quercus.daimi.aau.dk>
Subject: Re: ..db fejl -- ikke eksisterende ast indices
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Fri, 2 Jun 1995 10:09:26 +0200 (MET DST)
Cc: kjm@daimi.aau.dk, ole.madsen@eng.sun.com, sbrandt@daimi.aau.dk,
        datpete@mjolner.dk
In-Reply-To: <9506020624.AA18816@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Jun 1, 95 11:24:05 pm
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 6655      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


Jeg har ikke set den fornylig, men jeg synes ikke du skal fjerne den helt
fra listen. Kun suspendere :-)

Omvendt er det netop ved step at valhalla2.0 er mest ustabil, og jeg er 
ikke klar over om noget af det kan skyldes nedennaevnte problem. Folk er
generelt for daarlige til at give fejlbeskeder/beskrivelser. Men det ved
du jo alt om...  :-)

  -- Soren

> 
> Soeren
> 
> Har du fornylig har problemet, som beskrevet i vedlagte mail?
> SOm tidligere sagt har jeg ikke kunnet finde en fejl
> eller reproducere den.
> Hvis du ikke har haft probmelet i den senere tid, vil jeg
> fjeren den fra listen og afvente at den dukker op igen.
> 
> ---olm
> 
> > From sbrandt@daimi.aau.dk Thu Jan 19 07:24 PST 1995
> > Subject: ..db fejl -- ikke eksisterende ast indices
> > To: kjm@daimi.aau.dk (Kim Jensen M|ller), ole.madsen@Eng (Ole Lehrmann Madsen),
> >         sbrandt@daimi.aau.dk (S|ren Brandt)
> > Date: Thu, 19 Jan 1995 16:23:27 +0100 (MET)
> > 
> > 
> > Foelgende dopart stammer fra ~beta/guienv/v1.2/private/X11/guienv_unixbody.bet,
> > fragmentet "--- GUIENVdoSetUp: descriptor ---".
> > 
> > ============================================================================
> >     do inittickcount;
> >        private.theXtlib.init;
> >        initAppName;
> >        initAppClass;
> >        private.fallBackResources.init;
> >        private.options.init;
> >        &deviceInfo[] -> private.theDeviceInfo[] -> objectPool.put;
> >        XtToolkitInitialize;
> >        XtCreateApplicationContext -> private.appCon;
> >        (private.appCon,private.fallBackResources.address) -> XtAppSetFallbackResources;
> >        (private.appCon,0,
> >        private.appName,private.appClass,private.options[],0,getargc,getargv) 
> > 	 -> XtOpenDisplay -> private.display;
> >        (if private.display//0 then
> > 	   'Cannot open display' -> putLine;
> > 	   stop;
> > 	else
> > 	   private.display -> private.theDeviceInfo.init;
> > 	   initCursors;
> > 	   initBitmaps;
> > 	   initMenubar;
> > 	   initDeviceInfo; (* bifrost *)
> > 	   initBifrost; (* bifrost *)
> > 	   (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
> > 	   true -> setupDone;
> > 	   (* private.handleIdle.add; *)
> >        if);
> > ===========================================================================
> > 
> > Debug info genereret for denne dopart er:
> > 
> > ===========================================================================
> >       dopart <AstIndex>: 6516
> >              (8,6512)  inittickcount
> >              (40,6556)  private.theXtlib.init
> >              (76,6572)  initAppName
> >              (100,6588)  initAppClass
> >              (124,6632)  private.fallBackResources.init
> >              (168,6674)  private.options.init
> >              (228,6764)  &deviceInfo[]->private.theDeviceInfo[]->objectPool.put
> >              (392,6780)  XtToolkitInitialize
> >              (416,6834)  XtCreateApplicationContext->private.appCon
> >              (508,6938)  (private.appCon,private.fallBackResources.address)->XtAppSetFallbackResources
> >              (668,7168)  (private.appCon,0,private.appName,private.appClass,private.options[],0,getargc, getargv)->XtOpenDisplay->private.display
> >              (1280,7500)               
> >              (1296,7206)  0
> >              (1308,7238)  'Cannot open display'->putLine
> >              (1360,7252)  stop
> >              (1396,7240)  'Cannot open display'->putLine; stop;
> >              (1404,7336)  private.display->private.theDeviceInfo.init
> >              (1480,7352)  initCursors
> >              (1504,7368)  initBitmaps
> >              (1528,7384)  initMenubar
> >              (1552,7402)  initDeviceInfo
> >              (1576,7418)  initBifrost
> >              (1600,7452)  true->setupDone
> >              (1616,7492)              
> >              (1652,7338)  private.display->private.theDeviceInfo.init;initCursors;initBitmaps;initMenubar;initDeviceInfo;(*)initBifrost;(*)(*)true->setupDone;(*)
> >              (1652,6516)  inittickcount;private.theXtlib.init;initAppName;initAppClass;private.fallBackResources.init;private.options.init;&deviceInfo[]->private.theDeviceInfo[]->objectPool.put;XtToolkitInitialize;XtCreateApplicationContext->private.app> Con;(private.appCon,private.fallBackResources.address)->XtAppSetFallbackResources;(private.appCon,0,private.appName,private.appClass,private.options[],0,getargc, getargv)->XtOpenDisplay->private.display;(if private.display // 0 then 'Cannot open display'-> >putLine; stop; else    private.display->private.theDeviceInfo.init;    initCursors;    initBitmaps;    initMenubar;    initDeviceInfo;    (*)    initBifrost;    (*)    (*)    true->setupDone;    (*)if);
> >              Endmarker: 65535
> > ===========================================================================
> > 
> > Bemaerk de 2 linier begyndende med "(1280,7500)" og "(1616,7492)". Ifoelge
> > mine beregninger burde foerstnaevnte vaere (kode-offset for "if"-en, ast-index
> > for if'en). Sidstnaevnte burde slet ikke vaere der.
> > 
> > Det rigtig morsomme er, at der tilsyneladende slet ikke er nogen ast-knuder
> > med index 7500 eller 7492. Naar der altsaa ikke staar noget pretty-print bag
> > de fejlagtige linier, er det fordi jeg eksplicit undlader at prettyprinte
> > disse indices. Hvis jeg goer det alligevel, faar jeg en "error in indexToNode,
> > yggdrasil stops, bla bla bla" fejl.
> > 
> > Linien der ikke burde vaere der (7492) skyldes maaske en fejl lignende en jeg
> > tidligere har rapporteret, og som Ole mente var rettet. Den oprindelige
> > fejl-meddelelse foelger nedenfor.
> > 
> >   -- Soren
> > 
> > 
> > 
> > >    2. DER ER EN BUG (eller inkonsistens) OMKRING IF:
> > > 
> > >       Denne bug er ikke afspejlet ovenfor, men visse if-konstruktioner 
> > >       resulterer i en ImperativeInfo med astIndex=0.
> > >      
> > >       F.eks. giver foelgende if:
> > > 
> > >             (if (a=0)//TRUE then b;c if);
> > > 
> > >       Anledning til:
> > >         
> > >              8 astIndex<(if (a = 0) // TRUE then b; c if)>
> > >              80 astIndex<b>
> > >              92 astIndex<c>
> > >              104 astIndex<b;c>
> > >              104 0
> > > 
> > >       Hvorimod folgende
> > > 
> > >              (if (a = 0) then b; c if)
> > > 
> > >       giver:
> > > 
> > >              8 astIndex<(if (a = 0) then b; c if)>
> > >              80 astIndex<b>
> > >              92 astIndex<c>
> > >              104 astIndex<b;c>
> > > 
> > >       Jeg kan ikke lige gennemskue hvilke if'er der forarsaager problemet, men
> > >       den sidste linie skal FJERNES!
> > > 
> > > 
> > 
> > 
> 


From sbrandt@daimi.aau.dk Fri Jun  2 10:06:33 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA01318
  (5.67b8/IDA-1.5); Fri, 2 Jun 1995 10:06:27 +0200
Received: (from sbrandt@localhost) by quercus.daimi.aau.dk (8.6.11/8.6.11) id KAA10562; Fri, 2 Jun 1995 10:06:17 +0200
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199506020806.KAA10562@quercus.daimi.aau.dk>
Subject: Re: valhalla og callback funktioner
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Fri, 2 Jun 1995 10:06:16 +0200 (MET DST)
Cc: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk, datpete@daimi.aau.dk,
        kjm@daimi.aau.dk
In-Reply-To: <9506020629.AA18909@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Jun 1, 95 11:29:43 pm
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 12986     
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

> 
> Blot for at minde folk om, nu da Soerens afrejse nermer sig,
> at vi har en uafklaret problem som beskrevet i flg mail.
> Jeg har ikke haft tid til at goere noget ved det.
> Jeg ved ikke hvor presserede man opfatter det!
> 
> Men rette vedkommende boer gemme det paa sin todo-liste:-)
> 
> ---olm

Det er tilsyneladende ikke en fejl andre er stoedt ind i endnu, saa jeg
vil mene at den har relativt lav prioritet. Men den skal selvfoelgelig
rettes en dag.

MEN: Alexander er loebet ind i en valhalla2.0 fejl som formentlig skyldes
fejlagtig ..db information. Jeg har ikke selv tid til at kigge paa det.

Peter: Den "farlige" dopart er i ~beta/query/v0.2/private/databody.bet, og
       er dopart i patternet getSetValueToFromText. Valhalla rammer ganske
       forkert naar den skal mappe kode-adresser til imperativer, hvilket
       formentlig skyldes fejlagtig ..db information.

       ..db information kan checkes med foelgende haandtag:

          1. Generer den formastelige ..gs fil med option 498.
          2. Koer "~beta/debugger/v2.0/test/readdbfile". Denne tager
             foelgende parametre:
 
                 readdbfile <..db filename> <.ast filename> <pplevel>

             og udskriver paa standard out. Resultatet er en udskrift af 
             informationen i ..db filen, inclusive prettyprint af imperativer.
             <.ast filename> skal vaere uden extension. pplevel gives til
             prettyprinteren. En fornuftig vaerdi er som regel et sted mellem
             4 og 6. -1 printer i bund, men giver ogsaa alt for meget output.
       
       Givet 498 ..gs filen kan man saa med stor underholdningsvaerdi 
       gennemgaa om ..db offsets er korrekte.

       ..db fil formatet er beskrevet i pinlig detalje i 
                ~beta/debugger/v2.0/doc/debugInfoFormat.txt

       Du skal nok lige synkronisere med Alexandre inden du kigger i hans kode.

  -- Soren

> 
> >From sbrandt@daimi.aau.dk Fri Jan 20 00:42 PST 1995
> Subject: Re: valhalla og callback funktioner
> To: Ole.Madsen@Eng (Ole Lehrmann Madsen)
> Date: Fri, 20 Jan 1995 09:41:45 +0100 (MET)
> Cc: ole.madsen@Eng, kjm@daimi.aau.dk, sbrandt@daimi.aau.dk,
>         datpete@daimi.aau.dk
> 
>  > 
> > Jeg forstaar simplet hen ikke hvad det er du mener her???
> 
> Ok. Naar man fra C kalder funktionen foo, bliver koden efter
> "foo" entry pointet udfoert via CBFA. foo piller saa parametre
> af stakken og kalder defefter M1PROGRAM. Altsaa ser returaddresserne
> paa stakken nu (ca) ud som foelger (voksende nedefra og op):
> 
>    foo+64
>    <<Et eller andet i CBFA>>
>    <<C kode>>
> 
> Naar valhalla analyserer denne stak, vil foo+64 blive fortolket som
> BETA kode, eftersom det jo faktisk befinder sig i kode-segmentet
> hoerende til en BETA gruppe. Det "logiske" valg ville nu vaere
> hvis valhalla kunne vise denne returadresse som svarende til
> "cExternalEntry" imperativet, da det jo faktisk er det der er
> tilfaeldet.
> 
> Men som ..db filen genereres nu, mapper valhalla "foo+64" til det
> imperativ i doparten svarende til M1PROGRAM, som har det stoerste
> kodeoffset. Maaden dette kommer frem paa, er foelgende:
> 
>   1. Foerst lokaliseres det stoerste M (eller G) entry point som er 
>      mindre end "foo+64". I dit eksempel M1PROGRAM. 
> 
>   2. Find frem til  ..db informationerne svarende til dette M1PROGRRAM.
> 
>   3. Find det stoerste offset i doparten svarende til M1PROGRAM som er
>      mindre end "foo+64-M1PROGRAM". Det tilhoerende ast index udpeger
>      saa det soegte BETA imperativ.
> 
> Men det er jo netop det "sidste" imperativ i M1PROGRAM, og ikke
> "cExternalEntry" imperativet.
> 
> Problemet kan loeses paa 2 maader. 
> 
>   1. Den jeg kunne komme i tanker om i gaar, nemlig at lade ..db
>      kodeoffsettet for cExternalEntry vaere (foo-M1PROGRAM). Lige nu
>      er kode-offsettet 8, hvilket er det samme som for "(a+b)->c".
>      Altsaa en flertydighed som risikerer at resultere i at koden
>      svarende til "(a+b)->c" mappes til ast indexet angivet for
>      "cExternalEntry".
> 
>   2. Generere en indgang i ..db filen naar foo entry pointet genereres.
>      Denne indgang skal indeholde (foo-M1PROGRAM,astindex(cExternalEntry)).
>      Naar foo entry pointet genereres burde disse oplysninger vaere
>      tilgangelige.
> 
> Jeg vil foreslaa metode 2, som sikkert er lettest at haandtere.
> 
> Endelig vil jeg godt have at du helt fjerner ..db indgange for imperativer 
> der ikke genereres kode for, da disse resulterer i flere muligheder naar
> et kode-offset skal mappes til det tilsvarende imperativ. Mere generelt
> boer det sikres, at der for samme dopart ikke findes 2 ens kode-offsets
> med forskellige ast indices.
> 
> Ioevrigt forstaar jeg ikke 498 outputtet. Udpluk:
>    
>      > M2PROGRAM:	mov	%i1,%o0
>      > 	save	%sp,-64,%sp
>      > .L5:
>      > !  8,8  <=========================
>      > .stabn 68,0,69,.L6
>      > .L6:
>      > !  cExternalEntry  
>      > !  8,0 <=========================
>      > .stabn 68,0,95,.L7
>      > .L7:
>      > !  a+b->c  
>      > 	ld	[%i0+412],%l0
>      > !12
>      > 	ld	[%i0+416],%l7
>      > !16
>      > 	add	%l7,%l0,%l0
>      > !20
>      > 	st	%l0,[%i0+420]
>      > !24
>      > !  24,16 <=========================
> 
> Jeg antager at linierne !x afsloerer hvor din taeller er kommet til. Men
> hvad betyder y'et i linier af formen "!  x,y"? Laengden af den genererede
> kode?
> 
>   -- Soren
> 
> > 
> > Hwer er et eksempel med callBack
> > 
> > origin 'tstenv'
> > ---program:descriptor---
> > (# foo: External
> >      (# a,b,c: @integer
> >      enter(a,b,c)
> >      do cExternalEntry;
> >         a+b->c; 
> >         a*c->c
> >      exit c
> >      #);
> >    v: @integer
> > do 
> > #)
> > >
> > Med kode (498:-)
> > 
> > .global G1PROGRAM
> > G1PROGRAM:!  foo: External
> > !  v: @integer  
> > 	nop
> > !28
> > 	retl
> > 	nop
> > .global M1PROGRAM
> > M1PROGRAM:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > .L3:
> > !  8,8
> > .stabn 68,0,0,.L4
> > .L4:
> > 	ret
> > 	restore
> > .stabs "PROGRAM",38,0,134,T2PROGRAM
> > .global G2PROGRAM
> > G2PROGRAM:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > !  a,b,c: @integer  
> > 	ret
> > 	restore
> > .global M2PROGRAM<<<<<<<<<<<<<<<<<<<<< do-del af M-entrypoint for foo
> > 			<<<<<<<<<<<<<<< Er dette ikke OK?
> > 			<<<<<<<<<<<<<<< du skriver at det er forkert
> > M2PROGRAM:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > .L5:
> > !  8,8
> > .stabn 68,0,69,.L6
> > .L6:
> > !  cExternalEntry  
> > !  8,0
> > .stabn 68,0,95,.L7
> > .L7:
> > !  a+b->c  
> > 	ld	[%i0+412],%l0
> > !12
> > 	ld	[%i0+416],%l7
> > !16
> > 	add	%l7,%l0,%l0
> > !20
> > 	st	%l0,[%i0+420]
> > !24
> > !  24,16
> > .stabn 68,0,119,.L8
> > .L8:
> > !  a*c->c  
> > 	ld	[%i0+420],%l0
> > !28
> > 	ld	[%i0+412],%o0
> > !32
> > 	mov	%l0,%o1
> > !36
> > 	set	0,%i3
> > 	set	0,%i4
> > 	call	.mul
> > !48
> > 	set	0,%i2
> > 	mov	%o0,%l0
> 
> > 	st	%l0,[%i0+420]
> > !60
> > !  60,36
> > .stabn 68,0,0,.L9
> > .L9:
> > 	ret
> > 	restore
> > .global foo<<<<<<<<<<<<<<<<<<<<<<<<<<< foo-entry point
> >             <<<<<<<<<<< Det gir klart INGEN mening!!, da talleren
> > 			blot fortsetter som efter den forrige
> > 			Jeg kan her let cleare taelleren
> > 			saa de flg instruktioner blir relative
> > 			til foo, men det er ikk det du ber om?
> > ---olm
> > 
> > foo:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > 	mov	%i0,%o0
> > 	mov	%i1,%l0
> > !84
> > 	mov	%i2,%l1
> > !88
> > 	set	0,%i2
> > !92
> > 	mov	%i3,%l2
> > !96
> > 	set	0,%i3
> > !100
> > 	mov	%i0,%i1
> > !  Get long
> > 	mov	%l0,%l3
> > !108
> > 	st	%l3,[%i1+412]
> > !112
> > !  Get long
> > 	mov	%l1,%l0
> > !116
> > 	st	%l0,[%i1+416]
> > !120
> > !  Get long
> > 	mov	%l2,%l0
> > !124
> > 	st	%l0,[%i1+420]
> > !128
> > 	call	M2PROGRAM
> > !132
> > 	nop
> > 	ld	[%i1+420],%l0
> > !140
> > 	mov	%l0,%i0
> > 	ret
> > 	restore
> > BETA_code2:	nop
> > .data
> > BETA_data2:.word 2
> > .global T1PROGRAM
> > .word T1PROGRAM
> > .global T2PROGRAM
> > .word T2PROGRAM
> > .asciz "/home/olm/beta/system/v5.1/TST/zcallback"
> > .align 4
> > .word Return
> > .word M1PROGRAM
> > T1PROGRAM:.half 20
> > .half 2
> > .word G1PROGRAM
> > .word T27ENV
> > .half 4
> > .half 0
> > .half 1
> > .half 163
> > .half 0
> > .half 10
> > .half 0
> > .asciz "PROGRAM-~"
> > .align 4
> > .word Return
> > .word M2PROGRAM
> > T2PROGRAM:.half 24
> > .half 2
> > .word G2PROGRAM
> > .word T27ENV
> > .half 106
> > .half 0
> > .half 1
> > .half 134
> > .word foo
> > .half 0
> > .half 10
> > .half 0
> > .asciz "foo#"
> > .align 4
> > BETA_data3:!    
> > 
> > > 
> > > Betragt foelgende kode segment fra ~beta/guienv/v1.2/private/X11/widgetbody:
> > > 
> > >     -- GUIENVcallbackSelectorAdd: descriptor --
> > >     (# callCallbackSelector: external
> > > 	 (# w,client_data,call_data: @integer;
> > > 	 enter (w,client_data,call_data)
> > > 	 do cExternalEntry;
> > > 	    call_data -> data.ptr;
> > > 	    (if XsystemEnvPresent//true then
> > > 		this(callbackSelector)[] -> XsystemEnvHandleCallback;
> > > 	     else
> > > 		this(callbackSelector);
> > > 	    if);
> > > 	 #);
> > >        t: @text;
> > >     do (widgetID,name,callCallbackSelector##,0) -> XtAddCallback;
> > >     #)
> > > 
> > > Genereret kode foelger i bunden af denne mail. 
> > > 
> > > cExternalEntry's resulterer i genereringen af et entry point som foerst 
> > > piller C parametre af stakken, og derefter kalder det tilsvarende BETA 
> > > entry point.
> > > 
> > > For doparten i "callCallbackSelector: external" genereres foelgende ..db info.
> > > (x,y) betyder her ("codeoffset fra start a Mentry",ast index). Det tilsvarende
> > > imperativ er derefter pretty-printet.
> > > 
> > >       dopart <AstIndex>: 156
> > >              (8,152)  cExternalEntry
> > >              (8,200)  call_data->data.ptr
> > >              (32,318)  (if XsystemEnvPresent // true then <<AssignmentEvaluation>>; else THIS(callbackSelector);if)
> > >              (56,230)  true
> > >              (68,282)  THIS(callbackSelector)[]->XsystemEnvHandleCallback
> > >              (168,284)  THIS(callbackSelector)[]->XsystemEnvHandleCallback;
> > >              (176,308)  THIS(callbackSelector)
> > >              (200,312)  THIS(callbackSelector);
> > >              (200,156)  cExternalEntry;call_data->data.ptr;(if XsystemEnvPresent // true then <<Imperatives>> else THIS(callbackSelector);if);
> > >              Endmarker: 65535
> > > 
> > > Dette er forkert, da codeOffset for "cExternalEntry" snarere burde vaere 
> > > noget i stil med "callCallbackSelector - M2GUIENVCALLBACKSELECTORADD", 
> > > eftersom koden genereret for cExternalEntry ligger *efter* resten af koden 
> > > for denne dopart.
> > > 
> > > Fejlen faar ny valhalla til at mappe adresser i cExternalEntry koden
> > > til et af de andre imperativer i ovenstaaende liste. Naermere betegnet det
> > > imperativ med stoerst kode offset.
> > > 
> > > Jeg kan godt se at dette problem ikke er helt let at loese, eftersom det
> > > kraever "fixups" af code-offsets for cExternalEntry imperativer naar disse
> > > bliver kendt. Men kan det goeres alligevel?
> > > 
> > >   -- Soren
> > > 
> > > 
> > > .global M2GUIENVCALLBACKSELECTORADD
> > > M2GUIENVCALLBACKSELECTORADD:	mov	%i1,%o0
> > > 	save	%sp,-64,%sp
> > > .L162:
> > > .stabn 68,0,76,.L163
> > > .L163:
> > > .stabn 68,0,100,.L164
> > > .L164:
> > > 	ld	[%i0+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+12],%i2
> > > 	ld	[%i0+420],%l7
> > > 	st	%l7,[%i2+12]
> > > .stabn 68,0,159,.L165
> > > .L165:
> > > 	ld	[%i0+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ldub	[%i2+408],%l0
> > > 	cmp	%l0,1
> > > 	bne	.L167
> > > 	nop
> > > .stabn 68,0,141,.L168
> > > .L168:
> > > 	ld	[%i0+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i0+8],%i3
> > > 	ld	[%i3+8],%i3
> > > 	ld	[%i3+8],%i3
> > > 	ld	[%i3+8],%i3
> > > 	ld	[%i3+8],%i3
> > > 	ld	[%i3+412],%i3
> > > 	tst	%i3
> > > 	tle	17
> > > 	add	%i3,0,%i1
> > > 	add	%i1,12,%g1
> > > 	add	%i2,0,%i3
> > > 	sub	%g1,%g6,%i5
> > > 	cmp	%i5,%g7
> > > 	bleu	.L169
> > > 	st	%i3,[%g1]
> > > 	call	ChkRA
> > > 	nop
> > > .L169:
> > > 	set	0,%i3
> > > 	set	0,%i4
> > > 	call	M315GUIENV
> > > 	set	0,%i2
> > > 	b	.L166
> > > 	nop
> > > .L167:
> > > .stabn 68,0,154,.L170
> > > .L170:
> > > 	ld	[%i0+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	ld	[%i2+8],%i2
> > > 	add	%i2,0,%i1
> > > 	call	M24WIDGET
> > > 	set	0,%i2
> > > .L166:
> > > .stabn 68,0,0,.L171
> > > .L171:
> > > 	ret
> > > 	restore
> > > .global callCallbackSelector
> > > callCallbackSelector:	mov	%i1,%o0
> > > 	save	%sp,-64,%sp
> > > 	mov	%i0,%o0
> > > 	mov	%i1,%l0
> > > 	mov	%i2,%l1
> > > 	set	0,%i2
> > > 	mov	%i3,%l2
> > > 	set	0,%i3
> > > 	mov	%i0,%i1
> > > !  Get long
> > > 	mov	%l0,%l3
> > > 	st	%l3,[%i1+412]
> > > !  Get long
> > > 	mov	%l1,%l0
> > > 	st	%l0,[%i1+416]
> > > !  Get long
> > > 	mov	%l2,%l0
> > > 	st	%l0,[%i1+420]
> > > 	call	M2GUIENVCALLBACKSELECTORADD
> > > 	nop
> > > 	ret
> > > 	restore
> > > 
> > 
> 
> 
> 


From Ole.Madsen@eng.sun.com Fri Jun  2 08:30:31 1995
Received: from venus.Sun.COM by daimi.aau.dk with SMTP id AA29601
  (5.67b8/IDA-1.5); Fri, 2 Jun 1995 08:29:52 +0200
Received: from Eng.Sun.COM by venus.Sun.COM (Sun.COM)
	id XAA06715; Thu, 1 Jun 1995 23:29:46 -0700
Received: from det.Eng.Sun.COM by Eng.Sun.COM (5.x/SMI-5.3)
	id AA22648; Thu, 1 Jun 1995 23:29:42 -0700
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA18909; Thu, 1 Jun 1995 23:29:43 +0800
Date: Thu, 1 Jun 1995 23:29:43 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9506020629.AA18909@det.Eng.Sun.COM>
To: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk
Cc: datpete@daimi.aau.dk, kjm@daimi.aau.dk, ole.madsen@eng.sun.com
Subject: Re: valhalla og callback funktioner
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

Blot for at minde folk om, nu da Soerens afrejse nermer sig,
at vi har en uafklaret problem som beskrevet i flg mail.
Jeg har ikke haft tid til at goere noget ved det.
Jeg ved ikke hvor presserede man opfatter det!

Men rette vedkommende boer gemme det paa sin todo-liste:-)

---olm

>From sbrandt@daimi.aau.dk Fri Jan 20 00:42 PST 1995
Subject: Re: valhalla og callback funktioner
To: Ole.Madsen@Eng (Ole Lehrmann Madsen)
Date: Fri, 20 Jan 1995 09:41:45 +0100 (MET)
Cc: ole.madsen@Eng, kjm@daimi.aau.dk, sbrandt@daimi.aau.dk,
        datpete@daimi.aau.dk

 > 
> Jeg forstaar simplet hen ikke hvad det er du mener her???

Ok. Naar man fra C kalder funktionen foo, bliver koden efter
"foo" entry pointet udfoert via CBFA. foo piller saa parametre
af stakken og kalder defefter M1PROGRAM. Altsaa ser returaddresserne
paa stakken nu (ca) ud som foelger (voksende nedefra og op):

   foo+64
   <<Et eller andet i CBFA>>
   <<C kode>>

Naar valhalla analyserer denne stak, vil foo+64 blive fortolket som
BETA kode, eftersom det jo faktisk befinder sig i kode-segmentet
hoerende til en BETA gruppe. Det "logiske" valg ville nu vaere
hvis valhalla kunne vise denne returadresse som svarende til
"cExternalEntry" imperativet, da det jo faktisk er det der er
tilfaeldet.

Men som ..db filen genereres nu, mapper valhalla "foo+64" til det
imperativ i doparten svarende til M1PROGRAM, som har det stoerste
kodeoffset. Maaden dette kommer frem paa, er foelgende:

  1. Foerst lokaliseres det stoerste M (eller G) entry point som er 
     mindre end "foo+64". I dit eksempel M1PROGRAM. 

  2. Find frem til  ..db informationerne svarende til dette M1PROGRRAM.

  3. Find det stoerste offset i doparten svarende til M1PROGRAM som er
     mindre end "foo+64-M1PROGRAM". Det tilhoerende ast index udpeger
     saa det soegte BETA imperativ.

Men det er jo netop det "sidste" imperativ i M1PROGRAM, og ikke
"cExternalEntry" imperativet.

Problemet kan loeses paa 2 maader. 

  1. Den jeg kunne komme i tanker om i gaar, nemlig at lade ..db
     kodeoffsettet for cExternalEntry vaere (foo-M1PROGRAM). Lige nu
     er kode-offsettet 8, hvilket er det samme som for "(a+b)->c".
     Altsaa en flertydighed som risikerer at resultere i at koden
     svarende til "(a+b)->c" mappes til ast indexet angivet for
     "cExternalEntry".

  2. Generere en indgang i ..db filen naar foo entry pointet genereres.
     Denne indgang skal indeholde (foo-M1PROGRAM,astindex(cExternalEntry)).
     Naar foo entry pointet genereres burde disse oplysninger vaere
     tilgangelige.

Jeg vil foreslaa metode 2, som sikkert er lettest at haandtere.

Endelig vil jeg godt have at du helt fjerner ..db indgange for imperativer 
der ikke genereres kode for, da disse resulterer i flere muligheder naar
et kode-offset skal mappes til det tilsvarende imperativ. Mere generelt
boer det sikres, at der for samme dopart ikke findes 2 ens kode-offsets
med forskellige ast indices.

Ioevrigt forstaar jeg ikke 498 outputtet. Udpluk:
   
     > M2PROGRAM:	mov	%i1,%o0
     > 	save	%sp,-64,%sp
     > .L5:
     > !  8,8  <=========================
     > .stabn 68,0,69,.L6
     > .L6:
     > !  cExternalEntry  
     > !  8,0 <=========================
     > .stabn 68,0,95,.L7
     > .L7:
     > !  a+b->c  
     > 	ld	[%i0+412],%l0
     > !12
     > 	ld	[%i0+416],%l7
     > !16
     > 	add	%l7,%l0,%l0
     > !20
     > 	st	%l0,[%i0+420]
     > !24
     > !  24,16 <=========================

Jeg antager at linierne !x afsloerer hvor din taeller er kommet til. Men
hvad betyder y'et i linier af formen "!  x,y"? Laengden af den genererede
kode?

  -- Soren

> 
> Hwer er et eksempel med callBack
> 
> origin 'tstenv'
> ---program:descriptor---
> (# foo: External
>      (# a,b,c: @integer
>      enter(a,b,c)
>      do cExternalEntry;
>         a+b->c; 
>         a*c->c
>      exit c
>      #);
>    v: @integer
> do 
> #)
> >
> Med kode (498:-)
> 
> .global G1PROGRAM
> G1PROGRAM:!  foo: External
> !  v: @integer  
> 	nop
> !28
> 	retl
> 	nop
> .global M1PROGRAM
> M1PROGRAM:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> .L3:
> !  8,8
> .stabn 68,0,0,.L4
> .L4:
> 	ret
> 	restore
> .stabs "PROGRAM",38,0,134,T2PROGRAM
> .global G2PROGRAM
> G2PROGRAM:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> !  a,b,c: @integer  
> 	ret
> 	restore
> .global M2PROGRAM<<<<<<<<<<<<<<<<<<<<< do-del af M-entrypoint for foo
> 			<<<<<<<<<<<<<<< Er dette ikke OK?
> 			<<<<<<<<<<<<<<< du skriver at det er forkert
> M2PROGRAM:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> .L5:
> !  8,8
> .stabn 68,0,69,.L6
> .L6:
> !  cExternalEntry  
> !  8,0
> .stabn 68,0,95,.L7
> .L7:
> !  a+b->c  
> 	ld	[%i0+412],%l0
> !12
> 	ld	[%i0+416],%l7
> !16
> 	add	%l7,%l0,%l0
> !20
> 	st	%l0,[%i0+420]
> !24
> !  24,16
> .stabn 68,0,119,.L8
> .L8:
> !  a*c->c  
> 	ld	[%i0+420],%l0
> !28
> 	ld	[%i0+412],%o0
> !32
> 	mov	%l0,%o1
> !36
> 	set	0,%i3
> 	set	0,%i4
> 	call	.mul
> !48
> 	set	0,%i2
> 	mov	%o0,%l0

> 	st	%l0,[%i0+420]
> !60
> !  60,36
> .stabn 68,0,0,.L9
> .L9:
> 	ret
> 	restore
> .global foo<<<<<<<<<<<<<<<<<<<<<<<<<<< foo-entry point
>             <<<<<<<<<<< Det gir klart INGEN mening!!, da talleren
> 			blot fortsetter som efter den forrige
> 			Jeg kan her let cleare taelleren
> 			saa de flg instruktioner blir relative
> 			til foo, men det er ikk det du ber om?
> ---olm
> 
> foo:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> 	mov	%i0,%o0
> 	mov	%i1,%l0
> !84
> 	mov	%i2,%l1
> !88
> 	set	0,%i2
> !92
> 	mov	%i3,%l2
> !96
> 	set	0,%i3
> !100
> 	mov	%i0,%i1
> !  Get long
> 	mov	%l0,%l3
> !108
> 	st	%l3,[%i1+412]
> !112
> !  Get long
> 	mov	%l1,%l0
> !116
> 	st	%l0,[%i1+416]
> !120
> !  Get long
> 	mov	%l2,%l0
> !124
> 	st	%l0,[%i1+420]
> !128
> 	call	M2PROGRAM
> !132
> 	nop
> 	ld	[%i1+420],%l0
> !140
> 	mov	%l0,%i0
> 	ret
> 	restore
> BETA_code2:	nop
> .data
> BETA_data2:.word 2
> .global T1PROGRAM
> .word T1PROGRAM
> .global T2PROGRAM
> .word T2PROGRAM
> .asciz "/home/olm/beta/system/v5.1/TST/zcallback"
> .align 4
> .word Return
> .word M1PROGRAM
> T1PROGRAM:.half 20
> .half 2
> .word G1PROGRAM
> .word T27ENV
> .half 4
> .half 0
> .half 1
> .half 163
> .half 0
> .half 10
> .half 0
> .asciz "PROGRAM-~"
> .align 4
> .word Return
> .word M2PROGRAM
> T2PROGRAM:.half 24
> .half 2
> .word G2PROGRAM
> .word T27ENV
> .half 106
> .half 0
> .half 1
> .half 134
> .word foo
> .half 0
> .half 10
> .half 0
> .asciz "foo#"
> .align 4
> BETA_data3:!    
> 
> > 
> > Betragt foelgende kode segment fra ~beta/guienv/v1.2/private/X11/widgetbody:
> > 
> >     -- GUIENVcallbackSelectorAdd: descriptor --
> >     (# callCallbackSelector: external
> > 	 (# w,client_data,call_data: @integer;
> > 	 enter (w,client_data,call_data)
> > 	 do cExternalEntry;
> > 	    call_data -> data.ptr;
> > 	    (if XsystemEnvPresent//true then
> > 		this(callbackSelector)[] -> XsystemEnvHandleCallback;
> > 	     else
> > 		this(callbackSelector);
> > 	    if);
> > 	 #);
> >        t: @text;
> >     do (widgetID,name,callCallbackSelector##,0) -> XtAddCallback;
> >     #)
> > 
> > Genereret kode foelger i bunden af denne mail. 
> > 
> > cExternalEntry's resulterer i genereringen af et entry point som foerst 
> > piller C parametre af stakken, og derefter kalder det tilsvarende BETA 
> > entry point.
> > 
> > For doparten i "callCallbackSelector: external" genereres foelgende ..db info.
> > (x,y) betyder her ("codeoffset fra start a Mentry",ast index). Det tilsvarende
> > imperativ er derefter pretty-printet.
> > 
> >       dopart <AstIndex>: 156
> >              (8,152)  cExternalEntry
> >              (8,200)  call_data->data.ptr
> >              (32,318)  (if XsystemEnvPresent // true then <<AssignmentEvaluation>>; else THIS(callbackSelector);if)
> >              (56,230)  true
> >              (68,282)  THIS(callbackSelector)[]->XsystemEnvHandleCallback
> >              (168,284)  THIS(callbackSelector)[]->XsystemEnvHandleCallback;
> >              (176,308)  THIS(callbackSelector)
> >              (200,312)  THIS(callbackSelector);
> >              (200,156)  cExternalEntry;call_data->data.ptr;(if XsystemEnvPresent // true then <<Imperatives>> else THIS(callbackSelector);if);
> >              Endmarker: 65535
> > 
> > Dette er forkert, da codeOffset for "cExternalEntry" snarere burde vaere 
> > noget i stil med "callCallbackSelector - M2GUIENVCALLBACKSELECTORADD", 
> > eftersom koden genereret for cExternalEntry ligger *efter* resten af koden 
> > for denne dopart.
> > 
> > Fejlen faar ny valhalla til at mappe adresser i cExternalEntry koden
> > til et af de andre imperativer i ovenstaaende liste. Naermere betegnet det
> > imperativ med stoerst kode offset.
> > 
> > Jeg kan godt se at dette problem ikke er helt let at loese, eftersom det
> > kraever "fixups" af code-offsets for cExternalEntry imperativer naar disse
> > bliver kendt. Men kan det goeres alligevel?
> > 
> >   -- Soren
> > 
> > 
> > .global M2GUIENVCALLBACKSELECTORADD
> > M2GUIENVCALLBACKSELECTORADD:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > .L162:
> > .stabn 68,0,76,.L163
> > .L163:
> > .stabn 68,0,100,.L164
> > .L164:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+12],%i2
> > 	ld	[%i0+420],%l7
> > 	st	%l7,[%i2+12]
> > .stabn 68,0,159,.L165
> > .L165:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ldub	[%i2+408],%l0
> > 	cmp	%l0,1
> > 	bne	.L167
> > 	nop
> > .stabn 68,0,141,.L168
> > .L168:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i0+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+412],%i3
> > 	tst	%i3
> > 	tle	17
> > 	add	%i3,0,%i1
> > 	add	%i1,12,%g1
> > 	add	%i2,0,%i3
> > 	sub	%g1,%g6,%i5
> > 	cmp	%i5,%g7
> > 	bleu	.L169
> > 	st	%i3,[%g1]
> > 	call	ChkRA
> > 	nop
> > .L169:
> > 	set	0,%i3
> > 	set	0,%i4
> > 	call	M315GUIENV
> > 	set	0,%i2
> > 	b	.L166
> > 	nop
> > .L167:
> > .stabn 68,0,154,.L170
> > .L170:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	add	%i2,0,%i1
> > 	call	M24WIDGET
> > 	set	0,%i2
> > .L166:
> > .stabn 68,0,0,.L171
> > .L171:
> > 	ret
> > 	restore
> > .global callCallbackSelector
> > callCallbackSelector:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > 	mov	%i0,%o0
> > 	mov	%i1,%l0
> > 	mov	%i2,%l1
> > 	set	0,%i2
> > 	mov	%i3,%l2
> > 	set	0,%i3
> > 	mov	%i0,%i1
> > !  Get long
> > 	mov	%l0,%l3
> > 	st	%l3,[%i1+412]
> > !  Get long
> > 	mov	%l1,%l0
> > 	st	%l0,[%i1+416]
> > !  Get long
> > 	mov	%l2,%l0
> > 	st	%l0,[%i1+420]
> > 	call	M2GUIENVCALLBACKSELECTORADD
> > 	nop
> > 	ret
> > 	restore
> > 
> 



From henryml@daimi.aau.dk Tue May 23 20:27:14 1995
Received: from louise.daimi.aau.dk by daimi.aau.dk with SMTP id AA09493
  (5.67b8/IDA-1.5); Tue, 23 May 1995 20:27:13 +0200
Received: (from henryml@localhost) by louise.daimi.aau.dk (8.6.11/8.6.11) id OAA28053; Tue, 23 May 1995 14:27:11 -0400
Date: Tue, 23 May 1995 14:27:11 -0400
From: Henry Michael Lassen <henryml@daimi.aau.dk>
Message-Id: <199505231827.OAA28053@louise.daimi.aau.dk>
To: sbrandt@daimi.aau.dk
Subject: Valhalla (eller MPS) fejl
Cc: jlk@daimi.aau.dk, ess@daimi.aau.dk
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


Hej,

Valhalla gik ned med det dump, som er i slutningen af brevet, men jeg
mener at fejlen faktisk findes i list.newScan i astLevel.bet, som kan
finde på at kalde INNER med current[] = None.

I følgende kode er der en virtual definition "predefined", som ikke
giver så meget mening:

-- listNewScanBody: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;
   predefined:< (# current: ^Ast enter current[] do INNER newScan #);
   
do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx = 0)
    // false then
       currentSonNo+1->currentSonNo;
       privateInx->privateIndexToNode->a[];
       (if a.kind
        // kinds.interior then a[]->current[]; INNER newScan; 
        else
           a[]->predefined; 
       if);
       (if (privateInx->privateIsLastBrother)
        // false then privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)

Jo, jeg havde lovet et dump:

Beta execution aborted: Reference is none.

Call chain: (sun4s)

  item <findAndCache#> in ~beta/debugger/v2.0/private/utilitiesbody
    -- astToImpTable#hashTable#collection#container# in ~beta/debugger/v2.0/private/utilitiesbody
  item <*>codeAstToImperative# in ~beta/debugger/v2.0/private/utilitiesbody
    -- *newScan# in ~beta/debugger/v2.0/private/steppingbody
  item <*>newScan# in ~beta/debugger/v2.0/private/steppingbody
    -- handleImperativesOpt# in ~beta/debugger/v2.0/private/steppingbody
  item <LISTNEWSCANBODY-~> in ~beta/mps/v4.9.1/private/astBody
    -- *newScan# in ~beta/debugger/v2.0/private/steppingbody
  item *<newScan#> in ~beta/mps/v4.9.1/astlevel
    -- Imperatives#list#expanded#ast# in ~beta/betaast/v4.9.1/betacfl
  item <handleImperativesOpt#> in ~beta/debugger/v2.0/private/steppingbody
    -- *intolist# in ~beta/debugger/v2.0/breakpoints
  item <*>newScan# in ~beta/debugger/v2.0/private/steppingbody
    -- * in ~beta/debugger/v2.0/private/steppingbody
  item *<newScan#> in ~beta/mps/v4.9.1/astlevel
    -- Alternatives#list#expanded#ast# in ~beta/betaast/v4.9.1/betacfl
  item <*> in ~beta/debugger/v2.0/private/steppingbody
    -- handleImp# in ~beta/debugger/v2.0/private/steppingbody
  item <handleImp#> in ~beta/debugger/v2.0/private/steppingbody
    -- *intolist# in ~beta/debugger/v2.0/breakpoints
  item <*>intolist# in ~beta/debugger/v2.0/private/steppingbody
    -- init#init#init# in ~beta/debugger/v2.0/breakpoints
  item <init#>init#init# in ~beta/debugger/v2.0/breakpoints
    -- skipBreaker#singleStepBreaker#stepBreaker#breakList# in ~beta/debugger/v2.0/breakpoints
  item <*>scan# in ~beta/debugger/v2.0/private/breakpointsbody
    -- BREAKMANAGERLISTBEFORECONTINUEBODY-~ in ~beta/debugger/v2.0/private/breakpointsbody
  item <BREAKMANAGERLISTBEFORECONTINUEBODY-~> in ~beta/debugger/v2.0/private/breakpointsbody
    -- beforeContinueAction# in ~beta/debugger/v2.0/breakpoints
  item <beforeContinueAction#> in ~beta/debugger/v2.0/breakpoints
    -- breakManagerList#list#container# in ~beta/debugger/v2.0/breakpoints
  item <execute#>scan# in ~beta/debugger/v2.0/processInterface
    -- actionList#list#container# in ~beta/debugger/v2.0/processInterface
  item beforeContinue#<beforeContinue#> in ~beta/debugger/v2.0/processInterface
    -- GUIprocess#processInterface#mpsinterface# in ~beta/debugger/v2.0/UI/GUIprocess
  item <CONTINUEBODY-~> in ~beta/debugger/v2.0/private/processcommbody_unix
    -- Continue#UnlessTerminated# in ~beta/debugger/v2.0/processInterface
  item <Continue#>UnlessTerminated# in ~beta/debugger/v2.0/processInterface
    -- processComm# in ~beta/debugger/v2.0/processInterface
  item <doContinue#> in ~beta/debugger/v2.0/valhalla
    -- PROGRAM-~SystemEnv#SysHead# in ~beta/debugger/v2.0/valhalla
  item <debuggeeContinue#> in ~beta/debugger/v2.0/valhalla
    -- gui#valhallaGUI#GUIenv# in ~beta/debugger/v2.0/valhalla
  item <onMouseUp#>mouseUp#mouseEvent#basicEvent#event# in ~beta/debugger/v2.0/UI/valhallaGUI
    -- eventHandler#eventhandler#eventhandler#eventhandler# in ~beta/debugger/v2.0/UI/valhallaGUI
  item onMouseUp#mouseUp#mouseEvent#basicEvent#<event#> in ~beta/guienv/v1.2/guienv
    -- eventHandler#eventhandler#eventhandler#eventhandler# in ~beta/debugger/v2.0/UI/valhallaGUI
  item <handlePushButtonActivate#>motifCallbackSelector#callbackSelector# in ~beta/guienv/v1.2/private/X11/controls_unixbody
    -- shortcutButton#pushButton#button#control#windowitem#interfaceObject# in ~beta/debugger/v2.0/UI/valhallaGUI
  item <*>Cycle# in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
    -- XcallbackThread#System#SysHead# in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
  comp <XcallbackThread#>System#SysHead# in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody

  item <attNext#> in ~beta/basiclib/v1.4/private/basicsystemenvbody
    -- BASICSYSTEMENVPRIVATE-~ in ~beta/basiclib/v1.4/private/basicsystemenvbody
  item <next#> in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
    -- XcallbackThread#System#SysHead# in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
  item <registerCallback#>XsystemEnvHandleCallbackP# in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
    -- PIOPRIVATE-~ in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
  item pushbuttonActivateProcessor#<callbackProcessor#> in ~beta/guienv/v1.2/private/X11/callbacks
    -- gui#valhallaGUI#GUIenv# in ~beta/debugger/v2.0/valhalla
  item <pushbuttonActivateProcessor#>callbackProcessor# in ~beta/guienv/v1.2/private/X11/controls_unixbody
    -- shortcutButton#pushButton#button#control#windowitem#interfaceObject# in ~beta/debugger/v2.0/UI/valhallaGUI
  [ EXTERNAL ACTIVATION PART ]
  item <GUIENVDOPART-~> in ~beta/guienv/v1.2/private/X11/guienv_unixbody
    -- gui#valhallaGUI#GUIenv# in ~beta/debugger/v2.0/valhalla
  item <gui#>valhallaGUI#GUIenv# in ~beta/guienv/v1.2/guienv
    -- PROGRAM-~SystemEnv#SysHead# in ~beta/debugger/v2.0/valhalla
  item <start#> in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
    -- PIOPRIVATE-~ in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody
  comp <BASICSCHEDULER-~>SysHead# in ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody

  item <InsertedItem#>ObjectEvaluation#Transaction#Factor#Term#SimpleExp#Expression#Evaluation#Imp#cons#expanded#ast# in ~beta/mps/v4.9.1/astlevel
    -- beta#treeLevel# in ~beta/betaast/v4.9.1/betacfl

From sbrandt@daimi.aau.dk Tue May 23 11:43:33 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA28506
  (5.67b8/IDA-1.5); Tue, 23 May 1995 11:43:26 +0200
Received: by quercus.daimi.aau.dk id AA27686
  (5.67b8/IDA-1.5); Tue, 23 May 1995 11:43:10 +0200
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199505230943.AA27686@quercus.daimi.aau.dk>
Subject: Hvordan vi faar generelle repetitions (Was: Release status V3)
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Tue, 23 May 1995 11:43:10 +0200 (MET DST)
Cc: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk, datpete@mjolner.dk,
        ess@daimi.aau.dk, jacobse@daimi.aau.dk, jlk@daimi.aau.dk,
        kjm@mjolner.dk, pjs@mjolner.dk, pryberg@mjolner.dk
In-Reply-To: <9505230824.AA20478@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at May 23, 95 01:24:44 am
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 4735      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


> 
> > email email email.
> 
> Ja det forvirrer selv os der har brugt det lenge.

Lang mail slettet. Jeg er enig.

Lige en enkelt udredning.
Joergen og Elmer: I boer nok holde oererne stive her. Og gemme denne mail, da
I nok faar brug for den!!!

> > > 
> > > > > Saa det gir anledning til flg. sporgsmaal/kommentarer
> > > > > 
> > > > > 	Valhalla: her boer de kunne vises - saa hvad koster det
> > > > > 
> > > > > 	Objectbrowser: do - men kommer vel hvis Valhall kan?
> > > > 
> > > > Ja, det er 2 sider af samme sag. Og for den rette mand (mig:-), vil det
> > > > vel heller ikke tage mere end et par dage, omend jeg faktisk udelod det
> > > Udelod hvad? Generelle repetitions er der jo ikke?
> > 
> > Udelod at kunne haandtere generelle repetitions.
> 
> men hvordan kunne du vise dem naar de ikke er der?

Det var heller ikke let :-) Nej, de er selvfoelgelig bare ikke implementeret.

Vi begynder vores rejse i det interface der lyder navnet "attribute":
 
  ~beta/objectbrowser/v2.0/attribute.bet

"attribute" implementerer basal visning af objekter ovenpaa det tidligere
omtalte "objectdumper" interface. Den svarer vel egt. meget til astviewer
(altsaa pretty-printeren), men altsaa paa objekter. Mere praecist
understoetter "attribute" pretty-printning af instanser af det abstrakte 
pattern betaObject fra objectdumper.bet.

Nuvel, "attribute" deler objekt-attributter op som foelger:

(*
 *                       attribute
 *                           |
 *      _____________________|____________________
 *     |                                          |
 * complexAttribute                      repetitionAttribute
 *     |                                          |
 *     |                                          |
 * rootAttribute                                  |
 *                                                |
 *                           _____________________|________
 *                          |                              |
 *                  simpleRepetitionAttribute   complexRepetitionAttribute
 * 
 *)

hvor "complexRepetitionAttribute" svarer til generelle repetitions, som
altsaa ikke er implementeret. Hvor svaert det vil vaere, ved jeg ikke
med sikkerhed, men det er (vist nok) en anelse langhaaret. Statiske
part objects er repraesenteret ved "complexAttribute", og simple attributter,
dvs. Char, Integer, ... og dynamiske referencer er repraesenteret ved
"attribute".

En instans af "rootAttribute" holder styr paa visningen af et bestemt
objekt. Til saadan en sag kan man saa sige "scanVisibleAttributes", hvorved
der scannes over de oejeblikkeligt viste attributter i et objekt. For hver
attribut i objektet kaldes en passende qualificeret virtual i en
"attributeVisitor", som gives som parameter til scanVisibleAttributes.
En god attributeVisitor at stikke til "scanVisibleAttributes" er den
saakaldte "dumpVisitor" erklaeret i "dumpvisitor.bet". (Visitor er
faktisk et design pattern. Se "Design Patterns -- Elements of Reusable
Object-Oriented Software", side 331.)

Man kan saa vise objektets tilstand i fx et guienv vindue (i oejeblikket et 
"objectView" fra ~beta/objectbrowser/v2.0/UI/objectview.bet), eller
blot skrive det ud paa console, eller hvad man nu maatte oenske sig.

Foer "attribute" kan klare generelle repetitions skal "objectdumper"
kunne. Dette kraever en udvidelse af implementationen af
"objectdumper.scanPattern", samt ekstra interface metoder i det
abstrakte "betaObject" pattern. Ingen af disse ting er naeppe svaere.
I oejeblikket vil objectdumper.scanPattern skrive:

    FATAL:getRepetitionDeclInfo: Reptype was StaticItem

eller

    FATAL:getRepetitionDeclInfo: Reptype was StaticComponent

(og falde doed om) i fald den stoeder ind i een af disse nymodens repetitions.
Man vil saa vide hvor den er gal... :-)

Rulletekster: Denne historie havde foelgende hovedpersoner:

  Fragmentgruppe: ~beta/objectbrowser/v2.0/objectdumper.bet
  Patterns: objectdumper, betaObject
  Afhaenger af: Hele mps gymnastikken.
  Specialiseres i: ~beta/objectbrowser/v2.0/localdumper.bet
                   ~beta/objectbrowser/v2.0/psbrowser/psobjdumper.bet
                   ~beta/debugger/v2.0/remotedumper.bet

  Fragmentgruppe: ~beta/objectbrowser/v2.0/attribute.bet
  Patterns: attribute, attributeVisitor.
  Afhaenger af: objectdumper.

  Fragmentgruppe: ~beta/objectbrowser/v2.0/dumpvisitor.bet
  Pattern: dumpvisitor
  Afhaenger af: attribute

  Fragmentgruppe: ~beta/objectbrowser/v2.0/UI/objectview.bet
  Patterns: objectview
  Afhaenger af: objectdumper, attribute, dumpvisitor, guienv

Og hvem bruger saa ovenstaaende?
Jo: valhalla, objectbrowser (browser,psbrowser), schema-evolution 
    tool (Anders), Query/Tcl (Alexandre).    

God fornoejelse.

  -- Soren

From sbrandt@daimi.aau.dk Thu Mar 23 09:52:31 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA24090
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Thu, 23 Mar 1995 09:52:20 +0100
Received: by quercus.daimi.aau.dk id AA03732
  (5.67b8/IDA-1.5 for sbrandt@daimi.aau.dk); Thu, 23 Mar 1995 09:51:50 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199503230851.AA03732@quercus.daimi.aau.dk>
Subject: Re: ELF compiler entrypoints
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Thu, 23 Mar 1995 09:51:49 +0100 (MET)
Cc: sbrandt@daimi.aau.dk, datpete@mjolner.dk, Ole.Madsen@eng.sun.com
In-Reply-To: <9503230347.AA03501@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Mar 22, 95 07:47:36 pm
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 1339      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

> 
> 
> Soeren
> 
> En forskel paa .s- og ELF-versionen af beta5.1 er at den sidste
> markerer entry-points som funktioner/dataobjekter.
> 
> I .s-versionen er alle entry-points markeret som NOTYPE.
> 
> Men saa vidt jeg kan se paa din 'nm' saa fisker du alle ud
> af typen N eller T, saa det skulle ikke gi problemer?

Enten misforstaar jeg dig, eller ogsaa giver det netop problemer.
I valhalla returnerer min "nm-kode" kun oplysninger med type N (NOTYPE) 
eller T, og hvis entry points har faaet en ny type, skal dette laves
om (formentlig i valhalla). 

Kan du ikke fortalle mig hvor jeg finder en objektfil genereret af
den binaere ELF compiler, eller sende mig en udskrift fra nm paa
en eller anden executable genereret med ny compiler? Saa kan jeg
selv se hvad der evt. skal laves om.

> 
> Din nm kode virker iovrigt fint, dog kan 0 (nul) ikke bruges som terminering
> da de foerste entry-points der leveres fra nm har addresse 0 (nul).
> 
> Jeg endrede det til -1, men det holder maaske ikke?
> Kan -1 vere en sansynlig addresse?
> Ellers maa der vere en extra funktion der teste for eof.

Jeg tror -1 er ok, men jeg har nu alligevel taenkt mig at lave interfacet
om saa jeg kan noejes med et externt kald pr. label. Dette kan saa includere
explicit information om EOF.

  -- Soren

> 
> Men tak for assistancen!
> 
> ---olm
> 



From Ole.Madsen@eng.sun.com Wed Mar 22 05:21:38 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA10923
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Wed, 22 Mar 1995 05:21:21 +0100
Received: from Eng.Sun.COM (engmail2.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA14330; Tue, 21 Mar 95 20:21:04 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (5.x/SMI-5.3)
	id AA23758; Tue, 21 Mar 1995 20:21:00 -0800
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA01225; Tue, 21 Mar 1995 20:21:01 +0800
Date: Tue, 21 Mar 1995 20:21:01 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9503220421.AA01225@det.Eng.Sun.COM>
To: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk
Subject: Re: Valhalla step spm!
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

> 
> > b.	Addresse paa kode der beregner origin og T-entrypoint
> > 	
> > 	Er tilfeldet for virtuelle erkleret som foelger
> > 
> > 		V:< A;
> > 
> > 	For disse gelder at origin skal beregnes, og det genereres der
> > 	kode til.
> > 
> > 	Det er defor nok ikke saa nemt at se hvilket T-entrypoint der
> > 	fakstisk genereres, uden at udfoere koden
> 
> Forudsat at denne kode ikke har nogen side effekter, hvilket jeg ville
> forvente, kan jeg kalde den direkte. (Faktisk kan jeg kalde vilkaarlig 
> kode i den debuggede process, forudsat at det ikke har nogen side effekter.
> Dette udelukker dog i praksis at jeg kalder BETA kode fra debuggeren.)
> 

Der skulle ikke vere nogen side effekt.

> > 
> > Et virtuelt kald har normalt formen
> > 
> >         (e,e2,e3)-> R.V -> x
> > 
> > 	@@R ->  originReg (%o0)
> > 
> > 	a. via [%o0] slaa op i virtuel tabellen -> %i1
> > 	   som saa er prototypen
> > 
> > 	b. .... -> %i1 
> > 	   call %i1
> > 
> > 	  hvor der hoppes til kode af formen
> > 
> > 		ld [%o0+8],%o0
> > 	         ....
> > 	 	...., %o0  som saa er origin
> > 		lea T117FOO,%o0	prototypen
> > 
> > 		rts
> 
> 
> Oehmm, som du selv siger er du lettere beruset. Et kig i en ..s fil
> giver foelgende eksempel:
> 
> .L3:	ld	[%o0+80],%o0
> 	sethi	%hi(T26REMOTEDUMPER),%i1
> 	or	%i1,%lo(T26REMOTEDUMPER),%i1
> 
> 	nop
> 	retl
> 
> Altsaa returneres origin i %o0, og prototypen i %i1. Som oensket uden
> side effekter. Saa i dette tilfaelde kan jeg altsaa blot kalde koden, pille
> den korrekte prototype ud af %i1, og derefter saette et breakpoint paa starten
> af den foeste dopart for hvilken der er genereret kode. Dette er naturligvis
> maskin-specifikt, men det drejer sig om 4 linier assembler pr platform. Det
> kan vi nok leve med.
> 
Rigtigt - jeg er stadig ldit beruste. Marianne med svigerforeldre er netop
ankommet fra DK:-)

> 2 spoergsmaal:
> 
>    1. Kan jeg vha. af semantiske attributter se forskel paa tilfaeldene
>       a og b, altsaa om virtuel tabellen indeholder en prototype eller
>       noget kode der beregner den?
> 

Frit fra hukommelsen. Hvis V er en namepl for en virtuel, saa er
V.access = direct (Tilfelde a) indirect (Tilfelde b)
Men der 2 verdider for indirect og det er verdien cstInd (1).

>    2. Kan jeg vha af semantiske attributter paa en dopart eller 
>       objektdescriptor se om der genereres kode for doparten?
> 

Attributten  kind har flg. 2 bits sat

	16: hasAcode - dvs der er en G-part

	17: hasOnlyInner - dvs hvis true, saa er der INGEn M-entry point

Men for at dette er i sving skal ALT fra betanev vere oversate med switch 499]

> Saa vidt muligt vil jeg helst slippe for at skulle analysere ast'erne
> direkte. Det er jeg allerede ude i naar jeg skal genskabe raekkefoelgen af 
> prototyperne paa basis af AST'en alene. (Min kode for at goere dette er
> inkluderet nedenfor, og er en kopi af noget compiler kode der er omskrevet
> til at bruge astInterface i stedet for index.). Ogsaa paa det her punkt er det 
> compilerens job, og jo mere af den slags der havner i debuggeren, jo mere 
> saarbar bliver den overfor aendringer og forbedringer i compileren.
> 
> Lige en kommentar fra koden inkluderet i slutningen af denne mail, som har
> relevans for "den compiler ansvarlige":
> 
Jeh skal se paa det naar jeg blir lidt mere aedru - enig I at 
der kun boer vere een version af slig kode


>  	(* Code in this descriptor was based on "cProcDecoder"
>          * from "sematt.bet" in the compiler, but rewritten
>          * to use the "betacfl" interface instead of the
>          * "index" interface. For maintainability, future 
>          * compilers should set a semantic attribute revealing
>          * whether an objectdescriptor generates a prototype. *)
>                    
> > 
> > 	Og herefter for a og b
> > 		
> > 		call AlloI
> > 
> > 		overfoer e1,e2,e3...
> > 		
> > 		call M-for V ***************
> > 
> > 	Ved ******* peger %i1 paa det allokerede objekt.
> > 
> > 	Hvis M-entry pointet for V exsisterer hoopes direktte
> > 	til det. Hvis det ikke existerer hoppes via
> > 	inner tabellen for V (%i1)
> > 
> > 	Dvs hvis der kan saettes et breakpoiunt ved ****
> > 	kan man her let finde ud af hvor der hoppes
> > 	til
> > 
> > 	men jeg kan ikke gennemskue om det er let.
> > 
> > 	Jeg er ogsaa lidt beruset lige  nu:-)
> > 
> > Iovrigt kan evaluation jo vere ret kompliceret:
> > 
> > 	(F,G,H)->R->S->(Q,W,E)
> > 
> > med mange objekter der kan udfoeres.
> 
> Det problem er klaret. Valhalla analyserer hele molevitten, og saetter
> breakpoints alle de steder hvor den ikke kan afvise at ville havne som
> naeste BETA imperativ. Alt afhaengig af hvad dine navne ovenfor betyder,
> vil valhalla altsaa i ovenstaaende tilfaelde saette et breakpoint ved
> entry pointet for F,G,H,R,S,Q,W og E. Ikke specielt smart, men til gengaeld
> baade portabelt, og faktisk ogsaa mere effektivt end den gamle metode med
> at single steppe processoren og kigge efter for hvert skridt om vi har
> naaet noget kendt.
> 
Godt!

> Dette er til gengaeld ogsaa noget af det mest langhaarede BETA kode jeg 
> til dato har skrevet. Og vi er jo heller ikke faerdige endnu :-)
> 
> > 
> > jeg kan ike se om det kan gi problemer for Valhalla med at 'finde'
> > ud af hviket objekt der kaldes?
> > 
> > Maaske ville det generelt vere en god ide at kunne sette breakpoint
> > paa et call af et M-entry point (og G-ogsaa?)
> > 
> > Det kunne saa ogsaa bruges til at lave trace med.
> 
> Det er blot et spoergsmaal om et passende bruger interface. Hele mekanikken
> til at goere dette er allerede implementeret. Blot er der jo *mange* entry
> points, og det ville ogsaa vaere temmelig ineffektivt. Signal haandtering
> er ikke hurtigt. Maalinger lavet af nogen-jeg-ikke-kan-huske-navnet-paa antyder
> at haandteringen af et signal i de fleste UNIX implementationer bruger 
> processor tid svarende til ca. 10.000 instruktioner. Det er ret lang tid
> at braende af pr. M entry for at kunne trace.
> 
>   -- Soren

Ok - jeg er paa vej i seng:-)

---olm

> 
> > 
> > Naa ikke mere  nu:-)
> > 
> > ---olm
> > ~v
> > 
> > 
> > 1
> > > 
> > > Dette vil jo saa ogsaa loese 499 tingene. Men hvad har du ellers i
> > > aermet...?
> > > 
> > > Valhalla har brug for ressourcer... (Standard disclaimer, skift selv
> > > valhalla ud med navnet paa din yndlings delkomponent :-)
> > > 
> > >   -- Soren
> > > 
> > > > 
> > > > Soeren,
> > > > 
> > > > Kan Valhalla haandtere step for flg. program:
> > > > 
> > > > 	(# foo1: (# ... do ... #);
> > > > 	   foo2: (# ... do ... #);
> > > > 	     ...;
> > > > 	   R: ^ object
> > > >        do &foo1[]->R[]; R;
> > > >           &foo2[]->R[]; R;
> > > >          ...
> > > >        #)
> > > > 
> > > > Jeg kan ikke proeve det selv da jeg sidder hjemme lige nu.
> > > > 
> > > > Sporgsmaalet henger selvfolgelig sammen med overvejelser i forbindelse
> > > > med switch 499 og Valhalla.
> > > > 
> > > > I ovenstaaende program hoppes der jo ikke via det generelle pattern
> > > > object og dets INNER.
> > > > 
> > > > ---olm
> > > > 
> > > > 
> > > 
> > > 
> > 
> 
> 
> 
> Eksempel paa noget kode som egt. burde ligge i compileren, men som faktisk
> er kopieret og omskrevet til brug i debuggeren:
> 
> newGroupsInfoElement:
>   (# fg: ^AST.fragmentGroup; 
>      new: ^element;
>      groupName: ^Text;
>      
>      scanFragment:
>        (# exp: ^AST.expanded;
>           firstInDescriptorForm: @Boolean;
>           CprocKind: (# exit 3 #); generalKind:  (# exit 4 #);
>        enter exp[]
>        do
>           (exp.symbol=BETA.DescriptorForm)->firstInDescriptorForm;
>           BETA.ObjectDescriptor->exp.suffixWalkForProd
>           (# scanCat:: BETACFL.ObjectDescriptor;
>              createsPrototype: @Boolean;
>           do 
>              (if (current.kind -> tos'%getByte[0]')
>                  
>               //CprocKind then
>                  
>                  (* Current is an external declaration. No prototype is generated
>                   * UNLESS it is a callback procedure. *)
>                  
>                  (# (* Code in this descriptor was based on "cProcDecoder"
>                      * from "sematt.bet" in the compiler, but rewritten
>                      * to use the "betacfl" interface instead of the
>                      * "index" interface. For maintainability, future 
>                      * compilers should set a semantic attribute revealing
>                      * whether an objectdescriptor generates a prototype. *)
>                     
>                     mp: ^BETACFL.MainPart; ap: ^BETACFL.ActionPart;
>                     dp: ^BETACFL.DoPart; imps: ^BETACFL.Imperatives;
>                     imp: ^BETACFL.Imp; ae: ^BETACFL.assignmentEvaluation; 
>                     tr: ^BETACFL.Transaction; ad: ^BETACFL.attributeDenotation;
>                     obd: ^BETACFL.objectDenotation;
>                     a: ^AST.ast;
>                     
>                     getExtKind:
>                       (# a: ^AST.ast; na: ^BETACFL.NameApl; t: ^Text;
>                          createsPrototype :@Boolean;
>                       enter a[]
>                       do 
>                          (if a.symbol//BETA.NameApl then
>                              (a[]->na[]).getText->t[];
>                              (if true
>                               //'CallC'->t.equalNCS
>                               //'CallPascal'->t.equalNCS
>                               //'Pascal'->t.equalNCS
>                               //'CallStd'->t.equalNCS
>                               //'PascalTrap'->t.equalNCS then
>                                  FALSE->createsPrototype;
>                               else
>                                  TRUE->createsPrototype;
>                              if)
>                           else
>                              FALSE->createsPrototype;
>                          if);
>                       exit createsProtoType
>                       #);
>                     
>                  do
>                     (current.getMainPart->mp[]).getActionPart->ap[];
>                     ap.getDoPartOpt->a[];
>                     (if a.kind<>AST.kinds.optional then
>                         (a[]->dp[]).getImperatives->imps[];
>                         L: imps.newScan (# do current[]->imp[]; leave L #);
>                         (if imp[]<>NONE then
>                             (* imp is first imperative in dopart *)
>                             (if imp.symbol
>                              //BETA.assignmentEvaluation then
>                                 (* 'xxx'->YY *)
>                                 (imp[]->ae[]).getTransAction->tr[];
>                                 (if tr.symbol//BETA.objectDenotation then
>                                     (tr[]->obd[]).getAttributeDenotation->ad[];
>                                     ad[]->getExtKind->createsProtoType;
>                                 if);
>                              //BETA.objectDenotation then
>                                 (imp[]->obd[]).getAttributeDenotation->ad[];
>                                 ad[]->getExtKind->createsProtoType;
>                              else
>                                 TRUE->createsProtoType;
>                             if);
>                         if);
>                     if);
>                  #)
>                  
>               //generalKind then
>                  
>                  (if not (current.kind->TOS'%getBits[13,1]') then
>                      (* Current is *not* an inserted item 
>                       * of the inlined kind. *)
>                      TRUE->createsPrototype;
>                  if);
>                  
>              if);
>              
>              (if createsPrototype then
>                  current[]->new.append;
>                  (if firstInDescriptorForm then
>                      (if (current.getPrefixOpt).kind<>AST.kinds.optional then
>                          (* In descriptor forms with prefixed descriptors, the
>                           * prototype is put twice into the data segment 
>                           * prototype table! Don't know why! *)
>                          current[]->new.append;
>                      if);
>                  if);
>              if);
>              FALSE->firstInDescriptorForm->createsPrototype;
>           #);
>        #);
>      
>   enter groupName[]
>   do 
>      groupName[]->fragmentGroupTable.getFragmentGroup->fg[];
>      (if fg[]//NONE then leave newGroupsInfoElement if);
>      
>      groupName[]->onScan;
>      
>      &element[]->new[];
>      fg[]->new.fg[];
>      groupName.copy->new.groupName[];
>      new[]->insert;
>      
>      (* First run through the attributes fragments in the group. They
>       * are for some reason emitted first in the prototype table. *)
>      
>      fg.fragmentList.scan
>      (# ff: ^AST.fragmentForm; 
>         exp: ^AST.expanded;
>      do (if current.type=AST.FormType then
>             current.open->ff[];
>             ff.root[]->exp[];
>             (if exp.symbol=BETA.AttributesForm then
>                 exp[]->scanFragment;
>             if);
>         if);
>      #);
>      
>      (* Then run through the remaining fragments: *)
>      
>      fg.fragmentList.scan
>      (# ff: ^AST.fragmentForm; 
>         exp: ^AST.expanded;
>      do (if current.type //AST.FormType then
>             current.open->ff[];
>             ff.root[]->exp[];
>             (if exp.symbol<>BETA.AttributesForm then
>                 exp[]->scanFragment;
>             if);
>         if);
>      #);
>      
>      groupName[]->onScanDone;
>      
>   exit new[]   
>   #);
> 

From sbrandt@daimi.aau.dk Tue Mar 21 10:43:20 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA16947
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Tue, 21 Mar 1995 10:43:08 +0100
Received: by quercus.daimi.aau.dk id AA01747
  (5.67b8/IDA-1.5 for sbrandt@daimi.aau.dk); Tue, 21 Mar 1995 10:42:54 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199503210942.AA01747@quercus.daimi.aau.dk>
Subject: Re: Valhalla step spm!
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Tue, 21 Mar 1995 10:42:53 +0100 (MET)
Cc: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk
In-Reply-To: <9503210727.AA28778@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Mar 20, 95 11:27:40 pm
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 13587     
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


> > Et loesnings forslag som bedes kommenteret, er foelgende:
> > 
> > Givet "current object" og den nameApl som evaluerer til en virtuel hvis
> > entry point vi skal finde, goer foelgende:
> > 
> >   1. Find frem til det object hvis virtuel tabel indeholder oplysninger
> >      om den soegte virtuelle.
> >   2. Slaa op i virtuel tabellen.
> >       
> >      2a: Hvis resultatet er et T entrypoint er vi vel faerdige.
> Ja
> >      2b: Hvis resultatet er et G entrypoint, saa find frem til det
> >          tilsvarende T entrypoint ved at gennemsoege de relevante
> >          tabeller (disse findes allerede).
> Ikke forstaaet? Virtuel tabellen indeholder aldrig et G-entrypoint???
> Saa hvad mener du her?

Jeg havde kortvarigt fortraengt hvad indholdet af virtuel tabellen er...
Det er ikke en viden jeg har haft alvorligt brug for foer nu.

> 
> Virtuel tabellen indeholder en af to ting:
> 
> a.	Et T-entry point
> 
> 	Er tilfeldet for viruelle erkleret som foelger
> 
> 		V:< (# ... #);
> 		V: < A(# ... #);
> 
> 	Her er origin altid det objekt der indeholder den virtuelle
>

Ok. Det tilfaelde er altsaa "let" (hvilket dog ikke betyder at det er gjort
paa mindre end en week-ends arbejde). Jeg har ikke noget at bruge origin til,
altsaa bortset fra at finde frem til dennes virtuel tabel.


> b.	Addresse paa kode der beregner origin og T-entrypoint
> 	
> 	Er tilfeldet for virtuelle erkleret som foelger
> 
> 		V:< A;
> 
> 	For disse gelder at origin skal beregnes, og det genereres der
> 	kode til.
> 
> 	Det er defor nok ikke saa nemt at se hvilket T-entrypoint der
> 	fakstisk genereres, uden at udfoere koden

Forudsat at denne kode ikke har nogen side effekter, hvilket jeg ville
forvente, kan jeg kalde den direkte. (Faktisk kan jeg kalde vilkaarlig 
kode i den debuggede process, forudsat at det ikke har nogen side effekter.
Dette udelukker dog i praksis at jeg kalder BETA kode fra debuggeren.)

> 
> Et virtuelt kald har normalt formen
> 
>         (e,e2,e3)-> R.V -> x
> 
> 	@@R ->  originReg (%o0)
> 
> 	a. via [%o0] slaa op i virtuel tabellen -> %i1
> 	   som saa er prototypen
> 
> 	b. .... -> %i1 
> 	   call %i1
> 
> 	  hvor der hoppes til kode af formen
> 
> 		ld [%o0+8],%o0
> 	         ....
> 	 	...., %o0  som saa er origin
> 		lea T117FOO,%o0	prototypen
> 
> 		rts


Oehmm, som du selv siger er du lettere beruset. Et kig i en ..s fil
giver foelgende eksempel:

.L3:	ld	[%o0+80],%o0
	sethi	%hi(T26REMOTEDUMPER),%i1
	or	%i1,%lo(T26REMOTEDUMPER),%i1

	nop
	retl

Altsaa returneres origin i %o0, og prototypen i %i1. Som oensket uden
side effekter. Saa i dette tilfaelde kan jeg altsaa blot kalde koden, pille
den korrekte prototype ud af %i1, og derefter saette et breakpoint paa starten
af den foeste dopart for hvilken der er genereret kode. Dette er naturligvis
maskin-specifikt, men det drejer sig om 4 linier assembler pr platform. Det
kan vi nok leve med.

2 spoergsmaal:

   1. Kan jeg vha. af semantiske attributter se forskel paa tilfaeldene
      a og b, altsaa om virtuel tabellen indeholder en prototype eller
      noget kode der beregner den?

   2. Kan jeg vha af semantiske attributter paa en dopart eller 
      objektdescriptor se om der genereres kode for doparten?

Saa vidt muligt vil jeg helst slippe for at skulle analysere ast'erne
direkte. Det er jeg allerede ude i naar jeg skal genskabe raekkefoelgen af 
prototyperne paa basis af AST'en alene. (Min kode for at goere dette er
inkluderet nedenfor, og er en kopi af noget compiler kode der er omskrevet
til at bruge astInterface i stedet for index.). Ogsaa paa det her punkt er det 
compilerens job, og jo mere af den slags der havner i debuggeren, jo mere 
saarbar bliver den overfor aendringer og forbedringer i compileren.

Lige en kommentar fra koden inkluderet i slutningen af denne mail, som har
relevans for "den compiler ansvarlige":

 	(* Code in this descriptor was based on "cProcDecoder"
         * from "sematt.bet" in the compiler, but rewritten
         * to use the "betacfl" interface instead of the
         * "index" interface. For maintainability, future 
         * compilers should set a semantic attribute revealing
         * whether an objectdescriptor generates a prototype. *)
                   
> 
> 	Og herefter for a og b
> 		
> 		call AlloI
> 
> 		overfoer e1,e2,e3...
> 		
> 		call M-for V ***************
> 
> 	Ved ******* peger %i1 paa det allokerede objekt.
> 
> 	Hvis M-entry pointet for V exsisterer hoopes direktte
> 	til det. Hvis det ikke existerer hoppes via
> 	inner tabellen for V (%i1)
> 
> 	Dvs hvis der kan saettes et breakpoiunt ved ****
> 	kan man her let finde ud af hvor der hoppes
> 	til
> 
> 	men jeg kan ikke gennemskue om det er let.
> 
> 	Jeg er ogsaa lidt beruset lige  nu:-)
> 
> Iovrigt kan evaluation jo vere ret kompliceret:
> 
> 	(F,G,H)->R->S->(Q,W,E)
> 
> med mange objekter der kan udfoeres.

Det problem er klaret. Valhalla analyserer hele molevitten, og saetter
breakpoints alle de steder hvor den ikke kan afvise at ville havne som
naeste BETA imperativ. Alt afhaengig af hvad dine navne ovenfor betyder,
vil valhalla altsaa i ovenstaaende tilfaelde saette et breakpoint ved
entry pointet for F,G,H,R,S,Q,W og E. Ikke specielt smart, men til gengaeld
baade portabelt, og faktisk ogsaa mere effektivt end den gamle metode med
at single steppe processoren og kigge efter for hvert skridt om vi har
naaet noget kendt.

Dette er til gengaeld ogsaa noget af det mest langhaarede BETA kode jeg 
til dato har skrevet. Og vi er jo heller ikke faerdige endnu :-)

> 
> jeg kan ike se om det kan gi problemer for Valhalla med at 'finde'
> ud af hviket objekt der kaldes?
> 
> Maaske ville det generelt vere en god ide at kunne sette breakpoint
> paa et call af et M-entry point (og G-ogsaa?)
> 
> Det kunne saa ogsaa bruges til at lave trace med.

Det er blot et spoergsmaal om et passende bruger interface. Hele mekanikken
til at goere dette er allerede implementeret. Blot er der jo *mange* entry
points, og det ville ogsaa vaere temmelig ineffektivt. Signal haandtering
er ikke hurtigt. Maalinger lavet af nogen-jeg-ikke-kan-huske-navnet-paa antyder
at haandteringen af et signal i de fleste UNIX implementationer bruger 
processor tid svarende til ca. 10.000 instruktioner. Det er ret lang tid
at braende af pr. M entry for at kunne trace.

  -- Soren

> 
> Naa ikke mere  nu:-)
> 
> ---olm
> ~v
> 
> 
> 1
> > 
> > Dette vil jo saa ogsaa loese 499 tingene. Men hvad har du ellers i
> > aermet...?
> > 
> > Valhalla har brug for ressourcer... (Standard disclaimer, skift selv
> > valhalla ud med navnet paa din yndlings delkomponent :-)
> > 
> >   -- Soren
> > 
> > > 
> > > Soeren,
> > > 
> > > Kan Valhalla haandtere step for flg. program:
> > > 
> > > 	(# foo1: (# ... do ... #);
> > > 	   foo2: (# ... do ... #);
> > > 	     ...;
> > > 	   R: ^ object
> > >        do &foo1[]->R[]; R;
> > >           &foo2[]->R[]; R;
> > >          ...
> > >        #)
> > > 
> > > Jeg kan ikke proeve det selv da jeg sidder hjemme lige nu.
> > > 
> > > Sporgsmaalet henger selvfolgelig sammen med overvejelser i forbindelse
> > > med switch 499 og Valhalla.
> > > 
> > > I ovenstaaende program hoppes der jo ikke via det generelle pattern
> > > object og dets INNER.
> > > 
> > > ---olm
> > > 
> > > 
> > 
> > 
> 



Eksempel paa noget kode som egt. burde ligge i compileren, men som faktisk
er kopieret og omskrevet til brug i debuggeren:

newGroupsInfoElement:
  (# fg: ^AST.fragmentGroup; 
     new: ^element;
     groupName: ^Text;
     
     scanFragment:
       (# exp: ^AST.expanded;
          firstInDescriptorForm: @Boolean;
          CprocKind: (# exit 3 #); generalKind:  (# exit 4 #);
       enter exp[]
       do
          (exp.symbol=BETA.DescriptorForm)->firstInDescriptorForm;
          BETA.ObjectDescriptor->exp.suffixWalkForProd
          (# scanCat:: BETACFL.ObjectDescriptor;
             createsPrototype: @Boolean;
          do 
             (if (current.kind -> tos'%getByte[0]')
                 
              //CprocKind then
                 
                 (* Current is an external declaration. No prototype is generated
                  * UNLESS it is a callback procedure. *)
                 
                 (# (* Code in this descriptor was based on "cProcDecoder"
                     * from "sematt.bet" in the compiler, but rewritten
                     * to use the "betacfl" interface instead of the
                     * "index" interface. For maintainability, future 
                     * compilers should set a semantic attribute revealing
                     * whether an objectdescriptor generates a prototype. *)
                    
                    mp: ^BETACFL.MainPart; ap: ^BETACFL.ActionPart;
                    dp: ^BETACFL.DoPart; imps: ^BETACFL.Imperatives;
                    imp: ^BETACFL.Imp; ae: ^BETACFL.assignmentEvaluation; 
                    tr: ^BETACFL.Transaction; ad: ^BETACFL.attributeDenotation;
                    obd: ^BETACFL.objectDenotation;
                    a: ^AST.ast;
                    
                    getExtKind:
                      (# a: ^AST.ast; na: ^BETACFL.NameApl; t: ^Text;
                         createsPrototype :@Boolean;
                      enter a[]
                      do 
                         (if a.symbol//BETA.NameApl then
                             (a[]->na[]).getText->t[];
                             (if true
                              //'CallC'->t.equalNCS
                              //'CallPascal'->t.equalNCS
                              //'Pascal'->t.equalNCS
                              //'CallStd'->t.equalNCS
                              //'PascalTrap'->t.equalNCS then
                                 FALSE->createsPrototype;
                              else
                                 TRUE->createsPrototype;
                             if)
                          else
                             FALSE->createsPrototype;
                         if);
                      exit createsProtoType
                      #);
                    
                 do
                    (current.getMainPart->mp[]).getActionPart->ap[];
                    ap.getDoPartOpt->a[];
                    (if a.kind<>AST.kinds.optional then
                        (a[]->dp[]).getImperatives->imps[];
                        L: imps.newScan (# do current[]->imp[]; leave L #);
                        (if imp[]<>NONE then
                            (* imp is first imperative in dopart *)
                            (if imp.symbol
                             //BETA.assignmentEvaluation then
                                (* 'xxx'->YY *)
                                (imp[]->ae[]).getTransAction->tr[];
                                (if tr.symbol//BETA.objectDenotation then
                                    (tr[]->obd[]).getAttributeDenotation->ad[];
                                    ad[]->getExtKind->createsProtoType;
                                if);
                             //BETA.objectDenotation then
                                (imp[]->obd[]).getAttributeDenotation->ad[];
                                ad[]->getExtKind->createsProtoType;
                             else
                                TRUE->createsProtoType;
                            if);
                        if);
                    if);
                 #)
                 
              //generalKind then
                 
                 (if not (current.kind->TOS'%getBits[13,1]') then
                     (* Current is *not* an inserted item 
                      * of the inlined kind. *)
                     TRUE->createsPrototype;
                 if);
                 
             if);
             
             (if createsPrototype then
                 current[]->new.append;
                 (if firstInDescriptorForm then
                     (if (current.getPrefixOpt).kind<>AST.kinds.optional then
                         (* In descriptor forms with prefixed descriptors, the
                          * prototype is put twice into the data segment 
                          * prototype table! Don't know why! *)
                         current[]->new.append;
                     if);
                 if);
             if);
             FALSE->firstInDescriptorForm->createsPrototype;
          #);
       #);
     
  enter groupName[]
  do 
     groupName[]->fragmentGroupTable.getFragmentGroup->fg[];
     (if fg[]//NONE then leave newGroupsInfoElement if);
     
     groupName[]->onScan;
     
     &element[]->new[];
     fg[]->new.fg[];
     groupName.copy->new.groupName[];
     new[]->insert;
     
     (* First run through the attributes fragments in the group. They
      * are for some reason emitted first in the prototype table. *)
     
     fg.fragmentList.scan
     (# ff: ^AST.fragmentForm; 
        exp: ^AST.expanded;
     do (if current.type=AST.FormType then
            current.open->ff[];
            ff.root[]->exp[];
            (if exp.symbol=BETA.AttributesForm then
                exp[]->scanFragment;
            if);
        if);
     #);
     
     (* Then run through the remaining fragments: *)
     
     fg.fragmentList.scan
     (# ff: ^AST.fragmentForm; 
        exp: ^AST.expanded;
     do (if current.type //AST.FormType then
            current.open->ff[];
            ff.root[]->exp[];
            (if exp.symbol<>BETA.AttributesForm then
                exp[]->scanFragment;
            if);
        if);
     #);
     
     groupName[]->onScanDone;
     
  exit new[]   
  #);

From Ole.Madsen@eng.sun.com Tue Mar 21 08:27:54 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA13686
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Tue, 21 Mar 1995 08:27:44 +0100
Received: from Eng.Sun.COM (engmail2.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA23209; Mon, 20 Mar 95 23:27:42 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (5.x/SMI-5.3)
	id AA13965; Mon, 20 Mar 1995 23:27:39 -0800
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA28778; Mon, 20 Mar 1995 23:27:40 +0800
Date: Mon, 20 Mar 1995 23:27:40 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9503210727.AA28778@det.Eng.Sun.COM>
To: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk
Subject: Re: Valhalla step spm!
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

Tak for svaret! Vi maa ha fundet en loesning.
Jeg har veret lidt hengt op ida, udover Tcl/Tk kursus
har vi haft gaester hele aftenenen, saa....

Saa kun et par enkelte kommentaeer her til aften!
> 
> 
> Jeg har ikke taenkt over dette special tilfaelde. Faktisk mente jeg
> at have testet at man ved kald af noget der var "virtual object" faktisk
> gik igennem object patternets dopart. Det ser dog alligevel ikke ud til
> at vaere tilfaeldet (jeg har lige proevet igen). Eller er det lavet
> om for nylig?
> 

Nej - intet er endret paa dette punkt de seneste aar!

> Naah, men for at loese ovennaevnte problem er det jo noedvendigt paa
> runtime at finde ud af hvad type "R" objektet har. Altsaa maa jeg finde
> objektet frem. Det skulle ikke vaere noget saerligt problem. 
> 
> Vaerre er det hvis R havde vaeret navnet paa et virtuelt pattern, og entry 
> pointet ikke kan bestemmes statisk, altsaa hvis det er en virtual som "V" i 
> eksemplet ovenfor. Hvad goer jeg saa? Under antagelse af at jeg kan finde
> frem til objektet som indeholder den virtuelle (skulle vel vaere muligt),
> hvordan finder jeg saa ud af den faktiske type paa den virtuelle?
> Et loesnings forslag som bedes kommenteret, er foelgende:
> 
> Givet "current object" og den nameApl som evaluerer til en virtuel hvis
> entry point vi skal finde, goer foelgende:
> 
>   1. Find frem til det object hvis virtuel tabel indeholder oplysninger
>      om den soegte virtuelle.
>   2. Slaa op i virtuel tabellen.
>       
>      2a: Hvis resultatet er et T entrypoint er vi vel faerdige.
Ja
>      2b: Hvis resultatet er et G entrypoint, saa find frem til det
>          tilsvarende T entrypoint ved at gennemsoege de relevante
>          tabeller (disse findes allerede).
Ikke forstaaet? Virtuel tabellen indeholder aldrig et G-entrypoint???
Saa hvad mener du her?

Virtuel tabellen indeholder en af to ting:

a.	Et T-entry point

	Er tilfeldet for viruelle erkleret som foelger

		V:< (# ... #);
		V: < A(# ... #);

	Her er origin altid det objekt der indeholder den virtuelle

b.	Addresse paa kode der beregner origin og T-entrypoint
	
	Er tilfeldet for virtuelle erkleret som foelger

		V:< A;

	For disse gelder at origin skal beregnes, og det genereres der
	kode til.

	Det er defor nok ikke saa nemt at se hvilket T-entrypoint der
	fakstisk genereres, uden at udfoere koden

Et virtuelt kald har normalt formen

        (e,e2,e3)-> R.V -> x

	@@R ->  originReg (%o0)

	a. via [%o0] slaa op i virtuel tabellen -> %i1
	   som saa er prototypen

	b. .... -> %i1 
	   call %i1

	  hvor der hoppes til kode af formen

		ld [%o0+8],%o0
	         ....
	 	...., %o0  som saa er origin
		lea T117FOO,%o0	prototypen

		rts

	Og herefter for a og b
		
		call AlloI

		overfoer e1,e2,e3...
		
		call M-for V ***************

	Ved ******* peger %i1 paa det allokerede objekt.

	Hvis M-entry pointet for V exsisterer hoopes direktte
	til det. Hvis det ikke existerer hoppes via
	inner tabellen for V (%i1)

	Dvs hvis der kan saettes et breakpoiunt ved ****
	kan man her let finde ud af hvor der hoppes
	til

	men jeg kan ikke gennemskue om det er let.

	Jeg er ogsaa lidt beruset lige  nu:-)

Iovrigt kan evaluation jo vere ret kompliceret:

	(F,G,H)->R->S->(Q,W,E)

med mange objekter der kan udfoeres.

jeg kan ike se om det kan gi problemer for Valhalla med at 'finde'
ud af hviket objekt der kaldes?

Maaske ville det generelt vere en god ide at kunne sette breakpoint
paa et call af et M-entry point (og G-ogsaa?)

Det kunne saa ogsaa bruges til at lave trace med.

Naa ikke mere  nu:-)

---olm
~v


1
> 
> Dette vil jo saa ogsaa loese 499 tingene. Men hvad har du ellers i
> aermet...?
> 
> Valhalla har brug for ressourcer... (Standard disclaimer, skift selv
> valhalla ud med navnet paa din yndlings delkomponent :-)
> 
>   -- Soren
> 
> > 
> > Soeren,
> > 
> > Kan Valhalla haandtere step for flg. program:
> > 
> > 	(# foo1: (# ... do ... #);
> > 	   foo2: (# ... do ... #);
> > 	     ...;
> > 	   R: ^ object
> >        do &foo1[]->R[]; R;
> >           &foo2[]->R[]; R;
> >          ...
> >        #)
> > 
> > Jeg kan ikke proeve det selv da jeg sidder hjemme lige nu.
> > 
> > Sporgsmaalet henger selvfolgelig sammen med overvejelser i forbindelse
> > med switch 499 og Valhalla.
> > 
> > I ovenstaaende program hoppes der jo ikke via det generelle pattern
> > object og dets INNER.
> > 
> > ---olm
> > 
> > 
> 
> 

From Ole.Madsen@eng.sun.com Mon Mar 20 00:08:09 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA06201
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Mon, 20 Mar 1995 00:08:05 +0100
Received: from Eng.Sun.COM (engmail2.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA05566; Sun, 19 Mar 95 15:08:01 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (5.x/SMI-5.3)
	id AA23929; Sun, 19 Mar 1995 15:07:58 -0800
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA25823; Sun, 19 Mar 1995 15:07:58 +0800
Date: Sun, 19 Mar 1995 15:07:58 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9503192307.AA25823@det.Eng.Sun.COM>
To: sbrandt@daimi.aau.dk
Cc: Ole.Madsen@eng.sun.com
Subject: Valhalla step spm!
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

Soeren,

Kan Valhalla haandtere step for flg. program:

	(# foo1: (# ... do ... #);
	   foo2: (# ... do ... #);
	     ...;
	   R: ^ object
       do &foo1[]->R[]; R;
          &foo2[]->R[]; R;
         ...
       #)

Jeg kan ikke proeve det selv da jeg sidder hjemme lige nu.

Sporgsmaalet henger selvfolgelig sammen med overvejelser i forbindelse
med switch 499 og Valhalla.

I ovenstaaende program hoppes der jo ikke via det generelle pattern
object og dets INNER.

---olm


From sbrandt@daimi.aau.dk Mon Feb 27 22:29:13 1995
Received: from xdaimi.daimi.aau.dk by daimi.aau.dk with SMTP id AA22605
  (5.67b8/IDA-1.5); Mon, 27 Feb 1995 22:29:09 +0100
Received: by xdaimi.daimi.aau.dk id AA07523
  (5.67b8/IDA-1.5); Mon, 27 Feb 1995 22:27:31 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199502272127.AA07523@xdaimi.daimi.aau.dk>
Subject: Re: Compiler update paa DAIMI
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Mon, 27 Feb 95 22:27:28 GMT
Cc: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk, datpete@mjolner.dk,
        ess@daimi.aau.dk, jacobse@daimi.aau.dk, jlk@daimi.aau.dk,
        kjm@mjolner.dk, pingel@daimi.aau.dk, pjs@mjolner.dk,
        pryberg@mjolner.dk
In-Reply-To: <9502271823.AA29182@det.Eng.Sun.COM>; from "Ole Lehrmann Madsen" at Feb 27, 95 10:23 am
X-Mailer: ELM [version 2.3 PL11]
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

> 
> 
> jeg er enig i at 499 ikke skal bruges lige med det samme.
> Den gir dog betragtelige forbedringer hvad angaar plads og tid,
> saa ...!

Jamen dem vil jeg jo ogsaa gerne ha' :-)

> 
> 
> > > 2.	Elimination of superflous G-parts and M-parts.
> > > 
> > > 	No code is generated for empty G-parts.
> > > 	No  M-code is generated ro patterns of the form
> > > 
> > > 		P: (# do inner #)
> > > 
> > > 	These changes are INCOMPATIBLE with r3.0. Are only in effect
> > > 	when using option 499.
> > > 	All files including basiclib must be translated using 499.
> > > 	I.e. if you start using this option, a complete new version must
> > > 	be made, and care should be taken to ensure that 499 is then
> > > 	ALWAYS used for this version. 
> > 
> > Som Peter er inde paa, er disse aendringer ikke ligefrem noget som
> > elskes af personer med valhalla-implementations-kasketten paa.
> > 
> > Hvorfor nu ikke det? Jo, naar valhalla2.0 laver single-step, sker det
> > ved at analysere det aktuelle imperativ, og paa basis heraf forudse alle
> > steder i BETA koden hvor man kan havne naeste gang. Alle saadanne steder
> > saettes der saa et breakpoint inden processen faar lov til at fortsaette.
> > 
> > For nu at eksemplificere, er et af mange tilfaelde en name-application
> > "na" der statisk denoterer et pattern "p". I saa fald findes "p" frem
> > (descRef semantisk attribut), og prefix kaeden fra "p" foelges til
> > tops. Endelig saettes saa et breakpoint paa foerste imperativ i
> > doparten af dette "oeverste" super pattern (Ja, det _er_ langhaaret,
> > men alternativet er noget maskin-afhaengigt stads der er naermest
> > umuligt at portere.).  Da dette foerste imperativ jo kan vaere en
> > "inner" af slagsen der ikke genereres kode for, vil valhalla2.0 i sin
> > nuvaerende udgave fejle.
> > 
> > Hvordan loeses dette problem saa? Svaret er (naturligvis) at man i stedet
> > for det "oeverste" super pattern skal bruge det "oeverste" der har en
> > dopart som der genereres kode for. Men dette pattern er ikke noedvendigvis
> > kendt paa compile-time, og generelt kraever det altsaa at processens
> > aktuelle tilstand inddrages for at saette breakpointet et korrekt sted.
> > 
> 
> Compilereren goer saadan, altsaa
> 
> 1.	hvor det er statisk afgoerligt finder den det oeverste prefiks
>  	hvor der er mere end en INNER og kalder dette.
> 	Det kan Valhalla som sagt ogsaa goere

Ja. Er der en let maade at afgoere paa om dette er tilfaeldet, givet en
ObjectDescriptor?

> 
> 2.	De andre steder eksekvere indirekte via inner-tabellen for
> 	objektet. Og det er som du skriver ikke saa nemt at haandtere
> 	da man ikke ved hvor man hopper hen.
> 
> Som sagt er jeg enig I at 499 ikke skal i sving med det samme, 
> saa vi faar lidt tid til at tenke over en loesning. 
> Jeg synes ikke at det er en god ide med 2 set objekt-filer.
> Det fylder extra og gir mere bogholderi, og har den for brugere
> store ulempe at man IKKE umiddelbart kan debugge et program
> uden at generere nye filer.

Det kan han nu heller ikke med nogen andre compilere. Som regel forudsaettes
det at object-filer er oversat med -g for at kunne debugges. Hvis det ikke er
tilfaeldet maa man generere nye objekt-filer. I vores tilfaelde ville det
minimum kraeve at der blev skabt ..db filer, og det er jo ikke noedvendigvis 
mindre arbejde end at skabe .o filer. Paa RISC platforme og hvor vi har binaer
kodegenerering skal ..s filen ganske vist ikke skrives ud og assembles, men
bortset fra det er arbejdet jo det samme. Paa linux og nti, hvor det 
planlaegges at bruge stabs samt .oTIL..db praeprocessor, skal der ogsaa skabes
nye .o filer. Ioevrigt er det generelt umuligt at debugge optimeret
kode, da der i noget saadant ikke er en simpel korrespondance mellem
binar kode og kildetekst. Saa hvis compileren for alvor begynder at
optimere kommer vi ikke udenom 2 saet objektfiler alligevel.

> 
> En simpel loesning kunne vere at fortelle brugeren hvordan
> koden genereres, og saa maa brugeren satte breakpoint i de
> do-parts han mener er relevante.

Duer ikke. Den naevnte beregning af mulige naeste kode-adresser foretages
hver gang der skal steppes henover et blivende breakpoint. Det gider
brugeren formentlig ikke at rodes ind i. Ioevrigt er en single step 
facilitet hvor brugeren skal fortaelle hvor man stepper hen ikke meget
vaerd. Det er heller ikke givet at han kender svaret.

> Hvordan haandteres lign. problemer for fx C++. Der har man ikke
> et superpattern med en inner der altid exekveres?

Haandteres (formentlig) ikke. Man bruger en svaert-portabel, maskin-
afhaengig maade at single-steppe paa processor-niveau. Udover at
vi gerne skulle undgaa ikke-portable loesninger, vil det vaere meget
svaert med det nuvaerende design af valhalla2.0 at implementere single
step paa processor niveau. Og ioevrigt er denne loesning haabloest
ineffektiv. Hvis I vil vide hvorfor, skal jeg gerne forklare det. Men
overvej hvor lang tid det vil tage at single-steppe igennem en AOA-collection,
saa naermer I jer en slags forstaaelse... :-)

> 
> Det er som jeg skrev i praxis mest omkring virtuelle kald at
> problemet findes:
> 
> 	A: (# V:< (# do inner #) ... #)
> 
> Har Valhalla mulighed for at finde samtlige subpatterns af A?
> Den har al informationen i form af prototyper, saa i princippet kan
> det lade sig goere?

Det var muligvis en maade at goere det paa. Det vil blot betyde at
valhalla (inkrementelt) skal opbygge en slags global inheritance graf
for hele den debuggede process. Men det er bestemt ikke umuligt...
Skal overvejes.

  -- Soren

> 
> ---olm
> 
> 
> > KORT SAGT: Det her bliver skide indviklet... Faktisk er jeg bange for at
> > det bliver saa indviklet, at det skal overvejes om man skal undlade
> > denne optimering i programmer der er oversat med -g. Det kan man saa goere
> > ved at generere specielle object filer til brug ved debugging. Altsaa ved
> > at holde fast i ".go" som objekt-filer til brug ved debugging. 
> > 
> 
> 
> >   -- Soren
> > 
> 


From sbrandt@daimi.aau.dk Mon Feb 27 18:39:19 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA18780
  (5.67b8/IDA-1.5); Mon, 27 Feb 1995 18:39:16 +0100
Received: by quercus.daimi.aau.dk id AA09591
  (5.67b8/IDA-1.5); Mon, 27 Feb 1995 18:37:31 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199502271737.AA09591@quercus.daimi.aau.dk>
Subject: Re: Compiler update paa DAIMI
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Mon, 27 Feb 1995 18:37:01 +0100 (MET)
Cc: datpete@mjolner.dk, ess@daimi.aau.dk, jacobse@daimi.aau.dk,
        jlk@daimi.aau.dk, kjm@mjolner.dk, Ole.Madsen@eng.sun.com,
        pingel@daimi.aau.dk, pjs@mjolner.dk, pryberg@mjolner.dk,
        sbrandt@daimi.aau.dk
In-Reply-To: <9502262124.AA27458@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Feb 26, 95 01:24:22 pm
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 4207      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

> 
> Folks,
> 
> Jeg har updateret beta5.1 paa DAIMI, men rettelserne vil IKKE vere
> tilgaengelige foer KIM har installeret en ny beta5.1/beta+.
> (Min opdatering er som saedvanlig i ~olm/beta/system/v5.1)
> (og jeg forstaar ikke hvad CVS har gjort, saa dont TRUST anything
> foer Kim/Peter har kigget paa det. De har faaet en 'cvs'-mail:-)
> 
> Jeg vedlaegger min tilfojelse til CHANGES. Flg. er en summary af
> rettelserne.  I bedes naerlaese CHANGES, samt udsende et passende
> uddrag til betaexp naar den nye version goeres offentlig.
> 
> 1.	New type checker for assignment, binary and unary operators
> 
> 	Type checking of simple types like integer, boolean, etc.
> 	has been made more restricted like in C and Pascal. 
> 	
> 
> 2.	Elimination of superflous G-parts and M-parts.
> 
> 	No code is generated for empty G-parts.
> 	No  M-code is generated ro patterns of the form
> 
> 		P: (# do inner #)
> 
> 	These changes are INCOMPATIBLE with r3.0. Are only in effect
> 	when using option 499.
> 	All files including basiclib must be translated using 499.
> 	I.e. if you start using this option, a complete new version must
> 	be made, and care should be taken to ensure that 499 is then
> 	ALWAYS used for this version. 

Som Peter er inde paa, er disse aendringer ikke ligefrem noget som
elskes af personer med valhalla-implementations-kasketten paa.

Hvorfor nu ikke det? Jo, naar valhalla2.0 laver single-step, sker det
ved at analysere det aktuelle imperativ, og paa basis heraf forudse alle
steder i BETA koden hvor man kan havne naeste gang. Alle saadanne steder
saettes der saa et breakpoint inden processen faar lov til at fortsaette.

For nu at eksemplificere, er et af mange tilfaelde en name-application
"na" der statisk denoterer et pattern "p". I saa fald findes "p" frem
(descRef semantisk attribut), og prefix kaeden fra "p" foelges til
tops. Endelig saettes saa et breakpoint paa foerste imperativ i
doparten af dette "oeverste" super pattern (Ja, det _er_ langhaaret,
men alternativet er noget maskin-afhaengigt stads der er naermest
umuligt at portere.).  Da dette foerste imperativ jo kan vaere en
"inner" af slagsen der ikke genereres kode for, vil valhalla2.0 i sin
nuvaerende udgave fejle.

Hvordan loeses dette problem saa? Svaret er (naturligvis) at man i stedet
for det "oeverste" super pattern skal bruge det "oeverste" der har en
dopart som der genereres kode for. Men dette pattern er ikke noedvendigvis
kendt paa compile-time, og generelt kraever det altsaa at processens
aktuelle tilstand inddrages for at saette breakpointet et korrekt sted.

KORT SAGT: Det her bliver skide indviklet... Faktisk er jeg bange for at
det bliver saa indviklet, at det skal overvejes om man skal undlade
denne optimering i programmer der er oversat med -g. Det kan man saa goere
ved at generere specielle object filer til brug ved debugging. Altsaa ved
at holde fast i ".go" som objekt-filer til brug ved debugging. 

> ...
> OLM: 7/1/95:	Eliminated M-part for descriptors of the form
> 		   P(# ... do INNER #)
> 	        where P has the same form. I.e. the do-part consists of
> 		exactly one inner. The descriptor may have an enter/exit-part.
> 
> 		Consider
> 			A: (# do INNER #)
> 		        B: A(# do ... #);
> 
> 		Previously execution of 'B' implied a jsr A.M-part, where
> 		inner implied a jsr to B.M-part.
> 
> 		Now execution of 'B' implies a direct jsr B.M-part.
> 
> 		Previously execution of 'A' implied a jsr A.M-part. This
> 		is no longer possible. Instead an indirect jsr is made
> 		via the prototype inner-table for A. This will imply
> 		execution of Return (See below). Execution of 'A' is thus
> 		now made in the same way as execution of 'X' where
> 			X: ^object
> 		in which case the M-part of 'X' is not know.
> 
> 		This optimization requires a change of the protype-inner table.
> 		Previously:
> 
> 				Return
> 				A.M-part
> 			A.Txx:	...
> 
> 				Return
> 				B.M-part
> 				A.M-part
> 			B.Tyy:	...
> 		Now:
> 
> 				Return
> 				Return		<--------------------
> 			A.Txx:	...
> 
> 				Return
> 				B.M-part
> 				B.M-part	<--------------------
> 			B.Tyy:	...
> 
> 		This change may affect beta.dump and the debugger!!

JAAAHHHHHHHHH!!!!!


  -- Soren

From sbrandt@daimi.aau.dk Tue Feb  7 23:04:03 1995
Received: from blanche.daimi.aau.dk by daimi.aau.dk with SMTP id AA07074
  (5.67b8/IDA-1.5); Tue, 7 Feb 1995 23:04:01 +0100
Received: by blanche.daimi.aau.dk id AA04902
  (5.67b8/IDA-1.5); Tue, 7 Feb 1995 23:03:53 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199502072203.AA04902@blanche.daimi.aau.dk>
Subject: Re: Referat af morgenm|de 3-2-95
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Tue, 7 Feb 1995 23:03:52 +0100 (MET)
Cc: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk, datpete@mjolner.dk,
        ess@mjolner.dk, jlk@daimi.aau.dk, kjm@mjolner.dk
In-Reply-To: <9502071820.AA22258@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Feb 7, 95 10:20:15 am
X-Mailer: ELM [version 2.4 PL23]
Content-Type: text
Content-Length: 2081      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


>  Aha -----------------------^^^^^^ ovenfor skrev du nameApl, man bare du ved
> hvad du vil:-)

Jamen jeg ved skam godt hvad jeg vil. Det ved I bare ikke... (Aev baev :-).
Det er jo lige det der med at faa det sagt.

> 
> Det er mig ikke helt klart hvad du mener med finde, men ethvert nameApl
> har en on-attribut der angir antal blok niveauer man skal gaa ud fra
> current object, saa din a.b.c kan decodes til en
> 
> 	nameApl  NA for 'a'
> 
> 	NA.on  angir antal origins man skal gaa fra this-object til
> 	det object der indeholder 'a'.
> 
> Men husk at et objekt kan ha flere origins, og NA.on er relativt
> til origin i det prefiks niveau hvor a.b.c forekommer textuelt.
> Dvs for hvert objekt niveau skal du ha fat i descriptoren og
> finde dens origin offset.

NA.on var lige det jeg var ude efter. Saa er jeg nemlig fri for selv at
soege efter erklaeringen af "a". I den gamle valhalla (altsaa v1.3) tvang 
dette mig til at aabne en grufuld masse fragmenter. Aarsagen hertil var 
nu primaert at navnet blev skrevet af brugeren i en dialog boks, og ikke
udpeget ved click. Jeg havde altsaa ingen nameApl at tage udgangpunkt
i.

> 
> Endelig kan der vere lidt kompliktationer omkring do-parts
> og inserted descriptors, hvor der maaske skal goeres noget specielt.
> For do-part objekter er origin-offset i offset 8.
> Og igen - ikke alle doparts gor anledning til et specielt objekt.
> 
> Lad mig vide om jeg skal give yderligere info.

Jo tak. Hvad betyder "lidt komplik(t)ationer"? Antaget at udgangspunktet
for soegningen er en inserted descriptor i en dopart som giver anledning
til et dopart objekt. NA.on inkluderer vel i saa fald ogsaa det ekstra
blok-niveau foraarsaget af dopart objektet? Saa i praksis goer det vel
ingen forskel? (Jeg kan godt kende dopart objekter naar jeg moeder dem,
saa det er ikke noget principielt problem.)

> 
> Maaske skulle der vere et lib et eller andet sted der kan bruges
> til dette.
> 

Hvor Hvem Hvad Er det noget jeg kan faa fingre i ?????????????

Men det er vel baseret paa index interfacet til ast'er?

> ---olm

  -- Soren

From Ole.Madsen@eng.sun.com Tue Feb  7 19:21:38 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA03848
  (5.67b8/IDA-1.5); Tue, 7 Feb 1995 19:21:01 +0100
Received: from Eng.Sun.COM (engmail2.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA18304; Tue, 7 Feb 95 10:20:29 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (5.x/SMI-5.3)
	id AA02383; Tue, 7 Feb 1995 10:20:22 -0800
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA22258; Tue, 7 Feb 1995 10:20:15 +0800
Date: Tue, 7 Feb 1995 10:20:15 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9502071820.AA22258@det.Eng.Sun.COM>
To: Ole.Madsen@eng.sun.com, sbrandt@daimi.aau.dk
Subject: Re: Referat af morgenm|de 3-2-95
Cc: datpete@mjolner.dk, ess@mjolner.dk, ole.madsen@eng.sun.com,
        jlk@daimi.aau.dk, kjm@mjolner.dk
X-Sun-Charset: US-ASCII
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


> > 
> > >   5. Diverse browse faciliteter:
> > >    
> > >         Codeviews: Foelge SLOTS, vise declarations/prefixes, fragment bindings,
> > >                    ... Altsammen meget simpelt, men er altsaa ikke gjort.
> > > 
> > >                    Soegning efter *substans* svarende til en nameApl. Dette
> > >                    indbefatter at man naturligvis skal have udgangspunkt i 
> > >                    en eller anden instans af koden der er udgangpunkt for
> > >                    soegningen. Knap saa simpelt.
> > > 
> > >                    Ole: Antaget at jeg har en nameApl samt et objekt der er
> > >                    en instans af den omgivende descriptor, er der saa en
> > >                    "let" maade, vha. semantiske attributter, at grave den
> > >                    tilsvarende substans frem?? Fortolkeren maa jo goere det
> > >                    "hele tiden".
> > 
> > Mener du flg.:
> > 
> > 	A: (# ....  x: ^T (eller @T) .... do ...; x; ... #)
> > 
> > og du har en reference til en A-instans samt  en nameApl for 'x'?
> > 
> > I givet fald vil  xNameApl.dclRef-> xNameDcl;
> > 		  xNameDcl.off
> > give offset i A-instansen hvor 'x' starter.
> > (syntaksen er temmelig pseduo men vel forstaaelig?_)
> 
> Det er selvfoelgelig en hjaelp (men det vidste jeg nu godt i forvejen). 
> Mere generelt har jeg en <AttributeDenotation> (dog ikke <computedRemote> 

 Aha -----------------------^^^^^^ ovenfor skrev du nameApl, man bare du ved
hvad du vil:-)

> eller <remotePrimitive>), som jeg oensker at evaluere. Lad os sige at
> udtrykket er "a.b.c". Spoergsmaalet gik saa paa om dette kan goeres lettere 
> end ved at
> 
>   1. Finde objektet o' indeholdende "a". Dette kan jo vaere et origin for 
>      "current object".
> 
>   2. Evaluere b attributten i o', resulterende i o''.
> 
>   3. Evaluere c attributten i o''.
> 
> 2 og 3 er selvfoelgelig simple givet din beskrivelse ovenfor, men med
> min nuvaerende viden er jeg noedt til selv at udfoere soegningen efter
> det origin pattern der indeholder "a". Er der semantiske attributter
> der letter dette (fx. et "block-level")? Uanset hvad kan omtalte
> soegning heldigvis klares generisk saa den kan benyttes af alle
> objectbrowsere, inclusive psbrowseren, fx. via TCL interfacet.

Det er mig ikke helt klart hvad du mener med finde, men ethvert nameApl
har en on-attribut der angir antal blok niveauer man skal gaa ud fra
current object, saa din a.b.c kan decodes til en

	nameApl  NA for 'a'

	NA.on  angir antal origins man skal gaa fra this-object til
	det object der indeholder 'a'.

Men husk at et objekt kan ha flere origins, og NA.on er relativt
til origin i det prefiks niveau hvor a.b.c forekommer textuelt.
Dvs for hvert objekt niveau skal du ha fat i descriptoren og
finde dens origin offset.

Endelig kan der vere lidt kompliktationer omkring do-parts
og inserted descriptors, hvor der maaske skal goeres noget specielt.
For do-part objekter er origin-offset i offset 8.
Og igen - ikke alle doparts gor anledning til et specielt objekt.

Lad mig vide om jeg skal give yderligere info.

Maaske skulle der vere et lib et eller andet sted der kan bruges
til dette.

---olm

> 
> > 
> > 
> > Jeg gleder mig til en alpha-version!
> 
> Det goer jeg ogsaa :-)
> 
>   -- Soren
> 

From sbrandt@daimi.aau.dk Mon Feb  6 00:05:41 1995
Received: from quercus.daimi.aau.dk by daimi.aau.dk with SMTP id AA07770
  (5.67b8/IDA-1.5); Mon, 6 Feb 1995 00:05:39 +0100
Received: by quercus.daimi.aau.dk id AA26647
  (5.67b8/IDA-1.5); Mon, 6 Feb 1995 00:05:33 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199502052305.AA26647@quercus.daimi.aau.dk>
Subject: SPARC ..db taeller fejl. VIGTIG!
To: datpete@mjolner.dk, kjm@mjolner.dk, ess@daimi.aau.dk, jlk@daimi.aau.dk,
        ole.madsen@eng.sun.com (Ole Lehrmann Madsen), sbrandt@daimi.aau.dk
Date: Mon, 6 Feb 1995 00:05:32 +0100 (MET)
X-Mailer: ELM [version 2.4 PL23beta2]
Content-Type: text
Content-Length: 1876      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


Oev. Saa er det taeller compileren alligevel forkert :-(

(Mindst) ved kald af MkTO benytter compileren sig af foelgende SPARC
syntetiske instruktion:

   set <Label>,%o?

Eksempel:

    .data
    .align 8
    .L160:
    .asciz "File"
    .align 4
    .text
    .align 4
	    set	.L160,%o0
	    mov	%i2,%o1
	    set	3,%o2
	    call	MkTO
	    nop

Problemet er at "set	.L160,%o0" kun taelles til 1 long, selvom den
faktisk fylder 2. Assembleren oversaetter den nemlig til foelgende:

	sethi %hi(.L160),%o0
	or %o0,%lo(.L160),%o0

I andre tilfaelde kan set-instruktionen godt noejes med 1 long, men det
kraever (ifoelge "SPARC Architecture Manual") enten at -4096<=<Value>=<4095, 
eller at value&0x1fff er 0. Ingen af delene kan sikres af assembleren i 
tilfaeldet "set	.L160,%o0", hvor vaerdien af .L160 foerst er endeligt kendt
paa link-time.

Altsaa:

  1. Pas paa naar der anvendes "set".
  2. Problemet skal rettes foer ny valhalla kan bruges i praksis.

Jeg fandt problemet ved at haandrette i assembler-filer genereret med
option 498. Hvis fx. compileren i koden for M35PROGRAM spytter !24 ud,
betyder dette at den foelgende instruktion gerne skulle befinde sig paa
offset 24 i forhold til M35PROGRAM. Dette kan checkes ved at anbringe en
global label M35PROGRAM_24, hvis vaerdi efter assemblering kan checkes
med nm. 

For at automatisere denne debugging vil jeg foreslaa foelgende:

  1. En compiler option der lader compileren generere de ovenfor omtalte
     globale labels. Evt. kan den noejes med at generere disse for startem
     af hvert BETA imperativ

  2. Et lille program der vha. nm checker at der for alle labels af formen
     MxPROGRAM_n gaelder at
 
       val(MxPROGRAM_n)-val(MxPROGRAM) = n

     Hvis dette ikke er tilfaeldet, er der en fejl. Det lille check-program
     kan, ihvertfald for UNIX platforme, skrives maskin-uafhaengigt.


  -- Soren

From sbrandt@daimi.aau.dk Fri Jan 20 11:34:41 1995
Received: from blanche.daimi.aau.dk by daimi.aau.dk with SMTP id AA28754
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Fri, 20 Jan 1995 11:34:39 +0100
Received: by blanche.daimi.aau.dk id AA18908
  (5.67b8/IDA-1.5); Fri, 20 Jan 1995 11:34:18 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199501201034.AA18908@blanche.daimi.aau.dk>
Subject: Re: ..db fejl -- ikke eksisterende ast indices
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Fri, 20 Jan 1995 11:34:17 +0100 (MET)
Cc: kjm@daimi.aau.dk, ole.madsen@eng.sun.com, sbrandt@daimi.aau.dk
In-Reply-To: <9501191820.AA02318@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Jan 19, 95 10:20:11 am
X-Mailer: ELM [version 2.4 PL23]
Content-Type: text
Content-Length: 7182      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

> 
> 
> >
> 
> Jeg kan ikke umiddelbart finde en fejl, saa foerst et par kommentarer/
> spoergsmaal
> 
> 1.	(1280,7500) burde som du skriver vere kooridinaterne
> 	for (if private.display//0 then ...if)
> 
> 	Og disse kordinater udskrives paa samme maade uanset om
> 	det er en if- for-, ...
> 	
> 	Er det ellers ok i for de fleste andre situationer?

Jeg har (endnu) ikke vaeret ude for noget lignende andre steder, og jeg har
ellers lavet dette pretty-print for en del ..db filer.

> 
> 
> 2.	(1616,7492) kan vaere fordi der er en tom imp efter
> 
> 		true->setUpDone;
> 
> 	Men det er jeg ikke sikker paa, idet der saa ogsaa burde vere
> 	en efter 'stop;' i then-delen. Massek fjerner MPS tomme
> 	imperativer fra AST-en. Den tomme i else-delen blir maaske bevaret
>         da der er en kommentar paa dette sted??
> 
> 	KIM kan det vere problemet?
> 
> For begge gaelder dog at jeg ikke forstaar hvorfor der ikke er en
> AST-knude?
> 
> Jeg bruger  imp.nodeId til at udskrive ast-knuden, og den kan der vel naeppe
> vere fejl i.

Som sagt faar jeg en "error in indexToNode" naar jeg forsoeger at faa fat
i ast-knuderne med index 7500 og 7492. Jeg proevede saa at skrive
hele descriptor asten ud med "ast.dump". I dette dump stod der ingen steder
en knude med ast index 7500. Jeg kan ikke huske om jeg checkede 7492.

  -- Soren

> 
> > 
> > Foelgende dopart stammer fra ~beta/guienv/v1.2/private/X11/guienv_unixbody.bet,
> > fragmentet "--- GUIENVdoSetUp: descriptor ---".
> > 
> > ============================================================================
> >     do inittickcount;
> >        private.theXtlib.init;
> >        initAppName;
> >        initAppClass;
> >        private.fallBackResources.init;
> >        private.options.init;
> >        &deviceInfo[] -> private.theDeviceInfo[] -> objectPool.put;
> >        XtToolkitInitialize;
> >        XtCreateApplicationContext -> private.appCon;
> >        (private.appCon,private.fallBackResources.address) -> XtAppSetFallbackResources;
> >        (private.appCon,0,
> >        private.appName,private.appClass,private.options[],0,getargc,getargv) 
> > 	 -> XtOpenDisplay -> private.display;
> >        (if private.display//0 then
> > 	   'Cannot open display' -> putLine;
> > 	   stop;
> > 	else
> > 	   private.display -> private.theDeviceInfo.init;
> > 	   initCursors;
> > 	   initBitmaps;
> > 	   initMenubar;
> > 	   initDeviceInfo; (* bifrost *)
> > 	   initBifrost; (* bifrost *)
> > 	   (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
> > 	   true -> setupDone;
> > 	   (* private.handleIdle.add; *)
> >        if);
> > ===========================================================================
> > 
> > Debug info genereret for denne dopart er:
> > 
> > ===========================================================================
> >       dopart <AstIndex>: 6516
> >              (8,6512)  inittickcount
> >              (40,6556)  private.theXtlib.init
> >              (76,6572)  initAppName
> >              (100,6588)  initAppClass
> >              (124,6632)  private.fallBackResources.init
> >              (168,6674)  private.options.init
> >              (228,6764)  &deviceInfo[]->private.theDeviceInfo[]->objectPool.put
> >              (392,6780)  XtToolkitInitialize
> >              (416,6834)  XtCreateApplicationContext->private.appCon
> >              (508,6938)  (private.appCon,private.fallBackResources.address)->XtAppSetFallbackResources
> >              (668,7168)  (private.appCon,0,private.appName,private.appClass,private.options[],0,getargc, getargv)->XtOpenDisplay->private.display
> >              (1280,7500)               
> >              (1296,7206)  0
> >              (1308,7238)  'Cannot open display'->putLine
> >              (1360,7252)  stop
> >              (1396,7240)  'Cannot open display'->putLine; stop;
> >              (1404,7336)  private.display->private.theDeviceInfo.init
> >              (1480,7352)  initCursors
> >              (1504,7368)  initBitmaps
> >              (1528,7384)  initMenubar
> >              (1552,7402)  initDeviceInfo
> >              (1576,7418)  initBifrost
> >              (1600,7452)  true->setupDone
> >              (1616,7492)              
> >              (1652,7338)  private.display->private.theDeviceInfo.init;initCursors;initBitmaps;initMenubar;initDeviceInfo;(*)initBifrost;(*)(*)true->setupDone;(*)
> >              (1652,6516)  inittickcount;private.theXtlib.init;initAppName;initAppClass;private.fallBackResources.init;private.options.init;&deviceInfo[]->private.theDeviceInfo[]->objectPool.put;XtToolkitInitialize;XtCreateApplicationContext->private.appCon;(private.appCon,private.fallBackResources.address)->XtAppSetFallbackResources;(private.appCon,0,private.appName,private.appClass,private.options[],0,getargc, getargv)->XtOpenDisplay->private.display;(if private.display // 0 then 'Cannot open display'->putLine; stop; else    private.display->private.theDeviceInfo.init;    initCursors;    initBitmaps;    initMenubar;    initDeviceInfo;    (*)    initBifrost;    (*)    (*)    true->setupDone;    (*)if);
> >              Endmarker: 65535
> > ===========================================================================
> > 
> > Bemaerk de 2 linier begyndende med "(1280,7500)" og "(1616,7492)". Ifoelge
> > mine beregninger burde foerstnaevnte vaere (kode-offset for "if"-en, ast-index
> > for if'en). Sidstnaevnte burde slet ikke vaere der.
> > 
> > Det rigtig morsomme er, at der tilsyneladende slet ikke er nogen ast-knuder
> > med index 7500 eller 7492. Naar der altsaa ikke staar noget pretty-print bag
> > de fejlagtige linier, er det fordi jeg eksplicit undlader at prettyprinte
> > disse indices. Hvis jeg goer det alligevel, faar jeg en "error in indexToNode,
> > yggdrasil stops, bla bla bla" fejl.
> > 
> > Linien der ikke burde vaere der (7492) skyldes maaske en fejl lignende en jeg
> > tidligere har rapporteret, og som Ole mente var rettet. Den oprindelige
> > fejl-meddelelse foelger nedenfor.
> > 
> Jeg rettede en fejl omkring if som kom naar der INGEN else-del var.
> Men der er aabenbart flere:-(
> 
> Jeg skal lede videre.
> 
> ---olm
> 
> >   -- Soren
> > 
> > 
> > 
> > >    2. DER ER EN BUG (eller inkonsistens) OMKRING IF:
> > > 
> > >       Denne bug er ikke afspejlet ovenfor, men visse if-konstruktioner 
> > >       resulterer i en ImperativeInfo med astIndex=0.
> > >      
> > >       F.eks. giver foelgende if:
> > > 
> > >             (if (a=0)//TRUE then b;c if);
> > > 
> > >       Anledning til:
> > >         
> > >              8 astIndex<(if (a = 0) // TRUE then b; c if)>
> > >              80 astIndex<b>
> > >              92 astIndex<c>
> > >              104 astIndex<b;c>
> > >              104 0
> > > 
> > >       Hvorimod folgende
> > > 
> > >              (if (a = 0) then b; c if)
> > > 
> > >       giver:
> > > 
> > >              8 astIndex<(if (a = 0) then b; c if)>
> > >              80 astIndex<b>
> > >              92 astIndex<c>
> > >              104 astIndex<b;c>
> > > 
> > >       Jeg kan ikke lige gennemskue hvilke if'er der forarsaager problemet, men
> > >       den sidste linie skal FJERNES!
> > > 
> > > 
> > 
> > 
> 


From sbrandt@daimi.aau.dk Fri Jan 20 09:42:30 1995
Received: from blanche.daimi.aau.dk by daimi.aau.dk with SMTP id AA26804
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Fri, 20 Jan 1995 09:42:15 +0100
Received: by blanche.daimi.aau.dk id AA18004
  (5.67b8/IDA-1.5); Fri, 20 Jan 1995 09:41:46 +0100
From: S|ren Brandt <sbrandt@daimi.aau.dk>
Message-Id: <199501200841.AA18004@blanche.daimi.aau.dk>
Subject: Re: valhalla og callback funktioner
To: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Date: Fri, 20 Jan 1995 09:41:45 +0100 (MET)
Cc: ole.madsen@eng.sun.com, kjm@daimi.aau.dk, sbrandt@daimi.aau.dk,
        datpete@daimi.aau.dk
In-Reply-To: <9501191844.AA02367@det.Eng.Sun.COM> from "Ole Lehrmann Madsen" at Jan 19, 95 10:44:18 am
X-Mailer: ELM [version 2.4 PL23]
Content-Type: text
Content-Length: 9956      
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO

 > 
> Jeg forstaar simplet hen ikke hvad det er du mener her???

Ok. Naar man fra C kalder funktionen foo, bliver koden efter
"foo" entry pointet udfoert via CBFA. foo piller saa parametre
af stakken og kalder defefter M1PROGRAM. Altsaa ser returaddresserne
paa stakken nu (ca) ud som foelger (voksende nedefra og op):

   foo+64
   <<Et eller andet i CBFA>>
   <<C kode>>

Naar valhalla analyserer denne stak, vil foo+64 blive fortolket som
BETA kode, eftersom det jo faktisk befinder sig i kode-segmentet
hoerende til en BETA gruppe. Det "logiske" valg ville nu vaere
hvis valhalla kunne vise denne returadresse som svarende til
"cExternalEntry" imperativet, da det jo faktisk er det der er
tilfaeldet.

Men som ..db filen genereres nu, mapper valhalla "foo+64" til det
imperativ i doparten svarende til M1PROGRAM, som har det stoerste
kodeoffset. Maaden dette kommer frem paa, er foelgende:

  1. Foerst lokaliseres det stoerste M (eller G) entry point som er 
     mindre end "foo+64". I dit eksempel M1PROGRAM. 

  2. Find frem til  ..db informationerne svarende til dette M1PROGRRAM.

  3. Find det stoerste offset i doparten svarende til M1PROGRAM som er
     mindre end "foo+64-M1PROGRAM". Det tilhoerende ast index udpeger
     saa det soegte BETA imperativ.

Men det er jo netop det "sidste" imperativ i M1PROGRAM, og ikke
"cExternalEntry" imperativet.

Problemet kan loeses paa 2 maader. 

  1. Den jeg kunne komme i tanker om i gaar, nemlig at lade ..db
     kodeoffsettet for cExternalEntry vaere (foo-M1PROGRAM). Lige nu
     er kode-offsettet 8, hvilket er det samme som for "(a+b)->c".
     Altsaa en flertydighed som risikerer at resultere i at koden
     svarende til "(a+b)->c" mappes til ast indexet angivet for
     "cExternalEntry".

  2. Generere en indgang i ..db filen naar foo entry pointet genereres.
     Denne indgang skal indeholde (foo-M1PROGRAM,astindex(cExternalEntry)).
     Naar foo entry pointet genereres burde disse oplysninger vaere
     tilgangelige.

Jeg vil foreslaa metode 2, som sikkert er lettest at haandtere.

Endelig vil jeg godt have at du helt fjerner ..db indgange for imperativer 
der ikke genereres kode for, da disse resulterer i flere muligheder naar
et kode-offset skal mappes til det tilsvarende imperativ. Mere generelt
boer det sikres, at der for samme dopart ikke findes 2 ens kode-offsets
med forskellige ast indices.

Ioevrigt forstaar jeg ikke 498 outputtet. Udpluk:
   
     > M2PROGRAM:	mov	%i1,%o0
     > 	save	%sp,-64,%sp
     > .L5:
     > !  8,8  <=========================
     > .stabn 68,0,69,.L6
     > .L6:
     > !  cExternalEntry  
     > !  8,0 <=========================
     > .stabn 68,0,95,.L7
     > .L7:
     > !  a+b->c  
     > 	ld	[%i0+412],%l0
     > !12
     > 	ld	[%i0+416],%l7
     > !16
     > 	add	%l7,%l0,%l0
     > !20
     > 	st	%l0,[%i0+420]
     > !24
     > !  24,16 <=========================

Jeg antager at linierne !x afsloerer hvor din taeller er kommet til. Men
hvad betyder y'et i linier af formen "!  x,y"? Laengden af den genererede
kode?

  -- Soren

> 
> Hwer er et eksempel med callBack
> 
> origin 'tstenv'
> ---program:descriptor---
> (# foo: External
>      (# a,b,c: @integer
>      enter(a,b,c)
>      do cExternalEntry;
>         a+b->c; 
>         a*c->c
>      exit c
>      #);
>    v: @integer
> do 
> #)
> >
> Med kode (498:-)
> 
> .global G1PROGRAM
> G1PROGRAM:!  foo: External
> !  v: @integer  
> 	nop
> !28
> 	retl
> 	nop
> .global M1PROGRAM
> M1PROGRAM:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> .L3:
> !  8,8
> .stabn 68,0,0,.L4
> .L4:
> 	ret
> 	restore
> .stabs "PROGRAM",38,0,134,T2PROGRAM
> .global G2PROGRAM
> G2PROGRAM:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> !  a,b,c: @integer  
> 	ret
> 	restore
> .global M2PROGRAM<<<<<<<<<<<<<<<<<<<<< do-del af M-entrypoint for foo
> 			<<<<<<<<<<<<<<< Er dette ikke OK?
> 			<<<<<<<<<<<<<<< du skriver at det er forkert
> M2PROGRAM:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> .L5:
> !  8,8
> .stabn 68,0,69,.L6
> .L6:
> !  cExternalEntry  
> !  8,0
> .stabn 68,0,95,.L7
> .L7:
> !  a+b->c  
> 	ld	[%i0+412],%l0
> !12
> 	ld	[%i0+416],%l7
> !16
> 	add	%l7,%l0,%l0
> !20
> 	st	%l0,[%i0+420]
> !24
> !  24,16
> .stabn 68,0,119,.L8
> .L8:
> !  a*c->c  
> 	ld	[%i0+420],%l0
> !28
> 	ld	[%i0+412],%o0
> !32
> 	mov	%l0,%o1
> !36
> 	set	0,%i3
> 	set	0,%i4
> 	call	.mul
> !48
> 	set	0,%i2
> 	mov	%o0,%l0

> 	st	%l0,[%i0+420]
> !60
> !  60,36
> .stabn 68,0,0,.L9
> .L9:
> 	ret
> 	restore
> .global foo<<<<<<<<<<<<<<<<<<<<<<<<<<< foo-entry point
>             <<<<<<<<<<< Det gir klart INGEN mening!!, da talleren
> 			blot fortsetter som efter den forrige
> 			Jeg kan her let cleare taelleren
> 			saa de flg instruktioner blir relative
> 			til foo, men det er ikk det du ber om?
> ---olm
> 
> foo:	mov	%i1,%o0
> 	save	%sp,-64,%sp
> 	mov	%i0,%o0
> 	mov	%i1,%l0
> !84
> 	mov	%i2,%l1
> !88
> 	set	0,%i2
> !92
> 	mov	%i3,%l2
> !96
> 	set	0,%i3
> !100
> 	mov	%i0,%i1
> !  Get long
> 	mov	%l0,%l3
> !108
> 	st	%l3,[%i1+412]
> !112
> !  Get long
> 	mov	%l1,%l0
> !116
> 	st	%l0,[%i1+416]
> !120
> !  Get long
> 	mov	%l2,%l0
> !124
> 	st	%l0,[%i1+420]
> !128
> 	call	M2PROGRAM
> !132
> 	nop
> 	ld	[%i1+420],%l0
> !140
> 	mov	%l0,%i0
> 	ret
> 	restore
> BETA_code2:	nop
> .data
> BETA_data2:.word 2
> .global T1PROGRAM
> .word T1PROGRAM
> .global T2PROGRAM
> .word T2PROGRAM
> .asciz "/home/olm/beta/system/v5.1/TST/zcallback"
> .align 4
> .word Return
> .word M1PROGRAM
> T1PROGRAM:.half 20
> .half 2
> .word G1PROGRAM
> .word T27ENV
> .half 4
> .half 0
> .half 1
> .half 163
> .half 0
> .half 10
> .half 0
> .asciz "PROGRAM-~"
> .align 4
> .word Return
> .word M2PROGRAM
> T2PROGRAM:.half 24
> .half 2
> .word G2PROGRAM
> .word T27ENV
> .half 106
> .half 0
> .half 1
> .half 134
> .word foo
> .half 0
> .half 10
> .half 0
> .asciz "foo#"
> .align 4
> BETA_data3:!    
> 
> > 
> > Betragt foelgende kode segment fra ~beta/guienv/v1.2/private/X11/widgetbody:
> > 
> >     -- GUIENVcallbackSelectorAdd: descriptor --
> >     (# callCallbackSelector: external
> > 	 (# w,client_data,call_data: @integer;
> > 	 enter (w,client_data,call_data)
> > 	 do cExternalEntry;
> > 	    call_data -> data.ptr;
> > 	    (if XsystemEnvPresent//true then
> > 		this(callbackSelector)[] -> XsystemEnvHandleCallback;
> > 	     else
> > 		this(callbackSelector);
> > 	    if);
> > 	 #);
> >        t: @text;
> >     do (widgetID,name,callCallbackSelector##,0) -> XtAddCallback;
> >     #)
> > 
> > Genereret kode foelger i bunden af denne mail. 
> > 
> > cExternalEntry's resulterer i genereringen af et entry point som foerst 
> > piller C parametre af stakken, og derefter kalder det tilsvarende BETA 
> > entry point.
> > 
> > For doparten i "callCallbackSelector: external" genereres foelgende ..db info.
> > (x,y) betyder her ("codeoffset fra start a Mentry",ast index). Det tilsvarende
> > imperativ er derefter pretty-printet.
> > 
> >       dopart <AstIndex>: 156
> >              (8,152)  cExternalEntry
> >              (8,200)  call_data->data.ptr
> >              (32,318)  (if XsystemEnvPresent // true then <<AssignmentEvaluation>>; else THIS(callbackSelector);if)
> >              (56,230)  true
> >              (68,282)  THIS(callbackSelector)[]->XsystemEnvHandleCallback
> >              (168,284)  THIS(callbackSelector)[]->XsystemEnvHandleCallback;
> >              (176,308)  THIS(callbackSelector)
> >              (200,312)  THIS(callbackSelector);
> >              (200,156)  cExternalEntry;call_data->data.ptr;(if XsystemEnvPresent // true then <<Imperatives>> else THIS(callbackSelector);if);
> >              Endmarker: 65535
> > 
> > Dette er forkert, da codeOffset for "cExternalEntry" snarere burde vaere 
> > noget i stil med "callCallbackSelector - M2GUIENVCALLBACKSELECTORADD", 
> > eftersom koden genereret for cExternalEntry ligger *efter* resten af koden 
> > for denne dopart.
> > 
> > Fejlen faar ny valhalla til at mappe adresser i cExternalEntry koden
> > til et af de andre imperativer i ovenstaaende liste. Naermere betegnet det
> > imperativ med stoerst kode offset.
> > 
> > Jeg kan godt se at dette problem ikke er helt let at loese, eftersom det
> > kraever "fixups" af code-offsets for cExternalEntry imperativer naar disse
> > bliver kendt. Men kan det goeres alligevel?
> > 
> >   -- Soren
> > 
> > 
> > .global M2GUIENVCALLBACKSELECTORADD
> > M2GUIENVCALLBACKSELECTORADD:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > .L162:
> > .stabn 68,0,76,.L163
> > .L163:
> > .stabn 68,0,100,.L164
> > .L164:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+12],%i2
> > 	ld	[%i0+420],%l7
> > 	st	%l7,[%i2+12]
> > .stabn 68,0,159,.L165
> > .L165:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ldub	[%i2+408],%l0
> > 	cmp	%l0,1
> > 	bne	.L167
> > 	nop
> > .stabn 68,0,141,.L168
> > .L168:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i0+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+8],%i3
> > 	ld	[%i3+412],%i3
> > 	tst	%i3
> > 	tle	17
> > 	add	%i3,0,%i1
> > 	add	%i1,12,%g1
> > 	add	%i2,0,%i3
> > 	sub	%g1,%g6,%i5
> > 	cmp	%i5,%g7
> > 	bleu	.L169
> > 	st	%i3,[%g1]
> > 	call	ChkRA
> > 	nop
> > .L169:
> > 	set	0,%i3
> > 	set	0,%i4
> > 	call	M315GUIENV
> > 	set	0,%i2
> > 	b	.L166
> > 	nop
> > .L167:
> > .stabn 68,0,154,.L170
> > .L170:
> > 	ld	[%i0+8],%i2
> > 	ld	[%i2+8],%i2
> > 	ld	[%i2+8],%i2
> > 	add	%i2,0,%i1
> > 	call	M24WIDGET
> > 	set	0,%i2
> > .L166:
> > .stabn 68,0,0,.L171
> > .L171:
> > 	ret
> > 	restore
> > .global callCallbackSelector
> > callCallbackSelector:	mov	%i1,%o0
> > 	save	%sp,-64,%sp
> > 	mov	%i0,%o0
> > 	mov	%i1,%l0
> > 	mov	%i2,%l1
> > 	set	0,%i2
> > 	mov	%i3,%l2
> > 	set	0,%i3
> > 	mov	%i0,%i1
> > !  Get long
> > 	mov	%l0,%l3
> > 	st	%l3,[%i1+412]
> > !  Get long
> > 	mov	%l1,%l0
> > 	st	%l0,[%i1+416]
> > !  Get long
> > 	mov	%l2,%l0
> > 	st	%l0,[%i1+420]
> > 	call	M2GUIENVCALLBACKSELECTORADD
> > 	nop
> > 	ret
> > 	restore
> > 
> 


From Ole.Madsen@eng.sun.com Thu Jan 19 18:58:06 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA10596
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Thu, 19 Jan 1995 18:57:50 +0100
Received: from Eng.Sun.COM (zigzag.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA19928; Thu, 19 Jan 95 09:57:40 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (4.1(1/24/94)/SMI-4.1)
	id AA04714; Thu, 19 Jan 95 09:55:57 PST
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA02283; Thu, 19 Jan 1995 09:56:04 +0800
Date: Thu, 19 Jan 1995 09:56:04 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9501191756.AA02283@det.Eng.Sun.COM>
To: kjm@daimi.aau.dk, ole.madsen@eng.sun.com, sbrandt@daimi.aau.dk
Subject: Re: prototype generering igen igen
X-Sun-Charset: US-ASCII
Content-Length: 877
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO




Man skulle tro at det hed spoerge-soeren:-)

En singulaer descriptor i do-deln inlines hvis den har formen

	; (# <optional enter> do .... <optional exit> #);

Altsaa
	- no prefix

	- no attributes

Hvis du spoerger om hvordan man checker dette, saa er

	bit 13 = 1 i desc.kind

for saadanne descriptorer.

Se iovrigt pattern insertable i sematt.bet, hvor du kan se hvad
der ellers er af den slags ting. 

Jeg skal kigge paa de andre ting snarest - men de saa lidt mere 
langhaarede ud!

---olm

> 
> Ok. Angaaende externals der alligevel bliver genereret kode for, har jeg
> nu kopieret indholdet af cProcDecoder og omskrevet det til at bruge
> betacfl i stedet for index. Det ser ud til at virke.
> 
> NAESTE PROBLEM er hvordan jeg genkender simple inlinede descriptorer
> uden tilstand, da der heller ikke for disse genereres prototyper.
> 
> Hvodden?
> 
>   -- Soren
> 

From Ole.Madsen@eng.sun.com Wed Jan 11 19:35:21 1995
Received: from Sun.COM (koriel.Sun.COM) by daimi.aau.dk with SMTP id AA15454
  (5.67b8/IDA-1.5 for <sbrandt@daimi.aau.dk>); Wed, 11 Jan 1995 19:35:17 +0100
Received: from Eng.Sun.COM (zigzag.Eng.Sun.COM) by Sun.COM (sun-barr.Sun.COM)
	id AA23933; Wed, 11 Jan 95 10:34:51 PST
Received: from det.Eng.Sun.COM by Eng.Sun.COM (4.1(1/24/94)/SMI-4.1)
	id AA20707; Wed, 11 Jan 95 10:32:51 PST
Received: by det.Eng.Sun.COM (5.0/SMI-SVR4)
	id AA20094; Wed, 11 Jan 1995 10:32:57 +0800
Date: Wed, 11 Jan 1995 10:32:57 +0800
From: Ole.Madsen@eng.sun.com (Ole Lehrmann Madsen)
Message-Id: <9501111832.AA20094@det.Eng.Sun.COM>
To: sbrandt@daimi.aau.dk
Subject: For-, labelled-imp
Cc: Ole.Madsen@eng.sun.com
X-Sun-Charset: US-ASCII
Content-Length: 2485
X-Charset: LATIN1
X-Char-Esc: 29
Status: RO


>> 
> Nu vi er ved det: Jeg er kommet i tanker om at psbrowseren ikke
> er forberedt paa at haandtere objekt-attributter som er allokeret
> til brug for index-variable og slige sager. Hvis et objekt har 
> saadanne attributter, vil den nuvaerende version vise forkerte
> vaerdier af alle senere vaerdi attributter. Hvis labelled imperativer
> ogsaa allokerer reference attributter gaar det foerst helt galt.
> 
> Valhalla har ogsaa brug for denne information, omend den ikke doer
> af at mangle den.
> 
> Saa: - For hvilke imperativer allokeres der plads i et object?
>      - Hvilke typer af attributter allokeres der?
>      - Hvordan scanner jeg en dopart for at identificere de
>        "farlige" attributter. 
> 

Det gaelder

		for-imp
		labelled-imp
Du skal scanne doparten og for V i
		(for V: ... for)
		V: 

gaelder at V.off angir offset i objektet.

For en for-imp indeholder V.off index og V.off+4 inddeholder range

For labelled-imp indeholder V.off staktop (sp) og er vel ikke relevant?

Og disse attributter er kun definerede hvis kontrollen (pc) er i disse.
Altsa de skal vere under udfoersel.

> Jeg skulle gerne kunne skrive noget kode i stil med:
> 
>      dp: ^BETACFL.dopart;
>   do ...;
>      dp.suffixWalk
>      (#
>      do (if current.symbol
>         //BETA.forImp then
>             (* Dig out allocation information on the index 
>              * variable attribute *)
>         //BETA.labelledImp then
>             (* Dig out information on attributes allocated
>              * to save return information.
>              * SP and object reference (?) *)
>         //...??..
>         //BETA.simpleIfImp  (?)
>         //BETA.generalIfImp (?)

If'er har inge attributter mere.
>         if)
>      #)
> 
> Den information jeg skal bruge er: offset i det omgivende objekt samt 
> attributtens type (objekt reference, integer eller ?). Jeg gaar ud fra at
> saadanne attributter kun allokeres i et objekt hvis koden staar direkte i 
> patternets dopart, og ikke i et dopart eller descriptor SLOT eller, uha 
> uha :-), i et andet patterns dopart.

Ved 

	a: (# .... do .... #)  findes de i omgivende objekt

	b:  descriptor slots som ved 'a'.

	c:  (# ... <<SLOT xxx:doPart>> #)

	   ---xxx:doPart---
	      ....

	   her findes de ie et specielt doPart objekt som ogsaa skulle
	   blive refereret af th (%a0,%i0,...) Et saadant objekt
	   er netop allokeret hvis der findes for- labelled-imp
	   i doParten


Haaber det er nok:-)

---olm
> 
>   -- Soren

