ORIGIN 'UI/valhallaGUI';
INCLUDE 'remotedumper'
        'processInterface'
        'processCommCodes'
        'breakpoints'
        'valhallaoptions'
        'UI/valhallaGUI'
        'UI/GUIprocess'
        'UI/stackview'
        'UI/stackbrowser'
        'UI/objectviewadds'
        'UI/enveditor'
        'UI/objectlistview'
        'UI/refdiagview'
        'UI/heapview'
        '~beta/guienv/utils/promptForArgs'
        '~beta/toollibs/utils/options'
        '~beta/toollibs/utils/systemenvcompspawner'
        '~beta/guienv/stddialogs'
        '~beta/guienv/utils/simplemenu'
        '~beta/process/systemcomm'
        '~beta/objectbrowser/UI/evaluatormoveable'
        '~beta/compiler/DYN/dynlib'
        '~beta/compiler/DYN/AstOfObject'
        '~beta/compiler/DYN/treelib'
        '~beta/pretty/astviewer'
        'debuggerinterface'
        '~beta/mps/notifications';
LIB_DEF 'valhalla' '../lib';
BODY 'private/valhallabody';
BODY 'private/breakpointMenus';
BODY 'private/dynamic_compilation';
BODY 'private/valhallabodyext';
(*'~beta/freja/frejalib';*)
-- lib: Attributes --
DEFAULT_SIZE: (#  exit (250,250) #);   

-- systemlib: Attributes --
(* This is the programdescriptor from valhalla.bet *)
valhallaApplication: valhallaGUI
  (#
     (*FGC, windowEnvType:: valhallaGUI; *)
     (*FGC, setWindowEnv::  
      (#  do gui[]->theWindowEnv[] #);
      *)
     <<SLOT valhallalib:Attributes>>;
     thespawner: @systemenvspawner;
     theProgramFF: ^mps.ast.fragmentForm;
     AplProcess: GUIprocess
       (#
          savebreakPoints:
            (# breakpoints: ^stream; 
            <<SLOT processInterfaceSaveBreakPoints:DoPart>>
            exit breakpoints[]
            #);
          loadbreakPoints:
            (# breakpoints: ^stream; 
            enter breakpoints[]
            <<SLOT processInterfaceLoadBreakPoints:DoPart>>
            #);
          SDTracePointHit:: 
            (#
               thisObj,originObj:
                 ^debuggee.remoteBetaObject;
               setupObjects:
                 (#
                    theRealDesc: ^mps.BETACFL.objectDescriptor;
                    objects: ^remoteObjectDB;
                    
                 <<SLOT SDTracePointHitSetupObjects:DoPart>>
                 #)
            <<SLOT SDTracePointHit:DoPart>>
            #);
          showObjectOnStop::< 
            (#  do valhallaprefs.showObjectOnStop->value #);
          
       #);
     (* The process being debugged. *)
     debuggeeInterface::< AplProcess;
     SDObjectOwner: @objectowner;
     SDWindow: ^gui.window;
     (* Environment editor. *)
     theEnveditor: ^enveditType;
     enveditType: (*FGC, gui.*) gui.envEditor
       (# onClose::  (#  do none ->theEnveditor[] #) #);
     valhallaPrefs: ^valhallaPreferences;
     debuggeeOutDated: BooleanValue
       (#
          debuggeemodtime: @integer;
          f: @file;
          fault: @boolean;
          doRecompile:< BooleanValue;
          currentFG: ^mps.ast.fragmentgroup;
          EXECstrippedName: ^Text;
          SRCname: ^text
       do
          (if isStandAloneValhalla then leave debuggeeOutDated if);
          ((getExecNameparam).copy)->EXECstrippedName[]->f.name;
          exeFileExtension->EXECstrippedName.stripExtension;
          f.entry.modtime->debuggeemodtime;
          getSrcNameParam->SRCname[];
          mps.AST.dependencyGraph
            (# 
            do
               init;
               xverboselevel.nothing->xverboselevel;
               machine_type->TargetMachine[];
               machine_type->TargetDirectory[];
               scan: (*EXECstrippedName *)
               SRCname[]
                 ->scanextent
                   (#
                      ErrorText: ^text;
                      Alert:
                        (# 
                        do (ErrorText[],'Error')->alertInfo; true->value
                        #);
                      DoubleFormException:: 
                        (# 
                        do
                           'DoubleFormException in file: '->ErrorText[];
                           n[]->ErrorText.append;
                           true->continue;
                           Alert
                        #);
                      transAccessException::  (#  do  #);
                      circularDependencyException:: 
                        (# 
                        do
                           'CircularDependencyException in file: '->errorText[];
                           fg.name->errorText.append;
                           true->continue;
                           alert
                        #);
                      emptyFragmentException::  (#  do  #);
                      parseException::  (#  do  #);
                      transCreateDirException::  (#  do  #);
                      MPSexception::  (#  do  #);
                      notExistingException::  (#  do  #);
                      noSpaceException::  (#  do  #);
                      fragmentException::  (#  do  #);
                      propertyException::  (#  do  #)
                   do
                      (if current.modtime > debuggeemodtime then
                          true->value; leave scan
                      if);
                      current[]->currentFG[];
                      sources.edenv.groupEditorlist.scan
                        (# 
                        do
                           (if current.fg[] = currentFG[] then
                               (if current.touched > 0 then true->value if); 
                           if)
                        #)
                   #)
            #);
          (if value then
              (if sources.sifExternalInterface[] <> none then
                  (sources.ymerbrowser[],'Debugging impossible!',
                   'SourceCode touched, program must be recompiled! Compile?')
                    ->gui.promptForBoolean
                      (#
                         result: @boolean;
                         ok:: 
                           (# 
                           do
                              EXECstrippedName[]
                                ->mps.fragmentGroupTable.getFragmentGroup
                                ->sources.sifExternalInterface.compile->result;
                              (if result then false->value if)
                           #)
                      #)
              if)
          if)
       #);
     debuggeeIsRunning: BooleanValue
       (# 
       do
          (if debuggee[] <> none then
              (debuggee.running) and (not debuggee.terminated)->value; 
           else
              FALSE->value
          if)
       #);
     debuggeeIsReady: BooleanValue
       (# 
       do
          (if debuggee[] <> none then
              (not debuggee.running) and (not debuggee.terminated)->value; 
           else
              FALSE->value
          if)
       #);
     debuggeeIsStarted: BooleanValue (* debuggee has been running *)
       (# 
       do
          (if debuggee[] <> none then
              ((debuggee.waitcount > 0) and (not debuggee.running) and
               (not debuggee.terminated))
                ->value (* has been started, but is not running now *)
           else
              FALSE->value
          if);
          INNER
       #);
     ensureKilled:
       (# 
       do
          (if debuggee[] <> none then
              (if not debuggee.terminated then
                  debuggee.kill; (*FGC, gui.*) onTerminate; 
              if);
              
          if);
          
       #);
     getFrame:
       (#
          done:< (# result: @rectangle;  enter result do INNER #);
          pos: @point;
          res: @rectangle;
          h,v: @integer
       do (*FGC, gui.*)
          main.objworld.size->(h,v);
          'DEFAULT_H'
            -> (*FGC, gui.*) globalOptions.getIntegerOption
              (# found::  (#  do value->pos.h #) #);
          (if pos.h > h-50 then 0->pos.h if);
          ('DEFAULT_H',15+pos.h)-> (*FGC, gui.*) globalOptions.setIntegerOption;
          'DEFAULT_V'
            -> (*FGC, gui.*) globalOptions.getIntegerOption
              (# found::  (#  do value->pos.v #) #);
          (if pos.v > v-50 then 0->pos.v if);
          ('DEFAULT_V',15+pos.v)-> (*FGC, gui.*) globalOptions.setIntegerOption;
          DEFAULT_SIZE->res.size;
          pos->res.offset;
          (if dragOutlineOnOpen-> (*FGC, gui.*) getOption then
              res
                -> (*FGC, gui.*) main.objworld.getOutline
                  (# done::  (#  do result->THIS(getFrame).done #) #)
           else
              res->done; 
          if);
          
       #);
     newExecName:
       (# execName: ^Text; 
       do (*FGC, gui.*)
          main[]
            -> (*FGC, gui.*) gui.fileSelectionDialog
              (#  do 'Debug executable:'->label[];  #)->execName[];
          (if execName[] <> none then execName[]->setEXECNAMEparam if);
          
       exit execName[]
       #);
     runNewDebuggee:
       (# success: @Boolean; rerun: @Boolean; 
       enter rerun
       do <<SLOT runnewdebuggee:Descriptor>>
       exit success
       #);
     setStepIntoBreaks:
       (#
          uss:
            @debuggee.userSingleStepBreaker
            (#
               init::< 
                 (#
                    cancelled:: 
                      (# 
                      do TRUE->continue
                      #);
                    unknownCode:: 
                      (# 
                      do
                         ('Missing debug info. Cannot step.','Warning')
                           -> (*FGC, gui.*) alertInfo;
                         TRUE->continue
                      #)
                 #)
            #)
       exit not uss.init
       #);
     setStepOverBreaks:
       (#
          uss: @debuggee.userStepOverBreaker
            (#
               init::< 
                 (#
                    cancelled::  (#  do TRUE->continue #);
                    unknownCode:: 
                      (# 
                      do
                         ('Missing debug info. Cannot step.','Warning')
                           -> (*FGC, gui.*) alertInfo;
                         TRUE->continue;
                         
                      #);
                    
                 #);
               
            #);
          
       exit not uss.init
       #);
     doStepOver:
       (# 
       do
          (if debuggeeIsReady then
              (if setStepOverBreaks then doContinue if)
          if);
          
       #);
     doStepInto:
       (# 
       do
          (if debuggeeIsReady then
              (if debuggeeIsStarted then (* if first time, use go until mark *)
                  (if setStepIntoBreaks then doContinue if)
               else
                  <<SLOT ValhallaTryBreakOnProgram:Descriptor>>; 
              if)
          if)
       #);
     doGoUntil:
      <<SLOT valhalladoGoUntil:Descriptor>>;
     doContinue:
       (# 
       do
          debuggee.processComm.continue
            (#
               failure:: 
                 (# 
                 do
                    true->continue;
                    (* Display warning *)
                    'Error during Continue!'->continueError
                 #)
            #);
          'Running'-> (*FGC, gui.*) putpinfo;
          waitersem.V;
          
       #);
     doStop:
       (# 
       do
          (if debuggeeIsRunning then
              TRUE->stopped; debuggee.processComm.stop
          if)
       #);
     doFinish: <<SLOT valhalladoFinish:Descriptor>>;
     (*  TRUE if doStop was called. *)
     (* procwaiter
      * ==========
      * 
      * procwaiter is a coroutine doing the job of waiting for the debuggee
      * to stop. Using a separate coroutine for this job allows valhalla to
      * handle user-events while waiting.
      * 
      * procwaiter blocks on waitersem until it should wait for the debuggee
      * to stop. Then it blocks on a call to debuggee.processComm.wait. *)
     stopped: @Boolean;
     waitersem: @semaphore;
     procwaiter: @|System (#  do <<SLOT procwaiter:Descriptor>> #);
     theHeapView: ^heapView;
     heapView: main.heapView
       (#
          objHeap: ^heapHashedByProto;
          close:: 
            (#  do none ->theHeapView[] #);
          describe:
            (#
               txt: ^text;
               bo: ^debuggee.remotebetaobject;
               proto: @integer;
               ComponentPTValue:
                 (#  exit (- 1) #);
               StackObjectPTValue:
                 (#  exit (- 2) #);
               StructurePTValue:
                 (#  exit (- 3) #);
               RefRepPTValue:
                 (#  exit (- 4) #);
               LongRepPTValue:
                 (#  exit (- 5) #);
               ByteRepPTValue:
                 (#  exit (- 6) #);
               ShortRepPTValue:
                 (#  exit (- 7) #);
               DoubleRepPTValue:
                 (#  exit (- 8) #);
               DopartObjectPTValue:
                 (#  exit (- 9) #);
               DynItemRepPTValue:
                 (#  exit (- 10) #);
               DynCompRepPTValue:
                 (#  exit (- 11) #);
               
            enter bo[]
            do
               bo.protoAdr->proto;
               (if proto
                // ComponentPTValue then
                   '[Component]'->txt[]; 
                // StackObjectPTValue then
                   '[StackObject]'->txt[]; 
                // StructurePTValue then
                   '[Structure]'->txt[]; 
                // RefRepPTValue then
                   '[Reference_Repetition]'
                     ->txt[];
                   
                // LongRepPTValue then
                   '[Long_Repetition]'->txt[]; 
                // ByteRepPTValue then
                   '[Byte_Repetition]'->txt[]; 
                // ShortRepPTValue then
                   '[Short_Repetition]'->txt[]; 
                // DoubleRepPTValue then
                   '[Double_Repetition]'->txt[]; 
                // DopartObjectPTValue then
                   '[DoPart]'->txt[]; 
                // DynCompRepPTValue then
                   '[DynItem]'->txt[]; 
                // DynCompRepPTValue then
                   '[DynComponent]'->txt[]; 
                else
                   (bo.description).copy->txt[]; 
               if);
               
            exit txt[]
            #);
          findObjects:
            (# 
            do
               debuggee.processcomm.
                 scanHeapByProto->objHeap[];
                 (# i: @integer; 
                 do
                    1->i;
                    L:
                      (# 
                      do
                         (if i >= objHeap.range then leave L;  if);
                         i
                           ->objHeap.scanIndexed
                             (# bo: ^debuggee.remoteBetaObject; 
                             do
                                current.adr->debuggee.newRemoteObject->bo[];
                                (bo[],bo[]->describe)->insertTreeObj;
                                
                             #);
                         i+1->i;
                         restart L;
                         
                      #);
                    
                 #);
               updateTree;
               
            #);
          
       #);
     theRefDiagView: ^refDiagView;
     refDiagView: main.refDiagView
       (#
          heap: ^heapSortedByAddress;
          target: ^debuggee.remoteBetaObject;
          RDObjectOwner: @objectOwner
            (#
               onObjectIsGarbage:: 
                 (#  do bo[]->onSetObjectIsGarbage; (*doUpdate;*)  #);
               
            #);
          describe:
            (#
               txt: ^text;
               bo: ^debuggee.remotebetaobject;
               proto: @integer;
               ComponentPTValue: (#  exit (- 1) #);
               StackObjectPTValue: (#  exit (- 2) #);
               StructurePTValue: (#  exit (- 3) #);
               RefRepPTValue: (#  exit (- 4) #);
               LongRepPTValue: (#  exit (- 5) #);
               ByteRepPTValue: (#  exit (- 6) #);
               ShortRepPTValue: (#  exit (- 7) #);
               DoubleRepPTValue: (#  exit (- 8) #);
               DopartObjectPTValue: (#  exit (- 9) #);
               DynItemRepPTValue: (#  exit (- 10) #);
               DynCompRepPTValue: (#  exit (- 11) #);
               
            enter bo[]
            do
               bo.protoAdr->proto;
               (if proto
                // ComponentPTValue then
                   '[Component]'->txt[]; 
                // StackObjectPTValue then
                   '[StackObject]'->txt[]; 
                // StructurePTValue then
                   '[Structure]'->txt[]; 
                // RefRepPTValue then
                   '[Reference_Repetition]'->txt[]; 
                // LongRepPTValue then
                   '[Long_Repetition]'->txt[]; 
                // ByteRepPTValue then
                   '[Byte_Repetition]'->txt[]; 
                // ShortRepPTValue then
                   '[Short_Repetition]'->txt[]; 
                // DoubleRepPTValue then
                   '[Double_Repetition]'->txt[]; 
                // DopartObjectPTValue then
                   '[DoPart]'->txt[]; 
                // DynCompRepPTValue then
                   '[DynItem]'->txt[]; 
                // DynCompRepPTValue then
                   '[DynComponent]'->txt[]; 
                else
                   (bo.description).copy->txt[]; 
               if);
               
            exit txt[]
            #);
          onShowObject:: 
            (# ro: ^debuggee.remoteBetaObject; 
            do current[]->ro[]; ro[]->setTarget; 
            #);
          showObjectView::<  (#  do betaObj[]->newObjectMoveable;  #);
          pointsto::< 
            (# ro,ro2: ^debuggee.remoteBetaObject; 
            do
               false->result;
               dest[]->ro[];
               src[]->ro2[];
               (if 'NONE'->(ro[]->describe).equal then leave pointsto;  if);
               ro.getAddress->debuggee.processcomm.getRefsToObject->heap[];
               heap.scan
                 (# bo: ^debuggee.remotebetaobject; 
                 do
                    current.adr->debuggee.newRemoteObject->bo[];
                    (if bo[] = ro2[] then true->result;  if);
                    
                 #);
               
            #);
          present:
            (#
               thisObj: ^debuggee.remoteBetaObject;
               objects: ^GUIprocess.remoteObjectDB;
               numHeapObjs: @integer;
               found: @boolean;
               
            do
               0->numHeapObjs;
               heap.scan
                 (#  do numHeapObjs+1->numHeapObjs;  #);
               debuggee.getRemoteObjectDB->objects[];
               1->startNewObjectColumn;
               (if not ((target[]->describe,target[])->putNewObject) then
                   target[]->setIsTarget;
                   debuggee.curObj->debuggee.newRemoteObject->thisObj[];
                   (thisObj[],RDObjectOwner[])->objects.addObjectOwner;
                   numHeapObjs->startNewObjectColumn;
                   
                else
                   numHeapObjs->numObjs; 
               if);
               false->found;
               heap.scan
                 (# bo: ^debuggee.remotebetaobject; 
                 do
                    current.adr->debuggee.newRemoteObject->bo[];
                    (if not ((bo[]->describe,bo[])->putNewObject) then
                        true->found; 
                    if);
                    (target[],bo[])->putNewEdge;
                    current.adr->debuggee.newRemoteObject->thisObj[];
                    (thisObj[],RDObjectOwner[])->objects.addObjectOwner;
                    
                 #);
               initObjects;
               (if not found then curX-100->curX;  if);
               
            #);
          setTarget:
            (# 
            enter target[]
            do
               target.getAddress->debuggee.processcomm.getRefsToObject->heap[];
               present
            #);
          close:: 
            (# objects: ^GUIprocess.remoteObjectDB; 
            do
               none ->theRefDiagView[];
               debuggee.getRemoteObjectDB->objects[];
               RDObjectOwner[]->objects.removeObjectOwner;
               
            #);
          
       #);
     referenceView: main.objectListView
       (#
          heap: ^heapSortedByAddress;
          target: ^debuggee.remoteBetaObject;
          history: @stack
            (#
               element:: 
                 (#
                    heap: ^heapSortedByAddress;
                    target: ^debuggee.remoteBetaObject;
                    
                 #);
               
            #);
          push:
            (# elm: ^history.element; 
            do
               &history.element[]->elm[];
               target[]->elm.target[];
               heap[]->elm.heap[];
               elm[]->history.push;
               
            #);
          pop:
            (# elm: ^history.element; 
            do
               (if not history.empty then
                   history.pop->elm[];
                   elm.target[]->target[];
                   elm.heap[]->heap[];
                   present;
                   
               if);
               
            #);
          onFollow:: 
            (# 
            do
               push;
               (if inx > 0 then
                   (inx->heap.get).adr->debuggee.newRemoteObject->setTarget; 
               if);
               contents.backBtn.enable;
               
            #);
          onShow:: 
            (# 
            do
               (if inx > 0 then
                   (inx->heap.get).adr->debuggee.newRemoteObject
                     ->newObjectMoveable;
                   
               if);
               
            #);
          onBack:: 
            (# 
            do pop; (if history.empty then contents.backBtn.disable;  if); 
            #);
          present:
            (# data: ^main.textList; txt: ^text; 
            do
               &main.textList[]->data[];
               heap.scan
                 (# bo: ^debuggee.remotebetaobject; 
                 do
                    current.adr->debuggee.newRemoteObject->bo[];
                    bo[]->describe->data.append;
                    
                 #);
               data[]->set;
               'References to '->txt[];
               target[]->describe->txt.puttext;
               txt[]->title;
               
            #);
          describe:
            (#
               txt: ^text;
               bo: ^debuggee.remotebetaobject;
               proto: @integer;
               ComponentPTValue: (#  exit (- 1) #);
               StackObjectPTValue: (#  exit (- 2) #);
               StructurePTValue: (#  exit (- 3) #);
               RefRepPTValue: (#  exit (- 4) #);
               LongRepPTValue: (#  exit (- 5) #);
               ByteRepPTValue: (#  exit (- 6) #);
               ShortRepPTValue: (#  exit (- 7) #);
               DoubleRepPTValue: (#  exit (- 8) #);
               DopartObjectPTValue: (#  exit (- 9) #);
               DynItemRepPTValue: (#  exit (- 10) #);
               DynCompRepPTValue: (#  exit (- 11) #);
               
            enter bo[]
            do
               bo.protoAdr->proto;
               (if proto
                // ComponentPTValue then
                   '[Component]'->txt[]; 
                // StackObjectPTValue then
                   '[StackObject]'->txt[]; 
                // StructurePTValue then
                   '[Structure]'->txt[]; 
                // RefRepPTValue then
                   '[Reference_Repetition]'->txt[]; 
                // LongRepPTValue then
                   '[Long_Repetition]'->txt[]; 
                // ByteRepPTValue then
                   '[Byte_Repetition]'->txt[]; 
                // ShortRepPTValue then
                   '[Short_Repetition]'->txt[]; 
                // DoubleRepPTValue then
                   '[Double_Repetition]'->txt[]; 
                // DopartObjectPTValue then
                   '[DoPart]'->txt[]; 
                // DynCompRepPTValue then
                   '[DynItem]'->txt[]; 
                // DynCompRepPTValue then
                   '[DynComponent]'->txt[]; 
                else
                   (bo.description).copy->txt[]; 
               if);
               
            exit txt[]
            #);
          setTarget:
            (# txt: ^text; 
            enter target[]
            do
               target.getAddress->debuggee.processcomm.getRefsToObject->heap[];
               present
            #)
       #);
     newReferenceView:
       (#
          target: ^debuggee.remoteBetaObject;
          view: ^referenceView;
          computeFrame:
            (# frame: @rectangle; 
            do (13,13)->frame.topLeft; (400,300)->frame.size; 
            exit frame
            #);
          
       enter target[]
       do
          &referenceView[]->view[];
          (main.objworld[],computeFrame)->view.open;
          target[]->view.setTarget;
          
       #);
     newRefDiagView:
       (#
          target: ^debuggee.remoteBetaObject;
          computeFrame:
            (# frame: @rectangle; 
            do (13,13)->frame.topLeft; (400,300)->frame.size; 
            exit frame
            #);
          
       enter target[]
       do
          (if theRefDiagView[] = none then
              &refDiagView[]->theRefDiagView[];
              (main.objworld[],computeFrame)->theRefDiagView.open;
              
          if);
          target[]->theRefDiagView.setTarget;
          
       #);
     newHeapView:
       (#
          computeFrame:
            (# frame: @rectangle; 
            do (13,13)->frame.topleft; (400,300)->frame.size; 
            exit frame
            #);
          
       do
          (if theHeapView[] = none then
              &heapView[]->theHeapView[];
              (main.objworld[],computeFrame)->theHeapView.open;
              
          if);
          theHeapView.findObjects;
          
       #);
     mystackbrowser: (*FGC, gui.*) main.stackbrowser
       (#
          stackbrowserEncloserType:: 
            (#
               openNewCodeView:: 
                 (# 
                 do
                    cast[]
                      ->newcodemoveable
                        (#
                           acceptFound:: 
                             (# 
                             do
                                contents.browser.codePane.codeViews.find
                                  (#
                                     predicate:: 
                                       (# 
                                       do (found[] = current[])->value
                                       #)
                                  do true->value
                                  #)
                             #)
                        #);
                    
                 #);
               openNewObjectView:: 
                 (# 
                 do
                    bo[]
                      ->newobjectmoveable
                        (#
                           acceptFound:: 
                             (# 
                             do
                                true->value;
                                contents.browser.objectPane.objectViews.find
                                  (#
                                     predicate:: 
                                       (# 
                                       do
                                          (found[] = current.sov.contents[])
                                            ->value
                                       #)
                                  do false->value
                                  #)
                             #)
                        #);
                    
                 #);
               selectCodeView::  (#  <<SLOT selectCodeView:DoPart>> #);
               selectObjectView::  (#  <<SLOT selectObjectView:DoPart>> #);
               alertInfo:: 
                 (# 
                 do
                    (inf[],title[])
                      -> (*FGC, gui.*) alertInfo
                 #);
               
            #);
          
       #);
     mystackview: (*FGC, gui.*) main.stackviewmoveable
       (#
          listEncloserType:: 
            (#
               openNewCodeView::  (#  do cast[]->newcodemoveable #);
               openNewObjectView:: 
                 (# 
                 do
                    (bo[],TRUE)
                      -> (*FGC, gui.*) main.OpenMoveableObjectView
                        (#
                           getFather:: 
                             (# 
                             do (*FGC, gui.*) main.objworld[]->father[]
                             #)
                        #)
                 #);
               alertInfo:: 
                 (#  do (inf[],title[])-> (*FGC, gui.*) alertInfo #);
               openstackview::  (#  do comp[]->newstackview #);
               
            #);
          
       #);
     mycodeview: (*FGC, gui.*) main.myCodemoveable
       (#
          private: @<<SLOT mycodeviewPrivate:Descriptor>>;
          wriggle::< 
            (# 
            <<SLOT mycodeviewWriggle:DoPart>>
            #);
          selectNode:<
            (# node: ^astInterface.ast
            enter node[]
            <<SLOT mycodeviewSelectNode:DoPart>>
            #);
          open:: 
            (# 
            <<SLOT mycodeviewopen:DoPart>>
            #);
          
       #);
     lastEditor: ^ (*FGC, gui.*) gui.window.codemoveableEditor;
     newcodemoveable:
       (#
          openIfNotFound:< BooleanValue (#  do true->value; INNER #);
          wriggleIfFound:< BooleanValue
            (# found: ^ (*FGC, gui.*) main.codemoveableEditor; 
            enter found[]
            do valhallaprefs.wriggleiffound->value; INNER
            #);
          acceptFound:< BooleanValue
            (# found: ^ (*FGC, gui.*) main.codemoveableEditor; 
            enter found[]
            do found.isolated->value; INNER
            #);
          cast: ^astInterface.ast;
          
       enter cast[]
       <<SLOT newcodemoveable:DoPart>>
       #);
     newobjectmoveable:
       (#
          openIfNotFound:< BooleanValue
            (#  do true->value; INNER #);
          wriggleIfFound:< BooleanValue
            (#
               found: ^ (*FGC, gui.*)
               main.objectView
            enter found[]
            do
               valhallaprefs.wriggleiffound
                 ->value;
               INNER
            #);
          acceptFound:< BooleanValue
            (#
               found: ^ (*FGC, gui.*)
               main.objectView
            enter found[]
            do INNER
            #);
          bo: ^betaObject;
          
       enter bo[]
       <<SLOT newobjectmoveable:DoPart>>
       #);
     ShowObjectReferences:
       (# rb: ^debuggee.remoteBetaObject; h: ^heapSortedByAddress; 
       enter rb[]
       <<SLOT ShowObjectReferencesDP:DoPart>>
       #);
     valhallaCmdLinePrompt: (*FGC, gui.*)
      gui.promptForArgs
       (#
          okCalled: @Boolean;
          epdb: ^executableParamDB;
          ok:: 
            (# 
            do
               TRUE->okCalled;
               epdb.clear;
               (for i: argc repeat argv[i][]->epdb.append;  for);
               
            #);
          cancel::  (#  do FALSE->okCalled #);
          doPopup:
            (# defaultTxt: @Text; prompt: ^text; de: @diskEntry; 
            do
               getExecutableParamDB->epdb[];
               epdb.scan
                 (# 
                 do
                    findSpace:
                      (# 
                      do
                         ' '
                           ->current.findAll
                             (# 
                             do
                                '"'->defaultTxt.append;
                                current[]->defaultTxt.append;
                                '"'->defaultTxt.append;
                                ' '->defaultTxt.append;
                                leave findSpace;
                                
                             #);
                         current[]->defaultTxt.append;
                         ' '->defaultTxt.append;
                         
                      #);
                    
                 #);
               getEXECNAMEparam->de.path;
               de.path.name->prompt[];
               'Enter parameters for `'->prompt.prepend;
               '\':'->prompt.append;
               ( (*FGC, gui.*)
               main[],'Command Line Editor',prompt[],defaultTxt[])->popup;
               
            exit okCalled
            #)
       #);
     cmdlineprompt: ^valhallaCmdLinePrompt;
     rereadprompt: (*FGC, gui.*) gui.noteUser
       (# t: @Text; 
       do
          'Executable `%s\' changed on disk'
            ->t.putFormat
              (# de: @diskEntry; 
              do getEXECNAMEparam->de.path; de.path.name->s; 
              #);
          (*FGC, gui.*)
          main[]->owner[];
          'Executable Changed'->Title[];
          t[]->message[];
          
       #);
     doEditCommandLine: (#  do cmdlineprompt.doPopup;  #);
     newstackview:
       (# comp: ^processInterface.remoteBetaObject; 
       enter comp[]
       <<SLOT newstackviewbody:DoPart>>
       #);
     newstackbrowser:
       (#
          comp:
            ^processInterface.remoteBetaObject;
          
       enter comp[]
       <<SLOT newstackbrowserbody:DoPart>>
       #);
     (* FGC,     gui: @valhallaGUI
      (# *)
     (* gui eliminated *)
     sockgen: @socketGenerator;
     dc: ^MPS.AST.valhallaDynamicCompiler;
     dynamicCodeCounter: @integer;
     initCompiler: @<<SLOT ValhallaInitCompiler:Descriptor>>;
     InitCodeEditor: @
       (#
          vcem: main.codeeditorEditMenu
            (#
               formEditorExists:: 
                 (# 
                 do currentCfe[]->cfe[]
                 #);
               Evaluate: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         ((currentCfe[]
                           <> none ) and (EvaluateAction[] <> none ))->value
                      #);
                    onSelect:: 
                      (# 
                      do
                         (if EvaluateAction[] <> none then EvaluateAction if)
                      #)
                 #)
            #);
          cem: ^vcem;
          EvaluateAction: ^object;
          first: @boolean;
          currentCfe: ^main.codeeditor;
          
       <<SLOT ValhallaInitCodeEditor:DoPart>>
       #);
     (*     ymerBrowserWindow::< 
      (#
      <<SLOT debuggerBrowserWindowLib:Attributes>>;
      browserType::< 
      (#
      editorEncloserType::< 
      (# tryclose::<  (#  do false->okToClose #) #)
      #);
      workspace:: 
      (#
      menubarType:: 
      (# open::  (#  <<SLOT workspaceMenubarOpen:DoPart>> #)
      #)
      #);
      codeViewWindow:: 
      (#
      menubarType:: 
      (#
      open:: 
      (# 
      <<SLOT codeViewWindowMenubarOpen:DoPart>>
      #)
      #)
      #);
      onCodeViewOpen::  (#  <<SLOT onCodeViewOpen:DoPart>> #);
      onTerminateApplication::< 
      (# 
      do
      (if isStandAloneValhalla then
      false->okToTerminate; 
      if);
      (* hide; * )
      INNER
      #);
      quit::< 
      (# 
      do false->okToClose; hide; INNER
      #);
      eventhandler::< 
      (#
      onAboutToClose:: 
      (# 
      do false->okToClose; hide
      #)
      #);
      menubarType::< 
      (#
      open::< 
      (# 
      <<SLOT guiMenubarTypeOpen:DoPart>>
      #)
      #);
      open::< 
      (# 
      do
      (if isStandAloneValhalla then
      THIS(ymerBrowserWindow).hide; 
      if);
      INNER
      #);
      
      #); *)
     (* The following final bound virtuals are declared in valhallaGUI,
      * and called by menus and buttons in the user-interface. *)
     newCodeView::  (#  do cast[]->newcodemoveable #);
     newDebuggee:: 
       (# changedOutside,otherError: @boolean
       do
          (if newExecName <> none then
              ensureKilled;
              doEditCommandLine;
              FALSE->runNewDebuggee;
              (if debuggee[] <> none then
                  ('program',debuggee.MPS.BETA.DescriptorForm)
                    ->debuggee.DBmanager.slotnameToGroups
                      (#  do current[]->loadSources #);
                  
              if)
          if)
       #);
     debuggeeStatus::  (#  do debuggeeIsReady->value #);
     debuggeeRerun:: 
       (# 
       do (if rerunStatus then ensureKilled; TRUE->runNewDebuggee if)
       #);
     rerunStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              debuggeeIsReady or debuggee.terminated->value; 
           else
              TRUE->value; 
          if);
          value and (getEXECNAMEparam <> none )->value;
          
       #);
     killDebuggee:: 
       (# 
       do (if debuggeeIsReady then ensureKilled; 'Killed'->putpinfo if)
       #);
     stopDebugging::  (#  do main.dohide;  #);
     killStatus:: debuggeeIsReady (#  #);
     showStopCause: (* Update info field with reason debuggee is stopped *)
       (# tmp: ^text
       do
          (if debuggee.bml.userBreakHit
           // 0 // MNGR_USERSKIP then
              (if debuggee.bml.skipBreakHit or stopped then
                  'Stopped'->putpinfo; 
               else
                  &text[]->tmp[];
                  'Runtime Error: %s'
                    ->tmp.putformat
                      (# dummy: @Integer;  do debuggee.error->(dummy,s) #);
                  tmp[]->putpinfo;
                  tmp[]->putline
              if)
           else
              &text[]->tmp[];
              'Stopped at breakpoint %d'
                ->tmp.putformat (#  do debuggee.bml.userBreakHit->d #);
              tmp[]->putpinfo;
              
          if);
          
       #);
     source:: 
       (# x,y: @integer
       do
          'source 765'->screen.putline;
          (*
           sources.position->(x,y);
           (if (x = 0) and (y = 0) then (*FGC, gui.* )
           main.position->(x,y); (x+10,y+10)->sources.position
           if);
           sources.show;
           sources.wriggle *)
          
       #);
     sourceStatus::  (#  do true->value #);
     editenv:: 
       (# 
       do
          (if theEnveditor[] <> none then
              valhallaprefs.wriggleiffound->theEnveditor.wriggle
           else
              &envedittype[]->theEnveditor[]; theEnveditor.open
          if)
       #);
     editenvStatus:: TrueObject;
     editcmdline::  (#  do doEditCommandLine;  #);
     editcmdlineStatus:: TrueObject;
     quit:: 
       (# 
       do
          (if debuggeeIsReady and (debuggee[] <> none ) then
              debuggee.kill; onTerminate
          if)
       #);
     debuggeeContinue::  (#  do (if continueStatus then doContinue if) #);
     continueStatus:: debuggeeIsReady (#  #);
     debuggeeGoUntilMark:: 
       (#  do (if GoUntilMarkStatus then doGoUntil if) #);
     GoUntilMarkStatus:: debuggeeIsReady (#  #);
     debuggeeStepOver::  (#  do doStepOver #);
     stepOverStatus:: debuggeeIsStarted (#  #);
     debuggeeStepInto::  (#  do doStepInto;  #);
     stepIntoStatus:: debuggeeIsReady;
     debuggeeStop::  (#  do doStop #);
     stopStatus:: debuggeeIsRunning (#  #);
     debuggeeFinish::  (#  do doFinish #);
     FinishStatus:: debuggeeIsStarted (#  #);
     debuggeeActiveStack:: 
       (# 
       do
          (if activeStackStatus then
              debuggee.currentRemoteComponent->newstackview
          if);
          
       #);
     activeStackStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curComp <> 0)->value
              if);
              
           else
              false->value; 
          if);
          
       #);
     debuggeeStackBrowser:: 
       (# 
       do
          (if stackBrowserStatus then
              debuggee.currentRemoteComponent->newstackbrowser
          if);
          
       #);
     stackBrowserStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curComp <> 0)->value
              if);
              
           else
              false->value; 
          if);
          
       #);
     debuggeeCurObj::  (#  <<SLOT debuggeeCurObj:DoPart>> #);
     curObjStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              debuggeeIsReady->value;
              (if debuggee.curObj = 0 then
                  false->value
               else
                  true->value
              if)
           else
              false->value
          if)
       #);
     debuggeeCurCode:: 
       (# 
       do <<SLOT debuggeeCurCode:Descriptor>>
       #);
     curCodeStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              debuggeeIsReady->value;
              (if value then (debuggee.pc <> 0)->value;  if)
           else
              false->value
          if)
       #);
     debuggeeCurComp:: 
       (# 
       do
          (if curCompStatus then
              (debuggee.currentRemoteComponent,FALSE)
                -> (*FGC, gui.*) main.OpenMoveableObjectView
                  (#
                     getFather:: 
                       (#  do (*FGC, gui.*) main.objworld[]->father[] #)
                  #)
          if);
          
       #);
     curCompStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curComp <> 0)->value
              if)
           else
              false->value; 
          if);
          
       #);
     onTerminate:: 
       (# 
       do
          main.status.setenabling;
          0->setPIDparam;
          objectviews.newscan
            (#  do cur.encl.tryclose #);
          stackviews.newscan
            (#  do cur.encl.tryclose #);
          
       #);
     onMoveablesInsert::  (#  #);
     codeviews: ^gui.codemoveableEditorList;
     stackviews: ^gui.stackviewlistlist;
     objectviews: ^valhallaobjectviewlist;
     valhallaobjectviewlist: gui.objectviewList
       (#
          onInsert:: 
            (#
               addItemMenuItems: theObjectView.addObjectViewItemMenuItems
                 (#
                    show::  (#  do comp[]->newstackview #);
                    showC::  (#  do ast[]->newcodemoveable;  #);
                    ShowR::  (#  do obj[]->newReferenceView;  #);
                    ShowRD::  (#  do obj[]->newRefDiagView;  #);
                    ShowHV::  (#  do newHeapView;  #);
                    
                 #);
               addmovItems: movo.addObjectViewactionedMenuItems
                 (#
                    show::  (#  do comp[]->newstackview #);
                    showC::  (#  do ast[]->newcodemoveable;  #);
                    ShowR::  (#  do obj[]->newReferenceView #);
                    ShowRD::  (#  do obj[]->newRefDiagView #);
                    ShowHV::  (#  do newHeapView;  #);
                    
                 #);
               mov: ^main.moveable;
               movo: ^main.moveableObjectView;
               
            do
               theObjectView.encl.getMoveable->mov[];
               (if mov[] <> none then
                   (if mov## <= main.moveableObjectView## then
                       mov[]->movo[];
                       addmovItems##->movo.movMenu.onOpen.appendAction;
                       
                   if);
                   
               if);
               addItemMenuItems##->theObjectView.itemMenu.onOpen.appendAction;
               
            #);
          onDelete::  (#  #);
          
       #);
     ValhallamainWindow::< 
       (#
          menubarType:: 
            (# open::  (#  <<SLOT mainTypeMenubarTypeOpen:DoPart>> #) #);
          onhide::  (#  do resetdebugger #)
       #);
     (* FGC #); *)
     init::< (* gui.init *) 
       (# (*FGC, skal dette i en pattern, saa det kan redo *) 
       do
       (* 0->setPidParam;
        thespawner.init;
        thespawner[]->objectPool.put;
        0->sockgen.port;
        sockgen.bind;
        sockgen[]->objectPool.put;
        procWaiter[]->fork; *)
          &MPS.AST.valhallaDynamicCompiler[]->dc[];
          &gui.codemoveableEditorList[]->codeviews[];
          &gui.stackviewlistlist[]->stackviews[];
          &valhallaobjectviewlist[]->objectviews[];
          &valhallaCmdLinePrompt[]->cmdlineprompt[];
          stackviews.init;
          stackviews[]->objectPool.put;
          codeviews.init;
          codeviews[]->objectPool.put;
          objectviews.init;
          objectviews[]->objectPool.put;
          (dragOutLineOnOpen,false)->setOption;
          (dynamiccompilation,true)->setOption;
          parseValhallaParams;
          INNER ;
          
       #);
     loadSources:
       (# exec: ^text
       enter exec[]
       do
          exec[]-> (*FGC, gui.*) mps.ast.expandToFullPath
            -> (*FGC, gui.*) sources.appendProject;
          (*FGC, gui.*)
          sources.appendDone
       #);
     AfterInit:< Object;
     obp: @objectPreferences;
     ExternalInterface: @debuggerInterface
       (#
          initTcp:
            (# 
            do
               0->setPidParam;
               thespawner.init;
               thespawner[]->objectPool.put;
               0->sockgen.port;
               sockgen.bind;
               sockgen[]->objectPool.put;
               procWaiter[]->fork;
               true->TCPInitialized
            #);
          TCPInitialized: @boolean;
          GlobalWriteProtectionStatus: @boolean;
          debugProgram:: 
            (# 
            do
               (if not TCPInitialized then initTCP if);
               program[]->setSrcNameParam;
               (* (if debuggeeOutDated then leave debugProgram if); *)
               program[]->setExecNameParam;
               sources.edenv.globalWriteProtection->GlobalWriteProtectionStatus;
               true->sources.edenv.setglobalWriteProtection;
               ensureKilled;
               onTerminate;
               0->setPIDparam;
               (if not (THIS(valhallaapplication).isdebugging) then
                   true->THIS(valhallaapplication).isdebugging;
                   (if sources.sifExternalInterface[] <> none then
                       false->sources.sifExternalInterface.isEditor; 
                   if);
                   (if (FALSE->runNewDebuggee) then
                       main.show; true->value
                    else
                       resetDebugger
                   if)
                else
                     (# msg,title: ^text; 
                     do
                        &text[]->msg[];
                        &text[]->title[];
                        'It is not possible to have more than one debugger open'
                          ->msg.puttext;
                        'Error'->title.puttext;
                        (main[],msg[],title[])->gui.alertUser;
                        true->value;
                        
                     #);
                   
               if);
               
            #);
          debugProgramAs:: 
            (# doKill: @boolean; execName,msg: ^text; 
            do
               (if not TCPInitialized then initTCP if);
               newExecName->execName[];
               (if execName[] <> none then
                   (if ExecName[]->isProgramRunning then
                       'The program, '->msg[];
                       execName[]->msg.puttext;
                       ', is running, Kill?'->msg.puttext;
                       (none ,'Kill Program?',msg[])
                         ->GUI.promptForBoolean
                           (# ok::  (#  do true->doKill #) #);
                       (if doKill then
                           execName[]->killProgram
                        else
                           leave debugProgramAs
                       if)
                   if);
                   sources.edenv.globalWriteProtection
                     ->GlobalWriteProtectionStatus;
                   true->sources.edenv.setglobalWriteProtection;
                   ensureKilled;
                   onTerminate;
                   0->setPIDparam;
                   true->THIS(valhallaapplication).isdebugging;
                   (if sources.sifExternalInterface[] <> none then
                       false->sources.sifExternalInterface.isEditor; 
                   if);
                   (if (FALSE->runNewDebuggee) then
                       main.show
                    else
                       resetDebugger;
                       (main[],
                        'One of the files that are part of the program\n' 'has been edited since compilation.\n' 'The program can not be debugged!\n',
                        'Error')->gui.alertUser
                   if)
               if)
            #);
          stopDebugging::< 
            (#  do THIS(valhallaapplication).stopdebugging #);
          isDebugging:: 
            (#  do THIS(valhallaApplication).isdebugging->value #);
          onCodeViewOpen::< 
            (# theCodeViewer: ^gui.window.codemoveableeditor; 
            do
               theCodeView[]->theCodeViewer[];
                 (#  <<SLOT OnCodeViewOpenAppendAction:DoPart>> #);
               
            #)
       #);
     breakpoints: ^text;
     isProgramRunning:< booleanValue
       (# name: ^text
       enter name[]
       do INNER
       #);
     killProgram:<
       (# name: ^text
       enter name[]
       do INNER
       #);
     (* Exceptions should call this and close debugger in mjolnertool *)
     ResetDebugger:: 
       (#
          awaitdebuggee:
            (# pid: @integer; 
            do getPidParam->pid; <<SLOT awaitdebuggee:Descriptor>>
            #)
       do
          none ->theProgramFF[];
          true
            ->
              sources.sifExternalInterface.
                isEditor;
          objectviews.newscan
            (#  do cur.encl.tryclose #);
          stackviews.newscan
            (#  do cur.encl.tryclose #);
          (if debuggee[] <> none then
              debuggee.savebreakpoints->breakpoints[];
              debuggee.removeAllBreakPoints;
              
          if);
          (if debuggee[] <> none then
              (if not debuggee.terminated then
                  debuggee.kill; awaitDebuggee
              if)
          if);
          false->isDebugging;
          externalInterface.GlobalWriteProtectionStatus
            ->sources.edenv.setGlobalWriteProtection;
          INNER
       #);
     continueError:
       (# msg: ^text; 
       enter msg[]
       do
          (if msg[] = none then &text[]->msg[] if);
          '\nClosing Debugger due to internal error!'->msg.append;
          (main[],msg[],'Error')->gui.alertUser;
          stopDebugging
       #)
  do
     objectpool.get (# type::< valhallaPreferences;  #)->valhallaPrefs[];
     valhallaPrefs[]->obp.p[];
     obp[]->objectpool.put;
     INNER ;
     thespawner.init;
     thespawner[]->objectPool.put;
     0->sockgen.port;
     sockgen.bind;
     sockgen[]->objectPool.put;
     parseValhallaParams;
     procwaiter[]->fork;
     AfterInit;
     (*
      gui.init;
      parseValhallaParams;
      
      (if getEXECNAMEparam <> none then
      FALSE->runNewDebuggee;
      (if debuggee[] <> none then
      ('program',debuggee.MPS.BETA.DescriptorForm)
      ->debuggee.DBmanager.slotnameToGroups
      (#  do current[]->loadSources #);
      if);
      if)
      *)
     
  #)  

