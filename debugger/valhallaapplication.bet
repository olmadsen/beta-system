ORIGIN 'UI/valhallaGUI.bet';
LIB_DEF 'valhalla' '../lib';

INCLUDE 'remotedumper';

INCLUDE 'processInterface'
'processCommCodes'
'breakpoints'
'valhallaoptions'
'UI/valhallaGUI'
'UI/GUIprocess'
'UI/stackview'
'UI/stackbrowser'
'UI/objectviewadds'
'UI/enveditor'
'~beta/guienv/utils/promptForArgs'
'~beta/toollibs/utils/options'
'~beta/toollibs/utils/systemenvcompspawner'
'~beta/guienv/stddialogs'
'~beta/guienv/utils/simplemenu'
'~beta/process/systemcomm'
'~beta/objectbrowser/UI/evaluatormoveable'
'~beta/compiler/DYN/dynlib'
'~beta/compiler/DYN/AstOfObject'
'~beta/compiler/DYN/treelib'
'~beta/pretty/astviewer';
(*'~beta/freja/frejalib';*)
BODY 'private/valhallabody'; 
BODY 'private/breakpointMenus'; 
BODY 'private/dynamic_compilation'; 
BODY 'private/valhallabodyext';
-- lib: Attributes --
DEFAULT_SIZE: (#  exit (250,250) #);   

-- systemlib: attributes --   (* This is the programdescriptor from valhalla.bet *)
valhallaApplication:valhallaGUI
  (#
     <<SLOT valhallalib:Attributes>>;
     IsDebugging:@boolean;
     (*FGC, windowEnvType:: valhallaGUI; *)
     (*FGC, setWindowEnv::  
      (#  do gui[]->theWindowEnv[] #);
      *)
     thespawner: @systemenvspawner;
     debuggeeInterface::<GUIprocess;
     (*FGC, debuggee: ^gui.GUIprocess; *)
     (* The process being debugged. *)
     theEnveditor: ^enveditType;
     (* Environment editor. *)
     enveditType: (*FGC, gui.*) envEditor
     (#
        onClose:: 
          (#  do none ->theEnveditor[] #)
     #);
     
     valhallaPrefs:^valhallaPreferences;
     
     debuggeeOutDated: BooleanValue 
       (# debuggeemodtime:@integer;
          f:@file;
          fault:@boolean;
       do (*leave debuggeeoutdated;
          getExecNameparam->f.name;
          f.entry.modtime->debuggeemodtime;
          mps.AST.dependencyGraph
	  (#
	  do init; xverboselevel.nothing->xverboselevel;
	     machine_type->TargetMachine[];
	     machine_type->TargetDirectory[];
             scan:getExecNameparam->scanextent
             (# 
             do
                (if current.modtime>debuggeemodtime then
                    true->value;
                    leave scan;
                if);
             #);
          #);
          (if value then
              (sources[],'SourceCode touched pleaced recompile program before debugging!',
              'Debugging impossible!')->alertUser;
           if);               
           *)
          ymerbrowser.browser.cge.fg[]->
          ymerbrowser.DGchangedOutside
          (# onFragmentGroupChanged::<
               (# 
               do  (sources[],'SourceCode touched pleaced recompile program before debugging!',
                  'Debugging impossible!')->alertUser;
                  true->fault;
               #);
          #);
          fault->value;
       #);
     
     debuggeeIsRunning: BooleanValue
       (# 
       do
          (if debuggee[] <> none then
              (debuggee.running) and
              (not debuggee.terminated)->value;
           else
              FALSE->value
          if);
          
       #);
     debuggeeIsReady: BooleanValue
       (# 
       do
          (if debuggee[] <> none then
              (not debuggee.running) and (not debuggee.terminated)->value;
           else
              FALSE->value
          if);
       #);
     
     debuggeeIsStarted: BooleanValue  (* debuggee has been running *)
       (# 
       do (if debuggee[] <> none then
              ((debuggee.waitcount>0) and (not debuggee.running))-> value;   
              (* has been started, but is not running now *)
           else
              FALSE->value;
          if);
          INNER;
       #);
     
     ensureKilled:
       (# 
       do
          (if debuggee[] <> none then
              (if not debuggee.terminated then
                  debuggee.kill; (*FGC, gui.*) onTerminate; 
              if);
              
          if);
          
       #);
     getFrame:
       (#
          done:< (# result: @rectangle;  enter result do INNER #);
          pos: @point;
          res: @rectangle;
          h,v: @integer
       do
          (*FGC, gui.*) main.objworld.size->(h,v);
          'DEFAULT_H'
            ->(*FGC, gui.*) globalOptions.getIntegerOption
          (# found::  (#  do value->pos.h #) #);
          (if pos.h > h-50 then 0->pos.h if);
          ('DEFAULT_H',15+pos.h)->(*FGC, gui.*) globalOptions.setIntegerOption;
          'DEFAULT_V'
            ->(*FGC, gui.*) globalOptions.getIntegerOption
          (# found::  (#  do value->pos.v #) #);
          (if pos.v > v-50 then 0->pos.v if);
          ('DEFAULT_V',15+pos.v)->(*FGC, gui.*) globalOptions.setIntegerOption;
          DEFAULT_SIZE->res.size;
          pos->res.offset;
          (if dragOutlineOnOpen->(*FGC, gui.*) getOption then
              res
                ->(*FGC, gui.*) main.objworld.getOutline
              (# done::  (#  do result->THIS(getFrame).done #) #)
           else
              res->done; 
          if);
          
       #);
     newExecName:
       (# execName: ^Text; 
       do
          (*FGC, gui.*) main[]
            ->(*FGC, gui.*) fileSelectionDialog
          (#  do 'Debug executable:'->label[];  #)->execName[];
          (if execName[] <> none then execName[]->setEXECNAMEparam if);
          
       exit execName[]
       #);
     runNewDebuggee:
       (# success: @Boolean; rerun: @Boolean; 
       enter rerun
       do <<SLOT runnewdebuggee:Descriptor>>
       exit success
       #);
     setStepIntoBreaks:
       (#
          uss:
            @debuggee.userSingleStepBreaker
            (#
               init::< 
                 (#
                    cancelled:: 
                      (# 
                      do TRUE->continue
                      #);
                    unknownCode:: 
                      (# breakSetSucceded:@boolean;
                         trySetBreakOnFirstEntry:
                           <<SLOT valhallatrybreakonfirst:descriptor>>;
                      do 
                         (if debuggeeIsReady then
                             trySetBreakOnFirstEntry;
                         if);
                         (if not breakSetSucceded then
                             ('Missing debug info. Cannot step.','Warning')
                               ->(*FGC, gui.*) alertInfo;
                             TRUE->continue;
                         if);
                      #);
                 #);
            #);
       exit not uss.init
       #);
     setStepOverBreaks:
       (#
          uss: @debuggee.userStepOverBreaker
            (#
               init::< 
                 (#
                    cancelled::  (#  do TRUE->continue #);
                    unknownCode:: 
                      (# 
                      do
                         ('Missing debug info. Cannot step.','Warning')
                           ->(*FGC, gui.*) alertInfo;
                         TRUE->continue;
                         
                      #);
                    
                 #);
               
            #);
          
       exit not uss.init
       #);
     doStepOver:
       (# 
       do
          (if debuggeeIsReady then
              (if setStepOverBreaks then doContinue if)
          if);
          
       #);
     doStepInto:
       (# 
       do
          (if debuggeeIsReady then
              (if setStepIntoBreaks then doContinue if)
          if);
          
       #);
     doContinue:
       (# 
       do debuggee.processComm.continue; 'Running'->(*FGC, gui.*) putpinfo; waitersem.V; 
       #);
     doStop:
       (# 
       do
          (if debuggeeIsRunning then
              TRUE->stopped; debuggee.processComm.stop
          if)
       #);
     
     doFinish: <<SLOT valhalladoFinish:descriptor>>;
     
     stopped: @Boolean;
     (*  TRUE if doStop was called. *)
     (* procwaiter
      * ==========
      * 
      * procwaiter is a coroutine doing the job of waiting for the debuggee
      * to stop. Using a separate coroutine for this job allows valhalla to
      * handle user-events while waiting.
      * 
      * procwaiter blocks on waitersem until it should wait for the debuggee
      * to stop. Then it blocks on a call to debuggee.processComm.wait. *)
     waitersem: @semaphore;
     procwaiter: @|System (#  do <<SLOT procwaiter:Descriptor>> #);
     mystackbrowser: (*FGC, gui.*) main.stackbrowser
     (#
        stackbrowserEncloserType:: 
          (#
             openNewCodeView:: 
               (# 
               do
                  cast[]
                    ->newcodemoveable
                  (#
                     acceptFound:: 
                       (# 
                       do
                          contents.browser.
                          codePane.codeViews.find
                          (#
                             predicate:: 
                               (# 
                               do (found[] = current[])->value
                               #)
                          do true->value
                          #)
                       #)
                  #);
                  
               #);
             openNewObjectView:: 
               (# 
               do
                  bo[]
                    ->newobjectmoveable
                  (#
                     acceptFound:: 
                       (# 
                       do
                          true->value;
                          contents.browser.objectPane.objectViews.find
                          (#
                             predicate:: 
                               (# 
                               do
                                  (found[] = current.sov.contents[])
                                    ->value
                               #)
                          do false->value
                          #)
                       #)
                  #);
                  
               #);
             selectCodeView::  (#  <<SLOT selectCodeView:DoPart>> #);
             selectObjectView::  (#  <<SLOT selectObjectView:DoPart>> #);
             alertInfo:: 
               (# 
               do
                  (inf[],title[])
                    ->(*FGC, gui.*) alertInfo
               #);
             
          #);
        
     #);
     mystackview: (*FGC, gui.*) main.stackviewmoveable
     (#
        listEncloserType:: 
          (#
             openNewCodeView:: 
               (# 
               do cast[]->newcodemoveable
               #);
             openNewObjectView:: 
               (# 
               do
                  (bo[],true)
                    ->
                  (*FGC, gui.*) main.
                  OpenMoveableObjectView
                  (#
                     getFather:: 
                       (#  do (*FGC, gui.*) main.objworld[]->father[] #)
                  #)
               #);
             alertInfo::  (#  do (inf[],title[])->(*FGC, gui.*) alertInfo #);
             
          #);
        
     #);
     mycodeview: (*FGC, gui.*) main.myCodemoveable
     (#
        private: @<<SLOT mycodeviewPrivate:Descriptor>>;
        wriggle::< 
          (# 
          <<SLOT mycodeviewWriggle:DoPart>>
          #);
        selectNode:<
          (# node: ^astInterface.ast
          enter node[]
          <<SLOT mycodeviewSelectNode:DoPart>>
          #);
        open:: 
          (# 
          <<SLOT mycodeviewopen:DoPart>>
          #);
        
     #);
     lastEditor: ^(*FGC, gui.*) window.codemoveableEditor;
     newcodemoveable:
       (#
          openIfNotFound:< BooleanValue (#  do true->value; INNER #);
          wriggleIfFound:< BooleanValue
            (# found: ^(*FGC, gui.*) main.codemoveableEditor; 
            enter found[]
            do true->value; INNER
            #);
          acceptFound:< BooleanValue
            (# found: ^(*FGC, gui.*) main.codemoveableEditor; 
            enter found[]
            do found.isolated->value; INNER
            #);
          cast: ^astInterface.ast;
          
       enter cast[]
       <<SLOT newcodemoveable:DoPart>>
       #);
     newobjectmoveable:
       (#
          openIfNotFound:< BooleanValue
            (#  do true->value; INNER #);
          wriggleIfFound:< BooleanValue
            (# found: ^(*FGC, gui.*) main.objectView
            enter found[]
            do true->value; INNER
            #);
          acceptFound:< BooleanValue
            (# found: ^(*FGC, gui.*) main.objectView
            enter found[]
            do INNER
            #);
          bo: ^betaObject;
          
       enter bo[]
       <<SLOT newobjectmoveable:DoPart>>
       #);
     cmdlineprompt: @(*FGC, gui.*) promptForArgs
     (#
        okCalled: @Boolean;
        epdb: ^executableParamDB;
        ok:: 
          (# 
          do
             TRUE->okCalled;
             epdb.clear;
             (for i: argc repeat argv[i][]->epdb.append;  for);
             
          #);
        cancel::  (#  do FALSE->okCalled #);
        doPopup:
          (# defaultTxt: @Text; prompt: ^text; de: @diskEntry; 
          do
             getExecutableParamDB->epdb[];
             epdb.scan
             (# 
             do
                findSpace:
                  (# 
                  do
                     ' '
                       ->current.findAll
                     (# 
                     do
                        '"'->defaultTxt.append;
                        current[]->defaultTxt.append;
                        '"'->defaultTxt.append;
                        ' '->defaultTxt.append;
                        leave findSpace;
                        
                     #);
                     current[]->defaultTxt.append;
                     ' '->defaultTxt.append;
                     
                  #);
                
             #);
             getEXECNAMEparam->de.path;
             de.path.name->prompt[];
             'Enter parameters for `'->prompt.prepend;
             ''':'->prompt.append;
             ((*FGC, gui.*) main[],'Command Line Editor',prompt[],defaultTxt[])->popup;
             
          exit okCalled
          #)
     #);
     rereadprompt: (*FGC, gui.*) noteUser
     (# t: @Text; 
     do
        'Executable `%s'' changed on disk'
          ->t.putFormat
        (# de: @diskEntry; 
        do getEXECNAMEparam->de.path; de.path.name->s; 
        #);
        (*FGC, gui.*) main[]->owner[];
        'Executable Changed'->Title[];
        t[]->message[];
        
     #);
     doEditCommandLine: (#  do cmdlineprompt.doPopup;  #);
     newstackview:
       (# comp: ^processInterface.remoteBetaObject; 
       enter comp[]
       <<SLOT newstackviewbody:DoPart>>
       #);
     newstackbrowser:
       (#
          comp:
            ^processInterface.remoteBetaObject;
          
       enter comp[]
       <<SLOT newstackbrowserbody:DoPart>>
       #);
     sockgen: @socketGenerator;
     (* FGC,     gui: @valhallaGUI
      (# *)  (* gui eliminated *)
     dc: @MPS.AST.valhallaDynamicCompiler;
     dynamicCodeCounter: @integer;
     initCompiler: @<<SLOT ValhallaInitCompiler:descriptor>>;
     newCodeView::  (#  do cast[]->newcodemoveable #);
     ymerBrowserWindow::< 
       (#
          <<SLOT debuggerBrowserWindowLib:Attributes>>;
          browserType::< 
            (#
               editorEncloserType::< 
                 (# tryclose::<  (#  do false->okToClose #) #)
            #);
          workspace:: 
            (#
               menubarType:: 
                 (# open::  (#  <<SLOT workspaceMenubarOpen:DoPart>> #)
                 #)
            #);
          codeViewWindow:: 
            (#
               menubarType:: 
                 (#
                    open:: 
                      (#  <<SLOT codeViewWindowMenubarOpen:DoPart>> #)
                 #)
            #);
          onCodeViewOpen:: 
            (# 
            <<SLOT onCodeViewOpen:DoPart>>
            #);
          onTerminateApplication::< 
            (# 
            do (if isStandAloneValhalla then 
                   false->okToTerminate; 
               if);
               hide; 
               INNER
            #);
          quit::<  (#  do false->okToClose; hide; inner #);
          eventhandler::< 
            (# onAboutToClose::  (#  do false->okToClose; hide #)
            #);
          menubarType::< 
            (# open::<  (#  <<SLOT guiMenubarTypeOpen:DoPart>> #) #);
          open::<  (#  do (if isStandAloneValhalla then THIS(ymerBrowserWindow).hide; if); Inner  #);
          
       #);
     (* The following final bound virtuals are declared in valhallaGUI,
      * and called by menus and buttons in the user-interface. *)
     newDebuggee:: 
       (# changedOutside,otherError: @boolean
       do
          (if newExecName <> none then
              ensureKilled;
              doEditCommandLine;
              FALSE->runNewDebuggee;
              (if debuggee[] <> none then
                  ('program',debuggee.MPS.BETA.DescriptorForm)
                    ->debuggee.DBmanager.slotnameToGroups
                  (#  do current[]->loadSources #);
                  
              if)
          if)
       #);
     debuggeeStatus::  (#  do debuggeeIsReady->value #);
     debuggeeRerun:: 
       (# 
       do (if rerunStatus then ensureKilled; TRUE->runNewDebuggee if)
       #);
     rerunStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              debuggeeIsReady or debuggee.terminated->value; 
           else
              TRUE->value; 
          if);
          value and (getEXECNAMEparam <> none )->value;
          
       #);
     killDebuggee:: 
       (# 
       do (if debuggeeIsReady then ensureKilled; 'Killed'->putpinfo if)
       #);
     killStatus:: debuggeeIsReady (#  #);
     source:: 
       (# x,y: @integer
       do
          sources.position->(x,y);
          (if (x = 0) and (y = 0) then
              (*FGC, gui.*) main.position->(x,y); (x+10,y+10)->sources.position
          if);
          sources.show;
          sources.wriggle
       #);
     sourceStatus::  (#  do true->value #);
     editenv:: 
       (# 
       do
          (if theEnveditor[] <> none then
              theEnveditor.wriggle; 
           else
              &envedittype[]->theEnveditor[]; theEnveditor.open; 
          if);
          
       #);
     editenvStatus:: TrueObject;
     editcmdline::  (#  do doEditCommandLine;  #);
     editcmdlineStatus:: TrueObject;
     quit:: 
       (# 
       do
          (if debuggeeIsReady and (debuggee[] <> none ) then
              debuggee.kill; onTerminate
          if)
       #);
     debuggeeContinue:: 
       (#  do (if continueStatus then doContinue if) #);
     continueStatus:: debuggeeIsReady (#  #);
     debuggeeStepOver::  (#  do doStepOver #);
     stepOverStatus:: debuggeeIsStarted (#  #);
     debuggeeStepInto::  (#  do doStepInto;  #);
     stepIntoStatus:: debuggeeIsReady;
     debuggeeStop::  (#  do doStop #);
     stopStatus:: debuggeeIsRunning (#  #);
     
     debuggeeFinish::(# do doFinish #);
     FinishStatus::debuggeeIsStarted(# #);
     
     debuggeeActiveStack:: 
       (# 
       do
          (if activeStackStatus then
              debuggee.currentRemoteComponent->newstackview
          if);
       #);
     activeStackStatus:: 
       (# 
       do
          (if debuggee[]<> none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curComp <> 0)->value
              if);
           else
              false->value;
          if);
          
       #);
     debuggeeStackBrowser:: 
       (# 
       do
          (if stackBrowserStatus then
              debuggee.currentRemoteComponent->newstackbrowser
          if);
          
       #);
     stackBrowserStatus:: 
       (# 
       do
          (if debuggee[]<>none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curComp <> 0)->value
              if);
           else
              false->value;
          if);
       #);
     debuggeeCurObj::  (#  <<SLOT debuggeeCurObj:DoPart>> #);
     curObjStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curObj <> 0)->value
              if);
           else
              false->value;
          if);
       #);
     debuggeeCurCode:: 
       (# 
       do
          <<SLOT debuggeeCurCode:Descriptor>>
       #);
     curCodeStatus:: 
       (# 
       do
          (if debuggee[] <> none then
              debuggeeIsReady->value;
              (if value then 
                  (debuggee.pc <> 0)->value; 
              if);
           else
              false->value;
          if);
       #);
     debuggeeCurComp:: 
       (# 
       do
          (if curCompStatus then
              (debuggee.currentRemoteComponent,FALSE)
                ->(*FGC, gui.*) main.OpenMoveableObjectView
              (#
                 getFather:: 
                   (#  do (*FGC, gui.*) main.objworld[]->father[] #)
              #)
          if);
          
       #);
     curCompStatus:: 
       (# 
       do
          (if debuggee[]<>none then
              (if (debuggeeIsReady->value) then
                  (debuggee.curComp <> 0)->value
              if)
           else
              false->value;
          if);
       #);
     onTerminate:: 
       (# 
       do
          main.status.setenabling;
          0->setPIDparam;
          objectviews.newscan
          (#  do cur.encl.tryclose #);
          stackviews.newscan
          (#  do cur.encl.tryclose #);
          
       #);
     onMoveablesInsert::  (#  #);
     codeviews: @codemoveableEditorList;
     stackviews: @stackviewlistlist;
     objectviews: @objectviewList
       (#
          onInsert:: 
            (#
               addItemMenuItems: theObjectView.addObjectViewItemMenuItems
                 (#
                    show::  (#  do comp[]->newstackview #);
                    showC::  (#  do ast[]->newcodemoveable;  #);
                    
                 #);
               addmovItems: movo.addObjectViewactionedMenuItems
                 (#
                    show::  (#  do comp[]->newstackview #);
                    showC::  (#  do ast[]->newcodemoveable;  #);
                    
                 #);
               mov: ^main.moveable;
               movo: ^main.moveableObjectView;
               
            do
               theObjectView.encl.getMoveable->mov[];
               (if mov[] <> none then
                   (if mov## <= main.moveableObjectView## then
                       mov[]->movo[];
                       addmovItems##->movo.movMenu.onOpen.appendAction;
                       
                   if);
                   
               if);
               addItemMenuItems##
                 ->theObjectView.itemMenu.onOpen.appendAction;
               
            #);
          onDelete::  (#  #);
          
       #);
     ValhallamainWindow::<
       (#
          menubarType:: 
            (# open::  (#  <<SLOT mainTypeMenubarTypeOpen:DoPart>> #)
            #)
       #);
     init::< (* gui.init *) 
       (#  (*FGC, skal dette i en pattern, saa det kan redo *)
       do
          stackviews.init;
          stackviews[]
            ->objectPool.put;
          codeviews.init;
          codeviews[]
            ->objectPool.put;
          objectviews.init;
          objectviews[]
            ->objectPool.put;
          (dragOutLineOnOpen,false)->setOption;
          (dynamiccompilation,true)->setOption;
          INNER;
       #);
          (* FGC #); *)
     loadSources:
       (# exec: ^text
       enter exec[]
       do
          exec[]
            ->
          (*FGC, gui.*) mps.ast.
          expandToFullPath->(*FGC, gui.*) sources.appendProject;
          (*FGC, gui.*) sources.appendDone
       #);
     AfterInit:<Object;
  do
     INNER;

     thespawner.init;
     thespawner[]->objectPool.put;
     0->sockgen.port;
     sockgen.bind;
     sockgen[]->objectPool.put;
     parseValhallaParams;
     procwaiter[]->fork;

     AfterInit;
     (*
      gui.init;
      parseValhallaParams;

      (if getEXECNAMEparam <> none then
      FALSE->runNewDebuggee;
      (if debuggee[] <> none then
      ('program',debuggee.MPS.BETA.DescriptorForm)
      ->debuggee.DBmanager.slotnameToGroups
      (#  do current[]->loadSources #);
      if);
      if)
      *)
  #)  


