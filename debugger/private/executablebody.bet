ORIGIN '../processInterface';
INCLUDE '~beta/objectbrowser/v2.1/options'
        '~beta/basiclib/v1.5/formatio'
        '~beta/containers/v1.5/arrayContainer';
BUILD default '$$/labelnametable.o' 'external/labelnametable.c' '$CC -D$$ -c -o $0 $1'
       nti '$$/labelnametable.o' 'external/labelnametable.c' 'betacc $0 $1';
(* OBJFILE default '$/labelnametable.o';
 * MAKE default 'external/labelnametable.make';
 *)
-- executableInit: DoPart --
do
   'PreReadLabels'
     ->(getOptionDB).getBooleanOption
       (# found::  (#  do value->execPrivate.readLabelsOnStartup #) #);
   (getEXECNAMEparam).copy->execPrivate.execFile.name;
   (if execPrivate.execFile.entry.exists then
       execPrivate.execFile.entry.modTime->modTime;
       (if execPrivate.readLabelsOnStartup then
           execPrivate.labelTable.forknm; 
       if);
       
    else
       execPrivate.execFile.name->notFound; 
   if);
     

-- executableFinishInit: DoPart --
do
   (if execPrivate.readLabelsOnStartup then
       (if not execPrivate.labelTable.initialized then
           execPrivate.labelTable.readFromExecutable
       if);
       
   if);
     

-- executableReInit: DoPart --
do (* ... *)
   'PreReadLabels'
     ->(getOptionDB).getBooleanOption
       (# found::  (#  do value->execPrivate.readLabelsOnStartup #) #);
   doreinit:
   (if execPrivate.execFile.entry.exists then
       (if execPrivate.execFile.entry.modTime <> modTime then
           execPrivate.execFile.name->modTimeChanged; leave doreinit; 
       if);
       (if execPrivate.readLabelsOnStartup then
           (if not execPrivate.labelTable.initialized then
               execPrivate.labelTable.forknm; 
           if);
           
       if);
       
    else
       execPrivate.execFile.name->notFound; 
   if);
     

-- labelNameToAddress: DoPart --
do   

-- labelAddressToName: DoPart --
do address->execPrivate.labelTable.findNearestLabel->(name[],value);   

-- executableKill: DoPart --
do   

-- executablePrivate: Descriptor --
(#
   execFile: @File;
   readLabelsOnStartup: @Boolean;
   initReadNameTable: external
     (# execFileName: [1] @Char;  enter execFileName #);
   nextAddress: external (* exits 0 if no more code labels are available. *)
     (# address: @Integer;  exit address #);
   nextLabel: external (# label: [1] @Char;  exit label #);
   labelTable: @ (* Table of code and data labels. *)
     (#
        labels: [initialCapacity] ^Text;
        values: [initialCapacity] @Integer;
        initialCapacity: (#  exit 6000 #);
        count: @Integer;
        max: @Integer;
        initialized: @Boolean;
        nmforked: @Boolean;
        forknm:
          (# tmp: ^Text; 
          do execFile.name->tmp[]; tmp->initReadNameTable; TRUE->nmforked; 
          #);
        readFromExecutable:
        (* Reads the code labels of the executable into this table. *)
          (# tmp: ^Text; val: @Integer; 
          do
             onLabelRead;
             (if not nmforked then forknm if);
             initialCapacity->max;
             (* It is assumed that the labels are read in ascending order!! *)
             loop:
             (* datpete 14/3/96; chnged check for 0 to check for -1:
              * sgi has several symbols for address 0, 
              * which comes first in the ascending order 
              * => no labels are read.
              *)
             (if (nextAddress->val) <> - 1 then
                 count+1->count;
                 (if count > max then
                     labels.range->labels.extend;
                     labels.range->max;
                     values.range->values.extend;
                     
                 if);
                 ''->tmp[];
                 nextLabel->tmp;
                 tmp[]->labels[count][];
                 val->values[count];
                 restart loop;
                 
             if);
             onLabelReadDone;
             TRUE->initialized;
             FALSE->nmforked;
             
          #);
        findNearestLabel:
          (#
             adr: @Integer;
             low,mid,high: @Integer;
             label: ^Text;
             value: @Integer;
             
          enter adr
          do
             (if not initialized then readFromExecutable if);
             (if count > 0 then (* count=0 => the executable is stripped *)
                 1->low;
                 count->high;
                 (low+high) div 2->mid;
                 binsearch:
                 (if high = low then
                     (if values[low] = adr then
                         labels[low][]->label[]; values[low]->value; 
                      else
                         (if mid > 1 then
                             labels[low-1][]->label[]; values[low-1]->value; 
                         if);
                         
                     if);
                     
                  else
                     (if values[mid] < adr then
                         mid+1->low; 
                      else
                         mid->high; 
                     if);
                     (low+high) div 2->mid;
                     restart binsearch;
                     
                 if)
              else
                 'Unknown label'->label[]; adr->value
             if);
             
          exit (label[],value)
          #);
        
     #);
   
#)  

