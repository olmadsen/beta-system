ORIGIN '../processInterface';

INCLUDE '~beta/objectbrowser/v2.0.1/options';
INCLUDE '~beta/basiclib/v1.4/formatio';
INCLUDE '~beta/containers/v1.4/arrayContainer';

OBJFILE default '$/labelnametable.o';
MAKE default 'external/labelnametable.make';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- executableInit:dopart ---
do 
   'PreReadLabels'->(getOptionDB).getBooleanOption
   (# found:: (# do value->execPrivate.readLabelsOnStartup #)#);
   
   (getEXECNAMEparam).copy->execPrivate.execFile.name;
   
   (if execPrivate.execFile.entry.exists  then
       execPrivate.execFile.entry.modTime -> modTime;
       (if execPrivate.readLabelsOnStartup then
           execPrivate.labelTable.forknm;
       if);
    else
       execPrivate.execFile.name->notFound;
   if);
   
--- executableFinishInit:dopart ---
do 
   (if execPrivate.readLabelsOnStartup then
       (if not execPrivate.labelTable.initialized then
           execPrivate.labelTable.readFromExecutable
       if);
   if);
   
--- executableReInit:dopart ---
do (* ... *)
   
   'PreReadLabels'->(getOptionDB).getBooleanOption
   (# found:: (# do value->execPrivate.readLabelsOnStartup #)#);
   
   doreinit:
     (if execPrivate.execFile.entry.exists  then
         (if execPrivate.execFile.entry.modTime <> modTime then
             execPrivate.execFile.name->modTimeChanged;
             leave doreinit;
         if);
         (if execPrivate.readLabelsOnStartup then
             (if not execPrivate.labelTable.initialized then
                 execPrivate.labelTable.forknm;
             if);
         if);
      else
         execPrivate.execFile.name->notFound;
     if);
   
--- labelNameToAddress:dopart ---
do 

--- labelAddressToName:dopart ---
do address->execPrivate.labelTable.findNearestLabel->(name[],value);
   
--- executableKill:dopart ---
do 
   
--- executablePrivate:descriptor ---
(# execFile: @File;
   readLabelsOnStartup: @Boolean;
   
   initReadNameTable: external
     (# execFileName: [1]@Char;
     enter execFileName
     #);
   
   nextAddress: external 
     (* exits 0 if no more code labels are available. *)
     (# address: @Integer;
     exit address
     #);
   
   nextLabel: external 
     (# label: [1]@Char; 
     exit label
     #);
   
   labelTable: @ (* Table of code and data labels. *)
     (# labels: [initialCapacity]^Text;
        values: [initialCapacity]@Integer;
        
        initialCapacity: (# exit 6000 #);
        count: @Integer;
        max: @Integer;
        initialized: @Boolean;
        
        nmforked: @Boolean;
        forknm: 
          (# tmp: ^Text; 
          do execFile.name->tmp[]; tmp->initReadNameTable;
             TRUE->nmforked;
          #);
        
        readFromExecutable:
          (* Reads the code labels of the executable into this table. *)
          (# tmp: ^Text; val: @Integer;
          do 
             onLabelRead;
             (if not nmforked then forknm if);
             
             initialCapacity->max;
             (* It is assumed that the labels are read in ascending order!! *)
             loop:
               (* datpete 14/3/96; chnged check for 0 to check for -1:
                * sgi has several symbols for address 0, 
                * which comes first in the ascending order 
                * => no labels are read.
                *)
               (if (nextAddress->val) <> -1 then
                   count+1->count;
                   (if count>max then 
                       labels.range->labels.extend; labels.range->max;
                       values.range->values.extend;
                   if);
                   ''->tmp[];
                   nextLabel->tmp;
                   tmp[]->labels[count][];
                   val->values[count]; 
                   restart loop;
               if); 
             onLabelReadDone;
             TRUE->initialized;
             FALSE->nmforked;
          #);
        
        findNearestLabel:
          (# adr: @Integer; 
             low,mid,high: @Integer;
             label: ^Text; value: @Integer;
          enter adr
          do 
             (if not initialized then readFromExecutable if);
             
             1->low; count->high; (low+high) div 2->mid;
             binsearch:
               (if high=low then
                   (if values[low] = adr then
                       labels[low][]->label[];
                       values[low]->value;
                    else
                       (if mid>1 then
                           labels[low-1][]->label[];
                           values[low-1]->value;
                       if);
                   if);
                else
                   (if values[mid] < adr then
                       mid+1->low;
                    else
                       mid->high;
                   if);
                   (low+high) div 2 -> mid;
                   restart binsearch;
               if);
          exit (label[],value)
          #);
        
     #);
   
#)
