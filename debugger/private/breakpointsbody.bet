ORIGIN '../breakpoints';
INCLUDE '~beta/basiclib/formatio';
LIB_ITEM 'valhallabreak';
(*
 * COPYRIGHT
 *   Copyright (C) Aarhus University
 *   All rights reserved.
 *)
-- breakManagerListInitDopart: DoPart --
do
   afterWaitAction##->afterWaitActions.appendAction;
   beforeContinueAction##->beforeContinueActions.appendAction;
   INNER init;
     

-- breakListAppendDopart: DoPart --
do
   last+1->last;
   (if last > breaks.range then breaks.range->breaks.extend if);
   break[]->breaks[last][];
   INNER ;
     

-- breakListDeleteDopart: DoPart --
do
   (for i: last repeat
     (if break[] = breaks[i][] then
         breaks[last][]->breaks[i][];
         none ->breaks[last][];
         last-1->last;
         INNER ;
         
     if);
     
   for);
     

-- breakListScanBody: Descriptor --
(# breaksc: [0] ^breakType; lastc: @integer; 
do
   last->lastc;
   breaks->breaksc;
   (* Since members may be deleted during scan, take a copy first. *)
   (for i: lastc repeat breaksc[i][]->current[]; INNER scan;  for);
   
#)  

-- processInterfaceRemoveBreaks: DoPart --
do
     (# bml: ^breakManagerList; bm: ^breakManager; 
     do
        getBreakManagerList->bml[];
        bml.scan
          (# 
          do current[]->bm[]; bm.scan (#  do current.doClear;  #); 
          #);
        
     #);
     

-- breakManagerDeleteBreak: Descriptor --
(# 
do
   dodelete:
   (if last = 0 then
       (if not terminated then
           (codeAddress,oldCodeValue)
             ->processComm.processCode.unsetBreakpoint
               (#
                  accessFailure:: 
                    (#  do FALSE->breakfailure; leave dodelete #);
                  
               #);
          (* 'Cleared breakpoint at %d\n'->putformat
            (# 
            do codeAddress->d;
            #);
           *)
       if);
       THIS(breakManager)[]->bml.at->bml.delete;
       clearActions.execute;
       
   if);
   
#)  

-- breakManagerInit: Descriptor --
(# 
do
   doinit:
     (# 
     do
        codeAddress
          ->processComm.processCode.setBreakpoint
            (#
               accessFailure::  (#  do TRUE->breakfailure; leave doinit #); 
            #)->oldCodeValue;
        (*
         'Set breakpoint at %d (%s). New code value: %d.\n'->putformat 
         (# name: ^Text; value: @Integer;
         do codeAddress->d;
         codeAddress->executable.labelAddressToName->(name[],value);
         name.copy->name[];'+'->name.append;codeAddress-value->name.putInt;
         name[]->s;
         codeAddress->processComm.processData.peekLong->d;
         #);
         *)
        getBreakManagerList->bml[];
        THIS(breakManager)[]->bml.append;
        (if numberManager
         // MNGR_USERSKIP then
            MNGR_USERSKIP->number; 
         // MNGR_NEWNUMBER then
            bml.nextBreakNumber->number; 
        if);
        clearActions.init;
        
     #);
   
#)  

-- breakManagerMakePendingDopart: DoPart --
do
   (codeAddress,oldCodeValue)
     ->processComm.processCode.unsetBreakpoint
       (# accessFailure::  (#  do FALSE->breakfailure;  #);  #);
   THIS(breakManager)[]->bml.pending[];
   (*'Pending breakpoint at %d\n'->putformat (# do codeAddress->d #);*)
     

-- breakManagerReinstallDopart: DoPart --
do
   (if not terminated then
       codeAddress
         ->processComm.processCode.setBreakpoint
           (# accessFailure::  (#  do TRUE->breakfailure #) #)
              (* 'Reinstalled breakpoint at %d\n'->putformat (# do codeAddress->d #); *)
   if)

-- stepbreakerInitDopart: DoPart --
do
   getBreakManagerList->bml[];
   (if registerCallbackAction then
       onRTScallback##->steppingActions.appendAction; 
   if);
   INNER ;
   (* set stepStetIMPs and stepsetADRs *)
   (if not init_error then
       setBreaks:
         (# br: ^breakType; bm: ^breakManager; 
         do
            stepsetIMPs.scan
              (# 
              do
                 (current.start,mngrnumbering)->ensureBreakManager->bm[];
                 bm[]->(&breakType[]->br[]).init;
                 br[]->appendBreak;
                 (bm[],current[])->forEachImpNode;
                 
              #);
            stepsetADRs.scan
              (# 
              do (if debugStepBreak then
                     'Setting Break at adr:%d\n'->putformat
                     (# do current->d #)
                 if);
                 (current,mngrnumbering)->ensureBreakManager->bm[];
                 bm[]->(&breakType[]->br[]).init;
                 br[]->appendBreak;
                 bm[]->forEachAdr;
                 
              #);
            
         #);
       
   if);
     

-- breakManagerListAfterWaitBody: Descriptor --
(# curpc: @Integer; 
do (*'Process stopped at %d\n'->putformat
    (#
    do PC->d;
    #);*)
   PC->curpc;
   (if activeSkip[] <> none then activeSkip.onhit if);
   checkBreakpointHit: scan
     (# 
     do
        (if current.codeAddress = curpc then
            current.onHit; leave checkBreakpointHit; 
        if);
        
     #);
   
#)  

-- breakManagerListBeforeContinueBody: Descriptor --
(# curpc: @Integer; impi: ^ImperativeInfo; 
do
   FALSE->skipBreakHit->traceBreakHit;
   0->userBreakHit;
   (* Check if we are stepping across a set breakpoint.
    * If so, make it pending and set the required skipBreaks. *)
   PC->curpc;
   findPending: scan
     (# 
     do
        (if current.codeAddress = curpc then
            current.makePending;
            &skipBreaker[]->activeSkip[];
            (if activeSkip.init then none ->activeSkip[] if);
            leave findPending;
            
        if);
        
     #);
   
#)  
