ORIGIN '../valhallaapplication';
INCLUDE '~beta/compiler/GENERATOR/disass'
        '~beta/editor/codeeditor'
        'processinterfacebody'
        '~beta/sysutils/errorscreen';
LIB_ITEM 'valhalla';
-- ValhallaInitCompiler: Descriptor --
(# initialised,error: @boolean; exename: ^text; tmp: ^text; 
do
   'Compiling Evaluator ...'->putpinfo;
   (if not initialised then
       (if false then (* do not want unconditional tracing *)
           (if valhallaprefs.dynamiccompilation then
           (* FIXME: when mjolner starts using a streamwindow, 
            * replace the screen[] below with that log window 
            *)
               screen[]->DC.NT.traceStream[]; screen[]->DC.NT.infoStream[]
           if)
       if);
       (* The two stupid putlines below are needed on NTI.
        * If they are removed, the initialization of the dynamic compiler
        * fails! Must be a code generation error.
        *)
       dc.initDyn;
       'Reading symbols ...'->putpinfo;
       (getEXECNAMEparam,true)
         ->DC.NT.init
           (#
              ExternalLookup:: 
                (#  do t[]->debuggee.processComm.Lookup_Address->i #);
              
           #);
       'Initializing Dynamic Compiler ['->tmp[];
       DC.compilerversion->tmp.puttext;
       '] ...'->tmp.puttext;
       tmp[]->putinfo;
       getEXECNAMEparam->exename[];
       exefileextension->exename.stripextension;
       (exename[],none ,none )->dc.activateCompiler->error;
       (if error then
           'Initialisation of dynamic compiler failed'->putinfo;
           'Initialisation of dynamic compiler failed'->debuggee.othererror
        else
           'Dynamic compiler initialized.'->putinfo
       if);
       (if 'DebugDynamic'->getOption then
           'Getting process offset ...'->DC.NT.tracestream.puttext; 
       if);
       debuggee.processComm.get_main_physical-('main'->DC.NT.lookupC)
         ->DC.NT.logical2physical_offset;
       (if 'DebugDynamic'->getOption then
           'Done: is '->DC.NT.tracestream.puttext;
           DC.NT.logical2physical_offset->DC.NT.tracestream.putint;
           DC.NT.tracestream.newline;
           
       if);
       true->initialised
   if);
   
#)  

-- ValhallaInitCodeEditor: DoPart --
do (* setup edit menu *)
   (if first then
       
    else
       &vcem[]->cem[];
       cem.open;
       ('Evaluate',66016,false,false,false)->cem.Evaluate.newSpecKey;
       cem[]->main.mainmenubar.append;
       true->first
   if)  

-- valhallalib: Attributes --
constructUniqueID:
  (# T: @Text; timeSec,timeMiliSec: @integer; timeInMiliSec: @real
  do
     preciseTime->(timeSec,timeMiliSec);
     timeSec->timeInMiliSec;
     timeInMiliSec*1000000->timeInMiliSec;
     timeInMiliSec+timeMiliSec->timeInMiliSec;
     timeInMiliSec->t.putReal (#  do 0->precision #)
  exit t.copy
  #);
Evaluate:
  (#
     originFGname,evaluatorCode,dynamicFGname: ^text;
     aRemoteBetaObject: ^debuggee.remoteBetaObject;
     FF: ^MPS.AST.fragmentForm;
     FG,originFG: ^MPS.AST.fragmentGroup;
     im: ^imagePair;
     error: @boolean;
     evalobjadr: @integer;
     aPTI: ^debuggee.prototypeInfo;
     anOD: ^MPS.BETACFL.objectDescriptor;
     anIndex: @MPS.AST.ASTindex;
     dataAreaStart,codeAreaStart: @integer;
     allocateMemory:
       (#
          allocationFailed:< exception (#  do INNER #);
          IMG: ^IM.loadableImage;
          anImage: ^image;
          numBytes,allocatedAreaStart: @integer;
          tmp: ^text;
          
       enter IMG[]
       do
          IMG.im[]->anImage[];
          (if trace then 'LIP: '->puttext; anImage.LIP->puthex;  if);
          (if IMG.isCode then
              anImage.LIP->numBytes
           else
              (if trace then
                  ' GOTnoOfBytes: '->puttext; IM.GOTnoOfBytes->puthex; 
              if);
              anImage.LIP+IM.GOTnoOfBytes->numBytes
          if);
          (if trace then newline if);
          (if anImage.buffer_ptr <> 0 then
              'Normal externally allocated data buffer'->tmp[];
              'Buffer size: %i\n'
                ->tmp.putFormat (#  do anImage.buffer_size->i #);
              'Still needs to be implemented'->tmp.putLine;
              tmp[]->putinfo;
              tmp[]->debuggee.othererror;
              
           else
              numBytes->debuggee.processComm.processData.allocateMemory
                ->allocatedAreaStart;
              (if allocatedAreaStart = 0 then allocationFailed if)
          if)
       exit allocatedAreaStart
       #);
     protoAddress,objectAddress: @integer;
     trace: @boolean;
     dumpCode:
       (# DA: @disass; 
       do
          '\nDYNAMIC CODE SEGMENT:'->putline;
          (if DA.hasDisass then
              (for i: IM.xCode.IM.LIP div 4 repeat
                codeAreaStart+(i-1)*4->puthex;
                ':'->put;
                '\t'->put;
                codeAreaStart+(i-1)*4
                  ->debuggee.processComm.processData.peeklong
                    (#
                       accessFailure:: 
                         (#  do 'Reading code adr failed'->msg.append #)
                    #)->DA->screen.putline;
                
              for)
           else
              (codeAreaStart,IM.xCode.IM.LIP div 4)->dumpMemoryArea; 
          if);
          
       #);
     dumpMemoryArea:
       (# address,length: @integer; memoryContents: @integer; adr,con: @text
       enter (address,length)
       do
          'Address\t\tContents'->putLine;
          (for g: length repeat
            address+(g-1)*4
              ->adr.putHex
                (# format::<  (#  do true->zeroPadding; true->uppercase #)
                #);
            '0x'->adr.prepend;
            address+(g-1)*4->debuggee.processComm.processData.peekLong
              ->con.putHex
                (# format::<  (#  do true->zeroPadding; true->uppercase #)
                #);
            '0x'->con.prepend;
            '%s\t%s\n'->putFormat (#  do adr[]->s; con[]->s #);
            adr.clear;
            con.clear
          for)
       #);
     originObjectAddress,dynamicProtoAddress,originObjectProtoAddress:
       @integer;
     nameOfDynamicPattern: @text;
     a: ^MPS.AST.ast;
     theCexternalEntry: ^MPS.BETACFL.ObjectDenotation;
     theAttributes: ^MPS.BETACFL.attributes;
     theObjectDescriptor: ^MPS.BETACFL.objectDescriptor;
     thePatternDecl: ^MPS.BETACFL.patternDecl;
     theMainPart: ^MPS.BETACFL.mainPart;
     theActionPart: ^MPS.BETACFL.actionPart;
     theDoPart: ^MPS.BETACFL.doPart;
     theImperatives: ^MPS.BETACFL.imperatives;
     errorDuringCompilation:<
       (# owner: ^gui.window; msg,title: ^text; 
       enter (owner[],msg[],title[])
       do INNER
       #);
     
  enter evaluatorCode[]
  do
     compilationAndLinking:
       (# 
       do
          initCompiler;
          debuggee.currentRemoteBetaObject->aRemoteBetaObject[];
          aRemoteBetaObject.protoAdr
            ->debuggee.utilities.protoAddressToPrototypeInfo->aPTI[];
          aPTI.ofi.groupName[]->originFGname[];
          originFGname[]->MPS.BETACFL.openBETAfragmentGroup->originFG[];
          aPTI.objdesc[]->anOD[];
          (anOD.index,anOD.frag[])->anIndex;
          'dynamicPattern'->nameOfDynamicPattern.append;
          dynamicCodeCounter->nameOfDynamicPattern.putInt;
          ': external '->evaluatorCode.prepend;
          nameOfDynamicPattern[]->evaluatorCode.prepend;
          'dynamicCode'->MPS.BETACFL.makeBETAfragmentForm->FF[];
          (MPS.BETACFL.ObjectDenotation,'cExternalEntry',FF[])
            ->MPS.BETACFL.parseText->theCexternalEntry[];
          (MPS.BETA.attributes,evaluatorCode[],FF[])
            ->MPS.BETACFL.parseText
              (#
                 parseError::< 
                   (# 
                   do
                      'Parse errors in evaluator'->putinfo;
                      (main[],'Parse errors','Compilation Errors')
                        ->errorDuringCompilation;
                      leave compilationAndLinking
                   #)
              #)->theAttributes[];
          theAttributes.getSon1->thePatternDecl[];
          thePatternDecl.getObjectdescriptor->theObjectDescriptor[];
          theObjectDescriptor.getMainPart->theMainPart[];
          theMainPart.getActionPart->theActionPart[];
          theActionPart.getDoPartOpt->a[];
          (if a## = MPS.BETACFL.doPart## then
              a[]->theDoPart[]
           else
              leave compilationAndLinking
          if);
          theDoPart.getImperatives->a[];
          (if a## = MPS.BETACFL.imperatives## then
              a[]->theImperatives[];
              (1,theCexternalEntry[])->theImperatives.insert
           else
              (MPS.BETACFL.Imperatives,'cExternalEntry',FF[])
                ->MPS.BETACFL.parseText->theImperatives[];
              theImperatives[]->theDoPart.putImperatives
          if);
          theAttributes[]->FF.root[];
          constructUniqueID->dynamicFGname[];
          dynamicFGname[]->MPS.BETACFL.openBETAfragmentGroup->FG[];
          FF.name->FG.fragmentList.deleteLocalName;
          FF[]->FG.fragmentList.addFragment;
          (if (FG.prop[] <> none ) then
              'ORIGIN'->FG.prop.addProp (#  do originFGname[]->addString #);
              'doneCheck'->FG.prop.addProp (#  do 0->addConst #);
              
           else
              (main[],'No properties','Unrecoverable error')
                ->errorDuringCompilation;
              leave compilationAndLinking
          if);
          FG.markAsChanged;
          (FG.name,anIndex[],originFG[])
            ->dc.activateCompiler
              (#
                 Report::< 
                   (# 
                   do
                      'Compilation errors in evaluator'->putinfo;
                      (main[],msg[],'Compilation Error')
                        ->errorDuringCompilation;
                      leave compilationAndLinking
                   #);
                 semanticErrorsNotification::<  (#  do true->error #)
              #)->error;
          (if not error then
              true->dc.getImagePair->IM[];
              (if false then dc.imageList.scan (#  #) if);
              (if 'DebugDynamic'->getOption then
                  true->trace;
                  true->IM.trace;
                  newLine;
                  newLine;
                  'ALLOCATION:'->putLine
              if);
              (* Collect external symbols for building possible
               * Global Offset Table (GOT) in data segment.
               * This is currently only needed for SGI
               *)
              DC.NT[]->IM.xCollectExternals;
              allocation:
                (# 
                do
                   IM.xData[]
                     ->allocateMemory
                       (#
                          allocationFailed::< 
                            (#  do 'data: Allocation failed'->msg.append #)
                       #)->dataAreaStart;
                   IM.xCode[]
                     ->allocateMemory
                       (#
                          allocationFailed::< 
                            (#  do 'code: Allocation failed'->msg.append #)
                       #)->codeAreaStart
                #);
              (if 'DebugDynamic'->getOption then
                  'Allocation Succeed'->putLine;
                  'Datasegment buffer: %s\tCode-segment buffer: %s\n\n'
                    ->putFormat
                      (# st: @text
                      do
                         dataAreaStart
                           ->st.putHex
                             (#
                                format::< 
                                  (# 
                                  do true->zeroPadding; true->uppercase
                                  #)
                             #);
                         '0x'->st.prepend;
                         st[]->s;
                         st.clear;
                         codeAreaStart
                           ->st.putHex
                             (#
                                format::< 
                                  (# 
                                  do true->zeroPadding; true->uppercase
                                  #)
                             #);
                         '0x'->st.prepend;
                         st[]->s
                      #);
                  newLine;
                  newLine;
                  'RELOCATION:'->putLine
              if);
              relocation:
                (# 
                do
                   (dataAreaStart,codeAreaStart)->IM.xAllocImage;
                   dc.NT[]->IM.xCollectEntries;
                   dc.NT[]->IM.xRelocate
                #);
              (if 'DebugDynamic'->getOption then
                  'Relocation Succeed'->putLine;
                  newLine;
                  newLine;
                  'WRITING RELOCATED SEGMENTS TO DEBUGGEE:'->putLine
              if);
              writeToDebuggee:
                (# 
                do
                   IM.xTransferImage
                     (# 
                     do
                        (outProcessAdr,item)
                          ->debuggee.processComm.processData.pokeLong
                            (#
                               accessFailure::< 
                                 (# 
                                 do
                                    'writeToDebuggee: Failed to move segments'
                                      ->msg.append
                                 #)
                            #)
                     #)
                #);
              (if 'DebugDynamic'->getOption then
                  'writeToDebuggee Succeed'->putLine;
                  newLine;
                  newLine;
                  'ADDING GROUP TO DEBUGGEE'->putLine
              if);
              addingGroup:
                (# new: ^processInterface.ObjectFileInfo; 
                do
                   IM.dataStart
                     ->debuggee.processComm.processData.addGroup
                       (#
                          accessFailure::< 
                            (#  do 'AddGroup failed'->msg.append #);
                          
                       do
                          &debuggee.ObjectFileInfo[]->new[];
                          groupName[]->new.groupName[];
                          dataStart->new.dataStart;
                          dataEnd->new.dataEnd;
                          codeStart->new.codeStart;
                          codeEnd->new.codeEnd;
                          groupNameHash->new.groupNameHash;
                          checkTime->new.checkTime;
                          LL_INITIAL->new.loadLevel;
                          new[]->debuggee.piPrivate.ObjectFileInfos.insert;
                          
                       #);
                   
                #);
              (if 'DebugDynamic'->getOption then
                  'addingGroup Succeed'->putLine;
                  'Adding header located at: %s\n\n'
                    ->putFormat
                      (# st: @text
                      do
                         IM.dataStart
                           ->st.putHex
                             (#
                                format::< 
                                  (# 
                                  do true->zeroPadding; true->uppercase
                                  #)
                             #);
                         '0x'->st.prepend;
                         st[]->s
                      #);
                  newLine;
                  newLine;
                  
              if);
              calculateOrigin:
                (# 
                do
                   (if aRemoteBetaObject.isComp then
                       aRemoteBetaObject.getAddress+24->objectAddress
                    else
                       aRemoteBetaObject.getAddress->objectAddress
                   if);
                   
                #);
              calculateProto: (#  do (1->IM.indexedOff)->protoAddress;  #);
              executeObjectInDebuggee:
                (# tmp: @text; impi: ^processInterface.ImperativeInfo; 
                do
                   'Waiting for evaluator ...'->putinfo;
                   'Executing evaluator ...'->putpinfo;
                   (objectAddress,protoAddress)
                     ->debuggee.processComm.processData.executeObject
                       (#
                          accessFailure::< 
                            (# 
                            do
                               'Evaluator failed'->msg.append;
                               'Evaluator failed'->putinfo;
                               
                            #)
                       #)->evalobjadr;
                   debuggee.processComm.Wait2
                     (#
                        wrongMessage:: 
                          (# 
                          do
                             'Evaluator failed'->msg.append;
                             'Evaluator failed'->putinfo;
                             
                          #);
                        
                     #);
                   'Evaluator completed'->putinfo;
                   showStopCause;
                   debuggee.currentRemoteCode->impi[];
                   (if impi[] <> none then
                       impi.cast[]
                         ->newcodemoveable
                           (#
                              openIfNotFound:: 
                                (# 
                                do
                                   alwaysCurCode-> (*FGC, gui.*) getOption
                                     ->value;
                                   
                                #);
                              wriggleIfFound:: 
                                (# 
                                do
                                   (found[] <> lastEditor[])->value;
                                   found.bringToFront;
                                   
                                #);
                              
                           #);
                       
                    else
                       (if alwaysCurCode->getOption then debuggeeCurCode;  if)
                   if)
                #);
              (if 'DebugDynamic'->getOption then
                  'executeObjectInDebuggee Succeed'->putLine
              if)
          if)
       #)
  #)  

-- debuggeeCurObj: DoPart --
do
   InitCodeEditor;
   (if curObjStatus then
       (debuggee.currentRemoteBetaObject,FALSE)
         -> (*FGC, gui.*) main.OpenMoveableObjectView
           (#
              moveableObjectViewType:: (*FGC, gui.*)
               main.moveableObjectViewEvaluator
                (#
                   TheEvaluateAction: @ (#  do onEvaluateButton #);
                   openEvaluatorMenuEntry::< 
                     (#  do valhallaPrefs.DynamicCompilation->value #);
                   openFindAttributeMenuEntry::< 
                     (#  do valhallaPrefs.DynamicCompilation->value #);
                   onCloseEvaluator:: 
                     (#  do none ->InitCodeEditor.currentCfe[] #);
                   close::  (#  do none ->InitCodeEditor.currentCfe[] #);
                   onEvaluateButton::< 
                     (# 
                     do
                        contents.evaluator.editor.contents.contents
                          ->evaluate
                            (#
                               ErrorDuringCompilation:: 
                                 (# 
                                 do (owner[],msg[],title[])->gui.alertUser
                                 #)
                            #)
                            (* FIXME: when a streamwindow is used, 
                             * instead open that window with the error 
                             * output 
                             *)
                     #);
                   onEvaluatorOpened:: 
                     (# 
                     do
                        cfe[]->InitCodeEditor.currentCfe[];
                        TheEvaluateAction[]->InitCodeEditor.EvaluateAction[]
                     #);
                   onFindAttribute:: 
                     (#
                        eval: @evaluate
                          (#
                             ErrorDuringCompilation:: 
                               (# 
                               do
                                  (owner[],'Unable to find Attribute','Error')
                                    ->gui.alertUser
                               #)
                          #);
                        attributename: ^text;
                        evaluatortext: ^text;
                        offset,evalobjadr: @integer;
                        theNameApl: ^MPS.betacfl.nameApl;
                        theNameDcl: ^MPS.betacfl.nameDcl;
                        evalObject: ^debuggee.remoteBetaObject;
                        errorfound: @boolean;
                        
                     do
                        (main[],'Find Attribute','Attribute Name:','')
                          ->gui.promptForText
                            (# ok::  (#  do usertext[]->attributename[] #)
                            #);
                        '('->evaluatortext[];
                        '# evaluatorSaveInt:external(# i:@integer\n  enter i \n#)\ndo @@'
                          ->evaluatortext.append;
                        attributename[]->evaluatortext.append;
                        '->evaluatorSaveInt;\n #'->evaluatortext.append;
                        ')'->evaluatortext.append;
                        evaluatortext.reset;
                        evaluatortext[]->eval;
                        - 1->offset;
                        108
                          ->eval.theDoPart.suffixwalkforprod
                            (# 
                            do
                               current[]->thenameapl[];
                               thenameapl.dclRef->thenamedcl[];
                               (if thenameapl.gettext->attributename.equalncs
                                then
                                   (if thenamedcl[] <> none then
                                       thenamedcl.off->offset; 
                                   if);
                                   
                               if);
                               eval.evalobjadr-offset->evalobjadr;
                               (* point to surrounding object *)
                               ;
                               
                            #);
                        (if (offset <> - 1) and (evalobjadr <> 0) then
                            evalobjadr->debuggee.newRemoteObject->evalObject[];
                            (if evalObject[] <> none then
                                evalObject[]->newObjectMoveable
                            if)
                        if);
                        
                     #);
                   onOpenCodeView:: 
                     (# edenv: ^main.editorEnv; labeltext: @text; 
                     do (*FGC, gui.*)
                        sources.edenv[]->edenv[];
                        (cast.frag[],cast.frag.root[],cast[],scv.contents[],
                         (sources.id,cast.frag.father,true)
                           ->edenv.findOrCreateGroupEditor)
                          ->edenv.findOrCreateFormEditor;
                        'Objectcode:'->labeltext.append;
                        cast.frag.name->labeltext.append;
                        labeltext[]->scv.label;
                        cast[]->scv.contents.select
                     #);
                   contentsType::< 
                     (#
                        evaluatorType::< 
                          (#
                             editorType:: 
                               (#
                                  onClick:: 
                                    (# 
                                    do
                                       editor.sifviewer[]
                                         ->InitCodeEditor.currentCfe[];
                                       TheEvaluateAction[]
                                         ->InitCodeEditor.EvaluateAction[]
                                    #)
                               #);
                             open::< 
                               (#
                                  stderr: @errorscreen;
                                  T: @styledText;
                                  track: @trackMouse;
                                  cursorPos: @integer;
                                  FG: ^MPS.AST.fragmentGroup;
                                  FF: ^MPS.ast.fragmentform;
                                  anOD: ^MPS.BETACFL.objectDescriptor;
                                  anMP: ^MPS.BETACFL.mainPart;
                                  anAP: ^MPS.BETACFL.actionpart;
                                  anIMPS: ^MPS.BETACFL.Imperatives;
                                  anImpOpt: ^astInterface.unexpanded;
                                  anDP: ^MPS.BETACFL.dopart;
                                  cast: ^astInterface.ast;
                                  exp: ^astInterface.expanded;
                                  ge: ^object;
                                  (* groupeditor *)
                                  
                               do
                                  (editor[],constructUniqueID,false)
                                    ->sources.edenv.newBetaLibrary->fg[];
                                  (sources.Id,fg[],true)
                                    ->sources.edenv.findOrCreateGroupEditor
                                    ->ge[];
                                  fg.scan
                                    (#  do current[]->ff[] #);
                                  ff.root[]->exp[];
                                  mps.BETA.ObjectDescriptor
                                    ->exp.suffixWalkForProd
                                      (#  do current[]->anOD[] #);
                                  (mps.BETA.Prefix,ff[])
                                    ->mps.BetaCFL.newOptional
                                    ->anOD.putPrefixOpt;
                                  (*remove attributes decl opt. *)
                                  anOD.getMainpart->anMP[];
                                  (mps.BETA.Attributes,ff[])
                                    ->mps.betacfl.newOptional
                                    ->anMp.putAttributes;
                                  (* remove enter/exit and insert dopart *)
                                  anMP.getActionpart->anAP[];
                                  (mps.BETA.EnterPart,ff[])
                                    ->mps.BetaCfl.newOptional
                                    ->anAP.putEnterPartOpt;
                                  (mps.BETA.doPart,ff[])->mps.BetaCfl.newAst
                                    ->anDP[]->anAP.putDopartOpt;
                                  (mps.BETA.Imperatives,ff[])
                                    ->mps.BetaCfl.newAst->anIMPS[]
                                    ->anDP.putImperatives;
                                  (mps.BETA.ImpOpt,ff[])
                                    ->mps.betacfl.newUnexpanded->anImpOpt[]
                                    ->anImps.append;
                                  mps.BETA.ImpOpt->anImpOpt.nonTerminalSymbol;
                                  (mps.BETA.ExitPart,ff[])
                                    ->mps.BetaCfl.newOptional
                                    ->anAP.putExitPartOpt;
                                  (ff[],anMP[],anImpOpt[],editor[],ge[])
                                    ->sources.edenv.findOrCreateFormEditor
                               #)
                          #);
                        open::< 
                          (# 
                          do
                             (if false and valhallaPrefs.showEvaluator then
                                 movMenu.open; showEvaluatorAction
                             if)
                          #)
                     #)
                #);
              getFather:: 
                (#  do (*FGC, gui.*) main.objworld[]->father[] #)
           do (if theObjectView[]<>none then theObjectView.movMenu.open; theObjectView.showEvaluatorAction if)
           #)
   if);
     

