ORIGIN '../valhallaapplication';
INCLUDE '~beta/compiler/GENERATOR/disass' 
'~beta/editor/codeeditor'
'processinterfacebody' '~beta/sysutils/errorscreen';
LIB_ITEM 'valhalla';
-- ValhallaInitCompiler: Descriptor --
(# initialised,error: @boolean; exename: ^text; tmp: ^text; 
do
   'Compiling Evaluator ...'->putpinfo;
   (if not initialised then
       (if false then (* do not want unconditional tracing *)
           (if valhallaprefs.dynamiccompilation then
               (* FIXME: when mjolner starts using a streamwindow, 
                * replace the screen[] below with that log window 
                *)
               screen[]->DC.NT.traceStream[]; screen[]->DC.NT.infoStream[]; 
           if);
           
       if);
       dc.initDyn;
       (getEXECNAMEparam,true)
         ->DC.NT.init
       (#
          ExternalLookup:: 
            (#  do t[]->debuggee.processComm.Lookup_Address->i #);
          
       #);
       'Initializing Dynamic Compiler ['->tmp[];
       DC.compilerversion->tmp.puttext;
       '] ...'->tmp.puttext;
       tmp[]->putinfo;
       getEXECNAMEparam->exename[];
       exefileextension->exename.stripextension;
       (exename[],none ,none )->dc.activateCompiler->error;
       (if error then
           'Initialisation of dynamic compiler failed'->putinfo;
           'Initialisation of dynamic compiler failed'->debuggee.othererror;
           
        else
           'Dynamic compiler initialized.'->putinfo
       if);
       (if 'DebugDynamic'->getOption then
           'Getting process offset ...'->DC.NT.tracestream.puttext; 
       if);
       debuggee.processComm.get_main_physical-('main'->DC.NT.lookupC)
         ->DC.NT.logical2physical_offset;
       (if 'DebugDynamic'->getOption then
           'Done: is '->DC.NT.tracestream.puttext;
           DC.NT.logical2physical_offset->DC.NT.tracestream.putint;
           DC.NT.tracestream.newline;
           
       if);
       true->initialised
   if);
  
#)  

-- ValhallaInitCodeEditor:dopart --
(* setup edit menu *)
do (if first then 
    else
       &vcem[]->cem[];
       cem.open;
       cem[]->main.mainmenubar.append;
       true->first
   if)
   
--valhallalib:attributes--
constructUniqueID:
  (#
     T: @Text;
     timeSec,timeMiliSec: @integer;
     timeInMiliSec: @real
  do
     preciseTime->(timeSec,timeMiliSec);
     timeSec->timeInMiliSec;
     timeInMiliSec*1000000->timeInMiliSec;
     timeInMiliSec+timeMiliSec->timeInMiliSec;
     timeInMiliSec->t.putReal (#  do 0->precision #)
  exit t.copy
  #);
Evaluate:
  (#
     originFGname,evaluatorCode,dynamicFGname: ^text;
     aRemoteBetaObject: ^debuggee.remoteBetaObject;
     FF: ^MPS.AST.fragmentForm;
     FG,originFG: ^MPS.AST.fragmentGroup;
     im: ^imagePair;
     error: @boolean;
     evalobjadr:@integer;     
     aPTI: ^debuggee.prototypeInfo;
     anOD: ^MPS.BETACFL.objectDescriptor;
     anIndex: @MPS.AST.index;
     dataAreaStart,codeAreaStart: @integer;
     allocateMemory:
       (#
          allocationFailed:< exception (#  do INNER #);
          IMG: ^IM.loadableImage;
          anImage: ^image;
          numBytes,allocatedAreaStart: @integer;
          tmp: ^text;
          
       enter IMG[]
       do
          IMG.im[]->anImage[];
          (if trace then
              'LIP: '->puttext; anImage.LIP->puthex; 
          if);
          (if IMG.isCode then
              anImage.LIP->numBytes
           else
              (if trace then
                  ' GOTnoOfBytes: '->puttext;
                  IM.GOTnoOfBytes->puthex;
                  
              if);
              anImage.LIP+IM.GOTnoOfBytes->numBytes
          if);
          (if trace then newline if);
          (if anImage.buffer_ptr <> 0 then
              'Normal externally allocated data buffer'
                ->tmp[];
              'Buffer size: %i\n'
                ->tmp.putFormat
              (#  do anImage.buffer_size->i #);
              'Still needs to be implemented'->tmp.putLine;
              tmp[]->putinfo;
              tmp[]->debuggee.othererror;
              
           else
              numBytes
                ->
              debuggee.processComm.processData.
              allocateMemory->allocatedAreaStart;
              (if allocatedAreaStart = 0 then
                  allocationFailed
              if)
          if)
       exit allocatedAreaStart
       #);
     protoAddress,objectAddress: @integer;
     trace: @boolean;
     dumpCode:
       (# DA: @disass; 
       do
          '\nDYNAMIC CODE SEGMENT:'->putline;
          (if DA.hasDisass then
              (for i: IM.xCode.IM.LIP div 4 repeat
                   codeAreaStart+(i-1)*4->puthex;
                   ':'->put;
                   '\t'->put;
                   codeAreaStart+(i-1)*4
                     ->debuggee.processComm.processData.peeklong
                   (#
                      accessFailure:: 
                        (# 
                        do
                           'Reading code adr failed'
                             ->msg.append
                        #)
                   #)->DA->screen.putline;
                   
              for)
           else
              (codeAreaStart,IM.xCode.IM.LIP div 4)
                ->dumpMemoryArea;
              
          if);
          
       #);
     dumpMemoryArea:
       (#
          address,length: @integer;
          memoryContents: @integer;
          adr,con: @text
       enter (address,length)
       do
          'Address\t\tContents'->putLine;
          (for g: length repeat
               address+(g-1)*4
                 ->adr.putHex
               (#
                  format::< 
                    (# 
                    do true->zeroPadding; true->uppercase
                    #)
               #);
               '0x'->adr.prepend;
               address+(g-1)*4
                 ->debuggee.processComm.processData.peekLong
                 ->con.putHex
               (#
                  format::< 
                    (# 
                    do true->zeroPadding; true->uppercase
                    #)
               #);
               '0x'->con.prepend;
               '%s\t%s\n'
                 ->putFormat (#  do adr[]->s; con[]->s #);
               adr.clear;
               con.clear
          for)
       #);
     originObjectAddress,dynamicProtoAddress,
     originObjectProtoAddress: @integer;
     nameOfDynamicPattern: @text;
     a: ^MPS.AST.ast;
     theCexternalEntry: ^MPS.BETACFL.ObjectDenotation;
     theAttributes: ^MPS.BETACFL.attributes;
     theObjectDescriptor: ^MPS.BETACFL.objectDescriptor;
     thePatternDecl: ^MPS.BETACFL.patternDecl;
     theMainPart: ^MPS.BETACFL.mainPart;
     theActionPart: ^MPS.BETACFL.actionPart;
     theDoPart: ^MPS.BETACFL.doPart;
     theImperatives: ^MPS.BETACFL.imperatives;
     errorDuringCompilation:<
       (# owner:^gui.window;
          msg,title:^text;
       enter (owner[],msg[],title[])
       do inner 
       #);
  enter evaluatorCode[]
  do
     compilationAndLinking:
       (#
       do
          initCompiler;
          debuggee.currentRemoteBetaObject
            ->aRemoteBetaObject[];
          aRemoteBetaObject.protoAdr
            ->debuggee.utilities.protoAddressToPrototypeInfo
            ->aPTI[];
          aPTI.ofi.groupName[]->originFGname[];
          originFGname[]->MPS.BETACFL.openBETAfragmentGroup
            ->originFG[];
          aPTI.objdesc[]->anOD[];
          (anOD.index,anOD.frag[])->anIndex;
          'dynamicPattern'->nameOfDynamicPattern.append;
          dynamicCodeCounter->nameOfDynamicPattern.putInt;
          ': external '->evaluatorCode.prepend;
          nameOfDynamicPattern[]->evaluatorCode.prepend;
          'dynamicCode'->MPS.BETACFL.makeBETAfragmentForm
            ->FF[];
          (MPS.BETACFL.ObjectDenotation,'cExternalEntry',
          FF[])->MPS.BETACFL.parseText->theCexternalEntry[];
          (MPS.BETA.attributes,evaluatorCode[],FF[])
            ->MPS.BETACFL.parseText
          (#
             parseError::< 
               (# 
               do 'Parse errors in evaluator' -> putinfo;
                  (main[],'Parse errors',
                  'Compilation Errors')
                    ->errorDuringCompilation;
                  leave compilationAndLinking
               #)
          #)->theAttributes[];
          theAttributes.getSon1->thePatternDecl[];
          thePatternDecl.getObjectdescriptor
            ->theObjectDescriptor[];
          theObjectDescriptor.getMainPart->theMainPart[];
          theMainPart.getActionPart->theActionPart[];
          theActionPart.getDoPartOpt->a[];
          (if a## = MPS.BETACFL.doPart## then
              a[]->theDoPart[]
           else
              leave compilationAndLinking
          if);
          theDoPart.getImperatives->a[];
          (if a## = MPS.BETACFL.imperatives## then
              a[]->theImperatives[];
              (1,theCexternalEntry[])->theImperatives.insert
           else
              (MPS.BETACFL.Imperatives,'cExternalEntry',FF[])
                ->MPS.BETACFL.parseText->theImperatives[];
              theImperatives[]->theDoPart.putImperatives
          if);
          theAttributes[]->FF.root[];
          constructUniqueID->dynamicFGname[];
          dynamicFGname[]->MPS.BETACFL.openBETAfragmentGroup
            ->FG[];
          FF.name->FG.fragmentList.deleteLocalName;
          FF[]->FG.fragmentList.addFragment;
          (if (FG.prop[] <> none ) then
              'ORIGIN'
                ->FG.prop.addProp
              (#  do originFGname[]->addString #);
              'doneCheck'
                ->FG.prop.addProp (#  do 0->addConst #);
              
           else
              (main[],'No properties','Unrecoverable error')
                ->errorDuringCompilation;
              leave compilationAndLinking
          if);
          FG.markAsChanged;
          (FG.name,anIndex[],originFG[])
            ->dc.activateCompiler
          (#
             Report::< 
               (# 
               do 'Compilation errors in evaluator' -> putinfo;
                  (main[],'Compilation Error',msg[])
                    ->errorDuringCompilation;
                  leave compilationAndLinking
               #);
             semanticErrorsNotification::< 
               (#  do true->error #)
          #)->error;
          (if not error then
              true->dc.getImagePair->IM[];
              (if false then
                  dc.imageList.scan (#  #)
              if);
              (if 'DebugDynamic'->getOption then
                  true->trace;
                  true->IM.trace;
                  newLine;
                  newLine;
                  'ALLOCATION:'->putLine
              if);
              (* Collect external symbols for building possible
               * Global Offset Table (GOT) in data segment.
               * This is currently only needed for SGI
               *)
              DC.NT[]->IM.xCollectExternals;
              allocation:
                (# 
                do
                   IM.xData[]
                     ->allocateMemory
                   (#
                      allocationFailed::< 
                        (# 
                        do
                           'data: Allocation failed'
                             ->msg.append
                        #)
                   #)->dataAreaStart;
                   IM.xCode[]
                     ->allocateMemory
                   (#
                      allocationFailed::< 
                        (# 
                        do
                           'code: Allocation failed'
                             ->msg.append
                        #)
                   #)->codeAreaStart
                #);
              (if 'DebugDynamic'->getOption then
                  'Allocation Succeed'->putLine;
                  'Datasegment buffer: %s\tCode-segment buffer: %s\n\n'
                    ->putFormat
                  (# st: @text
                  do
                     dataAreaStart
                       ->st.putHex
                     (#
                        format::< 
                          (# 
                          do
                             true->zeroPadding;
                             true->uppercase
                          #)
                     #);
                     '0x'->st.prepend;
                     st[]->s;
                     st.clear;
                     codeAreaStart
                       ->st.putHex
                     (#
                        format::< 
                          (# 
                          do
                             true->zeroPadding;
                             true->uppercase
                          #)
                     #);
                     '0x'->st.prepend;
                     st[]->s
                  #);
                  newLine;
                  newLine;
                  'RELOCATION:'->putLine
              if);
              relocation:
                (# 
                do
                   (dataAreaStart,codeAreaStart)
                     ->IM.xAllocImage;
                   dc.NT[]->IM.xCollectEntries;
                   dc.NT[]->IM.xRelocate
                #);
              (if 'DebugDynamic'->getOption then
                  'Relocation Succeed'->putLine;
                  newLine;
                  newLine;
                  'WRITING RELOCATED SEGMENTS TO DEBUGGEE:'
                    ->putLine
              if);
              writeToDebuggee:
                (# 
                do
                   IM.xTransferImage
                   (# 
                   do
                      (outProcessAdr,item)
                        ->
                      debuggee.processComm.processData.
                      pokeLong
                      (#
                         accessFailure::< 
                           (# 
                           do
                              'writeToDebuggee: Failed to move segments'
                                ->msg.append
                           #)
                      #)
                   #)
                #);
              (if 'DebugDynamic'->getOption then
                  'writeToDebuggee Succeed'->putLine;
                  newLine;
                  newLine;
                  'ADDING GROUP TO DEBUGGEE'->putLine
              if);
              addingGroup:
                (# new: ^processInterface.ObjectFileInfo; 
                do
                   IM.dataStart
                     ->
                   debuggee.processComm.processData.
                   addGroup
                   (#
                      accessFailure::< 
                        (# 
                        do 'AddGroup failed'->msg.append
                        #);
                      
                   do
                      &debuggee.ObjectFileInfo[]->new[];
                      groupName[]->new.groupName[];
                      dataStart->new.dataStart;
                      dataEnd->new.dataEnd;
                      codeStart->new.codeStart;
                      codeEnd->new.codeEnd;
                      groupNameHash->new.groupNameHash;
                      checkTime->new.checkTime;
                      LL_INITIAL->new.loadLevel;
                      new[]
                        ->
                      debuggee.piPrivate.
                      ObjectFileInfos.insert;
                      
                   #);
                   
                #);
              (if 'DebugDynamic'->getOption then
                  'addingGroup Succeed'->putLine;
                  'Adding header located at: %s\n\n'
                    ->putFormat
                  (# st: @text
                  do
                     IM.dataStart
                       ->st.putHex
                     (#
                        format::< 
                          (# 
                          do
                             true->zeroPadding;
                             true->uppercase
                          #)
                     #);
                     '0x'->st.prepend;
                     st[]->s
                  #);
                  newLine;
                  newLine;
                  
              if);
              calculateOrigin:
                (# 
                do
                   (if aRemoteBetaObject.isComp then
                       aRemoteBetaObject.getAddress+24
                         ->objectAddress
                    else
                       aRemoteBetaObject.getAddress
                         ->objectAddress
                   if);
                   
                #);
              calculateProto:
                (# 
                do (1->IM.indexedOff)->protoAddress; 
                #);
              executeObjectInDebuggee:
                (# tmp: @text;
                   impi: ^processInterface.ImperativeInfo;
                do 'Waiting for evaluator ...' -> putinfo;
                   'Executing evaluator ...' -> putpinfo;
                   (objectAddress,protoAddress) ->
                   debuggee.processComm.processData.executeObject
                   (# accessFailure::< 
                        (# 
                        do 'Evaluator failed' ->msg.append;
                           'Evaluator failed' ->putinfo;
                        #)
                   #)->evalobjadr;
                   debuggee.processComm.Wait2
                   (#
                      wrongMessage:: 
                        (# 
                        do 'Evaluator failed' ->msg.append;
                           'Evaluator failed' ->putinfo;
                        #);
                      
                   #);
                   'Evaluator completed' -> putinfo;
                   showStopCause;
                   debuggee.currentRemoteCode->impi[];
                   (if impi[] <> none then
                       impi.cast[] ->newcodemoveable
                       (#
                          openIfNotFound:: 
                            (# 
                            do alwaysCurCode
                                 -> (*FGC, gui.*)
                               getOption->value;
                               
                            #);
                          wriggleIfFound:: 
                            (# 
                            do (found[] <> lastEditor[])
                                 ->value;
                               found.bringToFront;
                               
                            #);
                       #);
                    else
                       (if alwaysCurCode -> getOption then
                           debuggeeCurCode; 
                       if);
                   if);
                #);
              (if 'DebugDynamic'->getOption then
                  'executeObjectInDebuggee Succeed'->putLine;
              if)
          if);
       #);
  #) 
   
-- debuggeeCurObj: DoPart --
do InitCodeEditor;
   (if curObjStatus then
       (debuggee.currentRemoteBetaObject,FALSE)
         -> (*FGC, gui.*) main.OpenMoveableObjectView
       (#
          moveableObjectViewType:: (*FGC, gui.*)
            main.moveableObjectViewEvaluator
          (#
             openEvaluatorMenuEntry::< 
               (#  do valhallaPrefs.DynamicCompilation->value #);
             openFindAttributeMenuEntry::< 
               (#  do valhallaPrefs.DynamicCompilation->value #);
             onEvaluateButton::<
               (#
               do contents.evaluator.editor.contents.contents->evaluate
                  (# ErrorDuringCompilation::(# do (owner[],msg[],title[])->gui.alertUser#) #)
                      (* FIXME: when a streamwindow is used, 
                       * instead open that window with the error 
                       * output 
                       *)
               #); 
             onEvaluatorOpened::
               (# do cfe[]->InitCodeEditor.currentCfe[]
               #);
              onFindAttribute::
               (# eval:@evaluate 
                    (# ErrorDuringCompilation::(# do (owner[],'Unable to find Attribute','Error')->gui.alertUser #)
                    #);
                  attributename:^text;
                  evaluatortext:^text;
                  offset,evalobjadr:@integer;
                  theNameApl:^MPS.betacfl.nameApl;
                  theNameDcl:^MPS.betacfl.nameDcl;
                  evalObject:^debuggee.remoteBetaObject;
                  errorfound:@boolean;
               do (main[],'Find Attribute','Attribute Name:','')
                    ->gui.promptForText(# ok::(# do usertext[]->attributename[] #) #);
                  '('->evaluatortext[];
                  '# evaluatorSaveInt:external(# i:@integer\n  enter i \n#)\ndo @@'->evaluatortext.append;
                  attributename[]->evaluatortext.append;
                  '->evaluatorSaveInt;\n #'->evaluatortext.append; ')'->evaluatortext.append;
                  evaluatortext.reset; 
                  evaluatortext[]->eval;
                  -1->offset;
                  108->eval.theDoPart.suffixwalkforprod
                  (# 
                  do
                     current[]->thenameapl[];
                     thenameapl.dclRef->thenamedcl[];
                     (if thenameapl.gettext->attributename.equalncs then
                         (if thenamedcl[]<>none then
                             thenamedcl.off->offset;                             
                         if);
                     if);
                     eval.evalobjadr-offset->evalobjadr; (* point to surrounding object *);
                  #);
                  (if (offset<>-1) and (evalobjadr<>0) then
                      evalobjadr->debuggee.newRemoteObject->evalObject[];
                      (if evalObject[]<>none then evalObject[]->newObjectMoveable if)
                  if);
               #);
             onOpenCodeView::
               (# edenv: ^main.editorEnv;
                  labeltext:@text;
               do (*FGC, gui.*)
                  sources.edenv[]->edenv[];
                  (cast.frag[],cast.frag.root[],cast[],scv.contents[],
                  (sources.id,cast.frag.father,true)->edenv.findOrCreateGroupEditor)
                    ->edenv.findOrCreateFormEditor;
                  'Objectcode:'->labeltext.append;
                  cast.frag.name->labeltext.append;
                  labeltext[]->scv.label;
                   cast[]->scv.contents.select 
               #);
             contentsType::< 
               (#
                  evaluatorType::< 
                    (# 
                       open::< 
                         (# stderr:@errorscreen;
                            T: @styledText;
                            track: @trackMouse;
                            cursorPos: @integer;
                            FG: ^MPS.AST.fragmentGroup;
                            FF: ^MPS.ast.fragmentform;
                            anOD: ^MPS.BETACFL.objectDescriptor;
                            anMP: ^MPS.BETACFL.mainPart;
                            anAP: ^MPS.BETACFL.actionpart;
                            anIMPS: ^MPS.BETACFL.Imperatives;
                            anDP: ^MPS.BETACFL.dopart;
                            cast: ^astInterface.ast;
                            exp:^astInterface.expanded;
                            ge:^object; (* groupeditor *)
                         do 
                            (editor[],constructUniqueID,false)->sources.edenv.newBetaLibrary->fg[];
                            
                            (sources.Id,fg[],true)->sources.edenv.findOrCreateGroupEditor->ge[];
                            
                            fg.scan
                            (# 
                            do current[]->ff[]
                            #);
                            
                            ff.root[]->exp[];
                            4->exp.suffixWalkForProd 
                            (# do current[]->anOD[] #);
                            
                            (8,ff[])->mps.BetaCFL.newOptional->anOD.putPrefixOpt;
                            
                            anOD.getMainpart->anMP[];
                            (*remove attributes decl opt. *)
                            (6,ff[])->mps.betacfl.newOptional->anMp.putAttributes;
                            
                            anMP.getActionpart->anAP[];
                            (* remove enter/exit and insert dopart *)
                            (30,ff[])->mps.BetaCfl.newOptional->anAP.putEnterPartOpt;
                            
                            (* (31,ff[])->mps.BetaCfl.newAst->anDP[]->anAP.putDopartOpt; *)
                            (* 
                             * (33,ff[])->mps.BetaCfl.newAst->anIMPS[]->anDP.putImperatives;  
                             * (42,ff[])->mps.betacfl.newAst->anImps.append; 
                             *)
                            (32,ff[])->mps.BetaCfl.newOptional->anAP.putExitPartOpt; 
                             
                            
                            (ff[],anOD[],none,editor[],ge[])->sources.edenv.findOrCreateFormEditor
                             
                         #)
                    #)
               #)
          #);
          getFather:: 
            (#  do (*FGC, gui.*) main.objworld[]->father[] #)
       #)
   if);
   

