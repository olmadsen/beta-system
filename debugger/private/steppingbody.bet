ORIGIN '../stepping';
INCLUDE '~beta/basiclib/formatio'
        '~beta/toollibs/utils/mpsutils'
        '~beta/betaast/betasematt';
LIB_ITEM 'valhallastep';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-99
 *   All rights reserved.
 *)
(* Oct-Nov Flemming Gram completeted this. Several cases where missing (now?) *)
-- processInterfaceLib: Attributes --
printBreakpointPos:
  (# imp: ^imperativeInfo; prefix: ^text; 
  enter (prefix[],imp[])
  do
     prefix[]->screen.puttext;
     ' Breakpoint at astindex:%d, address+offset: 0x%x+0x%x=0x%x\n'
       ->screen.putformat
         (# 
         do
            imp.cast.index->d;
            imp.dpi.Mentry->x;
            imp.dpi.impAddresses[imp.inx]->x;
            imp.start->x
         #)
  #);
Debugputline:
  (# s: ^text enter s[] do (if debugStepBreak then s[]->putline if) #);
  

-- steppingIntoListLib: Attributes --
handleImperativesOpt: (* step-into *)
  (#
     a: ^MPS.AST.ast;
     imps: ^MPS.BETACFL.Imperatives;
     limpi: ^imperativeInfo;
     
  enter a[]
  do
     (if a.symbol <> MPS.AST.kinds.optional then
         a[]->imps[];
         getFirst: imps.newscan
           (# 
           do
              getCurrent:
              current[]
                ->utilities.codeAstToImperative
                  (# notfound::  (#  do leave getCurrent #) #)->limpi[];
              (if limpi[] <> none then
                  (if debugStepBreak then
                      ('30HandleIMPopt: ',limpi[])->printBreakpointPos
                  if);
                  (* find first imperative not placed at this point *)
                  (if pc <> limpi.start then
                      '53Leaving'->debugputline;
                      limpi[]->stepsetIMPs.append;
                      leave getFirst
                  if)
              if);
              
           #);
         
     if);
     
  #);
handleElsePartOpt: (* step-into *)
  (# a: ^MPS.AST.ast; ep: ^MPS.BETACFL.elsePart; 
  enter a[]
  do
     (if debugStepBreak then
         'handleElsePartOpt, index:%d\n'
           ->screen.putformat (#  do a.index->d #);
         
     if);
     (if a.kind <> MPS.AST.kinds.optional then
         (a[]->ep[]).getImperatives->handleImperativesOpt
     if)
  #);
handleINNER: (* step-into *)
(* This is  hairy: Locate the objectdescriptor of the 
 * current object, and use it together with the current dopart
 * to find out what dopart will receive control as a result of
 * INNER. *)
  (#
     im: ^MPS.BETACFL.InnerImp;
     od,dpod,subod,oriod: ^MPS.BETACFL.ObjectDescriptor;
     na: ^MPS.BETACFL.nameApl;
     a: ^MPS.AST.ast;
     bo,curbo: ^remoteBetaObject;
     limpi: ^ImperativeInfo;
     dpi: ^dopartInfo;
     
  enter im[]
  do
     intoINNER:
       (# 
       do
          currentRemoteBetaObject->curbo[];
          (if curbo.isNone then
              (if not ('Current Object was NONE'->stepfailure) then
                  cancelled; 
              if);
              
          if);
          (if curbo.isDopartObject then
              dopartObjectOriOff->curbo.ReferenceAttr->bo[]; 
           else
              curbo[]->bo[]; 
          if);
          (* bo is the current "real" BETA object. *)
          (if (im.getNameAplOpt->a[]).kind = MPS.AST.kinds.optional then
          (* "Easy" case. Find the objectDescriptor corresponding to the
           * current dopart. *)
              getimpi:
              im[]
                ->utilities.codeAstToImperative
                  (# notfound::  (#  do leave getimpi #) #)->limpi[];
              (if limpi[] = none then onFailure; leave intoINNER if);
              (limpi.dpi.ptinx-1,limpi.dpi.odofi.groupName[])
                ->groupsInfo.protoGroupToOD->dpod[];
              (if dpod[] = none then onFailure; leave intoINNER if);
              
           else
              a[]->na[];
              na[]->getObjectDesc->oriod[];
              (* was na.descRef->oriod[]; *)
              (if oriod[] = none then
                  (if not ('intoINNER(1): na.descRef failed'->stepfailure) then
                      cancelled; 
                  if);
                  leave intoINNER;
                  
              if);
              (* Find relevant origin object: *)
              im[]->a[];
              findOriObject:
                (# 
                do
                   (a[],MPS.BETA.ObjectDescriptor)
                     ->MPS.getEnclosingAST
                       (# followFragments:: TrueObject #)->dpod[];
                   (if dpod[] = none then
                       (if not
                       ('intoINNER(2): MPS.getEnclosingAST failed'->stepfailure)
                        then
                           cancelled; 
                       if);
                       leave intoINNER;
                       
                   if);
                   (if (dpod.kind->tos'%getBits[13,1]') then
                   (* dpod is an inserted item of the inlined kind.
                    * No instances of this one. Continue to next encloser. *)
                       dpod[]->a[]; restart findOriObject; 
                   if);
                   (* dpod is the first non-inlined objectDescriptor enclosing the
                    * INNER imperative. oriod is the descriptor referred to by the 
                    * NameApl part of the INNER imperative. Hopefully bo is an 
                    * instance of dpod or some subpattern ... *)
                   (if not (dpod[]->oriod.equal) then
                   (* Take one more step out. *)
                       dpod.originOff->bo.ReferenceAttr->bo[];
                       dpod.father->a[];
                       restart findOriObject;
                       
                   if);
                   
                #);
              (* dpod is objectDescriptor whose corresponding INNER we are trying to
               * locate. bo[] is an instance of dpod or some subpattern. *)
              
          if);
          bo[]->bo.dumper.betaObjectObjectDescriptor->od[];
          (if od[] = none then onFailure; leave intoINNER if);
          (if dpod[]->od.equal then
          (* No INNER. We are already in the most significant
           * descriptor. *)
              
           else
              od[]->subod[];
              getNextDopart: od.scanPrefix
                (# 
                do
                   (if thisObjectDescription[]->dpod.equal then
                       leave getNextDopart; 
                    else
                       thisObjectDescription[]->subod[]
                   if);
                   
                #);
              (if subod[] = none then
                  (if not ('UNEXPECTED: Next Dopart not found'->stepfailure)
                   then
                      cancelled; leave intoINNER; 
                  if)
              if);
              (* Ok. Add the first imperative of subod to stepsetIMPs. *)
              subod[]
                ->utilities.ObjectDescriptorToDopart
                  (#
                     noDoPart:: 
                       (# 
                       do (* No dopart in specialization *) leave intoINNER; 
                       #);
                     notfound:: 
                       (# 
                       do
                          (if not
                          ('UNEXPECTED: Next Dopart not found'->stepfailure)
                           then
                              cancelled; leave intoINNER; 
                          if)
                       #);
                     onPartialMinfo:: 
                       (# 
                       do (* Cannot find first imperative. Use Mentry. *)
                          (if debugStepBreak then
                              '196handleINNER appending address:%d\n'
                                ->screen.putformat
                                  (#  do ofi.Mentries[ptinx]->d #)
                          if);
                          ofi.Mentries[ptinx]->stepsetADRs.append;
                          leave intoINNER;
                          
                       #);
                     
                  #)->dpi[];
              dpi.dp.getImperatives->handleImperativesOpt
          if)
       #)
  #);
handleEvaluation: (* step-into *)
(* Some kind of evaluation. All we can do now is a suffix walk
 * looking for the following situations:
 * 
 *   1. For name applications denoting patterns whose topmost prefix
 *      (not counting object) has a dopart, set a breakpoint at the
 *      first imperative in the topmost dopart. If only the Object
 *      qualification is currently known, set a breakpoint at the
 *      first imperative of the Object pattern. If no debug info on
 *      that imperative was found, set a breakpoint directly at the
 *      corresponding M entry point.
 * 
 *   2. For mainparts, set a breakpoint at the first imperative of
 *      the dopart. Possible prefixes should have been handled by
 *      rule 1. The suffix walk may backtrack when attributes or
 *      actionParts are met.
 * 
 *   3. For name applications denoting externals, a callback from
 *      CBFA to the debugger makes sure that if external code is
 *      called, a possible callback is caught.
 * 
 *   4. In principle, allocation of BETA objects may execute code
 *      computing the sizes of repetitions. Currently there seems to
 *      be no way to catch this. If that happens, we are out of
 *      luck. One way to handle this is a callback to the debugger
 *      in the G code executing ordinary BETA code. Probably this
 *      case is pretty seldom.
 * 
 *   5. Evallists Break at every evaluation. Not very used, but (d,d)->(putint,putint) occours. 
 * 
 *  On step into, AttachCallback is enabled. Thus, the RTS tells the
 *  debugger when a component is attached or re-attached. If that
 *  happens, and a pending step-into is active, it should either be
 *  extended with an extra breakpoint at the into-attach-imperative
 *  (if a stepinto proper), and/or reset the pending breakpoint and
 *  then clear itself (if stepinto to handle pending breakpoint.)
 *)
  (# exp: ^MPS.AST.expanded; 
  enter exp[]
  do (* Case 2: *)
     (if debugStepBreak then
         'HandleEvaluation-into on ast:%d, symbol:%d\n'
           ->putformat (#  do exp.index->d; exp.symbol->d #)
     if);
     MPS.BETA.ObjectDescriptor
       ->exp.suffixWalkForProd
         (#
            cutIf:: 
              (# 
              do
              (* No need to go through mainparts, cf. case 2 above.
               * Furthermore, below structure references and a number of 
               * other syntactic categories we won't find anything 
               * interesting. *)
                 (if prod
                  // MPS.BETA.Mainpart // MPS.BETA.structureReference
                  // MPS.BETA.RemotePrimitive // MPS.BETA.Primitive
                  // MPS.BETA.address // MPS.BETA.ObjectReference then
                     TRUE->toCut; 
                 if);
                 
              #);
            scanCat:: MPS.BETACFL.ObjectDescriptor;
            dpi: ^dopartInfo;
            mp: ^MPS.BETACFL.MainPart;
            ap: ^MPS.BETACFL.ActionPart;
            dp: ^MPS.BETACFL.DoPart;
            
         do
            getDoPart:
              (# 
              do
                 ' 286 '->debugputline;
                 current[]
                   ->utilities.ObjectDescriptorToDopart
                     (#
                        noDoPart:: 
                          (#  do ' 290 '->debugputline; leave getDoPart #);
                        notfound:: 
                          (#  do ' 292 '->debugputline; leave getDoPart #);
                        onPartialMinfo:: 
                          (# 
                          do (* Cannot find first imperative. Use Mentry. *)
                             (if debugStepBreak then
                                 '283handleeval appending address:%d\n'
                                   ->screen.putformat
                                     (#  do ofi.Mentries[ptinx]->d #)
                             if);
                             ofi.Mentries[ptinx]->stepsetADRs.append;
                             leave getDoPart;
                             
                          #);
                        
                     #)->dpi[];
                 ' 305 '->debugputline;
                 (if dpi[] <> none then
                     dpi.dp.getImperatives->handleImperativesOpt; 
                  else
                 (* no dopart found !! *)
                 (* if inlined then there is no prototype, we can not use groupsinto or utilities *)
                     current.getMainPart->mp[];
                     mp.getActionPart->ap[];
                     (if ap[] = none then leave getDopart if);
                     ap.getDoPartOpt->dp[];
                     (if dp[] = none then leave getDopart if);
                     '316 Calling  handleImpOpt'->debugputline;
                     dp.getImperatives->handleImperativesOpt;
                     
                 if)
              #);
            
         #);
     (* Case 1 and 3 *)
     MPS.BETA.nameApl
       ->exp.suffixWalkForProd
         (#
            cutIf:: 
              (# 
              do
              (* No need to go through mainparts, cf. case 2 above.
               * Furthermore, below structure references and a number of 
               * other syntactic categories we won't find anything 
               * interesting. *)
                 (if prod
                  // MPS.BETA.MainPart // MPS.BETA.structureReference
                  // MPS.BETA.RemotePrimitive // MPS.BETA.Primitive
                  // MPS.BETA.address // MPS.BETA.ObjectReference then
                     TRUE->toCut
                 if);
                 
              #);
            scanCat:: MPS.BETACFL.NameApl;
            od,odpref: ^MPS.BETACFL.ObjectDescriptor;
            CprocKind: (#  exit 3 #);
            generalKind: (#  exit 4 #);
            dpi: ^dopartInfo;
            a: ^MPS.AST.ast;
            
         do
            (if debugStepBreak then
                '375 found nameapl index=%d symbol=%d\n'
                  ->putformat (#  do current.index->d; current.symbol->d #)
            if);
            current[]->getObjectDesc->a[];
            (* was: current.descRef->a[]; *)
            (if a[] = none then
                (if not ('intoINNER(3): current.descRef failed'->stepfailure)
                 then
                    cancelled; 
                if);
                
             else
                (if debugStepBreak then
                    'desc sym=%d, inx=%d\n'
                      ->putformat (#  do a.symbol->d; a.index->d #);
                    
                if);
                (* Get topmost prefix. *)
                (if a.symbol
                 // MPS.BETA.ObjectDescriptor then
                    a[]->od[]->odpref[];
                    od.scanPrefix
                      (#  do thisObjectDescription[]->odpref[] #);
                    handlePref:
                    (if (odpref.kind->tos'%getByte[0]')
                     // generalKind then
                     (* Ok. Add the first imperative of pref to stepsetIMPs. *)
                        odpref[]
                          ->utilities.ObjectDescriptorToDopart
                            (#
                               noDoPart::  (#  do leave handlePref #);
                               notfound::  (#  do leave handlePref #);
                               onPartialMinfo:: 
                                 (# 
                                 do
                                 (* Cannot find first imperative. Use Mentry. *)
                                    (if debugStepBreak then
                                        '353handleEVAL appending address:%d\n'
                                          ->screen.putformat
                                            (#  do ofi.Mentries[ptinx]->d #)
                                    if);
                                    ofi.Mentries[ptinx]->stepsetADRs.append;
                                    leave handlePref;
                                    
                                 #);
                               
                            #)->dpi[];
                        dpi.dp.getImperatives->handleImperativesOpt;
                        
                     // CprocKind then
                     (* Externals are handled by CBFA callback. *)
                        
                    if);
                    handleEnterPart:
                      (#
                         mp: ^MPS.BETACFL.MainPart;
                         ap: ^MPS.BETACFL.ActionPart;
                         ep: ^MPS.BETACFL.EnterPart;
                         temp: ^MPS.AST.ast;
                         exp2: ^MPS.AST.expanded;
                         
                      do
                         odPref.getMainPart->mp[];
                         mp.getActionPart->ap[];
                         (if ap[] = none then leave handleEnterPart if);
                         ap.getEnterPartOpt->temp[];
                         (if temp## = MPS.AST.optional## then
                             leave handleEnterPart
                         if);
                         temp[]->ep[];
                         (if ep[] = none then leave handleEnterPart if);
                         ep.son->temp[];
                         (if temp.symbol = MPS.BETA.insertedItem then
                             temp[]->exp2[];
                             MPS.BETA.ObjectDescriptor
                               ->exp2.suffixWalkForProd
                                 (#
                                    scanCat:: MPS.BETACFL.ObjectDescriptor;
                                    mp1: ^MPS.BETACFL.MainPart;
                                    ap1: ^MPS.BETACFL.ActionPart;
                                    dp1: ^MPS.BETACFL.DoPart;
                                    
                                 do
                                    getDoPart:
                                      (# optTemp: ^MPS.AST.ast; 
                                      do
                                         current.getMainPart->mp1[];
                                         mp1.getActionPart->ap1[];
                                         (if ap1[] = none then
                                             leave getDoPart
                                         if);
                                         ap1.getDoPartOpt->temp[];
                                         (if temp## = MPS.AST.optional## then
                                             leave getDoPart
                                         if);
                                         temp[]->dp1[];
                                         (if dp1[] = none then
                                             leave getDoPart
                                         if);
                                         dp1.getImperatives
                                           ->handleImperativesOpt;
                                         
                                      #)
                                 #);
                             
                         if);
                         
                      #);
                    handleExitPart:
                      (#
                         mp: ^MPS.BETACFL.MainPart;
                         ap: ^MPS.BETACFL.ActionPart;
                         ep: ^MPS.BETACFL.ExitPart;
                         temp: ^MPS.AST.ast;
                         exp2: ^MPS.AST.expanded;
                         
                      do
                         odPref.getMainPart->mp[];
                         mp.getActionPart->ap[];
                         (if ap[] = none then leave handleExitPart if);
                         ap.getExitPartOpt->temp[];
                         (if temp## = MPS.AST.optional## then
                             leave handleExitPart
                         if);
                         temp[]->ep[];
                         (if ep[] = none then leave handleExitPart if);
                         ep.son->temp[];
                         (if temp.symbol = MPS.BETA.insertedItem then
                             temp[]->exp2[];
                             MPS.BETA.ObjectDescriptor
                               ->exp2.suffixWalkForProd
                                 (#
                                    scanCat:: MPS.BETACFL.ObjectDescriptor;
                                    mp1: ^MPS.BETACFL.MainPart;
                                    ap1: ^MPS.BETACFL.ActionPart;
                                    dp1: ^MPS.BETACFL.DoPart;
                                    
                                 do
                                    getDoPart:
                                      (# 
                                      do
                                         current.getMainPart->mp1[];
                                         mp1.getActionPart->ap1[];
                                         (if ap1[] = none then
                                             leave getDoPart
                                         if);
                                         ap1.getDoPartOpt->dp1[];
                                         (if dp1[] = none then
                                             leave getDoPart
                                         if);
                                         dp1.getImperatives
                                           ->handleImperativesOpt;
                                         
                                      #)
                                 #);
                             
                         if);
                         
                      #);
                    
                 // MPS.AST.prodNo.unExpanded then
                    a[]->intoUnExp; 
                 else
                      (# od: ^mps.betacfl.objectdenotation
                      do
                      (*'current.descRef.symbol is not recognized'->stepfailure*)
                         '407unknown kind'->putline;
                         a.symbol->putint;
                         (a[],- 1)->doPrettyPrint->screen.putline;
                         exp.symbol->putint;
                         (exp[],- 1)->doPrettyPrint->screen.putline;
                         
                      #);
                    
                if);
                
            if);
            
         #);
     
  #);
onFailure:
  (# 
  do
     (if not ('Missing Debug Info. Cannot Step Into.'->stepfailure) then
         cancelled; 
     if);
     
  #);
intoUnExp: (* step-into *)
  (#
     unexp: ^MPS.AST.unexpanded;
     ofi: ^ObjectFileInfo;
     ff: ^MPS.AST.fragmentForm;
     dpi: ^dopartInfo;
     od: ^MPS.BETACFL.ObjectDescriptor;
     df: ^MPS.BETACFL.DescriptorForm;
     
  enter unexp[]
  do
     (if debugStepBreak then
         'HandleImp-intoUnExp on ast:%d, symbol:%d\n'
           ->putformat (#  do unexp.index->d; unexp.symbol->d #)
     if);
     intoUnExp:
       (# 
       do
          unexp.theSlot->utilities.SLOTtoFragment->(ff[],ofi[]);
          (if ofi[] = none then onFailure; leave intoUnExp if);
          (if ff.root.symbol
           // MPS.BETA.descriptorForm then
              ff.root[]->df[]; df.getObjectDescriptor->od[]; 
           // MPS.BETA.ObjectDescriptor then
              ff.root[]->od[]; 
           else
              (if not
              ('UNEXPECTED: Unexpanded imperative not a descriptor SLOT'
                 ->stepFailure) then
                  cancelled
              if);
              leave intoUnExp;
              
          if);
          od[]->handleEvaluation;
          (* od[]
           ->utilities.ObjectDescriptorToDopart
           (#
           nodopart::  (#  do leave intoUnExp #);
           notfound::  (#  do onFailure; leave intoUnExp #);
           onPartialMinfo:: 
           (# 
           do  (if debugStepBreak then
           '427intoUNEXP appending address:%d\n'->screen.putformat
           (# do ofi.Mentries[ptinx]->d#)
           if);
           ofi.Mentries[ptinx]->stepsetADRs.append; leave intoUnExp; 
           #)
           #)->dpi[];
           dpi.dp.getImperatives->handleImperativesOpt;
           *)
          
       #);
     
  #);
handleImp: (* step-into *)
  (# imp: ^MPS.AST.ast; 
  enter imp[]
  do
     (if debugStepBreak then
         'HandleImp-into on ast:%d, symbol:%d\n'
           ->putformat (#  do imp.index->d; imp.symbol->d #)
     if);
     (if imp.symbol
      // MPS.BETA.LabelledImp then
         intoLabelled:
           (#
              li: ^MPS.BETACFL.labelledImp;
              limpi: ^imperativeInfo;
              iimp: ^MPS.AST.ast;
              
           do
              imp[]->li[];
              li.getImp->iimp[]
                ->utilities.codeAstToImperative
                  (# notfound::  (#  do onFailure; leave intoLabelled #); 
                  #)->limpi[];
              (if limpi[] <> none then
                  (if debugStepBreak then
                      ('431HandleIMP, setbreak at ',limpi[])
                        ->printBreakpointPos;
                      (* limpi.cast.index->screen.putint;screen.putline *)
                      
                  if);
                  limpi[]->stepsetIMPs.append
               else
                  (if debugStepBreak then
                      '477 on ast:%d, symbol:%d\n'
                        ->screen.putformat
                          (#  do iimp.index->d; iimp.symbol->d #)
                  if)
              if);
              (* Setbreakpoints in inner imperatives *)
              iimp[]->handleImp;
              (* (if iimp.symbol then
               MPS.BETA.InsertedItem then
               iimp[]->handleImp 
               if)*)
              
           #);
         
      // MPS.BETA.ForImp then
         intoFor:
           (#
              fi: ^MPS.BETACFL.forImp;
              imps: ^MPS.BETACFL.Imperatives;
              limpi: ^imperativeInfo;
              first: ^MPS.AST.ast;
              
           do
              (if debugStepBreak then
                  '493HandleIMP, on forImp '->debugputline
              if);
              imp[]->fi[];
              getIndex:
              fi.getIndex
                ->utilities.codeAstToImperative
                  (# notfound::  (#  do leave getIndex #) #)->limpi[];
              (if limpi[] <> none then
                  (if debugStepBreak then
                      '452HandleIMP, setbreak at '->screen.puttext;
                      limpi.cast.index->screen.putint;
                      screen.putline
                  if);
                  limpi[]->stepsetIMPs.append
               else
                  (if debugStepBreak then
                      '505HandleIMP, no index found '->screen.putline; 
                  if)
              if);
              fi.getImperatives->handleImperativesOpt
           #);
         
      // MPS.BETA.SimpleIfImp then
         intoSimpleIf:
           (# si: ^MPS.BETACFL.simpleIfImp; 
           do
              imp[]->si[];
              (* Stepping into a simpleIf includes stepping into the
               * evaluation, since they share debug info. *)
              si.getEvaluation->handleImp;
              si.getImperatives->handleImperativesOpt;
              si.getElsePartOpt->handleElsePartOpt;
              
           #);
         
      // MPS.BETA.GeneralIfImp then
         intoGeneralIfImp:
           (# gi: ^MPS.BETACFL.generalIfImp; alt: ^MPS.BETACFL.alternatives; 
           do
              imp[]->gi[];
              gi.getEvaluation->handleImp;
              gi.getAlternatives->alt[];
              alt.newScan
                (# sels: ^MPS.BETACFL.selections; 
                do
                   current.getSelections->sels[];
                   sels.newScan
                     (#
                        csel: ^MPS.BETACFL.caseSelection;
                        limpi: ^imperativeInfo
                     do
                        current[]->csel[];
                        none ->limpi[];
                        getEval:
                        csel.getEvaluation
                          ->utilities.codeAstToImperative
                            (# notfound::  (#  do leave getEval #) #)->limpi[];
                        (if limpi[] <> none then
                            (if debugStepBreak then
                                '488HandleIMP, setbreak at '->screen.puttext;
                                limpi.cast.index->screen.putint;
                                screen.putline
                            if);
                            limpi[]->stepsetIMPs.append
                        if);
                        
                     #);
                   current.getImperatives->handleImperativesOpt;
                   
                #);
              gi.getElsePartOpt->handleElsePartOpt;
              
           #);
         
      // MPS.BETA.LeaveImp // MPS.BETA.RestartImp // MPS.BETA.CodeImp
      //
      MPS.BETA.Imperatives
      (* These cases are fully handled by overlist. 
       * It is assumed that a (code ... code) does not make any procedure
       * calls. Even if it did, it would be extremely impractical to check 
       * it. Anyway, nobody is using code imperatives these days. They 
       * don't work with binary code generators... :-) *)
      // MPS.BETA.SuspendImp then (* Handled by RTS attach callback. *)
         
      // MPS.BETA.InnerImp then
         imp[]->handleINNER; 
      // MPS.BETA.insertedItem then
      (* If this is an insertedItem containing a descriptor SLOT, handle this specially. 
       * Otherwise call handleEvaluation. *)
         handleInserted:
           (# a: ^MPS.AST.ast; ii: ^MPS.BETACFL.insertedItem; 
           do
              imp[]->ii[];
              ii.getObjectDescriptor->a[];
              (if a.symbol <> MPS.AST.prodNo.unexpanded then
                  imp[]->handleEvaluation; 
               else
                  a[]->intounexp
              if)
           #)
      else
         imp[]->handleEvaluation; 
     if);
     
  #);
getObjectDesc:
  (#
     na: ^MPS.BETACFL.NameApl;
     a: ^MPS.AST.ast;
     exp: ^MPS.AST.expanded;
     obs: ^MPS.BETACFL.ObjectSpecification
  enter na[]
  do
     loop:
       (# 
       do
          (if debugStepBreak then (na[],4)->doPrettyPrint->putline if);
          na.dclRef->a[];
          (* if the nameapl is inside a remoteprimitive:
           * <RemotePrimitive> ::= <AttributeDenotation> '.%' <NameApl>;
           * There is no corresponding nameDcl!!
           *)
          (if a[] = none then leave loop if);
          (a.father).father->exp[];
          (if debugStepBreak then
              'getobjdesc:'->puttext;
              exp.symbol->putint;
              ' '->put;
              (exp[],4)->doPrettyPrint->putline
          if);
          (if exp.symbol
           // MPS.BETA.PatternDecl then
              exp.getson2->a[]; 
           // MPS.BETA.VirtualDecl // MPS.BETA.BindingDecl
           // MPS.BETA.FinalDecl then
              exp.getson2->a[];
              (if a.symbol
               // MPS.BETA.NameApl then
                  a[]->na[]; na.descRef->a[]
               // MPS.BETA.Remote then
                  a[]->obs[]; obs.findDescriptor->a[]
              if)
           // MPS.BETA.SimpleDecl // MPS.BETA.RepetitionDecl then
              (if exp.symbol = MPS.BETA.RepetitionDecl then
                  exp.getson3->exp[]
               else
                  exp.getson2->exp[]; 
              if);
              (* exp=referenceSpecification *)
              (if exp.symbol
               // MPS.BETA.StaticItem // MPS.BETA.StaticComponent then
                  exp.getson1->a[];
                  (* a=objectSpecification *)
                  (if a.symbol
                   // MPS.BETA.ObjectDescriptor then
                   (* a=objectDescriptor - do no more *)
                      
                   // MPS.BETA.nameApl then
                      a[]->na[];
                      (* na=nameApl - continue to find objectDescriptor *)
                      restart loop
                   // MPS.BETA.Remote then
                      a[]->exp[];
                      exp.getson2->na[];
                      (* na=nameApl *)
                      restart loop
                  if)
               // MPS.BETA.DynamicItem // MPS.BETA.VariablePattern
               // MPS.BETA.DynamicComponent then
                  exp.getson1->a[];
                  (* a=objectSpecification *)
                  (if
                  a.symbol
                  (* was: exp.symbol, but this is known to be 20 (dynamicitem) *)
                   // MPS.BETA.nameApl (*=107*) then
                      a[]->na[]; (* was: exp[]->na[]; *) restart loop
                   // MPS.BETA.Remote (*=71*) then
                      a[]->exp[];
                      (* qua check *)
                      exp.getson2->na[];
                      (* na=nameApl *)
                      restart loop
                   else
                      'MPS.BETA.Dynamic*: elsepart: '->puttext;
                      a.symbol->putint;
                      newline
                  if)
              if)
           else
              'getobjectdesc,NOT found'->debugputline
          if)
       #)
  exit a[]
  #)  

-- steppingintolist: DoPart --
do
   (if imp[] = none then
         (# impi: ^ImperativeInfo; 
         do
            currentRemoteCode->impi[];
            (if impi[] <> none then
                impi.cast[]->imp[]
             else
                unknownCode->imp[]; 
            if);
            
         #);
       
   if);
   (if imp[] <> none then
       (if debugStepBreak then 'Calling OverList'->screen.putline if);
       imp[]->overlist (#  #)->(stepsetIMPs.appendList,stepsetADRs.appendList);
       (if debugStepBreak then
           'Intolist.Calling HandleImp'->screen.putline
       if);
       imp[]->handleImp;
       
   if);
     

-- steppingOverListLib: Attributes --
onFailure:
  (# 
  do
     (if not ('Missing Debug Info. Step may fail.'->stepfailure) then
         cancelled; 
     if);
     
  #);
getReturnAddress:
  (#
     retAdr: @Integer;
     componentaddr: @integer;
     comp,callcomp: ^remoteBetaObject;
     callcs: ^componentstack;
     impi: ^imperativeInfo;
     
  do
     (if s[] = none then curComp->getStack->s[];  if);
     (* Find first BETA address on stack not equal to PC. *)
     (if s.last >= 2 then (* this was the old *)
         (for i: s.last repeat
           (if s.returnObjs[i] <> 0 then
               (if (s.returnAdrs[i] <> PC) then
                   s.returnAdrs[i]->retAdr;
                   (if debugStepBreak then
                       'GetReturnAddress found: %d s.last=%d\n'
                         ->screen.putformat
                           (#  do retAdr->d; THIS(overlist).s.last->d #)
                   if);
                   leave getReturnAddress
               if)
           if)
         for)
      else
     (* last in component stack, this is new r5.0,gram *)
         (if s.callingComponents.range > 1 then
             s.callingComponents[1]->componentaddr;
             componentaddr->newRemoteObject->callcomp[];
             (if debugStepBreak then
                 'caller is component:%d, range = %d\n'
                   ->putformat
                     (# 
                     do
                        (if callcomp.isComp then 1->d else 0->d if);
                        THIS(overlist).s.callingComponents.range->d
                     #)
             if);
             callcomp.getaddress->getStack->callcs[];
             callcs.returnAdrs[1]->retAdr;
             (* actually callfrom point. ??, setbreak after this *)
             (if debugStepBreak then
                 'callcs.returnAdrs[1]=%d\n'->putformat (#  do retAdr->d #)
             if);
             retAdr->utilities.codeAddressToImperative->impi[];
             (if impi[] <> none then
                 (if debugStepBreak then '846 calling overlist'->putline if);
                 impi.cast[]->overlist
                   ->(stepsetIMPs.appendList,stepsetADRs.appendList);
                 leave getReturnAddress;
                 
             if);
             0->retAdr
          else
         (* last act.rec in last component *)
             (if debugStepBreak then 'doContinue'->putline if);
             (* doContinue; *)
             leave getReturnAddress
         if)
     if);
     (if debugStepBreak then 'No returnAdress found'->screen.putline if)
  exit retAdr
  #);
handleElsePartOpt: (* step-over *)
  (# a: ^MPS.AST.ast; ep: ^MPS.BETACFL.elsePart; 
  enter a[]
  do
     (if debugStepBreak then
         'handleElsePartOpt-Over, index:%d\n'
           ->screen.putformat (#  do a.index->d #)
     if);
     (if a.kind <> MPS.AST.kinds.optional then
         (a[]->ep[]).getImperatives->handleImperativesOpt
     if)
  #);
handleImperativesOpt: (* step-over *)
  (#
     a: ^MPS.AST.ast;
     imps: ^MPS.BETACFL.Imperatives;
     limpi: ^imperativeInfo;
     
  enter a[]
  do
     (if a.symbol <> MPS.AST.kinds.optional then
         a[]->imps[];
         getFirst: imps.newscan
           (# 
           do
              getCurrent:
              current[]
                ->utilities.codeAstToImperative
                  (# notfound::  (#  do leave getCurrent #) #)->limpi[];
              (if limpi[] <> none then
                  (if debugStepBreak then
                      '662HandleIMPopt, setbreak at '->screen.puttext;
                      limpi.cast.index->screen.putint;
                      screen.putline
                  if);
                  limpi[]->stepsetIMPs.append;
                  leave getFirst
              if);
              
           #);
         
     if);
     
  #);
handleImp: (* step-over *)
  (# imp,brother: ^MPS.AST.ast; limpi: ^ImperativeInfo; retAdr: @integer; 
  enter imp[]
  do
     (if debugStepBreak then
         'HandleIMP-over, ast=%d, symbol=%d\n '
           ->putformat (#  do imp.index->d; imp.symbol->d #)
     if);
     (if imp.symbol
      // MPS.BETA.leaveImp then
      (* If it is a labelled imp, do a step over on that imp.
       * If it is an objectDescriptor, we assume that it is
       * simply implemented as a return. Handle it by setting
       * a breakpoint at first BETA return address. *)
         overLeave:
           (#
              li: ^MPS.BETACFL.leaveImp;
              na: ^MPS.BETACFL.NameApl;
              a: ^MPS.AST.ast;
              adr: @Integer;
              
           do
              imp[]->li[];
              (li.getNameApl->na[]).descRef->a[];
              (if a.symbol = MPS.BETA.labelledImp then
                  a[]->handleImp; 
               else
                  (if debugStepBreak then
                      '754handleIMP-over appending address:%d\n'
                        ->screen.putformat (#  do getReturnAddress->d #)
                  if);
                  getReturnAddress->adr->stepsetADRs.append
              if)
           #)
      // MPS.BETA.restartImp then
         overRestart:
           (#
              ri: ^MPS.BETACFL.restartImp;
              na: ^MPS.BETACFL.NameApl;
              od: ^MPS.BETACFL.ObjectDescriptor;
              a: ^MPS.AST.ast;
              dpi: ^dopartInfo;
              
           do
              imp[]->ri[];
              (ri.getNameApl->na[]).descRef->a[];
              (if a.symbol
               // MPS.BETA.labelledImp then
                  a[]->intolist
                    ->(stepsetIMPs.appendList,stepsetADRs.appendList);
                  
               // MPS.BETA.ObjectDescriptor then
                  a[]
                    ->utilities.ObjectDescriptorToDopart
                      (#
                         nodopart:: 
                           (# 
                           do (* CANNOT HAPPEN *) onFailure; leave overRestart
                           #);
                         notfound::  (#  do onFailure; leave overRestart #);
                         onPartialMinfo:: 
                           (# 
                           do
                              (if debugStepBreak then
                                  '791handleIMP-over appending address:%d\n'
                                    ->screen.putformat
                                      (#  do ofi.Mentries[ptinx]->d #)
                              if);
                              ofi.Mentries[ptinx]->stepsetADRs.append;
                              leave overRestart;
                              
                           #);
                         
                      #)->dpi[];
                  dpi.dp.getImperatives->handleImperativesOpt;
                  
              if);
              
           #);
         
      // MPS.BETA.Imperatives then
      (* Search out until one of the following is met:
       *
       *   1. dopart: If dopart fragment or enclosing descriptor is not 
       *      inlined, use stack return address. Otherwise call recursively
       *      on objectDescriptor.
       * 
       *   2. forImp: Call step-into on forImp. This will handle both
       *      the after and into cases.
       * 
       *   3. simpleIfImp: Call recursively on simpleIfImp.
       * 
       *   4. generalIfImp: Call recursively on generalIfImp.
       *)
         overImperatives:
           (#
              a: ^MPS.AST.ast;
              limpi: ^ImperativeInfo;
              od: ^MPS.BETACFL.ObjectDescriptor;
              adr: @Integer;
              
           do
              imp.father->a[];
              loop:
              (if a.symbol
               // MPS.BETA.doPart then
                  (a[],MPS.BETA.ObjectDescriptor)
                    ->MPS.getEnclosingAST
                      (#
                         FollowFragments:: 
                           (# 
                           do (* We are in a dopart SLOT *)
                              (if debugStepBreak then
                                  '839handleIMP-over appending address:%d\n'
                                    ->screen.putformat
                                      (#  do getReturnAddress->d #)
                              if);
                              getReturnAddress->stepsetADRs.append;
                              leave overImperatives;
                              
                           #);
                         
                      #)->od[];
                  (if od[] <> none then
                      (if (od.kind->tos'%getBits[13,1]') then
                      (* od is an inserted item of the inlined kind.
                       * Call recursively on od. *)
                          od[]->handleImp; 
                       else
                          (if debugStepBreak then
                              'Scanning Stack in handleimp'->screen.putline
                          if);
                          getReturnAddress->retAdr;
                          (if debugStepBreak then
                              '858handleIMP appending address:%d\n'
                                ->screen.putformat (#  do retAdr->d #)
                          if);
                          (if retAdr <> 0 then retAdr->stepsetADRs.append if);
                          (if debugStepBreak then
                              'DONE Scanning Stack in handleimp'->screen.putline
                          if)
                      if)
                  if)
               // MPS.BETA.forImp then
                  a[]->intolist
                    ->(stepsetIMPs.appendList,stepsetADRs.appendList);
                  
               // MPS.BETA.simpleIfImp // MPS.BETA.generalIfImp then
                  a[]->handleImp; 
               else
                  a.father->a[]; restart loop; 
              if);
              
           #);
         
      else
     (* If the imperative has a next brother, we'll simply set the 
      * breakpoint at that brother.
      * 
      * Otherwise, if the father is an imperatives list, call recursively
      * on these imperatives.
      * 
      * Otherwise, if the imperative is an evaluation whose father is 
      * CaseSelection, then set breakpoints at the remaining brothers 
      * of the CaseSelection and at all evaluations in later brothers 
      * of the enclosing alternative. Finally, step into the corresponding
      * Imperatives. *)
         overGeneral:
           (#
              a: ^MPS.AST.ast;
              cs: ^MPS.BETACFL.CaseSelection;
              limpi: ^ImperativeInfo;
              
           do
              (if debugStepBreak then
                  '925 Over at astindex:%d, symbol:%d\n'
                    ->putformat (#  do imp.index->d; imp.symbol->d #);
                  
              if);
              imp[]->MPS.nextbrother->a[];
              checkBrother:
              (if a[] <> none then
                  (if debugStepBreak then
                      '964 found brother ast=%d,symbol=%d\n'
                        ->putformat (#  do a.index->d; a.symbol->d #);
                      
                  if);
                  a[]
                    ->utilities.codeAstToImperative
                      (#
                         notfound:: 
                           (# 
                           do a[]->MPS.nextbrother->a[]; restart checkBrother; 
                           #);
                         
                      #)->limpi[];
                  (if limpi[] <> none then
                      (if debugStepBreak then
                          ('836HandleIMP',limpi[])->printBreakpointPos; 
                      if);
                      limpi[]->stepsetIMPs.append
                  if);
                  leave overGeneral
              if);
              (* No brother found. *)
              imp.father->a[];
              (if debugStepBreak then
                  '982Found father = astindex:%d, symbol:%d\n'
                    ->screen.putformat (#  do a.index->d; a.symbol->d #);
                  
              if);
              (* go out until no more labels, never happens!! *)
              l:
              (if (a.father).symbol = MPS.BETA.LabelledImp then
                  a.father->a[]; restart l
              if);
              (if a.symbol
               // MPS.BETA.labelledImp // MPS.BETA.imperatives then
                  '990 calling handleimp'->debugputline; a[]->handleImp
               // MPS.BETA.InsertedItem then
                  a[]->handleImp
               // MPS.BETA.CaseSelection then
                    (#
                       handleSelections:
                         (#
                            cs: ^MPS.BETACFL.CaseSelection;
                            limpi: ^ImperativeInfo;
                            
                         enter cs[]
                         do
                            loop:
                            (if cs[] <> none then
                                none ->limpi[];
                                getEval:
                                cs.getEvaluation
                                  ->utilities.codeAstToImperative
                                    (# notfound::  (#  do leave getEval #)
                                    #)->limpi[];
                                (if limpi[] <> none then
                                    (if debugStepBreak then
                                        '865HandleIMP, setbreak at '
                                          ->screen.puttext;
                                        limpi.cast.index->screen.putint;
                                        screen.putline
                                    if);
                                    limpi[]->stepsetIMPs.append
                                if);
                                cs[]->MPS.nextbrother->cs[];
                                restart loop;
                                
                            if);
                            
                         #);
                       cs: ^MPS.BETACFL.CaseSelection;
                       alt: ^MPS.BETACFL.Alternative;
                       sels: ^MPS.BETACFL.Selections;
                       gi: ^MPS.BETACFL.generalIfImp;
                       (* set breakpoint in all imperatives, ie. then parts.
                        * and in all selection.eval's, this is done by handleSelection.
                        * In addition also set break after the if.
                        *)
                       
                    do
                       a[]->cs[];
                       cs[]->MPS.nextbrother->handleSelections;
                       (cs.father).father->alt[];
                       (alt.father).father->gi[]
                         ->overlist (* (alt.father).father is the general-if *)
                         ->(stepsetIMPs.appendList,stepsetADRs.appendList);
                       (* also set break in opt-elsepart *)
                       gi.getElsePartOpt->handleElsePartOpt;
                       loop:
                         (# 
                         do
                            (if debugStepBreak then
                                '903callind handleimpopt'->screen.putline
                            if);
                            alt.getImperatives->handleImperativesOpt;
                            alt[]->MPS.nextbrother->alt[];
                            (if alt[] <> none then
                                alt.getSelections->sels[];
                                selsscan: sels.newScan
                                  (# 
                                  do
                                     current[]->handleSelections; leave selsscan
                                  #);
                                restart loop
                            if)
                         #);
                       
                    #)
              if)
           #)
     if)
  #);
  

-- steppingoverlist: DoPart --
do
   (if imp[] = none then
         (# impi: ^ImperativeInfo; 
         do
            currentRemoteCode->impi[];
            (if impi[] <> none then
                impi.cast[]->imp[]
             else
                unknownCode; 
            if);
            
         #);
       
   if);
   (if imp[] <> none then imp[]->handleImp if);
     

