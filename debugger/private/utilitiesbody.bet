ORIGIN '../processInterface';
INCLUDE '~beta/objectserver/ObjectSerializerTables'
        '~beta/basiclib/formatio'
        '~beta/toollibs/utils/options'
        '~beta/toollibs/utils/mpsutils'
        '~beta/betaast/betasematt';
LIB_ITEM 'valhallaprocess';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- utilitiesLib: Attributes --
missingFragment:
  (#
     fragmentName: ^Text;
     type: @Integer;
     groupName: ^Text;
     errormsg: ^Text;
     
  enter (fragmentName[],type,groupName[])
  do
     &Text[]->errormsg[];
     'No debug info on fragment\n   %s:%s\nin\n   %s'
       ->errormsg.putFormat
         (# 
         do
            fragmentName[]->s;
            (if type
             // 2 then
                'Descriptor'->s
             // 3 then
                'Attributes'->s
             // 31 then
                'Dopart'->s
            if);
            groupName[]->s;
            
         #);
     errormsg[]->utilitiesFailure;
     
  #);
missingGroup:
  (# groupName: ^Text; errormsg: ^Text; 
  enter groupName[]
  do
     &text[]->errormsg[];
     'ERROR: Group\n   %s\nnot found in executable'
       ->errormsg.putFormat (#  do groupName[]->s #);
     errormsg[]->utilitiesFailure;
     
  #);
missingDoPart:
  (# index: @Integer; fragmentName,groupName: ^Text; errormsg: ^Text; 
  enter (index,fragmentName[],groupName[])
  do
     &Text[]->errormsg[];
     'MSGDP-ERROR: Dopart ast index %d not found in fragment\n   "%s"\nin\n   %s'
       ->errormsg.putFormat
         (#  do index->d; fragmentName[]->s; groupname[]->s;  #);
     errormsg[]->utilitiesFailure;
     
  #);
  

-- SLOTtoFragment: Descriptor --
(# syncat: @Integer; 
do
   (if theSLOT.category->syncat
    // MPS.BETA.ObjectDescriptor then
       MPS.BETA.DescriptorForm->syncat; 
    // MPS.BETA.Attributes then
       MPS.BETA.AttributesForm->syncat; 
   if);
   getfragment:
   (theSLOT.name,syncat)
     ->DBmanager.slotNameToGroups
       (#
          lsd: ^MPS.AST.slotDesc;
          errormsg: ^Text;
          fg: ^MPS.AST.fragmentgroup;
          
       do
          checkCurrent:
            (# 
            do (* TO BE ADDED: *)
            (* (groupNameHash,checkTime)
             ->uniqueGroupIDToObjectFileInfo
             ->ofi[]; *) (* ------------ *) (* TO BE REMOVED: *)
               current[]->groupNameToObjectFileInfo->ofi[];
               (* -------------- *)
               (if ofi[] = none then leave checkCurrent if);
               ofi.ensureMaxLoadLevel;
               (if ofi.fgLoadFailed then leave checkCurrent if);
               (theSLOT.name,screen[])->ofi.fg.open->ff[];
               (if ff[] = none then
                   &Text[]->errormsg[];
                   'UNEXPECTED: fragment %s of type %d\n   not found in %s'
                     ->errormsg.putformat
                       (# 
                       do
                          theSLOT.name->s;
                          theSLOT.category->d;
                          ofi.groupName[]->s
                       #);
                   errormsg[]->utilitiesFailure;
                   leave checkCurrent;
                   
               if);
               ff[]->ofi.fg.bind->lsd[];
               (if lsd[] = none then
                   &Text[]->errormsg[];
                   'UNEXPECTED: Failed to bind fragment\n   %s\nin\n   %s'
                     ->errormsg.putformat
                       (#  do theSLOT.name->s; ofi.groupName[]->s #);
                   errormsg[]->utilitiesFailure;
                   leave checkCurrent;
                   
                else
                   (if lsd[]->theSLOT.equal then leave getfragment if); 
               if);
               
            #);
          none ->ff[];
          none ->ofi[];
          
       #);
   
#)  

-- ProtoAddressToPrototypeInfo: DoPart --
do ptAdr->utprivate.ptinfoTable.findAndCache->pti[]  

-- codeAddressToImperativ: DoPart --
do
   (codeAdr,THIS(codeAddressToImperative)[])
     ->utprivate.adrToImpTable.findAndCache->impi[];
     

-- codeAstToImperative: DoPart --
do
   (cast[],THIS(codeAstToImperative)[])->utprivate.astToImpTable.findAndCache
     ->impi[];
     

-- objectDescriptorToDopartInfo: Descriptor --
(#
   ofi: ^ObjectFileInfo;
   ptinx: @Integer;
   errormsg: ^Text;
   groupName: ^Text;
   
do
   getDoPart:
     (# 
     do
     (*(od.frag.father).fullName->fgFullNameToOFIname
      ->mps.ast.expandtofullpath->groupName[]
      ->groupNameToObjectFileInfo
      ->ofi[];*)
        od.frag.father->mps.getUniqueGroupID->uniqueGroupIDToObjectFileInfo
          ->ofi[];
        (if ofi[] = none then groupName[]->missingGroup; leave getDoPart if);
        ofi.ensureMaxLoadLevel;
        (* 'groupname: '->puttext; groupName[]->putline; *)
        (od[],ofi.groupName[])
          ->groupsInfo.odGroupToProto
            (#
               notfound:: 
                 (# (* There was no prototype found, probably inlined  *) 
                 do leave getDopart
                 #)
            #)->ptinx;
        ptinx+1->ptinx;
        (*        newline;
         'ptinx '->puttext;ptinx->putint;newline; 
         *)
        (if (ofi.doparts[ptinx][]->dpi[]) <> none then leave getDoPart if);
        (* Ouuchhh. We'll have to do it the hard way: *)
          (#
             mp: ^MPS.BETACFL.MainPart;
             ap: ^MPS.BETACFL.ActionPart;
             a: ^MPS.AST.ast;
             unexp: ^MPS.AST.unexpanded;
             sd: ^MPS.AST.slotDesc;
             dofi: ^ObjectFileInfo;
             ff: ^MPS.AST.fragmentForm;
             fi: ^FragmentInfo;
             dp: ^MPS.BETACFL.doPart;
             
          do
             (od.getMainPart->mp[]).getActionPart->ap[];
             ap.getDoPartOpt->a[];
             (if a[] = none then leave getDoPart if);
             (if a.kind = MPS.AST.kinds.optional then
                 noDopart; leave getDoPart
             if);
             (if a.symbol = MPS.AST.prodNo.unexpanded then
             (* This is a dopart SLOT. Locate the fragment group containing the
              * corresponding fragment. *)
                 a[]->unexp[];
                 unexp.theSlot->sd[];
                 getdofi:
                 (sd.name,MPS.BETA.dopart)
                   ->DBmanager.slotNameToGroups
                     (# lsd: ^MPS.AST.slotDesc; 
                     do
                        checkCurrent:
                          (# 
                          do
                             current[]->mps.ast.expandtofullpath->current[]
                               ->groupNameToObjectFileInfo->dofi[];
                             (if dofi[] = none then
                                 current[]->missingGroup; leave checkCurrent; 
                             if);
                             dofi.ensureMaxLoadLevel;
                             (if dofi.fgLoadFailed then
                                 notfound; leave checkCurrent
                             if);
                             ((unexp.theSlot).name,screen[])->dofi.fg.open
                               ->ff[];
                             (if ff[] = none then
                                 &Text[]->errormsg[];
                                 'UNEXPECTED: %s:dopart\n   not found in\n   %s'
                                   ->errormsg.putformat
                                     (# 
                                     do
                                        (unexp.theSlot).name->s;
                                        dofi.groupName[]->s
                                     #);
                                 errormsg[]->utilitiesFailure;
                                 leave checkCurrent;
                                 
                             if);
                             ff[]->dofi.fg.bind->lsd[];
                             (if lsd[]->sd.equal then (* Hurraahh. *)
                                 leave getdofi
                             if);
                             
                          #);
                        none ->dofi[];
                        none ->ff[];
                        
                     #);
                 (if dofi[] = none then
                     &Text[]->errormsg[];
                     'ERROR: Failed to locate %s:dopart fragment'
                       ->errormsg.putformat (#  do sd.name->s #);
                     errormsg[]->utilitiesFailure;
                     notfound;
                     leave getDopart;
                     
                 if);
                 ff.root[]->dp[];
                 (sd.name,MPS.BETA.dopart)->dofi.findFragmentInfo->fi[];
                 (if fi[] = none then
                     '/users/gram/beta/r5.2/debugger/private/utilitiesbody.bet: Line 255'
                       ->screen.putline;
                     (sd.name,MPS.BETA.dopart,dofi.groupName[])
                       ->missingFragment;
                     (dp[],ofi[],ptinx)->onPartialMinfo;
                     leave getDopart;
                     
                 if);
                 (if fi.frag[] <> none then (* Consistency check. *)
                     (if not (fi.frag.root[]->ff.root.equal) then
                         'objectDescriptorToDopart(1): Consistency check failed'
                           ->otherError
                     if);
                     
                 if);
                 ff[]->fi.frag[];
                 (* Cache *)
                 (dp.getImperatives).index->fi.findDopartInfo->dpi[]
                   ->ofi.doparts[ptinx][];
                 (if dpi[] = none then
                     ((dp.getImperatives).index,fi.fragmentName[],
                      dofi.groupname[])->missingDopart;
                     (dp[],ofi[],ptinx)->onPartialMinfo;
                     leave getDopart;
                     
                 if);
                 
              else
             (* a is the dopart we're looking for. Just go find the 
              * corresponding dopart info in the fragment group containing the
              * ObjectDescriptor. *)
                 a[]->dp[];
                 (dp.frag.name,dp.frag.root.symbol)->ofi.findFragmentInfo->fi[];
                 (if fi[] = none then
                     '/users/gram/beta/r5.2/debugger/private/utilitiesbody.bet: Line 288'
                       ->screen.putline;
                     (dp.frag.name,dp.frag.root.symbol,ofi.groupName[])
                       ->missingFragment;
                     (dp[],ofi[],ptinx)->onPartialMinfo;
                     leave getDopart;
                     
                 if);
                 (dp.getImperatives).index->fi.findDopartInfo->dpi[]
                   ->ofi.doparts[ptinx][];
                 (if dpi[] = none then
                     ((dp.getImperatives).index,fi.fragmentName[],
                      ofi.groupname[])->missingDopart;
                     (dp[],ofi[],ptinx)->onPartialMinfo;
                     leave getDopart;
                     
                 if);
                 
             if);
             dp[]->ofi.doparts[ptinx].dp[];
             ofi.Mentries[ptinx]->dpi.Mentry;
             ofi[]->dpi.odofi[];
             ptinx->dpi.ptinx;
             
          #)
     #)
#)  

-- utilitiesInit: DoPart --
do utprivate.init;   

-- utilitiesPrivate: Descriptor --
(#
   debug: @Boolean;
   init:
     (# 
     do ptinfoTable.init; adrToImpTable.init; astToImpTable.init; true->debug; 
     #);
   astToImpTable: @hashTable
   (* Mapping from imperatives (ast nodes) to imperateInfo's. *)
     (#
        element:: imperativeInfo;
        hashfunction::  (#  do e.cast.index->value #);
        findAndCache:
          (#
             imp: ^MPS.AST.ast;
             thecati: ^codeAstToImperative;
             impi: ^imperativeInfo;
             
          enter (imp[],thecati[])
          do
             imp.index
               ->findIndexed
                 (#
                    predicate::  (#  do current.cast[]->imp.equal->value #);
                    
                 do current[]->impi[]; 
                 #);
             (if impi[] = none then
                 fullFind:
                   (#
                      groupName: ^Text;
                      ofi: ^ObjectFileInfo;
                      fi: ^FragmentInfo;
                      dp: ^MPS.BETACFL.doPart;
                      od: ^MPS.BETACFL.ObjectDescriptor;
                      a: ^MPS.AST.ast;
                      odofi: ^ObjectFileInfo;
                      odGroupName: ^Text;
                      dpi: ^dopartInfo;
                      errormsg: ^Text;
                      throughSLOT: @Boolean;
                      ptinx: @Integer;
                      
                   do
                      (imp.frag.father).fullName->fgFullNameToOFIname
                        ->mps.ast.expandtofullpath->groupName[]
                        ->groupNameToObjectFileInfo->ofi[];
                      (if debug then
                          'GroupName is:'->puttext;
                          groupName[]->putline;
                          ofi[]->debugGroupsInfo
                      if);
                      (if ofi[] = none then
                          groupName[]->missingGroup; leave fullFind; 
                      if);
                      ofi.ensureMaxLoadLevel;
                      (imp.frag.name,imp.frag.root.symbol)->ofi.findFragmentInfo
                        ->fi[];
                      (if fi[] = none then
                          '/users/gram/beta/r5.2/debugger/private/utilitiesbody.bet: Line 375'
                            ->screen.putline;
                          (imp.frag.name,imp.frag.root.symbol,ofi.groupName[])
                            ->missingFragment;
                          leave fullFind
                      if);
                      (if debug then
                          'astToImpTable: Fragment is %s\n'
                            ->putformat (#  do fi.fragmentName[]->s #)
                      if);
                      imp[]->a[];
                      getSignificantDopartAndDescriptor:
                        (# 
                        do
                           FALSE->throughSLOT;
                           (a[],MPS.BETA.doPart)->MPS.getEnclosingAst->dp[];
                           (if dp[] = none then
                               thecati.noEnclosingDopart; leave fullFind
                           if);
                           (if debug then
                               'astToImpTable: Found dopart: \n'->putLine;
                               (dp[],5)->doPrettyPrint->putLine;
                               
                           if);
                           (dp[],MPS.BETA.ObjectDescriptor)
                             ->MPS.getEnclosingAst
                               (#
                                  followFragments:: 
                                    (#  do true->value->throughSLOT #);
                                  
                               #)->od[];
                           (if od[] = none then
                               &Text[]->errormsg[];
                               'ERROR: Failed to locate ObjectDescriptor\nenclosing dopart in group\n   %s'
                                 ->errormsg.putFormat
                                   (#  do groupName[]->s #);
                               errormsg[]->utilitiesFailure;
                               leave fullFind;
                               
                           if);
                           (if debug then
                               'astToImpTable: Found descriptor: \n'->putLine;
                               (od[],5)->doPrettyPrint->putLine;
                               
                           if);
                           (if (od.kind->tos'%getBits[13,1]') then
                           (* Current is an inserted item of the inlined kind.
                            * No prototype for this one... *)
                               od[]->a[];
                               (if debug then
                                   'astToImpTable: Found inlined inserted item, restarting!'
                                     ->putline
                               if);
                               restart getSignificantDopartAndDescriptor;
                               
                           if);
                           
                        #);
                      (if throughSLOT then
                      (* The ObjectDescriptor (od) was found in some
                       * ORIGIN group and not in the same group as the
                       * dopart. We need the ObjectFileInfo on the origin
                       * group. ofi.ensureMaxLoadLevel has fully loaded
                       * the origin group too. *)
                      (* (od.frag.father).fullName
                       * ->fgFullNameToOFIname
                       * ->odGroupName[]
                       * ->groupNameToObjectFileInfo
                       * ->odofi[];*)
                          (if debug then
                              'astToImpTable: descriptor in origin fragmentgroup'
                                ->putline
                          if);
                          od.frag.father->mps.getUniqueGroupID
                            ->uniqueGroupIDToObjectFileInfo->odofi[];
                          (if debug then odofi[]->debugGroupsInfo if);
                          
                       else
                          ofi[]->odofi[]; 
                      if);
                      (if debug then
                          'astToImpTable: dp.index=%d dp.imperatives.index=%d\n'
                            ->putformat
                              (# 
                              do dp.index->d; (dp.getImperatives).index->d
                              #)
                      if);
                      (dp.getImperatives).index->fi.findDopartInfo->dpi[];
                      (if dpi[] = none then
                          &Text[]->errormsg[];
                          'FGC-ERROR: Missing dopart info on\n   %s'
                            ->errormsg.putFormat (#  do groupName[]->s #);
                          errormsg[]->utilitiesFailure;
                          leave fullFind;
                          
                      if);
                      (od[],odofi.groupName[])->groupsInfo.odGroupToProto
                        ->ptinx;
                      ptinx+1->ptinx;
                      (if debug then
                          'astToImpTable: ptinx found: %d.\n'
                            ->putformat (#  do ptinx->d;  #);
                          
                      if);
                      (* If the dopart has not already been cached in the
                       * doparts repetition of odofi, fill it out with
                       * the extra information and do it. *)
                      (if odofi.doparts[ptinx][] = none then
                          odofi.Mentries[ptinx]->dpi.Mentry;
                          odofi[]->dpi.odofi[];
                          ptinx->dpi.ptinx;
                          dp[]->dpi.dp[];
                          dpi[]->odofi.doparts[ptinx][];
                          
                       else
                      (* consistency check: *)
                          (if odofi.doparts[ptinx][] <> dpi[] then
                              'Consistency error: astToImpTable.findAndCache-1'
                                ->otherError;
                              stop;
                              
                          if);
                          
                      if);
                      (* All we need now is to find the imperative in 
                       * dpi.impAstRefs, and we're done. *)
                      l:
                      (for inx: dpi.impAstRefs.range repeat
                        (if (imp.index = dpi.impAstRefs[inx]) then
                        (* see if the next .db entry has the same code-entry,
                         * then select the corresponding ast instead.
                         *)
                            (if (inx < dpi.impAstRefs.range) and
                            (dpi.impAddresses[inx] = dpi.impAddresses[inx+1])
                             then
                            (* 'addr+1=%x\n'->putformat(# do dpi.impAddresses[inx+1]->x #);
                             'addr+1=%x\n'->putformat(# do dpi.impAddresses[inx+1]->x #); *)
                                dpi.impAstRefs[inx+1]->imp.frag.indextonode
                                  ->imp[];
                                inx+1->inx;
                                
                            if);
                            (* Got it. Create the imperative info. *)
                            &ImperativeInfo[]->impi[];
                            dpi[]->impi.dpi[];
                            inx->impi.inx;
                            imp[]->impi.cast[];
                            impi[]->insert;
                            (impi[],impi.start)->adrToImpTable.insert;
                            leave fullFind
                        if)
                      for);
                      'Did NOT LEVE fullfind'->putline;
                      (* OOPS. If we get here, the imperative ast index was 
                       * not found in dpi.impAstRefs. *)
                      thecati.notfound;
                      leave fullFind;
                      
                   #);
                 
             if);
             
          exit impi[]
          #);
        
     #);
   adrToImpTable: @IntegerHashTable
   (* Mapping from code addresses to imperativeInfo's.
    * 
    * Invariant on the adrToImpTable:
    *   
    *     If an imperativeInfo is contained in the table, it is at least 
    *     registered using its start address.
    *  
    *     An imperativeInfo is contained in the adrToImpTable iff it is
    *     contained in the astToImpTable.
    * 
    * However, in addition to its start address, an imperativeInfo may be 
    * registered under other addresses, also part of the code for that 
    * imperative. *)
     (#
        element:: imperativeInfo;
        findAndCache:
          (#
             codeAdr: @Integer;
             thecati: ^codeAddressToImperative;
             impi: ^imperativeInfo;
             ofi: ^ObjectFileInfo;
             (* The ObjectFileInfo whose code segment contains codeAdr. *)
             dpi: ^dopartInfo;
             (* ID of M or G entry found to contain codeAdr.
              * 
              * nofi is the group containing the prototype.
              * 
              * If ninx is negative, nearest entry is the Gentry in 
              * nofi.Gentries[-ninx]. Otherwise it is the Mentry in
              * nofi.Mentries[ninx].
              * 
              * nval is the value of tne nearest entry found. *)
             nofi: ^ObjectFileInfo;
             ninx: @Integer;
             nval: @Integer;
             errormsg: ^Text;
             getDopart:
               (#
                  a: ^MPS.AST.ast;
                  unexp: ^MPS.AST.unexpanded;
                  od: ^MPS.BETACFL.ObjectDescriptor;
                  dp: ^MPS.BETACFL.Dopart;
                  mp: ^MPS.BETACFL.MainPart;
                  ap: ^MPS.BETACFL.ActionPart;
                  im: ^MPS.BETACFL.Imperatives;
                  fi: ^fragmentInfo;
                  ff: ^MPS.AST.fragmentForm;
                  ok,first: @Boolean;
                  
               do
               (* HAIRY STUFF!!! Locate the dopart corresponding to nval,
                * the Mentry found to contain codeAdr. When found, cache
                * the information in the doparts repetition of nofi. *)
                  TRUE->ok;
                  (* First get hold of the ObjectDescriptor whose 
                   * dopart we're looking for: *)
                  (ninx-1,nofi.groupName[])->groupsInfo.protoGroupToOd->od[];
                  (if od[] = none then leave getDoPart if);
                  (if debug then
                      'getDopart: Found objectdescriptor %d od.descNO=%d:\n'
                        ->putformat (#  do ninx-1->d; od.descNO->d #);
                      (od[],5)->doPrettyPrint->putline;
                      newline;
                      
                  if);
                  (* Then dig out the dopart. This may involve 
                   * dopart SLOTS!! (May they burn in hell :-) *)
                  od.getMainPart->mp[];
                  (if mp[] = none then leave getDoPart if);
                  mp.getActionPart->ap[];
                  (if ap[] = none then leave getDoPart if);
                  ap.getDoPartOpt->a[];
                  (if a[] = none then leave getDoPart if);
                  (if a.kind = MPS.AST.kinds.optional then
                  (* UNEXPECTED!!! Since we believe to know
                   * that od has a dopart (at least we think we 
                   * found codeAdr to be part of that dopart), 
                   * this should not happen!!! *)
                      FALSE->ok;
                      &Text[]->errormsg[];
                      'ERROR: address %d\n   located to dopart of prototype %s,\n   which has no dopart at all!!'
                        ->errormsg.putFormat
                          (# dummy: @Integer; 
                          do
                             codeAdr->d;
                             nofi.Tentries[ninx]->executable.labelAddressToName
                               ->(s,dummy);
                             
                          #);
                      errormsg[]->utilitiesFailure;
                      (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],none )
                        ->thecati.onPartialMinfo;
                      leave getDoPart;
                      
                  if);
                  (if a.symbol = MPS.AST.prodNo.unexpanded then
                  (* This is a dopart SLOT. Find the 
                   * corresponding fragment in the group
                   * originally found to contain the 
                   * code codeAdr. *)
                      a[]->unexp[];
                      ((unexp.theSlot).name,MPS.BETA.dopart)
                        ->ofi.findFragmentInfo->fi[];
                      (if fi[] = none then
                          (if debug then
                              'no FI: Found mainpart:'->putline;
                              (od[],5)->doPrettyPrint->putline;
                              newline
                          if);
                          FALSE->ok;
                          (* ?? dp = what? 
                           * (dp.frag.name,dp.frag.root.symbol,nofi.groupName[])
                           ->missingFragment;
                           We try this:*)
                          (if debug then
                              'a.inx=%d, a.symbol=%d\n'
                                ->putformat
                                  (#  do a.index->d; a.symbol->d #);
                              (unexp.theSlot).name->putline
                          if);
                          (* try next index, sometimes confused ??? *)
                          ninx+1->ninx;
                          (if not first then
                              true->first; (* restart getDopart *) 
                          if);
                          (unexp.frag.name,unexp.frag.root.symbol,
                           nofi.groupName[])->missingFragment;
                          (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],none
                           )->thecati.onPartialMinfo;
                          leave getDopart;
                          
                      if);
                      (if fi.frag[] = none then
                          (if ofi.fg[] = none then
                              FALSE->ok;
                              &Text[]->errormsg[];
                              'ERROR: Could not locate dopart fragment %s\n   due to missing fragment group: "%s"'
                                ->errormsg.putFormat
                                  (# 
                                  do fi.fragmentName[]->s; ofi.groupName[]->s; 
                                  #);
                              errormsg[]->utilitiesFailure;
                              (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],
                               none )->thecati.onPartialMinfo;
                              leave getDoPart;
                              
                          if);
                          findFragmentForm: ofi.fg.fragmentList.scan
                            (#
                               ff: ^MPS.AST.fragmentForm;
                               exp: ^MPS.AST.expanded;
                               tmpdp: ^MPS.BETACFL.dopart;
                               
                            do
                               (if current.type = MPS.AST.formType then
                                   current.open->ff[];
                                   (if (ff.root[]->exp[]).symbol =
                                   MPS.BETA.dopart then
                                       (if ff.name->fi.fragmentName.equalNCS
                                        then
                                           ff[]->fi.frag[];
                                           leave findFragmentForm;
                                           
                                       if);
                                       
                                   if);
                                   
                               if);
                               
                            #);
                          (if fi.frag[] = none then
                              FALSE->ok;
                              '/users/gram/beta/r5.2/debugger/private/utilitiesbody.bet: Line 690'
                                ->screen.putline;
                              (fi.fragmentName[],fi.fragmentType,
                               ofi.groupName[])->missingFragment;
                              (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],
                               none )->thecati.onPartialMinfo;
                              leave getDopart;
                              
                          if);
                          
                      if);
                      ((fi.frag.root[]->dp[]).getImperatives).index
                        ->fi.findDopartInfo->nofi.doparts[ninx][];
                      (if nofi.doparts[ninx][] = none then
                          FALSE->ok;
                          ((dp.getImperatives).index,fi.fragmentName[],
                           ofi.groupname[])->missingDopart;
                          (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],dp[])
                            ->thecati.onPartialMinfo;
                          leave getDopart;
                          
                      if);
                      fi.frag.root[]->nofi.doparts[ninx].dp[];
                      
                   else
                  (* a is the dopart we're looking for.
                   * Just go find the corresponding
                   * dopart info. It is in the same fragment
                   * Group as the ObjectDescriptor itself.
                   * If we got here, nofi and ofi better be 
                   * the same! *)
                      (if ofi[] <> nofi[] then
                          'Consistency check failed: adrToImpTable(1)'
                            ->otherError
                      if);
                      a[]->dp[];
                      (if debug then
                          'getDopart: Found dopart:'->putline;
                          (dp[],5)->doPrettyPrint->putline;
                          newline;
                          
                      if);
                      (dp.frag.name,dp.frag.root.symbol)->nofi.findFragmentInfo
                        ->fi[];
                      (if fi[] = none then
                          FALSE->ok;
                          '/users/gram/beta/r5.2/debugger/private/utilitiesbody.bet: Line 735'
                            ->screen.putline;
                          (dp.frag.name,dp.frag.root.symbol,nofi.groupName[])
                            ->missingFragment;
                          (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],dp[])
                            ->thecati.onPartialMinfo;
                          leave getDopart;
                          
                      if);
                      (dp.getImperatives).index->fi.findDopartInfo
                        ->nofi.doparts[ninx][];
                      (if nofi.doparts[ninx][] = none then
                          FALSE->ok;
                          ((dp.getImperatives).index,fi.fragmentName[],
                           ofi.groupname[])->missingDopart;
                          (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],dp[])
                            ->thecati.onPartialMinfo;
                          leave getDopart;
                          
                      if);
                      dp[]->nofi.doparts[ninx].dp[];
                      
                  if);
                  nval->nofi.doparts[ninx].Mentry;
                  ninx->nofi.doparts[ninx].ptinx;
                  nofi[]->nofi.doparts[ninx].odofi[];
                  
               exit ok
               #);
             findNearestEntry:
               (# tmpofi: ^ObjectFileInfo; 
               do
               (* We've got the correct objectfile. Locate the
                * nearest M or G entry point: *)
                  ofi.ensureMaxLoadLevel;
                  ofi[]->tmpofi[];
                  scanOrigins:
                  (if tmpofi[] <> none then
                      (for i: tmpofi.protoCount repeat
                        tmpofi.Mentries[i]->tmp;
                        (if tmp <= codeAdr then
                            (if tmp > nval then
                                tmpofi[]->nofi[]; i->ninx; tmp->nval
                            if)
                        if);
                        tmpofi.Gentries[i]->tmp;
                        (if tmp <= codeAdr then
                            (if tmp > nval then
                                tmpofi[]->nofi[]; - i->ninx; tmp->nval
                            if)
                        if)
                      for);
                      tmpofi.originOfi[]->tmpofi[];
                      restart scanOrigins
                  if);
                  (if debug then
                      'findNearestEntry: Found %d while searching for %d ninx=%d\n'
                        ->putformat (#  do nval->d; codeAdr->d; ninx->d #)
                  if)
               #);
             noffsetinx,noffset,offset,tmp: @Integer
          enter (codeAdr,thecati[])
          do
             codeAdr->find->impi[];
             fullFind:
             (if impi[] = none then
                 codeAdr->codeAddressToObjectFileInfo->ofi[];
                 (if ofi[] = none then
                     &Text[]->errormsg[];
                     'ERROR: No BETA code segment containing address %d'
                       ->errormsg.putFormat (#  do codeAdr->d #);
                     errormsg[]->thecati.notBetaCode;
                     leave fullFind;
                     
                 if);
                 (if debug then ofi[]->debugGroupsInfo if);
                 findNearestEntry;
                 (if nofi[] = none then
                     &Text[]->errormsg[];
                     'ERROR: No entrypoint less than %d\n   in %s or origins'
                       ->errormsg.putFormat
                         (#  do codeAdr->d; ofi.groupName[]->s;  #);
                     errormsg[]->utilitiesFailure;
                     leave fullFind;
                     
                 if);
                 (* Ok. A nearest entry point was found. *)
                 (if ninx < 0 then (* It was a G entry. *)
                     (nofi.Tentries[- ninx],codeAdr-nofi.Gentries[- ninx])
                       ->thecati.onGentry;
                     leave fullFind;
                     
                 if);
                 (* It was a M entry. *)
                 (if nofi.doparts[ninx][] = none then
                 (* dopart corresponding to this M entry not seen before.
                  * Locate it and setup its Mentry and ofi attributes 
                  * before caching it nofi.doparts[ninx]. *)
                     (if not getDopart then leave fullFind if); 
                 if);
                 (* Find the nearest imperative: *)
                 nofi.doparts[ninx][]->dpi[];
                 (if dpi[] = none then leave fullFind if);
                 codeAdr-dpi.Mentry->offset;
                 (if debug then
                     'looking for nearest imperative after offset %d in: \n'
                       ->putformat (#  do offset->d #);
                     (dpi.dp[],5)->doPrettyPrint->putline;
                     newline;
                     newline;
                     
                 if);
                 (for inx: dpi.impAddresses.range repeat
                   dpi.impAddresses[inx]->tmp;
                   (if tmp <= offset then
                       (if tmp >= noffset then
                       (* If tmp=noffset, the same code offset if
                        * used for more than one .db entry. In
                        * that case, either the previous entry
                        * corresponds to an imperative generating
                        * no code, or one of the "offsetAfter"
                        * entries (see ../debugInfoFormat.txt).
                        * In any case, we are interested in the
                        * last of the entries sharing the same
                        * code offset. *)
                           tmp->noffset; inx->noffsetinx; 
                       if);
                       
                   if);
                   
                 for);
                 (if noffsetinx = 0 then
                     &Text[]->errormsg[];
                     'ERROR: Imperative offset not found in dopart'
                       ->utilitiesFailure;
                     (nofi.Tentries[ninx],codeAdr-nofi.Gentries[ninx],dpi.dp[])
                       ->thecati.onPartialMinfo;
                     none ->impi[];
                     leave fullFind;
                     
                 if);
                 (* Before creating a new imperative info, check if we
                  * have already seen it. In that case it has been
                  * registered under the start address: *)
                 (if offset <> noffset then
                     noffset+dpi.Mentry->find->impi[]
                 if);
                 (if impi[] = none then
                     &ImperativeInfo[]->impi[];
                     noffsetinx->impi.inx;
                     dpi[]->impi.dpi[];
                     dpi.impAstRefs[noffsetinx]->dpi.dp.frag.indexToNode
                       ->impi.cast[];
                     (impi[],noffset+dpi.Mentry (*impi.start*) )->insert;
                     (* Since it wasn't here, it can't be in the
                      * astToImpTable either: *)
                     impi[]->astToImpTable.insert;
                     
                 if);
                 (if noffset <> offset then
                 (* codeAdr does not correspond to the start address of
                  * this imperative. Also register it using codeAdr as 
                  * key: *)
                     (impi[],codeAdr)->insert; 
                 if);
                 
             if)
          exit impi[]
          #);
        
     #);
   ptinfoTable: @IntegerHashTable
     (#
        element:: ProtoTypeInfo;
        init:: 
          (# options: ^optionDB; 
          do
             (getObjectPrefs).getBoolean (#  do 'DebugValhalla'->name[] #)
               ->debug;
             
          #);
        findAndCache:
          (#
             ptAdr: @Integer;
             pti: ^ProtoTypeInfo;
             ofi: ^ObjectFileInfo;
             low,mid,high: @Integer;
             
          enter ptAdr
          do
             ptAdr->find->pti[];
             (if pti[] = none then
                 ptAdr->dataAddressToObjectFileInfo->ofi[];
                 (if debug then ofi[]->debugGroupsInfo if);
                 createpti:
                 (if ofi[] = none then
                     'ptinfoTable.findAndCache: ofi was NONE'->otherError; 
                  else
                 (* Create a new protoTypeInfo to be cached. *)
                     &ProtoTypeInfo[]->pti[];
                     ofi[]->pti.ofi[];
                     ofi.ensureMaxLoadLevel;
                     (if ofi.fg[] = none then
                         none ->pti[]; leave createpti
                     if);
                     (* Lookup the prototype address in the proto table
                      * using binary search;  *)
                     1->low;
                     ofi.protoCount->high;
                     (low+high) div 2->mid;
                     binsearch:
                     (if high = low then
                         (if ofi.Tentries[low] = ptAdr then
                             low->pti.inx; 
                          else
                         (* UNEXPECTED!!! *)
                             linearsearch:
                             (for i: ofi.protoCount repeat
                               (if ofi.Tentries[i] = ptAdr then
                                   i->pti.inx; leave linearsearch; 
                               if);
                               
                             for);
                             (* NONE->pti[]; leave createpti; *)
                             
                         if);
                         
                      else
                         (if ofi.Tentries[mid] < ptAdr then
                             mid+1->low; 
                          else
                             mid->high; 
                         if);
                         (low+high) div 2->mid;
                         restart binsearch;
                         
                     if);
                     (pti.inx-1,ofi.groupName[])->groupsInfo.protoGroupToOd
                       ->pti.objdesc[];
                     (pti[],ptAdr)->insert;
                     leave createpti;
                     
                 if);
                 
             if)
          exit pti[]
          #);
        
     #);
   debugGroupsInfo:
     (#
        ofi: ^ObjectFileInfo;
        od1,od2: ^MPS.BETACFL.ObjectDescriptor;
        formIndex,astIndex: @Integer;
        nd: ^MPS.BETACFL.NameDcl;
        kind: @Integer;
        t: ^text
     enter ofi[]
     do (* Check that groupsInfo and ofi agree: *)
        (for i: ofi.protoCount repeat
          0->ofi.astRefs[i].%getShort->formIndex;
          1->ofi.astRefs[i].%getShort->astIndex;
          (ofi.fg[],formIndex,2*astIndex)
            ->MPS.astRefToAst (# astType:: MPS.BETACFL.ObjectDescriptor #)
            ->od1[];
          (i-1,ofi.groupName[])->groupsInfo.protoGroupToOd->od2[];
          (if not (od1[]->od2.equal) then
              'Mismatch on '->t[];
              od1.getDescName->(nd[],kind);
              (if nd[] <> none then
                  nd.getText->t.putLine; 
               else
                  od1.frag.name->t.putLine; 
              if);
              'inx = '->t.putText;
              i->t.putInt;
              t.newline;
              t[]->otherError
          if);
          
        for);
        
     #);
   
#)  

