ORIGIN '../processInterface';
INCLUDE '~beta/basiclib/v1.6/numberio';
INCLUDE '~beta/basiclib/v1.6/formatio';
INCLUDE 'sorting';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

(* PROCESSINTERFACEPRIVATE
 * ======================= *)

--- processInterfacePrivate:descriptor ---
(# 
   (* ObjectFileInfos
    * =============== *)
   
   ObjectFileInfos: @
     (# table: [50]^ObjectFileInfo;
        last: @Integer;
        insert: 
          (# ofi: ^ObjectFileInfo;
          enter ofi[]
          do (if (last+1 -> last) > table.range  then
                 table.range -> table.extend;
             if);
             ofi[] -> table[last][];
          #);
        scan:
          (# current: ^ObjectFileInfo; 
          do (for i:last repeat
                  table[i][] -> current[];
                  INNER;
             for)
          #);
        sort:
          (#
          do (1,last)->qsort
             (# swap:: 
                  (# temp: ^ObjectFileInfo;
                  do table[i][]->temp[];
                     table[j][]->table[i][];
                     temp[]->table[j][];
                  #);
                less::
                  (# 
                  do table[i].dataStart<table[j].dataStart->value;
                  #);
             #);
          #);
        findByID:
          (#  groupNameHash,checkTime: @Integer;
             found: ^ObjectFileInfo;
          enter (groupNameHash,checkTime)
          do NONE -> found[];
             find: scan
               (# 
               do 
                  (if (current.groupNameHash=groupNameHash)
                      and (current.checkTime=checkTime)  then
                      current[] -> found[];
                      leave find;
                  if);
               #);
          exit found[]
          #);
        findByName:
          (# name: ^Text;
             found: ^ObjectFileInfo;
          enter name[]
          do NONE -> found[];
             find: scan
               (# 
               do 
                  (if current.groupName[] -> name.equal  then
                      current[] -> found[];
                      leave find;
                  if);
               #);
          exit found[]
          #);
        findByDataAddress:
          (# adr: @Integer;
             found: ^ObjectFileInfo;
             low,mid,high: @Integer;
          enter adr
          do 1->low; last->high; (low+high) div 2 ->mid;
             binsearch:
               (if low=high then
                   table[low][]->found[];
                   (if found.dataStart<=adr then
                       (if adr<found.dataEnd then
                           leave binsearch;
                       if);
                   if);
                   NONE->found[];
                else
                   (if table[mid].dataEnd < adr then
                       mid+1->low;
                    else
                       mid->high;
                   if);
                   (low+high) div 2 ->mid;
                   restart binsearch;
               if);
          exit found[]
          #);
        findByCodeAddress:
          (# adr: @Integer;
             found: ^ObjectFileInfo;
             low,mid,high: @Integer;
          enter adr
          do 1->low; last->high; (low+high) div 2 ->mid;
             binsearch:
               (if low=high then
                   table[low][]->found[];
                   (if found.codeStart<=adr then
                       (if adr<found.codeEnd then
                           leave binsearch;
                       if);
                   if);
                   NONE->found[];
                else
                   (if table[mid].codeEnd < adr then
                       mid+1->low;
                    else
                       mid->high;
                   if);
                   (low+high) div 2 ->mid;
                   restart binsearch;
               if);
          exit found[]
          #);
     #);
   
   init:
     (# 
     do processComm.ScanGroups
        (# new: ^ObjectFileInfo; firstDone: @Boolean;
        do (if not firstDone then onDataSegmentScan; TRUE->firstDone if);
           &ObjectFileInfo[] -> new[];
           groupName[]->mps.ast.expandtofullpath -> new.groupName[];
           dataStart -> new.dataStart;
           dataEnd -> new.dataEnd;
           codeStart -> new.codeStart;
           codeEnd -> new.codeEnd;
           groupNameHash -> new.groupNameHash;
           checkTime -> new.checkTime;
           LL_INITIAL -> new.loadLevel;
           new[] -> ObjectFileInfos.insert;
        #);
        ObjectFileInfos.sort;
        onDataSegmentScanDone;
     #);
#)

--- processInterfaceInit:dopart ---
do 
   (* Initialize executable and, if the readLabelsOnStartUp
    * option is TRUE, fork nm process to read and sort labels 
    * from the executable. It may work in parallel with other 
    * valhalla initialization. *)
   executable.init 
   (# notFound:: (# do execName[]->THIS(init).execNotFound #)#);
   
   beforeContinueActions.init; afterWaitActions.init;
   
   rd;
   
   processPathHandler.init;
   
   processComm.Init 
   (# forkFailed:: (# do THIS(init).forkFailed #);
      connectionTimedOut:: (# do THIS(init).connectionTimedOut->value #);
      wrongBetarunVersion:: (# do THIS(init).wrongBetarunVersion #);
   #);
      
   piPrivate.Init;
   
   DBmanager.init
   (# doingExpensiveRead:: (# do dbName[]->THIS(init).doingExpensiveRead #);
      doingCheapRead:: (# do dbName[]->THIS(init).doingCheapRead #);
      createFragInfo:: (# do THIS(init).createFragInfo -> value #);
      creationFailed:: (# do dbName[]->THIS(init).creationFailed #);
   #);
   
   &groupsInfoTableType[]->groupsInfo[];
   groupsInfo.init; groupsInfo[]->objectPool.put;
   utilities.init;
   
   executable.finishInit;
   
   INNER;
   
--- processInterfaceRerun:dopart ---
do
   (if not terminated then notTerminated if);
   
   rd;
   
   executable.reinit
   (# modtimeChanged:: (# do execName[]->THIS(rerun).modtimeChanged #);
      notFound:: (# do execName[]->THIS(rerun).execNotFound #)
   #);
   
   processComm.Init 
   (# forkFailed:: (# do THIS(rerun).forkFailed #)#);
   
   executable.finishInit;
   
   0->waitcount;
   
   INNER;
   
--- visibleGroups:dopart ---
do 
   
--- processInterfaceKill:dopart ---
do executable.kill; processComm.kill;
   
--- scanObjectFileInfos:descriptor ---
piPrivate.ObjectFileInfos.scan
(# 
do current[] -> THIS(scanObjectFileInfos).current[];
   INNER scanObjectFileInfos;
#)
 
--- codeAddressToObjectFileInfo:dopart ---
do adr->piPrivate.ObjectFileInfos.findByCodeAddress->ofi[]
   
--- dataAddressToObjectFileInfo:dopart ---
do adr->piPrivate.ObjectFileInfos.findByDataAddress->ofi[]
   
--- groupNameToObjectFileInfo:dopart ---
do groupName[]->piPrivate.ObjectFileInfos.findByName->ofi[]
   
--- uniqueGroupIDToObjectFileInfo:dopart ---
do (groupNameHash,checkTime)->piPrivate.ObjectFileInfos.findByID->ofi[]
   
--- fgFullNameToOFIname:dopart ---
do (fullName[],'~beta')->processPathHandler.localPath->fullName[];
   
--- OFIensureMaxLoadLevel:dopart ---
do (if loadLevel<LL_FULL then
       THIS(BasicObjectFileInfo)[]->processComm.loadProtoTable;
       THIS(BasicObjectFileInfo)[]->dbManager.readDB;
       groupName[]->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (fg[]=NONE)->fgLoadFailed;
       
       (* Ensure if possible that all groups in origin chain have been 
        * fully loaded as well: *)
       
       (if not fgLoadFailed then
           (# oriFG: ^mpsInterface.AST.fragmentGroup;
              oriName, t: ^Text;
              ori: ^ObjectFileInfo;
              
           do (if (fg.origin->oriFG[])<>NONE then
                  oriFG.fullName->fgFullNameToOFIname->oriName[];
                  oriName[]->mps.ast.expandtofullpath
                    ->groupNameToObjectFileInfo->ori[];
                  (if ori[]=NONE then
                      'UNEXPECTED: Failed to locate ORIGIN group '->t[];
                      oriName[]->t.putText;
                      ' in debugged process.'->t.putLine;
                      '(ORIGIN in '->t.putText;
                      groupName[]->t.putText;
                      ')'->t.putLine; t[]->otherError
                   else
                      ori[]->THIS(BasicObjectFileInfo).originOfi[];
                      ori.ensureMaxLoadLevel;
                  if);
              if);
           #);
       if);
   if);

--- findFragmentInfo:dopart ---
do
   dofind: scanFragments
   (# 
   do (if current.fragmentType=fragmentType then
          (if current.fragmentName[]->fragmentName.equalNCS then
              current[]->fi[]; leave dofind;
          if);
      if);
   #);
   
--- findDopartInfo:dopart ---
do 
   dofind:
     (for i:dopartCount repeat
          (if doparts[i].astRef=astRef then
              doparts[i][]->dpi[]; leave dofind;
          if);
     for);
