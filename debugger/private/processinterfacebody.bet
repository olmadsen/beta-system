ORIGIN '../processInterface';
LIB_ITEM 'valhallaprocess';
INCLUDE '~beta/basiclib/numberio';
INCLUDE '~beta/basiclib/formatio';
INCLUDE 'sorting';
INCLUDE '../remotedumper';

(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

(* PROCESSINTERFACEPRIVATE
 * ======================= *)
--debugstepbreakdp:dopart--
do false->value 
 
--- processInterfacePrivate:descriptor ---
(# 
   (* ObjectFileInfos
    * =============== *)
   
   ObjectFileInfos: @
     (# table: [50]^ObjectFileInfo;
        last: @Integer;
        insert: 
          (# ofi: ^ObjectFileInfo;
          enter ofi[]
          do (if (last+1 -> last) > table.range  then
                 table.range -> table.extend;
             if);
             ofi[] -> table[last][];
          #);
        scan:
          (# current: ^ObjectFileInfo; 
          do (for i:last repeat
                  table[i][] -> current[];
                  INNER;
             for)
          #);
        sort:
          (#
          do (1,last)->qsort
             (# swap:: 
                  (# temp: ^ObjectFileInfo;
                  do table[i][]->temp[];
                     table[j][]->table[i][];
                     temp[]->table[j][];
                  #);
                less::
                  (# 
                  do table[i].dataStart<table[j].dataStart->value;
                  #);
             #);
          #);
        findByID:
          (#  groupNameHash,checkTime: @Integer;
             found: ^ObjectFileInfo;
          enter (groupNameHash,checkTime)
          do NONE -> found[];
             find: scan
               (# 
               do 
                  (if (current.groupNameHash=groupNameHash)
                      and (current.checkTime=checkTime)  then
                      current[] -> found[];
                      leave find;
                  if);
               #);
          exit found[]
          #);
        findByName:
          (# name: ^Text;
             found: ^ObjectFileInfo;
          enter name[]
          do NONE -> found[];
             find: scan
               (# 
               do 
                  (if current.groupName[] -> name.equal  then
                      current[] -> found[];
                      leave find;
                  if);
               #);
          exit found[]
          #);
        findByDataAddress:
          (# adr: @Integer;
             found: ^ObjectFileInfo;
             low,mid,high: @Integer;
          enter adr
          do 1->low; last->high; (low+high) div 2 ->mid;
             binsearch:
               (if low=high then
                   table[low][]->found[];
                   (if found.dataStart<=adr then
                       (if adr<found.dataEnd then
                           leave binsearch;
                       if);
                   if);
                   NONE->found[];
                else
                   (if table[mid].dataEnd < adr then
                       mid+1->low;
                    else
                       mid->high;
                   if);
                   (low+high) div 2 ->mid;
                   restart binsearch;
               if);
          exit found[]
          #);
        findByCodeAddress:
          (# adr: @Integer;
             found: ^ObjectFileInfo;
             low,mid,high: @Integer;
          enter adr
          do 1->low; last->high; (low+high) div 2 ->mid;
             binsearch:
               (if low=high then
                   table[low][]->found[];
                   (if found.codeStart<=adr then
                       (if adr<found.codeEnd then
                           leave binsearch;
                       if);
                   if);
                   NONE->found[];
                else
                   (if table[mid].codeEnd < adr then
                       mid+1->low;
                    else
                       mid->high;
                   if);
                   (low+high) div 2 ->mid;
                   restart binsearch;
               if);
			   
			   
			 (if found[] = NONE then
			 	search: scan
					(#
					do (if current.codeStart <= adr then
					      (if adr < current.codeEnd then
						  	current[] -> found[];
							leave search;
					      if);
					    if);
					#);
			  if);
          exit found[]
          #);
     #);
   
   init:
     (# 
     do (if false (*'DebugDynamic'->getOption*) then
            'Finding debuggee address of M1PROGRAM (in main program): '
              ->screen.puttext;
            'M1PROGRAM' 
              -> processComm.Lookup_Address 
              -> screen.putint;
            screen.newline;
            'Finding debuggee address of M1BETAENV (in shared library): '
              ->screen.puttext;
            'M1BETAENV' 
              -> processComm.Lookup_Address 
              -> screen.putint;
            screen.newline;
        if);
        processComm.ScanGroups
        (# new: ^ObjectFileInfo; firstDone: @Boolean;
        do (if not firstDone then onDataSegmentScan; TRUE->firstDone if);
           &ObjectFileInfo[] -> new[];
           groupName[]->mps.ast.expandtofullpath -> new.groupName[];
           dataStart -> new.dataStart;
           dataEnd -> new.dataEnd;
           codeStart -> new.codeStart;
           codeEnd -> new.codeEnd;
           groupNameHash -> new.groupNameHash;
           checkTime -> new.checkTime;
           LL_INITIAL -> new.loadLevel;
           new[] -> ObjectFileInfos.insert;
        #);
        processComm.GetProgramGroupName->setSrcNameParam;
        ObjectFileInfos.sort;
        onDataSegmentScanDone;
     #);
#)

--- processInterfaceInit:dopart ---
do 
   (* Initialize executable and, if the readLabelsOnStartUp
    * option is TRUE, fork nm process to read and sort labels 
    * from the executable. It may work in parallel with other 
    * valhalla initialization. *)
	
   executable.init 
   (# notFound:: (# do execName[]->THIS(init).execNotFound #)#);
   
   beforeContinueActions.init; afterWaitActions.init;
   
   rd.init;
   
   
   processPathHandler.init;
     
   processComm.Init 
   (# forkFailed:: (# do THIS(init).forkFailed #);
      connectionTimedOut:: (# do THIS(init).connectionTimedOut->value #);
      wrongBetarunVersion:: 
        (# 
        do (if DebugValhalla then
               'processinterfacebody: wrong betarun version: ' -> screen.puttext;
               debuggeeVersion[] -> screen.putline;
           if);
           debuggeeVersion[] -> THIS(init).wrongBetarunVersion
        #);
   #);
   
      
   piPrivate.Init;
   
   (* check if exe.db file is present else leave *)
   (# de: @DiskEntry;
      dbName: ^Text;
      modTime: @Integer;
      warning:^text;
      is_nti: 
        (# target: ^Text;
        do machine_type->target[];
        exit ('nti_ms'->target.equal)
           or ('nti_gnu'->target.equal)
        #);
   do (* The following should be cleaned up, as it is also in DBmanager! *)
      (getSrcNAMEparam,NONE)->processPathHandler.convertFilePath->de.path;
      (* (getEXECNAMEparam,NONE)->processPathHandler.convertFilePath->de.path; *)
      de.path.head->dbName[]; directorychar->dbName.put;
      processComm.MachineType->dbName.append; directorychar->dbName.put;
      de.path.name;
      (if is_nti then
          de.path.name.prefix->dbName.append; (* forget the '.exe. *)
       else
          de.path.name->dbName.append
      if);
      '.db'->dbName.append->de.path;
      (if not de.exists  then
          'db file not found!'->screen.putline;
          dbName[]->exeDbMissing
      if)
   #);
   
   
   DBmanager.init
   (# doingExpensiveRead:: (# do dbName[]->THIS(init).doingExpensiveRead #);
      doingCheapRead:: (# do dbName[]->THIS(init).doingCheapRead #);
      createFragInfo:: (# do THIS(init).createFragInfo -> value #);
      creationFailed:: (# do dbName[]->THIS(init).creationFailed #);
   #);
   
   &groupsInfoTableType[]->groupsInfo[];
   groupsInfo.init; groupsInfo[]->objectPool.put;
   utilities.init;
   
   executable.finishInit;
   
   INNER;
   
--- processInterfaceRerun:dopart ---
do
   (if not terminated then notTerminated if);
   
   rd.init;
   
   executable.reinit
   (# modtimeChanged:: (# do execName[]->THIS(rerun).modtimeChanged #);
      notFound:: (# do execName[]->THIS(rerun).execNotFound #)
   #);
   
   processComm.Init 
   (# forkFailed:: (# do THIS(rerun).forkFailed #)#);
   
   executable.finishInit;
   
   0->waitcount;
   
   INNER;
   
--- visibleGroups:dopart ---
do 
   
--- processInterfaceKill:dopart ---
do executable.kill; processComm.kill;
   
--- scanObjectFileInfos:descriptor ---
piPrivate.ObjectFileInfos.scan
(# 
do current[] -> THIS(scanObjectFileInfos).current[];
   INNER scanObjectFileInfos;
#)
 
--- codeAddressToObjectFileInfo:dopart ---
do adr->piPrivate.ObjectFileInfos.findByCodeAddress->ofi[]
   
--- dataAddressToObjectFileInfo:dopart ---
do adr->piPrivate.ObjectFileInfos.findByDataAddress->ofi[]
   
--- groupNameToObjectFileInfo:dopart ---
do groupName[]->piPrivate.ObjectFileInfos.findByName->ofi[]
   
--- uniqueGroupIDToObjectFileInfo:dopart ---
do (groupNameHash,checkTime)->piPrivate.ObjectFileInfos.findByID->ofi[]
   
--- fgFullNameToOFIname:dopart ---
do (fullName[],'~beta')->processPathHandler.localPath->fullName[];
   
--- OFIensureMaxLoadLevel:dopart ---
do (if loadLevel<LL_FULL then
       THIS(BasicObjectFileInfo)[]->processComm.loadProtoTable;
       THIS(BasicObjectFileInfo)[]->dbManager.readDB;
       groupName[]->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (fg[]=NONE)->fgLoadFailed;
       
       (* Ensure if possible that all groups in origin chain have been 
        * fully loaded as well: *)
       
       (if not fgLoadFailed then
           (# oriFG: ^mpsInterface.AST.fragmentGroup;
              oriName, t: ^Text;
              ori: ^ObjectFileInfo;
              
           do (if (fg.origin->oriFG[])<>NONE then
                  oriFG.fullName->fgFullNameToOFIname->oriName[];
                  oriName[]->mps.ast.expandtofullpath
                    ->groupNameToObjectFileInfo->ori[];
                  (if ori[]=NONE then
                      'UNEXPECTED: Failed to locate ORIGIN group '->t[];
                      oriName[]->t.putText;
                      ' in debugged process.'->t.putLine;
                      '(ORIGIN in '->t.putText;
                      groupName[]->t.putText;
                      ')'->t.putLine; t[]->otherError
                   else
                      ori[]->THIS(BasicObjectFileInfo).originOfi[];
                      ori.ensureMaxLoadLevel;
                  if);
              if);
           #);
       if);
   if);

--- findFragmentInfo:dopart ---
do
   dofind: scanFragments
   (# 
   do (if current.fragmentType=fragmentType then
          (if current.fragmentName[]->fragmentName.equalNCS then
              current[]->fi[]; leave dofind;
          if);
      if);
   #);
   
--- findDopartInfo:dopart ---
do 
   dofind:
     (# myInt32:@integer;
     do
        (for ii:dopartCount repeat
             (if doparts[ii].astRef=astRef then
                 doparts[ii][]->dpi[]; leave dofind
             if);
        for);
     #)
