ORIGIN '../valhalla';

--- runnewdebuggee:descriptor ---
(#
do
   dorunNewDebuggee:
     (# 
     do
        TRUE->success;
        
        (if debuggee[]<>NONE then
            (if not debuggee.terminated then debuggee.kill if);
            (if not rerun then NONE->debuggee[] if);
        if);
        
        (if getEXECNAMEparam=NONE then
            (if newExecName=NONE then leave dorunNewDebuggee if);
        if);
        
        rerun and (debuggee[]<>NONE) -> rerun;
        
        doinit:
          (if not rerun then
              
              (if getPIDparam=0 then
                  (* Only edit commandline if the process is not
                   * already running. *)
                  doEditCommandLine 
              if);
              
              (if sources[]<>NONE then sources.close; NONE->sources[] if);
              gui.codeviews.newscan (# do cur.encl.tryclose #);              
              
              &gui.GUIprocess[]->debuggee[];
              
              debuggee.init
              (# doingExpensiveRead:: 
                   (# t: @Text;
                   do 'Creating debug info cache (%s)' -> t.putFormat
                      (# de: @diskEntry;
                      do dbName[]->de.path;
                         de.path.name->s; 
                      #);
                      t[]->gui.putinfo;
                   #);
                 doingCheapRead:: 
                   (# t: @Text;
                   do 'Reading debug info cache (%s)' -> t.putFormat
                      (# de: @diskEntry;
                      do dbName[]->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putinfo;
                   #);
                 timeoutcount: @Integer;
                 connectionTimedOut::
                   (# t: @Text;
                   do timeoutcount+1->timeoutcount;
                      (if timeoutcount=5 then
                          ('Connection timed out','Connection Error')
                            ->gui.alertinfo;
                          FALSE->value;
                       else
                          'Waiting (%d)'->t.putFormat
                          (# 
                          do timeoutCount->d;
                          #);
                          t[]->gui.putinfo;
                          TRUE->value;
                      if);
                   #);
                 createFragInfo:: TrueObject;
                 creationFailed::
                   (# t: @Text;
                   do 'Failed to create debug info cache (%s)'->t.putFormat
                      (# 
                      do dbName[]->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Debug Info Cache Error')
                        ->gui.alertinfo; 
                      TRUE->continue;
                   #);
                 execNotFound::
                   (# t: @Text;
                   do 'Executable `%s'' not found'->t.putFormat
                      (# 
                      do getEXECNAMEparam->s
                      #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')
                        ->gui.alertinfo; 
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
                 forkFailed::
                   (# t: @Text;
                   do 'Could not fork `%s'''->t.putFormat
                      (# de: @diskEntry;
                      do getEXECNAMEparam->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
              #);
           else
              debuggee.rerun
              (# execNotFound::
                   (# t: @Text;
                   do 'Executable `%s'' not found'->t.putFormat
                      (# 
                      do getEXECNAMEparam->s
                      #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')
                        ->gui.alertinfo; 
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
                 forkFailed::
                   (# t: @Text;
                   do 'Could not fork `%s'''->t.putFormat
                      (# de: @diskEntry;
                      do getEXECNAMEparam->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success; 
                      leave doinit;
                   #);
                 modtimeChanged::
                   (# 
                   do rereadprompt;
                      FALSE->rerun;
                      restart doinit;
                   #);
              #)
          if);
        
        (if not success then
            NONE->debuggee[];
            'No Process'->gui.putpinfo;
         else
            (# t: @Text;
            do 
               '`%s'' ready (PID=%d)'->t.putFormat
               (# de: @diskEntry;
               do getEXECNAMEparam->de.path;
                  de.path.name->s; 
                  getPIDparam->d;
               #);
               t[]->gui.putpinfo;
               ''->gui.putinfo;
            #)
        if);
        gui.main.status.setenabling;
     #)
#)

--- procwaiter: descriptor ---
(# tmp: @Text;
   impi: ^processInterface.ImperativeInfo;
do
   always:
     (# 
     do 
        waitersem.P;
        gui.main.status.setenabling;
        ''->gui.putinfo;
        
        waitloop:
          (# 
          do 
             debuggee.processComm.wait;
             
             (if debuggeeIsReady then
                 (if debuggee.notifyUserOnStop then
                     (if debuggee.bml.userBreakHit
                      //0//MNGR_USERSKIP then
                         (if debuggee.bml.skipBreakHit or stopped then
                             'Stopped'->gui.putpinfo;
                          else
                             tmp.clear;
                             'Runtime Error: %s'->tmp.putformat
                             (# dummy: @Integer;
                             do debuggee.error->(dummy,s);
                             #);
                             tmp[]->gui.putpinfo;
                         if);
                      else
                         tmp.clear;
                         'Stopped at breakpoint %d'->tmp.putformat
                         (# 
                         do debuggee.bml.userBreakHit->d
                         #);
                         tmp[]->gui.putpinfo;
                     if);
                     FALSE->stopped;
                     debuggee.currentRemoteCode->impi[];
                     (if impi[]<>NONE then
                         impi.cast[]->newcodemoveable
                         (# openIfNotFound::
                              (# 
                              do alwaysCurCode->gui.getOption->value;
                              #);
                            wriggleIfFound::
                              (# 
                              do (found[]<>lastEditor[])->value
                              #);
                         #);
                      else
                         (if alwaysCurCode->gui.getOption then
                             gui.debuggeeCurCode;
                         if);
                     if)
                  else
                     debuggee.processComm.continue;
                     restart waitloop;
                 if);
              else
                 'Terminated'->gui.putpinfo;
                 ('Process terminated','Terminated')->gui.alertinfo;
             if);
          #);
        gui.main.status.setenabling;
        restart always;
     #);
#)

--- newcodemoveable:dopart ---
do 
   findCode: gui.codeviews.newscan
     (# end::
          (# 
          do (if openIfNotFound then
                 getFrame
                 (# done::
                      (# mc: ^mycodeview;
                      do &mycodeview[]->mc[];
                         (gui.main.objworld[],result,debuggee[],cast[])
                           ->mc.open;
                         mc.contents.editor[]->lastEditor[];
                      #);
                 #);
             if)
          #);
     do (if cur.frag[]<>NONE then
            (if cur.frag.root[]->cast.frag.root.equal then
                (if cur[]->acceptFound then
                    cast[]->cur.select;
                    (if cur[]->wriggleIfFound then
                        cur.encl.onHighlight;
                    if);
                    cur[]->lastEditor[];
                    leave findCode;
                if);
            if);
        if);
     #);
   
--- newstackviewbody:dopart ---
do findStack: gui.stackviews.newscan
     (# end:: getFrame
          (# done::
               (# 
               do (gui.main.objworld[],result,debuggee[],comp[])
                    ->(&mystackview[]).open;
               #);
          #);
     do (if cur.component[]->comp.equal then
            cur.encl.onHighlight;
            leave findStack;
        if);
     #); 
   
--- debuggeeCurCode:descriptor ---
(#  impi: ^processInterface.ImperativeInfo;
   lldescription:
     (# txt: ^Text;
     do &Text[]->txt[];
        'address %d (%s).'->txt.putformat 
        (# name: ^Text; pc,value: @Integer;
        do debuggee.PC->pc->d;
           pc->debuggee.executable.labelAddressToName
             ->(name[],value);
           (if name[]<>NONE then
               name.copy->name[];
               '+'->name.append;
               pc-value->name.putInt;
               name[]->s;
            else
               '???'->s
           if);
        #); 
     exit txt[]
     #);
do (if curCodeStatus then
       debuggee.PC->debuggee.utilities.codeAddressToImperative
       (# onPartialMinfo::
            (# tmp: @Text; pti: ^processInterface.prototypeInfo;
            do 
               (if dp[]<>NONE then
                   (* Ok, at least we can show the dopart. *)
                   ('Unknown imperative. Showing surrounding dopart',
                   'Missing debug info')->alertInfo;
                   dp[]->newcodemoveable;
                else
                   ('Unable to show code.','Missing debug info')
                     ->alertInfo;
               if);
            #);
          onGentry::
            (# inf: @Text;
            do 'Object generation code (G entry) '->inf;
               lldescription->inf.append;
               (inf[],'No corresponding BETA source')->alertInfo;
            #);
          notBetaCode::
            (# inf: @Text;
            do 'Process stopped in non-BETA code '->inf;
               lldescription->inf.append;
               (inf[],'Not BETA code')->alertInfo;
            #);
       #)->impi[]; 
       (if impi[]<>NONE then impi.cast[]->newcodemoveable if);
   if)
#)
