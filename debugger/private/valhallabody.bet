ORIGIN '../valhalla';
LIB_ITEM 'valhalla';
INCLUDE '~beta/editor/codeeditor'
        '~beta/editor/private/nouser'
        '~beta/sourcebrowser/private/ymerPrivate'
        '~beta/toollibs/utils/architecture'

(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-98
 *   All rights reserved.
 *)
-- runnewdebuggee: Descriptor --
(#
   outline: @boolean;
   fg: ^gui.mps.ast.fragmentGroup;
   ff: ^gui.mps.ast.fragmentForm;
   execname:^text;
   warningmsg:^text;
   execf:@diskentry;
do
   getExecNameParam->execname[];
   execname[]->execf.path;
   (if execf.exists then (* check correct type of executable *)
       (if not (ExecName[]->is_native_executable) then
           NONE->debuggee[]->gui.debuggee[];
           'No Process'->gui.putpinfo;
           'Binary: '->warningmsg[];
           execname[]->warningmsg.puttext;
           ' is not a correct binary for this CPU!.\n'->warningmsg.puttext;
           'Seems to be of type: '->warningmsg.puttext;
           ExecName[]->type_of_executable->warningmsg.putline;
           warningmsg.newline;
           'Quit immediately (and recompile) to be able to continue debugging'
             ->warningmsg.puttext;
           (warningmsg[],'Warning')->gui.alertInfo;
           NONE->execname[];
       if);
    else  (* File does not exist *)
       'File: '->warningmsg[];
       execname[]->warningmsg.append;
       '. Does not exist!\nNo debuggee loaded!'
         ->warningmsg.puttext;
       (warningmsg[],'Warning')->gui.alertInfo;
       NONE->execname[]; 
   if);
   none->gui.debuggee[]; (* gram *)
   dorunNewDebuggee:
     (#
     do
        (if execname[]=NONE then (* wrong type of executable or not found*)
            FALSE->success;
            leave dorunNewDebuggee;
        if);
        TRUE->success;
        (if debuggee[] <> none then
            (if not debuggee.terminated then debuggee.kill if);
            (if not rerun then none ->debuggee[]->gui.debuggee[]; if); (* gram *)
            
        if);
        (if getEXECNAMEparam = none then
            (if newExecName = none then leave dorunNewDebuggee if); 
        if);
        rerun and (debuggee[] <> none )->rerun;
        doInit:
        (if not rerun then
            (if getPIDparam = 0 then
            (* Only edit commandline if the process is not
             * already running.
             * doEditCommandLine  *)
                
            if);
            (*
             * (if sources[]<>NONE then sources.close; NONE->sources[] if);
             *)
            gui.codeviews.newscan
              (#  do cur.encl.tryclose #);
            &gui.GUIprocess[]->debuggee[];
            none->gui.debuggee[]; (* gram, must be none to disable menus*)
            
            debuggeeInit:
            gui.mps[]
              ->debuggee.init
                (#
                   doingExpensiveRead:: 
                     (# t: @Text; 
                     do
                        'Creating debug info cache (%s)'
                          ->t.putFormat
                            (# de: @diskEntry
                            do dbName[]->de.path; de.path.name->s
                            #);
                        t[]->gui.putinfo;
                        
                     #);
                   doingCheapRead:: 
                     (# t: @Text; 
                     do
                        'Reading debug info cache (%s)'
                          ->t.putFormat
                            (# de: @diskEntry
                            do dbName[]->de.path; de.path.name->s
                            #);
                        t[]->gui.putinfo;
                        
                     #);
                   timeoutcount: @Integer;
                   connectionTimedOut:: 
                     (# t: @Text; 
                     do
                        timeoutcount+1->timeoutcount;
                        (if timeoutcount = 4 then
                            ('Connection timed out','Connection Error')
                              ->gui.alertinfo;
                            FALSE->value;
                            
                         else
                            'Waiting (%d)'
                              ->t.putFormat (#  do timeoutCount->d #);
                            t[]->gui.putinfo;
                            TRUE->value;
                            
                        if);
                        
                     #);
                   wrongBetarunVersion:: 
                     (# t: @Text; 
                     do
                        'This valhalla version requires the debugged process to be\nlinked with version '
                          ->t;
                        BETARUN_ID->t.append;
                        ' of the BETA runtime system'->t.append;
                        'Wrong BETA runtime system'->gui.putInfo;
                        (t[],'Version Error')->gui.alertinfo;
                        false->success;
                        leave debuggeeInit;
                        
                     #);
                   createFragInfo:: TrueObject;
                   creationFailed:: 
                     (# t: @Text; 
                     do
                        'Failed to create debug info cache (%s)'
                          ->t.putFormat (#  do dbName[]->s #);
                        t[]->gui.putInfo;
                        (t[],'Debug Info Cache Error')->gui.alertinfo;
                        TRUE->continue;
                        
                     #);
                   execNotFound:: 
                     (# t: @Text; 
                     do
                        'Executable `%s'' not found'
                          ->t.putFormat (#  do getEXECNAMEparam->s #);
                        t[]->gui.putInfo;
                        (t[],'Executable not found')->gui.alertinfo;
                        FALSE->success;
                        none ->debuggee[]->gui.debuggee[]; (* gram *)
                        leave debuggeeInit;
                        
                     #);
                   forkFailed:: 
                     (# t: @Text; 
                     do
                        'Could not fork `%s'''
                          ->t.putFormat
                            (# de: @diskEntry
                            do getEXECNAMEparam->de.path; de.path.name->s; 
                            #);
                        t[]->gui.putInfo;
                        (t[],'Fork Failure')->gui.alertinfo;
                        FALSE->success;
                        none ->debuggee[]->gui.debuggee[];
                        leave debuggeeInit;
                     #);
                   exeDbMissing::
                     (# t:@text;
                     do
                        'Debug information for executable not found\n'->t;
                        'File: '->t.append;
                        dbName[]->t.append;
                        '\n is necessary for debugging!\n'->t.append;
                        'Recompile executable without "-d" option and retry.'->t.append;
                        (t[],'Debugging impossible!')->gui.alertinfo;;
                        FALSE->success;
                        none -> debuggee[] -> gui.debuggee[];
                        leave debuggeeInit;
                     #);
                   
                #)->success;
            
         else
            debuggeeRerun:
            debuggee.rerun
              (#
                 execNotFound:: 
                   (# t: @Text; 
                   do
                      'Executable `%s'' not found'
                        ->t.putFormat (#  do getEXECNAMEparam->s #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')->gui.alertinfo;
                      FALSE->success;
                      none ->debuggee[];
                      leave debuggeeRerun;
                      
                   #);
                 forkFailed:: 
                   (# t: @Text; 
                   do
                      'Could not fork `%s'''
                        ->t.putFormat
                          (# de: @diskEntry
                          do getEXECNAMEparam->de.path; de.path.name->s
                          #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success;
                      leave debuggeeRerun;
                      
                   #);
                 modtimeChanged:: 
                   (#  do rereadprompt; FALSE->rerun; restart doinit;  #);
                 
              #)->success
        if);
        (if success then
              (# t: @Text; programFound: @boolean
              do
                 'Valhalla: Mjolner Source-level Debugger --  '->t;
                 getEXECNAMEparam->t.append;
                 t[]->gui.main.title;
                 ''->t;
                 '`%s'' ready (PID=%d)'
                   ->t.putFormat
                     (# de: @diskEntry; 
                     do
                        getEXECNAMEparam->de.path;
                        de.path.name->s;
                        getPIDparam->d;
                        
                     #);
                 t[]->gui.putpinfo;
                 ''->gui.putinfo;
                 debuggee[]->gui.debuggee[];
                 gui.main.status.setenabling;
                 ('program',debuggee.MPS.BETA.DescriptorForm)
                   ->debuggee.DBmanager.slotnameToGroups
                     (# 
                     do
                        true->programFound;
                        current[]
                          ->debuggee.mps.fragmentGroupTable.getFragmentGroup
                          ->fg[];
                        (if fg[] <> none then
                            ('program',screen[])->fg.open->ff[];
                            (if ff[] <> none then
                                dragOutlineOnOpen->gui.getOption->outline;
                                (dragOutlineOnOpen,false)->gui.setOption;
                                ff.root[]->gui.newCodeView;
                                (dragOutlineOnOpen,outline)->gui.setOption
                            if)
                        if);
                        
                     #);
                 (if not programFound then
                     'Missing debug info. "program" cannot be shown'
                       ->gui.putinfo;
                     (gui.main[],
                      'Missing .db file for main program fragment.\n"-- program: descriptor --" cannot be shown',
                      'Missing debug info')->gui.alertUser
                 if)
              #)
         else
            none ->debuggee[]; 'No Process'->gui.putpinfo; 
        if)
     #);
   debuggee[]->gui.debuggee[];
#)  

-- procwaiter: Descriptor --
(# tmp: @Text; impi: ^processInterface.ImperativeInfo; 
do
   always:
     (# 
     do
        waitersem.P;
        gui.main.status.setenabling;
        ''->gui.putinfo;
        waitloop:
          (# 
          do
             debuggee.processComm.wait
               (#
                  wrongMessage:: 
                    (# t: ^text
                    do
                       'Connection Broken'->gui.putpinfo;
                       'The connection to the debuggee has been disconnected.\n\n'
                         ->t[];
                       'If this is not what you expected, it might be an internal Valhalla error,\n'
                         ->t.puttext;
                       'in which case you should collect the details of this incident,\n'
                         ->t.puttext;
                       'and report them to support@mjolner.dk'->t.puttext;
                       (t[],'Connection Broken')->gui.alertinfo;
                       ensureKilled;
                       leave waitloop
                    #)
               #);
             (if debuggeeIsReady then
                 (if debuggee.notifyUserOnStop then
                     (if debuggee.bml.userBreakHit
                      // 0 // MNGR_USERSKIP then
                         (if debuggee.bml.skipBreakHit or stopped then
                             'Stopped'->gui.putpinfo; 
                          else
                             tmp.clear;
                             'Runtime Error: %s'
                               ->tmp.putformat
                                 (# dummy: @Integer; 
                                 do debuggee.error->(dummy,s); 
                                 #);
                             tmp[]->gui.putpinfo;
                             
                         if);
                         
                      else
                         tmp.clear;
                         'Stopped at breakpoint %d'
                           ->tmp.putformat
                             (#  do debuggee.bml.userBreakHit->d #);
                         tmp[]->gui.putpinfo;
                         
                     if);
                     FALSE->stopped;
                     debuggee.currentRemoteCode->impi[];
                     (if impi[] <> none then
                         impi.cast[]
                           ->newcodemoveable
                             (#
                                openIfNotFound:: 
                                  (# 
                                  do alwaysCurCode->gui.getOption->value; 
                                  #);
                                wriggleIfFound:: 
                                  (# 
                                  do
                                     (found[] <> lastEditor[])->value;
                                     found.bringToFront;
                                     
                                  #);
                                
                             #);
                         
                      else
                         (if alwaysCurCode->gui.getOption then
                             gui.debuggeeCurCode; 
                         if);
                         
                     if)
                  else
                     debuggee.processComm.continue; restart waitloop; 
                 if);
                 
              else
                 'Terminated'->gui.putpinfo;
                 ('Process terminated','Terminated')->gui.alertinfo;
                 
             if);
             
          #);
        gui.main.status.setenabling;
        restart always;
        
     #);
   
#)  

-- selectCodeView: DoPart --
do
     (# edenv: ^gui.main.editorEnv
     do
        gui.ymerPrivate.edenv[]->edenv[];
        (cast.frag[],cast.frag.root[],cast[],scv.contents[],
         (father[],cast.frag.father,true)->edenv.findOrCreateGroupEditor)
          ->edenv.findOrCreateFormEditor;
        cast.frag.name->scv.label;
        cast[]->scv.contents.select;
        
     #)  

-- selectObjectView: DoPart --
do   

-- newcodemoveable: DoPart --
do
   findCode: gui.codeviews.newscan
     (#
        end:: 
          (# 
          do
             (if openIfNotFound then
                 getFrame
                   (#
                      done:: 
                        (# mc: ^mycodeview; 
                        do
                           &mycodeview[]->mc[];
                           (gui.main.objworld[],result,cast[])->mc.open;
                           cast[]->mc.selectNode;
                           mc.contents.editor[]->lastEditor[];
                           
                        #);
                      
                   #);
                 
             if)
          #);
        
     do
        (if cur.frag[] <> none then
            (if cur.frag.root[]->cast.frag.root.equal then
                (if cur[]->acceptFound then
                    cast[]->cur.select;
                    (if cur[]->wriggleIfFound then cur.encl.onHighlight;  if);
                    cur[]->lastEditor[];
                    leave findCode;
                    
                if);
                
            if);
            
        if);
        
     #);
     

-- newobjectmoveable: DoPart --
do
   findObject: gui.objectviews.newscan
     (#
        end:: 
          (# 
          do
             (if openIfNotFound then
                 (bo[],true)
                   ->gui.main.OpenMoveableObjectView
                     (#
                        getFather::  (#  do gui.main.objworld[]->father[] #)
                     #)
             if)
          #);
        
     do
        (if cur.bo[] <> none then
            (if cur.bo[] = bo[] then
                (if cur[]->acceptFound then
                    (if cur[]->wriggleIfFound then cur.encl.onHighlight;  if);
                    leave findObject;
                    
                if);
                
            if);
            
        if);
        
     #);
     

-- newstackviewbody: DoPart --
do
   findStack: gui.stackviews.newscan
     (#
        end:: getFrame
          (#
             done:: 
               (# 
               do
                  (gui.main.objworld[],result,debuggee[],comp[])
                    ->(&mystackview[]).open;
                  
               #);
             
          #);
        
     do
        (if cur.component[]->comp.equal then
            cur.encl.onHighlight; leave findStack; 
        if);
        
     #);
     

-- newstackbrowserbody: DoPart --
do
(*findStack: gui.stackviews.newscan
 (# end:: getFrame
 (# done::
 (# 
 do (gui.main.objworld[],result,debuggee[],comp[])
 ->(&mystackview[]).open;
 #);
 #);
 do (if cur.component[]->comp.equal then
 cur.encl.onHighlight;
 leave findStack;
 if);
 #);*)
   getFrame
     (#
        done:: 
          (# 
          do
             (gui.main.objworld[],result,debuggee[],comp[])
               ->(&mystackbrowser[]).open;
             
          #);
        
     #);
     

-- debuggeeCurCode: Descriptor --
(#
   impi: ^processInterface.ImperativeInfo;
   lldescription:
     (# txt: ^Text; 
     do
        &Text[]->txt[];
        'address %d (%s).'
          ->txt.putformat
            (# name: ^Text; pc,value: @Integer; 
            do
               debuggee.PC->pc->d;
               pc->debuggee.executable.labelAddressToName->(name[],value);
               (if name[] <> none then
                   name.copy->name[];
                   '+'->name.append;
                   pc-value->name.putInt;
                   name[]->s;
                   
                else
                   '???'->s
               if);
               
            #);
        
     exit txt[]
     #);
   
do
   (if curCodeStatus then
       debuggee.PC
         ->debuggee.utilities.codeAddressToImperative
           (#
              onPartialMinfo:: 
                (# tmp: @Text; pti: ^processInterface.prototypeInfo; 
                do
                   (if dp[] <> none then
                   (* Ok, at least we can show the dopart. *)
                       ('Unknown imperative. Showing surrounding dopart',
                        'Missing debug info')->alertInfo;
                       dp[]->newcodemoveable;
                    else
                       ('Unable to show code.','Missing debug info')->alertInfo;
                   if);
                #);
              onGentry:: 
                (# inf: @Text; pti:^processInterface.PrototypeInfo;
                   a:^mps.BETACFL.PatternDecl;
                   n:^mps.ast.nameDecl;
                do
                   'Object generation code (G entry) '->inf;
                   lldescription->inf.append;
                   '\n'->inf.put;
                   'Runtime error occured! Maybe while allocating object:\n'->inf.append;
                   '(# t:^p; s:@t.i do ... #),  s is the problem since t is none!\n'->inf.append;
                   'Could be in pattern named: '->inf.append;
                   'Unknown!'->inf.putline;
                   protoAdr
                     ->debuggee.utilities.ProtoAddressToPrototypeInfo
                     ->pti[];

                   '\nIn file '->inf.append;
                   (if pti[]<>none then
                       pti.ofi.groupname[]->inf.append;
                       '.bet'->inf.append;
                       (if pti.objdesc[]<>NONE then
                           (* show descriptor *)
                           pti.objdesc[]->newcodemoveable;
                           '\nShowing objectdescriptor.'->inf.append;
                           (*
                            * '11'->putline;
                            pti.objdesc.father->a[];
                            '22'->putline;
                            a.kind->putint;newline;
                            pti.objdesc.kind->putint;
                            a.getnames->n[];
                            '33'->putline;
                            n.gettext->putline;
                            '44'->putline;
                            *)
                       if);
                    else
                       'unknown'->inf.append;
                   if);
                   (inf[],'No corresponding BETA source')->alertInfo;
                #);
              notBetaCode:: 
                (# inf: @Text; 
                do
                   'Process stopped in non-BETA code '->inf;
                   lldescription->inf.append;
                   (inf[],'Not BETA code')->alertInfo;
                #);
           #)->impi[];
       (if impi[] <> none then impi.cast[]->newcodemoveable if);
       
   if)
#)  

-- mycodeviewPrivate: Descriptor --
(#
   cfe: ^gui.main.codeeditor;
   ge: ^gui.main.editorEnv.groupEditor;
   edenv: ^gui.main.editorEnv;
   
#)  

-- mycodeviewWriggle: DoPart --
do contents.editor[]->lastEditor[];   

-- mycodeviewSelectNode: DoPart --
do
   gui.ymerPrivate.edenv[]->private.edenv[];
   (THIS(mycodeview)[],node.frag.father,true)
     ->private.edenv.findOrCreateGroupEditor->private.ge[];
   (node.frag[],node.frag.root[], (*node[]*) none ,contents.editor[],
    private.ge[])->private.edenv.findOrCreateFormEditor->private.cfe[];
   (* rettet af fgc, for at sifeditor expander 2 niveauer
    * hvis det er roden. (forste gang et codevindue vises)
    *)
   node[]->contents.editor.select;
     

