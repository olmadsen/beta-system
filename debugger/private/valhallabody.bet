ORIGIN '../valhalla';
INCLUDE '~beta/editor/v5.2/codeeditor';
INCLUDE '~beta/editor/v5.2/private/nouser';
INCLUDE '~beta/sourcebrowser/v1.2/private/ymerPrivate';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- runnewdebuggee:descriptor ---
(# outline: @boolean;
   fg: ^gui.mps.ast.fragmentGroup;
   ff: ^gui.mps.ast.fragmentForm;
do
   dorunNewDebuggee:
     (# 
     do
        TRUE->success;
        
        (if debuggee[]<>NONE then
            (if not debuggee.terminated then debuggee.kill if);
            (if not rerun then NONE->debuggee[] if);
        if);
        
        (if getEXECNAMEparam=NONE then
            (if newExecName=NONE then leave dorunNewDebuggee if);
        if);
        
        rerun and (debuggee[]<>NONE) -> rerun;
        
        doinit:
          (if not rerun then
              
              (if getPIDparam=0 then
                  (* Only edit commandline if the process is not
                   * already running.
                   * doEditCommandLine  *)
              if);
               
              (*
               * (if sources[]<>NONE then sources.close; NONE->sources[] if);
               *)
              gui.codeviews.newscan(# do cur.encl.tryclose #);
              
              &gui.GUIprocess[]->debuggee[];
              
              gui.mps[]->debuggee.init
              (# doingExpensiveRead:: 
                   (# t: @Text;
                   do 'Creating debug info cache (%s)' -> t.putFormat
                      (# de: @diskEntry;
                      do dbName[]->de.path;
                         de.path.name->s; 
                      #);
                      t[]->gui.putinfo;
                   #);
                 doingCheapRead:: 
                   (# t: @Text;
                   do 'Reading debug info cache (%s)' -> t.putFormat
                      (# de: @diskEntry;
                      do dbName[]->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putinfo;
                   #);
                 timeoutcount: @Integer;
                 connectionTimedOut::
                   (# t: @Text;
                   do timeoutcount+1->timeoutcount;
                      (if timeoutcount=5 then
                          ('Connection timed out','Connection Error')
                            ->gui.alertinfo;
                          FALSE->value;
                       else
                          'Waiting (%d)'->t.putFormat
                          (# 
                          do timeoutCount->d;
                          #);
                          t[]->gui.putinfo;
                          TRUE->value;
                      if);
                   #);
                 wrongBetarunVersion::
                   (# t: @Text;
                   do
                      'This valhalla version requires the debugged process to be\nlinked with version '->t;
                      BETARUN_ID->t.append;
                      ' of the BETA runtime system'->t.append;
                      'Wrong BETA runtime system'->gui.putInfo;
                      (t[],'Version Error')->gui.alertinfo;
                      false->success;
                      leave doinit;
                   #);
                 createFragInfo:: TrueObject;
                 creationFailed::
                   (# t: @Text;
                   do 'Failed to create debug info cache (%s)'->t.putFormat
                      (# 
                      do dbName[]->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Debug Info Cache Error')
                        ->gui.alertinfo; 
                      TRUE->continue;
                   #);
                 execNotFound::
                   (# t: @Text;
                   do 'Executable `%s'' not found'->t.putFormat
                      (# 
                      do getEXECNAMEparam->s
                      #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')
                        ->gui.alertinfo; 
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
                 forkFailed::
                   (# t: @Text;
                   do 'Could not fork `%s'''->t.putFormat
                      (# de: @diskEntry;
                      do getEXECNAMEparam->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
              #)->success;
           else
              debuggee.rerun
              (# execNotFound::
                   (# t: @Text;
                   do 'Executable `%s'' not found'->t.putFormat
                      (# 
                      do getEXECNAMEparam->s
                      #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')
                        ->gui.alertinfo; 
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
                 forkFailed::
                   (# t: @Text;
                   do 'Could not fork `%s'''->t.putFormat
                      (# de: @diskEntry;
                      do getEXECNAMEparam->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success; 
                      leave doinit;
                   #);
                 modtimeChanged::
                   (# 
                   do rereadprompt;
                      FALSE->rerun;
                      restart doinit;
                   #);
              #)->success
          if);
        
        (if success then
            (# t: @Text;
            do 
               '`%s'' ready (PID=%d)'->t.putFormat
               (# de: @diskEntry;
               do getEXECNAMEparam->de.path;
                  de.path.name->s; 
                  getPIDparam->d;
               #);
               t[]->gui.putpinfo;
               ''->gui.putinfo;
            #);
            debuggee[]->gui.debuggee[];
            gui.main.status.setenabling;
            
            ('program',debuggee.MPS.BETA.DescriptorForm)
              ->debuggee.DBmanager.slotnameToGroups
            (# 
            do current[]
                 ->debuggee.mps.fragmentGroupTable.getFragmentGroup
                 ->fg[];
               (if fg[]<>none then
                   ('program',screen[])->fg.open->ff[];
                   (if ff[]<>none then
                       dragOutlineOnOpen->gui.getOption->outline;
                       (dragOutlineOnOpen,false)->gui.setOption;
                       ff.root[]->gui.newCodeView;
                       (dragOutlineOnOpen,outline)->gui.setOption
                   if)
               if);
            #);
         else
            NONE->debuggee[];
            'No Process'->gui.putpinfo;
        if)
     #)
#)

--- procwaiter: descriptor ---
(# tmp: @Text;
   impi: ^processInterface.ImperativeInfo;
do
   always:
     (# 
     do 
        waitersem.P;
        gui.main.status.setenabling;
        ''->gui.putinfo;
        
        waitloop:
          (# 
          do 
             debuggee.processComm.wait
             (# wrongMessage::
                  (# t: ^text
                  do 'Connection Broken'->gui.putpinfo;
                     'The connection to the debuggee has been disconnected.\n\n'->t[];
                     'If this is not what you expected, it might be an internal Valhalla error,\n'->t.puttext;
                     'in which case you should collect the details of this incident,\n'->t.puttext;
                     'and report them to support@mjolner.dk'->t.puttext;
                     (t[],'Connection Broken')->gui.alertinfo;
                     ensureKilled;
                     leave waitloop
                  #)
             #);
             
             (if debuggeeIsReady then
                 (if debuggee.notifyUserOnStop then
                     (if debuggee.bml.userBreakHit
                      //0//MNGR_USERSKIP then
                         (if debuggee.bml.skipBreakHit or stopped then
                             'Stopped'->gui.putpinfo;
                          else
                             tmp.clear;
                             'Runtime Error: %s'->tmp.putformat
                             (# dummy: @Integer;
                             do debuggee.error->(dummy,s);
                             #);
                             tmp[]->gui.putpinfo;
                         if);
                      else
                         tmp.clear;
                         'Stopped at breakpoint %d'->tmp.putformat
                         (# 
                         do debuggee.bml.userBreakHit->d
                         #);
                         tmp[]->gui.putpinfo;
                     if);
                     FALSE->stopped;
                     debuggee.currentRemoteCode->impi[];
                     (if impi[]<>NONE then
                         impi.cast[]->newcodemoveable
                         (# openIfNotFound::
                              (# 
                              do alwaysCurCode->gui.getOption->value;
                              #);
                            wriggleIfFound::
                              (# 
                              do (found[]<>lastEditor[])->value;
                                 found.bringToFront;
                              #);
                         #);
                      else
                         (if alwaysCurCode->gui.getOption then
                             gui.debuggeeCurCode;
                         if);
                     if)
                  else
                     debuggee.processComm.continue;
                     restart waitloop;
                 if);
              else
                 'Terminated'->gui.putpinfo;
                 ('Process terminated','Terminated')->gui.alertinfo;
             if);
          #);
        gui.main.status.setenabling;
        restart always;
     #);
#)

--- selectCodeView: dopart ---
do (# edenv: ^gui.main.editorEnv
   do gui.ymerPrivate.edenv[]->edenv[];
      (cast.frag[],cast.frag.root[],cast[],scv.contents[]
      ,(father[],cast.frag.father,true)
        ->edenv.findOrCreateGroupEditor)
        ->edenv.findOrCreateFormEditor;
      cast.frag.name->scv.label;
      cast[]->scv.contents.select;
   #)

--- selectObjectView: dopart ---
do 
      
--- newcodemoveable:dopart ---
do findCode: gui.codeviews.newscan
     (# end::
          (# 
          do (if openIfNotFound then
                 getFrame
                 (# done::
                      (# mc: ^mycodeview;
                      do &mycodeview[]->mc[];
                         (gui.main.objworld[],result,cast[])->mc.open;
                         cast[]->mc.selectNode;
                         mc.contents.editor[]->lastEditor[];
                      #);
                 #);
             if)
          #);
     do (if cur.frag[]<>NONE then
            (if cur.frag.root[]->cast.frag.root.equal then
                (if cur[]->acceptFound then
                    cast[]->cur.select;
                    (if cur[]->wriggleIfFound then
                        cur.encl.onHighlight;
                    if);
                    cur[]->lastEditor[];
                    leave findCode;
                if);
            if);
        if);
     #);
   
--- newobjectmoveable:dopart ---
do findObject: gui.objectviews.newscan
     (# end::
          (# 
          do (if openIfNotFound then
                 (bo[],true)->gui.main.OpenMoveableObjectView
                 (# getFather:: (# do gui.main.objworld[]->father[]#)#)
             if)
          #);
     do (if cur.bo[]<>NONE then
            (if cur.bo[]=bo[] then
                (if cur[]->acceptFound then
                    (if cur[]->wriggleIfFound then
                        cur.encl.onHighlight;
                    if);
                    leave findObject;
                if);
            if);
        if);
     #);
   
--- newstackviewbody:dopart ---
do findStack: gui.stackviews.newscan
     (# end:: getFrame
          (# done::
               (# 
               do (gui.main.objworld[],result,debuggee[],comp[])
                    ->(&mystackview[]).open;
               #);
          #);
     do (if cur.component[]->comp.equal then
            cur.encl.onHighlight;
            leave findStack;
        if);
     #); 
   
--- newstackbrowserbody:dopart ---
do (*findStack: gui.stackviews.newscan
     (# end:: getFrame
          (# done::
               (# 
               do (gui.main.objworld[],result,debuggee[],comp[])
                    ->(&mystackview[]).open;
               #);
          #);
     do (if cur.component[]->comp.equal then
            cur.encl.onHighlight;
            leave findStack;
        if);
     #);*)
   getFrame
   (# done::
        (# 
        do (gui.main.objworld[],result,debuggee[],comp[])
             ->(&mystackbrowser[]).open;
        #);
   #);
   
--- debuggeeCurCode:descriptor ---
(#  impi: ^processInterface.ImperativeInfo;
   lldescription:
     (# txt: ^Text;
     do &Text[]->txt[];
        'address %d (%s).'->txt.putformat 
        (# name: ^Text; pc,value: @Integer;
        do debuggee.PC->pc->d;
           pc->debuggee.executable.labelAddressToName
             ->(name[],value);
           (if name[]<>NONE then
               name.copy->name[];
               '+'->name.append;
               pc-value->name.putInt;
               name[]->s;
            else
               '???'->s
           if);
        #); 
     exit txt[]
     #);
do (if curCodeStatus then
       debuggee.PC->debuggee.utilities.codeAddressToImperative
       (# onPartialMinfo::
            (# tmp: @Text; pti: ^processInterface.prototypeInfo;
            do 
               (if dp[]<>NONE then
                   (* Ok, at least we can show the dopart. *)
                   ('Unknown imperative. Showing surrounding dopart',
                   'Missing debug info')->alertInfo;
                   dp[]->newcodemoveable;
                else
                   ('Unable to show code.','Missing debug info')
                     ->alertInfo;
               if);
            #);
          onGentry::
            (# inf: @Text;
            do 'Object generation code (G entry) '->inf;
               lldescription->inf.append;
               (inf[],'No corresponding BETA source')->alertInfo;
            #);
          notBetaCode::
            (# inf: @Text;
            do 'Process stopped in non-BETA code '->inf;
               lldescription->inf.append;
               (inf[],'Not BETA code')->alertInfo;
            #);
       #)->impi[];
       (if impi[]<>NONE then impi.cast[]->newcodemoveable if);
   if)
#)
   
--- mycodeviewPrivate: descriptor ---
(# cfe: ^gui.main.codeeditor;
   ge: ^gui.main.editorEnv.groupEditor;
   edenv: ^gui.main.editorEnv;
#)

--- mycodeviewWriggle: dopart ---
do contents.editor[]->lastEditor[];
   
--- mycodeviewSelectNode: dopart ---
do gui.ymerPrivate.edenv[]->private.edenv[];
   (this(mycodeview)[],node.frag.father,true)
     ->private.edenv.findOrCreateGroupEditor
     ->private.ge[];
   (node.frag[],node.frag.root[],node[],contents.editor[],private.ge[])
     ->private.edenv.findOrCreateFormEditor
     ->private.cfe[];
   node[]->contents.editor.select;
