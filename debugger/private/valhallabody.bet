ORIGIN '../valhalla';
INCLUDE '~beta/editor/v5.1.1/codeeditor';
INCLUDE '~beta/editor/v5.1.1/private/nouser';
INCLUDE '~beta/sourcebrowser/v1.1.1/private/ymerPrivate';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- debuggeeChangedSources: descriptor ---
(# fileChangedOutside: booleanValue
     (# fg: ^astInterface.fragmentGroup;
        diskfile,textfile: @file;
        t: @text
     enter fg[]
     do fg.diskfilename->diskfile.name;
        fg.textfilename->textfile.name;
        (if textfile.entry.exists and
            (textfile.entry.modTime > execModtime) then
            t.clear;
            'Source file: '->t.puttext;
            fg.textfilename->t.putline;
            'has been changed since last compilation of the executable!'->t.putline;
            t.newLine;
            'Quit immediately (and recompile) to avoid further problems'
              ->t.puttext;
            (t[],'Warning')->gui.alertinfo; 
            true->value
         else
            (if diskfile.entry.exists then
                (if (diskfile.entry.modTime > execModtime) then
                    t.clear;
                    'Group file: '->t.puttext;
                    fg.diskfilename->t.putline;
                    'has been changed since last compilation of the executable!'->t.putline;
                    t.newLine;
                    'Quit immediately (and recompile) to avoid further problems'
                      ->t.puttext;
                    (t[],'Warning')->gui.alertinfo; 
                    true->value
                if)
             else
                t.clear;
                'Group file: '->t.puttext;
                fg.diskfilename->t.putline;
                'has been deleted!'->t.putline;
                t.newLine;
                'Quit immediately (and re-establish the file) to avoid further problems'
                  ->t.puttext;
                (t[],'Warning')->gui.alertinfo; 
                true->value
            if)
        if)
     #);
   execFG: ^astInterface.fragmentGroup; execModtime: @integer;
do FN[]
     ->gui.mps.fragmentGroupTable.getFragmentGroup
     ->execFG[];
   execFG.modtime->execModtime;
   scanningDG:
     FN[]->gui.mps.AST.expandToFullPath
     ->gui.mps.DG.scanExtent
   (# warn: ^text;
      Report:
        (# msg: ^text
        enter msg[]
        do
           (msg[],'Dependency graph error')->gui.alertinfo; 
           true->otherError;
           leave scanningDG
        #);
      startingParsingNotification::  (#  do  #);
      reloadingNotification::  (#  do false->doReload #);
      DoubleFormException::  (#  do true->continue #);
      transAccessException:: 
        (# 
        do 'No read access to: '->warn[];
           FN[]->warn.putline;
           true->continue;
           warn[]->Report
        #);
      circularDependencyException:: 
        (# 
        do 'Circular dependency: '->warn[];
           fg.name->warn.putline;
           true->continue;
           warn[]->Report
        #);
      unknownPropertyException::  (#  do true->continue #);
      emptyFragmentException::  (#  do true->continue #);
      parseException:: 
        (# 
        do 'File: "'->warn[];
           fullFN[]->warn.puttext;
           '" needs to be parsed'->warn.putline;
           true->continue;
           true->otherError;
           warn[]->Report;
           leave scanningDG
        #);
      transCreateDirException:: 
        (# 
        do 'Unable to create directory: '->warn[];
           FN[]->warn.putline;
           true->continue;
           warn[]->Report
        #);
      MPSexception:: 
        (# 
        do 'MPS overflow - '->warn[];
           T[]->warn.puttext;
           ' too large)'->warn.putline;
           true->continue;
           warn[]->Report
        #);
      notExistingException:: 
        (# 
        do 'Not a fragment file: '->warn[];
           fullFN[]->warn.putline;
           true->continue;
           warn[]->Report
        #);
      noSpaceException:: 
        (# 
        do 'No space on disk'->warn[];
           true->continue;
           warn[]->Report
        #);
        fragmentException::
        (* Note that the group is closed here.
         * Sif and other tools may NOT want to do this!
         *) 
        (# keepMsg: ^text
        do (*CloseGroup;*)
           msg.copy->keepMsg[];
           msg.clear;
           (if errNo
            // 1 then
               'Two or more slots have the name: '->msg.puttext;
               slot.name->msg.puttext;
            // 2 then
               'No free slot found for: '->msg.Puttext;
               FF.name->msg.puttext;
            // 3 then
               'Category of fragment: '->msg.puttext;
               FF.name->msg.puttext;
               ' does not correspond to category of slot'
                 ->msg.puttext;
            // 4 then
               'The slot: '->msg.Puttext;
               FF.name->msg.puttext;
               ' Is already bound'->msg.Puttext
            // 5 then
               'Category of: '->msg.Puttext;
               FF.name->msg.Puttext;
               ' must be either: '->msg.Putline;
               'Descriptor (ObjectDescriptor, DescriptorForm) or '
                 ->msg.puttext;
               'Attributes (AttributeDecl, AttributesForm)'
                 ->msg.putline;
            // 6 then
               'Category of the following slot is not supported!\n\n\t'
                 ->msg.putText;
               slot.name->msg.putLine;
               '\nCategory must be: descriptor, attributes or doPart'
                 ->msg.putLine
            // 7 then
               'Warning: mainPart-slots are NOT fully supported!'
                 ->msg.putLine
           if);
           (if slot[] <> none then
               msg[]->Report
            else
               (if ff[] <> none then
                   msg[]->Report
                else
                   (if fg[] <> none then
                       msg[]->Report
                    else
                       'fragmentException: '->putText;
                       errNo->putInt;
                       ': '->putLine;
                       keepMsg[]->putLine;
                       keepMsg[]->report
                   if)
               if)
           if)
        #);
      propertyException:: 
        (# keepMsg: ^text
        do msg.copy->keepMsg[];
           msg.clear;
           (if n
            // 1 then
               'Two or more origins are specified:\n\t'
                 ->msg.puttext;
               (# g: ^astInterface.fragment; 
               do FG.origin->g[]; g.name->msg.puttext; 
               #);
               '\n\t'->msg.puttext;
                 t[]->msg.putline
            // 2 then
               'The reserved property name "'->msg.puttext;
               t.makeUC;
               t[]->msg.puttext;
               '"\n\tappears in the property list for '
                 ->msg.puttext;
               p.makeUC;
               p[]->msg.puttext;
            // 3 then
               'Illegal "'->msg.puttext;
               p.makeUC;
               p[]->msg.puttext;
               '" property: "'->msg.puttext;
               t.makeUC;
               t[]->msg.puttext;
               '"\n'->msg.puttext
            // 4 then
               'Empty filename in property "'->msg.puttext;
               p.makeUC;
               p[]->msg.puttext;
               '"'->msg.put;
               msg.newline;
            // 5 then
               'Unrecognised property: '->Msg.Puttext;
               p[]->Msg.Putline;
               true->warning
            // 6 then
               'Property "'->msg.puttext;
               p[]->msg.puttext;
               '" has no value for "'->msg.putText;
               t[]->msg.putText;
               '"\n'->msg.putLine;
               true->warning
           if);
           (if not warning then
               '\n\n\tA ";" may be missing before '
                 ->msg.puttext;
               t[]->msg.putline;
           if);
           (if fg[] <> none then
               msg[]->Report
            else
               'propertyException: '->putText;
               n->putInt;
               ': '->putLine;
               keepMsg[]->putLine;
               keepMsg[]->report
           if)
        #)
   do (if current[]->fileChangedOutside->changedOutSide then
          leave scanningDG
      if)
   #)
#)

--- runnewdebuggee:descriptor ---
(# outline: @boolean;
   fg: ^gui.mps.ast.fragmentGroup;
   ff: ^gui.mps.ast.fragmentForm;
do
   dorunNewDebuggee:
     (# 
     do
        TRUE->success;
        
        (if debuggee[]<>NONE then
            (if not debuggee.terminated then debuggee.kill if);
            (if not rerun then NONE->debuggee[] if);
        if);
        
        (if getEXECNAMEparam=NONE then
            (if newExecName=NONE then leave dorunNewDebuggee if);
        if);
        
        rerun and (debuggee[]<>NONE) -> rerun;
        
        doinit:
          (if not rerun then
              
              
              (if getPIDparam=0 then
                  (* Only edit commandline if the process is not
                   * already running. *)
                  doEditCommandLine 
              if);
               
               (*
               * (if sources[]<>NONE then sources.close; NONE->sources[] if);
               *)
              gui.codeviews.newscan(# do cur.encl.tryclose #);
              
              &gui.GUIprocess[]->debuggee[];
              
              gui.mps[]->debuggee.init
              (# doingExpensiveRead:: 
                   (# t: @Text;
                   do 'Creating debug info cache (%s)' -> t.putFormat
                      (# de: @diskEntry;
                      do dbName[]->de.path;
                         de.path.name->s; 
                      #);
                      t[]->gui.putinfo;
                   #);
                 doingCheapRead:: 
                   (# t: @Text;
                   do 'Reading debug info cache (%s)' -> t.putFormat
                      (# de: @diskEntry;
                      do dbName[]->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putinfo;
                   #);
                 timeoutcount: @Integer;
                 connectionTimedOut::
                   (# t: @Text;
                   do timeoutcount+1->timeoutcount;
                      (if timeoutcount=5 then
                          ('Connection timed out','Connection Error')
                            ->gui.alertinfo;
                          FALSE->value;
                       else
                          'Waiting (%d)'->t.putFormat
                          (# 
                          do timeoutCount->d;
                          #);
                          t[]->gui.putinfo;
                          TRUE->value;
                      if);
                   #);
                 wrongBetarunVersion::
                   (# t: @Text;
                   do
                      'This valhalla version requires the debugged process to be\nlinked with version '->t;
                      BETARUN_ID->t.append;
                      ' of the BETA runtime system'->t.append;
                      'Wrong BETA runtime system'->gui.putInfo;
                      (t[],'Version Error')->gui.alertinfo;
                      false->success;
                      leave doinit;
                   #);
                 createFragInfo:: TrueObject;
                 creationFailed::
                   (# t: @Text;
                   do 'Failed to create debug info cache (%s)'->t.putFormat
                      (# 
                      do dbName[]->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Debug Info Cache Error')
                        ->gui.alertinfo; 
                      TRUE->continue;
                   #);
                 execNotFound::
                   (# t: @Text;
                   do 'Executable `%s'' not found'->t.putFormat
                      (# 
                      do getEXECNAMEparam->s
                      #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')
                        ->gui.alertinfo; 
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
                 forkFailed::
                   (# t: @Text;
                   do 'Could not fork `%s'''->t.putFormat
                      (# de: @diskEntry;
                      do getEXECNAMEparam->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
              #);
           else
              debuggee.rerun
              (# execNotFound::
                   (# t: @Text;
                   do 'Executable `%s'' not found'->t.putFormat
                      (# 
                      do getEXECNAMEparam->s
                      #);
                      t[]->gui.putInfo;
                      (t[],'Executable not found')
                        ->gui.alertinfo; 
                      FALSE->success; 
                      NONE->debuggee[];
                      leave doinit;
                   #);
                 forkFailed::
                   (# t: @Text;
                   do 'Could not fork `%s'''->t.putFormat
                      (# de: @diskEntry;
                      do getEXECNAMEparam->de.path;
                         de.path.name->s;
                      #);
                      t[]->gui.putInfo;
                      (t[],'Fork Failure')->gui.alertinfo;
                      FALSE->success; 
                      leave doinit;
                   #);
                 modtimeChanged::
                   (# 
                   do rereadprompt;
                      FALSE->rerun;
                      restart doinit;
                   #);
              #)
          if);
        
        (if success then
            (# t: @Text;
            do 
               '`%s'' ready (PID=%d)'->t.putFormat
               (# de: @diskEntry;
               do getEXECNAMEparam->de.path;
                  de.path.name->s; 
                  getPIDparam->d;
               #);
               t[]->gui.putpinfo;
               ''->gui.putinfo;
            #);
            debuggee[]->gui.debuggee[];
            gui.main.status.setenabling;
            
            ('program',debuggee.MPS.BETA.DescriptorForm)
              ->debuggee.DBmanager.slotnameToGroups
            (# 
            do current[]
                 ->debuggee.mps.fragmentGroupTable.getFragmentGroup
                 ->fg[];
               (if fg[]<>none then
                   ('program',screen[])->fg.open->ff[];
                   (if ff[]<>none then
                       dragOutlineOnOpen->gui.getOption->outline;
                       (dragOutlineOnOpen,false)->gui.setOption;
                       ff.root[]->gui.newCodeView;
                       (dragOutlineOnOpen,outline)->gui.setOption
                   if)
               if);
            #);
         else
            NONE->debuggee[];
            'No Process'->gui.putpinfo;
        if)
     #)
#)

--- procwaiter: descriptor ---
(# tmp: @Text;
   impi: ^processInterface.ImperativeInfo;
do
   always:
     (# 
     do 
        waitersem.P;
        gui.main.status.setenabling;
        ''->gui.putinfo;
        
        waitloop:
          (# 
          do 
             debuggee.processComm.wait
             (# wrongMessage::
                  (# t: ^text
                  do 'Connection Broken'->gui.putpinfo;
                     'The connection to the debuggee has been disconnected.\n\n'->t[];
                     'If this is not what you expected, it might be an internal Valhalla error,\n'->t.puttext;
                     'in which case you should collect the details of this incident,\n'->t.puttext;
                     'and report them to support@mjolner.dk'->t.puttext;
                     (t[],'Connection Broken')->gui.alertinfo;
                     ensureKilled;
                     leave waitloop
                  #)
             #);
             
             (if debuggeeIsReady then
                 (if debuggee.notifyUserOnStop then
                     (if debuggee.bml.userBreakHit
                      //0//MNGR_USERSKIP then
                         (if debuggee.bml.skipBreakHit or stopped then
                             'Stopped'->gui.putpinfo;
                          else
                             tmp.clear;
                             'Runtime Error: %s'->tmp.putformat
                             (# dummy: @Integer;
                             do debuggee.error->(dummy,s);
                             #);
                             tmp[]->gui.putpinfo;
                         if);
                      else
                         tmp.clear;
                         'Stopped at breakpoint %d'->tmp.putformat
                         (# 
                         do debuggee.bml.userBreakHit->d
                         #);
                         tmp[]->gui.putpinfo;
                     if);
                     FALSE->stopped;
                     debuggee.currentRemoteCode->impi[];
                     (if impi[]<>NONE then
                         impi.cast[]->newcodemoveable
                         (# openIfNotFound::
                              (# 
                              do alwaysCurCode->gui.getOption->value;
                              #);
                            wriggleIfFound::
                              (# 
                              do (found[]<>lastEditor[])->value;
                                 found.bringToFront;
                              #);
                         #);
                      else
                         (if alwaysCurCode->gui.getOption then
                             gui.debuggeeCurCode;
                         if);
                     if)
                  else
                     debuggee.processComm.continue;
                     restart waitloop;
                 if);
              else
                 'Terminated'->gui.putpinfo;
                 ('Process terminated','Terminated')->gui.alertinfo;
             if);
          #);
        gui.main.status.setenabling;
        restart always;
     #);
#)

--- newcodemoveable:dopart ---
do findCode: gui.codeviews.newscan
     (# end::
          (# 
          do (if openIfNotFound then
                 getFrame
                 (# done::
                      (# mc: ^mycodeview;
                      do &mycodeview[]->mc[];
                         (gui.main.objworld[],result,cast[])->mc.open;
                         cast[]->mc.selectNode;
                         mc.contents.editor[]->lastEditor[];
                      #);
                 #);
             if)
          #);
     do (if cur.frag[]<>NONE then
            (if cur.frag.root[]->cast.frag.root.equal then
                (if cur[]->acceptFound then
                    cast[]->cur.select;
                    (if cur[]->wriggleIfFound then
                        cur.encl.onHighlight;
                    if);
                    cur[]->lastEditor[];
                    leave findCode;
                if);
            if);
        if);
     #);
   
--- newstackviewbody:dopart ---
do findStack: gui.stackviews.newscan
     (# end:: getFrame
          (# done::
               (# 
               do (gui.main.objworld[],result,debuggee[],comp[])
                    ->(&mystackview[]).open;
               #);
          #);
     do (if cur.component[]->comp.equal then
            cur.encl.onHighlight;
            leave findStack;
        if);
     #); 
   
--- debuggeeCurCode:descriptor ---
(#  impi: ^processInterface.ImperativeInfo;
   lldescription:
     (# txt: ^Text;
     do &Text[]->txt[];
        'address %d (%s).'->txt.putformat 
        (# name: ^Text; pc,value: @Integer;
        do debuggee.PC->pc->d;
           pc->debuggee.executable.labelAddressToName
             ->(name[],value);
           (if name[]<>NONE then
               name.copy->name[];
               '+'->name.append;
               pc-value->name.putInt;
               name[]->s;
            else
               '???'->s
           if);
        #); 
     exit txt[]
     #);
do (if curCodeStatus then
       debuggee.PC->debuggee.utilities.codeAddressToImperative
       (# onPartialMinfo::
            (# tmp: @Text; pti: ^processInterface.prototypeInfo;
            do 
               (if dp[]<>NONE then
                   (* Ok, at least we can show the dopart. *)
                   ('Unknown imperative. Showing surrounding dopart',
                   'Missing debug info')->alertInfo;
                   dp[]->newcodemoveable;
                else
                   ('Unable to show code.','Missing debug info')
                     ->alertInfo;
               if);
            #);
          onGentry::
            (# inf: @Text;
            do 'Object generation code (G entry) '->inf;
               lldescription->inf.append;
               (inf[],'No corresponding BETA source')->alertInfo;
            #);
          notBetaCode::
            (# inf: @Text;
            do 'Process stopped in non-BETA code '->inf;
               lldescription->inf.append;
               (inf[],'Not BETA code')->alertInfo;
            #);
       #)->impi[]; 
       (if impi[]<>NONE then impi.cast[]->newcodemoveable if);
   if)
#)
   
--- mycodeviewPrivate: descriptor ---
(# cfe: ^gui.main.codeeditor;
   ge: ^gui.main.editorEnv.groupEditor;
   edenv: ^gui.main.editorEnv;
#)

--- mycodeviewWriggle: dopart ---
do contents.editor[]->lastEditor[];
   
--- mycodeviewSelectNode: dopart ---
do gui.ymerPrivate.edenv[]->private.edenv[];
   (this(mycodeview)[],node.frag.father,true)
     ->private.edenv.findOrCreateGroupEditor
     ->private.ge[];
   (node.frag[],node.frag.root[],node[] ,contents.editor[],private.ge[])
     ->private.edenv.findOrCreateFormEditor
     ->private.cfe[];
   node[]->contents.editor.select;
