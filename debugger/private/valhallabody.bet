ORIGIN '../valhallaapplication';
INCLUDE '~beta/editor/codeeditor'
        '~beta/editor/private/nouser'
        '~beta/toollibs/utils/architecture';
MDBODY nti 'valhalla_ntibody'
       mac 'valhalla_macbody'
       ppc 'valhalla_macbody'
       ppcmac 'valhalla_macbody'
       default 'valhalla_unixbody';
LIB_ITEM 'valhalla';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-98
 *   All rights reserved.
 *)
-- runnewdebuggee: Descriptor --
(#
   outline: @boolean;
   fg: ^mps.ast.fragmentGroup;
   ff: ^mps.ast.fragmentForm;
   execname: ^text;
   warningmsg: ^text;
   execf: @diskentry;
   localdebuggee: ^Aplprocess;
   (* to handle debuggee until fork is finished *)
   
do
   getExecNameParam->execname[];
   execname[]->execf.path;
   (if execf.exists then (* check correct type of executable *)
       (if not (ExecName[]->is_native_executable) then
           none ->debuggee[]->debuggee[];
           'No Process'->putpinfo;
           'Binary: '->warningmsg[];
           execname[]->warningmsg.puttext;
           ' is not a correct binary for this CPU!.\n'->warningmsg.puttext;
           'Seems to be of type: '->warningmsg.puttext;
           ExecName[]->type_of_executable->warningmsg.putline;
           warningmsg.newline;
           'Quit immediately (and recompile) to be able to continue debugging'
             ->warningmsg.puttext;
           (warningmsg[],'Warning')->alertInfo;
           none ->execname[];
           
       if);
       
    else
   (* File does not exist *)
       'File: '->warningmsg[];
       execname[]->warningmsg.append;
       '. Does not exist!\nNo debuggee loaded!'->warningmsg.puttext;
       (warningmsg[],'Warning')->alertInfo;
       none ->execname[];
       
   if);
   dorunNewDebuggee:
     (# 
     do
        (if execname[] = none then (* wrong type of executable or not found*)
            FALSE->success; leave dorunNewDebuggee; 
        if);
        TRUE->success;
        (if debuggee[] <> none then
            (if not debuggee.terminated then debuggee.kill if);
            (if not rerun then none ->debuggee[]->debuggee[];  if);
            (* gram *)
            
        if);
        (if getEXECNAMEparam = none then
            (if newExecName = none then leave dorunNewDebuggee if); 
        if);
        rerun and (debuggee[] <> none )->rerun;
        doInit:
        (if not rerun then
            (if getPIDparam = 0 then
            (* Only edit commandline if the process is not
             * already running.
             * doEditCommandLine  *)
                
            if);
            (*
             * (if sources[]<>NONE then sources.close; NONE->sources[] if);
             *)
            codeviews.newscan
              (#  do cur.encl.tryclose #);
            &Aplprocess[]->localdebuggee[];
            debuggeeInit:
            mps[]
              ->localdebuggee.init
                (#
                   doingExpensiveRead:: 
                     (# t: @Text; 
                     do
                        'Creating debug info cache (%s)'
                          ->t.putFormat
                            (# de: @diskEntry
                            do dbName[]->de.path; de.path.name->s
                            #);
                        t[]->putinfo;
                        
                     #);
                   doingCheapRead:: 
                     (# t: @Text; 
                     do
                        'Reading debug info cache (%s)'
                          ->t.putFormat
                            (# de: @diskEntry
                            do dbName[]->de.path; de.path.name->s
                            #);
                        t[]->putinfo;
                        
                     #);
                   timeoutcount: @Integer;
                   connectionTimedOut:: 
                     (# t: @Text; 
                     do
                        timeoutcount+1->timeoutcount;
                        (if timeoutcount = 4 then
                            ('Connection timed out','Connection Error')
                              ->alertinfo;
                            FALSE->value;
                            
                         else
                            'Waiting (%d)'
                              ->t.putFormat (#  do timeoutCount->d #);
                            t[]->putinfo;
                            TRUE->value;
                            
                        if);
                        
                     #);
                   wrongBetarunVersion:: 
                     (# t: @Text; 
                     do
                        (if DebugValhalla then
                            'valhallabody: wrong betarun version: '
                              ->screen.puttext;
                            debuggeeversion[]->screen.putline;
                            
                        if);
                        'This valhalla version requires the debugged process to be\nlinked with version '
                          ->t;
                        BETARUN_ID->t.append;
                        ' of the BETA runtime system.\n'->t.append;
                        'Found version '->t.append;
                        debuggeeVersion[]->t.append;
                        ' in the debugged process.'->t.append;
                        'Wrong BETA runtime system'->putInfo;
                        (t[],'Version Error')->alertinfo;
                        false->success;
                        leave debuggeeInit;
                        
                     #);
                   createFragInfo:: TrueObject;
                   creationFailed:: 
                     (# t: @Text; 
                     do
                        'Failed to create debug info cache (%s)'
                          ->t.putFormat (#  do dbName[]->s #);
                        t[]->putInfo;
                        (t[],'Debug Info Cache Error')->alertinfo;
                        TRUE->continue;
                        
                     #);
                   execNotFound:: 
                     (# t: @Text; 
                     do
                        'Executable `%s\' not found'
                          ->t.putFormat (#  do getEXECNAMEparam->s #);
                        t[]->putInfo;
                        (t[],'Executable not found')->alertinfo;
                        FALSE->success;
                        leave debuggeeInit;
                        
                     #);
                   forkFailed:: 
                     (# t: @Text; 
                     do
                        'Could not fork `%s\''
                          ->t.putFormat
                            (# de: @diskEntry
                            do getEXECNAMEparam->de.path; de.path.name->s; 
                            #);
                        t[]->putInfo;
                        (t[],'Fork Failure')->alertinfo;
                        FALSE->success;
                        leave debuggeeInit;
                        
                     #);
                   exeDbMissing:: 
                     (# t: @text; 
                     do
                        'Debug information for executable not found\n'->t;
                        'File: '->t.append;
                        dbName[]->t.append;
                        '\n is necessary for debugging!\n'->t.append;
                        'Recompile executable without "-d" option and retry.'
                          ->t.append;
                        (t[],'Debugging impossible!')->alertinfo;
                        ;
                        FALSE->success;
                        leave debuggeeInit;
                        
                     #);
                   
                #)->success;
            
         else
            debuggeeRerun:
            debuggee.rerun
              (#
                 execNotFound:: 
                   (# t: @Text; 
                   do
                      'Executable `%s` not found'
                        ->t.putFormat (#  do getEXECNAMEparam->s #);
                      t[]->putInfo;
                      (t[],'Executable not found')->alertinfo;
                      FALSE->success;
                      none ->debuggee[];
                      leave debuggeeRerun;
                      
                   #);
                 forkFailed:: 
                   (# t: @Text; 
                   do
                      'Could not fork `%s\''
                        ->t.putFormat
                          (# de: @diskEntry
                          do getEXECNAMEparam->de.path; de.path.name->s
                          #);
                      t[]->putInfo;
                      (t[],'Fork Failure')->alertinfo;
                      FALSE->success;
                      leave debuggeeRerun;
                      
                   #);
                 modtimeChanged:: 
                   (#  do rereadprompt; FALSE->rerun; restart doinit;  #);
                 
              #)->success
        if);
        (if success then
              (# t: @Text; programFound: @boolean
              do
                 'Debugging '->t;
                 getEXECNAMEparam->t.append;
                 t[]->main.title;
                 ''->t;
                 '\'%s\' ready (PID=%d)'
                   ->t.putFormat
                     (# de: @diskEntry; 
                     do
                        getEXECNAMEparam->de.path;
                        de.path.name->s;
                        getPIDparam->d;
                        
                     #);
                 t[]->putpinfo;
                 ''->putinfo;
                 (if DebugValhalla then t[]->screen.putline;  if);
                 (if not rerun then localdebuggee[]->debuggee[];  if);
                 main.status.setenabling;
                 ('program',debuggee.MPS.BETA.DescriptorForm)
                   ->debuggee.DBmanager.slotnameToGroups
                     (# 
                     do
                        true->programFound;
                        current[]
                          ->debuggee.mps.fragmentGroupTable.getFragmentGroup
                          ->fg[];
                        (if fg[] <> none then
                            ('program',screen[])->fg.open->ff[];
                            (if ff[] <> none then
                                ff[]->theProgramFF[];
                                dragOutlineOnOpen->getOption->outline;
                                (dragOutlineOnOpen,false)->setOption;
                                ff.root[]->newCodeView;
                                (dragOutlineOnOpen,outline)->setOption
                            if)
                        if);
                        
                     #);
                 (if not programFound then
                     'Missing debug info. "program" cannot be shown'->putinfo;
                     (main[],
                     'Missing .db file for main program fragment.\n"-- program: descriptor --" cannot be shown',
                     'Missing debug info')->gui.alertUser
                 if)
              #)
         else
            (if not rerun then localdebuggee[]->debuggee[] if);
            resetDebugger;
            none ->debuggee[]; 'No Process'->putpinfo; 
        if)
     #);
   debuggee[]->debuggee[];
   
#)  

-- procwaiter: Descriptor --
(#
   tmp: @Text;
   impi: ^processInterface.ImperativeInfo;
   errorNumber: @integer;
   errorText: ^text;
   
do
   always:
     (# 
     do
        waitersem.P;
        main.status.setenabling;
        ''->putinfo;
        waitloop:
          (# 
          do
             debuggee.processComm.wait
               (#
                  wrongMessage:: 
                    (# t: ^text
                    do
                       'Connection Broken'->putpinfo;
                       'The connection to the debuggee has been disconnected.\n\n'
                         ->t[];
                       'If this is not what you expected, it might be an internal Valhalla error,\n'
                         ->t.puttext;
                       'in which case you should collect the details of this incident,\n'
                         ->t.puttext;
                       'and report them to support@mjolner.dk'->t.puttext;
                       (t[],'Connection Broken')->alertinfo;
                       ensureKilled;
                       leave waitloop
                    #)
               #);
             (if debuggeeIsReady then
                 (if debuggee.notifyUserOnStop then
                     debuggee.processComm.status.error
                       ->(errorNumber,errorText[]);
                     (if (errorNumber = RTS_UPDATE) or
                     (((errorNumber = - 28) or (errorNumber = - 100)) and not
                      stopped) then
                         debuggee.processComm.continue
                           (#
                              failure:: 
                                (# 
                                do
                                   true->continue;
                                   (* Display warning *)
                                   'Protocol Error'->continueError
                                #)
                           #);
                         restart waitloop
                      else
                         showStopCause;
                         FALSE->stopped;
                         debuggee.currentRemoteCode->impi[];
                         (if impi[] <> none then
                             impi.cast[]
                               ->newcodemoveable
                                 (#
                                    openIfNotFound:: 
                                      (# 
                                      do alwaysCurCode->getOption->value; 
                                      #);
                                    wriggleIfFound:: 
                                      (# 
                                      do
                                         (found[] <> lastEditor[])->value;
                                         found.bringToFront;
                                         (* from search.bet in editor *)
                                         (impi.cast.frag.root[],impi.cast[],
                                          false)->sources.selectNode
                                      #)
                                 #)
                          else
                             (if alwaysCurCode->getOption then
                                 debuggeeCurCode
                             if)
                         if)
                     if)
                  else
                     debuggee.processComm.continue
                       (#
                          failure:: 
                            (# 
                            do
                               true->continue;
                               (* Display warning *)
                               'Debuggee not responding!\n'->continueError
                            #)
                       #);
                     restart waitloop;
                     
                 if);
                 
              else
                 'Terminated'->putpinfo;
                 ('Process terminated','Terminated')->alertinfo;
                 
             if);
             
          #);
        main.status.setenabling;
        restart always
     #)
#)  

-- selectCodeView: DoPart --
do
     (# edenv: ^editorEnv
     do 
        sources.edenv[]->edenv[];
        (cast.frag[],cast.frag.root[],cast[],scv.contents[],
         (sources.Id,cast.frag.father,true)->edenv.findOrCreateGroupEditor)
          ->edenv.findOrCreateFormEditor;
        cast.frag.name->scv.label;
        cast[]->scv.contents.select;
        'Selectcodeview'->screen.putline;
        
     #)  

-- selectObjectView: DoPart --
do   

-- newcodemoveable: DoPart --
do
   findCode: codeviews.newscan
     (#
        end::
          (# 
          do
             (if openIfNotFound then
                 (if isStandAloneValhalla then
                     getFrame
                       (#
                          done:: 
                            (# mc: ^mycodeview; 
                            do
                               &mycodeview[]->mc[];
                               (main.objworld[],result,cast[])->mc.open;
                               cast[]->mc.selectNode;
                               mc.contents.editor[]->lastEditor[]
                            #)
                       #)
                  else
                     (cast.frag.root[],cast[],false)->sources.selectNode;
                     (* lasteditor must be assigned, because if list was empty (ctrl-f7)
                      * scan will not call inner *)
                     sources.cfe.theSifTextEditor[]->lastEditor[]
                 if)
             if)
          #)
     do
        (if cur.frag[] <> none then
            (if cur.frag.root[]->cast.frag.root.equal then
                (if cur[]->acceptFound then
                    cast[]->cur.select;
                    (cast.frag.root[],cast[],false)->sources.selectNode;
                    (if cur[]->wriggleIfFound then cur.encl.onHighlight if);
                    cur[]->lastEditor[];
                    leave findCode
                if)
             else
                cast[]->sources.findAndSelect
            if)
        if)
     #);
     

-- newobjectmoveable: DoPart --
do
   findObject: objectviews.newscan
     (#
        end:: 
          (# 
          do
             (if openIfNotFound then
                 (bo[],true)
                   ->main.OpenMoveableObjectView
                     (# getFather::  (#  do main.objworld[]->father[] #)
                     #)
             if)
          #);
        
     do
        (if cur.bo[] <> none then
            (if cur.bo[] = bo[] then
                (if cur[]->acceptFound then
                    (if cur[]->wriggleIfFound then cur.encl.onHighlight;  if);
                    leave findObject;
                    
                if);
                
            if);
            
        if);
        
     #);
     

-- newstackviewbody: DoPart --
do
   findStack: stackviews.newscan
     (#
        end:: getFrame
          (#
             done:: 
               (# 
               do
                  (main.objworld[],result,debuggee[],comp[])
                    ->(&mystackview[]).open;
                  
               #);
             
          #);
        
     do
        (if cur.component[]->comp.equal then
            cur.encl.onHighlight; leave findStack; 
        if);
        
     #);
     

-- newstackbrowserbody: DoPart --
do getFrame
     (#
        done:: 
          (# 
          do
             (main.objworld[],result,debuggee[],comp[])
               ->(&mystackbrowser[]).open;
             
          #);
        
     #);
     

-- debuggeeCurCode: Descriptor --
(#
   impi: ^processInterface.ImperativeInfo;
   lldescription:
     (# txt: ^Text; 
     do
        &Text[]->txt[];
        'address %d (%s).'
          ->txt.putformat
            (# name: ^Text; pc,value: @Integer; 
            do
               debuggee.PC->pc->d;
               pc->debuggee.executable.labelAddressToName->(name[],value);
               (if name[] <> none then
                   name.copy->name[];
                   '+'->name.append;
                   pc-value->name.putInt;
                   name[]->s;
                   
                else
                   '???'->s
               if);
               
            #);
        
     exit txt[]
     #);
   
do
   (if curCodeStatus then
       debuggee.PC
         ->debuggee.utilities.codeAddressToImperative
           (#
              onPartialMinfo:: 
                (# tmp: @Text; pti: ^processInterface.prototypeInfo; 
                do
                   (if dp[] <> none then
                   (* Ok, at least we can show the dopart. *)
                       ('Unknown imperative. Showing surrounding dopart',
                        'Missing debug info')->alertInfo;
                       dp[]->newcodemoveable;
                       
                    else
                       ('Unable to show code.','Missing debug info')->alertInfo;
                       
                   if);
                   
                #);
              onGentry:: 
                (#
                   inf: @Text;
                   pti: ^processInterface.PrototypeInfo;
                   a: ^mps.BETACFL.PatternDecl;
                   n: ^mps.ast.nameDecl;
                   
                do
                   'Object generation code (G entry) '->inf;
                   lldescription->inf.append;
                   '\n'->inf.put;
                   'Runtime error occured! Maybe while allocating object:\n'
                     ->inf.append;
                   '(# t:^p; s:@t.i do ... #),  s is the problem since t is none!\n'
                     ->inf.append;
                   'Could be in pattern named: '->inf.append;
                   'Unknown!'->inf.putline;
                   protoAdr->debuggee.utilities.ProtoAddressToPrototypeInfo
                     ->pti[];
                   '\nIn file '->inf.append;
                   (if pti[] <> none then
                       pti.ofi.groupname[]->inf.append;
                       '.bet'->inf.append;
                       (if pti.objdesc[] <> none then (* show descriptor *)
                           pti.objdesc[]->newcodemoveable;
                           '\nShowing objectdescriptor.'->inf.append;
                           (*
                            * '11'->putline;
                            pti.objdesc.father->a[];
                            '22'->putline;
                            a.kind->putint;newline;
                            pti.objdesc.kind->putint;
                            a.getnames->n[];
                            '33'->putline;
                            n.gettext->putline;
                            '44'->putline;
                            *)
                           
                       if);
                       
                    else
                       'unknown'->inf.append; 
                   if);
                   (inf[],'No corresponding BETA source')->alertInfo;
                   
                #);
              notBetaCode:: 
                (# inf: @Text; 
                do
                   'Process stopped in non-BETA code '->inf;
                   lldescription->inf.append;
                   (inf[],'Not BETA code')->alertInfo;
                   
                #);
              
           #)->impi[];
       (if impi[] <> none then impi.cast[]->newcodemoveable if);
       
   if)
#)  

-- mycodeviewPrivate: Descriptor --
(#
   cfe: ^codeeditor;
   ge: ^editorEnv.groupEditor;
   edenv: ^editorEnv;
   
#)  

-- mycodeviewWriggle: DoPart --
do contents.editor[]->lastEditor[];   

-- mycodeviewSelectNode: DoPart --
do 
   sources.edenv[]->private.edenv[];
   (sources.Id,node.frag.father,true)
     ->private.edenv.findOrCreateGroupEditor->private.ge[];
   (node.frag[],node.frag.root[], none ,contents.editor[],
    private.ge[])->private.edenv.findOrCreateFormEditor->private.cfe[];
   node[]->contents.editor.select;
     

