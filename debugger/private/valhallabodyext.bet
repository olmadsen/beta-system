ORIGIN '../valhallaapplication';
INCLUDE '../breakpointOperations';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '~beta/betaast/betasematt';

-- valhallatrybreakOnProgram: Descriptor --
(#
   node: ^astinterface.ast;
   e: ^astinterface.expanded;
   i: @integer;
   t: @text;
do
   (if theProgramFF[]<>none then
       theProgramFF.root[]->node[]
   if);
   l:
   (if node[] <> none then
       (if node.hascomment then (* find descriptor *)
           node[]->e[]; e.getson1->node[]; (if node[] = none then leave l if)
       if);
       node[]->e[];
       e[]->sources.findAndSelect;
       doGoUntil
    else
       (' The debugger was unable to step. Please use "Go Until Mark"!',
        'Warning Debuggee not started!')-> (*FGC, gui.*) alertinfo
   if)
#)  

-- valhalladoFinish: Descriptor --
(# (* implementing step-out *)
   debugFinish: (#  exit true #);
   p: @ (*gui.*) breakpointcontroller
     (#
        getFocus:: 
          (# i: @integer do lasteditor.sifviewer.cs->(node[],i,i,i) #);
        
     #);
   node: ^astinterface.ast;
   dummy: @integer;
   cs,callcs: ^componentstack;
   comp,callcomp: ^processInterface.remoteBetaObject;
   returnadr,componentaddr: @integer;
   impi: ^debuggee.ImperativeInfo;
   after: @boolean
do (* getFocus->node[];  *)
   (if debugfinish then 'Finished Called'->screen.putline if);
   p.init;
   lasteditor.sifviewer.cs->(node[],dummy,dummy,dummy);
   debuggee.currentRemoteComponent->comp[];
   (* this component *)
   comp.getAddress->debuggee.getStack->cs[];
   (if debugfinish then
       'stack.last=%d\n'->putformat (#  do cs.last->d #)
   if);
   (* stack of this component *)
   (if cs.last > 1 then (* not bottom of object stack *)
       cs.returnAdrs[2]
         ->returnadr (* adrs[1] is this object, 2 is calling address *)
    else
   (* was bottom of stack, try to find calling object in calling component *)
       (if cs.callingComponents.range > 0 then
           cs.callingComponents[1]->componentaddr;
           componentaddr->debuggee.newRemoteObject->callcomp[];
           (if debugfinish then
               'caller is component:%d\n'
                 ->putformat (# do (if callcomp.isComp then 1->d else 0->d if) #)
           if);
           callcomp.getaddress->debuggee.getStack->callcs[];
           callcs.returnAdrs[1]->returnAdr;
           (* actually call point. ??*)
           (if debugfinish then
               'callcs.returnAdrs[1]=%d\n'->putformat (#  do returnAdr->d #)
           if);
           'callcs.last=%d\n'->putformat(# do callcs.last->d #);
           (if callcs.last>1 then
               (if debugfinish then
                   'callcs.returnAdrs[2]=%d\n'
                     ->putformat (#  do callcs.returnAdrs[2]->d #)
               if)
           if);
           True->After
        else
       (* last act.rec in last component *)
           doContinue
       if)
   if);
   (if returnAdr <> 0 then
       returnadr
         ->debuggee.utilities.codeAddressToImperative
           (#
              notBetaCode:: 
                (# 
                do
                   ('Warning return address! not in Beta-code\nAllowing debuggee to continue;',
                    'Trying to Finish descriptor!')-> (*gui.*) alertinfo;
                   doContinue
                #)
           #)->impi[];
       (* imp corresp. to addr *)
       (if impi[] = none then leave doFinish;  if);
       (* error occured *)
       impi.cast[]->node[];
       (* ast corresp. to addr *)
       (if (node[],After,debuggee[])->p.setOneShotBreakpoint then
           doContinue; (* go *) 
       if)
   if)
#)  

-- ShowObjectReferencesDP: DoPart --
do
     (#
        t: @gui.window
          (#
             scrlist: @textscrolllist
               (#
                  open:: 
                    (# 
                    do (200,200)->size; true->bindright; true->bindbottom
                    #);
                  eventhandler:: 
                    (#
                       onSelect:: 
                         (# bo: ^debuggee.remoteBetaObject; 
                         do
                            (if doubleClick then
                                item->gettext->putline;
                                (item->h.get).adr->debuggee.newRemoteObject
                                  ->bo[];
                                bo[]->newObjectMoveable
                            if)
                         #)
                    #)
               #);
             open:: 
               (# t: @text; 
               do
                  scrlist.open;
                  'References to '->t.append;
                  rb.description->t.append;
                  (200,200)->size;
                  
               #);
             
          #);
        adr: @integer;
        
     do
        'Address is %d\n'->putformat (#  do rb.address->d #);
        rb.getAddress->adr->putint;
        newline;
        rb.description->putline;
        adr->debuggee.processcomm.getRefsToObject->h[];
        'object has %d external references\n'
          ->putformat (#  do h.size->d #);
        t.open;
        h.size->t.scrlist.append;
        h.scan
          (# bo: ^debuggee.remotebetaobject; i: @integer; tt: ^text
          do
             current.adr->debuggee.newRemoteObject->bo[];
             i+1->i;
             &text[]->tt[];
             'Address:%8X, description:%s'
               ->tt.putformat (#  do current.adr->uX; bo.description->s #);
             (i,tt[])->t.scrlist.settext;
             
          #);
        
     #);
     

-- valhalladoGoUntil: Descriptor --
(#
   p: @ (*gui.*) breakpointcontroller
     (#
        getFocus:: 
          (# i: @integer do lasteditor.sifviewer.cs->(node[],i,i,i) #);
        
     #);
   node: ^astinterface.ast;
   dummy: @integer;
   
do
   p.init;
   lasteditor.sifviewer.cs->(node[],dummy,dummy,dummy);
   (if (node[],FALSE,debuggee[])->p.setOneShotBreakpoint then
       doContinue; (* go *) 
   if);
   
#)  

--valhallalib:attributes--
SeqWindow:gui.window
  (# 
     open::(# do 'SD'->title #)
  #)


--SDTracePointHitSetupObjects:dopart--
do debuggee.curObj->debuggee.newRemoteObject->thisObj[];
   
   getRemoteObjectDB->objects[];

   (thisObj[],SDObjectOwner[])->objects.addObjectOwner;
   
   
   desc[]->theRealDesc[];
   thisObj.getaddress+theRealDesc.originOff->processComm.processData.peekLong->debuggee.newRemoteObject->originobj[];
   (originobj[],SDObjectOwner[])->objects.addObjectOwner;
   
--SDTracePointHit:dopart--
do
   'SDTracepointHit: desc.ast=%d, msg=%s,isexit=%t\n'->screen.putformat
   (# do desc.index->d; msg[]->s; isExit->tv #);
   
   setupObjects;
   (if not isExit then

       'thisobj: '->puttext; thisObj.description->putline;
       
       'thisobj:%x, thisobjinx=%d, orgobj:%x inx=%d\n'->putformat
       (# do thisobj.getAddress->x;thisobj.dotinx->d; originobj.getAddress->x; originobj.dotinx->d #);
       
       'originObj:'->puttext; (true,false)->originObj.description->putline
   if)       
   
