ORIGIN '../processInterface';
INCLUDE '~beta/basiclib/formatio';
LIB_ITEM 'valhallaprocess';
(*
 * COPYRIGHT
 *   Copyright (C) Aarhus University
 *   All rights reserved.
 *)

(* .db FILE FORMAT
 * ================
 * 
 * See ../debugInfoFormat.txt for a description of the .db files format. *)

INCLUDE '~beta/sysutils/binarystream';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/sysutils/envstring';

--- lib:attributes --

dbExt: (# exit '.db' #);
dbcacheExt: (# exit '.dbc' #);

--- DBManagerInit:dopart ---
do THIS(Init)[]->dbmprivate.init;
   
--- DBManagerSlotNameToGroups:dopart ---
do (# elm: @dbmprivate.fragInfo.element;
   do 
      slotName.copy->elm.fragmentName[]; elm.fragmentName.MakeUC;
      slotType->elm.fragmentType;
      elm[]->dbmprivate.fragInfo.hashFunction->dbmprivate.fragInfo.scanIndexed
      (# 
      do (if current.fragmentType =slotType then
             (if current.fragmentName[]->slotName.equalNCS  then
                 current.groupName[]->THIS(slotNameToGroups).current[];
                 current.groupNameHash->THIS(slotNameToGroups).groupNameHash;
                 current.checkTime->THIS(slotNameToGroups).checkTime;
                 INNER slotNameToGroups;
             if);
         if)
      #);
   #)
   
--- DBManagerReadDB:dopart ---
do ofi[]->dbmprivate.read;
   
--- DBManagerprivate:descriptor ---
(# dbAccessError:@boolean; (* vrong permissions on .db file *)
   bin: @binarystream(# AccessError::<(# do true->dbAccessError;
                                         true->continue;
                                      #)
                     #);
   impAddresses: [256]@Integer; 
   impAstRefs: [256]@(*ShortInt*)int16u;
   accum: @Integer; (* Accumulated offset from M entrypoint *)
   is_nti: 
     (# target: ^Text;
     do machine_type->target[];
     exit ('nti_ms'->target.equal)
        or ('nti_gnu'->target.equal)
        or ('nti_bor'->target.equal)
     #);
   
   fragInfo: @HashTable
     (# element::< 
          (# fragmentName: ^Text;
             fragmentType: @Integer;
             groupName: ^Text; (* groupName from ofi.groupName. *)
             groupNameHash,checkTime: @Integer;
          #);
        hashFunction::<
          (# t: ^Text;
          do e.fragmentType->value;
             e.fragmentName[]->t[];
             (for i: t.length repeat value+t.t[i]->value for);
          #);
        rangeInitial::< (# do 233->value #);
     #);
   
   TheDE:@diskEntry;
   
   TstAstFile:@
     (# name:^text;
        dbmodtime:@integer;
     enter (name[],dbmodtime)
     do
        name.copy->name[];
        MPS.AST.astFileExtension->name.append;
        name[]->TheDE.path;
        (if not theDE.exists then
            'AstFile %s doen not exist\n'->putformat(# do name[]->s #)
         else
            (if theDE.modtime>dbmodtime then
                'AstFile %s is newer\n'->putformat(# do name[]->s #)
            if)
        if)
     #);
   
   makeDBname:
     (# ofi: ^ObjectFileInfo;
        de: @DiskEntry;
        dbName: ^Text;
        modTime: @Integer;
        notFound:< Notification;
     enter ofi[]
     do 
        (ofi.groupName[],NONE)->processPathHandler.convertFilePath->de.path;
        de.path.head->dbName[]; directorychar->dbName.put;
        processComm.MachineType->dbName.append; directorychar->dbName.put;
        de.path.name->dbName.append;
        dbExt->dbName.append->de.path;
        (if de.exists  then
            de.modTime->modTime
         else
            notFound
        if);
     exit (dbName[],modTime)
     #);
   
   makeDBCname:
     (# execName: ^text;
        de: @DiskEntry;
        dbcLoc, execLoc, dbcName, dbcPath: ^Text;
        modTime: @Integer;
        notFound:< Notification;
     enter execName[]
     do 
        (execName[],NONE)->processPathHandler.convertFilePath->de.path;
        de.path.head->dbcLoc[]; directorychar->dbcLoc.put;
        dbcLoc.copy->execLoc[];
        processComm.MachineType->dbcLoc.append; directorychar->dbcLoc.put;
        (if is_nti then
            de.path.name.prefix->dbcName[]; (* forget the '.exe. *)
         else
            de.path.name->dbcName[];
        if);
        dbcacheExt->dbcName.append;

        dbcLoc[]->dbcPath[]->de.path;
        (if not de.exists or not de.writeable then (* cannot use <machineDir> *)
            execLoc[]->dbcPath[];
	if);
        dbcName[]->dbcPath.append->de.path;
        (if not de.exists or
            (de.modTime<=executable.modtime) then
            notFound
        if);
     exit dbcPath[]
     #);
    
   init:
     (# fragName,dbName: ^Text;
        execDE,fragDE: @DiskEntry;
        makeFragInfo,missing: @Boolean;
        tmpBin: ^BinaryStream;
        theInit: ^THIS(dbManager).init;
                
     enter theInit[]
     do 
        
        (getEXECNAMEparam).copy->fragName[];
        
        fragName[]
          ->makeDBCname
              (# notFound:: (# do true->missing #) #)
          ->fragDE.path;
        
        (if missing  then
            fragDE.path->theInit.doingExpensiveRead;
            
            (if theInit.createFragInfo->makeFragInfo  then
                &BinaryStream[]->tmpBin[];
            if);
            scanObjectFileInfos
            (# 
               status:@integer; (* db file status *)
               new: ^fragInfo.element;
               noOfFrag, modTime: @Integer;
               groupNameHash,checkTime: @Integer;
            do 
               false->dbAccessError;
               DBFILE_OK->status;
               current[]->makeDBName
               (# notFound::< (# do DBFILE_NOTFOUND->status #);
               #)->(dbName[],modTime);

               (if status =DBFILE_OK then
                   (if modTime > executable.modTime  then
                       DBFILE_NEWER->status
                   if);
               if); 
               
               (*(current.groupname[],modTime)->TSTAstFile;*)
               
               (dbName[],status)->DBstatus;

               (if status =DBFILE_OK then 
                   
                   dbName[]->bin.fragRestore
                   (# 
                      NotFound::<(# do 
                                    (if dbAccessError then
                                        DBFILE_ACCESS->status;
                                        true->continue;
                                    if)
                                 #);
                   #);
                   (dbName[],status)->DBstatus;
                   
                   (* TO BE ADDED:
                    * bin.getLong->groupNameHash;
                    bin.getLong->checkTime;
                    *);
                   
                   bin.getShort->noOfFrag;
                   bin.getLong; (* Skip Fragment byte size *)
                   
                   (if makeFragInfo  then
                       current.groupName[]->tmpBin.putText;
                       groupNameHash->tmpBin.putLong;
                       checkTime->tmpBin.putLong;
                       noOfFrag->tmpBin.putShort;
                   if);
                   
                   (for noOfFrag repeat
                        &fragInfo.element[]->new[];
                        current.groupName[]->new.groupName[];
                        groupNameHash->new.groupNameHash;
                        checkTime->new.checkTime;
                        bin.gettext->new.fragmentName[];
                        bin.getShort->new.fragmentType;
                        new[]->fragInfo.insert;
                        (if makeFragInfo  then
                            new.fragmentName[]->tmpBin.putText;
                            new.fragmentType->tmpBin.putShort;
                        if);
                   for);
               if);
            #);
            (if makeFragInfo  then
                ''->tmpBin.puttext; (* endMarker *)
                saving: fragDE.path->tmpBin.save 
                (# openFailed::<
                     (# do fragDE.path->theInit.creationFailed; leave saving #)
                #)
            if);
            
         else
            fragDE.path->theInit.doingCheapRead;
            (# status:@integer; (* db file error *)
               groupName: ^Text;
               noOfFrag: @Integer;
               new: ^fragInfo.element;
               groupNameHash,checkTime: @Integer;
            do
               fragDE.path->bin.restore
               (# notfound::<(# do  (* raised if error during reading *)
                                (if dbAccessError then
                                    true->continue;
                                    DBFILE_ACCESS->status;
                                    'accesserror 250'->screen.putline;
                                if);
                             #);
               #);
               (fragDE.path,status)->DBstatus;
               
               loop:
                 (# 
                 do bin.gettext->groupName[];
                    (if groupName.lgth =0 then leave loop if);
                    bin.getLong->groupNameHash;
                    bin.getLong->checkTime;
                    bin.getShort->noOfFrag;
                    (for noOfFrag repeat
                         &fragInfo.element[]->new[];
                         groupNameHash->new.groupNameHash;
                         checkTime->new.checkTime;
                         groupName[]->new.groupName[];
                         bin.gettext->new.fragmentName[];
                         bin.getShort->new.fragmentType;
                         new[]->fragInfo.insert;
                    for);
                    restart loop;
                 #)
            #)
        if);
     #);
   
   read:
     (# ofi: ^ObjectFileInfo;
        dbname: ^Text;
        noOfFrag,nextProtoNumber,astRef,noOfDoparts,tmp,inx: @Integer;
        di: ^dopartInfo;
        status, modTime: @Integer;
     enter ofi[]
     do 
        DBFILE_OK->status;
        ofi[]->makeDBName 
        (# notFound::
             (# 
             do LL_NODBINFO->ofi.loadLevel;
                DBFILE_NOTFOUND->status;
             #)
        #)->(dbName[],modTime);

        (if status =DBFILE_OK then
            (if modTime > executable.modTime  then
                DBFILE_NEWER->status;
                LL_NODBINFO->ofi.loadLevel;
             if);
        if);

        (dbName[],status)->DBstatus;
        
        (if status =DBFILE_OK then
            dbName[]->bin.restore;
            bin.getShort->noOfFrag;
            noOfFrag->ofi.fragments.new;
            bin.getLong; (* Skip Fragment byte size *)
            
            (for i:noOfFrag repeat
                 &FragmentInfo[]->ofi.fragments[i][];
                 bin.gettext->ofi.fragments[i].fragmentName[];
                 bin.getShort->ofi.fragments[i].fragmentType;
            for);
            
            (* Read dopart information in file: *)
            (for i:noOfFrag repeat 
                 bin.getShort->noOfDoparts;
                 
                 noOfDoParts->ofi.fragments[i].dopartCount
                  ->ofi.fragments[i].doparts.new;
                 
                 (for k: noOfDoparts repeat
                      &dopartInfo[]->di[]->ofi.fragments[i].doparts[k][];
                      bin.getShort ->di.astRef; i->di.fragRef;
                      0->accum; 1->inx;
                      L: (#
                         do bin.getShort->tmp;
                            (if tmp=65535 then
                                (* -1,NOTE: may not work on all machines*)
                                impAddresses[1:inx-1]->di.impAddresses;
                                impAstRefs[1:inx-1]->di.impAstRefs;
                             else
                                (if inx>impAddresses.range then
                                    inx->impAddresses.extend;
                                    inx->impAstRefs.extend;
                                if);
                                tmp+accum->accum->impAddresses[inx];
                                bin.getShort->impAstRefs[inx];
                                inx+1->inx;
                                restart L 
                            if)
                         #);
                 for)
            for);
            
            LL_FULL->ofi.loadLevel;
         else
            (ofi[],dbName[],status)->dbLoadFailed;
        if);
     #);
#)
