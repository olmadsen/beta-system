ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '~beta/guienv/utils/colorTable';
INCLUDE '~beta/containers/sets';
INCLUDE '~beta/utils/AgentSystem/WorldWindow';
INCLUDE '~beta/utils/AgentSystem/colors';
INCLUDE '~beta/basiclib/math'
---lib:attributes--
Point:
  (# x,y: @integer;
     equal: BooleanValue
       (# P: ^Point
       enter P[]
       do (P.x = x) and (P.y = y) -> value
       #);
     print:
       (#
       do 'Point('->puttext; x -> putint; ','->put; y ->putint; ')'->put
       #)
  enter(x,y)
  exit(x,y)
  #);

computedest:
  (# dir: @real; (* angle *) ra: @real;
     loc: @Point; x,y: @real
  enter(dir,loc)
  do 'Compute: ' -> puttext; dir -> putreal; ' ' -> put;
     dir * (pi / 180) -> ra; ra -> putreal; ' ' -> put;
     '(' -> put;  ra -> cos -> x -> putreal;
     ',' -> put; ra -> sin -> y -> putreal; ')'->put;
     newline
  exit(x,y)
  #);
north: (#exit 0 #);
east: (#exit 1 #);
south: (#exit 2 #);
west: (#exit 3 #);

World: guienv
  (#
     Turtle:
       (# location: @Point;
          direction: @ integer;
          pen: @
            (# col: @color;
               width: @integer;
               isDown: @boolean;
               draw:
                 (# start,end: @Point;
                    l:  @theWorldW.turtleLine
                 enter(start,end)
                 do (if isDown then
                        'down:'->puttext;
                        width -> theWorldW.pensize;
                        (none,start.x,start.y,end.x,end.y,col) -> l.open
                     else
                        'up:'->puttext;
                    if);
                    (start.x,start.y)->out; 
                    (end.x,end.y)->out; 
                    width -> putint; 
                    ' direction: ' -> puttext; direction ->  putint;
                    newline;
                 #);
               
               out:
                 (# x,y: @integer
                 enter(x,y)
                 do '(' -> put; x -> putint; ','->put; y->putint; ')'->put
                 #)
            #);
          forward:
            (# distance: @integer; radian,x,y: @real; newLoc: @Point
            enter distance
            do (if true then
                   direction * (pi / 180) -> radian;
                   radian -> cos -> x;
                   radian -> sin -> y;
                   (location.x + x * distance, location.y + y * distance)
                     -> newLoc;
                else
                   (direction,location) -> computedest -> (x,y);
                   (location.x + x * distance, location.y + y * distance)
                     -> newLoc;
                   newloc.print;
               if);
               (location,newLoc) -> pen.draw;
               newloc -> location;
               10 -> guienvwait
            #);
          backward: 
            (# distance: @integer
            enter distance
            do  -distance -> forward
            #);
          right:
            (# angle: @integer
            enter angle
            do -angle -> left
            #);
          left: 
            (# angle: @integer
            enter angle
            do (direction + angle) mod 360-> direction
            #);
          up: (# do false -> pen.isDown #);
          down: (# do true -> pen.isDown #);
          set_color:(# enter pen.col #);
          fillcolor:(##);
          heading:(##);
          position: (# exit  location #);
          goto: 
            (# x,y: @integer 
            enter(x,y) 
            do (x,y) -> location
            #);
          penSize: 
            (# w: @integer 
            enter w 
            do w -> pen.width 
            #);
          begin_fill:(##);
          end_fill:(##);
          dot: (##);
          stamp: (##);
          shape:(##);
          move:
            (# spaces: @integer; turn: @integer; newLoc: @Point
            enter(spaces,turn)
            do (if direction
                // north then
                   (location.x,location.y - spaces) -> newLoc;
                // east then 
                   (location.x + spaces,location.y) -> newLoc;
                // south then
                   (location.x,location.y + spaces) -> newLoc;
                // west then
                   (location.x - spaces,location.y) -> newLoc;
                else
                   '????' -> putline
               if);
               (location,newLoc) -> pen.draw;
               newLoc -> location;
               (direction + turn) mod 4 -> direction;
            #)
       #);
     world_width: @ (# w: @integer enter w exit w #);
     world_height: @ (# h: @integer enter h exit h #);
     theWorldW: @WorldWindow;
     
  do 50 -> world_width;
     50 -> world_height;
     (world_width,world_height,7) -> theWorldW.open;
     
     inner World
  exit this(World)[]
  #)
---program:descriptor---
World
(# T: @Turtle;
   TurtleStar:
     (#
     do 
        (*color('red', 'yellow')
        begin_fill()*)
        L: 
        cycle
        (# i: @integer
        do i + 1 -> i;

           200 -> T.forward;
           170 -> T.left;
           (if (i = 10) then leave L if);
           (if (T.location.x->abs) < 1 then
               leave L
           if)
        #);
        'done'->putline;
     #)
do (if false then
       (40,100) -> T.location;
       east -> T.direction;
       green -> T.pen.col;
       2 -> T.pen.width;
       true -> T.pen.isDown;
       (10,1) -> T.move;
       (80,1) -> T.move;
       false -> T.pen.isDown;
       (20,1) -> T.move;
       true -> T.pen.isDown;
       red -> T.pen.col;
       (50,1) -> T.move;
       
       (0,(1,1)) -> computedest;
       (45,(1,1)) -> computedest;
       (90,(1,1)) -> computedest;
       (180,(1,1)) -> computedest;
       (270,(1,1)) -> computedest;
       
       
       '---'->putline;
       red -> T.set_color;
       2 -> T.pen.width;
       true -> T.pen.isDown;
       (10,10) -> T.location;
       0 -> T.direction;
       T.location.print;
       23 -> T.forward;
       
       90 -> T.left;
       12 -> T.forward;
       green -> T.set_color;
       45 -> T.left;
       20 -> T.forward;   
       100 -> T.left;
       30 -> T.forward;
   if);
   (0,0) -> T.location;
   red -> T.set_color;
   1 -> T.pen.width;
   true -> T.pen.isDown;
   0 -> T.direction;
   TurtleStar;
#)

