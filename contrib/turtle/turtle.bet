ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '~beta/guienv/utils/colorTable';
INCLUDE '~beta/containers/sets';
INCLUDE '~beta/utils/AgentSystem/WorldWindow';
INCLUDE '~beta/utils/AgentSystem/colors';
INCLUDE '~beta/basiclib/math'
---lib:attributes--
tPoint:
  (# x,y: @integer;
     equal: BooleanValue
       (# P: ^tPoint
       enter P[]
       do (P.x = x) and (P.y = y) -> value
       #);
     print:
       (#
       do 'tPoint('->puttext; x -> putint; ','->put; y ->putint; ')'->put
       #)
  enter(x,y)
  exit(x,y)
  #);

east: (#exit 0 #);
north: (#exit 90 #);
west: (#exit 180 #);
south: (#exit 270 #);


World: guienv
  (#
     Turtle:
       (# location: @tPoint;
          direction: @ integer;
          pen: @
            (# col: @color;
               width: @integer;
               isDown: @boolean;
               draw:
                 (# start,end: @tPoint;
                    l:  @theWorldW.turtleLine
                 enter(start,end)
                 do (if isDown then
                        (*'down:'->puttext;*)
                        width -> theWorldW.pensize;
                        (none,start.x,start.y,end.x,end.y,col) -> l.open
                     else
                        (*'up:'->puttext;*)
                    if);
                    (*(start.x,start.y)->out; 
                    (end.x,end.y)->out; 
                    width -> putint; 
                    ' direction: ' -> puttext; direction ->  putint;
                    newline;*)
                 #);               
               out:
                 (# x,y: @integer
                 enter(x,y)
                 do '(' -> put; x -> putint; ','->put; y->putint; ')'->put
                 #)
            #);
          forward:
            (# distance: @integer; radian,x,y: @real; newLoc: @tPoint
            enter distance
            do direction * (pi / 180) -> radian;
               radian -> cos -> x;
               radian -> sin -> y;
               (location.x + x * distance, location.y + y * distance)
                 -> newLoc;
               (location,newLoc) -> pen.draw;
               newloc -> location;
               (if isFilling then location -> points.add if);
               (*10 -> guienvwait*)
            #);
          backward: 
            (# distance: @integer
            enter distance
            do -distance -> forward
            #);
          right:
            (# angle: @integer
            enter angle
            do -angle -> left
            #);
          left: 
            (# angle: @integer
            enter angle
            do (direction + angle) mod 360-> direction
            #);
          up: (# do false -> pen.isDown #);
          down: (# do true -> pen.isDown #);
          set_color:(# enter pen.col #);
          fillcolor: (# #);
          heading: (# #);
          position: (# exit location #);
          goto: 
            (# x,y: @integer 
            enter(x,y) 
            do (x,y) -> location
            #);
          penSize: 
            (# w: @integer 
            enter w 
            do w -> pen.width 
            #);
          begin_fill: 
            (# 
            do points.init;
               true -> isFilling
            #);
          isFilling: @boolean;
          points: @
            (# pt: [3] ^Point; top: @integer;
               init:
                 (#
                 do 0 -> top; location -> add
                 #);
               add:
                 (# x,y: @integer
                 enter(x,y)
                 do (if (top + 1 -> top) > pt.range then
                        pt.range -> pt.extend
                    if);
                    &Point[] -> pt[top][];
                    (x,y) -> pt[top];
                 #);
               print:
                 (#
                 do (for i: top repeat
                         '(' -> put; pt[i].h -> putint; ',' -> put;
                         pt[i].v -> putint; ')'-> put; ' ' -> put
                    for);
                    newline;
                 #);
            #);
          end_fill:
            (# 
            do (if isFilling then
                   false -> isFilling;
                   (*points.print;*)
                   points.pt -> theWorldW.createPolygon;
               if)
            #);
          dot: (# #);
          stamp: (# #);
          shape: (# #);
          init:
            (#
            do (0,0) -> location;
               red -> set_color;
               1 -> pen.width;
               true -> pen.isDown;
               east -> direction
            #)
       #);
     world_width: @ (# w: @integer enter w exit w #);
     world_height: @ (# h: @integer enter h exit h #);
     theWorldW: @WorldWindow;
  do 75 -> world_width;
     75 -> world_height;
     (world_width,world_height,7) -> theWorldW.open;     
     inner World
  exit this(World)[]
  #)
---program:descriptor---
World
(# hexagon:
     (# T: @Turtle; s: @integer
     do T.init;
        (-180,80) -> T.location;
        2 -> T.penSize;
        100 -> s;
        t.begin_fill;  
        (* drawing the hexagon of side s *)
        (for i: 6 repeat
             s -> T.forward;
             -60 -> T.right;
        for);
        (* ending the filling of the color*)
         T.end_fill
     #);
   TurtleStar:
     (# T: @Turtle;
     do T.init;
        (*'yellow' -> T.fillColor;*)
        T.begin_fill;
        Loop: 
          cycle
          (# i: @integer
          do i + 1 -> i;
             200 -> T.forward;
             170 -> T.left;
             (if (i = 1500) then leave Loop if);
             (if (T.location.x->abs) < 1 then
                 leave Loop
             if)
          #);
        T.end_fill;
        'done'->putline;
     #);
   flowers1:
     (# T: @Turtle; dist: @integer
     do T.init;
        2 -> T.penSize;
        (for i: 2 repeat
             (if i
              // 1 then
                 100 -> dist;
              // 2 then
                 50 -> dist
             if);
             (for i: 5 repeat
                  (if i 
                   // 1 then
                      red -> T.set_color;
                   // 2 then
                      green -> T.set_color;
                   // 3 then
                      purple -> T.set_color;
                   // 4 then
                      gold1 -> T.set_color;
                   // 5 then
                      darkRed -> T.set_color;
                  if);
                  (for i: 4 repeat
                       dist -> T.forward;
                       90 -> T.right;
                  for);
                  72 -> T.right
             for);
        for);
     #);
   regularPolygon:
     (# size,n: @integer; T: @Turtle
     enter(size,n)
     do T.init;
        (for i : n repeat
             size -> T.forward;
             360 / n -> T.left
        for)
     #);

do (if false then
       TurtleStar;
       hexagon;

       flowers1
    else
       (129,5) -> regularPolygon
   if)
#)

