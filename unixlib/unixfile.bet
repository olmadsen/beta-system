ORIGIN '~beta/basiclib/v1.5/file';
BODY 'private/unixfile_body';

(* idx=2 *)
---- LIB: attributes ----

UnixEntry: DiskEntry
  (* Pattern describing unix specific attributes of disk-entries like
   * files and directories in a hierarchic unix file system
   *)
  (# 
     <<SLOT UnixEntryLib: attributes>>;
     
     UnixEntryExisted: Exception
       (* Raised on attempt to make an existing unix entry into a
        * symbolic link using linkTo or linkFrom. Message: "Attempt to
        * make an existing UnixEntry into a symbolic link"
        *)
       (# <<SLOT UnixEntryExisted: dopart>> #);

     followlinks: 
       (* If the disk entry corresponding to THIS(UnixEntry).path
        * exists and is a link to some other entry, then if
        * followlinks is true the disk entry pointed to is manipulated
        * by the operations below, otherwise the link itself is
        * manipulated.  Defaults to TRUE.
        *)
       (# f: @boolean;
       enter (# enter f <<SLOT UnixEntryChangeLink: dopart>> #)
       exit (# <<SLOT UnixEntryGetLink: dopart>> exit f #)
       #);
     
     permission: @permissiondesc
       (* An object to manipulate the protection and mode of
        * THIS(UnixEntry).  This gives a more fine-grained access to
        * the unix permissions than the inherited attributes
        * "readable" and "writeable".  All operations on "permission"
        * are used like this :
        * 
        * (who,mode) -> permission.operation ... ;
        * 
        * "who" denotes a category of users : 'a' -- all, 'u' -- user
        * (owner), 'g' -- group, 'o' -- other.
        * 
        * "mode" denotes the mode of THIS(UnixEntry) : 'r' -- read,
        * 'w' -- write, 'x' -- execute.
        *);
     (* idx+ *)
     permissiondesc:<
       (# <<SLOT UnixFilePermLib: attributes>>;
          
          (* PERMISSION EXCEPTIONS *)
          WrongUserError:< Exception
            (* Raised if something other than 'a', 'u', 'g', or 'o'
             * is specified for "who". Message: "Wrong user
             * specification for disk entry permission."
             *)
            (# <<SLOT UnixEntryPermWrongUser: dopart>> #);
          WrongModeError:< Exception
            (* Raised if something other than 'r', 'w', or 'x' is
             * specified for "mode". Message: "Wrong mode
             * specification for disk entry permission."
             *)
            (# <<SLOT UnixEntryPermWrongMode: dopart>> #);
          ChangePermError:< DiskEntryException
            (* Raised if a change of permissions has failed for
             * THIS(UnixEntry).  Message: "Failed to change permission
             * for disk entry."
             *)
            (# <<SLOT UnixEntryChangePermError: dopart>> #);
          OtherError:< DiskEntryException
            (* Raised if other errors occurred *);
          
          has:
            (* True if "who" has the "mode" access to
             * THIS(UnixEntry).
             *)
            (# mode,who: @char;
               result: @boolean;
            enter (who,mode)
            <<SLOT UnixEntryPermHas: dopart>>
            exit result
            #);
          add: 
            (* Give "who" the "mode" access to THIS(UnixEntry) *)
            (# mode,who: @char;
            enter (who,mode)
            <<SLOT UnixEntryPermAdd: dopart>>
            #);
          remove: 
            (* Remove the "mode" from the way "who" may access
             * THIS(UnixEntry).
             *) 
            (# mode,who: @char;
            enter (who,mode)
            <<SLOT UnixEntryPermRemove: dopart>>
            #);
       #); (* permission *)
     (* idx- *)
     device: IntegerValue
       (* Integer denoting the device on which the Inode of
        * THIS(UnixEntry) resides
        *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryDevice: dopart>>
       #);
     inode: IntegerValue
       (* Unambigous integer denoting the identity of this unix entry
        *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryInode: dopart>>
       #);
     isCharSpecial: BooleanValue
       (# error:<DiskEntryException;
       <<SLOT UnixEntryIsCharSpecial: dopart>>
       #);
     isBlockSpecial: BooleanValue
       (# error:<DiskEntryException;
       <<SLOT UnixEntryIsBlockSpecial: dopart>>
       #);
     isSymbolicLink: BooleanValue
       (* True if THIS(UnixEntry) is a symbolic link.  Always false
        * if followlinks is set to true (default)
        *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryIsSymLink: dopart>>
       #);
     isSocket: BooleanValue
       (* True if THIS(UnixEntry) is a socket *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryIsSocket: dopart>>
       #);
     hardLinks: IntegerValue
       (* Number of hard links to THIS(UnixEntry) *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryHardLinks: dopart>>
       #);
     deviceType: IntegerValue
       (* If THIS(UnixEntry) is a device, the integer exited denotes
        * the type of the device
        *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryDeviceType: dopart>>
       #);
     owner:
       (* Set/get the userid (an integer) denoting the identity of
        * the owner of THIS(UnixEntry)
        *) 
       (# uid: @integer;
          error:<DiskEntryException;
          set: (# enter uid do <<SLOT UnixEntrySetOwner: descriptor>> #);
          get: (# <<SLOT UnixEntryGetOwner: dopart>> exit uid #);
       enter set
       exit get
       #);
     group:
       (* Set/get the group id (an integer) denoting the identity of
        * the group to which the owner of THIS(UnixEntry) belongs
        *) 
       (# gid: @integer;
          error:<DiskEntryException;
          set: (# enter gid do <<SLOT UnixEntrySetGroup: descriptor>> #);
          get: (# <<SLOT UnixEntryGetGroup: dopart>> exit gid #);
       enter set
       exit get
       #);
     accessTime: IntegerValue
       (* The (system) time of the last read or write manipulation of
        * THIS(UnixEntry)
        *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryAccessTime: dopart>>
       #);
     statusTime: IntegerValue
       (* System time of the last status change of
        * THIS(UnixEntry). In our case a status change occurs when the
        * following operations are activated on THIS(UnixEntry):
        * touch, permission.add, permission.remove
        *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryStatusTime: dopart>>
       #);
     optimalBlockSize: IntegerValue
       (# error:<DiskEntryException;
       <<SLOT UnixEntryOptBlockSize: dopart>>
       #);
     blocks: IntegerValue 
       (* The actual number of blocks allocated for THIS(UnixEntry) *)
       (# error:<DiskEntryException;
       <<SLOT UnixEntryBlocks: dopart>>
       #);
     linkTo:
       (* Make THIS(UnixEntry) be a symbolic link to dst. The
        * 'exists' exception is raised if THIS(UnixEntry) allready
        * exists.
        *)
       (# dst: ^text;
          error:< DiskEntryException;
          exists:< UnixEntryExisted;
          link: ^UnixEntry;
       enter dst[]
       do <<SLOT UnixEntryLinkTo: descriptor>>;
       #);
     linkFrom:
       (* Make src be a symbolic link to THIS(UnixEntry). The
        * 'exists' exception is raised if src allready exists. If no
        * errors occur, link is a UnixEntry for the link, with
        * followlinks set to false.
        *)
       (# src: ^text;
          error:<DiskEntryException;
          exists:< UnixEntryExisted;
          link: ^UnixEntry;
       enter src[]
       do <<SLOT UnixEntryLinkFrom: descriptor>>;
       exit link
       #);
     
  #); (* UnixEntry *)


UnixFile: File
  (* BETA interface to disk files in UNIX *)
  (#
     <<SLOT UnixFileLib: attributes>>;
     
     EntryDesc::< UnixEntry;
     
     OpenExeWrite: 
       (* Like OpenWrite, except that the file written will be
        * executable
        *)
       (# <<SLOT UnixFileOpenExeWrite:dopart>> #);
     OpenExeAppend:
       (* Like OpenAppend, except that the file written will be
        * executable
        *)
       (# <<SLOT UnixFileOpenExeAppend:dopart>> #);
  #)
