ORIGIN '../unixfile';
INCLUDE '~beta/basiclib/v1.6/private/file_unixbody';
BUILD default '$$/unixfileInt.o' 'external/unixfileInt.c' '$CC -D$$ -c -o $0 $1';

-- LIB: attributes --
getEntryPermissions: External 
  (#
     path: [1]@char;
     permBuffer: @integer; 
     follow: @boolean; (* Follow links ? *)
     status: @integer; (* -1 => error *)
  enter(path,permBuffer,follow)
  exit status
  #);

getEntryDevice: External
  (# path: [1]@char;
     follow: @boolean;
     dev: @integer; (* -1 => error *)
  enter (path,follow)
  exit dev
  #);
getEntryInode: External
  (# path: [1]@char;
     follow: @boolean;
     inode: @integer; (* -1 => error *)
  enter (path,follow)
  exit inode
  #);
getEntryHardLinks: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryOwner: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryGroup: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryDeviceType: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryAccessTime: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryStatusTime: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryOptBlockSize: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
getEntryBlocks: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);


isEntryCharSpecial: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
isEntryBlockSpecial: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
isEntrySymLink: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);
isEntrySocket: External
  (# path: [1]@char;
     follow: @boolean;
     res: @integer; (* -1 => error *)
  enter (path,follow)
  exit res
  #);


-- UnixEntryChangeLink: dopart --
do f -> private.follow; true -> private.followset
   
-- UnixEntryGetLink: dopart --
do private.checkfollow;
   private.follow -> f
   
-- UnixEntryLib: attributes --
MakeFullPath: 
  (# p: ^text;
  do (if true
      // private.path.t[1]='/' then
         (* Already full path *)
         &text[]->p[]; private.path -> p;
      // '.' -> private.path.equal then
         getCurrentDir -> p[];
      else
         (* path relative to CWD *)
         getCurrentDir -> p[];
         '/' -> p.append;
         private.path[] -> p.append;
     if);
  exit p[]
  #);

   
-- UnixFilePermLib: attributes -- 

convert: 
  (# mode,who: @char;
     pos,offset: @integer;
     permbuf: [9]@integer;
  enter(who,mode)
  do (if who
      // 'a' then -1 -> pos
      // 'o' then 0 -> pos
      // 'g' then 3 -> pos
      // 'u' then 6 -> pos 
      else WrongUserError
     if);
     (if mode 
      // 'x' then 1 -> offset
      // 'w' then 2 -> offset
      // 'r' then 3 -> offset
      else WrongModeError
     if);
     (if ((private.path,@@permbuf[1],private.follow)->getEntryPermissions)=-1 
         then othererror
     if);
     inner;
  #);

convertAndAssign: convert
  (# 
  do inner;
     (if ((private.path,@@permBuf[1])->changeProtection) = -1 then
         ChangePermError;
     if);
  #);

-- UnixEntryExisted: dopart ---
do 'Attempt to make an existing UnixEntry into a symbolic link.\n' -> msg.append; INNER
   
-- UnixEntryChangePermError: dopart --
do 'Failed to change permission for disk entry.\n' -> msg.append; INNER

-- UnixEntryPermWrongUser: dopart-- 
do 'Wrong user specification for disk entry permission.\n' -> msg.append; INNER

-- UnixEntryPermWrongMode: dopart -- 
do 'Wrong mode specification for disk entry permission.\n' -> msg.append; INNER

-- UnixEntryPermHas: dopart -- 
do (who,mode) -> 
   convert(# 
          do (if pos=-1 then
                 (permbuf[  offset]=1) and
                 (permBuf[3+offset]=1) and
                 (permBuf[6+offset]=1)
 		   -> result;
              else
                 permBuf[pos+offset]=1 -> result;
             if);
          #);

-- UnixEntryPermAdd: dopart -- 
do (who,mode) -> 
   convertAndAssign
   (# 
   do (if pos=-1 then
          1 -> permBuf[offset];
          1 -> permBuf[3+offset];
          1 -> permBuf[6+offset];
       else
          1 -> permBuf[pos+offset] 
      if)
   #);

-- UnixEntryPermRemove: dopart -- 
do (who,mode) -> 
   convertAndAssign
   (# 
   do (if pos=-1 then
          0 -> permBuf[  offset];
          0 -> permBuf[3+offset];
          0 -> permBuf[6+offset];
       else
          0 -> permBuf[pos+offset]
      if)
   #);

-- UnixEntryDevice: dopart --
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryDevice -> value) = -1 then
       error
   if);

-- UnixEntryInode: dopart --  
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryInode -> value) = -1 then
       error
   if);

-- UnixEntryIsCharSpecial: dopart -- 
do private.checkfollow;
   (if ((private.path,private.follow)->isEntryCharSpecial)
    // -1 then
       error
    // 0 then false -> value
    // 1 then true -> value
   if);

-- UnixEntryIsBlockSpecial: dopart -- 
do private.checkfollow;
   (if ((private.path,private.follow)->isEntryBlockSpecial)
    // -1 then
       error
    // 0 then false -> value
    // 1 then true -> value
   if);

-- UnixEntryIsSymLink: dopart -- 
do private.checkfollow;
   (if ((private.path,private.follow)->isEntrySymlink)
    // -1 then
       error
    // 0 then false -> value
    // 1 then true -> value
   if);

-- UnixEntryIsSocket: dopart --  
do private.checkfollow;
   (if ((private.path,private.follow)->isEntrySocket)
    // -1 then
       error
    // 0 then false -> value
    // 1 then true -> value
   if);

-- UnixEntryHardLinks: dopart -- 
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryHardLinks -> value) = -1 then
       error
   if);

-- UnixEntryGetOwner: dopart --
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryOwner -> uid) = -1 then
       error
   if);

-- UnixEntryGetGroup: dopart --   
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryGroup -> gid) = -1 then
       error
   if);

-- UnixEntryDeviceType: dopart --  
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryDeviceType -> value) = -1 then
       error
   if);

-- UnixEntryAccessTime: dopart -- 
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryAccessTime -> value) = -1 then
       error
   if);

-- UnixEntryStatusTime: dopart -- 
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryStatusTime -> value) = -1 then
       error
   if);

-- UnixEntryOptBlockSize: dopart -- 
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryOptBlockSize -> value) = -1 then
       error
   if);

-- UnixEntryBlocks: dopart -- 
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryBlocks -> value) = -1 then
       error
   if);

-- UnixEntrySetOwner: descriptor -- 
(# gid: @integer;
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryGroup -> gid) = -1 then
       error
   if);
   (if (private.path, uid, gid) -> chownUnixEntry
    // -1 then error;
   if)
#)

-- UnixEntrySetGroup: descriptor --  
(# uid: @integer;
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryOwner -> uid) = -1 then
       error
   if);
   (if (private.path, uid, gid) -> chownUnixEntry
    // -1 then error;
   if)
#)

-- UnixEntryLinkFrom: descriptor --
(# path: ^text; 
do (if src[]//NONE then
    else
       (if ((src, false) -> entryExists)
        // -1 then error
        // 1 then exists
        else
           (if true
            // '.' -> private.path.equal
            // getCurrentDir -> private.path.equal then
               &text[]->path[]; private.path -> path;
            else
               makefullpath -> path[];
           if);
           (if ((src, path) -> makeSymLink)
            // -1 then error
            else
               &UnixEntry[] -> link[];
               false -> link.followlinks;
               src[] -> link.path;
           if);
       if);
   if)
#)

-- UnixEntryLinkTo: descriptor --
(# 
do (if dst[]//NONE then 
    else
       (if ((private.path, false) -> entryExists)
        // -1 then error
        // 1 then exists
        else
           (if ((private.path, dst) -> makeSymLink)
            // -1 then error
           if);
       if);
       
   if)
#)




-- UnixFileOpenExeWrite:dopart --
do INNER;
   entry.private.checkfollow;
   (if ((entry.private.path, entry.private.follow) -> entryExists)
    // -1 then entry.DiskEntryException
    // 1 then 
       (* Entry exist. If exec perm is not set previously, open
        * don't seem to work. Thus let's do it manually:
        *)
       ('a','x') -> entry.permission.add
   if);
   (entry.private.path[],writeCreateMode,true) -> doOpen;
   true -> private.outputFile;
   'w' -> private.SetUpUnixStream;

-- UnixFileOpenExeAppend:dopart -- 
do INNER;
   entry.private.checkfollow;
   (if ((entry.private.path, entry.private.follow) -> entryExists)
    // -1 then entry.DiskEntryException
    // 1 then 
       (* Entry exist. If exec perm is not set previously, open
        * don't seem to work. Thus let's do it manually:
        *)
       ('a','x') -> entry.permission.add
   if);
   (entry.private.path[], appendCreateMode,true) -> doOpen;
   true -> private.outputFile;
   'a' -> private.SetUpUnixStream;
