ORIGIN '../unixfile';
INCLUDE '~beta/basiclib/v1.6/private/file_unixbody';
BUILD default '$$/unixfileInt.o' 'external/unixfileInt.c' '$CC -D$$ -c -o $0 $1';

-- LIB: attributes --
getEntryDevice: External
  (# path: [1]@char;
     follow: @boolean;
     dev: @integer; (* -1 => error *)
  enter (path,follow)
  exit dev
  #);
getEntryInode: External
  (# path: [1]@char;
     follow: @boolean;
     inode: @integer; (* -1 => error *)
  enter (path,follow)
  exit inode
  #);

-- UnixEntryChangeLink: dopart --
do f -> private.follow; true -> private.followset
   
-- UnixEntryGetLink: dopart --
do private.checkfollow;
   private.follow -> f
   
-- UnixEntryLib: attributes --
MakeFullPath: 
  (# p: ^text;
  do (if true
      // private.path.t[1]='/' then
         (* Already full path *)
         &text[]->p[]; private.path -> p;
      // '.' -> private.path.equal then
         getCurrentDir -> p[];
      else
         (* path relative to CWD *)
         getCurrentDir -> p[];
         '/' -> p.append;
         private.path[] -> p.append;
     if);
  exit p[]
  #);

   
-- UnixFilePermLib: attributes -- 

convert: 
  (# mode,who: @char;
     pos,offset: @integer;
  enter(who,mode)
  do (if who
      // 'a' then -1 -> pos
      // 'o' then 0 -> pos
      // 'g' then 3 -> pos
      // 'u' then 6 -> pos 
      else WrongUserError
     if);
     (if mode 
      // 'x' then 1 -> offset
      // 'w' then 2 -> offset
      // 'r' then 3 -> offset
      else WrongModeError
     if);
     (if THIS(UnixEntry).private.dostat
      // True then othererror
     if);
     inner;
  #);

convertAndAssign: convert
  (# 
  do inner;
     (if (THIS(UnixEntry).private.path,@@THIS(UnixEntry).private.permBuf[1]) 
	   -> changeProtection
      // -1 then ChangePermError;
     if);
  #);

-- UnixEntryExisted: dopart ---
do 'Attempt to make an existing UnixEntry into a symbolic link.\n' -> msg.append; INNER
   
-- UnixEntryChangePermError: dopart --
do 'Failed to change permission for disk entry.\n' -> msg.append; INNER

-- UnixEntryPermWrongUser: dopart-- 
do 'Wrong user specification for disk entry permission.\n' -> msg.append; INNER

-- UnixEntryPermWrongMode: dopart -- 
do 'Wrong mode specification for disk entry permission.\n' -> msg.append; INNER

-- UnixEntryPermHas: dopart -- 
do (who,mode) -> 
   convert(# 
          do (if pos//-1 then
                 (THIS(UnixEntry).private.permBuf[  offset]=1) and
                 (THIS(UnixEntry).private.permBuf[3+offset]=1) and
                 (THIS(UnixEntry).private.permBuf[6+offset]=1)
 		   -> result;
              else
                 THIS(UnixEntry).private.permBuf[pos+offset]=1 -> result;
             if);
          #);

-- UnixEntryPermAdd: dopart -- 
do (who,mode) -> 
   convertAndAssign
   (# 
   do (if pos//-1 then
          1 -> THIS(UnixEntry).private.permBuf[offset];
          1 -> THIS(UnixEntry).private.permBuf[3+offset];
          1 -> THIS(UnixEntry).private.permBuf[6+offset];
       else
          1 -> THIS(UnixEntry).private.permBuf[pos+offset] 
      if)
   #);

-- UnixEntryPermRemove: dopart -- 
do (who,mode) -> 
   convertAndAssign
   (# 
   do (if pos//-1 then
          0 -> THIS(UnixEntry).private.permBuf[  offset];
          0 -> THIS(UnixEntry).private.permBuf[3+offset];
          0 -> THIS(UnixEntry).private.permBuf[6+offset];
       else
          0 -> THIS(UnixEntry).private.permBuf[pos+offset]
      if)
   #);

-- UnixEntryDevice: dopart --
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryDevice -> value) = -1 then
       error
   if);

-- UnixEntryInode: dopart --  
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryInode -> value) = -1 then
       error
   if);

-- UnixEntryIsCharSpecial: dopart -- 
do (if private.dostat
    // false then private.statBuf[4]=1 -> value
    // True then false -> value; error;
   if)

-- UnixEntryIsBlockSpecial: dopart -- 
do (if private.dostat
    // false then private.statBuf[5]=1 -> value
    // True then false -> value; error;
   if)

-- UnixEntryIsSymLink: dopart -- 
do (if private.dostat
    // false then private.statBuf[7]=1 -> value;
    // True then false -> value; error;
   if)

-- UnixEntryIsSocket: dopart --  
do (if private.dostat
    // false then private.statBuf[8]=1 -> value
    // True then false -> value; error;
   if)

-- UnixEntryHardLinks: dopart -- 
do (if private.dostat
    // false then private.statBuf[11] -> value
    // True then -1 -> value; error;
   if)

-- UnixEntryGetOwner: dopart --
do (if private.dostat
    // false then private.statBuf[12] -> uid
    // True then -1 -> uid; error;
   if)

-- UnixEntryGetGroup: dopart --   
do (if private.dostat
    // false then private.statBuf[13] -> gid
    // True then -1 -> gid; error;
   if)

-- UnixEntryDeviceType: dopart --  
do (if private.dostat
    // false then private.statBuf[14] -> value
    // True then -1 -> value; error;
   if)

-- UnixEntryAccessTime: dopart -- 
do (if private.dostat
    // false then private.statBuf[16] -> value
    // True then -1 -> value; error;
   if)

-- UnixEntryStatusTime: dopart -- 
do (if private.dostat
    // false then private.statBuf[18] -> value
    // True then -1 -> value; error;
   if)

-- UnixEntryOptBlockSize: dopart -- 
do (if private.dostat
    // false then private.statBuf[19] -> value
    // True then -1 -> value; error;
   if)

-- UnixEntryBlocks: dopart -- 
do (if private.dostat
    // false then private.statBuf[20] -> value
    // True then -1 -> value; error;
   if)


-- UnixEntrySetOwner: descriptor -- 
(# gid: @integer;
do (if private.dostat
    // false then private.statBuf[13] -> gid
    // True then -1 -> gid; error;
   if);
   (if (private.path, uid, gid) -> chownUnixEntry
    // -1 then error;
   if)
#)

-- UnixEntrySetGroup: descriptor --  
(# uid: @integer;
do (if private.dostat
    // false then private.statBuf[12] -> uid
    // True then -1 -> uid; error;
   if);
   (if (private.path, uid, gid) -> chownUnixEntry
    // -1 then error;
   if)
#)

-- UnixEntryLinkFrom: descriptor --
(# path: ^text; 
do (if src[]//NONE then
    else
       (if ((src, false) -> entryExists)
        // -1 then error
        // 1 then exists
        else
           (if true
            // '.' -> private.path.equal
            // getCurrentDir -> private.path.equal then
               &text[]->path[]; private.path -> path;
            else
               makefullpath -> path[];
           if);
           (if ((src, path) -> makeSymLink)
            // -1 then error
            else
               &UnixEntry[] -> link[];
               false -> link.followlinks;
               src[] -> link.path;
           if);
       if);
   if)
#)

-- UnixEntryLinkTo: descriptor --
(# 
do (if dst[]//NONE then 
    else
       (if ((private.path, false) -> entryExists)
        // -1 then error
        // 1 then exists
        else
           (if ((private.path, dst) -> makeSymLink)
            // -1 then error
           if);
       if);
       
   if)
#)




-- UnixFileOpenExeWrite:dopart --
do INNER;
   entry.private.checkfollow;
   (if ((entry.private.path, entry.private.follow) -> entryExists)
    // -1 then entry.DiskEntryException
    // 1 then 
       (* Entry exist. If exec perm is not set previously, open
        * don't seem to work. Thus let's do it manually:
        *)
       ('a','x') -> entry.permission.add
   if);
   (entry.private.path[],writeCreateMode,true) -> doOpen;
   true -> private.outputFile;
   'w' -> private.SetUpUnixStream;

-- UnixFileOpenExeAppend:dopart -- 
do INNER;
   entry.private.checkfollow;
   (if ((entry.private.path, entry.private.follow) -> entryExists)
    // -1 then entry.DiskEntryException
    // 1 then 
       (* Entry exist. If exec perm is not set previously, open
        * don't seem to work. Thus let's do it manually:
        *)
       ('a','x') -> entry.permission.add
   if);
   (entry.private.path[], appendCreateMode,true) -> doOpen;
   true -> private.outputFile;
   'a' -> private.SetUpUnixStream;
