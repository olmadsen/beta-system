ORIGIN '~beta/guienv/guienv';
LIB_DEF 'guienvutilsobguiadds' '../../lib';
BODY 'private/obguienvaddsbody';
BODY 'private/obrubberbody';
-- windowLib: Attributes --
wriggle:
  (# pos: @Point; reallyWriggle: @boolean (* nobody wants it now *)
  enter reallyWriggle
  do
     bringToFront;
     (if not reallyWriggle then leave wriggle if);
     position->pos;
     (- 10,0)->pos.add;
     pos->position;
     TRUE->update;
     (for i: 10 repeat
       (if i mod 2 = 1 then
           (20-(2*i),0)->pos.add; pos->position; TRUE->update; 
        else
           (- 20+(2*i),0)->pos.add; pos->position; TRUE->update; 
       if);
       
     for);
     
  #);
  

-- windowItemLib: Attributes --
(* RESIZERELATIVE
 * ==============
 *
 * Changes the frame of a child windowItem in response, and relative
 * to, a change in the frame of the father frame, as reported by
 * eventHandler.onFatherFrameChanged *)
resizeRelative:
  (# theEvent: ^theEventHandler.onFatherFrameChanged; 
  enter theEvent[]
  do <<SLOT VEUresizeRelative:Descriptor>>
  #);
onFatherFrameResizeRelative: action
  (#
     eventType::
      theEventHandler.fatherFrameChanged;
     
  do theEvent[]->resizeRelative; 
  #);
installResizeRelativeAction:
  (# 
  do
     &onFatherFrameResizeRelative[]
       ->appendAction;
     
  #);
itemPos:
(* Returns the position of this windowItem in the coordinatsystem
 * of the surrounding window. *)
  (# pos: @Point;  <<SLOT VEUitemPos:DoPart>> exit pos #);
FrameDrawer:
(* If UseRunningOutline is TRUE, FrameDrawer draws a
 * running outline around THIS(windowItem) until kill is called.
 * Otherwise a black outline is drawn and kept refreshed until kill
 * is called.
 *)
  (#
     <<SLOT FrameDrawerLib:Attributes>>;
     kill:
       (# doupdate: @Boolean; 
       enter doupdate
       <<SLOT FrameDrawerKill:DoPart>>
       #);
     fdprivate: @<<SLOT FrameDrawerPrivate:Descriptor>>;
     UseRunningOutline: @Boolean;
     
  enter UseRunningOutline
  <<SLOT FrameDrawerDo:DoPart>>
  #);
mydrag:
(* Differs from drag by drawing without clipping the children, and
 * by taking a start point from which mousemoves should be handled
 * relatively. Furthermore, the frame of this windowItem is not set,
 * but the resulting frame is returned. *)
  (# startpos: @Point; newFrame: @rectangle; 
  enter startpos
  <<SLOT obrubbermydrag:DoPart>>
  exit newFrame
  #);
  

-- canvasLib: Attributes --
getOutline:
(* Lets the user define a default rectangle by dragging and resizing
 * an outline. When an outline has been defined, done is called.
 * When the rectangle is not being resized, it is presented with an
 * illusion of a running outline. 
 *)
  (#
     done:< (# result: @rectangle;  enter result do INNER #);
     default: @rectangle;
     
  enter default
  do <<SLOT canvasGetOutlineBody:Descriptor>>
  #);
defineRect:
(* Used to resize window rectangles. *)
  (# theRect: @rectangle; followWhenOutside: @Boolean; 
  enter (theRect,followWhenOutside)
  do <<SLOT DefineRectBody:Descriptor>>
  exit theRect
  #);
simpleDefineRect:
(* Used to define a simple rectangle, starting in the point entered. *)
  (# p: @Point; theRect: @rectangle; 
  enter p
  do <<SLOT SimpleDefineRectBody:Descriptor>>
  exit theRect
  #);
browserDrawRect:
(* Draws (or clears) rectangle. *)
  (# theRect: @rectangle; 
  enter theRect
  <<SLOT browserrubberdrawRect:DoPart>>
  #);
  

-- lib: Attributes --
actionList: List
  (#
     element::  (# action: ##Object #);
     appendAction:
       (# new: ^element; action: ##Object; 
       enter action##
       do &element[]->new[]; action##->new.action##; new[]->append; 
       #);
     
  #);
actionedMenuItemAction:
  (# paramType:< Object; param: ^paramType; checked: @Boolean; 
  enter param[]
  do INNER
  exit checked
  #);
actionedMenuItemOnStatus:
  (# paramType:< Object; param: ^paramType; value: @Boolean
  enter param[]
  do INNER
  exit value
  #);
  

-- menuLib: Attributes --
actionedMenuItem: menuItem
  (#
     onSelectAction: ##actionedMenuItemAction;
     onStatusAction: ##actionedMenuItemOnStatus;
     paramType:< Object;
     param: ^paramType;
     open::< 
       (# itemname: ^Text; 
       enter (onSelectAction##,onStatusAction##,param[],itemname[])
       do THIS(actionedMenuItem)[]->append; itemname[]->name; INNER ; 
       #);
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
               (if onSelectAction## <> none then
                   param[]->onSelectAction->checked
               if);
               INNER ;
               
            #);
          onStatus::< 
            (# 
            do
               (if onStatusAction## <> none then
                   param[]->onStatusAction->value
               if);
               INNER ;
               
            #);
          
       #);
     
  #);
  

