ORIGIN '../pane';
INCLUDE '../../graphics';
INCLUDE '../graphicsadds'; (* graphics.clipChildren *)
INCLUDE '../guienvadds'; (* translate *)
--- panelib:attributes ---
enforceConstraints:
  (# beforeframe,afterframe: @rectangle;
     pos: @Point;
  do dppriv.members[1].frame->beforeframe;
     (for i: dppriv.last-1 repeat
          dppriv.members[i+1].frame->afterframe;
          (if dppriv.moved[i] then
              dppriv.seps[i].position->pos;
              (if dppriv.vs then
                  pos.v-1->beforeframe.bottom;
                  pos.v+dppriv.pw->afterframe.top;
               else
                  pos.h-1->beforeframe.right;
                  pos.h+dppriv.pw->afterframe.left;
              if);
          if);
          (if not (dppriv.members[i].frame->beforeframe.isEqual) then
              beforeframe->dppriv.members[i].frame
          if);
          (if i<dppriv.last-1 then
              afterframe->beforeframe;
           else
              (if not (dppriv.members[dppriv.last].frame
                    ->afterframe.isEqual) then
                  afterframe->dppriv.members[dppriv.last].frame
              if);
          if);
     for);
  #);

panecanvas: canvas
  (# inx: @Integer; (* Index in dppriv.seps *)
     eventHandler::
       (# onMouseDown::
            (# pos,oldpos,fsize,fpos: @Point; tmpRect: @rectangle;
               mouseMoved: @Boolean;
               sepinx: @Integer; sep: ^panecanvas;
               down: (# exit 1 #);
               up: (# exit 2 #);
               walkPanes:
                 (# direction: @Integer;
                    getpos:
                      (# p: @Point; value: @Integer;
                      enter p
                      do (if dppriv.vs then p.v->value;
                          else p.h->value;
                         if);
                      exit value
                      #);
                    setpos:
                      (# p: ^Point; value: @Integer;
                      enter (p[],value)
                      do (if dppriv.vs then value-> p.v
                          else value->p.h
                         if);
                      #);
                    sepinx: @Integer;
                 enter direction
                 do position->oldpos;
                    TRUE->dppriv.moved[inx];
                    (if direction
                     //down then
                        inx+1->sepinx;
                        loop:
                          (if sepinx<dppriv.last then
                              dppriv.seps[sepinx][]->sep[];
                              sep.position->pos;
                              (if (oldpos->getpos)+dppriv.pw+dppriv.ms>(pos->getpos)
                                  then
                                  (pos[],(oldpos->getpos)+dppriv.pw+dppriv.ms)
                                    ->setpos;
                                  pos->sep.position;
                                  TRUE->dppriv.moved[sepinx];
                               else
                                  leave loop;
                              if);
                              (oldpos[],pos->getpos)->setpos; 
                              sepinx+1->sepinx;
                              restart loop;
                          if);
                     //up then
                        inx-1->sepinx;
                        loop:
                          (if sepinx>0 then
                              dppriv.seps[sepinx][]->sep[];
                              sep.position->pos;
                              (if (oldpos->getpos)<(pos->getpos)+dppriv.pw+dppriv.ms
                                  then
                                  (pos[],(oldpos->getpos)-dppriv.pw-dppriv.ms)
                                    ->setpos;
                                  pos->sep.position;
                                  TRUE->dppriv.moved[sepinx];
                               else
                                  leave loop;
                              if);
                              (oldpos[],pos->getpos)->setpos; 
                              sepinx-1->sepinx;
                              restart loop;
                          if);
                    if);
                    enforceConstraints;
                 #);
            do 
               (if not (dppriv.sliding or ((inx=dppriv.last) and not shiftKey)) then
                   position->oldpos;
                   fatherFrame->tmpRect; tmpRect.size->fsize;
                   (position,this(paneCanvas)[],father.father[])
                     ->translate->fpos;
                   father.father.graphics
                   (# overrideChildren:: (# do TRUE -> value #);
                   do patterns.black[]->Pen.stipple; 
                      TransferModes.xorBlend->Pen.mode;
                      2->pen.size;
                      father.father.trackmouse
                      (# draw: @
                           (# 
                           do
                              (if dppriv.vs then
                                  ((fpos.h,pos.v-dppriv.pw),(fpos.h,pos.v))
                                    ->drawLine;
                                  (if not (shiftKey and (onMemberResize=paneResizable)) then
                                      ((fpos.h,pos.v),(fpos.h,pos.v+dppriv.pw))
                                        ->drawLine;
                                  if);
                                  ((fpos.h+fsize.h,pos.v-dppriv.pw),(fpos.h+fsize.h,pos.v))
                                    ->drawLine;
                                  ((fpos.h,pos.v),(fpos.h+fsize.h,pos.v))->drawLine;
                                  (if not (shiftKey and (onMemberResize=paneResizable)) then
                                      ((fpos.h+fsize.h,pos.v),(fpos.h+fsize.h,pos.v+dppriv.pw))
                                        ->drawLine;
                                  if);
                               else
                                  ((pos.h-dppriv.pw,fpos.v),(pos.h,fpos.v))
                                    ->drawLine;
                                  (if not (shiftKey and (onMemberResize=paneResizable)) then
                                      ((pos.h,fpos.v),(pos.h+dppriv.pw,fpos.v))
                                        ->drawLine;
                                  if);
                                  ((pos.h,fpos.v),(pos.h,fpos.v+fsize.v))->drawLine;
                                  ((pos.h-dppriv.pw,fpos.v+fsize.v),(pos.h,fpos.v+fsize.v))
                                    ->drawLine;
                                  (if not (shiftKey and (onMemberResize=paneResizable)) then
                                      ((pos.h,fpos.v+fsize.v),(pos.h+dppriv.pw,fpos.v+fsize.v))
                                        ->drawLine;
                                  if);
                              if);
                           #);
                         mousePress:: (# do curPt->pos; draw #);
                         mouseMove:: 
                           (# 
                           do (if dppriv.vs then
                                  (if curPt.v<>prevPt.v then
                                      draw;
                                      curPt->pos;
                                      draw;
                                      true->mouseMoved;
                                  if);
                               else
                                  (if curPt.h<>prevPt.h then
                                      draw;
                                      curPt->pos;
                                      draw;
                                      true->mouseMoved;
                                  if);
                              if);      
                           #);
                         mouseRelease::
                           (# 
                           do draw;
                           #);
                      #);
                   #);
                   (if Shiftkey and (onMemberResize=paneResizable) then
                       (# delta: @Integer;
                          sz: @Point;
                          oldmembers: [0]^Canvas;
                       do
                          (* Resize member before separator *)
                          (if dppriv.vs then
                              (if (pos.v-oldpos.v->delta)<>0 then
                                  prevmember.size->sz;
                                  (sz.h,sz.v+delta)->prevmember.size;
                              if);
                           else
                              (if (pos.h-oldpos.h->delta)<>0 then
                                  prevmember.size->sz;
                                  (sz.h+delta,sz.v)->prevmember.size;
                              if);
                          if);
                          
                          (* Use appendMember to slide members into position. *)
                          TRUE->dppriv.sliding;
                          (0,0)->dppriv.szaccum;
                          dppriv.members->oldmembers;
                          0->dppriv.last->dppriv.members.new;
                          
                          (for j:oldmembers.range repeat
                               oldmembers[j][]->appendMember
                               (# 
                               do (* Slide separator into new position: *)
                                  (if dppriv.seps[j][]<>NONE then
                                      j->dppriv.seps[j].attach;
                                  if);
                               #);
                          for);
                          appendsDone;
                          FALSE->dppriv.sliding;
                       #)
                    else
                       (if true
                        //not mouseMoved then
                           (* nothing *)
                        //dppriv.vs then
                           (inx*dppriv.ms+(inx-1)*dppriv.pw,pos.v)->max->pos.v;
                           (fsize.v-(dppriv.last-inx)*(dppriv.ms+dppriv.pw),pos.v)
                             ->min->pos.v;
                           (if true
                            //pos.v>oldpos.v then
                               (* Walk down *)
                               pos.v->oldpos.v; oldpos->position;
                               down->walkPanes;
                            //pos.v<oldpos.v then
                               (* Walk up *)
                               pos.v->oldpos.v; oldpos->position;
                               up->walkPanes;
                           if);
                        else
                           (inx*dppriv.ms+(inx-1)*dppriv.pw,pos.h)->max->pos.h;
                           (fsize.h-(dppriv.last-inx)*(dppriv.ms+dppriv.pw),pos.h)
                             ->min->pos.h;
                           (if true
                            //pos.h>oldpos.h then
                               (* Walk right *)
                               pos.h->oldpos.h; oldpos->position;
                               down->walkPanes;
                            //pos.h<oldpos.h then
                               (* Walk left *)
                               pos.h->oldpos.h; oldpos->position;
                               up->walkPanes;
                           if);
                       if);
                   if);
               if);
            #);
       #);
     memberaction: prevmember.action
       (# eventType:: prevmember.theEventHandler.frameChanged;
          sz,nsz: @Point;
       do (if not dppriv.sliding then
              (if not dppriv.moved[inx] then
                  (* The event was not generated due to this pane being 
                   * moved. *)
                  size->sz; theEvent.newFrame.size->nsz;
                  (if dppriv.vs then
                      (0,theEvent.newFrame.bottom+1)->position;
                      (nsz.h,sz.v)->size;
                   else
                      (theEvent.newFrame.right+1,0)->position;
                      (sz.h,nsz.v)->size;
                  if);
              if);
              FALSE->dppriv.moved[inx];
          if);
       #);
     prevmember: ^Canvas;
     pmaction: ^memberaction;
     open:: 
       (# 
       enter inx
       do
          dppriv.members[inx][]->prevmember[];
          attach;
          cursors.cross[]->theCursor;
          &memberaction[]->pmaction[]->prevmember.appendAction;
       #);
     attach:
       (# pframe, tmpRect: @rectangle; fsize: @Point;
       enter inx
       do 
          THIS(panecanvas)[]->dppriv.seps[inx][];
          dppriv.members[inx].frame->pframe;
          fatherFrame->tmpRect; tmpRect.size->fsize;
          (if dppriv.vs then
              (0,pframe.bottom+1)->position;
              (fsize.h,dppriv.pw)->size;
           else
              (pframe.right+1,0)->position;
              (dppriv.pw,fsize.v)->size;
          if);
       #);
     deattach:
       (#
       do pmaction[]->prevmember.deleteAction;
       #);
  #);

--- paneonframechanged:descriptor ---
(# sz: @point;
   ofw,ofh,nfw,nfh,w,h,lastPane: @Integer;
   frames: [dppriv.last]@rectangle;
   sw,sh: @real;
do
   (if (not dppriv.resizing) and (dppriv.last<>0) then
       
       (* External event caused resize *)
       
       oldFrame.size->(ofw,ofh);
       (* OldFatherWidth, OldFatherHeight *)
       
       newFrame.size->(nfw,nfh);
       (* NewFatherWidth, NewFatherHeight *)
       
       (if (nfw<>ofw) or (nfh<>ofh) then
           
           (for i: dppriv.last repeat
                (if dppriv.fixedSize[i] and not dppriv.vs then
                    (if dppriv.members[i][]=dppriv.zoomed[] then
                        dppriv.zoomedFrame.size->(w,h)
                     else
                        dppriv.members[i].size->(w,h)
                    if);
                    nfw-w->nfw; ofw-w->ofw;
                if);
                (if dppriv.fixedSize[i] and dppriv.vs then
                    (if dppriv.members[i][]=dppriv.zoomed[] then
                        dppriv.zoomedFrame.size->(w,h)
                     else
                        dppriv.members[i].size->(w,h)
                    if);
                    nfh-h->nfh; ofh-h->ofh;
                if);
           for);
           
           nfw/ofw->sw; nfh/ofh->sh;
           
           (0,0)->dppriv.szaccum;
           (for i: dppriv.last repeat
                (if dppriv.members[i][]=dppriv.zoomed[] then
                    dppriv.zoomedFrame.size->sz
                 else
                    dppriv.members[i].size->sz
                if);
                (if not (dppriv.fixedSize[i] and dppriv.vs) then
                    sz.v*sh->sz.v
                if);
                (if not (dppriv.fixedSize[i] and not dppriv.vs) then
                    sz.h*sw->sz.h
                if);
                
                dppriv.szaccum.v->frames[i].top;
                dppriv.szaccum.h->frames[i].left;
                
                frames[i].top+sz.v->frames[i].bottom;
                frames[i].left+sz.h->frames[i].right;
                (if dppriv.vs then
                    (0,sz.v)->dppriv.szaccum.add;
                    (0,dppriv.pw)->dppriv.szaccum.add;
					
					(*
					 * Michael: testing
					 *)
					 (0, 1) -> dppriv.szaccum.add;
                 else
                    (sz.h,0)->dppriv.szaccum.add;
                    (dppriv.pw,0)->dppriv.szaccum.add;
					
					(*
					 * Michael: testing
					 *)
					 (1, 0) -> dppriv.szaccum.add;
                if);          
           for);
           (# sz, error: @point;
              setFrame:
                (# i: @integer
                enter i
                do (if dppriv.members[i][]=dppriv.zoomed[] then
                       frames[i]->dppriv.zoomedFrame;
                       fatherFrame->dppriv.members[i].frame
                    else
                       frames[i]->dppriv.members[i].frame
                   if)
                #)
           do newframe.size->(nfw,nfh);
              (if ((not dppriv.vs and (dppriv.szaccum.h<>nfw)) or
                  (dppriv.vs and (dppriv.szaccum.v<>nfh))) then
                  (for i: dppriv.last repeat
                       (if not dppriv.fixedSize[i] then i->lastPane if)
                  for);
                  (if dppriv.vs then
                      (0,nfh-dppriv.szaccum.v)->error
                   else
                      (nfw-dppriv.szaccum.h,0)->error
                  if);
                  (for i: lastPane-1 repeat
                       i->setFrame
                  for);
                  frames[lastPane].size->sz;
                  error->sz.add; sz->frames[lastPane].size;
                  lastPane->setFrame;
                  (for i: dppriv.last-lastPane repeat
                       error->frames[i+lastPane].offset;
                       i+lastPane->setFrame
                  for)
               else
                  (for i: dppriv.last repeat
                       i->setFrame
                  for);
              if)
           #);
       if);
   if);
   (if dppriv.zoomed[]<>NONE then
       fitToFather
       (# fitHoriz:: (# do true->value #);
          fitVert:: (# do true->value #);
       #);
       newFrame->dppriv.zoomedPaneFrame
   if);
   
   INNER onFrameChanged;
#)

--- paneopen:dopart ---
do setDefaults;
   (2,panewidth)->max->dppriv.pw;
   verticalStacking->dppriv.vs;
   minsize->dppriv.ms;
   0->dppriv.extcount;
   
   INNER open;

--- paneappendmember:dopart ---
do (# msz: @Point;
   do 
      dppriv.last+1->dppriv.last;
      1->dppriv.members.extend;
      1->dppriv.fixedSize.extend;
      dppriv.extcount+1->dppriv.extcount;
      
      member.size->msz;
      (if dppriv.vs then
          (0,dppriv.szaccum.v)->member.position;
          ((dppriv.szaccum.h,msz.h)->max,dppriv.szaccum.v+msz.v)
            ->dppriv.szaccum;
          (0,dppriv.pw)->dppriv.szaccum.add;
       else
          (dppriv.szaccum.h,0)->member.position;
          (dppriv.szaccum.h+msz.h,(dppriv.szaccum.v,msz.v)->max)
            ->dppriv.szaccum;
          (dppriv.pw,0)->dppriv.szaccum.add;
      if);
      
      member[]->dppriv.members[dppriv.last][];
      INNER appendmember;
   #);

--- paneappenddone: dopart ---
do
   (# sz,msz: @Point;
   do dppriv.szaccum->sz;
      (dppriv.pw,sz.v)->max->sz.v;
      (dppriv.pw,sz.h)->max->sz.h; (* to avoid zero-sized pane *)
      
      (if onMemberResize=paneFixed then
          (if dppriv.vs then
              (0,-dppriv.pw)->sz.add;
           else
              (-dppriv.pw,0)->sz.add;
          if);          
      if);
      
      TRUE->dppriv.resizing; sz->size; FALSE->dppriv.resizing; 
   
      (if not dppriv.sliding then
          (if dppriv.extcount>0 then
              dppriv.extcount->dppriv.seps.extend;
              dppriv.extcount->dppriv.moved.extend;
          if);
      if);
      
      (for i: dppriv.last-1 repeat
           (if not dppriv.sliding then
               (if dppriv.seps[i][]//NONE then 
                   (* Ensure members are same heigth (or width) *)
                   dppriv.members[i].size->msz;
                   (if dppriv.vs then
                       (if msz.h<>sz.h then
                           (sz.h,msz.v)->dppriv.members[i].size;
                       if);
                    else
                       (if msz.v<>sz.v then
                           (msz.h,sz.v)->dppriv.members[i].size;
                       if);
                   if);
                   (NONE,i)->(&panecanvas[]).open 
               if);
           if)
      for);
      (if not dppriv.sliding  and (onMemberResize=paneResizable) then
          (NONE,dppriv.last)->(&panecanvas[]).open
      if);
      
      0->dppriv.extcount;
   #);
   
--- paneFixedSize: dopart ---
do 
   find:
     (for i: dppriv.last repeat
          (if dppriv.members[i][]=member[] then
              true->dppriv.fixedSize[i];
              leave find;
          if)
     for)

--- panedeletemember:dopart ---
do 
   (if dppriv.zoomed[]=member[] then unzoom if);
   
   TRUE->dppriv.sliding;

   (* Find and remove member and corresponding separator. *)
   remove:
     (for i: dppriv.last repeat
          (if dppriv.members[i][]=member[] then
              
              member.close;
              NONE->dppriv.members[i][];

	      (if dppriv.last>1 then
                  (* Deattach and close a separator: *)
                  (if true
                   //i<=dppriv.last then
                      dppriv.seps[i].deattach; dppriv.seps[i].close;
                      NONE->dppriv.seps[i][];
                   else
                      dppriv.seps[i-1].deattach; dppriv.seps[i-1].close;
                      NONE->dppriv.seps[i-1][];
                  if)
              if);

              (* Reset and simulate open with remaining members *)
              (# oldmembers: [0]^Canvas;
                 skipped: @Integer;
              do 
	         (0,0)->dppriv.szaccum;
	         dppriv.members->oldmembers;
                 0->dppriv.last->dppriv.members.new;

                 (for j:oldmembers.range repeat
                      (if oldmembers[j][]<>NONE then
                          oldmembers[j][]->appendMember
                          (# 
                          do (* Slide separator into new position: *)
                             (if dppriv.seps[j][]<>NONE then
                                 j-skipped->dppriv.seps[j].attach;
                             if);
                          #);
                       else
                          1->skipped;
                      if);
                 for);
                 appendsDone;
                 (* Update dppriv.moved to new size: *)
	         dppriv.last->dppriv.moved.new;
                 (* Update dppriv.seps to new size: *)
                 (if dppriv.last>0 then
                     dppriv.seps[1:dppriv.last]->dppriv.seps;
                  else
                     0->dppriv.seps.new;
                 if);
                     
                 leave remove;
              #);
          if)
     for);

   FALSE->dppriv.sliding;
       
 
--- paneZoomMember:dopart ---
do (if dppriv.zoomed[]<>NONE then
       unzoom
   if);
   member[]->dppriv.zoomed[];
   member.frame->dppriv.zoomedFrame;
   frame->dppriv.zoomedPaneFrame;
   fatherFrame->member.frame;
   TRUE->dppriv.resizing;fatherFrame->frame;FALSE->dppriv.resizing;
   (for i: dppriv.last repeat
        (if dppriv.members[i][]<>dppriv.zoomed[] then
            dppriv.members[i].hide;
            (if dppriv.seps[i][]<>NONE then dppriv.seps[i].hide if)
        if)
   for);
   
--- paneUnzoom:dopart ---
do (if dppriv.zoomed[]<>NONE then
       (for i: dppriv.last repeat
            dppriv.members[i].show;
            (if dppriv.seps[i][]<>NONE then dppriv.seps[i].show if)
       for);
       fitToFather
       (# fitHoriz:: (# do true->value #);
          fitVert:: (# do true->value #);
       #);
       dppriv.zoomedFrame->dppriv.zoomed.frame;
       NONE->dppriv.zoomed[]
   if);
   
--- panefithorizdefault:descriptor ---
(# do dppriv.vs->value #)
--- panefitvertdefault:descriptor ---
(# do not dppriv.vs->value #)
--- panefittofather:descriptor ---
(# fsz,msz,newsz: @Point; tmpRect: @rectangle
do fatherFrame->tmpRect; tmpRect.size->fsz;
   size->msz->newsz;
   (if fitHoriz then fsz.h->newsz.h if);
   (if fitVert then fsz.v->newsz.v if);
   (if not (newsz->msz.isEqual) then newsz->size if);       
#)

--- paneprivate:descriptor ---
(# seps: [0]^panecanvas;
   moved: [0]@Boolean;
   members: [0]^Canvas;
   fixedSize: [0]@Boolean;
   last: @Integer;
   szaccum: @Point;
   vs: @Boolean; (* VerticalStacking *)
   ms: @Integer; (* minsize          *)
   pw: @Integer; (* panewidth        *)

   extcount: @Integer; (* Number of panes to add in this append round. *)
   sliding: @Boolean;  (* TRUE iff appendMember is used to slide members. *)
   resizing: @Boolean; (* TRUE iff appendsDone is setting size. *)
   zoomed: ^Canvas; (* not NONE iff zoomed[] fills the entire pane. *)
   zoomedFrame: @rectangle;
   zoomedPaneFrame: @rectangle;
#)
