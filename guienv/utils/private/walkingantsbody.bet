ORIGIN '../walkingants';

INCLUDE '../../graphics';
INCLUDE '../graphicsadds';


-- GUIenvWalkingAntsStart: doPart --
do (if status = inActive then
       1 -> private.currentInx;
       (if interval = 0 then
	   100 -> interval
       if);
       interval -> private.onTimer.start;
       active -> status;
       private.drawCurrent;
   if);
   

-- GUIenvWalkingAntsStop: doPart --
do (if status = active then
       private.onTimer.stop;
       private.rectangles.iterate
       (# 
       do true -> current.elm.item.update;
       #);
       inActive -> status;
   if);

-- GUIenvWalkingAntsInit: doPart --
do 'stripes1' -> loadPixmap -> private.stripes[1][];
   'stripes2' -> loadPixmap -> private.stripes[2][];
   'stripes3' -> loadPixmap -> private.stripes[3][];
   'stripes4' -> loadPixmap -> private.stripes[4][];
   'stripes5' -> loadPixmap -> private.stripes[5][];
   'stripes6' -> loadPixmap -> private.stripes[6][];
   'stripes7' -> loadPixmap -> private.stripes[7][];
   'stripes8' -> loadPixmap -> private.stripes[8][];
   oneWay -> style;
   inActive -> status;
   inner;

-- walkingAntsLib: attributes --

loadPixmap:
  (# pm: ^pixmap;
     name: ^text;
  enter name[]
  do &pixmap[] -> pm[];
     name[] -> pm.read
       (# error::
	    (# errorMsg: ^text;
	    do msg[] -> errorMsg[];
	       exception
		 (#
		 do 'Failed to read pixmap "' -> msg.putText;
		    name[] -> msg.putText;
		    '"' -> msg.putLine;
		    '==>' -> msg.putLine;
		    errorMsg[] -> msg.putLine;
		 #);
	    #)
       #)
  exit pm[]
  #);


status:
  (#
  enter private.status
  exit private.status
  #);

active: (# exit 1 #);
inActive: (# exit 2 #);
-- GUIenvWalkingAntsPrivate: descriptor --
(# status: @integer;

   stripes: [8] ^pixmap;
   currentInx: @integer;
   step: @integer;

   drawCurrent: @
     (#
     do rectangles.iterate
	(#
	do current.elm.item.graphics
	   (# (* Draw on top of children of THIS(canvas)
	      overrideChildren:: (# do true -> value #); *)
	   do stripes[currentInx][] ->  pen.stipple;
	      (if pensize<>0 then pensize -> pen.size; if);
	      current.elm.area -> drawRect;
	   #);
	#);

     #);

   onTimer: @timer
     (# action::
	  (#
	  do (if style
	      //oneWay then
		 (if currentInx = 8 then
		     1 -> currentInx;
		  else
		     1 + currentInx -> currentInx;
		 if);
	      else
		 (if currentInx
		  //4 then
		     -1 -> step;
		  //1 then
		     1 -> step;
		 if);
		 currentInx + step -> currentInx;
	     if);
	     drawCurrent;
	  #);
     #);
   rectangles: @list
     (# element::
	  (# area: ^rectangle;
	     item: ^window.windowItem;
	  #);

	add:
	  (# area: ^rectangle;
	     item: ^window.windowItem;

	  enter (item[], area[])
	  do (# elm: ^element;
	     do &element[] -> elm[];
		item[] -> elm.item[];
		area[] -> elm.area[];
		elm[] -> append;
	     #);
	  #);

	remove:
	  (# area: ^rectangle;
	     item: ^window.windowItem;
	  enter (item[], area[])
	  do l: iterate
	     (#
	     do (if (current.elm.item[] = item[])
		     and
		    (area[] = none) then
		    current[] -> delete;
		    leave l;
		if);
	     #);
	  #);
     #);
#)

-- walkingAntsAdd: doPart --
do (theWindowItem[], theRectangle[]) -> private.rectangles.add;
   (if status = active then
       private.drawCurrent;
   if);

-- walkingAntsDelete: doPart --
do (theWindowItem[], theRectangle[]) -> private.rectangles.remove;
   true -> theWindowItem.update;
   (* (if status = active then
    *        private.drawCurrent;
    *    if);
    *)

-- walkingAntsClear: doPart --
do private.rectangles.clear;
