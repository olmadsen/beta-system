ORIGIN '../promptForArgs';
INCLUDE 'promptsbody';

--PromptForArgsLib: attributes --
insert:
  (# t: ^text
  enter t[]
  do argc+1 -> argc;
     (if argc>argv.range then
         argv.range -> argv.extend;
     if);
     t[] -> argv[argc][];
  #);

--PromptForArgsValidate: descriptor--
(# inWord, inTickString, inQuoteString: @boolean; 
   lastsep, inx: @integer;
   lastquote: @char;
   
do 1 -> argv.new;
   0 -> argc;
   0 -> lastsep;
   0 -> inx;
   false -> inTickString;
   false -> inQuoteString;
   false -> inWord;
   1->inx;
   true -> THIS(validate).value;
   false -> hiliteOnError;
   scan:
     (if inx<=usertext.lgth then
         (if true
          // usertext.T[inx]= '''' then
             (if inTickString then
                 (if lastquote='"' then
                     (* Unterminated quotestring in tickstring *)
                     false -> THIS(validate).value;
                     leave scan;
                 else
                     (* Terminate tickstring *)
                     (lastsep+2, inx-1) -> usertext.sub -> insert;
                     false -> inWord;
                     false -> inTickString;
                     inx+1->lastsep;
                 if)
              else
                 (if not inQuoteString then true -> inTickString if);
             if);
             (if lastquote='''' then
                 0 -> lastquote;
              else
                 ''''->lastquote;
             if);
          // usertext.T[inx]= '"' then
             (if inQuoteString then
                 (if lastquote='''' then
                     (* Unterminated tickstring in quotestring *)
                     false -> THIS(validate).value;
                     leave scan;
                 else
                     (* Terminate quotestring *)
                     (lastsep+2, inx-1) -> usertext.sub -> insert;
                     false -> inQuoteString;
                     false -> inWord;
                     inx+1->lastsep;
                 if)
              else
                 (if not inTickString then true -> inQuoteString if);
             if);
             (if lastquote='"' then
                 0 -> lastquote;
              else
                 '"'->lastquote;
             if);
          // usertext.T[inx]->ascii.isWhiteSpace then
             (* Met whitespace *)
             (if true
              // inTickString then (* keep going *)
              // inQuoteString then (* keep going *)
              else
                 (if inWord then
                     (* Complete previous word *)
                     (lastsep+1,inx-1) 
                       -> usertext.sub
                       -> insert;
                     false -> inWord;
                 if);
                 inx->lastsep;
             if)
          else
             (* Met ordinary character - just continue *)
             true -> inWord;
         if);
         inx+1 -> inx;
         restart scan;
      else
         (if (inTickString or inQuoteString) then
             (* Unterminated string *)
             false -> THIS(validate).value;
          else
             (if lastsep+1<=inx-1 then
                 (* Terminate last word *)
                 (lastsep+1,inx-1)->usertext.sub->insert;
             if);
         if);
         leave scan;
     if);
   (if not THIS(validate).value then 
       (0, inx-1) -> private.theText.selection;
   if);

#)
