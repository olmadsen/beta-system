Origin '~beta/guienv/fields';
INCLUDE '~beta/basiclib/pcre';

--windowLib: attributes--

indentRegexps:
  (#
     editPcre: pcre
       (# editorReplace:< replace #);
     
     blockPcre:
       (# blockDepth: @integer;
          begin, end: ^text;
          theBlockPcre: ^pcre; (* (.* )(begin | end)(.* )  *)          
       #);
     
     reg: [1] ^editPcre; 
     blockreg: [1] ^blockPcre;
     eater: ^pcre;
     nonCaseSensitive: @boolean;
     
     (* (.* )(begin1 | begin2 | ...)(.* )  *)
     lastBlockBegin_pcre,lastBlockEnd_pcre: ^pcre;
     
     init: (# do ('^ *'->pcre)->eater[]; #);
     
     setNumberOfRegexps: 
       (# i: @integer;
       enter i
       do (if i-reg.range>0 then
              i-reg.range->reg.extend    
          if);
       #);
     
     setNumberOfBlocks:
       (# i: @integer;
       enter i
       do (if i-blockReg.range>0 then
              i-blockReg.range->blockReg.extend
          if);
       #);
     
     eat_indent:
       (# i: @integer; t: ^text; b : @boolean;
       enter t[]
       do t.length->i;
          (t[],'')->eater.replace->(b,t[]);
       exit (i-t.length,t[])
       #);
     
     init_reg:
       (# regNumber: @integer; t: ^text;
          specialPcre:<editPcre;
       enter t[]
       do INNER;
          (t[]->specialPcre)->reg[regNumber][];          
       #);
     
     init_block:
       (# begin,end,blockRegexp: ^text;
          blockDepth,blockNumber: @integer;
          newBlock: ^blockPcre;
       enter (begin[],end[],blockDepth)
       do
          INNER;
          &blockPcre[]->newBlock[];
          blockDepth->newBlock.blockDepth;
          begin[]->newBlock.begin[];
          end[]->newBlock.end[];
          '(.*)('->blockRegexp[];
          begin[]->escape_special_characters
            ->blockRegexp.append;
          '|'->blockRegexp.append;
          end[]->escape_special_characters
            ->blockRegexp.append;          
          ').*'->blockRegexp.append;
          blockRegexp[]->pcre->newBlock.theBlockPcre[];
          newBlock[]->blockreg[blockNumber][]; 
          (if blockNumber=blockreg.range then init_blockRelated if);
       #);
     
     (* called when the last block is initialized *)
     init_blockRelated:
       (# 
          regexp: ^text;          
       do           
          '(.*)('->regexp[];
          (for i: blockreg.range repeat
               blockreg[i].begin[]->escape_special_characters
                 ->regexp.append;
               (if i<>blockreg.range then '|'->regexp.append; if);
          for);
          ').*'->regexp.append;
          regexp[]->pcre->lastBlockBegin_pcre[];
          '(.*)('->regexp[];
          (for i: blockreg.range repeat
               blockreg[i].end[]->escape_special_characters
                 ->regexp.append;
               (if i<>blockreg.range then '|'->regexp.append; if);
          for);
          ').*'->regexp.append;
          regexp[]->pcre->lastBlockEnd_pcre[]; 
       #);
     
     lastBlockBegin: removePattern
       (# block: @integer;
          matchingBlock: ^text;
       enter t[]
       do
          (t[],'')->lastBlockBegin_pcre.replace
          (# rep::
               (# do 
                  sub1->value[];
                  (for i: blockreg.range repeat
                       (if sub2->blockreg[i].begin.equal then
                           i->block;
                           blockreg[i].end.copy->matchingBlock[];
                       if);
                  for); 
               #)
          #)->(b,t[]);
          (if block<>0 then 
              t.length+blockreg[block].blockDepth->block
          if); 
       exit (b,block,matchingBlock[])
       #);
     
     lastBlockEnd: removePattern
       (# block: @integer;
       enter t[]
       do
          (t[],'')->lastBlockEnd_pcre.replace
          (# rep::
               (# do
                  sub1->value[];
                  (for i:blockreg.range repeat
                       (if sub2->blockreg[i].end.equal then
                           i->block;
                       if);
                  for);
               #)             
          #)->(b,t[]);          
       exit block
       #);
     
     RemoveBlock: removePattern
       (# firstBlock: @boolean;
          blockNumber: @integer;
       enter (t[],blockNumber)
       do
          (t[],'')->blockreg[blockNumber].theblockPcre.replace
          (# rep::(# do 
                     sub1->value[]; 
                     sub2->blockreg[blockNumber].begin.equal
                       ->firstblock; 
                  #)
          #)->(b,t[]);
       exit (b,firstBlock)
       #);
     
     removePattern:
       (# t,orig: ^text;
          b: @boolean;
       do
          t[]->orig[]; 
          INNER;
          orig.clear;
          t[]->orig.puttext;
       #);
               
     reg_match: 
       (# t: ^text; regNumber: @integer;
       enter t[]
       do INNER;
       exit t[]->reg[regNumber].match
       #); 
     
     reg_replace: removePattern
       (# result: @boolean; regNumber: @integer;
       enter t[]
       do INNER;
          (t[],'')->reg[regNumber].editorReplace->(result,t[]);
       exit result
       #);
     
     reg_replaceAll: removePattern
       (# result: @boolean;
          regNumber: @integer;
       enter t[] 
       do INNER;
          (t[],'')->reg[regNumber].replaceAll->(result,t[]);
       exit result
       #);
     
     
     escape_special_characters:
       (# t,result: ^text;
       enter t[]
       do
          &text[]->result[];
          t.reset;          
          (if (t.T.range>0) and (t.T[1]->isAscii) then
              '\\b'->result.append;
          if); 
          (for i:t.length repeat
               (if t.T[i]
                // '(' 
                // ')' 
                // '?'
                // '*' then
                   '\\'->result.append; 
               if);
               t.T[i]->result.put;
          for);
          (if (t.T.range>0) and (t.T[t.length]->isAscii) then
              '\\b'->result.append;
          if); 
       exit result[]
       #);
     
     lowercase:
       (# t: ^text; 
       enter t[]
       do (for i:t.length repeat
               (if t.T[i]->isAscii then (t.T[i] %Bor 2x100000)->t.T[i]; 
               if);
          for); 
       exit t[]
       #);
     
     isAscii:
       (# ch: @char; 
       enter ch 
          (* clearing bit 6 converts lower case to uppercase *)
       exit ('A'<=(ch %Band 2x1011111)) and 
          ((ch %Band 2x1011111)<='Z')
       #); 
     
#);
