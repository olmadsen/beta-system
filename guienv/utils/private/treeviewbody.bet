ORIGIN '../treeview';
INCLUDE '~beta/containers/list'
        '~beta/guienv/utils/interfaceObjectAdds'
        '~beta/guienv/graphics'
        '~beta/guienv/controls'
        '~beta/guienv/utils/graphicsadds'
        '~beta/guienv/utils/scrolleradds'
        '~beta/basiclib/formatio';
-- treeviewlib: Attributes --
iconWidth: (#  exit 18 (* oprindeligt 22 *) #);
iconHeight: (#  exit 17 (* oprindeligt 16 *) #);
  

-- treeviewItemIcon: DoPart --
do INNER ; i[]->itemPrivate.icon[]  

-- treeviewFolderOpenedIcon: DoPart --
do
   INNER ;
   true->folderprivate.hasicons;
   (if openicon[] <> none then
       openicon[]->folderprivate.openedicon[]
    else
       i[]->folderprivate.openedicon[]
   if);
   i[]->folderPrivate.closedicon[]  

-- treeviewItemPopupMenu: DoPart --
do INNER ; m[]->itemPrivate.popupMenu[];   

-- treeviewItemScrollIntoView: DoPart --
do
     (# first,last,h,v,hscroll,vscroll: @integer; scroll: @boolean
     do
        sc.thescroll->(hscroll,vscroll);
        (vscroll div iconWidth)+1->first;
        sc.viewsize->(h,v);
        (v div iconWidth)->v;
        first+v->last;
        (if (itemPrivate.grid.v <= first) or (itemPrivate.grid.v >= last) then
            (itemPrivate.grid.v-(v div 2)-1)*iconWidth->vscroll; true->scroll
        if);
        (if (itemPrivate.grid.h*iconHeight <= hscroll) or
        (itemPrivate.grid.h*iconHeight >= hscroll+h) then
            itemPrivate.grid.h*iconHeight->hscroll; true->scroll
        if);
        (if scroll then (hscroll,vscroll)->sc.thescroll if)
     #)  

-- treeviewItemSelect: DoPart --
do
   (if (treeviewPrivate.root[],THIS(item)[])->treeviewPrivate.openToItem then
       (if visible then treeviewPrivate.update; itemPrivate.doSelect if);
       onSelected
   if);
   INNER  

-- treeviewItemDeselect: DoPart --
do
   (if THIS(item)[] = selection[] then
       false->selection.itemPrivate.selected;
       treeviewPrivate.updateTreeviewGraphics
         (# 
         do
            (selection.label[],selection.itemPrivate.selected,
             selection.itemPrivate.grid)->writeInGrid
         #);
       none ->selection[];
       
   if);
   INNER  

-- treeviewItemOnselected: DoPart --
do itemPrivate.doSelect; INNER  

-- treeviewItemOniconselected: DoPart --
do INNER ; ev[]->onSelected  

-- treeviewItemOnlabelchanged: DoPart --
do INNER  

-- treeviewItemPrivate: Descriptor --
(#
   selected: @boolean;
   vline: [100] @boolean;
   toggle,icon: ^pixmap;
   popupMenu: ^guienv.menu;
   level: @integer;
   grid: @point;
   doSelect: @
     (# 
     do
        (if THIS(item)[] <> selection[] then
            (if selection[] <> none then
                false->selection.itemPrivate.selected;
                treeviewPrivate.updateTreeviewGraphics
                  (#  do selection[]->drawItem #);
                
            if);
            THIS(item)[]->selection[];
            true->selection.itemPrivate.selected;
            treeviewPrivate.updateTreeviewGraphics
              (#  do selection[]->drawItem #)
        if)
     #)
#)  

-- treeviewFolderOnselected: DoPart --
do
   (if (ev[] <> none ) and (ev.doubleclick) then onToggleSelected if); INNER  

-- treeviewFolderOniconselected: DoPart --
do INNER  

-- treeviewFolderOntoggleselected: DoPart --
do
   INNER ;
   (if folderPrivate.open then onCollapse else onExpand if);
   (* to ensure update of toggle, etc. if the folder is empty: *)
   treeviewPrivate.updateTreeviewGraphics
     (#  do THIS(item)[]->drawItem #);
     

-- treeviewFolderOnexpand: DoPart --
do INNER ; true->folderPrivate.open; treeviewPrivate.update  

-- treeviewFolderOncollapse: DoPart --
do INNER ; false->folderPrivate.open; treeviewPrivate.update  

-- treeviewFolderIsExpanded: DoPart --
do folderPrivate.open->open  

-- treeviewFolderPrivate: Descriptor --
(# openedicon,closedicon: ^pixmap; open,hasicons: @boolean;  #)  

-- treeviewSetRoot: DoPart --
do
   f[]->treeviewPrivate.root[];
   (if treeviewPrivate.images[] = none then treeviewPrivate.init if);
   (if isOpen then (if visible then treeviewPrivate.update if) if);
     

-- treeviewGetRoot: DoPart --
do treeviewPrivate.root[]->f[]  

-- treeviewchanged: DoPart --
do (if visible then treeviewPrivate.update if); INNER  

-- treeviewOnrefresh: DoPart --
do updateRect->treeviewPrivate.updateTreeview; INNER  

-- treeviewOnmousedown: DoPart --
do
     (# h,v,line,level: @integer; l: ^treeviewPrivate.levelType; 
     do
        localPosition->(h,v);
        (h div iconHeight)+1->level;
        (v div iconWidth)+1->line;
        (if line <= treeviewPrivate.numberOfItems then
            treeviewPrivate.levels[line][]->l[];
            (if buttonState = 3 then
                (if l.elm.itemPrivate.popupMenu[] <> none then
                    (1,localposition,THIS(treeview)[])
                      ->l.elm.itemPrivate.popupMenu.popup;
                    
                if)
            if)
        if)
     #)  

-- treeviewOnmouseup: DoPart --
do
     (#
        h,v,line,level: @integer;
        l: ^treeviewPrivate.levelType;
        previousSelection: ^item
     do
        treeviewPrivate.editLabel.hide;
        localPosition->(h,v);
        (h div iconHeight)+1->level;
        (v div iconWidth)+1->line;
        (if line <= treeviewPrivate.numberOfItems then
            (if line <= treeviewPrivate.levels.range then
                treeviewPrivate.levels[line][]->l[];
                (if true
                 // level > l.level+1 then
                    selection[]->previousSelection[];
                    THIS(onMouseUp)[]->l.elm.onSelected;
                    (if (l.elm[] = previousSelection[]) and l.elm.allowLabelEdit
                     then
                        (if not doubleclick then
                            l.elm[]->treeviewPrivate.editTimer.prepareEdit
                         else
                            treeviewPrivate.editTimer.stop
                        if)
                    if)
                 // level = l.level+1 then
                    THIS(onMouseUp)[]->l.elm.onIconSelected
                 // (level = l.level) and l.elm.isFolder then
                    (l.elm[]->qua (# as:: folder #)).onToggleSelected
                if)
            if)
        if)
     #);
   INNER  

-- treeviewOpen: DoPart --
do
   INNER ;
   (if treeviewPrivate.images[] = none then treeviewPrivate.init if);
   treeviewPrivate.editLabel.open;
     

-- treeviewPrivate: Descriptor --
(#
   images: ^treeviewImages;
   levels: [100] @levelType;
   numberOfItems: @integer;
   levelType: (# level: @integer; elm: ^item #);
   newWidth,newHeight: @integer;
   ts: ^textstyle;
   editLabel: @edittext
     (#
        open:: 
          (# 
          do hide; ts[]->style; THIS(treeview).backgroundcolor->backgroundcolor
          #);
        i: ^item;
        eventhandler:: 
          (#
             onVisibleChanged:: 
               (# 
               do
                  (if not visible and (i[] <> none ) then
                      (if not (contents->i.label.equal) then
                          contents->i.onLabelChanged
                      if);
                      none ->i[]
                  if);
                  
               #)
          #)
     #);
   editTimer: @timer
     (#
        prepareEdit:
          (#  enter editLabel.i[] do 1000 (* 1 sec *) ->start;  #);
        action:: 
          (# 
          do
             stop;
             treeviewPrivate.updateTreeviewGraphics
               (# 
               do
                  (selection.label[],selection.itemPrivate.selected,
                   selection.itemPrivate.grid)->editInGrid
               #)
          #)
     #);
   root: ^folder;
   init:
     (# 
     do
        getTreeviewImages->images[];
        &textstyle[]->ts[];
        'helvetica'->ts.name;
        10->ts.size;
        textFaces.plain->ts.face;
        (if isOpen then (if visible then update if) if)
     #);
   update: @
     (#
        h,v: @integer;
        r: @rectangle;
        level: @integer;
        minWidth,minHeight: @integer;
        count: @integer;
        
     enter level
     do
     (* implicitly executing treeviewPrivate.updateTreeview since
      * this(treeview).size results in onRefresh being executed
      *)
        treeviewPrivate.setupTreeview;
        (if hideRoot then 0->newHeight else iconWidth->newHeight if);
        0->newWidth;
        (root[],1)->calcSize;
        minSize->(minWidth,minHeight);
        (minWidth,newWidth)->max->newWidth;
        (minHeight,newHeight)->max->newHeight;
        (*(newwidth,newHeight+iconHeight)->THIS(treeview).size;*)
        (newwidth,newHeight)->theEventhandler.onUpdate;
        
     #);
   calcSize:
     (# f: ^treeview.folder; level: @integer; w: @integer; 
     enter (f[],level)
     do
        (if f.folderPrivate.open then
            f.items.scan
              (# 
              do
                 newHeight+iconWidth->newHeight;
                 (level+2)*iconHeight+4->w;
                 w+(current.label[]->ts.widthoftext)->w;
                 (if w > newWidth then w->newWidth if);
                 (if current.isFolder then
                     (if
                     (current[]->qua (# as:: folder #)).folderPrivate.open then
                         level+1->putint;
                         ' level'->putLine;
                         (current[],level+1)->calcSize
                     if)
                 if)
              #)
         else
            (level+2)*iconHeight+4->w;
            w+(f.label[]->ts.widthoftext)->w;
            (if w > newWidth then w->newWidth if);
            
        if);
        
     #);
   updateTreeview: @updateTreeviewGraphics
     (# clip: ^rectangle; inx,last: @integer; 
     enter clip[]
     do
        (clip.top div iconWidth)+1->inx;
        (clip.bottom div iconWidth)+1->last;
        loop:
        (if (inx <= last) and (inx <= numberOfItems) then
            levels[inx].elm[]->drawItem; inx+1->inx; restart loop
        if);
        
     #);
   updateTreeviewGraphics: graphics
     (#
        writeInGrid: @
          (# t: ^text; grid: @point; h,v: @integer; selected: @boolean; 
          enter (t[],selected,grid)
          do
             grid->(h,v);
             (if selected then
                 (0,0,0xfffff)->pen.foregroundcolor;
                 (((h+1)*iconHeight+2,(v-1)*iconWidth+2),
                  ((h+1)*iconHeight+6+(t[]->ts.widthoftext),v*iconWidth-1))
                   ->fillrect;
                 
              else
                 backgroundcolor->pen.foregroundcolor; 
             if);
             ((h+1)*iconHeight+4,v*iconWidth-4)->moveTo;
             (if selected then
                 (0xfffff,0xfffff,0xfffff)->pen.foregroundcolor
              else
                 (0,0,0)->pen.foregroundcolor
             if);
             ts[]->style;
             t[]->drawText;
             
          #);
        editInGrid: @
          (# t: ^text; grid: @point; h,v: @integer; selected: @boolean; 
          enter (t[],selected,grid)
          do
             grid->(h,v);
             (((h+1)*iconHeight+2,(v-1)*iconWidth+2),
              ((h+1)*iconHeight+6+(t[]->ts.widthoftext)+10,v*iconWidth))
               ->editLabel.frame;
             t[]->editLabel.contents;
             editLabel.show
          #);
        drawItem: @
          (# itm: ^item; h,v: @integer
          enter itm[]
          do
             itm.itemPrivate.grid->(h,v);
             backgroundcolor->pen.foregroundcolor;
             (((h-1)*iconHeight,(v-1)*iconWidth+2),
              ((h+2)*iconHeight+(itm.label[]->ts.widthoftext),v*iconWidth-1))
               ->fillrect;
             (for l: h-1 repeat
               (if itm.itemPrivate.vline[l] then
                   (images.pm[12][],(0,0),((l-1)*iconHeight,(v-1)*iconWidth),
                    iconHeight,iconWidth)->drawRaster
               if)
             for);
             (itm.itemPrivate.toggle[],(0,0),((h-1)*iconHeight,(v-1)*iconWidth),
              iconHeight,iconWidth)->drawRaster;
             (itm.itemPrivate.icon[],(0,0),(h*iconHeight,(v-1)*iconWidth),
              iconHeight,iconWidth)->drawRaster;
             (if itm.label[] <> none then
                 (itm.label[],itm.itemPrivate.selected,itm.itemPrivate.grid)
                   ->writeInGrid
             if)
          #);
        
     do INNER
     #);
   setupTreeview: @
     (#
        vline: [100] @boolean;
        drawFolder:
          (# f: ^treeview.folder; level,noOfItems: @integer; 
          enter (f[],level)
          do
             f.items.size->noOfItems;
             (if level > vline.range then 100->vline.extend if);
             true->vline[level];
             f.items.scan
               (# count: @integer
               do
                  numberOfItems+1->numberOfItems;
                  count+1->count;
                  (level,numberOfItems)->current.itemPrivate.grid;
                  (if numberOfItems > levels.range then
                      100->levels.extend
                  if);
                  level->levels[numberOfItems].level;
                  current[]->levels[numberOfItems].elm[];
                  (if current.isFolder then
                      current[]->f[];
                      (if (level = 1) and hideRoot then
                      (* this is the toplevel *)
                          false->vline[level];
                          (if f.folderPrivate.open then
                              images.pm[14][]->current.itemPrivate.toggle[]
                           else
                              images.pm[13][]->current.itemPrivate.toggle[]
                          if)
                       else
                          (if count >= noOfItems (* last item *) then
                              false->vline[level];
                              (if f.folderPrivate.open then
                                  images.pm[7][]->current.itemPrivate.toggle[]
                               else
                                  images.pm[11][]->current.itemPrivate.toggle[]
                              if)
                           else
                              (if f.folderPrivate.open then
                                  images.pm[6][]->current.itemPrivate.toggle[]
                               else
                                  images.pm[10][]->current.itemPrivate.toggle[]
                              if)
                          if)
                      if);
                      (if (*current.itemPrivate.icon[]=none*) not
                      f.folderprivate.hasicons then
                          (if f.folderPrivate.open then
                              images.pm[2][]->current.itemPrivate.icon[]
                           else
                              images.pm[1][]->current.itemPrivate.icon[]
                          if)
                       else
                          (if f.folderPrivate.open then
                              f.folderPrivate.openedicon[]
                                ->current.itemPrivate.icon[]
                           else
                              f.folderPrivate.closedicon[]
                                ->current.itemPrivate.icon[]
                          if)
                      if);
                      vline->current.itemPrivate.vline;
                      (if f.folderPrivate.open then
                          (f[],level+1)->drawFolder
                      if)
                   else
                      (if (level = 1) and hideRoot then
                      (* this is the toplevel *)
                          images.pm[5][]->current.itemPrivate.toggle[]
                       else
                          (if count >= noOfItems (* last item *) then
                              false->vline[level];
                              images.pm[9][]->current.itemPrivate.toggle[]
                           else
                              images.pm[8][]->current.itemPrivate.toggle[]
                          if)
                      if);
                      (if current.itemPrivate.icon[] = none then
                          images.pm[3][]->current.itemPrivate.icon[]
                      if);
                      vline->current.itemPrivate.vline;
                      
                  if)
               #)
          #);
        rootLevel: @integer;
        
     do
        (if not hideRoot then
            (rootLevel,1)->root.itemPrivate.grid;
            (if root.folderPrivate.open then
                images.pm[7][]->root.itemPrivate.toggle[];
                images.pm[2][]->root.itemPrivate.icon[];
                
             else
                images.pm[6][]->root.itemPrivate.toggle[];
                images.pm[1][]->root.itemPrivate.icon[];
                
            if);
            1->numberOfItems;
            rootLevel->levels[numberOfItems].level;
            root[]->levels[numberOfItems].elm[];
            (if root.folderPrivate.open then
                (root[],rootLevel+1)->drawFolder
            if)
         else
            0->numberOfItems;
            true->root.folderPrivate.open;
            (root[],1)->drawFolder
        if)
     #);
   openToItem:
     (# i: ^item; f: ^folder; found: @boolean
     enter (f[],i[])
     do
        search: f.items.scan
          (# 
          do
             (if current[] = i[] then
                 true->found; leave search
              else
                 (if current.isfolder then
                     (if (current[]->qua (# as:: folder #),i[])->openToItem then
                         true->found; leave search
                     if)
                 if)
             if)
          #);
        (if found then true->f.folderPrivate.open if)
     exit found
     #);
   treeviewImages:
     (#
        pm: [14] @pixmap;
        init:
          (# 
          do
             'tv-folderclosed'->pm[1].read;
             'tv-folderopen'->pm[2].read;
             'tv-doc'->pm[3].read;
             'tv-link'->pm[4].read;
             'tv-blank'->pm[5].read;
             'tv-mnode'->pm[6].read;
             'tv-mlastnode'->pm[7].read;
             'tv-node'->pm[8].read;
             'tv-lastnode'->pm[9].read;
             'tv-pnode'->pm[10].read;
             'tv-plastnode'->pm[11].read;
             'tv-vertline'->pm[12].read;
             'tv-prootnode'->pm[13].read;
             'tv-mrootnode'->pm[14].read;
             
          #);
        
     #);
   getTreeviewImages: objectPool.get
     (#
        type:: treeViewImages;
        exact:: trueObject;
        init::  (#  do obj.init #)
     #)
#)  

