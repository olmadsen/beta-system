ORIGIN '~beta/guienv/utils/codeTextField';
-- secure_posToRowCol: DoPart --
do
     (# begin,end: @integer; 
     do
        texteditingExtent->(begin,end);
        (if (pos >= begin) and (pos <= end) then
            pos->posToRowCol->value
         else
            (if pos < begin then begin->posToRowCol->value if);
            (if pos > end then end->posToRowCol->value if);
            
        if);
        
     #)  

-- set_selection: DoPart --
do
     (# begin,end: @integer
     do
        texteditingExtent->(begin,end);
        (if pos < begin then begin->pos if);
        (if pos > end then end->pos if);
        (if endpos < begin then begin->endpos if);
        (if endpos > end then end->endpos if);
        (pos,endpos)->selection
     #)  

-- textfield_beginning_of_line: DoPart --
do
     (# pos: @integer
     do
        selection.start->posToRowCol->global;
        beginning_of_line;
        global->rowColToPos->pos;
        (pos,pos)->set_selection
     #)  

-- textfield_next_line: DoPart --
do
     (# pos: @integer
     do
        selection.start->posToRowCol->global;
        next_line;
        global->rowColToPos->pos;
        (pos,pos)->set_selection
     #)  

-- textfield_previous_line: DoPart --
do
     (# pos: @integer
     do
        selection.start->posToRowCol->global;
        previous_line;
        global->rowColToPos->pos;
        (pos,pos)->set_selection;
        
     #)  

-- textfield_end_of_line: DoPart --
do
     (# pos: @integer
     do
        selection.start->posToRowCol->global;
        end_of_line;
        global->rowColToPos->pos;
        (pos,pos)->set_selection
     #)  

-- beginning_of_line: DoPart --
do
     (# begin,end: @integer
     do
        (if not (first_line) then
            1->global.col
         else
            texteditingExtent->(begin,end); begin->posToRowCol->global
        if)
     #)  

-- end_of_line: DoPart --
do
     (# begin,end: @integer
     do
        (if not (last_line) then
            (global.row+1,0)->rowColToPos->posToRowCol->global
         else
            texteditingExtent->(begin,end); end->posToRowCol->global
        if)
     #)  

-- previous_line: DoPart --
do
     (# col,begin,end: @integer; beginPos: @rowCol
     do
        global.col->col;
        texteditingExtent->(begin,end);
        (if not (first_line) then
            (global.row,0)->rowColToPos->posToRowCol->global;
            (if global.col > col then col->global.col if);
            (if first_line then
                begin->posToRowCol->beginPos;
                (if beginPos.col > global.col then
                    beginPos.col->global.col
                if)
            if)
         else
            begin->posToRowCol->global
        if)
     #)  

-- next_line: DoPart --
do
     (# col,begin,end: @integer
     do
        global.col->col;
        (if not (last_line) then
            (global.row+1,1)->rowColToPos->posToRowCol->global;
            end_of_line;
            (if global.col > col then col->global.col if)
         else
            texteditingExtent->(begin,end); end->posToRowCol->global
        if)
     #)  

-- current_line: DoPart --
do
     (# pos,endpos: @integer; mem: @rowCol
     do
        global->mem;
        (if not (globalFresh) then
            contents->globalText[]; true->globalFresh
        if);
        beginning_of_line;
        global->rowColToPos->pos;
        end_of_line;
        global->rowColToPos->endpos;
        (pos+1,endpos)->globalText.sub->t[];
        (if regexp.nonCaseSensitive then t[]->regexp.lowercase->t[] if);
        mem->global
     #)  

-- insertText: DoPart --
do
     (# pos: @integer
     do
        (if t[] <> none then
            global->rowColToPos->pos; (pos,pos)->set_selection; t[]->insert
        if)
     #)  

-- deleteText: DoPart --
do
     (# pos,endpos: @integer
     do
        begin->rowColToPos->pos;
        (if begin.row = end.row then
            pos+end.col-begin.col->endpos
         else
            end->rowColToPos->endpos
        if);
        (pos,endpos)->set_selection;
        delete
     #)  

-- getSelection: DoPart --
do
     (# pos,endpos: @integer
     do
        begin->rowColToPos->pos;
        (if begin.row = end.row then
            pos+end.col-begin.col->endpos
         else
            end->rowColToPos->endpos
        if);
        (pos,endpos)->set_selection;
        selection.contents->result[]
     #)  

-- last_line: DoPart --
do
     (# begin,end: @integer; last: @rowCol
     do
        texteditingExtent->(begin,end);
        end->posToRowCol->last;
        (last.row = global.row)->result
     #);
     

-- first_line: DoPart --
do
     (# begin,end: @integer; first: @rowCol
     do
        texteditingExtent->(begin,end);
        begin->posToRowCol->first;
        (global.row = first.row)->result
     #);
     

-- indent_by_int: DoPart --
do
     (# current_indent: @integer; t: ^text; begin,end: @rowCol
     enter t[]
     do
        (if t[] = none then current_line->t[] if);
        t[]->regexp.eat_indent->(current_indent,t[]);
        (if (current_indent > indent) and (indent >= 0) then
            beginning_of_line;
            global->begin;
            global.row->end.row;
            global.col+current_indent-indent->end.col;
            (begin,end)->deleteText
        if);
        (if (current_indent < indent) then
            beginning_of_line; indent-current_indent->get_whitespace->insertText
        if)
     #)  

-- eat_indent: DoPart --
do
   t[]->regexp.eat_indent->(indent,res[]);
   (if (first_line) then beginning_of_line; global.col-1+indent->indent if)  

-- get_whitespace: DoPart --
do &text[]->result[]; (for i repeat ' '->result.append for)  

-- indent_textField: DoPart --
do
     (# pos: @integer
     do
        selection.start->pos;
        texteditingExtent->indentHandler;
        (pos,pos)->set_selection
     #)  

-- frozen_indent_line: DoPart --
do disableUpdate; line->indent_line->updateLine  

-- indent_line: DoPart --
do
     (# pos: @integer
     do
        (if entered.row = 0 then
            selection.start->posToRowCol->global
         else
            entered->global
        if);
        global.row->lineNumber;
        1->offset;
        current_line->current[]->regexp.eat_indent->(indent_value,t[]);
        (if global.col > indent_value then
            global.col-indent_value->offset
        if);
        INNER indent_line;
        (if indent_value > 0 then
            indent_value+offset->global.col
         else
            offset->global.col
        if);
        global->rowColToPos->pos;
        (pos,pos)->set_selection
     #)  

-- getBlockIndent: DoPart --
do
     (#
        count,mem1,mem2: @integer;
        b,finished,firstBlock: @boolean;
        mem: @rowCol
     do
        global->mem;
        toploop: cycle
          (# 
          do
             loop: cycle
               (# 
               do
                  (t[],getBlockNumber)->regexp.RemoveBlock->(b,firstBlock);
                  (if not (b) then
                      leave loop; 
                   else
                      (if firstBlock then
                          (if count = 0 then (* t.length->blockIndent; *)
                              t[]->eat_indent->(block.col,t[]);
                              block.col+t.length->block.col;
                              global.row->block.row;
                              true->finished;
                              leave loop
                          if);
                          count-1->count
                       else
                          count+1->count
                      if)
                  if)
               #);
             (if finished then
                 INNER getBlockIndent; leave toploop; 
              else
                 (if first_line then (* error: missing blockBegin *)
                     (0,0)->block; leave toploop
                 if);
                 previous_line;
                 true->differentLines;
                 current_line->t[]
             if)
          #);
        (* toploop *)
        mem->global
     #)  

-- indentHandler: DoPart --
do
     (# depth,lineNumber,x,y1,y2: @integer; begin,end: @rowcol
     do
        pos->posToPt->(x,y1);
        endpos->posToPt->(x,y2);
        pos->posToRowCol->begin;
        endpos->posToRowCol->end;
        disableUpdate;
        end.row-begin.row+1->depth;
        begin->indent_line->lineNumber;
        (for depth-1 repeat next_line; global->indent_line for);
        (y1,y2)->updateRegion
     #)  

-- keyDownTimer_action: DoPart --
do
     (# begin,end,col: @integer
     do
        stop;
        (if texteditMode then
            (if theKey
             // 30 then (* textfield_previous_line *)
                
             // 31 then (* textfield_next_line *)
                
             // specKeys.HOME then
                (if controlModified then
                    texteditingExtent->(begin,end);
                    (begin,begin)->set_selection;
                    selection.scrollintoview;
                    enableUpdate
                 else
                    textfield_beginning_of_line;
                    selection.start->posToRowCol->(updateLine,col)
                if)
             // specKeys.END then
                (if controlModified then
                    texteditingExtent->(begin,end);
                    (end,end)->set_selection;
                    selection.scrollintoview;
                    enableUpdate
                 else
                    textfield_end_of_line;
                    selection.start->posToRowCol->(updateLine,col)
                if)
             // 8 then
                texteditingExtent->(begin,end);
                selection.start->col;
                (if col < begin then ' '->insert if)
             // 127 then
                texteditingExtent->(begin,end);
                selection.start->col;
                (if col > end then ' '->insert; (col,col)->set_selection if)
            if)
        if)
     #)  

-- codeTextField_onKeyDown: DoPart --
do
   controlkey->controlmodified;
   metaKey->metaModified;
   (if texteditmode then
       (if trace then 'onKeyDown'->putline if);
       (if ch
        // 13 then
           true->enterPushed
        // 28 then
           (if controlkey then  if)
        // 29 then
           (if controlkey then  if)
        // 30 then (* Uparrow *)
           key->theKey; keyDownTimer.start
        // 31 then (* DownArrow *)
           key->theKey; keyDownTimer.start
        // ascii.bs then
           ascii.bs->theKey; keyDownTimer.start
        // ascii.del then
           ascii.del->theKey; keyDownTimer.start
       if);
       (if key
        // specKeys.HOME then
           disableUpdate; key->theKey; keyDownTimer.start
        // specKeys.END then
           disableUpdate; key->theKey; keyDownTimer.start
       if);
       INNER onKeyDown
    else
       INNER onKeyDown
   if)  

-- codeTextField_onTextChanged: DoPart --
do
     (# lineNumber,x,y1,y2: @integer
     do
        false->globalFresh;
        (if texteditmode then
            (if trace and enterPushed then 'enterPushed'->putline;  if);
            (if enterPushed and not (changingText) then
                disableUpdate;
                true->changingText;
                selection.start->posToRowCol->global;
                previous_line;
                global->indent_line->lineNumber;
                false->globalFresh;
                next_line;
                beginning_of_line;
                global->indent_line;
                false->enterPushed->changingText;
                (lineNumber,1)->rowColToPos->posToPt->(x,y1);
                (lineNumber+1,1)->rowColToPos->posToPt->(x,y2);
                (y1,y2)->updateRegion
            if);
            INNER onTextChanged
         else
            INNER onTextChanged
        if);
        false->globalFresh
     #)  

-- codeTextField_onBeforeChange: DoPart --
do
     (# t: ^text; begin,end: @rowCol; pos,endpos,min,max: @integer
     do
        (if texteditmode then
            (if trace then 'onBeforeChange'->putline;  if);
            (if (trace and controlmodified) then 'Control'->putline;  if);
            theText->T[];
            (if (t[] <> none ) and (T.lgth = 1) then
                (if t.T[1]
                 // ascii.ht then
                    (if trace then 'Tab'->screen.putline;  if);
                    selection.start->pos->posToRowCol->begin;
                    selection.end->endpos->posToRowCol->end;
                    (if (begin.row <> end.row) or (begin.col <> end.col) then
                        (pos,endpos)->indentHandler; 
                     else
                        begin->frozen_indent_line; 
                    if);
                    false->allow
                 else
                    INNER onBeforeChange
                if)
             else
                INNER onBeforeChange
            if)
         else
            INNER onBeforeChange
        if)
     #)  

-- removeBlanks: DoPart --
do
     (# white,pos: @integer; t: ^text; begin,end,start: @rowCol
     do
        selection.start->posToRowCol->start->global;
        start.row->begin.row->end.row;
        current_line->t[];
        start.col->t.pos;
        loop: cycle
          (# 
          do
             (if (t.pos = t.length) then leave loop if);
             (if (t.T[t.pos] <> ascii.sp) then leave loop if);
             t.pos+1->t.pos;
             white+1->white
          #);
        start.col+white->end.col;
        0->white;
        start.col->t.pos;
        loop: cycle
          (# 
          do
             (if t.pos = 0 then leave loop if);
             (if (t.T[t.pos] <> ascii.sp) then leave loop if);
             t.pos-1->t.pos;
             white+1->white;
             
          #);
        start.col-white->begin.col;
        (if (begin.col <> end.col) then
            ((begin.row,begin.col),(end.row,end.col))->deleteText;
            (start.row,start.col+1)->rowColToPos->pos;
            (pos,pos)->set_selection;
            false->allow
         else
            true->allow
        if)
     #)  

-- end_of_word: DoPart --
do (* not implemented yet *)   

-- beginning_of_word: DoPart --
do (* not implemented yet *)   

