ORIGIN '../tabControlBody';
LIB_ITEM 'guienvutilstabctrl';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/utils/guienvadds';

INCLUDE '~beta/win32lib/commctrl';

INCLUDE '~beta/basiclib/external';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/wingdi';
INCLUDE '~beta/win32lib/windowsmisc.bet';
INCLUDE '~beta/win32lib/mousecursorsupport';

INCLUDE '~beta/sysutils/objinterface';

-- lib: attributes --
ntPOINT2: ExternalRecord
  (# 
     x: @long (# pos::< (# do 0 -> value; #); #); (* int x *)
     y: @long (# pos::< (# do 4 -> value; #); #); (* int y *)
  enter(x,y)
  exit(x,y)
  #);

ntRECT2: ExternalRecord
  (# 
     left: @long (# pos::< (# do 0 -> value; #); #); (* int left *)
     top: @long (# pos::< (# do 4 -> value; #); #); (* int top *)
     right: @long (# pos::< (# do 8 -> value; #); #); (* int right *)
     bottom: @long (# pos::< (# do 12 -> value; #); #); (* int bottom *)
  enter (left, top, right, bottom)
  exit (left, top, right, bottom)
  #);
sizeOfNtRect2: (# exit 16 #);


-- tabControlLib: attributes --
BeginDeferWindowPos: external
  (# nNumWindows: @integer;  (* number of windows *)
     theHDWP: @integer;
  enter nNumWindows
  do callStd;
  exit theHDWP
  #);
EndDeferWindowPos: external
  (# hWinPosInfo: @integer; (* handle to internal structure *)
     result: @integer;
  enter hWinPosInfo
  do callStd;
  exit result
  #);
DeferWindowPos: external
  (# 
     hWinPosInfo: @integer;     (* handle to internal structure *)
     hWnd: @integer;            (* handle to window to position *)
     hWndInsertAfter: @integer; (* placement-order handle *)
     x: @integer;               (* horizontal position *)
     y: @integer;               (* vertical position *)
     cx: @integer;	      (* width *)
     cy: @integer;	      (* height *)
     uFlags: @integer;          (* window-positioning flags *)
     theHDWP: @integer;
  enter (hWinPosInfo,hWnd,hWndInsertAfter,x,y,cx,cy,uFlags)
  do callStd;
  exit theHDWP
  #);

TCHITTESTINFO_ext: ExternalRecord
  (# pt: @
       (# x: @long (# pos::< (# do 0 -> value; #); #); (* int x *)
          y: @long (# pos::< (# do 4 -> value; #); #); (* int y *)
       enter (x,y)
       exit (x,y)
       #);
     flags: @long (# pos::< (# do 8 -> value; #); #);
  #);

sizeOf_TCHITTESTINFO: (# exit 12 #);

TCM_HITTEST: (# exit TCM_FIRST + 13 #);

TabCtrl_HitTest:
  (# hwnd,x,y: @integer;
     result: @integer;
     ptInfo: @TCHITTESTINFO_ext;
  enter (hwnd,x,y)
  do sizeOf_TCHITTESTINFO -> malloc -> ptInfo.ptr;
     (if ptInfo.ptr<>0 then
         (x,y) -> ptInfo.pt;
         (hwnd, TCM_HITTEST, 0, ptInfo.ptr) -> SendMessage -> result;
         
         ptInfo.ptr -> free;
         0 -> ptInfo.ptr;
     if);
  exit result
  #);

TC_ITEM: ExternalRecord
  (# (* value specifying which members to retrieve or set *)
     mask: @long (# pos::< (# do 0 -> value; #); #);  
     
     (* reserved; do not use *)
     lpReserved1: @long (# pos::< (# do 4 -> value; #); #);
     
     (* reserved; do not use *)
     lpReserved2: @long (# pos::< (# do 8 -> value; #); #); 
     
     (* pointer to string containing tab text *)
     pszText: @long (# pos::< (# do 12 -> value; #); #); 
     
     (* size of buffer pointed to by the pszText member *)
     cchTextMax: @long (# pos::< (# do 16 -> value; #); #);  
     
     (* index to tab controls image *)
     iImage: @long (# pos::< (# do 20 -> value; #); #); 
     
     (* application-defined data associated with tab *)
     lParam: @long (# pos::< (# do 24 -> value; #); #);
  #);
sizeOfTC_ITEM: (# exit 28 #);

TCS_FORCEICONLEFT: (# exit       0x0010 #);
TCS_FORCELABELLEFT: (# exit      0x0020 #);
TCS_TABS: (# exit                0x0000 #);
TCS_BUTTONS: (# exit             0x0100 #);
TCS_SINGLELINE: (# exit          0x0000 #);
TCS_MULTILINE: (# exit           0x0200 #);
TCS_RIGHTJUSTIFY: (# exit        0x0000 #);
TCS_FIXEDWIDTH: (# exit          0x0400 #);
TCS_RAGGEDRIGHT: (# exit         0x0800 #);
TCS_FOCUSONBUTTONDOWN: (# exit   0x1000 #);
TCS_OWNERDRAWFIXED: (# exit      0x2000 #);
TCS_TOOLTIPS: (# exit            0x4000 #);
TCS_FOCUSNEVER: (# exit          0x8000 #);

TCM_FIRST: (# exit                0x1300 #);

TCM_SETITEMA: (# exit          (TCM_FIRST + 6) #);
TCM_SETITEM: (# exit TCM_SETITEMA #);

TabCtrl_SetItem:
  (# hwnd, iItem, pitem: @integer;
     result: @integer;
  enter (hwnd, iItem, pitem)
  do (hwnd, TCM_SETITEM, iItem, pitem) -> SendMessage -> result;
  exit result
  #);

TCM_GETCURFOCUS: (# exit TCM_FIRST + 47 #);
TabCtrl_GetCurFocus:
  (# hwnd: @integer;
     result: @integer;
  enter hwnd
  do (hwnd, TCM_GETCURFOCUS , 0, 0) -> SendMessage -> result;
  exit result
  #);

TCM_GETCURSEL: (# exit (TCM_FIRST + 11) #);
TabCtrl_GetCurSel:
  (# hwnd: @integer;
     result: @integer;
  enter hwnd
  do (hwnd, TCM_GETCURSEL, 0, 0) -> SendMessage -> result;
  exit result
  #);

TCM_INSERTITEMc:    (# exit TCM_FIRST + 7 #);
TabCtrl_InsertItem:
  (# hwnd, iItem, pitem: @integer;
     result: @integer;
  enter (hwnd, iItem, pitem)
  do (hwnd, TCM_INSERTITEMc, iItem, pitem) -> SendMessage -> result;
  exit result
  #);

TCM_DELETEITEMc:    (# exit TCM_FIRST + 8 #);
TabCtrl_DeleteItem:
  (# hwnd, iItem: @integer;
     result: @integer;
  enter (hwnd, iItem)
  do (hwnd, TCM_DELETEITEMc, iItem, 0) -> SendMessage -> result;
  exit result
  #);

TCM_ADJUSTRECTc:    (# exit           (TCM_FIRST + 40) #);
TabCtrl_AdjustRect:
  (# hwnd, bLarger, prc: @integer;
     result: @integer;
  enter (hwnd, bLarger, prc)
  do (hwnd, TCM_ADJUSTRECTc, bLarger, prc)
       -> SendMessage -> result;
  #);

TCN_FIRST: (# exit                -550            #);
TCN_LAST: (# exit                 -580            #);
TCN_SELCHANGE: (# exit             (TCN_FIRST - 1) #);
TCN_SELCHANGING: (# exit          (TCN_FIRST - 2) #);

TCIF_TEXT: (# exit                0x0001 #);
TCIF_IMAGE: (# exit               0x0002 #);
TCIF_RTLREADING: (# exit          0x0004 #);
TCIF_PARAM: (# exit               0x0008 #);

TCM_GETITEMCOUNT: (# exit (TCM_FIRST + 4) #);
TabCtrl_GetItemCount:
  (# hwnd,result: @integer;
  enter hwnd
  do (hwnd, TCM_GETITEMCOUNT, 0, 0) -> SendMessage -> result;
  exit result
  #);

TCN_KEYDOWN: (# exit           (TCN_FIRST - 0) #);

TCM_SETCURSEL: (# exit           (TCM_FIRST + 12) #);
TabCtrl_SetCurSel:
  (# hwnd,i,result: @integer;
  enter (hwnd,i)
  do (hwnd, TCM_SETCURSEL, i, 0) -> SendMessage -> result;
  exit result
  #);

PatBlt: external
  (# hdc, left, top, width, height,rasterMode: @integer;
     result: @integer;
  enter (hdc, left, top, width, height, rasterMode)
  do callStd;
  exit result
  #);

tabControlNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# 
          processNotify:
            (# hwndFrom: @integer;
               theTab: ^tab;
            do (%getLongAt(info.lParam)) -> hwndFrom;
            (* Above line tos_converted from: do info.lParam -> TOS'%adrGetLong' -> hwndFrom; *)
               (if hwndFrom=private.hwndTab then
                   (if ((%getLongAt(info.lParam+8)))
                   (* Above line tos_converted from: (if (info.lParam+8 -> TOS'%adrGetLong') *)
                    //TCN_SELCHANGE then
                       private.hwndTab -> TabCtrl_GetCurSel
                         -> private.theTabs.findTab -> theTab[];
                       (if theTab[]<>NONE then
                           theTab[] -> private.updateCurVisibleCanvas;
                           theTab.onSelect;
                       if);
                    //TCN_SELCHANGING then
                       (if onBeforeSelectionChange then
                           0 -> info.result;
                        else
                           1 -> info.result;
                       if);
                    //TCN_KEYDOWN then
                       (# vKey: @integer;
                       do (%getShortAt(info.lParam+12)) -> vKey;
                       (* Above line tos_converted from: do info.lParam+12 -> TOS'%adrGetShort' -> vKey; *)
                          (if vKey=VK_TAB then
                              (if (VK_SHIFT -> isVKeyDown) then
                                  
                               else
                                  (* L:
                                   *                                     private.current_canvas.scan
                                   *                                   (# 
                                   *                                   do current[] -> target;
                                   *                                      leave L 
                                   *                                   #);
                                   *)
                              if);
                           else
                              false -> didSomething;
                          if);
                       #);
                    else
                       false -> didSomething;
                   if);
               if);
            #);
          
          
          didSomething: @boolean;
       do true -> didSomething;
          (if info.message = WM_NOTIFY then processNotify;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

   
-- GUIEnvTabSetLabel: doPart --
do theLabel[] -> tabPrivate.privLabel[];
   (if tabPrivate.openDone then
       tabPrivate.updateLabel;
   if);
   
-- GUIEnvTabGetLabel: doPart --
do tabPrivate.privLabel[] -> theLabel[];
   
-- GUIEnvTabSetIcon: doPart --
do theIcon[] -> tabPrivate.privIcon[];
   
-- GUIEnvTabGetIcon: doPart --
do tabPrivate.privIcon[] -> theIcon[]
   
-- GUIEnvTabSetPage: doPart --
do (if private.current_canvas[]=tabPrivate.theCanvas[] then
       thePage[] -> private.current_canvas[];
   if);
   thePage[] -> tabPrivate.theCanvas[];
   (if tabPrivate.openDone then
       private.handleSize;
   if);
   (if private.current_canvas[]<>NONE then
       private.current_canvas.bringToFront;
   if);
   
-- GUIEnvTabGetPage: doPart --
do tabPrivate.theCanvas[] -> thePage[];
   
-- GUIEnvTabOpen: doPart --
do (# tie: @TC_ITEM; 
      tempLabel: @cString;
      mask: @integer;
      insertRes: @integer;
   do false -> tabPrivate.openDone;
      
      inner open;
      
      (if tabPrivate.theCanvas[]=NONE then
          'Page is NONE in tab.open.' -> useError;
       else
          0 -> mask;
          
          sizeOfTC_ITEM -> malloc -> tie.ptr; 
          
          (if tie.ptr<>0 then
              (if tabPrivate.privLabel[]<>NONE then
                  (if tabPrivate.privLabel.length>0 then
                      mask %Bor TCIF_TEXT -> mask; 
                      (* Above line tos_converted from: (mask, TCIF_TEXT) -> tos'%or' -> mask; *)
                      tabPrivate.privLabel[] -> tempLabel.set;
                      tempLabel -> tie.pszText;
                  if);
              if);
              
              (if tabPrivate.privIcon[]<>NONE then
                  mask %Bor TCIF_IMAGE -> mask; 
                  (* Above line tos_converted from: (mask, TCIF_IMAGE) -> tos'%or' -> mask; *)
               else
                  -1 -> tie.iImage; 
              if);
              mask -> tie.mask;
              
              private.hwndTab -> TabCtrl_GetItemCount -> tabPrivate.inx;
              (private.hwndTab, tabPrivate.inx, tie.ptr) 
                -> TabCtrl_InsertItem -> insertRes;
              
              (if (insertRes = -1) then
                  tempLabel.free;
                  tie.ptr -> free;
                  0 -> tie.ptr;
                  (* failed; *)
               else
                  this(tab)[] -> private.theTabs.append;
                  
                  this(tab)[] -> private.updateCurVisibleCanvas
                  (# 
                  do private.handleSize; 
                     (private.hwndTab, tabPrivate.inx) -> TabCtrl_SetCurSel;
                  #);
              if);
              
              (if tempLabel.charPtr<>0 then 
                  tempLabel.free; 
              if);
              (if (tie.ptr<>0) then
                  tie.ptr -> free;
                  0 -> tie.ptr;
              if);
           else
              'Failled to allocate TC_ITEM  while adding tab.'
                -> resourceAllocationError;
          if);
      if);
      true -> tabPrivate.openDone;
   #);
   
-- GUIEnvTabClose: doPart --
do (# deleteRes: @integer;
      errMsg: ^text;
   do 
      (if tabPrivate.inx<>0 then
          
          (private.hwndTab, tabPrivate.inx) -> TabCtrl_DeleteItem -> deleteRes;
          
          (if deleteRes=0 then
              &text[] -> errMsg[];
              'TabCtrl_DeleteItem failed. Error= ' -> errMsg.putText;
              GetLastError -> errMsg.putInt; errMsg.newline;
              errMsg[] -> apiError;
          if);
          
          this(tab)[] -> private.theTabs.at -> private.theTabs.delete;
          private.theTabs.scan
          (# 
          do (if current.tabPrivate.inx > tabPrivate.inx then
                 current.tabPrivate.inx - 1 -> current.tabPrivate.inx;
             if);
          #);
          
          0 -> tabPrivate.inx;
      if);
   #);
        
-- GUIEnvTabSelect: doPart --
do this(tab)[] -> selection;
   
-- GUIenvTabPrivate: descriptor --
(# 
   privLabel: ^text;
   privIcon: ^pixmap;
   theCanvas: ^canvas;
   inx: @integer;
   openDone: @boolean;
   
   updateLabel:
     (# tie: @TC_ITEM; 
        tempLabel: @cString;
        mask: @integer;
     do sizeOfTC_ITEM -> malloc -> tie.ptr; 
        (if tie.ptr<>0 then
            (if privLabel[]<>NONE then
                (if privLabel.length>0 then
                    TCIF_TEXT -> mask; 
                    privLabel[] -> tempLabel.set;
                    tempLabel -> tie.pszText;
                    mask -> tie.mask;
                    
                    (private.hwndTab, inx, tie.ptr) 
                      -> TabCtrl_SetItem;
                    
                    (if tempLabel.charPtr<>0 then 
                        tempLabel.free; 
                    if);
                if);
            if);
            (if (tie.ptr<>0) then
                tie.ptr -> free;
                0 -> tie.ptr;
            if);
        if);
     #);
#)

-- GUIEnvTabsSize: doPart --
do private.theTabs.size -> value;
   
-- GUIEnvTabsScan: doPart --
do private.theTabs.scan
   (# 
   do (if current.tabPrivate.theCanvas[]<>NONE then
          current[] -> THIS(scan).current[];
          inner scan;
      if);
   #);
   
-- GUIenvTabsPrivate: descriptor --
(# 
#)

-- GUIenvTabControlCreate: doPart --
do InitCommonControls; 
   
   &tabControlNotiMethods[] -> theNotiMethods;
   isSubClass  -> windowItemClassStatus; 
   'SysTabControl32' -> windowItemClass;
   
   (if multiLine then
       TCS_MULTILINE %Bor TCS_FOCUSONBUTTONDOWN -> windowItemStyle;
    else
       TCS_FOCUSONBUTTONDOWN -> windowItemStyle;
   if);
   
   inner;
   
-- GUIEnvTabControlOpen: doPart --
do (# rcClient: @ntRECT2;
      hwndParent: @integer;
      theTextStyle: ^textStyle;
   do interfaceObjectID -> private.hwndTab;
      (if father[]=none then
          this(window).interfaceObjectID -> hwndParent;
       else
          father.interfaceObjectID -> hwndParent;
      if);
      sizeOfNtRect2 -> malloc -> rcClient.ptr;
      (if rcClient.ptr<>0 then
          (hwndParent, rcClient.ptr) -> GetClientRect; 
          ((rcClient.right - rcClient.left),(rcClient.bottom - rcClient.top))
            -> size;
          rcClient.ptr -> free;          
          0 -> rcClient.ptr;
      if);
      
      (if defaultButtonTextStyle=NONE then
          &textStyle[] -> theTextStyle[];
          'MS Sans Serif' -> theTextStyle.name;
          8 -> theTextStyle.size;
          theTextStyle.create;
          theTextStyle[] -> defaultButtonTextStyle;
       else
          defaultButtonTextStyle -> theTextStyle[];
      if);
      
      (private.hwndTab,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
      inner open;
      
      (* true -> bindTop -> bindLeft -> bindBottom -> bindRight; *)
   #);
   
-- GUIEnvTabControlClose: doPart --
do inner;
   tabs.scan
   (#
   do current.close
   #);
   private.theTabs.clear;
   
-- GUIEnvTabControlSetSelection: doPart --
do (if theTab[]<>NONE then
       (if theTab.tabPrivate.theCanvas[]<>NONE then
           L: private.theTabs.scan
             (# 
             do (if current.tabPrivate.theCanvas[]=theTab.tabPrivate.theCanvas[] then
                    (private.hwndTab, current.tabPrivate.inx) -> TabCtrl_SetCurSel;
                    
                    (if private.current_canvas[]<>NONE then
                        (if private.current_canvas.visible then
                            private.current_canvas.hide;
                        if);
                    if);
                    
                    theTab.tabPrivate.theCanvas[] -> private.current_canvas[];
                    private.current_canvas.interfaceObjectID 
                      -> private.current_hwndDisplay;
                    (if not theTab.tabPrivate.theCanvas.visible then
                        theTab.tabPrivate.theCanvas.show;
                    if);
                    theTab.tabPrivate.theCanvas.bringToFront;
                    leave L
                if);
             #);
       if);   
   if);
   
-- GUIEnvTabControlGetSelection: doPart --
do private.hwndTab -> TabCtrl_GetCurSel
     -> private.theTabs.findTab -> theTab[];
   
-- GUIenvTabControlEventHandlerOnMouseUp: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnMouseDown: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnFatherFrameChanged: doPart --
do private.handleSize;
   inner;
   
-- GUIenvTabControlEventHandlerOnActivate: doPart --
do (if private.current_canvas[]<>NONE then
       private.current_canvas.bringToFront;
   if);
   inner;
   
-- GUIenvTabControlEventHandlerOnRefresh: doPart --
do inner;


-- GUIenvTabControlPrivate: descriptor --
(# 
   
   theTabs: @list
     (# element:: tab;
        findTab:
          (# inx: @integer;
             theTab: ^tab;
          enter inx
          do L:
               scan
               (# 
               do (if current.tabPrivate.inx=inx then
                      current[] -> theTab[];
                      leave L
                  if);
               #);
          exit theTab[]
          #);
     #);
   
   updateCurVisibleCanvas:
     (# theTab: ^tab;
        
     enter theTab[]
     do (if theTab[]<>NONE then
            (if current_canvas[]<>NONE then
                (if current_canvas.isOpen then
                    (if current_canvas.visible then
                        current_canvas.hide;
                    if);
                if);
            if);
            theTab.tabPrivate.theCanvas[] 
              -> current_canvas[];
            current_canvas.interfaceObjectID 
              -> private.current_hwndDisplay;
            
            inner updateCurVisibleCanvas;
            
            (if not theTab.tabPrivate.theCanvas.visible then
                theTab.tabPrivate.theCanvas.show;
            if);
            theTab.tabPrivate.theCanvas.bringToFront;
        if);
     #);

   hwndTab: @integer;
   current_hwndDisplay: @integer;
   current_canvas: ^canvas;
   
   handleSize:
     (# rc: @ntRECT2;
        hdwp: @integer;
        width,height: @integer;
     do 
        this(tabControl).size -> (width,height);
        
        sizeOfNtRect2 -> malloc -> rc.ptr;
        (if rc.ptr<>0 then
            (* Calculate the display rectangle, assuming the 
             * tab control is the size of the client area.
             *)
            0 -> rc.left; 0 -> rc.top;
            width -> rc.right;
            height -> rc.bottom;
            (private.hwndTab, 0, rc.ptr) -> TabCtrl_AdjustRect;
            (* Size the tab control to fit the client area. *)            
            theTabs.scan
            (# 
            do (rc.left, rc.top) -> current.tabPrivate.theCanvas.position;
               ((rc.right - rc.left),(rc.bottom - rc.top))
                 -> current.tabPrivate.theCanvas.size;
            #);
            
            rc.ptr -> free;
        if);
     #);
#)
