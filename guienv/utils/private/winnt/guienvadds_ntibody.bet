ORIGIN '../guienvaddsbody';
INCLUDE '../../../stddialogs';
INCLUDE '../../../controls';
INCLUDE '../../../private/winnt/scrolllists_ntibody';
INCLUDE '../../../private/winnt/controls_ntibody';
INCLUDE '../../../private/winnt/optionbutton_ntiprivate';
INCLUDE '../../../private/winnt/guienv_ntiprivate';
INCLUDE '../../optionbox';
INCLUDE 'optionbox_ntibody';
INCLUDE '~beta/win32lib/v1.1/shellapi';
INCLUDE '~beta/win32lib/v1.1/winerror';
INCLUDE '~beta/basiclib/v1.4/file';

-- windowLaunchFile: descriptor --
(# extHInstance: @integer;
   defaultDir: @text;
   msg: ^text;
   theWindow: ^window;
   aFile: @file;
do filename[] -> aFile.name;
   aFile.entry.path.head -> defaultDir.append; defaultDir.reset;
   this(window)[] -> theWindow[];
   (theWindow.interfaceObjectID, 0, filename, 0, defaultDir, 1) 
     -> ShellExecute -> extHInstance;
   'extHInstance: ' -> puttext; extHInstance -> putint; newline;
   (if extHInstance<33 then
       &text[] -> msg[];
       (if extHInstance
        //SE_ERR_ASSOCINCOMPLETE then 'SE_ERR_ASSOCINICOMPLETE. '-> msg.append;
        //SE_ERR_DDEBUSY then 'SE_ERR_DDEBUSY. ' -> msg.append;
        //SE_ERR_DDEFAIL then 'SE_ERR_DDEFAIL. ' -> msg.append;
        //SE_ERR_DDETIMEOUT then 'SE_ERR_DDETIMEOUT. ' -> msg.append;
        //SE_ERR_NOASSOC then 'SE_ERR_NOASSOC. ' -> msg.append;
        //SE_ERR_SHARE then 'SE_ERR_SHARE. ' -> msg.append;
        //0 then 'Out of memory or resources. ' -> msg.append;
        //ERROR_FILE_NOT_FOUND then 'File not found. ' -> msg.append;
        //ERROR_PATH_NOT_FOUND then 'Path not found. ' -> msg.append;
        //ERROR_BAD_FORMAT then 'Bad format. ' -> msg.append;
       if);
       'ShellExecute failed for: ' -> msg.append; filename[] -> msg.append; 
       '. ' -> msg.append;
       (none,msg[],none) -> alertUser;
   if);
#)

-- GUIENVsetWindowIcon: doPart --
do id -> this(window).private.iconID;


-- GUIENVsetApplIcon: doPart --
do id -> applIconID;


-- windowItemlib: attributes --


-- windowItemBringToFront: doPart --
do (interfaceObjectID,HWND_TOP,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE)-> SetWindowPos;
   
-- windowItemBringToBack: doPart --
do (interfaceObjectID,HWND_BOTTOM,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE)
     -> SetWindowPos;

-- windowItemPreferredSize: doPart --
do (# aTextScrollList: ^textScrollList; 
      theOptionButton: ^optionButton;
      theOptionBox: ^optionBox;
      aButton: ^button;
      buttonWidth, buttonHeight, widthOfLabel, noOfLines: @integer; l,temp,partLabel1,partLabel2: ^text;
      width, height: @integer;
      theTextStyle: ^textStyle;
   do (if true 
       //this(windowitem).struc <= textScrollList## then
          this(windowitem)[] -> aTextScrollList[];
          aTextScrollList.private.preferredSize 
            -> (preferredWidth, preferredHeight);
       //this(windowitem).struc <= optionButton## then
          this(windowitem)[] -> theOptionButton[];
          theOptionButton.preferredSize
            -> (preferredWidth, preferredHeight);
       //this(windowitem).struc <= optionBox## then
          this(windowitem)[] -> theOptionBox[];
          theOptionBox.private.preferredSize
            -> (preferredWidth, preferredHeight);
       //this(windowitem).struc <= staticText## then
          this(windowitem)[] -> aButton[];
          aButton.style -> theTextStyle[];
          aButton.label -> temp[]; temp.copy -> l[];
          (if l[]//none then
              &text[] -> l[]; 'l is none' -> putline;
          if);
          l.reset;
          (if (l.length > 5)//true then
              &text[] -> partLabel1[]; &text[] -> partLabel2[]; 
              1 -> noOfLines;
              l.scan
              (# while::< (# do true -> value; #);
              do (if ch
                  //ascii.nl then 
                     (if partLabel1.length > partLabel2.length//true then 
                         partLabel1 -> partLabel2;
                         partLabel1.clear;
                         noOfLines + 1 -> noOfLines;
                     if);
                  else
                     ch -> partLabel1.put;
                 if);
              #);
              (if partLabel2.length//0 then
                  partLabel1[] -> partLabel2[];
              if);
              partLabel2[] -> theTextStyle.widthOfText -> widthOfLabel;
              
              (if (width < widthOfLabel + 4)// true then
                  widthOfLabel + 4 -> width;
              if);
              (if (height < (theTextStyle.lineHeight * noOfLines) + 2)//true then
                  theTextStyle.lineHeight + 2 -> height;
              if);
              (width,height) -> (preferredWidth, preferredHeight); 
          if);
       else
          (100,100) -> (preferredWidth, preferredHeight);
      if);
   #)

-- windowItemDrawShadows: doPart --
do (# x,y,width,height: @integer;
   do r.topLeft -> (x, y);
      r.size -> (width, height);
      (this(windowItem)[],type,x,y,width,height) -> drawBorder;
   #)
   
-- GUIENVwindowItemOrigin: doPart --
do (# translate:
        (# h,v: @integer;
           ntpPtr: @integer;
        enter (h,v)
        do (h,v) -> makeNtPointPtr -> ntpPtr;
           (interfaceObjectID,ntpPtr) -> ClientToScreen;
           ntpPtr -> getPointFromNtPointPtr -> (h,v);
           ntpPtr -> free;
        exit (h,v)
        #);
   do (0,0) -> translate -> (x,y)
   #)
   
-- GUIenvWindowItemDelegateMouseEvents: doPart --
do (* not implemented *)
