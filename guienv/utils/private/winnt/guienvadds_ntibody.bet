ORIGIN '../guienvaddsbody';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE '~beta/guienv/controls';
INCLUDE '~beta/guienv/private/winnt/scrolllists_ntibody';
INCLUDE '~beta/guienv/private/winnt/controls_ntibody';
INCLUDE '~beta/guienv/private/winnt/optionbutton_nti';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/private/winnt/guienv_ntibody';
INCLUDE '~beta/win32lib/shellapi';
INCLUDE '~beta/win32lib/winerror';
INCLUDE '~beta/win32lib/mousecursorsupport';
INCLUDE '~beta/basiclib/file';
-- windowLaunchFile: descriptor --
(# extHInstance: @integer;
   defaultDir: @text;
   msg: ^text;
   theWindow: ^window;
   aFile: @file;
do filename[] -> aFile.name;
   aFile.entry.path.head -> defaultDir.append; defaultDir.reset;
   this(window)[] -> theWindow[];
   (theWindow.interfaceObjectID, 0, filename, 0, defaultDir, 1) 
     -> ShellExecute -> extHInstance;
   'extHInstance: ' -> puttext; extHInstance -> putint; newline;
   (if extHInstance<33 then
       &text[] -> msg[];
       (if extHInstance
        //SE_ERR_ASSOCINCOMPLETE then 'SE_ERR_ASSOCINICOMPLETE. '-> msg.append;
        //SE_ERR_DDEBUSY then 'SE_ERR_DDEBUSY. ' -> msg.append;
        //SE_ERR_DDEFAIL then 'SE_ERR_DDEFAIL. ' -> msg.append;
        //SE_ERR_DDETIMEOUT then 'SE_ERR_DDETIMEOUT. ' -> msg.append;
        //SE_ERR_NOASSOC then 'SE_ERR_NOASSOC. ' -> msg.append;
        //SE_ERR_SHARE then 'SE_ERR_SHARE. ' -> msg.append;
        //0 then 'Out of memory or resources. ' -> msg.append;
        //ERROR_FILE_NOT_FOUND then 'File not found. ' -> msg.append;
        //ERROR_PATH_NOT_FOUND then 'Path not found. ' -> msg.append;
        //ERROR_BAD_FORMAT then 'Bad format. ' -> msg.append;
       if);
       'ShellExecute failed for: ' -> msg.append; filename[] -> msg.append; 
       '. ' -> msg.append;
       (none,msg[],none) -> alertUser;
   if);
#)

-- GUIENVsetWindowIcon: doPart --
do id -> this(window).private.iconID;
   
--GUIENVsetWindowIconPixmap:dopart--
do 'setWindowIconPixmap is Unix-only. Use loadWindowIcon instead.'->screen.putline;
   
-- GUIENVloadWindowIcon: doPart --
do (# tempName: @cString;
      iconOK:@integer;
   do
      (if filename[] <> NONE then 
          filename[] -> tempName.set;
          (if tempName.charPtr <> 0 then
              (uienvHinstance, tempName, 1 (* =IMAGE_ICON *), 0, 0, 16 (* =LR_LOADFROMFILE *)) 
                -> LoadImage -> private.iconHandle;
              tempName.free;
              (if private.iconHandle = 0 then
                  'LoadImage failed. Error loading icon:'->screen.puttext;
                  GetLastError->putint; newline;
               else
                  (InterfaceObjectID, GCL_HICON, private.iconHandle)->setClassLong->iconOK;
                  (if (iconOK=0) then 
                      'ERROR: setting icon failed. Error code: ' -> screen.putText;
                      GetLastError -> screen.putInt; screen.newline;
                  if);
              if);
           else
              'Setting icon file name to '->screen.puttext;
              filename[]->screen.puttext;
              ' failed!'->screen.putline;
          if);
       else
          'Error: Icon file name is NONE!'->screen.putline; 
      if);
      
   #)
   
-- GUIENVsetApplIcon: doPart --
do id -> applIconID;
   
-- GUIENVloadMouseCursor: doPart --
do (# namechars: [filename.length]@char;
      newCur: ^cursor;
   do &Cursor[] -> newCur[];
      (for i: filename.length repeat filename.t[i] -> namechars[i] for);
      namechars -> LoadCursorFromFile -> newCur.cursorHandle;
      newCur[] -> THIS(guienv).private.currentMouseCursor[];
   #)
   
-- GUIENVsetMouseCursor: doPart --
do 'Error: setMouseCursor is Unix-only. Use loadMouseCursor instead'->screen.putline;
   
-- windowItemlib: attributes --


-- windowItemBringToFront: doPart --
do (if interfaceObjectID <> 0 then
      (interfaceObjectID,HWND_TOP,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE)-> SetWindowPos;
   if);
   (if father[] <> NONE then
      this(windowItem)[] -> father.private.children.at
                         -> father.private.children.delete;
      this(windowItem)[] -> father.private.children.append;
   if);
   
-- windowItemBringToBack: doPart --
do (if interfaceObjectID <> 0 then
      (interfaceObjectID,HWND_BOTTOM,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE)
        -> SetWindowPos;
   if);
   (if father[] <> NONE then
      this(windowItem)[] -> father.private.children.at
                         -> father.private.children.delete;
      this(windowItem)[] -> father.private.children.prepend;
   if);

-- windowItemPreferredSize: doPart --
do (# aTextScrollList: ^textScrollList; 
      theOptionButton: ^optionButton;
      aButton: ^button;
      anEditText: ^editText;
      buttonWidth, buttonHeight, widthOfLabel, noOfLines: @integer; l,temp,partLabel1,partLabel2: ^text;
      height: @integer;
      theTextStyle: ^textStyle;
   do (if true 
       //this(windowitem)## <= textScrollList## then
          this(windowitem)[] -> aTextScrollList[];
          aTextScrollList.private.preferredSize 
            -> (preferredWidth, preferredHeight);
       //this(windowitem)## <= optionButton## then
          this(windowitem)[] -> theOptionButton[];
          theOptionButton.preferredSize
            -> (preferredWidth, preferredHeight);
       //this(windowitem)## <= staticText## then
          this(windowitem)[] -> aButton[];
          aButton.style -> theTextStyle[];
          aButton.label -> temp[]; temp.copy -> l[];
          (if l[]=none then
              &text[] -> l[]; 
          if);
          l.reset;
          (if theTextStyle[]<>NONE then
              &text[] -> partLabel1[]; &text[] -> partLabel2[]; 
              1 -> noOfLines;
              l.scan
              (# while::< (# do true -> value; #);
              do (if ch=ascii.nl then 
                     (if partLabel1.length > partLabel2.length then 
                         partLabel1 -> partLabel2;
                         partLabel1.clear;
                         noOfLines + 1 -> noOfLines;
                     if);
                  else
                     ch -> partLabel1.put;
                 if);
              #);
              (if partLabel2.length=0 then
                  partLabel1[] -> partLabel2[];
              if);
              (if partLabel2[]<>NONE then
                  partLabel2[] -> theTextStyle.widthOfText -> widthOfLabel;
               else
                  l.length + 4 -> widthOfLabel;
              if);
              (theTextStyle.lineHeight * noOfLines) -> height
           else
              l.length + 4 -> widthOfLabel;
              16 -> height;
          if);
          (if aButton.border.visible then 
              (if border.style=borderStyles.simple then
                  widthOfLabel + 6 -> widthOfLabel;
                  height + 2 -> height
               else
                  widthOfLabel + 8 -> widthOfLabel;
                  height + 4 -> height 
              if);
          if); 
          (widthOfLabel,height) -> (preferredWidth, preferredHeight); 
          
       //this(windowItem)## <= pushButton## then
          this(windowItem)[] -> aButton[];
          aButton.style -> theTextStyle[];
          aButton.label -> theTextStyle.widthOftext -> preferredWidth;
          preferredWidth + 12 -> preferredWidth;
          (theTextStyle.lineHeight + 6, 20) -> Max -> preferredHeight;
          
       //this(windowItem)## <= toggleButton## then
          this(windowItem)[] -> aButton[];
          aButton.style -> theTextStyle[];
          aButton.label -> theTextStyle.widthOftext -> preferredWidth;
          preferredWidth + 22 -> preferredWidth;
          (theTextStyle.lineHeight + 2, 16) -> Max -> preferredHeight;
          
       //this(windowItem)## <= editText## then
          size -> (preferredWidth, preferredHeight);
          (if preferredWidth<200 then 200 -> preferredWidth; if);
          this(windowItem)[] -> anEditText[];
          anEditText.style -> theTextStyle[];
          (theTextStyle.lineHeight + 6, 20) -> Max -> preferredHeight;
       else
          size -> (preferredWidth, preferredHeight);
      if);
   #)

-- windowItemDrawShadows: doPart --
do (# x,y,width,height: @integer;
   do r.topLeft -> (x, y);
      r.size -> (width, height);
      (this(windowItem)[],type,x,y,width,height) -> drawBorder;
   #)
   
-- GUIENVwindowItemOrigin: doPart --
do (# translate:
        (# h,v: @integer;
           ntpPtr: @integer;
        enter (h,v)
        do (h,v) -> makeNtPointPtr -> ntpPtr;
           (interfaceObjectID,ntpPtr) -> ClientToScreen;
           ntpPtr -> getPointFromNtPointPtr -> (h,v);
           ntpPtr -> free;
        exit (h,v)
        #);
   do (0,0) -> translate -> (x,y)
   #)
   
-- GUIenvWindowItemDelegateMouseEvents: doPart --
do (* not implemented *)
