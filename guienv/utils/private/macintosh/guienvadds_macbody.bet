ORIGIN '../guienvaddsbody';
INCLUDE '../../../controls';
INCLUDE '../../../private/macintosh/guienv_macprivate';

-- windowItemBringToFront: doPart --
do assertOpen;
	(if father[] <> NONE then
		(if shouldUpdate then
			invalFrame;
		if);
		(if NOT private.isFigureItem then
			THIS(windowItem)[] -> father.private.children.at -> father.private.children.delete;
			THIS(windowItem)[] -> father.private.children.append;
			true -> forgetVisibleRgn;
		else
			THIS(windowItem)[] -> father.private.figs.at -> father.private.figs.delete;
			THIS(windowItem)[] -> father.private.figs.append;
		if);
	if);

-- windowItemBringToBack: doPart --
do assertOpen;
	(if father[] <> NONE then
		(if shouldUpdate then
			invalFrame;
		if);
		(if NOT private.isFigureItem then
		   true -> forgetVisibleRgn;
			THIS(windowItem)[] -> father.private.children.at -> father.private.children.delete;
			THIS(windowItem)[] -> father.private.children.prepend;
			
		else
			THIS(windowItem)[] -> father.private.figs.at -> father.private.figs.delete;
			THIS(windowItem)[] -> father.private.figs.prepend;
		if);
	if);


-- windowItemPreferredSize: doPart --
do (# theStyle: ^textStyle;
		theButton: ^button;
		thisEditText: ^editText;
		theLabel, line, maxLine: ^text;
		noOfLines: @integer;
	do size -> (preferredWidth, preferredHeight);
		(if true 
			//THIS(windowItem)## <= staticText## then
				this(windowItem)[] -> theButton[];
				theButton.style -> theStyle[];
				theButton.label -> theLabel[];
				
				theLabel.reset;
            &text[] -> line[];
				&text[] -> maxLine[]; 
            1 -> noOfLines;
            theLabel.scan
            	(# while:: (# do true -> value; #);
              do (if ch = ascii.newline then 
                     (if line.length > maxLine.length then 
                         line -> maxLine;
                         line.clear;
                         noOfLines + 1 -> noOfLines;
                     if);
                  else
                     ch -> line.put;
                 if);
              #);
				(if maxLine.length <> 0 then
					maxLine[] -> theStyle.widthOfText -> preferredWidth;
				else
					theLabel[] -> theStyle.widthOfText -> preferredWidth;
				if);
				(theStyle.lineHeight * noOfLines) -> preferredHeight;
				(if border.visible then 
				  (if border.style = borderStyles.simple then
						preferredWidth + 6 -> preferredWidth;
						preferredHeight + 2 -> preferredHeight;
					else
						preferredWidth + 8 -> preferredWidth;
						preferredHeight + 4 -> preferredHeight 
				  if);
				if); 
				preferredWidth + 1 -> preferredWidth;
			//THIS(windowItem)## <= optionButton## then
				(200, 22) -> (preferredWidth, preferredHeight);
			//THIS(windowItem)## <= pushButton## then
				this(windowItem)[] -> theButton[];
				theButton.style -> theStyle[];
				theButton.label -> theStyle.widthOftext -> preferredWidth;
				preferredWidth + 12 -> preferredWidth;
				(theStyle.lineHeight + 6, 20) -> Max -> preferredHeight;
			//THIS(windowItem)## <= toggleButton## then
				this(windowItem)[] -> theButton[];
				theButton.style -> theStyle[];
				theButton.label -> theStyle.widthOftext -> preferredWidth;
				preferredWidth + 20 -> preferredWidth;
				(theStyle.lineHeight + 2, 16) -> Max -> preferredHeight;
			//THIS(windowItem)## <= editText## then
				THIS(windowItem)[] -> thisEditText[];
				thisEditText.style -> theStyle[];
				theStyle.lineHeight + theStyle.leading + 6 -> preferredHeight;
				(if preferredWidth < 200 then
					200 -> preferredWidth;
				if);
		if);
	#)

-- windowItemDrawShadows: doPart --
do standardGraphics (# do (r, type) -> drawBorder; #);


-- GUIENVwindowItemOrigin: doPart --
do private.originX -> x;
   private.originY -> y;
	
-- windowLaunchFile: descriptor --
(#
do 'LaunchFile is NOT implemented' -> putLine;
#)

-- GUIenvWindowItemDelegateMouseEvents: doPart --
do 'LaunchFile is NOT implemented' -> putLine;

-- GUIENVsetWindowIcon: doPart --
do 'Window SET ICON is a Window PC feature' -> putLine;

-- GUIENVsetApplIcon: doPart --
do 'Window SET ICON is a Window PC feature' -> putLine;
