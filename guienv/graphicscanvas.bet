ORIGIN '~beta/guienv/guienv';

BODY 'private/graphicscanvasbody';
INCLUDE '~beta/basiclib/math';
INCLUDE '~beta/basiclib/numberio';

INCLUDE '~beta/sysutils/objinterface';

-- PixmapLib: attributes --

readAlpha:
  (# error:< exception
       (# what: ^Text;
       enter what[]
       do 'failed to read PNG file  "' -> msg.puttext;
          name[] -> msg.puttext;
          '" ' -> msg.puttext;
          what[] -> msg.puttext;
          INNER;
       #);
     name: ^Text;
  enter name[]
  <<SLOT PixmapReadAlpha: doPart>>
  #);


-- GUIenvLib: attributes --
Point2d:
  (# x, y: @real;
  enter (x, y)
  exit (x, y)
  #);
  
PointList: List
  (# Element:: Point2d;
  #); 


ScalePixmap:
  (# src: ^Pixmap;
     width, height: @integer;
     
     dst: ^Pixmap;
  enter (src[], width, height)
  <<SLOT GUIenvScalePixmap: doPart>>
  exit dst[]
  #);


PenSmooth: (# exit 0 #);
PenSolid: (# exit 1 #);
PenDash: (# exit 2 #);
PenDot: (# exit 3 #);
PenDashDot: (# exit 4 #);
PenDashDotDot: (# exit 5 #);


BorderSimple: (# exit 0 #);
BorderSunken: (# exit 1 #);
BorderRaised: (# exit 2 #);

Surface:
  (# <<SLOT SurfaceLib: attributes>>;
     
     init:<
       (#
       do INNER;
       #);
     
     drawText:<
       (# theText: ^Text;
       enter theText[]
       do INNER;
       #);
     drawLine:<
       (# start, end: ^Point2d;
       enter (start[], end[])
       do INNER;
       #);
     drawRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     fillPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     drawPixmap:<
       (# thePixmap: ^Pixmap;
       enter thePixmap[]
       do INNER;
       #);
     
     drawBorder:<
       (# width, height: @integer;
          style: @integer;
       enter (style, width, height)
       do INNER;
       #);
       
     style:<
       (# theStyle: ^TextStyle;
       enter theStyle[]
       do INNER;
       #);
     pen:<
       (# theColor: ^Color;
       enter theColor[]
       do INNER;
       #);
     penStyle:<
       (# thePenStyle: @integer;
       enter thePenStyle
       do INNER;
       #);
     angle:<
       (# theAngle: @integer;
       enter theAngle
       do INNER;
       #);
     width:<
       (# theWidth: @integer;
       enter theWidth
       do INNER;
       #);
     push:<
       (# do INNER #);
     pop:<
       (# do INNER #);
     
     translate:<
       (# dx, dy: @real;
       enter (dx, dy)
       do INNER;
       #);
     
     transform:<
       (# x, y: @real;
       enter (x, y)
       do INNER;
       exit (x, y)
       #);
       
     begin:<
       (# do INNER #);
     end:<
       (# do INNER #);
     
     left, right, top, bottom: @real;
  #);


OvalLimit:
  (# limit: @integer;
     set: (# enter limit <<SLOT SetOvalLimit: doPart>> #);
     get: (# <<SLOT GetOvalLimit: doPart>> exit limit #);
  enter set
  exit get
  #);
UseGDI:
  (# value: @boolean;
     set: (# enter value <<SLOT SetUseGDI: doPart>> #);
     get: (# <<SLOT GetUseGDI: doPart>> exit value #);
  enter set
  exit get
  #);
  
PixmapSurface: Surface
  (# <<SLOT PixmapSurfaceLib: attributes>>;
     content: ^Pixmap;
     strokewidth: @integer;
     currentStyle: ^TextStyle;
     currentAngle: @integer;
     currentPenStyle: @integer;
     
     ovalLimit: @integer;
     useGDI: @boolean;
     
     init::<
       (# 
       enter content[]
       <<SLOT PixmapSurfaceInit: doPart>>
       #);
     
     drawText:: (# <<SLOT PixmapSurfaceDrawText: doPart>> #);
     drawLine:: (# <<SLOT PixmapSurfaceDrawLine: doPart>> #);
     drawRect:: (# <<SLOT PixmapSurfaceDrawRect: doPart>> #);
     fillRect:: (# <<SLOT PixmapSurfaceFillRect: doPart>> #);
     drawOval:: (# <<SLOT PixmapSurfaceDrawOval: doPart>> #);
     fillOval:: (# <<SLOT PixmapSurfaceFillOval: doPart>> #);
     drawPolygon:: (# <<SLOT PixmapSurfaceDrawPolygon: doPart>> #);
     fillPolygon:: (# <<SLOT PixmapSurfaceFillPolygon: doPart>> #);
     drawPixmap:: (# <<SLOT PixmapSurfaceDrawPixmap: doPart>> #);
     drawBorder:: (# <<SLOT PixmapSurfaceDrawBorder: doPart>> #);
     style:: (# <<SLOT PixmapSurfaceStyle: doPart>> #);
     angle:: (# <<SLOT PixmapSurfaceAngle: doPart>> #);
     pen:: (# <<SLOT PixmapSurfacePen: doPart>> #);
     penStyle:: (# do thePenStyle -> currentPenStyle #);
     width:: (# do theWidth -> strokewidth #);
     push:: (# <<SLOT PixmapSurfacePush: doPart>> #);
     pop:: (# <<SLOT PixmapSurfacePop: doPart>> #);
     translate:: (# <<SLOT PixmapSurfaceTranslate: doPart>> #);
     transform:: (# <<SLOT PixmapSurfaceTransform: doPart>> #);
     begin:: (# <<SLOT PixmapSurfaceBegin: doPart>> #);
     end:: (# <<SLOT PixmapSurfaceEnd: doPart>> #);
     private: @<<SLOT PixmapSurfacePrivate: descriptor>>;
  #);



-- WindowLib: attributes --



GraphicsCanvas: Canvas
  (# <<SLOT GraphicsCanvasLib: attributes>>;
     backgroundColor: @color;
     
     transparent: ^Color;
     
     add:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasAdd: doPart>>
       #);
     remove:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasRemove: doPart>>
       #);
     
     
     pan:
       (# changePan:
            (# newx, newy: @real;
            enter (newx, newy)
            <<SLOT GraphicsCanvasChangePan: doPart>>
            #);
       enter changePan
       exit (panx, pany)
       #);
     writePNG:
       (# name: ^Text;
          area: @Rectangle;
          depth: @integer;
       enter (name[], area, depth)
       <<SLOT GraphicsCanvasWritePNG: doPart>>
       #);
     writeJPG:
       (# name: ^Text;
          area: @rectangle;
          quality: @integer; (* 50 - 100 % *)
       enter (name[], area, quality)
       <<SLOT GraphicsCanvasWriteJPG: doPart>>
       #);
     changed:
       (# 
       do true -> changedFlag;
          0 -> updateRgn.left;
          0 -> updateRgn.top;
          size -> (updateRgn.right, updateRgn.bottom);
       #);
     updateRect:
       (# area: ^Rectangle;
       enter area[]
       <<SLOT GraphicsCanvasUpdateRect: doPart>>
       #);
     Layer:
       (# children: @list
            (# Element:: Item;
            #);
          
          init:<
            (#
            do true -> visible; INNER;
            #);
          add:
            (# child: ^Item;
            enter child[]
            <<SLOT LayerAdd: doPart>>
            #);
          remove:
            (# child: ^Item;
            enter child[]
            <<SLOT LayerRemove: doPart>>
            #);
          drawOn:
            (# theSurface: ^Surface;
            enter theSurface[]
            <<SLOT LayerDrawOn: doPart>>
            #);
          visible: @boolean;
	#);
      layers: @List
	(# element:: Layer;
	#);

      addLayer:
	(# theLayer: ^Layer;
	enter theLayer[]
	<<SLOT GraphicsCanvasAddLayer: doPart>>
	#);
      removeLayer:
       (# theLayer: ^Layer;
       enter theLayer[]
       <<SLOT GraphicsCanvasRemoveLayer: doPart>>
       #);
     
     Item:
       (# x, y: @real;
          father: ^Composite;
          
          init:<
	    (# do INNER #);
          
          outline:<
            (# points: ^PointList;
            do &PointList[] -> points[];
               INNER;
            exit points[]
            #);
          changed:
            (# <<SLOT ItemChanged: doPart>> #);
          
          updateRect:
            (# area: ^Rectangle;
            enter area[]
            <<SLOT ItemUpdateRect: doPart>>
            #);
          
	  drawOn:<
	    (# theSurface: ^Surface;
	    enter theSurface[]
	    <<SLOT ItemDrawOn: doPart>>
	    #);
          
          
          mouseEvent:
            (# local: @Point2d;
               global: @Point2d;
               button: @integer;
               doubleClick: @boolean;
               shiftKey: @boolean;
               controlKey: @boolean;
               tickcount: @integer;
               
            enter (local, global, button, doubleClick, shiftKey, controlKey, tickcount)
            do INNER;
            #);
          
          
          onMouseDown:< mouseEvent;
          onMouseMove:< mouseEvent;
          onMouseUp:< mouseEvent;
          
          localToGlobal:
            (# x, y: @real;
            enter (x, y)
            do (if father[] = NONE then
                   x + panx -> x;
                   y + pany -> y;
                else
                   (x, y) -> father.localToGlobal -> (x, y);
               if);
               x + THIS(Item).x -> x;
               y + THIS(Item).y -> y;
            exit (x, y)
            #);
          globalToLocal:
            (# x, y: @real;
            enter (x, y)
            do (if father[] = NONE then
                   x - panx -> x;
                   y - pany -> y;
                else
                   (x, y) -> father.globalToLocal -> (x, y);
               if);
               x - THIS(Item).x -> x;
               y - THIS(Item).y -> y;
            exit (x, y)
            #);
          hit:
            (# target: ^Item;
               x, y: @real;
            enter (x, y)
            do (if father[] = NONE then
                   x - panx -> x;
                   y - pany -> y;
                else
                   (x, y) -> father.globalToLocal -> (x, y);
               if);
               (x, y) -> containsPoint -> target[]
            exit target[]
            #);
          containsPoint:<
            (# x, y: @real;
               target: ^Item;
            enter (x, y)
            do x - THIS(Item).x -> x;
               y - THIS(Item).y -> y;
               INNER;
            exit target[]
            #);
          
       #);
     SimpleItem: Item
       (# stroke: ^Color;
          fill: ^Color;
          strokewidth: @integer;
       #);
     Line: SimpleItem
       (# start: ^Point2d;
          end: ^Point2d;
          style: @integer; (* PenSmooth, PenSolid, PenDash etc. *)
          drawOn::
            (# <<SLOT LineDrawOn: doPart>> #);
          containsPoint::
            (# left, right, top, bottom: @real;
               a, b, c: @real;
               d: @real;
               dist: @real;
               halfStrokeWidth: @integer;
            <<SLOT LineContainsPoint: doPart>>
            #);
          outline::
            (# <<SLOT LineOutline: doPart>> #);
       #);
     
     Rect: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT RectDrawOn: doPart>> #);
          outline::
            (# pt: ^Point2d;
            do &Point2d[] -> pt[];
               x - strokewidth -> pt.x;
               y - strokewidth -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x + width + strokewidth -> pt.x;
               y - strokewidth -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x + width + strokewidth -> pt.x;
               y + height + strokewidth -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x - strokewidth -> pt.x;
               y + height + strokewidth -> pt.y;
               pt[] -> points.append;
               
            #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Rect)[] -> target[];
               if);
            #);
       #);
     Oval: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT OvalDrawOn: doPart>> #);
          outline::
            (# pt: ^Point2d;
            do &Point2d[] -> pt[];
               x - strokewidth -> pt.x;
               y - strokewidth -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x + width + strokewidth -> pt.x;
               y - strokewidth -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x + width + strokewidth -> pt.x;
               y + height + strokewidth -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x - strokewidth -> pt.x;
               y + height + strokewidth -> pt.y;
               pt[] -> points.append;
               
            #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Oval)[] -> target[];
               if);
            #);
       #);
     Border: Item
       (# style: @integer;
          width, height: @integer;
          drawOn::
            (# <<SLOT BorderDrawOn: doPart>> #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Border)[] -> target[];
               if);
            #);
       #);
     Polygon: SimpleItem
       (# points: @PointList;
          drawOn::
            (# <<SLOT PolygonDrawOn: doPart>> #);
          containsPoint::
            (# <<SLOT PolygonContainsPoint: doPart>> #);
       #);
     TextItem: Item
       (# <<SLOT TextItemLib: attributes>>;
          content: ^Text;
          style: ^TextStyle;
          angle: @integer; (* Degrees 0 - 360 counter clockwise *)
          stroke: ^Color;
	  drawOn::
            (# <<SLOT TextItemDrawOn: doPart>> #);
          outline::
            (# <<SLOT TextItemOutline: doPart>> #);
          containsPoint::
            (# <<SLOT TextItemContainsPoint: doPart>> #);
          
       #);
     PixmapItem: SimpleItem
       (# content: ^Pixmap;
          drawOn::
            (# <<SLOT PixmapItemDrawOn: doPart>> #);
          containsPoint::
            (# 
            do (if content[]<>none then
                   (if (x > 0) AND (x < content.width) AND (y > 0) AND (y < content.height) then
                       THIS(PixmapItem)[] -> target[];
                   if);
               if);
            #);
          outline::
            (# pt: ^Point2d;
            do &Point2d[] -> pt[];
               x -> pt.x;
               y -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               (if content[]<>none then
                   x + content.width -> pt.x;
                else
                   x -> pt.x;
               if);
               y -> pt.y;
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               
               (if content[]<>none then
                   x + content.width -> pt.x;
                   y + content.height -> pt.y;
                else
                   x -> pt.x;
                   y -> pt.y;
               if);
               pt[] -> points.append;
               
               &Point2d[] -> pt[];
               x -> pt.x;
               (if content[]<>none then
                   y + content.height -> pt.y;
                else
                   y -> pt.y;
               if);
               pt[] -> points.append;
            #);
       #);
     Composite: Item
       (# children: @list
            (# element:: Item;
	    #);
	  add:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompositeAdd: doPart>>
	    #);
	  remove:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompoisteRemove: doPart>>
	    #);
          clear:
            (# <<SLOT CompositeClear: doPart>>  #);
	  drawOn::<
	    (# exclude:< booleanValue;
            <<SLOT CompositeDrawOn: doPart>> 
            #);
          containsPoint::<
            (# 
            do search: children.scanReverse
                 (#
                 do (x, y) -> current.containsPoint -> target[];
                    (if target[] <> NONE then
                        leave search;
                    if);
                 #);
               INNER;
            #);
       #);
     
     select:
       (# x, y: @integer;
          selected: ^Item;
       enter (x, y)
       do x - panx -> x;
          y - pany -> y;
          search:
            (#
            do layers.scanReverse
               (#
               do current.children.scanReverse
                  (#
                  do (x, y) -> current.containsPoint -> target[];
                     (if target[] <> NONE then
                         current[] -> selected[];
                         leave search;
                     if);
                  #);
               #);
               children.scanReverse
               (#
               do (x, y) -> current.containsPoint -> target[];
                  (if target[] <> NONE then
                      current[] -> selected[];
                      leave search;
                  if);
               #);
            #);
       exit selected[]
       #);
     children: @list
       (# Element:: Item;
       #);
     
     current: ^Item;
     target: ^Item;
     
     doublebuffer: ^PixmapSurface;
     panx, pany: @real;
     changedFlag: @boolean;
     updateRgn: @Rectangle;
     
     flush:
       (# <<SLOT GraphicsCanvasFlush: doPart>> #);
     
     updateTimer: @Timer
       (#
          action::
            (#
            do flush;
            #);
       #);
     
     onMouseDown:<
       (# x, y: @integer;
          button: @integer;
       enter (button, x, y)
       do INNER;
       #);
     onMouseMove:<
       (# x, y: @integer;
       enter (x, y)
       do INNER;
       #);
     onMouseUp:<
       (# x, y: @integer;
       enter (x, y)
       do INNER;
       #);
     open::<
       (# <<SLOT GraphicsCanvasOpen: doPart>> #);
     eventHandler::<
       (# onRefresh::< (# <<SLOT GraphicsCanvasOnRefresh: doPart>> #);
          onMouseDown::<
            (# <<SLOT GraphicsCanvasOnMouseDown: doPart>> #);
          onMouseUp::<
            (# <<SLOT GraphicsCanvasOnMouseUp: doPart>> #);
          onMouseMove:<
            (# localPosition: @Point;
               globalPosition: @Point;
               buttonState: @integer;
               doubleClick, shiftKey, controlKey: @boolean;
               when: @integer;
               
            enter (localPosition, globalPosition, buttonState, doubleClick, shiftKey, controlKey, when)
            <<SLOT GraphicsCanvasOnMouseMove: doPart>>
            #);
          
          onMouseWheel:<
            (# globalPosition: @Point;
               button: @integer;
               shiftKey, controlKey: @boolean;
               delta: @integer;
            enter (globalPosition, button, shiftKey, controlKey, delta)
            do INNER onMouseWheel;
            #);
          
          onSystemKeyUp:<
            (* Is called when the user releases a key that was pressed while the 
             * ALT key was held down. 
             * Is also called if the ALT key is released without another key was 
             * pressed while the ALT key was held down.
             * Is also called when the F10 key is released.
             * 
             * Set done to true to stop the application from handling the key 
             * event in the normal way.
             *)
            (# key: @int32u;
               done: @boolean;
            enter key
            do INNER;
            exit done
            #);
       #);
     captured: @boolean;
  #);
  
  
