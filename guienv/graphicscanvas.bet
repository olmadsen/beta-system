ORIGIN '~beta/guienv/guienv';

BODY 'private/graphicscanvasbody';
INCLUDE '~beta/basiclib/math';
INCLUDE '~beta/basiclib/numberio';

-- PixmapLib: attributes --

readAlpha:
  (# error:< exception
       (# what: ^Text;
       enter what[]
       do 'failed to read PNG file  "' -> msg.puttext;
          name[] -> msg.puttext;
          '" ' -> msg.puttext;
          what[] -> msg.puttext;
          INNER;
       #);
     name: ^Text;
  enter name[]
  <<SLOT PixmapReadAlpha: doPart>>
  #);


-- GUIenvLib: attributes --
Point2d:
  (# x, y: @real;
  enter (x, y)
  exit (x, y)
  #);
  
PointList: List
  (# Element:: Point2d;
  #); 


Surface:
  (# <<SLOT SurfaceLib: attributes>>;
     
     init:<
       (#
       do INNER;
       #);
     
     drawText:<
       (# theText: ^Text;
       enter theText[]
       do INNER;
       #);
     drawLine:<
       (# start, end: ^Point2d;
       enter (start[], end[])
       do INNER;
       #);
     drawRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     fillPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     drawPixmap:<
       (# thePixmap: ^Pixmap;
       enter thePixmap[]
       do INNER;
       #);
       
     style:<
       (# theStyle: ^TextStyle;
       enter theStyle[]
       do INNER;
       #);
     pen:<
       (# theColor: ^Color;
       enter theColor[]
       do INNER;
       #);
     width:<
       (# theWidth: @integer;
       enter theWidth
       do INNER;
       #);
     push:<
       (# do INNER #);
     pop:<
       (# do INNER #);
     
     translate:<
       (# dx, dy: @real;
       enter (dx, dy)
       do INNER;
       #);
       
     begin:<
       (# do INNER #);
     end:<
       (# do INNER #);
  #);


  
PixmapSurface: Surface
  (# <<SLOT PixmapSurfaceLib: attributes>>;
     content: ^Pixmap;
     strokewidth: @integer;
     
     init::<
       (# 
       enter content[]
       <<SLOT PixmapSurfaceInit: doPart>>
       #);
     
     drawText:: (# <<SLOT PixmapSurfaceDrawText: doPart>> #);
     drawLine:: (# <<SLOT PixmapSurfaceDrawLine: doPart>> #);
     drawRect:: (# <<SLOT PixmapSurfaceDrawRect: doPart>> #);
     fillRect:: (# <<SLOT PixmapSurfaceFillRect: doPart>> #);
     drawOval:: (# <<SLOT PixmapSurfaceDrawOval: doPart>> #);
     fillOval:: (# <<SLOT PixmapSurfaceFillOval: doPart>> #);
     drawPolygon:: (# <<SLOT PixmapSurfaceDrawPolygon: doPart>> #);
     fillPolygon:: (# <<SLOT PixmapSurfaceFillPolygon: doPart>> #);
     drawPixmap:: (# <<SLOT PixmapSurfaceDrawPixmap: doPart>> #);
     style:: (# <<SLOT PixmapSurfaceStyle: doPart>> #);
     pen:: (# <<SLOT PixmapSurfacePen: doPart>> #);
     width:: (# do theWidth -> strokewidth #);
     push:: (# <<SLOT PixmapSurfacePush: doPart>> #);
     pop:: (# <<SLOT PixmapSurfacePop: doPart>> #);
     translate:: (# <<SLOT PixmapSurfaceTranslate: doPart>> #);
     begin:: (# <<SLOT PixmapSurfaceBegin: doPart>> #);
     end:: (# <<SLOT PixmapSurfaceEnd: doPart>> #);
     private: @<<SLOT PixmapSurfacePrivate: descriptor>>;
  #);


-- WindowLib: attributes --


GraphicsCanvas: Canvas
  (# <<SLOT GraphicsCanvasLib: attributes>>;
     backgroundColor: @color;
     
     
     
     add:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasAdd: doPart>>
       #);
     remove:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasRemove: doPart>>
       #);
     
     
     pan:
       (#
       enter (# enter (panx, pany) do changed #)
       exit (panx, pany)
       #);
     
     changed:
       (# do true -> changedFlag #);
     
     Layer:
       (# children: @list
            (# Element:: Item;
            #);
          
          init:<
            (#
            do INNER;
            #);
          add:
            (# child: ^Item;
            enter child[]
            <<SLOT LayerAdd: doPart>>
            #);
          remove:
            (# child: ^Item;
            enter child[]
            <<SLOT LayerRemove: doPart>>
            #);
          drawOn:
            (# theSurface: ^Surface;
            enter theSurface[]
            <<SLOT LayerDrawOn: doPart>>
	     #);
	#);
      layers: @List
	(# element:: Layer;
	#);

      addLayer:
	(# theLayer: ^Layer;
	enter theLayer[]
	<<SLOT GraphicsCanvasAddLayer: doPart>>
	#);
      removeLayer:
       (# theLayer: ^Layer;
       enter theLayer[]
       <<SLOT GraphicsCanvasRemoveLayer: doPart>>
       #);
     
     Item:
       (# x, y: @real;
          init:<
	    (# do INNER #);
          
          changed:
            (# do this(GraphicsCanvas).changed  #);
          
	  drawOn:<
	    (# theSurface: ^Surface;
	    enter theSurface[]
	    <<SLOT ItemDrawOn: doPart>>
	    #);
          
          
          mouseEvent:
            (# local: @Point2d;
               global: @Point2d;
               button: @integer;
               doubleClick: @boolean;
               shiftKey: @boolean;
               controlKey: @boolean;
               tickcount: @integer;
               
            enter (local, global, button, doubleClick, shiftKey, controlKey, tickcount)
            do INNER;
            #);
          
          
          onMouseDown:< mouseEvent
            (# delay:
                 (# period: @integer
                 enter period
                 <<SLOT GraphicsCanvasItemMouseDownDelay: doPart>>
                 #)
            do INNER;
            #);
          onMouseMove:< mouseEvent;
          onMouseUp:< mouseEvent;
          
          containsPoint:<
            (# x, y: @real;
               target: ^Item;
            enter (x, y)
            do x - THIS(Item).x -> x;
               y - THIS(Item).y -> y;
               INNER;
            exit target[]
            #);
          
          drag:
            (# <<SLOT GraphicsCanvasItemDrag: doPart>> #);
       #);
     SimpleItem: Item
       (# stroke: ^Color;
          fill: ^Color;
          strokewidth: @integer;
       #);
     Line: SimpleItem
       (# start: ^Point2d;
          end: ^Point2d;
          drawOn::
            (# <<SLOT LineDrawOn: doPart>> #);
          containsPoint::
            (# left, right, top, bottom: @real;
               a, b, c: @real;
               d: @real;
               dist: @real;
            do (if start.x < end.x then
                   start.x -> left;
                   end.x -> right;
                else
                   start.x -> right;
                   end.x  -> left;
               if);
               (if start.y < end.y then
                   start.y -> top;
                   end.y -> bottom;
                else
                   start.y -> bottom;
                   end.y  -> top;
               if);
               (if (x >= left) AND (x <= right) AND (y >= top) AND (y <= bottom) then
                   end.x - start.x -> b;
                   -(end.y - start.y) -> a;
                   -a * start.x - b*start.y -> c;
                   a*a + b*b -> sqrt -> d;
                   (if d > 0.0001 then
                       (a*x + b*y + c) / d -> abs -> dist;
                       (if dist < (strokewidth / 2 + 3) then
                           THIS(Line)[] -> target[];
                       if);
                   if);
               if);
            #);
       #);
     Rect: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT RectDrawOn: doPart>> #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Rect)[] -> target[];
               if);
            #);
       #);
     Oval: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT OvalDrawOn: doPart>> #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Oval)[] -> target[];
               if);
            #);
       #);
     Polygon: SimpleItem
       (# points: @PointList;
          drawOn::
            (# <<SLOT PolygonDrawOn: doPart>> #);
       #);
     TextItem: Item
       (# content: ^Text;
          style: ^TextStyle;
          angle: @integer; (* Degrees 0 - 360 counter clockwise *)
          stroke: ^Color;
	  drawOn::
            (# <<SLOT TextItemDrawOn: doPart>> #);
          
       #);
     PixmapItem: SimpleItem
       (# content: ^Pixmap;
          drawOn::
            (# <<SLOT PixmapItemDrawOn: doPart>> #);
       #);
     Composite: Item
       (# children: @list
            (# element:: Item;
	    #);
	  add:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompositeAdd: doPart>>
	    #);
	  remove:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompoisteRemove: doPart>>
	    #);
          clear:
            (# <<SLOT CompositeClear: doPart>>  #);
	  drawOn::
	    (# <<SLOT CompositeDrawOn: doPart>> #);
          containsPoint::
            (# 
            do search: children.scanReverse
                 (#
                 do (x, y) -> current.containsPoint -> target[];
                    (if target[] <> NONE then
                        leave search;
                    if);
                 #);
            #);
       #);
     
     select:
       (# x, y: @integer;
          selected: ^Item;
       enter (x, y)
       do search:
            (#
            do layers.scanReverse
               (#
               do current.children.scanReverse
                  (#
                  do (x, y) -> current.containsPoint -> target[];
                     (if target[] <> NONE then
                         current[] -> selected[];
                         leave search;
                     if);
                  #);
               #);
               children.scanReverse
               (#
               do (x, y) -> current.containsPoint -> target[];
                  (if target[] <> NONE then
                      current[] -> selected[];
                      leave search;
                  if);
               #);
            #);
       exit selected[]
       #);
     children: @list
       (# Element:: Item;
       #);
     
     current: ^Item;
     target: ^Item;
     
     doublebuffer: ^PixmapSurface;
     panx, pany: @real;
     changedFlag: @boolean;
     
     updateTimer: @Timer
       (#
          action::
            (#
            do (if changedFlag then
                   update;
                   false -> changedFlag;
               if);
            #);
       #);
     
     open::<
       (# <<SLOT GraphicsCanvasOpen: doPart>> #);
     eventHandler::<
       (# onRefresh::< (# <<SLOT GraphicsCanvasOnRefresh: doPart>> #);
          onMouseDown::<
            (# <<SLOT GraphicsCanvasOnMouseDown: doPart>> #);
          onMouseUp::<
            (# <<SLOT GraphicsCanvasOnMouseUp: doPart>> #);
          onMouseMove:<
            (# localPosition: @Point;
               globalPosition: @Point;
               buttonState: @integer;
               doubleClick, shiftKey, controlKey: @boolean;
               when: @integer;
               
            enter (localPosition, globalPosition, buttonState, doubleClick, shiftKey, controlKey, when)
            <<SLOT GraphicsCanvasOnMouseMove: doPart>>
            #);
       #);
  #);
  
  
