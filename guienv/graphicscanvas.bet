ORIGIN '~beta/guienv/guienv';

BODY 'private/graphicscanvasbody';



-- WindowLib: attributes --

Point2d:
  (# x, y: @real;
  enter (x, y)
  exit (x, y)
  #);
  
PointList: List
  (# Element:: Point2d;
  #); 
  
GraphicsCanvas: Canvas
  (# <<SLOT GraphicsCanvasLib: attributes>>;
     
     add:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasAdd: doPart>>
       #);
     remove:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasRemove: doPart>>
       #);
     
     Item:
       (# x, y: @real;
          init:<
	    (# do INNER #);
	  drawOn:<
	    (# theSurface: ^Surface;
	    enter theSurface[]
	    <<SLOT ItemDrawOn: doPart>>
	    #);
          onMouseDown:<
            (# x, y: @integer;
            enter (x, y)
            do INNER;
            #);
          onMouseMove:<
            (# x, y: @integer;
            enter (x, y)
            do INNER;
            #);
          onMouseUp:<
            (# x, y: @integer;
            enter (x, y)
            do INNER;
            #);
          containsPoint:<
            (# result: @boolean;
               x, y: @real;
            enter (x, y)
            do x - THIS(Item).x -> x;
               y - THIS(Item).y -> y;
               INNER;
            exit result
            #);
       #);
     SimpleItem: Item
       (# stroke: ^Color;
          fill: ^Color;
       #);
     Rect: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT RectDrawOn: doPart>> #);
          containsPoint::
            (#
            do (x > 0) AND (x < width) AND (y > 0) AND (y < height) -> result;
            #);
       #);
     Oval: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT OvalDrawOn: doPart>> #);
          containsPoint::
            (#
            do (x > 0) AND (x < width) AND (y > 0) AND (y < height) -> result;
            #);
       #);
     Polygon: SimpleItem
       (# points: @PointList;
          drawOn::
            (# <<SLOT PolygonDrawOn: doPart>> #);
       #);
     TextItem: Item
       (# content: ^Text;
          style: ^TextStyle;
          stroke: ^Color;
	  drawOn::
            (# <<SLOT TextItemDrawOn: doPart>> #);
          
       #);
     PixmapItem: SimpleItem
       (# content: ^Pixmap;
          drawOn::
            (# <<SLOT PixmapItemDrawOn: doPart>> #);
       #);
     Composite: Item
       (# children: @list
            (# element:: Item;
	    #);
	  add:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompositeAdd: doPart>>
	    #);
	  remove:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompoisteRemove: doPart>>
	    #);
	  drawOn::
	    (# <<SLOT CompositeDrawOn: doPart>> #);
          containsPoint::
            (# 
            do search: children.scanReverse
                 (#
                 do (x, y) -> current.containsPoint -> result;
                    (if result then
                        leave search;
                    if);
                 #);
            #);
       #);
     select:
       (# x, y: @integer;
          target: ^Item;
       enter (x, y)
       do search: children.scan
            (# result: @boolean;
            do (x, y) -> current.containsPoint -> result;
               (if result then
                   current[] -> target[];
                   leave search;
               if);
            #);
       exit target[]
       #);
     children: @list
       (# Element:: Item;
       #);
     
     target: ^Item;
     
     doublebuffer: @PixmapSurface;
     image: ^Pixmap;
     
     open::<
       (# <<SLOT GraphicsCanvasOpen: doPart>> #);
     eventHandler::<
       (# onRefresh:: (# <<SLOT GraphicsCanvasOnRefresh: doPart>> #);
          onMouseDown::
            (# <<SLOT GraphicsCanvasOnMouseDown: doPart>> #);
          onMouseUp::
            (# <<SLOT GraphicsCanvasOnMouseUp: doPart>> #);
       #);
  #);
  
  
Surface:
  (# <<SLOT SurfaceLib: attributes>>;
     
     init:<
       (#
       do INNER;
       #);
     
     drawText:<
       (# theText: ^Text;
       enter theText[]
       do INNER;
       #);
     drawRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     fillPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     drawPixmap:<
       (# thePixmap: ^Pixmap;
       enter thePixmap[]
       do INNER;
       #);
       
     style:<
       (# theStyle: ^TextStyle;
       enter theStyle[]
       do INNER;
       #);
     pen:<
       (# theColor: ^Color;
       enter theColor[]
       do INNER;
       #);
     push:<
       (# do INNER #);
     pop:<
       (# do INNER #);
     translate:<
       (# dx, dy: @real;
       enter (dx, dy)
       do INNER;
       #);
       
     begin:<
       (# do INNER #);
     end:<
       (# do INNER #);
  #);


  
PixmapSurface: Surface
  (# <<SLOT PixmapSurfaceLib: attributes>>;
     content: ^Pixmap;
     
     init::<
       (# 
       enter content[]
       <<SLOT PixmapSurfaceInit: doPart>>
       #);
     
     drawText:: (# <<SLOT PixmapSurfaceDrawText: doPart>> #);
     drawRect:: (# <<SLOT PixmapSurfaceDrawRect: doPart>> #);
     fillRect:: (# <<SLOT PixmapSurfaceFillRect: doPart>> #);
     drawOval:: (# <<SLOT PixmapSurfaceDrawOval: doPart>> #);
     fillOval:: (# <<SLOT PixmapSurfaceFillOval: doPart>> #);
     drawPolygon:: (# <<SLOT PixmapSurfaceDrawPolygon: doPart>> #);
     fillPolygon:: (# <<SLOT PixmapSurfaceFillPolygon: doPart>> #);
     drawPixmap:: (# <<SLOT PixmapSurfaceDrawPixmap: doPart>> #);
     style:: (# <<SLOT PixmapSurfaceStyle: doPart>> #);
     pen:: (# <<SLOT PixmapSurfacePen: doPart>> #);
     push:: (# <<SLOT PixmapSurfacePush: doPart>> #);
     pop:: (# <<SLOT PixmapSurfacePop: doPart>> #);
     translate:: (# <<SLOT PixmapSurfaceTranslate: doPart>> #);
     begin:: (# <<SLOT PixmapSurfaceBegin: doPart>> #);
     end:: (# <<SLOT PixmapSurfaceEnd: doPart>> #);
     private: @<<SLOT PixmapSurfacePrivate: descriptor>>;
  #);
