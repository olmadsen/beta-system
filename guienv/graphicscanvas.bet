ORIGIN '~beta/guienv/guienv';

BODY 'private/graphicscanvasbody';
INCLUDE '~beta/basiclib/math';
INCLUDE '~beta/basiclib/numberio';

-- PixmapLib: attributes --

readAlpha:
  (# error:< exception
       (# what: ^Text;
       enter what[]
       do 'failed to read PNG file  "' -> msg.puttext;
          name[] -> msg.puttext;
          '" ' -> msg.puttext;
          what[] -> msg.puttext;
          INNER;
       #);
     name: ^Text;
  enter name[]
  <<SLOT PixmapReadAlpha: doPart>>
  #);


-- WindowLib: attributes --

Point2d:
  (# x, y: @real;
  enter (x, y)
  exit (x, y)
  #);
  
PointList: List
  (# Element:: Point2d;
  #); 
  
GraphicsCanvas: Canvas
  (# <<SLOT GraphicsCanvasLib: attributes>>;
     backgroundColor: @color;
     
     add:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasAdd: doPart>>
       #);
     remove:
       (# child: ^Item;
       enter child[]
       <<SLOT GraphicsCanvasRemove: doPart>>
       #);
     
     Layer:
       (# children: @list
            (# Element:: Item;
            #);
          add:
            (# child: ^Item;
            enter child[]
            <<SLOT LayerAdd: doPart>>
            #);
          remove:
            (# child: ^Item;
            enter child[]
            <<SLOT LayerRemove: doPart>>
            #);
          drawOn:
            (# theSurface: ^Surface;
            enter theSurface[]
            <<SLOT LayerDrawOn: doPart>>
            #);
       #);
     Item:
       (# x, y: @real;
          init:<
	    (# do INNER #);
	  drawOn:<
	    (# theSurface: ^Surface;
	    enter theSurface[]
	    <<SLOT ItemDrawOn: doPart>>
	    #);
          onMouseDown:<
            (# x, y: @integer;
            enter (x, y)
            do INNER;
            #);
          onMouseMove:<
            (# x, y: @integer;
            enter (x, y)
            do INNER;
            #);
          onMouseUp:<
            (# x, y: @integer;
            enter (x, y)
            do INNER;
            #);
          containsPoint:<
            (# x, y: @real;
               target: ^Item;
            enter (x, y)
            do x - THIS(Item).x -> x;
               y - THIS(Item).y -> y;
               INNER;
            exit target[]
            #);
       #);
     SimpleItem: Item
       (# stroke: ^Color;
          fill: ^Color;
          strokewidth: @integer;
       #);
     Line: SimpleItem
       (# start: ^Point2d;
          end: ^Point2d;
          drawOn::
            (# <<SLOT LineDrawOn: doPart>> #);
          containsPoint::
            (# left, right, top, bottom: @real;
               a, b, c: @real;
               d: @real;
               dist: @real;
            do (if start.x < end.x then
                   start.x -> left;
                   end.x -> right;
                else
                   start.x -> right;
                   end.x  -> left;
               if);
               (if start.y < end.y then
                   start.y -> top;
                   end.y -> bottom;
                else
                   start.y -> bottom;
                   end.y  -> top;
               if);
               (if (x >= left) AND (x <= right) AND (y >= top) AND (y <= bottom) then
                   end.x - start.x -> b;
                   -(end.y - start.y) -> a;
                   -a * start.x - b*start.y -> c;
                   a*a + b*b -> sqrt -> d;
                   (if d > 0.0001 then
                       (a*x + b*y + c) / d -> abs -> dist;
                       (if dist < (strokewidth / 2 + 3) then
                           THIS(Line)[] -> target[];
                       if);
                   if);
               if);
            #);
       #);
     Rect: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT RectDrawOn: doPart>> #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Rect)[] -> target[];
               if);
            #);
       #);
     Oval: SimpleItem
       (# width, height: @real;
          drawOn::
            (# <<SLOT OvalDrawOn: doPart>> #);
          containsPoint::
            (#
            do (if (x > 0) AND (x < width) AND (y > 0) AND (y < height) then
                   THIS(Oval)[] -> target[];
               if);
            #);
       #);
     Polygon: SimpleItem
       (# points: @PointList;
          drawOn::
            (# <<SLOT PolygonDrawOn: doPart>> #);
       #);
     TextItem: Item
       (# content: ^Text;
          style: ^TextStyle;
          stroke: ^Color;
	  drawOn::
            (# <<SLOT TextItemDrawOn: doPart>> #);
          
       #);
     PixmapItem: SimpleItem
       (# content: ^Pixmap;
          drawOn::
            (# <<SLOT PixmapItemDrawOn: doPart>> #);
       #);
     Composite: Item
       (# children: @list
            (# element:: Item;
	    #);
	  add:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompositeAdd: doPart>>
	    #);
	  remove:
	    (# child: ^Item;
	    enter child[]
	    <<SLOT CompoisteRemove: doPart>>
	    #);
          clear:
            (# <<SLOT CompositeClear: doPart>>  #);
	  drawOn::
	    (# <<SLOT CompositeDrawOn: doPart>> #);
          containsPoint::
            (# 
            do search: children.scanReverse
                 (#
                 do (x, y) -> current.containsPoint -> target[];
                    (if target[] <> NONE then
                        leave search;
                    if);
                 #);
            #);
       #);
     
     select:
       (# x, y: @integer;
          selected: ^Item;
       enter (x, y)
       do search: children.scan
            (#
            do (x, y) -> current.containsPoint -> target[];
               (if target[] <> NONE then
                   current[] -> selected[];
                   leave search;
               if);
            #);
       exit selected[]
       #);
     children: @list
       (# Element:: Item;
       #);
     
     current: ^Item;
     target: ^Item;
     
     doublebuffer: @PixmapSurface;
     image: ^Pixmap;
     
     open::<
       (# <<SLOT GraphicsCanvasOpen: doPart>> #);
     eventHandler::<
       (# onRefresh:: (# <<SLOT GraphicsCanvasOnRefresh: doPart>> #);
          onMouseDown::
            (# <<SLOT GraphicsCanvasOnMouseDown: doPart>> #);
          onMouseUp::
            (# <<SLOT GraphicsCanvasOnMouseUp: doPart>> #);
       #);
  #);
  
  
Surface:
  (# <<SLOT SurfaceLib: attributes>>;
     
     init:<
       (#
       do INNER;
       #);
     
     drawText:<
       (# theText: ^Text;
       enter theText[]
       do INNER;
       #);
     drawLine:<
       (# start, end: ^Point2d;
       enter (start[], end[])
       do INNER;
       #);
     drawRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillRect:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     fillOval:<
       (# width, height: @real;
       enter (width, height)
       do INNER;
       #);
     drawPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     fillPolygon:<
       (# points: ^PointList;
       enter points[]
       do INNER;
       #);
     drawPixmap:<
       (# thePixmap: ^Pixmap;
       enter thePixmap[]
       do INNER;
       #);
       
     style:<
       (# theStyle: ^TextStyle;
       enter theStyle[]
       do INNER;
       #);
     pen:<
       (# theColor: ^Color;
       enter theColor[]
       do INNER;
       #);
     width:<
       (# theWidth: @integer;
       enter theWidth
       do INNER;
       #);
     push:<
       (# do INNER #);
     pop:<
       (# do INNER #);
     
     translate:<
       (# dx, dy: @real;
       enter (dx, dy)
       do INNER;
       #);
       
     begin:<
       (# do INNER #);
     end:<
       (# do INNER #);
  #);


  
PixmapSurface: Surface
  (# <<SLOT PixmapSurfaceLib: attributes>>;
     content: ^Pixmap;
     strokewidth: @integer;
     
     init::<
       (# 
       enter content[]
       <<SLOT PixmapSurfaceInit: doPart>>
       #);
     
     drawText:: (# <<SLOT PixmapSurfaceDrawText: doPart>> #);
     drawLine:: (# <<SLOT PixmapSurfaceDrawLine: doPart>> #);
     drawRect:: (# <<SLOT PixmapSurfaceDrawRect: doPart>> #);
     fillRect:: (# <<SLOT PixmapSurfaceFillRect: doPart>> #);
     drawOval:: (# <<SLOT PixmapSurfaceDrawOval: doPart>> #);
     fillOval:: (# <<SLOT PixmapSurfaceFillOval: doPart>> #);
     drawPolygon:: (# <<SLOT PixmapSurfaceDrawPolygon: doPart>> #);
     fillPolygon:: (# <<SLOT PixmapSurfaceFillPolygon: doPart>> #);
     drawPixmap:: (# <<SLOT PixmapSurfaceDrawPixmap: doPart>> #);
     style:: (# <<SLOT PixmapSurfaceStyle: doPart>> #);
     pen:: (# <<SLOT PixmapSurfacePen: doPart>> #);
     width:: (# do theWidth -> strokewidth #);
     push:: (# <<SLOT PixmapSurfacePush: doPart>> #);
     pop:: (# <<SLOT PixmapSurfacePop: doPart>> #);
     translate:: (# <<SLOT PixmapSurfaceTranslate: doPart>> #);
     begin:: (# <<SLOT PixmapSurfaceBegin: doPart>> #);
     end:: (# <<SLOT PixmapSurfaceEnd: doPart>> #);
     private: @<<SLOT PixmapSurfacePrivate: descriptor>>;
  #);
