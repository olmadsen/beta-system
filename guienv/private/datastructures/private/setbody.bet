ORIGIN '../set';

-- setDeleteSomeDeleteCurrent: doPart --
do data[top][] -> data[doDeleteSome.inx][];
   doDeleteSome.deleted + 1 -> doDeleteSome.deleted;
   
-- setDeleteSome: descriptor --
(# deleted: @integer;
   inx: @integer;
do 0 -> deleted;
   (for i: top repeat 
        i - deleted -> inx;
        data[inx][] -> current[];
        inner deleteSome;
   for);
#)

-- setInsert: doPart --
do l: (# 
      do (for inx: top repeat
              (if data[inx][] = elm[] then
                  leave l;
              if);
         for);
         (if top = data.range then
             data.range -> data.extend;
         if);
         top + 1 -> top;
         elm[] -> data[top][];
         inner insert;
      #);
   
-- setDelete: doPart --
do inner;
   (for inx: top repeat
        (if data[inx][] = elm[] then
            (if top <> 0 then
                data[top][] -> data[inx][];
                none -> data[top][];
                top - 1 -> top;
            if);
        if);
   for);
   
-- setInit: doPart --
do 1 -> data.new;
   0 -> top;
   inner;

-- setClear: doPart --
do 1 -> data.new;
   0 -> top;
   inner;
   
-- setScan: doPart --
do (for inx: top repeat
        data[inx][] -> current[];
        inner;
   for);
   
-- setSize: doPart --
do top -> value;

-- setEmpty: doPart --
do top = 0 -> value;

-- setHas: doPart --
do false -> value;
   l:
     (for inx: top repeat
          (if data[inx][] = elm[] then
              true -> value;
              leave l;
          if);
     for);
   
