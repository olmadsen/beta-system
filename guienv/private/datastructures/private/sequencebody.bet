ORIGIN '../sequence';
INCLUDE '../simplestacks';


-- sequenceLib: attributes --

slideLeft:
  (# i, j: @integer;
  enter (i, j)
  do (for inx: (j - i) + 1 repeat
          storage.data[i + inx - 1][] -> storage.data[i + inx - 2][];
     for);
  #);

slideRight:
  (# i, j: @integer;
  enter (i, j)
  do (for inx: (j - i) + 1 repeat
          storage.data[j - inx + 1][] -> storage.data[j - inx + 2][];
     for);
  #);

-- sequenceDoBinarySearch: descriptor --
(# eq: @equal;
   le: @less;
   low, high, mid: @integer;
   isLess: @boolean;
do none -> left[];
   none -> right[];
   none -> found[];
   storage.low -> low;
   storage.high - 1 -> high;
   search:
     (if low <= high then
         (low + high) div 2 -> mid;
         (if storage.data[mid][] -> eq then
             storage.data[mid][]  -> found[];
             leave search;
          else 
             storage.data[mid][] -> le -> isLess;
             (if isLess then
                 mid + 1 -> low;
                 restart search;
              else
                 mid - 1 -> high;
                 restart search;
             if);
         if);
     if);
   (if found[] = none then
       (if not isLess then
           storage.data[mid][] -> right[];
           (if mid - 1 >= storage.low then
               storage.data[mid - 1][] -> left[];
           if);
        else
           storage.data[mid][] -> left[];
           (if mid + 1 <= storage.high - 1 then
               storage.data[mid + 1][] -> right[];
           if);
       if);
   if);
#)

-- sequenceExtendCapacityRight: doPart --
do n -> storage.data.extend;
   
-- sequenceExtendCapacityLeft: doPart --
do n -> storage.data.extend;
   (for inx: n repeat
        storage.data[inx][] -> storage.data[inx + n][] 
   for);
   storage.low + n -> storage.low;
   storage.high + n -> storage.high;
   
-- sequenceGet: doPart --
do (if storage.low + inx > storage.high then
       indexError;
    else
       storage.data[storage.low + inx - 1][] -> elm[];
   if);
-- sequencePut: doPart --
do (if storage.low + inx > storage.high then
       indexError;
    else
       elm[] -> storage.data[storage.low + inx - 1][];
   if);
   
-- sequenceAppend: doPart --
do (if storage.high = 0 then
       1 -> storage.data.new;
       1 -> storage.low;
       1 -> storage.high;
    else
       (if storage.high - 1 = storage.data.range then
           storage.data.range -> storage.data.extend;
       if);
   if);
   elm[] -> storage.data[storage.high][];
   storage.high + 1 -> storage.high;
   INNER;

-- sequencePrepend: descriptor --
(# range: @integer;
do (if storage.low = 0 then
       1 -> storage.data.new;
       1 -> storage.low;
       2 -> storage.high;
    else
       (if storage.low > 1 then
           storage.low - 1 -> storage.low;
        else
           storage.data.range -> range;
           range -> storage.data.extend;
           (for inx: range repeat
                storage.data[inx][] -> storage.data[inx + range][] 
           for);
           range -> storage.low;
           storage.high + range -> storage.high;
       if);
   if);
   elm[] -> storage.data[storage.low][];
   inner prepend;
#)


-- sequenceDeleteLast: doPart --
do (if storage.low = storage.high then
       emptyContainer;
    else
       storage.high - 1 -> storage.high;
       storage.data[storage.high][] -> elm[];
   if);
   INNER;

-- sequenceDeleteFirst: doPart --
do (if storage.low = storage.high then
       emptyContainer;
    else
       storage.data[storage.low][] -> elm[];
       storage.low + 1 -> storage.low;
   if);
   INNER;

-- sequenceLast: doPart --
do (if storage.low = storage.high then
       emptyContainer;
    else
       storage.data[storage.high - 1][] -> elm[];
   if);

-- sequenceFirst: doPart --
do (if storage.low = storage.high then
       emptyContainer;
    else
       storage.data[storage.low][] -> elm[];
   if);

-- sequenceInit: doPart --
do 0 -> storage.low;
   0 -> storage.high;
   0 -> storage.data.new;
   inner;

-- sequenceClear: doPart --
do 0 -> storage.low;
   0 -> storage.high;
   0 -> storage.data.new;
   inner;

-- sequenceSize: doPart --
do storage.high - storage.low -> value;

-- sequenceScan: doPart --
do (for i: (storage.high - storage.low)  repeat
        storage.data[i + storage.low - 1][] -> current[];
        i -> inx;
        inner;
   for);
   
-- sequenceScanReverse: doPart --
do storage.high - storage.low -> inx;
   (for (storage.high - storage.low)  repeat
        storage.data[storage.low + inx - 1][] -> current[];
        inner;
        inx - 1 -> inx;
   for);
   
-- sequenceEmpty: doPart --
do (storage.low = storage.high) -> value;
   
-- sequenceHas: descriptor --
(#
do false -> value;
   l:
     (for inx: (storage.high - storage.low)  repeat
          (if storage.data[inx + storage.low - 1][] = elm[] then
              true -> value;
              leave l;
          if);
     for);
#)

-- sequenceSort: descriptor --
(# qsort: @storage.quicksort;
   l: @less;
do l[] -> qsort;
#)

-- sequenceInsert: doPart --
do INNER;
   
-- sequenceDelete: doPart --
do l: (for i: (storage.high - storage.low) repeat
           (if storage.data[i + storage.low - 1][] = elm[] then
               (if i < (storage.high - 1) then
                   (storage.low + i, storage.high - 1) -> slideLeft;
               if);
               storage.high - 1 -> storage.high;
               leave l;
           if)
      for);
   INNER;
   

-- sequenceInxInsert: doPart --
do exception (# do 'sequenceInxInsert: doPart is not implemented' -> msg.putText #);
   
-- sequenceInxDelete: doPart --
do exception (# do 'sequenceInxDelete: doPart is not implemented' -> msg.putText #);
   
-- sequenceInsertRange: doPart --
do  exception (# do 'sequenceInsertRange: doPart is not implemented' -> msg.putText #);
-- sequenceDeleteRange: doPart --
do  exception (# do 'sequenceDeleteRange: doPart is not implemented' -> msg.putText #);

-- sequenceStorage: descriptor --
(# data: [0] ^element;
   low, high : @integer;
   
   quickSort:
     (# less: ^lessFunction;
        controlStack: @intStack
          (# initialCapacity:: (# do 100 -> value #);
          #);
        controlPush: @controlStack.push;
        controlPop: @controlStack.pop;
        controlTop: @controlStack.top;
        controlEmpty: @controlStack.empty;
        
        mid, tmp: ^element;
        i, j: @integer;
        lowInx, highInx: @integer;
        midInx: @integer;
     enter less[]
     do low -> controlPush;
        high - 1 -> controlPush;
        control: 
          (if not controlEmpty then
              controlTop -> j;
              controlPop;
              controlTop -> i;
              controlPop;
              sortUpper: 
                (if i < j then
                    data[(i + j) div 2 -> midInx][] -> mid[];
                    i -> lowInx;
                    j -> highInx;
                    swap:
                      (#
                      do moveLowInx:
                           (if (lowInx < highInx) and ((data[lowInx][], mid[]) -> less) then
                               lowInx + 1 -> lowInx;
                               restart moveLowInx
                           if);
                         moveHighInx:
                           (if (lowInx < highInx) and (not ((data[highInx][], mid[]) -> less)) then
                               highInx - 1 -> highInx;
                               restart moveHighInx;
                           if);
                         (if lowInx < highInx then
                             data[lowInx][] -> tmp[];
                             data[highInx][] -> data[lowInx][];
                             tmp[]-> data[highInx][];
                             (if tmp[] = mid[] then
                                 highInx -> midInx;
                             if);
                             restart swap;
                         if);
                      #);
                    (if lowInx <> midInx then
                        data[lowInx][] -> data[midInx][];
                        mid[] -> data[lowInx][];
                    if);
                    (if lowInx + 1 < j then
                        lowInx + 1 -> controlPush;
                        j -> controlPush;
                    if);
                    lowInx - 1 -> j;
                    restart sortUpper;
                if);
              restart control;
          if);
        
     #);
#)

