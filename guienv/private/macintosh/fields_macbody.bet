ORIGIN '../fieldsbody'
[[
-- Include 'guienv_macprivate'
-- Include 'texteditstuff'
-- Include '~beta/maclib/v3.0/scrap'
-- Include 'quickdrawstuff'
-- Include 'windowsstuff'

-- lib: attributes --
between:
	(#	minimum,value,maximum: @integer;
	enter (minimum,value,maximum)
	do ((minimum,value) -> Max, maximum) -> Min -> value;
	exit value
	#);
-- GUIENVmovieFieldSetContents: descriptor --
(#
do
#)

-- GUIENVmovieFieldGetContents: descriptor --
(#
do
#)

-- GUIENVmovieFieldSetScaleToFit: descriptor --
(#
do
#)

-- GUIENVmovieFieldGetScaleToFit: descriptor --
(#
do
#)

-- GUIENVmovieFieldCreate: descriptor --
(#
do
#)

-- GUIENVmovieFieldOpen: descriptor --
(#
do
#)

-- GUIENVmovieFieldClose: descriptor --
(#
do
#)

-- GUIENVmovieFieldPrivate: descriptor --
(#
do
#)

-- GUIENVtextFieldonFrameChanged: descriptor --
(# TextEditUpdateViewRect: external
		(# teHandle: @integer;
			view: ^macRect;
		enter (teHandle,view[])
		#);
	view: ^macRect;
do calcViewRect -> makeMacRect -> view[];
	(textFieldHandle,view[]) -> TextEditUpdateViewRect;
	adjustScrollvaluesMaybe;
	inner onFrameChanged;
#)

-- GUIENVtextFieldonKeyDown: descriptor --
(#	start,end,length: @integer;
	peformEdit: @boolean;
do selection -> (start,end);
	end - start -> length;
	true -> peformEdit;
	(if length<>0//true then
		(start,-length) -> theEventHandler.onBeforeChange -> peformEdit;
	if);
	(if peformEdit//true then
		(if ch<>8//true (* backspace *) then
			this(guienv).private.globalTheText.clear;
			ch -> this(guienv).private.globalTheText.put;
			(start,1) -> theEventHandler.onBeforeChange -> peformEdit;
		if);
		(if peformEdit//true then
			focus
				(# 
				do  (ch,textFieldHandle) -> TEKey
				#);
			handleTextChanged;
		if);
	if);
	inner onKeyDown;
#)

-- GUIENVtextFieldonMouseDown: descriptor --
(#
do inner onMouseDown;
	this(textField)[] -> target;
	focus
		(# macPt: @macPoint;
		do localPosition -> macPt.setPoint;
			(macPt,false,textfieldHandle) -> TEClick;
			adjustScrollValuesMaybe;
			onMouseUp;
		#);
#)

-- GUIENVtextFieldonMouseUp: descriptor --
(#
do inner onMouseUp;
#)

-- GUIENVtextFieldonRefresh: descriptor --
(# view: ^macRect;
	r: @rectangle;
do ((0,0),size) -> r;
	r[] -> makeMacRect -> view[];
	focus
		(#	
		do ResetPen;
			(view[],textFieldHandle) -> TEUpdate;
		#);
	inner onRefresh;
#)

-- GUIENVtextFieldOnEnableTarget: descriptor --
(#
do focus
		(#
		do textFieldHandle -> TEActivate;
		#);
	private.installTimer;
	inner onEnableTarget;
#)

-- GUIENVtextFieldOnDisableTarget: descriptor --
(#
do focus
		(#
		do textFieldHandle -> TEDeactivate;
		#);
	private.deleteTimer;
	inner onDisableTarget;
#)

-- GUIENVtextFieldonIdle: descriptor --
(#
do focus
		(#
		do textFieldHandle -> TEIdle;
		#);
	inner onIdle;
#)

-- GUIENVtextFieldDoPaste: descriptor --
(# offset: @longInt;
	error: @integer;
	TextType: (# exit 1413830740 #);
	clipboardLength: @integer;
	start,end,length: @integer;
	performEdit: @boolean;
do getClipboardLength -> clipboardLength;
	(if clipboardLength + length < 32000//true then
		(if clipboardLength<>0//true then
			selection -> (start,end);
			end - start -> length;
			true -> performEdit;
			(if length<>0//true then
				(start,-length) -> theEventHandler.onBeforeChange -> performEdit;
			if);
			(if performEdit//true then
				(start,clipboardLength) -> theEventHandler.onBeforeChange -> performEdit;
				(if performEdit//true then
					TEFromScrap -> error;
					focus
						(#
						do textFieldHandle -> TEstylePaste;
						#);
					handleTextChanged;
				if);
			if);
		if);
	if);
#)

-- GUIENVtextFieldDoCopy: descriptor --
(# error: @integer;
do ZeroScrap -> error;
	(if error//0 then
		textFieldHandle -> TECopy;
		TEToScrap -> error;
	if);
#)

-- GUIENVtextFieldDoCut: descriptor --
(# error: @integer;
	start,end,length: @integer;
	performEdit: @boolean;
do ZeroScrap -> error;
	(if error//0 then
		selection -> (start,end);
		end - start -> length;
		(if length<>0//true then
			(start,-length) -> theEventHandler.onBeforeChange -> performEdit;
			(if performEdit//true then
				focus
					(#
					do textFieldHandle -> TECut;
					#);
				TEToScrap -> error;
				handleTextChanged;
			if);
		if);
	if);
#)

-- GUIENVtextFieldDoClear: descriptor --
(# start,end,length: @integer;
	performEdit: @boolean;
do selection -> (start,end);
	end - start -> length;
	(if length<>0//true then
		(start,-length) -> theEventHandler.onBeforeChange -> performEdit;
		(if performEdit//true then
			focus
				(#
				do textFieldHandle -> TEDelete;
				#);
			handleTextChanged;
		if);
	if);
#)

-- GUIENVtextFieldSetContents: descriptor --
(#
do textFieldDefaultStyle -> useTextStyle;
	(if (theText[] <> none) and (theText.length > 0) then
	(@@theText.T[1],theText.lgth,textFieldHandle) -> TESetText;
	(if theText.styleInfo<>0 then
		(0,theText.lgth,theText.styleInfo,textFieldHandle,false)
			-> TEUseStyleScrap;
	if);
	(textFieldHandle,0,0) -> TextEditSetSelection;
	else
		(0, 0, textFieldHandle) -> TESetText;
	if);
	(textFieldHandle,0,0) -> TextEditSetSelection;
	adjustScrollValuesMaybe;
	updateMaybe;
#)

-- GUIENVtextFieldGetContents: descriptor --
(#	len: @integer;
	textHandle: @integer;
	address: @integer;
	start,end: @integer;
do	&styledText[] -> theText[];
	(if length > 0 then
	length -> len;
	len - theText.T.range -> theText.extend;
	textFieldHandle -> TEGetText -> textHandle;
	textHandle -> TOS'%adrGetLong' -> address;
	(address,@@theText.T[1],len) -> BlockMove;
	len -> theText.lgth -> theText.pos;
	(0,len) -> withSelection
		(#
		do textFieldHandle -> TEGetStyleScrapHandle -> theText.styleInfo;
		#);
	if);
#)

-- GUIENVtextFieldGetChar: descriptor --
(#
do (textFieldHandle,pos) -> TextEditGetChar -> ch;
#)

-- GUIENVtextFieldLength: descriptor --
(# TextEditGetLength: external
		(# teHandle: @integer;
			length: @integer;
		enter teHandle
		exit length
		#);
do textFieldHandle -> TextEditGetLength -> value;
#)

-- GUIENVtextFieldScanText: descriptor --
(#	teHandle: @integer;
	current,increment: @integer;
	
do	(0,start,length) -> between -> start;
	(0,end,length) -> between -> end;
	(if start<>end//true then
		textFieldHandle -> teHandle;
		start -> current;
		(if start < end//true then
			1 -> increment;
		else
			-1 -> increment;
		if);
		scan:
			(if current<>end//true then
				(teHandle,current) -> TextEditGetChar -> ch;
				inner scanText;
				current + increment -> current;
				restart scan;
			if);
	if);
#)

-- GUIENVtextFieldPosToPt: descriptor --
(# macPt: ^macPoint;
do (pos,textFieldHandle) -> TEGetPoint -> macPt[];
	macPt.getPoint -> pt;
#)

-- GUIENVtextFieldPtToPos: descriptor --
(# macPt: @macPoint;
do	pt -> macPt.setPoint;
	(macPt,textFieldHandle) -> TEGetOffset -> pos;
#)

-- GUIENVtextFieldSelectionStart: descriptor --
(#	TextEditGetSelectionStart: external
		(# teHandle: @integer;
			start: @integer;
		enter teHandle
		exit start
		#);
do textFieldHandle -> TextEditGetSelectionStart -> value;
#)

-- GUIENVtextFieldSelectionEnd: descriptor --
(# TextEditGetSelectionEnd: external
		(# teHandle: @integer;
			end: @integer;
		enter teHandle
		exit end
		#);
do textFieldHandle -> TextEditGetSelectionEnd -> value;
#)

-- GUIENVtextFieldSelectionContents: descriptor --
(# 
do &text[] -> theText[];
	(start,end) -> scanText
		(#
		do ch -> theText.put;
		#);
#)

-- GUIENVtextFieldSelectionScrollIntoView: descriptor --
(#
do focus
		(#
		do textFieldHandle -> TESelView;
		#);
	adjustScrollvaluesMaybe;
#)

-- GUIENVtextFieldSelectionSet: descriptor --
(#
do (if privateAutomaticUpdate then
		focus
			(#
			do (theStart,theEnd,textFieldHandle) -> TESetSelect;
			#);
	else
		focusEmpty
			(#
			do (theStart,theEnd,textFieldHandle) -> TESetSelect;
			#);
	if);
#)

-- GUIENVtextFieldSetDefaultStyle: descriptor --
(#
do style[] -> textFieldDefaultStyle;
#)

-- GUIENVtextFieldGetDefaultStyle: descriptor --
(#
do textFieldDefaultStyle -> style[];
#)

-- GUIENVtextFieldIsOneStyle: descriptor --
(#
do (* Not implemented !!! *)
#)

-- GUIENVtextFieldSetOneSize: descriptor --
(#	macStyle: @textStyleRec;
do	theSize -> macStyle.tsSize;
	(macStyle[],doSize,start,end) -> setStyleElement;
#)

-- GUIENVtextFieldSetOneFont: descriptor --
(#	macStyle: @textStyleRec;
	style: @textStyle;
do	theFont[] -> style.name;
	style.familyID -> macStyle.tsFont;
	(macStyle[],doFont,start,end) -> setStyleElement;
#)

-- GUIENVtextFieldSetOneFace: descriptor --
(#	macStyle: @textStyleRecord;
do	theFace -> macStyle.face;
	(macStyle[],doFace,start,end) -> setStyleElement;
#)

-- GUIENVtextFieldSetOneStyle: descriptor --
(#	macStyle: @textStyleRec;
do	theStyle.familyID -> macStyle.tsFont;
	theStyle.size -> macStyle.tsSize;
	theStyle.face -> macStyle.tsFace;
	(macStyle[],doSize + doFace + doFont,start,end) -> setStyleElement;
#)

-- GUIENVtextFieldScanTextWithStyle: descriptor --
(#
do (* Not implemented !!! *)
#)

-- GUIENVtextFieldSetMargin: descriptor --
(#
do	(leftMargin,topMargin) -> textFieldMargin;
#)

-- GUIENVtextFieldGetMargin: descriptor --
(#
do textFieldMargin ->  (leftMargin,topMargin);
#)

-- GUIENVtextFieldInsert: descriptor --
(#
do (if (theText[] <> none) and (theText.lgth <> 0) then
		(if privateAutomaticUpdate then
		focus
			(#
			do (@@theText.T[1],theText.lgth,textFieldHandle) -> TEInsert
			#);
	else
		focusEmpty
			(#
			do (@@theText.T[1],theText.lgth,textFieldHandle) -> TEInsert
			#);
	if);
	adjustScrollvaluesMaybe;
	if);
#)

-- GUIENVtextFieldDelete: descriptor --
(#
do (if privateAutomaticUpdate then
		focus
			(#
			do textFieldHandle -> TEDelete;
			#);
	else
		focusEmpty
			(#
			do textFieldHandle -> TEDelete;
			#);
	if);
	adjustScrollvaluesMaybe
#)

-- GUIENVtextFieldCreate: descriptor --
(#
do whiteBackGround -> backGroundStyle;
	inner create;
#)

-- GUIENVtextFieldOpen: descriptor --
(# style: ^textStyle;
do &textStyle[] -> style[];
	'Courier' -> style.name;
	12 -> style.size;
	style[] -> textFieldDefaultStyle;
	textFieldDefaultStyle -> useTextStyle;
	(4,4) -> textFieldMargin;
	((0,0),(100,100)) -> privateWindowItemFrame;
	father.calculateFocusForChildren;
	focus
		(# view,dest: ^macRect;
		do calcViewRect -> makeMacRect -> view[];
			calcInitialDestRect -> makeMacRect -> dest[];
			(dest[],view[]) -> TEStyleNew -> textFieldHandle;
			(true,textFieldHandle) -> TEAutoView;
		#);
	false -> this(windowitem).private.updateOnResize;
	cursors.iBeam[] -> theCursor;
	(if this(window).style = plain then
		borderStyles.simple -> border.style;
	else
		borderStyles.shadowIn -> border.style;
	if);
	true -> border.visible;
	cursors.iBeam[] -> theCursor;
	inner open;
#)

-- GUIENVtextFieldClose: descriptor --
(#
do inner close;
	textFieldHandle -> TEDispose;
#)

-- textFieldLib: attributes --
handleTextChanged:
	(# 
	do adjustScrollvaluesMaybe;
		theEventHandler.onTextChanged;
	#);
adjustScrollvaluesMaybe:
	(# theTextEditor: ^textEditor;
	do textFieldScroller -> theTextEditor[];
		(if theTextEditor[]<>none//true then
			theTextEditor.adjustScrollValues;
		if);
	#);
getClipboardLength: integerValue
	(# offset: @longInt;
		TextType: (# exit 1413830740 #);
	do (0,TextType,offset[]) -> GetScrap -> value;
	#);
calcViewRect:
	(#	r: ^rectangle;
		left,top: @integer;
		width,height: @integer;
		t: @text;
	do &rectangle[] -> r[];
		textFieldMargin -> (left,top);
		(left+1,top+1) -> r.topLeft;
		size -> (width,height);
		width - 1 -> r.right;
		height - 1 -> r.bottom;
	exit r[]
	#);
calcInitialDestRect:
	(#	r: ^rectangle;
		left,top: @integer;
		width,height: @integer;
	do &rectangle[] -> r[];
		textFieldMargin -> (left,top);
		(left+1,top+1) -> r.topLeft;
		size -> (width,height);
		1000 -> r.right;
		height - top - 1 -> r.bottom;
	exit r[]
	#);
textFieldHandle:
	(#
	enter private.textFieldHandle
	exit private.textFieldHandle
	#);
textFieldDefaultStyle:
	(#
	enter private.textFieldDefaultStyle[]
	exit private.textFieldDefaultStyle[]
	#);
textFieldMargin:
	(#
	enter private.textFieldMargin
	exit private.textFieldMargin
	#);
textFieldScroller:
	(#
	enter private.textFieldScroller[]
	exit private.textFieldScroller[]
	#);
TextEditSetSelection: external
	(# teHandle: @integer;
		start,end: @integer;
	enter (teHandle,start,end)
	#);
TextEditGetSelection: external
	(# teHandle: @integer;
		startP,endP: @integer;
	enter (teHandle,startP,endP)
	#);
TextEditGetChar: external
	(#	teHandle: @integer;
		inx: @integer;
		ch: @integer;
	enter (teHandle,inx)
	exit ch
	#);
withSelection:
	(# start,end: @integer;
		curStart,curEnd: @integer;
	enter (start,end)
	do (textFieldHandle,@@curStart,@@curEnd) -> TextEditGetSelection;
		(textFieldHandle,start,end) -> TextEditSetSelection;
		inner;
		(textFieldHandle,curStart,curEnd) -> TextEditSetSelection;
	#);
setStyleElement:
	(#	macStyle: ^textStyleRec;
		curStart,curEnd,start,end: @integer;
		currentSelection: @boolean;
		element: @integer;
	enter (macStyle[],element,start,end)
	do	selection -> (curStart,curEnd);
		(curStart = start) and (curEnd = end) -> currentSelection;
		(if currentSelection//true then
			focus
				(#
				do (element,macStyle[],true,textFieldHandle) -> TESetStyle;
				#);
		else
			(start,end) -> withSelection
				(#
				do (element,macStyle[],false,textFieldHandle) -> TESetStyle;
				#);
			updateMaybe;
		if);
		adjustScrollvaluesMaybe;
	#);
-- GUIENVtextFieldPrivate: descriptor --
(# textFieldHandle: @integer;
	textFieldDefaultStyle: ^textStyle;
	textFieldMargin: @point;
	textFieldScroller: ^textEditor;
	installTimer:
		(#
		do theTimer[] -> this(GUIenv).private.timerQueue.insert;
		#);
	deleteTimer:
		(#
		do theTimer[] -> this(GUIenv).private.timerQueue.delete;
		#);
	theTimer: @timerAction
		(# doIt:@ focus
				(#
				do textFieldHandle -> TEIdle;
				#);
		do (if textFieldHandle <> 0 then
				doIt;
			if);
		#);
	
#)

-- GUIENVabstractScrollerScroll: descriptor --
(#
do inner scroll;
#)

-- GUIENVabstractScrollerCreate: descriptor --
(#
do inner create;
#)

-- GUIENVabstractScrollerOpen: descriptor --
(#
do ((0,0),(200,200)) -> privateWindowItemFrame;
	(if father[] <> none then
		father.calculateFocusForChildren;
	else
		calculateFocus;
	if);
	&scrollerVerticalScrollbar[] -> THIS(abstractScroller).private.VerticalScrollbar[];
	this(abstractScroller)[] -> THIS(abstractScroller).private.VerticalScrollbar.open;
	&scrollerHorizontalScrollbar[] -> THIS(abstractScroller).private.HorizontalScrollbar[];
	this(abstractScroller)[] -> THIS(abstractScroller).private.HorizontalScrollbar.open;
	true -> border.visible;
	inner open;
#)

-- GUIENVabstractScrollerClose: descriptor --
(#
do inner close;
	THIS(abstractScroller).private.VerticalScrollbar.close;
	THIS(abstractScroller).private.HorizontalScrollbar.close;
#)

-- abstractScrollerLib: attributes --
scrollerVerticalScrollbar: scrollbar
	(#	open::<
			(# width,height: @integer;
			do this(abstractScroller).size -> (width,height);
				((width - 16,0),(width,height - 15)) -> frame;
				true -> bindTop;
				true -> bindRight;
				false -> bindLeft;
				true -> bindBottom;
			#);
		eventHandler::<
			(#	onButtonDown::<
					(#
					do (0,scrollAmount) -> scroll;
						focusZero;
					#);
				onButtonUp::<
					(#
					do (0,-scrollAmount) -> scroll;
						focusZero;
					#);
				onPageUp::<
					(#
					do (0,-pageScrollAmount) -> scroll;
						focusZero;
					#);
				onPageDown::<
					(#
					do (0,pageScrollAmount) -> scroll;
						focusZero;
					#);
				onThumbMoved::<
					(#
					do (0,amount) -> scroll;
						focusZero;
					#);
			#);
	#);
scrollerHorizontalScrollbar: scrollbar
	(#	open::<
			(# width,height: @integer;
			do this(abstractScroller).size -> (width,height);
				((0,height - 16),(width - 15,height)) -> frame;
				true -> bindLeft;
				false -> bindTop;
				true -> bindRight;
				true -> bindBottom;
			#);
		eventHandler::<
			(#	onButtonDown::<
					(#
					do (scrollAmount,0) -> scroll;
						focusZero;
					#);
				onButtonUp::<
					(#
					do (-scrollAmount,0) -> scroll;
						focusZero;
					#);
				onPageUp::<
					(#
					do (-pageScrollAmount,0) -> scroll;
						focusZero;
					#);
				onPageDown::<
					(#
					do (pageScrollAmount,0) -> scroll;
						focusZero;
					#);
				onThumbMoved::<
					(# 
					do (amount,0) -> scroll;
						focusZero;
					#);
			#);
	#);
-- GUIENVabstractScrollerPrivate: descriptor --
(# verticalScrollbar, horizontalScrollbar: ^scrollbar;
#)

-- textEditorLib: attributes --

adjustScrollValues:
	(#	TextEditGetScrollvalues: external
			(#	editTextHandle: @integer;
				hMaxP,hP,vMaxP,vP: @integer;
			enter (editTextHandle,hMaxP,hP,vMaxP,vP)
			#);
		TextEditAdjustScroll: external
			(#	editTextHandle: @integer;
				h,v: @integer;
			enter (editTextHandle,h,v)
			#);
		hMax,h,vMax,v: @integer;
		t: @text;
		width,height: @integer;
	do (contents.textFieldHandle,@@hMax,@@h,@@vMax,@@v) -> TextEditGetScrollvalues;
		hMax -> THIS(abstractScroller).private.HorizontalScrollbar.maxValue;
		h -> THIS(abstractScroller).private.HorizontalScrollbar.value;
		vMax -> THIS(abstractScroller).private.VerticalScrollbar.maxValue;
		v -> THIS(abstractScroller).private.VerticalScrollbar.value;
		(* contents.focus
			(#
			do (contents.textFieldHandle,h,v) -> TextEditAdjustScroll;
			#); *)
		contents.size -> (width,height);
		width -> THIS(abstractScroller).private.HorizontalScrollbar.pageScrollAmount;
		height -> THIS(abstractScroller).private.VerticalScrollbar.pageScrollAmount;
	#);
-- GUIENVtextEditorScroll: descriptor --
(#
do contents.focus
		(#
		do (-dh,-dv,contents.textFieldHandle) -> TEPinScroll;
		#);
	inner scroll;
#)

-- GUIENVtextEditorCreate: descriptor --
(#
do inner create;
#)

-- GUIENVtextEditorOpen: descriptor --
(# width,height: @integer;
do	this(textEditor)[] -> contents.textFieldScroller;
	this(textEditor)[] -> contents.open;
	size -> (width,height);
	((2, 2), (width - 16, height - 16)) -> contents.frame;
	(* ((0,0),(width - 15,height - 15)) -> contents.frame; *)
	true -> contents.bindLeft;
	true -> contents.bindTop;
	true -> contents.bindRight;
	true -> contents.bindBottom;
	false -> contents.border.visible;
	inner open;
#)

-- GUIENVtextEditorClose: descriptor --
(#
do inner close;
#)

-- GUIENVtexteditorprivate: descriptor --
(#
#)
-- GUIENVscrollerScroll: descriptor --

(* Denne version virker, men er lidt grim: *)
(# h, v: @integer;
	width,height,viewWidth,viewHeight: @integer;
	newH,newV: @integer;
	saved: @boolean;
do true -> private.scrolling;
	contents.position -> (h, v);
	contents.size -> (width,height);
	private.view.size -> (viewWidth,viewHeight);
	((viewWidth - width, 0) -> Min, h - dh, 0) -> between -> newH;
	((viewHeight - height, 0) -> Min, v - dv, 0) -> between -> newV;
	(if (newH <> h) OR (newV <> v) then
 		contents.privateAutomaticUpdate -> saved;
		false -> contents.privateAutomaticUpdate;
		(newH,newV) -> contents.position;
		saved -> contents.privateAutomaticUpdate;
		(newH, newV) -> contents.position;
		contents.theEventHandler.onRefresh;
	if);
	false -> private.scrolling;
#)


-- GUIENVscrollerCreate: descriptor --
(#
do	inner create;
#)

-- GUIENVscrollerOpen: descriptor --
(# width,height: @integer;
do	this(scroller)[] -> private.view.open;
	whiteBackGround -> private.view.backGroundStyle;
	private.view[] -> contents.open;
	whiteBackGround -> contents.backGroundStyle;
	size -> (width,height);
	((2,2),(width - 16,height - 16)) -> private.view.frame;
	true -> private.view.bindLeft;
	true -> private.view.bindTop;
	true -> private.view.bindRight;
	true -> private.view.bindBottom;
	((0,0),(1000,1000)) -> contents.frame;
	adjustScrollValues;
	
	inner open;
#)

-- GUIENVscrollerClose: descriptor --
(#
do inner close;
#)

-- scrollerLib: attributes --
adjustScrollValues:
	(#	width,height,viewWidth,viewHeight: @integer;
		h,v: @integer;
		maxWidth, maxHeight: @integer;
	do contents.size -> (width,height);
		private.view.size -> (viewWidth,viewHeight);
		
		(width - viewWidth, 	0) -> Max -> maxWidth;
		(height - viewHeight, 	0) -> Max -> maxHeight;
		
		maxWidth -> THIS(abstractScroller).private.HorizontalScrollbar.maxValue;
		maxHeight -> THIS(abstractScroller).private.VerticalScrollbar.maxValue;
		
		contents.position -> (h,v);
		(0, -h, maxWidth) -> between -> h;
		(0, -v, maxHeight) -> between -> v;
		h -> THIS(abstractScroller).private.HorizontalScrollbar.value;
		v -> THIS(abstractScroller).private.VerticalScrollbar.value;
		
		(h,v) -> setScroll;
		
		viewWidth -> THIS(abstractScroller).private.HorizontalScrollbar.pageScrollAmount;
		viewHeight -> THIS(abstractScroller).private.VerticalScrollbar.pageScrollAmount;
	#);
setScroll:
	(#	h,v: @integer;
		currentH,currentV: @integer;
	enter (h,v)
	do contents.position -> (currentH,currentV);
		(if (h<>currentH) and (v<>currentV)//true then
			(currentH - h,currentV - v) -> scroll;
		if);
	#);

-- GUIENVscrollerOnFrameChanged: descriptor --
(#
do adjustScrollValues;
	inner onFrameChanged;
#)

-- GUIENVscrollerPrivate: descriptor --
(# scrolling: @boolean;
	view: @canvas
		(# eventHandler::
				(# onChildFrameChanged::
						(#
						do (if not scrolling then
								adjustScrollValues; 
							if);
						#);
				#);
		#);
#)

-- GUIENVputmovieFieldLayout: doPart --
do

-- GUIENVgetmovieFieldLayout: doPart --
do

-- GUIENVtextFieldputLayout: doPart --
do

-- GUIENVtextFieldgetLayout: doPart --
do

-- GUIENVabstractScrollerputLayout: doPart --
do

-- GUIENVabstractScrollergetLayout: doPart --
do

-- GUIENVtextEditorputLayout: doPart --
do

-- GUIENVtextEditorgetLayout: doPart --
do

-- GUIENVscrollerputLayout: doPart --
do

-- GUIENVscrollergetLayout: doPart --
do

-- GUIENVtextFieldBeforeChangeTheText: doPart --
do this(guienv).private.globalTheText.copy -> value[];

--]]
