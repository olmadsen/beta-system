ORIGIN 'guienv_macprivate';

BUILD default ':$$/guienv_mac.obj' ':external/guienv_mac.c' 'mrc -proto strict -o $0 $1';
BUILD default ':$$/windowmanagement.obj' ':external/windowmanagement.c' 'mrc -proto strict -o $0 $1';

RESOURCE default 'external/guienv.r';

INCLUDE '~beta/maclib/v3.1/osutils';
INCLUDE '~beta/maclib/v3.1/debug';
INCLUDE '~beta/maclib/v3.1/windows';
INCLUDE '~beta/maclib/v3.1/fonts';
INCLUDE '~beta/maclib/v3.1/quickdraw';
INCLUDE '~beta/maclib/v3.1/dialogs';
INCLUDE '~beta/maclib/v3.1/toolutils';
INCLUDE '~beta/maclib/v3.1/scrap';
INCLUDE '~beta/maclib/v3.1/textedit';
INCLUDE '~beta/maclib/v3.1/desk';
INCLUDE '~beta/maclib/v3.1/menus';
INCLUDE '~beta/maclib/v3.1/memory';
INCLUDE '~beta/maclib/v3.1/diskinit';
INCLUDE '~beta/maclib/v3.1/events';
INCLUDE '~beta/maclib/v3.1/appleevents';
INCLUDE '~beta/maclib/v3.1/morefiles';

INCLUDE '~beta/containers/v1.6/list';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '../linkedlist';
INCLUDE '../../fields';
INCLUDE '../../graphics';

-- lib: attributes --
MACLocalToGlobal:
	(# p: ^macPoint 
	enter p[]
	do p[] -> LocalToGlobal;
	#);
MACGlobalToLocal:
	(# p: ^macPoint 
	enter p[]
	do p[] -> GlobalToLocal;
	#);
	
-- canvasLib: attributes --
processMouseDown:
	(# pt: @point;
		theObjectClicked: ^windowitem;
		theCanvas: ^canvas;
	enter pt
	do pt -> private.children.findObjectClicked -> theObjectClicked[];
		(if theObjectClicked[] = none then
			pt -> private.figs.findObjectClicked -> theObjectClicked[];
		if);
		(if theObjectClicked[] = none then
			pt -> currentLocalPosition;
			(if doubleClickPossible then
				(if lastClickedObject <> THIS(canvas)[] then
					false -> doubleClickPossible
				if);
			if);
			this(canvas)[] -> lastClickedObject;
			theEventHandler.onMouseDown;
		else
			theObjectClicked.position -> pt.subTract;
			(if theObjectClicked##<= canvas## then
				theObjectClicked[] -> theCanvas[];
				pt -> theCanvas.processMouseDown
			else
				pt -> currentLocalPosition;
				(if doubleClickPossible then
					(if lastClickedObject <> theObjectClicked[] then
						false -> doubleClickPossible
					if);
					
				if);
				theObjectClicked[] -> lastClickedObject;
				theObjectClicked.theEventHandler.onMouseDown;
			if);
		if);
	#);
	
-- GUIENVLib: attributes --


(*****
 * Interface to the routines in "windowmanagement.c"
 *****)
 
SetWindowMaxSize: external
	(# theWindow: @integer;
		width, height: @integer;
	enter (theWindow, width, height)
	#);

SetWindowBackground: external
	 (# theWindow: @integer;
		   red, green, blue: @shortInt;
		enter (theWindow, red, green, blue)
	 #);
	 
SelectTheWindow: external
	(# theWindow: @integer;
		deActivatedWindow: @integer;
	enter	theWindow
	exit deActivatedWindow
	#);
DragTheWindow: external
	(# theWindow: @integer;
		startPt: @integer;
		dragRect: ^macrect;
	enter	(theWindow, startPt, dragRect[])
	#);
ShowTheWindow: external
	(# theWindow: @integer;
	enter	theWindow
	#);
HideTheWindow: external
	(# theWindow: @integer;
	enter	theWindow
	#);
SetTheWindowKind: external
	(# theWindow: @integer;
		kind: @shortInt;
	enter	(theWindow, kind)
	#);
	
FrontNonFloatingWindow: external
	(# theWindow: @integer;
	exit theWindow
	#);
(* END of windowmanagement *)


makeColor:
	(# maxValue: (# exit 65535 #);
   	percent: @integer;
   	value: @integer;
   	theColor: ^color;
   enter	percent
   do (maxValue * percent) div 100 -> value;
  		&color[] -> theColor[];
   	(value, value, value) -> theColor;
   exit theColor[]
   #);
	

sleep: (# exit 2 #);
mainLoop:
	(#	processOne: @processOneEvent;
	do l:
			(if not private.done then
				processOne;
				restart l;
			if);
	#);
processOneEvent:
	(# gotEvent: @boolean;
		dispatch: @dispatchEvent;
		currentTime: @integer;
		WaitNextEvent: External
			(# eventMask: @ShortInt;
				theEvent: @integer;
				sleep,mouseRgn: @Integer;
				result: @Boolean;
			enter (eventMask, theEvent, sleep, mouseRgn)
			do '$A860' -> PascalTrap;
			exit result
			#);
	do	(if private.globalMacMenuBar.needsUpdate then
			private.globalMacMenuBar.update;
		if);
		(if private.updateCursorFlag then
			doUpdateCursor;
		if);
		TickCount -> currentTime;
		(if currentTime - private.timerQueue.lastVisit > private.timerQueue.minInterval then
			private.timerQueue.executeElapsed;
		if);
		(everyEvent,private.event.address,sleep,private.cursorRegion) -> WaitNextEvent -> gotEvent;
		(if gotEvent then
			dispatch;
		if);
	#);
dispatchEvent:
	(# doProcessMouseDown: @processMouseDown;
		doProcessMouseUp: @processMouseUp;
		doProcessKeyDown: @processKeyDown;
		doProcessActivate: @processActivate;
		doProcessUpdate: @processUpdate;
		doProcessDiskEvent: @processDiskEvent;
		doProcessOsEvent: @processOsEvent;
		doProcessHighLevelEvent: @processHighLevelEvent;
	do (if private.event.what
			//mouseDown then doProcessMouseDown
			//mouseUp then doProcessMouseUp
			//keyDown//autoKey then doProcessKeyDown
			//activateEvt then doProcessActivate
			//updateEvt then doProcessUpdate
			//diskEvt then doProcessDiskEvent
			//osEvt then doProcessOsEvent
			//kHighLevelEvent then doProcessHighLevelEvent
		if);
	#);
processMouseDown:
	(# partCode: @integer;
		windowPointer: @longint;
		theWindow: ^window;
		macPt: @macPoint;
		clickPosition,pt: @point;
		time,dlbClickTime: @integer;
		SystemClick: External
			(# theEvent: @integer;
			   theWindow: @Integer;
			enter (theEvent,theWindow)
			do '$A9B3' -> pascalTrap;
			#);
	do false -> doubleClickPossible;
		true -> sendOnMouseUp;
		(private.event.where,windowPointer[]) -> FindWindow -> partCode;
		(if partCode
			//inMenubar then
				(if modalState = systemModal then
					30 -> SysBeep;
				else
					processMenubarClick;
				if);
				false -> sendOnMouseUp;
			//inSysWindow then
				(private.event.address,windowPointer) -> SystemClick;
				false -> sendOnMouseUp;
			//inDesk then
				false -> sendOnMouseUp;
		else
			(* first determine if this can possibly be a doubleclick *)
			private.event.where -> macPt;
			macPt.getPoint -> clickPosition;
			private.event.when -> time;
			lastClickPosition -> pt;
			clickPosition -> pt.subTract;
			(if (pt.h*pt.h + pt.v*pt.v) < 10 then
				GetDblTime -> dlbClickTime;
				((time - lastClickTime) < dlbClickTime) -> doubleClickPossible;
		  	if);
			clickPosition -> lastClickPosition;
			time -> lastClickTime;
			(* now find the window *)
			windowPointer -> private.windows.findBywindowPointer -> theWindow[];
			(if theWindow[]<>none then
				partCode -> theWindow.processMouseDown;
			else
				false -> sendOnMouseUp;
				NONE -> lastClickedObject;
			if);
		if);
	#);
processMouseUp: 
	(# 
	do	(if sendOnMouseUp then
			(if lastClickedObject <> NONE then
				(lastClickedObject).theEventHandler.onMouseUp;
			if);
		if);
	#);
processKeyDown: 
	(# key: @char;
		result: @longInt;
		theWindow: ^window;
	do private.event.charCode -> key;
		(if private.event.cmdKey then
			(if private.event.what//keyDown then
				private.globalMacMenubar.adjust;
				key -> MenuKey -> result;
				(if result.hiWord<>0 then
					(result.hiWord,result.loWord) -> processMenuSelect;
					0 -> HiliteMenu;
				if);
			if);
		else
			activeWindow -> theWindow[];
			(if theWindow[]<>none then
				key -> theWindow.processKeyDown;
			if);
		if);
	#);
processActivate: 
	(# theWindow: ^window;
	do private.event.message -> private.windows.findByWindowPointer -> theWindow[];
		(if theWindow[]<>none then
			private.event.activeFlag -> theWindow.processActivate;
		if);
	#);
processUpdate: 
	(# windowPointer: @integer;
		theWindow: ^window;
	do	private.event.message -> windowPointer;
		windowPointer -> private.windows.findByWindowPointer -> theWindow[];
		(if theWindow[]<>none then
			theWindow.processUpdate;
		if);
	#);
processDiskEvent: 
	(# message: @longint;
		macPt: @macPoint;
		theError: @integer;
	do private.event.message -> message;
		(if message.hiWord<>0 then
			(* DILoad; *)
			(120,120) -> macPt.setPoint;
			(* (macPt,message) -> DIBadMount -> theError; *)
		if);
	#);
processOsEvent: 
	(#
	do (if private.event.app4Selector
			//1 then
				(if private.event.resume then
					processResume;
				else
					processSuspend;
				if);
			//250 then processMouseMoved;
		if);
	#);
processResume:
	(#	theWindow: ^window;
	do private.windows.scan
			(#
			do (if current.type = windowTypes.palette then
					(if current.private.windowVisible then
						(current.private.windowPointer, true) -> ShowHide;
					if);
				if);
			#);
		activeWindow -> theWindow[];
		(if theWindow[] <> none then
			(theWindow.private.windowPointer, true) -> HiliteWindow;
			true -> theWindow.processActivate;
		if);
		true -> updateCursor;
	#);
processSuspend:
	(#	theWindow: ^window;
	do private.windows.scan
			(#
			do (if current.type = windowTypes.palette then
					(if current.private.windowVisible then
						(current.private.windowPointer, false) -> ShowHide;
					if);
				if);
			#);
		activeWindow -> theWindow[];
		(if theWindow[] <> none then
			(theWindow.private.windowPointer, false) -> HiliteWindow;
			false -> theWindow.processActivate;
		if);
	#);
processMouseMoved:
	(#
	do doUpdateCursor;
	#);
processHighLevelEvent: 
	(# err: @integer;
		AEProcessAppleEvent: External
		  (# theEventRecord: @integer; OSErr: @ShortInt; 
		  enter theEventRecord
		  do '{$303C,$021B,$A816}'->PascalTrap; 
		  exit OSErr
		  #);
	do private.event.address -> AEProcessAppleEvent -> err; 
	#);

processMenubarClick:
	(# result: @longint;
	do	private.globalMacMenubar.adjust;
		private.event.where -> MenuSelect -> result;
		(if result.hiWord<>0 then
			(result.hiWord,result.loWord) -> processMenuSelect;
			0 -> HiliteMenu;
		if);
	#);
processMenuSelect:
	(# menuID,itemNumber: @integer;
		theMenu: ^menu;
		appleMenuID: (# exit 128 #);
	enter (menuID,itemNumber)
	do (if menuID//appleMenuID then
			itemNumber -> processAppleMenuSelect;
		else
			menuID -> private.menus.findByID -> theMenu[];
			itemNumber -> theMenu.itemSelected;
		if);
	#);
processAppleMenuSelect:
	(# number: @integer;
		itemText: @pascalString;
		rep:  ^text;
		daRefNum: @integer;
	enter number
	do (if number//1 then
			showAboutBox;
		else
			(appleMenu,number,itemText[]) -> GetMenuItemText;
			itemText.getText -> rep[];
			rep -> OpenDeskAcc -> daRefNum;
		if);
	#);
showAboutBox:
	(# result: @integer;
	do (7128,0) -> Alert -> result;
	#);
	
	
	  
	  
installAppleEvent:
	(# handler: ##AppleEventHandler;
		class, type: @integer;
		err: @integer;
	enter (class, type, handler##)
	do (class, type, handler##, 1234, false) -> AEInstallEventHandler -> err;
	#);

handleOpenDocuments: appleEventHandler
	(# docList: @AEDescList;
		count: @longInt;
		keywd, returnedType, actualSize: @longInt;
		spec: @FSSpec;
		AEGetParamDesc: External
		  (# theAppleEvent: @integer;
			  theAEKeyword,desiredType: @Integer;
			  result: ^AEDesc;
			  OSErr: @ShortInt;
			  
		  enter (theAppleEvent,theAEKeyword,desiredType,result[])
		  do '{$303C,$0812,$A816}'->PascalTrap; 
		  exit OSErr
		  #);
		AEGetNthPtr: External
		  (# theAEDescList: ^AEDescList;
			  index,desiredType,maximumSize: @Integer;
			  data: ^cStruct;
			  theAEKeyword,typeCode,actualSize: ^LongInt;
			  OSErr: @ShortInt;
			  
		  enter
		  (theAEDescList[],index,desiredType,theAEKeyword[],typeCode[],data[],maximumSize,actualSize[])
		  do '{$303C,$100A,$A816}'->PascalTrap; 
		  exit OSErr
		  #);
		path: ^text;
		ignoreErr: @integer;
	do (theAppleEvent, keyDirectObject, typeAEList, docList[]) -> AEGetParamDesc -> err;
		(if err = 0 then
			(doclist[], count[]) -> AECountItems -> err;
			(if err = 0 then
				(for index: count repeat
					(docList[], index, typeFSS, keywd[], returnedType[], spec[], 70, actualSize[])
						-> AEGetNthPtr -> err;
					(if err = 0 then
						spec[] -> convertToFullPath -> path[];
						(if path[] <> NONE then
							path[] -> onOpenDocument;
						if);
					if);
				for);
			if);
			docList[] -> AEDisposeDesc -> ignoreErr;
		if);
	#);
handleOpenApplication: appleEventHandler
	(#
	do onStartApplication
	#);
handleQuitApplication: appleEventHandler
	(#
	do Terminate;
	#);
	
installCoreEventhandlers:
	(#
	do (kCoreEventClass, kAEOpenDocuments, handleOpenDocuments##) -> installAppleEvent;
		(kCoreEventClass, kAEOpenApplication, handleOpenApplication##) -> installAppleEvent;
		(kCoreEventClass, kAEQuitApplication, handleQuitApplication##) -> installAppleEvent;
	#);
	
-- GUIENVdoUpdateCursor: doPart --
do
(# macPt, windowPosition: @macPoint;
	cursorRgn: @integer;
	theWindow: ^window;
	left, top: @integer;
	visRgn: @integer;
	result: @boolean;
	handled: @boolean;
	GlobalToLocal: External (# p: ^macPoint enter p[] do '$A871' -> PascalTrap; #);
do false -> private.updateCursorFlag;
	private.cursorRegion -> cursorRgn;
	(cursorRgn, -32768, -32768, 32766, 32766) -> SetRectRgn;
	private.event.where -> macPt;
	activeWindow -> theWindow[];
	(if theWindow[] <> None then
		theWindow.private.windowPointer -> SetPort;
		(0, 0) -> SetOrigin;
		0 -> windowPosition.h;
		0 -> windowPosition.v;
		windowPosition[] -> LocalToGlobal;
		windowPosition.h -> left;
		windowPosition.v -> top;
		macPt[] -> GlobalToLocal;
		theWindow.private.windowPointer + 24 -> TOS'%adrGetLong' -> visRgn;
		(macPt, visRgn) -> PtInRgn  -> result;
		(if result then
			macPt.getPoint -> theWindow.handleCursor -> handled;
			(if not handled then
				(visRgn, cursorRgn) -> CopyRgn;
				(cursorRgn, left, top) -> OffsetRgn;
				cursors.cross[] -> mouse.busyCursor;
			if);
		else
			(left, top) -> SetOrigin;
			(cursorRgn, visRgn, cursorRgn) -> DiffRgn;
			(0, 0) -> SetOrigin;
			cursors.arrow[] -> mouse.busyCursor;
		if);
	else
		cursors.arrow[] -> mouse.busyCursor;
	if);
#)

-- GUIENVterminateBody: doPart --
do true -> private.done;

-- GUIENVsetTheMenubar: doPart --
do theMenubar[] -> private.theMenuBar[];
	globalMacMenuBar -> theMenubar.changeMacMenubar;

-- GUIENVgetTheMenubar: doPart --
do private.theMenuBar[] -> theMenubar[]

-- GUIENVinterfaceObjectEvent: doPart -- 
do (if private.beforeActions[]<>None then
       private.beforeActions.scan
       (# 
       do (if (current.eventType## >= this(event)##) then
              this(event)[] -> current;
          if);
       #);
   if);
   inner event;
   (if private.afterActions[]<>None then
       private.afterActions.scan
       (# 
       do (if (current.eventType## >= this(event)##) then
              this(event)[] -> current;
          if);
       #);
   if);

-- GUIENVbasicEventShiftKey: doPart --	
do this(guienv).private.event.shiftKey -> value;

-- GUIENVbasicEventAltKey: doPart --
do this(guienv).private.event.optionKey -> value;

-- GUIENVbasicEventMetaKey: doPart --
do this(guienv).private.event.cmdKey -> value;

-- GUIENVbasicEventControlKey: doPart --
do this(guienv).private.event.controlKey -> value

-- GUIENVbasicEventButtonState: doPart --
do (if this(guienv).private.event.cmdKey then
		3 -> value;
	else
		(if this(guienv).private.event.optionKey then
			2 -> value;
		else
			1 -> value;
		if);
	if);

-- GUIENVbasicEventWhen: doPart --
do this(guienv).private.event.when -> value;

-- GUIENVbasicEventGlobalPosition: doPart --
do 
(#	macPt: @macPoint;
do this(guienv).private.event.where -> macPt;
	macPt.getPoint -> p;
#)

-- GUIENVbasicEventLocalPosition: doPart --
do currentLocalPosition -> p;

-- GUIENVmouseEventDoubleClick: doPart --
do doubleClickPossible -> value;

-- GUIENVkeyEventCh: doPart --
do this(guienv).private.event.charCode -> theChar;

-- GUIENVmouseDownDelay: doPart --
do	inner delay;



-- GUIENVinterfaceObjectPrependAction: doPart --
do assertOpen;
	(if private.beforeActions[]//none then
       &actionList[] -> private.beforeActions[];
   if);
   (if not (theAction[] -> private.beforeActions.member) then
       theAction[] -> private.beforeActions.prepend;
   if);

-- GUIENVinterfaceObjectAppendAction: doPart --
do assertOpen;
	(if private.afterActions[]//none then
       &actionList[] -> private.afterActions[];
   if);
   (if not (theAction[] -> private.afterActions.member) then
       theAction[] -> private.afterActions.append;
   if);

-- GUIENVinterfaceObjectDeleteAction: doPart --
do assertOpen;
   (if private.beforeActions[]<>none then
       theAction[] -> private.beforeActions.delete;
   if);
   (if private.afterActions[]<>none then
       theAction[] -> private.afterActions.delete;
   if);

-- GUIENVintefaceObjectCreate: doPart --
do inner create;

-- GUIENVinterfaceObjectOpen: doPart --
do (if not private.isOpen then
		true -> private.isOpen;
		create;
		inner open;
	if);

-- GUIENVinterfaceObjectClose: doPart --
do assertOpen;
	(if private.isOpen then
		inner close;
		false -> private.isOpen;
		NONE -> private.beforeActions[];
		NONE -> private.afterActions[];
	if);

-- GUIENVenableEventType: doPart --
do (* Not Implemented !!! *)

-- GUIENVdisableEventType: doPart --
do (* Not Implemented !!! *)


-- GUIENVinterfaceObjectException: doPart --
do (* Not Implemented !!! *)

-- GUIENVnotOpenedException: doPart --
do (* Not Implemented !!! *)

-- GUIENVseparatorSetStyle: doPart --
do assertOpen;
	(if value <> private.style then
		value -> private.style;
		theEventHandler.onStyleChanged;
		updateMaybe;
	if);
	
-- GUIENVseparatorGetStyle: doPart --
do assertOpen;
	private.style -> value;

-- GUIENVwindowseparatorCreate: doPart --
do inner create;

-- GUIENVwindowseparatorOpen: doPart --
do (if this(window).style = plain then
		separatorStyles.singleLine -> private.style;
	else
		separatorStyles.etchedIn -> private.style;
	if);
	initialLayout;
	inner open;
	
-- GUIENVwindowseparatorClose: doPart --
do inner close;
	0 -> private.style;

-- GUIENVwindowSeparatorOnRefresh: doPart --
do graphics
		(# width, height: @integer;
			from, to: @point;
			dx, dy: @integer;
		do 
			size -> (width, height);
			(if vertical then
				(width div 2, 0) -> from;
				(width div 2, height) -> to;
				1 -> dx;
				0 -> dy;
			else
				(0, height div 2) -> from;
				(width,  height div 2) -> to;
				0 -> dx;
				1 -> dy;
			if);
			(if this(separator).private.style
				//separatorStyles.singleLine then
					(from, to) -> drawLine;
	  			//separatorStyles.doubleLine then
					(-1 * dx,-1 * dy) -> from.add;
					(-1 * dx, -1  * dy) -> to.add;
					(from, to) -> drawLine;
					(2 * dx, 2  * dy) -> from.add;
					(2 * dx, 2  * dy) -> to.add;
					(from, to) -> drawLine;
				//separatorStyles.singleDashedLine then
					patterns.gray[] -> pen.stipple;
					(from, to) -> drawLine;
				//separatorStyles.doubleDashedLine then
					(-1 * dx,-1 * dy) -> from.add;
					(-1 * dx, -1  * dy) -> to.add;
					patterns.gray[] -> pen.stipple;
					(from, to) -> drawLine;
					(2 * dx, 2  * dy) -> from.add;
					(2 * dx, 2  * dy) -> to.add;
					(from, to) -> drawLine;
				//separatorStyles.etchedOut then
					this(guienv).private.white -> pen.foregroundColor;
					(from, to) -> drawLine;
					(1 * dx, 1  * dy) -> from.add;
					(1 * dx, 1  * dy) -> to.add;
					this(guienv).private.gray[7] -> pen.foregroundColor;
					(from, to) -> drawLine;
				//separatorStyles.etchedIn then
					this(guienv).private.gray[7]  -> pen.foregroundColor;
					(from, to) -> drawLine;
					(1 * dx, 1  * dy) -> from.add;
					(1 * dx, 1  * dy) -> to.add;
					this(guienv).private.white -> pen.foregroundColor;
					(from, to) -> drawLine;
			if);
		#);
	
	inner onRefresh;
	
-- GUIENVwindowseparatorPrivate: descriptor --
(# style: @integer;
#)

-- separatorLib: attributes --
initialLayout:
	(# width, height: @integer;
		left, top, right, bottom: @integer;
	do 
		father.size -> (width, height);
		(if vertical then
			width div 2 -> left;
			left + 3 -> right;
			((left, 0), (right, height)) -> privateWindowItemFrame;
			
		else
			height div 2 -> top;
			top + 3 -> bottom;
			((0, top), (width, bottom)) -> privateWindowItemFrame;
		if);
	#);
	



-- menubarLib: attributes --
adjust:
	(#
	do private.menus.scan
			(#
			do current.adjust;
			#);
	#);
changeMacMenubar:
	(# theMacMenubar: ^macMenubar;
	enter theMacMenubar[]
	do (if theMacMenubar[]<>private.theMacMenubar[] then
			(if theMacMenubar[] = none then
				scan
					(#
					do current[] -> private.theMacMenubar.delete;
					#);
			else
				scan
					(#
					do current[] -> theMacMenubar.append;
					#);
			if);
			theMacMenubar[] -> private.theMacMenubar[];
		if);
	#);

-- GUIENVmenubarAppend: doPart --
do assertOpen;
	(if not (theMenu[] -> private.menus.has) then
		theMenu[] -> private.menus.append;
		this(menubar)[] -> theMenu.owner;
		(if private.theMacMenuBar[]<>none then
			theMenu[] -> private.theMacMenuBar.append;
		if);
	if);

-- GUIENVmenubarDelete: doPart --
do	assertOpen;
	(if theMenu[] -> private.menus.has then
		theMenu[] -> private.menus.remove;
		none -> theMenu.owner;
		(if private.theMacMenuBar[]<>none then
			theMenu[] -> private.theMacMenuBar.delete;
		if);
	if);

-- GUIENVmenubarClear: doPart --
do	assertOpen;
	scan
		(#
		do current[] -> delete;
		#);

-- GUIENVmenubarAppendMenubar: doPart --
do	(* not implemented *)

-- GUIENVmenubarReplaceMenubar: doPart --
do 	(* not implemented *)

-- GUIENVmenubarDeleteMenubar: doPart --
do 	(* not implemented *)

-- GUIENVmenubarScan: doPart --
do	assertOpen;
	private.menus.scan
		(#
		do current[] -> this(scan).current[];
			inner scan;
		#);

-- GUIENVmenubarCreate: doPart --
do inner create;

-- GUIENVmenubarOpen: doPart --
do inner open;

-- GUIENVmenubarClose: doPart --
do inner close;
	private.menus.clear;
	NONE -> private.theMacMenubar[];

-- GUIENVmenubarPrivate: descriptor --
(# menus: @list
		(# element::< menu;
			findByID:
				(# ID: @integer;
					e: ^element;
				enter ID
				do	l: scan
						(#
						do (if current.private.menuID//ID then
								current[] -> e[];
							if);
						#);
				exit e[]
				#);
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
		#);
	theMacMenubar: ^macMenuBar;
#)

-- GUIENVmenuSetName: doPart --
do assertOpen;
	theName -> private.name;
	destroyMenu;
	buildMenu;

-- GUIENVmenuGetName: doPart --
do assertOpen;
	private.name.copy -> theName[];

-- menuitemLib: attributes --
adjust:
	(#
	do	(if theEventHandler.onStatus then
			enable;
		else
			disable;
		if);
	#);
enable:
	(#
	do (this(menu).private.handle,private.number) -> EnableItem;
	#);
disable:
	(#
	do (this(menu).private.handle,private.number) -> DisableItem;
	#);
updateAll:
	(#
	do updateName;
		updateKey;
		updateMark;
		updateFace;
		updateChecked;
		updateSubMenu;
	#);
updateName:
	(#
	do (if private.name.empty then
			(handle,private.number,' ') -> SetMenuItemText;
		else
			(handle,private.number,private.name) -> SetMenuItemText;
		if);
	#);
updateKey:
	(#
	do (handle,private.number,private.key) -> SetItemCmd;
	#);
updateMark:
	(#
	do (if private.mark<>0 then
			(handle,private.number,private.mark) -> SetItemMark;
		if);
	#);
updateFace:
	(#
	do (handle,private.number,private.face) -> SetItemStyle;
	#);
updateChecked:
	(#
	do (handle,private.number,private.checked) -> CheckItem;
	#);
updateSubMenu:
	(# 
	do (if private.submenu[]//none then
			 (handle,private.number,private.mark) -> SetItemMark;
			 (handle,private.number,private.key) -> SetItemCmd; 
		else
			(handle,private.number,private.subMenu.menuID) -> SetItemMark;
			(handle,private.number,27) -> SetItemCmd;
		if);
	#);
buildItem:
	(#
	do (if menuitemIsSeparator then
			(this(menu).private.handle,'(-') -> AppendMenu;
		else
			(this(menu).private.handle,'...') -> AppendMenu;
			updateAll;
		if);
	#);

-- GUIENVmenuitemSetKey: doPart --
do assertOpen;
	c -> private.key;
	(if private.number<>0 then
		updateKey;
	if);

-- GUIENVmenuitemGetKey: doPart --
do assertOpen;
	private.key -> c;

-- GUIENVmenuitemSetName: doPart --
do assertOpen;
	t -> private.name;
	(if private.number<>0 then
		updateName;
	if);

-- GUIENVmenuitemGetName: doPart --
do assertOpen;
	private.name.copy -> t[];

-- GUIENVmenuitemSetChecked: doPart --
do assertOpen;
	checked -> private.checked;
	(if private.number<>0 then
		updateChecked;
	if);

-- GUIENVmenuitemGetChecked: doPart --
do assertOpen;
	private.checked -> checked;

-- GUIENVsetSubMenu: doPart --
do assertOpen;
	(if private.subMenu[]<>none then
		private.subMenu.menuID -> DeleteMenu;
		none -> private.subMenu[];
	if);
	theMenu[] -> private.subMenu[];
	(if private.subMenu[]<>none then
		(private.subMenu.handle,-1) -> InsertMenu;
	if);
	(if private.number<>0 then
		updateSubMenu;
	if);

-- GUIENVgetSubMenu: doPart --
do assertOpen;
	private.subMenu[] -> theMenu[];

-- GUIENVmenuitemPosition: doPart --
do assertOpen;
	private.number -> value;


-- GUIENVmenuitemOnStatus: doPart --
do true -> value;
	inner onStatus;

-- GUIENVmenuitemCreate: doPart --
do inner create;

-- GUIENVmenuitemOpen: doPart --
do inner open;

-- GUIENVmenuitemAttach: doPart --
do assertOpen;
	(if theAction[]<>none then
		none -> theAction.theMenuitem[];
	if);
	anAction[] -> theAction[];
	(if theAction[]<>none then
		this(dynamicMenuitem)[] -> theAction.theMenuitem[];
	if);

-- GUIENVmenuitemDetach: doPart --
do	assertOpen;
	none -> attach;

-- GUIENVdynamicMenuitemOnStatus: doPart --
do	(if theAction[] = NONE then
		false -> value;
	else
		theAction.onStatus -> value;
	if);

-- GUIENVdynamicMenuitemOnSelect: doPart --
do (if theAction[] = NONE then
	else
		theAction.onSelect;
	if);

-- GUIENVactionOnStatus: doPart --
do	true -> value;
	inner onStatus;

-- GUIENVseparatorCreate: doPart --
do	inner create;

-- GUIENVseparatorOpen: doPart --
do	true -> menuitemIsSeparator;
	inner open;

-- GUIENVseparatorClose: doPart --
do	false -> menuitemIsSeparator;
	inner close;

-- menuLib: attributes --
adjust:
	(#
	do theEventHandler.onSelect;
		private.menuitems.scan
			(#
			do current.adjust;
			#);
	#);
itemSelected:
	(# itemNumber: @integer;
		theItem: ^menuitem;
	enter itemNumber
	do itemNumber -> private.menuitems.findByNumber -> theItem[];
		(if theItem[]<>none then
			theItem.theEventHandler.onSelect;
		else
			debug
				(#
				do 'Did not find the item' -> putLine;
				#);
		if);
	#);
buildMenu:
	(# theMenubar: ^menuBar;
	do	(if private.handle//0 then
			(private.menuID,private.name) -> NewMenu -> private.handle;
			private.menuItems.scan
				(#
				do current.buildItem;
				#);
			owner -> theMenubar[];
			(if theMenubar[]<>none then
				(if theMenubar.private.theMacMenubar[]<>none then
					this(menu)[] -> theMenubar.private.theMacMenubar.append;
				if);
			if);
		if);
	#);
destroyMenu:
	(# theMenubar: ^menuBar;
	do (if private.handle//0 then
		else
			owner -> theMenubar[];
			(if theMenubar[]<>none then
				(if theMenubar.private.theMacMenubar[]<>none then
					this(menu)[] -> theMenubar.private.theMacMenubar.delete;
				if);
			if);
			private.handle -> DisposeMenu;
			0 -> private.handle;
		if);
	#);
-- GUIENVmenuAppend: doPart --
do assertOpen;
	(if not (theMenuitem[] -> private.menuitems.has) then
		theMenuitem[] -> private.menuitems.append;
		private.menuitems.size -> theMenuitem.private.number;
		(if theMenuitem.menuitemIsSeparator then
			(private.handle,'(-') -> AppendMenu;
		else
			(private.handle,'...') -> AppendMenu;
			theMenuitem.updateAll;
		if);
	if);

-- GUIENVmenuDelete: doPart --
do
(# 
	pos: ^private.menuitems.theCellType;
do assertOpen;
	(if theMenuitem[] -> private.menuitems.has then
		(handle,theMenuitem.number) -> DeleteMenuItem;
		theMenuitem[] -> private.menuitems.at -> pos[];
		pos[] -> private.menuitems.iterateFrom
			(#
			do current.elm.number - 1 -> current.elm.number;
			#);
		pos[] -> private.menuitems.delete;
	if);
#)

-- GUIENVmenuScan: doPart --
do assertOpen;
	private.menuItems.scan
		(#
		do current[] -> this(scan).current[];
			inner scan;
		#);

-- GUIENVmenuClear: doPart --
do assertOpen;
	scan
		(#
		do current[] -> delete;
		#);

-- GUIENVmenuNoOfMenuitems: doPart --
do	assertOpen;
	private.menuitems.size -> value;

-- GUIENVmenuPopUp: doPart --
do
(# 
	result: @longInt;
	p: @point;
do	assertOpen;
	popupAt -> popupIn.toScreenCoordinates -> p;
	adjust;
	(handle, -1) -> InsertMenu;
	(handle,p.v,p.h,popupWith) -> PopUpMenuSelect -> result;
	(if result.hiWord<>0 then
		(result.hiWord,result.loWord) -> processMenuSelect;
	if);
	menuID -> DeleteMenu;
#)

-- GUIENVmenuGetMenuitemByNumber: doPart --
do assertOpen;
	number -> private.menuitems.findByNumber -> theMenuitem[];

-- GUIENVmenuEnable: doPart --
do	assertOpen;
	(handle,0) -> EnableItem;
	true -> menuEnabled;

-- GUIENVmenuDisable: doPart --
do assertOpen;
	(handle,0) -> DisableItem;
	false -> menuEnabled;

-- GUIENVmenuEnabled: doPart --
do assertOpen;
	menuEnabled -> value;


-- GUIENVmenuCreate: doPart --
do inner create;

-- GUIENVmenuOpen: doPart --
do
(# t: ^text;
do this(Menu)[] -> getPatternName -> t[];
	t -> private.name;
	(lastMenuID + 1) -> lastMenuID;
	(lastMenuID,private.name) -> NewMenu -> private.handle;
	lastMenuID -> private.menuID;
	this(menu)[] -> this(guienv).private.menus.append;
	inner open;
#)

-- GUIENVmenuClose: doPart --
do inner close;
	
	this(menu)[] -> this(guienv).private.menus.remove;
	menuID -> DeleteMenu;
	handle -> DisposeMenu;
	0 -> handle;
	0 -> menuID;
	false -> private.menuEnabled;
	private.name.clear;
	private.menuitems.clear;
	NONE -> private.owner[];


-- GUIENVstandardFileMenuOpen: doPart --
do newMenuitem.open;
	'New' -> newMenuitem.name;
	newMenuitem[] -> append;
	
	openMenuitem;
	'Open...' -> openMenuitem.name;
	openMenuitem[] -> append;
	
	closeMenuitem;
	'Close' -> closeMenuitem.name;
	closeMenuitem[] -> append;
	
	saveMenuitem;
	'Save' -> saveMenuitem.name;
	saveMenuitem[] -> append;
	
	saveAsMenuitem;
	'Save as...' -> saveAsMenuitem.name;
	saveAsMenuitem[] -> append;
	
	revertMenuitem;
	'Revert' -> revertMenuitem.name;
	revertMenuitem[] -> append;
	
	printMenuitem;
	'Print...' -> printMenuitem.name;
	printMenuitem[] -> append;
	
	pageSetUpMenuitem;
	'Page setup' -> pageSetUpMenuitem.name;
	pageSetUpMenuitem[] -> append;
	
	quitMenuitem;
	'Quit' -> quitMenuitem.name;
	quitMenuitem[] -> append;
	inner open;

-- GUIENVstandardEditMenuOpen: doPart --
do undoMenuitem.open;
	'Undo' -> undoMenuitem.name;
	undoMenuitem[] -> append;
	
	cutMenuitem.open;
	'Cut' -> cutMenuitem.name;
	cutMenuitem[] -> append;
	
	copyMenuitem.open;
	'Copy' -> copyMenuitem.name;
	copyMenuitem[] -> append;
	
	pasteMenuitem.open;
	'Paste' -> pasteMenuitem.name;
	pasteMenuitem[] -> append;
	
	clearMenuitem.open;
	'Clear' -> clearMenuitem.name;
	clearMenuitem[] -> append;
	inner open;

-- GUIENVwindowGetContents: doPart --
do assertOpen;
	windowContents -> theContents[]; 




-- GUIENVstandardMenubarOpen: doPart --
do &fileMenu[] -> theFileMenu[];
	(if theFileMenu##<= menu## then
		theFileMenu.open;
		theFileMenu[] -> append;
	else
		none -> theFileMenu[];
	if);
	&editMenu[] -> theeditMenu[];
	(if theeditMenu##<= menu## then
		theeditMenu.open;
		theeditMenu[] -> append;
	else
		none -> theeditMenu[];
	if);
	inner open;

-- windowLib: attributes --


	
DialogKind: (# exit 2 #);
NormalKind: (# exit 8 #);
ApplicationFloaterKind: (# exit 7 #);
	
	
GetRegionBounds:
	(# rgn: @integer;
		bounds: @rectangle;
	enter rgn
	do (# rgnRec: @regionRecord;
			rgnBBox: @rgnRec.rgnBBox;
		do rgn -> HLock;
			rgn -> rgnRec.initFromHandle;
			rgnBBox.left -> bounds.left;
			rgnBBox.top -> bounds.top;
			rgnBBox.right -> bounds.right;
			rgnBBox.bottom -> bounds.bottom;
			rgn -> HUnLock;
		#);
	exit bounds
	#);
processMouseDown:
	(# partCode: @integer;
		handleTheEvent: @boolean;
		
		screenBounds: @macRect;
	enter partCode
	do (if this(window)[] = activeWindow then
			true -> handleTheEvent;
		else
			(modalState = modeless) -> handleTheEvent;
		if);				
		(if handleTheEvent then
			(if partCode
				//inContent then
					(if this(window)[]//activeWindow then
						processContentClick;
					else
						private.windowPointer -> SelectTheWindow;
						false -> sendOnMouseUp;
						NONE -> lastClickedObject;
					if);
				//inDrag then
					GetGrayRgn -> GetRegionBounds -> screenBounds;
					(private.windowPointer, this(guienv).private.event.where, screenBounds[]) -> DragTheWindow;
					false -> sendOnMouseUp;
					NONE -> lastClickedObject;
				//inGrow then
					false -> sendOnMouseUp;
					NONE -> lastClickedObject;
					(if resizeable then
						processResize;
					if);
				//inGoAway then
					processGoAway;
					false -> sendOnMouseUp;
					NONE -> lastClickedObject;
				//inZoomIn//inZoomOut then
					partCode -> processZoom;
					false -> sendOnMouseUp;
					NONE -> lastClickedObject;
			if);
		else
			false -> sendOnMouseUp;
			NONE -> lastClickedObject;
			30 -> SysBeep;
		if);
	#);
processKeyDown:
	(# key: @char;
		defaultButton: ^windowItem;
	enter key
	do windowDefaultButton -> defaultButton[];
		(if defaultButton[]<>None then
			(if key//13//3 then
				true -> defaultButton.hilite;
				10 -> system.wait;
				false -> defaultButton.hilite;
				defaultButton.theEventHandler.onMouseUp;
			if);
		if);
		(if windowTarget<>none then
			private.windowTarget.theEventhandler.onKeyDown;
		else
			theEventHandler.onKeyDown;
		if);
	#);
processActivate:
	(#	doActivate: @boolean;
	enter doActivate
	do (if doActivate<>windowActive then
			doActivate -> windowActive;
			(if doActivate then
				theEventHandler.onActivate;
				(if windowTarget<>none then
					private.windowTarget.theEventHandler.onEnableTarget;
				if);
			else
				theEventHandler.onDeactivate;
				(if windowTarget<>none then
					private.windowTarget.theEventHandler.onDisableTarget;
				if);
			if);
			(if resizeable then
				invalidateGrowIcon;
			if);
		if);
		handleCursor;
	#);
processUpdate:
	(#	
	do private.windowPointer -> BeginUpdate;
		private.windowContents.theEventHandler.onRefresh;
		theEventHandler.onRefresh;
		ResetPen;
		drawDefaultButton;
		ResetPen;
		(if resizeable then
			drawGrow;
		if);
		private.windowPointer -> EndUpdate;
	#);
erasePortRect:
	(# 
	do private.windowContents.setupPortWideClip
			(# port: @grafPortRecord;
				mr: @macRect;
				a,b,c,d: @integer;
			do private.windowPointer -> port.ptr;
				port.portRectangle -> ((a,b),(c,d));
				(a, b, c, d) -> EraseRectangle;
			#);
	#);
processContentClick:
	(# macPt: @macPoint;
		GlobalToLocal: External (# p: ^macPoint enter p[] do '$A871' -> PascalTrap; #);
	do 
		this(guienv).private.event.where -> macPt;
		private.windowPointer -> SetPort;
		(0,0) -> SetOrigin;
		macPt[] -> GlobalToLocal;
		macPt.getPoint -> private.windowContents.processMouseDown;
	#);
processResize:
	(# 
		limit: @macRect;
		result: @macPoint;
		width,height: @integer;
	do	
		(theMinSize,theMaxSize) -> limit;
		(private.windowPointer,this(guienv).private.event.where,limit[]) -> GrowWindow -> result;
		result.getPoint -> (width,height);
		(if (width<>0) or (height<>0) then
			(width,height) -> size;
		if);
	#);
processGoAway:
	(#
		result: @boolean;
	do 
		(private.windowPointer,this(guienv).private.event.where) -> TrackGoAway -> result;
		(if result then
			(if theEventHandler.onAboutToClose then
				close;
			if);
		if);
	#);
processZoom:
	(# partCode: @integer;
		result: @boolean;
	enter partCode
	do 
		(private.windowPointer,this(guienv).private.event.where,partCode) -> TrackBox -> result;
		(if result then
			partCode ->	zoom;
		if);
	#);
zoom:
	(# partCode: @integer;
		r: @rectangle;
	enter partCode
	do erasePortRect;
		private.windowPointer -> SetPort;
		(private.windowPointer,partCode,false) -> ZoomWindow;
		getBounds -> r;
		r.size -> size;
	#);
getBounds:
	(#  LocalToGlobal: External (# p: ^macPoint enter p[] do '$A870' -> PascalTrap; #);
		port: @grafportRecord;
		r: @rectangle;
		left,top,right,bottom: @integer;
		translate:
			(#	pt: @point;
				macPt: @macPoint;
			enter pt
			do pt -> macPt.setPoint;
				macPt[] -> LocalToGlobal;
				macPt.getPoint -> pt;
			exit pt
			#);
	do private.windowPointer -> SetPort;
		(0,0) -> SetOrigin;
		private.windowPointer -> port.ptr;
		port.portRectangle -> ((left,top),(right,bottom));
		(left,top) -> translate -> r.topLeft;
		(right,bottom) -> translate -> r.bottomRight;
	exit r
	#);
getGrowIconBounds:
	(# bounds: @rectangle;
	do size -> bounds.bottomRight;
		bounds.bottom - 15 -> bounds.top;
		bounds.right - 15 -> bounds.left;
	exit bounds
	#);
drawGrow:
	(# mr: @macRect;
	do (if menubarVisible then
			private.windowPointer -> SetPort;
			getGrowIconBounds -> mr;
			mr[] -> ClipRect;
			(0,0) -> SetOrigin;
			ResetPen;
			private.windowPointer -> DrawGrowIcon;
		if);
	#);
drawDefaultButton:
	(#	theButton: ^windowItem;
		r: @rectangle;
	do windowDefaultButton -> theButton[];
		(if theButton[]<>None then
			theButton.frame -> r;
			(if this(window).style = plain then
				theButton.father.graphics
					(#
					do (-4,-4) -> r.inset;
						3 -> pen.size;
						(r, ((0, 0), (16,16))) -> drawRoundRect;
					#);
				else
					theButton.father.graphics
					(#
					do (-3,-3) -> r.inset;
						2 -> pen.size;
						(r, ((0, 0), (4,4))) -> drawRoundRect;
					#);
					(* (-4, -4) -> r.inset;
					(r, borderStyles.shadowIn) -> theButton.father.drawBorder; *)
			if);
		if);
	#);
invalidateGrowIcon:
	(# mr: @macRect;
	do private.windowPointer -> SetPort;
		getGrowIconBounds -> mr;
		(0,0) -> SetOrigin;
		mr[] -> InvalRect;
	#);
handleCursor: booleanValue
	(# pt: @point;
		ObjectClicked: ^windowItem;
		left, right: @integer;
	enter pt
	do pt -> private.windowContents.findObjectClicked -> ObjectClicked[];
		pt -> ObjectClicked.handleCursor;
		true -> value;
	#);
-- GUIENVupdateRect: doPart --
do (# rgnTop: (# exit 2 #);
		rgnLeft: (# exit 4 #);
		rgnBottom: (# exit 6 #);
		rgnRight: (# exit 8 #);
		
		visibleRgn: @integer;
		address: @integer;
		(* theWindowItem: ^window.windowItem; *)
	do (* this(interfaceObject)[] -> theWindowItem[]; *)
		&rectangle[] -> value[];
		
		this(GUIenv).private.wideRgn -> visibleRgn;
		visibleRgn -> TOS'%adrGetLong' -> address;
		address + rgnLeft -> TOS'%adrGetSignedShort' -> value.left;
		address + rgnTop -> TOS'%adrGetSignedShort' -> value.top;
		address + rgnRight -> TOS'%adrGetSignedShort' -> value.right;
		address + rgnBottom -> TOS'%adrGetSignedShort' -> value.bottom;
   #);

-- guienvQuit: doPart --
do true -> okToQuit;
	INNER;
   (if okToQuit then
       Terminate;
   if);
	
-- guienvFitToContents: doPart --
do (# style: ^textStyle;
		theButton: ^button;
		preferredWidth, preferredHeight: @integer;
	do (if true 
			//this(windowItem)## <= staticText## then
				this(windowItem)[] -> theButton[];
				theButton.style -> style[];
				theButton.label -> style.widthOftext -> preferredWidth;
				preferredWidth + 1 -> preferredWidth;
				style.lineHeight -> preferredHeight;
			//this(windowItem)## <= optionButton## then
				(200, 22) -> (preferredWidth, preferredHeight);
			//this(windowItem)## <= pushButton## then
				this(windowItem)[] -> theButton[];
				theButton.style -> style[];
				theButton.label -> style.widthOftext -> preferredWidth;
				preferredWidth + 12 -> preferredWidth;
				(style.lineHeight + 6, 20) -> Max -> preferredHeight;
			//this(windowItem)## <= toggleButton## then
				this(windowItem)[] -> theButton[];
				theButton.style -> style[];
				theButton.label -> style.widthOftext -> preferredWidth;
				preferredWidth + 20 -> preferredWidth;
				(style.lineHeight + 2, 16) -> Max -> preferredHeight;
		else
			size -> (preferredWidth, preferredHeight);
		if);
		(preferredWidth, preferredHeight) -> size;
	#)
	
-- windowEnterVisible: doPart --
do assertOpen;
	(if value <> private.windowVisible then
		(if value then
			show;
		else
			hide;
		if);
	if);
-- windowExitVisible: doPart --
do assertOpen;
	private.windowVisible -> value;
