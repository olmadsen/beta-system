ORIGIN '../graphicsbody';

INCLUDE 'guienv_macprivate';
INCLUDE '~beta/maclib/quickdraw';
INCLUDE '~beta/maclib/icons';

INCLUDE 'pixmapbody';

-- graphicsLib: attributes --

setupPortForGraphics: setupPortForDrawing
  (# 
  do private.savedPenState[] -> GetPenState;
     private.savedForeColor[] -> GetForeColor;
	  private.savedBackColor[] -> GetBackColor;
     ResetPen;
	  this(windowItem).private.background -> pen.backGroundColor;
     INNER;
	  private.savedPenState[] -> SetPenState;
	  private.savedForeColor[] -> RGBForeColor;
	  private.savedBackColor[] -> RGBBackColor;
  #);

makeMacColor:
  (# theColor: ^RGBColor;
     red, green, blue: @integer;
  enter	 (red, green, blue)
  do &RGBColor[] -> theColor[];
     red -> theColor.red;
     green -> theColor.green;
     blue -> theColor.blue;
  exit theColor[]
  #);

-- GUIENVgraphicsPenSize: descriptor --
(#
do value -> private.width;
	(value,value) -> PenSize;
#)

-- GUIENVgraphicsPenForegroundColor: descriptor --
(#
do theColor -> makeMacColor -> RGBForeColor
#)

-- GUIENVgraphicsPenBackgroundColor: descriptor --
(#
do theColor -> makeMacColor -> RGBBackColor
#)

-- GUIENVgraphicsPenStipple: descriptor --
(# 
do	(if b.private.patAddress <> 0 then
		b.private.patAddress -> PenPat;
	if);
#)

-- GUIENVgraphicsPenMode: descriptor --
(# qdMode: @integer;
do (if m
    //transferModes.copy then srcCopy -> qdMode;
    //transferModes.invertCopy then notSrcCopy -> qdMode;
    //transferModes.erase then srcBic -> qdMode;
    //transferModes.andBlend then 0 -> qdMode;
    //transferModes.orBlend then srcOr -> qdMode;
    //transferModes.xorBlend then srcXor -> qdMode;
    //transferModes.notAndBlend then 0 -> qdMode;
    //transferModes.notOrBlend then notSrcOr -> qdMode;
   if);
   qdMode -> PenMode;
#)

-- GUIENVgraphicsStyle: descriptor --
(#
do	theTextStyle.familyID -> TextFont;
   theTextStyle.size -> TextSize;
   theTextStyle.face -> TextFace;
#)

-- GUIENVgraphicsMove: descriptor --

(# Move: External (# dh,dv: @ShortInt; enter (dh,dv) do '$A894' -> PascalTrap; #);
do	(p.h,p.v) -> Move;
#)

-- GUIENVgraphicsMoveTo: descriptor --

(# MoveTo: External (# h,v: @ShortInt; enter (h,v) do '$A893' -> PascalTrap; #);
do (p.h,p.v) -> MoveTo;
#)

-- GUIENVgraphicsDraw: descriptor --
(# Line: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A892'->PascalTrap;  #);
do	(p.h,p.v) -> Line;
#)

-- GUIENVgraphicsDrawTo: descriptor --

(#
do (p.h,p.v) -> LineTo;
#)

-- GUIENVgraphicsDrawSpot: descriptor --

(#
do	(1,1) -> PenSize;
	(p.h,p.v) -> MoveTo;
   (p.h,p.v) -> LineTo;
	(private.width, private.width) -> PenSize;
#)

-- GUIENVgraphicsDrawLine: descriptor --
(#
do	(p1.h, p1.v) -> MoveTo;
   (p2.h,p2.v) -> LineTo;
#)

-- GUIENVgraphicsDrawText: descriptor --

(# 
do t[] -> DrawBetaText;
#)

-- GUIENVgraphicsDrawPolygon: descriptor --

(# macPoly: @integer;
do	points -> makeMacPoly -> macPoly;
   macPoly -> FramePoly;
   macPoly -> KillPoly;
#)

-- GUIENVgraphicsDrawRect: descriptor --
(# do (r[] -> makeMacRect).r[] -> FrameRect; #)

-- GUIENVgraphicsDrawRoundRect: descriptor --

(#	mr: ^macRect;
   width,height: @integer;
do r[] -> makeMacRect -> mr[];
   roundNess.size -> (width,height);
   (mr.r[],width,height) -> FrameRoundRect;
#)

-- GUIENVgraphicsDrawOval: descriptor --
(# do (r[] -> makeMacRect).r[] -> FrameOval; #)

-- GUIENVgraphicsDrawSlice: descriptor --
(# mr: ^macRect;
do r[] -> makeMacRect -> mr[];
   (mr.r[],fromAngle,toAngle) -> FrameArc;
#)

-- GUIENVgraphicsFillPolygon: descriptor --
(# macPoly: @integer;
do	points -> makeMacPoly -> macPoly;
   macPoly -> PaintPoly;
   macPoly -> KillPoly;
#)

-- GUIENVgraphicsFillRect: descriptor --
(# do (r[] -> makeMacRect).r[] -> PaintRect; #)


-- GUIENVgraphicsFillRoundRect: descriptor --
(#	mr: ^macRect;
   width,height: @integer;
do r[] -> makeMacRect -> mr[];
   roundNess.size -> (width,height);
   (mr.r[],width,height) -> PaintRoundRect;
#)

-- GUIENVgraphicsFillOval: descriptor --
(#	mr: ^macRect;
do (r[] -> makeMacRect).r[] -> PaintOval;
#)

-- GUIENVgraphicsFillSlice: descriptor --
(# mr: ^macRect;
do r[] -> makeMacRect -> mr[];
   (mr.r[],fromAngle,toAngle) -> PaintArc;
#)

-- GUIENVgraphicsDrawRaster: descriptor --
(# srcMcRect, dstMcRect: ^macRect;
	srcRect, dstRect: @rectangle;
	gworld: @integer;
	wp: @integer;
	fore, back: @RGBColor;
	
	pixmap: @int32;
	good: @boolean;
do 
	from -> srcRect.topLeft;
	(width, height) -> srcRect.size;
	to -> dstRect.topLeft;
	(width, height) -> dstRect.size;
	srcRect[] -> makeMacRect -> srcMcRect[];
	dstRect[] -> makeMacRect -> dstMcRect[];
	p.private.gworld -> gworld;
	(if gworld <> 0 then
		this(window).private.windowPointer -> wp;
		(if wp <> 0 then
			fore[] -> GetForeColor;
			back[] -> GetBackColor;
			blackColor -> foreColor;
			whiteColor -> backColor;
			gworld -> GetGWorldPixMap -> pixmap;
			pixmap -> LockPixels -> good;
			(if good then
				(if p.private.maskrgn <> 0 then
					(p.private.maskrgn, to.h, to.v) -> OffsetRgn;
				if);
				(gworld + 2, wp + 2, srcMcRect.r[], dstMcRect.r[], srcCopy, p.private.maskrgn) -> CopyBits;
				(if p.private.maskrgn <> 0 then
					(p.private.maskrgn, -to.h, -to.v) -> OffsetRgn;
				if);
				pixmap -> UnLockPixels;
			if);
			fore[] -> RGBForeColor;
			back[] -> RGBBackColor;
		if);
	if);
#)

-- GUIENVgraphicsPrivate: descriptor --
(# width: @integer;
	coloredCopyBits: @boolean;
	savedPenState: @PenState;
	savedForeColor: @RGBColor;
	savedBackColor: @RGBColor;
#)

-- GUIENVgraphicsBody: descriptor --
(#
do assertOpen;
	1 -> private.width;
	FALSE -> private.coloredCopyBits;
	(if THIS(windowItem).private.isFigureItem then
		(if father[] <> NONE then
			(FALSE, THIS(windowItem).private.originX, THIS(windowItem).private.originY) -> father.setupPortForDrawingAt
				(#
				do INNER graphics;
				#);
		if);
	else
		overrideChildren -> setupPortForGraphics
			(#
			do INNER graphics;
			#);
	if);
#)

-- GUIENVgraphicsDrawSpots: doPart --
do (for inx: points.range repeat 
        points[inx] -> drawSpot;
   for);

