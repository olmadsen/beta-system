ORIGIN 'guienv_macbody';
INCLUDE '~beta/maclib/v3.0/scrap';

-- GUIENVwindowUseTextStyle: descriptor --
(#
do assertOpen;
	private.windowPointer -> SetPort;
	style.familyID -> TextFont;
	style.textStyleSize -> TextSize;
	style.textStyleFace -> TextFace;
#)

-- GUIENVwindowOnActivate: descriptor --
(# theMenubar: ^menubar;
do windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		globalMacMenubar -> theMenubar.changeMacMenubar;
	if);
	private.windowContents.theEventHandler.onActivate;
	inner onActivate;
#)

-- GUIENVwindowOnDeactivate: descriptor --
(# theMenubar: ^menubar;
do 
	inner onDeactivate;
	private.windowContents.theEventHandler.onDeactivate;
	windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		none -> theMenubar.changeMacMenubar;
	if);
#)

-- GUIENVwindowSetTheMenubar: descriptor --
(#
do assertOpen;
	theBar.assertOpen;
	theBar[] -> windowMenuBar;
#)

-- GUIENVwindowGetTheMenubar: descriptor --
(#
do assertOpen;
	windowMenuBar -> theBar[];
#)

-- GUIENVwindowSetFloating: descriptor --
(#
do (* Not implemented !!! *)
#)

-- GUIENVwindowGetFloating: descriptor --
(#
do (* Not implemented !!! *)
#)

-- GUIENVwindowSetTitle: descriptor --
(#
do assertOpen;
	(private.windowPointer,theTitle) -> SetWTitle;
#)

-- GUIENVwindowGetTitle: descriptor --
(# ps: @pascalString;
do assertOpen;
	(private.windowPointer,ps[]) -> GetWTitle;
	ps.getText -> theTitle[];
#)

-- GUIENVwindowSetPosition: descriptor --
(#
do assertOpen;
	(private.windowPointer,pt.h,pt.v,false) -> MoveWindow;
	handleCursor;
#)

-- GUIENVwindowGetPosition: descriptor --
(# r: @rectangle;
do assertOpen;
	getBounds -> r;
	r.topLeft -> pt;
#)

-- GUIENVwindowSetSize: descriptor --
(#
do assertOpen;
	invalidateGrowIcon;
	(private.windowPointer,width,height,false) -> SizeWindow;
	(width,height) -> private.windowContents.size;
	invalidateGrowIcon;
	updateCursor;
#)

-- GUIENVwindowGetSize: descriptor --
(# r: @rectangle;
do assertOpen;
	getBounds -> r;
	r.size -> (width,height);
#)

-- GUIENVwindowSetFrame: descriptor --
(#
do assertOpen;	
	theFrame.topLeft -> position;
	theFrame.size -> size;
#)

-- GUIENVwindowGetFrame: descriptor --
(#
do assertOpen;
	getBounds -> theFrame;
#)

-- GUIENVwindowInsideRectangle: descriptor --
(#
do assertOpen;
	(0,0) -> theRectangle.topLeft;
	size -> theRectangle.size;
#)

-- GUIENVshowWindow: descriptor --
(#
do assertOpen;
	private.windowPointer -> ShowTheWindow;
	bringToFront;
	true -> windowVisible;
#)

-- GUIENVwindowShowModal: descriptor --
(# doProcessOneEvent: @processOneEvent;
do assertOpen;
	systemModal -> modalState;
	show;
	loop:
		(if modalState<>modeless then
			doProcessOneEvent;
			restart loop;
		if);
#)

-- GUIENVhideWindow: descriptor --
(#
do assertOpen;
	private.windowPointer -> HideTheWindow;
	modeless -> modalState;
	false -> windowVisible;
	false -> private.doShow;
#)

-- GUIENVwindowSetMaxSize: descriptor --
(#
do assertOpen;
	(width,height) -> theMaxSize;
#)

-- GUIENVwindowGetMaxSize: descriptor --
(#
do assertOpen;
	theMaxSize -> (width,height);
#)

-- GUIENVwindowSetMinSize: descriptor --
(#
do assertOpen;
	(width,height) -> theMinSize;
#)

-- GUIENVwindowGetMinSize: descriptor --
(#
do assertOpen;
	theMinSize -> (width,height)
#)

-- GUIENVwindowBringToFront: descriptor --
(# BringToFront: External (# theWindow: @Integer; enter theWindow do '$A920' -> PascalTrap; #);
do assertOpen;
	private.windowPointer -> SelectWindow;
#)

-- GUIENVwindowBringToBack: descriptor --
(#
do assertOpen;
	(private.windowPointer,0) -> SendBehind;
#)

-- GUIENVwindowBringBehind: descriptor --
(#
do assertOpen;
	(private.windowPointer,theWindow.private.windowPointer) -> SendBehind;
#)

-- GUIENVwindowUpdate: descriptor --
(#
do assertOpen;
	processUpdate;
#)

-- GUIENVwindowCreate: descriptor --
(# bounds: @macRect;
	MovableDBoxProc: (# exit 5 #);
	rFloatingWindowProc: (# exit 124 #);
	macType: @integer;
do shadows -> style;
	(if menubarVisible then
		normal -> private.type;
	else
		dialog -> private.type;
	if);
	inner create;
	(if private.type
		//normal then
			ZoomDocProc -> macType;
		//dialog then
			DBoxProc -> macType;
		//utility then
			rFloatingWindowProc * 16 -> macType;
	if);
	(if private.windowPointer = 0 then
		((40,40),(340,240)) -> bounds;
		(0,bounds[],'Title',false,macType, -1, true, 0) -> NewCWindow -> private.windowPointer;
		(private.windowPointer, 56797, 56797, 56797) -> SetWindowBackground;
		
		(if private.type
			//normal then
				(private.windowPointer, NormalKind) -> SetTheWindowKind;
			//dialog then
				(private.windowPointer, DialogKind) -> SetTheWindowKind;
			//utility then
				(private.windowPointer, ApplicationFloaterKind) -> SetTheWindowKind;
		if);
	if);
#)

-- GUIENVwindowOpen: descriptor --
(# aMenubar: ^menubarType;
do (64, 64) -> theMinSize;
	(32767,32767) -> theMaxSize;
	this(window)[] -> this(guienv).private.windows.append;
	&menubarType[] -> aMenubar[];
	(if aMenubar.struc <= menubar## then
		aMenubar.open;
		aMenubar[] -> theMenubar;
	else
		none -> aMenubar[];
	if);
	private.windowContents.open;
	true -> private.doShow;
	inner open;
	(if private.doShow then
		show;
	if);
	updateCursor;
#)

-- GUIENVwindowClose: descriptor --
(#
do hide;
	inner close;	
	false -> processActivate;
	private.windowContents.close;
	
	this(window)[] -> this(guienv).private.windows.remove;
	private.windowPointer -> CloseWindow;
	0 -> private.windowPointer;
	false -> private.doShow;
	0 -> private.type;
	0 -> private.style;
	(0, 0) -> private.theMaxSize;
	(0, 0) -> private.theMinSize;
	false -> private.windowActive;
	false -> private.windowVisible;
	NONE -> private.windowTarget[];
	NONE -> private.lastObjectClicked[];
	NONE -> private.windowDefaultButton[];
	(if private.windowMenuBar[] <> NONE then
		private.windowMenuBar.close;
		NONE -> private.windowMenuBar[];
	if);
	updateCursor;
#)

-- GUIENVwindowPutLayout: doPart --
do

-- GUIENVwindowGetLayout: doPart --
do

-- GUIENVwindowSetTarget: descriptor --
(#
do assertOpen;
	(if windowTarget<>theTarget[] then
		(if windowTarget<>None then
			private.windowTarget.theEventHandler.onDisableTarget;
		if);
		(if theTarget[] <> NONE then
			theTarget.assertOpen;
			theTarget[] -> windowTarget;
			private.windowTarget.theEventHandler.onEnableTarget;
		else
			NONE -> windowTarget;
		if);
	if);
#)

-- GUIENVwindowGetTarget: descriptor --
(#
do assertOpen;
	windowTarget -> theTarget[];
#)

-- GUIENVwindowitemOnRefresh: descriptor --
(# rgn: @integer;
do (if private.visibleFlag then
		(if private.eraseWhenUpdating then
			(if NOT private.isFigureItem then
				graphics
					(# width, height: @integer;
					do size -> (width, height);
						(0, 0, width, height) -> EraseRectangle;
					#);
			if);
		if);
		(if backGroundStyle <> noneBackGround then
			(* graphics
				(# width, height: @integer;
				do size -> (width, height);
					(0, 0, width, height) -> EraseRectangle;
				#);
			*)
		if);
		(if border.visible then
			(if not private.isFigureItem then
				(((0, 0), size), border.style) -> drawBorder;
			if);
		if);
		inner onRefresh;
	if);
#)


-- GUIENVwindowitemSetFrame: descriptor --
(# oldFrame: @rectangle;

	isVisible:
		(# value: @boolean;
		do (if this(window).private.windowVisible then
				private.visibleFlag -> value;
			else
				false -> value;
			if);
		exit value
		#);
do assertOpen;
	(if false then
		this(windowItem)[] -> getPatternName -> putText;
		'.changeFrame' -> putLine;
	if);
	private.left -> oldFrame.left;
	private.top -> oldFrame.top;
	private.right -> oldFrame.right;
	private.bottom -> oldFrame.bottom;
	(if not (theFrame -> oldFrame.isEqual) then
		(if private.isFigureItem then
			invalFrame;
			theFrame.left -> private.left;
			theFrame.right -> private.right;
			theFrame.top -> private.top;
			theFrame.bottom -> private.bottom;
			calculateOrigin;
			invalFrame;
		else
			(if isVisible then
				invalVisibleRgn;
				true -> forgetVisibleRgn;
				theFrame.left -> private.left;
				theFrame.right -> private.right;
				theFrame.top -> private.top;
				theFrame.bottom -> private.bottom;
				calculateOrigin;
				invalVisibleRgn;
			else
				true -> forgetVisibleRgn;
				theFrame -> privateWindowItemFrame;
				calculateOrigin;
			if);
		if);
		(if father[]<>none then
			(oldFrame,theFrame) -> father.theEventHandler.onChildFrameChanged;
		if);
		(oldFrame,theFrame) -> theEventHandler.onFrameChanged;
	if);
#)

(*

-- GUIENVwindowitemSetFrame: descriptor --
(# oldFrame: @rectangle;
	oldVisibleRgn: @integer;
	newVisibleRgn: @integer;
	onlyResize: @boolean;
do assertOpen;
	private.left -> oldFrame.left;
	private.top -> oldFrame.top;
	private.right -> oldFrame.right;
	private.bottom -> oldFrame.bottom;
   (oldFrame.top = theFrame.top)
     and 
    (oldFrame.left = theFrame.left) ->  onlyResize;
	(if not (oldFrame -> theFrame.isEqual) then
		(if (private.automaticUpdate and visible) then
			(if (onlyResize and (not private.updateOnResize)) then
				NewRgn -> oldVisibleRgn;
				(if private.clip = 0 then
					exception
						(#
						do 'Accesing NIL clip region' -> msg.append;
						#);
				else
					(private.clip, oldVisibleRgn) -> CopyRgn;
				if);
			else
				update
			if);
		if);
		theFrame -> privateWindowItemFrame;
		(if (private.automaticUpdate and visible) then
			(if (onlyResize and (not private.updateOnResize)) then
				NewRgn -> newVisibleRgn;
				(if private.clip = 0 then
					exception
						(#
						do 'Accesing NIL clip region' -> msg.append;
						#);
				else
					(private.clip, newVisibleRgn) -> CopyRgn;
					(oldVisibleRgn,newVisibleRgn,newVisibleRgn) -> XorRgn;
					oldVisibleRgn -> DisposeRgn;
					newVisibleRgn -> InvalRgn;
					newVisibleRgn -> DisposeRgn;
				if);
			else
				update;
			if);
		if);
		(if father[]<>none then
			(oldFrame,theFrame) -> father.theEventHandler.onChildFrameChanged;
		if);
		(oldFrame,theFrame) -> theEventHandler.onFrameChanged;
	if);
	updateCursor;
#)

*)


-- GUIENVwindowitemGetFrame: descriptor --
(#
do assertOpen;
	private.left -> theFrame.left;
	private.top -> theFrame.top;
	private.right -> theFrame.right;
	private.bottom -> theFrame.bottom;
#)

-- GUIENVwindowitemSetPosition: descriptor --

(#	r: @rectangle;
	width,height: @integer;
do assertOpen;
	frame -> r;
	r.size -> (width,height);
	pt -> r.topLeft;
	(width,height) -> r.size;
	r -> frame;
#)

-- GUIENVwindowitemGetPosition: descriptor --
(# r: @rectangle;
do assertOpen;
	frame -> r;
	r.topleft -> pt;
#)

-- GUIENVwindowitemMove: descriptor --
(# pt: @point;
do assertOpen;
	position -> pt;
	(dh,dv) -> pt.add;
	pt -> position;
#)

-- GUIENVwindowitemSetSize: descriptor --
(# r: @rectangle;
do assertOpen;
	frame -> r;
	(width,height) -> r.size;
	r -> frame;
#)

-- GUIENVwindowitemGetSize: descriptor --
(# r: @rectangle;
do assertOpen;
	frame -> r;
	r.size -> (width,height);
#)

-- GUIENVwindowitemSetVisible: descriptor --
(#
do assertOpen;
	(if value<>private.visibleFlag then
		(if private.visibleFlag then
			updateMaybe;
		if);
		value -> private.visibleFlag;
		true -> forgetVisibleRgn;
		theEventHandler.onVisibleChanged;
		(if private.visibleFlag then
			updateMaybe;
		if);
		(if this(windowItem)[] = target then
			father[] -> target;
		if);
		updateCursor;
	if);
#)

-- GUIENVwindowitemGetVisible: descriptor --
(#
do assertOpen;
	private.visibleFlag -> value;
#)

-- GUIENVwindowitemSetHilite: descriptor --
(#
do assertOpen;
	(if value<>private.hiliteFlag then
		value -> private.hiliteFlag;
		theEventHandler.onHiliteChanged;
	if);
#)

-- GUIENVwindowitemGetHilite: descriptor --
(#
do assertOpen;
	private.hiliteFlag -> value;
#)

-- GUIENVwindowitemShow: descriptor --
(#
do assertOpen;
	true -> visible;
#)

-- GUIENVwindowitemHide: descriptor --
(#
do assertOpen;
	false -> visible;
#)

-- GUIENVwindowitemSetEnabled: descriptor --
(#
do assertOpen;
	(if value<>private.enabledFlag then
		value -> private.enabledFlag;
		theEventHandler.onEnabledChanged;
	if);
	updateCursor;
#)

-- GUIENVwindowitemGetEnabled: descriptor --
(#
do assertOpen;
	private.enabledFlag -> value;
#)

-- GUIENVwindowitemEnable: descriptor --
(#
do assertOpen;
	true -> enabled;
#)

-- GUIENVwindowitemDisable: descriptor --
(#
do assertOpen;
	false -> enabled;
#)

-- GUIENVwindowitemBorderSetVisible: doPart --
do assertOpen;
	(if value <> private.borderVisibleFlag then
		value -> private.borderVisibleFlag;
		update;
	if);

-- GUIENVwindowitemBorderGetVisible: doPart --
do assertOpen;
	private.borderVisibleFlag -> value;

-- GUIENVwindowitemBorderSetStyle: doPart --
do assertOpen;
	(if value <> private.borderStyle then
		value -> private.borderStyle;
		update;
	if);

-- GUIENVwindowitemBorderGetStyle: doPart --
do assertOpen;
	private.borderStyle -> value;

-- GUIENVwindowiteminsideRectangle: doPart --
do 
   
-- GUIENVwindowitemSetTheCursor: descriptor --
(#
do assertOpen;
	theCur[] -> windowItemCursor;
	updateCursor;
#)

-- GUIENVwindowitemGetTheCursor: descriptor --
(#
do assertOpen;
	windowItemCursor -> theCur[];
#)

-- GUIENVwindowItemTrackMouse: descriptor --
(# GlobalToLocal: External (# p: ^macPoint enter p[] do '$A871' -> PascalTrap; #);
do assertOpen;
	(if StillDown then
		setupClipForDrawing
			(#
				macPt: @macPoint;
				dh,dv: @integer;
			do 
				this(guienv).private.event.where -> macPt;
				macPt[] -> GlobalToLocal;
				macPt.getPoint -> curPt -> prevPt;
				mousePress;
				loop:
					(if StillDown then
						macPt[] -> GetMouse;
						macPt.getPoint -> curPt;
						curPt.h - prevPt.h -> dh;
						curPt.v - prevPt.v -> dv;
						(if ((dh<>0) or (dv<>0)) then
							(dh,dv) -> mouseMove;
						if);
						curPt -> prevPt;
						restart loop;
					if);
				mouseRelease;
				none -> lastObjectClicked;
			#);
	if);
#)

-- GUIENVwindowitemDrag: descriptor --
(#
do assertOpen;
	father.trackMouse
		(# currentFrame: @rectangle;
			drawFrame: @
				(#
				do currentFrame[] -> makeMacRect -> FrameRect;
				#);
			mousePress::<
				(#
				do PenNormal;
					blackColor -> ForeColor;
					whiteColor -> BackColor;
					srcXor -> PenMode;
					frame -> currentFrame;
					drawFrame;
				#);
			mouseMove::<
				(#
				do drawFrame;
					(h,v) -> currentFrame.offset;
					drawFrame;
				#);
			mouseRelease::<
				(#
				do drawFrame;
					currentFrame -> frame;
				#);
		#);
#)

-- GUIENVwindowitemResize: descriptor --
(#
do (* not implemented !!! *)
#)

-- GUIENVwindowitemUpdate: descriptor --
(# 
do assertOpen;
	(if private.visibleFlag then
	 	invalVisibleRgn;
	if);
#)

-- GUIENVwindowitemCreate: descriptor --
(# origin: ^object;
do (if this(window).style = plain then
		whiteBackGround -> backGroundStyle
	else
		grayBackGround -> backGroundStyle;
	if);
	inner create;
	(if father[] = none then
		(if this(windowitem)[] = windowContents then
		else
			this(windowitem)[] -> getOrigin -> origin[];
			l:
			(if origin[] = none then
				windowContents -> father[];
			else 
				(if (origin.struc <= canvas##) then 
					origin[] -> father[];
				else 
					origin[] -> getOrigin -> origin[];
					restart l;
				if)
			if);
		if);
	if);
	
#)

-- GUIENVwindowitemOpen: descriptor --
(#
do 
	(if father[]<>none then
		(if private.isFigureItem then
			this(windowitem)[] -> father.private.figs.append;
		else
			this(windowitem)[] -> father.private.children.append;
		if);
	if);
	((0, 0), (100, 30)) -> privateWindowItemFrame;
	true -> private.automaticUpdate;
	true -> private.visibleFlag;
	true -> private.enabledFlag;
	true -> private.updateOnResize;
	true -> private.eraseWhenUpdating;
	true -> bindTop;
	true -> bindLeft;
	(if this(window).style = plain then
		borderStyles.simple -> private.borderStyle;
	else
		borderStyles.shadowIn -> private.borderStyle;
	if);
	brotherForgetVisibleRgn;
	inner open;
	updateCursor;
	
#)

-- GUIENVwindowitemClose: descriptor --
(#
do updateMaybe;
	inner close;
	(if this(windowItem)[] = target then
		none -> target;
	if);
	(if private.isFigureItem then
		this(windowitem)[] -> father.private.figs.remove;
	else
		forgetVisibleRgn;
		this(windowitem)[] -> father.private.children.remove;
	if);
	0 -> private.originX;
	0 -> private.originY;
	false -> private.visibleFlag;
	false -> private.automaticUpdate;
	false -> private.enabledFlag;
	false -> private.updateOnResize;
	false -> private.eraseWhenUpdating;
	false -> private.hiliteFlag;
	false -> bindTop;
	false -> bindLeft;
	0 -> private.backGroundStyle;
	0 -> private.left;
	0 -> private.right;
	0 -> private.top;
	0 -> private.bottom;
	0 -> private.borderStyle;
	NONE -> private.windowItemCursor[];
	updateCursor;
#)
                                                                    
	
-- GUIENVwindowItemHit: doPart --
do (pt.h >= private.left) AND (pt.h < private.right) 
		AND 
	(pt.v >= private.top) AND (pt.v < private.bottom) -> value;
	

-- GUIENVwindowItemHandleCursor: doPart --
do 
(# left, top: @integer;
	visRgn: @integer;
do 
	(if windowItemCursor = none then
		cursors.arrow[] -> mouse.busyCursor;
	else
		windowItemCursor -> mouse.busyCursor;
	if);
	this(guienv).private.cursorRegion -> getDrawingRgn;
	this(window).position -> (left, top);
	(this(guienv).private.cursorRegion, left, top) -> OffsetRgn;
#)

-- windowItemLib: attributes --

setRgnToFrame:
	(# rgn: @integer;
		left, top, right, bottom: @integer;
	enter	rgn
	do private.originX -> left;
		private.originY -> top;
		private.originX + (private.right -  private.left) -> right;
		private.originY + (private.bottom - private.top) -> bottom;
		(rgn, left, top, right, bottom) -> SetRectRgn;
	#);

processFatherFrameChanged:
	(# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
	enter (oldFrame,newFrame)
	do newFrame.size -> delta;
		oldFrame.size -> delta.subTract;
		(if not ((0,0) -> delta.isEqual) then
			frame -> chainRect -> itsFrame;
			delta -> chainRect.offset;
			(if not bindLeft then
				chainRect.left -> itsFrame.left;
			if);
			(if bindBottom then
				chainRect.bottom -> itsFrame.bottom
			if);
			(if bindRight then
				chainRect.right -> itsFrame.right
			if);
			(if not bindTop then
				chainRect.top -> itsFrame.top
			if);
			itsFrame -> frame;
		if);
		(oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
	#); 
	


-- GUIENVcanvasPutLayout: doPart --
do

-- GUIENVcanvasGetLayout: doPart --
do

-- GUIENVcanvasOnActivate: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onActivate;
		#);
	inner onActivate;
#)

-- GUIENVcanvasOnDeactivate: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onDeactivate;
		#);
	inner onDeactivate;
#)

-- GUIENVcanvasOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVcanvasOnRefresh: descriptor --
(#
do inner onRefresh;
	scan
		(#
		do current.theEventHandler.onRefresh;
		#);
#)

-- GUIENVcanvasOnMouseUp: descriptor --
(#
do inner onMouseUp;
#)

-- GUIENVcanvasOnFrameChanged: descriptor --
(#
do inner onFrameChanged;
   scan
		(#
		do (oldFrame,newFrame) -> current.processFatherFrameChanged;
		#);
#)

-- GUIENVcanvasSelectionAdd: descriptor --
(#
do assertOpen;
	theWindowitem.assertOpen;
	(if not (theWindowitem[] -> private.selection.has) then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionSet: descriptor --
(#
do assertOpen;
	theWindowItem.assertOpen;
	private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;
#)

-- GUIENVcanvasSelectionRemove: descriptor --
(#
do assertOpen;
	theWindowitem.assertOpen;
	(if theWindowitem[] -> private.selection.has then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionEmpty: descriptor --
(#
do assertOpen;
	private.selection.empty -> value;
#)

-- GUIENVcanvasSelectionScan: descriptor --
(#
do assertOpen;
	private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVcanvasSelectionClear: descriptor --
(#
do assertOpen;
	private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
#)

-- GUIENVcanvasScan: descriptor --
(#
do assertOpen;
	private.figs.scan
	(#
	do current[] -> this(scan).current[];
		inner scan;
	#);
	private.children.scan
	(#
	do current[] -> this(scan).current[];
		inner scan;
	#)
#)

-- GUIENVcanvasCreate: descriptor --
(#
do inner create;
#)

-- GUIENVcanvasOpen: descriptor --
(#
do 
	(if this(window).style = plain then
		borderStyles.simple -> border.style;
	else
		borderStyles.shadowIn -> border.style;
	if);
	private.children.init;
	private.figs.init;
	inner open;
#)

-- GUIENVcanvasClose: descriptor --
(#
do inner close;
	private.children.clear;
	private.figs.clear;
	scan
		(#
		do current.close;
		#);
#)

-- GUIENVcanvasPrintOpenPage: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- GUIENVsharedWindowAddDisplay: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- GUIENVsharedWindowRemoveDisplay: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- cursorLib: attributes --
cursorHandle:
	(#
	enter private.cursorHandle
	exit private.cursorHandle
	#);
readCursorResource:
	(#	id: @integer;
	enter id
	do id -> GetCursor -> cursorHandle;
	#);

-- GUIENVcursorPrivate: descriptor --
(# cursorHandle: @integer;
#)

-- GUIENVtextStyleSetName: descriptor --
(# sr: @shortRef;
do (theName,sr[]) -> GetFNum;
	sr -> familyID;
#)

-- GUIENVtextStyleGetName: descriptor --
(# ps: @pascalString;
do (private.familyID, ps[]) -> GetFontName;
	ps.getText -> theName[];
#)

-- GUIENVtextStyleSetSize: descriptor --
(#
do value -> textStyleSize;
#)

-- GUIENVtextStyleGetSize: descriptor --
(#
do textStyleSize -> value;
#)

-- GUIENVtextStyleSetFace: descriptor --
(#
do value -> textStyleFace;
#)

-- GUIENVtextStyleGetFace: descriptor --
(#
do textStyleFace -> value;
#)

-- GUIENVtextStyleAscent: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent -> value;
#)

-- GUIENVtextStyleDescent: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.descent -> value;
#)

-- GUIENVtextStyleLeading: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.leading -> value;
#)

-- GUIENVtextStyleHeight: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent + info.descent -> value;
#)

-- GUIENVtextStyleMaxChWidth: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.widMax -> value;
#)

-- GUIENVtextStyleWidthOfChar: descriptor --
(#
do withTextStyle
		(#
		do ch -> CharWidth -> value;
		#);
#)

-- GUIENVtextStyleStringWidth: descriptor --
(#
do withTextStyle
		(#
		do str[] -> GetTextWidth -> value;
		#);
#)

-- GUIENVtextStyleFamilySizes: descriptor --
(#
do (* Not Implemented !!!*)
#)

-- GUIENVTextStyleWithTextStyle: descriptor --
(#	port: @longInt;
do port[] -> GetPort;
	utilityPort -> SetPort;
	familyID -> TextFont;
	textStyleSize -> TextSize;
	textStyleFace -> TextFace;
	inner withTextStyle;
	port -> SetPort;
#)


-- GUIENVclipBoardHasText: descriptor --
(#	length: @integer;
	offset: @longInt;
	TextType: (# exit 1413830740 #);
do (0,TextType,offset[]) -> GetScrap -> length;
	(length >= 0) -> value;
#)

-- GUIENVclipBoardSetText: descriptor --
(# ignore: @integer;
do	ZeroScrap -> ignore;
	(if txt.lgth > 0 then
		(txt[],'TEXT') -> PutTextScrap;
	if);
#)

-- GUIENVclipBoardGetText: descriptor --
(#	
do 'TEXT' -> GetScrapAsText -> txt[];
#)

-- GUIENVclipBoardClearContents: descriptor --
(# ignore: @integer;
do	ZeroScrap -> ignore;
#)

-- GUIENVmouseGlobalPosition: descriptor --
(#	event: @eventRecord;
	ignore: @boolean;
	macPt: @macPoint;
do	(everyEvent,event[]) -> OSEventAvail -> ignore;
	event.where -> macPt;
	macPt.getPoint -> pt;
#)

-- GUIENVmouseButtonState: descriptor --
(#
do	(if Button then
		1 -> value;
	else
		0 -> value;
	if);
#)

-- GUIENVmouseTheCursorSet: descriptor --
(#	g: @globVars;
	h: @integer;
do	(if theCur[] = none then
		g.init;
		g.arrowAddress -> SetCursor;
	else
		(if theCur.cursorHandle//0 then
			g.init;
			g.arrowAddress -> SetCursor;
		else
			theCur.cursorHandle -> h;
			h -> TOS'%adrGetLong' -> SetCursor;
		if);
	if);
#)

-- GUIENVmouseTheCursorGet: descriptor --
(#
do	(* Not implemented !!! *)
#)

-- GUIENVsystemScreenRectangle: descriptor --
(# g: @globVars;
do	g.init;
	g.screenBitsBoundsBR -> theRectangle.bottomRight;
#)

-- GUIENVsystemScreenRgn: descriptor --
(# 
do	(* Not implemented !!! *)
#)

-- GUIENVsystemBeepBody: descriptor --
(#
do	2 -> SysBeep;
#)

-- GUIENVsystemWaitBody: descriptor --
(# ignore: @longInt;
do	(ticks,ignore[]) -> Delay;
#)

-- GUIENVdoSetUp: descriptor --
(# initRegions:
		(#
		do	NewRgn -> cursorRegion;
			NewRgn -> private.emptyRgn;
			NewRgn -> private.wideRgn;
			(private.wideRgn, -32768, -32768, 32766, 32766) 
				-> SetRectRgn;
		#);
	initMenubar:
		(# initAppleMenu:
				(# appleMenuID: (# exit 128 #);
					type: @integer;
				do appleMenuID -> GetMenu -> appleMenu;
					'DRVR' -> toResType -> type;
					(appleMenu,type) -> AppendResMenu;
					(appleMenu,0) -> InsertMenu;
				#);
			aMenubar: ^menuBarType;
		do 200 -> lastMenuID;
			initAppleMenu;
			&menuBarType[] -> aMenubar[];
			aMenuBar.open;
			aMenubar[] -> applicationMenubar;
			true -> private.globalMacMenuBar.needsUpdate;
		#);
	consoleStream: stream
		(# consoleWindow: @window
				(#	waitingForInput: @boolean;
					lastPosition: @integer;
					waitForInput:
						(#
						do	
							true -> waitingForInput;
							theTextEditor.contents.length -> lastPosition;
							(lastPosition,lastPosition) -> theTextEditor.contents.selection;
							showModal;
						#);
					theTextEditor: @textEditor
						(#	contentsType::<
								(# eventHandler::<
										(# 
											onBeforeChange::<
												(#
												do waitingForInput and (position >= lastPosition) 
														-> allow -> beeingChanged;
												#);
											beeingChanged: @boolean;
											onKeyDown::<
												(#
												do (if beeingChanged then
														(if ch//13 then
															buffer.clear;
															(lastPosition,length)  -> scanText
																(#
																do ch -> buffer.put;
																#);
															0 -> buffer.setPos;
															false -> waitingForInput;
															consoleWindow.Hide;
														if);
													if);
												#);
										#);
								#);
							open::<
								(#	width,height: @integer;
								do consoleWindow.size -> (width,height);
									(* ((-1,-1),(width+1,height+1)) -> frame; *)
									(width, height) -> size;
									true -> bindRight;
									true -> bindBottom;
								#);
						#);
					eventHandler::
						(# onAboutToClose::
								(#
								do	hide;
									false -> okToClose;
								#);
						#);
					open::<
						(#	r: @rectangle;
						do hide;
							system.screenRectangle -> r;
							r.bottom div 2 -> r.top;
							(4,4) -> r.inset;
							r -> frame;
							theTextEditor.open;
							theTextEditor.contents[] -> target;
							'Console Window' -> title;
						#);
					append:
						(# t: ^text;
						enter t[]
						do private.windowPointer -> ShowTheWindow;
							true -> windowVisible;
							(theTextEditor.contents.length,theTextEditor.contents.length)
								-> theTextEditor.contents.selection;
							t[] -> theTextEditor.contents.insert;
						#);
				#);
			put::<
				(# t: ^text;
				do &text[] -> t[];
					ch -> t.put;
					t[] -> consoleWindow.append;
				#);
			putText::<
				(#
				do txt[] -> consoleWindow.append;
				#);
			buffer: @text;
			whenInput:
				(# nonBlank: @boolean;
				enter nonBlank
				do loop: 
						(if true then
							(if nonBlank then
								buffer.ScanWhiteSpace;
							if);
							(if buffer.eos
							then
								consoleWindow.waitForInput;
								restart loop;
							else
								inner;
							if);
						if);
				#);
			get::<
				(# 
				do whenInput
						(#
						do buffer.get -> ch;
						#);
				#);
			getAtom::<
				(#
				do true -> whenInput
						(#
						do buffer.getAtom -> txt[];
						#);
				#);
			getLine::<
				(#
				do whenInput
						(#
						do buffer.getLine -> txt[];
						#);
				#);
			eos::<
				(#
				do false -> value;
				#);
			init: (# do buffer.clear;consoleWindow.open; #);
		#);
	fileConsole: stream
		(#	f: @file;
			init:
				(#
				do 'beta-stdout' -> f.name;
					f.openWrite;
				#);
			put::
				(#
				do ch -> f.put;
					f.flush;
				#);
		    puttext::
			 	(#
				do txt[] -> f.putText;
					f.flush;
				#);
		#);
		
	initConsole:
		(# theConsole: ^consoleStream;
			theFileConsole: ^fileConsole;
		do (if false then
				&fileConsole[] -> theFileConsole[] -> screen[] -> keyBoard[];
				theFileConsole.init;
			else
				&consoleStream[] -> theConsole[] -> screen[] -> keyBoard[];
				theConsole.init;
			if);
		#);
	initUtilityPort:
		(#
		do 108 -> NewPtr -> utilityPort;
			utilityPort -> OpenPort;
		#);
	initCursors:
		(#
		do 1 -> cursors.iBeam.readCursorResource;
			2 -> cursors.cross.readCursorResource;
			3 -> cursors.plus.readCursorResource;
			4 -> cursors.watch.readCursorResource;
		#);
	initPatterns:
		(#	
		do private.globals.init;
			&raster[] -> patterns.black[];
			private.globals.blackAddress -> patterns.black.copyPatternData;
			
			&raster[] -> patterns.white[];
			private.globals.whiteAddress -> patterns.white.copyPatternData;
			
			&raster[] -> patterns.dkGray[];
			private.globals.dkGrayAddress -> patterns.dkGray.copyPatternData;
			
			&raster[] -> patterns.gray[];
			private.globals.grayAddress -> patterns.gray.copyPatternData;
			
			&raster[] -> patterns.ltGray[];
			private.globals.ltGrayAddress -> patterns.ltGray.copyPatternData;
			
			128 -> GetPixPat -> private.grayPixPat;
			private.globals.whiteAddress -> private.whitePat;
		#);
do private.event.init;
	initRegions;
	initMenubar;
	modeless -> modalState;
	initPatterns;
	initConsole;
	initUtilityPort;
	initCursors;
	private.timerQueue.init;
	private.initColors;
#)

-- GUIENVDoPart: descriptor --
(#
do 
	doSetup;
	inner guienv;
	mainLoop
#)

-- GUIENVactiveWindow: descriptor --
(# windowPointer: @integer;
do	FrontWindow -> windowPointer;
	(if windowPointer//0 then
		none -> theWindow[];
	else
		windowPointer -> private.windows.findBywindowPointer -> theWindow[];
	if);
#)

-- GUIENVwindowsFindBywindowPointer: descriptor --
(#
do	l: scan
		(#
		do (if current.private.windowPointer//windowPointer then
				current[] -> e[];
				leave l;
			if);
		#);
#)

-- GUIENVInterfaceObjectPutLayout: Descriptor --
(#
do (* Not Implemented !!! *)
#)

-- GUIENVmacMenuBarappend: descriptor --
(#
do (if not (theMenu[] -> member) then
		theMenu[] -> menus.append;
		(theMenu.private.handle,0) -> InsertMenu;
		true -> needsUpdate;
	if);
#)

-- GUIENVmacMenuBardelete: descriptor --
(#
do	(if theMenu[] -> member then
		theMenu[] -> menus.at -> menus.delete;
		theMenu.menuID -> DeleteMenu;
		true -> needsUpdate;
	if);
#)

-- GUIENVmacMenuBarmember: descriptor --
(#
do theMenu[] -> menus.has -> value;
#)

-- GUIENVmacMenuBarFindByName: descriptor --
(#
do l: menus.scan
			(#
			do (if current.name -> name.equalNCS then
					current[] -> theMenu[];
					leave l;
				if);
			#);
#)

-- GUIENVmacMenuBarFindByID: descriptor --
(#
do l: menus.scan
			(#
			do (if current.handle//ID then
					current[] -> theMenu[];
					leave l;
				if);
			#);
#)

-- GUIENVmacMenuBarInit: descriptor --
(#
do menus.init;
#)

-- GUIENVmacMenuBarUpdate: descriptor --
(#
do DrawMenuBar;
	false -> needsUpdate;
#)

-- GUIENVwindowGlobalToLocal: doPart --
do debug
		(#
		do	'GlobalToLocal not implemented' -> putText;
		#);

-- GUIENVwindowLocalCoordsToGlobal: doPart --
do debug
		(#
		do	'GlobalToLocal not implemented' -> putText;
		#);

-- TimerQueueInit: doPart --
do	maxInt -> minInterval;

-- TimerQueueInsert: doPart --
do TickCount -> action.time;
	(if action.interval < minInterval then
		action.interval -> minInterval;
	if);
	(if top < R.range then
		top + 1 -> top;
		action[] -> R[top][];
	else
		false -> inserted;
		(for inx: top repeat
			(if R[inx][] = none then
				action[] -> R[inx][];
				true -> inserted;
			if);
		for);
		(if not inserted then
			top -> R.extend;
			top + 1 -> top;
			action[] -> R[top][];
		if);
	if);
					
					
-- TimerQueueDelete: doPart --
do maxInt -> minInterval;
	(for inx: top repeat
		(if R[inx][] <> none then
			(if R[inx][] = action[] then
				none -> R[inx][];
			else
				(if R[inx].interval < minInterval then
					R[inx].interval -> minInterval;
				if);
			if);
		if);
	for);
	
-- TimerQueueScan: doPart --
do (for inx: top repeat
		(if R[inx][] <> none then
			R[inx][] -> current[];
			inner;
		if);
	for);
	
-- TimerQueueExecuteElapsed: doPart --
do maxInt -> minInterval;
	1 -> inx;
	l: (if inx <= top then
			(if R[inx][] <> none then
				R[inx][] -> current[];
				TickCount -> currentTime;
				(if currentTime - current.time > current.interval then
					current;
					TickCount -> currentTime;
					currentTime -> current.time;
				if);
				current.interval - (currentTime - current.time)  -> interval;
				(if interval < minInterval then
					interval -> minInterval;
				if);
			if);
			inx + 1 -> inx;
			restart l;
		if);
	currentTime -> lastVisit;
	
-- GUIENVwindowItemDrawBorder: doPart --
do (#
	   
	   	
	   left, top, right, bottom: @integer;
	   
	do assertOpen;
	   r.topLeft -> (left, top);
	   r.bottomRight -> (right, bottom);
	   graphics
		   (# 
		   do (if this(drawborder).style 
		   	//borderStyles.shadowIn then
					this(guienv).private.black -> pen.foreGroundColor;
					((left+1, top+1), (right-1, bottom-1)) -> drawRect;
					
					this(guienv).private.gray[5] -> pen.foreGroundColor;
					((left, top), (right - 2, top)) -> drawLine;
					((left, top), (left, bottom - 2)) -> drawLine;
					
					this(guienv).private.white -> pen.foreGroundColor;
					((right - 1, top + 1), (right - 1, bottom - 1)) -> drawLine;
					((left + 1, bottom - 1), (right - 1, bottom - 1)) -> drawLine;

			   //borderStyles.shadowOut then
					this(guienv).private.black -> pen.foreGroundColor;
					((left, top), (right, bottom)) -> drawRect;
					
		   		this(guienv).private.white -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 2)) -> drawLine;
			   	((left + 1, top + 1), (right - 2, top + 1)) -> drawLine;
					
			   	this(guienv).private.gray[5] -> pen.foreGroundColor;
			   	((left + 2, bottom - 2), (right - 2, bottom - 2)) -> drawLine;
			   	((right - 2, top + 2), (right - 2, bottom - 2)) -> drawLine;
					
			   //borderStyles.etchedIn then
			   	this(guienv).private.gray[7] -> pen.foreGroundColor;
			   	((left, top), (right - 1, bottom - 1)) -> drawRect;
					
			   	this(guienv).private.white -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 3)) -> drawLine;
			   	((left + 1, top + 1), (right - 3, top + 1)) -> drawLine;
			   	((left, bottom - 1), (right - 1, bottom - 1)) -> drawLine;
			   	((right - 1, top), (right - 1, bottom - 1)) -> drawLine;
					
			   //borderStyles.etchedOut then
			   	this(guienv).private.white -> pen.foreGroundColor;
			   	((left, top), (right - 1, bottom - 1)) -> drawRect;
					
			   	this(guienv).private.gray[7] -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 3)) -> drawLine;
			   	((left + 1, top + 1), (right - 3, top + 1)) -> drawLine;
			   	((left, bottom - 1), (right - 1, bottom - 1)) -> drawLine;
			   	((right - 1, top), (right - 1, bottom - 1)) -> drawLine;
					
			   //borderStyles.simple then
			   	r -> drawRect;
			   if);
		   #)
	#)
	
-- GUIENVcanvasFindObjectClicked: doPart --
do position -> pt.subtract;
	l: private.children.scanReverse
		(# currentCanvas: ^canvas;
		do (if current.clickable then
				(if pt -> current.hit then
					(if current## <= canvas## then
						current[] -> currentCanvas[];
						pt -> currentCanvas.findObjectClicked -> ObjectClicked[];
					else
						current[] -> ObjectClicked[];
					if);
					leave l;
				if);
			if);
		#);
	(if ObjectClicked[] = NONE then
		this(canvas)[] -> ObjectClicked[];
	if);

	
-- GUIENVwindowItemToScreenCoordinates: doPart --
do (# macPt: @macPoint;
       LocalToGlobal: External (# p: ^macPoint enter p[] do '$A870' -> PascalTrap; #);
	do assertOpen;
		p -> macPt.setPoint;
		this(window).private.windowPointer -> SetPort;
		(-private.originX, -private.originY) -> SetOrigin;
		macPt[] -> LocalToGlobal;
		macPt.getPoint -> q;
	#);
	
-- MacMenuBarAdjust: doPart --
do menus.iterate
		(#
		do current.elm.adjust;
		#);


-- windowItemCalculateVisibleRgn: doPart --
do (# fatherVisibleRgn: @integer; (* Region Handle *)
		siblingFrameRgn: @integer; (* Region Handle *)
		pos: ^father.private.children.theCellType;
	do (if false then
			this(windowItem)[] -> getPatternName -> putText;
			'.calculateVisibleRgn' -> putLine;
		if);
		NewRgn -> rgn;
	
		(*
		 * Start out with the frame in global coordinates in
		 * the window:
		 *)
		 
		rgn -> setRgnToFrame;
		
		
		(if father[] <> NONE then
			(*
			 * Intersect with the fathers visibleRgn:
			 *)
			 
			father.getVisibleRgn -> fatherVisibleRgn;
			
				
			(fatherVisibleRgn, rgn, rgn) -> SectRgn;
			
			(*
			 * Remove the bounding box of the
			 * overlapping siblings:
			 *)
			 
			(if not (rgn -> EmptyRgn) then
				this(windowItem)[] -> father.getChildPosition -> pos[];
				pos.succ[] -> pos[];
				(if pos[] <> NONE then
					NewRgn -> siblingFrameRgn;
					l: pos[] -> father.private.children.scanFrom
					  (#
					  do (if current.visible then
					  			siblingFrameRgn -> current.setRgnToFrame;
							  (rgn, siblingFrameRgn, rgn) -> DiffRgn;
							  (if (rgn -> EmptyRgn) then
									leave l;
							  if);
							if);
					  #);
					siblingFrameRgn -> DisposeRgn;
				if);
				
			if);
		if);
		
	#)
	
-- windowItemForgetVisibleRgn: doPart --
do (# 
	   asCanvas: ^canvas;
	do (*
		 * Deallocate the visible rgn
		 *)
		 
		(if false then
			this(windowItem)[] -> getPatternName -> putText;
			'.forgetVisibleRgn' -> putLine;
		if);
		
		(if private.visibleRgn <> 0 then
			 private.visibleRgn -> DisposeRgn;
			 0 -> private.visibleRgn;
			 
			 (*
			  * Tell the other objects whose visibleRgn depends
			  * on my visibleRgn to forget their visibleRgn.
			  *)
			  
			  
			  (if this(windowItem)## <= canvas## then
					this(windowItem)[] -> asCanvas[];
					asCanvas.scan
						(#
						do current.forgetVisibleRgn;
						#);
			  if);
		 if);
		 
		 
		 (if tellBrothers then
					brotherForgetVisibleRgn;
		 if);
	#);

-- windowItemBrotherForgetVisibleRgn: doPart --
do (if NOT private.isFigureItem then
		(# prevSibling: ^windowItem;
		do (if father[] <> NONE then
				this(windowItem)[] -> father.getPrevSibling -> prevSibling[];
				(if prevSibling[] <> NONE then
					true -> prevSibling.forgetVisibleRgn;
				if);
			if);
		#);
	if);
	
-- windowItemCalculateOrigin: doPart --
do (# x, y: @integer;
	   asCanvas: ^canvas;
   do (if father[] = NONE then
			0 -> private.originX;
			0 -> private.originY;
		else
			father.privateOrigin -> (x, y);
			x + private.left -> private.originX;
			y + private.top -> private.originY;
			(if this(windowItem)## <= canvas## then
				this(windowItem)[] -> asCanvas[];
				asCanvas.scan
					(#
					do current.calculateOrigin;
					#);
			if);
		if);
		
   #);
	
-- windowItemGetDrawingRgn: doPart --
do (# visRgn: @integer;
		childFrameRgn: @integer;
		asCanvas: ^canvas;
	do getVisibleRgn -> visRgn;
		(visRgn, rgn) -> CopyRgn;
		(if not (visRgn -> EmptyRgn) then
			(if this(windowItem)## <= canvas## then
				this(windowItem)[] -> asCanvas[];
				NewRgn -> childFrameRgn;
				l: asCanvas.private.children.scan
					(#
					do (if current.visible then
							childFrameRgn -> current.setRgnToFrame;
							(rgn, childFrameRgn, rgn) -> DiffRgn;
							(if (rgn -> EmptyRgn) then
								leave l;
							if);
						if);
					#);
				childFrameRgn -> DisposeRgn;
			if);
		if);
	#);