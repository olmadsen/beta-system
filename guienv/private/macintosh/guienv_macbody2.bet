ORIGIN 'guienv_macbody';

-- GUIENVwindowUseTextStyle: descriptor --
(#
do private.windowPointer -> SetPort;
	style.familyID -> TextFont;
	style.textStyleSize -> TextSize;
	style.textStyleFace -> TextFace;
#)

-- GUIENVwindowOnActivate: descriptor --
(# theMenubar: ^menubar;
do windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		globalMacMenubar -> theMenubar.changeMacMenubar;
	if);
	private.windowContents.theEventHandler.onActivate;
	inner onActivate;
#)

-- GUIENVwindowOnDeactivate: descriptor --
(# theMenubar: ^menubar;
do 
	inner onDeactivate;
	private.windowContents.theEventHandler.onDeactivate;
	windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		none -> theMenubar.changeMacMenubar;
	if);
#)

-- GUIENVwindowSetTheMenubar: descriptor --
(#
do theBar[] -> windowMenuBar;
#)

-- GUIENVwindowGetTheMenubar: descriptor --
(#
do windowMenuBar -> theBar[];
#)

-- GUIENVwindowSetFloating: descriptor --
(#
do (* Not implemented !!! *)
#)

-- GUIENVwindowGetFloating: descriptor --
(#
do (* Not implemented !!! *)
#)

-- GUIENVwindowSetTitle: descriptor --
(#
do (private.windowPointer,theTitle) -> SetWTitle;
#)

-- GUIENVwindowGetTitle: descriptor --
(# ps: @pascalString;
do (private.windowPointer,ps[]) -> GetWTitle;
	ps.getText -> theTitle[];
#)

-- GUIENVwindowSetPosition: descriptor --
(#
do (private.windowPointer,pt.h,pt.v,false) -> MoveWindow;
	handleCursor;
#)

-- GUIENVwindowGetPosition: descriptor --
(# r: @rectangle;
do getBounds -> r;
	r.topLeft -> pt;
#)

-- GUIENVwindowSetSize: descriptor --
(#
do invalidateGrowIcon;
	(private.windowPointer,width,height,true) -> SizeWindow;
	(width,height) -> private.windowContents.size;
	invalidateGrowIcon;
	updateCursor;
#)

-- GUIENVwindowGetSize: descriptor --
(# r: @rectangle;
do getBounds -> r;
	r.size -> (width,height);
#)

-- GUIENVwindowSetFrame: descriptor --
(#
do theFrame.topLeft -> position;
	theFrame.size -> size;
#)

-- GUIENVwindowGetFrame: descriptor --
(#
do getBounds -> theFrame;
#)

-- GUIENVwindowInsideRectangle: descriptor --
(#
do (0,0) -> theRectangle.topLeft;
	size -> theRectangle.size;
#)

-- GUIENVshowWindow: descriptor --
(#
do private.windowPointer -> ShowWindow;
	bringToFront;
	true -> windowVisible;
#)

-- GUIENVwindowShowModal: descriptor --
(# doProcessOneEvent: @processOneEvent;
do systemModal -> modalState;
	show;
	loop:
		(if modalState<>modeless then
			doProcessOneEvent;
			restart loop;
		if);
#)

-- GUIENVhideWindow: descriptor --
(#
do private.windowPointer -> HideWindow;
	modeless -> modalState;
	false -> windowVisible;
#)

-- GUIENVwindowSetMaxSize: descriptor --
(#
do (width,height) -> theMaxSize;
#)

-- GUIENVwindowGetMaxSize: descriptor --
(#
do theMaxSize -> (width,height);
#)

-- GUIENVwindowSetMinSize: descriptor --
(#
do (width,height) -> theMinSize;
#)

-- GUIENVwindowGetMinSize: descriptor --
(#
do theMinSize -> (width,height)
#)

-- GUIENVwindowBringToFront: descriptor --
(# BringToFront: External (# theWindow: @Integer; enter theWindow do '$A920' -> PascalTrap; #);
do private.windowPointer -> SelectWindow;
#)

-- GUIENVwindowBringToBack: descriptor --
(#
do (private.windowPointer,0) -> SendBehind;
#)

-- GUIENVwindowBringBehind: descriptor --
(#
do (private.windowPointer,theWindow.private.windowPointer) -> SendBehind;
#)

-- GUIENVwindowUpdate: descriptor --
(#
do processUpdate;
#)

-- GUIENVwindowCreate: descriptor --
(# bounds: @macRect;
do shadows -> style;
	inner create;
	(if private.windowPointer//0 then
		((40,40),(400,500)) -> bounds;
		(0,bounds[],'Title',false,ZoomDocProc, -1, true, 0) -> NewCWindow -> private.windowPointer;
	if);
#)

-- GUIENVwindowOpen: descriptor --
(# aMenubar: ^menubar;
do (20,20) -> theMinSize;
	(1000,1000) -> theMaxSize;
	this(window)[] -> this(guienv).private.windows.append;
	&menubarType[] -> aMenubar[];
	(if aMenubar.struc <= menubar## then
		aMenubar.open;
		aMenubar[] -> theMenubar;
	else
		none -> aMenubar[];
	if);
	private.windowContents.open;
	true -> windowVisible;
	inner open;
	(if windowVisible then
		private.windowPointer -> ShowWindow;
	if);
	updateCursor;
#)

-- GUIENVwindowClose: descriptor --
(#
do hide;
	inner close;
	false -> processActivate;
	private.windowPointer -> CloseWindow;
	this(window)[] -> this(guienv).private.windows.remove;
	updateCursor;
#)

-- GUIENVwindowPutLayout: doPart --
do

-- GUIENVwindowGetLayout: doPart --
do

-- GUIENVwindowSetTarget: descriptor --
(#
do (if windowTarget<>theTarget[] then
		(if windowTarget<>None then
			private.windowTarget.theEventHandler.onDisableTarget;
		if);
		theTarget[] -> windowTarget;
		(if windowTarget<>None then
			private.windowTarget.theEventHandler.onEnableTarget;
		if);
	if);
#)

-- GUIENVwindowGetTarget: descriptor --
(#
do windowTarget -> theTarget[];
#)

-- GUIENVwindowitemOnRefresh: descriptor --
(#
do (if private.visibleFlag then
		(if backGroundStyle <> noneBackGround then
			graphics
				(# width, height: @integer;
				do size -> (width, height);
					(0, 0, width, height) -> EraseRectangle;
				#);
		if);
		(if border.visible then
			(((0, 0), size), border.style) -> drawBorder;
		if);
		inner onRefresh;
	if);
#)

-- GUIENVwindowitemSetFrame: descriptor --
(# oldFrame: @rectangle;
	oldVisibleRgn: @integer;
	newVisibleRgn: @integer;
	onlyResize: @boolean;
do private.windowItemFrame -> oldFrame;
   (oldFrame.top = theFrame.top)
     and 
    (oldFrame.left = theFrame.left) ->  onlyResize;
	(if not (oldFrame -> theFrame.isEqual) then
		(if (private.automaticUpdate and visible) then
			(if (onlyResize and (not private.updateOnResize)) then
				NewRgn -> oldVisibleRgn;
				(if private.clip = 0 then
					exception
						(#
						do 'Accesing NIL clip region' -> msg.append;
						#);
				else
					(private.clip, oldVisibleRgn) -> CopyRgn;
				if);
			else
				update
			if);
		if);
		theFrame -> private.windowItemFrame;
		(if father[] <> none then
			father.calculateFocusForChildren;
		else
			calculateFocus;
		if);	
		(if (private.automaticUpdate and visible) then
			(if (onlyResize and (not private.updateOnResize)) then
				NewRgn -> newVisibleRgn;
				(if private.clip = 0 then
					exception
						(#
						do 'Accesing NIL clip region' -> msg.append;
						#);
				else
					(private.clip, newVisibleRgn) -> CopyRgn;
					(oldVisibleRgn,newVisibleRgn,newVisibleRgn) -> XorRgn;
					oldVisibleRgn -> DisposeRgn;
					newVisibleRgn -> InvalRgn;
					newVisibleRgn -> DisposeRgn;
				if);
			else
				update;
			if);
		if);
		(if father[]<>none then
			(oldFrame,theFrame) -> father.theEventHandler.onChildFrameChanged;
		if);
		(oldFrame,theFrame) -> theEventHandler.onFrameChanged;
	if);
	updateCursor;
#)

-- GUIENVwindowitemGetFrame: descriptor --
(#
do private.windowItemFrame -> theFrame;
#)

-- GUIENVwindowitemSetPosition: descriptor --
(#	r: @rectangle;
	width,height: @integer;
do frame -> r;
	r.size -> (width,height);
	pt -> r.topLeft;
	(width,height) -> r.size;
	r -> frame;
#)

-- GUIENVwindowitemGetPosition: descriptor --
(# r: @rectangle;
do frame -> r;
	r.topleft -> pt;
#)

-- GUIENVwindowitemMove: descriptor --
(# pt: @point;
do position -> pt;
	(dh,dv) -> pt.add;
	pt -> position;
#)

-- GUIENVwindowitemSetSize: descriptor --
(# r: @rectangle;
do frame -> r;
	(width,height) -> r.size;
	r -> frame;
#)

-- GUIENVwindowitemGetSize: descriptor --
(# r: @rectangle;
do frame -> r;
	r.size -> (width,height);
#)

-- GUIENVwindowitemSetVisible: descriptor --
(#
do (if value<>private.visibleFlag then
		value -> private.visibleFlag;
		father.calculateFocus;
		updateMaybe;
		theEventHandler.onVisibleChanged;
		(if this(windowItem)[]//target then
			father[] -> target;
		if);
		updateCursor;
	if);
#)

-- GUIENVwindowitemGetVisible: descriptor --
(#
do private.visibleFlag -> value;
#)

-- GUIENVwindowitemSetHilite: descriptor --
(#
do (if value<>private.hiliteFlag then
		value -> private.hiliteFlag;
		theEventHandler.onHiliteChanged;
	if);
#)

-- GUIENVwindowitemGetHilite: descriptor --
(#
do private.hiliteFlag -> value;
#)

-- GUIENVwindowitemShow: descriptor --
(#
do true -> visible;
#)

-- GUIENVwindowitemHide: descriptor --
(#
do false -> visible;
#)

-- GUIENVwindowitemSetEnabled: descriptor --
(#
do (if value<>private.enabledFlag then
		value -> private.enabledFlag;
		theEventHandler.onEnabledChanged;
	if);
	updateCursor;
#)

-- GUIENVwindowitemGetEnabled: descriptor --
(#
do private.enabledFlag -> value;
#)

-- GUIENVwindowitemEnable: descriptor --
(#
do true -> enabled;
#)

-- GUIENVwindowitemDisable: descriptor --
(#
do false -> enabled;
#)

-- GUIENVwindowitemBorderSetVisible: doPart --
do (if value <> private.borderVisibleFlag then
		value -> private.borderVisibleFlag;
		update;
	if);

-- GUIENVwindowitemBorderGetVisible: doPart --
do private.borderVisibleFlag -> value;

-- GUIENVwindowitemBorderSetStyle: doPart --
do (if value <> private.borderStyle then
		value -> private.borderStyle;
		update;
	if);

-- GUIENVwindowitemBorderGetStyle: doPart --
do private.borderStyle -> value;

-- GUIENVwindowiteminsideRectangle: doPart --
do 
   
-- GUIENVwindowitemSetTheCursor: descriptor --
(#
do theCur[] -> windowItemCursor;
	updateCursor;
#)

-- GUIENVwindowitemGetTheCursor: descriptor --
(#
do windowItemCursor -> theCur[];
#)

-- GUIENVwindowItemTrackMouse: descriptor --
(# GlobalToLocal: External (# p: ^macPoint enter p[] do '$A871' -> PascalTrap; #);
do (if StillDown then
		focus
			(#
				macPt: @macPoint;
				dh,dv: @integer;
			do 
				this(guienv).private.event.where -> macPt;
				macPt[] -> GlobalToLocal;
				macPt.getPoint -> curPt -> prevPt;
				mousePress;
				loop:
					(if StillDown then
						macPt[] -> GetMouse;
						macPt.getPoint -> curPt;
						curPt.h - prevPt.h -> dh;
						curPt.v - prevPt.v -> dv;
						(if ((dh<>0) or (dv<>0)) then
							(dh,dv) -> mouseMove;
						if);
						curPt -> prevPt;
						restart loop;
					if);
				mouseRelease;
				none -> hitWindowItem;
			#);
	if);
#)

-- GUIENVwindowitemDrag: descriptor --
(#
do father.trackMouse
		(# currentFrame: @rectangle;
			drawFrame: @
				(#
				do currentFrame[] -> makeMacRect -> FrameRect;
				#);
			mousePress::<
				(#
				do PenNormal;
					blackColor -> ForeColor;
					whiteColor -> BackColor;
					srcXor -> PenMode;
					frame -> currentFrame;
					drawFrame;
				#);
			mouseMove::<
				(#
				do drawFrame;
					(h,v) -> currentFrame.offset;
					drawFrame;
				#);
			mouseRelease::<
				(#
				do drawFrame;
					currentFrame -> frame;
				#);
		#);
#)

-- GUIENVwindowitemResize: descriptor --
(#
do (* not implemented !!! *)
#)

-- GUIENVwindowitemUpdate: descriptor --
(# 
do 
	focus
		(# r: @rectangle;
		do (if private.clip <> 0 then
				private.clip -> InvalRgn;
			else
				((0, 0), size) -> r;
				r[] -> makeMacRect -> InvalRect;
			if);
		#);
#)

-- GUIENVwindowitemCreate: descriptor --
(# origin: ^object;
do (if this(window).style = plain then
		whiteBackGround -> backGroundStyle
	else
		grayBackGround -> backGroundStyle;
	if);
	inner create;
	(if windowItemMethods = none then
		&defaultMethods[] ->  windowItemMethods;
	if);
	(if father[] = none then
		(if this(windowitem)[] = windowContents then
		else
			this(windowitem)[] -> getOrigin -> origin[];
			l:
			(if origin[] = none then
				windowContents -> father[];
			else 
				(if (origin.struc <= canvas##) then 
					origin[] -> father[];
				else 
					origin[] -> getOrigin -> origin[];
					restart l;
				if)
			if);
		if);
	if);
	
#)

-- GUIENVwindowitemOpen: descriptor --
(#
do (if father[]<>none then
		this(windowitem)[] -> father.private.children.append;
	if);
	((0, 0), (100, 30)) -> private.windowItemFrame;
	NewRgn -> private.clip;
	(if father[] <> none then
		father.calculateFocusForChildren;
	else
		calculateFocus;
	if);
	true -> private.automaticUpdate;
	true -> private.visibleFlag;
	true -> private.enabledFlag;
	true -> private.updateOnResize;
	true -> bindTop;
	true -> bindLeft;
	(if this(window).style = plain then
		borderStyles.simple -> private.borderStyle;
	else
		borderStyles.shadowIn -> private.borderStyle;
	if);
	inner open;
	updateCursor;
#)

-- GUIENVwindowitemClose: descriptor --
(#
do inner close;
	(if this(windowItem)[] = target then
			none -> target;
	if);
	(if private.clip <> 0 then
		private.clip -> DisposeRgn;
	if);
	this(windowitem)[] -> father.private.children.remove;
	updateCursor;
#)

-- GUIENVwindowItemCalculateFocus: doPart --
do (if private.visibleFlag then
		(# theClipRgn, fatherClipRgn: @integer; (* Region Handles *)
			x, y: @integer;
			width, height: @integer;
			fatherOriginX, fatherOriginY: @integer;
			left, right, top, bottom: @integer;
			tmpRgn: @integer;
		do private.clip -> theClipRgn;
			(if father[] = none then
				this(window).size -> (width, height);
				(theClipRgn, 0, 0, width, height) -> SetRectRgn;
				0 -> private.originX;
				0 -> private.originY;
			else
				position -> (x, y);
				father.privateOrigin -> (fatherOriginX, fatherOriginY);
				(x + fatherOriginX, y + fatherOriginY) -> (private.originX, private.originY);
				private.windowItemFrame -> ((left, top), (right, bottom));
				(theClipRgn, left, top, right, bottom) -> SetRectRgn;
			if);
			(if siblingsRgn <> 0 then
				NewRgn -> tmpRgn;
				(theClipRgn, tmpRgn) -> CopyRgn;
				(theClipRgn, siblingsRgn, theClipRgn) -> DiffRgn;
				(siblingsRgn, tmpRgn, siblingsRgn) -> UnionRgn;
				tmpRgn -> DisposeRgn;
			if);
			(if father[] <> none then
				father.privateClip -> fatherClipRgn;
				(fatherClipRgn, theClipRgn, theClipRgn) -> SectRgn;
				(theClipRgn, -x, -y) -> OffsetRgn;
			if);
			
		#);
		inner;
	else
		private.clip -> EmptyRgn;
	if);

-- GUIENVwindowitemFocus: doPart --
do this(window).private.windowPointer -> SetPort;
	(- private.originX, - private.originY) -> SetOrigin;
	(if private.clip <> 0 then
		private.clip -> SetClip;
	else
		this(guienv).private.wideRgn -> SetClip;
	if);
	(if private.backgroundStyle = whiteBackGround then
		this(guienv).private.whitePat -> BackPat;
	else
		this(guienv).private.grayPixPat -> BackPixPat;
	if);
	inner;

-- GUIENVwindowItemFocusVisible: doPart --
do this(window).private.windowPointer -> SetPort;
	(- private.originX, - private.originY) -> SetOrigin;
	this(window).private.windowPointer + 28 -> TOS'%adrGetLong' 
		-> visibleRgn -> getVisibleRgn;
	(if private.backgroundStyle = whiteBackGround then
		this(guienv).private.whitePat -> BackPat;
	else
		this(guienv).private.grayPixPat -> BackPixPat;
	if);
	inner;
	
-- GUIENVwindowitemFocusZero: doPart --

do 
	this(window).private.windowPointer -> SetPort;
	(0,0) -> SetOrigin;
	private.clip -> SetClip;
	(private.originX, private.originY) -> (h,v);
	this(window).private.windowPointer + 28 -> TOS'%adrGetLong' -> windowClip;
	(windowClip, h, v) -> OffsetRgn;
	(if private.backgroundStyle = whiteBackGround then
		this(guienv).private.whitePat -> BackPat;
	else
		this(guienv).private.grayPixPat -> BackPixPat;
	if);
	inner;

-- GUIENVwindowItemFocusEmpty: doPart --
do this(window).private.windowPointer -> SetPort;
	(0, 0) -> SetOrigin;
	this(guienv).private.emptyRgn -> SetClip;
	inner;
	
-- GUIENVwindowItemDefaultHitMethod: descriptor --
(# r: @rectangle;
do frame -> r;
	pt -> r.containsPoint -> value;
#)


-- GUIENVwindowItemdefaultHandleCursorMethod: descriptor --
(# left, top: @integer;
do 
	(if windowItemCursor = none then
		cursors.arrow[] -> mouse.busyCursor;
	else
		windowItemCursor -> mouse.busyCursor;
	if);
	this(guienv).private.cursorRegion -> getVisibleRgn;
	(this(guienv).private.cursorRegion, 
	private.originX, private.originY) -> OffsetRgn;
	this(window).position -> (left, top);
	(this(guienv).private.cursorRegion, left, top) -> OffsetRgn;
#)

-- windowItemLib: attributes --

debugFocus:
	(#	
	do debug
			(#
			do this(windowItem)[] -> getPatternName -> putText;
				' o: ' -> putText;
				(private.originX, private.originY) -> putPoint;
			#);
	#);
processFatherFrameChanged:
	(# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
	enter (oldFrame,newFrame)
	do newFrame.size -> delta;
		oldFrame.size -> delta.subTract;
		(if (0,0) -> delta.isEqual//false then
			frame -> chainRect -> itsFrame;
			delta -> chainRect.offset;
			(if bindLeft//false then
				chainRect.left -> itsFrame.left;
			if);
			(if bindBottom then
				chainRect.bottom -> itsFrame.bottom
			if);
			(if bindRight then
				chainRect.right -> itsFrame.right
			if);
			(if bindTop//false then
				chainRect.top -> itsFrame.top
			if);
			itsFrame -> frame;
		if);
		(oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
	#);
	

-- GUIENVCanvasCalculateFocus: doPart --
do calculateFocusForChildren;
	inner;

-- GUIENVcanvasHandleCursor: doPart --
do inner;

-- GUIENVcanvasPutLayout: doPart --
do

-- GUIENVcanvasGetLayout: doPart --
do

-- GUIENVcanvasOnActivate: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onActivate;
		#);
	inner onActivate;
#)

-- GUIENVcanvasOnDeactivate: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onDeactivate;
		#);
	inner onDeactivate;
#)

-- GUIENVcanvasOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVcanvasOnRefresh: descriptor --
(#
do inner onRefresh;
	scan
		(#
		do current.theEventHandler.onRefresh;
		#);
#)

-- GUIENVcanvasOnMouseUp: descriptor --
(#
do inner onMouseUp;
#)

-- GUIENVcanvasOnFrameChanged: descriptor --
(#
do inner onFrameChanged;
   private.children.scan
		(#
		do (oldFrame,newFrame) -> current.processFatherFrameChanged;
		#);
	
#)

-- GUIENVcanvasSelectionAdd: descriptor --
(#
do (if theWindowitem[] -> private.selection.has//false then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionSet: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;
#)

-- GUIENVcanvasSelectionRemove: descriptor --
(#
do (if theWindowitem[] -> private.selection.has then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionEmpty: descriptor --
(#
do private.selection.empty -> value;
#)

-- GUIENVcanvasSelectionScan: descriptor --
(#
do private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVcanvasSelectionClear: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
#)

-- GUIENVcanvasScan: descriptor --
private.children.scan
(#
do current[] -> this(scan).current[];
	inner scan;
#)

-- GUIENVcanvasCreate: descriptor --
(#
do inner create;
	&canvasMethods[] -> windowItemMethods;
#)

-- GUIENVcanvasOpen: descriptor --
(#
do (* false -> this(windowItem).private.updateOnResize; *)
	(if this(window).style = plain then
		borderStyles.simple -> border.style;
	else
		borderStyles.shadowIn -> border.style;
	if);
	(* true -> border.visible; *)
	inner open;
#)

-- GUIENVcanvasClose: descriptor --
(#
do inner close;
	scan
		(#
		do current.close;
		#);
#)

-- GUIENVcanvasPrintOpenPage: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- GUIENVsharedWindowAddDisplay: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- GUIENVsharedWindowRemoveDisplay: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- cursorLib: attributes --
cursorHandle:
	(#
	enter private.cursorHandle
	exit private.cursorHandle
	#);
readCursorResource:
	(#	id: @integer;
	enter id
	do id -> GetCursor -> cursorHandle;
	#);

-- GUIENVcursorPrivate: descriptor --
(# cursorHandle: @integer;
#)

-- GUIENVtextStyleSetName: descriptor --
(# sr: @shortRef;
do (theName,sr[]) -> GetFNum;
	sr -> familyID;
#)

-- GUIENVtextStyleGetName: descriptor --
(# ps: @pascalString;
do (private.familyID, ps[]) -> GetFontName;
	ps.getText -> theName[];
#)

-- GUIENVtextStyleSetSize: descriptor --
(#
do value -> textStyleSize;
#)

-- GUIENVtextStyleGetSize: descriptor --
(#
do textStyleSize -> value;
#)

-- GUIENVtextStyleSetFace: descriptor --
(#
do value -> textStyleFace;
#)

-- GUIENVtextStyleGetFace: descriptor --
(#
do textStyleFace -> value;
#)

-- GUIENVtextStyleAscent: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent -> value;
#)

-- GUIENVtextStyleDescent: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.descent -> value;
#)

-- GUIENVtextStyleLeading: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.leading -> value;
#)

-- GUIENVtextStyleHeight: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent + info.descent -> value;
#)

-- GUIENVtextStyleMaxChWidth: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.widMax -> value;
#)

-- GUIENVtextStyleWidthOfChar: descriptor --
(#
do withTextStyle
		(#
		do ch -> CharWidth -> value;
		#);
#)

-- GUIENVtextStyleStringWidth: descriptor --
(#
do (if (str[] <> none) and (str.lgth <> 0) then
		withTextStyle
		(#
		do (@@str.T[1],0,str.lgth) -> TextWidth -> value;
		#);
	else
		0 -> value;
	if);
#)

-- GUIENVtextStyleFamilySizes: descriptor --
(#
do (* Not Implemented !!!*)
#)

-- GUIENVTextStyleWithTextStyle: descriptor --
(#	port: @longInt;
do port[] -> GetPort;
	utilityPort -> SetPort;
	familyID -> TextFont;
	textStyleSize -> TextSize;
	textStyleFace -> TextFace;
	inner withTextStyle;
	port -> SetPort;
#)


-- GUIENVclipBoardHasText: descriptor --
(#	length: @integer;
	offset: @longInt;
	TextType: (# exit 1413830740 #);
do (0,TextType,offset[]) -> GetScrap -> length;
	(length >= 0) -> value;
#)

-- GUIENVclipBoardSetText: descriptor --
(# ignore: @integer;
	TextType: (# exit 1413830740 #);
do	ZeroScrap -> ignore;
	(if txt.lgth > 0 then
		(txt.lgth,TextType,@@txt.T[1]) -> PutScrap -> ignore;
	if);
#)

-- GUIENVclipBoardGetText: descriptor --
(#	length: @integer;
	offset: @longInt;
	TextType: (# exit 1413830740 #);
	textHndl: @integer;
	address: @integer;
do 0 -> NewHandle -> textHndl;
	(textHndl,TextType,offset[]) -> GetScrap -> length;
	&text[] -> txt[];
	(if length > 0 then
		length -> txt.extend;
		textHndl -> TOS'%adrGetLong' -> address;
		(address,@@txt.T[1],length) -> BlockMove;
		length -> txt.lgth -> txt.pos;
	if);
	textHndl -> DisposeHandle;
#)

-- GUIENVclipBoardClearContents: descriptor --
(# ignore: @integer;
do	ZeroScrap -> ignore;
#)

-- GUIENVmouseGlobalPosition: descriptor --
(#	event: @eventRecord;
	ignore: @integer;
	macPt: @macPoint;
do	(everyEvent,event[]) -> OSEventAvail -> ignore;
	event.where -> macPt;
	macPt.getPoint -> pt;
#)

-- GUIENVmouseButtonState: descriptor --
(#
do	Button -> value;
#)

-- GUIENVmouseTheCursorSet: descriptor --
(#	g: @globVars;
	h: @integer;
do	(if theCur[] = none then
		g.init;
		g.arrowAddress -> SetCursor;
	else
		(if theCur.cursorHandle//0 then
			g.init;
			g.arrowAddress -> SetCursor;
		else
			theCur.cursorHandle -> h;
			h -> TOS'%adrGetLong' -> SetCursor;
		if);
	if);
#)

-- GUIENVmouseTheCursorGet: descriptor --
(#
do	(* Not implemented !!! *)
#)

-- GUIENVsystemScreenRectangle: descriptor --
(# g: @globVars;
do	g.init;
	g.screenBitsBoundsBR -> theRectangle.bottomRight;
#)

-- GUIENVsystemScreenRgn: descriptor --
(# 
do	(* Not implemented !!! *)
#)

-- GUIENVsystemBeepBody: descriptor --
(#
do	2 -> SysBeep;
#)

-- GUIENVsystemWaitBody: descriptor --
(# ignore: @longInt;
do	(ticks,ignore[]) -> Delay;
#)

-- GUIENVdoSetUp: descriptor --
(# initRegions:
		(#
		do	NewRgn -> cursorRegion;
			NewRgn -> private.emptyRgn;
			NewRgn -> private.wideRgn;
			(private.wideRgn, -32768, -32768, 32766, 32766) 
				-> SetRectRgn;
		#);
	initMenubar:
		(# initAppleMenu:
				(# appleMenuID: (# exit 128 #);
					type: @integer;
				do appleMenuID -> GetMenu -> appleMenu;
					'DRVR' -> toResType -> type;
					(appleMenu,type) -> AppendResMenu;
					(appleMenu,0) -> InsertMenu;
				#);
			aMenubar: ^menuBar;
		do 200 -> lastMenuID;
			initAppleMenu;
			&menuBarType[] -> aMenubar[];
			aMenuBar.open;
			aMenubar[] -> applicationMenubar;
			true -> private.globalMacMenuBar.needsUpdate;
		#);
	consoleStream: stream
		(# consoleWindow: @window
				(#	waitingForInput: @boolean;
					lastPosition: @integer;
					waitForInput:
						(#
						do	
							true -> waitingForInput;
							theTextEditor.contents.length -> lastPosition;
							(lastPosition,lastPosition) -> theTextEditor.contents.selection;
							showModal;
						#);
					theTextEditor: @textEditor
						(#	contentsType::<
								(# eventHandler::<
										(# 
											onBeforeChange::<
												(#
												do waitingForInput and (position >= lastPosition) 
														-> allow -> beeingChanged;
												#);
											beeingChanged: @boolean;
											onKeyDown::<
												(#
												do (if beeingChanged then
														(if ch//13 then
															buffer.clear;
															(lastPosition,length)  -> scanText
																(#
																do ch -> buffer.put;
																#);
															0 -> buffer.setPos;
															false -> waitingForInput;
															consoleWindow.Hide;
														if);
													if);
												#);
										#);
								#);
							open::<
								(#	width,height: @integer;
								do consoleWindow.size -> (width,height);
									((-1,-1),(width+1,height+1)) -> frame;
									true -> bindRight;
									true -> bindBottom;
								#);
						#);
					eventHandler::
						(# onAboutToClose::
								(#
								do	hide;
									false -> okToClose;
								#);
						#);
					open::<
						(#	r: @rectangle;
						do hide;
							system.screenRectangle -> r;
							r.bottom div 2 -> r.top;
							(4,4) -> r.inset;
							r -> frame;
							theTextEditor.open;
							theTextEditor[] -> target;
							'Console Window' -> title;
						#);
					append:
						(# t: ^text;
						enter t[]
						do private.windowPointer -> ShowWindow;
							(theTextEditor.contents.length,theTextEditor.contents.length)
								-> theTextEditor.contents.selection;
							t[] -> theTextEditor.contents.insert;
						#);
				#);
			put::<
				(# t: @text;
				do ch -> t.put;
					t[] -> consoleWindow.append;
				#);
			putText::<
				(#
				do txt[] -> consoleWindow.append;
				#);
			buffer: @text;
			whenInput:
				(# nonBlank: @boolean;
				enter nonBlank
				do loop: 
						(if true then
							(if nonBlank then
								buffer.ScanWhiteSpace;
							if);
							(if buffer.eos
							then
								consoleWindow.waitForInput;
								restart loop;
							else
								inner;
							if);
						if);
				#);
			get::<
				(# 
				do whenInput
						(#
						do buffer.get -> ch;
						#);
				#);
			getAtom::<
				(#
				do true -> whenInput
						(#
						do buffer.getAtom -> txt[];
						#);
				#);
			getLine::<
				(#
				do whenInput
						(#
						do buffer.getLine -> txt[];
						#);
				#);
			eos::<
				(#
				do false -> value;
				#);
			init: (# do buffer.clear;consoleWindow.open; #);
		#);
	initConsole:
		(# theConsole: ^consoleStream;
		do &consoleStream[] -> theConsole[] -> screen[] -> keyBoard[];
			theConsole.init;
		#);
	initUtilityPort:
		(#
		do 108 -> NewPtr -> utilityPort;
			utilityPort -> OpenPort;
		#);
	initCursors:
		(#
		do 1 -> cursors.iBeam.readCursorResource;
			2 -> cursors.cross.readCursorResource;
			3 -> cursors.plus.readCursorResource;
			4 -> cursors.watch.readCursorResource;
		#);
	initPatterns:
		(#	globals: @globVars;
		do globals.init;
			&raster[] -> patterns.black[];
			globals.blackAddress -> patterns.black.copyPatternData;
			
			&raster[] -> patterns.white[];
			globals.whiteAddress -> patterns.white.copyPatternData;
			
			&raster[] -> patterns.dkGray[];
			globals.dkGrayAddress -> patterns.dkGray.copyPatternData;
			
			&raster[] -> patterns.gray[];
			globals.grayAddress -> patterns.gray.copyPatternData;
			
			&raster[] -> patterns.ltGray[];
			globals.ltGrayAddress -> patterns.ltGray.copyPatternData;
			
			128 -> GetPixPat -> private.grayPixPat;
			globals.whiteAddress -> private.whitePat;
		#);
do (* 70 -> makeColor -> private.background[]; *)
	100 -> makeColor -> private.background[];
	
	private.event.init;
	initRegions;
	initMenubar;
	modeless -> modalState;
	initConsole;
	initUtilityPort;
	initCursors;
	initPatterns;
	private.timerQueue.init;
#)

-- GUIENVDoPart: descriptor --
(#
do 
	doSetup;
	inner guienv;
	mainLoop
#)

-- GUIENVactiveWindow: descriptor --
(# windowPointer: @integer;
do	FrontWindow -> windowPointer;
	(if windowPointer//0 then
		none -> theWindow[];
	else
		windowPointer -> private.windows.findBywindowPointer -> theWindow[];
	if);
#)

-- GUIENVwindowsFindBywindowPointer: descriptor --
(#
do	l: scan
		(#
		do (if current.private.windowPointer//windowPointer then
				current[] -> e[];
				leave l;
			if);
		#);
#)

-- GUIENVInterfaceObjectPutLayout: Descriptor --
(#
do (* Not Implemented !!! *)
#)

-- GUIENVsaveRestoreFocus: descriptor --
(#
	currentPort: @longInt;
	currentClip: @integer;
	currentOrigin: @point;
	saveState:
		(#	grafPort: @grafPortRecord;
			bounds: @rectangle;
		do currentPort[] -> GetPort;
			(if currentPort<>0 then
				grafPort.portRectangle -> bounds;
				bounds.topLeft -> currentOrigin;
				NewRgn -> currentClip;
				currentClip -> GetClip;
			if);
		#);
	restoreState:
		(#
		do (if currentPort<>0 then
				currentPort -> SetPort;
				currentOrigin -> SetOrigin;
				currentClip -> SetClip;
				currentClip -> DisposeRgn;
			if);
		#);
do saveState;
	inner saveRestoreFocus;
	restoreState;
#)

-- GUIENVmacMenuBarappend: descriptor --
(#
do (if theMenu[] -> member//false then
		theMenu[] -> menus.append;
		(theMenu.private.handle,0) -> InsertMenu;
		true -> needsUpdate;
	if);
#)

-- GUIENVmacMenuBardelete: descriptor --
(#
do	(if theMenu[] -> member then
		theMenu[] -> menus.at -> menus.delete;
		theMenu.menuID -> DeleteMenu;
		true -> needsUpdate;
	if);
#)

-- GUIENVmacMenuBarmember: descriptor --
(#
do theMenu[] -> menus.has -> value;
#)

-- GUIENVmacMenuBarFindByName: descriptor --
(#
do l: menus.scan
			(#
			do (if current.name -> name.equalNCS then
					current[] -> theMenu[];
					leave l;
				if);
			#);
#)

-- GUIENVmacMenuBarFindByID: descriptor --
(#
do l: menus.scan
			(#
			do (if current.handle//ID then
					current[] -> theMenu[];
					leave l;
				if);
			#);
#)

-- GUIENVmacMenuBarInit: descriptor --
(#
do menus.init;
#)

-- GUIENVmacMenuBarUpdate: descriptor --
(#
do DrawMenuBar;
	false -> needsUpdate;
#)

-- GUIENVwindowGlobalToLocal: doPart --
do debug
		(#
		do	'GlobalToLocal not implemented' -> putText;
		#);

-- GUIENVwindowLocalCoordsToGlobal: doPart --
do debug
		(#
		do	'GlobalToLocal not implemented' -> putText;
		#);

-- TimerQueueInit: doPart --
do	maxInt -> minInterval;

-- TimerQueueInsert: doPart --
do TickCount -> action.time;
	(if action.interval < minInterval then
		action.interval -> minInterval;
	if);
	(if top < R.range then
		top + 1 -> top;
		action[] -> R[top][];
	else
		false -> inserted;
		(for inx: top repeat
			(if R[inx][] = none then
				action[] -> R[inx][];
				true -> inserted;
			if);
		for);
		(if not inserted then
			top -> R.extend;
			top + 1 -> top;
			action[] -> R[top][];
		if);
	if);
					
					
-- TimerQueueDelete: doPart --
do maxInt -> minInterval;
	(for inx: top repeat
		(if R[inx][] <> none then
			(if R[inx][] = action[] then
				none -> R[inx][];
			else
				(if R[inx].interval < minInterval then
					R[inx].interval -> minInterval;
				if);
			if);
		if);
	for);
	
-- TimerQueueScan: doPart --
do (for inx: top repeat
		(if R[inx][] <> none then
			R[inx][] -> current[];
			inner;
		if);
	for);
	
-- TimerQueueExecuteElapsed: doPart --
do maxInt -> minInterval;
	1 -> inx;
	l: (if inx <= top then
			(if R[inx][] <> none then
				R[inx][] -> current[];
				TickCount -> currentTime;
				(if currentTime - current.time > current.interval then
					current;
					TickCount -> currentTime;
					currentTime -> current.time;
				if);
				current.interval - (currentTime - current.time)  -> interval;
				(if interval < minInterval then
					interval -> minInterval;
				if);
			if);
			inx + 1 -> inx;
			restart l;
		if);
	currentTime -> lastVisit;

-- GUIENVcanvasCalculateFocusForChildren: doPart --
do NewRgn -> siblingsRgn;
	private.children.iterateReverse
		(#
		do siblingsRgn -> current.elm.calculateFocus;
		#);
	siblingsRgn -> DisposeRgn;
	
-- GUIENVwindowItemDrawBorder: doPart --
do (#
	   
	   	
	   lightColor: ^color;
	   darkColor: ^color;
	   black: ^color;
	   left, top, right, bottom: @integer;
	   
	do 
		(if private.backGroundStyle = whiteBackGround then
			75 -> makeColor -> lightColor[];
			60 -> makeColor -> darkColor[];
		else
			100 -> makeColor -> lightColor[];
	   	60 -> makeColor -> darkColor[];
		if);
		0 -> makeColor -> black[];
	   r.topLeft -> (left, top);
	   r.bottomRight -> (right, bottom);
	   graphics
		   (# 
		   do (if this(drawborder).style 
		   	//borderStyles.shadowIn then
					black -> pen.foreGroundColor;
					((left, top), (right, bottom)) -> drawRect;
		   		darkColor -> pen.foreGroundColor;
			   	(* ((left, top), (left, bottom - 1)) -> drawLine; *)
			   	(*	((left, top), (right - 1, top)) -> drawLine; *)
			   	((left + 1, top + 1), (left + 1, bottom - 2)) -> drawLine;
			   	((left + 1, top + 1), (right - 2, top + 1)) -> drawLine;
			   	lightColor -> pen.foreGroundColor;
			   	(* ((left + 1, bottom - 1), (right - 1, bottom - 1)) -> drawLine; *)
			   	(* ((right - 1, top + 1), (right - 1, bottom - 1)) -> drawLine; *)
			   	((left + 2, bottom - 2), (right - 2, bottom - 2)) -> drawLine;
			   	((right - 2, top + 2), (right - 2, bottom - 2)) -> drawLine;
			   //borderStyles.shadowOut then
					black -> pen.foreGroundColor;
					((left, top), (right, bottom)) -> drawRect;
		   		lightColor -> pen.foreGroundColor;
			   	(* ((left, top), (left, bottom - 1)) -> drawLine; *)
			   	(* ((left, top), (right - 1, top)) -> drawLine; *)
			   	((left + 1, top + 1), (left + 1, bottom - 2)) -> drawLine;
			   	((left + 1, top + 1), (right - 2, top + 1)) -> drawLine;
			   	darkColor -> pen.foreGroundColor;
			   	(* ((left + 1, bottom - 1), (right - 1, bottom - 1)) -> drawLine; *)
			   	(* ((right - 1, top + 1), (right - 1, bottom - 1)) -> drawLine; *)
			   	((left + 2, bottom - 2), (right - 2, bottom - 2)) -> drawLine;
			   	((right - 2, top + 2), (right - 2, bottom - 2)) -> drawLine;
			   //borderStyles.etchedIn then
			   	darkColor -> pen.foreGroundColor;
			   	((left, top), (right - 1, bottom - 1)) -> drawRect;
			   	lightColor -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 3)) -> drawLine;
			   	((left + 1, top + 1), (right - 3, top + 1)) -> drawLine;
			   	((left, bottom - 1), (right - 1, bottom - 1)) -> drawLine;
			   	((right - 1, top), (right - 1, bottom - 1)) -> drawLine;
			   //borderStyles.etchedOut then
			   	lightColor -> pen.foreGroundColor;
			   	((left, top), (right - 1, bottom - 1)) -> drawRect;
			   	darkColor -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 3)) -> drawLine;
			   	((left + 1, top + 1), (right - 3, top + 1)) -> drawLine;
			   	((left, bottom - 1), (right - 1, bottom - 1)) -> drawLine;
			   	((right - 1, top), (right - 1, bottom - 1)) -> drawLine;
			   //borderStyles.simple then
			   	r -> drawRect;
			   if);
		   #)
	#)
   
-- GUIENVwindowItemGetVisibleRegion: doPart --
do (if private.clip <> 0 then
		(private.clip, rgn) -> CopyRgn;
	else
		(this(guienv).private.emptyRgn, rgn) -> CopyRgn;
	if);
	inner;
	
-- GUIENVcanvasGetVisibleRgn: doPart --
do scan
		(# childVisibleRgn: @integer;
			left, right: @integer;
		do (if current.private.visibleFlag then
				current.private.clip -> childVisibleRgn;
				(if childVisibleRgn <> 0 then
					current.position -> (left, right);
					(childVisibleRgn, left, right) -> OffsetRgn;
					(rgn, childVisibleRgn, rgn) -> DiffRgn;
					(childVisibleRgn, -left, -right) -> OffsetRgn;
				if);
			if);
		#);
	inner;
	
-- GUIENVwindowItemFindHitObject: doPart --
do inner;
	(if hitObject[] = None then
		this(windowItem)[] -> hitObject[];
	if);
	
-- GUIENVcanvasFindHitObject: doPart --
do position -> pt.subtract;
	l: private.children.scanReverse
		(#
		do (if current.visible and current.enabled then
				(if pt -> current.hit then
					pt -> current.findHitObject -> hitObject[];
					leave l;
				if);
			if);
		#);
-- GUIENVwindowItemToScreenCoordinates: doPart --
do (# macPt: @macPoint;
       LocalToGlobal: External (# p: ^macPoint enter p[] do '$A870' -> PascalTrap; #);
	do p -> macPt.setPoint;
		this(window).private.windowPointer -> SetPort;
		(-private.originX, -private.originY) -> SetOrigin;
		macPt[] -> LocalToGlobal;
		macPt.getPoint -> q;
	#);
	
-- MacMenuBarAdjust: doPart --
do menus.iterate
		(#
		do current.elm.adjust;
		#);
