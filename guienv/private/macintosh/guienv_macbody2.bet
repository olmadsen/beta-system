ORIGIN 'guienv_macbody';
INCLUDE '~beta/maclib/v3.1/scrap';

-- GUIENVwindowUseTextStyle: doPart --
do assertOpen;
	private.windowContents.savePort
		(#
		do style.familyID -> TextFont;
			style.textStyleSize -> TextSize;
			style.textStyleFace -> TextFace;
		#);

-- GUIENVwindowOnActivate: doPart --
do 
(# theMenubar: ^menubar;
do windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		globalMacMenubar -> theMenubar.changeMacMenubar;
	if);
	private.windowContents.theEventHandler.onActivate;
	inner onActivate;
#)

-- GUIENVwindowOnDeactivate: doPart --
do
(# theMenubar: ^menubar;
do 
	inner onDeactivate;
	private.windowContents.theEventHandler.onDeactivate;
	windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		none -> theMenubar.changeMacMenubar;
	if);
#)

-- GUIENVwindowSetTheMenubar: doPart --
do assertOpen;
	theBar.assertOpen;
	theBar[] -> windowMenuBar;

-- GUIENVwindowGetTheMenubar: doPart --
do assertOpen;
	windowMenuBar -> theBar[];

-- GUIENVwindowSetTitle: doPart --
do assertOpen;
	(private.windowPointer,theTitle) -> SetWTitle;

-- GUIENVwindowGetTitle: doPart --
do
(# ps: @pascalString;
do assertOpen;
	(private.windowPointer,ps[]) -> GetWTitle;
	ps.getText -> theTitle[];
#)

-- GUIENVwindowSetPosition: doPart --
do assertOpen;
	(private.windowPointer,pt.h,pt.v,false) -> MoveWindow;
	handleCursor;

-- GUIENVwindowGetPosition: doPart --
do
(# r: @rectangle;
do assertOpen;
	getBounds -> r;
	r.topLeft -> pt;
#)

-- GUIENVwindowSetSize: doPart --
do assertOpen;
	(if resizeable then
		invalidateGrowIcon;
	if);
	(private.windowPointer,width,height,false) -> SizeWindow;
	(width,height) -> private.windowContents.size;
	(if resizeable then
		invalidateGrowIcon;
	if);
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);

-- GUIENVwindowGetSize: doPart --
do
(# r: @rectangle;
do assertOpen;
	getBounds -> r;
	r.size -> (width,height);
#)

-- GUIENVwindowSetFrame: doPart --
do assertOpen;	
	theFrame.topLeft -> position;
	theFrame.size -> size;

-- GUIENVwindowGetFrame: doPart --
do assertOpen;
	getBounds -> theFrame;

-- GUIENVwindowInsideRectangle: doPart --
do assertOpen;
	(0,0) -> theRectangle.topLeft;
	size -> theRectangle.size;

-- GUIENVshowWindow: doPart --
do assertOpen;
	private.windowPointer -> ShowTheWindow;
	(* bringToFront; *)
	true -> windowVisible;
	
	(if private.windowContents.privateVisibleRgn <> 0 then
		'It has a visibleRgn' -> putLine;
	if);

-- GUIENVwindowShowModal: doPart --
do
(# doProcessOneEvent: @processOneEvent;
do assertOpen;
	systemModal -> modalState;
	show;
	loop:
		(if modalState<>modeless then
			doProcessOneEvent;
			restart loop;
		if);
#)

-- GUIENVhideWindow: doPart --
do assertOpen;
	private.windowPointer -> HideTheWindow;
	modeless -> modalState;
	false -> windowVisible;
	false -> private.doShow;

-- GUIENVwindowSetMaxSize: doPart --
do assertOpen;
	(width,height) -> theMaxSize;
	(private.windowPointer, width, height) -> SetWindowMaxSize;

-- GUIENVwindowGetMaxSize: doPart --
do assertOpen;
	theMaxSize -> (width,height);

-- GUIENVwindowSetMinSize: doPart --
do assertOpen;
	(width,height) -> theMinSize;

-- GUIENVwindowGetMinSize: doPart --
do assertOpen;
	theMinSize -> (width,height)

-- GUIENVwindowBringToFront: doPart --
do
(# BringToFront: External (# theWindow: @Integer; enter theWindow do '$A920' -> PascalTrap; #);
do assertOpen;
	private.windowPointer -> SelectTheWindow;
#)

-- GUIENVwindowBringToBack: doPart --
do assertOpen;
	(private.windowPointer,0) -> SendBehind;

-- GUIENVwindowBringBehind: doPart --
do assertOpen;
	(private.windowPointer,theWindow.private.windowPointer) -> SendBehind;

-- GUIENVwindowUpdate: doPart --
do assertOpen;
	processUpdate;

-- GUIENVwindowCreate: doPart --
do
(# bounds: @macRect;
	MovableDBoxProc: (# exit 5 #);
	rFloatingWindowProc: (# exit 124 #);
	macType: @integer;
do shadows -> style;
	(if menubarVisible then
		normal -> private.type;
	else
		dialog -> private.type;
	if);
	inner create;
	(if type
		//windowtypes.normal then
			(if resizeable then
				ZoomDocProc -> macType;
			else
				noGrowDocProc -> macType;
			if);
		//windowtypes.dialog then
			movableDBoxProc -> macType;
		//windowtypes.palette then
			rFloatingWindowProc * 16 -> macType;
	if);
	(if private.windowPointer = 0 then
		((40,40),(340,240)) -> bounds;
		(0,bounds[],'Title',false,macType, 0, true, 0) -> NewCWindow -> private.windowPointer;
		(if private.windowPointer = 0 then
			memoryFailure;
		if);
		(private.windowPointer, 56797, 56797, 56797) -> SetWindowBackground;
		
		(if type
			//windowtypes.normal then
				(private.windowPointer, NormalKind) -> SetTheWindowKind;
			//windowtypes.dialog then
				(private.windowPointer, DialogKind) -> SetTheWindowKind;
			//windowtypes.palette then
				(private.windowPointer, ApplicationFloaterKind) -> SetTheWindowKind;
		if);
	if);
#)

-- GUIENVwindowOpen: doPart --
do
(# aMenubar: ^menubarType;
do (64, 64) -> theMinSize;
	(32767,32767) -> theMaxSize;
	this(window)[] -> this(guienv).private.windows.append;
	&menubarType[] -> aMenubar[];
	(if aMenubar## <= menubar## then
		aMenubar.open;
		aMenubar[] -> theMenubar;
	else
		none -> aMenubar[];
	if);
	private.windowContents.open;
	true -> private.doShow;
	inner open;
	(if private.doShow then
		(if type = windowTypes.dialog then
			showModal;
		else
			show;
		if);
	if);
#)

-- GUIENVwindowClose: doPart --
do hide;
	inner close;	
	false -> processActivate;
	private.windowContents.close;
	
	this(window)[] -> this(guienv).private.windows.remove;
	private.windowPointer -> CloseWindow;
	0 -> private.windowPointer;
	false -> private.doShow;
	0 -> private.type;
	0 -> private.style;
	(0, 0) -> private.theMaxSize;
	(0, 0) -> private.theMinSize;
	false -> private.windowActive;
	false -> private.windowVisible;
	NONE -> private.windowTarget[];
	NONE -> private.windowDefaultButton[];
	(if private.windowMenuBar[] <> NONE then
		private.windowMenuBar.close;
		NONE -> private.windowMenuBar[];
	if);
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);


-- GUIENVwindowSetTarget: doPart --
do assertOpen;
	(if windowTarget<>theTarget[] then
		(if windowTarget<>None then
			private.windowTarget.theEventHandler.onDisableTarget;
		if);
		(if theTarget[] <> NONE then
			theTarget.assertOpen;
			(if theTarget.viewable and theTarget.clickable then
				theTarget[] -> windowTarget;
				private.windowTarget.theEventHandler.onEnableTarget;
			else
				notification
					(#
					do	'Setting target to ' -> msg.putText;
						theTarget[] -> getPatternName -> msg.putText;
						', which is ' -> msg.putText;
						(if false
							//theTarget.viewable then
								' invisible' -> msg.putLine;
							//theTarget.enabled then
								' disabled' -> msg.putLine;
						if);
					#);
				NONE -> windowTarget;
			if);
		else
			NONE -> windowTarget;
		if);
	if);

-- GUIENVwindowGetTarget: doPart --
do assertOpen;
	windowTarget -> theTarget[];

-- GUIENVwindowitemOnRefresh: doPart --
do (if private.visibleFlag then
	   (if not private.isFigureItem then
			standardGraphics
				(# width, height: @integer;
				do 
					(if this(windowItem).private.eraseWhenUpdating then
						size -> (width, height);
						(0, 0, width, height) -> EraseRectangle;
					if);
					INNER onRefresh;
					ResetPen;
					(if border.visible then
						(((0, 0), size), border.style) -> drawBorder;
					if);
					(if hilite then
						(if NOT this(windowItem).private.specialHilite then
							this(guienv).private.hiliteColor -> pen.foreGroundColor;
							2 -> pen.size;
							(if border.visible then
								((2, 2), (width - 2, height - 2)) -> drawRect;
							else
								((0, 0), (width, height)) -> drawRect;
							if);
						if);
					if);
				#);
		else
			INNER;
		if);
	if);
	


-- GUIENVwindowitemSetFrame: doPart --
do
(# oldFrame: @rectangle;

   doUpdate: booleanValue
		(#
		do viewable 
		   AND THIS(window).private.windowVisible
			AND NOT THIS(window).private.disableUpdate -> value;
		#);

do assertOpen;
	private.left -> oldFrame.left;
	private.top -> oldFrame.top;
	private.right -> oldFrame.right;
	private.bottom -> oldFrame.bottom;
	(if not (theFrame -> oldFrame.isEqual) then
		(if private.isFigureItem then
			invalFrame;
			theFrame.left -> private.left;
			theFrame.right -> private.right;
			theFrame.top -> private.top;
			theFrame.bottom -> private.bottom;
			calculateOrigin;
			invalFrame;
		else
			(if doUpdate  then
				invalVisibleRgn;
				true -> forgetVisibleRgn;
				theFrame.left -> private.left;
				theFrame.right -> private.right;
				theFrame.top -> private.top;
				theFrame.bottom -> private.bottom;
				calculateOrigin;
				invalVisibleRgn;
			else
				(if THIS(window).private.windowVisible then
					true -> forgetVisibleRgn;
				if);
				theFrame -> privateWindowItemFrame;
				calculateOrigin;
			if);
		if);
		(if father[]<>none then
			(oldFrame,theFrame) -> father.theEventHandler.onChildFrameChanged;
		if);
		(oldFrame,theFrame) -> theEventHandler.onFrameChanged;
	if);
#)

(*

-- GUIENVwindowitemSetFrame: doPart --
do
(# oldFrame: @rectangle;
	oldVisibleRgn: @integer;
	newVisibleRgn: @integer;
	onlyResize: @boolean;
do assertOpen;
	private.left -> oldFrame.left;
	private.top -> oldFrame.top;
	private.right -> oldFrame.right;
	private.bottom -> oldFrame.bottom;
   (oldFrame.top = theFrame.top)
     and 
    (oldFrame.left = theFrame.left) ->  onlyResize;
	(if not (oldFrame -> theFrame.isEqual) then
		(if shouldUpdate then
			(if (onlyResize and (not private.updateOnResize)) then
				NewRgn -> oldVisibleRgn;
				(if private.clip = 0 then
					exception
						(#
						do 'Accesing NIL clip region' -> msg.append;
						#);
				else
					(private.clip, oldVisibleRgn) -> CopyRgn;
				if);
			else
				updateMaybe;
			if);
		if);
		theFrame -> privateWindowItemFrame;
		(if shouldUpdate then
			(if (onlyResize and (not private.updateOnResize)) then
				NewRgn -> newVisibleRgn;
				(if private.clip = 0 then
					exception
						(#
						do 'Accesing NIL clip region' -> msg.append;
						#);
				else
					(private.clip, newVisibleRgn) -> CopyRgn;
					(oldVisibleRgn,newVisibleRgn,newVisibleRgn) -> XorRgn;
					oldVisibleRgn -> DisposeRgn;
					newVisibleRgn -> InvalRgn;
					newVisibleRgn -> DisposeRgn;
				if);
			else
				updateMaybe;
			if);
		if);
		(if father[]<>none then
			(oldFrame,theFrame) -> father.theEventHandler.onChildFrameChanged;
		if);
		(oldFrame,theFrame) -> theEventHandler.onFrameChanged;
	if);
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);
#)

*)


-- GUIENVwindowitemGetFrame: doPart --
do assertOpen;
	private.left -> theFrame.left;
	private.top -> theFrame.top;
	private.right -> theFrame.right;
	private.bottom -> theFrame.bottom;

-- GUIENVwindowitemSetPosition: doPart --
do

(#	r: @rectangle;
	width,height: @integer;
do assertOpen;
	frame -> r;
	r.size -> (width,height);
	pt -> r.topLeft;
	(width,height) -> r.size;
	r -> frame;
#)

-- GUIENVwindowitemGetPosition: doPart --
do
(# r: @rectangle;
do assertOpen;
	frame -> r;
	r.topleft -> pt;
#)

-- GUIENVwindowitemMove: doPart --
do
(# pt: @point;
do assertOpen;
	position -> pt;
	(dh,dv) -> pt.add;
	pt -> position;
#)

-- GUIENVwindowitemSetSize: doPart --
do
(# r: @rectangle;
do assertOpen;
	frame -> r;
	(width,height) -> r.size;
	r -> frame;
#)

-- GUIENVwindowitemGetSize: doPart --
do
(# r: @rectangle;
do assertOpen;
	frame -> r;
	r.size -> (width,height);
#)

-- GUIENVwindowitemSetVisible: doPart --
do assertOpen;
	(if value<>private.visibleFlag then
		(if private.visibleFlag then
			updateMaybe;
		if);
		value -> private.visibleFlag;
		(if  THIS(window).private.windowVisible then
			true -> forgetVisibleRgn;
		if);
		theEventHandler.onVisibleChanged;
		(if private.visibleFlag then
			updateMaybe;
		if);
		(if this(windowItem)[] = target then
			father[] -> target;
		if);
		(if THIS(window).private.windowVisible then
			updateCursor;
		if);
	if);

-- GUIENVwindowitemGetVisible: doPart --
do assertOpen;
	private.visibleFlag -> value;

-- GUIENVwindowitemSetHilite: doPart --
do assertOpen;
	(if value<>private.hiliteFlag then
		value -> private.hiliteFlag;
		theEventHandler.onHiliteChanged;
		updateMaybe;
	if);

-- GUIENVwindowitemGetHilite: doPart --
do assertOpen;
	private.hiliteFlag -> value;

-- GUIENVwindowitemShow: doPart --
do assertOpen;
	true -> visible;
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);

-- GUIENVwindowitemHide: doPart --
do assertOpen;
	false -> visible;
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);

-- GUIENVwindowitemSetEnabled: doPart --
do assertOpen;
	(if value<>private.enabledFlag then
		value -> private.enabledFlag;
		theEventHandler.onEnabledChanged;
		updateMaybe;
	if);
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);

-- GUIENVwindowitemGetEnabled: doPart --
do assertOpen;
	private.enabledFlag -> value;

-- GUIENVwindowitemEnable: doPart --
do assertOpen;
	true -> enabled;

-- GUIENVwindowitemDisable: doPart --
do assertOpen;
	false -> enabled;

-- windowItemEnterBackgroundColor: doPart --
do assertOpen;
   theColor -> private.background;
	updateMaybe;
	
-- windowItemExitBackgroundColor: doPart --
do assertOpen;
   private.background -> theColor;
	
-- GUIENVwindowitemBorderSetVisible: doPart --
do assertOpen;
	(if value <> private.borderVisibleFlag then
		value -> private.borderVisibleFlag;
		updateMaybe;
	if);

-- GUIENVwindowitemBorderGetVisible: doPart --
do assertOpen;
	private.borderVisibleFlag -> value;

-- GUIENVwindowitemBorderSetStyle: doPart --
do assertOpen;
	(if value <> private.borderStyle then
		value -> private.borderStyle;
		updateMaybe;
	if);

-- GUIENVwindowitemBorderGetStyle: doPart --
do assertOpen;
	private.borderStyle -> value;

-- GUIENVwindowiteminsideRectangle: doPart --
do assertOpen;
	((0, 0), size) -> theRectangle;
	(if border.visible then
   	(2, 2) -> theRectangle.inset;
	if);
	
-- GUIENVwindowitemSetTheCursor: doPart --
do assertOpen;
	theCur[] -> windowItemCursor;
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);

-- GUIENVwindowitemGetTheCursor: doPart --
do assertOpen;
	windowItemCursor -> theCur[];

-- GUIENVwindowItemTrackMouse: doPart --
do
(# GlobalToLocal: External 
		(# p: ^macPoint enter p[] do '$A871' -> PascalTrap; #);
	
	GetLocalPosition: @setupPort
		(# x, y: @integer;
		do macPt[] -> GetMouse;
			macPt.getPoint -> (x, y);
		exit (x, y)
		#);
	savedPort: @LongInt;
	oriX, oriY: @longInt;
	macPt: @macPoint;
	dh,dv: @integer;
	x, y: @integer;
do assertOpen;
	(if StillDown then
		this(guienv).private.event.where -> macPt;
		setupPort
			(#
			do macPt[] -> GlobalToLocal;
			#);
		macPt.getPoint -> curPt -> prevPt;
		mousePress;
		loop:
			(if StillDown then
				GetLocalPosition -> curPt;
				curPt.h - prevPt.h -> dh;
				curPt.v - prevPt.v -> dv;
				(if ((dh<>0) or (dv<>0)) then
					(dh,dv) -> mouseMove;
				if);
				curPt -> prevPt;
				restart loop;
			if);
		mouseRelease;
		false -> sendOnMouseUp;
	if);
#)

-- GUIENVwindowitemDrag: doPart --
do assertOpen;
	true -> father.setupPortForDrawing
	(#
	do father.trackMouse
			(# currentFrame: @rectangle;
				drawFrame: @
					(#
					do currentFrame[] -> makeMacRect -> FrameRect;
					#);
				mousePress::<
					(#
					do PenNormal;
						blackColor -> ForeColor;
						whiteColor -> BackColor;
						srcXor -> PenMode;
						frame -> currentFrame;
						drawFrame;
					#);
				mouseMove::<
					(#
					do drawFrame;
						(h,v) -> currentFrame.offset;
						drawFrame;
					#);
				mouseRelease::<
					(#
					do drawFrame;
						currentFrame -> frame;
					#);
			#);
	#);

-- GUIENVwindowitemResize: doPart --
do assertOpen;
	true -> father.setupPortForDrawing
	(#
	do father.trackMouse
			(# currentFrame: @rectangle;
				drawFrame: @
					(#
					do currentFrame[] -> makeMacRect -> FrameRect;
					#);
				mousePress::<
					(#
					do PenNormal;
						blackColor -> ForeColor;
						whiteColor -> BackColor;
						srcXor -> PenMode;
						frame -> currentFrame;
						drawFrame;
					#);
				mouseMove::<
					(# 
					do drawFrame;
						(currentFrame.right + h, currentFrame.left + 1) 
							-> MAX 
							-> currentFrame.right;
						(currentFrame.bottom + v, currentFrame.top + 1) 
							-> MAX 
							-> currentFrame.bottom;
						drawFrame;
					#);
				mouseRelease::<
					(#
					do drawFrame;
						currentFrame -> frame;
					#);
			#);
	#);


-- GUIENVwindowitemUpdate: doPart --
do assertOpen;
	(if private.isFigureItem then
		invalFrame;
	else
		invalVisibleRgn;
	if);
	(if immediate then
		THIS(window).private.windowPointer -> BeginUpdate;
		theEventHandler.onRefresh;
		drawDefaultButton;
		(if resizeable then
			drawGrow;
		if);
		THIS(window).private.windowPointer -> EndUpdate;
	if);

-- GUIENVwindowitemCreate: doPart --
do
(# origin: ^object;
do (if this(window).style = plain then
		whiteBackGround -> backGroundStyle
	else
		grayBackGround -> backGroundStyle;
	if);
	inner create;
	(if father[] = none then
		(if this(windowitem)[] = windowContents then
		else
			this(windowitem)[] -> getOrigin -> origin[];
			l:
			(if origin[] = none then
				windowContents -> father[];
			else 
				(if (origin## <= canvas##) then 
					origin[] -> father[];
				else 
					origin[] -> getOrigin -> origin[];
					restart l;
				if)
			if);
		if);
	if);
	this(guienv).private.gray[2] -> private.background;
#)

-- GUIENVwindowitemOpen: doPart --
do 
	(if father[]<>none then
		(if private.isFigureItem then
			this(windowitem)[] -> father.private.figs.append;
		else
			this(windowitem)[] -> father.private.children.append;
		if);
	if);
	

	((0, 0), (100, 30)) -> privateWindowItemFrame;
	true -> private.automaticUpdate;
	true -> private.visibleFlag;
	true -> private.enabledFlag;
	true -> private.updateOnResize;
	true -> private.eraseWhenUpdating;
	true -> bindTop;
	true -> bindLeft;
	(if this(window).style = plain then
		borderStyles.simple -> private.borderStyle;
	else
		borderStyles.shadowIn -> private.borderStyle;
	if);
	(if THIS(window).private.windowVisible then
		brotherForgetVisibleRgn;
	if);
	inner open;
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);
	

-- GUIENVwindowitemClose: doPart --
do updateMaybe;
	(if this(windowItem)[] = target then
		none -> target;
	if);
	inner close;
	(if father[] <> NONE then
		(if private.isFigureItem then
			this(windowitem)[] -> father.private.figs.remove;
		else
			(if THIS(window).private.windowVisible then
				forgetVisibleRgn;
			if);
			this(windowitem)[] -> father.private.children.remove;
		if);
		NONE -> father[];
	if);
	0 -> private.originX;
	0 -> private.originY;
	false -> private.visibleFlag;
	false -> private.automaticUpdate;
	false -> private.enabledFlag;
	false -> private.updateOnResize;
	false -> private.eraseWhenUpdating;
	false -> private.hiliteFlag;
	false -> bindTop;
	false -> bindLeft;
	0 -> private.backGroundStyle;
	0 -> private.left;
	0 -> private.right;
	0 -> private.top;
	0 -> private.bottom;
	0 -> private.borderStyle;
	NONE -> private.windowItemCursor[];
	(if THIS(window).private.windowVisible then
		updateCursor;
	if);
                                                                    
	
-- GUIENVwindowItemHit: doPart --
do (pt.h >= private.left) AND (pt.h < private.right) 
		AND 
	(pt.v >= private.top) AND (pt.v < private.bottom) -> value;
	

-- GUIENVwindowItemHandleCursor: doPart --
do 
(# left, top: @integer;
	visRgn: @integer;
do 
	(if windowItemCursor = none then
		cursors.arrow[] -> mouse.busyCursor;
	else
		windowItemCursor -> mouse.busyCursor;
	if);
	this(guienv).private.cursorRegion -> getDrawingRgn;
	this(window).position -> (left, top);
	(this(guienv).private.cursorRegion, left, top) -> OffsetRgn;
#)

-- windowItemLib: attributes --

setRgnToFrame:
	(# rgn: @integer;
		left, top, right, bottom: @integer;
	enter	rgn
	do private.originX -> left;
		private.originY -> top;
		private.originX + (private.right -  private.left) -> right;
		private.originY + (private.bottom - private.top) -> bottom;
		(rgn, left, top, right, bottom) -> SetRectRgn;
	#);

processFatherFrameChanged:
	(# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
	enter (oldFrame,newFrame)
	do newFrame.size -> delta;
		oldFrame.size -> delta.subTract;
		(if not ((0,0) -> delta.isEqual) then
			frame -> chainRect -> itsFrame;
			delta -> chainRect.offset;
			(if not bindLeft then
				chainRect.left -> itsFrame.left;
			if);
			(if bindBottom then
				chainRect.bottom -> itsFrame.bottom
			if);
			(if bindRight then
				chainRect.right -> itsFrame.right
			if);
			(if not bindTop then
				chainRect.top -> itsFrame.top
			if);
			itsFrame -> frame;
		if);
		(oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
	#); 
	


-- GUIENVcanvasOnActivate: doPart --
do scan
		(#
		do current.theEventHandler.onActivate;
		#);
	inner onActivate;

-- GUIENVcanvasOnDeactivate: doPart --
do scan
		(#
		do current.theEventHandler.onDeactivate;
		#);
	inner onDeactivate;

-- GUIENVcanvasOnMouseDown: doPart --
do inner onMouseDown;

-- GUIENVcanvasOnRefresh: doPart --
do inner onRefresh;
	scan
		(#
		do (if current.visible then
		     (if NOT (current.getVisibleRgn -> EmptyRgn) then
					current.theEventHandler.onRefresh;
				if);
			if);
		#);

-- GUIENVcanvasOnVisibleChanged: doPart --
do scan
		(#
		do (if current.visible then
				current.theEventHandler.onVisibleChanged;
			if);
		#);
	INNER;
	
-- GUIENVcanvasOnMouseUp: doPart --
do inner onMouseUp;

-- GUIENVcanvasOnFrameChanged: doPart --
do inner onFrameChanged;
   scan
		(#
		do (oldFrame,newFrame) -> current.processFatherFrameChanged;
		#);

-- GUIENVcanvasSelectionAdd: doPart --
do assertOpen;
	theWindowitem.assertOpen;
	(if not (theWindowitem[] -> private.selection.has) then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);

-- GUIENVcanvasSelectionSet: doPart --
do assertOpen;
	theWindowItem.assertOpen;
	private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;

-- GUIENVcanvasSelectionRemove: doPart --
do assertOpen;
	theWindowitem.assertOpen;
	(if theWindowitem[] -> private.selection.has then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);

-- GUIENVcanvasSelectionEmpty: doPart --
do assertOpen;
	private.selection.empty -> value;

-- GUIENVcanvasSelectionScan: doPart --
do assertOpen;
	private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);

-- GUIENVcanvasSelectionClear: doPart --
do assertOpen;
	private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);

-- GUIENVcanvasScan: doPart --
do assertOpen;
	private.figs.scan
	(#
	do current[] -> this(scan).current[];
		inner scan;
	#);
	private.children.scan
	(#
	do current[] -> this(scan).current[];
		inner scan;
	#)

-- GUIENVcanvasCreate: doPart --
do inner create;

-- GUIENVcanvasOpen: doPart --
do 
	(if this(window).style = plain then
		borderStyles.simple -> border.style;
	else
		borderStyles.shadowIn -> border.style;
	if);
	private.children.init;
	private.figs.init;
	inner open;

-- GUIENVcanvasClose: doPart --
do inner close;
	scan
		(#
		do current.close;
		#);
	private.children.clear;
	private.figs.clear;



-- cursorLib: attributes --
cursorHandle:
	(#
	enter private.cursorHandle
	exit private.cursorHandle
	#);
readCursorResource:
	(#	id: @integer;
	enter id
	do id -> GetCursor -> cursorHandle;
	#);

-- GUIENVcursorPrivate: descriptor --
(# cursorHandle: @integer;
#)

-- GUIENVtextStyleSetName: doPart --
do
(# sr: @shortRef;
do (theName,sr[]) -> GetFNum;
	sr -> familyID;
#)

-- GUIENVtextStyleGetName: doPart --
do
(# ps: @pascalString;
do (private.familyID, ps[]) -> GetFontName;
	ps.getText -> theName[];
#)

-- GUIENVtextStyleSetSize: doPart --
do value -> textStyleSize;

-- GUIENVtextStyleGetSize: doPart --
do textStyleSize -> value;

-- GUIENVtextStyleSetFace: doPart --
do value -> textStyleFace;

-- GUIENVtextStyleGetFace: doPart --
do textStyleFace -> value;

-- GUIENVtextStyleAscent: doPart --
do
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent -> value;
#)

-- GUIENVtextStyleDescent: doPart --
do
(# info: ^FontInfo;
do getInfo -> info[];
	info.descent -> value;
#)

-- GUIENVtextStyleLeading: doPart --
do
(# info: ^FontInfo;
do getInfo -> info[];
	info.leading -> value;
#)

-- GUIENVtextStyleHeight: doPart --
do
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent + info.descent -> value;
#)

-- GUIENVtextStyleMaxChWidth: doPart --
do
(# info: ^FontInfo;
do getInfo -> info[];
	info.widMax -> value;
#)

-- GUIENVtextStyleWidthOfChar: doPart --
do withTextStyle
		(#
		do ch -> CharWidth -> value;
		#);

-- GUIENVtextStyleStringWidth: doPart --
do withTextStyle
		(#
		do str[] -> GetTextWidth -> value;
		#);

-- GUIENVtextStyleFamilySizes: doPart --
do exception
     (# do 'textstyle.familysizes are not implemented' -> msg.append; #);

-- GUIENVTextStyleWithTextStyle: doPart --
do
(#	port: @longInt;
do port[] -> GetPort;
	utilityPort -> SetPort;
	familyID -> TextFont;
	textStyleSize -> TextSize;
	textStyleFace -> TextFace;
	inner withTextStyle;
	port -> SetPort;
#)


-- GUIENVclipBoardHasText: doPart --
do
(#	length: @integer;
	offset: @longInt;
	TextType: (# exit 1413830740 #);
do (0,TextType,offset[]) -> GetScrap -> length;
	(length >= 0) -> value;
#)

-- GUIENVclipBoardSetText: doPart --
do
(# ignore: @integer;
do	ZeroScrap -> ignore;
	(if txt.lgth > 0 then
		(txt[],'TEXT') -> PutTextScrap;
	if);
#)

-- GUIENVclipBoardGetText: doPart --
do
(#	
do 'TEXT' -> GetScrapAsText -> txt[];
#)

-- GUIENVclipBoardClearContents: doPart --
do
(# ignore: @integer;
do	ZeroScrap -> ignore;
#)

-- GUIENVmouseGlobalPosition: doPart --
do
(#	event: @eventRecord;
	ignore: @boolean;
	macPt: @macPoint;
do	(everyEvent,event[]) -> OSEventAvail -> ignore;
	event.where -> macPt;
	macPt.getPoint -> pt;
#)

-- GUIENVmouseButtonState: doPart --
do	(if Button then
		1 -> value;
	else
		0 -> value;
	if);

-- GUIENVmouseTheCursorSet: doPart --
do
(#	g: @globVars;
	h: @integer;
do	(if theCur[] = none then
		g.init;
		g.arrowAddress -> SetCursor;
	else
		(if theCur.cursorHandle//0 then
			g.init;
			g.arrowAddress -> SetCursor;
		else
			theCur.cursorHandle -> h;
			h -> TOS'%adrGetLong' -> SetCursor;
		if);
	if);
#)

-- GUIENVmouseTheCursorGet: doPart --
do	exception
    (# do 'mouse.cursorget is not implemented' -> msg.append #);
-- GUIENVsystemScreenRectangle: doPart --
do
(# g: @globVars;
do	g.init;
	g.screenBitsBoundsBR -> theRectangle.bottomRight;
#)

-- GUIENVsystemScreenRgn: doPart --
do	exception
    (# do 'system.screenrgn is not implemented' -> msg.append #);

-- GUIENVsystemBeepBody: doPart --
do	2 -> SysBeep;

-- GUIENVsystemWaitBody: doPart --
do
(# ignore: @longInt;
do	(ticks,ignore[]) -> Delay;
#)

-- GUIENVdoSetUp: descriptor --
(# initRegions:
		(#
		do	NewRgn -> cursorRegion;
			NewRgn -> private.emptyRgn;
			NewRgn -> private.wideRgn;
			(private.wideRgn, -32768, -32768, 32766, 32766) 
				-> SetRectRgn;
		#);
	initMenubar:
		(# initAppleMenu:
				(# appleMenuID: (# exit 128 #);
					type: @integer;
				do appleMenuID -> GetMenu -> appleMenu;
					'DRVR' -> toResType -> type;
					(appleMenu,type) -> AppendResMenu;
					(appleMenu,0) -> InsertMenu;
				#);
			aMenubar: ^menuBarType;
		do 200 -> lastMenuID;
			initAppleMenu;
			&menuBarType[] -> aMenubar[];
			aMenuBar.open;
			aMenubar[] -> applicationMenubar;
			true -> private.globalMacMenuBar.needsUpdate;
		#);
	consoleStream: stream
		(# consoleWindow: @window
				(#	waitingForInput: @boolean;
					lastPosition: @integer;
					waitForInput:
						(#
						do	
							true -> waitingForInput;
							theTextEditor.contents.length -> lastPosition;
							(lastPosition,lastPosition) -> theTextEditor.contents.selection;
							showModal;
						#);
					theTextEditor: @textEditor
						(#	contentsType::<
								(# eventHandler::<
										(# 
											onBeforeChange::<
												(#
												do waitingForInput and (position >= lastPosition) 
														-> allow -> beeingChanged;
												#);
											beeingChanged: @boolean;
											onKeyDown::<
												(#
												do (if beeingChanged then
														(if ch//13 then
															buffer.clear;
															(lastPosition,length)  -> scanText
																(#
																do ch -> buffer.put;
																#);
															0 -> buffer.setPos;
															false -> waitingForInput;
															consoleWindow.Hide;
														if);
													if);
												#);
										#);
								#);
							open::<
								(#	width,height: @integer;
								do consoleWindow.size -> (width,height);
									(* ((-1,-1),(width+1,height+1)) -> frame; *)
									(width, height) -> size;
									true -> bindRight;
									true -> bindBottom;
								#);
						#);
					eventHandler::
						(# onAboutToClose::
								(#
								do	hide;
									false -> okToClose;
								#);
						#);
					open::<
						(#	r: @rectangle;
						do hide;
							system.screenRectangle -> r;
							r.bottom div 2 -> r.top;
							(4,4) -> r.inset;
							r -> frame;
							theTextEditor.open;
							theTextEditor.contents[] -> target;
							'Console Window' -> title;
						#);
					append:
						(# t: ^text;
						enter t[]
						do private.windowPointer -> ShowTheWindow;
							true -> windowVisible;
							(theTextEditor.contents.length,theTextEditor.contents.length)
								-> theTextEditor.contents.selection;
							t[] -> theTextEditor.contents.insert;
						#);
				#);
			put::<
				(# t: ^text;
				do &text[] -> t[];
					ch -> t.put;
					t[] -> consoleWindow.append;
				#);
			putText::<
				(#
				do txt[] -> consoleWindow.append;
				#);
			buffer: @text;
			whenInput:
				(# nonBlank: @boolean;
				enter nonBlank
				do loop: 
						(if true then
							(if nonBlank then
								buffer.ScanWhiteSpace;
							if);
							(if buffer.eos
							then
								consoleWindow.waitForInput;
								restart loop;
							else
								inner;
							if);
						if);
				#);
			get::<
				(# 
				do whenInput
						(#
						do buffer.get -> ch;
						#);
				#);
			getAtom::<
				(#
				do true -> whenInput
						(#
						do buffer.getAtom -> txt[];
						#);
				#);
			getLine::<
				(#
				do whenInput
						(#
						do buffer.getLine -> txt[];
						#);
				#);
			eos::<
				(#
				do false -> value;
				#);
			init: (# do buffer.clear;consoleWindow.open; #);
		#);
	fileConsole: stream
		(#	f: @file;
			init:
				(#
				do 'beta-stdout' -> f.name;
					f.openWrite;
				#);
			put::
				(#
				do ch -> f.put;
					f.flush;
				#);
		    puttext::
			 	(#
				do txt[] -> f.putText;
					f.flush;
				#);
		#);
		
	initConsole:
		(# theConsole: ^consoleStream;
			theFileConsole: ^fileConsole;
		do (if true then
				&fileConsole[] -> theFileConsole[] -> screen[] -> keyBoard[];
				theFileConsole.init;
			else
				&consoleStream[] -> theConsole[] -> screen[] -> keyBoard[];
				theConsole.init;
			if);
		#);
	initUtilityPort:
		(#
		do 108 -> NewPtr -> utilityPort;
			utilityPort -> OpenCPort;
		#);
	initCursors:
		(#
		do 1 -> cursors.iBeam.readCursorResource;
			2 -> cursors.cross.readCursorResource;
			3 -> cursors.plus.readCursorResource;
			4 -> cursors.watch.readCursorResource;
		#);
	initPatterns:
		(#	
		do private.globals.init;
			&pixmap[] -> patterns.black[];
			private.globals.blackAddress -> patterns.black.copyPatternData;
			
			&pixmap[] -> patterns.white[];
			private.globals.whiteAddress -> patterns.white.copyPatternData;
			
			&pixmap[] -> patterns.dkGray[];
			private.globals.dkGrayAddress -> patterns.dkGray.copyPatternData;
			
			&pixmap[] -> patterns.gray[];
			private.globals.grayAddress -> patterns.gray.copyPatternData;
			
			&pixmap[] -> patterns.ltGray[];
			private.globals.ltGrayAddress -> patterns.ltGray.copyPatternData;
			
			128 -> GetPixPat -> private.grayPixPat;
			private.globals.whiteAddress -> private.whitePat;
		#);
do private.event.init;
	initRegions;
	initMenubar;
	modeless -> modalState;
	initPatterns;
	initUtilityPort;
	initCursors;
	private.timerQueue.init;
	private.initColors;
	installCoreEventhandlers;
	initConsole;

#)

-- GUIENVDoPart: doPart --
do 
	doSetup;
	inner guienv;
	mainLoop

-- GUIENVactiveWindow: doPart --
do
(# windowPointer: @integer;
do	FrontNonFloatingWindow -> windowPointer;
	(if windowPointer//0 then
		none -> theWindow[];
	else
		windowPointer -> private.windows.findBywindowPointer -> theWindow[];
	if);
#)

-- GUIENVwindowsFindBywindowPointer: doPart --
do	l: scan
		(#
		do (if current.private.windowPointer = windowPointer then
				current[] -> e[];
				leave l;
			if);
		#);


-- GUIENVmacMenuBarappend: doPart --
do (if not (theMenu[] -> member) then
		theMenu[] -> menus.append;
		(theMenu.private.handle,0) -> InsertMenu;
		true -> needsUpdate;
	if);

-- GUIENVmacMenuBardelete: doPart --
do	(if theMenu[] -> member then
		theMenu[] -> menus.at -> menus.delete;
		theMenu.menuID -> DeleteMenu;
		true -> needsUpdate;
	if);

-- GUIENVmacMenuBarmember: doPart --
do theMenu[] -> menus.has -> value;

-- GUIENVmacMenuBarFindByName: doPart --
do l: menus.scan
			(#
			do (if current.name -> name.equalNCS then
					current[] -> theMenu[];
					leave l;
				if);
			#);

-- GUIENVmacMenuBarFindByID: doPart --
do l: menus.scan
			(#
			do (if current.handle//ID then
					current[] -> theMenu[];
					leave l;
				if);
			#);

-- GUIENVmacMenuBarInit: doPart --
do menus.init;

-- GUIENVmacMenuBarUpdate: doPart --
do DrawMenuBar;
	false -> needsUpdate;

-- GUIENVwindowGlobalToLocal: doPart --
do	assertOpen;
	private.windowContents.setupPortZero
	(# macPt: @macPoint;
	do global -> macPt.setPoint;
		macPt[] -> MACGlobalToLocal;
		macPt.getPoint -> local;
	#);
	
-- GUIENVwindowLocalCoordsToGlobal: doPart --
do assertOpen;
	private.windowContents.setupPortZero
	(# macPt: @macPoint;
	do local -> macPt.setPoint;
		macPt[] -> MacLocalToGlobal;
		macPt.getPoint -> global;
	#);

-- TimerQueueInit: doPart --
do	maxInt -> minInterval;

-- TimerQueueInsert: doPart --
do TickCount -> action.time;
	(if action.interval < minInterval then
		action.interval -> minInterval;
	if);
	(if top < R.range then
		top + 1 -> top;
		action[] -> R[top][];
	else
		false -> inserted;
		(for inx: top repeat
			(if R[inx][] = none then
				action[] -> R[inx][];
				true -> inserted;
			if);
		for);
		(if not inserted then
			top -> R.extend;
			top + 1 -> top;
			action[] -> R[top][];
		if);
	if);
					
					
-- TimerQueueDelete: doPart --
do maxInt -> minInterval;
	(for inx: top repeat
		(if R[inx][] <> none then
			(if R[inx][] = action[] then
				none -> R[inx][];
			else
				(if R[inx].interval < minInterval then
					R[inx].interval -> minInterval;
				if);
			if);
		if);
	for);
	
-- TimerQueueScan: doPart --
do (for inx: top repeat
		(if R[inx][] <> none then
			R[inx][] -> current[];
			inner;
		if);
	for);
	
-- TimerQueueExecuteElapsed: doPart --
do maxInt -> minInterval;
	1 -> inx;
	l: (if inx <= top then
			(if R[inx][] <> none then
				R[inx][] -> current[];
				TickCount -> currentTime;
				(if currentTime - current.time > current.interval then
					current;
					TickCount -> currentTime;
					currentTime -> current.time;
				if);
				current.interval - (currentTime - current.time)  -> interval;
				(if interval < minInterval then
					interval -> minInterval;
				if);
			if);
			inx + 1 -> inx;
			restart l;
		if);
	currentTime -> lastVisit;
	
-- GUIENVwindowItemDrawBorder: doPart --
do (#
	   	
	   left, top, right, bottom: @integer;
	   
	do r.topLeft -> (left, top);
	   r.bottomRight -> (right, bottom);
	   (if this(drawborder).style 
		   	//borderStyles.shadowIn then
					this(guienv).private.black -> pen.foreGroundColor;
					((left+1, top+1), (right-1, bottom-1)) -> drawRect;
					
					this(guienv).private.gray[5] -> pen.foreGroundColor;
					((left, top), (right - 2, top)) -> drawLine;
					((left, top), (left, bottom - 2)) -> drawLine;
					
					this(guienv).private.white -> pen.foreGroundColor;
					((right - 1, top + 1), (right - 1, bottom - 1)) -> drawLine;
					((left + 1, bottom - 1), (right - 1, bottom - 1)) -> drawLine;

			   //borderStyles.shadowOut then
					this(guienv).private.black -> pen.foreGroundColor;
					((left, top), (right, bottom)) -> drawRect;
					
		   		this(guienv).private.white -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 2)) -> drawLine;
			   	((left + 1, top + 1), (right - 2, top + 1)) -> drawLine;
					
			   	this(guienv).private.gray[5] -> pen.foreGroundColor;
			   	((left + 2, bottom - 2), (right - 2, bottom - 2)) -> drawLine;
			   	((right - 2, top + 2), (right - 2, bottom - 2)) -> drawLine;
					
			   //borderStyles.etchedIn then
			   	this(guienv).private.gray[7] -> pen.foreGroundColor;
			   	((left, top), (right - 1, bottom - 1)) -> drawRect;
					
			   	this(guienv).private.white -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 3)) -> drawLine;
			   	((left + 1, top + 1), (right - 3, top + 1)) -> drawLine;
			   	((left, bottom - 1), (right - 1, bottom - 1)) -> drawLine;
			   	((right - 1, top), (right - 1, bottom - 1)) -> drawLine;
					
			   //borderStyles.etchedOut then
			   	this(guienv).private.white -> pen.foreGroundColor;
			   	((left, top), (right - 1, bottom - 1)) -> drawRect;
					
			   	this(guienv).private.gray[7] -> pen.foreGroundColor;
			   	((left + 1, top + 1), (left + 1, bottom - 3)) -> drawLine;
			   	((left + 1, top + 1), (right - 3, top + 1)) -> drawLine;
			   	((left, bottom - 1), (right - 1, bottom - 1)) -> drawLine;
			   	((right - 1, top), (right - 1, bottom - 1)) -> drawLine;
					
			   //borderStyles.simple then
			   	r -> drawRect;
			   if);
	#)
	
-- GUIENVcanvasFindObjectClicked: doPart --
do position -> pt.subtract;
	l: private.children.scanReverse
		(# currentCanvas: ^canvas;
		do (if current.clickable then
				(if pt -> current.hit then
					(if current## <= canvas## then
						current[] -> currentCanvas[];
						pt -> currentCanvas.findObjectClicked -> ObjectClicked[];
					else
						current[] -> ObjectClicked[];
					if);
					leave l;
				if);
			if);
		#);
	(if ObjectClicked[] = NONE then
		this(canvas)[] -> ObjectClicked[];
	if);

	
-- GUIENVwindowItemToScreenCoordinates: doPart --
do (# macPt: @macPoint;
      LocalToGlobal: External (# p: ^macPoint enter p[] do '$A870' -> PascalTrap; #);
	do assertOpen;
		setupPort
			(#
			do p -> macPt.setPoint;
				macPt[] -> LocalToGlobal;
				macPt.getPoint -> q;
			#);		
	#);
	
-- MacMenuBarAdjust: doPart --
do menus.iterate
		(#
		do 
			current.elm.adjust;
		#);


-- windowItemCalculateVisibleRgn: doPart --
do (if NOT THIS(window).private.windowVisible then
		(failureTrace, '') -> stop;
   if);
	(# fatherVisibleRgn: @integer; (* Region Handle *)
		siblingFrameRgn: @integer; (* Region Handle *)
		pos: ^father.private.children.theCellType;
	do (if false then
			this(windowItem)[] -> getPatternName -> putText;
			'.calculateVisibleRgn' -> putLine;
		if);
		NewRgn -> rgn;
	
		(*
		 * Start out with the frame in global coordinates in
		 * the window:
		 *)
		 
		rgn -> setRgnToFrame;
		
		
		(if father[] <> NONE then
			(*
			 * Intersect with the fathers visibleRgn:
			 *)
			 
			father.getVisibleRgn -> fatherVisibleRgn;
			
				
			(fatherVisibleRgn, rgn, rgn) -> SectRgn;
			
			(*
			 * Remove the bounding box of the
			 * overlapping siblings:
			 *)
			 
			(if not (rgn -> EmptyRgn) then
				this(windowItem)[] -> father.getChildPosition -> pos[];
				pos.succ[] -> pos[];
				(if pos[] <> NONE then
					NewRgn -> siblingFrameRgn;
					l: pos[] -> father.private.children.scanFrom
					  (#
					  do (if current.visible then
					  			siblingFrameRgn -> current.setRgnToFrame;
							  (rgn, siblingFrameRgn, rgn) -> DiffRgn;
							  (if (rgn -> EmptyRgn) then
									leave l;
							  if);
							if);
					  #);
					siblingFrameRgn -> DisposeRgn;
				if);
				
			if);
		if);
		
	#)
	
-- windowItemForgetVisibleRgn: doPart --
do (# 
	   asCanvas: ^canvas;
	do (*
		 * Deallocate the visible rgn
		 *)
		 
		(if false then
			this(windowItem)[] -> getPatternName -> putText;
			'.forgetVisibleRgn' -> putLine;
		if);
		
		(if private.visibleRgn <> 0 then
			 private.visibleRgn -> DisposeRgn;
			 0 -> private.visibleRgn;
			 
			 (*
			  * Tell the other objects whose visibleRgn depends
			  * on my visibleRgn to forget their visibleRgn.
			  *)
			  
			  
			  (if this(windowItem)## <= canvas## then
					this(windowItem)[] -> asCanvas[];
					asCanvas.scan
						(#
						do current.forgetVisibleRgn;
						#);
			  if);
		 if);
		 
		 
		 (if tellBrothers then
					brotherForgetVisibleRgn;
		 if);
	#);

-- windowItemBrotherForgetVisibleRgn: doPart --
do (if NOT private.isFigureItem then
		(# prevSibling: ^windowItem;
		do (if father[] <> NONE then
				this(windowItem)[] -> father.getPrevSibling -> prevSibling[];
				(if prevSibling[] <> NONE then
					true -> prevSibling.forgetVisibleRgn;
				if);
			if);
		#);
	if);
	
-- windowItemCalculateOrigin: doPart --
do (# x, y: @integer;
	   asCanvas: ^canvas;
   do (if father[] = NONE then
			0 -> private.originX;
			0 -> private.originY;
		else
			father.privateOrigin -> (x, y);
			x + private.left -> private.originX;
			y + private.top -> private.originY;
			(if this(windowItem)## <= canvas## then
				this(windowItem)[] -> asCanvas[];
				asCanvas.scan
					(#
					do current.calculateOrigin;
					#);
			if);
		if);
		
   #);
	
-- windowItemGetDrawingRgn: doPart --
do (# visRgn: @integer;
		childFrameRgn: @integer;
		asCanvas: ^canvas;
	do getVisibleRgn -> visRgn;
		(visRgn, rgn) -> CopyRgn;
		(if not (visRgn -> EmptyRgn) then
			(if this(windowItem)## <= canvas## then
				this(windowItem)[] -> asCanvas[];
				NewRgn -> childFrameRgn;
				l: asCanvas.private.children.scan
					(#
					do (if current.visible then
							childFrameRgn -> current.setRgnToFrame;
							(rgn, childFrameRgn, rgn) -> DiffRgn;
							(if (rgn -> EmptyRgn) then
								leave l;
							if);
						if);
					#);
				childFrameRgn -> DisposeRgn;
			if);
		if);
	#);
