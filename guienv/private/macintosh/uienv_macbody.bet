ORIGIN 'uienv_macprivate';
OBJFILE mac 'mac/uienv_mac.c.o';
MAKE mac 'external/uienv.make'
[[
-- Include 'eventsstuff'
-- Include '~beta/maclib/v3.0/osutils'
-- Include '~beta/maclib/v3.0/debug'
-- Include 'windowsstuff'
-- Include '~beta/maclib/v3.0/fonts'
-- Include 'quickdrawstuff'
-- Include '~beta/maclib/v3.0/dialogs'
-- Include '~beta/maclib/v3.0/ToolUtils'
-- Include '~beta/maclib/v3.0/scrap'
-- Include '~beta/maclib/v3.0/textedit'
-- Include '~beta/maclib/v3.0/desk'
-- Include '~beta/maclib/v3.0/menus'
-- Include '~beta/maclib/v3.0/memory'
-- Include '~beta/containers/v1.5/list'
-- Include '~beta/basiclib/v1.5/objinterface'
-- Include 'diskinitstuff'
-- Include '~beta/uienv/v1.1.8/private/linkedlist'
-- Include 'raster_macprivate'
-- Include '~beta/uienv/v1.1.8/fields'
-- uienvLib: attributes --
sleep: (# exit 2 #);
mainLoop:
	(#	processOne: @processOneEvent;
	do l:
			(if not private.done then
				processOne;
				restart l;
			if);
	#);
processOneEvent:
	(# gotEvent: @boolean;
		dispatch: @dispatchEvent;
		idle: @doIdle;
	do	idle;
		handleCursor;
		(everyEvent,private.event[],sleep,private.cursorRegion) -> WaitNextEvent -> gotEvent;
		(if gotEvent then
			dispatch;
		if);
	#);
dispatchEvent:
	(# doProcessMouseDown: @processMouseDown;
		doProcessMouseUp: @processMouseUp;
		doProcessKeyDown: @processKeyDown;
		doProcessActivate: @processActivate;
		doProcessUpdate: @processUpdate;
		doProcessDiskEvent: @processDiskEvent;
		doProcessOsEvent: @processOsEvent;
		doProcessHighLevelEvent: @processHighLevelEvent;
	do (if private.event.what
			//mouseDown then doProcessMouseDown
			//mouseUp then doProcessMouseUp
			//keyDown//autoKey then doProcessKeyDown
			//activateEvt then doProcessActivate
			//updateEvt then doProcessUpdate
			//diskEvt then doProcessDiskEvent
			//osEvt then doProcessOsEvent
			//kHighLevelEvent then doProcessHighLevelEvent
		if);
	#);
doIdle:
	(# theWindow: ^window;
	do	(if private.globalMacMenuBar.needsUpdate then
			private.globalMacMenuBar.update;
		if);
		activeWindow -> theWindow[];
		(if theWindow[]<>none then
			theWindow.processIdle;
		if);
	#);
processMouseDown:
	(# partCode: @integer;
		windowPointer: @longint;
		theWindow: ^window;
		macPt: @macPoint;
		clickPosition,pt: @point;
		time,dlbClickTime: @integer;
	do false -> doubleClickPossible;
		(private.event.where,windowPointer[]) -> FindWindow -> partCode;
		(if partCode
			//inMenubar then
				(if modalState//systemModal then
					30 -> SysBeep;
				else
					processMenubarClick;
				if);
			//inSysWindow then
				(private.event[],windowPointer) -> SystemClick;
			//inDesk then
		else
			(* first determine if this can possibly be a doubleclick *)
			private.event.where -> macPt;
			macPt.getPoint -> clickPosition;
			lastClickPosition -> pt;
			clickPosition -> pt.subTract;
			(if (pt.h*pt.h + pt.v*pt.v) < 10 then
				private.event.when -> time;
				GetDblTime -> dlbClickTime;
				((time - lastClickTime) < dlbClickTime) -> doubleClickPossible;
		  	if);
			(* now find the window *)
			windowPointer -> private.windows.findBywindowPointer -> theWindow[];
			(if theWindow[]<>none then
				theWindow[] -> hitWindow;
				partCode -> theWindow.processMouseDown;
			if);
		if);
	#);
processMouseUp: 
	(# theWindow: ^window;
	do hitWindow -> theWindow[];
		(if theWindow[]<>none then
			theWindow.processMouseUp;
			none -> hitWindow;
		if);
	#);
processKeyDown: 
	(# key: @char;
		result: @longInt;
		theWindow: ^window;
	do private.event.charCode -> key;
		(if private.event.cmdKey then
			(if private.event.what//keyDown then
				private.theMenubar.adjust;
				key -> MenuKey -> result;
				(if result.hiWord<>0 then
					(result.hiWord,result.loWord) -> processMenuSelect;
					0 -> HiliteMenu;
				if);
			if);
		else
			activeWindow -> theWindow[];
			(if theWindow[]<>none then
				key -> theWindow.processKeyDown;
			if);
		if);
	#);
processActivate: 
	(# theWindow: ^window;
	do private.event.message -> private.windows.findByWindowPointer -> theWindow[];
		(if theWindow[]<>none then
			private.event.activeFlag -> theWindow.processActivate;
		if);
	#);
processUpdate: 
	(# windowPointer: @integer;
		theWindow: ^window;
	do	private.event.message -> windowPointer;
		windowPointer -> private.windows.findByWindowPointer -> theWindow[];
		(if theWindow[]<>none then
			theWindow.processUpdate;
		if);
	#);
processDiskEvent: 
	(# message: @longint;
		macPt: @macPoint;
		theError: @integer;
	do private.event.message -> message;
		(if message.hiWord<>0 then
			DILoad;
			(120,120) -> macPt.setPoint;
			(macPt,message) -> DIBadMount -> theError;
		if);
	#);
processOsEvent: 
	(#
	do (if private.event.app4Selector
			//1 then
				(if private.event.resume then
					processResume;
				else
					processSuspend;
				if);
			//250 then processMouseMoved;
		if);
	#);
processResume:
	(#	theWindow: ^window;
	do activeWindow -> theWindow[];
		true -> theWindow.processActivate;
	#);
processSuspend:
	(#	theWindow: ^window;
	do activeWindow -> theWindow[];
		false -> theWindow.processActivate;
	#);
processMouseMoved:
	(#
	#);
processHighLevelEvent: 
	(#
	
	#);

processMenubarClick:
	(# result: @longint;
	do	private.theMenubar.adjust;
		private.event.where -> MenuSelect -> result;
		(if result.hiWord<>0 then
			(result.hiWord,result.loWord) -> processMenuSelect;
			0 -> HiliteMenu;
		if);
	#);
processMenuSelect:
	(# menuID,itemNumber: @integer;
		theMenu: ^menu;
		appleMenuID: (# exit 128 #);
	enter (menuID,itemNumber)
	do (if menuID//appleMenuID then
			itemNumber -> processAppleMenuSelect;
		else
			menuID -> private.menus.findByID -> theMenu[];
			itemNumber -> theMenu.itemSelected;
		if);
	#);
processAppleMenuSelect:
	(# number: @integer;
		itemText: @pascalString;
		rep:  ^text;
		daRefNum: @integer;
	enter number
	do (if number//1 then
			showAboutBox;
		else
			(appleMenu,number,itemText[]) -> GetItem;
			itemText.getText -> rep[];
			rep -> OpenDeskAcc -> daRefNum;
		if);
	#);
showAboutBox:
	(# result: @integer;
	do (7128,0) -> Alert -> result;
	#);
withCurrentEvent:
	(#	event: ^eventRecord;
	do currentEvent -> event[];
		inner;
	#);
handleCursor:
	(#	event: @eventRecord;
		ignore: @boolean;
		macPt: @macPoint;
		windowPointer: @longInt;
		partCode: @integer;
		theWindow: ^window;
		handled: @boolean;
	do (everyEvent,event[]) -> OSEventAvail -> ignore;
		event.where -> macPt;
		(macPt,windowPointer[]) -> FindWindow -> partCode;
		(if partCode//inContent then
			windowPointer -> private.windows.findBywindowPointer -> theWindow[];
			(if theWindow[]<>none then
				(if theWindow.windowActive then
					windowPointer -> SetPort;
					(0,0) -> SetOrigin;
					macPt[] -> GlobalToLocal;
					macPt.getPoint -> theWindow.handleCursor -> handled;
				if);
			if);
		if);
		(if not handled then
			cursors.arrow[] -> mouse.theCursor;
		if);
	#);
-- UIENVterminateBody: descriptor --
(#
do true -> private.done;
#)

-- UIENVsetTheMenubar: descriptor --
(#
do theBar[] -> private.theMenuBar[];
	globalMacMenuBar -> theBar.changeMacMenubar;
#)

-- UIENVgetTheMenubar: descriptor --
(#
do  (* Not Implemented !!! *)
#)

-- UIENVinterfaceObjectEvent: descriptor --
(# 
do (if private.beforeActions[]<>None then
       private.beforeActions.scan
       (# 
       do (if (current.eventType## >= this(event).struc) then
              this(event)[] -> current;
          if);
       #);
   if);
   inner event;
   (if private.afterActions[]<>None then
       private.afterActions.scan
       (# 
       do (if (current.eventType## >= this(event).struc) then
              this(event)[] -> current;
          if);
       #);
   if);
#)

-- UIENVbasicEventShiftKey: descriptor --
withCurrentEvent
(#	
do event.shiftKey -> value;
#)

-- UIENVbasicEventAltKey: descriptor --
withCurrentEvent
(#
do event.optionKey -> value;
#)

-- UIENVbasicEventMetaKey: descriptor --
withCurrentEvent
(#
do event.cmdKey -> value;
#)

-- UIENVbasicEventControlKey: descriptor --
withCurrentEvent
(#
do event.controlKey -> value
#)

-- UIENVbasicEventCapsLock: descriptor --
withCurrentEvent
(#
do event.alphaLock -> value;
#)

-- UIENVbasicEventButtonState: descriptor --
withCurrentEvent
(#
do event.btnState -> value;
#)

-- UIENVbasicEventWhen: descriptor --
withCurrentEvent
(#
do event.when -> value;
#)

-- UIENVbasicEventGlobalPosition: descriptor --
withCurrentEvent
(#	macPt: @macPoint;
do event.where -> macPt;
	macPt.getPoint -> p;
#)

-- UIENVbasicEventLocalPosition: descriptor --
(#
do currentLocalPosition -> p;
#)

-- UIENVmouseEventDoubleClick: descriptor --
(#
do doubleClickPossible -> value;
#)

-- UIENVkeyEventCh: descriptor --
withCurrentEvent
(# 
do event.charCode -> theChar;
#)

-- UIENVkeyEventKeyCode: descriptor --
withCurrentEvent
(# 
do event.keyCode -> value;
#)

-- UIENVmouseDownDelay: descriptor --
(#
do	(* Not implemented !!! *)
#)

-- interfaceObjectLib: attributes --
actionList: linkedList
  (# element::< action;
  #);

-- UIENVinterfaceObjectPrependAction: descriptor --
(# 
do (if private.beforeActions[]//none then
       &actionList[] -> private.beforeActions[];
   if);
   (if not (theAction[] -> private.beforeActions.member) then
       theAction[] -> private.beforeActions.prepend;
   if);
#)

-- UIENVinterfaceObjectAppendAction: descriptor --
(# 
do (if private.afterActions[]//none then
       &actionList[] -> private.afterActions[];
   if);
   (if theAction[] -> private.afterActions.member//false then
       theAction[] -> private.afterActions.append;
   if);
#)

-- UIENVinterfaceObjectDeleteAction: descriptor --
(# 
do 
   (if private.beforeActions[]<>none then
       theAction[] -> private.beforeActions.delete;
   if);
   (if private.afterActions[]<>none then
       theAction[] -> private.afterActions.delete;
   if);
#)

-- UIENVintefaceObjectCreate: descriptor --
(#
do inner create;
#)

-- UIENVinterfaceObjectOpen: descriptor --
(#
do create;
	inner open;
#)

-- UIENVinterfaceObjectClose: descriptor --
(#
do inner close;
#)

-- UIENVenableEventType: descriptor --
(#
do (* Not Implemented !!! *)
#)

-- UIENVdisableEventType: descriptor --
(#
do (* Not Implemented !!! *)
#)

-- UIENVinterfaceObjectGetLayout: descriptor --
(#
do (* Not Implemented !!! *)
#)

-- UIENVinterfaceObjectException: descriptor --
(#
do (* Not Implemented !!! *)
#)

-- UIENVnotOpenedException: descriptor --
(#
do (* Not Implemented !!! *)
#)

-- UIENVinterfaceObjectPrivate: descriptor --
(# beforeActions,afterActions: ^actionList;
#)

-- menubarLib: attributes --
adjust:
	(#
	do private.menus.scan
			(#
			do current.adjust;
			#);
	#);
changeMacMenubar:
	(# theMacMenubar: ^macMenubar;
	enter theMacMenubar[]
	do (if theMacMenubar[]<>private.theMacMenubar[] then
			(if theMacMenubar[]//none then
				scan
					(#
					do current[] -> private.theMacMenubar.delete;
					#);
			else
				scan
					(#
					do current[] -> theMacMenubar.append;
					#);
			if);
			theMacMenubar[] -> private.theMacMenubar[];
		if);
	#);

-- UIENVmenubarAppend: descriptor --
(#
do (if theMenu[] -> private.menus.has//false then
		theMenu[] -> private.menus.append;
		this(menubar)[] -> theMenu.owner;
		(if private.theMacMenuBar[]<>none then
			theMenu[] -> private.theMacMenuBar.append;
		if);
	if);
#)

-- UIENVmenubarDelete: descriptor --
(#
do	(if theMenu[] -> private.menus.has then
		theMenu[] -> private.menus.remove;
		none -> theMenu.owner;
		(if private.theMacMenuBar[]<>none then
			theMenu[] -> private.theMacMenuBar.delete;
		if);
	if);
#)

-- UIENVmenubarClear: descriptor --
(#
do	scan
		(#
		do current[] -> delete;
		#);
#)

-- UIENVmenubarAppendMenubar: descriptor --
(#
do	(* not implemented *)
#)

-- UIENVmenubarReplaceMenubar: descriptor --
(#
do 	(* not implemented *)
#)

-- UIENVmenubarDeleteMenubar: descriptor --
(#
do 	(* not implemented *)
#)

-- UIENVmenubarScan: descriptor --
(#
do	private.menus.scan
		(#
		do current[] -> this(scan).current[];
			inner scan;
		#);
#)

-- UIENVmenubarCreate: descriptor --
(#
do inner create;
#)

-- UIENVmenubarOpen: descriptor --
(#
do inner open;
#)

-- UIENVmenubarClose: descriptor --
(#
do inner close;
#)

-- UIENVmenubarPrivate: descriptor --
(# menus: @list
		(# element::< menu;
			findByID:
				(# ID: @integer;
					e: ^element;
				enter ID
				do	l: scan
						(#
						do (if current.private.menuID//ID then
								current[] -> e[];
							if);
						#);
				exit e[]
				#);
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
		#);
	theMacMenubar: ^macMenuBar;
#)

-- UIENVmenuSetName: descriptor --
(#
do theName -> private.name;
	destroyMenu;
	buildMenu;
#)

-- UIENVmenuGetName: descriptor --
(#
do private.name.copy -> theName[];
#)

-- menuitemLib: attributes --
adjust:
	(#
	do	(if theEventHandler.onStatus then
			enable;
		else
			disable;
		if);
	#);
enable:
	(#
	do (this(menu).private.handle,private.number) -> EnableItem;
	#);
disable:
	(#
	do (this(menu).private.handle,private.number) -> DisableItem;
	#);
updateAll:
	(#
	do updateName;
		updateKey;
		updateMark;
		updateFace;
		updateChecked;
		updateSubMenu;
	#);
updateName:
	(#
	do (handle,private.number,private.name) -> SetItem;
	#);
updateKey:
	(#
	do (handle,private.number,private.key) -> SetItemCmd;
	#);
updateMark:
	(#
	do (if private.mark<>0 then
			(handle,private.number,private.mark) -> SetItemMark;
		if);
	#);
updateFace:
	(#
	do (handle,private.number,private.face) -> SetItemStyle;
	#);
updateChecked:
	(#
	do (handle,private.number,private.checked) -> CheckItem;
	#);
updateSubMenu:
	(# 
	do (if private.submenu[]//none then
			 (handle,private.number,private.mark) -> SetItemMark;
			 (handle,private.number,private.key) -> SetItemCmd; 
		else
			(handle,private.number,private.subMenu.menuID) -> SetItemMark;
			(handle,private.number,27) -> SetItemCmd;
		if);
	#);
buildItem:
	(#
	do (this(menu).private.handle,'...',private.number - 1) -> InsMenuItem;
		updateAll;
	#);

-- UIENVmenuitemSetMark: descriptor --
(#
do c -> private.mark;
	(if private.number<>0 then
		updateMark;
	if);
#)

-- UIENVmenuitemGetMark: descriptor --
(#
do  private.mark -> c;
#)

-- UIENVmenuitemSetKey: descriptor --
(#
do c -> private.key;
	(if private.number<>0 then
		updateKey;
	if);
#)

-- UIENVmenuitemGetKey: descriptor --
(#
do private.key -> c;
#)

-- UIENVmenuitemSetFace: descriptor --
(#
do f -> private.face;
	(if private.number<>0 then
		updateFace;
	if);
#)

-- UIENVmenuitemGetFace: descriptor --
(#
do private.face -> f;
#)

-- UIENVmenuitemSetName: descriptor --
(#
do t -> private.name;
	(if private.number<>0 then
		updateName;
	if);
#)

-- UIENVmenuitemGetName: descriptor --
(#
do private.name.copy -> t[];
#)

-- UIENmenuitemsSetChecked: descriptor --
(#
do checked -> private.checked;
	(if private.number<>0 then
		updateChecked;
	if);
#)

-- UIENVmenuitemGetChecked: descriptor --
(#
do private.checked -> checked;
#)

-- UIENVsetSubMenu: descriptor --
(#
do (if private.subMenu[]<>none then
		private.subMenu.menuID -> DeleteMenu;
		none -> private.subMenu[];
	if);
	theMenu[] -> private.subMenu[];
	(if private.subMenu[]<>none then
		(private.subMenu.handle,-1) -> InsertMenu;
	if);
	(if private.number<>0 then
		updateSubMenu;
	if);
#)

-- UIENVgetSubMenu: descriptor --
(#
do private.subMenu[] -> theMenu[];
#)

-- UIENVmenuitemPosition: descriptor --
(#
do private.number -> value;
#)

-- UIENVmenuitemOnStatus: descriptor --
(#
do true -> value;
	inner onStatus;
#)

-- UIENVmenuitemCreate: descriptor --
(#
do inner create;
#)

-- UIENVmenuitemOpen: descriptor --
(#
do inner open;
#)

-- UIENVmenuitemAttach: descriptor --
(#
do (if theAction[]<>none then
		none -> theAction.theMenuitem[];
	if);
	anAction[] -> theAction[];
	(if theAction[]<>none then
		this(dynamicMenuitem)[] -> theAction.theMenuitem[];
	if);
#)

-- UIENVmenuitemDetach: descriptor --
(#
do	none -> attach;
#)

-- UIENVdynamicMenuitemOnStatus: descriptor --
(#
do	(if theAction[]//none then
		false -> value;
	else
		theAction.onStatus -> value;
	if);
#)

-- UIENVdynamicMenuitemOnSelect: descriptor --
(#
do (if theAction[]//none then
	else
		theAction.onSelect;
	if);
#)

-- UIENVactionOnStatus: descriptor --
(#
do	true -> value;
	inner onStatus;
#)

-- UIENVseparatorCreate: descriptor --
(#
do	inner create;
#)

-- UIENVseparatorOpen: descriptor --
(#
do	true -> menuitemIsSeparator;
	inner open;
#)

-- UIENVseparatorClose: descriptor --
(#
do	inner close;
#)

-- menuLib: attributes --
adjust:
	(#
	do theEventHandler.onSelect;
		private.menuitems.scan
			(#
			do current.adjust;
			#);
	#);
itemSelected:
	(# itemNumber: @integer;
		theItem: ^menuitem;
	enter itemNumber
	do itemNumber -> private.menuitems.findByNumber -> theItem[];
		(if theItem[]<>none then
			theItem.theEventHandler.onSelect;
		else
			'Did not find the item' -> putLine;
		if);
	#);
buildMenu:
	(# theMenubar: ^menuBar;
	do	(if private.handle//0 then
			(private.menuID,private.name) -> NewMenu -> private.handle;
			private.menuItems.scan
				(#
				do current.buildItem;
				#);
			owner -> theMenubar[];
			(if theMenubar[]<>none then
				(if theMenubar.private.theMacMenubar[]<>none then
					this(menu)[] -> theMenubar.private.theMacMenubar.append;
				if);
			if);
		if);
	#);
destroyMenu:
	(# theMenubar: ^menuBar;
	do (if private.handle//0 then
		else
			owner -> theMenubar[];
			(if theMenubar[]<>none then
				(if theMenubar.private.theMacMenubar[]<>none then
					this(menu)[] -> theMenubar.private.theMacMenubar.delete;
				if);
			if);
			private.handle -> DisposeMenu;
			0 -> private.handle;
		if);
	#);
-- UIENVmenuAppend: descriptor --
(#
do (if theMenuitem[] -> private.menuitems.has//false then
		theMenuitem[] -> private.menuitems.append;
		private.menuitems.size -> theMenuitem.private.number;
		(if theMenuitem.menuitemIsSeparator then
			(private.handle,'(-') -> AppendMenu;
		else
			(private.handle,'...') -> AppendMenu;
			theMenuitem.updateAll;
		if);
	if);
#)

-- UIENVmenuDelete: descriptor --
(# pos: ^private.menuitems.theCellType;
do (if theMenuitem[] -> private.menuitems.has then
		(handle,theMenuitem.number) -> DelMenuItem;
		theMenuitem[] -> private.menuitems.at -> pos[];
		pos[] -> private.menuitems.iterateFrom
			(#
			do current.elm.number - 1 -> current.elm.number;
			#);
		pos[] -> private.menuitems.delete;
	if);
#)

-- UIENVmenuScan: descriptor --
(#
do private.menuItems.scan
		(#
		do current[] -> this(scan).current[];
			inner scan;
		#);
#)

-- UIENVmenuClear: descriptor --
(#
do scan
		(#
		do current[] -> delete;
		#);
#)

-- UIENVmenuNoOfMenuitems: descriptor --
(#
do	private.menuitems.size -> value;
#)

-- UIENVmenuPopUp: descriptor --
(# result: @longInt;
do	adjust;
	(handle,topLeft.v,topLeft.h,popUpMenuitem) -> PopUpMenuSelect -> result;
	(if result.hiWord<>0 then
		(result.hiWord,result.loWord) -> processMenuSelect;
	if);
	
#)

-- UIENVmenuGetMenuitemByNumber: descriptor --
(#
do number -> private.menuitems.findByNumber -> theMenuitem[];
#)

-- UIENVmenuEnable: descriptor --
(#
do	(handle,0) -> EnableItem;
	true -> menuEnabled;
#)

-- UIENVmenuDisable: descriptor --
(#
do (handle,0) -> DisableItem;
	false -> menuEnabled;
#)

-- UIENVmenuEnabled: descriptor --
(#
do menuEnabled -> value;
#)

-- UIENVmenuCreate: descriptor --
(#
do inner create;
#)

-- UIENVmenuOpen: descriptor --
(# t: ^text;
do this(Menu)[] -> getPatternName -> t[];
	t -> private.name;
	(lastMenuID + 1) -> lastMenuID;
	(lastMenuID,private.name) -> NewMenu -> private.handle;
	lastMenuID -> private.menuID;
	this(menu)[] -> this(uienv).private.menus.append;
	inner open;
#)

-- UIENVmenuClose: descriptor --
(#
do inner close;
	this(menu)[] -> this(uienv).private.menus.remove;
	menuID -> DeleteMenu;
	handle -> DisposeMenu;
	0 -> handle;
#)



-- UIENVstandardFileMenuOpen: descriptor --
(#
do newMenuitem.open;
	'New' -> newMenuitem.name;
	newMenuitem[] -> append;
	
	openMenuitem;
	'Open...' -> openMenuitem.name;
	openMenuitem[] -> append;
	
	closeMenuitem;
	'Close' -> closeMenuitem.name;
	closeMenuitem[] -> append;
	
	saveMenuitem;
	'Save' -> saveMenuitem.name;
	saveMenuitem[] -> append;
	
	saveAsMenuitem;
	'Save as...' -> saveAsMenuitem.name;
	saveAsMenuitem[] -> append;
	
	revertMenuitem;
	'Revert' -> revertMenuitem.name;
	revertMenuitem[] -> append;
	
	printMenuitem;
	'Print...' -> printMenuitem.name;
	printMenuitem[] -> append;
	
	pageSetUpMenuitem;
	'Page setup' -> pageSetUpMenuitem.name;
	pageSetUpMenuitem[] -> append;
	
	quitMenuitem;
	'Quit' -> quitMenuitem.name;
	quitMenuitem[] -> append;
	inner open;
#)

-- UIENVstandardEditMenuOpen: descriptor --
(#
do undoMenuitem.open;
	'Undo' -> undoMenuitem.name;
	undoMenuitem[] -> append;
	
	cutMenuitem.open;
	'Cut' -> cutMenuitem.name;
	cutMenuitem[] -> append;
	
	copyMenuitem.open;
	'Copy' -> copyMenuitem.name;
	copyMenuitem[] -> append;
	
	pasteMenuitem.open;
	'Paste' -> pasteMenuitem.name;
	pasteMenuitem[] -> append;
	
	clearMenuitem.open;
	'Clear' -> clearMenuitem.name;
	clearMenuitem[] -> append;
	inner open;
#)

-- UIENVstandardMenubarOpen: descriptor --
(# 
do &fileMenu[] -> theFileMenu[];
	(if theFileMenu.struc <= menu## then
		theFileMenu.open;
		theFileMenu[] -> append;
	else
		none -> theFileMenu[];
	if);
	&editMenu[] -> theeditMenu[];
	(if theeditMenu.struc <= menu## then
		theeditMenu.open;
		theeditMenu[] -> append;
	else
		none -> theeditMenu[];
	if);
	inner open;
#)

-- windowLib: attributes --

processIdle:
	(#
	do theEventHandler.onIdle;
		(if windowTarget<>none then
			private.windowTarget.theEventHandler.onIdle;
		if);
	#);
processMouseDown:
	(# partCode: @integer;
		handleTheEvent: @boolean;
		event: ^eventRecord;
		grayRgn: @regionRecord;
		screenBounds: @macRect;
		a,b,c,d: @integer;
	enter partCode
	do currentEvent -> event[];
		(if this(window)[]//activeWindow then
			true -> handleTheEvent;
		else
			(modalState = modeless) -> handleTheEvent
		if);				
		(if handleTheEvent then
			(if partCode
				//inContent then
					(if this(window)[]//activeWindow then
						processContentClick;
					else
						private.windowPointer -> SelectWindow;
					if);
				//inDrag then
					GetGrayRgn -> grayRgn.init;
					grayRgn.bounds -> ((a,b),(c,d));
					((a,b),(c,d)) -> screenBounds;
					(private.windowPointer,event.where,screenBounds[]) -> DragWindow;
				//inGrow then
					processResize;
				//inGoAway then
					processGoAway;
				//inZoomIn//inZoomOut then
					partCode -> processZoom;
			if);
		else
			30 -> SysBeep;
		if);
	#);
processMouseUp:
	(# theWindowItem: ^windowItem;
	do hitWindowitem -> theWindowItem[];
		(if theWindowitem[]<>none then
			theWindowitem.theEventHandler.onMouseUp;
			none -> hitWindowitem;
		if);
	#);
processKeyDown:
	(# key: @char;
		defaultButton: ^windowItem;
	enter key
	do windowDefaultButton -> defaultButton[];
		(if defaultButton[]<>None then
			(if key//13//3 then
				defaultButton.theEventHandler.onMouseUp;
			if);
		if);
		(if windowTarget<>none then
			private.windowTarget.theEventhandler.onKeyDown;
		else
			theEventHandler.onKeyDown;
		if);
	#);
processActivate:
	(#	doActivate: @boolean;
	enter doActivate
	do (if doActivate<>windowActive then
			doActivate -> windowActive;
			(if doActivate then
				theEventHandler.onActivate;
				(if windowTarget<>none then
					private.windowTarget.theEventHandler.onEnableTarget;
				if);
			else
				theEventHandler.onDeactivate;
				(if windowTarget<>none then
					private.windowTarget.theEventHandler.onDisableTarget;
				if);
			if);
			invalidateGrowIcon;
		if);
	#);
processUpdate:
	(#	
	do private.windowPointer -> BeginUpdate;
		erasePortRect;
		private.windowContents.theEventHandler.onRefresh;
		theEventHandler.onRefresh;
		drawDefaultButton;
		drawGrow;
		private.windowPointer -> EndUpdate;
	#);
erasePortRect:
	(# 
	do private.windowContents.focus
			(# port: @grafPortRecord;
				mr: @macRect;
				a,b,c,d: @integer;
			do private.windowPointer -> port;
				port.portRectangle -> ((a,b),(c,d)) -> mr;
				mr[] -> EraseRect;
			#);
	#);
processContentClick:
	(# macPt: @macPoint;
		event: ^eventRecord;
	do currentEvent -> event[];
		event.where -> macPt;
		private.windowPointer -> SetPort;
		(0,0) -> SetOrigin;
		macPt[] -> GlobalToLocal;
		macPt.getPoint -> private.windowContents.processMouseDown;
	#);
processResize:
	(# event: ^eventRecord;
		limit: @macRect;
		result: @macPoint;
		width,height: @integer;
	do	currentEvent -> event[];
		(theMinSize,theMaxSize) -> limit;
		(private.windowPointer,event.where,limit[]) -> GrowWindow -> result;
		result.getPoint -> (width,height);
		(if (width<>0) or (height<>0) then
			(width,height) -> size;
		if);
	#);
processGoAway:
	(# event: ^eventRecord;
		result: @boolean;
	do currentEvent -> event[];
		(private.windowPointer,event.where) -> TrackGoAway -> result;
		(if result then
			(if theEventHandler.onAboutToClose then
				close;
			if);
		if);
	#);
processZoom:
	(# partCode: @integer;
		result: @boolean;
		event: ^eventRecord;
	enter partCode
	do currentEvent -> event[];
		(private.windowPointer,event.where,partCode) -> TrackBox -> result;
		(if result then
			partCode ->	zoom;
		if);
	#);
zoom:
	(# partCode: @integer;
	enter partCode
	do erasePortRect;
		private.windowPointer -> SetPort;
		(private.windowPointer,partCode,false) -> ZoomWindow;
	#);
getBounds:
	(# port: @grafportRecord;
		r: @rectangle;
		left,top,right,bottom: @integer;
		translate:
			(#	pt: @point;
				macPt: @macPoint;
			enter pt
			do pt -> macPt.setPoint;
				macPt[] -> LocalToGlobal;
				macPt.getPoint -> pt;
			exit pt
			#);
	do private.windowPointer -> SetPort;
		(0,0) -> SetOrigin;
		private.windowPointer -> port;
		port.portRectangle -> ((left,top),(right,bottom));
		(left,top) -> translate -> r.topLeft;
		(right,bottom) -> translate -> r.bottomRight;
	exit r
	#);
getGrowIconBounds:
	(# bounds: @rectangle;
	do size -> bounds.bottomRight;
		bounds.bottom - 15 -> bounds.top;
		bounds.right - 15 -> bounds.left;
	exit bounds
	#);
drawGrow:
	(# mr: @macRect;
	do private.windowPointer -> SetPort;
		getGrowIconBounds -> mr;
		mr[] -> ClipRect;
		(0,0) -> SetOrigin;
		private.windowPointer -> DrawGrowIcon;
	#);
drawDefaultButton:
	(#	theButton: ^windowItem;
	do windowDefaultButton -> theButton[];
		(if theButton[]<>None then
			theButton.father.focus
				(#	r: @rectangle;
				do theButton.frame -> r;
					(-4,-4) -> r.inset;
					PenNormal;
					blackColor -> ForeColor;
					(3,3) -> PenSize;
					(r[] -> makeMacRect,16,16) -> FrameRoundRect;
				#);
		if);
	#);
invalidateGrowIcon:
	(# mr: @macRect;
	do private.windowPointer -> SetPort;
		getGrowIconBounds -> mr;
		(0,0) -> SetOrigin;
		mr[] -> InvalRect;
	#);
handleCursor: booleanValue
	(# pt: @point;
	enter pt
	do pt -> private.windowContents.handleCursor -> value;
	#);

-- UIENVwindowUseTextStyle: descriptor --
(#
do private.windowPointer -> SetPort;
	style.familyID -> TextFont;
	style.textStyleSize -> TextSize;
	style.textStyleFace -> TextFace;
#)

-- UIENVwindowOnActivate: descriptor --
(# theMenubar: ^menubar;
do windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		globalMacMenubar -> theMenubar.changeMacMenubar;
	if);
	private.windowContents.theEventHandler.onActivate;
	inner onActivate;
#)

-- UIENVwindowOnDeactivate: descriptor --
(# theMenubar: ^menubar;
do 
	inner onDeactivate;
	private.windowContents.theEventHandler.onDeactivate;
	windowMenubar -> theMenubar[];
	(if theMenubar[]<>none then
		none -> theMenubar.changeMacMenubar;
	if);
#)

-- UIENVwindowSetTheMenubar: descriptor --
(#
do theBar[] -> windowMenuBar;
#)

-- UIENVwindowGetTheMenubar: descriptor --
(#
do windowMenuBar -> theBar[];
#)

-- UIENVwindowSetFloating: descriptor --
(#
do (* Not implemented !!! *)
#)

-- UIENVwindowGetFloating: descriptor --
(#
do (* Not implemented !!! *)
#)

-- UIENVwindowSetTitle: descriptor --
(#
do (private.windowPointer,theTitle) -> SetWTitle;
#)

-- UIENVwindowGetTitle: descriptor --
(# ps: @pascalString;
do (private.windowPointer,ps[]) -> GetWTitle;
	ps.getText -> theTitle[];
#)

-- UIENVwindowSetPosition: descriptor --
(#
do (private.windowPointer,pt.h,pt.v,false) -> MoveWindow;
#)

-- UIENVwindowGetPosition: descriptor --
(# r: @rectangle;
do getBounds -> r;
	r.topLeft -> pt;
#)

-- UIENVwindowSetSize: descriptor --
(#
do invalidateGrowIcon;
	(private.windowPointer,width,height,true) -> SizeWindow;
	(width,height) -> private.windowContents.size;
	invalidateGrowIcon;
#)

-- UIENVwindowGetSize: descriptor --
(# r: @rectangle;
do getBounds -> r;
	r.size -> (width,height);
#)

-- UIENVwindowSetFrame: descriptor --
(#
do theFrame.topLeft -> position;
	theFrame.size -> size;
#)

-- UIENVwindowGetFrame: descriptor --
(#
do getBounds -> theFrame;
#)

-- UIENVwindowInsideRectangle: descriptor --
(#
do (0,0) -> theRectangle.topLeft;
	size -> theRectangle.size;
#)

-- UIENVshowWindow: descriptor --
(#
do private.windowPointer -> ShowWindow;
	bringToFront;
	true -> windowVisible;
#)

-- UIENVwindowShowModal: descriptor --
(# doProcessOneEvent: @processOneEvent;
do systemModal -> modalState;
	show;
	loop:
		(if modalState<>modeless then
			doProcessOneEvent;
			restart loop;
		if);
#)

-- UIENVhideWindow: descriptor --
(#
do private.windowPointer -> HideWindow;
	modeless -> modalState;
	false -> windowVisible;
#)

-- UIENVwindowSetMaxSize: descriptor --
(#
do (width,height) -> theMaxSize;
#)

-- UIENVwindowGetMaxSize: descriptor --
(#
do theMaxSize -> (width,height);
#)

-- UIENVwindowSetMinSize: descriptor --
(#
do (width,height) -> theMinSize;
#)

-- UIENVwindowGetMinSize: descriptor --
(#
do theMinSize -> (width,height)
#)

-- UIENVwindowBringToFront: descriptor --
(# BringToFront: External (# theWindow: @Integer; enter theWindow do '$A920' -> PascalTrap; #);
do private.windowPointer -> SelectWindow;
#)

-- UIENVwindowBringToBack: descriptor --
(#
do (private.windowPointer,0) -> SendBehind;
#)

-- UIENVwindowBringBehind: descriptor --
(#
do (private.windowPointer,theWindow.private.windowPointer) -> SendBehind;
#)

-- UIENVwindowUpdate: descriptor --
(#
do processUpdate;
#)

-- UIENVwindowCreate: descriptor --
(# bounds: @macRect;
do inner create;
	(if private.windowPointer//0 then
		((40,40),(400,500)) -> bounds;
		(0,bounds[],'Title',false,ZoomDocProc,0,true,0) -> NewWindow -> private.windowPointer;
	if);
#)

-- UIENVwindowOpen: descriptor --
(# aMenubar: ^menubar;
do (20,20) -> theMinSize;
	(1000,1000) -> theMaxSize;
	this(window)[] -> this(uienv).private.windows.append;
	&menubarType[] -> aMenubar[];
	(if aMenubar.struc <= menubar## then
		aMenubar.open;
		aMenubar[] -> theMenubar;
	else
		none -> aMenubar[];
	if);
	private.windowContents.open;
	true -> windowVisible;
	inner open;
	(if windowVisible then
		private.windowPointer -> ShowWindow;
	if);
#)

-- UIENVwindowClose: descriptor --
(#
do hide;
	inner close;
	false -> processActivate;
	private.windowPointer -> CloseWindow;
	this(window)[] -> this(uienv).private.windows.remove;
#)

-- UIENVwindowSetTarget: descriptor --
(#
do (if windowTarget<>theTarget[] then
		(if windowTarget<>None then
			private.windowTarget.theEventHandler.onDisableTarget;
		if);
		theTarget[] -> windowTarget;
		(if windowTarget<>None then
			private.windowTarget.theEventHandler.onEnableTarget;
		if);
	if);
#)

-- UIENVwindowGetTarget: descriptor --
(#
do windowTarget -> theTarget[];
#)

-- UIENVwindowitemOnRefresh: descriptor --
(#
do (if visibleFlag then
		inner onRefresh;
	if);
#)

-- UIENVwindowitemSetFrame: descriptor --
(# oldFrame: @rectangle;
	oldVisibleRgn: @integer;
	newVisibleRgn: @integer;
	onlyResize: @boolean;
	mr: @macRect;
	t: @text
		(#
			putRect:
				(#	r: @rectangle;
				enter r
				do '[' -> put;
					r.left -> putInt;
					' ' -> put;
					r.top -> putInt;
					' ' -> put;
					r.right -> putInt;
					' ' -> put;
					r.bottom -> putInt;
					']' -> put;
				#);
		#);
do private.windowItemFrame -> oldFrame;
	oldFrame.topLeft -> theFrame.topLeft.isEqual -> onlyResize;
	(if oldFrame -> theFrame.isEqual//false then
		(if (automaticUpdate and visible) then
			(if (onlyResize and (not updateOnResize)) then
				NewRgn -> oldVisibleRgn;
				clip -> mr;
				(oldVisibleRgn,mr[]) -> RectRgn;
			else
				update
			if);
		if);
		theFrame -> private.windowItemFrame;
		calculateFocus;
		(if (automaticUpdate and visible) then
			(if (onlyResize and (not updateOnResize)) then
				NewRgn -> newVisibleRgn;
				clip -> mr;
				(newVisibleRgn,mr[]) -> RectRgn;
				(oldVisibleRgn,newVisibleRgn,newVisibleRgn) -> XorRgn;
				oldVisibleRgn -> DisposeRgn;
				newVisibleRgn -> InvalRgn;
				newVisibleRgn -> DisposeRgn;
			else
				update;
			if);
		if);
		(if father[]<>none then
			(oldFrame,theFrame) -> father.theEventHandler.onChildFrameChanged;
		if);
		(oldFrame,theFrame) -> theEventHandler.onFrameChanged;
	if);
#)

-- UIENVwindowitemGetFrame: descriptor --
(#
do private.windowItemFrame -> theFrame;
#)

-- UIENVwindowitemSetPosition: descriptor --
(#	r: @rectangle;
	width,height: @integer;
do frame -> r;
	r.size -> (width,height);
	pt -> r.topLeft;
	(width,height) -> r.size;
	r -> frame;
#)

-- UIENVwindowitemGetPosition: descriptor --
(# r: @rectangle;
do frame -> r;
	r.topleft -> pt;
#)

-- UIENVwindowitemMove: descriptor --
(# pt: @point;
do position -> pt;
	(dh,dv) -> pt.add;
	pt -> position;
#)

-- UIENVwindowitemSetSize: descriptor --
(# r: @rectangle;
do frame -> r;
	(width,height) -> r.size;
	r -> frame;
#)

-- UIENVwindowitemGetSize: descriptor --
(# r: @rectangle;
do frame -> r;
	r.size -> (width,height);
#)

-- UIENVwindowitemSetVisible: descriptor --
(#
do (if value<>visibleFlag then
		value -> visibleFlag;
		updateMaybe;
		theEventHandler.onVisibleChanged;
		(if this(windowItem)[]//target then
			father[] -> target;
		if);
	if);
#)

-- UIENVwindowitemGetVisible: descriptor --
(#
do visibleFlag -> value;
#)

-- UIENVwindowitemSetHilite: descriptor --
(#
do (if value<>hiliteFlag then
		value -> hiliteFlag;
		theEventHandler.onHiliteChanged;
	if);
#)

-- UIENVwindowitemGetHilite: descriptor --
(#
do hiliteFlag -> value;
#)

-- UIENVwindowitemShow: descriptor --
(#
do true -> visible;
#)

-- UIENVwindowitemHide: descriptor --
(#
do false -> visible;
#)

-- UIENVwindowitemSetEnabled: descriptor --
(#
do (if value<>enabledFlag then
		value -> enabledFlag;
		theEventHandler.onEnabledChanged;
	if);
#)

-- UIENVwindowitemGetEnabled: descriptor --
(#
do enabledFlag -> value;
#)

-- UIENVwindowitemEnable: descriptor --
(#
do true -> enabled;
#)

-- UIENVwindowitemDisable: descriptor --
(#
do false -> enabled;
#)

-- UIENVwindowitemSetTheCursor: descriptor --
(#
do theCur[] -> windowItemCursor;
#)

-- UIENVwindowitemGetTheCursor: descriptor --
(#
do windowItemCursor -> theCur[];
#)

-- UIENVwindowItemTrackMouse: descriptor --
(#
do (if StillDown then
		focus
			(# event: ^eventRecord;
				macPt: @macPoint;
				dh,dv: @integer;
			do currentEvent -> event[];
				event.where -> macPt;
				macPt[] -> GlobalToLocal;
				macPt.getPoint -> curPt -> prevPt;
				mousePress;
				loop:
					(if StillDown then
						macPt[] -> GetMouse;
						macPt.getPoint -> curPt;
						curPt.h - prevPt.h -> dh;
						curPt.v - prevPt.v -> dv;
						(if ((dh<>0) or (dv<>0)) then
							(dh,dv) -> mouseMove;
						if);
						curPt -> prevPt;
						restart loop;
					if);
				mouseRelease;
			#);
	if);
#)

-- UIENVwindowitemDrag: descriptor --
(#
do father.trackMouse
		(# currentFrame: @rectangle;
			drawFrame: @
				(#
				do currentFrame[] -> makeMacRect -> FrameRect;
				#);
			mousePress::<
				(#
				do PenNormal;
					blackColor -> ForeColor;
					whiteColor -> BackColor;
					srcXor -> PenMode;
					frame -> currentFrame;
					drawFrame;
				#);
			mouseMove::<
				(#
				do drawFrame;
					(h,v) -> currentFrame.offset;
					drawFrame;
				#);
			mouseRelease::<
				(#
				do drawFrame;
					currentFrame -> frame;
				#);
		#);
#)

-- UIENVwindowitemResize: descriptor --
(#
do (* not implemented !!! *)
#)

-- UIENVwindowitemUpdate: descriptor --
(# 
do focus
		(# mr: @macRect;
			t: @text;
		do clip -> mr;
			(*
			mr.left -> t.putInt;
			' ' -> t.put;
			mr.top -> t.putInt;
			' ' -> t.put;
			mr.right -> t.putInt;
			' ' -> t.put;
			mr.bottom -> t.putInt;
			 t[] -> putText; *)
			mr[] -> InvalRect;
		#);
#)

-- UIENVwindowitemCreate: descriptor --
(# origin: ^object;
do inner create;
	(if father[]//none then
		(if this(windowitem)[]//windowContents then
		else
			this(windowitem)[] -> getOrigin -> origin[];
			l:
			(if origin[]//none then
				windowContents -> father[];
			else 
				(if (origin.struc <= canvas##) then 
					origin[] -> father[];
				else 
					origin[] -> getOrigin -> origin[];
					restart l;
				if)
			if);
		if);
	if);
	
#)

-- UIENVwindowitemOpen: descriptor --
(#
do (if father[]<>none then
		this(windowitem)[] -> father.private.children.append;
	if);
	((0,0),(100,30)) -> private.windowItemFrame;
	calculateFocus;
	true -> automaticUpdate;
	true -> visibleFlag;
	true -> enabledFlag;
	true -> updateOnResize;
	true -> bindTop;
	true -> bindLeft;
	inner open;
#)

-- UIENVwindowitemClose: descriptor --
(#
do inner close;
	(if this(windowItem)[]//target then
			father[] -> target;
	if);
	this(windowitem)[] -> father.private.children.remove
#)

-- UIENVwindowItemCalculateFocus: descriptor --
(#	o,oldOrigin: @point;
	myClip: @rectangle;
	thisCanvas: ^canvas;
	h,v: @integer;
do origin -> oldOrigin;
	(if father[]//none then
		insideRectangle -> clip;
		(0,0) -> origin;
	else
		position -> o;
		father.origin -> o.add;
		o -> origin;
		(father.clip,frame) -> myClip.intersection;
		position -> (h,v);
		(-h,-v) -> myClip.offset;
		myClip -> clip;
	if);
	(* printFocus; *)
	withMethods
		(#
		do (if theMethods[]//none then
				else
					theMethods.focusChanged;
			if);
		#);
#)

-- UIENVwindowitemFocus: descriptor --
(#	h,v: @integer;
	theClip: @rectangle;
	mr: ^macrect;
	wp: @integer;
do windowPointer -> wp;
	wp -> SetPort;
	origin -> (h,v);
	(-h,-v) -> SetOrigin;
	clip -> theClip;
	theClip[] -> makeMacRect -> mr[];
	mr[] -> ClipRect;
	inner focus;
#)

-- UIENVwindowitemFocusZero: descriptor --
(#	mr: ^macrect;
	theClip: @rectangle;
	h,v: @integer;
	wp: @integer;
do windowPointer -> wp;
	wp -> SetPort;
	(0,0) -> SetOrigin;
	clip -> theClip;
	origin -> (h,v);
	(h,v) -> theClip.offset;
	theClip[] -> makeMacRect -> mr[];
	mr[] -> ClipRect;
	inner focusZero;
#)

-- UIENVWindowItemHit: descriptor --
withMethods
(#
do (if theMethods[]//none then
		pt -> defaultHitMethod -> value;
	else
		pt -> theMethods.hit -> value;
	if);
#)

-- UIENVwindowItemDefaultHitMethod: descriptor --
(# r: @rectangle;
do frame -> r;
	pt -> r.containsPoint -> value;
#)

-- UIENVwindowItemHandleCursor: descriptor --
withMethods
(#	t: @text; 
do	(if theMethods[]//none then
		pt -> defaultHandleCursorMethod -> value;
	else
		pt -> theMethods.handleCursor -> value;
	if);
#)

-- UIENVwindowItemdefaultHandleCursorMethod: descriptor --
(#
do (if windowItemCursor//none then
		false -> value;
	else
		windowItemCursor -> mouse.theCursor;
		true -> value;
	if);
#)

-- windowItemLib: attributes --
printFocus:
	(#	t: @text
			(# putPoint:
					(#	pt: @point;
					enter pt
					do pt.h -> putInt;
						' ' -> put;
						pt.v -> putInt;
					#);
				putRect:
					(# r: @rectangle;
					enter r
					do r.topLeft -> putPoint;
						' ' -> put;
						r.bottomRight -> putPoint;
					#);
			#);
	do this(windowItem)[] -> getPatternName -> t.putText;
		' o: ' -> t.putText;
		origin -> t.putPoint;
		' clip: ' -> t.putText;
		clip -> t.putRect;
		t -> debugStr;
	#);
processFatherFrameChanged:
	(# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
	enter (oldFrame,newFrame)
	do newFrame.size -> delta;
		oldFrame.size -> delta.subTract;
		(if (0,0) -> delta.isEqual//false then
			frame -> chainRect -> itsFrame;
			delta -> chainRect.offset;
			(if bindLeft//false then
				chainRect.left -> itsFrame.left;
			if);
			(if bindBottom then
				chainRect.bottom -> itsFrame.bottom
			if);
			(if bindRight then
				chainRect.right -> itsFrame.right
			if);
			(if bindTop//false then
				chainRect.top -> itsFrame.top
			if);
			itsFrame -> frame;
		if);
		(oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
	#);
	
-- canvasLib: attributes --
processMouseDown:
	(# pt: @point;
		theHitObject: ^windowitem;
		theCanvas: ^canvas;
	enter pt
	do pt -> private.children.findHitObject -> theHitObject[];
		(if theHitObject[]//none then
			pt -> currentLocalPosition;
			this(canvas)[] -> hitWindowitem;
			theEventHandler.onMouseDown;
		else
			theHitObject.position -> pt.subTract;
			(if theHitObject.struc <= canvas## then
				theHitObject[] -> theCanvas[];
				pt -> theCanvas.processMouseDown
			else
				pt -> currentLocalPosition;
				theHitObject[] -> hitWindowitem;
				theHitObject.theEventHandler.onMouseDown;
			if);
		if);
	#);
-- UIENVcanvasFocusChanged: descriptor --
(#
do private.children.scan
		(#
		do current.calculateFocus;
		#);
#)

-- UIENVcanvasHandleCursorMethod: descriptor --
(# theHitObject: ^windowitem;
	trySelf: @boolean;
do pt -> private.children.findHitObject -> theHitObject[];
	(if theHitObject[]//none then
		true -> trySelf;
	else
		theHitObject.position -> pt.subTract;
		(not (pt ->  theHitObject.handleCursor)) -> trySelf;
	if);
	(if trySelf then
		pt -> defaultHandleCursorMethod -> value;
	else
		true -> value;
	if);
#)

-- UIENVcanvasOnActivate: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onActivate;
		#);
	inner onActivate;
#)

-- UIENVcanvasOnDeactivate: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onDeactivate;
		#);
	inner onDeactivate;
#)

-- UIENVcanvasOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- UIENVcanvasOnRefresh: descriptor --
(#
do scan
		(#
		do current.theEventHandler.onRefresh;
		#);
	inner onRefresh;
#)

-- UIENVcanvasOnMouseUp: descriptor --
(#
do inner onMouseUp;
#)

-- UIENVcanvasOnFrameChanged: descriptor --
(#
do private.children.scan
		(#
		do (oldFrame,newFrame) -> current.processFatherFrameChanged;
		#);
	inner onFrameChanged;
#)

-- UIENVcanvasSelectionAdd: descriptor --
(#
do (if theWindowitem[] -> private.selection.has//false then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);
#)

-- UIENVcanvasSelectionSet: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;
#)

-- UIENVcanvasSelectionRemove: descriptor --
(#
do (if theWindowitem[] -> private.selection.has then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);
#)

-- UIENVcanvasSelectionEmpty: descriptor --
(#
do private.selection.empty -> value;
#)

-- UIENVcanvasSelectionScan: descriptor --
(#
do private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- UIENVcanvasSelectionClear: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
#)

-- UIENVcanvasScan: descriptor --
private.children.scan
(#
do current[] -> this(scan).current[];
	inner scan;
#)

-- UIENVcanvasCreate: descriptor --
(#
do inner create;
#)

-- UIENVcanvasOpen: descriptor --
(#
do false -> updateOnResize;
	&canvasMethods[] -> windowItemMethods;
	inner open;
#)

-- UIENVcanvasClose: descriptor --
(#
do inner close;
	scan
		(#
		do current.close;
		#);
#)

-- UIENVcanvasPrintOpenPage: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- UIENVsharedWindowAddDisplay: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- UIENVsharedWindowRemoveDisplay: descriptor --
(#
do (* not implemented yet !!! *)
#)

-- cursorLib: attributes --
cursorHandle:
	(#
	enter private.cursorHandle
	exit private.cursorHandle
	#);
readCursorResource:
	(#	id: @integer;
	enter id
	do id -> GetCursor -> cursorHandle;
	#);

-- UIENVcursorPrivate: descriptor --
(# cursorHandle: @integer;
#)

-- UIENVtextStyleSetName: descriptor --
(# sr: @shortRef;
do (theName,sr[]) -> GetFNum;
	sr -> familyID;
#)

-- UIENVtextStyleGetName: descriptor --
(# ps: @pascalString;
do (familyID,ps[]) -> GetFontName;
	ps.getText -> theName[];
#)

-- UIENVtextStyleSetSize: descriptor --
(#
do value -> textStyleSize;
#)

-- UIENVtextStyleGetSize: descriptor --
(#
do textStyleSize -> value;
#)

-- UIENVtextStyleSetFace: descriptor --
(#
do value -> textStyleFace;
#)

-- UIENVtextStyleGetFace: descriptor --
(#
do textStyleFace -> value;
#)

-- UIENVtextStyleAscent: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent -> value;
#)

-- UIENVtextStyleDescent: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.descent -> value;
#)

-- UIENVtextStyleLeading: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.leading -> value;
#)

-- UIENVtextStyleHeight: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.ascent + info.descent -> value;
#)

-- UIENVtextStyleMaxChWidth: descriptor --
(# info: ^FontInfo;
do getInfo -> info[];
	info.widMax -> value;
#)

-- UIENVtextStyleWidthOfChar: descriptor --
(#
do withTextStyle
		(#
		do ch -> CharWidth -> value;
		#);
#)

-- UIENVtextStyleStringWidth: descriptor --
(#
do withTextStyle
		(#
		do (@@str.T[1],0,str.lgth) -> TextWidth -> value;
		#);
#)

-- UIENVtextStyleFamilySizes: descriptor --
(#
do (* Not Implemented !!!*)
#)

-- UIENVTextStyleWithTextStyle: descriptor --
(#	port: @longInt;
do port[] -> GetPort;
	utilityPort -> SetPort;
	familyID -> TextFont;
	textStyleSize -> TextSize;
	textStyleFace -> TextFace;
	inner withTextStyle;
	port -> SetPort;
#)


-- UIENVclipBoardHasText: descriptor --
(#	length: @integer;
	offset: @longInt;
	TextType: (# exit 1413830740 #);
do (0,TextType,offset[]) -> GetScrap -> length;
	(length >= 0) -> value;
#)

-- UIENVclipBoardSetText: descriptor --
(# ignore: @integer;
	TextType: (# exit 1413830740 #);
do	ZeroScrap -> ignore;
	(txt.lgth,TextType,@@txt.T[1]) -> PutScrap -> ignore;
#)

-- UIENVclipBoardGetText: descriptor --
(#	length: @integer;
	offset: @longInt;
	TextType: (# exit 1413830740 #);
	textHndl: @integer;
	address: @integer;
do 0 -> NewHandle -> textHndl;
	(textHndl,TextType,offset[]) -> GetScrap -> length;
	(if length >= 0 then
		&text[] -> txt[];
		length -> txt.extend;
		textHndl -> TOS'%adrGetLong' -> address;
		(address,@@txt.T[1],length) -> BlockMove;
		length -> txt.lgth -> txt.pos;
	if);
	textHndl -> DisposHandle;
#)

-- UIENVclipBoardClearContents: descriptor --
(# ignore: @integer;
do	ZeroScrap -> ignore;
#)

-- UIENVmousePosition: descriptor --
(#	macPt: @macPoint;
do	macPt[] -> GetMouse;
	macPt.getPoint -> pt;
#)

-- UIENVmouseGlobalPosition: descriptor --
(#	event: @eventRecord;
	ignore: @integer;
	macPt: @macPoint;
do	(everyEvent,event[]) -> OSEventAvail -> ignore;
	event.where -> macPt;
	macPt.getPoint -> pt;
#)

-- UIENVmouseButtonState: descriptor --
(#
do	Button -> value;
#)

-- UIENVmouseTheCursorSet: descriptor --
(#	g: @globVars;
	h: @integer;
do	(if theCur.cursorHandle//0 then
		g.init;
		g.arrowAddress -> SetCursor;
	else
		theCur.cursorHandle -> h;
		h -> TOS'%adrGetLong' -> SetCursor;
	if);
#)

-- UIENVmouseTheCursorGet: descriptor --
(#
do	(* Not implemented !!! *)
#)

-- UIENVsystemScreenRectangle: descriptor --
(# g: @globVars;
do	g.init;
	g.screenBitsBoundsBR -> theRectangle.bottomRight;
#)

-- UIENVsystemScreenRgn: descriptor --
(# 
do	(* Not implemented !!! *)
#)

-- UIENVsystemBeepBody: descriptor --
(#
do	2 -> SysBeep;
#)

-- UIENVsystemWaitBody: descriptor --
(# ignore: @longInt;
do	(ticks,ignore[]) -> Delay;
#)

-- UIENVdoSetUp: descriptor --
(# initCursorRgn:
		(#
		do	NewRgn -> cursorRegion;
		#);
	initMenubar:
		(# initAppleMenu:
				(# appleMenuID: (# exit 128 #);
					type: @integer;
				do appleMenuID -> GetMenu -> appleMenu;
					'DRVR' -> toResType -> type;
					(appleMenu,type) -> AddResMenu;
					(appleMenu,0) -> InsertMenu;
				#);
			aMenubar: ^menuBar;
		do 200 -> lastMenuID;
			initAppleMenu;
			&menuBarType[] -> aMenubar[];
			aMenuBar.open;
			aMenubar[] -> theMenubar;
			true -> private.globalMacMenuBar.needsUpdate;
		#);
	consoleStream: stream
		(# consoleWindow: @window
				(#	waitingForInput: @boolean;
					lastPosition: @integer;
					waitForInput:
						(#
						do	
							true -> waitingForInput;
							theTextEditor.contents.length -> lastPosition;
							(lastPosition,lastPosition) -> theTextEditor.contents.selection;
							showModal;
						#);
					theTextEditor: @textEditor
						(#	contentsType::<
								(# eventHandler::<
										(# onBeforeChange::<
												(#
												do waitingForInput and (position >= lastPosition) -> allow;
												#);
											onKeyDown::<
												(#
												do (if ch//13 then
														buffer.clear;
														(lastPosition,length)  -> scanText
															(#
															do ch -> buffer.put;
															#);
														0 -> buffer.setPos;
														false -> waitingForInput;
														consoleWindow.Hide;
													if);
												#);
										#);
								#);
							open::<
								(#	width,height: @integer;
								do consoleWindow.size -> (width,height);
									((-1,-1),(width+1,height+1)) -> frame;
									true -> bindRight;
									true -> bindBottom;
								#);
						#);
					open::<
						(#	r: @rectangle;
						do hide;
							system.screenRectangle -> r;
							r.bottom div 2 -> r.top;
							(4,4) -> r.inset;
							r -> frame;
							theTextEditor.open;
							theTextEditor[] -> target;
							'Console Window' -> title;
						#);
					append:
						(# t: ^text;
						enter t[]
						do private.windowPointer -> ShowWindow;
							(theTextEditor.contents.length,theTextEditor.contents.length)
								-> theTextEditor.contents.selection;
							t[] -> theTextEditor.contents.insert;
						#);
				#);
			put::<
				(# t: @text;
				do ch -> t.put;
					t[] -> consoleWindow.append;
				#);
			putText::<
				(#
				do t[] -> consoleWindow.append;
					true -> doneInInner;
				#);
			buffer: @text;
			whenInput:
				(# nonBlank: @boolean;
				enter nonBlank
				do loop: 
						(if true then
							(if nonBlank then
								buffer.scanBlanks;
							if);
							(if buffer.eos
							then
								consoleWindow.waitForInput;
								restart loop;
							else
								inner;
							if);
						if);
				#);
			get::<
				(# 
				do whenInput
						(#
						do buffer.get -> ch;
						#);
				#);
			getAtom::<
				(#
				do true -> whenInput
						(#
						do buffer.getAtom -> t[];
						#);
					true -> doneInInner;
				#);
			getLine::<
				(#
				do whenInput
						(#
						do buffer.getLine -> t[];
						#);
					true -> doneInInner;
				#);
			eos::<
				(#
				do false -> value;
				#);
			init: (# do buffer.clear;consoleWindow.open; #);
		#);
	initConsole:
		(# theConsole: ^consoleStream;
		do &consoleStream[] -> theConsole[] -> screen[] -> keyBoard[];
			theConsole.init;
		#);
	initUtilityPort:
		(#
		do 108 -> NewPtr -> utilityPort;
			utilityPort -> OpenPort;
		#);
	initCursors:
		(#
		do 1 -> cursors.iBeam.readCursorResource;
			2 -> cursors.cross.readCursorResource;
			3 -> cursors.plus.readCursorResource;
			4 -> cursors.watch.readCursorResource;
		#);
	initPatterns:
		(#	globals: @globVars;
		do globals.init;
			&raster[] -> patterns.black[];
			globals.blackAddress -> patterns.black.copyPatternData;
			
			&raster[] -> patterns.white[];
			globals.whiteAddress -> patterns.white.copyPatternData;
			
			&raster[] -> patterns.dkGray[];
			globals.dkGrayAddress -> patterns.dkGray.copyPatternData;
			
			&raster[] -> patterns.gray[];
			globals.grayAddress -> patterns.gray.copyPatternData;
			
			&raster[] -> patterns.ltGray[];
			globals.ltGrayAddress -> patterns.ltGray.copyPatternData;
		#);
do initCursorRgn;
	initMenubar;
	modeless -> modalState;
	initConsole;
	initUtilityPort;
	initCursors;
	initPatterns;
#)

-- UIenvDoPart: descriptor --
(#
do 
	doSetup;
	inner uienv;
	mainLoop
#)

-- UIENVactiveWindow: descriptor --
(# windowPointer: @integer;
do	FrontWindow -> windowPointer;
	(if windowPointer//0 then
		none -> theWindow[];
	else
		windowPointer -> private.windows.findBywindowPointer -> theWindow[];
	if);
#)

-- UIENVwindowsFindBywindowPointer: descriptor --
(#
do	l: scan
		(#
		do (if current.private.windowPointer//windowPointer then
				current[] -> e[];
				leave l;
			if);
		#);
#)

-- UIENVInterfaceObjectPutLayout: Descriptor --
(#
do (* Not Implemented !!! *)
#)

-- UIENVsaveRestoreFocus: descriptor --
(#
	currentPort: @longInt;
	currentClip: @integer;
	currentOrigin: @point;
	saveState:
		(#	grafPort: @grafPortRecord;
			bounds: @rectangle;
		do currentPort[] -> GetPort;
			(if currentPort<>0 then
				grafPort.portRectangle -> bounds;
				bounds.topLeft -> currentOrigin;
				NewRgn -> currentClip;
				currentClip -> GetClip;
			if);
		#);
	restoreState:
		(#
		do (if currentPort<>0 then
				currentPort -> SetPort;
				currentOrigin -> SetOrigin;
				currentClip -> SetClip;
				currentClip -> DisposeRgn;
			if);
		#);
do saveState;
	inner saveRestoreFocus;
	restoreState;
#)

-- UIENVmacMenuBarappend: descriptor --
(#
do (if theMenu[] -> member//false then
		theMenu[] -> menus.append;
		(theMenu.private.handle,0) -> InsertMenu;
		true -> needsUpdate;
	if);
#)

-- UIENVmacMenuBardelete: descriptor --
(#
do	(if theMenu[] -> member then
		theMenu[] -> menus.at -> menus.delete;
		theMenu.menuID -> DeleteMenu;
		true -> needsUpdate;
	if);
#)

-- UIENVmacMenuBarmember: descriptor --
(#
do theMenu[] -> menus.has -> value;
#)

-- UIENVmacMenuBarFindByName: descriptor --
(#
do l: menus.scan
			(#
			do (if current.name -> name.equalNCS then
					current[] -> theMenu[];
					leave l;
				if);
			#);
#)

-- UIENVmacMenuBarFindByID: descriptor --
(#
do l: menus.scan
			(#
			do (if current.handle//ID then
					current[] -> theMenu[];
					leave l;
				if);
			#);
#)

-- UIENVmacMenuBarInit: descriptor --
(#
do menus.init;
#)

-- UIENVmacMenuBarUpdate: descriptor --
(#
do DrawMenuBar;
	false -> needsUpdate;
#)


--]]
