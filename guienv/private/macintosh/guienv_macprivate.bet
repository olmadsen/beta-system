ORIGIN '../guienvbody';
BODY 'guienv_macbody' 'guienv_macbody2';

INCLUDE '~beta/containers/v1.5/list';
INCLUDE '~beta/maclib/v3.0/memory';
INCLUDE '~beta/maclib/v3.0/events';
INCLUDE '~beta/maclib/v3.0/quickdraw';
INCLUDE '~beta/maclib/v3.0/windows';
INCLUDE '~beta/maclib/v3.0/osutils';
INCLUDE '../../figureitems';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '../linkedlist';

-- interfaceObjectLib: attributes --

assertOpen:
	(# location:<
			(# t: ^text;
			do	INNER;
			exit t[]
			#);
	do (if private.isOpen then
			INNER;
		else
			location -> notOpenedError;
		if);
	#);

actionList: linkedList
  (# element:: action;
  #);
  
-- guienvLib: attributes --

EraseRectangle: external
	(# left, top, right, bottom: @integer;
	enter	 (left, top, right, bottom)
	#);

ResetPen:
	(#
	do	PenNormal;
		blackColor -> foreColor;
		whiteColor -> backColor;
	#);
	
plain: (# exit 1 #);
shadows: (# exit 2 #);
mixed: (# exit 3 #);

normal: (# exit 1 #);
dialog: (# exit 2 #);
utility: (# exit 3 #);

noneBackGround: (# exit 0 #);
whiteBackGround: (# exit 1 #);
grayBackGround: (# exit 2 #);

timerAction:
	(# interval: @integer;
		time: @integer;
	do inner;
	#);

currentLocalPosition:
	(#
	enter private.currentLocalPosition
	exit private.currentLocalPosition
	#);
cursorRegion:
	(#
	enter private.cursorRegion
	exit private.cursorRegion
	#);
modalState:
	(#
	enter private.modalState
	exit private.modalState
	#);
lastMenuID:
	(#
	enter private.lastMenuID
	exit private.lastMenuID
	#);
appleMenu:
	(#
	enter private.appleMenu
	exit private.appleMenu
	#);
utilityPort:
	(#
	enter private.utilityPort
	exit private.utilityPort
	#);
doubleClickPossible:
	(#
	enter private.doubleClickPossible
	exit private.doubleClickPossible
	#);
lastClickTime:
	(#
	enter private.lastClickTime
	exit private.lastClickTime
	#);
lastClickPosition:
	(#
	enter private.lastClickPosition
	exit private.lastClickPosition
	#);
lastClickedObject:
	(#
	enter private.lastClickedObject[]
	exit private.lastClickedObject[]
	#);
sendOnMouseUp:
	(#
	enter private.sendOnMouseUp
	exit private.sendOnMouseUp
	#);
globalMacMenubar:
	(#
	exit private.globalMacMenubar[]
	#);
activeWindow:
	(# theWindow: ^window;
	do <<SLOT GUIENVactiveWindow: descriptor>>
	exit theWindow[]
	#);
modeless: (# exit 1 #);
applicationModal: (# exit 2 #);
systemModal: (# exit 3 #);

makeMacRect:
	(#	r: ^rectangle;
		mr: ^macRect;
	enter r[]
	do &macRect[] -> mr[];
		(mr.R, 0, r.top)    -> TOS'%inxPutShort';
		(mr.R, 2, r.left)   -> TOS'%inxPutShort';
		(mr.R, 4, r.bottom) -> TOS'%inxPutShort';
		(mr.R, 6, r.right)  -> TOS'%inxPutShort'
	exit mr[]
	#);
makeMacPoly:
	(#	points: [0] ^point;
		macPoly: @integer;
	enter points
	do withUtilityPort
			(#
			do OpenPoly -> macPoly;
				points[1] -> MoveTo;
				(for inx: points.range - 1 repeat
					points[inx + 1] -> LineTo;
				for);
				points[1] -> LineTo;
				ClosePoly;
			#);
	exit macPoly
	#);
withUtilityPort:
	(#	currentPort: @longInt;
	do currentPort[] -> GetPort;
		utilityPort -> SetPort;
		inner;
		currentPort -> SetPort;
	#);
savePenState:
	(# 
	do
		inner;
		
	#);
macMenuBar:
	(#	menus: @list
			(# element::< menu;
			#);
		append:
			(# theMenu: ^menu;
			enter theMenu[]
			do <<SLOT GUIENVmacMenuBarappend: descriptor>>;
			#);
		delete:
			(# theMenu: ^menu;
			enter theMenu[]
			do <<SLOT GUIENVmacMenuBardelete: descriptor>>;
			#);
		member: booleanValue
			(# theMenu: ^menu;
			enter theMenu[]
			do <<SLOT GUIENVmacMenuBarmember: descriptor>>;
			#);
		findByName:
			(# name: ^text;
				theMenu: ^menu;
			enter name[]
			do <<SLOT GUIENVmacMenuBarFindByName: descriptor>>;
			exit theMenu[]
			#);
		findByID:
			(# ID: @integer;
				theMenu: ^menu;
			enter ID
			do <<SLOT GUIENVmacMenuBarFindByID: descriptor>>;
			exit theMenu[]
			#);
		init:
			(# do <<SLOT GUIENVmacMenuBarInit: descriptor>>; #);
		update:
			(# do <<SLOT GUIENVmacMenuBarUpdate: descriptor>>; #);
		adjust:
			(#
			<<SLOT MacMenuBarAdjust: doPart>>
			#);
		needsUpdate: @boolean;
	#);
debug: trace
	(# putLine: @msg.putLine;
		putInt: @msg.putInt;
		put: @msg.put;
		putText: @msg.putText;
		putPoint:
			(#	pt: @point;
			enter pt
			do pt.h -> putInt;
				' ' -> put;
				pt.v -> putInt;
			#);
		putRect:
			(# r: @rectangle;
			enter r
			do r.topLeft -> putPoint;
				' ' -> put;
				r.bottomRight -> putPoint;
			#);
		msg: @text;
		DebugStr: External 
			(# str: [1] @Char; 
			enter str
			do '$ABFF' -> PascalTrap;
			#);
	do inner;
		msg -> debugStr;
	#);

updateCursor:
	(# immediate: @boolean;
	enter	immediate
	do (if immediate then
			doUpdateCursor;
		else
			true -> private.updateCursorFlag;
		if);
	#);
doUpdateCursor: (# <<SLOT GUIENVdoUpdateCursor: doPart>> #);
-- GUIENVPrivate: descriptor --
(# gray: [12] @color;
	black: @color;
	white: @color;
	initColors:
		(#
		do (0, 0, 0) -> black; 
			(65535, 65535, 65535) -> white;
			(61166, 61166, 61166) -> gray[1];
			(56797, 56797, 56797) -> gray[2];
			(52428, 52428, 52428) -> gray[3];
			(48059, 48059, 48059) -> gray[4];
			(43690, 43690, 43690) -> gray[5];
			(39321, 39321, 39321) -> gray[6];
			(34952, 34952, 34952) -> gray[7];
			(30583, 30583, 30583) -> gray[8];
			(26214, 26214, 26214) -> gray[9];
			(21845, 21845, 21845) -> gray[10];
			(17476, 17476, 17476) -> gray[11];
			(8738, 8738, 8738) -> gray[12];
			
			gray[2][] -> backGround[];
		#);
		
	globals: @globVars;
	
	globalTheText: @text;
	grayPixPat, whitePat: @integer;
	backGround: ^color;
	done: @boolean; (* True when the eventloop should terminate *)
	cursorRegion, emptyRgn, wideRgn: @integer;
	updateCursorFlag: @boolean;
	event: @
		(# address: @integer;
			init:
				(#
				do 16 -> NewPtr -> address;
				#);
			what: @(# value: @integer  do address + 0 -> TOS'%adrGetShort' -> value; exit value #);
			message: @(# value: @integer  do address + 2 -> TOS'%adrGetLong' -> value; exit value #);
			keyCode: @(# value: @integer  do address + 4 -> TOS'%adrGetByte' -> value; exit value #);
			charCode: @(# value: @integer  do address + 5 -> TOS'%adrGetByte' -> Value; exit value #);
			when: @(# value: @integer  do address + 6 -> TOS'%adrGetLong' ->value; exit value #);
			where: @(# value: @integer  do address + 10 -> TOS'%adrGetLong' ->value; exit value #);
			modifiers: @(# value: @integer  do address + 14 -> TOS'%adrGetShort' -> value; exit value #);
			app4Selector: @(# value: @integer  do address + 2 -> TOS'%adrGetByte' -> value; exit value #);
			childDiedStatus: @(# value: @integer  do address + 3 -> TOS'%adrGetByte' -> value; exit value #);
			resume: @(# b: @Boolean exit message -> TOS'%GetBits[31,1]' -> b #);
			scrapDataHasChanged: @(# b: @Boolean exit message -> TOS'%GetBits[30,1]' -> b #);
			activeFlag: @(# b: @Boolean exit modifiers -> TOS'%GetBits[31,1]' -> b #);
			btnState: @(# b: @Boolean exit modifiers -> TOS'%GetBits[24,1]' -> b #);
			cmdKey: @(# b: @Boolean exit modifiers -> TOS'%GetBits[23,1]' -> b #);
			shiftKey: @(# b: @Boolean exit modifiers -> TOS'%GetBits[22,1]' -> b #);
			alphaLock: @(# b: @Boolean exit modifiers -> TOS'%GetBits[21,1]' -> b #);
			optionKey: @(# b: @Boolean exit modifiers -> TOS'%GetBits[20,1]' -> b #);
			controlKey: @(# b: @Boolean exit modifiers -> TOS'%GetBits[19,1]' -> b #);
		#);
	currentLocalPosition: @point;
	modalState: @integer;
	activeWindow: ^window;
	windows: @list
		(# element::< window;
			findBywindowPointer:
				(# e: ^element;
					windowPointer: @integer;
				enter windowPointer
				do <<SLOT GUIENVwindowsFindBywindowPointer: descriptor>>;
				exit e[]
				#);
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
		#);
	menus: @list
		(# element::< menu;
			findByID:
				(# ID: @integer;
					e: ^element;
				enter ID
				do	l: scan
						(#
						do (if current.private.menuID//ID then
								current[] -> e[];
							if);
						#);
				exit e[]
				#);
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
		#);
	theMenubar: ^menubarType;
	globalMacMenubar: @macMenuBar;
	lastMenuID: @integer;
	appleMenu: @integer;
	utilityPort: @integer;
	doubleClickPossible: @boolean;
	lastClickTime: @integer;
	lastClickPosition: @point;
	lastClickedObject: ^window.windowItem;
	sendOnMouseUp: @boolean;
	
	timerQueue: @
		(# R: [16] ^timerAction;
			top: @integer;
			lastVisit: @integer;
			minInterval: @integer;
			init:
				(#
				<<SLOT TimerQueueInit: doPart>>
				#);
			insert:
				(# action: ^timerAction;
					inserted: @boolean;
				enter	action[]
				<<SLOT TimerQueueInsert: doPart>>
				#);
			delete:
				(# action: ^timerAction;
				enter	action[]
				<<SLOT TimerQueueDelete: doPart>>
				#);
			scan:
				(# current: ^timerAction;
				<<SLOT TimerQueueScan: doPart>>
				#);
			executeElapsed: @
				(# currentTime: @integer;
					interval: @integer;
					inx: @integer;
					current: ^timerAction;
				<<SLOT TimerQueueExecuteElapsed: doPart>>
				#);
		#);
#)

-- windowLib: attributes --
setupPort:
	(#
	do this(window).private.windowPointer -> SetPort;
		(0, 0) -> SetOrigin;
		INNER;
	#);
	
style:
	(#
	enter private.style
	exit private.style
	#);
windowPointer:
	(# 
	enter private.windowPointer
	exit private.windowPointer 
	#);
theMaxSize:
	(#
	enter private.theMaxSize
	exit private.theMaxSize
	#);
theMinSize:
	(#
	enter private.theMinSize
	exit private.theMinSize
	#);
windowTarget:
	(#
	enter private.windowTarget[]
	exit private.windowTarget[]
	#);
windowContents:
	(#
	enter private.windowContents[]
	exit private.windowContents[]
	#);
windowDefaultButton:
	(#
	enter private.windowDefaultButton[]
	exit private.windowDefaultButton[]
	#);
useTextStyle:
	(# style: ^textStyle;
	enter style[]
	do <<SLOT GUIENVwindowUseTextStyle: descriptor>>
	#);
windowActive:
	(#
	enter private.windowActive
	exit private.windowActive
	#);
windowVisible:
	(#
	enter private.windowVisible
	exit private.windowVisible
	#);
windowMenuBar:
	(#
	enter private.windowMenuBar[]
	exit private.windowMenuBar[]
	#);
windowSize:
	(# left, top, right, bottom: @integer;
		topOffset: (# exit 16 #);
		leftOffset: (# exit 18 #);
		bottomOffset: (# exit 20 #);
		rightOffset: (# exit 22 #);
		width, height: @integer;
	do	private.windowPointer + leftOffset -> TOS'%adrGetSignedShort' -> left;
		private.windowPointer + topOffset -> TOS'%adrGetSignedShort' -> top;
		private.windowPointer + rightOffset -> TOS'%adrGetSignedShort' -> right;
		private.windowPointer + bottomOffset -> TOS'%adrGetSignedShort' -> bottom;
		right - left -> width;
		bottom - top -> height;
		debug
			(#
			do width -> putInt;
				' ' ->put;
				height -> putInt;
				newLine;
			#);
	exit (width, height)
	#);
-- GUIENVwindowPrivate: descriptor --
(# windowPointer: @integer;
	doShow: @boolean;
	type: @integer;
	style: @integer;
	theMaxSize: @point;
	theMinSize: @point;
	windowActive: @boolean;
	windowVisible: @boolean;
	windowTarget: ^windowItem;
	windowContents: @canvas
		(# eventHandler::<
				(# onMouseDown::<
						(#
						do this(window).theEventHandler.onMouseDown;
						#);
					onMouseUp::<
						(#
						do this(window).theEventHandler.onMouseUp;
						#);
				#);
			open::
				(#
				do true -> this(windowItem).private.eraseWhenUpdating;
					windowSize -> size;
				#);
		#);
	windowDefaultButton: ^windowItem;
	windowMenuBar: ^menuBarType;
#)

-- menuLib: attributes --
menuID:
	(#
	enter private.menuID
	exit private.menuID
	#);
handle:
	(#
	enter private.handle
	exit private.handle
	#);
menuEnabled:
	(#
	enter private.menuEnabled
	exit private.menuEnabled
	#);
owner:
	(#
	enter private.owner[]
	exit private.owner[]
	#);

-- GUIENVmenuPrivate: descriptor --
(# menuID: @integer;
	handle: @integer;
	name: @text;
	menuEnabled: @boolean;
	owner: ^menubar;
	menuitems: @list
		(# element::< menuitem;
			findByNumber:
				(# number: @integer;
					e: ^element;
				enter number
				do l: scan
						(#
						do	(if current.private.number//number then
								current[] -> e[];
								leave l;
							if);
						#);
				exit e[]
				#);
		#);
#)

-- menuItemLib: attributes --
number:
	(#
	enter private.number
	exit private.number
	#);
menuitemIsSeparator:
	(#
	enter private.menuitemIsSeparator
	exit private.menuitemIsSeparator
	#);

-- GUIENVmenuitemPrivate: descriptor --
(# number: @integer;
	name: @text;
	key,mark: @char;
	subMenu: ^menu;
	face: @integer;
	checked: @boolean;
	menuitemIsSeparator: @boolean;
#)

-- windowitemLib: attributes --


viewable: booleanValue
	(#
	do (if private.visibleFlag then
			(if father[] = NONE then
				this(window).private.windowVisible -> value;
			else
				father.viewable -> value;
			if);
		else
			false -> value;
		if);
	#);
clickable: booleanValue
	(#
	do private.enabledFlag AND private.visibleFlag -> value;
	#);
debugMe:
	(#
	enter private.debugMe
	exit private.debugMe
	#);

drawBorder:
	(# style: @integer;
		r: @rectangle;
	enter (r, style)
	<<SLOT GUIENVwindowItemDrawBorder: doPart>>
	#);

backGroundStyle:
	(#
	enter private.backGroundStyle
	exit private.backGroundStyle
	#);
	
privateOrigin: (# exit (private.originX, private.originY) #);

privateWindowItemFrame:
	(#
	enter	((private.left, private.top), (private.right, private.bottom))
	exit ((private.left, private.top), (private.right, private.bottom))
	#);
privateAutomaticUpdate:
	(#
	enter private.automaticUpdate
	exit private.automaticUpdate
	#);

updateMaybe:
	(#
	do (if private.automaticUpdate then update if);
	#);


getVisibleRgn:
	(# rgn: @integer;
	do (if private.visibleRgn = 0 then
			calculateVisibleRgn -> private.visibleRgn;
		if);
		private.visibleRgn -> rgn;
	exit rgn
	#);
calculateVisibleRgn:
	(# rgn: @integer;
	<<SLOT windowItemCalculateVisibleRgn: doPart>>
	exit rgn
	#);
forgetVisibleRgn:
	(# tellBrothers: @boolean;
	enter tellBrothers
	<<SLOT windowItemForgetVisibleRgn: doPart>>
	#);
brotherForgetVisibleRgn:
	(#
	<<SLOT windowItemBrotherForgetVisibleRgn: doPart>>
	#);
	
calculateOrigin:
	(#
	<<SLOT windowItemCalculateOrigin: doPart>>
	#);
	
getDrawingRgn:
   (*
	 * The clip region when drawing in the windowitem
	 * will be copied into the "rgn" that should be
	 * allocated before calling getDrawingRgn.
	 *)
	(# rgn: @integer;
	enter rgn
	<<SLOT windowItemGetDrawingRgn: doPart>>
	#);
	

setupClipForDrawing: setupPortForDrawing
	(# drawingRgn: @integer;
	do NewRgn -> drawingRgn;
		drawingRgn -> getDrawingRgn;
		(drawingRgn, -private.originX, -private.originY) -> OffsetRgn;
		drawingRgn ->SetClip;
		drawingRgn -> DisposeRgn;
		INNER;
	#);
setupPortForDrawing:
	(#
	do this(window).private.windowPointer -> SetPort;
		(-private.originX, -private.originY) -> SetOrigin;
		INNER;
	#);

setupPortWideClip: setupPort
	(#
	do this(guienv).private.wideRgn -> SetClip;
		INNER;
	#);
setupPortClipEmpty: setupPort
	(#
	do this(guienv).private.emptyRgn -> SetClip;
		INNER;
	#);
setupPortForToolBox: setupPort
	(# visRgn: @integer;
	do getVisibleRgn -> visRgn;
		visRgn -> SetClip;
		INNER;
	#);
	
invalVisibleRgn:
	(# visRgn: @integer;
	do setupPortWideClip
			(#
			do getVisibleRgn -> visRgn;
				(if false then
					(#
					do ResetPen;
						(visRgn, this(guienv).private.globals.grayAddress) -> FillRgn;
						30 -> system.wait;
					#);
				if);
				visRgn -> InvalRgn;
			#);
	#);
invalFrame:
	(#  r: @rectangle;
	do privateOrigin -> r.topLeft;
		size -> r.size;
		(if true then
			this(windowItem)[] -> getPatternName -> putText;
			'.invalFrame ' -> putText;
			'[' -> put;
			r.left -> putInt;
			' ' -> put;
			r.top -> putInt;
			' ' -> put;
			r.right -> putInt;
			' ' -> put;
			r.bottom -> putInt;
			']' -> put;
			newLine;
		if);
		setupPortWideClip
			(# 
			do r[] -> makeMacRect -> InvalRect;
			#);
	#);

	
hit: booleanValue
	(# pt: @point;
	enter pt
	<<SLOT GUIENVwindowItemHit: doPart>>
	#);

handleCursor: booleanValue
	(#	pt: @point;
	enter pt
	<<SLOT GUIENVwindowItemHandleCursor: doPart>>
	#);
	
	
windowItemCursor:
	(#
	enter private.windowItemCursor[]
	exit private.windowItemCursor[]
	#);
	
toScreenCoordinates:
	(# p, q: @point;
	enter p
	<<SLOT GUIENVwindowItemToScreenCoordinates: doPart>>
	exit q
	#);
	
-- GUIENVinterfaceObjectPrivate: descriptor --
(# beforeActions,afterActions: ^actionList;
	isOpen: @boolean;
#)

-- GUIENVwindowitemPrivate: descriptor --
(# originX, originY: @integer;
	visibleRgn: @integer; (* Region handle *)
	background: ^color;
	backGroundStyle: @integer;
	left, top, right, bottom: @integer;
	visibleFlag,enabledFlag,hiliteFlag,
	automaticUpdate,updateOnResize, borderVisibleFlag, isFigureItem: @boolean;
	borderStyle: @integer;
	windowItemCursor: ^cursor;
	eraseWhenUpdating: @boolean;
	debugMe: @boolean;
	
#)

-- canvasLib: attributes --


getChildPosition:
	(*
	 * Cannot be used to find a figureitem, since they are
	 * placed in the  "figs" list
	 *)
	(# child: ^windowItem;
		pos: ^private.children.theCellType;
	enter	child[]
	do child[] -> private.children.at -> pos[]
	exit pos[]
	#);
getPrevSibling:
	(# child: ^windowItem;
		pos: ^private.children.theCellType;
		prevSibling: ^windowItem;
	enter child[]
	do child[] -> getChildPosition -> pos[];
		(if pos.pred[] <> NONE then
			pos.pred.elm[] -> prevSibling[];
		if);
	exit prevSibling[]
	#);


findObjectClicked:
	(# pt: @point;
		ObjectClicked: ^windowItem;
	enter pt
	<<SLOT GUIENVcanvasFindObjectClicked: doPart>>
   exit ObjectClicked[]
	#);
	


-- GUIENVcanvasPrivate: descriptor --
(# children: @list
		(# element:: windowItem;
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
			findObjectClicked:
				(# pt: @point;
					e: ^element;
				enter pt
				do l: scanReverse
						(# where::<
								(#
								do (if current.clickable then
										pt -> current.hit -> value;
									else
										false -> value;
									if);
								#);
						do current[] -> e[];
							leave l;
						#);
				exit e[]
				#);
		#);
	figs: @list
		(# element:: figureItem;
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
			findObjectClicked:
				(# pt: @point;
					e: ^element;
				enter pt
				do l: scanReverse
						(# where::<
								(#
								do (if current.clickable then
										pt -> current.hit -> value;
									else
										false -> value;
									if);
								#);
						do current[] -> e[];
							leave l;
						#);
				exit e[]
				#);
		#);
	selection: @list
     (# 
        element::< windowitem;
     #);
#)

-- textStyleLib: attributes --
familyID:
	(#
	enter private.familyID
	exit private.familyID
	#);
textStyleSize:
	(#
	enter private.textStyleSize
	exit private.textStyleSize
	#);
textStyleFace:
	(#
	enter private.textStyleFace
	exit private.textStyleFace
	#);
textStyleAttributes:
	(#
	enter (familyID,textStyleSize,textStyleFace)
	exit (familyID,textStyleSize,textStyleFace)
	#);
getInfo:
	(# info: ^FontInfo;
	do &FontInfo[] -> info[];
		withTextStyle
			(#
			do info[] -> GetFontInfo;
			#);
	exit info[]
	#);
withTextStyle:
	(#
	do <<SLOT GUIENVTextStyleWithTextStyle: descriptor>>
	#);
-- GUIENVtextStylePrivate: descriptor --
(# familyID,textStyleSize,textStyleFace: @integer;
#)

