ORIGIN '../guienvbody';
BODY 'guienv_macbody' 'guienv_macbody2' 'pixmapbody' 'timerbody';

INCLUDE '~beta/maclib/memory';
INCLUDE '~beta/maclib/events';
INCLUDE '~beta/maclib/quickdraw';
INCLUDE '~beta/maclib/windows';
INCLUDE '~beta/maclib/osutils';
INCLUDE '~beta/maclib/menus';

INCLUDE '~beta/containers/list';

INCLUDE '../../figureitems';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '../linkedlist';
INCLUDE '../../graphics';

-- interfaceObjectLib: attributes --

assertOpen:
	(# location:<
			(# t: ^text;
			do	INNER;
			exit t[]
			#);
	do (if private.isOpen then
			INNER;
		else
			location -> notOpenedError;
		if);
	#);

actionList: linkedList
  (# element:: action;
  #);
  
-- guienvLib: attributes --


GetActiveMenubar:
	(# mbar: ^Menubar;
	<<SLOT GUIenvGetActiveMenubar: doPart>>
	exit mbar[]
	#);

maskBitmap: macBitmap
	(# top: Short (# Pos::< (# do 6->Value;  #);  #);
		left: Short (# Pos::< (# do 8->Value;  #);  #);
		bottom: Short (# Pos::< (# do 10->Value;  #);  #);
		right: Short (# Pos::< (# do 12->Value;  #);  #);
	#);

gworldKind: (# exit 1 #);
iconSuiteKind: (# exit 2 #);


memoryFailure: exception
  (#
  do 'Out of ToolBox Memory' -> msg.append;
  #);

EraseRectangle: external
	(# left, top, right, bottom: @integer;
	enter	 (left, top, right, bottom)
	#);

ResetPen:
	(#
	do	PenNormal;
		blackColor -> foreColor;
		whiteColor -> backColor;
	#);
	
plain: (# exit 1 #);
shadows: (# exit 2 #);
mixed: (# exit 3 #);

normal: (# exit 1 #);
dialog: (# exit 2 #);
utility: (# exit 3 #);

noneBackGround: (# exit 0 #);
whiteBackGround: (# exit 1 #);
grayBackGround: (# exit 2 #);

timerAction:
	(# interval: @integer;
		time: @integer;
	do inner;
	#);

currentLocalPosition:
	(#
	enter private.currentLocalPosition
	exit private.currentLocalPosition
	#);
cursorRegion:
	(#
	enter private.cursorRegion
	exit private.cursorRegion
	#);
modalState:
	(#
	enter private.modalState
	exit private.modalState
	#);
lastMenuID:
	(#
	enter private.lastMenuID
	exit private.lastMenuID
	#);
appleMenu:
	(#
	enter private.appleMenu
	exit private.appleMenu
	#);
utilityPort:
	(#
	enter private.utilityPort
	exit private.utilityPort
	#);
doubleClickPossible:
	(#
	enter private.doubleClickPossible
	exit private.doubleClickPossible
	#);
lastClickTime:
	(#
	enter private.lastClickTime
	exit private.lastClickTime
	#);
lastClickPosition:
	(#
	enter private.lastClickPosition
	exit private.lastClickPosition
	#);
lastClickedObject:
	(#
	enter private.lastClickedObject[]
	exit private.lastClickedObject[]
	#);
sendOnMouseUp:
	(#
	enter private.sendOnMouseUp
	exit private.sendOnMouseUp
	#);
activeWindow:
	(# theWindow: ^window;
	<<SLOT GUIENVactiveWindow: doPart>>
	exit theWindow[]
	#);
modeless: (# exit 1 #);
applicationModal: (# exit 2 #);
systemModal: (# exit 3 #);

makeMacRect:
	(#	r: ^rectangle;
		mr: ^MacRect;
	enter r[]
	do &macRect[] -> mr[];
		r.top -> mr.r.top;
		r.left -> mr.r.left;
		r.right -> mr.r.right ;
		r.bottom -> mr.r.bottom;
	exit mr[]
	#);
makeMacPoly:
	(#	points: [0] ^point;
		macPoly: @integer;
	enter points
	do withUtilityPort
			(#
			do OpenPoly -> macPoly;
				points[1] -> MoveTo;
				(for inx: points.range - 1 repeat
					points[inx + 1] -> LineTo;
				for);
				points[1] -> LineTo;
				ClosePoly;
			#);
	exit macPoly
	#);
withUtilityPort:
	(#	currentPort: @longInt;
	do currentPort[] -> GetPort;
		utilityPort -> SetPort;
		inner;
		currentPort -> SetPort;
	#);

menuList: list
	(# element:: menu;
		findByID: find
			(# ID: @integer;
				predicate:: (# do current.private.menuID = ID -> value #);
			enter ID
			#);
		findByName: find
			(# name: ^text;
				predicate:: (# do current.name -> name.equalNCS -> value #);
			enter name[]
			#);
		remove:
			(# elm: ^element;
			enter elm[]
			do elm[] -> at -> delete;
			#);
	#);
updateMenubarFlag:
	(#
	enter private.updateMenubarFlag
	exit private.updateMenubarFlag
	#);

debug: trace
	(# putLine: @msg.putLine;
		putInt: @msg.putInt;
		put: @msg.put;
		putText: @msg.putText;
		putPoint:
			(#	pt: @point;
			enter pt
			do pt.h -> putInt;
				' ' -> put;
				pt.v -> putInt;
			#);
		putRect:
			(# r: @rectangle;
			enter r
			do r.topLeft -> putPoint;
				' ' -> put;
				r.bottomRight -> putPoint;
			#);
		msg: @text;
		DebugStr: External 
			(# str: [1] @Char; 
			enter str
			do '$ABFF' -> PascalTrap;
			#);
	do inner;
		msg -> debugStr;
	#);

updateCursor:
	(# immediate: @boolean;
	enter	immediate
	do (if immediate then
			doUpdateCursor;
		else
			true -> private.updateCursorFlag;
		if);
	#);
doUpdateCursor: (# <<SLOT GUIENVdoUpdateCursor: doPart>> #);


-- GUIENVPrivate: descriptor --
(# updateMenubarFlag: @boolean;
	disabled: @boolean;
   defaultFileMenu: @menu
		(#	quitItem: @menuItem
				(# eventHandler::
						(# onSelect::
								(#
								do Terminate;
								#);
						#);
					open::
						(#
						do 'Quit' -> name;
							'Q' -> key;
						#);
				#);
			open::
				(#
				do 'File' -> name;
					quitItem.open;
					quitItem[] -> append;
				#);
		#);

	gray: [12] @color;
	black: @color;
	white: @color;
	hiliteColor: @color;
	aboutAction: ^object; (* This hook can be used to override what
								  * happens when the user chooses about.
								  * If you really need to!
								  *)
								  
	eventHook: ^object; (* Called once during each cycle in the eventloop *)
	
	movieControllers: @list
		(# element:: integerObject;
		#);
	
	GetHiliteColor: External
		(# windowPtr: @integer;
			rgb: ^RGBColor;
		enter (windowPtr, rgb[])
		#);
	
	initColors:
		(# rgb: @RGBColor;
		do (0xFFFF, 0xFFFF, 0xFFFF) -> white;
			(0xEEEE, 0xEEEE, 0xEEEE) -> gray[1];
			(0xDDDD, 0xDDDD, 0xDDDD) -> gray[2];
			(0xCCCC, 0xCCCC, 0xCCCC) -> gray[3];
			(0xBBBB, 0xBBBB, 0xBBBB) -> gray[4];
			(0xAAAA, 0xAAAA, 0xAAAA) -> gray[5];
			(0x9999, 0x9999, 0x9999) -> gray[6];
			(0x8888, 0x8888, 0x8888) -> gray[7];
			(0x7777, 0x7777, 0x7777) -> gray[8];
			(0x6666, 0x6666, 0x6666) -> gray[9];
			(0x5555, 0x5555, 0x5555) -> gray[10];
			(0x4444, 0x4444, 0x4444) -> gray[11];
			(0x2222, 0x2222, 0x2222) -> gray[12];
			(0, 0, 0) -> black; 
			
			gray[2][] -> backGround[];
			
			(utilityPort, rgb[]) -> GetHiliteColor;
			rgb.red -> hiliteColor.red;
			rgb.green -> hiliteColor.green;
			rgb.blue -> hiliteColor.blue;
		#);
		
	globals: @globVars;
	
	globalTheText: @text;
	grayPixPat, whitePat: @integer;
	backGround: ^color;
	done: @boolean; (* True when the eventloop should terminate *)
	cursorRegion, emptyRgn, wideRgn: @integer;
	updateCursorFlag: @boolean;
	
	event: @EventInterface;
	
	currentLocalPosition: @point;
	modalState: @integer;
	activeWindow: ^window;
	windows: @list
		(# element::< window;
			findBywindowPointer:
				(# e: ^element;
					windowPointer: @integer;
				enter windowPointer
				<<SLOT GUIENVwindowsFindBywindowPointer: doPart>>
				exit e[]
				#);
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
		#);
	menus: @menulist;
	
	mbar: @menulist;
	
	theMenubar: ^menubarType;
	lastMenuID: @integer;
	appleMenu: @integer;
	utilityPort: @integer;
	doubleClickPossible: @boolean;
	lastClickTime: @integer;
	lastClickPosition: @point;
	lastClickedObject: ^window.windowItem;
	sendOnMouseUp: @boolean;
	
	timerQueue: @
		(# R: [16] ^timerAction;
			top: @integer;
			lastVisit: @integer;
			minInterval: @integer;
			init:
				(#
				<<SLOT TimerQueueInit: doPart>>
				#);
			insert:
				(# action: ^timerAction;
					inserted: @boolean;
				enter	action[]
				<<SLOT TimerQueueInsert: doPart>>
				#);
			delete:
				(# action: ^timerAction;
				enter	action[]
				<<SLOT TimerQueueDelete: doPart>>
				#);
			scan:
				(# current: ^timerAction;
				<<SLOT TimerQueueScan: doPart>>
				#);
			executeElapsed: @
				(# currentTime: @integer;
					interval: @integer;
					inx: @integer;
					current: ^timerAction;
				<<SLOT TimerQueueExecuteElapsed: doPart>>
				#);
		#);
#)

-- windowLib: attributes --

	
style:
	(#
	enter private.style
	exit private.style
	#);
windowPointer:
	(# 
	enter private.windowPointer
	exit private.windowPointer 
	#);
theMaxSize:
	(#
	enter private.theMaxSize
	exit private.theMaxSize
	#);
theMinSize:
	(#
	enter private.theMinSize
	exit private.theMinSize
	#);
windowTarget:
	(#
	enter private.windowTarget[]
	exit private.windowTarget[]
	#);
windowContents:
	(#
	enter private.windowContents[]
	exit private.windowContents[]
	#);
windowDefaultButton:
	(#
	enter private.windowDefaultButton[]
	exit private.windowDefaultButton[]
	#);
useTextStyle:
	(# style: ^textStyle;
	enter style[]
	<<SLOT GUIENVwindowUseTextStyle: doPart>>
	#);
windowActive:
	(#
	enter private.windowActive
	exit private.windowActive
	#);
windowVisible:
	(#
	enter private.windowVisible
	exit private.windowVisible
	#);
windowMenuBar:
	(#
	enter private.windowMenuBar[]
	exit private.windowMenuBar[]
	#);
windowSize:
	(# left, top, right, bottom: @integer;
		topOffset: (# exit 16 #);
		leftOffset: (# exit 18 #);
		bottomOffset: (# exit 20 #);
		rightOffset: (# exit 22 #);
		width, height: @integer;
	do	(%getSignedShortAt(private.windowPointer+leftOffset)) -> left;
	(* Above line tos_converted from: do	private.windowPointer + leftOffset -> TOS'%adrGetSignedShort' -> left; *)
		(%getSignedShortAt(private.windowPointer+topOffset)) -> top;
		(* Above line tos_converted from: private.windowPointer + topOffset -> TOS'%adrGetSignedShort' -> top; *)
		(%getSignedShortAt(private.windowPointer+rightOffset)) -> right;
		(* Above line tos_converted from: private.windowPointer + rightOffset -> TOS'%adrGetSignedShort' -> right; *)
		(%getSignedShortAt(private.windowPointer+bottomOffset)) -> bottom;
		(* Above line tos_converted from: private.windowPointer + bottomOffset -> TOS'%adrGetSignedShort' -> bottom; *)
		right - left -> width;
		bottom - top -> height;
		debug
			(#
			do width -> putInt;
				' ' ->put;
				height -> putInt;
				newLine;
			#);
	exit (width, height)
	#);
-- GUIENVwindowPrivate: descriptor --
(# 
	windowPointer: @integer;
	doShow: @boolean;
	console: @boolean;
	disableUpdate: @boolean;
	type: @integer;
	style: @integer;
	theMaxSize: @point;
	theMinSize: @point;
	windowActive: @boolean;
	windowVisible: @boolean;
	windowTarget: ^windowItem;
	windowContents: @canvas
		(# eventHandler::<
				(# onMouseDown::<
						(#
						do this(window).theEventHandler.onMouseDown;
						#);
					onMouseUp::<
						(#
						do this(window).theEventHandler.onMouseUp;
						#);
				#);
			open::
				(#
				do true -> this(windowItem).private.eraseWhenUpdating;
					windowSize -> size;
				#);
		#);
	windowDefaultButton: ^windowItem;
	windowMenuBar: ^menuBarType;
#)

-- menuLib: attributes --

menuID:
	(#
	enter private.menuID
	exit private.menuID
	#);
handle:
	(#
	enter private.handle
	exit private.handle
	#);
menuEnabled:
	(#
	enter private.menuEnabled
	exit private.menuEnabled
	#);
owner:
	(#
	enter private.owner[]
	exit private.owner[]
	#);
installCount:
	(#
	enter private.installCount
	exit private.installCount
	#);
install:
	(# where: @integer; (* The ID of the menu to install
								* After. 0 means append. -1 means
								* in the hierachical portion
								* of the toolbox menu list.
								* A menu can be installed in
								* the menulist more than once.
								* This is used for popupmenus.
								*)
	enter where
	do (if private.handle <> NIL then
			(private.handle, where) -> InsertMenu;
		 	installCount + 1 -> installCount;
		if);
	#);
deInstall:
	(#
	do (if installCount > 0 then
			menuID -> DeleteMenu;
			installCount -1 -> installCount;
		if);
	#);
deleteFromMbar:
	(#
	do (if menuID <> 0 then
			menuID -> DeleteMenu;
		if);
	#);

-- GUIENVmenuPrivate: descriptor --
(# menuID: @integer;
	handle: @integer;
	installCount: @integer;
	name: @text;
	menuEnabled: @boolean;
	owner: ^menubar;
	menuitems: @list
		(# element::< menuitem;
			findByNumber:
				(# number: @integer;
					e: ^element;
				enter number
				do l: scan
						(#
						do	(if current.private.number//number then
								current[] -> e[];
								leave l;
							if);
						#);
				exit e[]
				#);
		#);
#)

-- menuItemLib: attributes --
number:
	(#
	enter private.number
	exit private.number
	#);
menuitemIsSeparator:
	(#
	enter private.menuitemIsSeparator
	exit private.menuitemIsSeparator
	#);

-- GUIENVmenuitemPrivate: descriptor --
(# number: @integer;
	name: @text;
	key,mark: @char;
	subMenu: ^menu;
	face: @integer;
	checked: @boolean;
	menuitemIsSeparator: @boolean;
#)

-- windowitemLib: attributes --

defaultBehaviour:
	(# exit (NOT private.disableDefaultEventHandling) #);

viewable: booleanValue
	(#
	do (if private.visibleFlag then
			(if father[] = NONE then
				true -> value;
			else
				father.viewable -> value;
			if);
		else
			false -> value;
		if);
	#);
clickable: booleanValue
	(#
	do private.enabledFlag AND private.visibleFlag -> value;
	#);
debugMe:
	(#
	enter private.debugMe
	exit private.debugMe
	#);

standardGraphics: graphics
	(# drawBorder:
			(# style: @integer;
				r: @rectangle;
			enter (r, style)
			<<SLOT GUIENVwindowItemDrawBorder: doPart>>
			#);
	do INNER;
	#);

backGroundStyle:
	(#
	enter private.backGroundStyle
	exit private.backGroundStyle
	#);
privateBackground:
	(#
	enter private.background
	exit private.background
	#);
	
privateOrigin: (# exit (private.originX, private.originY) #);
privateVisibleRgn: (# exit private.visibleRgn #);

privateWindowItemFrame:
	(#
	enter	((private.left, private.top), (private.right, private.bottom))
	exit ((private.left, private.top), (private.right, private.bottom))
	#);
automaticUpdate:
	(#
	enter private.automaticUpdate
	exit private.automaticUpdate
	#);
updateMaybe:
	(#
	do (if shouldUpdate then
			update 
		if);
	#);

shouldUpdate: booleanValue
	(#
	do FALSE -> value;
		(if THIS(window).private.windowVisible then
			(if NOT THIS(window).private.disableUpdate then
				(if private.automaticUpdate then
					(if viewable then
						TRUE -> value;
					if);
				if);
			if);
		if);
	#);

getVisibleRgn:
	(# rgn: @integer;
	do (if private.visibleRgn = 0 then
			calculateVisibleRgn -> private.visibleRgn;
		if);
		private.visibleRgn -> rgn;
	exit rgn
	#);
calculateVisibleRgn:
	(# rgn: @integer;
	<<SLOT windowItemCalculateVisibleRgn: doPart>>
	exit rgn
	#);
forgetVisibleRgn:
	(# tellBrothers: @boolean;
	enter tellBrothers
	<<SLOT windowItemForgetVisibleRgn: doPart>>
	#);
brotherForgetVisibleRgn:
	(#
	<<SLOT windowItemBrotherForgetVisibleRgn: doPart>>
	#);
	
calculateOrigin:
	(#
	<<SLOT windowItemCalculateOrigin: doPart>>
	#);
	
getDrawingRgn:
   (*
	 * The clip region when drawing in the windowitem
	 * will be copied into the "rgn" that should be
	 * allocated before calling getDrawingRgn.
	 *)
	(# rgn: @integer;
	enter rgn
	<<SLOT windowItemGetDrawingRgn: doPart>>
	#);
	


savePort:
	(# currentPort: @longInt;
		currentClip: @integer;
		same: @boolean;
		currentX, currentY: @longInt;
		GetOrigin: External
			(# windowPtr: @integer;
				x, y: ^longInt;
			enter (windowPtr, x[], y[])
			#);
	do currentPort[] -> GetPort;
		(if THIS(window).private.windowVisible then
			currentPort = this(window).private.windowPointer -> same;
			(if same then
				(currentPort, currentX[], currentY[]) -> GetOrigin;
				NewRgn -> currentClip;
				currentClip -> GetClip;
			if);
		if);
		this(window).private.windowPointer -> SetPort;
		INNER;
		currentPort -> SetPort;
		(if same then
			(currentX, currentY) -> SetOrigin;
			currentClip -> SetClip;
			currentClip -> DisposeRgn;
		if);
	#);
	
setupPort: savePort
	(#
	do (-private.originX, -private.originY) -> SetOrigin;
		INNER;
	#);
setupPortForDrawing: setupPort
	(# drawingRgn: @integer;
		overrideChildren: @boolean;
	enter overrideChildren
	do (if THIS(window).private.windowVisible then
			NewRgn -> drawingRgn;
			(if overrideChildren then
				(getVisibleRgn, drawingRgn) -> CopyRgn;
			else
				drawingRgn -> getDrawingRgn;
			if);
			(drawingRgn, -private.originX, -private.originY) -> OffsetRgn;
			drawingRgn ->SetClip;
			drawingRgn -> DisposeRgn;
		if);
		INNER;
	#);
setupPortForDrawingAt: savePort
	(# drawingRgn: @integer;
		overrideChildren: @boolean;
		x, y: @integer;
	enter (overrideChildren, x, y)
	do (if THIS(window).private.windowVisible then
			(-x, -y) -> SetOrigin;
			NewRgn -> drawingRgn;
			(if overrideChildren then
				(getVisibleRgn, drawingRgn) -> CopyRgn;
			else
				drawingRgn -> getDrawingRgn;
			if);
			(drawingRgn, -x, -y) -> OffsetRgn;
			drawingRgn ->SetClip;
			drawingRgn -> DisposeRgn;
		if);
		INNER;
	#);
setupPortZero: savePort
	(#
	do (0, 0) -> SetOrigin;
		INNER;
	#);

setupPortWideClip: setupPortZero
	(#
	do this(guienv).private.wideRgn -> SetClip;
		INNER;
	#);
setupPortClipEmpty: setupPortZero
	(#
	do this(guienv).private.emptyRgn -> SetClip;
		INNER;
	#);
setupPortForToolBox: setupPortZero
	(# visRgn: @integer;
	do (if THIS(window).private.windowVisible then
			getVisibleRgn -> visRgn;
			visRgn -> SetClip;
		if);
		INNER;
	#);
	
invalVisibleRgn:
	(# visRgn: @integer;
	do setupPortWideClip
			(#
			do (if private.visibleRgn <> 0 then
					private.visibleRgn -> InvalRgn;
				else
					invalFrame;
				if);
			#);
	#);
invalFrame:
	(#  r: @rectangle;
	do privateOrigin -> r.topLeft;
		size -> r.size;
		setupPortWideClip
			(# 
			do (r[] -> makeMacRect).r[] -> InvalRect;
			#);
	#);

	
hit: booleanValue
	(# pt: @point;
	enter pt
	<<SLOT GUIENVwindowItemHit: doPart>>
	#);

handleCursor: booleanValue
	(#	pt: @point;
	enter pt
	<<SLOT GUIENVwindowItemHandleCursor: doPart>>
	#);
	
	
windowItemCursor:
	(#
	enter private.windowItemCursor[]
	exit private.windowItemCursor[]
	#);
	
toScreenCoordinates:
	(# p, q: @point;
	enter p
	<<SLOT GUIENVwindowItemToScreenCoordinates: doPart>>
	exit q
	#);
	
-- GUIENVinterfaceObjectPrivate: descriptor --
(# beforeActions,afterActions: ^actionList;
	isOpen: @boolean;
#)

-- GUIENVwindowitemPrivate: descriptor --
(# originX, originY: @integer;
	visibleRgn: @integer; (* Region handle *)
	background: @color;
	backGroundStyle: @integer;
	left, top, right, bottom: @integer;
	visibleFlag,enabledFlag,hiliteFlag,
	automaticUpdate,updateOnResize, borderVisibleFlag, isFigureItem: @boolean;
	borderStyle: @integer;
	windowItemCursor: ^cursor;
	eraseWhenUpdating: @boolean;
	specialHilite: @boolean;
	disableDefaultEventHandling: @boolean;
	debugMe: @boolean;
	pos: ^canvas.private.children.theCellType;
#)

-- canvasLib: attributes --


getChildPosition:
	(*
	 * Cannot be used to find a figureitem, since they are
	 * placed in the  "figs" list
	 *)
	(# child: ^windowItem;
		pos: ^private.children.theCellType;
	enter	child[]
	do child[] -> private.children.at -> pos[]
	exit pos[]
	#);
getPrevSibling:
	(# child: ^windowItem;
		prevSibling: ^windowItem;
	enter child[]
	do 
		(if child.private.pos.pred[] <> NONE then
			child.private.pos.pred.elm[] -> prevSibling[];
		if);
	exit prevSibling[]
	#);


findObjectClicked:
	(# pt: @point;
		ObjectClicked: ^windowItem;
	enter pt
	<<SLOT GUIENVcanvasFindObjectClicked: doPart>>
   exit ObjectClicked[]
	#);
	


-- GUIENVcanvasPrivate: descriptor --
(# hit: ^windowItem;
   children: @list
		(# element:: windowItem;
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
			findObjectClicked:
				(# pt: @point;
					e: ^element;
				enter pt
				do l: scanReverse
						(# where::<
								(#
								do (if current.clickable then
										pt -> current.hit -> value;
									else
										false -> value;
									if);
								#);
						do current[] -> e[];
							leave l;
						#);
				exit e[]
				#);
		#);
	figs: @list
		(# element:: figureItem;
			remove:
				(# e: ^element;
				enter e[]
				do e[] -> at -> delete;
				#);
			findObjectClicked:
				(# pt: @point;
					e: ^element;
				enter pt
				do l: scanReverse
						(# where::<
								(#
								do (if current.clickable then
										pt -> current.hit -> value;
									else
										false -> value;
									if);
								#);
						do current[] -> e[];
							leave l;
						#);
				exit e[]
				#);
		#);
	selection: @list
     (# 
        element::< windowitem;
     #);
   overlap: @boolean;
#)

-- textStyleLib: attributes --
familyID:
	(#
	enter private.familyID
	exit private.familyID
	#);
textStyleSize:
	(#
	enter private.textStyleSize
	exit private.textStyleSize
	#);
textStyleFace:
	(#
	enter private.textStyleFace
	exit private.textStyleFace
	#);
textStyleAttributes:
	(#
	enter (familyID,textStyleSize,textStyleFace)
	exit (familyID,textStyleSize,textStyleFace)
	#);
getInfo:
	(# info: ^FontInfo;
	do &FontInfo[] -> info[];
		withTextStyle
			(#
			do info[] -> GetFontInfo;
			#);
	exit info[]
	#);
withTextStyle:
	(#
	<<SLOT GUIENVTextStyleWithTextStyle: doPart>>
	#);
-- GUIENVtextStylePrivate: descriptor --
(# familyID,textStyleSize,textStyleFace: @integer;
#)


-- pixmapLib: attributes --

copyPatternData:
	(#	address: @integer;
	enter address
	<<SLOT GUIENVRastercopyPatternData: doPart>>
	#);

-- pixmapPrivate: descriptor --
(# gworld: @integer; (* GWorldPtr *)
	width, height: @integer;
	
	maskrgn: @integer;
   theMask: ^pixmap;
   TransparentFlag: @boolean;
	TransparentColor: @color;
	
	
	patAddress: @integer; (* Pointer Black and White pattern *)
#)


