ORIGIN 'guienv_macprivate';
INCLUDE '../pathmanager';
INCLUDE '~beta/basiclib/v1.6/private/file_macbody';


BUILD default ':$$/raster_mac.obj' ':external/raster_mac.c' 'mrc -o $0 $1';
BUILD default ':$$/imaging.obj' ':external/imaging.c' 'mrc -o $0 $1';


INCLUDE '~beta/maclib/v3.1/mactypes';



-- guienvLib: attributes --

CopyGWorldToWindow: External
	(*
	 * CopyBits from GWorld to Window
	 *)
	(# src: @integer; (* GWorldPtr *)
		dst: @integer; (* WindowPtr *)
		srcRect, dstRect: ^macRect;
		mode: @shortInt;
		maskRgn: @integer;
	enter (src, dst, srcRect[], dstRect[], mode, maskRgn)
	#);

CreateGWorld: External
	(# width, height: @shortInt;
		gworld: @integer; (* GWorldPtr *)
	enter (width, height)
	exit gworld
	#);
	
ClearGWorld: External
	(# gworld: @integer; (* GWorldPtr *)
		red, green, blue: @shortInt;
	enter (gworld, red, green, blue)
	#);

CopyWindowToGWorld: External
	(*
	 * CopyBits from Window to GWorld
	 *)
	(# src: @integer; (* WindowPtr *)
		dst: @integer; (* GWorldPtr *)
		srcRect, dstRect: ^macRect;
		mode: @shortInt;
		maskRgn: @integer;
	enter (src, dst, srcRect[], dstRect[], mode, maskRgn)
	#);


ReadPictureFile: External
	(# spec: ^FSSpec;
		picture: @integer; (* PicHandle *)
	enter spec[]
	exit picture
	#);
DrawPictureInGWorld: External
	(# picture: @integer; (* PicHandle *)
		gworld: @integer; (* GWorldPtr *)
		dstRect: ^macRect;
	enter (picture, gworld, dstRect[])
	#);
GWorldFromPictureFile: External
	(# spec: ^FSSpec;
		gworld: @integer; (* GWorldPtr *)
	enter spec[]
	exit gworld
	#);

GetGWorldSize: External
	(# gworld: @integer; (* GWorldPtr *)
		widht, height: ^longInt;
	enter (gworld, widht[], height[])
	#);


-- pixmapLib: attributes --



LockPix: external
	(# pixmap,data: @integer;
	enter (pixmap,data)
	#);
UnlockPix: external
	(# pixmap,data: @integer;
	enter (pixmap,data)
	#);
	
CreatePixPatFromPixMap: external
	(# pixmap, data, pixpat: @integer;
	enter (pixmap, data)
	exit pixpat
	#);
CreatePixmapFromPictureFile: external
	(# name: [1] @char;
		pixelsP,dataP: @integer;
	enter (name,pixelsP,dataP)
	#);
PixMapGetWidth: external
	(#	pixels: @integer;
		width: @integer;
	enter pixels
	exit width
	#);
PixMapGetHeight: external
	(#	pixels: @integer;
		height: @integer;
	enter pixels
	exit height
	#);
PixMapGetSize: external
	(# pixels: @integer;
		width,height: ^longInt;
	enter (pixels,width[],height[])
	#);
CreateBitmapFromPictureFile: external
	(# name: [1] @char;
		bitMapHandleP: @integer;
		dataHandleP: @integer;
		error: @integer;
	enter (name,bitMapHandleP,dataHandleP)
	exit error
	#);
BitMapGetSize: external
	(# bitMapHandle: @integer;
		width,height: ^longInt;
	enter (bitMapHandle,width[],height[])
	#);
BitMapGetWidth: external
	(# bitMapHandle: @integer;
		width: @integer;
	enter bitMapHandle
	exit width
	#);
BitMapGetHeight: external
	(# bitMapHandle: @integer;
		height: @integer;
	enter bitMapHandle
	exit height
	#);


getPixmapPathManager: objectPool.get
  (# type:: pixmapPathManager;
     exact:: (# do true -> value #);
     init:: (# do obj.init #);
  #);
  

pixmapPathManager: pathManager
	(# init::
			(# betalib: ^text;
				pixmapDir: ^text;
			do ':' -> add;
				':pixmaps:' -> add;
			#);
	#);

search:
  (# name: ^text;
     expandedName: ^text;
  enter name[]
  do (# thePixmapPathManager: ^pixmapPathManager;
     do getPixmapPathManager -> thePixmapPathManager[];
        name[] -> thePixmapPathManager.lookup -> expandedName[];
     #);
  exit expandedName[]
  #);

expandPixmapName:
  (# name: ^text;
     expandedName: ^text;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
     
  enter name[]
  do (# isPath: @boolean;
        hasExtension: @boolean;
        doesNotExists:
          (# msg: ^text;
          do &text[] -> msg[];
             'PICT file "' -> msg.putText;
             name[] -> msg.putText;
             '" does not exist' -> msg.putLine;
             msg[] -> error;
          #);
        wasNotFound:
          (# msg: ^text;
          do &text[] -> msg[];
             'PICT file "' -> msg.putText;
             name[] -> msg.putText;
             '" was not found in any of the pixmap directories' -> msg.putLine;
             msg[] -> error;
          #);
     do (if (name[] <> NONE) and (not name.empty) then
            name.reset;
            l: ':' -> name.find (# do true -> isPath; leave l; #);
            (if isPath then
                (if name[] -> exists then
                    name.copy -> expandedName[];
                 else
                    doesNotExists;
                if);
             else
                l: '.' -> name.find (# do true -> hasExtension; leave l #);
                (if not hasExtension then
                    '.pict' -> (name.copy).append -> name[];
                if);
                name[] -> search -> expandedName[];
                (if expandedName[] = NONE then
                    wasNotFound;
                if);
            if);
        if);
     #);
  exit expandedName[]
  #);
  
-- GUIENVRastercopyPatternData: descriptor --
(#
#)

-- GUIENVrasterLock: descriptor --
(# 
do	
#)

-- GUIENVrasterUnlock: descriptor --
(#
do 
#)

 
-- pixMapRead: doPart --
do l: (# expandedName: ^text;
		do name[] -> expandPixmapName 
			(# error::
				  (# 
				  do msg[] -> this(read).error;
					  leave l;
				  #);
			#) -> expandedName[];
			'expanded name = ' -> putText;
			expandedName[] -> putLine;
			
			(if expandedName[] <> NONE then
				(# 
					f: @file;
					w, h: @longInt;
				do expandedName[] -> f.name;
					f.entry.private.fs[] -> GWorldFromPictureFile -> private.gworld;
					(if private.gworld = 0 then
						'Failed to read picture file' -> this(read).error;
					else
						(private.gworld, w[], h[]) -> GetGWorldSize;
						w -> private.width;
						h -> private.height;
					if);
				#)
			if);
		#);

-- pixmapInit: doPart --
do

-- pixmapDispose: doPart --
do

-- pixmapWidth: doPart --
do private.width -> value;

-- pixmapHeight: doPart --
do private.height -> value;

