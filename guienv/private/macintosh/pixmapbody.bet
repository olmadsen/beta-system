ORIGIN 'guienv_macprivate';
INCLUDE '../pathmanager';
INCLUDE '~beta/basiclib/private/file_macbody';
INCLUDE '~beta/sysutils/private/mjolnerprefs_mac';
INCLUDE '~beta/maclib/qdoffscreen';

BUILD default ':$$/raster_mac.obj' ':external/raster_mac.c' 'mrc -shared_lib_export on -o $0 $1';
BUILD default ':$$/imaging.obj' ':external/imaging.c' 'mrc -shared_lib_export on -o $0 $1';


INCLUDE '~beta/toollibs/utils/PNG/private/macpnginterface';

INCLUDE '~beta/maclib/mactypes';



-- guienvLib: attributes --
allocate_bitmap: external
		(# bits: ^macBitMap;
		enter bits[]
		#);
CalculateMask: external
	(# gworld: @integer; (* GWorldPtr *)
		red, green, blue: @int32;
		rgn: @int32;
	enter (gworld, red, green, blue)
	exit rgn
	#);
copy_mask_to_window: external
	(# gworld: @integer;
		window: @integer;
		srcRect: ^MacRect;
		maskRect: ^MacRect;
		dstRect: ^MacRect;
		mask: ^macBitMap;
	enter (gworld, window, srcRect[], maskRect[], dstRect[], mask[])
	#);

getPixmapPathManager: objectPool.get
  (# type:: pixmapPathManager;
     exact:: (# do true -> value #);
     init:: (# do obj.init #);
  #);
pixmapPathManager: pathManager
	(# init::
			(# betalib: ^text;
				pixmapDir: ^text;
				
			do ':' -> add;
				':pixmaps:' -> add;
				(* 'tromlen:beta:r4.1:bitmap:interfacebuilders:' -> add; *)
			#);
	#);

CreateGWorld: External
	(# width, height: @shortInt;
		gworld: @integer; (* GWorldPtr *)
	enter (width, height)
	exit gworld
	#);
	
ClearGWorld: External
	(# gworld: @integer; (* GWorldPtr *)
		red, green, blue: @shortInt;
	enter (gworld, red, green, blue)
	#);

CopyWindowToGWorld: External
	(*
	 * CopyBits from Window to GWorld
	 *)
	(# src: @integer; (* WindowPtr *)
		dst: @integer; (* GWorldPtr *)
		srcRect, dstRect: ^macRect;
		mode: @shortInt;
		maskRgn: @integer;
	enter (src, dst, srcRect[], dstRect[], mode, maskRgn)
	#);


ReadPictureFile: External
	(# spec: ^FSSpec;
		picture: @integer; (* PicHandle *)
	enter spec[]
	exit picture
	#);
DrawPictureInGWorld: External
	(# picture: @integer; (* PicHandle *)
		gworld: @integer; (* GWorldPtr *)
		dstRect: ^macRect;
	enter (picture, gworld, dstRect[])
	#);
GWorldFromPictureFile: External
	(# spec: ^FSSpec;
		gworld: @integer; (* GWorldPtr *)
	enter spec[]
	exit gworld
	#);

GetGWorldSize: External
	(# gworld: @integer; (* GWorldPtr *)
		widht, height: ^longInt;
	enter (gworld, widht[], height[])
	#);


-- pixmapLib: attributes --



LockPix: external
	(# pixmap,data: @integer;
	enter (pixmap,data)
	#);
UnlockPix: external
	(# pixmap,data: @integer;
	enter (pixmap,data)
	#);
	
CreatePixPatFromPixMap: external
	(# pixmap, data, pixpat: @integer;
	enter (pixmap, data)
	exit pixpat
	#);
CreatePixmapFromPictureFile: external
	(# name: [1] @char;
		pixelsP,dataP: @integer;
	enter (name,pixelsP,dataP)
	#);
PixMapGetWidth: external
	(#	pixels: @integer;
		width: @integer;
	enter pixels
	exit width
	#);
PixMapGetHeight: external
	(#	pixels: @integer;
		height: @integer;
	enter pixels
	exit height
	#);
PixMapGetSize: external
	(# pixels: @integer;
		width,height: ^longInt;
	enter (pixels,width[],height[])
	#);
CreateBitmapFromPictureFile: external
	(# name: [1] @char;
		bitMapHandleP: @integer;
		dataHandleP: @integer;
		error: @integer;
	enter (name,bitMapHandleP,dataHandleP)
	exit error
	#);
BitMapGetSize: external
	(# bitMapHandle: @integer;
		width,height: ^longInt;
	enter (bitMapHandle,width[],height[])
	#);
BitMapGetWidth: external
	(# bitMapHandle: @integer;
		width: @integer;
	enter bitMapHandle
	exit width
	#);
BitMapGetHeight: external
	(# bitMapHandle: @integer;
		height: @integer;
	enter bitMapHandle
	exit height
	#);



  



search:
  (# name: ^text;
     expandedName: ^text;
  enter name[]
  do (# thePixmapPathManager: ^pixmapPathManager;
     do getPixmapPathManager -> thePixmapPathManager[];
        name[] -> thePixmapPathManager.lookup -> expandedName[];
     #);
  exit expandedName[]
  #);

expandPixmapName:
	(# name: ^text;
		expandedName: ^text;
		hasExtension: @boolean;
		isPath: @boolean;
		lastColonPos, lastDotPos: @integer;
		e: @diskEntry;
		error:<
		 (# msg: ^text;
		 enter msg[]
		 do INNER;
		 #);
		betaLib: ^text;
	enter name[]
	do name.copy -> expandedName[];
		
		expandedName[] -> e.path;
		(if NOT e.isFile then
			expandedName.reset;
			expandedName.scanAll
			(# inx: @integer;
			do inx + 1 -> inx;
				(if ch = ':' then
					true -> isPath;
					inx -> lastColonPos;
				if);
				(if ch = '.' then
					inx -> lastDotPos;
				if);
			#);
			(if lastDotPos > lastColonPos then
				true -> hasExtension;
			if);
			(if NOT hasExtension then
				'.png' -> expandedName.append;
			if);
			
			
			expandedName[] -> e.path;
			(if NOT e.isFile then
				 (if NOT isPath then
					':pixmaps:' -> (expandedName.copy).prepend -> e.path;
					
					(if e.isFile then
					
						e.path -> expandedName[];
						
					else
						getBetaLib -> betaLib[];
						(if betaLib[] <> NONE then
							'bitmap:interfacebuilders:' 
								-> (betaLib.copy).append 
								-> (expandedName.copy).prepend
								-> e.path;
							(if e.isFile then
								e.path -> expandedName[];
							else
								'bitmap:objectbrowser:' 
								-> (betaLib.copy).append 
								-> (expandedName.copy).prepend
								-> e.path;
								(if e.isFile then
									e.path -> expandedName[];
								else
									'bitmap:guienv:' 
									-> (betaLib.copy).append 
									-> (expandedName.copy).prepend
									-> e.path;
									(if e.isFile then
										e.path -> expandedName[];
									if);
								if);
							if);
						if);
					if);
				if);
			else
			if);
		else
		if);
		
	exit expandedName[]
	#);
	
expandPixmapName1:
  (# name: ^text;
     expandedName: ^text;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
     
  enter name[]
  do (# isPath: @boolean;
        hasExtension: @boolean;
        doesNotExists:
          (# msg: ^text;
          do &text[] -> msg[];
             'PICT file "' -> msg.putText;
             name[] -> msg.putText;
             '" does not exist' -> msg.putLine;
             msg[] -> error;
          #);
        wasNotFound:
          (# msg: ^text;
          do &text[] -> msg[];
             'PICT file "' -> msg.putText;
             name[] -> msg.putText;
             '" was not found in any of the pixmap directories' -> msg.putLine;
             msg[] -> error;
          #);
     do (if (name[] <> NONE) and (not name.empty) then
            name.reset;
            l: ':' -> name.find (# do true -> isPath; leave l; #);
            (if isPath then
                (if name[] -> exists then
                    name.copy -> expandedName[];
                 else
                    doesNotExists;
                if);
             else
                l: '.' -> name.find (# do true -> hasExtension; leave l #);
                (if not hasExtension then
                    '.pict' -> (name.copy).append -> name[];
                if);
                name[] -> search -> expandedName[];
                (if expandedName[] = NONE then
                    wasNotFound;
                if);
            if);
        if);
     #);
  exit expandedName[]
  #);
  
readPNG: external
	(# name: [1] @char;
 		gworld: @int32;
		result: @int32;
		maskrgn: @int32;
	enter (name, gworld, maskrgn)
	exit result
  	#);
readPNGFile:
	(# name: ^text;
		gworld: @int32;
		result: @integer;
		mask: @int32;
	enter name[]
	do (name, @@gworld, @@mask) -> readPNG -> result;
	exit (gworld, mask)
	#);
	
-- GUIENVRastercopyPatternData: doPart --
do address -> private.patAddress; (* Does not make a copy! 
  										     * Lets hope nobody frees the address.
											  *)
 
 
-- pixMapRead: doPart --
do l: (# expandedName: ^text;
		do (if name[] = NONE then
				'Error in pixmap.read: Name is none' -> error;
			else
				name[] -> expandPixmapName 
				(# error::
					  (# 
					  do msg[] -> this(read).error;
						  leave l;
					  #);
				#) -> expandedName[];
				
				(if expandedName[] <> NONE then
					(# 
						f: @file;
						w, h: @longInt;
						t: @text;
					do expandedName[] -> f.name;
					   (** f.entry.private.fs[] -> GWorldFromPictureFile -> private.gworld; ***)
					   
					   
					   expandedName[] -> readPNGFile -> (private.gworld, private.maskrgn);
					   
						(if private.gworld = 0 then
							'Failed to read picture file' -> t;
							name[] -> t.append;
							t[] -> this(read).error;
						else
							(private.gworld, w[], h[]) -> GetGWorldSize;
							w -> private.width;
							h -> private.height;
						if);
					#)
				if);
			if);
		#);

-- pixmapInit: doPart --
do (# bounds: @rectangle;
	  mcBounds: ^macRect;
	  theGWorld: @longInt;
	  error: @integer;
	  pix: @integer;
   do (0, 0) -> bounds.topLeft;
   	  (width, height) -> bounds.size;
	  bounds[] -> makeMacRect -> mcBounds[];
	  (theGWorld[], 0, mcBounds.r[], 0, 0, 0) -> NewGWorld -> error;
	  (if error = 0 then
	  	theGWorld -> private.gworld;
	  	width -> private.width;
		height -> private.height;
		
		private.gworld -> GetGWorldPixmap -> pix;
		(if pix -> LockPixels then
			private.gworld -> SetPort;
			mcBounds.r[] -> EraseRect;
			pix -> UnlockPixels;
		if);
	  if);
   #);


-- pixmapClear: doPart --
do 
(# rgb: @RGBColor;
	mcBounds: ^macRect;
	bounds: @Rectangle;
	pix: @integer;
do (if private.gWorld <> 0 then
			private.gworld -> GetGWorldPixmap -> pix;
			(if pix -> LockPixels then
				private.gworld -> SetPort;
				theColor.red -> rgb.red;
				theColor.green -> rgb.green;
				theColor.blue -> rgb.blue;
				rgb[] -> RGBBackColor;
				(width, height) -> bounds.size;
	  			bounds[] -> makeMacRect -> mcBounds[];
				mcBounds.r[] -> EraseRect;
				0xFFFF -> rgb.red;
				0xFFFF -> rgb.green;
				0xFFFF -> rgb.blue;
				rgb[] -> RGBBackColor;
				pix -> UnlockPixels;
			if);
		if);
#)


-- pixmapDispose: doPart --
do (if private.gworld <> 0 then
			private.gworld -> DisposeGWorld;
			0 -> private.gworld;
			
	if);
	0 -> private.width;
	0 -> private.height;
	(if private.maskrgn <> 0 then
		private.maskrgn -> DisposeRgn;
		0 -> private.maskrgn;
	if);
	NONE -> private.theMask[];

-- pixmapWidth: doPart --
do private.width -> value;

-- pixmapHeight: doPart --
do private.height -> value;

-- pixmapSetTransparent: doPart --
do (if value <> private.TransparentFlag then
		value -> private.TransparentFlag;
		(if private.TransparentFlag then
		else
			none -> private.theMask[];
		if);
	if);

-- pixmapGetTransparent: doPart --
do private.TransparentFlag -> value;

-- pixmapSetTransparentColor: doPart --
do (# 
	do theColor -> private.TransparentColor;
		(if private.gworld <> 0 then
			(private.gworld, theColor.red, theColor.green, theColor.blue) 
				-> CalculateMask 
				-> private.maskrgn;
			if);
		true -> private.TransparentFlag;
	#);

-- pixmapGetTransparentColor: doPart --
do private.TransparentColor -> theColor;

-- pixmapSetMask: doPart --
do (if theMask[] <> NONE then
		true -> private.TransparentFlag;
		theMask[] -> private.theMask[];
	else
		NONE -> private.theMask[];
		false -> private.TransparentFlag;
	if);
	

-- pixmapGetMask: doPart --
do private.theMask[] -> theMask[];

-- pixmapDrawPixmap: doPart --
do 


