ORIGIN 'guienv_macprivate';
INCLUDE '../pathmanager';
INCLUDE '~beta/basiclib/private/file_macbody';
INCLUDE '~beta/sysutils/private/mjolnerprefs_mac';
INCLUDE '~beta/maclib/qdoffscreen';

BUILD default ':$$/raster_mac.obj' ':external/raster_mac.c' 'mrc -shared_lib_export on -o $0 $1';
BUILD default ':$$/imaging.obj' ':external/imaging.c' 'mrc -shared_lib_export on -o $0 $1';


INCLUDE '~beta/maclib/mactypes';



-- guienvLib: attributes --
allocate_bitmap: external
		(# bits: ^macBitMap;
		enter bits[]
		#);
calc_pixmap_mask: external
	(# gworld: @integer; (* GWorldPtr *)
		bits: ^macBitMap;
		seedColor: ^RGBColor;
	enter (gworld, bits[], seedColor[])
	#);
copy_mask_to_window: external
	(# gworld: @integer;
		window: @integer;
		srcRect: ^MacRect;
		maskRect: ^MacRect;
		dstRect: ^MacRect;
		mask: ^macBitMap;
	enter (gworld, window, srcRect[], maskRect[], dstRect[], mask[])
	#);

getPixmapPathManager: objectPool.get
  (# type:: pixmapPathManager;
     exact:: (# do true -> value #);
     init:: (# do obj.init #);
  #);
pixmapPathManager: pathManager
	(# init::
			(# betalib: ^text;
				pixmapDir: ^text;
				
			do ':' -> add;
				':pixmaps:' -> add;
				(* 'tromlen:beta:r4.1:bitmap:interfacebuilders:' -> add; *)
			#);
	#);

CopyGWorldToWindow: External
	(*
	 * CopyBits from GWorld to Window
	 *)
	(# src: @integer; (* GWorldPtr *)
		dst: @integer; (* WindowPtr *)
		srcRect, dstRect: ^macRect;
		mode: @shortInt;
		maskRgn: @integer;
	enter (src, dst, srcRect[], dstRect[], mode, maskRgn)
	#);

CreateGWorld: External
	(# width, height: @shortInt;
		gworld: @integer; (* GWorldPtr *)
	enter (width, height)
	exit gworld
	#);
	
ClearGWorld: External
	(# gworld: @integer; (* GWorldPtr *)
		red, green, blue: @shortInt;
	enter (gworld, red, green, blue)
	#);

CopyWindowToGWorld: External
	(*
	 * CopyBits from Window to GWorld
	 *)
	(# src: @integer; (* WindowPtr *)
		dst: @integer; (* GWorldPtr *)
		srcRect, dstRect: ^macRect;
		mode: @shortInt;
		maskRgn: @integer;
	enter (src, dst, srcRect[], dstRect[], mode, maskRgn)
	#);


ReadPictureFile: External
	(# spec: ^FSSpec;
		picture: @integer; (* PicHandle *)
	enter spec[]
	exit picture
	#);
DrawPictureInGWorld: External
	(# picture: @integer; (* PicHandle *)
		gworld: @integer; (* GWorldPtr *)
		dstRect: ^macRect;
	enter (picture, gworld, dstRect[])
	#);
GWorldFromPictureFile: External
	(# spec: ^FSSpec;
		gworld: @integer; (* GWorldPtr *)
	enter spec[]
	exit gworld
	#);

GetGWorldSize: External
	(# gworld: @integer; (* GWorldPtr *)
		widht, height: ^longInt;
	enter (gworld, widht[], height[])
	#);


-- pixmapLib: attributes --

iconSuite:
	(# iconSuiteHandle: @integer;
	enter iconSuiteHandle
	do iconSuiteKind -> private.kind;
		iconSuiteHandle -> private.resourceHandle;
		32 -> private.width;
		32 -> private.height;
	#);


LockPix: external
	(# pixmap,data: @integer;
	enter (pixmap,data)
	#);
UnlockPix: external
	(# pixmap,data: @integer;
	enter (pixmap,data)
	#);
	
CreatePixPatFromPixMap: external
	(# pixmap, data, pixpat: @integer;
	enter (pixmap, data)
	exit pixpat
	#);
CreatePixmapFromPictureFile: external
	(# name: [1] @char;
		pixelsP,dataP: @integer;
	enter (name,pixelsP,dataP)
	#);
PixMapGetWidth: external
	(#	pixels: @integer;
		width: @integer;
	enter pixels
	exit width
	#);
PixMapGetHeight: external
	(#	pixels: @integer;
		height: @integer;
	enter pixels
	exit height
	#);
PixMapGetSize: external
	(# pixels: @integer;
		width,height: ^longInt;
	enter (pixels,width[],height[])
	#);
CreateBitmapFromPictureFile: external
	(# name: [1] @char;
		bitMapHandleP: @integer;
		dataHandleP: @integer;
		error: @integer;
	enter (name,bitMapHandleP,dataHandleP)
	exit error
	#);
BitMapGetSize: external
	(# bitMapHandle: @integer;
		width,height: ^longInt;
	enter (bitMapHandle,width[],height[])
	#);
BitMapGetWidth: external
	(# bitMapHandle: @integer;
		width: @integer;
	enter bitMapHandle
	exit width
	#);
BitMapGetHeight: external
	(# bitMapHandle: @integer;
		height: @integer;
	enter bitMapHandle
	exit height
	#);



  



search:
  (# name: ^text;
     expandedName: ^text;
  enter name[]
  do (# thePixmapPathManager: ^pixmapPathManager;
     do getPixmapPathManager -> thePixmapPathManager[];
        name[] -> thePixmapPathManager.lookup -> expandedName[];
     #);
  exit expandedName[]
  #);

expandPixmapName:
	(# name: ^text;
		expandedName: ^text;
		hasExtension: @boolean;
		isPath: @boolean;
		lastColonPos, lastDotPos: @integer;
		e: @diskEntry;
		error:<
		 (# msg: ^text;
		 enter msg[]
		 do INNER;
		 #);
		betaLib: ^text;
	enter name[]
	do name.copy -> expandedName[];
		
		expandedName[] -> e.path;
		(if NOT e.isFile then
			expandedName.reset;
			expandedName.scanAll
			(# inx: @integer;
			do inx + 1 -> inx;
				(if ch = ':' then
					true -> isPath;
					inx -> lastColonPos;
				if);
				(if ch = '.' then
					inx -> lastDotPos;
				if);
			#);
			(if lastDotPos > lastColonPos then
				true -> hasExtension;
			if);
			(if NOT hasExtension then
				'.pict' -> expandedName.append;
			if);
			
			
			expandedName[] -> e.path;
			(if NOT e.isFile then
				 (if NOT isPath then
					':pixmaps:' -> (expandedName.copy).prepend -> e.path;
					
					(if e.isFile then
					
						e.path -> expandedName[];
						
					else
						getBetaLib -> betaLib[];
						(if betaLib[] <> NONE then
							'bitmap:interfacebuilders:' 
								-> (betaLib.copy).append 
								-> (expandedName.copy).prepend
								-> e.path;
							(if e.isFile then
								e.path -> expandedName[];
							else
								'bitmap:objectbrowser:' 
								-> (betaLib.copy).append 
								-> (expandedName.copy).prepend
								-> e.path;
								(if e.isFile then
									e.path -> expandedName[];
								if);
							if);
						if);
					if);
				if);
			else
			if);
		else
		if);
		
	exit expandedName[]
	#);
	
expandPixmapName1:
  (# name: ^text;
     expandedName: ^text;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
     
  enter name[]
  do (# isPath: @boolean;
        hasExtension: @boolean;
        doesNotExists:
          (# msg: ^text;
          do &text[] -> msg[];
             'PICT file "' -> msg.putText;
             name[] -> msg.putText;
             '" does not exist' -> msg.putLine;
             msg[] -> error;
          #);
        wasNotFound:
          (# msg: ^text;
          do &text[] -> msg[];
             'PICT file "' -> msg.putText;
             name[] -> msg.putText;
             '" was not found in any of the pixmap directories' -> msg.putLine;
             msg[] -> error;
          #);
     do (if (name[] <> NONE) and (not name.empty) then
            name.reset;
            l: ':' -> name.find (# do true -> isPath; leave l; #);
            (if isPath then
                (if name[] -> exists then
                    name.copy -> expandedName[];
                 else
                    doesNotExists;
                if);
             else
                l: '.' -> name.find (# do true -> hasExtension; leave l #);
                (if not hasExtension then
                    '.pict' -> (name.copy).append -> name[];
                if);
                name[] -> search -> expandedName[];
                (if expandedName[] = NONE then
                    wasNotFound;
                if);
            if);
        if);
     #);
  exit expandedName[]
  #);
  
-- GUIENVRastercopyPatternData: doPart --
do address -> private.patAddress; (* Does not make a copy! 
  										     * Lets hope nobody frees the address.
											  *)
 
 
-- pixMapRead: doPart --
do l: (# expandedName: ^text;
		do (if name[] = NONE then
				'Error in pixmap.read: Name is none' -> error;
			else
				name[] -> expandPixmapName 
				(# error::
					  (# 
					  do msg[] -> this(read).error;
						  leave l;
					  #);
				#) -> expandedName[];
				
				(if expandedName[] <> NONE then
					(# 
						f: @file;
						w, h: @longInt;
						t: @text;
					do expandedName[] -> f.name;
						f.entry.private.fs[] -> GWorldFromPictureFile -> private.gworld;
						(if private.gworld = 0 then
							'Failed to read picture file' -> t;
							name[] -> t.append;
							t[] -> this(read).error;
						else
							gworldKind -> private.kind;
							(private.gworld, w[], h[]) -> GetGWorldSize;
							w -> private.width;
							h -> private.height;
						if);
					#)
				if);
			if);
		#);

-- pixmapInit: doPart --
do (# bounds: @rectangle;
	  mcBounds: ^macRect;
	  theGWorld: @longInt;
	  error: @integer;
	  pix: @integer;
   do (0, 0) -> bounds.topLeft;
   	  (width, height) -> bounds.size;
	  bounds[] -> makeMacRect -> mcBounds[];
	  (theGWorld[], 0, mcBounds[], 0, 0, 0) -> NewGWorld -> error;
	  (if error = 0 then
	  	theGWorld -> private.gworld;
	  	width -> private.width;
		height -> private.height;
		gworldKind -> private.kind;
		
		private.gworld -> GetGWorldPixmap -> pix;
		(if pix -> LockPixels then
			private.gworld -> SetPort;
			mcBounds[] -> EraseRect;
			pix -> UnlockPixels;
		if);
	  if);
   #);


-- pixmapClear: doPart --
do 
(# rgb: @RGBColor;
	mcBounds: ^macRect;
	bounds: @Rectangle;
	pix: @integer;
do (if private.kind
    //gWorldKind then
		(if private.gWorld <> 0 then
			private.gworld -> GetGWorldPixmap -> pix;
			(if pix -> LockPixels then
				private.gworld -> SetPort;
				theColor.red -> rgb.red;
				theColor.green -> rgb.green;
				theColor.blue -> rgb.blue;
				rgb[] -> RGBBackColor;
				(width, height) -> bounds.size;
	  			bounds[] -> makeMacRect -> mcBounds[];
				mcBounds[] -> EraseRect;
				0xFFFF -> rgb.red;
				0xFFFF -> rgb.green;
				0xFFFF -> rgb.blue;
				rgb[] -> RGBBackColor;
				pix -> UnlockPixels;
			if);
		if);
	if);
#)


-- pixmapDispose: doPart --
do (if private.kind
	//gWorldKind then
		
		(if private.gworld <> 0 then
			private.gworld -> DisposeGWorld;
			0 -> private.gworld;
			0 -> private.width;
			0 -> private.height;
			0 -> private.kind;
		if);
	//iconSuiteKind then
		(if private.resourceHandle <> 0 then
			private.resourceHandle -> ReleaseResource;
			0 -> private.resourceHandle;
			0 -> private.width;
			0 -> private.height;
			0 -> private.kind;
		if);
   if);

-- pixmapWidth: doPart --
do private.width -> value;

-- pixmapHeight: doPart --
do private.height -> value;

-- pixmapSetTransparent: doPart --
do (if value <> private.TransparentFlag then
		value -> private.TransparentFlag;
		(if private.TransparentFlag then
		else
			none -> private.theMask[];
		if);
	if);

-- pixmapGetTransparent: doPart --
do private.TransparentFlag -> value;

-- pixmapSetTransparentColor: doPart --
do theColor -> private.TransparentColor;
	&pixmap[] -> private.theMask[];
	(this(pixmap)[], private.TransparentColor) -> private.theMask.calculateMask;
	true -> private.TransparentFlag;

-- pixmapGetTransparentColor: doPart --
do private.TransparentColor -> theColor;

-- pixmapSetMask: doPart --
do (if theMask[] <> NONE then
		true -> private.TransparentFlag;
		theMask[] -> private.theMask[];
		private.theMask.convertToMask;
	else
		NONE -> private.theMask[];
		false -> private.TransparentFlag;
	if);
	

-- pixmapGetMask: doPart --
do private.theMask[] -> theMask[];

-- pixmapDrawPixmap: doPart --
do (# otherPixmap, thisPixmap: @integer; (* Pixmap Handle *)
			srcRect, dstRect: @rectangle;
			srcMcRect, dstMcRect: ^macRect;
			mask: ^macBitMap;
		do other.private.gworld -> GetGWorldPixmap -> otherPixmap;
			(if otherPixmap <> 0 then
				private.gworld -> GetGWorldPixmap -> thisPixmap;
				(if thisPixmap <> 0 then
					(if otherPixmap -> LockPixels then
						(if thisPixmap -> LockPixels then
							from -> srcRect.topLeft;
							(width, height) -> srcRect.size;
							srcRect[] -> makeMacRect -> srcMcRect[];
							to -> dstRect.topLeft;
							(width, height) -> dstRect.size;
							dstRect[] -> makeMacRect -> dstMcRect[];
							thisPixmap -> HLock;
							otherPixmap -> HLock;
							
							(if other.private.theMask[] <> NONE then
								other.private.theMask.private.asMask[]
									-> mask[];
								(%getLongAt otherPixmap, @@mask.R[1], %getLongAt thisPixmap,
								 srcMcRect[], srcMcRect[], dstMcRect[])
								  -> CopyMask;
							else
								(%getLongAt otherPixmap, %getLongAt thisPixmap,
								 srcMcRect[], dstMcRect[], srcCopy, 0)
								  -> CopyBits;
							if);
							thisPixmap -> HUnlock;
							otherPixmap -> HUnlock;
							thisPixmap -> UnLockPixels;
						if);
						otherPixmap -> UnLockPixels;
					if);
				if);
			if);
		#);

-- pixmapCalculateMask: doPart --
do (# rgb: @RGBColor;
	do (if other[] <> NONE then
		  (if other.private.gworld <> 0 then
				&maskBitmap[] -> private.asMask[];
				other.width -> private.asMask.right;
				other.height -> private.asMask.bottom;
				other.width -> private.width;
				other.height -> private.height;
				private.asMask[] -> allocate_bitmap;
				theColor.red -> rgb.red;
				theColor.green -> rgb.green;
				theColor.blue -> rgb.blue;
				(other.private.gworld, private.asMask[], rgb[]) -> calc_pixmap_mask;
		  if);
	   if);
	#);

-- pixmapConvertToMask: doPart --
do 
