ORIGIN '../controlsbody';

INCLUDE '~beta/maclib/v3.0/controlmanager';
INCLUDE '~beta/maclib/v3.0/textedit';
INCLUDE '~beta/maclib/v3.0/memory';
INCLUDE '~beta/maclib/v3.0/debug';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '~beta/maclib/v3.0/quickdraw';

INCLUDE 'guienv_macprivate';
INCLUDE 'guienv_macbody';
INCLUDE 'raster_macprivate';
INCLUDE '../../graphics';

-- GUIENVcontrolCreate: descriptor --
(#
do inner create;
#)

-- GUIENVcontrolOpen: descriptor --
(#
do 
	inner open;
#)

-- GUIENVcontrolClose: descriptor --
(#
do inner close;
	(if private.controlHandle<>0 then
		private.controlHandle -> disposeToolBoxControl;
		0 -> private.controlHandle;
	if);
	(if private.controlActionProc <> 0 then
		private.controlActionProc -> FreeCBF;
		0 -> private.controlActionProc;
	if);
#)

-- controlLib: attributes --

ThreeDdefProc: (# exit 2048 #);


putPoint:
	(# h, v: @integer;
	enter (h, v)
	do '[' -> put;
		h -> putInt;
		' ' -> put;
		v -> putInt;
		']' -> put;
	#);
putRect:
	(# left, top, right, bottom: @integer;
	enter ((left, top), (right, bottom))
	do (left, top) -> putPoint;
		(right, bottom) -> putPoint;
	#);

(* updateToolboxControl and drawToolboxControl are designed to
 * avoid flicker. The problem is that SizeControl redraws the
 * control imediately and uienv wants the control to be drawn by
 * the event loop. So when the control is resized it is first 
 * hidden to prevent the flicker. And then when the control is
 * drawn it is shown if it is invisible.
 *)
 
 goDebug:
 	(# s: @text;
		handle: @integer;
	enter	handle
	do handle -> s.putInt;
		s -> DebugStr;
	#);
	
updateToolboxControl:
	(# controlHandle: @integer;
		width,height: @integer;
		x, y: @integer;
		s: @text;
	enter (controlHandle,x,y,width,height)
	do 
		setupClipForDrawing
			(#
			do HidePen;
				controlHandle -> HideControl;
				(controlHandle,width,height) -> SizeControl;
				(controlHandle,x,y) -> MoveControl;
				
				
				ShowPen;
			#);
		
	#);
drawToolboxControl:
	(# controlHandle: @integer;
		visible: @integer;
		controlRec: @controlRecord;
		
	enter controlHandle
	do controlHandle -> HLock;
		controlHandle -> controlRec.initFromHandle;
		controlRec.contrlVis -> visible;
		controlHandle -> HUnLock;
	   setupClipForDrawing
			(#
			do (if this(control).struc <= optionButton## then
					(* this(guienv).private.whitePat -> BackPat; *)
				if);
				(if visible//255 then
					controlHandle -> Draw1Control;
				else
					HidePen;
					controlHandle -> ShowControl;
					ShowPen;
					controlHandle -> Draw1Control;
				if);
			#);
	#);
removeToolboxControl:
	(# controlHandle: @integer;
		RemoveFromOwner: external
			(# controlHandle: @integer;
			enter controlHandle
			#);
	enter controlHandle
	do controlHandle -> RemoveFromOwner;
	#);
disposeToolboxControl:
	(# controlHandle: @integer;
	enter controlHandle
	do setupClipForDrawing
			(#
			do hidePen;
				controlHandle -> DisposeControl;
				showPen;
			#);
	#);
adjustBounds:
	(# h,v,width,height: @integer;
		f: @rectangle;
	do (if private.controlHandle<>0 then
			((0,0),size) -> f;
			(* privateOrigin -> f.offset; *)
			f.size -> (width,height);
			f.topLeft -> (h,v);
			(private.controlHandle,h,v,width,height) -> updateToolboxControl;
		if);
	#);

theControlHandle:
	(#
	exit private.controlHandle
	#);
-- GUIENVcontrolPrivate: descriptor --
(# controlHandle: @integer;
	controlActionProc: @integer;
#)

-- GUIENVScrollbarOnFrameChanged: descriptor --
(# 
do adjustBounds;
	inner onFrameChanged;
#)

-- GUIENVScrollbarOnRefresh: descriptor --
(#
do (if private.scrollbarActive then
		this(control).private.controlHandle  -> drawToolboxControl;
	else
		setupClipForDrawing
			(#	r: @rectangle;
				mr: ^macRect;
			do	((0,0),size) -> r;
				r[] -> makeMacRect -> mr[];
				ResetPen;
				mr[] -> FrameRect;
			#);
	if);
	inner onRefresh;
#)

-- GUIENVScrollbarOnMouseDown: descriptor --
(#	macPt: @macPoint;
	originalPart,returnPart,originalValue: @integer;
	p: @point;
do inner onMouseDown;
	localPosition -> p;
	p -> macPt.setPoint;
	(this(control).private.controlHandle ,macPt) -> TestControl -> originalPart;
	setupClipForDrawing
		(#
		do (if originalPart = inThumb then
				value -> originalValue;
				(this(control).private.controlHandle ,macPt,0) -> TrackControl -> returnPart;
				(if returnPart = originalPart then
					(value - originalValue) -> theEventHandler.onThumbMoved;
				if);
			else
				(# 
				do (this(control).private.controlHandle,
				   macPt,
				   this(control).private.controlActionProc) -> TrackControl -> returnPart;
			   #)
			if);
			(if returnPart = originalPart then
				theEventHandler.onMouseUp;
			if);
			false -> sendOnMouseUp;
		#);
#)

-- GUIENVscrollbarOnActivate: descriptor --
(#
do	true -> private.scrollbarActive;
	updateMaybe;
	inner onActivate;
#)

-- GUIENVscrollbarOnDeactivate: descriptor --
(#
do	false -> private.scrollbarActive;
	setupClipForDrawing
		(#
		do	HidePen;
			this(control).private.controlHandle -> HideControl;
			ShowPen;
		#);
	updateMaybe;
	inner onDeactivate;
#)
-- GUIENVscrollbarbuttondown: descriptor --
(#
do inner buttonDown; 
#)

-- GUIENVscrollbarSetScrollAmount: descriptor --
(#
do assertOpen;
	value -> private.scrollbarScrollamount;
	theEventHandler.onScrollAmountChanged;
#)

-- GUIENVscrollbarGetScrollAmount: descriptor --
(#
do assertOpen;
	private.scrollbarScrollamount -> value;
#)

-- GUIENVscrollbarSetPageScrollAmount: descriptor --
(#
do assertOpen;
	value -> private.scrollbarPageScrollAmount;
	theEventHandler.onPageScrollAmountChanged;
#)

-- GUIENVscrollbarGetPageScrollAmount: descriptor --
(#
do assertOpen;
	private.scrollbarPageScrollAmount -> value;
#)

-- GUIENVscrollbarSetMaxValue: descriptor --
(# 
do assertOpen;
	(if viewable and privateAutomaticUpdate then
		setupClipForDrawing
			(#
			do (this(control).private.controlHandle ,value) -> SetControlMaximum;
			#);
	else
		setupPortClipEmpty
			(#
			do (this(control).private.controlHandle ,value) -> SetControlMaximum;
			#);
	if);
	theEventHandler.onMaxValueChanged;
#)

-- GUIENVscrollbarGetMaxValue: descriptor --
(#
do assertOpen;
	this(control).private.controlHandle  -> GetControlMaximum -> value;
#)

-- GUIENVscrollbarSetValue: descriptor --
(#
do assertOpen;
	(if viewable and privateAutomaticUpdate then
		setupClipForDrawing
			(#
			do (this(control).private.controlHandle ,pos) -> SetControlValue;
			#);
	else
		setupPortClipEmpty
			(#
			do (this(control).private.controlHandle ,pos) -> SetControlValue;
			#);
	if);
	theEventHandler.onValueChanged;
#)

-- GUIENVscrollbarGetValue: descriptor --
(#
do assertOpen;
	this(control).private.controlHandle  -> GetControlValue -> pos;
#)

-- GUIENVscrollbarSetLength: descriptor --
(# 
   width,height: @integer;
do assertOpen;
	size -> (width,height);
   (if vertical
       then
       (width,theLength) -> size;
    else
       (theLength,height) -> size;
   if);
#)

-- GUIENVscrollbarGetLength: descriptor --
(# width,height: @integer;
do assertOpen;
	size -> (width,height);
   (if vertical then
       height -> theLength;
    else
       width -> theLength;
   if);
#)

-- GUIENVscrollbarCreate: descriptor --
(#
do inner create;
#)

-- GUIENVscrollbarOpen: descriptor --
(# mr: @macRect;
do ((0,0),size) -> mr;
	(this(window).private.windowPointer,mr[],'',false,0,0,0,ScrollbarProc,0) 
		-> NewControl -> this(control).private.controlHandle ;
	actionProc## -> setScrollbarActionProc;
	16 -> private.scrollbarScrollamount;
	50 -> private.scrollbarPageScrollAmount;
	true -> private.scrollbarActive;
	inner open;
#)
-- GUIENVscrollbarClose: descriptor --
(#
do inner close;
	0 -> private.scrollbarOrientation;
	0 -> private.scrollbarScrollamount;
	0 -> private.scrollbarPageScrollamount;
	false -> private.scrollbarActive;
#)

-- GUIENVscrollbarpagedown:  descriptor --
(#
do inner pageDown;
#)

-- GUIENVscrollbarPageUp: descriptor --
(# 
do inner pageUp;
#)

-- GUIENVscrollbarButtonUp: descriptor --
(# 
do inner buttonUp;
#)

-- GUIENVthumbMoved: descriptor --
(#
do inner thumbMoved; 
#)

-- scrollbarLib: attributes --

actionProc: external
	(# controlHandle: @integer;
		partCode: @shortInt;
		currentValue,currentMax,newValue: @integer;
	enter (controlHandle,partCode)
	do pascalExternalEntry;
		value -> currentValue;
		maxValue -> currentMax;
		(if partCode
			//inUpButton then
				(currentValue - private.scrollbarScrollamount,0) -> max -> newValue;
				newValue -> value;
				theEventHandler.onButtonUp;
			//inDownButton then
				(currentValue + private.scrollbarScrollamount,currentMax) -> min -> newValue;
				newValue -> value;
				theEventHandler.onButtonDown;
			//inPageUp then
				(currentValue - private.scrollbarPageScrollAmount,0) -> max -> newValue;
				newValue -> value;
				theEventHandler.onPageUp;
			//inPageDown then
				(currentValue + private.scrollbarPageScrollAmount,currentMax) -> min -> newValue;
				newValue -> value;
				theEventHandler.onPageDown;
		if);
	#);


setScrollbarActionProc:
	(#	theActionProc: ##actionProc;
		toFuncPtr: external
			(# func: ##actionProc;
				ptr: @integer;
			enter func##
			do 'copyinput' -> callC;
			exit ptr
			#);
	enter theActionProc##
	do theActionProc## -> toFuncPtr -> this(control).private.controlActionProc;
	#);

-- GUIENVscrollbarPrivate: descriptor --
(# scrollbarOrientation: @integer;
	scrollbarScrollamount: @integer;
	scrollbarPageScrollamount: @integer;
	scrollbarActive: @boolean;
#)


	
-- GUIENVButtonOnFrameChanged: descriptor --
(# thisOptionButton: ^optionButton;
do (if this(button).struc <= optionButton## then
		(*
			this(button)[] -> thisOptionButton[];
			thisOptionButton.adjustOptionButtonBounds;
		*)
   else
   	adjustBounds;
	if);
   inner onFrameChanged;
#)

-- GUIENVButtonOnRefresh: descriptor --
(#
do 
	(if this(control).private.controlHandle <>0 then
		private.buttonStyle[] -> useTextStyle;
		this(control).private.controlHandle  -> drawToolboxControl;
	if);
	
	inner onRefresh;
#)

-- GUIENVButtonOnMouseDown: descriptor --
(#	macPt: @macPoint;
	originalPart,returnPart,originalValue: @integer;
	thisScrollbar: ^scrollbar;
	thisOptionButton: ^optionButton;
	p: @point;
do inner onMouseDown;
	(if this(control).private.controlHandle <> 0 then
		localPosition -> p;
		privateOrigin -> p.add;
		p -> macPt.setPoint;
		
		setupClipForDrawing
			(# 
			do private.buttonStyle[] -> useTextStyle;
				(this(control).private.controlHandle ,macPt,this(control).private.controlActionProc) -> TrackControl -> returnPart;
			#);
		(if returnPart <> 0 then
			theEventHandler.onMouseUp;
		if);
		false -> sendOnMouseUp;
	else
		(if this(button).struc <= optionButton## then
			this(button)[] -> thisOptionButton[];
			this(onMouseDown)[] -> thisOptionButton.handleMouseDown;
		if);
	if);
#)

-- GUIENVbuttonSetLabel: descriptor --
(#
do assertOpen;
	theLabel.copy -> private.buttonLabel[];
	(if this(control).private.controlHandle <> 0 then
		(if viewable and privateAutomaticUpdate then
			setupClipForDrawing
				(#
				do (this(control).private.controlHandle ,theLabel) -> SetControlTitle;
				#);
		else
			setupPortClipEmpty
				(#
				do (this(control).private.controlHandle ,theLabel) -> SetControlTitle;
				#);
		if);
	else
		updateMaybe;
	if);
	theEventHandler.onLabelChanged;
#)

-- GUIENVbuttonGetLabel: descriptor --
(#
do assertOpen;
	private.buttonLabel[] -> theLabel[];
	theLabel.copy -> theLabel[];
#)

-- GUIENVbuttonSetStyle: descriptor --
(#
do assertOpen;
	theStyle[] -> private.buttonStyle[];
	updateMaybe;
	theEventHandler.onStyleChanged;
#)

-- GUIENVbuttonGetStyle: descriptor --
(#
do assertOpen;
	private.buttonStyle[] -> theStyle[];
#)

-- GUIENVbuttonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVbuttonOpen: descriptor --
(#	style: ^textStyle;
do this(button)[] -> getPatternName -> private.buttonLabel[];
	&textStyle[] -> style[];
	'Chicago' -> style.name;
    12 -> style.size;
	
	(* 'Geneva' -> style.name;
	 * 10 -> style.size;
	 * textFaces.bold -> style.face;
	 *)
	
	style[] -> private.buttonStyle[];
	inner open;
#)

-- GUIENVbuttonClose: descriptor --
(#
do inner close;
	NONE -> private.buttonStyle[];
	NONE -> private.buttonLabel[];
#)

	
-- GUIENVbuttonPrivate: descriptor --
(# buttonLabel: ^text;
	buttonStyle: ^textStyle;
#)

-- GUIENVpushButtonCreate: descriptor --
(#
do whiteBackGround -> backgroundStyle;
	inner create;
#)

-- GUIENVpushButtonOpen: descriptor --
(# mr: @macRect;
	t: ^text;
do ((0,0),size) -> mr;
	label -> t[];
	(if this(window).style = shadows then
		(this(window).private.windowPointer,mr[],t,false,0,0,0,ThreeDdefProc + PushButProc + useWFont,0) 
			-> NewControl -> this(control).private.controlHandle;
	if);
	inner open;
#)

-- GUIENVpushButtonClose: descriptor --
(#
do inner close;
#)

-- pushButtonLib: attributes --

drawButton:
	(#
	do graphics
			(# left, right, top, bottom: @integer;
			do this(guienv).private.black -> pen.foreGroundColor;
					((left + 3, top), (right - 3, top)) -> drawLine;
					((right, top + 3), (right, bottom - 3)) -> drawLine;
					((right - 3, bottom), (left + 3, bottom)) -> drawLine;
					((left, bottom - 3), (left, top + 3)) -> drawLine;
					(left + 1, top + 1) -> drawSpot;
					(right - 1, top + 1) -> drawSpot;
					(right - 1, bottom - 1) -> drawSpot;
					(left + 1, bottom - 1) -> drawSpot;
					
					this(guienv).private.gray[12] -> pen.foreGroundColor;
					(left + 2, top) -> drawSpot;
					(left, top + 2) -> drawSpot;
					(right - 2, top) -> drawSpot;
					(right, top + 2) -> drawSpot;
					(right - 2, bottom) -> drawSpot;
					(right, bottom - 2) -> drawSpot;
					(left + 2, bottom) -> drawSpot;
					(left, bottom - 2) -> drawSpot;
					
					this(guienv).private.gray[4] -> pen.foreGroundColor;
					(left + 1, top + 2) -> drawSpot;
					(left + 2, top + 1) -> drawSpot;
					
					(left + 1, bottom - 2) -> drawSpot;
					(left + 2, bottom - 1) -> drawSpot;
					
					(right - 2, top + 1) -> drawSpot;
					
					this(guienv).private.gray[5] -> pen.foreGroundColor;
					(right - 1, top + 2) -> drawSpot;
					((right - 2, top + 3), (right - 2, bottom - 3)) -> drawLine;
					((right - 3, bottom - 2), (left + 3, bottom - 2)) -> drawLine;
					(right - 3, bottom - 3) -> drawSpot;
					
					this(guienv).private.gray[8] -> pen.foreGroundColor;
					((right - 1, top + 3), (right - 1, bottom - 2)) -> drawLine;
					((right - 2, bottom - 1), (left + 3, bottom - 1)) -> drawLine;
					(right - 2, bottom - 2) -> drawSpot;
					
					this(guienv).private.white -> pen.foreGroundColor;
					((left + 2, top + 2), (right - 3, top + 2)) -> drawLine;
					((left + 2, top + 2), (left + 2, bottom - 3)) -> drawLine;
					(left + 3, top + 3) -> drawSpot;
			#);
	#);

(* setHilite:
	(# value: @boolean;
	enter value
	do (if value <> private.hilited then
			value -> private.hilited;
			draw;
		if);
	#);
*)

draw:
	(# makeColor:
			(# maxValue: (# exit 65535 #);
				percent: @integer;
				value: @integer;
				theColor: ^color;
			enter	percent
			do (maxValue * percent) div 100 -> value;
				&color[] -> theColor[];
				(value, value, value) -> theColor;
			exit theColor[]
			#);
	do graphics
			(# black, lightColor, darkColor, mediumColor: ^color;
				width, height: @integer;
				tWidth: @integer;
				tHeight: @integer;
				theStyle: ^textStyle;
			do size -> (width, height);
				0 -> makeColor -> black[];
				100 -> makeColor -> lightColor[];
				50 -> makeColor -> darkColor[];
				80 -> makeColor -> mediumColor[];
				
				mediumColor -> pen.foreGroundColor;
				((2, 2), (width - 2, height - 2)) -> fillRect;
				
				black -> pen.foreGroundColor;
				this(button).style -> theStyle[] -> style;
				label -> theStyle.widthOfText -> tWidth; 
				theStyle.lineHeight -> tHeight;
				(if hilite then
					((width - tWidth) div 2,
					 (height - tHeight) div 2 + theStyle.ascent) -> moveTo;
				else
					((width - tWidth) div 2,
					 (height - tHeight) div 2 + theStyle.ascent) -> moveTo;
				if);
				label -> drawText;
				 
				((1, 0), (width - 2, 0)) -> drawLine;
				((width - 1, 1), (width - 1, height - 2)) -> drawLine;
				((width - 2, height - 1), (2, height - 1)) -> drawLine;
				((0, height - 2), (0, 1)) -> drawLine;
				
				(if hilite then
					darkColor -> pen.foreGroundColor;
				else
					lightColor -> pen.foreGroundColor;
				if);
				((1, height - 2), (1, 1)) -> drawLine;
				((2, 1), (width - 2, 1)) -> drawLine;
				
				(if hilite then
					lightColor -> pen.foreGroundColor;
				else
					darkColor -> pen.foreGroundColor;
				if);
				((width - 2, 2), (width - 2, height - 2)) -> drawLine;
				((width - 3, height - 2), (1, height - 2)) -> drawLine;
				
			#);
		#);

-- GUIENVpushButtonPrivate: descriptor --
(#
#)

-- GUIENVstaticTextOnRefresh: descriptor --
(#	mr: @macRect;
	t: ^text;
do ((0,0),size) -> mr;
	label -> t[];
	(if (t[] <> none) and (t.length <> 0) then
		graphics
			(#
			do this(statictext).style -> style;
				(t[], mr[], 0) -> TextBox;
			#);
	if);
	inner onRefresh;
#)

-- GUIENVstaticTextCreate: descriptor --
(#
do inner create;
#)

-- GUIENVstaticTextOpen: descriptor --
(# style: ^textStyle;
do &textStyle[] -> style[];
	'Geneva' -> style.name;
	10 -> style.size;
	textFaces.bold -> style.face;
	
	style[] -> this(button).private.buttonStyle[];
	inner open;
#)

-- GUIENVstaticTextClose: descriptor --
(#
do inner close;
#)

-- GUIENVstaticTextPrivate: descriptor --
(#
#)

-- GUIENViconButtonOnRefresh: descriptor --
(# calcImageBounds:
     (# 
     do (if showLabel then
            theLabel[] -> theStyle.widthOfText -> textWidth;
            theStyle.lineHeight -> textHeight;
         else
            0 -> textWidth;
            0 -> textHeight;
        if);
        (if private.iconButtonRaster[]<>none then
            private.iconButtonRaster.width -> iconWidth;
            private.iconButtonRaster.height -> iconHeight;
         else
            0 -> iconWidth;
            0 -> iconHeight;
        if);
        (textHeight+iconHeight) -> imageHeight;
        (textWidth,iconWidth) -> max -> imageWidth;
     #);
   calcImageAnchors:
     (# width,height: @integer;
     do size -> (width,height);
        (width - iconWidth) div 2 -> iconAnchor.h;
        (height - imageHeight) div 2 -> iconAnchor.v;
        (width - textWidth) div 2 -> textAnchor.h;
        iconAnchor.v + iconHeight + theStyle.ascent -> textAnchor.v;
     #);
   theStyle: ^textStyle;
   theLabel: ^text;
   imageWidth,imageHeight,textWidth,textHeight,iconWidth,iconHeight: @integer;
   iconAnchor,textAnchor: @point;
	
	DrawBitMapInPort: external
		(# bitmapHandle: @integer;
			port: @integer;
			from,to,width,height: @integer;
		enter (bitmapHandle,port,from,to,width,height)
		#);
do style -> theStyle[];
   label -> theLabel[];
   calcImageBounds;
   calcImageAnchors;
	setupClipForDrawing
		(# f: @rectangle;
			from,to: @macPoint;
			wp: @integer;
		do PenNormal;
			blackColor -> ForeColor;
			(if private.iconButtonRaster[]<>none then
				(0,0) -> from.setPoint;
				iconAnchor -> to.setPoint;
				windowPointer -> wp;
				private.iconButtonRaster.lock;
				(private.iconButtonRaster.rasterAddress,wp,from,to,iconWidth,iconHeight) 
					-> DrawBitMapInPort;
				private.iconButtonRaster.unlock;
				(if hilite then
					((0,0),size) -> f;
					f.bottom - 1 -> f.bottom;
					f.right - 1 -> f.right;
					f[] -> makeMacRect -> FrameRect;
					(1,1) -> f.inset;
					f[] -> makeMacRect -> FrameRect;
				if);
			if);
			(if showLabel then
				(textAnchor.h,textAnchor.v) -> MoveTo;
				theStyle[] -> useTextStyle;
				theLabel[] -> DrawBetaText;
			if);
		#);
   inner onRefresh;
#)

-- GUIENViconbuttonOnHiliteChanged: descriptor --
(#
do inner onHiliteChanged;
#)

-- GUIENViconButtonSetShowLabel: descriptor --
(#
do assertOpen;
	doShow -> private.iconButtonShowLabel;
	theEventHandler.onShowLabelChanged;
	updateMaybe;
#)

-- GUIENViconButtonGetShowLabel: descriptor --
(#
do assertOpen;
	private.iconButtonShowLabel -> doShow;
#)

-- GUIENViconButtonSetIcon: descriptor --
(#
do assertOpen;
	theIcon[] -> private.iconButtonRaster[];
	theEventHandler.onIconChanged;
	updateMaybe;
#)

-- GUIENViconButtonGetIcon: descriptor --
(#
do assertOpen;
	private.iconButtonRaster[] -> theIcon[];
#)

-- GUIENViconButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENViconButtonOpen: descriptor --
(#	
do true -> private.iconButtonShowLabel;
	inner open;
#)

-- GUIENViconButtonClose: descriptor --
(#
do inner close;
	false -> private.iconButtonShowLabel;
	NONE -> private.iconButtonRaster[];
#)


-- GUIENViconButtonPrivate: descriptor --
(# iconButtonShowLabel: @boolean;
	iconButtonRaster: ^raster;
#)

-- optionButtonLib: attributes --

handleMouseDown:
	(# theEvent: ^eventHandler.mouseDown;
		left, top: @integer;
		width, height: @integer;
		theMenu: ^menu;
		result: @longInt;
	enter theEvent[]
	do drawPressed;
		popupMenu -> theMenu[];
		(if theMenu[] <> none then
			labelWidth + 5 -> left;
			size -> (width, height);
			height -> top;
			(left, top) -> toScreenCoordinates -> (left, top);
			theMenu.adjust;
			(theMenu.handle, -1) -> InsertMenu;
			(theMenu.handle,top, left,0) -> PopUpMenuSelect -> result;
			(if result.hiWord<>0 then
				(result.hiWord,result.loWord) -> processMenuSelect;
				result.loWord -> currentItem;
			if);
			theMenu.menuID -> DeleteMenu			
		else
			trackMouse;
		if);
		drawNormal;
	#);

getCurrentItemText:
	(# itemText: ^text;
		theMenu: ^menu;
		theItem: ^menu.menuItem;
	do popupMenu -> theMenu[];
		(if theMenu[] <> NONE then
			(if private.currentItem <> 0 then
				private.currentItem -> theMenu.getMenuitemByNumber -> theItem[];
				(if theItem[] <> none then
					theItem.name -> itemText[];
				if);
			if);
		if);
	exit itemText[]
	#);
	
optionButtonGraphics: graphics
	(# left, right, top, bottom: @integer;
		
		drawOuterBorder:
			(#
			do this(guienv).private.black -> pen.foreGroundColor;
				((left + 3, top), (right - 3, top)) -> drawLine;
				((right, top + 3), (right, bottom - 3)) -> drawLine;
				((right - 3, bottom), (left + 3, bottom)) -> drawLine;
				((left, bottom - 3), (left, top + 3)) -> drawLine;
				(left + 1, top + 1) -> drawSpot;
				(right - 1, top + 1) -> drawSpot;
				(right - 1, bottom - 1) -> drawSpot;
				(left + 1, bottom - 1) -> drawSpot;
				
				this(guienv).private.gray[12] -> pen.foreGroundColor;
				(left + 2, top) -> drawSpot;
				(left, top + 2) -> drawSpot;
				(right - 2, top) -> drawSpot;
				(right, top + 2) -> drawSpot;
				(right - 2, bottom) -> drawSpot;
				(right, bottom - 2) -> drawSpot;
				(left + 2, bottom) -> drawSpot;
				(left, bottom - 2) -> drawSpot;
			#);
		drawLabel:
			(# mr: @macRect;
				t: ^text;
			do label -> t[];
				(if t.length > 0 then
					 (0,bottom - 5) -> moveTo;
					 t[] -> drawText;
				if);
			#);
		drawInnerText:
			(# itemText: ^text;
			do (left + 8, bottom - 5) -> moveTo;
				getCurrentItemText -> itemText[];
				(if itemText[] <> NONE then
					itemText[] -> drawText;
				if);
			#);
		drawArrow:
			(# arrowLeft, arrowTop: @integer;
				arrowWidth: (# exit 9 #);
			enter (arrowLeft, arrowTop)
			do (for inx: 5 repeat
					((arrowLeft + (inx - 1), arrowTop + (inx - 1)), (arrowLeft + arrowWidth - inx, arrowTop + (inx - 1))) -> drawLine;
				for);
			#);
	do labelWidth + 5 -> left;
		0 -> top;
		size -> (right, bottom);
		right - 1 -> right;
		top + 20 -> bottom;
		(* bottom - 1 -> bottom; *)
		
		(left, top, right + 1, bottom + 1) -> EraseRectangle;
		drawLabel;
		drawOuterBorder;
		INNER;
	#);
drawNormal: optionButtonGraphics
	(#
	do 
		this(guienv).private.gray[4] -> pen.foreGroundColor;
					
		(right - 2, top + 1) -> drawSpot;
		(right - 21, bottom - 1) -> drawSpot;
		
		this(guienv).private.gray[5] -> pen.foreGroundColor;
		(right - 1, top + 2) -> drawSpot;
		((right - 2, top + 3), (right - 2, bottom - 3)) -> drawLine;
		((right - 3, bottom - 2), (right - 19, bottom - 2)) -> drawLine;
		((right - 23, bottom - 1), (left + 2, bottom - 1)) -> drawLine;
		((right - 22, top + 2), (right - 22, bottom - 1)) -> drawLine;

		
		this(guienv).private.gray[8] -> pen.foreGroundColor;
		((right - 1, top + 3), (right - 1, bottom - 2)) -> drawLine;
		((right - 2, bottom - 1), (right - 20, bottom - 1)) -> drawLine;
		(right - 2, bottom - 2) -> drawSpot;
		
		
		this(guienv).private.white -> pen.foreGroundColor;
		((left + 2, top + 1), (right - 23, top + 1)) -> drawLine;
		((left + 1, top + 2), (left + 1, bottom - 2)) -> drawLine;
		((right - 20, top + 2), (right - 3, top + 2)) -> drawLine;
		((right - 20, top + 2), (right - 20, bottom - 3)) -> drawLine;
		
		this(guienv).private.black -> pen.foreGroundColor;
		drawInnerText;
		(right - 14, bottom - 11) -> drawArrow;
	#);
	
drawPressed: optionButtonGraphics
	(#
	do this(guienv).private.gray[9] -> pen.foreGroundColor;
		((left + 2, top + 2), (right - 22, bottom - 1)) -> fillRect;
		
		((right - 19, top + 3), (right - 2, bottom - 2)) -> fillRect;
		
		(right - 2, top + 2) -> drawSpot;
		(right - 20, bottom - 2) -> drawSpot;
		
		this(guienv).private.gray[11] -> pen.foreGroundColor;
		
		((right - 21, top + 1), (right - 2, top + 1)) -> drawLine;
		((right - 21, top + 1), (right - 21, top - 1)) -> drawLine;
				
		this(guienv).private.gray[8] -> pen.foreGroundColor;
		(right - 1, top + 2) -> drawSpot;
		((right - 2, top + 3), (right - 2, bottom - 3)) -> drawLine;
		((right - 3, bottom - 2), (right - 19, bottom - 2)) -> drawLine;
		((right - 23, bottom - 1), (left + 2, bottom - 1)) -> drawLine;
		((right - 22, top + 2), (right - 22, bottom - 1)) -> drawLine;

		
		this(guienv).private.gray[7] -> pen.foreGroundColor;
		((right - 1, top + 3), (right - 1, bottom - 2)) -> drawLine;
		((right - 2, bottom - 1), (right - 20, bottom - 1)) -> drawLine;
		(right - 2, bottom - 2) -> drawSpot;
		
		
		this(guienv).private.gray[10] -> pen.foreGroundColor;
		((left + 2, top + 1), (right - 22, top + 1)) -> drawLine;
		((left + 1, top + 2), (left + 1, bottom - 2)) -> drawLine;
		(left + 2, top + 2) -> drawSpot;
		((right - 20, top + 2), (right - 3, top + 2)) -> drawLine;
		((right - 20, top + 2), (right - 20, bottom - 3)) -> drawLine;
		
		
		this(guienv).private.white -> pen.foreGroundColor;
		drawInnerText;
		(right - 14, bottom - 11) -> drawArrow;
	#);
	
maxStringLength: integerValue
	(# style: @textStyle;
		theMenu: ^menu;
	do 'Chicago' -> style.name;
		12 -> style.size;
		popupMenu -> theMenu[];
		(if theMenu[] = none then
			'Nothing' -> style.widthOfText -> value;
		else
			theMenu.scan
				(# w: @integer;
				do	current.name -> style.widthOfText -> w;
					(value, w) -> Max -> value;
				#);
			
		if);
	#);
labelWidth: integerValue
	(# s: ^textStyle;
	do	style -> s[];
		label -> s.widthOfText -> value;
	#);
	
(*
adjustOptionButtonBounds:
	(# h,v,width,height: @integer;
		theHandle: @integer;
	do theControlHandle -> theHandle;
		(if theHandle<>0 then
			h + labelWidth + 5 -> h;
			maxStringLength + 41 -> width;
			19 -> height;
			
			(theHandle,h,v,width,height) -> updateToolboxControl;
		if);
	#);
	
*)

	
-- GUIENVoptionButtonSetCurItem: descriptor --
(#
do	assertOpen;
	itemNo -> private.currentItem;
	updateMaybe;
	theEventHandler.onCurrentItemChanged;
	
#)
-- GUIENVoptionButtonGetCurItem: descriptor --
(#
do assertOpen;
	private.currentItem -> itemNo;

#)
-- GUIENVoptionButtonSetPopupMenu: descriptor --
(# 
do	assertOpen;
	popupMenu[] -> private.menuButtonPopupMenu[];
	1 -> private.currentItem;
	updateMaybe;
	theEventHandler.onPopUpMenuChanged;
#)
-- GUIENVoptionButtonGetPopupMenu: descriptor --
(#
do assertOpen;
	private.menuButtonPopupMenu[] -> popupMenu[];
#)


-- GUIENVoptionButtonCreate: descriptor --

(#
do	grayBackground -> backgroundStyle;
	inner create;
#)


-- GUIENVoptionButtonOpen: descriptor --
(#
do ((0, 0), (200, 20)) -> privateWindowItemFrame;
	INNER open;
#)


-- GUIENVoptionButtonClose: descriptor --
(#
do inner close;
	NONE -> private.menuButtonPopupMenu[];
	0 -> private.currentItem;
#)

-- GUIENVoptionButtononstylechanged: descriptor --
(#
do inner onStyleChanged;
#)

-- GUIENVoptionButtononlabelchanged: descriptor --
(#
do 
	inner onLabelChanged;
#)

-- GUIENVoptionButtonOnRefresh: doPart --
do drawNormal;
	INNER;
	
-- GUIENVoptionButtonprivate: descriptor --
(# menuButtonPopupMenu: ^menu;
	currentItem: @integer;
#)

-- GUIENVtoggleButtonSetState: descriptor --
(#
do	assertOpen;
	theState -> private.toggleButtonState;
	(if this(control).private.controlHandle <> 0 then
		(if viewable and privateAutomaticUpdate then
			setupClipForDrawing
				(# v: @integer;
				do (if theState then
						1 -> v;
					else
						0 -> v;
					if);
					(this(control).private.controlHandle ,v) -> SetControlValue;
				#);
		else
			setupPortClipEmpty
				(# v: @integer;
				do (if theState then
						1 -> v;
					else
						0 -> v;
					if);
					(this(control).private.controlHandle ,v) -> SetControlValue;
				#);
		if);
	if);
	theEventHandler.onStateChanged;
#)

-- GUIENVtoggleButtonGetState: descriptor --
(#
do assertOpen;
	private.toggleButtonState -> theState;
#)

-- GUIENVtoggleButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVtoggleButtonOpen: descriptor --
(#	
do false -> private.toggleButtonState;
	inner open;
#)

-- GUIENVtoggleButtonClose: descriptor --
(#
do inner close;
	false -> private.toggleButtonState;
#)


-- GUIENVtoggleButtonPrivate: descriptor --
(# toggleButtonState: @boolean;
#)

-- GUIENVradioButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVRadioButtonOpen: descriptor --
(#	r: @rectangle;
	mr: ^macRect;
	t: ^text;
do	((0,0),size) -> r;
	r[] -> makeMacRect -> mr[];
	label -> t[];
	(this(window).private.windowPointer,mr[],t,false,0,0,1,ThreeDdefProc + radioButProc + useWFont,0) 
		-> NewControl -> this(control).private.controlHandle ;
	inner open;
#)

-- GUIENVRadioButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVradioButtonPrivate: descriptor --
(#
#)

-- GUIENVcheckBoxCreate: descriptor --
(#
do inner create;
#)

-- GUIENVcheckBoxOpen: descriptor --
(#	r: @rectangle;
	mr: ^macRect;
	t: ^text;
do	((0,0),size) -> r;
	r[] -> makeMacRect -> mr[];
	label -> t[];
	(this(window).private.windowPointer,mr[],t,false,0,0,1,ThreeDdefProc + checkBoxProc + useWFont,0) 
		-> NewControl -> this(control).private.controlHandle ;
	inner open;
#)

-- GUIENVcheckBoxClose: descriptor --
(#
do inner close;
#)

-- GUIENVcheckBoxPrivate: descriptor --
(#
#)

-- GUIENVeditTextSetStyle: descriptor --
(#
do assertOpen;
	txStyle[] -> private.editTextStyle[];
	txStyle[] -> updateStyle;
#)

-- GUIENVeditTextGetStyle: descriptor --
(#
do assertOpen;
	private.editTextStyle[] -> txStyle[];
#)

-- GUIENVeditTextSetContents: descriptor --
(#
do assertOpen;
	(str[], private.editTextHandle) -> TextEditSetText;
	updateMaybe;
#)

-- GUIENVeditTextGetContents: descriptor --
(# length: @integer;
	textHandle: @integer;
	TextEditGetLength: external
		(#	teHandle: @integer;
			length: @integer;
		enter teHandle
		exit length
		#);
do assertOpen;
	private.editTextHandle -> TextEditGetLength -> length;
	(if length > 0 then
		length - str.T.range -> str.extend;
		private.editTextHandle -> TEGetText -> textHandle;
		textHandle -> MakeText -> str[];
	else
		'' -> str[];
	if);
#)

-- GUIENVeditTextonFrameChanged: descriptor --
(#	viewRect,destRect: ^macRect;
	UpdateTextEditRecord: external
		(#	teHandle: @integer;
			view,dest: ^macRect;
		enter (teHandle,view[],dest[])
		#);
	style: ^textStyle;
	width,height: @integer;
do private.editTextStyle[] -> style[];
	size -> (width,height);
	((style.lineHeight * 2) > (height - 6)) -> private.editTextSingleLine;
	calcViewRect -> makeMacRect -> viewRect[];
	calcDestRect -> makeMacRect -> destRect[];
	(private.editTextHandle,viewRect[],destRect[]) -> UpdateTextEditRecord;
	private.editTextHandle -> TECalText;
	inner onFrameChanged;
#)

-- GUIENVeditTextonKeyDown: descriptor --
(#
do setupClipForDrawing
		(#	insertChar: @boolean;
		do ResetPen;
			true -> insertChar;
			(if ch
				//13 then
					(if private.editTextSingleLine then
						false -> insertChar
					if);
				//3 then false -> insertChar;
			if);
			(if insertChar then
				(ch,private.editTextHandle) -> TEKey;
			if);
		#);
	inner onKeyDown;
#)

-- GUIENVeditTextonMouseDown: descriptor --
(#
do this(editText)[] -> target;
	setupClipForDrawing
		(#	p: @point;
			macPt: @macPoint;
		do ResetPen;
			localPosition -> p;
			(* privateOrigin -> p.add; *)
			p -> macPt.setPoint;
			(macPt,false,private.editTextHandle) -> TEClick;
		#);
	inner onMouseDown;
#)

-- GUIENVeditTextonRefresh: descriptor --
(#
do setupClipForDrawing
		(#	viewRect: ^macRect;
		do	ResetPen;
			calcViewRect -> makeMacRect -> viewRect[];
			viewRect[] -> EraseRect;
			(viewRect[],private.editTextHandle) -> TEUpdate;
		#);
	(((0, 0), size), borderStyles.shadowIn) -> drawBorder;
	inner onRefresh;
#)

-- GUIENVeditTextonEnableTarget: descriptor --
(#
do setupClipForDrawing
		(#
		do ResetPen;
			private.editTextHandle -> TEActivate
		#);
	private.installTimer;
	inner onEnableTarget;
#)

-- GUIENVeditTextonDisableTarget: descriptor --
(#
do setupClipForDrawing
		(#
		do 
			ResetPen;
			(if private.editTextHandle <> 0 then
				private.editTextHandle -> TEDeactivate;
			if);
		#);
	private.deleteTimer;
	inner onDisableTarget;
#)

-- GUIENVeditTextCreate: descriptor --
(#
do whiteBackGround -> backGroundStyle;
	inner create;
#)

-- GUIENVeditTextOpen: descriptor --
(#	style: ^textStyle;
	viewRect,destRect: ^macRect;
do	&textStyle[] -> style[];
	'Geneva' -> style.name;
	10 -> style.size;
	
	
	style[] -> private.editTextStyle[];
	((0,0),(100,6 + style.lineHeight + style.leading)) -> privateWindowItemFrame;
	true -> private.editTextSingleLine;
	calcViewRect -> makeMacRect -> viewRect[];
	calcDestRect -> makeMacRect -> destRect[];
	setupClipForDrawing
		(#
		do private.editTextStyle[] -> useTextStyle;
			(destRect[],viewRect[]) -> TENew -> private.editTextHandle;
			(true,private.editTextHandle) -> TEAutoView;
		#);
	cursors.iBeam[] -> theCursor;
	(if this(window).style = plain then
		borderStyles.simple -> border.style;
	else
		borderStyles.shadowIn -> border.style;
	if);
	true -> border.visible;
	cursors.iBeam[] -> theCursor;
	inner open;
#)

-- GUIENVeditTextClose: descriptor --
(#
do inner close;
	private.editTextHandle -> TEDispose;
	0 -> private.editTextHandle;
	NONE -> private.editTextStyle[];
#)

-- editTextLib: attributes --

calcViewRect:
	(#	r: ^rectangle;
		minInt: (# exit -32767 #);
	do	&rectangle[] -> r[];
		(if textVisible then
			((0,0),size) -> r;
			(* privateOrigin -> r.offset; *)
			(2,2) -> r.inset;
		else
			((minInt,minInt),(minInt + 1,minInt + 1)) -> r; 
		if);
	exit r[]
	#);
calcDestRect:
	(#	style: ^textStyle;
		width,height,lineHeight: @integer;
		singleLine: @boolean;
		h,v: @integer;
		r: ^rectangle;
		minInt: (# exit -32767 #);
	do	&rectangle[] -> r[];
		private.editTextStyle[] -> style[];
		(if textVisible then
			size -> (width,height);
			(* privateOrigin -> (h,v); *)
			(h+3,v+3) -> r.topLeft;
			(if private.editTextSingleLine then
				r.left + 1000 -> r.right;
				r.top + style.lineHeight + style.leading -> r.bottom;
			else
				r.left + (width - 6) -> r.right;
				r.top + (height - 6) -> r.bottom;
			if);
		else
			((minInt,minInt),(minInt + style.maxChWidth,minInt + 1)) -> r;
		if);
	exit r[]
	#);
updateStyle:
	(# style: ^textStyle;
	enter style[]
	do
	#);
textVisible: booleanValue
	(# width,height: @integer;
		style: ^textStyle;
	do private.editTextStyle[] -> style[];
		size -> (width,height);
		((width > (6 + style.maxChWidth)) and (height > 6)) -> value;
	#);

-- GUIENVeditTextPrivate: descriptor --
(#	editTextStyle: ^textStyle;
	editTextHandle: @integer;
	editTextSingleLine: @boolean;
	
	installTimer:
		(#
		do theTimer[] -> this(GUIenv).private.timerQueue.insert;
		#);
	deleteTimer:
		(#
		do theTimer[] -> this(GUIenv).private.timerQueue.delete;
		#);
	theTimer: @timerAction
		(# doIt:@ setupClipForDrawing
				(#
				do editTextHandle -> TEIdle;
				#);
		do (if editTextHandle <> 0 then
				doIt;
			if);
		#);
#)

-- GUIENVsetDefaultButton: descriptor --
(#
do	assertOpen;
	theButton.assertOpen;
	theButton[] -> windowDefaultButton;
#)

-- GUIENVgetDefaultButton: descriptor --
(#
do assertOpen;
	windowDefaultButton -> theButton[];
#)
-- GUIENVcontrolputLayout: doPart --
do

-- GUIENVcontrolgetLayout: doPart --
do

-- GUIENVscrollbarputLayout: doPart --
do

-- GUIENVscrollbargetLayout: doPart --
do

-- GUIENVbuttonputLayout: doPart --
do

-- GUIENVbuttongetLayout: doPart --
do

-- GUIENVpushButtonputLayout: doPart --
do

-- GUIENVpushButtongetLayout: doPart --
do

-- GUIENVstaticTextputLayout: doPart --
do

-- GUIENVstaticTextgetLayout: doPart --
do

-- GUIENViconButtonputLayout: doPart --
do

-- GUIENViconButtongetLayout: doPart --
do

-- GUIENVoptionButtonputLayout: doPart --
do
   
-- GUIENVoptionButtongetLayout: doPart --
do

-- GUIENVtoggleButtonputLayout: doPart --
do

-- GUIENVtoggleButtongetLayout: doPart --
do

-- GUIENVradioButtonputLayout: doPart --
do

-- GUIENVradioButtongetLayout: doPart --
do

-- GUIENVcheckBoxputLayout: doPart --
do

-- GUIENVcheckBoxgetLayout: doPart --
do

-- GUIENVeditTextputLayout: doPart --
do

-- GUIENVeditTextgetLayout: doPart --
do

-- GUIENVcontrolOnEnabledChanged: doPart --
do (if private.controlHandle <> 0 then
		(if viewable and privateAutomaticUpdate then
			setupClipForDrawing
				(#
				do
					(if enabled then
						(private.controlHandle, 0) -> HiliteControl;
					else
						(private.controlHandle, 255) -> HiliteControl
					if);
				#);
		else
			setupPortClipEmpty
				(#
				do
					(if enabled then
						(private.controlHandle, 0) -> HiliteControl;
					else
						(private.controlHandle, 255) -> HiliteControl
					if);
				#);
		if);
	if);
	inner;

-- GUIENVtoggleButtonOnMouseUp: doPart --
do not state -> state;
	inner;
	
-- GUIENVpushButtonOnMouseDown: doPart --
do inner;
	(if this(control).private.controlHandle = 0 then
		trackMouse
			(# r: @rectangle;
				inside: @
					(# p: @point;
						value: @boolean;
					enter p
					do p -> r.containsPoint -> value;
					exit value
					#);
				mousePress::
					(#
					do ((0, 0), size) -> r;
						true -> hilite;
					#);
				mouseMove::
					(#
					do curPt -> inside -> hilite;
					#);
				mouseRelease::
					(#
					do false -> hilite;
						(if curPt -> inside then
							onMouseUp;
						if);
					#);
			#);
	if);
	

-- GUIENVpushButtonOnRefresh: doPart --
do (if this(control).private.controlHandle = 0 then
		draw;
	if);
	inner;
-- GUIENVpushButtonHiliteChanged: doPart --
do draw;
