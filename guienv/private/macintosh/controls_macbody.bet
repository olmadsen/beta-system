ORIGIN '../controlsbody';


INCLUDE 'guienv_macprivate';
INCLUDE 'controlmanager';
INCLUDE '~beta/maclib/v3.0/textedit';
INCLUDE '~beta/maclib/v3.0/memory';
INCLUDE '~beta/maclib/v3.0/debug';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE 'quickdrawstuff';
INCLUDE 'raster_macprivate';
INCLUDE '../../graphics';

-- GUIENVcontrolCreate: descriptor --
(#
do inner create;
#)

-- GUIENVcontrolOpen: descriptor --
(#
do &controlMethods[] -> windowitemMethods;
	inner open;
#)

-- GUIENVcontrolClose: descriptor --
(#
do inner close;
	(if private.controlHandle<>0//true then
		private.controlHandle -> disposeToolBoxControl;
		0 -> private.controlHandle;
	if);
#)

-- controlLib: attributes --

putPoint:
	(# h, v: @integer;
	enter (h, v)
	do '[' -> put;
		h -> putInt;
		' ' -> put;
		v -> putInt;
		']' -> put;
	#);
putRect:
	(# left, top, right, bottom: @integer;
	enter ((left, top), (right, bottom))
	do (left, top) -> putPoint;
		(right, bottom) -> putPoint;
	#);

(* updateToolboxControl and drawToolboxControl are designed to
 * avoid flicker. The problem is that SizeControl redraws the
 * control imediately and uienv wants the control to be drawn by
 * the event loop. So when the control is resized it is first 
 * hidden to prevent the flicker. And then when the control is
 * drawn it is shown if it is invisible.
 *)
 
 goDebug:
 	(# s: @text;
		handle: @integer;
	enter	handle
	do handle -> s.putInt;
		s -> DebugStr;
	#);
	
updateToolboxControl:
	(# controlHandle: @integer;
		width,height: @integer;
		x, y: @integer;
		s: @text;
	enter (controlHandle,x,y,width,height)
	do 
		focusZero
			(#
			do HidePen;
				controlHandle -> HideControl;
				(controlHandle,width,height) -> SizeControl;
				(controlHandle,x,y) -> MoveControl;
				
				
				ShowPen;
			#);
		
	#);
drawToolboxControl:
	(# controlHandle: @integer;
		visible: @integer;
		controlRec: @controlRecord;
		
	enter controlHandle
	do controlHandle -> HLock;
		controlHandle -> controlRec.initFromHandle;
		controlRec.contrlVis -> visible;
		controlHandle -> HUnLock;
	   focusZero
			(#
			do (if this(control).struc <= optionButton## then
					this(guienv).private.whitePat -> BackPat;
				if);
				(if visible//255 then
					controlHandle -> Draw1Control;
				else
					HidePen;
					controlHandle -> ShowControl;
					ShowPen;
					controlHandle -> Draw1Control;
				if);
			#);
	#);
removeToolboxControl:
	(# controlHandle: @integer;
		RemoveFromOwner: external
			(# controlHandle: @integer;
			enter controlHandle
			#);
	enter controlHandle
	do controlHandle -> RemoveFromOwner;
	#);
disposeToolboxControl:
	(# controlHandle: @integer;
	enter controlHandle
	do focusZero
			(#
			do hidePen;
				controlHandle -> DisposeControl;
				showPen;
			#);
	#);
adjustBounds:
	(# h,v,width,height: @integer;
		f: @rectangle;
	do (if private.controlHandle<>0 then
			((0,0),size) -> f;
			privateOrigin -> f.offset;
			f.size -> (width,height);
			f.topLeft -> (h,v);
			(private.controlHandle,h,v,width,height) -> updateToolboxControl;
		if);
	#);

controlMethods: methods
	(#	hit::< defaultHitMethod;
		calculateFocus::< defaultCalculateFocus
			(#
			do adjustBounds;
				inner;
			#);
		handleCursor::< defaultHandleCursorMethod;
	#);
theControlHandle:
	(#
	exit private.controlHandle
	#);
-- GUIENVcontrolPrivate: descriptor --
(# controlHandle: @integer;
	controlActionProc: @integer;
#)

-- GUIENVScrollbarOnFrameChanged: descriptor --
(# 
do adjustBounds;
	inner onFrameChanged;
#)

-- GUIENVScrollbarOnRefresh: descriptor --
(#
do (if private.scrollbarActive//true then
		this(control).private.controlHandle  -> drawToolboxControl;
	else
		focus
			(#	r: @rectangle;
				mr: ^macRect;
			do	((0,0),size) -> r;
				r[] -> makeMacRect -> mr[];
				ResetPen;
				mr[] -> FrameRect;
				(*(mr[],1,1) -> InsetRect;
				mr[] -> EraseRect;
				*)
			#);
	if);
	inner onRefresh;
#)

-- GUIENVScrollbarOnMouseDown: descriptor --
(#	macPt: @macPoint;
	originalPart,returnPart,originalValue: @integer;
	p: @point;
do inner onMouseDown;
	localPosition -> p;
	privateOrigin -> p.add;
	p -> macPt.setPoint;
	(this(control).private.controlHandle ,macPt) -> TestControl -> originalPart;
	focusZero
		(#
		do (if originalPart//inThumb then
				value -> originalValue;
				(this(control).private.controlHandle ,macPt,0) -> TrackControl -> returnPart;
				(if returnPart//originalPart then
					(value - originalValue) -> theEventHandler.onThumbMoved;
				if);
			else
				(this(control).private.controlHandle,
				macPt,
				this(control).private.controlActionProc) -> TrackControl -> returnPart;
			if);
			(if returnPart//originalPart then
				theEventHandler.onMouseUp;
				none -> hitWindowItem;
			if);
		#);
#)

-- GUIENVscrollbarOnActivate: descriptor --
(#
do	true -> private.scrollbarActive;
	updateMaybe;
	inner onActivate;
#)

-- GUIENVscrollbarOnDeactivate: descriptor --
(#
do	false -> private.scrollbarActive;
	focusZero
		(#
		do	HidePen;
			this(control).private.controlHandle -> HideControl;
			ShowPen;
		#);
	updateMaybe;
	inner onDeactivate;
#)
-- GUIENVscrollbarbuttondown: descriptor --
(#
do inner buttonDown; 
#)

-- GUIENVscrollbarSetScrollAmount: descriptor --
(#
do value -> private.scrollbarScrollamount;
	theEventHandler.onScrollAmountChanged;
#)

-- GUIENVscrollbarGetScrollAmount: descriptor --
(#
do private.scrollbarScrollamount -> value;
#)

-- GUIENVscrollbarSetPageScrollAmount: descriptor --
(#
do value -> private.scrollbarPageScrollAmount;
	theEventHandler.onPageScrollAmountChanged;
#)

-- GUIENVscrollbarGetPageScrollAmount: descriptor --
(#
do private.scrollbarPageScrollAmount -> value;
#)

-- GUIENVscrollbarSetMaxValue: descriptor --
(# 
do focusZero
		(#
		do (this(control).private.controlHandle ,value) -> SetControlMaximum;
		#);
	theEventHandler.onMaxValueChanged;
#)

-- GUIENVscrollbarGetMaxValue: descriptor --
(#
do this(control).private.controlHandle  -> GetControlMaximum -> value;
#)

-- GUIENVscrollbarSetValue: descriptor --
(#
do 
	focusZero
		(#
		do (this(control).private.controlHandle ,pos) -> SetControlValue;
		#);
	theEventHandler.onValueChanged;
#)

-- GUIENVscrollbarGetValue: descriptor --
(#
do this(control).private.controlHandle  -> GetControlValue -> pos;
#)
(******
-- GUIENVscrollbarSetOrientation: descriptor --
(#
do theOrientation -> private.scrollbarOrientation;
#)

-- GUIENVscrollbarGetOrientation: descriptor --
(#
do private.scrollbarOrientation -> theOrientation;
#)
*****)
-- GUIENVscrollbarSetLength: descriptor --
(#
do (* not implemented !!! *)
#) 

-- GUIENVscrollbarGetLength: descriptor --
(#
do (* not implemented !!! *)
#)

-- GUIENVscrollbarCreate: descriptor --
(#
do inner create;
#)

-- GUIENVscrollbarOpen: descriptor --
(# mr: @macRect;
do ((0,0),size) -> mr;
	(this(window).private.windowPointer,mr[],'',false,0,0,0,ScrollbarProc,0) 
		-> NewControl -> this(control).private.controlHandle ;
	actionProc## -> setScrollbarActionProc;
	16 -> private.scrollbarScrollamount;
	50 -> private.scrollbarPageScrollAmount;
	true -> private.scrollbarActive;
	inner open;
#)
-- GUIENVscrollbarClose: descriptor --
(#
do inner close;
#)

-- GUIENVscrollbarpagedown:  descriptor --
(#
do inner pageDown;
#)

-- GUIENVscrollbarPageUp: descriptor --
(# 
do inner pageUp;
#)

-- GUIENVscrollbarButtonUp: descriptor --
(# 
do inner buttonUp;
#)

-- GUIENVthumbMoved: descriptor --
(#
do inner thumbMoved; 
#)

-- scrollbarLib: attributes --
actionProc: external
	(# controlHandle: @integer;
		partCode: @shortInt;
		currentValue,currentMax,newValue: @integer;
	enter (controlHandle,partCode)
	do pascalExternalEntry;
		value -> currentValue;
		maxValue -> currentMax;
		(if partCode
			//inUpButton then
				(currentValue - private.scrollbarScrollamount,0) -> max -> newValue;
				newValue -> value;
				theEventHandler.onButtonUp;
			//inDownButton then
				(currentValue + private.scrollbarScrollamount,currentMax) -> min -> newValue;
				newValue -> value;
				theEventHandler.onButtonDown;
			//inPageUp then
				(currentValue - private.scrollbarPageScrollAmount,0) -> max -> newValue;
				newValue -> value;
				theEventHandler.onPageUp;
			//inPageDown then
				(currentValue + private.scrollbarPageScrollAmount,currentMax) -> min -> newValue;
				newValue -> value;
				theEventHandler.onPageDown;
		if);
	#);
setScrollbarActionProc:
	(#	theActionProc: ##actionProc;
		toFuncPtr: external
			(# func: ##actionProc;
				ptr: @integer;
			enter func##
			do 'copyinput' -> callC;
			exit ptr
			#);
	enter theActionProc##
	do theActionProc## -> toFuncPtr -> this(control).private.controlActionProc;
	#);

-- GUIENVscrollbarPrivate: descriptor --
(# scrollbarOrientation: @integer;
	scrollbarScrollamount: @integer;
	scrollbarPageScrollamount: @integer;
	scrollbarActive: @boolean;
#)


	
-- GUIENVButtonOnFrameChanged: descriptor --
(# thisOptionButton: ^optionButton;
do (if this(button).struc <= optionButton## then
		this(button)[] -> thisOptionButton[];
		thisOptionButton.adjustOptionButtonBounds;
   else
   	adjustBounds;
	if);
   inner onFrameChanged;
#)

-- GUIENVButtonOnRefresh: descriptor --
(#
do 
	(if this(control).private.controlHandle <>0//true then
		private.buttonStyle[] -> useTextStyle;
		this(control).private.controlHandle  -> drawToolboxControl;
	if);
	inner onRefresh;
#)

-- GUIENVButtonOnMouseDown: descriptor --
(#	macPt: @macPoint;
	originalPart,returnPart,originalValue: @integer;
	thisScrollbar: ^scrollbar;
	p: @point;
do inner onMouseDown;
	(if this(control).private.controlHandle <>0//true then
		localPosition -> p;
		privateOrigin -> p.add;
		p -> macPt.setPoint;
		(this(control).private.controlHandle ,macPt) -> TestControl -> originalPart;
		focusZero
			(# 
			do 
				private.buttonStyle[] -> useTextStyle;
				(if this(control).struc <= optionButton## then
					this(guienv).private.whitePat -> BackPat;
				if);
				(this(control).private.controlHandle ,macPt,this(control).private.controlActionProc) -> TrackControl -> returnPart;
			#);
		(if returnPart//originalPart then
			theEventHandler.onMouseUp;
		if);
	if);
#)

-- GUIENVbuttonSetLabel: descriptor --
(#
do theLabel.copy -> private.buttonLabel[];
	(if this(control).private.controlHandle <>0//true then
		focusZero
			(#
			do (this(control).private.controlHandle ,theLabel) -> SetControlTitle;
			#);
	else
		updateMaybe;
	if);
	theEventHandler.onLabelChanged;
#)

-- GUIENVbuttonGetLabel: descriptor --
(#
do private.buttonLabel[] -> theLabel[];
	theLabel.copy -> theLabel[];
#)

-- GUIENVbuttonSetStyle: descriptor --
(#
do theStyle[] -> private.buttonStyle[];
	updateMaybe;
	theEventHandler.onStyleChanged;
#)

-- GUIENVbuttonGetStyle: descriptor --
(#
do private.buttonStyle[] -> theStyle[];
#)

-- GUIENVbuttonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVbuttonOpen: descriptor --
(#	style: ^textStyle;
do this(button)[] -> getPatternName -> private.buttonLabel[];
	&textStyle[] -> style[];
	(if this(window).style = plain then
		'Chicago' -> style.name;
		12 -> style.size;
	else
		'Geneva' -> style.name;
		9 -> style.size;
		textFaces.bold -> style.face;
	if);
	style[] -> private.buttonStyle[];
	inner open;
#)

-- GUIENVbuttonClose: descriptor --
(#
do inner close;
#)

	
-- GUIENVbuttonPrivate: descriptor --
(# buttonLabel: ^text;
	buttonStyle: ^textStyle;
#)

-- GUIENVpushButtonCreate: descriptor --
(#
do whiteBackGround -> backgroundStyle;
	inner create;
#)

-- GUIENVpushButtonOpen: descriptor --
(# mr: @macRect;
	t: ^text;
do ((0,0),size) -> mr;
	label -> t[];
	(if this(window).style <> shadows then
		(this(window).private.windowPointer,mr[],t,false,0,0,0,PushButProc + useWFont,0) 
			-> NewControl -> this(control).private.controlHandle;
	if);
	inner open;
#)

-- GUIENVpushButtonClose: descriptor --
(#
do inner close;
#)

-- pushButtonLib: attributes --


(* setHilite:
	(# value: @boolean;
	enter value
	do (if value <> private.hilited then
			value -> private.hilited;
			draw;
		if);
	#);
*)

draw:
	(# makeColor:
			(# maxValue: (# exit 65535 #);
				percent: @integer;
				value: @integer;
				theColor: ^color;
			enter	percent
			do (maxValue * percent) div 100 -> value;
				&color[] -> theColor[];
				(value, value, value) -> theColor;
			exit theColor[]
			#);
	do graphics
			(# black, lightColor, darkColor, mediumColor: ^color;
				width, height: @integer;
				tWidth: @integer;
				tHeight: @integer;
				theStyle: ^textStyle;
			do size -> (width, height);
				0 -> makeColor -> black[];
				100 -> makeColor -> lightColor[];
				50 -> makeColor -> darkColor[];
				80 -> makeColor -> mediumColor[];
				
				mediumColor -> pen.foreGroundColor;
				((2, 2), (width - 2, height - 2)) -> fillRect;
				
				black -> pen.foreGroundColor;
				this(button).style -> theStyle[] -> style;
				label -> theStyle.widthOfText -> tWidth; 
				theStyle.lineHeight -> tHeight;
				(if hilite then
					((width - tWidth) div 2,
					 (height - tHeight) div 2 + theStyle.ascent) -> moveTo;
				else
					((width - tWidth) div 2,
					 (height - tHeight) div 2 + theStyle.ascent) -> moveTo;
				if);
				label -> drawText;
				 
				((1, 0), (width - 2, 0)) -> drawLine;
				((width - 1, 1), (width - 1, height - 2)) -> drawLine;
				((width - 2, height - 1), (2, height - 1)) -> drawLine;
				((0, height - 2), (0, 1)) -> drawLine;
				
				(if hilite then
					darkColor -> pen.foreGroundColor;
				else
					lightColor -> pen.foreGroundColor;
				if);
				((1, height - 2), (1, 1)) -> drawLine;
				((2, 1), (width - 2, 1)) -> drawLine;
				
				(if hilite then
					lightColor -> pen.foreGroundColor;
				else
					darkColor -> pen.foreGroundColor;
				if);
				((width - 2, 2), (width - 2, height - 2)) -> drawLine;
				((width - 3, height - 2), (1, height - 2)) -> drawLine;
				
			#);
		#);

-- GUIENVpushButtonPrivate: descriptor --
(#
#)

-- GUIENVstaticTextOnRefresh: descriptor --
(#	mr: @macRect;
	t: ^text;
do ((0,0),size) -> mr;
	label -> t[];
	(if (t[] <> none) and (t.length <> 0) then
	graphics
		(#
		do 
			this(statictext).style -> style;
			this(guienv).private.background -> pen.backGroundColor;
			(@@t.T[1],t.lgth,mr[],0) -> TETextBox;
		#);
	if);
	inner onRefresh;
#)

-- GUIENVstaticTextCreate: descriptor --
(#
do inner create;
#)

-- GUIENVstaticTextOpen: descriptor --
(#
do inner open;
#)

-- GUIENVstaticTextClose: descriptor --
(#
do inner close;
#)

-- GUIENVstaticTextPrivate: descriptor --
(#
#)

-- GUIENViconButtonOnRefresh: descriptor --
(# calcImageBounds:
     (# 
     do (if showLabel//true then
            theLabel[] -> theStyle.widthOfText -> textWidth;
            theStyle.lineHeight -> textHeight;
         else
            0 -> textWidth;
            0 -> textHeight;
        if);
        (if private.iconButtonRaster[]<>none//true then
            private.iconButtonRaster.width -> iconWidth;
            private.iconButtonRaster.height -> iconHeight;
         else
            0 -> iconWidth;
            0 -> iconHeight;
        if);
        (textHeight+iconHeight) -> imageHeight;
        (textWidth,iconWidth) -> max -> imageWidth;
     #);
   calcImageAnchors:
     (# width,height: @integer;
     do size -> (width,height);
        (width - iconWidth) div 2 -> iconAnchor.h;
        (height - imageHeight) div 2 -> iconAnchor.v;
        (width - textWidth) div 2 -> textAnchor.h;
        iconAnchor.v + iconHeight + theStyle.ascent -> textAnchor.v;
     #);
   theStyle: ^textStyle;
   theLabel: ^text;
   imageWidth,imageHeight,textWidth,textHeight,iconWidth,iconHeight: @integer;
   iconAnchor,textAnchor: @point;
	
	DrawBitMapInPort: external
		(# bitmapHandle: @integer;
			port: @integer;
			from,to,width,height: @integer;
		enter (bitmapHandle,port,from,to,width,height)
		#);
do style -> theStyle[];
   label -> theLabel[];
   calcImageBounds;
   calcImageAnchors;
	focus
		(# f: @rectangle;
			from,to: @macPoint;
			wp: @integer;
		do PenNormal;
			blackColor -> ForeColor;
			(if private.iconButtonRaster[]<>none//true then
				(0,0) -> from.setPoint;
				iconAnchor -> to.setPoint;
				windowPointer -> wp;
				private.iconButtonRaster.lock;
				(private.iconButtonRaster.rasterAddress,wp,from,to,iconWidth,iconHeight) 
					-> DrawBitMapInPort;
				private.iconButtonRaster.unlock;
				(if hilite then
					((0,0),size) -> f;
					f.bottom - 1 -> f.bottom;
					f.right - 1 -> f.right;
					f[] -> makeMacRect -> FrameRect;
					(1,1) -> f.inset;
					f[] -> makeMacRect -> FrameRect;
				if);
			if);
			(if showLabel//true then
				(if (theLabel[] <> none) and (theLabel.length <> 0) then
				(textAnchor.h,textAnchor.v) -> MoveTo;
				theStyle[] -> useTextStyle;
				(@@theLabel.T[1],0,theLabel.lgth) -> DrawText;
			if);
			if);
		#);
   inner onRefresh;
#)

-- GUIENViconbuttonOnHiliteChanged: descriptor --
(#
do inner onHiliteChanged;
#)

-- GUIENViconButtonSetShowLabel: descriptor --
(#
do doShow -> private.iconButtonShowLabel;
	theEventHandler.onShowLabelChanged;
	updateMaybe;
#)

-- GUIENViconButtonGetShowLabel: descriptor --
(#
do private.iconButtonShowLabel -> doShow;
#)

-- GUIENViconButtonSetIcon: descriptor --
(#
do theIcon[] -> private.iconButtonRaster[];
	theEventHandler.onIconChanged;
	updateMaybe;
#)

-- GUIENViconButtonGetIcon: descriptor --
(#
do private.iconButtonRaster[] -> theIcon[];
#)

-- GUIENViconButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENViconButtonOpen: descriptor --
(#	
do true -> private.iconButtonShowLabel;
	inner open;
#)

-- GUIENViconButtonClose: descriptor --
(#
do inner close;
#)


-- GUIENViconButtonPrivate: descriptor --
(# iconButtonShowLabel: @boolean;
	iconButtonRaster: ^raster;
#)

-- optionButtonLib: attributes --

maxStringLength: integerValue
	(# style: @textStyle;
		theMenu: ^menu;
	do 'Chicago' -> style.name;
		12 -> style.size;
		popupMenu -> theMenu[];
		(if theMenu[] = none then
			'Nothing' -> style.widthOfText -> value;
		else
			theMenu.scan
				(# w: @integer;
				do	current.name -> style.widthOfText -> w;
					(value, w) -> Max -> value;
				#);
			
		if);
	#);
labelWidth: integerValue
	(# s: ^textStyle;
	do	style -> s[];
		label -> s.widthOfText -> value;
	#);
	
adjustOptionButtonBounds:
	(# h,v,width,height: @integer;
		theHandle: @integer;
	do theControlHandle -> theHandle;
		(if theHandle<>0 then
			privateOrigin -> (h, v);
			h + labelWidth + 5 -> h;
			maxStringLength + 41 -> width;
			19 -> height;
			
			(theHandle,h,v,width,height) -> updateToolboxControl;
		if);
	#);

optionButtonMethods: methods
	(#	hit::< defaultHitMethod;
		calculateFocus::< defaultCalculateFocus
			(#
			do adjustOptionButtonBounds;
				inner;
			#);
		handleCursor::< defaultHandleCursorMethod;
	#);
	
-- GUIENVoptionButtonSetCurItem: descriptor --
(#
do	focusZero
		(#
		do (this(control).private.controlHandle ,itemNo) -> SetControlValue;
		#);
	theEventHandler.onCurrentItemChanged;
#)

-- GUIENVoptionButtonGetCurItem: descriptor --
(#
do this(control).private.controlHandle  -> GetControlValue -> itemNo;
#)
-- GUIENVoptionButtonSetPopupMenu: descriptor --
(# SetMenubuttonMenu: external
		(#	control,menuHandle: @integer;
			menuID: @shortInt;
		enter (control,menuHandle,menuID)
		#);
do	popupMenu[] -> private.menuButtonPopupMenu[];
	focusZero
		(#
		do hidePen;
			this(control).private.controlHandle  -> HideControl;
			showPen;
			(this(control).private.controlHandle ,popupMenu.handle,popupMenu.menuID) -> SetMenubuttonMenu;
		#);
	adjustOptionButtonBounds;
	updateMaybe;
	theEventHandler.onPopUpMenuChanged;
#)
-- GUIENVoptionButtonGetPopupMenu: descriptor --
(#
do private.menuButtonPopupMenu[] -> popupMenu[];
#)


-- GUIENVoptionButtonCreate: descriptor --

(#
do	grayBackground -> backgroundStyle;
	inner create;
#)


-- GUIENVoptionButtonOpen: descriptor --
(# nothingMenuID: (# exit 129 #);
	bounds: @macRect;
	t: ^text;
do true -> debugMe;
	((0,0),(200,30)) -> bounds;
	label -> t[];
	(this(window).private.windowPointer,bounds[],t,false,0,nothingMenuID,0,popupMenuProc ,0) 
		-> NewControl -> this(control).private.controlHandle ;
	-1 -> this(control).private.controlActionProc;
	&optionButtonMethods[] -> windowitemMethods;
	inner open;
#)

-- GUIENVoptionButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVoptionButtononstylechanged: descriptor --
(#
do inner onStyleChanged;
#)

-- GUIENVoptionButtononlabelchanged: descriptor --
(#
do adjustOptionButtonBounds;
	inner onLabelChanged;
#)

-- GUIENVoptionButtonOnRefresh: doPart --
do 
	(#	mr: @macRect;
		t: ^text;
	do ((0,4),(labelWidth + 4, 16)) -> mr;
		label -> t[];
		(if t.length > 0 then
			graphics
				(#
				do 
					this(optionButton).style -> style;
					this(guienv).private.background -> pen.backGroundColor;
					(@@t.T[1],t.lgth,mr[],0) -> TETextBox;
				#);
		if);
		inner onRefresh;
	#)

-- GUIENVoptionButtonprivate: descriptor --
(# menuButtonPopupMenu: ^menu;
#)

-- GUIENVtoggleButtonSetState: descriptor --
(#
do	theState -> private.toggleButtonState;
	(if this(control).private.controlHandle <>0//true then
		focusZero
			(#
			do (this(control).private.controlHandle ,theState) -> SetControlValue;
			#);
	if);
	theEventHandler.onStateChanged;
#)

-- GUIENVtoggleButtonGetState: descriptor --
(#
do private.toggleButtonState -> theState;
#)

-- GUIENVtoggleButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVtoggleButtonOpen: descriptor --
(#	
do false -> private.toggleButtonState;
	inner open;
#)

-- GUIENVtoggleButtonClose: descriptor --
(#
do inner close;
#)


-- GUIENVtoggleButtonPrivate: descriptor --
(# toggleButtonState: @boolean;
#)

-- GUIENVradioButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVRadioButtonOpen: descriptor --
(#	r: @rectangle;
	mr: ^macRect;
	t: ^text;
do	((0,0),size) -> r;
	r[] -> makeMacRect -> mr[];
	label -> t[];
	(this(window).private.windowPointer,mr[],t,false,0,0,1,radioButProc + useWFont,0) 
		-> NewControl -> this(control).private.controlHandle ;
	inner open;
#)

-- GUIENVRadioButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVradioButtonPrivate: descriptor --
(#
#)

-- GUIENVcheckBoxCreate: descriptor --
(#
do inner create;
#)

-- GUIENVcheckBoxOpen: descriptor --
(#	r: @rectangle;
	mr: ^macRect;
	t: ^text;
do	((0,0),size) -> r;
	r[] -> makeMacRect -> mr[];
	label -> t[];
	(this(window).private.windowPointer,mr[],t,false,0,0,1,checkBoxProc + useWFont,0) 
		-> NewControl -> this(control).private.controlHandle ;
	inner open;
#)

-- GUIENVcheckBoxClose: descriptor --
(#
do inner close;
#)

-- GUIENVcheckBoxPrivate: descriptor --
(#
#)

-- GUIENVeditTextSetStyle: descriptor --
(#
do txStyle[] -> private.editTextStyle[];
	txStyle[] -> updateStyle;
#)

-- GUIENVeditTextGetStyle: descriptor --
(#
do private.editTextStyle[] -> txStyle[];
#)

-- GUIENVeditTextSetContents: descriptor --
(#
do (if (str[] <> none) and (str.length <> 0) then
		(@@str.T[1],str.lgth,private.editTextHandle) -> TESetText;
	else
		(0, 0 ,private.editTextHandle) -> TESetText;
	if);
	updateMaybe;
#)

-- GUIENVeditTextGetContents: descriptor --
(# length: @integer;
	textHandle: @integer;
	TextEditGetLength: external
		(#	teHandle: @integer;
			length: @integer;
		enter teHandle
		exit length
		#);
	CopyText: external
		(#	h: @integer;
			buffer: @integer;
			count: @integer;
		enter (h,buffer,count)
		#);
do private.editTextHandle -> TextEditGetLength -> length;
	&text[] -> str[];
	(if length > 0 then
	length - str.T.range -> str.extend;
	private.editTextHandle -> TEGetText -> textHandle;
	(textHandle,@@str.T[1],length) -> CopyText;
	length -> str.lgth -> str.pos;
	if);
#)

-- GUIENVeditTextonFrameChanged: descriptor --
(#	viewRect,destRect: ^macRect;
	UpdateTextEditRecord: external
		(#	teHandle: @integer;
			view,dest: ^macRect;
		enter (teHandle,view[],dest[])
		#);
	style: ^textStyle;
	width,height: @integer;
do private.editTextStyle[] -> style[];
	size -> (width,height);
	((style.lineHeight * 2) > (height - 6)) -> private.editTextSingleLine;
	calcViewRect -> makeMacRect -> viewRect[];
	calcDestRect -> makeMacRect -> destRect[];
	(private.editTextHandle,viewRect[],destRect[]) -> UpdateTextEditRecord;
	private.editTextHandle -> TECalText;
	inner onFrameChanged;
#)

-- GUIENVeditTextonKeyDown: descriptor --
(#
do focusZero
		(#	insertChar: @boolean;
		do ResetPen;
			true -> insertChar;
			(if ch
				//13 then
					(if private.editTextSingleLine//true then
						false -> insertChar
					if);
				//3 then false -> insertChar;
			if);
			(if insertChar//true then
				(ch,private.editTextHandle) -> TEKey;
			if);
		#);
	inner onKeyDown;
#)

-- GUIENVeditTextonMouseDown: descriptor --
(#
do this(editText)[] -> target;
	focusZero
		(#	p: @point;
			macPt: @macPoint;
		do ResetPen;
			localPosition -> p;
			privateOrigin -> p.add;
			p -> macPt.setPoint;
			(macPt,false,private.editTextHandle) -> TEClick;
		#);
	inner onMouseDown;
#)

-- GUIENVeditTextonRefresh: descriptor --
(#
do focusZero
		(#	viewRect: ^macRect;
		do	ResetPen;
			calcViewRect -> makeMacRect -> viewRect[];
			(viewRect[],private.editTextHandle) -> TEUpdate;
		#);
	inner onRefresh;
#)

-- GUIENVeditTextonEnableTarget: descriptor --
(#
do focusZero
		(#
		do ResetPen;
			private.editTextHandle -> TEActivate
		#);
	private.installTimer;
	inner onEnableTarget;
#)

-- GUIENVeditTextonDisableTarget: descriptor --
(#
do focusZero
		(#
		do 
			ResetPen;
			(if private.editTextHandle <> 0 then
				private.editTextHandle -> TEDeactivate;
			if);
		#);
	private.deleteTimer;
	inner onDisableTarget;
#)

-- GUIENVeditTextCreate: descriptor --
(#
do whiteBackGround -> backGroundStyle;
	inner create;
#)

-- GUIENVeditTextOpen: descriptor --
(#	style: ^textStyle;
	viewRect,destRect: ^macRect;
do	&textStyle[] -> style[];
	(if this(window).style = plain then
		'Chicago' -> style.name;
		12 -> style.size;
	else
		'Geneva' -> style.name;
		9 -> style.size;
	if);
	style[] -> private.editTextStyle[];
	((0,0),(100,6 + style.lineHeight + style.leading)) -> privateWindowItemFrame;
	father.calculateFocusForChildren;
	true -> private.editTextSingleLine;
	calcViewRect -> makeMacRect -> viewRect[];
	calcDestRect -> makeMacRect -> destRect[];
	focusZero
		(#
		do private.editTextStyle[] -> useTextStyle;
			(destRect[],viewRect[]) -> TENew -> private.editTextHandle;
			(true,private.editTextHandle) -> TEAutoView;
		#);
	cursors.iBeam[] -> theCursor;
	(if this(window).style = plain then
		borderStyles.simple -> border.style;
	else
		borderStyles.shadowIn -> border.style;
	if);
	true -> border.visible;
	cursors.iBeam[] -> theCursor;
	inner open;
#)

-- GUIENVeditTextClose: descriptor --
(#
do inner close;
	private.editTextHandle -> TEDispose;
	0 -> private.editTextHandle;
#)

-- editTextLib: attributes --

calcViewRect:
	(#	r: ^rectangle;
		minInt: (# exit -32767 #);
	do	&rectangle[] -> r[];
		(if textVisible//true then
			((0,0),size) -> r;
			privateOrigin -> r.offset;
			(3,3) -> r.inset;
		else
			((minInt,minInt),(minInt + 1,minInt + 1)) -> r; 
		if);
	exit r[]
	#);
calcDestRect:
	(#	style: ^textStyle;
		width,height,lineHeight: @integer;
		singleLine: @boolean;
		h,v: @integer;
		r: ^rectangle;
		minInt: (# exit -32767 #);
	do	&rectangle[] -> r[];
		private.editTextStyle[] -> style[];
		(if textVisible//true then
			size -> (width,height);
			privateOrigin -> (h,v);
			(h+3,v+3) -> r.topLeft;
			(if private.editTextSingleLine//true then
				r.left + 1000 -> r.right;
				r.top + style.lineHeight + style.leading -> r.bottom;
			else
				r.left + (width - 6) -> r.right;
				r.top + (height - 6) -> r.bottom;
			if);
		else
			((minInt,minInt),(minInt + style.maxChWidth,minInt + 1)) -> r;
		if);
	exit r[]
	#);
updateStyle:
	(# style: ^textStyle;
	enter style[]
	do
	#);
textVisible: booleanValue
	(# width,height: @integer;
		style: ^textStyle;
	do private.editTextStyle[] -> style[];
		size -> (width,height);
		((width > (6 + style.maxChWidth)) and (height > 6)) -> value;
	#);

-- GUIENVeditTextPrivate: descriptor --
(#	editTextStyle: ^textStyle;
	editTextHandle: @integer;
	editTextSingleLine: @boolean;
	
	installTimer:
		(#
		do theTimer[] -> this(GUIenv).private.timerQueue.insert;
		#);
	deleteTimer:
		(#
		do theTimer[] -> this(GUIenv).private.timerQueue.delete;
		#);
	theTimer: @timerAction
		(# doIt:@ focusZero
				(#
				do editTextHandle -> TEIdle;
				#);
		do (if editTextHandle <> 0 then
				doIt;
			if);
		#);
#)

-- GUIENVsetDefaultButton: descriptor --
(#
do	theButton[] -> windowDefaultButton;
#)

-- GUIENVgetDefaultButton: descriptor --
(#
do windowDefaultButton -> theButton[];
#)
-- GUIENVcontrolputLayout: doPart --
do

-- GUIENVcontrolgetLayout: doPart --
do

-- GUIENVscrollbarputLayout: doPart --
do

-- GUIENVscrollbargetLayout: doPart --
do

-- GUIENVbuttonputLayout: doPart --
do

-- GUIENVbuttongetLayout: doPart --
do

-- GUIENVpushButtonputLayout: doPart --
do

-- GUIENVpushButtongetLayout: doPart --
do

-- GUIENVstaticTextputLayout: doPart --
do

-- GUIENVstaticTextgetLayout: doPart --
do

-- GUIENViconButtonputLayout: doPart --
do

-- GUIENViconButtongetLayout: doPart --
do

-- GUIENVoptionButtonputLayout: doPart --
do
   
-- GUIENVoptionButtongetLayout: doPart --
do

-- GUIENVtoggleButtonputLayout: doPart --
do

-- GUIENVtoggleButtongetLayout: doPart --
do

-- GUIENVradioButtonputLayout: doPart --
do

-- GUIENVradioButtongetLayout: doPart --
do

-- GUIENVcheckBoxputLayout: doPart --
do

-- GUIENVcheckBoxgetLayout: doPart --
do

-- GUIENVeditTextputLayout: doPart --
do

-- GUIENVeditTextgetLayout: doPart --
do

-- GUIENVcontrolOnEnabledChanged: doPart --
do (if private.controlHandle <> 0 then
		focusZero
			(#
			do
				(if enabled then
					(private.controlHandle, 0) -> HiliteControl;
				else
					(private.controlHandle, 255) -> HiliteControl
				if);
			#);
	if);
	inner;

-- GUIENVtoggleButtonOnMouseUp: doPart --
do not state -> state;
	inner;
	
-- GUIENVpushButtonOnMouseDown: doPart --
do inner;
	(if this(control).private.controlHandle = 0 then
		trackMouse
			(# r: @rectangle;
				inside: @
					(# p: @point;
						value: @boolean;
					enter p
					do p -> r.containsPoint -> value;
					exit value
					#);
				mousePress::
					(#
					do ((0, 0), size) -> r;
						true -> hilite;
					#);
				mouseMove::
					(#
					do curPt -> inside -> hilite;
					#);
				mouseRelease::
					(#
					do false -> hilite;
						(if curPt -> inside then
							onMouseUp;
						if);
					#);
			#);
	if);
	

-- GUIENVpushButtonOnRefresh: doPart --
do (if this(control).private.controlHandle = 0 then
		draw;
	if);
	inner;
-- GUIENVpushButtonHiliteChanged: doPart --
do draw;
