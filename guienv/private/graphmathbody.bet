ORIGIN '../graphmath';
MDBODY  
mac 'macintosh/graphmath_macbody'
nti 'winnt/graphmath_ntibody'
default 'X11/graphmath_unixbody'
[[
-- Include '~beta/basiclib/v1.4/math'
-- lib: attributes --
twopi: (# exit (2*pi) #);

-- GUIENVpointAdd: descriptor ---
(# 
do p.h + h -> h;
   p.v + v -> v;
#)
-- GUIENVpointSubtract: descriptor ---
(# 
do h - p.h -> h;
   v - p.v -> v;
#)
-- GUIENVpointIsEqual: descriptor ---
(# 
do ((p.h = h) and (p.v = v)) -> value;
#)

-- GUIENVrectangleSet: descriptor ---
(# 
do (left,top) -> topLeft;
   (right,bottom) -> bottomRight;
#)

-- GUIENVrectangleSetFromPts: descriptor ---
(# 
do (p1.h,p2.h) -> min -> left;
   (p1.h,p2.h) -> max -> right;
   (p1.v,p2.v) -> min -> top;
   (p1.v,p2.v) -> max -> bottom;
#)

-- GUIENVrectSetSize: descriptor ---
(# 
do left + w -> right;
   top + h -> bottom;
#)
-- GUIENVrectangleGetSize: descriptor ---
(# 
do right - left -> w;
   bottom - top -> h;
#)
-- GUIENVrectangleOffset: descriptor ---
(# 
do delta.h + left -> left;
   delta.h + right -> right;
   delta.v + top -> top;
   delta.v + bottom -> bottom;
#)
-- GUIENVrectangleInSet: descriptor ---
(# width,height: @integer;
do size -> (width,height);
   (delta.h,width div 2) -> min -> delta.h;
   (delta.v,height div 2) -> min -> delta.v;
   delta.h + left -> left;
   delta.v + top -> top;
   right - delta.h -> right;
   bottom - delta.v -> bottom;
#)
-- GUIENVrectangleIntersection: descriptor ---
(# 
do (src1.top,src2.top) -> max -> top;
   (src1.left,src2.left) -> max -> left;
   (src1.bottom,src2.bottom) -> min -> bottom;
   (src1.right,src2.right) -> min -> right;
   (if (bottom <= top) or (right <= left) then
       (0,0,0,0) -> set;
       false -> value;
    else
       true -> value;
   if)
#)
-- GUIENVrectangleUnion: descriptor ---
(# 
do (src1.top,src2.top) -> min -> top;
   (src1.left,src2.left) -> min -> left;
   (src1.bottom,src2.bottom) -> max -> bottom;
   (src1.right,src2.right) -> max -> right;
#)
-- GUIENVrectangleContainsPoint: descriptor ---
(# 
do (p.v >= top) and (p.v < bottom) and (p.h >= left) and (p.h < right) -> value;
#)
-- GUIENVrectanglePToAngle: descriptor ---
(# 
do 'rectangle.ptoangle is not implemented' -> putLine;
#)
-- GUIENVrectangleIsEqual: descriptor ---
(# 
do (theRectangle.top = top) and (theRectangle.right = right) 
   and 
   (theRectangle.left = left) and (theRectangle.bottom = bottom) -> value
#)
-- GUIENVrectangleIsEmpty: descriptor ---
(# 
do (bottom <= top) or (right <= left) -> value;
#)
-- GUIENVmultiplyMatrixBody: descriptor ---
(#   (* res = A*B *)
do 
   (if A[]=IDMatrix then B[] -> res[]
    else
       (if B[]=IDMatrix then A[] -> res[]
        else
           &Matrix[] -> res[];
           
           (* 
            * 	(if NONE
            * 	 // A[] then 'MatrixMul: A is NONE'->putline;
            * 	 // B[] then 'MatrixMul: B is NONE'->putline;
            * 	if);
            *) 
            
           A.a*B.a + A.b*B.c -> res.a;
	   A.c*B.a + A.d*B.c -> res.c;
	   A.tx*B.a + A.ty*B.c + B.tx -> res.tx;
	   A.a*B.b + A.b*B.d -> res.b;
	   A.c*B.b + A.d*B.d -> res.d;
	   A.tx*B.b + A.ty*B.d + B.ty -> res.ty;
       if)
   if);
#)
-- GUIENVtransformPointMatrixBody: descriptor ---
(# 
do (if THIS(Matrix)[]=IDMatrix then p -> result
    else
       a*p.h + c*p.v + tx -> result.h;
       b*p.h + d*p.v + ty -> result.v;
   if);
#)
-- GUIENVinverseTransformPointMatrixBody: descriptor ---
(# 
do GetInverse;
   p1 -> inverse.transformPoint -> p2;
#)
-- GUIENVtransformRectangleMatrixBody: descriptor ---
(#
#)
-- GUIENVinverseTransformRectangleMatrixBody: descriptor ---
(# 
do GetInverse;
   r -> inverse.transformRectangle -> result;
#)
-- GUIENVcalcInverseMatrixBody: descriptor ---
(#  det: @Real;
do 
   (if inverse[] = NONE then 
       (if THIS(Matrix)[]=IDMatrix then IDMatrix -> inverse[]
        else
           &Matrix[] -> inverse[];
           a*d - b*c -> det;
           (if det<>0.0 then
               d div det -> inverse.a;
               -b div det -> inverse.b;
               -c div det -> inverse.c;
               a div det -> inverse.d;
               (c*ty - d*tx) div det -> inverse.tx;
               (b*tx - a*ty) div det -> inverse.ty;
           if);
       if);
   if);
#)
-- GUIENVIDmatrixBody: descriptor ---
(# 
do 
#)
-- GUIENVmoveMatrixBody: descriptor ---
(# 
do itx -> tx;
   ity -> ty;
   1.0  -> a;
   1.0  -> d;
   0.0 -> b;
   0.0 -> c;
#)
-- GUIENVscaleMatrixBody: descriptor ---
(# 
do 0.0 -> b;
   0.0 -> c;
   0.0 -> tx;
   0.0 -> ty;
#)
-- GUIENVrotateMatrixBody: descriptor ---
(# 
do theta -> cos ->  a;
   theta -> sin ->  b;
   -(theta -> sin) -> c;
   theta -> cos -> d;
   0.0 -> tx;
   0.0 -> ty;
#)
-- GUIENVovalAngle: descriptor ---
(#  hrr, vrr: @real    (* horizontalradius, verticalradius as reals *)
do
   hr -> hrr;
   vr -> vrr;
   (if x=cx then
       (if y>=cy then
           pihalf -> a;
           1.0 -> sin_a;
        else
           pi+pihalf -> a;
           -1.0 -> sin_a;
       if);
       0.0 -> cos_a;
    else	      
       ((y-cy) div vrr) div ((x-cx) div hrr)-> atan -> a;
       (if true
        // x<cx then
           pi+a -> a;
        // x>cx then
           (if y<cy then
               twopi+a -> a;
           if);
       if);
       a -> cos -> cos_a;
       a -> sin -> sin_a;
   if);
#)
-- GUIENVcircleAngle: descriptor ---
(#  rx, ry: @real;
do
   (* No need to scale by r in both dimensions *)
   
   (if x=cx then
       (if y>=cy then
           pihalf -> a;
           1.0 -> sin_a;
        else
           pi+pihalf -> a;
           -1.0 -> sin_a;
       if);
       0.0 -> cos_a;
    else	      
       (y-cy) -> ry;
       (x-cx) -> rx;
       (ry div rx) -> atan -> a;
       (if true
        // x<cx then
           pi+a -> a;
        // x>cx then
           (if y<cy then
               twopi+a -> a;
           if);
       if);
       a -> cos -> cos_a;
       a -> sin -> sin_a;
   if);
#)

--]]
