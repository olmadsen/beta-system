ORIGIN '../graphicscanvas';

MDBODY nti 'winnt/graphicscanvas_nti'
       ppcmac 'macintosh/graphicscanvas_mac'
       default 'X11/graphicscanvas_X11';

-- GUIenvLib: attributes --

getShared: objectPool.get
  (# type:: PixmapSurface;
     
     init::
       (# screen: @Rectangle;
          image: ^Pixmap;
       do &Pixmap[] -> image[];
          screenRectangle -> screen;
          screen.size -> image.init;
          image[] -> obj.init;
       #);
  #);


   
   
-- LayerAdd: doPart --
do child[] -> children.append;

-- LayerRemove: doPart --
do child[] -> children.at -> children.delete;

-- LayerDrawOn: doPart --
do children.scan
   (#
   do theSurface[] -> current.drawOn;
   #);
   

-- GraphicsCanvasAdd: doPart --
do child[] -> children.append;

-- GraphicsCanvasRemove: doPart --
do child[] -> children.at -> children.delete;

-- ItemDrawOn: doPart --
do theSurface.push;
   (x, y) -> theSurface.translate;
   INNER;
   theSurface.pop;
   
-- LineDrawOn: doPart --
do (if stroke[] <> NONE then
       stroke[] -> theSurface.pen;
   if);
   strokewidth -> theSurface.width;
   (start[], end[]) -> theSurface.drawLine;
   
-- LineContainsPoint: doPart --
do (if start.x < end.x then
       start.x -> left;
       end.x -> right;
    else
       start.x -> right;
       end.x  -> left;
   if);
   (if start.y < end.y then
       start.y -> top;
       end.y -> bottom;
    else
       start.y -> bottom;
       end.y  -> top;
   if);
   strokewidth / 2 -> halfStrokeWidth;
   left - halfStrokeWidth -> left;
   right + halfStrokeWidth -> right;
   top - halfStrokeWidth -> top;
   bottom + halfStrokeWidth -> bottom;
   (if (x >= left) AND (x <= right) AND (y >= top) AND (y <= bottom) then
       end.x - start.x -> b;
       -(end.y - start.y) -> a;
       -a * start.x - b*start.y -> c;
       a*a + b*b -> sqrt -> d;
       (if d > 0.0001 then
           (a*x + b*y + c) / d -> abs -> dist;
           (if dist < (halfStrokeWidth + 3) then
               THIS(Line)[] -> target[];
           if);
       if);
   if);

-- RectDrawOn: doPart --
do (if fill[] <> NONE then
      fill[] -> theSurface.pen;
      (width, height) -> theSurface.fillRect;
   if);
   (if stroke[] <> NONE then
      stroke[] -> theSurface.pen;
      (width, height) -> theSurface.drawRect;
   if);
   
-- OvalDrawOn: doPart --
do strokewidth -> theSurface.width;
    (if stroke[] <> NONE then
       stroke[] -> theSurface.pen;
       (width, height) -> theSurface.drawOval;
   if);
   (if fill[] <> NONE then
      fill[] -> theSurface.pen;
      (width, height) -> theSurface.fillOval;
   if);
  

-- PolygonDrawOn: doPart --
do (if fill[] <> NONE then
      fill[] -> theSurface.pen;
      points[] -> theSurface.fillPolygon;
   if);
   (if stroke[] <> NONE then
      stroke[] -> theSurface.pen;
      points[] -> theSurface.drawPolygon;
   if);
   

-- TextItemDrawOn: doPart --
do style[] -> theSurface.style;
   (if stroke[] <> NONE then
       stroke[] -> theSurface.pen;
       angle -> theSurface.angle;
       (if content[] <> NONE then
           content[] -> theSurface.drawText;
       if);
   if);
   
-- PixmapItemDrawOn: doPart --
do 
   (if content[] <> NONE then
       content[] -> theSurface.drawPixmap;
   if);

-- CompositeAdd: doPart --
do (if child.father[] = NONE then
       child[] -> children.append;
       THIS(Composite)[] -> child.father[];
   if);

-- CompoisteRemove: doPart --
do (if child.father[] = THIS(Composite)[] then
       child[] -> children.at -> children.delete;
       NONE -> child.father[];
   if);
   
-- CompositeClear: doPart --
do children.scan
   (#
   do NONE -> current.father[];
   #);
   children.clear;
   
-- CompositeDrawOn: doPart --
do children.scan
     (#
     do theSurface[] -> current.drawOn;
     #);

-- GraphicsCanvasOnMouseDown: doPart --
do (# tempx, tempy: @integer;
   do localPosition -> select -> current[];
      (if current[] <> NONE then
          localPosition -> (tempx,tempy);
          tempx - panx -> tempx;
          tempy - pany -> tempy;
          ((tempx,tempy), globalPosition, buttonState, doubleClick, shiftKey, controlKey, when) 
            -> current.onMouseDown;
       else
          INNER onMouseDown;
      if);
   #);
   
-- GraphicsCanvasOnMouseUp: doPart --
do (# tempx, tempy: @integer;
   do (if current[] <> NONE then
          localPosition -> (tempx,tempy);
          tempx - panx -> tempx;
          tempy - pany -> tempy;
          ((tempx,tempy), globalPosition, buttonState, doubleClick, shiftKey, controlKey, when) 
            -> current.onMouseUp;
          NONE -> current[];
       else
          INNER onMouseUp;
      if);
   #)
   
-- GraphicsCanvasOnMouseMove: doPart --
do (# tempx, tempy: @integer;
   do flush;
      (if current[] <> NONE then
          localPosition -> (tempx,tempy);
          tempx - panx -> tempx;
          tempy - pany -> tempy;
          ((tempx,tempy), globalPosition, buttonState, doubleClick, shiftKey, controlKey, when) 
            -> current.onMouseMove;
      if);
      INNER onMouseMove;
   #);
   
   
-- GraphicsCanvasAddLayer: doPart --
do theLayer[] -> layers.append;
   
-- GraphicsCanvasRemoveLayer: doPart --
do theLayer[] -> layers.at -> layers.delete;
   
-- ItemChanged: doPart --
do (*'ItemChanged. THIS(Item) = ' -> screen.puttext; THIS(Item)[] -> getPatternName -> screen.putline;*)
   (if THIS(Item)## <= Composite## then
    else
       (# curve: ^PointList;
          bounds: ^Rectangle;
       do outline -> curve[];
          &Rectangle[] -> bounds[];
          
          10000-> bounds.left;
          -10000 -> bounds.right;
          10000 -> bounds.top;
          -10000  -> bounds.bottom;
          
          curve.scan
          (#
          do (if current.x < bounds.left then
                 current.x -> bounds.left;
             if);
             (if current.x > bounds.right then
                 current.x -> bounds.right;
             if);
             (if current.y < bounds.top then
                 current.y -> bounds.top;
             if);
             (if current.y > bounds.bottom then
                 current.y -> bounds.bottom;
             if);
          #);
          (if false then
              THIS(Item)[] -> getPatternName -> puttext;
              '.changed: [' -> puttext;
              bounds.left -> putint;
              ' ' -> put;
              bounds.top -> putint;
              ' ' -> put;
              bounds.right -> putint;
              ' ' -> put;
              bounds.bottom -> putint;
              ']' -> puttext;
              ' (' -> puttext;
              x -> putint;
              ' ' -> put;
              y -> putint;
              ')' -> putline;
          if);
          (if father[] <> NONE then
              bounds[] -> father.updateRect;
           else
              bounds[] -> THIS(GraphicsCanvas).updateRect;
          if);
       #);
   if);
-- ItemUpdateRect: doPart --
do (if false then
       THIS(Item)[] -> getPatternName -> puttext;
       '.updateRect: [' -> puttext;
       area.left -> putint;
       ' ' -> put;
       area.top -> putint;
       ' ' -> put;
       area.right -> putint;
       ' ' -> put;
       area.bottom -> putint;
       ']' -> puttext;
       ' (' -> puttext;
       x -> putint;
       ' ' -> put;
       y -> putint;
       ')' -> putline;
   if);
   area.left + x -> area.left;
   area.right + x -> area.right;
   area.top + y -> area.top;
   area.bottom + y -> area.bottom;
   (if father[] <> NONE then
       area[] -> father.updateRect;
    else
       area[] -> THIS(GraphicsCanvas).updateRect;
   if);
   
-- GraphicsCanvasUpdateRect: doPart --
do (# width, height: @integer;
   do size -> (width, height);
      area.left + panx -> area.left;
      area.right + panx -> area.right;
      area.top + pany -> area.top;
      area.bottom + pany -> area.bottom;
      
      (if changedFlag then
          (if area.left < updateRgn.left then
              (if area.left > 0 then
                  area.left -> updateRgn.left;
               else
                  0 -> updateRgn.left;
              if);
          if);
          
          (if area.right > updateRgn.right then
              (if area.right < width then
                  area.right -> updateRgn.right;
               else
                  width -> updateRgn.right;
              if);
          if);
          
          (if area.top < updateRgn.top then
              (if area.top > 0 then
                  area.top -> updateRgn.top;
               else
                  0 -> updateRgn.top;
              if);
          if);
          
          (if area.bottom > updateRgn.bottom then
              (if area.bottom < height then
                  area.bottom -> updateRgn.bottom;
               else
                  height -> updateRgn.bottom;
              if);
          if);
       else
          area.left -> updateRgn.left;
          area.top -> updateRgn.top;
          area.right -> updateRgn.right;
          area.bottom -> updateRgn.bottom;
          true -> changedFlag;
      if);
   #);
   
-- LineOutline: doPart --
do (# vx, vy: @real;
      x1, y1: @real;
      x2, y2: @real;
      length: @real;
      ux, uy: @real;
      
      xx, yy: @real;
      
      p: ^Point2d;
      delta: @real;
   do (strokewidth + 4 ) / 2 -> delta;
      start -> (x1, y1);
      end -> (x2, y2);
      x2 - x1 -> vx;
      y2 - y1 -> vy;
      vx*vx + vy*vy -> sqrt -> length;
      (if length > 0.0001 then
          
          vx / length -> xx;
          vy / length -> yy;
          
          x1 - xx*2 -> x1;
          y1 - yy*2 -> y1;
          
          x2 + xx*2 -> x2;
          y2 + yy*2 -> y2;
          
          
          (vx / length) * delta -> uy;
          - (vy / length) * delta -> ux;
          
          
          &Point2d[] -> p[];
          x1 - ux -> p.x;
          y1 - uy -> p.y;
          p[] -> points.append;
          &Point2d[] -> p[];
          x1 + ux -> p.x;
          y1 + uy -> p.y;
          p[] -> points.append;
          &Point2d[] -> p[];
          x2 + ux -> p.x;
          y2 + uy -> p.y;
          p[] -> points.append;
          &Point2d[] -> p[];
          x2 - ux -> p.x;
          y2 - uy -> p.y;
          p[] -> points.append;
          &Point2d[] -> p[];
          x1 - ux -> p.x;
          y1 - uy -> p.y;
          p[] -> points.append;
      if);
      
   #)
