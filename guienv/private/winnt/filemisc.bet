ORIGIN '~beta/win32lib/v1.6/ntitypes';

-- lib: attributes --
myCreateFile:
  (# dwDesiredAccess, dwFlagsAndAttributes: @integer;
     hFile: @integer; errorCode: @integer;
     
     fileName: @integer;
     fileAttribute: @integer;
  enter (fileName, fileAttribute)
  do GENERIC_READ + GENERIC_WRITE -> dwDesiredAccess;
     CREATE_ALWAYS -> dwFlagsAndAttributes;
     (fileName,                     (* filename  *)
     dwDesiredAccess,               (* open for reading and/or writing *)
     FILE_SHARE_READ,               (* share for read access *)
     0,                             (* no security *)
     dwFlagsAndAttributes,          (*  *)
     FILE_ATTRIBUTE_NORMAL,         (* normal file *)
     0)                             (* no attr. template *)
       -> CreateFile
       -> hFile;
  exit hFile
  #);

myOpenFile:
  (# dwDesiredAccess, dwFlagsAndAttributes: @integer;
     hFile: @integer; errorCode: @integer;
     
     fileName: @integer;
     fileAttribute: @integer;
  enter (fileName, fileAttribute)
  do GENERIC_READ + GENERIC_WRITE -> dwDesiredAccess;
     OPEN_EXISTING -> dwFlagsAndAttributes;
     (fileName,                     (* filename  *)
     dwDesiredAccess,               (* open for reading and/or writing *)
     FILE_SHARE_READ,               (* share for read access *)
     0,                             (* no security *)
     dwFlagsAndAttributes,          (*  *)
     FILE_ATTRIBUTE_NORMAL,         (* normal file *)
     0)                             (* no attr. template *)
       -> CreateFile
       -> hFile;
  exit hFile
  #);

WriteFile: external
  (# hFile: @integer;                   (* handle to file to write to *)
     lpBuffer: @integer;                (* pointer to data to write to file *)
     nNumberOfBytesToWrite: @integer;   (* number of bytes to write  *)
     lpNumberOfBytesWritten: @integer;  (* pointer to number of bytes written  *)
     lpOverlapped : @integer; (* pointer to structure needed for overlapped I/O *)
     res: @integer;
  enter (hFile,lpBuffer,nNumberOfBytesToWrite,lpNumberOfBytesWritten,lpOverlapped)
  do 'WriteFile' -> callStd;
  exit res
  #);

myWriteFile:
  (# hf: @integer;
     lpBuffer: @integer;
     nNumberOfBytesToWrite: @integer;
     lpNumberOfBytesWritten: @integer;  (* pointer to number of bytes written  *)
     res: @integer;
  enter (hf, lpBuffer, nNumberOfBytesToWrite)
  do 4 -> malloc -> lpNumberOfBytesWritten;
     (if (lpNumberOfBytesWritten<>0) then
         (hf, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, 0)
           -> WriteFile -> res;
         (if res<>0 then
             lpNumberOfBytesWritten -> TOS'%adrGetLong' -> res;
         if);
         lpNumberOfBytesWritten -> free;
     if);
  exit res
  #);

ReadFile: external
  (# hFile: @integer;	             (* handle of file to read *)
     lpBuffer: @integer;             (* address of buffer that receives data *)
     nNumberOfBytesToRead: @integer; (* number of bytes to read *)
     lpNumberOfBytesRead: @integer;  (* address of number of bytes read *)
     lpOverlapped: @integer;         (* address of structure for data *)
     result: @integer;
  enter (hFile,lpBuffer,nNumberOfBytesToRead,lpNumberOfBytesRead,lpOverlapped)
  do callStd;
  exit result
  #);

myReadFile:
  (# hFile: @integer;	             (* handle of file to read *)
     lpBuffer: @integer;             (* address of buffer that receives data *)
     nNumberOfBytesToRead: @integer; (* number of bytes to read *)
     lpNumberOfBytesRead: @integer;  (* address of number of bytes read *)
     res: @integer;
  enter (hFile,lpBuffer,nNumberOfBytesToRead)
  do 4 -> malloc -> lpNumberOfBytesRead;
     (if (lpNumberOfBytesRead<>0) then
         (hFile,lpBuffer,nNumberOfBytesToRead,lpNumberOfBytesRead,0)
           -> ReadFile -> res;
         (if res<>0 then
             lpNumberOfBytesRead -> TOS'%adrGetLong' -> res;
         if);
         lpNumberOfBytesRead -> free;
     if);
  exit res
  #);

CloseHandle: external
  (# hObject: @integer;
     result: @integer;
  enter hObject
  do callStd;
  exit result
  #);


ofnAlloc: External
  (# size: @integer;
     ptr: @integer;
  enter size
     do 'malloc' -> callC
  exit ptr
  #);
ofnFree: External
  (# ptr: @integer
  enter ptr
  do 'free' -> callC;
  #);
OPENFILENAME: ExternalRecord
  (# 
     lStructSize: @long (# pos::< (# do 0 -> value; #); #);  
     hwndOwner: @long (# pos::< (# do 4 -> value; #); #);  
     hInstance: @long (# pos::< (# do 8 -> value; #); #);  
     lpstrFilter: @long (# pos::< (# do 12 -> value; #); #);  
     lpstrCustomFilter: @long (# pos::< (# do 16 -> value; #); #);  
     nMaxCustFilter: @long (# pos::< (# do 20 -> value; #); #);  
     nFilterIndex: @long (# pos::< (# do 24 -> value; #); #);  
     lpstrFile: @long (# pos::< (# do 28 -> value; #); #);  
     nMaxFile: @long (# pos::< (# do 32 -> value; #); #);  
     lpstrFileTitle: @long (# pos::< (# do 36 -> value; #); #);  
     nMaxFileTitle: @long (# pos::< (# do 40 -> value; #); #);  
     lpstrInitialDir: @long (# pos::< (# do 44 -> value; #); #);  
     lpstrTitle: @long (# pos::< (# do 48 -> value; #); #);  
     Flags: @long (# pos::< (# do 52 -> value; #); #);  
     nFileOffset: @short (# pos::< (# do 56 -> value; #); #);  
     nFileExtension: @short (# pos::< (# do 58 -> value; #); #);  
     lpstrDefExt: @long (# pos::< (# do 60 -> value; #); #);  
     lCustData: @long (# pos::< (# do 64 -> value; #); #); 
     lpfnHook: @long (# pos::< (# do 68 -> value; #); #); 
     lpTemplateName: @long (# pos::< (# do 72 -> value; #); #);  
     
     bytesize: integerValue(# do 76 -> value; #);
     
     init:
       (# do bytesize -> ofnAlloc -> ptr; #);
     
     free:
       (# do (if ptr<>0 then ptr -> ofnFree; 0 -> ptr; if); #);
  #);

MAX_PATH: (# exit  260 #);
OFN_READONLY: (# exit   0x00000001 #);
OFN_OVERWRITEPROMPT: (# exit 0x00000002 #);
OFN_HIDEREADONLY: (# exit 0x00000004 #);
OFN_CREATEPROMPT: (# exit 0x00002000 #);
OFN_FILEMUSTEXIST: (# exit 0x00001000 #);

OF_READ: (# exit              0x00000000 #);
OF_READWRITE: (# exit         0x00000002 #);

FNERR_FILENAMECODES: (# exit     0x3000 #);
FNERR_SUBCLASSFAILURE: (# exit   0x3001 #);
FNERR_INVALIDFILENAME: (# exit   0x3002 #);
FNERR_BUFFERTOOSMALL: (# exit    0x3003 #);


(* BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR* ); *)
GetOpenFileName: external
  (# theOfn: @integer;
     result: @integer;
  enter theOfn
  do 'GetOpenFileNameA' -> callStd;
  exit result
  #);

(* BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR* ); *)
GetSaveFileName: external
  (# theOfn: @integer;
     result: @integer;
  enter theOfn
  do 'GetSaveFileNameA' -> callStd;
  exit result
  #);

(* int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT); *)
GetFileTitle: external
  (# lpszFile: @integer;
     lpszTitle: @integer;
     cbBuf: @integer;
     res: @integer;
  enter (lpszFile,lpszTitle,cbBuf)
  do 'GetFileTitleA' -> callStd;
  exit res
  #);

FILE_ATTRIBUTE_READONLY: (# exit 16x00000001 #);
FILE_ATTRIBUTE_NORMAL: (# exit 16x00000080 #);
FILE_SHARE_READ: (# exit 16x00000001 #);
FILE_SHARE_WRITE: (# exit 16x00000002 #);
CREATE_NEW: (# exit 1 #);
CREATE_ALWAYS: (# exit 2 #);
OPEN_EXISTING: (# exit 3 #);
OPEN_ALWAYS: (# exit 4 #);
TRUNCATE_EXISTING: (# exit 5 #);

GENERIC_READ: (# exit 16x80000000 #);
GENERIC_WRITE: (# exit 16x40000000 #);
GENERIC_EXECUTE: (# exit 16x20000000 #);
GENERIC_ALL: (# exit 16x10000000 #);

INVALID_HANDLE_VALUE: (# exit-1 #);

ERROR_SHARING_VIOLATION:       (# exit 32 #);
ERROR_LOCK_VIOLATION:          (# exit 33 #);
ERROR_WRONG_DISK:              (# exit 34 #);
ERROR_FCB_UNAVAILABLE:         (# exit 35 #);
ERROR_SHARING_BUFFER_EXCEEDED: (# exit 36 #);

CreateFile: external
  (# lpFileName: @integer;
     dwDesiredAccess: @integer;
     dwShareMode: @integer;
     lpSecurityAttributes: @integer;
     dwCreationDisposition: @integer;
     dwFlagsAndAttributes: @integer;
     hTemplateFile: @integer;
     theHandle: @integer;
  enter (lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,
     dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile)
  do 'CreateFileA' -> callStd;
  exit theHandle
  #);

GetFileAttributes: external
  (# lpFileName: @integer; (* address of the name of a file or directory. *)
     result: @integer;
  enter lpFileName
  do 'GetFileAttributesA' -> callStd;
  exit result
  #);

getFilterLoadTxt:
  (# filter: @text;
  do 'Text and Rich Text' -> filter.append;
     ascii.nul -> filter.put;
     '*.TXT;*.RTF' -> filter.append;
     ascii.nul -> filter.put;
     'Text Files (*.TXT)' -> filter.append;
     ascii.nul -> filter.put;
     '*.TXT' -> filter.append;
     ascii.nul -> filter.put;
     'Rich Text Format (*.RTF)' -> filter.append;
     ascii.nul -> filter.put;
     '*.RTF' -> filter.append;
     ascii.nul -> filter.put;
     'All Files' -> filter.append;
     ascii.nul -> filter.put;
     '*.*' -> filter.append;
     ascii.nul -> filter.put; ascii.nul -> filter.put;
  exit filter.copy
  #);

getFilterSaveTxt:
  (# filter: @text;
  do 'Text Files (*.TXT)' -> filter.append;
     ascii.nul -> filter.put;
     '*.TXT' -> filter.append;
     ascii.nul -> filter.put;
     
     'Rich Text Format (*.RTF)' -> filter.append;
     ascii.nul -> filter.put;
     '*.RTF' -> filter.append;
     ascii.nul -> filter.put;
     
     'RTF w/o Objects (*.RTF)' -> filter.append;
     ascii.nul -> filter.put;
     '*.RTF' -> filter.append;
     ascii.nul -> filter.put;
     
     'Textized' -> filter.append;
     ascii.nul -> filter.put;
     '*.TXT' -> filter.append;
     ascii.nul -> filter.put;
     
     ascii.nul -> filter.put;
  exit filter.copy
  #);
