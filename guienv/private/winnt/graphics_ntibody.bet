ORIGIN '../graphicsbody' (*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
;
INCLUDE 'guienv_ntiprivate'
        '~beta/win32lib/windowsmisc'
        '~beta/win32lib/wingdi'
        '~beta/win32lib/wingdiconsts'
        '~beta/win32lib/bitmapsupport'
        '~beta/win32lib/winuserconsts'
        '~beta/win32lib/errorhandling'
        '~beta/win32lib/dcmanagement'
        '~beta/sysutils/cstring'
        '~beta/sysutils/objinterface'
        '~beta/basiclib/math';
-- lib: Attributes --
CreateDC2: external
  (#
     driver: [1] @char;
     (* LPCSTR *)
     device: @integer;
     (* LPCSTR *)
     output: @integer;
     (* Must be NULL *)
     initData: @integer;
     (* const void FAR* *)
     hdc: @integer;
     (* HDC *)
     
  enter (driver,device,output,initData)
  do 'CreateDCA'->callStd; 
  exit hdc
  #);
  

-- GUIENVgraphicsPenSize: Descriptor --
(#  do value->private.penSize; TRUE->private.penAttributesChanged;  #)  

-- GUIENVgraphicsPenForegroundColor: Descriptor --
(# hBrush: @integer; 
do
   theColor->private.theGuienvFoColor;
   (theColor.red div 256,0)->private.theFoColor.%putByte;
   (* Above line tos_converted from: (@@ private.theFoColor,theColor.red div 256)->tos'%PutByte'; *)
   theColor.green div 256 %putByteAt(@@ private.theFoColor+1);
   (* Above line tos_converted from: (@@ private.theFoColor+1,theColor.green div 256)->tos'%PutByte'; *)
   theColor.blue div 256 %putByteAt(@@ private.theFoColor+2);
   (* Above line tos_converted from: (@@ private.theFoColor+2,theColor.blue div 256)->tos'%PutByte'; *)
   2 %putByteAt(@@ private.theFoColor+3);
   (* Above line tos_converted from: (@@ private.theFoColor+3,2)->tos'%PutByte'; *)
   (if private.theStipple[] = none then
       private.theFoColor->graphicsCreateSolidBrush->hBrush;
       (if private.hDefaultBrush = 0 then
           (private.hdc,hBrush)->SelectObject->private.hDefaultBrush; 
        else
           (private.hdc,hBrush)->SelectObject->GraphicsDeleteBrush; 
       if);
       hbrush->private.penBrush;
       
    else
       (if getOsVersionId <> VER_PLATFORM_WIN32_NT then
           private.theFoColor->graphicsCreateSolidBrush->hBrush;
           (if private.hDefaultBrush = 0 then
               (private.hdc,hBrush)->SelectObject->private.hDefaultBrush; 
            else
               (private.hdc,hBrush)->SelectObject->GraphicsDeleteBrush; 
           if);
           hbrush->private.penBrush;
           
       if);
       
   if);
   TRUE->private.penAttributesChanged;
   (private.hdc,private.theFoColor)->SetTextColor;
   
#)  

-- GUIENVgraphicsPenBackgroundColor: Descriptor --
(# 
do
   (theColor.red div 256,0)->private.theBaColor.%putByte;
   (* Above line tos_converted from: (@@ private.theBaColor,theColor.red div 256)->tos'%PutByte'; *)
   theColor.green div 256 %putByteAt(@@ private.theBaColor+1);
   (* Above line tos_converted from: (@@ private.theBaColor+1,theColor.green div 256)->tos'%PutByte'; *)
   theColor.blue div 256 %putByteAt(@@ private.theBaColor+2);
   (* Above line tos_converted from: (@@ private.theBaColor+2,theColor.blue div 256)->tos'%PutByte'; *)
   0 %putByteAt(@@ private.theBaColor+3);
   (* Above line tos_converted from: (@@ private.theBaColor+3,0)->tos'%PutByte'; *)
   (private.hdc,private.theBaColor)->SetBkColor;
   
#)  

-- GUIENVgraphicsPenStipple: Descriptor --
(# hBrush: @integer; 
do
   b[]->private.theStipple[];
   (if b[] = none then
       NULL_BRUSH->GetStockObject->hbrush;
       (if private.hDefaultBrush = 0 then
           (private.hdc,hBrush)->SelectObject; 
        else
           (private.hdc,hBrush)->SelectObject->GraphicsDeleteBrush;
           0->private.hDefaultBrush;
           
       if);
       hbrush->private.penBrush;
       TRUE->private.penAttributesChanged;
       
    else
       (if b.private.handleToPixmap <> 0 then
           b.private.handleToPixmap->graphicsCreatePatternBrush->hbrush;
           (if hbrush = 0 then
               '*WARNING: CreatePatternBrush failed in graphicsPenStipple.'
                 ->putline;
               'Error: '->puttext;
               GetLastError->putint;
               newline;
               
            else
               (if private.hDefaultBrush = 0 then
                   (private.hdc,hBrush)->SelectObject->private.hDefaultBrush; 
                else
                   (private.hdc,hBrush)->SelectObject->GraphicsDeleteBrush; 
               if);
               hbrush->private.penBrush;
               (if getOsVersionId = VER_PLATFORM_WIN32_NT then
                   TRUE->private.penAttributesChanged; 
               if);
               
           if);
           
       if);
       
   if);
   
#)  

-- GUIENVgraphicsPenMode: Descriptor --
(# 
do
   (if m
    // transferModes.copy then
       R2_COPYPEN->private.graphicsPenMode; PATCOPY->private.TernaryRasterMode; 
    // transferModes.invertCopy then
       R2_NOTCOPYPEN->private.graphicsPenMode;
       NOTSRCCOPY->private.TernaryRasterMode;
       
    // transferModes.erase then
       R2_NOP->private.graphicsPenMode; SRCERASE->private.TernaryRasterMode; 
    // transferModes.andBlend then
       R2_MASKPEN->private.graphicsPenMode; SRCAND->private.TernaryRasterMode; 
    // transferModes.orBlend then
       R2_MERGEPEN->private.graphicsPenMode;
       SRCPAINT->private.TernaryRasterMode;
       
    // transferModes.xorBlend then
       R2_NOTXORPEN->private.graphicsPenMode;
       PATINVERT->private.TernaryRasterMode;
       
    // transferModes.notAndBlend then
       R2_MERGENOTPEN->private.graphicsPenMode;
       NOTSRCERASE->private.TernaryRasterMode;
       
    // transferModes.notOrBlend then
       R2_MERGEPENNOT->private.graphicsPenMode;
       PATPAINT->private.TernaryRasterMode;
       
   if);
   (private.hdc,private.graphicsPenMode)->SetROP2;
   
#)  

-- GUIENVgraphicsStyle: Descriptor --
(# 
do
   (if theTextStyle[] <> none then
       (if theTextStyle[] <> private.graphicsTextStyle[] then
           theTextStyle[]->private.graphicsTextStyle[]; theTextStyle.create; 
       if);
       
   if);
   
#)  

-- GUIENVgraphicsMove: Descriptor --
(# ntpPtr: @integer; pt: @point; 
do
   8->malloc->ntpPtr;
   (private.hdc,ntpPtr)->GetCurrentPositionEx;
   ntpPtr->getPointFromNtPointPtr->(pt.h,pt.v);
   (private.translateX,private.translateY)->p.add;
   p->pt.add;
   (private.hdc,pt.h,pt.v,0)->MoveToEx;
   ntpPtr->free;
   
#)  

-- GUIENVgraphicsMoveTo: Descriptor --
(# 
do
   (private.translateX,private.translateY)->p.add;
   (private.hdc,p.h,p.v,0)->MoveToEx;
   
#)  

-- GUIENVgraphicsDraw: Descriptor --
(# ntpPtr: @integer; pt: @point; 
do
   8->malloc->ntpPtr;
   (if ntpPtr <> 0 then
       updatePen;
       (private.hdc,ntpPtr)->GetCurrentPositionEx;
       ntpPtr->getPointFromNtPointPtr->(pt.h,pt.v);
       p->pt.add;
       (private.hdc,pt.h+private.translateX,pt.v+private.translateY)->LineTo;
       ntpPtr->free;
       
    else
       'graphicsDraw failed.'->screen.putLine; 
   if);
   
#)  

-- GUIENVgraphicsDrawTo: Descriptor --
(# 
do
   updatePen;
   (private.hdc,p.h+private.translateX,p.v+private.translateY)->LineTo;
   
#)  

-- GUIENVgraphicsDrawSpot: Descriptor --
(# ntpPtr: @integer; pt: @point; 
do
   8->malloc->ntpPtr;
   (if ntpPtr <> 0 then
       updatePen;
       (private.hdc,p.h+private.translateX,p.v+private.translateY,ntpPtr)
         ->MoveToEx;
       (private.hdc,p.h+private.translateX+private.penSize,p.v+
        private.translateY)->LineTo;
       (* restore the penposition *)
       ntpPtr->getPointFromNtPointPtr->(pt.h,pt.v);
       (private.hdc,pt.h,pt.v,0)->MoveToEx;
       ntpPtr->free;
       
    else
       'graphicsDrawSpot failed.'->screen.putLine; 
   if);
   
#)  

-- GUIENVgraphicsDrawLine: Descriptor --
(# ntpPtr: @integer; pt: @point; 
do
   8->malloc->ntpPtr;
   updatePen;
   (private.hdc,p1.h+private.translateX,p1.v+private.translateY,ntpPtr)
     ->MoveToEx;
   (private.hdc,p2.h+private.translateX,p2.v+private.translateY)->LineTo;
   (* restore the penposition *)
   ntpPtr->getPointFromNtPointPtr->(pt.h,pt.v);
   (private.hdc,pt.h,pt.v,0)->MoveToEx;
   ntpPtr->free;
   
#)  

-- GUIENVgraphicsDrawText: Descriptor --
(# length: @integer; tempHdc: @integer; 
do
   (if private.graphicsTextStyle[] <> none then
       (private.hdc,private.graphicsTextStyle.textStyleID)->SelectObject; 
   if);
   updatePen;
   t.length->length;
   private.hdc->tempHdc;
   (if length > 0 then (tempHdc,0,0,@@ t.T[1],length)->TextOut;  if);
   
#)  

-- GUIENVgraphicsDrawPolygon: Descriptor --
(# ntPoints: [0] @integer; hbr,hBrushOld,hdc: @integer; 
do
   updatePen;
   private.hdc->hdc;
   2*points.range->ntPoints.new;
   (for i: points.range repeat
     points[i].h+private.translateX->ntPoints[(i*2)-1];
     points[i].v+private.translateY->ntPoints[i*2];
     
   for);
   NULL_BRUSH->GetStockObject->hbr;
   (hdc,hbr)->SelectObject->hbrushOld;
   (hdc,@@ ntPoints[1],points.range)->Polygon;
   (hdc,hbrushOld)->SelectObject;
   
#)  

-- GUIENVgraphicsDrawRect: Descriptor --
(# hbr: @integer; hbrushOld: @integer; 
do
   (if (private.theStipple[] <> none ) and
   ((R2_COPYPEN = private.graphicsPenMode) or
    (R2_NOTXORPEN = private.graphicsPenMode)) then
       (private.hdc,r.left+private.translateX,r.top+private.translateY,r.right+
        private.translateX-r.left+private.translateX,private.penSize,
        private.TernaryRasterMode)->PatBlt;
       (private.hdc,r.left+private.translateX+private.translateX,r.bottom+
        private.translateY,private.penSize,-
        (r.bottom+private.translateY-r.top+private.translateY),
        private.TernaryRasterMode)->PatBlt;
       (private.hdc,r.right+private.translateX-private.penSize,r.top+
        private.translateY,private.penSize,r.bottom+private.translateY-r.top+
        private.translateY,private.TernaryRasterMode)->PatBlt;
       (private.hdc,r.right+private.translateX,r.bottom+private.translateY-
        private.penSize,-
        (r.right+private.translateX-r.left+private.translateX),private.penSize,
        private.TernaryRasterMode)->PatBlt;
       
    else
       updatePen;
       NULL_BRUSH->GetStockObject->hbr;
       (private.hdc,hbr)->SelectObject->hbrushOld;
       (private.hdc,r.left+private.translateX,r.top+private.translateY,r.right+
        private.translateX,r.bottom+private.translateY)->ntRectangle;
       (private.hdc,hbrushOld)->SelectObject;
       
   if);
   
#)  

-- GUIENVgraphicsDrawRoundRect: Descriptor --
(# hbr,hBrushOld: @integer; ovalHeight,ovalWidth: @integer; 
do
   updatePen;
   NULL_BRUSH->GetStockObject->hbr;
   (private.hdc,hbr)->SelectObject->hbrushOld;
   roundNess.size->(ovalWidth,ovalHeight);
   (private.hdc,r.left+private.translateX,r.top+private.translateY,r.right+
    private.translateX,r.bottom+private.translateY,ovalWidth,ovalHeight)
     ->RoundRect;
   (private.hdc,hbrushOld)->SelectObject;
   
#)  

-- GUIENVgraphicsDrawOval: Descriptor --
(# hbr,hBrushOld: @integer; 
do
   updatePen;
   NULL_BRUSH->GetStockObject->hbr;
   (private.hdc,hbr)->SelectObject->hBrushOld;
   (private.hdc,r.left+private.translateX,r.top+private.translateY,r.right+
    private.translateX,r.bottom+private.translateY)->Ellipse;
   (private.hdc,hbrushOld)->SelectObject;
   
#)  

-- GUIENVgraphicsDrawSlice: Descriptor --
(#
   hbr,hBrushOld: @integer;
   ch,cv: @integer;
   (* center of rectangle *)
   a,b: @Real;
   (* half height and half width of rectangle *)
   xRadial1,yRadial1,xRadial2,yRadial2: @integer;
   angle1,angle2: @Real;
   left,right,top,bottom: @integer;
   
do
   updatePen;
   NULL_BRUSH->GetStockObject->hbr;
   (private.hdc,hbr)->SelectObject->hbrushOld;
   r.left+private.translateX->left;
   r.right+private.translateX->right;
   r.top+private.translateY->top;
   r.bottom+private.translateY->bottom;
   (right-left) / 2->a;
   a+left->ch;
   (bottom-top) / 2->b;
   b+top->cv;
   (fromAngle / 180)*pi->angle1;
   (toAngle / 180)*pi->angle2;
   ch+a*(angle1->cos)->xRadial1;
   cv+b*(angle1->sin)->yRadial1;
   ch+a*(angle2->cos)->xRadial2;
   cv+b*(angle2->sin)->yRadial2;
   (2*cv)-yRadial1->yRadial1;
   (2*cv)-yRadial2->yRadial2;
   (private.hdc,left,top,right,bottom,xRadial1,yRadial1,xRadial2,yRadial2)->Pie;
   (private.hdc,hbrushOld)->SelectObject;
   
#)  

-- GUIENVgraphicsFillPolygon: Descriptor --
(# ntPoints: [0] @integer; hdc: @integer; 
do
   updatePen;
   private.hdc->hdc;
   2*points.range->ntPoints.new;
   (for i: points.range repeat
     points[i].h+private.translateX->ntPoints[(i*2)-1];
     points[i].v+private.translateY->ntPoints[i*2];
     
   for);
   (hdc,@@ ntPoints[1],points.range)->Polygon;
   
#)  

-- GUIENVgraphicsFillRect: Descriptor --
(#
   ntFillRect2: external
     (#
        hdc: @integer;
        (* HDC *)
        theRect: ^ntRECT;
        (* const RECT FAR* *)
        hbr: @integer;
        (* HBRUSH *)
        result: @integer;
        (* int *)
        
     enter (hdc,theRect[],hbr)
     do 'FillRect'->callStd; 
     exit result
     #);
   theRect: @ntRECT;
   tempHdc,tempPenBrush: @integer;
   
do
   updatePen;
   r.left+private.translateX->theRect.left;
   r.right+private.translateX->theRect.right;
   r.top+private.translateY->theRect.top;
   r.bottom+private.translateY->theRect.bottom;
   private.hdc->tempHdc;
   private.penBrush->tempPenBrush;
   (tempHdc,theRect[],tempPenBrush)->ntFillRect2;
   
#)  

-- GUIENVgraphicsFillRoundRect: Descriptor --
(# ovalHeight,ovalWidth: @integer; left,right,top,bottom: @integer; 
do
   updatePen;
   r.left+private.translateX->left;
   r.right+private.translateX->right;
   r.top+private.translateY->top;
   r.bottom+private.translateY->bottom;
   roundNess.size->(ovalWidth,ovalHeight);
   (private.hdc,left,top,right,bottom,ovalWidth,ovalHeight)->RoundRect;
   
#)  

-- GUIENVgraphicsFillOval: Descriptor --
(# 
do
   updatePen;
   (private.hdc,r.left+private.translateX,r.top+private.translateY,r.right+
    private.translateX,r.bottom+private.translateY)->Ellipse;
   
#)  

-- GUIENVgraphicsFillSlice: Descriptor --
(#
   ch,cv: @integer;
   (* center of rectangle *)
   a,b: @Real;
   (* half height and half width of rectangle *)
   xRadial1,yRadial1,xRadial2,yRadial2: @integer;
   angle1,angle2: @Real;
   left,right,top,bottom: @integer;
   
do
   updatePen;
   r.left+private.translateX->left;
   r.right+private.translateX->right;
   r.top+private.translateY->top;
   r.bottom+private.translateY->bottom;
   (right-left) / 2->a;
   a+left->ch;
   (bottom-top) / 2->b;
   b+top->cv;
   (fromAngle / 180)*pi->angle1;
   (toAngle / 180)*pi->angle2;
   ch+a*(angle1->cos)->xRadial1;
   cv+b*(angle1->sin)->yRadial1;
   ch+a*(angle2->cos)->xRadial2;
   cv+b*(angle2->sin)->yRadial2;
   (2*cv)-yRadial1->yRadial1;
   (2*cv)-yRadial2->yRadial2;
   (private.hdc,left,top,right,bottom,xRadial1,yRadial1,xRadial2,yRadial2)->Pie;
   
#)  

-- GUIENVgraphicsDrawRaster: Descriptor --
(#
   drawBitmap: external
     (#
        hdc: @integer;
        hBitmap: @integer;
        xSrcPos,ySrcPos,xDestPos,yDestPos: @integer;
        result: @integer;
        
     enter (hdc,hBitmap,xSrcPos,ySrcPos,xDestPos,yDestPos)
     do 'drawBitmap'->callC; 
     exit result
     #);
   result: @integer;
   theColor: @integer;
   tc: @color;
   DrawTransparentBitmap: external
     (#
        hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,
          transparentColor: @integer;
        result: @integer;
        
     enter
     (hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,
      transparentColor)
     do callC; 
     exit result
     #);
   DrawTransparentBitmapHDC: external
     (#
        hdc,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,
          transparentColor: @integer;
        result: @integer;
        
     enter
     (hdc,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,transparentColor)
     do callC; 
     exit result
     #);
   DrawTransparentBitmapFromMask: external
     (#
        hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,pixmapMask:
          @integer;
        result: @integer;
        
     enter
     (hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,pixmapMask)
     do callC; 
     exit result
     #);
   DrawTransparentBitmapFromMaskHDC: external
     (#
        hdc,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,pixmapMask:
          @integer;
        result: @integer;
        
     enter
     (hdc,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,pixmapMask)
     do callC; 
     exit result
     #);
   drawBrokenImage:
     (# 
        drawBackground:
          (# bottomRight: @point
          do
             to->bottomRight;
             (width,height)->bottomRight.add;
             (maxInt,maxInt,maxInt)->pen.foregroundcolor;
             (to,bottomRight)->fillRect
          #);
        drawCross:
          (# x,y: @Integer
          do
             to->(x,y);
             (maxInt,0,0)->pen.foregroundcolor;
             10->pen.size;
             (to,(x+width,y+height))->drawLine;
             ((x,y+height),(x+width,y))->drawLine
          #);
        
     do drawBackground; drawCross;
     #);
   
do
   (if p.private.handleToPixmap = - 1 then
       drawBrokenImage
    else
       (if p.private.drawTransparent then
           (if p.private.transparentmask[] = none then (* use TransPcolor *)
               p.transparentColor->tc;
               (tc.red div 256,0)->theColor.%putByte;
               (tc.green div 256,1)->theColor.%putByte;
               (tc.blue div 256,2)->theColor.%putByte;
               (0,3)->theColor.%putByte;
               (private.hdc,p.private.handleToPixmap,from.h,from.v,to.h,to.v,
                p.width,p.height,theColor)->DrawTransparentBitmapHDC->result;
               
            else
           (* draw using mask *)
               (private.hdc,p.private.handleToPixmap,from.h,from.v,to.h,to.v,
                p.width,p.height,
                p.private.transparentmask.private.handleToPixmap)
                 ->DrawTransparentBitmapFromMaskHDC->result;
               
           if);
           
        else
           (private.hdc,p.private.handleToPixmap,from.h+private.translateX,
            from.v+private.translateY,to.h+private.translateX,to.v+
            private.translateY)->drawBitmap->result;
           
       if);
       (if result = 0 then
           'drawBitmap failed in GUIENVgraphicsDrawRaster.'->screen.putline; 
       if);
       
   if);
   
#)  

-- graphicsLib: Attributes --
createSimplePen:
  (# hPen: @integer; 
  do
     (PS_INSIDEFRAME+PS_SOLID,1,private.theFoColor)->graphicsCreatePen->hPen;
     (if hPen = 0 then
         'CreatePen failed. Error: '->puttext; GetLastError->putint; newline; 
      else
         (if private.hDefaultPen = 0 then
             (private.hdc,hPen)->SelectObject->private.hDefaultPen; 
          else
             (private.hdc,hPen)->SelectObject->GraphicsDeletePen; 
         if);
         
     if);
     
  #);
createAdvancedPen:
  (#
  (* A pen with a brush or a widht greater than one must be a geometric pen.
   * A geometric pen is 3 to 10 times slower than a cosmetic pen.
   *)
     hBrush: @integer;
     theLogbrush: @LOGBRUSH;
     result: @integer;
     penStyle: @integer;
     hPen: @integer;
     
  do
     private.penBrush->hBrush;
     (hBrush,12,theLogbrush[])->GetLogbrush->result;
     (if result
      // 0 then
         'GetLogBrush returns 0'->putline; 
      // GDI_ERROR then
         'GetLogBrush returns GDI_ERROR'->putline; 
      else
         (PS_GEOMETRIC %Bor PS_SOLID)->penStyle;
         (* Above line tos_converted from: ((PS_GEOMETRIC,PS_SOLID)->tos'%or')->penStyle; *)
         PS_INSIDEFRAME %Bor penStyle->penStyle;
         (* Above line tos_converted from: (PS_INSIDEFRAME,penStyle)->tos'%or'->penStyle; *)
         PS_ENDCAP_FLAT %Bor penStyle->penStyle;
         (* Above line tos_converted from: (PS_ENDCAP_FLAT,penStyle)->tos'%or'->penStyle; *)
         (if getOsVersionId <> VER_PLATFORM_WIN32_NT then
             BS_SOLID->theLogbrush.lbStyle; 
          else
             (if not
             ((private.theGuienvFoColor.red = 0) and
              (private.theGuienvFoColor.green = 0) and
              (private.theGuienvFoColor.blue = 0)) then
                 BS_SOLID->theLogbrush.lbStyle; 
             if);
             
         if);
         private.theFoColor->theLogBrush.lbColor;
         (penStyle,private.penSize,theLogbrush[])->graphicsExtCreatePen->hPen;
         (if hPen = 0 then
             'createAdvancedPen. ExtCreatePen failed. Error: '->puttext;
             GetLastError->screen.putint;
             screen.newline;
             
          else
             (if private.hDefaultPen = 0 then
                 (private.hdc,hPen)->SelectObject->private.hDefaultPen; 
              else
                 (private.hdc,hPen)->SelectObject->GraphicsDeletePen; 
             if);
             
         if);
         
     if);
     
  #);
updatePen:
  (# 
  do
     (if private.penAttributesChanged then
         (if (private.theStipple[] = none ) and (private.penSize = 1) then
             createSimplePen; 
          else
             createAdvancedPen; 
         if);
         
     if);
     
  #);
graphicsCreatePen:
  (#
     penStyle: @integer;
     penWidth: @integer;
     color: @integer;
     thePen: @integer;
     
  enter (penStyle,penWidth,color)
  do
     (penStyle,penWidth,color)->CreatePen->thePen;
     (if thePen <> 0 then thePen->private.currentHpen;  if);
     
  exit thePen
  #);
graphicsExtCreatePen:
  (#
     penStyle: @integer;
     penWidth: @integer;
     theLogbrush: ^LOGBRUSH;
     thePen: @integer;
     
  enter (penStyle,penWidth,theLogBrush[])
  do
     (penStyle,penWidth,theLogbrush[],0,0)->ExtCreatePen->thePen;
     (if thePen <> 0 then thePen->private.currentHpen;  if);
     
  exit thePen
  #);
graphicsCreateSolidBrush:
  (# brushColor: @integer; theBrush: @integer; 
  enter brushColor
  do brushColor->CreateSolidBrush->theBrush; 
  exit theBrush
  #);
graphicsCreatePatternBrush:
  (# handleToPixmap: @integer; theBrush: @integer; 
  enter handleToPixmap
  do handleToPixmap->CreatePatternBrush->theBrush; 
  exit theBrush
  #);
graphicsDeleteBrush:
  (# theBrush: @integer;  enter theBrush do theBrush->DeleteObject;  #);
graphicsDeletePen:
  (# thePen: @integer;  enter thePen do thePen->DeleteObject;  #);
getGraphicsHdc: (#  exit private.hdc #);
setGraphicsHdc: (#  enter private.hdc #);
  

-- GUIENVgraphicsPrivate: Descriptor --
(#
   hdc: @integer;
   release: @boolean;
   penSize: @integer;
   theStipple: ^pixmap;
   penBrush,hDefaultPen,currentHpen,hDefaultBrush: @integer;
   theFoColor,theBaColor: @integer;
   theGuienvFoColor: @color;
   graphicsTextStyle: ^textStyle;
   graphicsPenMode,TernaryRasterMode: @integer;
   translateX,translateY: @integer;
   windowID: @integer;
   penAttributesChanged: @boolean;
   
#)  

-- GUIENVgraphicsBody: Descriptor --
(# prevBkMode,hPal,deviceType: @integer; 
do
   (if THIS(windowItem).interfaceObjectID = 0 then
       father.interfaceObjectID->private.windowID;
       position->(private.translateX,private.translateY);
       
    else
       THIS(windowItem).interfaceObjectID->private.windowID;
       (0,0)->(private.translateX,private.translateY);
       
   if);
   (if windowItemDevice <> 0 then
       windowItemDevice->private.hdc; false->private.release; 
    else
       true->private.release;
       (if overrideChildren then
           DCX_PARENTCLIP %Bor DCX_CLIPSIBLINGS->deviceType;
           (private.windowID,0,deviceType)->GetDCEx->private.hdc;
           
        else
           DCX_PARENTCLIP %Bor DCX_CLIPSIBLINGS %Bor DCX_CLIPCHILDREN
             ->deviceType;
           (private.windowID,0,deviceType)->GetDCEx->private.hdc;
           
       if);
       
   if);
   (if private.hdc = 0 then
       'GetDCEx failed. Error: '->puttext; GetLastError->putint; newline; 
   if);
   (if private.release then
       (if THIS(guienv).private.curhPal <> 0 then
           THIS(guienv).private.curhPal->hPal; 
        else
           THIS(guienv).private.ghPal->hPal; 
       if);
       (if (hPal <> 0) then
           (private.hdc,hPal,1)->SelectPalette; private.hdc->RealizePalette; 
       if);
       
   if);
   (0,0,0)->pen.foregroundColor;
   1->pen.size;
   (private.hdc,TRANSPARENT)->SetBkMode->prevBkMode;
   (if prevBkMode = 0 then 'SetBkMode failed.'->screen.putLine;  if);
   (private.hdc,TA_BASELINE+TA_LEFT+TA_UPDATECP)->SetTextAlign;
   INNER graphics;
   (if private.hDefaultPen <> 0 then
       (private.hdc,private.hDefaultPen)->SelectObject->GraphicsDeletePen; 
   if);
   (if private.hDefaultBrush <> 0 then
       (private.hdc,private.hDefaultBrush)->SelectObject->GraphicsDeleteBrush; 
   if);
   (private.hdc,prevBkMode)->SetBkMode;
   (if private.release then (private.windowID,private.hdc)->ReleaseDC;  if);
   
#)  

-- GUIENVgraphicsDrawSpots: DoPart --
do (for inx: points.range repeat points[inx]->drawSpot;  for);   

