ORIGIN '../graphicsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
INCLUDE 'guienv_ntiprivate';
INCLUDE '~beta/win32lib/v1.6/windowsmisc';
INCLUDE '~beta/win32lib/v1.6/wingdi';
INCLUDE '~beta/win32lib/v1.6/wingdiconsts';
INCLUDE '~beta/win32lib/v1.6/bitmapsupport';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';
INCLUDE '~beta/win32lib/v1.6/errorhandling';
INCLUDE '~beta/sysutils/v1.6/cstring';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '~beta/basiclib/v1.6/math';

-- GUIENVgraphicsPenSize: descriptor --
(# 
do value -> private.penSize;
   TRUE -> private.penAttributesChanged;
#)

-- GUIENVgraphicsPenForegroundColor: descriptor --
(#      
   hBrush: @integer;
do theColor -> private.theGuienvFoColor;
   
   (@@private.theFoColor,theColor.red div 256) -> TOS'%PutByte';
   (@@private.theFoColor + 1,theColor.green div 256) -> TOS'%PutByte';
   (@@private.theFoColor + 2,theColor.blue div 256) -> TOS'%PutByte';
   (@@private.theFoColor + 3,2) -> TOS'%PutByte';
   
   (if private.theStipple[]=none then
       private.theFoColor -> graphicsCreateSolidBrush -> hBrush; 
       (if private.hDefaultBrush=0 then
           (private.hdc, hBrush) -> SelectObject -> private.hDefaultBrush; 
        else
           (private.hdc, hBrush) -> SelectObject -> GraphicsDeleteBrush; 
       if);
       hbrush -> private.penBrush;
    else
       (if getOsVersionId<>VER_PLATFORM_WIN32_NT then 
           private.theFoColor -> graphicsCreateSolidBrush -> hBrush; 
           (if private.hDefaultBrush=0 then
               (private.hdc, hBrush) -> SelectObject -> private.hDefaultBrush; 
            else
               (private.hdc, hBrush) -> SelectObject -> GraphicsDeleteBrush; 
           if);
           hbrush -> private.penBrush;
       if);
   if);
   
   TRUE -> private.penAttributesChanged;
   (private.hdc, private.theFoColor) -> SetTextColor;   
#)

-- GUIENVgraphicsPenBackgroundColor: descriptor --
(#
do (@@private.theBaColor,theColor.red div 256) -> TOS'%PutByte';
   (@@private.theBaColor + 1,theColor.green div 256) -> TOS'%PutByte';
   (@@private.theBaColor + 2,theColor.blue div 256) -> TOS'%PutByte';
   (@@private.theBaColor + 3,0) -> TOS'%PutByte';
   (private.hdc, private.theBaColor) -> SetBkColor;
#)

-- GUIENVgraphicsPenStipple: descriptor --
(# hBrush: @integer;
do b[] -> private.theStipple[];
   (if b[]=none then
       NULL_BRUSH -> GetStockObject -> hbrush;
       (if private.hDefaultBrush=0 then
           (private.hdc, hBrush) -> SelectObject; 
        else
           (private.hdc, hBrush) -> SelectObject -> GraphicsDeleteBrush; 
           0 -> private.hDefaultBrush;
       if);
       
       hbrush -> private.penBrush;
       TRUE -> private.penAttributesChanged;
    else
       (if b.private.handleToPixmap<>0 then
           b.private.handleToPixmap -> graphicsCreatePatternBrush -> hbrush;
           (if hbrush=0 then 
               '*WARNING: CreatePatternBrush failed in graphicsPenStipple.' -> putline;
               'Error: ' -> puttext;
               GetLastError -> putint; newline;
            else
               (if private.hDefaultBrush=0 then
                   (private.hdc, hBrush) -> SelectObject -> private.hDefaultBrush; 
                else
                   (private.hdc, hBrush) -> SelectObject -> GraphicsDeleteBrush; 
               if);
               hbrush -> private.penBrush;
               (if getOsVersionId=VER_PLATFORM_WIN32_NT then
                   TRUE -> private.penAttributesChanged;
               if);
           if);
       if);
   if);
#)

-- GUIENVgraphicsPenMode: descriptor --
(# 
do (if m=transferModes.copy then R2_COPYPEN -> private.graphicsPenMode; if);
   (if m=transferModes.invertCopy then R2_NOTCOPYPEN -> private.graphicsPenMode; if);
   (if m=transferModes.erase then R2_NOT -> private.graphicsPenMode; if);
   (if m=transferModes.andBlend then R2_MASKPEN -> private.graphicsPenMode; if);
   (if m=transferModes.orBlend then R2_MERGEPEN -> private.graphicsPenMode; if);
   (if m=transferModes.xorBlend then R2_NOTXORPEN -> private.graphicsPenMode; if);
   (if m=transferModes.notAndBlend then R2_MASKNOTPEN -> private.graphicsPenMode; if);
   (if m=transferModes.notOrBlend then R2_MERGENOTPEN -> private.graphicsPenMode; if);
   (private.hdc, private.graphicsPenMode) -> SetROP2;
#)

-- GUIENVgraphicsStyle: descriptor --
(#
do (if theTextStyle[]<>NONE then
       (if theTextStyle[]<>private.graphicsTextStyle[] then
           theTextStyle[] -> private.graphicsTextStyle[];
           theTextStyle.create;
       if);
   if);
#)

-- GUIENVgraphicsMove: descriptor --
(# ntpPtr: @integer; pt: @point; 
do 8 -> malloc -> ntpPtr;
   (private.hdc,ntpPtr) -> GetCurrentPositionEx;
   
   ntpPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
   (private.translateX,private.translateY) -> p.add;
   p -> pt.add;
   (private.hdc,pt.h,pt.v,0) -> MoveToEx;
   
   ntpPtr -> free;
#)

-- GUIENVgraphicsMoveTo: descriptor --
(# 
do (private.translateX,private.translateY) -> p.add;
   (private.hdc,p.h,p.v,0) -> MoveToEx;
#)

-- GUIENVgraphicsDraw: descriptor --
(# ntpPtr: @integer; pt: @point;
do 8 -> malloc -> ntpPtr;
   (if ntpPtr<>0 then
       updatePen;
       (private.hdc,ntpPtr) -> GetCurrentPositionEx;
       
       ntpPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
       p -> pt.add;
       (private.hdc,pt.h+private.translateX,pt.v+private.translateY) 
         -> LineTo;
       
       ntpPtr -> free;
    else
       'graphicsDraw failed.' -> screen.putLine;
   if);
#)

-- GUIENVgraphicsDrawTo: descriptor --
(# 
do updatePen;
   (private.hdc,p.h+private.translateX,p.v+private.translateY) 
     -> LineTo;
#)

-- GUIENVgraphicsDrawSpot: descriptor --
(# ntpPtr: @integer; pt: @point; 
do 8 -> malloc -> ntpPtr;
   
   (if ntpPtr<>0 then
       updatePen;
       (private.hdc,p.h+private.translateX,p.v+private.translateY,ntpPtr) 
         -> MoveToEx;
       (private.hdc,p.h+private.translateX+private.penSize,
       p.v+private.translateY) -> LineTo;
       (* restore the penposition *)
       ntpPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
       (private.hdc,pt.h,pt.v,0) -> MoveToEx;
       
       ntpPtr -> free;
    else
       'graphicsDrawSpot failed.' -> screen.putLine;
   if);
#)

-- GUIENVgraphicsDrawLine: descriptor --
(# ntpPtr: @integer; pt: @point; 
do 8 -> malloc -> ntpPtr;
   
   updatePen;
   (private.hdc,p1.h+private.translateX,p1.v+private.translateY,ntpPtr) 
     -> MoveToEx;
   (private.hdc,p2.h+private.translateX,p2.v+private.translateY) 
     -> LineTo;

   (* restore the penposition *)
   ntpPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
   (private.hdc,pt.h,pt.v,0) -> MoveToEx;
   
   ntpPtr -> free;
#)

-- GUIENVgraphicsDrawText: descriptor --
(# length: @integer;
   tempHdc: @integer;
do (if private.graphicsTextStyle[]<>none then
       (private.hdc,private.graphicsTextStyle.textStyleID) -> SelectObject;
   if);
   
   updatePen;
   t.length -> length;
   private.hdc -> tempHdc;
   (tempHdc, 0, 0, @@t.T[1],length) -> TextOut; 
#)

-- GUIENVgraphicsDrawPolygon: descriptor --
(# ntPoints: [0] @integer; hbr, hBrushOld,hdc: @integer; 
do 
   updatePen;
   private.hdc -> hdc;
   2 * points.range ->  ntPoints.new;
   (for i: points.range repeat
      points[i].h+private.translateX -> ntPoints[(i*2)-1];
      points[i].v+private.translateY -> ntPoints[i*2];
   for);
   NULL_BRUSH -> GetStockObject -> hbr;
   (hdc, hbr) -> SelectObject -> hbrushOld;
   (hdc,@@ntPoints[1],points.range) -> Polygon; 
   (hdc, hbrushOld) -> SelectObject;

#)

-- GUIENVgraphicsDrawRect: descriptor --
(# hbr: @integer; hRgn: @integer; 
   hbrushOld: @integer;
   fWidth,fHeight: @integer;
do updatePen;
   NULL_BRUSH -> GetStockObject -> hbr;
   (private.hdc, hbr) -> SelectObject -> hbrushOld;
   (private.hdc,
   r.left+private.translateX,r.top+private.translateY,
   r.right+private.translateX,r.bottom+private.translateY) -> ntRectangle;
   (private.hdc, hbrushOld) -> SelectObject;
#)

-- GUIENVgraphicsDrawRoundRect: descriptor --
(# hbr, hBrushOld: @integer; 
   ovalHeight, ovalWidth: @integer;
do updatePen;
   NULL_BRUSH -> GetStockObject -> hbr;
   (private.hdc, hbr) -> SelectObject -> hbrushOld;
   roundNess.size -> (ovalWidth,ovalHeight);
   (private.hdc,
   r.left+private.translateX,r.top+private.translateY,
   r.right+private.translateX,r.bottom+private.translateY,ovalWidth,ovalHeight) 
     -> RoundRect;
   (private.hdc, hbrushOld) -> SelectObject;
#)

-- GUIENVgraphicsDrawOval: descriptor --
(# hbr, hBrushOld: @integer; 
do updatePen;
   NULL_BRUSH -> GetStockObject -> hbr;
   (private.hdc, hbr) -> SelectObject -> hBrushOld;
   (private.hdc,r.left+private.translateX,r.top+private.translateY,
   r.right+private.translateX,r.bottom+private.translateY) -> Ellipse;
   (private.hdc, hbrushOld) -> SelectObject;
#)

-- GUIENVgraphicsDrawSlice: descriptor --
(# hbr, hBrushOld: @integer;
   ch,cv: @integer; (* center of rectangle *)
   a,b: @Real; (* half height and half width of rectangle *)
   xRadial1,yRadial1,xRadial2,yRadial2: @integer;
   angle1,angle2: @Real;
   left,right,top,bottom: @integer;
do updatePen;
   NULL_BRUSH -> GetStockObject -> hbr;
   (private.hdc, hbr) -> SelectObject -> hbrushOld;
   
   r.left+private.translateX -> left; 
   r.right+private.translateX -> right;
   r.top+private.translateY -> top;
   r.bottom+private.translateY -> bottom;
   
   (right - left)/2 -> a;
   a + left -> ch;
   (bottom - top)/2 -> b;
   b + top -> cv;
   (fromAngle/180) * pi -> angle1;
   (toAngle/180) * pi -> angle2;
   ch + a * (angle1 -> cos) -> xRadial1;
   cv + b * (angle1 -> sin) -> yRadial1; 
   ch + a * (angle2 -> cos) -> xRadial2;
   cv + b * (angle2 -> sin) -> yRadial2;
   (2 * cv) - yRadial1 -> yRadial1;
   (2 * cv) - yRadial2 -> yRadial2;
   
   (private.hdc,left,top,right,bottom,xRadial1,yRadial1,xRadial2,yRadial2)
     -> Pie; 
   (private.hdc, hbrushOld) -> SelectObject;

#)

-- GUIENVgraphicsFillPolygon: descriptor --
(# ntPoints: [0] @integer; hdc: @integer;
do updatePen;
   private.hdc -> hdc;
   2 * points.range ->  ntPoints.new;
   (for i: points.range repeat
      points[i].h+private.translateX -> ntPoints[(i*2)-1];
      points[i].v+private.translateY -> ntPoints[i*2];
   for);
   (hdc,@@ntPoints[1],points.range) -> Polygon;
#)

-- GUIENVgraphicsFillRect: descriptor --
(# 
   ntFillRect2: external
     (# hdc: @integer; (* HDC *)
        theRect: ^ntRECT; (* const RECT FAR* *)
        hbr: @integer; (* HBRUSH *)
        result: @integer; (* int *)
     enter (hdc,theRect[],hbr)
     do 'FillRect' -> callStd;
     exit result
     #);
   theRect: @ntRECT;
   tempHdc, tempPenBrush: @integer;
do updatePen;
   r.left+private.translateX -> theRect.left;
   r.right+private.translateX -> theRect.right;
   r.top+private.translateY -> theRect.top;
   r.bottom+private.translateY -> theRect.bottom;
   private.hdc -> tempHdc;
   private.penBrush -> tempPenBrush;
   
   (tempHdc,theRect[],tempPenBrush) -> ntFillRect2;
#)

-- GUIENVgraphicsFillRoundRect: descriptor --
(# 
   ovalHeight, ovalWidth: @integer;
   left,right,top,bottom: @integer;
do 
   updatePen;
   r.left+private.translateX -> left; 
   r.right+private.translateX -> right;
   r.top+private.translateY -> top;
   r.bottom+private.translateY -> bottom;
   
   roundNess.size -> (ovalWidth,ovalHeight);
   (private.hdc,left,top,right,bottom,ovalWidth,ovalHeight) 
     -> RoundRect; 
#)

-- GUIENVgraphicsFillOval: descriptor --
(# 
do updatePen;
   (private.hdc,r.left+private.translateX,r.top+private.translateY,
   r.right+private.translateX,r.bottom+private.translateY) -> Ellipse;
#)

-- GUIENVgraphicsFillSlice: descriptor --
(# ch,cv: @integer; (* center of rectangle *)
   a,b: @Real; (* half height and half width of rectangle *)
   xRadial1,yRadial1,xRadial2,yRadial2: @integer;
   angle1,angle2: @Real;
   left,right,top,bottom: @integer;
do 
   updatePen;
   r.left+private.translateX -> left; 
   r.right+private.translateX -> right;
   r.top+private.translateY -> top;
   r.bottom+private.translateY -> bottom;
   
   (right - left)/2 -> a;
   a + left -> ch;
   (bottom - top)/2 -> b;
   b + top -> cv;
   (fromAngle/180) * pi -> angle1;
   (toAngle/180) * pi -> angle2;
   ch + a * (angle1 -> cos) -> xRadial1;
   cv + b * (angle1 -> sin) -> yRadial1;
   ch + a * (angle2 -> cos) -> xRadial2;
   cv + b * (angle2 -> sin) -> yRadial2;
   (2 * cv) - yRadial1 -> yRadial1;
   (2 * cv) - yRadial2 -> yRadial2;
   (private.hdc,left,top,right,bottom,xRadial1,yRadial1,xRadial2,yRadial2)
     -> Pie;
#)

-- GUIENVgraphicsDrawRaster: descriptor --
(# drawBitmap: external
     (# hwnd: @integer;
        hBitmap: @integer;
        xSrcPos, ySrcPos, xDestPos, yDestPos: @integer;
        result: @integer;
     enter (hwnd, hBitmap, xSrcPos, ySrcPos, xDestPos, yDestPos)
     do 'drawBitmap' -> callC;
     exit result
     #);
   result: @integer;
   
   theColor: @integer;
   DrawTransparentBitmap: external
     (# hWnd, hBitmap, xStart, yStart, xDestPos, yDestPos, 
        transparentColor: @integer;
     enter (hWnd, hBitmap, xStart, yStart, xDestPos, yDestPos, 
        transparentColor)
     do callC;
     #);
   
do (private.windowID,p.private.handleToPixmap,
   from.h+private.translateX,from.v+private.translateY,
   to.h+private.translateX,to.v+private.translateY)
     -> drawBitmap -> result;
   (if result=0 then
       'drawBitmap failed in GUIENVgraphicsDrawRaster.' -> screen.putline;
    if);
   
   (* 
    *    (@@theColor,0) -> TOS'%PutByte';
    *    (@@theColor + 1,0) -> TOS'%PutByte';
    *    (@@theColor + 2,255) -> TOS'%PutByte';
    *    (@@theColor + 3,0) -> TOS'%PutByte';
    *    (this(windowItem).interfaceObjectID,
    *    r.private.handleToPixmap,from.h,from.v,to.h,to.v,theColor)
    *      -> DrawTransparentBitmap;
    *)
#)

-- graphicsLib: attributes --
createSimplePen:
  (# hPen: @integer;
  do (PS_INSIDEFRAME+PS_SOLID, 1, private.theFoColor) 
       -> graphicsCreatePen -> hPen;
     (if hPen=0 then 
         'CreatePen failed. Error: ' -> puttext; 
         GetLastError -> putint; newline;
      else
         (if private.hDefaultPen=0 then
             (private.hdc,hPen) -> SelectObject -> private.hDefaultPen;
          else
             (private.hdc,hPen) -> SelectObject -> GraphicsDeletePen;
         if);
     if);
  #);

createAdvancedPen:
  (# (* A pen with a brush or a widht greater than one must be a geometric pen.
      * A geometric pen is 3 to 10 times slower than a cosmetic pen.
      *)
     hBrush: @integer;
     theLogbrush: @LOGBRUSH; result: @integer;
     penStyle: @integer; hPen: @integer; 
     
  do 
     private.penBrush -> hBrush;
     (hBrush, 12, theLogbrush[]) -> GetLogbrush -> result;
     (if result
      //0 then 'GetLogBrush returns 0' -> putline;
      //GDI_ERROR then 'GetLogBrush returns GDI_ERROR' -> putline;
      else
         ((PS_GEOMETRIC,PS_SOLID) -> tos'%or')-> penStyle;
         (PS_INSIDEFRAME,penStyle) -> tos'%or' -> penStyle;
         (PS_ENDCAP_FLAT,penStyle) -> tos'%or' -> penStyle;
         (if getOsVersionId<>VER_PLATFORM_WIN32_NT then 
             BS_SOLID -> theLogbrush.lbStyle;
          else
             (if not 
                 ((private.theGuienvFoColor.red=0) 
                 and (private.theGuienvFoColor.green=0) 
                 and (private.theGuienvFoColor.blue=0)) then
                 BS_SOLID -> theLogbrush.lbStyle;
             if);
         if);
         
         private.theFoColor -> theLogBrush.lbColor;
         (penStyle,private.penSize,theLogbrush[]) 
           -> graphicsExtCreatePen -> hPen;
         (if hPen=0 then 
             'createAdvancedPen. ExtCreatePen failed. Error: ' -> puttext; 
             GetLastError -> screen.putint; screen.newline;
          else
             (if private.hDefaultPen=0 then
                 (private.hdc,hPen) -> SelectObject -> private.hDefaultPen;
              else
                 (private.hdc,hPen) -> SelectObject -> GraphicsDeletePen;
             if);
         if);
     if);
  #);

updatePen:
  (# 
  do (if private.penAttributesChanged then
         (if (private.theStipple[]=NONE) and (private.penSize=1) then
             createSimplePen;
          else
             createAdvancedPen;
         if);
     if);
  #);

graphicsCreatePen:
  (# penStyle: @integer;
     penWidth: @integer;
     color: @integer;
     thePen: @integer;
  enter (penStyle, penWidth, color)
  do (penStyle, penWidth, color) -> CreatePen -> thePen; 
     (if thePen<>0 then
         thePen -> private.currentHpen;
     if);
  exit thePen
  #);
graphicsExtCreatePen:
  (# penStyle: @integer;
     penWidth: @integer;
     theLogbrush: ^LOGBRUSH;
     thePen: @integer;
  enter (penStyle, penWidth, theLogBrush[])
  do (penStyle,penWidth,theLogbrush[],0,0) -> ExtCreatePen -> thePen;
     (if thePen<>0 then
         thePen -> private.currentHpen;
     if);
  exit thePen
  #);

graphicsCreateSolidBrush:
  (# brushColor: @integer;
     theBrush: @integer;
  enter brushColor
  do brushColor -> CreateSolidBrush -> theBrush;
  exit theBrush
  #);

graphicsCreatePatternBrush:
  (# handleToPixmap: @integer;
     theBrush: @integer;
  enter handleToPixmap
  do handleToPixmap -> CreatePatternBrush -> theBrush;
  exit theBrush
  #);
  
graphicsDeleteBrush:
  (# theBrush: @integer;
  enter theBrush
  do theBrush -> DeleteObject;
  #);

graphicsDeletePen:
  (# thePen: @integer;
  enter thePen
  do thePen -> DeleteObject;
  #);
  
getGraphicsHdc:
  (#
  exit private.hdc
  #);
setGraphicsHdc:
  (#
  enter private.hdc
  #);
-- GUIENVgraphicsPrivate: descriptor --
(# hdc: @integer;
   penSize: @integer;
   theStipple: ^pixmap;
   penBrush, hDefaultPen, currentHpen, hDefaultBrush: @integer;
   theFoColor,theBaColor: @integer;
   theGuienvFoColor: @color;
   graphicsTextStyle: ^textStyle;
   graphicsPenMode: @integer;
   translateX,translateY: @integer;
   windowID: @integer;
   
   penAttributesChanged: @boolean;
#)

-- GUIENVgraphicsBody: descriptor --
(# prevBkMode, hPal, deviceType: @integer; 
do (if this(windowItem).interfaceObjectID=0 then
       father.interfaceObjectID -> private.windowID;
       position ->( private.translateX, private.translateY);
    else
       this(windowItem).interfaceObjectID -> private.windowID;
       (0,0) -> ( private.translateX, private.translateY);
   if);
   
   (if overrideChildren then
       private.windowID -> GetDC -> private.hdc; 
    else
       DCX_PARENTCLIP %Bor DCX_CLIPSIBLINGS %Bor DCX_CLIPCHILDREN ->deviceType;
       (private.windowID,0, deviceType) -> GetDCEx -> private.hdc; 
   if);
   (if private.hdc=0 then
       'GetDCEx failed. Error: ' -> puttext;
       GetLastError -> putint; newline;
   if);
   
   (if this(guienv).private.curhPal<>0 then
       this(guienv).private.curhPal -> hPal;
    else
       this(guienv).private.ghPal -> hPal;
   if);
   (if (hPal<>0) then
       (private.hdc, hPal, 1) -> SelectPalette;
       private.hdc -> RealizePalette;
   if);
   
   (0,0,0) -> pen.foregroundColor; 1->pen.size;
   (private.hdc,TRANSPARENT) -> SetBkMode -> prevBkMode; 
   (if prevBkMode=0 then
       'SetBkMode failed.' -> screen.putLine;
   if);
   (private.hdc,TA_BASELINE+TA_LEFT+TA_UPDATECP) -> SetTextAlign;
   
   inner graphics;
   
   (if private.hDefaultPen<>0 then
       (private.hdc, private.hDefaultPen) -> SelectObject -> GraphicsDeletePen; 
   if);
   (if private.hDefaultBrush<>0 then
       (private.hdc, private.hDefaultBrush) -> SelectObject -> GraphicsDeleteBrush; 
   if);
   (private.hdc,prevBkMode) -> SetBkMode;
   (private.windowID,private.hdc) -> ReleaseDC;
   
#)
