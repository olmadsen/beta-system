ORIGIN '../graphicscanvasbody';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/win32lib/bitmapsupport';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/wingdi';
INCLUDE '~beta/win32lib/wingdiconsts';
INCLUDE '~beta/win32lib/devicecapabilities';
INCLUDE '~beta/win32lib/dcmanagement';
INCLUDE '~beta/win32lib/windowsmisc';
INCLUDE '~beta/guienv/graphics';
INCLUDE '~beta/basiclib/math';
INCLUDE '~beta/sysutils/cstring';
INCLUDE '~beta/toollibs/utils/PNG/png';

BUILD nti '$$/aadraw.obj' 'external/aadraw.c' 'betacc $0 $1';
BUILD nti '$$/rotatetext.obj' 'external/rotatetext.cpp' 'betacc $0 $1';


BUILD nti '$$/ovalfill.obj' 'external/ovalfill.c' 'betacc $0 $1';


-- lib: attributes --


write_pixels_to_png: external
  (# pixels: @int32u;
     width: @int32;
     height: @int32;
     filename: [1] @char;
  enter (pixels, width, height, filename)
  #);
ROTATE: (# exit true #);

drawRotatedText_ext1: external
  (# theText: [1]@char;
     angle: @integer;
     height: @integer;
     weight: @integer;
     italic: @boolean;
     facename: [1]@char;
     hdc: @integer;
  enter (theText, angle, height, weight, italic, facename, hdc)
  #);

ReadPNGalpha: external
  (# name: [1] @char;
     hbmp: @integer;
     pixels: @integer;
     width: @integer;
     height: @integer;
     result: @integer;
  enter (name, hbmp, pixels, width, height)
  exit result
  #);

init_tables: external
  (# buffer: @int32u;
     width, height: @integer;
  enter (buffer, width, height)
  #);
aamoveto: external
  (# x, y: @real;
  enter (x, y)
  #);
aalineto: external
  (# x, y: @real;
  enter (x, y)
  #);
aapen: external
  (# red, green, blue: @real;
  enter (red, green, blue)
  #);
ovalpen: external
  (# red, green, blue: @real;
  enter (red, green, blue)
  #);

TransferRedPixels: external
  (# src, dst: @integer;
     srcrowbytes, dstrowbytes: @integer;
     x, y: @integer;
     width, height: @integer;
  enter (src, srcrowbytes, dst, dstrowbytes, x, y, width, height)
  #);


ANTIALIAS: (# exit true #);
MICHAEL: (# exit true #);

DRAW_MULTIPLE_OVALS: (# exit true #);



init_ovals: external
  (#
  #);
fill_oval: external
  (# x, y, width, height: @integer;
  enter (x, y, width, height)
  #);
-- GraphicsCanvasLib: attributes --



isPointInRegion: booleanValue
  (#
     win32Points: [8] @Integer;
     theNtRect: @ntRECTextR;
     regionHandle: @integer;
     counter: @integer;
     noOfPoints: @integer;
     points: ^PointList;
     ptIn: @Point;
     
  enter (points[],ptIn)
  do
     (if (2*points.size) > win32Points.range then
         (2*points.size)-win32Points.range->win32Points.extend; 
     if);
     0->counter;
     points.scan
       (# 
       do
          counter+1->counter;
          current.x->win32Points[(counter*2)-1];
          current.y->win32Points[counter*2];
          
       #);
     points.size->noOfPoints;
     (@@ win32Points[1],noOfPoints,WINDING)->CreatePolygonRgn->regionHandle;
     (if regionHandle <> 0 then
         (((regionHandle,ptIn.h,ptIn.v)->PtInRegion) <> 0)->value;
         regionHandle->DeleteObject;
         0->regionHandle;
     if);
     
  #);

InputCanvasMethods: WindowItemMethods
  (# count: @integer;
     
     dispatchMessage::<
       (# 
          x, y: @integer;
          clrbkgnd:@boolean;
       do false->clrbkgnd;
	  (if info.message=WM_ERASEBKGND then
              true->info.handled;
	  if);
          (if info.message = WM_MOUSEMOVE then
              (info.lParam.loWord,info.lParam.hiWord) 
                -> (x, y);
              ((info.lParam.loWord,info.lParam.hiWord), info.where, info.button, doubleClickPossible, (VK_SHIFT -> isVKeyDown), (VK_CONTROL -> isVKeyDown), GetMessageTime)
               -> theEventHandler.onMouseMove;
          if);
          INNER;
       #);
  #);

-- SurfaceLib: attributes --


ComputeOutline:
  (# x, y: @real;
     a, b: @real;
     outline: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 10 #);
     number: (# exit 36 #);
  enter (x, y, a, b)
  do &PointList[] -> outline[];
     (for number repeat
          (degree / 180) * PI -> angle;
          &Point2d[] -> p[];
          x + (angle -> cos)*a -> p.x;
          y + (angle -> sin)*b -> p.y;
          p[] -> outline.append;
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*a -> p.x;
     y + (0 -> sin)*b -> p.y;
     p[] -> outline.append;
  exit outline[]
  #);
ComputeSplitOutline:
  (# x, y: @real;
     a, b: @real;
     outside, inside: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 5 #);
     number: (# exit 72 #);
     delta: @real;
     cosa, sina: @real;
  enter (x, y, a, b, delta)
  do &PointList[] -> outside[];
     &PointList[] -> inside[];
     
     (for number repeat
          (degree / 180) * PI -> angle;
          angle -> cos -> cosa;
          angle -> sin -> sina;
          
          &Point2d[] -> p[];
          x + cosa*(a+delta) -> p.x;
          y + sina*(b+delta) -> p.y;
          p[] -> outside.append;
          
          &Point2d[] -> p[];
          x + cosa*(a-delta) -> p.x;
          y + sina*(b-delta) -> p.y;
          p[] -> inside.append;
          
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*(a+delta) -> p.x;
     y + (0 -> sin)*(b+delta) -> p.y;
     p[] -> outside.append;
     &Point2d[] -> p[];
     x + (0 -> cos)*(a-delta) -> p.x;
     y + (0 -> sin)*(b-delta) -> p.y;
     p[] -> inside.append;
  exit (inside[], outside[])
  #);

-- GraphicsCanvasWritePNG: doPart --
do (# pixels: @integer;
      width, height: @integer;
   do (0xFFFF, 0xFFFF, 0xFFFF)  -> doublebuffer.content.clear;
      doublebuffer.begin;
      doublebuffer.push;
      (panx, pany) -> doublebuffer.translate;
      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      layers.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      doublebuffer.pop;
      
      
      size -> (width, height);
      doublebuffer.content.private.handleToPixmap -> pixels;
      (pixels, width, height, filename) -> write_pixels_to_png;
      doublebuffer.end;
   #);
   
-- PixmapReadAlpha: doPart --
do (# result: @integer;
   do (name, @@private.handleToPixmap, @@private.pixels, 
      @@private.width, @@private.height) -> ReadPNGalpha -> result;
      (if result <> 0 then
          ' for unknown reasons.' -> error;
      if);
   #);
   
-- GraphicsCanvasOpen: doPart --
do INNER;
   &InputCanvasMethods[] -> theMethods;
   getShared -> doublebuffer[];
   15 -> updateTimer.start;
   

-- GraphicsCanvasOnRefresh: doPart --
do (# windowid, pixmapid: @integer;
      width, height: @integer;
   do (0xFFFF, 0xFFFF, 0xFFFF)  -> doublebuffer.content.clear;
      doublebuffer.begin;
      doublebuffer.push;
      (panx, pany) -> doublebuffer.translate;
      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      layers.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      doublebuffer.pop;

      THIS(Canvas).windowItemDevice -> windowid;
      doublebuffer.private.hdc -> pixmapid;
      size -> (width, height);
      (windowid, 0, 0, width, height, pixmapid, 0, 0, SRCCOPY) -> BitBlt;
      doublebuffer.end;
   #);
   
-- PixmapSurfaceInit: doPart --
do (if ANTIALIAS then
       (content.private.pixels, content.width, content.height) -> init_tables;
       init_ovals;
   if);
   

-- PixmapSurfaceDrawText: doPart --
do (if (ROTATE AND (currentStyle[] <> NONE)) then
       (# xi, yi: @integer;
          faceName: ^Text;
          weight, height: @integer;
          italic: @integer;
       do (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, 0) -> MoveToEx;
          currentStyle.name -> faceName[];
          (private.hdc, TRANSPARENT) -> SetBkMode;
          
          (currentStyle.size,(private.hdc,LOGPIXELSY)->GetDeviceCaps,72)->MulDiv
            ->height;
          FW_NORMAL->weight;
          (if currentStyle.face = textFaces.bold then FW_BOLD->weight;  if);
          (if currentStyle.face = textFaces.italic then 1->italic;  if);
          (if currentStyle.face = textFaces.italic+textFaces.bold then
              FW_BOLD->weight; 1->italic; 
          if);
          
          
          (theText, currentAngle*10, height, weight, italic > 0, faceName, private.hdc)
            -> drawRotatedText_ext1;
       #);
    else
       (# xi, yi: @integer;
       do (0, 0) -> transform -> (xi, yi);
          (private.hdc, TA_BASELINE) -> SetTextAlign;
          (private.hdc, TRANSPARENT) -> SetBkMode;
          (private.hdc, xi, yi, @@theText.T[1], theText.lgth) -> TextOut;
       #);
   if);
   
-- PixmapSurfaceDrawLine: doPart --
do (# drawSimpleLine: 
        (# 
        do start -> transform -> aamoveto;
           end -> transform -> aalineto;
        #);
      drawComplexLine:
        (# vx, vy: @real;
           x1, y1: @real;
           x2, y2: @real;
           length: @real;
           ux, uy: @real;
           outside: @PointList;
           p: ^Point2d;
           flag: @boolean;
           xr, yr: @real;
           delta: @real;
           ntPoints: [0] @integer;
           size: @integer;
           nullpen, prev: @integer;
        do strokewidth / 2 -> delta;
           start -> transform -> (x1, y1);
           end -> transform -> (x2, y2);
           x2 - x1 -> vx;
           y2 - y1 -> vy;
           vx*vx + vy*vy -> sqrt -> length;
           (if length > 0.0001 then
               (vx / length) * delta -> uy;
               - (vy / length) * delta -> ux;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 + ux -> p.x;
               y1 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 + ux -> p.x;
               y2 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 - ux -> p.x;
               y2 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               
               
              
               outside.size -> size;
               2 * size ->  ntPoints.new;
               outside.scan
               (# xi, yi: @integer;
                  i: @integer;
               do i + 1 -> i;
                  current -> (xi, yi);
                  xi -> ntPoints[(i*2)-1];
                  yi -> ntPoints[i*2];
               #);
               
               
               NULL_PEN -> GetStockObject -> nullpen;
               (private.hdc, nullpen) -> SelectObject -> prev;
               (private.hdc,@@ntPoints[1],size) -> Polygon;
               (private.hdc, prev) -> SelectObject;
               
               true -> flag;
               outside.scan
               (# xi, yi: @integer;
               do current  -> (xi, yi);
                  (if flag then
                      (xi, yi) -> aamoveto;
                      false -> flag;
                   else
                      (xi, yi) -> aalineto;
                  if);
               #);
           if);
           
        #);
   do (if strokewidth <= 1 then
          drawSimpleLine;
       else
          drawComplexLine;
      if);
   #);

-- PixmapSurfaceDrawRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFrameRect;
   #);

-- PixmapSurfaceFillRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFillRect;
   #);
   
-- PixmapSurfaceDrawOval: doPart --
do (if MICHAEL then
       (# x, y: @integer;
          w, h: @integer;
          x1, y1: @integer;
       do (0, 0) -> transform -> (x1, y1);
          width -> w;
          height -> h;
          (x1, y1, w, h) -> fill_oval;
       #);
    else
       
       (if ANTIALIAS then
           (if DRAW_MULTIPLE_OVALS then
               (# cx, cy, a, b: @real;
                  xr, yr: @real;
                  n: @integer;
                  outline: ^PointList;
                  flag: @boolean;
               do (if strokewidth > 1 then
                      strokewidth -> n;
                   else
                      1 -> n;
                  if);
                  (width/2,height/2) -> transform -> (cx, cy);
                  width / 2 - n / 2 -> a;
                  height / 2 - n / 2 -> b;
                  a - 0.5 -> a;
                  b - 0.5 -> b;
                  (for n + 1 repeat
                       (cx, cy, a, b) -> ComputeOutline -> outline[];
                       true -> flag;
                       outline.scan
                       (#
                       do current  -> (xr, yr);
                          (if flag then
                              (xr, yr) -> aamoveto;
                              false -> flag;
                           else
                              (xr, yr) -> aalineto;
                          if);
                       #);
                       a + 1 -> a;
                       b + 1 -> b;
                  for);
               #);
            else
               (# flag: @boolean;
                  xi, yi: @integer;
                  xr, yr: @real;
                  cx, cy: @integer;
                  curve: ^PointList;
                  outside, inside: ^PointList;
                  
                  delta: @real;
               do (if strokewidth  > 1 then
                      strokewidth / 2 -> delta;
                      (width/2,height/2) -> transform -> (cx, cy);
                      (cx, cy, width/2, height/2, delta) -> ComputeSplitOutline -> (inside[], outside[]);
                      
                      (# ntPoints: [0] @integer;
                         size: @integer;
                         points: ^PointList;
                         nullpen, prev: @integer;
                      do &PointList[] -> points[];
                         
                         inside.scan
                         (#
                         do current[] -> points.append;
                         #);
                         outside.scanReverse
                         (#
                         do current[] -> points.append;
                         #);
                         points.size -> size;
                         2 * size ->  ntPoints.new;
                         points.scan
                         (# xi, yi: @integer;
                            i: @integer;
                         do i + 1 -> i;
                            current  -> (xi, yi);
                            xi -> ntPoints[(i*2)-1];
                            yi -> ntPoints[i*2];
                         #);
                         NULL_PEN -> GetStockObject -> nullpen;
                         (private.hdc, nullpen) -> SelectObject -> prev;
                         (private.hdc,@@ntPoints[1],size) -> Polygon;
                         (private.hdc, prev) -> SelectObject;
                      #);
                      
                      
                      true -> flag;
                      inside.scan
                      (#
                      do current  -> (xr, yr);
                         (if flag then
                             (xr, yr) -> aamoveto;
                             false -> flag;
                          else
                             (xr, yr) -> aalineto;
                         if);
                      #);
                      
                      true -> flag;
                      outside.scan
                      (#
                      do current  -> (xr, yr);
                         (if flag then
                             (xr, yr) -> aamoveto;
                             false -> flag;
                          else
                             (xr, yr) -> aalineto;
                         if);
                         
                      #);
                   else
                      (width/2,height/2) -> transform -> (cx, cy);
                      (cx, cy, width/2+0.75, height/2+0.75) -> ComputeOutline -> inside[];
                      true -> flag;
                      inside.scan
                      (#
                      do current  -> (xr, yr);
                         (if flag then
                             (xr, yr) -> aamoveto;
                             false -> flag;
                          else
                             (xr, yr) -> aalineto;
                         if);
                      #);
                      (cx, cy, width/2, height/2) -> ComputeOutline -> inside[];
                      true -> flag;
                      inside.scan
                      (#
                      do current  -> (xr, yr);
                         (if flag then
                             (xr, yr) -> aamoveto;
                             false -> flag;
                          else
                             (xr, yr) -> aalineto;
                         if);
                      #); 
                  if);
               #);
           if);
        else
           (# nullbrush: @integer;
              prev: @integer;
              xi, yi: @integer;
           do NULL_BRUSH  -> GetStockObject -> nullbrush;
              (private.hdc, nullbrush) -> SelectObject -> prev;
              (0, 0) -> transform -> (xi, yi);
              (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
              (private.hdc, prev) -> SelectObject;
           #);
       if);
   if);
-- PixmapSurfaceFillOval: doPart --
do (if MICHAEL   then
       (# x, y: @integer;
          w, h: @integer;
          x1, y1: @integer;
       do (0, 0) -> transform -> (x1, y1);
          x1 + strokewidth -> x1;
          y1 + strokewidth -> y1;
          
          (width / 2, height / 2) -> transform -> (x, y);
          width - 2*strokewidth -> w;
          height - 2*strokewidth -> h;
          (x1, y1, w, h) -> fill_oval;
       #);
    else
       
       (if ANTIALIAS then
           (# flag: @boolean;
              xi, yi: @integer;
              xr, yr: @real;
              cx, cy: @real;
              curve: ^PointList;
              ntPoints: [0] @integer;
              size: @integer;
              nullpen, prev: @integer;
           do (width/2,height/2) -> transform -> (cx, cy);
              cx + 0.5 -> cx;
              cy + 0.5 -> cy;
              (cx, cy, width/2 - (strokewidth + 1) / 2 , height/2 - (strokewidth + 1)/ 2) -> ComputeOutline -> curve[];
              curve.size -> size;
              2 * size ->  ntPoints.new;
              curve.scan
              (# xi, yi: @integer;
                 i: @integer;
              do i + 1 -> i;
                 current -> (xi, yi);
                 xi -> ntPoints[(i*2)-1];
                 yi -> ntPoints[i*2];
              #);
              NULL_PEN -> GetStockObject -> nullpen;
              (private.hdc, nullpen) -> SelectObject -> prev;
              (private.hdc,@@ntPoints[1],size) -> Polygon;
              (private.hdc, prev) -> SelectObject;
           #);
        else
           (# nullpen: @integer;
              prev: @integer;
              xi, yi: @integer;
           do NULL_PEN -> GetStockObject -> nullpen;
              (private.hdc, nullpen) -> SelectObject -> prev;
              (0, 0) -> transform -> (xi, yi);
              (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
              (private.hdc, prev) -> SelectObject;
           #);
       if);
   if);
-- PixmapSurfaceDrawPolygon: doPart --
do (# flag: @boolean;
      xi, yi: @integer;
   do true -> flag;
      points.scan
      (#
      do current -> transform -> (xi, yi);
         (if flag then
             (private.hdc, xi, yi, 0) -> MoveToEx;
             false -> flag;
          else
             (private.hdc, xi, yi) -> LineTo;
         if);
      #);
   #);
   
-- PixmapSurfaceFillPolygon: doPart --
do (# flag: @boolean;
      xr, yr: @real;
      fx, fy: @real;
   do true -> flag;
      points.scan
      (#
      do current -> transform -> (xr, yr);
         (if flag then
             (xr, yr) -> aamoveto;
             (xr, yr) -> (fx, fy);
             false -> flag;
          else
             (xr, yr) -> aalineto;
         if);
      #);
      (fx, fy) -> aalineto;
    #);
   
   
   (# ntPoints: [0] @integer;
      size: @integer;
   do points.size -> size;
      2 * size ->  ntPoints.new;
      points.scan
      (# xi, yi: @integer;
         i: @integer;
      do i + 1 -> i;
         current -> transform -> (xi, yi);
         xi -> ntPoints[(i*2)-1];
         yi -> ntPoints[i*2];
      #);
      (private.hdc,@@ntPoints[1],size) -> Polygon;
   #);
   
-- PixmapSurfaceDrawPixmap: doPart --
do (# x, y: @integer;
      hdcmem: @integer;
      oldbmp: @integer;
   do 
      (0, 0) -> transform -> (x, y);
      
      (if thePixmap.private.pixels <> 0 then
          (thePixmap.private.pixels, thePixmap.width * 4, 
          content.private.pixels, content.width * 4,  x, 
          content.height - y - thePixmap.height, 
          thePixmap.width, thePixmap.height)
            -> TransferRedPixels;
       else
          
          private.hdc -> CreateCompatibleDC -> hdcmem;
          (hdcmem, thePixmap.private.handleToPixmap) -> SelectObject -> oldbmp;
          (private.hdc, x, y, thePixmap.width, thePixmap.height, hdcmem, 0, 0, SRCCOPY) -> BitBlt;
          (hdcmem, oldbmp) -> SelectObject;
          hdcmem -> DeleteDC;
      if);

   #);
   

-- PixmapSurfaceStyle: doPart --
do theStyle[] -> currentStyle[];
   
-- PixmapSurfaceAngle: doPart --
do theAngle -> currentAngle;

-- PixmapSurfacePen: doPart --
do (# red, green, blue: @int8u;
      colorref: @int32u;
      
   do theColor.red %srl 8 -> red;
      theColor.green %srl 8 -> green;
      theColor.blue %srl 8 -> blue;
      
      (if ANTIALIAS then
          (blue / 255, green / 255, red / 255) -> aapen;
          (blue / 255, green / 255, red / 255) -> ovalpen;
      if);
      
      
      red %bor (green %sll 8) %bor (blue %sll 16) -> colorref;
      (private.hdc, colorref) -> SetTextColor;
      colorref -> CreateSolidBrush -> private.brush;
      (private.hdc, private.brush) -> SelectObject -> DeleteObject;
      (PS_SOLID, 0, colorref) -> CreatePen -> private.pen;
      (private.hdc, private.pen) -> SelectObject -> DeleteObject;
      
   #);

-- PixmapSurfacePush: doPart --
do (# new: ^Matrix;
   do &Matrix[] -> new[];
      private.current.x -> new.x;
      private.current.y -> new.y;
      private.current[] -> new.next[];
      new[] -> private.current[];
   #);

-- PixmapSurfacePop: doPart --
do private.current.next[] -> private.current[];

-- PixmapSurfaceTranslate: doPart --
do private.current.x + dx -> private.current.x;
   private.current.y + dy -> private.current.y;
   
-- PixmapSurfaceBegin: doPart --
do &Matrix[] -> private.current[];
   0 -> CreateCompatibleDC -> private.hdc;
   (private.hdc, content.private.handleToPixmap) -> SelectObject -> private.old_dib;
   0 -> CreateSolidBrush -> private.brush;
   (private.hdc, private.brush) -> SelectObject -> private.old_brush;
   (PS_SOLID, 0, 0) -> CreatePen -> private.pen;
   (private.hdc, private.pen) -> SelectObject -> private.old_pen;
   
-- PixmapSurfaceEnd: doPart --
do (private.hdc, private.old_dib) -> SelectObject;
   (private.hdc, private.old_brush) -> SelectObject -> DeleteObject;
   (private.hdc, private.old_pen) -> SelectObject -> DeleteObject;
   private.hdc -> DeleteDC;
   
   
-- PixmapSurfaceLib: attributes --


plotpixel: external
  (# x, y, color: @integer;
  enter (x, y, color)
  #);


Matrix:
  (# next: ^Matrix;
     x, y: @real;
  #);

transform:
  (# x, y: @real;
  enter (x, y)
  do private.current.x + x -> x;
     private.current.y + y -> y;
  exit (x, y)
  #);

ntFillRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FillRect' -> callStd;
  exit result
  #);
ntFrameRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FrameRect' -> callStd;
  exit result
  #);



-- PixmapSurfacePrivate: descriptor --
(# hdc: @integer;
   brush: @integer;
   pen: @integer;
   old_dib: @integer;
   old_brush: @integer;
   old_pen: @integer;
   current: ^Matrix;
#)


-- TextItemLib: attributes --

MyCreateFont_ext: external
  (#
     angle: @integer;
     height,faceName: @integer;
     weight: @integer;
     italic: @integer;
     hdc: @integer;
     hFont: @integer;
     
  enter (angle,height,weight,italic,faceName,hdc)
  do callC
  exit hFont
  #);

(* In GUIEnv you cannot set the text angle
 * therefore we have to create an extra font with the 
 * correct angle, otherwise we cannot calculate size of the
 * label.
 *)
createActualFont:
  (# hdc,height,weight,italic: @integer; faceNameCstr: @Cstring; 
     hActualFont: @integer;
  do
     
     (if (style[] <> none ) and (angle <> 0) then
         0->GetDC->hdc;
         (style.size,(hdc,LOGPIXELSY)->GetDeviceCaps,72)->MulDiv
           ->height;
         style.name->faceNameCstr.set;
         FW_NORMAL->weight;
         (if style.face = textFaces.bold then FW_BOLD->weight;  if);
         (if style.face = textFaces.italic then 1->italic;  if);
         (if style.face = textFaces.italic+textFaces.bold then
             FW_BOLD->weight; 1->italic; 
         if);
         (angle,height,weight,italic,faceNameCstr,hdc)->MyCreateFont_ext
           ->hActualFont;
         (0,hdc)->ReleaseDC;
         (if faceNameCstr <> 0 then faceNameCstr.free;  if);
         
     if);
  exit hActualFont 
  #);
disposeActualFont:
  (# hActualFont: @integer;
  enter hActualFont
  do
     (if hActualFont <> 0 then
         hActualFont->DeleteObject; 0->hActualFont; 
     if);
     
  #);
useActualTextStyle:
  (# dc: @integer; saved: @integer; infoPtr: @integer; 
     hActualFont: @integer;
  do
     createActualFont -> hActualFont;
     56->malloc->infoPtr;
     0->GetDC->dc;
     (if hActualFont <> 0 then
         (dc,hActualFont)->SelectObject->saved; 
      else
         (dc,style.textStyleID)->SelectObject->saved; 
     if);
     (dc,infoPtr)->GetTextMetrics;
     INNER ;
     hActualFont -> disposeActualFont;
     (dc,saved)->SelectObject;
     (0,dc)->ReleaseDC;
     infoPtr->free;
     
  #);

getActualFontHeight: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmHeightOffset->tos'%adrGetLong'->value; 
  exit value
  #);
getActualFontAscent: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmAscentOffset->tos'%adrGetLong'->value; 
  exit value
  #);
getActualFontDescent: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmDescentOffset->tos'%adrGetLong'->value; 
  exit value
  #);
getActualFontExternalLeading: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmExternalLeadingOffset->tos'%adrGetLong'->value; 
  exit value
  #);

-- TextItemOutline: doPart --
do (# pt: @point;
      points: [4] ^point;
      (* private *)
      tempPoint: @Point;
      res: @real;
      cosAngle,sinAngle,lhcos2,lhsin2,xr,yr,vx,vy,ux,uy:
        @real;
      w: @integer;
      tempText: ^Text;
      noOfNewLines: @integer;
      fontHeight,fontAscent,fontDescent,xFontDescent,
      yFontDescent,externalLeading: @integer;
      q: ^Point2d;
   do (x, y) -> pt;
      (if content[] <> none then
          (for i: 4 repeat &point[]->points[i][];  for);
          content[]->style.widthOfText->w;
          (((- angle)*pi) / 180)->res;
          res->cos->cosAngle;
          (w*cosAngle)->lhcos2;
          res->sin->sinAngle;
          (w*sinAngle)->lhsin2;
          pt->tempPoint;
          tempPoint->points[1];
          tempPoint.h+lhcos2->points[2].h;
          tempPoint.v+lhsin2->points[2].v;
          content[]->tempText[];
          tempText.scanall
          (# 
          do (if ch = ascii.nl then noOfNewLines+1->noOfNewLines;  if); 
          #);
          getActualFontAscent->fontAscent;
          cosAngle*fontAscent->xr;
          sinAngle*fontAscent->yr;
          points[2].h+yr->points[3].h;
          points[2].v-xr->points[3].v;
          points[1].h+yr->points[4].h;
          points[1].v-xr->points[4].v;
          getActualFontDescent->fontDescent;
          (if ((fontDescent = 0) or (angle <> 0)) and
              ('marlett'->(style.name).equalNCS) then
              (* this is symbol font. Actually it should not be used but you can
               * select it from the font dialog so we try to handle it. It is a problem
               * because the descent is set to zero so we have to guess.
               *)
              getActualFontHeight->fontHeight;
              fontHeight / 6+1->fontDescent;
              (if fontDescent = 0 then 4->fontDescent;  if);
              
          if);
          cosAngle*fontDescent->xFontDescent;
          sinAngle*fontDescent->yFontDescent;
          points[1].h-yFontDescent->points[1].h;
          points[1].v+xFontDescent->points[1].v;
          points[2].h-yFontDescent->points[2].h;
          points[2].v+xFontDescent->points[2].v;
          (if noOfNewLines > 0 then
              getActualFontHeight->fontHeight;
              getActualFontExternalLeading->externalLeading;
              cosAngle*fontHeight+externalLeading->xr;
              sinAngle*fontHeight+externalLeading->yr;
              points[1].h-(yr*noOfNewLines)->points[1].h;
              points[1].v+(xr*noOfNewLines)->points[1].v;
              points[2].h-(yr*noOfNewLines)->points[2].h;
              points[2].v+(xr*noOfNewLines)->points[2].v;
              
          if);
          
      if);
      (for inx: points.range repeat
           &Point2d[] -> q[];
           points[inx] -> q;
           q[] -> THIS(outline).points.append;
      for);
   #);
   
-- TextItemContainsPoint: doPart --
do 
   x + THIS(Item).x -> x;
   y + THIS(Item).y -> y;
   (if ((outline,(x,y))->isPointInRegion) then
       THIS(TextItem)[] -> target[];
   if);
