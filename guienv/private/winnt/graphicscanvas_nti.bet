ORIGIN '../graphicscanvasbody';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/win32lib/bitmapsupport';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/wingdi';
INCLUDE '~beta/win32lib/wingdiconsts';
INCLUDE '~beta/win32lib/dcmanagement';
INCLUDE '~beta/guienv/graphics';
INCLUDE '~beta/basiclib/math';
INCLUDE '~beta/toollibs/utils/PNG/png';

BUILD nti '$$/aadraw.obj' 'external/aadraw.c' 'betacc $0 $1';

-- lib: attributes --
ReadPNGalpha: external
  (# name: [1] @char;
     hbmp: @integer;
     pixels: @integer;
     width: @integer;
     height: @integer;
     result: @integer;
  enter (name, hbmp, pixels, width, height)
  exit result
  #);

init_tables: external
  (# buffer: @int32u;
     width, height: @integer;
  enter (buffer, width, height)
  #);
aamoveto: external
  (# x, y: @real;
  enter (x, y)
  #);
aalineto: external
  (# x, y: @real;
  enter (x, y)
  #);
aapen: external
  (# red, green, blue: @real;
  enter (red, green, blue)
  #);

TransferRedPixels: external
  (# src, dst: @integer;
     srcrowbytes, dstrowbytes: @integer;
     x, y: @integer;
     width, height: @integer;
  enter (src, srcrowbytes, dst, dstrowbytes, x, y, width, height)
  #);


ANTIALIAS: (# exit true #);
DRAW_MULTIPLE_OVALS: (# exit true #);


-- GraphicsCanvasLib: attributes --

InputCanvasMethods: WindowItemMethods
  (# count: @integer;
     
     dispatchMessage::<
       (# 
          x, y: @integer;
          clrbkgnd:@boolean;
       do false->clrbkgnd;
	  (if info.message=WM_ERASEBKGND then
              true->info.handled;
	  if);
          (if info.message = WM_MOUSEMOVE then
              (info.lParam.loWord,info.lParam.hiWord) 
                -> (x, y);
              (if current[] <> NONE then
                  (x, y) -> current.onMouseMove;
              if);
          if);
          INNER;
       #);
  #);

-- SurfaceLib: attributes --
ComputeOutline:
  (# x, y: @real;
     a, b: @real;
     outline: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 10 #);
     number: (# exit 36 #);
  enter (x, y, a, b)
  do &PointList[] -> outline[];
     (for number repeat
          (degree / 180) * PI -> angle;
          &Point2d[] -> p[];
          x + (angle -> cos)*a -> p.x;
          y + (angle -> sin)*b -> p.y;
          p[] -> outline.append;
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*a -> p.x;
     y + (0 -> sin)*b -> p.y;
     p[] -> outline.append;
  exit outline[]
  #);
ComputeSplitOutline:
  (# x, y: @real;
     a, b: @real;
     outside, inside: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 5 #);
     number: (# exit 72 #);
     delta: @real;
     cosa, sina: @real;
  enter (x, y, a, b, delta)
  do &PointList[] -> outside[];
     &PointList[] -> inside[];
     
     (for number repeat
          (degree / 180) * PI -> angle;
          angle -> cos -> cosa;
          angle -> sin -> sina;
          
          &Point2d[] -> p[];
          x + cosa*(a+delta) -> p.x;
          y + sina*(b+delta) -> p.y;
          p[] -> outside.append;
          
          &Point2d[] -> p[];
          x + cosa*(a-delta) -> p.x;
          y + sina*(b-delta) -> p.y;
          p[] -> inside.append;
          
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*(a+delta) -> p.x;
     y + (0 -> sin)*(b+delta) -> p.y;
     p[] -> outside.append;
     &Point2d[] -> p[];
     x + (0 -> cos)*(a-delta) -> p.x;
     y + (0 -> sin)*(b-delta) -> p.y;
     p[] -> inside.append;
  exit (inside[], outside[])
  #);

-- PixmapReadAlpha: doPart --
do (# result: @integer;
   do (name, @@private.handleToPixmap, @@private.pixels, 
      @@private.width, @@private.height) -> ReadPNGalpha -> result;
      (if result <> 0 then
          ' for unknown reasons.' -> error;
      if);
   #);
   

-- GraphicsCanvasOpen: doPart --
do INNER;
   &InputCanvasMethods[] -> theMethods;
   getShared -> doublebuffer[];
   

-- GraphicsCanvasOnRefresh: doPart --
do (# windowid, pixmapid: @integer;
      width, height: @integer;
   do (0xFFFF, 0xFFFF, 0xFFFF)  -> doublebuffer.content.clear;
      doublebuffer.begin;
      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      layers.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      THIS(Canvas).windowItemDevice -> windowid;
      doublebuffer.private.hdc -> pixmapid;
      size -> (width, height);
      (windowid, 0, 0, width, height, pixmapid, 0, 0, SRCCOPY) -> BitBlt;
      doublebuffer.end;
   #);
   
-- PixmapSurfaceInit: doPart --
do (if ANTIALIAS then
       (content.private.pixels, content.width, content.height) -> init_tables;
   if);
   

-- PixmapSurfaceDrawText: doPart --
do (# xi, yi: @integer;
   do (0, 0) -> transform -> (xi, yi);
      (private.hdc, TA_BASELINE) -> SetTextAlign;
      (private.hdc, TRANSPARENT) -> SetBkMode;
      (private.hdc, xi, yi, @@theText.T[1], theText.lgth) -> TextOut;
   #);
   
-- PixmapSurfaceDrawLine: doPart --
do (# drawSimpleLine: 
        (# 
        do start -> transform -> aamoveto;
           end -> transform -> aalineto;
        #);
      drawComplexLine:
        (# vx, vy: @real;
           x1, y1: @real;
           x2, y2: @real;
           length: @real;
           ux, uy: @real;
           outside: @PointList;
           p: ^Point2d;
           flag: @boolean;
           xr, yr: @real;
           delta: @real;
           ntPoints: [0] @integer;
           size: @integer;
           nullpen, prev: @integer;
        do strokewidth / 2 -> delta;
           start -> transform -> (x1, y1);
           end -> transform -> (x2, y2);
           x2 - x1 -> vx;
           y2 - y1 -> vy;
           vx*vx + vy*vy -> sqrt -> length;
           (if length > 0.0001 then
               (vx / length) * delta -> uy;
               - (vy / length) * delta -> ux;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 + ux -> p.x;
               y1 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 + ux -> p.x;
               y2 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 - ux -> p.x;
               y2 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               
               
               outside.size -> size;
               2 * size ->  ntPoints.new;
               outside.scan
               (# xi, yi: @integer;
                  i: @integer;
               do i + 1 -> i;
                  current -> (xi, yi);
                  xi -> ntPoints[(i*2)-1];
                  yi -> ntPoints[i*2];
               #);
               
               
               NULL_PEN -> GetStockObject -> nullpen;
               (private.hdc, nullpen) -> SelectObject -> prev;
               (private.hdc,@@ntPoints[1],size) -> Polygon;
               (private.hdc, prev) -> SelectObject;
               
               true -> flag;
               outside.scan
               (# xi, yi: @integer;
               do current  -> (xi, yi);
                  (if flag then
                      (xi, yi) -> aamoveto;
                      false -> flag;
                   else
                      (xi, yi) -> aalineto;
                  if);
               #);
              
           if);
           
        #);
   do (if strokewidth <= 1 then
          drawSimpleLine;
       else
          drawComplexLine;
      if);
   #);

-- PixmapSurfaceDrawRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFrameRect;
   #);

-- PixmapSurfaceFillRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFillRect;
   #);
   
-- PixmapSurfaceDrawOval: doPart --
do (if ANTIALIAS then
       (if DRAW_MULTIPLE_OVALS then
           (# cx, cy, a, b: @real;
              xr, yr: @real;
              n: @integer;
              outline: ^PointList;
              flag: @boolean;
           do (if strokewidth > 1 then
                  strokewidth -> n;
               else
                  1 -> n;
              if);
              (width/2,height/2) -> transform -> (cx, cy);
              width / 2 - n / 2 -> a;
              height / 2 - n / 2 -> b;
              a - 0.5 -> a;
              b - 0.5 -> b;
              (for n + 1 repeat
                   (cx, cy, a, b) -> ComputeOutline -> outline[];
                   true -> flag;
                   outline.scan
                   (#
                   do current  -> (xr, yr);
                      (if flag then
                          (xr, yr) -> aamoveto;
                          false -> flag;
                       else
                          (xr, yr) -> aalineto;
                      if);
                   #);
                   a + 1 -> a;
                   b + 1 -> b;
              for);
           #);
        else
           (# flag: @boolean;
              xi, yi: @integer;
              xr, yr: @real;
              cx, cy: @integer;
              curve: ^PointList;
              outside, inside: ^PointList;
              
              delta: @real;
           do (if strokewidth  > 1 then
                  strokewidth / 2 -> delta;
                  (width/2,height/2) -> transform -> (cx, cy);
                  (cx, cy, width/2, height/2, delta) -> ComputeSplitOutline -> (inside[], outside[]);
                  
                  (# ntPoints: [0] @integer;
                     size: @integer;
                     points: ^PointList;
                     nullpen, prev: @integer;
                  do &PointList[] -> points[];
                     
                     inside.scan
                     (#
                     do current[] -> points.append;
                     #);
                     outside.scanReverse
                     (#
                     do current[] -> points.append;
                     #);
                     points.size -> size;
                     2 * size ->  ntPoints.new;
                     points.scan
                     (# xi, yi: @integer;
                        i: @integer;
                     do i + 1 -> i;
                        current  -> (xi, yi);
                        xi -> ntPoints[(i*2)-1];
                        yi -> ntPoints[i*2];
                     #);
                     NULL_PEN -> GetStockObject -> nullpen;
                     (private.hdc, nullpen) -> SelectObject -> prev;
                     (private.hdc,@@ntPoints[1],size) -> Polygon;
                     (private.hdc, prev) -> SelectObject;
                  #);
                  
                  
                  true -> flag;
                  inside.scan
                  (#
                  do current  -> (xr, yr);
                     (if flag then
                         (xr, yr) -> aamoveto;
                         false -> flag;
                      else
                         (xr, yr) -> aalineto;
                     if);
                  #);
                  
                  true -> flag;
                  outside.scan
                  (#
                  do current  -> (xr, yr);
                     (if flag then
                         (xr, yr) -> aamoveto;
                         false -> flag;
                      else
                         (xr, yr) -> aalineto;
                     if);
                     
                  #);
               else
                  (width/2,height/2) -> transform -> (cx, cy);
                  (cx, cy, width/2+0.75, height/2+0.75) -> ComputeOutline -> inside[];
                  true -> flag;
                  inside.scan
                  (#
                  do current  -> (xr, yr);
                     (if flag then
                         (xr, yr) -> aamoveto;
                         false -> flag;
                      else
                         (xr, yr) -> aalineto;
                     if);
                  #);
                  (cx, cy, width/2, height/2) -> ComputeOutline -> inside[];
                  true -> flag;
                  inside.scan
                  (#
                  do current  -> (xr, yr);
                     (if flag then
                         (xr, yr) -> aamoveto;
                         false -> flag;
                      else
                         (xr, yr) -> aalineto;
                     if);
                  #); 
              if);
           #);
       if);
    else
       (# nullbrush: @integer;
          prev: @integer;
          xi, yi: @integer;
       do NULL_BRUSH  -> GetStockObject -> nullbrush;
          (private.hdc, nullbrush) -> SelectObject -> prev;
          (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
          (private.hdc, prev) -> SelectObject;
       #);
   if);
-- PixmapSurfaceFillOval: doPart --
do (if ANTIALIAS then
       (# flag: @boolean;
          xi, yi: @integer;
          xr, yr: @real;
          cx, cy: @real;
          curve: ^PointList;
          ntPoints: [0] @integer;
          size: @integer;
          nullpen, prev: @integer;
       do (width/2,height/2) -> transform -> (cx, cy);
          cx + 0.5 -> cx;
          cy + 0.5 -> cy;
          (cx, cy, width/2 - (strokewidth + 1) / 2 , height/2 - (strokewidth + 1)/ 2) -> ComputeOutline -> curve[];
          curve.size -> size;
          2 * size ->  ntPoints.new;
          curve.scan
          (# xi, yi: @integer;
             i: @integer;
          do i + 1 -> i;
             current -> (xi, yi);
             xi -> ntPoints[(i*2)-1];
             yi -> ntPoints[i*2];
          #);
          NULL_PEN -> GetStockObject -> nullpen;
          (private.hdc, nullpen) -> SelectObject -> prev;
          (private.hdc,@@ntPoints[1],size) -> Polygon;
          (private.hdc, prev) -> SelectObject;
       #);
    else
       (# nullpen: @integer;
          prev: @integer;
          xi, yi: @integer;
       do NULL_PEN -> GetStockObject -> nullpen;
          (private.hdc, nullpen) -> SelectObject -> prev;
          (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
          (private.hdc, prev) -> SelectObject;
       #);
   if);

-- PixmapSurfaceDrawPolygon: doPart --
do (# flag: @boolean;
      xi, yi: @integer;
   do true -> flag;
      points.scan
      (#
      do current -> transform -> (xi, yi);
         (if flag then
             (private.hdc, xi, yi, 0) -> MoveToEx;
             false -> flag;
          else
             (private.hdc, xi, yi) -> LineTo;
         if);
      #);
   #);
   
-- PixmapSurfaceFillPolygon: doPart --
do (# ntPoints: [0] @integer;
      size: @integer;
   do points.size -> size;
      2 * size ->  ntPoints.new;
      points.scan
      (# xi, yi: @integer;
         i: @integer;
      do i + 1 -> i;
         current -> transform -> (xi, yi);
         xi -> ntPoints[(i*2)-1];
         yi -> ntPoints[i*2];
      #);
      (private.hdc,@@ntPoints[1],size) -> Polygon;
   #);
   
-- PixmapSurfaceDrawPixmap: doPart --
do (# x, y: @integer;
      hdcmem: @integer;
      oldbmp: @integer;
   do 'transfering...' -> putline;
      (0, 0) -> transform -> (x, y);
      
      (if thePixmap.private.pixels <> 0 then
          (thePixmap.private.pixels, thePixmap.width * 4, 
          content.private.pixels, content.width * 4,  x, 
          content.height - y - thePixmap.height, 
          thePixmap.width, thePixmap.height)
            -> TransferRedPixels;
       else
          '-- using old ways' -> putline;
          private.hdc -> CreateCompatibleDC -> hdcmem;
          (hdcmem, thePixmap.private.handleToPixmap) -> SelectObject -> oldbmp;
          (private.hdc, x, y, thePixmap.width, thePixmap.height, hdcmem, 0, 0, SRCCOPY) -> BitBlt;
          (hdcmem, oldbmp) -> SelectObject;
          hdcmem -> DeleteDC;
      if);
   #);
   

-- PixmapSurfaceStyle: doPart --
do
   

-- PixmapSurfacePen: doPart --
do (# red, green, blue: @int8u;
      colorref: @int32u;
      
   do theColor.red %srl 8 -> red;
      theColor.green %srl 8 -> green;
      theColor.blue %srl 8 -> blue;
      
      (if ANTIALIAS then
          (blue / 255, green / 255, red / 255) -> aapen;
      if);
      
      red %bor (green %sll 8) %bor (blue %sll 16) -> colorref;
      (private.hdc, colorref) -> SetTextColor;
      colorref -> CreateSolidBrush -> private.brush;
      (private.hdc, private.brush) -> SelectObject -> DeleteObject;
      (PS_SOLID, 0, colorref) -> CreatePen -> private.pen;
      (private.hdc, private.pen) -> SelectObject -> DeleteObject;
      
   #);

-- PixmapSurfacePush: doPart --
do (# new: ^Matrix;
   do &Matrix[] -> new[];
      private.current.x -> new.x;
      private.current.y -> new.y;
      private.current[] -> new.next[];
      new[] -> private.current[];
   #);

-- PixmapSurfacePop: doPart --
do private.current.next[] -> private.current[];

-- PixmapSurfaceTranslate: doPart --
do private.current.x + dx -> private.current.x;
   private.current.y + dy -> private.current.y;
   
-- PixmapSurfaceBegin: doPart --
do &Matrix[] -> private.current[];
   0 -> CreateCompatibleDC -> private.hdc;
   (private.hdc, content.private.handleToPixmap) -> SelectObject -> private.old_dib;
   0 -> CreateSolidBrush -> private.brush;
   (private.hdc, private.brush) -> SelectObject -> private.old_brush;
   (PS_SOLID, 0, 0) -> CreatePen -> private.pen;
   (private.hdc, private.pen) -> SelectObject -> private.old_pen;
   
-- PixmapSurfaceEnd: doPart --
do (private.hdc, private.old_dib) -> SelectObject;
   (private.hdc, private.old_brush) -> SelectObject -> DeleteObject;
   (private.hdc, private.old_pen) -> SelectObject -> DeleteObject;
   private.hdc -> DeleteDC;
   
   
-- PixmapSurfaceLib: attributes --

Matrix:
  (# next: ^Matrix;
     x, y: @real;
  #);

transform:
  (# x, y: @real;
  enter (x, y)
  do private.current.x + x -> x;
     private.current.y + y -> y;
  exit (x, y)
  #);

ntFillRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FillRect' -> callStd;
  exit result
  #);
ntFrameRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FrameRect' -> callStd;
  exit result
  #);



-- PixmapSurfacePrivate: descriptor --
(# hdc: @integer;
   brush: @integer;
   pen: @integer;
   old_dib: @integer;
   old_brush: @integer;
   old_pen: @integer;
   current: ^Matrix;
#)
