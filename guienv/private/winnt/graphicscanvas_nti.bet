ORIGIN '../graphicscanvasbody';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/win32lib/bitmapsupport';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/wingdi';
INCLUDE '~beta/win32lib/wingdiconsts';
INCLUDE '~beta/win32lib/devicecapabilities';
INCLUDE '~beta/win32lib/dcmanagement';
INCLUDE '~beta/win32lib/windowsmisc';
INCLUDE '~beta/guienv/graphics';
INCLUDE '~beta/basiclib/math';
INCLUDE '~beta/sysutils/cstring';
INCLUDE '~beta/toollibs/utils/PNG/png';

BUILD nti '$$/aadraw.obj' 'external/aadraw.c' 'betacc $0 $1';
BUILD nti '$$/rotatetext.obj' 'external/rotatetext.cpp' 'betacc $0 $1';


BUILD nti '$$/ovalfill.obj' 'external/ovalfill.c' 'betacc $0 $1';
BUILD nti '$$/imageprocessing.obj' 'external/imageprocessing.c' 'betacc $0 $1';


-- lib: attributes --
WM_MOUSEWHEEL: (# exit                   0x020A #);
MK_XBUTTON1: (# exit         0x0020 #);
MK_XBUTTON2: (# exit         0x0040 #);

WeimanExpansionOut: external
  (# src, src_width, src_height: @integer;
     dst, dst_width, dst_height: @integer;
     p, q: @integer;
  enter (src, src_width, src_height, dst, dst_width, dst_height, p, q)
  #);
WeimanExpansionIn: external
  (# src, src_width, src_height: @integer;
     dst, dst_width, dst_height: @integer;
     p, q: @integer;
  enter (src, src_width, src_height, dst, dst_width, dst_height, p, q)
  #);
WeimanExpansionOutVert: external
  (# src, src_width, src_height: @integer;
     dst, dst_width, dst_height: @integer;
     p, q: @integer;
  enter (src, src_width, src_height, dst, dst_width, dst_height, p, q)
  #);
WeimanExpansionInVert: external
  (# src, src_width, src_height: @integer;
     dst, dst_width, dst_height: @integer;
     p, q: @integer;
  enter (src, src_width, src_height, dst, dst_width, dst_height, p, q)
  #);

write_pixels_to_png: external
  (# pixels: @int32u;
     width: @int32;
     height: @int32;
     filename: [1] @char;
  enter (pixels, width, height, filename)
  #);
write_pixels_to_png_area: external
  (# pixels: @int32u;
     x: @int32;
     y: @int32;
     width: @int32;
     height: @int32;
     filename: [1] @char;
  enter (pixels, x, y, width, height, filename)
  #);
write_pixels_to_png_area_rgb: external
  (# pixels: @int32u;
     x: @int32;
     y: @int32;
     width: @int32;
     height: @int32;
     filename: [1] @char;
  enter (pixels, x, y, width, height, filename)
  #);

ROTATE: (# exit true #);

drawRotatedText_ext1: external
  (# theText: [1]@char;
     angle: @integer;
     height: @integer;
     weight: @integer;
     italic: @boolean;
     facename: [1]@char;
     hdc: @integer;
  enter (theText, angle, height, weight, italic, facename, hdc)
  #);

ReadPNGalpha: external
  (# name: [1] @char;
     hbmp: @integer;
     pixels: @integer;
     width: @integer;
     height: @integer;
     result: @integer;
  enter (name, hbmp, pixels, width, height)
  exit result
  #);

init_tables: external
  (# buffer: @int32u;
     width, height: @integer;
  enter (buffer, width, height)
  #);
aamoveto: external
  (# x, y: @real;
  enter (x, y)
  #);
aalineto: external
  (# x, y: @real;
  enter (x, y)
  #);
aapen: external
  (# red, green, blue: @real;
  enter (red, green, blue)
  #);
ovalpen: external
  (# red, green, blue: @real;
  enter (red, green, blue)
  #);

TransferRedPixels: external
  (# src, dst: @integer;
     srcrowbytes, dstrowbytes: @integer;
     x, y: @integer;
     width, height: @integer;
     winwidth, winheight: @integer;
  enter (src, srcrowbytes, dst, dstrowbytes, x, y, width, height, winwidth, winheight)
  #);


MICHAEL: (# exit true #);

DRAW_MULTIPLE_OVALS: (# exit true #);



init_ovals: external
  (#
  #);
oval_limit: external
  (# limit: @integer;
  enter limit
  #);
fill_oval: external
  (# x, y, width, height: @integer;
  enter (x, y, width, height)
  #);
-- GraphicsCanvasLib: attributes --



isPointInRegion: booleanValue
  (#
     win32Points: [8] @Integer;
     theNtRect: @ntRECTextR;
     regionHandle: @integer;
     counter: @integer;
     noOfPoints: @integer;
     points: ^PointList;
     ptIn: @Point;
     
  enter (points[],ptIn)
  do
     (if (2*points.size) > win32Points.range then
         (2*points.size)-win32Points.range->win32Points.extend; 
     if);
     0->counter;
     points.scan
       (# 
       do
          counter+1->counter;
          current.x->win32Points[(counter*2)-1];
          current.y->win32Points[counter*2];
          
       #);
     points.size->noOfPoints;
     (@@ win32Points[1],noOfPoints,WINDING)->CreatePolygonRgn->regionHandle;
     (if regionHandle <> 0 then
         (((regionHandle,ptIn.h,ptIn.v)->PtInRegion) <> 0)->value;
         regionHandle->DeleteObject;
         0->regionHandle;
     if);
     
  #);

InputCanvasMethods: WindowItemMethods
  (# 
     
     dispatchMessage::<
       (# x, y: @integer;
          clrbkgnd:@boolean;
       do false->clrbkgnd;
	  (if info.message=WM_ERASEBKGND then
              true->info.handled;
	  if);
          (if info.message = WM_MOUSEMOVE then
              (info.lParam.loWord,info.lParam.hiWord) 
                -> (x, y);
              ((info.lParam.loWord,info.lParam.hiWord), info.where, info.button, doubleClickPossible, (VK_SHIFT -> isVKeyDown), (VK_CONTROL -> isVKeyDown), GetMessageTime)
                -> theEventHandler.onMouseMove;
          if);
          
          (if info.message = WM_SYSCHAR then
              (* Test bit 29 of lParam *)
              (if ((info.lParam %Band 1000000)<>0) then
                  (* The ALT key is down while the key is released 
                   * Return zero, otherwise we get a default beep.
                   *)
                  true -> info.handled;
                  0 -> info.result;
              if)
          if);
          (if info.message = WM_SYSKEYUP then
              (* Test bit 29 of lParam *)
              (if ((info.lParam %Band 1000000)<>0) then
                  (* The ALT key is down while the key is released *)
                  info.wParam->THIS(GraphicsCanvas).theEventHandler.onSystemKeyUp
                    ->info.handled;
                  (if info.handled then
                      0 -> info.result;
                  if);
              if)
          if);
          
          (if info.message = WM_MOUSEWHEEL then
              (# longInt: @CStruct
                   (# ByteSize::  (#  do 4->Value;  #);
                      loWord: signedShort (# Pos::  (#  do 0->Value;  #);  #);
                      hiWord: signedShort (# Pos::  (#  do 2->Value;  #);  #);
                   enter R[1]
                   exit R[1]
                   #);
                 zDelta: @int16;
                 fwKeys: @int16;
                 globalPosition: @Point;
                 button: @integer;
                 shiftKey, controlKey: @boolean;
                 
                 bitComp: 
                   (# style: @integer;
                      mask: @integer;
                   enter (style, mask)
                   do style %Band (%Bnot mask) -> style;
                   exit style
                   #);
              do
                 info.wParam -> longInt;
                 longInt.hiWord -> zDelta;
                 longInt.loWord -> fwKeys;
                 ((MK_CONTROL %Band fwKeys)<>0) -> controlKey;
                 ((MK_SHIFT %Band fwKeys)<>0) -> shiftKey;
                 (if ((MK_LBUTTON %Band fwKeys)<>0) then
                     1 -> button;
                  else
                     (if ((MK_MBUTTON %Band fwKeys)<>0) then
                         2 -> button;
                      else
                         (if ((MK_RBUTTON %Band fwKeys)<>0) then
                             3 -> button;
                          else
                             (if ((MK_XBUTTON1 %Band fwKeys)<>0) then
                                 4 -> button;
                              else
                                 (if ((MK_XBUTTON2 %Band fwKeys)<>0) then
                                     5 -> button;
                                 if);
                             if);
                         if);
                     if);
                 if);
                 
                 (globalPosition, button, shiftKey, controlKey,zDelta)
                   -> THIS(GraphicsCanvas).theEventHandler.onMouseWheel;
              #)
          if);
          INNER;
       #);
  #);

-- SurfaceLib: attributes --


ComputeOutline:
  (# x, y: @real;
     a, b: @real;
     outline: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 10 #);
     number: (# exit 36 #);
  enter (x, y, a, b)
  do &PointList[] -> outline[];
     (for number repeat
          (degree / 180) * PI -> angle;
          &Point2d[] -> p[];
          x + (angle -> cos)*a -> p.x;
          y + (angle -> sin)*b -> p.y;
          p[] -> outline.append;
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*a -> p.x;
     y + (0 -> sin)*b -> p.y;
     p[] -> outline.append;
  exit outline[]
  #);
ComputeSplitOutline:
  (# x, y: @real;
     a, b: @real;
     outside, inside: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 5 #);
     number: (# exit 72 #);
     delta: @real;
     cosa, sina: @real;
  enter (x, y, a, b, delta)
  do &PointList[] -> outside[];
     &PointList[] -> inside[];
     
     (for number repeat
          (degree / 180) * PI -> angle;
          angle -> cos -> cosa;
          angle -> sin -> sina;
          
          &Point2d[] -> p[];
          x + cosa*(a+delta) -> p.x;
          y + sina*(b+delta) -> p.y;
          p[] -> outside.append;
          
          &Point2d[] -> p[];
          x + cosa*(a-delta) -> p.x;
          y + sina*(b-delta) -> p.y;
          p[] -> inside.append;
          
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*(a+delta) -> p.x;
     y + (0 -> sin)*(b+delta) -> p.y;
     p[] -> outside.append;
     &Point2d[] -> p[];
     x + (0 -> cos)*(a-delta) -> p.x;
     y + (0 -> sin)*(b-delta) -> p.y;
     p[] -> inside.append;
  exit (inside[], outside[])
  #);


-- GraphicsCanvasWritePNG: doPart --
do (# pixels: @integer;
      width, height: @integer;
   do backgroundColor  -> doublebuffer.content.clear;
      
      0 -> doublebuffer.left;
      0 -> doublebuffer.top;
      10000 -> doublebuffer.right;
      10000 -> doublebuffer.bottom;
        
      doublebuffer.begin;
      doublebuffer.push;

      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      layers.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      doublebuffer.pop;
      (if transparent[] <> NONE then
          transparent -> doublebuffer.content.transparentColor;
      if);
      (name[], area, depth) -> doublebuffer.content.writePNG;
      false  -> doublebuffer.content.transparent;
      doublebuffer.end;
   #);
   
-- GraphicsCanvasWriteJPG: doPart --
do (# pixels: @integer;
      width, height: @integer;
   do backgroundColor  -> doublebuffer.content.clear;
      
      0 -> doublebuffer.left;
      0 -> doublebuffer.top;
      10000 -> doublebuffer.right;
      10000 -> doublebuffer.bottom;
        
      doublebuffer.begin;
      doublebuffer.push;

      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      layers.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      doublebuffer.pop;
      (name[], area, quality) -> doublebuffer.content.writeJPG;
      doublebuffer.end;
   #);
   
-- PixmapReadAlpha: doPart --
do (# result: @integer;
   do (name, @@private.handleToPixmap, @@private.pixels, 
      @@private.width, @@private.height) -> ReadPNGalpha -> result;
      (if result <> 0 then
          ' for unknown reasons.' -> error;
      if);
   #);
   
-- GraphicsCanvasOpen: doPart --
do INNER;
   &InputCanvasMethods[] -> theMethods;
   getShared -> doublebuffer[];
   15 -> updateTimer.start;
   

-- GraphicsCanvasOnRefresh: doPart --
do (# windowid, pixmapid: @integer;
      width, height: @integer;
      
      area: ^Rectangle;
      
      
   do updateRect -> area[];
      
      (if false then
          'update [' -> puttext;
          area.left -> putint;
          ' ' -> put;
          area.top -> putint;
          ' ' -> put;
          area.right -> putint;
          ' ' -> put;
          area.bottom -> putint;
          ']' -> putline;
          
      if);
      
      backgroundColor -> doublebuffer.content.clear;
      (* Clear only area *)
      
      area.left -> doublebuffer.left;
      area.right -> doublebuffer.right;
      area.top -> doublebuffer.top;
      area.bottom -> doublebuffer.bottom;
      
      doublebuffer.begin;
      doublebuffer.push;
      (panx, pany) -> doublebuffer.translate;
      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      layers.scan
      (#
      do (if current.visible then
             doublebuffer[] -> current.drawOn;
         if);
      #);
      doublebuffer.pop;
      inner onRefresh;
      THIS(GraphicsCanvas).windowItemDevice -> windowid;
      doublebuffer.private.hdc -> pixmapid;
      area.size -> (width, height);
      (windowid, area.left, area.top, width, height, pixmapid, area.left, area.top, SRCCOPY) -> BitBlt;
      doublebuffer.end;
   #);
   
-- PixmapSurfaceInit: doPart --
do (content.private.pixels, content.width, content.height) -> init_tables;
   init_ovals;
   false -> useGDI;
   

-- PixmapSurfaceDrawText: doPart --
do (if (ROTATE AND (currentStyle[] <> NONE)) then
       (# xi, yi: @integer;
          faceName: ^Text;
          weight, height: @integer;
          italic: @integer;
       do (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, 0) -> MoveToEx;
          currentStyle.name -> faceName[];
          (private.hdc, TRANSPARENT) -> SetBkMode;
          
          (currentStyle.size,(private.hdc,LOGPIXELSY)->GetDeviceCaps,72)->MulDiv
            ->height;
          FW_NORMAL->weight;
          (if currentStyle.face = textFaces.bold then FW_BOLD->weight;  if);
          (if currentStyle.face = textFaces.italic then 1->italic;  if);
          (if currentStyle.face = textFaces.italic+textFaces.bold then
              FW_BOLD->weight; 1->italic; 
          if);
          
          
          (theText, currentAngle*10, height, weight, italic > 0, faceName, private.hdc)
            -> drawRotatedText_ext1;
       #);
    else
       (# xi, yi: @integer;
       do (0, 0) -> transform -> (xi, yi);
          (private.hdc, TA_BASELINE) -> SetTextAlign;
          (private.hdc, TRANSPARENT) -> SetBkMode;
          (private.hdc, xi, yi, @@theText.T[1], theText.lgth) -> TextOut;
       #);
   if);
   
-- PixmapSurfaceDrawLine: doPart --
do (# drawGDILine:
        (# theLogbrush: @LOGBRUSH;
           width: @integer;
           x1, y1: @integer;
           x2, y2: @integer;
           hpen, prevpen: @int32u;
        do BS_SOLID -> theLogbrush.lbStyle;
           private.colorref -> theLogbrush.lbColor;
           (if strokewidth > 0 then
               strokewidth -> width;
            else
               1 -> width;
           if);
           (PS_GEOMETRIC + PS_SOLID + PS_ENDCAP_FLAT, width, theLogbrush[], 0, 0) 
             -> ExtCreatePen
             -> hpen;
           
           (private.hdc, hpen) -> SelectObject -> prevpen;
           start -> transform -> (x1, y1);
           end -> transform -> (x2, y2);
           (private.hdc, x1, y1, 0) -> MoveToEx;
           (private.hdc, x2, y2) -> LineTo;
           (private.hdc, prevpen) -> SelectObject -> DeleteObject;
        #);
      drawDashed:
        (# theLogbrush: @LOGBRUSH;
           width: @integer;
           x1, y1: @integer;
           x2, y2: @integer;
           hpen, prevpen: @int32u;
           value: @integer;
           
        do BS_SOLID -> theLogbrush.lbStyle;
           private.colorref -> theLogbrush.lbColor;
           (if strokewidth > 0 then
               strokewidth -> width;
            else
               1 -> width;
           if);
           (if currentPenStyle
            //PenSmooth then
               PS_SOLID -> value;
            //PenSolid then PS_SOLID -> value;
            //PenDash then PS_DASH -> value;
            //PenDot then PS_DOT -> value;
            //PenDashDot then PS_DASHDOT -> value;
            //PenDashDotDot then PS_DASHDOTDOT -> value;
           if);
           (PS_GEOMETRIC + value + PS_ENDCAP_FLAT, width, theLogbrush[], 0, 0) 
             -> ExtCreatePen
             -> hpen;
           
           (private.hdc, hpen) -> SelectObject -> prevpen;
           start -> transform -> (x1, y1);
           end -> transform -> (x2, y2);
           (private.hdc, x1, y1, 0) -> MoveToEx;
           (private.hdc, x2, y2) -> LineTo;
           (private.hdc, prevpen) -> SelectObject -> DeleteObject;
        #);
      drawSimpleLine: 
        (# 
        do start -> transform -> aamoveto;
           end -> transform -> aalineto;
        #);
      drawComplexLine2:
        (# vx, vy: @real;
           x1, y1: @real;
           x2, y2: @real;
           length: @real;
           ux, uy: @real;
           outside: @PointList;
           p: ^Point2d;
           flag: @boolean;
           xr, yr: @real;
           delta: @real;
           ntPoints: [0] @integer;
           size: @integer;
           nullpen, prev: @integer;
        do strokewidth / 2 -> delta;
           start -> transform -> (x1, y1);
           end -> transform -> (x2, y2);
           x2 - x1 -> vx;
           y2 - y1 -> vy;
           vx*vx + vy*vy -> sqrt -> length;
           (if length > 0.0001 then
               (vx / length) * delta -> uy;
               - (vy / length) * delta -> ux;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 + ux -> p.x;
               y1 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 + ux -> p.x;
               y2 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 - ux -> p.x;
               y2 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               outside[] -> PolygonScan;
           if);
           
        #);
      drawComplexLine:
        (# vx, vy: @real;
           x1, y1: @real;
           x2, y2: @real;
           length: @real;
           ux, uy: @real;
           outside: @PointList;
           p: ^Point2d;
           flag: @boolean;
           xr, yr: @real;
           delta: @real;
           ntPoints: [0] @integer;
           size: @integer;
           nullpen, prev: @integer;
        do strokewidth / 2 -> delta;
           start -> transform -> (x1, y1);
           end -> transform -> (x2, y2);
           x2 - x1 -> vx;
           y2 - y1 -> vy;
           vx*vx + vy*vy -> sqrt -> length;
           (if length > 0.0001 then
               (vx / length) * delta -> uy;
               - (vy / length) * delta -> ux;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 + ux -> p.x;
               y1 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 + ux -> p.x;
               y2 + uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x2 - ux -> p.x;
               y2 - uy -> p.y;
               p[] -> outside.append;
               &Point2d[] -> p[];
               x1 - ux -> p.x;
               y1 - uy -> p.y;
               p[] -> outside.append;
               
               
              
               outside.size -> size;
               2 * size ->  ntPoints.new;
               outside.scan
               (# xi, yi: @integer;
                  i: @integer;
               do i + 1 -> i;
                  current -> (xi, yi);
                  xi -> ntPoints[(i*2)-1];
                  yi -> ntPoints[i*2];
               #);
               
               
               NULL_PEN -> GetStockObject -> nullpen;
               (private.hdc, nullpen) -> SelectObject -> prev;
               (private.hdc,@@ntPoints[1],size) -> Polygon;
               (private.hdc, prev) -> SelectObject;
               
               true -> flag;
               outside.scan
               (# xi, yi: @integer;
               do current  -> (xi, yi);
                  (if flag then
                      (xi, yi) -> aamoveto;
                      false -> flag;
                   else
                      (xi, yi) -> aalineto;
                  if);
               #);
           if);
           
        #);
   do (if useGDI then
          drawDashed;
       else
          (if currentPenStyle = PenSmooth then
              (if strokewidth <= 1 then
                  drawSimpleLine;
               else
                  (if newstyle then
                      drawComplexLine2;
                   else
                      drawComplexLine;
                  if);
              if);
           else
              drawDashed;
          if);
      if);
   #);

-- PixmapSurfaceDrawRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFrameRect;
   #);

-- PixmapSurfaceFillRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFillRect;
   #);
   
-- PixmapSurfaceDrawOval: doPart --
do (if useGDI then
       (# nullbrush: @integer;
          prev: @integer;
          xi, yi: @integer;
       do (* NULL_BRUSH  -> GetStockObject -> nullbrush;
          (private.hdc, nullbrush) -> SelectObject -> prev; *)
          (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
          (* private.hdc, prev) -> SelectObject; *)
       #);
    else
       filling:
         (# x, y: @integer;
            w, h: @integer;
            x1, y1: @integer;
         do (0, 0) -> transform -> (x1, y1);
            width -> w;
            height -> h;
            
            (if x1 > right then
                leave filling;
            if);
            (if y1 > bottom then
                leave filling;
            if);
            (if x1 + w < left then
                leave filling;
            if);
            (if y1 + h < top then
                leave filling;
            if);
            (x1, y1, w, h) -> fill_oval;
         #);
   if);
   
-- PixmapSurfaceFillOval: doPart --
do (if useGDI  then
       (# nullpen: @integer;
          prev: @integer;
          x1, y1: @integer;
       do (*NULL_PEN -> GetStockObject -> nullpen;
          (private.hdc, nullpen) -> SelectObject -> prev;*)
          (0, 0) -> transform -> (x1, y1);
          x1 + strokewidth -> x1;
          y1 + strokewidth -> y1;
          
          (private.hdc, x1, y1, x1 + width - 2*strokewidth, y1 + height - 2*strokewidth) -> Ellipse;
          (* (private.hdc, prev) -> SelectObject; *)
       #);
    else
       filling:
         (# x, y: @integer;
            w, h: @integer;
            x1, y1: @integer;
         do (0, 0) -> transform -> (x1, y1);
            x1 + strokewidth -> x1;
            y1 + strokewidth -> y1;
            
            (width / 2, height / 2) -> transform -> (x, y);
            width - 2*strokewidth -> w;
            height - 2*strokewidth -> h;
            (if x1 > right then
                leave filling;
            if);
            (if y1 > bottom then
                leave filling;
            if);
            (if x1 + w < left then
                leave filling;
            if);
            (if y1 + h < top then
                leave filling;
            if);
            
            (x1, y1, w, h) -> fill_oval;
         #);
   if);
-- PixmapSurfaceDrawPolygon: doPart --
do (# flag: @boolean;
      xi, yi: @integer;
   do true -> flag;
      points.scan
      (#
      do current -> transform -> (xi, yi);
         (if flag then
             (private.hdc, xi, yi, 0) -> MoveToEx;
             false -> flag;
          else
             (private.hdc, xi, yi) -> LineTo;
         if);
      #);
   #);
   
-- PixmapSurfaceFillPolygon: doPart --
do (if NOT newstyle then
       (if NOT useGDI then
           (# flag: @boolean;
              xr, yr: @integer;
              fx, fy: @integer;
           do true -> flag;
              points.scan
              (#
              do current -> transform -> (xr, yr);
                 (if flag then
                     (xr, yr) -> aamoveto;
                     (xr, yr) -> (fx, fy);
                     false -> flag;
                  else
                     (xr, yr) -> aalineto;
                 if);
              #);
              (fx, fy) -> aalineto;
           #);
           
       if);
   if);
   (if newstyle then
       (# curve: @PointList;
          p: ^Point2d;
       do points.scan
          (#
          do &Point2d[] -> p[];
             current -> transform -> p;
             p[] -> curve.append;
          #);
          curve[] -> PolygonScan;
       #);
   else
       (# ntPoints: [0] @integer;
          size: @integer;
       do points.size -> size;
          2 * size ->  ntPoints.new;
          points.scan
          (# xi, yi: @integer;
             i: @integer;
          do i + 1 -> i;
             current -> transform -> (xi, yi);
             xi -> ntPoints[(i*2)-1];
             yi -> ntPoints[i*2];
          #); 
          (private.hdc,@@ntPoints[1],size) -> Polygon;
       #);
   if);
-- PixmapSurfaceDrawPixmap: doPart --
do (# x, y: @integer;
      hdcmem: @integer;
      oldbmp: @integer;
      width, height: @integer;
      result: @integer;
      
      theColor: @integer;
      tc:@color;
      DrawTransparentBitmap: external
        (# hWnd, hBitmap, xStart, yStart, xDestPos, yDestPos, width, height,
           transparentColor: @integer;
           result:@integer;
        enter (hWnd, hBitmap, xStart, yStart, xDestPos, yDestPos, width, height,
           transparentColor)
        do callC;
        exit result
        #);
      DrawTransparentBitmapHDC: external
        (# hdc, hBitmap, xStart, yStart, xDestPos, yDestPos, width, height,
           transparentColor: @integer;
           result:@integer;
        enter (hdc, hBitmap, xStart, yStart, xDestPos, yDestPos, width, height,
           transparentColor)
        do callC;
        exit result
        #);
      
      DrawTransparentBitmapFromMask: external
        (# hWnd, hBitmap, xStart, yStart, xDestPos, yDestPos, 
           width,height,
           pixmapMask: @integer;
           result: @integer;
        enter (hWnd, hBitmap, xStart, yStart, xDestPos, yDestPos, width, height,
           pixmapMask)
        do callC;
        exit result
        #);
      DrawTransparentBitmapFromMaskHDC: external
        (# hdc, hBitmap, xStart, yStart, xDestPos, yDestPos, 
           width,height,
           pixmapMask: @integer;
           result: @integer;
        enter (hdc, hBitmap, xStart, yStart, xDestPos, yDestPos, width, height,
           pixmapMask)
        do callC;
        exit result
        #);
   do 
      (0, 0) -> transform -> (x, y);
      
      (if thePixmap.private.drawtransparent then
          (if thePixmap.private.transparentmask[]=none then (* use TransPcolor *)
              thePixmap.transparentColor->tc;
              (tc.red div 256,0) -> theColor.%putByte;
              (tc.green div 256,1) -> theColor.%putByte;
              (tc.blue div 256,2) -> theColor.%putByte;
              (0,3) -> theColor.%putByte;
              
              (private.hdc, thePixmap.private.handleToPixmap,
              0, 0, x, y, thePixmap.width, thePixmap.height,theColor)
                -> DrawTransparentBitmapHDC
                ->result;
           else 
              (private.hdc, thePixmap.private.handleToPixmap,
              0, 0, x, y, thePixmap.width,thePixmap.height,
              thePixmap.private.transparentmask.private.handleToPixmap)
                -> DrawTransparentBitmapFromMaskHDC
                ->result;
          if);
       else
          (if (NOT useGDI) AND (thePixmap.private.pixels <> 0)  then
              thePixmap.width -> width;
              thePixmap.height -> height;
              (thePixmap.private.pixels, width * 4, 
              content.private.pixels, content.width * 4,  x, 
              y, width, height, content.width, content.height)
                -> TransferRedPixels;
           else
              
              private.hdc -> CreateCompatibleDC -> hdcmem;
              (hdcmem, thePixmap.private.handleToPixmap) -> SelectObject -> oldbmp;
              (private.hdc, x, y, thePixmap.width, thePixmap.height, hdcmem, 0, 0, SRCCOPY) -> BitBlt;
              (hdcmem, oldbmp) -> SelectObject;
              hdcmem -> DeleteDC;
          if);
      if);

   #);
   

-- PixmapSurfaceStyle: doPart --
do theStyle[] -> currentStyle[];
   
-- PixmapSurfaceAngle: doPart --
do theAngle -> currentAngle;

-- PixmapSurfacePen: doPart --
do (# red, green, blue: @int8u;
      colorref: @int32u;
      colorvalue: @int32u;
   do theColor.red %srl 8 -> red;
      theColor.green %srl 8 -> green;
      theColor.blue %srl 8 -> blue;
      
      (blue / 255, green / 255, red / 255) -> aapen;
      (blue / 255, green / 255, red / 255) -> ovalpen;
      
      
      red %bor (green %sll 8) %bor (blue %sll 16) -> colorref;
      blue %bor (green %sll 8) %bor (red %sll 16) -> colorvalue;
      
      (private.hdc, colorref) -> SetTextColor;
      colorref -> CreateSolidBrush -> private.brush;
      (private.hdc, private.brush) -> SelectObject -> DeleteObject;
      (PS_SOLID, 0, colorref) -> CreatePen -> private.pen;
      (private.hdc, private.pen) -> SelectObject -> DeleteObject;
      
      colorref -> private.colorref;
      colorvalue -> private.colorvalue;
   #);
   
-- PixmapSurfacePush: doPart --
do (# new: ^Matrix;
   do &Matrix[] -> new[];
      private.current.x -> new.x;
      private.current.y -> new.y;
      private.current[] -> new.next[];
      new[] -> private.current[];
   #);

-- PixmapSurfacePop: doPart --
do private.current.next[] -> private.current[];

-- PixmapSurfaceTranslate: doPart --
do private.current.x + dx -> private.current.x;
   private.current.y + dy -> private.current.y;
   
-- PixmapSurfaceBegin: doPart --
do &Matrix[] -> private.current[];
   0 -> CreateCompatibleDC -> private.hdc;
   (private.hdc, content.private.handleToPixmap) -> SelectObject -> private.old_dib;
   0 -> CreateSolidBrush -> private.brush;
   (private.hdc, private.brush) -> SelectObject -> private.old_brush;
   (PS_SOLID, 0, 0) -> CreatePen -> private.pen;
   (private.hdc, private.pen) -> SelectObject -> private.old_pen;
   
-- PixmapSurfaceEnd: doPart --
do (private.hdc, private.old_dib) -> SelectObject;
   (private.hdc, private.old_brush) -> SelectObject -> DeleteObject;
   (private.hdc, private.old_pen) -> SelectObject -> DeleteObject;
   private.hdc -> DeleteDC;
   
   
-- PixmapSurfaceLib: attributes --

trace_plot: (# exit false #);
trace_poly: (# exit false #);

newstyle: (# exit true #);


FixedPoint:
  (# x, y: @integer;
  #);

PolygonScan:
  (# poly: ^PointList;
     left, top, right, bottom: @integer;
     xorigin: @integer;
     yorigin: @integer;
     
     scanlines: @integer;
     
     EdgeTable:
       (# storage: [1] ^Edge;
          top: @integer;
          
          insert:
            (# theEdge: ^Edge;
            enter theEdge[]
            do top + 1 -> top;
               (if top > storage.range then
                   storage.range -> storage.extend;
               if);
               theEdge[] -> storage[top][];
            #);
          sort:
            (# k: @integer;
               tmp: ^Edge;
            do (for i: top - 1 repeat
                    (for j: top - i repeat
                         top - j + 1 -> k;
                         (if storage[k].xmin < storage[k-1].xmin then
                             storage[k][] -> tmp[];
                             storage[k-1][] -> storage[k][];
                             tmp[] -> storage[k-1][];
                         if);
                    for);
               for);
            #);
          scan:
            (# current: ^Edge;
            do (for inx: top repeat
                    storage[inx][] -> current[];
                    INNER;
               for);
            #);
          weed:
            (# y: @integer;
               inx: @integer;
            enter y
            do 1 -> inx;
               loop:
                 (if inx <= top then
                     (if storage[inx].ymax = y then
                         storage[top][] -> storage[inx][];
                         NONE -> storage[top][];
                         top - 1 -> top;
                      else
                         inx + 1 -> inx;
                     if);
                     restart loop;
                 if);
            #);
       #);
     
     GlobalEdgeTable: [0] @EdgeTable;
     ActiveEdgeTable: @EdgeTable;
     
     
     Edge:
       (# dx: @real;
          ymax: @integer;
          xmin: @real;
       #);
     
     convert:
       (# y: @integer;
          xleft, xright: @integer;
          tmp: @real;
          color: @integer;
          buffer: [0] @int8u;
          rowbytes: @integer;
          lx: @integer;
          count: @integer;
          line: @integer;
          gray: @integer;
          ll, rr: @integer;
          i: @integer;
       do private.colorvalue -> color;
          1 -> y;
          (right + 7) div 8 -> rowbytes;
          rowbytes + 1 -> buffer.new;
          rowbytes -> ll;
          0 -> rr;
          (for major: scanlines div 8 repeat
               rowbytes -> ll;
               0 -> rr;
               
               (for minor: 8 repeat
                    GlobalEdgeTable[y].scan
                    (#
                    do current[] -> ActiveEdgeTable.insert;
                    #);
                    y -> ActiveEdgeTable.weed;
                    ActiveEdgeTable.sort;
                    (if ActiveEdgeTable.top > 0 then
                        (if ActiveEdgeTable.top = 2 then
                            ActiveEdgeTable.storage[1].xmin -> ceil -> tmp;
                            tmp -> xleft;
                            ActiveEdgeTable.storage[2].xmin -> ceil -> tmp;
                            tmp -> xright;
                            (if xleft = xright then
                                xleft div 8 + 1 -> lx;
                                buffer[lx] + 1 -> buffer[lx];
                                (if lx < ll then
                                    lx -> ll;
                                 else
                                    (if lx > rr then
                                        lx -> rr;
                                    if);
                                if);
                             else
                                (for i: (xright - xleft) repeat
                                     (xleft + i - 1) div 8 + 1 -> lx;
                                     buffer[lx] + 1 -> buffer[lx];
                                     (if lx < ll then
                                         lx -> ll;
                                      else
                                         (if lx > rr then
                                             lx -> rr;
                                         if);
                                     if);
                                for);
                            if);
                            
                        if);
                    if);
                    y + 1 -> y;
                    ActiveEdgeTable.scan
                    (#
                    do current.xmin + current.dx -> current.xmin;
                    #);
               for);
               
               
               
               (for k: (rr - ll) + 1  repeat
                    ll + k - 1 -> i;
                    0 -> count;
                    buffer[i] -> count;
                    0 -> buffer[i];
                    (if count > 0 then
                        (if count = 64 then
                            (xorigin + i - 1, yorigin + major - 1, color) -> plotpixel;
                         else
                            (count * 0xFF) / 64 -> gray;
                            (xorigin + i - 1, yorigin + major  - 1, gray, color) -> blend_pixel;
                        if);
                    if);
               for);
          for);
       #);
     
     
     prepare:
       (# 
	  insertEdge:
	    (# p1, p2: ^FixedPoint;
	       
	       e: ^Edge;
               low, high: ^FixedPoint;
               inx: @integer;
	    enter (p1[], p2[])
	    do (if p1.y <> p2.y then
	           
		   (if p1.y < p2.y then
		       p1[] -> low[];
                       p2[] -> high[];
		    else
		       p2[] -> low[];
                       p1[] -> high[];
		   if);
                   
		   &Edge[] -> e[];
                   (high.x - low.x) / (high.y - low.y) -> e.dx;
		   high.y + 1 -> e.ymax;
		   low.x  -> e.xmin;
                   low.y + 1 -> inx;
                   e[] -> GlobalEdgeTable[inx].insert;
	       if);
	    #);
          
          data: [0] ^FixedPoint;
          ox, oy: @real;
          curve: @PointList;
       do (if poly.size > 2 then
              
              (* Calculate origin *)
              
              (poly.head).elm.x -> ox;
              (poly.head).elm.y -> oy;
              poly.scan
              (#
              do (if current.x < ox then
                     current.x -> ox;
                 if);
                 (if current.y < oy then
                     current.y -> oy;
                 if);
              #);
              ox -> floor -> xorigin;
              oy -> floor -> yorigin;
              
              
              poly.size -> data.new;
              poly.scan
              (# inx: @integer;
              do inx + 1 -> inx;
                 &FixedPoint[] -> data[inx][];
                 (current.x - xorigin) * 8.0  -> data[inx].x;
                 (current.y - yorigin) * 8.0 -> data[inx].y;
              #);
              data[1].x -> left -> right;
	      data[1].y -> top -> bottom;
	      (for inx: data.range - 1 repeat
	           (if data[inx+1].x < left then
	               data[inx+1].x -> left;
	           if);
	           (if data[inx+1].x > right then
	               data[inx+1].x -> right;
	           if);
	           (if data[inx+1].y < top then
	               data[inx+1].y -> top;
	           if);
	           (if data[inx+1].y > bottom then
	               data[inx+1].y -> bottom;
	           if);
	      for);
              
	      ((bottom + 7) div 8) * 8 -> scanlines;
              
              
	      scanlines -> GlobalEdgeTable.new;
              
	      (for inx: data.range repeat
	           (if inx = data.range then
		       (data[inx][], data[1][]) -> insertEdge;
		    else
		       (data[inx][], data[inx+1][]) -> insertEdge;
		   if);
	      for);
              (for inx: GlobalEdgeTable.range repeat
                   GlobalEdgeTable[inx].sort;
              for);
          if);
       #);
     inside:
       (# yes: @boolean;
       do false  -> yes;
          search: poly.scan
            (# 
            do test:
                 (# 
                 do (if current.x < THIS(PixmapSurface).left then
                        leave test;
                    if);
                    (if current.x > THIS(PixmapSurface).right then
                        leave test;
                    if);
                    (if current.y < THIS(PixmapSurface).top then
                        leave test;
                    if);
                    (if current.y > THIS(PixmapSurface).right then
                        leave test;
                    if);
                    true -> yes;
                    leave search;
                 #);
            #);
       exit yes
       #);
  enter poly[]
  do (if inside then
         prepare;
         convert;
     if);
  #);

PolygonScan1:
  (# poly: ^PointList;
     left, top, right, bottom: @integer;
     xorigin: @integer;
     yorigin: @integer;
     
     scanlines: @integer;
     
     EdgeTable:
       (# storage: [1] ^Edge;
          top: @integer;
          
          insert:
            (# theEdge: ^Edge;
            enter theEdge[]
            do top + 1 -> top;
               (if top > storage.range then
                   storage.range -> storage.extend;
               if);
               theEdge[] -> storage[top][];
            #);
          sort:
            (# k: @integer;
               tmp: ^Edge;
            do (for i: top - 1 repeat
                    (for j: top - i repeat
                         top - j + 1 -> k;
                         (if storage[k].xmin < storage[k-1].xmin then
                             storage[k][] -> tmp[];
                             storage[k-1][] -> storage[k][];
                             tmp[] -> storage[k-1][];
                         if);
                    for);
               for);
            #);
          scan:
            (# current: ^Edge;
            do (for inx: top repeat
                    storage[inx][] -> current[];
                    INNER;
               for);
            #);
          weed:
            (# y: @integer;
               inx: @integer;
            enter y
            do 1 -> inx;
               loop:
                 (if inx <= top then
                     (if storage[inx].ymax = y then
                         storage[top][] -> storage[inx][];
                         NONE -> storage[top][];
                         top - 1 -> top;
                      else
                         inx + 1 -> inx;
                     if);
                     restart loop;
                 if);
            #);
          print:
            (#
            do scan
               (#
               do current.xmin -> putint;
                  '(' -> put;
                  current.dx -> putreal;
                  ')' -> put;
                  '[' -> put;
                  current.ymax -> putint;
                  ']' -> put;
                  ' ' -> put;
               #);
            #);
       #);
     
     GlobalEdgeTable: [0] @EdgeTable;
     ActiveEdgeTable: @EdgeTable;
     
     
     Edge:
       (# dx: @real;
          ymax: @integer;
          xmin: @real;
       #);
     
     print:
       (#
       do (for inx: GlobalEdgeTable.range repeat
               inx -> putint;
               ': ' -> puttext;
               GlobalEdgeTable[inx].print;
               newline;
          for);
       #);
     convert:
       (# y: @integer;
          xleft, xright: @integer;
          tmp: @real;
          color: @integer;
          plot:
            (# x, y: @integer;
               minory: @integer;
               majorx: @integer;
               minorx: @integer;
               mask: @integer;
            enter (x, y)
            do y mod 8 + 1 -> minory;
               x div 8 -> majorx;
               x mod 8 -> minorx;
               1 %sll minorx -> mask;
               
               (if trace_poly AND trace_plot then
                   '(' -> puttext;
                   x -> putint;
                   ' ' -> puttext;
                   y -> putint;
                   ')' -> put;
                   '[' -> put;
                   minory -> putint;
                   '; ' -> puttext;
                   majorx -> putint;
                   ', ' -> puttext;
                   minorx -> putint;
                   ' #' -> puttext;
                   mask -> puthex;
                   
                   ']' -> put;
               if);
               
               buffer[minory].storage[majorx + 1] + mask -> buffer[minory].storage[majorx + 1];
               
               (** (xorigin*8 + x, yorigin*8 + y, color) -> plotpixel; **)
            #);
          clear:
            (#
            do (for j: 8 repeat
                    (for i: buffer[j].storage.range repeat
                         0 -> buffer[j].storage[i];
                    for);
               for);
            #);
          plotline:
            (# count: @integer;
               line: @integer;
               gray: @integer;
            enter line
            do (if trace_plot then
                   'LINE [' -> puttext;
               if);
               (for i: rowbytes repeat
                    0 -> count;
                    (for j: 8 repeat
                         count + bits[buffer[j].storage[i]+1] -> count;
                    for);
                    (if trace_plot then
                        count -> putint;
                        ' ' -> put;
                    if);
                    
                    (if count > 0 then
                        (if count = 64 then
                            (xorigin + i - 1, yorigin + line - 1, color) -> plotpixel;
                         else
                            (count * 0xFF) / 64 -> gray;
                            (xorigin + i - 1, yorigin + line - 1, gray, color) -> blend_pixel;
                        if);
                    if);
               for);
               (if trace_plot then
                   ']' -> put;
                   newline;
               if);
            #);
          Row:
            (# storage: [0] @int8u;
            #);
          buffer: [8] @Row;
          rowbytes: @integer;
          
          bits: [256] @int8u;
          
          number_of_bits_set: external
            (# a: @integer;
               b: @integer;
            enter a
            exit b
            #);
            
          
       do private.colorvalue -> color;
          (for i: 256 repeat
               i - 1 -> number_of_bits_set -> bits[i];
          for);
          1 -> y;
          (right + 7) div 8 -> rowbytes;
          (for inx: 8 repeat
               rowbytes -> buffer[inx].storage.new;
          for);
          
          (for major: scanlines div 8 repeat
               (for minor: 8 repeat
                    (if trace_poly then
                        y -> putint;
                        ': ' -> puttext;
                    if);
                    GlobalEdgeTable[y].scan
                    (#
                    do current[] -> ActiveEdgeTable.insert;
                    #);
                    (* Remove AET[i] if AET[i].ymax = y *)
                    y -> ActiveEdgeTable.weed;
                    (* Sort AET *)
                    ActiveEdgeTable.sort;
                    
                    (* Fill *)
                    
                    (if ActiveEdgeTable.top > 0 then
                        (if ActiveEdgeTable.top = 2 then
                            (if trace_poly then
                                '[' -> puttext;
                                ActiveEdgeTable.storage[1].xmin -> putreal;
                                ' ' -> puttext;
                                ActiveEdgeTable.storage[2].xmin -> putreal;
                                ']' -> puttext;
                            if);
                            
                            ActiveEdgeTable.storage[1].xmin -> ceil -> tmp;
                            tmp -> xleft;
                            ActiveEdgeTable.storage[2].xmin -> ceil -> tmp;
                            tmp -> xright;
                            (if trace_poly then
                                ' SPAN[' -> puttext;
                                xleft -> putint;
                                ' ' -> puttext;
                                xright -> putint;
                                ']' -> puttext;
                            if);
                            
                            (if xleft = xright then
                                (xleft, y - 1) -> plot;
                             else
                                (for i: (xright - xleft) repeat
                                     (xleft + i - 1, y - 1) -> plot;
                                for);
                            if);
                            
                        if);
                    if);
                    y + 1 -> y;
                    (* Increment xmin *)
                    ActiveEdgeTable.scan
                    (#
                    do current.xmin + current.dx -> current.xmin;
                    #);
                    (if trace_poly then
                        newline;
                    if);
               for);
               major -> plotline;
               clear;
          for);
       #);
     
     
     prepare:
       (# 
	  insertEdge:
	    (# p1, p2: ^FixedPoint;
	       
	       e: ^Edge;
               low, high: ^FixedPoint;
               inx: @integer;
	    enter (p1[], p2[])
	    do (if p1.y <> p2.y then
	           
		   (if p1.y < p2.y then
		       p1[] -> low[];
                       p2[] -> high[];
		    else
		       p2[] -> low[];
                       p1[] -> high[];
		   if);
                   
		   &Edge[] -> e[];
                   (high.x - low.x) / (high.y - low.y) -> e.dx;
		   high.y + 1 -> e.ymax;
		   low.x  -> e.xmin;
                   low.y + 1 -> inx;
                   e[] -> GlobalEdgeTable[inx].insert;
	       if);
	    #);
          
          data: [0] ^FixedPoint;
          ox, oy: @real;
          curve: @PointList;
       do (if trace_poly then
              'poly [' -> puttext;
              poly.scan
              (#
              do '(' -> put;
                 current.x -> putint;
                 ', ' -> puttext;
                 current.y -> putint;
                 ')' -> put;
              #);
              ']' -> putline;
          if);
          
          (if poly.size > 2 then
              
              (* Calculate origin *)
              
              (poly.head).elm.x -> ox;
              (poly.head).elm.y -> oy;
              poly.scan
              (#
              do (if current.x < ox then
                     current.x -> ox;
                 if);
                 (if current.y < oy then
                     current.y -> oy;
                 if);
              #);
              ox -> floor -> xorigin;
              oy -> floor -> yorigin;
              
              
              poly.size -> data.new;
              poly.scan
              (# inx: @integer;
              do inx + 1 -> inx;
                 &FixedPoint[] -> data[inx][];
                 (current.x - xorigin) * 8.0  -> data[inx].x;
                 (current.y - yorigin) * 8.0 -> data[inx].y;
              #);
              data[1].x -> left -> right;
	      data[1].y -> top -> bottom;
	      (for inx: data.range - 1 repeat
	           (if data[inx+1].x < left then
	               data[inx+1].x -> left;
	           if);
	           (if data[inx+1].x > right then
	               data[inx+1].x -> right;
	           if);
	           (if data[inx+1].y < top then
	               data[inx+1].y -> top;
	           if);
	           (if data[inx+1].y > bottom then
	               data[inx+1].y -> bottom;
	           if);
	      for);
              
              
              
	      ((bottom + 7) div 8) * 8 -> scanlines;
              
              (if trace_poly then
                  'box [' -> puttext;
                  left -> putint;
                  ' ' -> put;
                  top -> putint;
                  ' ' -> put;
                  right -> putint;
                  ' ' -> put;
                  bottom -> putint;
                  ']' -> putline;
              if);
              
	      scanlines -> GlobalEdgeTable.new;
              
	      (for inx: data.range repeat
	           (if inx = data.range then
		       (data[inx][], data[1][]) -> insertEdge;
		    else
		       (data[inx][], data[inx+1][]) -> insertEdge;
		   if);
	      for);
              (for inx: GlobalEdgeTable.range repeat
                   GlobalEdgeTable[inx].sort;
              for);
          if);
       #);
     
  enter poly[]
  do prepare;
     convert;
  #);

plotpixel: external
  (# x, y, color: @integer;
  enter (x, y, color)
  #);
blend_pixel: external
  (# x, y, gray, color: @integer;
  enter (x, y, gray, color)
  #);


Matrix:
  (# next: ^Matrix;
     x, y: @real;
  #);

transform:
  (# x, y: @real;
  enter (x, y)
  do private.current.x + x -> x;
     private.current.y + y -> y;
  exit (x, y)
  #);

ntFillRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FillRect' -> callStd;
  exit result
  #);
ntFrameRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FrameRect' -> callStd;
  exit result
  #);



-- PixmapSurfacePrivate: descriptor --
(# hdc: @integer;
   brush: @integer;
   pen: @integer;
   old_dib: @integer;
   old_brush: @integer;
   old_pen: @integer;
   current: ^Matrix;
   colorref: @int32u;
   colorvalue: @int32u;
   doomed: @boolean;
#)


-- TextItemLib: attributes --

MyCreateFont_ext: external
  (#
     angle: @integer;
     height,faceName: @integer;
     weight: @integer;
     italic: @integer;
     hdc: @integer;
     hFont: @integer;
     
  enter (angle,height,weight,italic,faceName,hdc)
  do callC
  exit hFont
  #);

(* In GUIEnv you cannot set the text angle
 * therefore we have to create an extra font with the 
 * correct angle, otherwise we cannot calculate size of the
 * label.
 *)
createActualFont:
  (# hdc,height,weight,italic: @integer; faceNameCstr: @Cstring; 
     hActualFont: @integer;
  do
     
     (if (style[] <> none ) and (angle <> 0) then
         0->GetDC->hdc;
         (style.size,(hdc,LOGPIXELSY)->GetDeviceCaps,72)->MulDiv
           ->height;
         style.name->faceNameCstr.set;
         FW_NORMAL->weight;
         (if style.face = textFaces.bold then FW_BOLD->weight;  if);
         (if style.face = textFaces.italic then 1->italic;  if);
         (if style.face = textFaces.italic+textFaces.bold then
             FW_BOLD->weight; 1->italic; 
         if);
         (angle,height,weight,italic,faceNameCstr,hdc)->MyCreateFont_ext
           ->hActualFont;
         (0,hdc)->ReleaseDC;
         (if faceNameCstr <> 0 then faceNameCstr.free;  if);
         
     if);
  exit hActualFont 
  #);
disposeActualFont:
  (# hActualFont: @integer; 
  enter hActualFont
  do
     (if hActualFont <> 0 then
         hActualFont->DeleteObject; 0->hActualFont; 
     if);
     
  #);
useActualTextStyle:
  (# dc: @integer; saved: @integer; infoPtr: @integer; 
     hActualFont: @integer;
  do
     createActualFont -> hActualFont;
     56->malloc->infoPtr;
     0->GetDC->dc;
     (if hActualFont <> 0 then
         (dc,hActualFont)->SelectObject->saved; 
      else
         (dc,style.textStyleID)->SelectObject->saved; 
     if);
     (dc,infoPtr)->GetTextMetrics;
     INNER ;
     
     (dc,saved)->SelectObject;
     hActualFont -> disposeActualFont;
     (0,dc)->ReleaseDC;
     infoPtr->free;
     
  #);

getActualFontHeight: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmHeightOffset->tos'%adrGetLong'->value; 
  exit value
  #);
getActualFontAscent: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmAscentOffset->tos'%adrGetLong'->value; 
  exit value
  #);
getActualFontDescent: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmDescentOffset->tos'%adrGetLong'->value; 
  exit value
  #);
getActualFontExternalLeading: useActualTextStyle
  (# value: @integer; 
  do infoPtr+textmetricTmExternalLeadingOffset->tos'%adrGetLong'->value; 
  exit value
  #);

-- TextItemOutline: doPart --
do (# pt: @point;
      points: [4] ^point;
      (* private *)
      tempPoint: @Point;
      res: @real;
      cosAngle,sinAngle,lhcos2,lhsin2,xr,yr,vx,vy,ux,uy:
        @real;
      w: @integer;
      tempText: ^Text;
      noOfNewLines: @integer;
      fontHeight,fontAscent,fontDescent,xFontDescent,
      yFontDescent,externalLeading: @integer;
      q: ^Point2d;
   do (x, y) -> pt;
      (if content[] <> none then
          (for i: 4 repeat &point[]->points[i][];  for);
          content[]->style.widthOfText->w;
          (((- angle)*pi) / 180)->res;
          res->cos->cosAngle;
          (w*cosAngle)->lhcos2;
          res->sin->sinAngle;
          (w*sinAngle)->lhsin2;
          pt->tempPoint;
          tempPoint->points[1];
          tempPoint.h+lhcos2->points[2].h;
          tempPoint.v+lhsin2->points[2].v;
          content[]->tempText[];
          tempText.scanall
          (# 
          do (if ch = ascii.nl then noOfNewLines+1->noOfNewLines;  if); 
          #);
          getActualFontAscent->fontAscent;
          cosAngle*fontAscent->xr;
          sinAngle*fontAscent->yr;
          points[2].h+yr->points[3].h;
          points[2].v-xr->points[3].v;
          points[1].h+yr->points[4].h;
          points[1].v-xr->points[4].v;
          getActualFontDescent->fontDescent;
          (if ((fontDescent = 0) or (angle <> 0)) and
              ('marlett'->(style.name).equalNCS) then
              (* this is symbol font. Actually it should not be used but you can
               * select it from the font dialog so we try to handle it. It is a problem
               * because the descent is set to zero so we have to guess.
               *)
              getActualFontHeight->fontHeight;
              fontHeight / 6+1->fontDescent;
              (if fontDescent = 0 then 4->fontDescent;  if);
              
          if);
          cosAngle*fontDescent->xFontDescent;
          sinAngle*fontDescent->yFontDescent;
          points[1].h-yFontDescent->points[1].h;
          points[1].v+xFontDescent->points[1].v;
          points[2].h-yFontDescent->points[2].h;
          points[2].v+xFontDescent->points[2].v;
          (if noOfNewLines > 0 then
              getActualFontHeight->fontHeight;
              getActualFontExternalLeading->externalLeading;
              cosAngle*fontHeight+externalLeading->xr;
              sinAngle*fontHeight+externalLeading->yr;
              points[1].h-(yr*noOfNewLines)->points[1].h;
              points[1].v+(xr*noOfNewLines)->points[1].v;
              points[2].h-(yr*noOfNewLines)->points[2].h;
              points[2].v+(xr*noOfNewLines)->points[2].v;
              
          if);
          
      if);
      (for inx: points.range repeat
           &Point2d[] -> q[];
           points[inx] -> q;
           q[] -> THIS(outline).points.append;
      for);
   #);
   
-- TextItemContainsPoint: doPart --
do 
   x + THIS(Item).x -> x;
   y + THIS(Item).y -> y;
   (if (content[]<>none) and (outline<>none) then
       (if ((outline,(x,y))->isPointInRegion) then
           THIS(TextItem)[] -> target[];
       if);
   if);
-- SetOvalLimit: doPart --
do (# theSurface: ^PixmapSurface;
   do ((limit + 3) div 4) * 4 -> limit;
      getShared -> theSurface[];
      
      
      (if theSurface.ovallimit <> limit then
          limit -> theSurface.ovallimit;
          limit -> oval_limit;
      if);
   #);
   
-- GetOvalLimit: doPart --
do (# theSurface: ^PixmapSurface;
   do getShared -> theSurface[];
      theSurface.ovallimit -> limit;
   #);
   
-- SetUseGDI: doPart --
do (# theSurface: ^PixmapSurface;
   do getShared -> theSurface[];
      value -> theSurface.useGDI;
   #);
   
-- GetUseGDI: doPart --
do (# theSurface: ^PixmapSurface;
   do getShared -> theSurface[];
      theSurface.useGDI -> value;
   #);

-- GraphicsCanvasChangePan: doPart --
do (# hwnd: @integer;
      hdc: @integer;
      dx, dy: @integer;
      width, height: @integer;
      
      fromx, tox, fromy, toy: @integer;
      
      area: @Rectangle;
      ptr: @integer;
   do panx - newx -> dx;
      pany - newy -> dy;
      
      (if ((dx <> 0) OR (dy <> 0)) then
          size -> (width, height);
          (if dx > 0 then
              dx -> fromx;
              0 -> tox;
              width - fromx -> width; 
           else
              0 -> fromx;
              -dx -> tox;
              width - tox -> width;
          if);
          
          (if dy > 0 then
              dy -> fromy;
              0 -> toy;
              height - fromy -> height;
           else
              0 -> fromy;
              -dy -> toy;
              height - toy -> height;
          if);
          THIS(GraphicsCanvas).interfaceObjectID -> hwnd;
          hwnd -> GetDC -> hdc;
          (hdc, tox, toy, width, height, hdc, fromx, fromy, SRCCOPY) -> BitBlt;
          
          0 -> area.left;
          0 -> area.top;
          size -> (area.right, area.bottom);
          area[] -> makeNtRectPtr -> ptr;
          (hwnd, ptr, 0) -> InvalidateRect;
          ptr -> free;
          
          tox -> area.left;
          toy -> area.top;
          area.left + width -> area.right;
          area.top + height -> area.bottom;
          area[] -> makeNtRectPtr -> ptr;
          
          (hwnd, ptr) -> ValidateRect;
          ptr -> free;
          
          
          newx -> panx;
          newy -> pany;
          (hwnd, hdc) -> ReleaseDC;
      if);
   #);
   
-- GraphicsCanvasFlush: doPart --
do (# ptr: @integer;
      hwnd: @integer;
   do (if changedFlag then
          interfaceObjectID -> hwnd;
          updateRgn[] -> makeNtRectPtr -> ptr;
          (hwnd, ptr, 0) -> InvalidateRect;
          ptr -> free;
          (* hwnd -> UpdateWindow; *)
          (if false then
              'flush: ' -> puttext;
              updateRgn.left -> putint;
              ' ' -> put;
              updateRgn.top -> putint;
              ' ' -> put;
              updateRgn.right -> putint;
              ' ' -> put;
              updateRgn.bottom -> putint;
              newline;
          if);
          false -> changedFlag;
      if);
   #);
   
-- GUIenvLib: attributes --
GMD:
  (# n, m: @integer;
     p, q: @integer;
  enter (n, m)
  do n -> p;
     m -> q;
     loop:
       (#
       do (if p > q then
              p - q -> p;
              restart loop;
          if);
          (if q > p then
              q - p -> q;
              restart loop;
          if);
       #);
  exit p
  #);
WeimanExpandWidth:
  (# src: ^Pixmap;
     dst: ^Pixmap;
     d: @integer;
     p, q: @integer;
     width: @integer;
  enter (src[], width)
  do &Pixmap[] -> dst[];
     (width, src.height) -> dst.init;
     (width, src.width) -> GMD -> d;
     width div d -> p;
     src.width div d -> q;
     (if p > q then
         (src.private.pixels, src.width, src.height,
         dst.private.pixels, dst.width, dst.height,
         p, q) -> WeimanExpansionOut;
      else
         (src.private.pixels, src.width, src.height,
         dst.private.pixels, dst.width, dst.height,
         p, q) -> WeimanExpansionIn;
     if);
  exit dst[]
  #);

WeimanExpandHeight:
  (# src: ^Pixmap;
     dst: ^Pixmap;
     d: @integer;
     p, q: @integer;
     height: @integer;
  enter (src[], height)
  do &Pixmap[] -> dst[];
     (src.width, height) -> dst.init;
     (height, src.height) -> GMD -> d;
     height div d -> p;
     src.height div d -> q;
          
     (if p > q then
         (src.private.pixels, src.width, src.height,
         dst.private.pixels, dst.width, dst.height,
         p, q) -> WeimanExpansionOutVert;
      else
         (src.private.pixels, src.width, src.height,
         dst.private.pixels, dst.width, dst.height,
         p, q) -> WeimanExpansionInVert;
     if);
  exit dst[]
  #);

-- GUIenvScalePixmap: doPart --
do (# copy: ^Pixmap;
      
   do (if width <> src.width then
          (src[], width) -> WeimanExpandWidth -> copy[];
          (if height <> src.height then
              (copy[], height) -> WeimanExpandHeight -> dst[];
              copy.dispose;
           else
              copy[] -> dst[];
          if);
       else
          (if height <> src.height then
              (src[], height) -> WeimanExpandHeight -> dst[];
           else
              src[] -> dst[];
          if);
      if);
      
   #);
   
