ORIGIN '../graphicscanvasbody';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/win32lib/bitmapsupport';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/wingdi';
INCLUDE '~beta/win32lib/wingdiconsts';
INCLUDE '~beta/win32lib/dcmanagement';
INCLUDE '~beta/guienv/graphics';
INCLUDE '~beta/basiclib/math';
BUILD nti '$$/aadraw.obj' 'external/aadraw.c' 'betacc $0 $1';

-- lib: attributes --

init_tables: external
  (# buffer: @int32u;
     width, height: @integer;
  enter (buffer, width, height)
  #);
aamoveto: external
  (# x, y: @real;
  enter (x, y)
  #);
aalineto: external
  (# x, y: @real;
  enter (x, y)
  #);
aapen: external
  (# red, green, blue: @real;
  enter (red, green, blue)
  #);

ANTIALIAS: (# exit true #);
-- SurfaceLib: attributes --
ComputeOutline:
  (# x, y: @real;
     a, b: @real;
     outline: ^PointList;
     p: ^Point2d;
     angle: @real;
     degree: @integer;
     step: (# exit 10 #);
     number: (# exit 36 #);
  enter (x, y, a, b)
  do &PointList[] -> outline[];
     (for number repeat
          (degree / 180) * PI -> angle;
          &Point2d[] -> p[];
          x + (angle -> cos)*a -> p.x;
          y + (angle -> sin)*b -> p.y;
          p[] -> outline.append;
          degree + step -> degree;
     for);
     &Point2d[] -> p[];
     x + (0 -> cos)*a -> p.x;
     y + (0 -> sin)*b -> p.y;
     p[] -> outline.append;
  exit outline[]
  #);

-- GraphicsCanvasOpen: doPart --
do INNER;
   &Pixmap[] -> image[];
   size -> image.init;
   image[] -> doublebuffer.init;
   (if ANTIALIAS then
       (image.private.pixels, image.width, image.height) -> init_tables;
   if);

-- GraphicsCanvasOnRefresh: doPart --
do (# windowid, pixmapid: @integer;
      width, height: @integer;
   do (0xFFFF, 0xFFFF, 0xFFFF)  -> image.clear;
      doublebuffer.begin;
      children.scan
      (#
      do doublebuffer[] -> current.drawOn;
      #);
      THIS(Canvas).windowItemDevice -> windowid;
      doublebuffer.private.hdc -> pixmapid;
      image.width -> width;
      image.height -> height;
      (windowid, 0, 0, width, height, pixmapid, 0, 0, SRCCOPY) -> BitBlt;
      doublebuffer.end;
   #);
   
-- PixmapSurfaceInit: doPart --
do (* Do Nothing *)

-- PixmapSurfaceDrawText: doPart --
do (# xi, yi: @integer;
   do (0, 0) -> transform -> (xi, yi);
      (private.hdc, TA_BASELINE) -> SetTextAlign;
      (private.hdc, TRANSPARENT) -> SetBkMode;
      (private.hdc, xi, yi, @@theText.T[1], theText.lgth) -> TextOut;
   #);
   

-- PixmapSurfaceDrawRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFrameRect;
   #);

-- PixmapSurfaceFillRect: doPart --
do (# r: @ntRect;
   do (0, 0) -> transform -> (r.left, r.top);
      r.left + width -> r.right;
      r.top + height -> r.bottom;
      (private.hdc, r[], private.brush) ->  ntFillRect;
   #);
   
-- PixmapSurfaceDrawOval: doPart --
do (if ANTIALIAS then
       (# flag: @boolean;
          xi, yi: @integer;
          xr, yr: @real;
          cx, cy: @integer;
          curve: ^PointList;
       do (width/2,height/2) -> transform -> (cx, cy);
          (cx, cy, width/2, height/2) -> ComputeOutline -> curve[];
          true -> flag;
          curve.scan
          (#
          do current  -> (xr, yr);
             (if flag then
                 (xr, yr) -> aamoveto;
                 false -> flag;
              else
                 (xr, yr) -> aalineto;
             if);
          #);
          
       #);
   else
       (# nullbrush: @integer;
          prev: @integer;
          xi, yi: @integer;
       do NULL_BRUSH  -> GetStockObject -> nullbrush;
          (private.hdc, nullbrush) -> SelectObject -> prev;
          (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
          (private.hdc, prev) -> SelectObject;
       #);
   if);
-- PixmapSurfaceFillOval: doPart --
do (if ANTIALIAS then
       (# flag: @boolean;
          xi, yi: @integer;
          xr, yr: @real;
          cx, cy: @integer;
          curve: ^PointList;
          ntPoints: [0] @integer;
          size: @integer;
       do (width/2,height/2) -> transform -> (cx, cy);
          (cx, cy, width/2, height/2) -> ComputeOutline -> curve[];
          curve.size -> size;
          2 * size ->  ntPoints.new;
          curve.scan
          (# xi, yi: @integer;
             i: @integer;
          do i + 1 -> i;
             current -> (xi, yi);
             xi -> ntPoints[(i*2)-1];
             yi -> ntPoints[i*2];
          #);
          (private.hdc,@@ntPoints[1],size) -> Polygon;
       #);
    else
       (# nullpen: @integer;
          prev: @integer;
          xi, yi: @integer;
       do NULL_PEN -> GetStockObject -> nullpen;
          (private.hdc, nullpen) -> SelectObject -> prev;
          (0, 0) -> transform -> (xi, yi);
          (private.hdc, xi, yi, xi + width, yi + height) -> Ellipse;
          (private.hdc, prev) -> SelectObject;
       #);
   if);

-- PixmapSurfaceDrawPolygon: doPart --
do (# flag: @boolean;
      xi, yi: @integer;
   do true -> flag;
      points.scan
      (#
      do current -> transform -> (xi, yi);
         (if flag then
             (private.hdc, xi, yi, 0) -> MoveToEx;
             false -> flag;
          else
             (private.hdc, xi, yi) -> LineTo;
         if);
      #);
   #);
   
-- PixmapSurfaceFillPolygon: doPart --
do (# ntPoints: [0] @integer;
      size: @integer;
   do points.size -> size;
      2 * size ->  ntPoints.new;
      points.scan
      (# xi, yi: @integer;
         i: @integer;
      do i + 1 -> i;
         current -> transform -> (xi, yi);
         xi -> ntPoints[(i*2)-1];
         yi -> ntPoints[i*2];
      #);
      (private.hdc,@@ntPoints[1],size) -> Polygon;
   #);
   
-- PixmapSurfaceDrawPixmap: doPart --
do 

-- PixmapSurfaceStyle: doPart --
do

-- PixmapSurfacePen: doPart --
do (# red, green, blue: @int8u;
      colorref: @int32u;
      
   do theColor.red %srl 8 -> red;
      theColor.green %srl 8 -> green;
      theColor.blue %srl 8 -> blue;
      
      (if ANTIALIAS then
          (blue / 255, green / 255, red / 255) -> aapen;
      if);
      
      red %bor (green %sll 8) %bor (blue %sll 16) -> colorref;
      (private.hdc, colorref) -> SetTextColor;
      colorref -> CreateSolidBrush -> private.brush;
      (private.hdc, private.brush) -> SelectObject -> DeleteObject;
      (PS_SOLID, 0, colorref) -> CreatePen -> private.pen;
      (private.hdc, private.pen) -> SelectObject -> DeleteObject;
      
   #);

-- PixmapSurfacePush: doPart --
do (# new: ^Matrix;
   do &Matrix[] -> new[];
      private.current[] -> new.next[];
      new[] -> private.current[];
   #);

-- PixmapSurfacePop: doPart --
do private.current.next[] -> private.current[];

-- PixmapSurfaceTranslate: doPart --
do private.current.x + dx -> private.current.x;
   private.current.y + dy -> private.current.y;
   
-- PixmapSurfaceBegin: doPart --
do &Matrix[] -> private.current[];
   0 -> CreateCompatibleDC -> private.hdc;
   (private.hdc, content.private.handleToPixmap) -> SelectObject -> private.old_dib;
   0 -> CreateSolidBrush -> private.brush;
   (private.hdc, private.brush) -> SelectObject -> private.old_brush;
   (PS_SOLID, 0, 0) -> CreatePen -> private.pen;
   (private.hdc, private.pen) -> SelectObject -> private.old_pen;
   
-- PixmapSurfaceEnd: doPart --
do (private.hdc, private.old_dib) -> SelectObject;
   (private.hdc, private.old_brush) -> SelectObject -> DeleteObject;
   (private.hdc, private.old_pen) -> SelectObject -> DeleteObject;
   private.hdc -> DeleteDC;
   
   
-- PixmapSurfaceLib: attributes --

Matrix:
  (# next: ^Matrix;
     x, y: @real;
  #);

transform:
  (# x, y: @real;
  enter (x, y)
  do private.current.x + x -> x;
     private.current.y + y -> y;
  exit (x, y)
  #);

ntFillRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FillRect' -> callStd;
  exit result
  #);
ntFrameRect: external
  (# hdc: @integer; (* HDC *)
     theRect: ^ntRECT; (* const RECT FAR* *)
     hbr: @integer; (* HBRUSH *)
     result: @integer; (* int *)
  enter (hdc,theRect[],hbr)
  do 'FrameRect' -> callStd;
  exit result
  #);



-- PixmapSurfacePrivate: descriptor --
(# hdc: @integer;
   brush: @integer;
   pen: @integer;
   old_dib: @integer;
   old_brush: @integer;
   old_pen: @integer;
   current: ^Matrix;
#)
