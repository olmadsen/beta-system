ORIGIN '../controlsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
INCLUDE '../../graphics';
INCLUDE 'optionbutton_nti';
INCLUDE 'guienv_ntiprivate';
INCLUDE 'guienvattributes';
INCLUDE 'raster_ntiprivate';
INCLUDE '~beta/win32lib/v1.2/gdistructs';
INCLUDE '~beta/win32lib/v1.2/wingdiconsts';
INCLUDE '~beta/win32lib/v1.2/wingdi';
INCLUDE '~beta/win32lib/v1.2/windowsmisc';
INCLUDE '~beta/win32lib/v1.2/mousecursorsupport';
INCLUDE '~beta/win32lib/v1.2/scrollbarsupport';
INCLUDE '~beta/win32lib/v1.2/winuserconsts';
INCLUDE '~beta/win32lib/v1.2/errorhandling';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '~beta/sysutils/v1.5/cstring';
INCLUDE '~beta/basiclib/v1.5/math';

-- GUIENVcontrolCreate: descriptor --
(#
do isSubClass -> windowItemClassStatus;
   inner create;
#)

-- GUIENVcontrolOpen: descriptor --
(#
do inner open;
#)

-- GUIENVcontrolClose: descriptor --
(#
do inner close;
#)

-- controlLib: attributes --


-- GUIENVcontrolPrivate: descriptor --
(#
#)

-- GUIENVthumbMoved: descriptor --
(# 
do value + amount -> value;
   inner thumbMoved;
#)

-- GUIENVscrollbarPageDown: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue + scrollbarPageScrollamount,currentMax) -> min -> newValue;
   newValue -> value;
   inner pageDown;
#)

-- GUIENVscrollbarPageUp: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue - scrollbarPageScrollamount,0) -> max -> newValue;
   newValue -> value;
   inner pageUp;
#)

-- GUIENVscrollbarButtonDown: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue + scrollbarScrollamount,currentMax) -> min -> newValue;   
   newValue -> value;
   inner buttonDown;
#)

-- GUIENVscrollbarButtonUp: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue - scrollbarScrollamount,0) -> max -> newValue;
   newValue -> value;
   inner buttonUp;
#)

-- GUIENVScrollbarOnFrameChanged: descriptor --
(# 
do inner onFrameChanged;
#)

-- GUIENVScrollbarOnRefresh: descriptor --
(#
do inner onReFresh;
#)

-- GUIENVScrollbarOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVscrollbarOnActivate: descriptor --
(#
do inner onActivate;
#)

-- GUIENVscrollbarOnDeactivate: descriptor --
(#
do inner onDeactivate;
#)

-- GUIENVscrollbarSetScrollAmount: descriptor --
assertOpen
(# location::(# do 'Scrollbar.SetScrollAmount'->t[] #);
do value -> scrollbarScrollamount;
   theEventHandler.onScrollAmountChanged;
#)

-- GUIENVscrollbarGetScrollAmount: descriptor --
assertOpen
(# location::(# do 'Scrollbar.GetScrollAmount'->t[] #);
do scrollbarScrollamount -> value;
#)

-- GUIENVscrollbarSetPageScrollAmount: descriptor --
assertOpen
(# location::(# do 'Scrollbar.SetPageScrollAmount'->t[] #);
do value -> scrollbarPageScrollAmount;
   theEventHandler.onPageScrollAmountChanged;
#)

-- GUIENVscrollbarGetPageScrollAmount: descriptor --
assertOpen
(# location::(# do 'Scrollbar.GetPageScrollAmount'->t[] #);
do scrollbarPageScrollAmount -> value;
#)

-- GUIENVscrollbarSetMaxValue: descriptor --
(#
do (0,value) -> max -> value;
   (interfaceObjectID, SB_CTL, 0, value, 1) -> SetScrollRange;
   theEventHandler.onMaxValueChanged;
#)

-- GUIENVscrollbarGetMaxValue: descriptor --
(# minVal, maxVal: @longRef;
   windowID: @integer;
do interfaceObjectID -> windowID;
   (windowID, SB_CTL, minVal[], maxVal[] )  -> GetScrollRange;
   maxVal -> value;
#)

-- GUIENVscrollbarSetValue: descriptor --
(# 
do (pos,maxValue) -> min -> pos;
   (0,pos) -> max -> pos;
   (interfaceObjectID, SB_CTL, pos, 1) -> SetScrollPos;
#)

-- GUIENVscrollbarGetValue: descriptor --
(# result: @integer;
do (interfaceObjectID, SB_CTL) -> GetScrollPos -> result;
   result -> pos;
#)

-- GUIENVscrollbarSetLength: descriptor --
(# width,height: @integer;
do size -> (width,height);
   (if vertical then
       (width,theLength) -> size;
    else
       (theLength,height) -> size;
   if);
#)

-- GUIENVscrollbarGetLength: descriptor --
(# width,height: @integer;
do size -> (width,height);
   (if vertical then
       height -> theLength;
    else
       width -> theLength;
   if);
#)

-- GUIENVscrollbarCreate: descriptor --
(#
do 'SCROLLBAR' -> windowItemClass;
   (if vertical then
        SBS_VERT -> windowItemStyle;
    else
       SBS_HORZ  -> windowItemStyle;
   if);
   inner create;
#)

-- GUIENVscrollbarOpen: descriptor --
(# width,height,h,v,fw,fh: @integer;
do (0,0) -> position;
   (200,16) -> size;
   16 -> scrollbarScrollamount;
   50 -> scrollbarPageScrollamount; 
   inner open;
#)

-- GUIENVscrollbarClose: descriptor --
(#
do inner close;
#)

-- scrollbarLib: attributes --

scrollbarOrientation:
  (#
  enter private.scrollbarOrientation
  exit private.scrollbarOrientation
  #);
scrollbarScrollamount:
  (#
  enter private.scrollbarScrollamount
  exit private.scrollbarScrollamount
  #);
scrollbarPageScrollamount:
  (#
  enter private.scrollbarPageScrollamount
  exit private.scrollbarPageScrollamount
  #);
scrollbarActive:
  (#
  enter private.scrollbarActive
  exit private.scrollbarActive
  #);



-- GUIENVscrollbarPrivate: descriptor --
(# scrollbarOrientation: @integer;
   scrollbarScrollamount: @integer;
   scrollbarPageScrollamount: @integer;
   scrollbarActive: @boolean;
#)

-- GUIENVButtonOnFrameChanged: descriptor --
(#
do inner onFrameChanged;
#)

-- GUIENVButtonOnRefresh: descriptor --
(#
do inner onRefresh;
#)

-- GUIENVButtonOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVbuttonSetLabel: descriptor --
assertOpen
(# location::(# do 'Button.SetLabel'->t[] #);
   theTextStyle: ^textStyle;
   l: ^text;
   widthOfLabel,heightOfLabel,width,height: @integer;
do (if theLabel[]=NONE then &text[] -> theLabel[] if);
   theLabel.copy -> buttonLabel;
   (if (interfaceObjectID<>0) then
       (if (windowItemClassStatus=isSubClass) then
           theLabel.copy -> l[];
           (interfaceObjectID,theLabel) -> SetWindowText;
           (if (l.length > 5) then
               buttonStyle -> theTextStyle[];
               (if theTextStyle[]=NONE then
                   defaultButtonTextStyle -> theTextStyle[];
               if);
               size -> (width,height);
               l[] -> theTextStyle.widthOfText -> widthOfLabel;
               (if (width < widthOfLabel + 4) then
                   widthOfLabel + 4 -> width;
               if);
               (if (height < theTextStyle.lineHeight + 2) then
                   theTextStyle.lineHeight + 2 -> height;
               if);
               (width,height) -> size;
           if);
       if);
   if);
   update;
   theEventHandler.onLabelChanged;
#)

-- GUIENVbuttonGetLabel: descriptor --
assertOpen
(# location::(# do 'Button.GetLabel'->t[] #);
do buttonLabel -> theLabel[];
   theLabel.copy -> theLabel[];
#)

-- GUIENVbuttonSetStyle: descriptor --
assertOpen
(# location::(# do 'Button.SetStyle'->t[] #);
do (if theStyle[]<>NONE then
       theStyle[] -> buttonStyle;
       theStyle.create;
       (interfaceObjectID,WM_SETFONT,theStyle.textStyleID,1) -> SendMessage;
       theEventHandler.onStyleChanged;
   if);
#)

-- GUIENVbuttonGetStyle: descriptor --
assertOpen
(# location::(# do 'Button.GetStyle'->t[] #);
do buttonStyle -> theStyle[];
#)

-- GUIENVbuttonCreate: descriptor --
(#
do 'Button' -> windowItemClass;  
   inner create;
#)

-- GUIENVbuttonOpen: descriptor --
(# style: ^textStyle;
do this(button)[] -> getPatternName -> buttonLabel;
   defaultButtonTextStyle -> style[];
   (if (style[]=none) then
       &textStyle[] -> style[];
       'MS Sans Serif' -> style.name;
       8 -> style.size;
       style.create;
       style[] -> defaultButtonTextStyle;
   if);
   (interfaceObjectID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   style[] -> buttonStyle;
   inner open;
#)

-- GUIENVbuttonClose: descriptor --
(# buttonTextstyle: ^textStyle;
do inner close;
   buttonStyle -> buttonTextStyle[];
   (if buttonTextStyle[]<>defaultButtonTextStyle then
       (if buttonTextStyle[]<>none then
           buttonTextStyle.dispose;
       if);
   if);
#)

-- buttonLib: attributes --
buttonLabel:
  (#
  enter private.buttonLabel[]
  exit private.buttonLabel[]
  #);
buttonStyle:
  (#
  enter private.buttonStyle[]
  exit private.buttonStyle[]
  #);

-- GUIENVbuttonPrivate: descriptor --
(# buttonLabel: ^text;
   buttonStyle: ^textStyle;
#)

-- GUIENVpushButtonCreate: descriptor --
(#
do BS_PUSHBUTTON -> windowItemStyle;
   inner create;
#)

-- GUIENVpushButtonOpen: descriptor --
(# t: ^text;
do buttonLabel -> t[];
   inner open;
#)

-- GUIENVpushButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVpushButtonPrivate: descriptor --
(#
#)

-- GUIENVstaticTextOnRefresh: descriptor --
(# dc: @integer;
   l: ^text; cstr: @cstring; 
   theNtRectPtr: @integer; r: @rectangle;
   theTextStyle: ^textStyle;
   bkColor: @integer;
   width,height: @integer;
   resTextOut: @integer;
do inner onRefresh;
   windowItemDevice -> dc;
   buttonLabel -> l[]; l.reset;
   buttonStyle -> theTextStyle[];
   size -> (width,height);
   
   (if border.visible then
       (if width<3 then 3 -> width; if);
       (if height<3 then 3 -> height; if);
       (if (border.style=borderStyles.simple) then
           width - 2 -> width; height - 2 -> height;
           ((2,1),(width,height)) -> r;
        else
           width - 2-> width; height - 2 -> height;
           ((3,1),(width,height)) -> r;
       if);
    else
       ((0,0),size) -> r;
   if);
   r[] -> makeNtRectPtr -> theNtRectPtr;
   
   (if (theTextStyle[]<>none) then
       (dc,theTextStyle.textStyleID) -> SelectObject;
   if);
   (* COLOR_WINDOW *) COLOR_BTNFACE -> GetSysColor -> bkColor;
   (dc,bkColor) -> SetBkColor;
   (if (l.lgth>0) then
       l[] -> cstr.set;
       (* (dc,cstr.charPtr,-1,theNtRectPtr,DT_SINGLELINE+DT_LEFT+DT_VCENTER) 
        -> DrawText; *)
       (dc,cstr.charPtr,-1,theNtRectPtr,DT_LEFT+DT_WORDBREAK) 
         -> DrawText;
       cstr.free; 
   if);
   theNtRectPtr -> free;
#)

-- GUIENVstaticTextCreate: descriptor --
(#
do uienvStandardWindowClass -> windowItemClass;
   isStandardClass -> windowItemClassStatus;
   inner create;
#)

-- GUIENVstaticTextOpen: descriptor --
(# theTextStyle: ^textStyle;
   l: ^text;
   width, height, widthOfLabel: @integer;
do (50,16) -> size;
   defaultStaticTextTextStyle -> theTextStyle[];
   (if theTextStyle[]=none then
       &textStyle[] -> theTextStyle[];
       'MS Sans Serif' -> theTextStyle.name;
       8 -> theTextStyle.size;
       theTextStyle.create;
       theTextStyle[] -> defaultStaticTextTextStyle;
   if);
   theTextStyle[] -> buttonStyle;
   (interfaceObjectID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   inner open;
#)

-- GUIENVstaticTextClose: descriptor --
(# theTextStyle: ^textStyle;
do inner close;
   buttonStyle -> theTextStyle[];
   (if theTextStyle[]<>defaultStaticTextTextStyle then
      (if theTextStyle[]<>NONE then
         theTextStyle.dispose;
      if);
   if);
   NONE -> buttonStyle;
#)

-- GUIENVstaticTextPrivate: descriptor --
(#
#)

-- GUIENViconButtonOnRefresh: descriptor --
assertOpen 
(# location:: (# do 'iconbutton.onRefresh' -> t[] #);
   calcImageBounds:
     (# 
     do (if showLabel then
            theLabel[] -> theStyle.widthOfText -> textWidth;
            theStyle.lineHeight -> textHeight;
         else
            0 -> textWidth;
            0 -> textHeight;
        if);
        (if (private.iconButtonRaster[]<>none) then
            private.iconButtonRaster.width -> iconWidth;
            private.iconButtonRaster.height -> iconHeight;
         else
            0 -> iconWidth;
            0 -> iconHeight;
        if);
        (textHeight+iconHeight) -> imageHeight;
        (textWidth,iconWidth) -> max -> imageWidth;
     #);
   calcImageAnchors:
     (# width,height: @integer;
     do size -> (width,height);
        
        (width - iconWidth) div 2 -> iconAnchor.h;
        (height - imageHeight) div 2 -> iconAnchor.v;
        (width - textWidth) div 2 -> textAnchor.h;
        iconAnchor.v + iconHeight + theStyle.ascent -> textAnchor.v;
        theStyle.ascent -> ascent;
     #);
   drawBitmap: external
     (# hdc: @integer;
        hBitmap: @integer;
        xSrcPos, ySrcPos, xDestPos, yDestPos: @integer;
        result: @boolean;
     enter (hdc, hBitmap, xSrcPos, ySrcPos, xDestPos, yDestPos)
     do 'drawBitmap' -> callC;
     exit result
     #);
   DrawTransparentBitmap: external
     (# hdc, hBitmap, xStart, yStart, transparentColor: @integer;
     enter (hdc, hBitmap, xStart, yStart, transparentColor)
     do callC;
     #);
   result: @boolean;
   theStyle: ^textStyle; ascent: @integer;
   theLabel: ^text; cstr: @cstring;
   imageWidth,imageHeight,textWidth,textHeight,iconWidth,iconHeight: @integer;
   iconAnchor,textAnchor: @point;
   lblRect: @rectangle; hdc, hbr: @integer; 
   width,height: @integer;
   doReleaseHdc: @boolean;
   bkColor,textColor: @integer;
   windowID: @integer;
do interfaceObjectID -> windowID;
   (if (windowItemDevice=0) then
       windowID -> GetDC -> hdc;
       true -> doReleaseHdc;
    else windowItemDevice -> hdc;
   if);
   (if hilite then
       COLOR_HIGHLIGHT -> GetSysColor -> bkColor;
       COLOR_HIGHLIGHTTEXT -> GetSysColor -> textColor;
       (hdc,textColor) -> SetTextColor;
    else
       (* COLOR_WINDOW *) COLOR_BTNFACE  -> GetSysColor -> bkColor;
   if);
   (hdc,bkColor) -> SetBkColor;
   style -> theStyle[];
   label -> theLabel[];
   calcImageBounds;
   calcImageAnchors;
   (if (private.iconButtonRaster[]<>none) then
       (if private.iconButtonRaster.isIcon then
           (hdc,
           iconAnchor.h,iconAnchor.v,private.iconButtonRaster.handleToIcon) 
             -> DrawIcon -> result;
        else
           (windowID,
           private.iconButtonRaster.handleToBitmap,0,0,iconAnchor.h,iconAnchor.v)
             -> drawBitmap -> result; 
       if);
       (if not result then
           'iconbutton.onRefresh: drawBitmap failed. Errorcode: ' -> puttext;
           GetLastError -> putint; newline;
       if);
   if);
   (if showLabel then
       size -> (width,height);
       textAnchor.v - theStyle.ascent -> lblRect.top;
       1 -> lblRect.left;
       width - 1 -> lblRect.right;
       textAnchor.v + theStyle.descent  -> lblRect.bottom;
       (hdc,theStyle.textStyleID) -> SelectObject;
       
       theLabel[] -> cstr.set;
       (hdc,TA_CENTER) -> SetTextAlign;
       (hdc,width div 2, lblRect.top, cstr.charPtr, cstr.length)
         -> TextOut;
   if);
   (if doReleaseHdc then 
       (windowID,hdc) -> ReleaseDC;
   if);
   inner onRefresh;
#)

-- GUIENViconbuttonOnHiliteChanged: descriptor --
(# hdc: @integer;
   doReleaseHdc: @boolean;
   windowID: @integer;
do inner onHiliteChanged;
   interfaceObjectID -> windowID;
   (if (windowItemDevice=0) then
       windowID -> GetDC -> hdc;
       true -> doReleaseHdc;
    else windowItemDevice -> hdc;
   if);
   update; 
   (if doReleaseHdc then 
       (windowID,hdc) -> ReleaseDC;
   if);
#)

-- GUIENViconButtonSetShowLabel: descriptor --
assertOpen
(# location::(# do 'IconButton.SetShowLabel'->t[] #);
do doShow -> iconButtonShowLabel;
   theEventHandler.onShowLabelChanged;
   updateMaybe;
#)

-- GUIENViconButtonGetShowLabel: descriptor --
assertOpen
(# location::(# do 'IconButton.GetShowLabel'->t[] #);
do iconButtonShowLabel -> doShow;
#)

-- GUIENViconButtonSetIcon: descriptor --
assertOpen
(# location::(# do 'IconButton.SetIcon'->t[] #);
do theIcon[] -> iconButtonRaster;
   theEventHandler.onIconChanged;
   updateMaybe;
#)

-- GUIENViconButtonGetIcon: descriptor --
assertOpen
(# location::(# do 'IconButton.GetIcon'->t[] #);
do iconButtonRaster -> theIcon[];
#)

-- GUIENViconButtonCreate: descriptor --
(#
do uienvStandardWindowClass -> windowItemClass;
   isStandardClass  -> windowItemClassStatus;
   inner create;
#)

-- GUIENViconButtonOpen: descriptor --
(#
do true -> iconButtonShowLabel;
   (* hide; *)
   inner open;
#)

-- GUIENViconButtonClose: descriptor --
(#
do inner close;
#)

-- iconButtonLib: attributes --
iconButtonShowLabel:
  (#
  enter private.iconButtonShowLabel
  exit private.iconButtonShowLabel
  #);
iconButtonRaster:
  (#
  enter private.iconButtonRaster[]
  exit private.iconButtonRaster[]
  #);

-- GUIENViconButtonPrivate: descriptor --
(# iconButtonShowLabel: @boolean;
   iconButtonRaster: ^raster;
#)

-- optionButtonLib: attributes --

preferredSize:
  (# prefW, prefH: @integer;
     l: ^text; theTextStyle: ^textStyle;
     widthOfLabel: @integer;
  do this(optionButton).buttonLabel -> l[];
     (if (l[]=none) then &text[] -> l[]; if);
     this(optionButton).buttonStyle -> theTextStyle[];
     (if theTextStyle[]<>NONE then
         l[] -> theTextStyle.widthOfText -> widthOfLabel;
         (if l.length>0 then
             widthOfLabel + 4 -> widthOfLabel;
         if);
      else
         l.length + 5 -> widthOfLabel;
     if);
     private.theComboBox.preferredSize -> (prefW,prefH);
     widthOfLabel + prefW -> prefW;
     private.theComboBox.calcTheHeight;
     private.theComboBoxHeight + 4 -> prefH;
  exit (prefW,prefH)
  #); 

updateHeightOfDropDownList:
  (# w,h: @integer;
     itemH,noOfItems: @integer;
  do (dropDownListID,CB_GETITEMHEIGHT,0,0) -> SendMessage -> itemH;
     (dropDownListID,CB_GETCOUNT,0,0) -> SendMessage -> noOfItems;
     1 + noOfItems -> noOfItems; (* to get the right hight. *)
     
     private.theComboBox.size -> (w,h);
     (w,itemH*noOfItems) -> private.theComboBox.size;
  #);

-- GUIENVoptionButtonOnLabelChanged: descriptor --
(# l: ^text; 
   x,y,w,h,heightOfLabel,widthOfLabel: @integer;
   theTextStyle: ^textStyle;
   labelH: @integer;
   result: @integer;
do buttonLabel -> l[];
   buttonStyle -> theTextStyle[];
   (if theTextStyle[]=NONE then
       defaultButtonTextStyle -> theTextStyle[];
   if);
   (mbLabelID,l) -> SetWindowText;
   
   l[] -> theTextStyle.widthOfText -> widthOfLabel;
   theTextStyle.lineHeight -> heightOfLabel;
   
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2) - (heightOfLabel div 2)  -> labelH;
    else
       heightOfLabel div 2  -> labelH;
   if);
   (mbLabelID,0,labelH,widthOfLabel,heightOflabel,1) -> MoveWindow -> result;
   (result,'optionButtonOnLabelChanged(1)')  -> checkNullError;
   
   position -> (x,y); size -> (w,h);
   (if l.length>0 then widthOfLabel+2 -> widthOfLabel; if);
   (x+widthOfLabel,y+2) ->  private.theComboBox.position;
   (w-widthOfLabel,100) -> private.theComboBox.size;
   private.theComboBox.bringToFront;
   inner onLabelChanged;
#)
-- GUIENVoptionButtonOnStyleChanged: descriptor --
(# l: ^text; 
   x,y,w,h,heightOfLabel,widthOfLabel: @integer;
   theTextStyle: ^textStyle;
   labelH: @integer;
   result: @integer;
do buttonLabel -> l[];
   buttonStyle -> theTextStyle[];
   (if theTextStyle[]=NONE then
       defaultButtonTextStyle -> theTextStyle[];
   if);
   (mbLabelID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   (mbLabelID,l) -> SetWindowText;
   (dropDownListID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   
   l[] -> theTextStyle.widthOfText -> widthOfLabel;
   theTextStyle.lineHeight -> heightOfLabel;
   
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2) - (heightOfLabel div 2)  -> labelH;
    else
       heightOfLabel div 2  -> labelH;
   if);
   
   (mbLabelID,0,labelH,widthOfLabel,heightOflabel,1) -> MoveWindow -> result;
   (result,'optionButtonOnStyleChanged(1)')  -> checkNullError;
   
   (if l.length>0 then widthOfLabel+2 -> widthOfLabel; if);
   position -> (x,y); size -> (w,h);
   (x+widthOfLabel,y+2) ->  private.theComboBox.position;
   (w-widthOfLabel,100) -> private.theComboBox.size;
   private.theComboBox.bringToFront;
   inner onStyleChanged;
#)
-- GUIENVoptionButtonSetCurItem: descriptor --
assertOpen
(# location::(# do 'OptionButton.SetCurItem'->t[] #);
do (dropDownListID,CB_SETCURSEL,itemNo-1,0) -> sendMessage;
   (* 'Not implemented.' -> screen.putline; *)
#)

-- GUIENVoptionButtonGetCurItem: descriptor --
assertOpen
(# location::(# do 'OptionButton.GetCutItem'->t[] #);
do (dropDownListID,CB_GETCURSEL,0,0) -> sendMessage -> itemNo;
   itemNo + 1 -> itemNo;
#)

-- GUIENVoptionButtonSetPopupMenu: descriptor --
assertOpen
(# location::(# do 'OptionButton.SetPopupMenu'->t[] #);
   cstr: @cString; result,inx: @integer;
   menuItemId: @integer;
   noOfItems: @integer;
do (if (popupMenu[]<>optionButtonPopupMenu) then
       (if (optionButtonPopupMenu<>none) then
           (if (dropDownListID<>0) then
               (dropDownListID,CB_RESETCONTENT,0,0) -> sendMessage -> result;
               clearOptionButtonMenuItems;
               none -> optionButtonPopupMenu;
           if);
       if);
       
       (if (popupMenu[]<>none) then
           popupMenu[] -> optionButtonPopupMenu;
           popupMenu.scan
           (# 
           do current.name -> cstr.set;
              (dropDownListID,CB_ADDSTRING,0,cstr.charPtr) -> sendMessage -> inx;
              (if inx
               //CB_ERR
               //CB_ERRSPACE then
                  'optionButtonSetPopupMenu failed!! Errorcode: ' -> puttext;
                  GetLastError -> putint; newline;
               else
                  (inx,current[]) -> addoptionButtonMenuItem;
              if);
           #);
           (dropDownListID,CB_GETCOUNT,0,0) -> sendMessage -> noOfItems;
           (if noOfItems
            //CB_ERR then 
               'optionButton: CB_GETCOUNT failed!! Errorcode: ' -> puttext;
               GetLastError -> putint; newline;
            //0 then
            else
               (dropDownListID,CB_SETCURSEL,0,0) -> sendMessage -> inx;
               (if inx
                //CB_ERR
                //CB_ERRSPACE then
                   'optionButton. CB_SETCURSEL failed!! Errorcode: ' -> puttext;
                   GetLastError -> putint; newline;
                else
                   (* 1 -> popupMenu.getMenuitemByNumber -> firstMenuItem[];
                    firstMenuItem.theEventHandler.onSelect; *)
               if);
           if);
           updateHeightOfDropDownList;
       if);
       theEventHandler.onPopUpMenuChanged;
   if);
#)

-- GUIENVoptionButtonGetPopupMenu: descriptor --
assertOpen
(# location::(# do 'OptionButton.GetPopupMenu'->t[] #);
do optionButtonPopupMenu -> popupMenu[];
#)

-- GUIENVoptionButtonCreate: descriptor --
(# 
do (* WS_BORDER -> windowItemStyle;   *)
   uienvStandardWindowClass -> windowItemClass;
   isStandardClass  -> windowItemClassStatus;
   inner create;
#)

-- GUIENVoptionButtonOpen: descriptor --
(# l: ^text; 
   x,y,w,h,heightOfLabel,widthOfLabel,labelH: @integer;
   theTextStyle: ^textStyle;
   style: @integer;
   class,name: @text;
   ID,hInstance: @integer;
   r: ^rectangle;
   result: @integer;
do 
   'STATIC' -> class;
   'Label' -> name;
   UniqueID -> ID;
   0 -> style;
   (0,class,name,WS_CHILDWINDOW + 
   style,0,0,40,20,interfaceObjectID,ID,hInstance,0) -> CreateWindowEx
     -> mbLabelID; 
   
   position -> (x,y);
   father[] -> private.theComboBox.open;
   (x+41,y+2) -> private.theComboBox.position;
   (59,100) -> private.theComboBox.size;
   
   (mbLabelID,SW_SHOWNORMAL) -> ShowWindow; 
   (100,22) -> size;
   
   inner open;
   
   buttonLabel -> l[];
   buttonStyle -> theTextStyle[];
   (if theTextStyle[]=NONE then
       defaultButtonTextStyle -> theTextStyle[];
   if);
   (mbLabelID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   (mbLabelID,l) -> SetWindowText;
   
   (dropDownListID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   
   l[] -> theTextStyle.widthOfText -> widthOfLabel;
   theTextStyle.lineHeight -> heightOfLabel;
   
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2) - (heightOfLabel div 2)  -> labelH;
    else
       heightOfLabel div 2  -> labelH;
   if);
   
   (mbLabelID,1,labelH,widthOfLabel,heightOflabel,1) -> MoveWindow -> result;
   (result,'optionButtonOpen(1)')  -> checkNullError;
   
   position -> (x,y); size -> (w,h);
   (if l.length>0 then widthOfLabel+2 -> widthOfLabel; if);
   (x+widthOfLabel,y+2) -> private.theComboBox.position;
   (w-widthOfLabel,100) -> private.theComboBox.size;
   private.theComboBox.bringToFront;
   private.theVisibleChangedAction[]  -> this(optionButton).AppendAction;
   private.theEnableTargetAction[] -> this(optionButton).AppendAction;
   private.optFrameChangedAction[] -> this(optionButton).AppendAction;
#)

-- GUIENVoptionButtonClose: descriptor --
(#
do inner close;
   private.theVisibleChangedAction[]  -> deleteAction;
   private.theEnableTargetAction[] -> deleteAction;
   private.optFrameChangedAction[] -> deleteAction;
   private.theComboBox.close;
#)

-- GUIENVtoggleButtonSetState: descriptor --
assertOpen
(# location::(# do 'ToggleButton.SetState'->t[] #);
do (if theState then 
       (interfaceObjectID, BM_SETCHECK, 1, 0) -> SendMessage;
    else 
       (interfaceObjectID, BM_SETCHECK, 0, 0) -> SendMessage;
   if);
   theEventHandler.onStateChanged;
#)

-- GUIENVtoggleButtonGetState: descriptor --
assertOpen
(# location::(# do 'ToggleButton.GetState'->t[] #); 
   tempState: @integer;
do (interfaceObjectID, BM_GETCHECK, 0, 0) -> SendMessage -> tempState;
   (if tempState<>0 then
       TRUE -> theState;
    else
       FALSE -> theState;
   if);
#)

-- GUIENVtoggleButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVtoggleButtonOpen: descriptor --
(# 
do inner open;
#)

-- GUIENVtoggleButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVtoggleButtonPrivate: descriptor --
(# 
#)

-- GUIENVradioButtonCreate: descriptor --
(#
do BS_RADIOBUTTON -> windowItemStyle;
   inner create;
#)

-- GUIENVRadioButtonOpen: descriptor --
(#
do private.theMouseUpAction[] -> appendAction;
   private.theKeyDownAction[] -> appendAction;
   inner open;
#)

-- GUIENVRadioButtonClose: descriptor --
(#
do inner close;
   private.theMouseUpAction[] -> deleteAction;
   private.theKeyDownAction[] -> deleteAction;
#)

-- GUIENVradioButtonPrivate: descriptor --
(# theMouseUpAction: @mouseUpAction
     (# 
     do not state -> state;
     #);
   theKeyDownAction: @keyDownAction
     (# 
     do (if theEvent.ch=ascii.sp then
            not state -> state;
        if);
     #);
#)

-- GUIENVcheckBoxCreate: descriptor --
(#
do BS_AUTOCHECKBOX -> windowItemStyle;
   inner create;
#)

-- GUIENVcheckBoxOpen: descriptor --
(#
do inner open;
#)

-- GUIENVcheckBoxClose: descriptor --
(#
do inner close;
#)

-- GUIENVcheckBoxPrivate: descriptor --
(#
#)

-- GUIENVeditTextSetStyle: descriptor --
(#
do txStyle[] -> editTextStyle;
   txStyle[] -> updateStyle;
   txStyle.create;
   (interfaceObjectID,WM_SETFONT,txStyle.textStyleID,1) -> SendMessage; 
#)

-- GUIENVeditTextGetStyle: descriptor --
(#
do editTextStyle -> txStyle[];
#)

-- GUIENVeditTextSetContents: descriptor --
(# cstr: @cString; result: @integer;
do str[] -> cstr.set;
   (interfaceObjectID,WM_SETTEXT, 0, cstr.charPtr) -> sendMessage -> result;
   (result,'editTextSetContents') -> checkSetTextError;
   cstr.free;
#)

-- GUIENVeditTextGetContents: descriptor --
(# result: @integer;
   cstr: @cString;
   length: @integer; 
do (interfaceObjectID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
   length + 1 -> cstr.init;
   (interfaceObjectID,WM_GETTEXT, length+1, cstr.charPtr) -> sendMessage 
      -> result;
   (if (result<>length) then
       'TextField.getContents: Did not copy all text!' -> screen.putLine;
   if);
   &text[] -> str[];
   cstr.get -> str[]; 
   str.T.range -> str.pos -> str.lgth;
   cstr.free;
#)

-- GUIENVeditTextonFrameChanged: descriptor --
(# 
do inner onFrameChanged;
   setEditTextMargins;
#)

-- GUIENVeditTextonKeyDown: descriptor --
(# insertChar: @boolean;
   info: ^messageInfo;
do currentMessageInfo -> info[];
   FALSE -> info.callback;
   true -> insertChar;
   (if (ch=ascii.cr) then  false -> insertChar; if);
   (if insertChar then
       callDefaultWindowProc;
   if);
   inner onKeyDown;
#)

-- GUIENVeditTextonMouseDown: descriptor --
(# 
do inner onMouseDown;
#)

-- GUIENVeditTextonRefresh: descriptor --
(# width,height: @integer;
   info: ^messageInfo;
do inner onRefresh;
   currentMessageInfo -> info[];
   FALSE -> info.callback;
   callDefaultWindowProc;
   size -> (width,height);
   (this(editText)[],borderStyles.shadowIn,0,0,width,height) -> drawBorder;
#)

-- GUIENVeditTextonEnableTarget: descriptor --
(#
do inner onEnableTarget;
#)

-- GUIENVeditTextonDisableTarget: descriptor --
(#
do inner onDisableTarget;
#)

-- GUIENVeditTextCreate: descriptor --
(# wStyle: @integer;
do 'EDIT' -> windowItemClass;
   (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
   (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
   wStyle  -> windowItemStyle;
   true -> this(windowItem).private.borderHandledLocally;
   inner create;
#)

-- GUIENVeditTextOpen: descriptor --
(# style: ^textStyle; 
   windowID: @integer;
   t: ^text;
do interfaceObjectID -> windowID;
   defaultEditTextTextStyle -> style[];
   (if style[]=none then
       &textStyle[] -> style[];
       'MS Sans Serif' -> style.name;
       8 -> style.size;
       style.create;
       style[] -> defaultEditTextTextStyle;
   if);
   style[] -> editTextStyle;
   cursors.iBeam[] -> theCursor;
   false -> border.visible;
   
   &text[] -> t[]; 
   (if ( (windowID,t) -> SetWindowText) = 0  then
      (0,'editTextOpen.SetWindowText') -> checkNullError;
   if);
   
   inner open;
   
   editTextStyle -> style[];
   (if style[]<>defaultEditTextTextStyle then
       style.create;
   if);
   (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;    
   
   setEditTextMargins;   
#)

-- GUIENVeditTextClose: descriptor --
(# theTextStyle: ^textStyle;
do inner close;
   editTextStyle -> theTextStyle[];
   (if theTextStyle[]<>defaultEditTextTextStyle then
       (if theTextStyle[]<>NONE then
           theTextStyle.dispose;
       if);
   if);
#)

-- editTextLib: attributes --
setEditTextMargins:
  (# width,height: @integer;
  do size -> (width,height);
     (if (border.style=borderStyles.simple) then
         width - 1 -> width; height - 1 -> height;
         (2,2,width,height,interfaceObjectID) -> setEditRect; 
      else
         width - 2 -> width; height - 2 -> height;
         (3,3,width,height,interfaceObjectID) -> setEditRect; 
     if);
  #);
setEditRect: external
  (# x,y,width,height,hWnd: @integer;
  enter (x,y,width,height,hWnd)
  do callC;
  #);
editTextStyle:
  (#
  enter private.editTextStyle[]
  exit private.editTextStyle[]
  #);
updateStyle:
  (# style: ^textStyle;
  enter style[]
  do
  #);

WS_EX_CLIENTEDGE: (# exit 0x00000200 #);

-- GUIENVeditTextPrivate: descriptor --
(# editTextStyle: ^textStyle;
   OsMajorVersion: @integer;
#)

-- GUIENVsetDefaultButton: descriptor --
(# result, newStyle, basicStyle: @integer;
do theButton[] -> windowDefaultButton;
   WS_CHILDWINDOW + BS_DEFPUSHBUTTON -> newStyle;
   (theButton.interfaceObjectID, BM_SETSTYLE, newStyle, 1) -> SendMessage;
#)

-- GUIENVgetDefaultButton: descriptor --
(#
do windowDefaultButton -> theButton[];
#)


-- GUIENVcontrolputLayout: doPart --
do
   
-- GUIENVcontrolgetLayout: doPart --
do
   
-- GUIENVscrollbarputLayout: doPart --
do
   
-- GUIENVscrollbargetLayout: doPart --
do
   
-- GUIENVbuttonputLayout: doPart --
do
   
-- GUIENVbuttongetLayout: doPart --
do
   
-- GUIENVpushButtonputLayout: doPart --
do
   
-- GUIENVpushButtongetLayout: doPart --
do
-- GUIENVstaticTextputLayout: doPart --
do
   
-- GUIENVstaticTextgetLayout: doPart --
do
   
-- GUIENViconButtonputLayout: doPart --
do
   
-- GUIENViconButtongetLayout: doPart --
do
   
-- GUIENVoptionButtonputLayout: doPart --
do
   
-- GUIENVoptionButtongetLayout: doPart --
do
   
-- GUIENVtoggleButtonputLayout: doPart --
do
   
-- GUIENVtoggleButtongetLayout: doPart --
do
   
-- GUIENVradioButtonputLayout: doPart --
do
   
-- GUIENVradioButtongetLayout: doPart --
do
   
-- GUIENVcheckBoxputLayout: doPart --
do
   
-- GUIENVcheckBoxgetLayout: doPart --
do
   
-- GUIENVeditTextputLayout: doPart --
do
   
-- GUIENVeditTextgetLayout: doPart --
do
