ORIGIN '../controlsbody' (*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
;
INCLUDE '../../graphics'
        'optionbutton_nti'
        'guienv_ntiprivate'
        'guienvattributes'
        '~beta/win32lib/gdistructs'
        '~beta/win32lib/wingdiconsts'
        '~beta/win32lib/wingdi'
        '~beta/win32lib/windowsmisc'
        '~beta/win32lib/mousecursorsupport'
        '~beta/win32lib/scrollbarsupport'
        '~beta/win32lib/winuserconsts'
        '~beta/win32lib/errorhandling'
        '~beta/sysutils/objinterface'
        '~beta/sysutils/cstring'
        '~beta/basiclib/math';
-- GUIENVcontrolCreate: Descriptor --
(# 
do
   isSubClass->windowItemClassStatus; 'Button'->windowItemClass; INNER create; 
#)  

-- GUIENVcontrolOpen: Descriptor --
(#  do false->THIS(windowItem).private.updateOnResize; INNER open;  #)  

-- GUIENVcontrolClose: Descriptor --
(#  do INNER close;  #)  

-- controlLib: Attributes --
  

-- GUIENVcontrolPrivate: Descriptor --
(#  #)  

-- GUIENVthumbMoved: Descriptor --
(#  do value+amount->value; INNER thumbMoved;  #)  

-- GUIENVscrollbarPageDown: Descriptor --
(# currentValue,newValue,currentMax: @integer; 
do
   value->currentValue;
   maxValue->currentMax;
   (currentValue+scrollbarPageScrollamount,currentMax)->min->newValue;
   newValue->value;
   INNER pageDown;
   
#)  

-- GUIENVscrollbarPageUp: Descriptor --
(# currentValue,newValue,currentMax: @integer; 
do
   value->currentValue;
   maxValue->currentMax;
   (currentValue-scrollbarPageScrollamount,0)->max->newValue;
   newValue->value;
   INNER pageUp;
   
#)  

-- GUIENVscrollbarButtonDown: Descriptor --
(# currentValue,newValue,currentMax: @integer; 
do
   value->currentValue;
   maxValue->currentMax;
   (currentValue+scrollbarScrollamount,currentMax)->min->newValue;
   newValue->value;
   INNER buttonDown;
   
#)  

-- GUIENVscrollbarButtonUp: Descriptor --
(# currentValue,newValue,currentMax: @integer; 
do
   value->currentValue;
   maxValue->currentMax;
   (currentValue-scrollbarScrollamount,0)->max->newValue;
   newValue->value;
   INNER buttonUp;
   
#)  

-- GUIENVScrollbarOnFrameChanged: Descriptor --
(#  do INNER onFrameChanged;  #)  

-- GUIENVScrollbarOnRefresh: Descriptor --
(#  do INNER onReFresh;  #)  

-- GUIENVScrollbarOnMouseDown: Descriptor --
(#  do INNER onMouseDown;  #)  

-- GUIENVscrollbarOnActivate: Descriptor --
(#  do INNER onActivate;  #)  

-- GUIENVscrollbarOnDeactivate: Descriptor --
(#  do INNER onDeactivate;  #)  

-- GUIENVscrollbarSetScrollAmount: Descriptor --
(# 
do
   assertOpen;
   value->scrollbarScrollamount;
   theEventHandler.onScrollAmountChanged;
   
#)  

-- GUIENVscrollbarGetScrollAmount: Descriptor --
(#  do assertOpen; scrollbarScrollamount->value;  #)  

-- GUIENVscrollbarSetPageScrollAmount: Descriptor --
(# 
do
   assertOpen;
   value->scrollbarPageScrollAmount;
   theEventHandler.onPageScrollAmountChanged;
   
#)  

-- GUIENVscrollbarGetPageScrollAmount: Descriptor --
(#  do assertOpen; scrollbarPageScrollAmount->value;  #)  

-- GUIENVscrollbarSetMaxValue: Descriptor --
(# 
do
   (0,value)->max->value;
   (interfaceObjectID,SB_CTL,0,value,1)->SetScrollRange;
   theEventHandler.onMaxValueChanged;
   
#)  

-- GUIENVscrollbarGetMaxValue: Descriptor --
(#
   minVal,maxVal: @com (# v: @integer #);
   windowID: @integer;
   (* BOOL WINAPI GetScrollRange(HWND, int, int FAR*, int FAR* ); *)
   GetScrollRange: external
   (* May cause callback: f you specify a scroll bar control, GetScrollRange 
    * sends an SBM_GETRANGE message to the control.
    *)
     (#
        hwnd: @integer;
        (* HWND *)
        nBar: @integer;
        (* int *)
        minPos: @integer;
        (* int FAR* *)
        maxPos: @integer;
        (* int FAR* *)
        result: @integer
     enter (hwnd,nBar,minPos,maxPos)
     do callStd; 
     exit result
     #);
   
do
   interfaceObjectID->windowID;
   (windowID,SB_CTL,@@ minVal.v,@@ maxVal.v)->GetScrollRange;
   maxVal.v->value;
   
#)  

-- GUIENVscrollbarSetValue: Descriptor --
(# 
do
   (pos,maxValue)->min->pos;
   (0,pos)->max->pos;
   (interfaceObjectID,SB_CTL,pos,1)->SetScrollPos;
   theEventHandler.onValueChanged;
   
#)  

-- GUIENVscrollbarGetValue: Descriptor --
(#  do (interfaceObjectID,SB_CTL)->GetScrollPos->pos;  #)  

-- GUIENVscrollbarSetLength: Descriptor --
(# width,height: @integer; 
do
   size->(width,height);
   (if vertical then
       (width,theLength)->size; 
    else
       (theLength,height)->size; 
   if);
   
#)  

-- GUIENVscrollbarGetLength: Descriptor --
(# width,height: @integer; 
do
   size->(width,height);
   (if vertical then height->theLength;  else width->theLength;  if);
   
#)  

-- GUIENVscrollbarCreate: Descriptor --
(# 
do
   'SCROLLBAR'->windowItemClass;
   (if vertical then
       SBS_VERT->windowItemStyle; 
    else
       SBS_HORZ->windowItemStyle; 
   if);
   INNER create;
   
#)  

-- GUIENVscrollbarOpen: Descriptor --
(# 
do
   (0,0)->position;
   (200,16)->size;
   16->scrollbarScrollamount;
   50->scrollbarPageScrollamount;
   INNER open;
   
#)  

-- GUIENVscrollbarClose: Descriptor --
(#  do INNER close;  #)  

-- scrollbarLib: Attributes --
scrollbarOrientation:
  (# 
  enter private.scrollbarOrientation
  exit private.scrollbarOrientation
  #);
scrollbarScrollamount:
  (# 
  enter private.scrollbarScrollamount
  exit private.scrollbarScrollamount
  #);
scrollbarPageScrollamount:
  (# 
  enter private.scrollbarPageScrollamount
  exit private.scrollbarPageScrollamount
  #);
scrollbarActive:
  (#  enter private.scrollbarActive exit private.scrollbarActive #);
  

-- GUIENVscrollbarPrivate: Descriptor --
(#
   scrollbarOrientation: @integer;
   scrollbarScrollamount: @integer;
   scrollbarPageScrollamount: @integer;
   scrollbarActive: @boolean;
   
#)  

-- GUIENVButtonOnFrameChanged: Descriptor --
(#  do INNER onFrameChanged;  #)  

-- GUIENVButtonOnRefresh: Descriptor --
(#  do INNER onRefresh;  #)  

-- GUIENVButtonOnMouseDown: Descriptor --
(#  do INNER onMouseDown;  #)  

-- GUIENVbuttonSetLabel: Descriptor --
(#
   theTextStyle: ^textStyle;
   l: ^text;
   widthOfLabel,heightOfLabel,width,height: @integer;
   
do
   assertOpen;
   (if theLabel[] = none then &text[]->theLabel[] if);
   theLabel.copy->buttonLabel;
   (if (interfaceObjectID <> 0) then
       (if (windowItemClassStatus = isSubClass) then
           theLabel.copy->l[];
           (interfaceObjectID,theLabel)->SetWindowText;
           (if (l.length > 5) then
               private.buttonTextStyle[]->theTextStyle[];
               (if theTextStyle[] = none then
                   defaultButtonTextStyle->theTextStyle[]; 
               if);
               size->(width,height);
               l[]->theTextStyle.widthOfText->widthOfLabel;
               (if (width < widthOfLabel+4) then widthOfLabel+4->width;  if);
               (if (height < theTextStyle.lineHeight+2) then
                   theTextStyle.lineHeight+2->height; 
               if);
               (width,height)->size;
               
           if);
           
       if);
       
   if);
   update;
   theEventHandler.onLabelChanged;
   
#)  

-- GUIENVbuttonGetLabel: Descriptor --
(#  do assertOpen; buttonLabel->theLabel[]; theLabel.copy->theLabel[];  #)  

-- GUIENVbuttonSetStyle: Descriptor --
(# 
do
   assertOpen;
   (if theStyle[] <> none then
       theStyle[]->private.buttonTextStyle[];
       theStyle.create;
       (interfaceObjectID,WM_SETFONT,theStyle.textStyleID,1)->SendMessage;
       theEventHandler.onStyleChanged;
       
   if);
   
#)  

-- GUIENVbuttonGetStyle: Descriptor --
(#  do assertOpen; private.buttonTextStyle[]->theStyle[];  #)  

-- GUIENVForeGroundColor: Descriptor --
(#  do c[]->makeColorRef->private.theFGColorref #)  

-- GUIENVbuttonCreate: Descriptor --
(#  do 'Button'->windowItemClass; INNER create;  #)  

-- GUIENVbuttonOpen: Descriptor --
(# style: ^textStyle; 
do
   THIS(button)[]->getPatternName->buttonLabel;
   defaultButtonTextStyle->style[];
   (if (style[] = none ) then
       &textStyle[]->style[];
       'MS Sans Serif'->style.name;
       8->style.size;
       style.create;
       style[]->defaultButtonTextStyle;
       
   if);
   (interfaceObjectID,WM_SETFONT,style.textStyleID,1)->SendMessage;
   style[]->private.buttonTextStyle[];
   INNER open;
   
#)  

-- GUIENVbuttonClose: Descriptor --
(#  do INNER close; none ->private.buttonTextStyle[];  #)  

-- buttonLib: Attributes --
buttonLabel: (#  enter private.buttonLabel[] exit private.buttonLabel[] #);
  

-- GUIENVbuttonPrivate: Descriptor --
(# buttonLabel: ^text; buttonTextStyle: ^textStyle; theFgColorRef: @integer
#)  

-- GUIENVpushButtonCreate: Descriptor --
(#  do BS_PUSHBUTTON->windowItemStyle; INNER create;  #)  

-- GUIENVpushButtonOpen: Descriptor --
(#  do INNER open;  #)  

-- GUIENVpushButtonClose: Descriptor --
(#  do INNER close;  #)  

-- GUIENVpushButtonPrivate: Descriptor --
(#  #)  

-- GUIENVstaticTextOnRefresh: Descriptor --
(#
   hdc: @integer;
   l: ^text;
   cstr: @cstring;
   theNtRectPtr: @integer;
   r: @rectangle;
   theTextStyle: ^textStyle;
   bkColor: @integer;
   width,height: @integer;
   
do
   INNER onRefresh;
   windowItemDevice->hdc;
   buttonLabel->l[];
   l.reset;
   THIS(button).private.buttonTextStyle[]->theTextStyle[];
   size->(width,height);
   (if border.visible then
       (if width < 3 then 3->width;  if);
       (if height < 3 then 3->height;  if);
       (if (border.style = borderStyles.simple) then
           width-2->width; height-2->height; ((2,1),(width,height))->r; 
        else
           width-2->width; height-2->height; ((3,1),(width,height))->r; 
       if);
       
    else
       ((0,0),size)->r; 
   if);
   r[]->makeNtRectPtr->theNtRectPtr;
   (if theNtRectPtr <> 0 then
       (if (theTextStyle[] <> none ) then
           (hdc,theTextStyle.textStyleID)->SelectObject; 
       if);
       (if THIS(windowItem).theBkColorInfo = none then
           COLOR_BTNFACE->GetSysColor->bkColor; 
        else
           (THIS(windowItem).theBkColorInfo).theColorRef->bkColor; 
       if);
       (hdc,bkColor)->SetBkColor;
       (if THIS(button).private.theFgColorref > 0 then
           (hdc,THIS(button).private.theFgColorref)->setTextcolor
       if);
       (if (l.lgth > 0) then
           l[]->cstr.set;
           (if cstr <> 0 then
           (* (hdc,cstr.charPtr,-1,theNtRectPtr,DT_SINGLELINE+DT_LEFT+DT_VCENTER) 
            -> DrawText; *)
               (hdc,cstr.charPtr,- 1,theNtRectPtr,DT_LEFT+DT_WORDBREAK)
                 ->DrawText;
               cstr.free;
               
           if);
           
       if);
       theNtRectPtr->free;
       
   if);
   
#)  

-- GUIENVstaticTextCreate: Descriptor --
(# 
do
   uienvStandardWindowClass->windowItemClass;
   isStandardClass->windowItemClassStatus;
   INNER create;
   
#)  

-- GUIENVstaticTextOpen: Descriptor --
(# theTextStyle: ^textStyle; 
do
   (50,16)->size;
   defaultStaticTextTextStyle->theTextStyle[];
   (if theTextStyle[] = none then
       &textStyle[]->theTextStyle[];
       'MS Sans Serif'->theTextStyle.name;
       8->theTextStyle.size;
       theTextStyle.create;
       theTextStyle[]->defaultStaticTextTextStyle;
       
   if);
   theTextStyle[]->THIS(button).private.buttonTextStyle[];
   (interfaceObjectID,WM_SETFONT,theTextStyle.textStyleID,1)->SendMessage;
   INNER open;
   
#)  

-- GUIENVstaticTextClose: Descriptor --
(#  do INNER close; none ->THIS(button).private.buttonTextStyle[];  #)  

-- GUIENVstaticTextPrivate: Descriptor --
(#  #)  

-- GUIENViconButtonOnRefresh: Descriptor --
(#
   calcImageBounds:
     (# 
     do
        (if showLabel then
            theLabel[]->theStyle.widthOfText->textWidth;
            theStyle.lineHeight->textHeight;
            
         else
            0->textWidth; 0->textHeight; 
        if);
        (if (private.iconButtonPixmap[] <> none ) then
            private.iconButtonPixmap.width->iconWidth;
            private.iconButtonPixmap.height->iconHeight;
            
         else
            0->iconWidth; 0->iconHeight; 
        if);
        (textHeight+iconHeight)->imageHeight;
        (textWidth,iconWidth)->max->imageWidth;
        
     #);
   calcImageAnchors:
     (# width,height: @integer; 
     do
        size->(width,height);
        (width-iconWidth) div 2->iconAnchor.h;
        (height-imageHeight) div 2->iconAnchor.v;
        (width-textWidth) div 2->textAnchor.h;
        iconAnchor.v+iconHeight+theStyle.ascent->textAnchor.v;
        theStyle.ascent->ascent;
        
     #);
   drawPixmap: external
     (#
        hdc: @integer;
        hPixmap: @integer;
        xSrcPos,ySrcPos,xDestPos,yDestPos: @integer;
        result: @boolean;
        
     enter (hdc,hPixmap,xSrcPos,ySrcPos,xDestPos,yDestPos)
     do 'drawBitmap'->callC; 
     exit result
     #);
   DrawTransparentBitmap: external
     (#
        hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,
          transparentColor: @integer;
        result: @integer;
        
     enter
     (hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,
      transparentColor)
     do callC; 
     exit result
     #);
   DrawTransparentBitmapFromMask: external
     (#
        hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,pixmapMask:
          @integer;
        result: @integer;
        
     enter
     (hWnd,hBitmap,xStart,yStart,xDestPos,yDestPos,width,height,pixmapMask)
     do callC; 
     exit result
     #);
   result: @boolean;
   theStyle: ^textStyle;
   ascent: @integer;
   theLabel: ^text;
   cstr: @cstring;
   imageWidth,imageHeight,textWidth,textHeight,iconWidth,iconHeight: @integer;
   iconAnchor,textAnchor: @point;
   lblRect: @rectangle;
   hdc,hbr: @integer;
   width,height: @integer;
   doReleaseHdc: @boolean;
   bkColor,textColor: @integer;
   windowID: @integer;
   iconpxm: ^pixmap;
   
do
   assertOpen;
   interfaceObjectID->windowID;
   (if (windowItemDevice = 0) then
       windowID->GetDC->hdc; true->doReleaseHdc; 
    else
       windowItemDevice->hdc; 
   if);
   (if hilite then
       COLOR_HIGHLIGHT->GetSysColor->bkColor;
       COLOR_HIGHLIGHTTEXT->GetSysColor->textColor;
       (hdc,textColor)->SetTextColor;
       
    else
       (if THIS(windowItem).theBkColorInfo = none then
           COLOR_BTNFACE->GetSysColor->bkColor; 
        else
           (THIS(windowItem).theBkColorInfo).theColorRef->bkColor; 
       if);
       
   if);
   (hdc,bkColor)->SetBkColor;
   style->theStyle[];
   label->theLabel[];
   calcImageBounds;
   calcImageAnchors;
   (if (private.iconButtonPixmap[] <> none ) then
       (if private.iconButtonPixmap.private.isIcon then
           (((hdc,iconAnchor.h,iconAnchor.v,
              private.iconButtonPixmap.private.handleToPixmap,0,0,0,0,DI_NORMAL)
               ->DrawIconEx) <> 0)->result;
           
        else
           private.iconButtonPixmap[]->iconpxm[];
           (if iconpxm.Transparent then
               (if iconpxm.private.transparentmask[] = none then
               (* use TransPcolor *)
                     (# tc: @color; theColor: @integer; 
                     do
                        iconpxm.transparentColor->tc;
                        (tc.red div 256,0)->theColor.%putByte;
                        (tc.green div 256,1)->theColor.%putByte;
                        (tc.blue div 256,2)->theColor.%putByte;
                        (0,3)->theColor.%putByte;
                        (THIS(windowitem).interfaceObjectID,
                         iconpxm.private.handleToPixmap,0,0,iconAnchor.h,
                         iconAnchor.v,iconpxm.width,iconpxm.height,theColor)
                          ->DrawTransparentBitmap;
                        
                     #);
                   true->result;
                   
                else
               (* draw using mask *)
                   (THIS(windowitem).interfaceObjectID,
                    iconpxm.private.handleToPixmap,0,0,iconAnchor.h,
                    iconAnchor.v,iconpxm.width,iconpxm.height,
                    iconpxm.private.transparentmask.private.handleToPixmap)
                     ->DrawTransparentBitmapFromMask;
                   true->result;
                   
               if);
               
            else
               (hdc,private.iconButtonPixmap.private.handleToPixmap,0,0,
                iconAnchor.h,iconAnchor.v)->drawPixmap->result;
               
           if);
           
       if);
       (if not result then
           'iconbutton.onRefresh: drawPixmap failed. Errorcode: '->puttext;
           GetLastError->putint;
           newline;
           
       if);
       
   if);
   size->(width,height);
   (if showLabel then
       textAnchor.v-theStyle.ascent->lblRect.top;
       1->lblRect.left;
       width-1->lblRect.right;
       textAnchor.v+theStyle.descent->lblRect.bottom;
       (hdc,theStyle.textStyleID)->SelectObject;
       theLabel[]->cstr.set;
       (if cstr <> 0 then
           (hdc,TA_CENTER)->SetTextAlign;
           (hdc,width div 2,lblRect.top,cstr.charPtr,cstr.length)->TextOut;
           cstr.free;
           
       if);
       
   if);
   (if doReleaseHdc then (windowID,hdc)->ReleaseDC;  if);
   INNER onRefresh;
   (THIS(iconButton)[],private.privBorderStyle,0,0,width,height)->drawBorder;
   
#)  

-- GUIENViconbuttonOnHiliteChanged: Descriptor --
(# hdc: @integer; doReleaseHdc: @boolean; windowID: @integer; 
do
   INNER onHiliteChanged;
   interfaceObjectID->windowID;
   (if (windowItemDevice = 0) then
       windowID->GetDC->hdc; true->doReleaseHdc; 
    else
       windowItemDevice->hdc; 
   if);
   update;
   (if doReleaseHdc then (windowID,hdc)->ReleaseDC;  if);
   
#)  

-- iconButtonOnMouseDown: DoPart --
do
   INNER onMouseDown;
   (if buttonState = 1 then
       borderStyles.shadowIn->private.privBorderStyle;
       true->update;
       trackMouse
         (#
            mouseMove::
              (# r: @rectangle; 
              do
                 ((0,0),size)->r;
                 (if (curPt->r.containsPoint) then
                     (if private.privBorderStyle = borderStyles.shadowOut then
                         borderStyles.shadowIn->private.privBorderStyle;
                         true->update;
                         
                     if);
                     
                  else
                     (if private.privBorderStyle = borderStyles.shadowIn then
                         borderStyles.shadowOut->private.privBorderStyle;
                         true->update;
                         
                     if);
                     
                 if);
                 
              #);
            MouseRelease::
              (# 
              do
                 borderStyles.shadowOut->private.privBorderStyle; true->update; 
              #);
            
         #);
       
   if);
     

-- GUIENViconButtonSetShowLabel: Descriptor --
(# 
do
   assertOpen;
   doShow->iconButtonShowLabel;
   theEventHandler.onShowLabelChanged;
   update;
   
#)  

-- GUIENViconButtonGetShowLabel: Descriptor --
(#  do assertOpen; iconButtonShowLabel->doShow;  #)  

-- GUIENViconButtonSetIcon: Descriptor --
(# 
do
   assertOpen;
   theIcon[]->iconButtonPixmap;
   theEventHandler.onIconChanged;
   update;
   
#)  

-- GUIENViconButtonGetIcon: Descriptor --
(#  do assertOpen; iconButtonPixmap->theIcon[];  #)  

-- GUIENViconButtonCreate: Descriptor --
(# 
do
   uienvStandardWindowClass->windowItemClass;
   isStandardClass->windowItemClassStatus;
   INNER create;
   
#)  

-- GUIENViconButtonOpen: Descriptor --
(# 
do
   true->iconButtonShowLabel;
   true->THIS(windowItem).private.updateOnResize;
   INNER open;
   (if THIS(interfaceobject).private.isOpen then
       true->border.visible;
       borderStyles.shadowOut->border.style;
       borderStyles.shadowOut->private.privBorderStyle;
       true->THIS(windowItem).private.borderHandledLocally;
       
   if);
   
#)  

-- GUIENViconButtonClose: Descriptor --
(#  do INNER close;  #)  

-- iconButtonLib: Attributes --
DI_NORMAL: (#  exit 0x0003 #);
DrawIconEx: external
  (#
     hdc, (* HDC, handle to device context *) xLeft,
     (* int, x-coordinate of upper left corner *) yTop,
     (* int, y-coordinate of upper left corner *) hIcon,
     (* HICON, handle to icon to draw *) cxWidth, (* int, width of the icon *)
     cyWidth, (* int, height of the icon *) istepIfAniCur,
     (* UINT, index of frame in animated cursor *) hbrFlickerFreeDraw,
     (* HBRUSH, handle to background brush *) diFlags: @integer;
     (* UINT, icon-drawing flags *)
     result: @integer;
     
  enter
  (hdc,xLeft,yTop,hIcon,cxWidth,cyWidth,istepIfAniCur,hbrFlickerFreeDraw,
   diFlags)
  do callStd; 
  exit result
  #);
iconButtonShowLabel:
  (#  enter private.iconButtonShowLabel exit private.iconButtonShowLabel #);
iconButtonPixmap:
  (#  enter private.iconButtonPixmap[] exit private.iconButtonPixmap[] #);
  

-- GUIENViconButtonPrivate: Descriptor --
(#
   iconButtonShowLabel: @boolean;
   iconButtonPixmap: ^pixmap;
   privBorderStyle: @integer;
   
#)  

-- optionButtonLib: Attributes --
optionButtonMethods: windowItemMethods
  (#
     dispatchMessage::
       (# didSomething: @boolean; foColor: @integer; hdc: @integer; 
       do
          (if info.message = WM_CTLCOLORSTATIC then
              (if info.lParam = mbLabelID then
                  (if THIS(windowItem).theBkColorInfo <> none then
                      true->didSomething;
                      (THIS(windowItem).theBkColorInfo).hBrush->info.result;
                      info.wParam->hdc;
                      (hdc,(THIS(windowItem).theBkColorInfo).theColorRef)
                        ->SetBkColor;
                      (if getOsMajorVersionId
                       // 3 then
                          COLOR_WINDOWTEXT->GetSysColor->foColor;
                          (hdc,foColor)->SetTextColor;
                          
                       // 4 then
                          COLOR_BTNTEXT->GetSysColor->foColor;
                          (hdc,foColor)->SetTextColor;
                          
                      if);
                      
                   else
                      false->didSomething; 
                  if);
                  
               else
                  false->didSomething; 
              if);
              
          if);
          didSomething or info.handled->info.handled;
          
       #);
     
  #);
preferredSize:
  (#
     prefW,prefH: @integer;
     l: ^text;
     theTextStyle: ^textStyle;
     widthOfLabel: @integer;
     
  do
     THIS(optionButton).buttonLabel->l[];
     (if (l[] = none ) then &text[]->l[];  if);
     THIS(button).private.buttonTextStyle[]->theTextStyle[];
     (if theTextStyle[] <> none then
         l[]->theTextStyle.widthOfText->widthOfLabel;
         (if l.length > 0 then widthOfLabel+4->widthOfLabel;  if);
         
      else
         l.length+5->widthOfLabel; 
     if);
     private.theComboBox.preferredSize->(prefW,prefH);
     widthOfLabel+prefW->prefW;
     private.theComboBoxHeight->prefH;
     (if border.visible then
         (if (border.style = borderStyles.simple) then
             prefH+2->prefH; prefW+2->prefW; 
          else
             prefH+4->prefH; prefW+4->prefW; 
         if);
         
     if);
     
  exit (prefW,prefH)
  #);
  

-- GUIENVoptionButtonOnLabelChanged: Descriptor --
(#
   l: ^text;
   x,y,w,h,heightOfLabel,widthOfLabel: @integer;
   theTextStyle: ^textStyle;
   labelH,margin: @integer;
   result: @integer;
   
do
   buttonLabel->l[];
   THIS(button).private.buttonTextStyle[]->theTextStyle[];
   (if theTextStyle[] = none then
       defaultButtonTextStyle->theTextStyle[]; 
   if);
   (mbLabelID,l)->SetWindowText;
   (if border.visible then
       (if (border.style = borderStyles.simple) then
           2->margin; 
        else
           3->margin; 
       if);
       
   if);
   l[]->theTextStyle.widthOfText->widthOfLabel;
   theTextStyle.lineHeight->heightOfLabel;
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2)-(heightOfLabel div 2)->labelH; 
    else
       heightOfLabel div 2->labelH; 
   if);
   (mbLabelID,margin,labelH,widthOfLabel,heightOflabel,1)->MoveWindow->result;
   (result,'optionButtonOnLabelChanged(1)')->checkNullError;
   position->(x,y);
   size->(w,h);
   (if l.length > 0 then widthOfLabel+sblc->widthOfLabel;  if);
   (x+margin+widthOfLabel,y+2)->private.theComboBox.position;
   (w-widthOfLabel-(2*margin),100)->private.theComboBox.size;
   private.theComboBox.bringToFront;
   INNER onLabelChanged;
   
#)  

-- GUIENVoptionButtonOnStyleChanged: Descriptor --
(#
   l: ^text;
   x,y,w,h,heightOfLabel,widthOfLabel: @integer;
   theTextStyle: ^textStyle;
   labelH,margin: @integer;
   result: @integer;
   
do
   buttonLabel->l[];
   THIS(button).private.buttonTextStyle[]->theTextStyle[];
   (if theTextStyle[] = none then
       defaultButtonTextStyle->theTextStyle[]; 
   if);
   (mbLabelID,WM_SETFONT,theTextStyle.textStyleID,1)->SendMessage;
   (mbLabelID,l)->SetWindowText;
   (dropDownListID,WM_SETFONT,theTextStyle.textStyleID,1)->SendMessage;
   l[]->theTextStyle.widthOfText->widthOfLabel;
   theTextStyle.lineHeight->heightOfLabel;
   (if border.visible then
       (if (border.style = borderStyles.simple) then
           2->margin; 
        else
           3->margin; 
       if);
       
   if);
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2)-(heightOfLabel div 2)->labelH; 
    else
       heightOfLabel div 2->labelH; 
   if);
   (mbLabelID,margin,labelH,widthOfLabel,heightOflabel,1)->MoveWindow->result;
   (result,'optionButtonOnStyleChanged(1)')->checkNullError;
   (if l.length > 0 then widthOfLabel+sblc->widthOfLabel;  if);
   position->(x,y);
   size->(w,h);
   (x+margin+widthOfLabel,y+4)->private.theComboBox.position;
   (w-widthOfLabel-(2*margin),100)->private.theComboBox.size;
   private.theComboBox.bringToFront;
   INNER onStyleChanged;
   
#)  

-- GUIENVoptionButtonSetCurItem: Descriptor --
(# 
do assertOpen; (dropDownListID,CB_SETCURSEL,itemNo-1,0)->sendMessage; 
#)  

-- GUIENVoptionButtonGetCurItem: Descriptor --
(# 
do
   assertOpen;
   (dropDownListID,CB_GETCURSEL,0,0)->sendMessage->itemNo;
   itemNo+1->itemNo;
   
#)  

-- GUIENVoptionButtonSetPopupMenu: Descriptor --
(# 
do
   assertOpen;
   (if (popupMenu[] <> optionButtonPopupMenu) then
       popupMenu[]->insertNewMenu; theEventHandler.onPopUpMenuChanged; 
   if);
   
#)  

-- GUIENVoptionButtonGetPopupMenu: Descriptor --
(#  do assertOpen; optionButtonPopupMenu->popupMenu[];  #)  

-- GUIENVoptionButtonCreate: Descriptor --
(# 
do
   uienvStandardWindowClass->windowItemClass;
   isStandardClass->windowItemClassStatus;
   &optionButtonMethods[]->theMethods;
   INNER create;
   
#)  

-- GUIENVoptionButtonOpen: Descriptor --
(#
   l: ^text;
   x,y,w,h,heightOfLabel,widthOfLabel,labelH: @integer;
   theTextStyle: ^textStyle;
   style: @integer;
   class,name: @text;
   ID,hInstance: @integer;
   result,margin: @integer;
   
do
   'STATIC'->class;
   'Label'->name;
   UniqueID->ID;
   0->style;
   uienvHInstance->hInstance;
   (0,class,name,WS_CHILDWINDOW+style,0,0,40,20,interfaceObjectID,ID,hInstance,
    0)->CreateWindowEx->mbLabelID;
   position->(x,y);
   father[]->private.theComboBox.open;
   (x+43,y+2)->private.theComboBox.position;
   (57,100)->private.theComboBox.size;
   (mbLabelID,SW_SHOWNORMAL)->ShowWindow;
   (100,22)->size;
   private.theVisibleChangedAction[]->THIS(optionButton).AppendAction;
   private.theEnableTargetAction[]->THIS(optionButton).AppendAction;
   private.optFrameChangedAction[]->THIS(optionButton).AppendAction;
   INNER open;
   (if THIS(interfaceobject).private.isOpen then
       buttonLabel->l[];
       THIS(button).private.buttonTextStyle[]->theTextStyle[];
       (if theTextStyle[] = none then
           defaultButtonTextStyle->theTextStyle[]; 
       if);
       (mbLabelID,WM_SETFONT,theTextStyle.textStyleID,1)->SendMessage;
       (mbLabelID,l)->SetWindowText;
       (dropDownListID,WM_SETFONT,theTextStyle.textStyleID,1)->SendMessage;
       l[]->theTextStyle.widthOfText->widthOfLabel;
       theTextStyle.lineHeight->heightOfLabel;
       (if border.visible then
           (if (border.style = borderStyles.simple) then
               2->margin; 
            else
               3->margin; 
           if);
           
       if);
       (if private.theComboBoxHeight > heightOflabel then
           (private.theComboBoxHeight div 2)-(heightOfLabel div 2)->labelH; 
        else
           heightOfLabel div 2->labelH; 
       if);
       (mbLabelID,margin,labelH,widthOfLabel,heightOflabel,1)->MoveWindow
         ->result;
       (result,'optionButtonOpen(1)')->checkNullError;
       position->(x,y);
       size->(w,h);
       (if l.length > 0 then widthOfLabel+sblc->widthOfLabel;  if);
       (x+margin+widthOfLabel,y+2)->private.theComboBox.position;
       (w-widthOfLabel-(2*margin),100)->private.theComboBox.size;
       private.theComboBox.bringToFront;
       
   if);
   
#)  

-- GUIENVoptionButtonClose: Descriptor --
(# 
do
   INNER close;
   private.theVisibleChangedAction[]->deleteAction;
   private.theEnableTargetAction[]->deleteAction;
   private.optFrameChangedAction[]->deleteAction;
   (if private.theComboBox.isOpen then private.theComboBox.close;  if);
   
#)  

-- toggleButtonLib: Attributes --
  

-- GUIENVtoggleButtonOnMouseUp: DoPart --
do INNER ;   

-- GUIENVtoggleButtonSetState: Descriptor --
(# 
do
   assertOpen;
   (* theState -> this(toggleButton).private.oldState; *)
   (if theState then
       (interfaceObjectID,BM_SETCHECK,1,0)->SendMessage; 
    else
       (interfaceObjectID,BM_SETCHECK,0,0)->SendMessage; 
   if);
   theEventHandler.onStateChanged;
   
#)  

-- GUIENVtoggleButtonGetState: Descriptor --
(# 
do
   assertOpen;
   (if ((interfaceObjectID,BM_GETCHECK,0,0)->SendMessage) <> 0 then
       TRUE->theState; 
    else
       FALSE->theState; 
   if);
   
#)  

-- GUIENVtoggleButtonCreate: Descriptor --
(#  do INNER create;  #)  

-- GUIENVtoggleButtonOpen: Descriptor --
(#  do INNER open;  #)  

-- GUIENVtoggleButtonClose: Descriptor --
(#  do INNER close;  #)  

-- GUIENVtoggleButtonPrivate: Descriptor --
(# oldState: @boolean;  #)  

-- radioButtonLib: Attributes --
radioBtnNotiMethods: windowItemNotificationMethods
  (#
     handleNotification::
       (#
          processWMcommand:
            (# notifyType: @integer; index: @integer; 
            do
               info.wParam.hiWord->notifyType;
               true->didSomething;
               (if notifyType = BN_CLICKED then
                   (if not THIS(toggleButton).private.oldState then
                       TRUE->state; 
                   if);
                   
                else
                   false->didSomething; 
               if);
               
            #);
          didSomething: @boolean;
          
       do
          (if info.message = WM_COMMAND then
              processWMcommand; 
           else
              false->didSomething; 
          if);
          didSomething or info.handled->info.handled;
          
       #);
     
  #);
  

-- GUIENVradioButtonCreate: Descriptor --
(# 
do
   BS_RADIOBUTTON->windowItemStyle;
   &radioBtnNotiMethods[]->theNotiMethods;
   INNER create;
   
#)  

-- GUIENVRadioButtonOpen: Descriptor --
(# 
do
   private.theMouseDownAction[]->appendAction;
   private.theKeyDownAction[]->appendAction;
   INNER open;
   
#)  

-- GUIENVRadioButtonClose: Descriptor --
(# 
do
   INNER close;
   private.theMouseDownAction[]->deleteAction;
   private.theKeyDownAction[]->deleteAction;
   
#)  

-- GUIENVradioButtonPrivate: Descriptor --
(#
   theMouseDownAction: @mouseDownAction
     (#  do state->THIS(toggleButton).private.oldState;  #);
   theKeyDownAction: @keyDownAction
     (# 
     do
        (if theEvent.ch = ascii.sp then
            state->THIS(toggleButton).private.oldState; 
        if);
        
     #);
   
#)  

-- checkBoxLib: Attributes --
checkBoxNotiMethods: windowItemNotificationMethods
  (#
     handleNotification::
       (#
          processWMcommand:
            (# notifyType: @integer; index: @integer; 
            do
               info.wParam.hiWord->notifyType;
               true->didSomething;
               (if notifyType = BN_CLICKED then
                   theEventHandler.onStateChanged; 
                else
                   false->didSomething; 
               if);
               
            #);
          didSomething: @boolean;
          
       do
          (if info.message = WM_COMMAND then
              processWMcommand; 
           else
              false->didSomething; 
          if);
          didSomething or info.handled->info.handled;
          
       #);
     
  #);
  

-- GUIENVcheckBoxCreate: Descriptor --
(# 
do
   BS_AUTOCHECKBOX->windowItemStyle;
   &checkBoxNotiMethods[]->theNotiMethods;
   INNER create;
   
#)  

-- GUIENVcheckBoxOpen: Descriptor --
(#  do INNER open;  #)  

-- GUIENVcheckBoxClose: Descriptor --
(#  do INNER close;  #)  

-- GUIENVcheckBoxPrivate: Descriptor --
(#  #)  

-- GUIENVeditTextSetStyle: Descriptor --
(# 
do
   txStyle[]->private.editTextStyle[];
   txStyle[]->updateStyle;
   txStyle.create;
   (interfaceObjectID,WM_SETFONT,txStyle.textStyleID,1)->SendMessage;
   
#)  

-- GUIENVeditTextGetStyle: Descriptor --
(#  do private.editTextStyle[]->txStyle[];  #)  

-- GUIENVeditTextSetContents: Descriptor --
(# cstr: @cString; 
do
   str[]->cstr.set;
   (interfaceObjectID,WM_SETTEXT,0,cstr.charPtr)->sendMessage;
   cstr.free;
   
#)  

-- GUIENVeditTextGetContents: Descriptor --
(# result: @integer; cstr: @cString; length: @integer; 
do
   (interfaceObjectID,WM_GETTEXTLENGTH,0,0)->sendMessage->length;
   length+1->cstr.init;
   (interfaceObjectID,WM_GETTEXT,length+1,cstr.charPtr)->sendMessage->result;
   (if (result <> length) then
       'EditText.getContents: Did not copy all text!'->screen.putLine; 
   if);
   &text[]->str[];
   cstr.get->str[];
   str.T.range->str.pos->str.lgth;
   cstr.free;
   
#)  

-- GUIENVeditTextonFrameChanged: Descriptor --
(#  do INNER onFrameChanged; setEditTextMargins;  #)  

-- GUIENVeditTextonKeyDown: Descriptor --
(# insertChar: @boolean; info: ^messageInfo; 
do
   currentMessageInfo->info[];
   FALSE->info.callback;
   true->insertChar;
   (if (ch = ascii.cr) then false->insertChar;  if);
   (if insertChar then callDefaultWindowProc;  if);
   INNER onKeyDown;
   
#)  

-- GUIENVeditTextonMouseDown: Descriptor --
(#  do INNER onMouseDown;  #)  

-- GUIENVeditTextonRefresh: Descriptor --
(# width,height: @integer; info: ^messageInfo; 
do
   INNER onRefresh;
   currentMessageInfo->info[];
   FALSE->info.callback;
   callDefaultWindowProc;
   size->(width,height);
   (THIS(editText)[],borderStyles.shadowIn,0,0,width,height)->drawBorder;
   
#)  

-- GUIENVeditTextonEnableTarget: Descriptor --
(#  do INNER onEnableTarget;  #)  

-- GUIENVeditTextonDisableTarget: Descriptor --
(#  do INNER onDisableTarget;  #)  

-- GUIENVeditTextCreate: Descriptor --
(# wStyle: @integer; 
do
   'EDIT'->windowItemClass;
   (ES_MULTILINE,ES_LEFT)->tos'%or'->wStyle;
   (ES_AUTOHSCROLL,wStyle)->tos'%or'->wStyle;
   wStyle->windowItemStyle;
   true->THIS(windowItem).private.borderHandledLocally;
   INNER create;
   
#)  

-- GUIENVeditTextOpen: Descriptor --
(# style: ^textStyle; windowID: @integer; t: ^text; 
do
   interfaceObjectID->windowID;
   defaultEditTextTextStyle->style[];
   (if style[] = none then
       &textStyle[]->style[];
       'MS Sans Serif'->style.name;
       8->style.size;
       style.create;
       style[]->defaultEditTextTextStyle;
       
   if);
   style[]->private.editTextStyle[];
   cursors.iBeam[]->theCursor;
   &text[]->t[];
   (if ((windowID,t)->SetWindowText) = 0 then
       (0,'editTextOpen.SetWindowText')->checkNullError; 
   if);
   INNER open;
   (if THIS(interfaceobject).private.isOpen then
       TRUE->border.visible;
       borderStyles.shadowIn->border.style;
       private.editTextStyle[]->style[];
       (if style[] <> defaultEditTextTextStyle then style.create;  if);
       (windowID,WM_SETFONT,style.textStyleID,1)->SendMessage;
       setEditTextMargins;
       
   if);
   
#)  

-- GUIENVeditTextClose: Descriptor --
(#  do INNER close; none ->private.editTextStyle[];  #)  

-- editTextLib: Attributes --
setEditTextMargins:
  (# width,height: @integer; 
  do
     size->(width,height);
     (if (border.style = borderStyles.simple) then
         width-1->width;
         height-1->height;
         (2,2,width,height,interfaceObjectID)->setEditRect;
         
      else
         width-2->width;
         height-2->height;
         (3,3,width,height,interfaceObjectID)->setEditRect;
         
     if);
     
  #);
setEditRect: external
  (# x,y,width,height,hWnd: @integer; 
  enter (x,y,width,height,hWnd)
  do callC; 
  #);
updateStyle: (# style: ^textStyle;  enter style[] do  #);
  

-- GUIENVeditTextPrivate: Descriptor --
(# editTextStyle: ^textStyle;  #)  

-- GUIENVsetDefaultButton: Descriptor --
(# newStyle: @integer; 
do
   theButton[]->windowDefaultButton;
   WS_CHILDWINDOW+BS_DEFPUSHBUTTON->newStyle;
   (theButton.interfaceObjectID,BM_SETSTYLE,newStyle,1)->SendMessage;
   
#)  

-- GUIENVgetDefaultButton: Descriptor --
(#  do windowDefaultButton->theButton[];  #)  

