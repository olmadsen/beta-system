ORIGIN '../controlsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
INCLUDE '../../graphics';
INCLUDE 'optionbutton_nti';
INCLUDE 'guienv_ntiprivate';
INCLUDE 'guienvattributes';
INCLUDE '~beta/win32lib/v1.6/gdistructs';
INCLUDE '~beta/win32lib/v1.6/wingdiconsts';
INCLUDE '~beta/win32lib/v1.6/wingdi';
INCLUDE '~beta/win32lib/v1.6/windowsmisc';
INCLUDE '~beta/win32lib/v1.6/mousecursorsupport';
INCLUDE '~beta/win32lib/v1.6/scrollbarsupport';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';
INCLUDE '~beta/win32lib/v1.6/errorhandling';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '~beta/sysutils/v1.6/cstring';
INCLUDE '~beta/basiclib/v1.6/math';

-- GUIENVcontrolCreate: descriptor --
(#
do isSubClass -> windowItemClassStatus;
   -1 -> this(windowItem).private.backGroundColor;
   inner create;
#)

-- GUIENVcontrolOpen: descriptor --
(#
do inner open;
#)

-- GUIENVcontrolClose: descriptor --
(#
do inner close;
#)

-- controlLib: attributes --


-- GUIENVcontrolPrivate: descriptor --
(#
#)

-- GUIENVthumbMoved: descriptor --
(# 
do value + amount -> value;
   inner thumbMoved;
#)

-- GUIENVscrollbarPageDown: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue + scrollbarPageScrollamount,currentMax) -> min -> newValue;
   newValue -> value;
   inner pageDown;
#)

-- GUIENVscrollbarPageUp: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue - scrollbarPageScrollamount,0) -> max -> newValue;
   newValue -> value;
   inner pageUp;
#)

-- GUIENVscrollbarButtonDown: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue + scrollbarScrollamount,currentMax) -> min -> newValue;   
   newValue -> value;
   inner buttonDown;
#)

-- GUIENVscrollbarButtonUp: descriptor --
(# currentValue,newValue,currentMax: @integer;
do value -> currentValue;
   maxValue -> currentMax;
   (currentValue - scrollbarScrollamount,0) -> max -> newValue;
   newValue -> value;
   inner buttonUp;
#)

-- GUIENVScrollbarOnFrameChanged: descriptor --
(# 
do inner onFrameChanged;
#)

-- GUIENVScrollbarOnRefresh: descriptor --
(#
do inner onReFresh;
#)

-- GUIENVScrollbarOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVscrollbarOnActivate: descriptor --
(#
do inner onActivate;
#)

-- GUIENVscrollbarOnDeactivate: descriptor --
(#
do inner onDeactivate;
#)

-- GUIENVscrollbarSetScrollAmount: descriptor --
(# 
do assertOpen;
   value -> scrollbarScrollamount;
   theEventHandler.onScrollAmountChanged;
#)

-- GUIENVscrollbarGetScrollAmount: descriptor --
(# 
do assertOpen;
   scrollbarScrollamount -> value;
#)

-- GUIENVscrollbarSetPageScrollAmount: descriptor --
(# 
do assertOpen;
   value -> scrollbarPageScrollAmount;
   theEventHandler.onPageScrollAmountChanged;
#)

-- GUIENVscrollbarGetPageScrollAmount: descriptor --
(# 
do assertOpen;
   scrollbarPageScrollAmount -> value;
#)

-- GUIENVscrollbarSetMaxValue: descriptor --
(#
do (0,value) -> max -> value;
   (interfaceObjectID, SB_CTL, 0, value, 1) -> SetScrollRange;
   theEventHandler.onMaxValueChanged;
#)

-- GUIENVscrollbarGetMaxValue: descriptor --
(# minVal, maxVal: @longRef;
   windowID: @integer;
do interfaceObjectID -> windowID;
   (windowID, SB_CTL, minVal[], maxVal[] )  -> GetScrollRange;
   maxVal -> value;
#)

-- GUIENVscrollbarSetValue: descriptor --
(# 
do (pos,maxValue) -> min -> pos;
   (0,pos) -> max -> pos;
   (interfaceObjectID, SB_CTL, pos, 1) -> SetScrollPos;
   theEventHandler.onValueChanged;
#)

-- GUIENVscrollbarGetValue: descriptor --
(# 
do (interfaceObjectID, SB_CTL) -> GetScrollPos -> pos;
#)

-- GUIENVscrollbarSetLength: descriptor --
(# width,height: @integer;
do size -> (width,height);
   (if vertical then
       (width,theLength) -> size;
    else
       (theLength,height) -> size;
   if);
#)

-- GUIENVscrollbarGetLength: descriptor --
(# width,height: @integer;
do size -> (width,height);
   (if vertical then
       height -> theLength;
    else
       width -> theLength;
   if);
#)

-- GUIENVscrollbarCreate: descriptor --
(#
do 'SCROLLBAR' -> windowItemClass;
   (if vertical then
        SBS_VERT -> windowItemStyle;
    else
       SBS_HORZ  -> windowItemStyle;
   if);
   inner create;
#)

-- GUIENVscrollbarOpen: descriptor --
(# 
do (0,0) -> position;
   (200,16) -> size;
   16 -> scrollbarScrollamount;
   50 -> scrollbarPageScrollamount; 
   inner open;
#)

-- GUIENVscrollbarClose: descriptor --
(#
do inner close;
#)

-- scrollbarLib: attributes --

scrollbarOrientation:
  (#
  enter private.scrollbarOrientation
  exit private.scrollbarOrientation
  #);
scrollbarScrollamount:
  (#
  enter private.scrollbarScrollamount
  exit private.scrollbarScrollamount
  #);
scrollbarPageScrollamount:
  (#
  enter private.scrollbarPageScrollamount
  exit private.scrollbarPageScrollamount
  #);
scrollbarActive:
  (#
  enter private.scrollbarActive
  exit private.scrollbarActive
  #);



-- GUIENVscrollbarPrivate: descriptor --
(# scrollbarOrientation: @integer;
   scrollbarScrollamount: @integer;
   scrollbarPageScrollamount: @integer;
   scrollbarActive: @boolean;
#)

-- GUIENVButtonOnFrameChanged: descriptor --
(#
do inner onFrameChanged;
#)

-- GUIENVButtonOnRefresh: descriptor --
(#
do inner onRefresh;
#)

-- GUIENVButtonOnMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVbuttonSetLabel: descriptor --
(# 
   theTextStyle: ^textStyle;
   l: ^text;
   widthOfLabel,heightOfLabel,width,height: @integer;
do assertOpen;
   (if theLabel[]=NONE then &text[] -> theLabel[] if);
   theLabel.copy -> buttonLabel;
   (if (interfaceObjectID<>0) then
       (if (windowItemClassStatus=isSubClass) then
           theLabel.copy -> l[];
           (interfaceObjectID,theLabel) -> SetWindowText;
           (if (l.length > 5) then
               private.buttonTextStyle[] -> theTextStyle[];
               (if theTextStyle[]=NONE then
                   defaultButtonTextStyle -> theTextStyle[];
               if);
               size -> (width,height);
               l[] -> theTextStyle.widthOfText -> widthOfLabel;
               (if (width < widthOfLabel + 4) then
                   widthOfLabel + 4 -> width;
               if);
               (if (height < theTextStyle.lineHeight + 2) then
                   theTextStyle.lineHeight + 2 -> height;
               if);
               (width,height) -> size;
           if);
       if);
   if);
   update;
   theEventHandler.onLabelChanged;
#)

-- GUIENVbuttonGetLabel: descriptor --
(# 
do assertOpen;
   buttonLabel -> theLabel[];
   theLabel.copy -> theLabel[];
#)

-- GUIENVbuttonSetStyle: descriptor --
(# 
do assertOpen;
   (if theStyle[]<>NONE then
       theStyle[] -> private.buttonTextStyle[];
       theStyle.create;
       (interfaceObjectID,WM_SETFONT,theStyle.textStyleID,1) -> SendMessage;
       theEventHandler.onStyleChanged;
   if);
#)

-- GUIENVbuttonGetStyle: descriptor --
(# 
do assertOpen;
   private.buttonTextStyle[] -> theStyle[];
#)

-- GUIENVbuttonCreate: descriptor --
(#
do 'Button' -> windowItemClass;  
   inner create;
#)

-- GUIENVbuttonOpen: descriptor --
(# style: ^textStyle;
do this(button)[] -> getPatternName -> buttonLabel;
   defaultButtonTextStyle -> style[];
   (if (style[]=none) then
       &textStyle[] -> style[];
       'MS Sans Serif' -> style.name;
       8 -> style.size;
       style.create;
       style[] -> defaultButtonTextStyle;
   if);
   (interfaceObjectID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   style[] -> private.buttonTextStyle[];
   inner open;
#)

-- GUIENVbuttonClose: descriptor --
(# 
do inner close;
   NONE -> private.buttonTextStyle[];
#)

-- buttonLib: attributes --
buttonLabel:
  (#
  enter private.buttonLabel[]
  exit private.buttonLabel[]
  #);

-- GUIENVbuttonPrivate: descriptor --
(# buttonLabel: ^text;
   buttonTextStyle: ^textStyle;
#)

-- GUIENVpushButtonCreate: descriptor --
(#
do BS_PUSHBUTTON -> windowItemStyle;
   inner create;
#)

-- GUIENVpushButtonOpen: descriptor --
(# 
do inner open;
#)

-- GUIENVpushButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVpushButtonPrivate: descriptor --
(#
#)

-- GUIENVstaticTextOnRefresh: descriptor --
(# hdc: @integer;
   l: ^text; cstr: @cstring; 
   theNtRectPtr: @integer; r: @rectangle;
   theTextStyle: ^textStyle;
   bkColor: @integer;
   width,height: @integer;
do inner onRefresh;
   windowItemDevice -> hdc;
   buttonLabel -> l[]; l.reset;
   this(button).private.buttonTextStyle[] -> theTextStyle[];
   size -> (width,height);
   
   (if border.visible then
       (if width<3 then 3 -> width; if);
       (if height<3 then 3 -> height; if);
       (if (border.style=borderStyles.simple) then
           width - 2 -> width; height - 2 -> height;
           ((2,1),(width,height)) -> r;
        else
           width - 2-> width; height - 2 -> height;
           ((3,1),(width,height)) -> r;
       if);
    else
       ((0,0),size) -> r;
   if);
   
   r[] -> makeNtRectPtr -> theNtRectPtr;
   
   (if theNtRectPtr<>0 then
       (if (theTextStyle[]<>none) then
           (hdc,theTextStyle.textStyleID) -> SelectObject;
       if);
       
       (if this(windowItem).private.backGroundColor = -1 then
           COLOR_BTNFACE -> GetSysColor -> bkColor;
        else
           this(windowItem).private.backGroundColor -> bkColor;
       if);
       (hdc,bkColor) -> SetBkColor;
       (if (l.lgth>0) then
           l[] -> cstr.set;
           (if cstr<>0 then
               (* (hdc,cstr.charPtr,-1,theNtRectPtr,DT_SINGLELINE+DT_LEFT+DT_VCENTER) 
                -> DrawText; *)
               (hdc,cstr.charPtr,-1,theNtRectPtr,DT_LEFT+DT_WORDBREAK) 
                 -> DrawText;
               cstr.free; 
           if);
       if);
       theNtRectPtr -> free;
   if);
#)

-- GUIENVstaticTextCreate: descriptor --
(#
do uienvStandardWindowClass -> windowItemClass;
   isStandardClass -> windowItemClassStatus;
   inner create;
#)

-- GUIENVstaticTextOpen: descriptor --
(# theTextStyle: ^textStyle;
do (50,16) -> size;
   defaultStaticTextTextStyle -> theTextStyle[];
   (if theTextStyle[]=none then
       &textStyle[] -> theTextStyle[];
       'MS Sans Serif' -> theTextStyle.name;
       8 -> theTextStyle.size;
       theTextStyle.create;
       theTextStyle[] -> defaultStaticTextTextStyle;
   if);
   theTextStyle[] -> this(button).private.buttonTextStyle[];
   (interfaceObjectID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   inner open;
#)

-- GUIENVstaticTextClose: descriptor --
(# 
do inner close;
   NONE -> this(button).private.buttonTextStyle[];
#)

-- GUIENVstaticTextPrivate: descriptor --
(#
#)

-- GUIENViconButtonOnRefresh: descriptor --
(# 
   calcImageBounds:
     (# 
     do (if showLabel then
            theLabel[] -> theStyle.widthOfText -> textWidth;
            theStyle.lineHeight -> textHeight;
         else
            0 -> textWidth;
            0 -> textHeight;
        if);
        (if (private.iconButtonPixmap[]<>none) then
            private.iconButtonPixmap.width -> iconWidth;
            private.iconButtonPixmap.height -> iconHeight;
         else
            0 -> iconWidth;
            0 -> iconHeight;
        if);
        (textHeight+iconHeight) -> imageHeight;
        (textWidth,iconWidth) -> max -> imageWidth;
     #);
   calcImageAnchors:
     (# width,height: @integer;
     do size -> (width,height);
        
        (width - iconWidth) div 2 -> iconAnchor.h;
        (height - imageHeight) div 2 -> iconAnchor.v;
        (width - textWidth) div 2 -> textAnchor.h;
        iconAnchor.v + iconHeight + theStyle.ascent -> textAnchor.v;
        theStyle.ascent -> ascent;
     #);
   drawPixmap: external
     (# hdc: @integer;
        hPixmap: @integer;
        xSrcPos, ySrcPos, xDestPos, yDestPos: @integer;
        result: @boolean;
     enter (hdc, hPixmap, xSrcPos, ySrcPos, xDestPos, yDestPos)
     do 'drawBitmap' -> callC;
     exit result
     #);
   DrawTransparentPixmap: external
     (# hdc, hPixmap, xStart, yStart, transparentColor: @integer;
     enter (hdc, hPixmap, xStart, yStart, transparentColor)
     do callC;
     #);
   result: @boolean;
   theStyle: ^textStyle; ascent: @integer;
   theLabel: ^text; cstr: @cstring;
   imageWidth,imageHeight,textWidth,textHeight,iconWidth,iconHeight: @integer;
   iconAnchor,textAnchor: @point;
   lblRect: @rectangle; hdc, hbr: @integer; 
   width,height: @integer;
   doReleaseHdc: @boolean;
   bkColor,textColor: @integer;
   windowID: @integer;
do assertOpen;
   interfaceObjectID -> windowID;
   (if (windowItemDevice=0) then
       windowID -> GetDC -> hdc;
       true -> doReleaseHdc;
    else windowItemDevice -> hdc;
   if);
   (if hilite then
       COLOR_HIGHLIGHT -> GetSysColor -> bkColor;
       COLOR_HIGHLIGHTTEXT -> GetSysColor -> textColor;
       (hdc,textColor) -> SetTextColor;
    else
       (if this(windowItem).private.backGroundColor = -1 then
           COLOR_BTNFACE -> GetSysColor -> bkColor;
        else
           this(windowItem).private.backGroundColor -> bkColor;
       if);
   if);
   (hdc,bkColor) -> SetBkColor;
   style -> theStyle[];
   label -> theLabel[];
   calcImageBounds;
   calcImageAnchors;
   (if (private.iconButtonPixmap[]<>none) then
       (if private.iconButtonPixmap.private.isIcon then
           (((hdc,
           iconAnchor.h,iconAnchor.v,
           private.iconButtonPixmap.private.handleToPixmap,
           0,0,0,0,DI_NORMAL) 
             -> DrawIconEx)<>0) -> result;
        else
           (windowID,
           private.iconButtonPixmap.private.handleToPixmap,
           0,0,iconAnchor.h,iconAnchor.v)
             -> drawPixmap -> result; 
       if);
       (if not result then
           'iconbutton.onRefresh: drawPixmap failed. Errorcode: ' -> puttext;
           GetLastError -> putint; newline;
       if);
   if);
   size -> (width,height);
   (if showLabel then
       textAnchor.v - theStyle.ascent -> lblRect.top;
       1 -> lblRect.left;
       width - 1 -> lblRect.right;
       textAnchor.v + theStyle.descent  -> lblRect.bottom;
       (hdc,theStyle.textStyleID) -> SelectObject;
       
       theLabel[] -> cstr.set;
       (if cstr<>0 then
           (hdc,TA_CENTER) -> SetTextAlign;
           (hdc,width div 2, lblRect.top, cstr.charPtr, cstr.length)
             -> TextOut;
           cstr.free;
       if);
   if);
   (if doReleaseHdc then 
       (windowID,hdc) -> ReleaseDC;
   if);
   inner onRefresh;
   
   (this(iconButton)[],private.privBorderStyle,0,0,width,height) -> drawBorder;
#)

-- GUIENViconbuttonOnHiliteChanged: descriptor --
(# hdc: @integer;
   doReleaseHdc: @boolean;
   windowID: @integer;
do inner onHiliteChanged;
   interfaceObjectID -> windowID;
   (if (windowItemDevice=0) then
       windowID -> GetDC -> hdc;
       true -> doReleaseHdc;
    else windowItemDevice -> hdc;
   if);
   update; 
   (if doReleaseHdc then 
       (windowID,hdc) -> ReleaseDC;
   if);
#)

-- iconButtonOnMouseDown: doPart --
do (if buttonState=1 then
       borderStyles.shadowIn -> private.privBorderStyle;
       true -> update;
       trackMouse
       (# mouseMove::
            (# r: @rectangle; 
            do ((0,0),size) -> r;
               (if (curPt -> r.containsPoint) then
                   (if private.privBorderStyle=borderStyles.shadowOut then
                       borderStyles.shadowIn -> private.privBorderStyle;
                       true -> update;
                   if);
                else
                   (if private.privBorderStyle=borderStyles.shadowIn then
                       borderStyles.shadowOut -> private.privBorderStyle;
                       true -> update;
                   if);
               if);
            #);
          MouseRelease::
            (#
            do borderStyles.shadowOut -> private.privBorderStyle;
               true -> update;
            #); 
       #);
   if);
   INNER onMouseDown;

-- GUIENViconButtonSetShowLabel: descriptor --
(# 
do assertOpen;
   doShow -> iconButtonShowLabel;
   theEventHandler.onShowLabelChanged;
   update;
#)

-- GUIENViconButtonGetShowLabel: descriptor --
(# 
do assertOpen;
   iconButtonShowLabel -> doShow;
#)

-- GUIENViconButtonSetIcon: descriptor --
(# 
do assertOpen;
   theIcon[] -> iconButtonPixmap;
   theEventHandler.onIconChanged;
   update;
#)

-- GUIENViconButtonGetIcon: descriptor --
(# 
do assertOpen;
   iconButtonPixmap -> theIcon[];
#)

-- GUIENViconButtonCreate: descriptor --
(#
do uienvStandardWindowClass -> windowItemClass;
   isStandardClass  -> windowItemClassStatus;
   inner create;
#)

-- GUIENViconButtonOpen: descriptor --
(#
do true -> iconButtonShowLabel;
   true -> this(windowItem).private.updateOnResize;
   inner open;
   (if THIS(interfaceobject).private.isOpen then
       true -> border.visible;
       borderStyles.shadowOut -> border.style;
       borderStyles.shadowOut -> private.privBorderStyle;
       true -> this(windowItem).private.borderHandledLocally;
   if);
#)

-- GUIENViconButtonClose: descriptor --
(#
do inner close;
#)

-- iconButtonLib: attributes --
DI_NORMAL: (# exit 0x0003 #);

DrawIconEx: external
  (# hdc,                (* HDC, handle to device context *)
     xLeft,              (* int, x-coordinate of upper left corner *)
     yTop,               (* int, y-coordinate of upper left corner *)
     hIcon,              (* HICON, handle to icon to draw *)
     cxWidth,            (* int, width of the icon *)
     cyWidth,            (* int, height of the icon *)
     istepIfAniCur,      (* UINT, index of frame in animated cursor *)
     hbrFlickerFreeDraw, (* HBRUSH, handle to background brush *)
     diFlags: @integer;  (* UINT, icon-drawing flags *)
     result: @integer;
  enter (hdc,xLeft,yTop,hIcon,cxWidth,cyWidth,istepIfAniCur,
     hbrFlickerFreeDraw,diFlags)
  do callStd;
  exit result
  #);

iconButtonShowLabel:
  (#
  enter private.iconButtonShowLabel
  exit private.iconButtonShowLabel
  #);
iconButtonPixmap:
  (#
  enter private.iconButtonPixmap[]
  exit private.iconButtonPixmap[]
  #);

-- GUIENViconButtonPrivate: descriptor --
(# iconButtonShowLabel: @boolean;
   iconButtonPixmap: ^pixmap;
   privBorderStyle: @integer;
#)

-- optionButtonLib: attributes --

optionButtonMethods: windowItemMethods
  (# 
     dispatchMessage::
       (# didSomething: @boolean;
          foColor: @integer; hdc: @integer;
       do 
          (if info.message=WM_CTLCOLORSTATIC then
              (if info.lParam = mbLabelID then
                  (if this(windowItem).private.backGroundColor<>-1 then
                      true -> didSomething;
                      this(windowItem).private.hBackGroundBrush -> info.result;
                      info.wParam -> hdc;
                      (hdc,this(windowItem).private.backGroundColor) 
                        -> SetBkColor; 
                      (if getOsMajorVersionId
                       //3 then
                          COLOR_WINDOWTEXT -> GetSysColor -> foColor;
                          (hdc, foColor) -> SetTextColor; 
                       //4 then
                          COLOR_BTNTEXT -> GetSysColor -> foColor;
                          (hdc, foColor) -> SetTextColor;  
                      if);
                   else
                      false -> didSomething;
                  if);
               else
                  false -> didSomething;
              if);
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

preferredSize:
  (# prefW, prefH: @integer;
     l: ^text; theTextStyle: ^textStyle;
     widthOfLabel: @integer;
  do this(optionButton).buttonLabel -> l[];
     (if (l[]=none) then &text[] -> l[]; if);
     this(button).private.buttonTextStyle[] -> theTextStyle[];
     (if theTextStyle[]<>NONE then
         l[] -> theTextStyle.widthOfText -> widthOfLabel;
         (if l.length>0 then
             widthOfLabel + 4 -> widthOfLabel;
         if);
      else
         l.length + 5 -> widthOfLabel;
     if);
     private.theComboBox.preferredSize -> (prefW,prefH);
     widthOfLabel + prefW -> prefW;
     private.theComboBoxHeight -> prefH;
     (if border.visible then
         (if (border.style=borderStyles.simple) then
             prefH + 2 -> prefH;
             prefW + 2 -> prefW;
          else
             prefH + 4 -> prefH;
             prefW + 4 -> prefW;
         if);
         
     if);
  exit (prefW,prefH)
  #); 



-- GUIENVoptionButtonOnLabelChanged: descriptor --
(# l: ^text; 
   x,y,w,h,heightOfLabel,widthOfLabel: @integer;
   theTextStyle: ^textStyle;
   labelH, margin: @integer;
   result: @integer;
do buttonLabel -> l[];
   this(button).private.buttonTextStyle[] -> theTextStyle[];
   (if theTextStyle[]=NONE then
       defaultButtonTextStyle -> theTextStyle[];
   if);
   (mbLabelID,l) -> SetWindowText;
   
   (if border.visible then
       (if (border.style=borderStyles.simple) then
           2 -> margin;
        else
           3 -> margin;
       if);
   if);
   
   l[] -> theTextStyle.widthOfText -> widthOfLabel;
   theTextStyle.lineHeight -> heightOfLabel;
   
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2) - (heightOfLabel div 2)  -> labelH;
    else
       heightOfLabel div 2  -> labelH;
   if);
   (mbLabelID,margin,labelH,widthOfLabel,heightOflabel,1) -> MoveWindow -> result;
   (result,'optionButtonOnLabelChanged(1)')  -> checkNullError;
   
   position -> (x,y); size -> (w,h);
   (if l.length>0 then widthOfLabel+sblc -> widthOfLabel; if);
   (x+margin+widthOfLabel,y+2) ->  private.theComboBox.position;
   (w-widthOfLabel-(2*margin),100) -> private.theComboBox.size;
   private.theComboBox.bringToFront;
   inner onLabelChanged;
#)
-- GUIENVoptionButtonOnStyleChanged: descriptor --
(# l: ^text; 
   x,y,w,h,heightOfLabel,widthOfLabel: @integer;
   theTextStyle: ^textStyle;
   labelH, margin: @integer;
   result: @integer;
do buttonLabel -> l[];
   this(button).private.buttonTextStyle[] -> theTextStyle[];
   (if theTextStyle[]=NONE then
       defaultButtonTextStyle -> theTextStyle[];
   if);
   (mbLabelID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   (mbLabelID,l) -> SetWindowText;
   (dropDownListID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
   
   l[] -> theTextStyle.widthOfText -> widthOfLabel;
   theTextStyle.lineHeight -> heightOfLabel;
   
   (if border.visible then
       (if (border.style=borderStyles.simple) then
           2 -> margin;
        else
           3 -> margin;
       if);
   if);
   
   (if private.theComboBoxHeight > heightOflabel then
       (private.theComboBoxHeight div 2) - (heightOfLabel div 2)  -> labelH;
    else
       heightOfLabel div 2  -> labelH;
   if);
   
   (mbLabelID,margin,labelH,widthOfLabel,heightOflabel,1) -> MoveWindow -> result;
   (result,'optionButtonOnStyleChanged(1)')  -> checkNullError;
   
   (if l.length>0 then widthOfLabel+sblc -> widthOfLabel; if);
   position -> (x,y); size -> (w,h);
   (x+margin+widthOfLabel,y+4) ->  private.theComboBox.position;
   (w-widthOfLabel-(2*margin),100) -> private.theComboBox.size;
   private.theComboBox.bringToFront;
   inner onStyleChanged;
#)
-- GUIENVoptionButtonSetCurItem: descriptor --
(# 
do assertOpen;
   (dropDownListID,CB_SETCURSEL,itemNo-1,0) -> sendMessage;
#)

-- GUIENVoptionButtonGetCurItem: descriptor --
(# 
do assertOpen;
   (dropDownListID,CB_GETCURSEL,0,0) -> sendMessage -> itemNo;
   itemNo + 1 -> itemNo;
#)

-- GUIENVoptionButtonSetPopupMenu: descriptor --
(# 
do assertOpen;
   (if (popupMenu[]<>optionButtonPopupMenu) then
       popupMenu[] -> insertNewMenu;
       theEventHandler.onPopUpMenuChanged;
   if);
#)

-- GUIENVoptionButtonGetPopupMenu: descriptor --
(# 
do assertOpen;
   optionButtonPopupMenu -> popupMenu[];
#)

-- GUIENVoptionButtonCreate: descriptor --
(# 
do 
   uienvStandardWindowClass -> windowItemClass;
   isStandardClass  -> windowItemClassStatus;
   &optionButtonMethods[] -> theMethods;
   inner create;
#)

-- GUIENVoptionButtonOpen: descriptor --
(# l: ^text; 
   x,y,w,h,heightOfLabel,widthOfLabel,labelH: @integer;
   theTextStyle: ^textStyle;
   style: @integer;
   class,name: @text;
   ID,hInstance: @integer;
   result, margin: @integer;
do 
   'STATIC' -> class;
   'Label' -> name;
   UniqueID -> ID;
   0 -> style;
   uienvHInstance -> hInstance;
   (0,class,name,WS_CHILDWINDOW + 
   style,0,0,40,20,interfaceObjectID,ID,hInstance,0) -> CreateWindowEx
     -> mbLabelID; 
   
   position -> (x,y);
   father[] -> private.theComboBox.open;
   (x+43,y+2) -> private.theComboBox.position;
   (57,100) -> private.theComboBox.size;
   
   (mbLabelID,SW_SHOWNORMAL) -> ShowWindow; 
   (100,22) -> size;
   
   private.theVisibleChangedAction[]  -> this(optionButton).AppendAction;
   private.theEnableTargetAction[] -> this(optionButton).AppendAction;
   private.optFrameChangedAction[] -> this(optionButton).AppendAction;
   
   inner open;
   
   (if THIS(interfaceobject).private.isOpen then
       buttonLabel -> l[];
       this(button).private.buttonTextStyle[] -> theTextStyle[];
       (if theTextStyle[]=NONE then
           defaultButtonTextStyle -> theTextStyle[];
       if);
       (mbLabelID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
       (mbLabelID,l) -> SetWindowText;
       
       (dropDownListID,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
       
       l[] -> theTextStyle.widthOfText -> widthOfLabel;
       theTextStyle.lineHeight -> heightOfLabel;
       
       (if border.visible then
           (if (border.style=borderStyles.simple) then
               2 -> margin;
            else
               3 -> margin;
           if);
       if);
       
       (if private.theComboBoxHeight > heightOflabel then
           (private.theComboBoxHeight div 2) - (heightOfLabel div 2)  -> labelH;
        else
           heightOfLabel div 2  -> labelH;
       if);
       
       (mbLabelID,margin,labelH,widthOfLabel,heightOflabel,1) -> MoveWindow -> result;
       (result,'optionButtonOpen(1)')  -> checkNullError;
       
       position -> (x,y); size -> (w,h);
       (if l.length>0 then widthOfLabel+sblc -> widthOfLabel; if);
       (x+margin+widthOfLabel,y+2) -> private.theComboBox.position;
       (w-widthOfLabel-(2*margin),100) -> private.theComboBox.size;
       private.theComboBox.bringToFront;
       
   if);
#)

-- GUIENVoptionButtonClose: descriptor --
(#
do inner close;
   private.theVisibleChangedAction[]  -> deleteAction;
   private.theEnableTargetAction[] -> deleteAction;
   private.optFrameChangedAction[] -> deleteAction;
   (if private.theComboBox.isOpen then
       private.theComboBox.close;
   if);
#)

-- toggleButtonLib: attributes --

-- GUIENVtoggleButtonOnMouseUp: doPart --
do inner; 

-- GUIENVtoggleButtonSetState: descriptor --
(# 
do assertOpen;
   (* theState -> this(toggleButton).private.oldState; *)
   (if theState then 
       (interfaceObjectID, BM_SETCHECK, 1, 0) -> SendMessage;
    else 
       (interfaceObjectID, BM_SETCHECK, 0, 0) -> SendMessage;
   if);
   theEventHandler.onStateChanged;
#)

-- GUIENVtoggleButtonGetState: descriptor --
(# 
do assertOpen;
   (if ((interfaceObjectID, BM_GETCHECK, 0, 0) -> SendMessage)<>0 then
       TRUE -> theState;
    else
       FALSE -> theState;
   if);
#)

-- GUIENVtoggleButtonCreate: descriptor --
(#
do inner create;
#)

-- GUIENVtoggleButtonOpen: descriptor --
(# 
do inner open;
#)

-- GUIENVtoggleButtonClose: descriptor --
(#
do inner close;
#)

-- GUIENVtoggleButtonPrivate: descriptor --
(# oldState: @boolean;
#)

-- radioButtonLib: attributes --
radioBtnNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# 
          processWMcommand:
            (# notifyType: @integer;
               index: @integer;
            do info.wParam.hiWord -> notifyType;
               true -> didSomething;
               (if notifyType=BN_CLICKED then 
                   (if not this(toggleButton).private.oldState then
                       TRUE -> state;
                   if);
                else
                   false -> didSomething;
               if);
            #);
          didSomething: @boolean;
       do (if info.message=WM_COMMAND then processWMcommand;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

-- GUIENVradioButtonCreate: descriptor --
(#
do BS_RADIOBUTTON -> windowItemStyle;
   &radioBtnNotiMethods[] -> theNotiMethods;
   inner create;
#)

-- GUIENVRadioButtonOpen: descriptor --
(#
do private.theMouseDownAction[] -> appendAction;
   private.theKeyDownAction[] -> appendAction;
   inner open;
#)

-- GUIENVRadioButtonClose: descriptor --
(#
do inner close;
   private.theMouseDownAction[] -> deleteAction;
   private.theKeyDownAction[] -> deleteAction; 
#)

-- GUIENVradioButtonPrivate: descriptor --
(# theMouseDownAction: @mouseDownAction
     (# 
     do state -> this(toggleButton).private.oldState;
     #);
   theKeyDownAction: @keyDownAction
     (# 
     do (if theEvent.ch=ascii.sp then
            state -> this(toggleButton).private.oldState;
        if);
     #);
#)

-- checkBoxLib: attributes --
checkBoxNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# 
          processWMcommand:
            (# notifyType: @integer;
               index: @integer;
            do info.wParam.hiWord -> notifyType;
               true -> didSomething;
               (if notifyType=BN_CLICKED then 
                   theEventHandler.onStateChanged;
                else
                   false -> didSomething;
               if);
            #);
          didSomething: @boolean;
       do 
          (if info.message=WM_COMMAND then processWMcommand;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

-- GUIENVcheckBoxCreate: descriptor --
(#
do BS_AUTOCHECKBOX -> windowItemStyle;
   &checkBoxNotiMethods[] -> theNotiMethods;
   inner create;
#)

-- GUIENVcheckBoxOpen: descriptor --
(#
do inner open;
#)

-- GUIENVcheckBoxClose: descriptor --
(#
do inner close;
#)

-- GUIENVcheckBoxPrivate: descriptor --
(#
#)

-- GUIENVeditTextSetStyle: descriptor --
(#
do txStyle[] -> private.editTextStyle[];
   txStyle[] -> updateStyle;
   txStyle.create;
   (interfaceObjectID,WM_SETFONT,txStyle.textStyleID,1) -> SendMessage; 
#)

-- GUIENVeditTextGetStyle: descriptor --
(#
do private.editTextStyle[] -> txStyle[];
#)

-- GUIENVeditTextSetContents: descriptor --
(# cstr: @cString; 
do str[] -> cstr.set;
   (interfaceObjectID,WM_SETTEXT, 0, cstr.charPtr) -> sendMessage;
   cstr.free;
#)

-- GUIENVeditTextGetContents: descriptor --
(# result: @integer;
   cstr: @cString;
   length: @integer; 
do (interfaceObjectID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
   length + 1 -> cstr.init;
   (interfaceObjectID,WM_GETTEXT, length+1, cstr.charPtr) -> sendMessage 
      -> result;
   (if (result<>length) then
       'EditText.getContents: Did not copy all text!' -> screen.putLine;
   if);
   &text[] -> str[];
   cstr.get -> str[]; 
   str.T.range -> str.pos -> str.lgth;
   cstr.free;
#)

-- GUIENVeditTextonFrameChanged: descriptor --
(# 
do inner onFrameChanged;
   setEditTextMargins;
#)

-- GUIENVeditTextonKeyDown: descriptor --
(# insertChar: @boolean;
   info: ^messageInfo;
do currentMessageInfo -> info[];
   FALSE -> info.callback;
   true -> insertChar;
   (if (ch=ascii.cr) then  false -> insertChar; if);
   (if insertChar then
       callDefaultWindowProc;
   if);
   inner onKeyDown;
#)

-- GUIENVeditTextonMouseDown: descriptor --
(# 
do inner onMouseDown;
#)

-- GUIENVeditTextonRefresh: descriptor --
(# width,height: @integer;
   info: ^messageInfo;
do inner onRefresh;
   currentMessageInfo -> info[];
   FALSE -> info.callback;
   callDefaultWindowProc;
   size -> (width,height);
   (this(editText)[],borderStyles.shadowIn,0,0,width,height) -> drawBorder;
#)

-- GUIENVeditTextonEnableTarget: descriptor --
(#
do inner onEnableTarget;
#)

-- GUIENVeditTextonDisableTarget: descriptor --
(#
do inner onDisableTarget;
#)

-- GUIENVeditTextCreate: descriptor --
(# wStyle: @integer;
do 'EDIT' -> windowItemClass;
   (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
   (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
   wStyle  -> windowItemStyle;
   true -> this(windowItem).private.borderHandledLocally;
   inner create;
#)

-- GUIENVeditTextOpen: descriptor --
(# style: ^textStyle; 
   windowID: @integer;
   t: ^text;
do interfaceObjectID -> windowID;
   defaultEditTextTextStyle -> style[];
   (if style[]=none then
       &textStyle[] -> style[];
       'MS Sans Serif' -> style.name;
       8 -> style.size;
       style.create;
       style[] -> defaultEditTextTextStyle;
   if);
   style[] -> private.editTextStyle[];
   cursors.iBeam[] -> theCursor;
   
   &text[] -> t[]; 
   (if ( (windowID,t) -> SetWindowText) = 0  then
      (0,'editTextOpen.SetWindowText') -> checkNullError;
   if);
   
   inner open;
   
   (if THIS(interfaceobject).private.isOpen then
       TRUE -> border.visible;
       borderStyles.shadowIn -> border.style;
       private.editTextStyle[] -> style[];
       (if style[]<>defaultEditTextTextStyle then
           style.create;
       if);
       (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;    
       
       setEditTextMargins;   
   if);
#)

-- GUIENVeditTextClose: descriptor --
(# 
do inner close;
   NONE -> private.editTextStyle[];
#)

-- editTextLib: attributes --
setEditTextMargins:
  (# width,height: @integer;
  do size -> (width,height);
     (if (border.style=borderStyles.simple) then
         width - 1 -> width; height - 1 -> height;
         (2,2,width,height,interfaceObjectID) -> setEditRect; 
      else
         width - 2 -> width; height - 2 -> height;
         (3,3,width,height,interfaceObjectID) -> setEditRect; 
     if);
  #);
setEditRect: external
  (# x,y,width,height,hWnd: @integer;
  enter (x,y,width,height,hWnd)
  do callC;
  #);

updateStyle:
  (# style: ^textStyle;
  enter style[]
  do
  #);


-- GUIENVeditTextPrivate: descriptor --
(# editTextStyle: ^textStyle;
#)

-- GUIENVsetDefaultButton: descriptor --
(# newStyle: @integer;
do theButton[] -> windowDefaultButton;
   WS_CHILDWINDOW + BS_DEFPUSHBUTTON -> newStyle;
   (theButton.interfaceObjectID, BM_SETSTYLE, newStyle, 1) -> SendMessage;
#)

-- GUIENVgetDefaultButton: descriptor --
(#
do windowDefaultButton -> theButton[];
#)

