ORIGIN  '../stddialogsbody';
MAKE default 'external/stdfiledlg.make';
OBJFILE default '$/stdfiledlg.obj';
INCLUDE 'guienv_ntiprivate';
INCLUDE '~beta/win32lib/v1.6/messageboxsupport';
INCLUDE '~beta/win32lib/v1.6/commdlg';
INCLUDE '~beta/win32lib/v1.6/dialogcontrolmanagement';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';
INCLUDE '~beta/sysutils/v1.6/cstring';

-- lib: attributes --
PrivMessageBox: external
  (# hWndOwner: @integer; (* HWND *)
     szText: @integer; (* LPCSTR *)
     szTitle: [1] @char; (* LPCSTR *)
     style: @integer; (* UINT *)
     out: @integer; (* int *)
  enter (hWndOwner,szText,szTitle,style)
  do 'MessageBoxA' -> callStd;
  exit out
  #);

-- noteUserBody: doPart --
do inner;
   MB_ICONINFORMATION+MB_OK+MB_TASKMODAL -> messageDialogPrivate.type;
   'NOTE' -> messageDialogPrivate.mtitle;

-- alertUserBody: doPart --
do MB_ICONEXCLAMATION+MB_OK+MB_TASKMODAL -> messageDialogPrivate.type;
   'ALERT' -> messageDialogPrivate.mtitle;

-- fileSelectionDialogBody: doPart --
do inner;
   fileDialogPrivate.openfiledlgType -> fileDialogPrivate.type;
   'Open' -> fileDialogPrivate.ftitle;
   
-- fileCreationDialogBody: doPart --
do inner;
   fileDialogPrivate.savefiledlgType -> fileDialogPrivate.type;
   'Create' -> fileDialogPrivate.ftitle;
   
-- GUIENVdialog: doPart --
do 0 -> this(guienv).private.lastCaptureID;
   (* To make sure that the modal dialog is visible we must remove any floating window
    * properties. *)
   this(guienv).private.windows.scan
   (# windowID: @integer;
   do current.interfaceObjectID -> windowID;
      (if windowID<>0 then
          (if current.type=windowTypes.palette then
              (windowID,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE + SWP_NOACTIVATE) 
                -> SetWindowPos;
          if);
      if);
   #);
   
   inner;
   
   (* Now we must restore floating window properties. *)
   this(guienv).private.windows.scan
   (# windowID: @integer;
   do current.interfaceObjectID -> windowID;
      (if windowID<>0 then
          (if current.type=windowTypes.palette then
              (windowID,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE + SWP_NOACTIVATE) 
                -> SetWindowPos;
          if);
      if);
   #);
   
-- GUIENVfileDialog: doPart --
do inner;
   (# stdopenfiledlg: external
        (# owner: @integer;
           winapiFilter: @integer;
           defaultPath: @integer;
           defaultFileName: @integer;
           dialogTitle: @integer;
           resultPath: @integer; (* LPCSTR *)
           length: @integer;
        enter (owner,winapiFilter,defaultPath,defaultFileName,dialogTitle)
        do callC
        exit resultPath
        #);
      
      stdsavefiledlg: external
        (# owner: @integer;
           winapiFilter: @integer;
           defaultPath: @integer;
           defaultFileName: @integer;
           dialogTitle: @integer;
           resultPath: @integer; (* LPCSTR *)
        enter (owner,winapiFilter,defaultPath,defaultFileName,dialogTitle)
        do callC
        exit resultPath
        #);
      
      tempTitle,winapiFilter,defaultPath,defaultFileName: @cString;
      resultPath: @cString;
      hwnd: @integer;
      tempFilter: @text;
   do (if title[] = None then
          fileDialogPrivate.ftitle[] -> tempTitle.set;
       else
          title[] -> tempTitle.set;
      if);
      (if filter[]=none then
          'All Files |*.*|' -> winapiFilter.set;
       else
          ' |' -> tempFilter.append;
          filter[] -> tempFilter.append;
          '|' -> tempFilter.append;
          tempFilter[] -> winapiFilter.set;
      if);      
      (if fileName[]<>none then
          fileName[] -> defaultFileName.set;
       else
          '' -> defaultFileName.set;
      if);
      (if path[]<>none then
          path[] -> defaultPath.set;
       else
          '' -> defaultPath.set;
      if);
      
      (if owner[]=none then
          GetActiveWindow -> hWnd;
          (if hWnd=0 then GetDeskTopWindow -> hWnd; if);
       else
          owner.interfaceObjectID -> hWnd;
      if);
      
      
      (if fileDialogPrivate.type
       //fileDialogPrivate.savefiledlgType then
          (hwnd,winapiFilter,defaultPath,defaultFileName,tempTitle) -> stdsavefiledlg -> resultPath;
       //fileDialogPrivate.openfiledlgType then 
          (hwnd,winapiFilter,defaultPath,defaultFileName,tempTitle) -> stdopenfiledlg -> resultPath;
       else
          '**WARNING: Do not know type in fileDialog.' -> screen.putLine;
      if);
      (if resultPath.charPtr=0 then
          none -> fileName[];
       else
          resultPath.get -> fileName[];
          resultPath.free;
      if);
      winapiFilter.free;
      defaultFileName.free;
      defaultPath.free;
      tempTitle.free;
   #);
   
-- GUIENVmessageDialog: doPart --
do inner;
   (if title[] = None then
       messageDialogPrivate.mtitle[] -> title[];
   if);
   (if message[]=NONE then &text[] -> message[]; if);
   message[] -> messageDialogPrivate.msgCstr.set;
   (if messageDialogPrivate.msgCstr<>0 then
       (if owner[]=none then
           (0,messageDialogPrivate.msgCstr,title,messageDialogPrivate.type) 
             -> PrivMessageBox;
        else
           (owner.interfaceObjectID,messageDialogPrivate.msgCstr,title,
           messageDialogPrivate.type) 
             -> PrivMessageBox;
       if);
       messageDialogPrivate.msgCstr.free;
    else
       (0,'Could not allocate msg. string.','Alert',messageDialogPrivate.type) 
             -> MessageBox;
   if);

-- GUIENVdialogPrivate: descriptor --
(# 
#)

-- GUIENVfileDialogPrivate: descriptor --
(# type: @integer;
   openfiledlgType: (# exit 1 #);
   savefiledlgType: (# exit 2 #);
   ftitle: @text;
#)

-- GUIENVmessageDialogPrivate: descriptor --
(# type: @integer; 
   mtitle: @text;
   msgCstr: @cString;
#)
