ORIGIN 'richTextFieldBody';
INCLUDE 'guienv_ntiprivate'
        '~beta/win32lib/v1.6/wingdiconsts'
        '~beta/win32lib/v1.6/devicecapabilities'
        '~beta/win32lib/v1.6/dcmanagement'
        'richTextConsts';

-- lib: attributes --

chooseFontFunc: external
  (# ptr2ChooseFont: @integer; (* pointer to structure with initialization 
                                * data *)
     res: @integer;
  enter ptr2ChooseFont
  do 'ChooseFontA' -> callStd;
  exit res
  #);

-- textFieldLib: attributes --
applyFormatting:
  (# oldSel, tempSel: @CHARRANGE;
     cf: @CHARFORMAT;
     windowID: @integer;
     theHdc: @integer;
     startPos: @ntPOINTextR;
     clientRect: @ntRECTextR;
     lineInxStart,lineInxEnd: @integer;
     
     start, end: @integer;
  enter (start, end)
  do interfaceObjectID -> windowID;
     windowID -> GetDC -> theHdc;
     
     8 -> malloc -> oldSel.ptr;
     8 -> malloc -> tempSel.ptr;
     sizeOfCharFormat -> malloc -> cf.ptr;
     
     (if (oldSel.ptr<>0) and (tempSel.ptr<>0) and (cf.ptr<>0) then
         (windowID,WM_SETREDRAW,0,0) -> SendMessage;
         (* Save current selection *)
         (windowID,EM_EXGETSEL,0,oldSel.ptr) -> SendMessage;
         (if start <> end then
             start -> private.translateToLocal -> start;
             end -> private.translateToLocal -> end;
          else
             start -> private.translateToLocal -> start -> end;
         if);
         start -> tempSel.cpMin;
         end -> tempSel.cpMax;
         (windowID,EM_EXSETSEL,0,tempSel.ptr) -> SendMessage;
         
         (cf.ptr,0,sizeOfCharFormat) -> memset;
         sizeOfCharFormat ->  cf.cbSize;
         
         INNER;
         
         (windowID,EM_SETCHARFORMAT,SCF_SELECTION,cf.ptr)->SendMessage;
         
         (* Restore current selection *)
         (windowID,EM_EXSETSEL,0,oldSel.ptr) -> SendMessage;
         
         (windowID,WM_SETREDRAW,1,0) -> SendMessage;
         
         8 -> malloc -> startPos.ptr; 0 -> startPos.x; 0 -> startPos.y;
         16 -> malloc -> clientRect.ptr;
         (if (startPos.ptr<>0) and (clientRect.ptr<>0) then
             (interfaceObjectID,clientRect.ptr) -> GetClientRect;
             
             (windowID,EM_EXLINEFROMCHAR,0,start) -> SendMessage -> lineInxStart;
             
             (if lineInxStart>0 then
                 (windowID,EM_LINEINDEX,lineInxStart-1,0) -> SendMessage -> start;
                 (windowId,EM_POSFROMCHAR,startPos.ptr,start) -> SendMessage;
                 startPos.y -> clientRect.top;
             if);
             
             (windowID,clientRect.ptr,1) -> InvalidateRect;
             windowID -> UpdateWindow;
             clientRect.ptr -> free;
             startPos.ptr -> free;
          else
             TRUE -> update;
         if);
         
         (* TRUE -> update; *)
         oldSel.ptr -> free;
         tempSel.ptr -> free;
         cf.ptr -> free;          
      else
         (NONE,'Failed to set size.',NONE) -> alertUser;
     if);
     
     (windowID,theHdc) -> ReleaseDC;  
  #);

investigateFont:
  (# cf: @CHARFORMAT;
     oldSel, tempSel: @CHARRANGE;
     windowID: @integer;
     theFaceName: ^text; cstr: @cString;
     start, end, checkStyle: @integer;
  enter (start, end, checkStyle)
  do sizeOfCharFormat -> malloc -> cf.ptr;
     8 -> malloc -> oldSel.ptr;
     8 -> malloc -> tempSel.ptr;
     
     (if (oldSel.ptr<>0) and (tempSel.ptr<>0) and (cf.ptr<>0) then
         (cf.ptr,0,sizeOfCharFormat) -> memset;
         sizeOfCharFormat ->  cf.cbSize;
         interfaceObjectID -> windowID;
         
         
         (windowID,WM_SETREDRAW,0,0) -> SendMessage;
         (* Save current selection *)
         (windowID,EM_EXGETSEL,0,oldSel.ptr) -> SendMessage;
         (if start <> end then
             start -> private.translateToLocal -> start;
             end -> private.translateToLocal -> end;
          else
             start -> private.translateToLocal -> start -> end;
         if);
         start -> tempSel.cpMin;
         end -> tempSel.cpMax;
         (windowID,EM_EXSETSEL,0,tempSel.ptr) -> SendMessage;
         
         (windowID, EM_GETCHARFORMAT, 1, cf.ptr) -> SendMessage;
         
         (if ((cf.dwMask %Band checkStyle)<>0) then
             
             inner investigateFont;
             
         if);
         
         (* Restore current selection *)
         (windowID,EM_EXSETSEL,0,oldSel.ptr) -> SendMessage;
         
         (windowID,WM_SETREDRAW,1,0) -> SendMessage;
         
         oldSel.ptr -> free;
         tempSel.ptr -> free;
         cf.ptr -> free;          
     if);
  #);

-- handleFontSelectionImpl: doPart --
do 
   (* CHOOSEFONT csf = {0}; *)
   sizeOfCharFormat -> malloc -> cf.ptr;
   sizeOfChooseFont -> malloc -> csf.ptr;
   sizeOfLogFont -> malloc -> lf.ptr;
   (if (cf.ptr<>0) and (csf.ptr<>0) and (lf.ptr<>0) then
       (cf.ptr,0,sizeOfCharFormat) -> memset;
       (csf.ptr,0,sizeOfChooseFont) -> memset;
       (lf.ptr,0,sizeOfLogFont) -> memset;
       
       sizeOfCharFormat -> cf.cbSize;
       
       interfaceObjectID -> windowID;
       (if topLevelWindow[]<>NONE then
           toplevelWindow.interfaceObjectID -> topLevelWindowID;
        else
           father.interfaceObjectID -> topLevelWindowID;
       if);
       
       topLevelWindowID -> GetDC -> hdc;
       (hdc, LOGPIXELSY) -> GetDeviceCaps -> yPerInch;
       (topLevelWindowID, hdc) -> ReleaseDC;
       
       (windowID, EM_GETCHARFORMAT, 1, cf.ptr) -> SendMessage;
       
       sizeOfChooseFont -> csf.lStructSize;
       topLevelWindowID -> csf.hwndOwner;
       0 -> csf.hDC;
       lf.ptr -> csf.lpLogFont;
       CF_EFFECTS + CF_SCREENFONTS + CF_INITTOLOGFONTSTRUCT + CF_LIMITSIZE
         -> csf.Flags;
       1 -> csf.nSizeMin;
       yHeightCharPtsMost -> csf.nSizeMax;
       cf.crTextColor -> csf.rgbColors;
       0 -> csf.lpszStyle;
       
       REGULAR_FONTTYPE + SCREEN_FONTTYPE -> csf.nFontType;
       ((cf.yHeight * yPerInch) / 1440) -> lf.lfHeight;
       0 -> lf.lfWidth;
       0 -> lf.lfEscapement;
       0 -> lf.lfOrientation;
       (if ((cf.dwEffects, CFE_BOLD) -> tos'%and') > 0 then
           FW_BOLD -> lf.lfWeight;
        else
           FW_NORMAL -> lf.lfWeight;
       if);
       (if ((cf.dwEffects , CFE_ITALIC) -> tos'%and') > 0 then
           1 -> lf.lfItalic;
        else
           0 -> lf.lfItalic;
       if);
       (if ((cf.dwEffects , CFE_UNDERLINE) -> tos'%and') > 0 then
           1 -> lf.lfUnderline;
        else
           0 -> lf.lfUnderline;
       if);
       (if ((cf.dwEffects , CFE_STRIKEOUT) -> tos'%and') > 0 then
           1 -> lf.lfStrikeOut;
        else
           0 -> lf.lfStrikeOut;
       if);
       OUT_DEFAULT_PRECIS -> lf.lfOutPrecision;
       CLIP_DEFAULT_PRECIS -> lf.lfClipPrecision;
       DRAFT_QUALITY -> lf.lfQuality;
       cf.bCharSet -> lf.lfCharSet;
       cf.bPitchAndFamily -> lf.lfPitchAndFamily;
       
       (* _tcscpy(lf.lfFaceName, cf.szFaceName); *)
       (lf.ptr+28, cf.ptr+26) -> _tcscpy;
       
       (if (csf.ptr -> ChooseFontFunc)=0 then
           
        else
           sizeOfCharFormat -> cf.cbSize;
           
           (* don't change read-only bit *)
           CFM_SIZE + CFM_EFFECTS + CFM_COLOR + CFM_FACE + CFM_CHARSET
             -> cf.dwMask;
           csf.iPointSize * 2 -> cf.yHeight;
           CFM_EFFECTS -> cf.dwEffects;
           (if (lf.lfWeight < FW_BOLD) then
               cf.dwEffects %Band (%Bnot CFE_BOLD) -> cf.dwEffects;
           if);
           (if lf.lfItalic=0 then
               cf.dwEffects %Band (%Bnot CFE_ITALIC) -> cf.dwEffects;
           if);
           (if lf.lfUnderline=0 then
               cf.dwEffects %Band (%Bnot CFE_UNDERLINE) -> cf.dwEffects;
           if);
           (if lf.lfStrikeOut=0 then
               cf.dwEffects %Band (%Bnot CFE_STRIKEOUT) -> cf.dwEffects;
           if);
           
           csf.rgbColors -> cf.crTextColor -> theTextColor;
           
           lf.lfCharSet -> cf.bCharSet;
           lf.lfPitchAndFamily -> cf.bPitchAndFamily;
           (* _tcscpy(cf.szFaceName, lf.lfFaceName); *)
           (cf.ptr+26, lf.ptr+28) -> _tcscpy;
           
           (if ((windowID,EM_SETCHARFORMAT,formatFlags,cf.ptr)->SendMessage)=0
               then
               
               (topLevelWindow[],'Error setting character format',NONE)
                 -> alertUser;
               0 -> theTextColor;
           if);
       if);
   if);
   (if (cf.ptr<>0) then cf.ptr -> free; if);
   (if (csf.ptr<>0) then csf.ptr -> free; if);
   (if (lf.ptr<>0) then lf.ptr -> free; if);
   
   
-- GUIENVtextFieldIsOneStyle: descriptor --
(# checkStyle, hdc, yPerInch: @integer;
   windowID: @integer;
do 
   CFM_BOLD %Bor CFM_COLOR %Bor CFM_FACE %Bor CFM_ITALIC %Bor CFM_OFFSET
   %Bor CFM_PROTECTED %Bor CFM_SIZE %Bor CFM_STRIKEOUT %Bor CFM_UNDERLINE
     -> checkStyle;
   
   (start, end, checkStyle)
     -> investigateFont
   (# 
   do &textStyle[] -> theStyle[];
      (if ((cf.dwMask %Band CFM_BOLD)<>0) then
          textFaces.bold -> theStyle.face; 
      if);
      (if ((cf.dwMask %Band CFM_FACE)<>0) then
          LF_FACESIZE -> cstr.init;
          (if cstr<>0 then
              (cstr, cf.ptr+26) -> _tcscpy;
              cstr.get -> theStyle.name;
              cstr.free;
          if);
      if);
      (if ((cf.dwMask %Band CFM_ITALIC)<>0) then
          (if ((cf.dwMask %Band CFM_BOLD)<>0) then
              textFaces.bold+textFaces.italic -> theStyle.face; 
           else
              textFaces.italic -> theStyle.face; 
          if);
      if);
      (if ((cf.dwMask %Band CFM_SIZE)<>0) then
          (cf.yHeight, 72, 1440) -> MulDiv -> theStyle.size;
      if);
      theStyle.create;
   #);
#)

-- GUIENVtextFieldSetOneSize: descriptor --
(# 
do (start,end) 
     -> applyFormatting
   (# 
   do CFM_SIZE -> cf.dwMask;
      (theSize, 1440, 72) -> MulDiv -> cf.yHeight;
   #);
#)

-- GUIENVtextFieldSetOneFont: descriptor --
(# theFaceName: @cString;
do (if theFont[]<>NONE then
       theFont[] -> theFaceName.set;
       (start,end) 
         -> applyFormatting
       (# 
       do CFM_FACE -> cf.dwMask;
          (* _tcscpy(cf.szFaceName, lf.lfFaceName); *)
          (cf.ptr+26, theFaceName.charPtr) -> _tcscpy;
       #);
       theFaceName.free;
   if);
#)

-- GUIENVtextFieldSetOneFace: descriptor --
(# checkStyle: @integer; isSameFace, hasEffects: @boolean;
   effects: @integer;
do (if theFace=textFaces.bold then
       CFM_BOLD -> checkStyle;
       CFE_BOLD -> effects;
   if);
   (if theFace=textFaces.italic then
       CFM_ITALIC -> checkStyle;
       CFE_ITALIC -> effects;
   if);
   (if theFace=textFaces.italic + textFaces.bold then
       CFM_BOLD %Bor CFM_ITALIC -> checkStyle;
       CFE_BOLD %Bor CFE_ITALIC -> effects;
   if);
   
   (start, end, checkStyle)
     -> investigateFont
   (# 
   do true -> isSameFace;
      ((cf.dwEffects %Band effects) <> 0)  -> hasEffects;
   #);
   
   (if doToggle then
       (start,end) 
         -> applyFormatting
       (# 
       do checkStyle -> cf.dwMask;
          (if isSameFace then
              (if hasEffects then
                  0 -> effects;
              if);
          if);
          effects -> cf.dwEffects;
       #);
    else
       (start,end) 
         -> applyFormatting
       (# 
       do checkStyle -> cf.dwMask;
          effects -> cf.dwEffects;
       #);
   if);
   
#)

-- GUIENVtextFieldSetOneStyle: descriptor --
(# mask, effects: @integer; theFaceName: @cString;
do (if theStyle.face=textFaces.bold then
       CFM_BOLD -> mask;
       CFE_BOLD -> effects;
   if);
   (if theStyle.face=textFaces.italic then
       CFM_ITALIC -> mask;
       CFE_ITALIC -> effects;
   if);
   (if theStyle.face=textFaces.italic + textFaces.bold then
       CFM_BOLD %Bor CFM_ITALIC -> mask;
       CFE_BOLD %Bor CFE_ITALIC -> effects;
   if);
       
   (start,end) 
     -> applyFormatting
   (# 
   do (if theStyle.name<>NONE then
          theStyle.name -> theFaceName.set;
          (if theFaceName<>0 then
              CFM_FACE %Bor mask -> mask;
              (cf.ptr+26, theFaceName.charPtr) -> _tcscpy;
              theFaceName.free;
          if);
      if);
      
      (if theStyle.size > 0 then
          CFM_SIZE %Bor mask -> mask;
          (theStyle.size, 1440, 72) -> MulDiv -> cf.yHeight;
      if);
      
      mask -> cf.dwMask;
      effects -> cf.dwEffects;
   #);
#)

-- GUIENVtextFieldScanTextWithStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)
