ORIGIN 'guienv_ntiprivate';

BUILD default '$$/loadBitmapFile.obj' 
              'external/loadBitmapFile.c' 
              'external/loadBitmapFile.h' 
              'betacc $0 $1';

INCLUDE '~beta/toollibs/utils/PNG/png';

INCLUDE '../datastructures/association'
        '../pathmanager'
        '~beta/win32lib/winbase'
        '~beta/win32lib/windowsmisc'
        '~beta/sysutils/cstring';

-- lib: attributes --

GlobalFree: external
  (# hMem: @integer; (* handle to the global memory object *)
     res: @integer; 
  enter hMem
  do callStd;
  exit res
  #);

getApplPath:
  (# thePath: ^Text;
     theFile: @file;
     tempName: @cString; 
     noOfChars: @integer;
  do 
     MAX_PATH+1 -> tempName.init;
     (if tempName.charPtr<>0 then
         (0,tempName.charPtr,MAX_PATH) 
           -> GetModuleFileName -> noOfChars;
         (if noOfChars>0 then
             tempName.get -> theFile.name;
             theFile.entry.path.head -> thePath[];
         if);
         tempName.free;
     if);
  exit thePath[]
  #);

getPixmapPathManager: objectPool.get
  (# type:: pixmapPathManager;
     exact:: (# do true -> value #);
     init:: (# do obj.init #);
  #);

pixmapPathManager: pathManager
  (# init::
       (# betalib: ^text;
          pixmapDir: ^text;
       do 
          '$(BETALIB)' -> expandEnvVar
          (# defaultValue::
               (# 
               do 'c:\\beta' -> envvarvalue[];
               #);
          #) -> betalib[];
          '.' -> add;
          '.\\pixmaps' -> add;
          '\\bitmap\\interfacebuilders' -> (betalib.copy).append -> add;
          '\\bitmap\\objectbrowser' -> (betalib.copy).append -> add;
          '\\bitmap\\guienv' -> (betalib.copy).append -> add;
          '\\bitmap' -> (betalib.copy).append -> add;
          getApplPath -> (betalib.copy).append -> add;
          
          '$(PIXMAPS)' -> expandEnvVar 
          (# 
          #) -> pixmapDir[];
          (if pixmapDir[] <> NONE then
              (if pixmapDir.length > 0 then
                  (if (pixmapDir.length -> pixmapDir.inxGet) <> '\\' then
                      '\\' -> pixmapDir.append;
                  if);
                  pixmapDir[] -> add;
              if);
          if);
       #);
     
     
  #);

isBMPfile: external
  (# 
     filename: @integer; (* [1]@char; *)
     result: @integer;
  enter filename
  do callC;
  exit result
  #);

loadDIBitmapFile: external
  (# 
     filename: @integer; (* [1]@char; *)
     theBitmapinfoheader_ext: @integer;
     result: @integer;
  enter (filename,theBitmapInfoHeader_ext)
  do 'LoadDIBitmapFile'->callC
  exit result
  #);

drawBitmapOnBitmap:external
  (# hbitmap:@integer;
     intx,inty:@integer;
     hsrcbitmap:@integer;
     intxs,intys:@integer;
     width,height:@integer;
     tc:@integer;
     hmaskbitmap:@integer;
     result:@integer;
  enter (hbitmap,intx,inty,hsrcbitmap,intxs,intys,width,height,tc,hmaskbitmap)
  do CallC;
  exit result
  #);

createBitmap:external
  (# handle:@integer;
     width,height:@integer;
  enter (width,height)
  do CallC;
  exit handle
  #);

CreateCompatibleBitmap:external
  (# hdc,width,height:@integer;
     hbmp:@integer;
  enter (hdc,width,height)
  do CallStd;
  exit hbmp
  #);

CreateCompatibleDC:external
  (# hdcorig:@integer;
     hdccomp:@integer;
  enter hdcorig
  do callStd;
  exit hdccomp
  #);

GetDC:external
  (# hdcorig:@integer;
     hdccomp:@integer;
  enter hdcorig
  do callStd;
  exit hdccomp
  #);

DeleteDC:external
  (# hdc:@integer;
     result:@integer;
  enter hdc
  do CallStd;
  exit result
  #);

-- pixmapLib: attributes --

search:
  (# name: ^text;
     expandedName: ^text;
  enter name[]
  do (# thePixmapPathManager: ^pixmapPathManager;
     do getPixmapPathManager -> thePixmapPathManager[];
        name[] -> thePixmapPathManager.lookup -> expandedName[];
     #);
  exit expandedName[]
  #);

expandPixmapName:
  (# name: ^text;
     expandedName: ^text;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
     
  enter name[]
  do (# isPath: @boolean;
        hasExtension: @boolean;
        doesNotExists:
          (# msg: ^text;
          do &text[] -> msg[];
             'pixmap file "' -> msg.putText;
             name[] -> msg.putText;
             '" does not exist' -> msg.putLine;
             msg[] -> error;
          #);
        wasNotFound:
          (# msg: ^text;
          do &text[] -> msg[];
             'pixmap file "' -> msg.putText;
             name[] -> msg.putText;
             '" was not found in any of the pixmap directories' -> msg.putLine;
             msg[] -> error;
          #);
     do (if (name[] <> NONE) and (not name.empty) then
            name.reset;
            l: '\\' -> name.find (# do true -> isPath; leave l; #);
            (if isPath then
                (if name[] -> exists then
                    name.copy -> expandedName[];
                 else
                    doesNotExists;
                if);
             else
                l: '.' -> name.find (# do true -> hasExtension; leave l #);
                (if not hasExtension then
                    '.png' -> (name.copy).append -> name[];
                if);  
                name[] -> search -> expandedName[];
                (if expandedName[] = NONE then
                    (# file: @diskentry;
                    do 
                       applDirectory -> name.prepend;
                       name[] -> file.path;
                       
                       (if file.exists then
                           name.copy -> expandedName[];
                        else   
                           wasNotFound;
                       if)
                    #)
                if);
            if);
        if);
     #);
  exit expandedName[]
  #);

guessPixmapFormat:
  (# name: ^text; cstr: @cstring;
     format: @integer;
  enter name[]
  do l: (# fail:
             (# 
             do unknown -> format;
                leave l;
             #);
        do name[] -> cstr.set;
           (if true
            //((cstr -> isBMPfile)<>0) then
               BMPformat -> format;
            else
               PNGFormat -> format;
               (* fail; *)
           if);
        #);
     (if cstr<>0 then cstr.free; if);
  exit format
  #);

BITMAPINFOHEADER_EXT: ExternalRecord
  (# biSize: @long (# pos::< (# do 0 -> value; #); #);   (* DWORD *)
     biWidth: @long (# pos::< (# do 4 -> value; #); #);  (* LONG *) 
     biHeight: @long (# pos::< (# do 8 -> value; #); #);  (* LONG *) 
     biPlanes: @short (# pos::< (# do 12 -> value; #); #);  (* WORD *) 
     biBitCount: @short (# pos::< (# do 14 -> value; #); #);  (* WORD *) 
     biCompression: @long (# pos::< (# do 16 -> value; #); #);   (* DWORD *)
     biSizeImage: @long (# pos::< (# do 20 -> value; #); #);   (* DWORD *)
     biXPelsPerMeter: @long (# pos::< (# do 24 -> value; #); #);  (* LONG *) 
     biYPelsPerMeter: @long (# pos::< (# do 28 -> value; #); #);  (* LONG *) 
     biClrUsed: @long (# pos::< (# do 32 -> value; #); #);   (* DWORD *) 
     biClrImportant: @long (# pos::< (# do 36 -> value; #); #);   (* DWORD *)
     hBitmap: @long (# pos::< (# do 40 -> value; #); #);   (* DWORD *)
     hDIB: @long (# pos::< (# do 44 -> value; #); #);   (* DWORD *)
  #);

sizeOf_BITMAPINFOHEADER_EXT: (# exit 48 #);

BITMAP_OK: (# exit 1 #);
ERR_OPEN_FILE: (# exit 2 #);
ERR_READ_DI_BITMAPINFO: (# exit 3 #);
ERR_REALLOCATE_HDIB: (# exit 4 #);
ERR_READING_BITMAP_FROM_DIB: (# exit 5 #);
ERR_NO_RETURN_BUFFER: (# exit 6 #);
  

unknown: (# exit 0 #);
BMPformat: (# exit 1 #);
MetaFileformat: (# exit 2 #);
PNGFormat: (# exit 3 #);

readBMPfile: 
  (# name: ^text; cstr: @cstring;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
     errorMsg: ^text;
     
     result: @integer;
     theBITMAPINFOHEADER_EXT: @BITMAPINFOHEADER_EXT;
  enter name[]
  do 
     sizeOf_BITMAPINFOHEADER_EXT -> malloc -> theBITMAPINFOHEADER_EXT.ptr;
     (if theBITMAPINFOHEADER_EXT.ptr<>0 then
         name[] -> cstr.set;
         (cstr,theBITMAPINFOHEADER_EXT.ptr)
           -> loadDIBitmapFile-> result;
         cstr.free;
         (if result=BITMAP_OK then
             theBITMAPINFOHEADER_EXT.hBitmap -> private.handleToPixmap;
             theBITMAPINFOHEADER_EXT.hDIB -> private.handleToDib;
             theBITMAPINFOHEADER_EXT.biWidth -> private.width;
             theBITMAPINFOHEADER_EXT.biHeight -> private.height;
             theBITMAPINFOHEADER_EXT.biBitCount -> private.depth;
          else
             &text[] -> errorMsg[];
             'Pixmap.read failed for: ' ->errorMsg.puttext;
             name[] -> errorMsg.putline;
             (if result
              //ERR_OPEN_FILE then
                 'Error: The file could not be opened.' -> errorMsg.putline;
              //ERR_READ_DI_BITMAPINFO then
                 'Error: Failed to read BITMAPINFO.' -> errorMsg.putline;
              //ERR_REALLOCATE_HDIB then
                 'Error: Failed to reallocate space for DIB.' -> errorMsg.putline;
              //ERR_READING_BITMAP_FROM_DIB then
                 'Error: Failed to read bitmap from DIB.' -> errorMsg.putline;
              //ERR_NO_RETURN_BUFFER then
                 'Error: Not enough space to load bitmap.' -> errorMsg.putline;
             if);
             errorMsg[] -> error;
         if);
         theBITMAPINFOHEADER_EXT.ptr -> free;
     if);
  #);

readMetafile:
  (# name: ^text;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
  enter name[]
  do 
  #);


readPNGfile:
  (# name: ^text;
     error:<
       (# msg: ^text;
       enter msg[]
       do INNER;
       #);
     result: @integer;
     hmask: @integer;
     mask: ^Pixmap;
  enter name[]
  do (name, @@private.handleToPixmap, @@private.width, @@private.height, @@hmask)
       -> readPNG
       -> result;
     
     (if hmask <> 0 then
         &Pixmap[] -> mask[];
         hmask -> mask.private.handleToPixmap;
         private.width -> mask.private.width;
         private.height -> mask.private.height;
         mask[] -> private.transparentmask[];
         true -> private.drawtransparent;
     if);
  #);
-- pixMapRead: doPart --
do l: (# expandedName: ^text;
         format: @integer;
         msg: ^text;
      do name[] -> expandPixmapName 
         (# error::
              (# 
              do 'expandPixmapName error' -> putline;
                 msg[] -> this(read).error;
                 leave l;
              #);
         #) -> expandedName[];
         (if expandedName[] <> NONE then
             expandedName[] -> guessPixmapFormat -> format;
             (if format
              //BMPformat then
                 expandedName[] -> readBMPfile
                 (# error:: (# do msg[] -> this(read).error #) #);
              //MetaFileformat then
                 expandedName[] -> readMetafile
                 (# error:: (# do msg[] -> this(read).error #) #);
              //PNGFormat then
                 expandedName[] -> readPNGFile
                 (# error:: (# do msg[] -> this(read).error #) #);
              //unknown then
                 &text[] -> msg[];
                 'file "' -> msg.putText;
                 expandedName[] -> msg.putText;
                 '" has an unknown format!' -> msg.putLine;
                 msg[] -> error;
             if);
         if); 
      #);

-- pixmapInit: doPart --
do (# hdc:@integer;
   do 0->GetDC->hdc;
   (if ((hdc,width,height)->createCompatibleBitmap->private.handletopixmap)>0 then
       width->private.width;
       height->private.height;
   if);
      hdc->DeleteDC;
   #);
   
--- pixmapClear:DoPart ---
do
   (# 
      colorref:@integer;

      ntFillRect2: external
        (# hdc: @integer; (* HDC *)
           theRect: ^ntRECT; (* const RECT FAR* *)
           hbr: @integer; (* HBRUSH *)
           result: @integer; (* int *)
        enter (hdc,theRect[],hbr)
        do 'FillRect' -> callStd;
        exit result
        #);
      theRect: @ntRECT;
      tempHdc, tempPenBrush: @integer;
   do 
      (if private.handleToBrush=0 then
          theColor[]->makecolorref->colorref -> CreateSolidBrush -> private.handleToBrush; 
      if);
      0->createCompatibleDC->private.hdc;
      (private.hdc, private.handletopixmap)-> SelectObject;
      0-> theRect.left;
      private.width -> theRect.right;
      0 -> theRect.top;
      private.height -> theRect.bottom;
      (private.hdc,theRect[],private.handleToBrush) -> ntFillRect2;
      private.hdc->deleteDC;
   #)
   
-- pixmapDispose: doPart --
do assertInitialized;
   0 -> private.width;
   0 -> private.height;
   0 -> private.depth;
   (if not (private.isFromResource and private.isIcon) then 
       private.handleToPixmap -> DeleteObject;
       (if private.handleToDib<>0 then
           private.handleToDib -> GlobalFree;
       if);
   if); 

-- pixmapWidth: doPart --
do assertInitialized;
   private.width -> value;

-- pixmapHeight: doPart --
do assertInitialized;
   private.height -> value;

-- pixmapSetTransparent: doPart --
do value->private.drawtransparent;
   (if not value then
       (0,0,0)->private.transparentcolor;
       none->private.transparentmask[];
   if);

-- pixmapGetTransparent: doPart --
do
   private.drawtransparent->value;
   
-- pixmapSetTransparentColor: doPart --
do    
   true->private.drawtransparent;
   theColor->private.transparentcolor;

-- pixmapGetTransparentColor: doPart --
do
   private.transparentcolor->theColor;
   
-- pixmapSetMask: doPart --
do
   true->private.drawtransparent;
   theMask[]->private.transparentmask[];

-- pixmapGetMask: doPart --
do
   private.transparentmask[]->theMask[];


-- pixmapDrawPixmap: doPart --
do 
 (# result:@integer;
      colorref:@integer;
 do
    (if other.private.drawtransparent then
          (if other.private.transparentmask[]<>none then (* draw with mask *)
              (private.handletopixmap,to.h,to.v,other.private.handletopixmap,from.h,from.v,width,height,-2,
              other.private.transparentmask.private.handletopixmap)->drawbitmaponbitmap->result;
           else (* draw with transparentcolor *)
              other.private.transparentcolor[]->makeColorRef->colorref;
              (private.handletopixmap,to.h,to.v,other.private.handletopixmap,from.h,from.v,width,height,
              colorref,0)->drawbitmaponbitmap->result;
          if);
     else  (* draw normal *)
          (private.handletopixmap,to.h,to.v,other.private.handletopixmap,from.h,from.v,width,height,
          -1,0)->drawbitmaponbitmap->result;
          
      if);
      (if result=0 then
          'draw pixmap on pixmap failed' -> screen.putline;
      if);
   #)
