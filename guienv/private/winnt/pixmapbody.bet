ORIGIN 'guienv_ntiprivate';
INCLUDE '~beta/toollibs/utils/PNG/png'
        '../datastructures/association'
        '../pathmanager'
        '~beta/win32lib/winbase'
        '~beta/win32lib/windowsmisc'
        '~beta/sysutils/cstring';
BUILD default '$$/loadBitmapFile.obj' 'external/loadBitmapFile.c' 'external/loadBitmapFile.h' 'betacc $0 $1';
BUILD default '$$/readjpgfile.obj' 'external/readjpgfile.c' 'betacc $0 $1';
LIBFILE nti 'external/ijl15l.lib';
-- lib: Attributes --
write_pixels_to_png_area: external
  (#
     pixels: @int32u;
     x: @int32;
     y: @int32;
     width: @int32;
     height: @int32;
     filename: [1] @char;
     
  enter (pixels,x,y,width,height,filename)
  #);
write_pixels_to_png_area_rgb: external
  (#
     pixels: @int32u;
     x: @int32;
     y: @int32;
     width: @int32;
     height: @int32;
     filename: [1] @char;
     transparent: @integer;
     t_red,t_green,t_blue: @integer;
     
  enter (pixels,x,y,width,height,filename,transparent,t_red,t_green,t_blue)
  #);
write_pixels_to_png_area_indexed: external
  (#
     pixels: @int32u;
     x: @int32;
     y: @int32;
     width: @int32;
     height: @int32;
     filename: [1] @char;
     transparent: @integer;
     t_red,t_green,t_blue: @integer;
     
  enter (pixels,x,y,width,height,filename,transparent,t_red,t_green,t_blue)
  #);
GlobalFree: external
  (#
     hMem: @integer; (* handle to the global memory object *) res: @integer; 
  enter hMem
  do callStd; 
  exit res
  #);
getApplPath:
  (#
     thePath: ^Text;
     theFile: @file;
     tempName: @cString;
     noOfChars: @integer;
     
  do
     MAX_PATH+1->tempName.init;
     (if tempName.charPtr <> 0 then
         (0,tempName.charPtr,MAX_PATH)->GetModuleFileName->noOfChars;
         (if noOfChars > 0 then
             tempName.get->theFile.name; theFile.entry.path.head->thePath[]; 
         if);
         tempName.free;
         
     if);
     
  exit thePath[]
  #);
getPixmapPathManager: objectPool.get
  (#
     type:: pixmapPathManager;
     exact::  (#  do true->value #);
     init::  (#  do obj.init #);
     
  #);
pixmapPathManager: pathManager
  (#
     init:: 
       (# betalib: ^text; pixmapDir: ^text; 
       do
          '$(BETALIB)'
            ->expandEnvVar
              (# defaultValue::  (#  do 'c:\\beta'->envvarvalue[];  #); 
              #)->betalib[];
          '.'->add;
          '.\\pixmaps'->add;
          '.\\images'->add;
          '\\bitmap\\interfacebuilders'->(betalib.copy).append->add;
          '\\bitmap\\objectbrowser'->(betalib.copy).append->add;
          '\\bitmap\\guienv'->(betalib.copy).append->add;
          '\\bitmap'->(betalib.copy).append->add;
          getApplPath->(betalib.copy).append->add;
          '$(PIXMAPS)'->expandEnvVar (#  #)->pixmapDir[];
          (if pixmapDir[] <> none then
              (if pixmapDir.length > 0 then
                  (if (pixmapDir.length->pixmapDir.inxGet) <> '\\' then
                      '\\'->pixmapDir.append; 
                  if);
                  pixmapDir[]->add;
                  
              if);
              
          if);
          
       #);
     
  #);
isBMPfile: external
  (# filename: @integer; (* [1]@char; *) result: @integer; 
  enter filename
  do callC; 
  exit result
  #);
loadDIBitmapFile: external
  (#
     filename: @integer;
     (* [1]@char; *)
     theBitmapinfoheader_ext: @integer;
     result: @integer;
     
  enter (filename,theBitmapInfoHeader_ext)
  do 'LoadDIBitmapFile'->callC
  exit result
  #);
drawBitmapOnBitmap: external
  (#
     hbitmap: @integer;
     intx,inty: @integer;
     hsrcbitmap: @integer;
     intxs,intys: @integer;
     width,height: @integer;
     tc: @integer;
     hmaskbitmap: @integer;
     result: @integer;
     
  enter (hbitmap,intx,inty,hsrcbitmap,intxs,intys,width,height,tc,hmaskbitmap)
  do CallC; 
  exit result
  #);
createBitmap: external
  (# handle: @integer; width,height: @integer; 
  enter (width,height)
  do CallC; 
  exit handle
  #);
BetaCreateBitmap: external
  (#
     hdc: @integer;
     pixels: @integer;
     width: @integer;
     height: @integer;
     hbmp: @integer;
     
  enter (hdc,pixels,width,height)
  exit hbmp
  #);
CreateCompatibleBitmap: external
  (# hdc,width,height: @integer; hbmp: @integer; 
  enter (hdc,width,height)
  do CallStd; 
  exit hbmp
  #);
CreateCompatibleDC: external
  (# hdcorig: @integer; hdccomp: @integer; 
  enter hdcorig
  do callStd; 
  exit hdccomp
  #);
GetDC: external
  (# hdcorig: @integer; hdccomp: @integer; 
  enter hdcorig
  do callStd; 
  exit hdccomp
  #);
DeleteDC: external
  (# hdc: @integer; result: @integer; 
  enter hdc
  do CallStd; 
  exit result
  #);
  

-- pixmapLib: Attributes --
search:
  (# name: ^text; expandedName: ^text; 
  enter name[]
  do
       (# thePixmapPathManager: ^pixmapPathManager; 
       do
          getPixmapPathManager->thePixmapPathManager[];
          name[]->thePixmapPathManager.lookup->expandedName[];
          
       #);
     
  exit expandedName[]
  #);
expandPixmapName:
  (#
     name: ^text;
     expandedName: ^text;
     error:< (# msg: ^text;  enter msg[] do INNER ;  #);
     
  enter name[]
  do
       (#
          isPath: @boolean;
          hasExtension: @boolean;
          doesNotExists:
            (# msg: ^text; 
            do
               &text[]->msg[];
               'pixmap file "'->msg.putText;
               name[]->msg.putText;
               '" does not exist'->msg.putLine;
               msg[]->error;
               
            #);
          wasNotFound:
            (# msg: ^text; 
            do
               &text[]->msg[];
               'pixmap file "'->msg.putText;
               name[]->msg.putText;
               '" was not found in any of the pixmap directories'->msg.putLine;
               msg[]->error;
               
            #);
          
       do
          (if (name[] <> none ) and (not name.empty) then
              name.reset;
              l: '\\'->name.find (#  do true->isPath; leave l;  #);
              (if isPath then
                  (if name[]->exists then
                      name.copy->expandedName[]; 
                   else
                      doesNotExists; 
                  if);
                  
               else
                  l: '.'->name.find (#  do true->hasExtension; leave l #);
                  (if not hasExtension then
                      '.png'->(name.copy).append->name[]; 
                  if);
                  name[]->search->expandedName[];
                  (if expandedName[] = none then
                        (# file: @diskentry; absolutPath: ^Text; 
                        do
                           name.copy->absolutPath[];
                           applDirectory->absolutPath.prepend;
                           absolutPath[]->file.path;
                           (if file.exists then
                               absolutPath.copy->expandedName[]; 
                            else
                               name.copy->expandedName[]; wasNotFound; 
                           if)
                        #)
                  if);
                  
              if);
              
          if);
          
       #);
     
  exit expandedName[]
  #);
guessPixmapFormat:
  (#
     name: ^text;
     cstr: @cstring;
     format: @integer;
     extension: ^Text;
     slash,dot: @integer;
     
  enter name[]
  do
     (if '-1'->name.equal then
         errorFormat->format; 
      else
         l:
           (# fail: (#  do unknown->format; leave l;  #); 
           do
              name[]->cstr.set;
              (if true
               // ((cstr->isBMPfile) <> 0) then BMPformat->format; 
               else
                  name.scanAll
                    (# inx: @integer; 
                    do
                       inx+1->inx;
                       (if ch = '\\' then inx->slash;  if);
                       (if ch = '.' then inx->dot;  if);
                       
                    #);
                  (if dot > slash then
                      (dot,name.length)->name.sub->extension[];
                      (if '.jpg'->extension.equalNCS then
                          JPGFormat->format; 
                       else
                          PNGFormat->format; 
                      if);
                      
                   else
                      PNGFormat->format; 
                  if);
                  
              if)
           #)
     if);
     (if cstr <> 0 then cstr.free;  if);
     
  exit format
  #);
BITMAPINFOHEADER_EXT: ExternalRecord
  (#
     biSize: @long (# pos::<  (#  do 0->value;  #);  #);
     (* DWORD *)
     biWidth: @long (# pos::<  (#  do 4->value;  #);  #);
     (* LONG *)
     biHeight: @long (# pos::<  (#  do 8->value;  #);  #);
     (* LONG *)
     biPlanes: @short (# pos::<  (#  do 12->value;  #);  #);
     (* WORD *)
     biBitCount: @short (# pos::<  (#  do 14->value;  #);  #);
     (* WORD *)
     biCompression: @long (# pos::<  (#  do 16->value;  #);  #);
     (* DWORD *)
     biSizeImage: @long (# pos::<  (#  do 20->value;  #);  #);
     (* DWORD *)
     biXPelsPerMeter: @long (# pos::<  (#  do 24->value;  #);  #);
     (* LONG *)
     biYPelsPerMeter: @long (# pos::<  (#  do 28->value;  #);  #);
     (* LONG *)
     biClrUsed: @long (# pos::<  (#  do 32->value;  #);  #);
     (* DWORD *)
     biClrImportant: @long (# pos::<  (#  do 36->value;  #);  #);
     (* DWORD *)
     hBitmap: @long (# pos::<  (#  do 40->value;  #);  #);
     (* DWORD *)
     hDIB: @long (# pos::<  (#  do 44->value;  #);  #);
     (* DWORD *)
     
  #);
sizeOf_BITMAPINFOHEADER_EXT: (#  exit 48 #);
BITMAP_OK: (#  exit 1 #);
ERR_OPEN_FILE: (#  exit 2 #);
ERR_READ_DI_BITMAPINFO: (#  exit 3 #);
ERR_REALLOCATE_HDIB: (#  exit 4 #);
ERR_READING_BITMAP_FROM_DIB: (#  exit 5 #);
ERR_NO_RETURN_BUFFER: (#  exit 6 #);
errorFormat: (#  exit - 1 #);
unknown: (#  exit 0 #);
BMPformat: (#  exit 1 #);
MetaFileformat: (#  exit 2 #);
PNGFormat: (#  exit 3 #);
JPGFormat: (#  exit 4 #);
readBMPfile:
  (#
     name: ^text;
     cstr: @cstring;
     error:< (# msg: ^text;  enter msg[] do INNER ;  #);
     errorMsg: ^text;
     result: @integer;
     theBITMAPINFOHEADER_EXT: @BITMAPINFOHEADER_EXT;
     
  enter name[]
  do
     sizeOf_BITMAPINFOHEADER_EXT->malloc->theBITMAPINFOHEADER_EXT.ptr;
     (if theBITMAPINFOHEADER_EXT.ptr <> 0 then
         name[]->cstr.set;
         (cstr,theBITMAPINFOHEADER_EXT.ptr)->loadDIBitmapFile->result;
         cstr.free;
         (if result = BITMAP_OK then
             theBITMAPINFOHEADER_EXT.hBitmap->private.handleToPixmap;
             theBITMAPINFOHEADER_EXT.hDIB->private.handleToDib;
             theBITMAPINFOHEADER_EXT.biWidth->private.width;
             theBITMAPINFOHEADER_EXT.biHeight->private.height;
             theBITMAPINFOHEADER_EXT.biBitCount->private.depth;
             
          else
             &text[]->errorMsg[];
             'Pixmap.read failed for: '->errorMsg.puttext;
             name[]->errorMsg.putline;
             (if result
              // ERR_OPEN_FILE then
                 'Error: The file could not be opened.'->errorMsg.putline; 
              // ERR_READ_DI_BITMAPINFO then
                 'Error: Failed to read BITMAPINFO.'->errorMsg.putline; 
              // ERR_REALLOCATE_HDIB then
                 'Error: Failed to reallocate space for DIB.'->errorMsg.putline;
                 
              // ERR_READING_BITMAP_FROM_DIB then
                 'Error: Failed to read bitmap from DIB.'->errorMsg.putline; 
              // ERR_NO_RETURN_BUFFER then
                 'Error: Not enough space to load bitmap.'->errorMsg.putline; 
             if);
             errorMsg[]->error;
             
         if);
         theBITMAPINFOHEADER_EXT.ptr->free;
         
     if);
     
  #);
readMetafile:
  (# name: ^text; error:< (# msg: ^text;  enter msg[] do INNER ;  #); 
  enter name[]
  do 
  #);
ReadPNGalpha: external
  (#
     name: [1] @char;
     hbmp: @integer;
     pixels: @integer;
     width: @integer;
     height: @integer;
     result: @integer;
     mask: @integer;
     
  enter (name,hbmp,pixels,width,height,mask)
  exit result
  #);
ReadJPGtoDibSection: external
  (#
     name: [1] @char;
     hbmp: @integer;
     pixels: @integer;
     width: @integer;
     height: @integer;
     result: @integer;
     
  enter (name,hbmp,pixels,width,height)
  exit result
  #);
readJPGfile:
  (#
     name: ^text;
     error:< (# msg: ^text;  enter msg[] do INNER ;  #);
     result: @integer;
     
  enter name[]
  do
     (name,@@ private.handleToPixmap,@@ private.pixels,@@ private.width,@@
      private.height)->ReadJPGtoDibSection->result;
     
  #);
makePixmap: (#  do - 1->private.handleToPixmap #);
WriteDIBSectionToJPGFile: external
  (#
     name: [1] @char;
     pixels: @integer;
     width,height: @integer;
     left,top,right,bottom: @integer;
     channels: @integer;
     quality: @integer;
     err: @integer;
     
  enter (name,pixels,width,height,left,top,right,bottom,channels,quality)
  exit err
  #);
readPNGfile:
  (#
     name: ^text;
     error:< (# msg: ^text;  enter msg[] do INNER ;  #);
     result: @integer;
     hmask: @integer;
     mask: ^Pixmap;
     
  enter name[]
  do
     (name,@@ private.handleToPixmap,@@ private.pixels,@@ private.width,@@
     private.height,@@ hmask)->ReadPNGalpha->result;
     (if result = 0 then
         (if hmask <> 0 then
             &Pixmap[]->mask[];
             hmask->mask.private.handleToPixmap;
             private.width->mask.private.width;
             private.height->mask.private.height;
             mask[]->private.transparentmask[];
             true->private.drawtransparent
         if);
      else 
         -1 -> private.handleToPixmap;
     if);
  #);
  

-- pixMapRead: DoPart --
do
   l:
     (# theExpandedName: ^text; format: @integer; msg: ^text; 
     do
        name[]
          ->expandPixmapName
            (#
               error::< 
                 (# originalMsg: ^text; 
                 do
                 (* msg[]->originalMsg[];
                  * 'brokenImageImage.png'
                  *   ->expandPixmapName
                  * (#
                  *    error::< 
                  *      (# 
                  *      do originalMsg[]->THIS(read).error; leave l; 
                  *      #);
                  *    
                  * #)->expandedName[];
                  *) '-1'->expandedName[]; 
                 #);
               
            #)->theExpandedName[];
        (if theExpandedName[] <> none then
            theExpandedName[]->guessPixmapFormat->format;
            (if format
             // BMPformat then
                theExpandedName[]
                  ->readBMPfile
                    (# error::  (#  do msg[]->THIS(read).error #) #);
                
             // MetaFileformat then
                theExpandedName[]
                  ->readMetafile
                    (# error::  (#  do msg[]->THIS(read).error #) #);
                
             // PNGFormat then
                theExpandedName[]
                  ->readPNGFile
                    (# error::  (#  do msg[]->THIS(read).error #) #);
                
             // JPGFormat then
                theExpandedName[]
                  ->readJPGfile
                    (# error::  (#  do msg[]->THIS(read).error;  #) #);
                
             // errorFormat then
                makePixmap
             // unknown then
                &text[]->msg[];
                'file "'->msg.putText;
                theExpandedName[]->msg.putText;
                '" has an unknown format!'->msg.putLine;
                msg[]->error;
                
            if);
            
        if)
     #);
     

-- pixmapInit: DoPart --
do
     (# 
     do
        (0,@@ private.pixels,width,- height)->BetaCreateBitmap
          ->private.handletopixmap;
        (if private.handletopixmap <> 0 then
            width->private.width; height->private.height; 
        if);
        
     #);
     

-- pixmapClear: DoPart --
do
     (#
        colorref: @integer;
        ntFillRect2: external
          (#
             hdc: @integer;
             (* HDC *)
             theRect: ^ntRECT;
             (* const RECT FAR* *)
             hbr: @integer;
             (* HBRUSH *)
             result: @integer;
             (* int *)
             
          enter (hdc,theRect[],hbr)
          do 'FillRect'->callStd; 
          exit result
          #);
        theRect: @ntRECT;
        tempHdc,tempPenBrush: @integer;
        
     do
        theColor[]->makecolorref->colorref->CreateSolidBrush
          ->private.handleToBrush;
        0->createCompatibleDC->private.hdc;
        (private.hdc,private.handletopixmap)->SelectObject;
        0->theRect.left;
        private.width->theRect.right;
        0->theRect.top;
        private.height->theRect.bottom;
        (private.hdc,theRect[],private.handleToBrush)->ntFillRect2;
        private.handleToBrush->DeleteObject;
        private.hdc->deleteDC;
        
     #)  

-- pixmapDispose: DoPart --
do
   assertInitialized;
   0->private.width;
   0->private.height;
   0->private.depth;
   (if not (private.isFromResource and private.isIcon) then
       private.handleToPixmap->DeleteObject;
       (if private.handleToDib <> 0 then
           private.handleToDib->GlobalFree; 
       if);
       
   if);
     

-- pixmapWidth: DoPart --
do
   assertInitialized;
   (if private.handleToPixmap = - 1 then
       (if private.width = 0 then 
           100->value;
        else private.width->value
       if)
    else
       private.width->value
   if);
     

-- pixmapHeight: DoPart --
do
   assertInitialized;
   (if private.handleToPixmap = - 1 then
       (if private.height = 0 then
           100->value
        else
           private.width->value
       if)
    else
       private.height->value
   if);
     

-- pixmapSetTransparent: DoPart --
do
   value->private.drawtransparent;
   (if not value then
       (0,0,0)->private.transparentcolor; none ->private.transparentmask[]; 
   if);
     

-- pixmapGetTransparent: DoPart --
do private.drawtransparent->value;   

-- pixmapSetTransparentColor: DoPart --
do true->private.drawtransparent; theColor->private.transparentcolor;   

-- pixmapGetTransparentColor: DoPart --
do private.transparentcolor->theColor;   

-- pixmapSetMask: DoPart --
do true->private.drawtransparent; theMask[]->private.transparentmask[];   

-- pixmapGetMask: DoPart --
do private.transparentmask[]->theMask[];   

-- pixmapDrawPixmap: DoPart --
do
     (# result: @integer; colorref: @integer; 
     do
        (if other.private.drawtransparent then
            (if other.private.transparentmask[] <> none then
            (* draw with mask *)
                (private.handletopixmap,to.h,to.v,other.private.handletopixmap,
                 from.h,from.v,width,height,- 2,
                 other.private.transparentmask.private.handletopixmap)
                  ->drawbitmaponbitmap->result;
                
             else
            (* draw with transparentcolor *)
                other.private.transparentcolor[]->makeColorRef->colorref;
                (private.handletopixmap,to.h,to.v,other.private.handletopixmap,
                 from.h,from.v,width,height,colorref,0)->drawbitmaponbitmap
                  ->result;
                
            if);
            
         else
        (* draw normal *)
            (private.handletopixmap,to.h,to.v,other.private.handletopixmap,
             from.h,from.v,width,height,- 1,0)->drawbitmaponbitmap->result;
            
        if);
        (if result = 0 then
            'draw pixmap on pixmap failed'->screen.putline; 
        if);
        
     #)  

-- PixmapWriteJPG: DoPart --
do
   (if private.pixels <> 0 then
       (name,private.pixels,private.width,private.height,area.left,area.top,
        area.right,area.bottom,4,quality)->WriteDIBSectionToJPGFile;
       
    else
       'NO pixels!'->putline; 
   if);
     

-- PixmapWritePNG: DoPart --
do
     (#
        width,height: @integer;
        t_red,t_green,t_blue: @integer;
        transparent: @integer;
        t_color: ^Color;
        
     do
        area.size->(width,height);
        (if private.drawtransparent then
            private.transparentcolor[]->t_color[];
            t_color.red %srl 8->t_red;
            t_color.green %srl 8->t_green;
            t_color.blue %srl 8->t_blue;
            1->transparent;
            
         else
            0->transparent; 
        if);
        (if depth
         // 32 then
            (private.handletopixmap,area.left,area.top,width,height,name)
              ->write_pixels_to_png_area;
            
         // 24 then
            (private.handletopixmap,area.left,area.top,width,height,name,
             transparent,t_red,t_green,t_blue)->write_pixels_to_png_area_rgb;
            
         // 8 then
            (private.handletopixmap,area.left,area.top,width,height,name,
             transparent,t_red,t_green,t_blue)
              ->write_pixels_to_png_area_indexed;
            
        if);
        
     #);
     

