ORIGIN '../fieldsbody';
BODY 'richTextFieldBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)

INCLUDE '../../guienvactions';
INCLUDE 'guienv_ntiprivate';
INCLUDE 'guienvattributes';
INCLUDE '~beta/win32lib/v1.2/scrollbarsupport';
INCLUDE '~beta/win32lib/v1.2/systemmetrics';
INCLUDE '~beta/win32lib/v1.2/dialogcontrolmanagement';
INCLUDE '~beta/win32lib/v1.2/wingdi';
INCLUDE '~beta/win32lib/v1.2/gdistructs';
INCLUDE '~beta/win32lib/v1.2/windowsmisc';
INCLUDE '~beta/win32lib/v1.2/winuserconsts';
INCLUDE '~beta/win32lib/v1.2/memorymanagement';
INCLUDE '~beta/win32lib/v1.2/errorhandling';
INCLUDE '~beta/win32lib/v1.2/clipboardmanager';
INCLUDE '~beta/sysutils/v1.6/cstring';

INCLUDE 'richTextI_O';
INCLUDE 'richTextConsts';

-- lib: attributes --
minMax:
  (# minimum,value,maximum: @integer;
  enter (minimum,value,maximum)
  do ((minimum,value) -> Max,maximum) -> Min -> value;
  exit value
  #);

-- GUIENVmovieFieldSetContents: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldGetContents: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldSetScaleToFit: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldGetScaleToFit: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldCreate: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldOpen: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldClose: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldPrivate: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldBeforeChangeTheText: doPart --
do (if length>0 then this(guienv).private.textfieldChangeText[]->value[]; if);
   
-- GUIENVtextFieldonFrameChanged: descriptor --
(# 
do inner onFrameChanged;
   setTextFieldMargins;
#)

-- GUIENVtextFieldonKeyDown: descriptor --
(# start,end,length: @integer;
   performEdit: @boolean;
   info: ^messageInfo;
do (if not (VK_CONTROL -> isVKeyDown) then
       inner onKeyDown;
       currentMessageInfo -> info[];
       FALSE -> info.callback;
       (if this(textField).isOpen then
           selection -> (start,end);
           end - start -> length;
           true -> performEdit;
           (if (length<>0) then
               (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
           if);
           none -> this(guienv).private.textfieldChangeText[];
           (if performEdit then
               (if ch
                //ascii.bs then
                   (start-1,-1) -> theEventHandler.onBeforeChange -> performEdit;
                //ascii.del then
                   (start,-1) -> theEventHandler.onBeforeChange -> performEdit;
                //ascii.cr
                //ascii.nl then
                   &text[] -> this(guienv).private.textfieldChangeText[];
                   ch -> this(guienv).private.textfieldChangeText.put;
                   (start,1) -> theEventHandler.onBeforeChange -> performEdit;
                else
                   &text[] -> this(guienv).private.textfieldChangeText[];
                   ch -> this(guienv).private.textfieldChangeText.put;
                   (start,1) -> theEventHandler.onBeforeChange -> performEdit;
               if);
               (if performEdit then
                   callDefaultWindowProc;
                   handleTextChanged;
               if);
           if);
           none -> this(guienv).private.textfieldChangeText[];
       if);
   if);
#)

-- GUIENVtextFieldonMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVtextFieldonMouseUp: descriptor --
(#
do (if private.notification then (* 060396 /les *)
       inner onMouseUp; 
   if);
#)

-- GUIENVtextFieldonRefresh: descriptor --
(# width,height: @integer;
   info: ^messageInfo;
do inner onReFresh;
   currentMessageInfo -> info[];
   FALSE -> info.callback;
   callDefaultWindowProc;
   size -> (width,height);
   (this(textField)[],borderStyles.shadowIn,0,0,width,height) -> drawBorder;
#)

-- GUIENVtextFieldOnEnableTarget: descriptor --
(#
do inner onEnableTarget;
#)

-- GUIENVtextFieldOnDisableTarget: descriptor --
(#
do inner onDisableTarget;
#)

-- GUIENVtextFieldDoPaste: descriptor --
(# result: @integer;
do (interfaceObjectID,WM_PASTE, 0, 0) -> sendMessage -> result;
#)

-- GUIENVtextFieldDoCopy: descriptor --
(# 
do (interfaceObjectID,WM_COPY, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldDoCut: descriptor --
(# 
do (interfaceObjectID,WM_CUT, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldDoClear: descriptor --
(# 
do (interfaceObjectID,WM_CLEAR, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldSetContents: descriptor --
assertOpen
(# location::(# do 'TextField.SetContents'->t[] #);
   result: @integer;
   cstr: @cString; localCstr: ^cString;
   theTextStyle: ^textStyle;
do textFieldDefaultStyle -> theTextStyle[];
   setTextFieldMargins;
   theText[] -> cstr.set;
   cstr.toLocal -> localCstr[];
   (interfaceObjectID,WM_SETTEXT, 0, localCstr.charPtr)->sendMessage->result;
   (result,'textFieldSetContents') -> checkSetTextError;
   cstr.free; localCstr.free;
#)

-- GUIENVtextFieldGetContents: descriptor --
assertOpen
(# location::(# do 'TextField.GetContents'->t[] #);
   result: @integer;
   cstr: ^cString; localCstr: @cString;
   length: @integer; 
   t: ^text;
   windowID: @integer;
do interfaceObjectID -> windowID;
   (windowID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
   length+1 -> localCstr.init;
   (windowID,WM_GETTEXT, length+1, localCstr.charPtr) -> sendMessage 
      -> result;
   (if (result<>length) then
       'TextField.getContents: Did not copy all text!' -> screen.putLine;
   if);
   localCstr.fromLocal -> cstr[];
   &styledText[] -> theText[];
   cstr.get -> t[];  t -> theText;
   theText.T.range -> theText.pos -> theText.lgth;
   localCstr.free; cstr.free;
#)

-- GUIENVtextFieldGetChar: descriptor --
assertOpen
(# location::(# do 'TextField.GetChar'->t[] #); 
do pos -> TextEditGetChar -> ch;
#)

-- GUIENVtextFieldLength: descriptor --
assertOpen
(# location::(# do 'TextField.Length'->t[] #);
   windowId: @integer;
   totalNoOfLines: @integer;
do interfaceObjectID -> windowId;
   (windowId,WM_GETTEXTLENGTH,0,0) -> SendMessage -> value;
   (windowId,EM_GETLINECOUNT,0,0)-> sendMessage -> totalNoOfLines;
   value - totalNoOfLines+1 -> value;
#)

-- GUIENVtextFieldScanText: descriptor --
assertOpen
(# location::(# do 'TextField.ScanText'->t[] #);
   theText: ^text;
do cursors.watch[] -> mouse.busyCursor;
   (0,start,length) -> minMax -> start;
   (0,end,length) -> minMax -> end;
   (if (start<>end) then       
       (if (start<end) then
           (start,end) -> TextEditGetRange -> theText[];
        else
           (end,start) -> TextEditGetRange -> theText[];
       if);
       
       theText.scanAll(# do ch -> this(scanText).ch; inner scanText; #);
   if);
   NONE -> mouse.busyCursor;
#)

-- GUIENVtextFieldPosToPt: descriptor --
assertOpen
(# location::(# do 'TextField.PosToPt'->t[] #);   
   windowId: @integer;
   thePointPtr: @integer;
   EM_POSFROMCHAR: (# exit 16x00D6 #);
   
do interfaceObjectId -> windowId;
   pos -> private.translateToLocal -> pos;
   8 -> malloc -> thePointPtr;
   (windowId,EM_POSFROMCHAR,thePointPtr,pos) -> SendMessage;
   thePointPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
   pt.v + charHeight -> pt.v;
   thePointPtr -> free;
#)

-- GUIENVtextFieldPtToPos: descriptor --
assertOpen
(# location::(# do 'TextField.PtToPos'->t[] #);
   windowId: @integer;
   thePosPtr: @integer;
   EM_CHARFROMPOS: (# exit 16x00D7 #);
   
do interfaceObjectId -> windowId;
   pt -> makeNtPointPtr -> thePosPtr;
   (windowId,EM_CHARFROMPOS,0,thePosPtr) -> SendMessage -> pos; 
   pos -> private.translateFromLocal -> pos;
   thePosPtr -> free;
#)

-- GUIENVtextFieldSelectionStart: descriptor --
(# id: @integer;
   h,v: @integer;
do interfaceObjectID -> id;
   (id,EM_GETSEL,@@h,@@v) -> SendMessage;
   h -> private.translateFromLocal -> value;
#)

-- GUIENVtextFieldSelectionEnd: descriptor --
(# id: @integer;
   h,v: @integer;
do interfaceObjectID -> id;
   (id,EM_GETSEL,@@h,@@v) -> SendMessage;
   v -> private.translateFromLocal -> value;
#)

-- GUIENVtextFieldSelectionContents: descriptor --
(# theStart, theEnd: @integer;
do &text[] -> theText[];
   start -> theStart; end -> theEnd;
   (start,end) -> TextEditGetRange -> theText[];
#)

-- GUIENVtextFieldSelectionScrollIntoView: descriptor --
(# result: @integer;
do (* (interfaceObjectID,EM_SCROLLCARET,0,0) -> SendMessage -> result; *)
   scrollIntoView2;
#)

-- GUIENVtextFieldSelectionSet: descriptor --
(# result: @integer;
   id: @integer;
do interfaceObjectID -> id;
   (if theStart <> theEnd then
       theStart -> private.translateToLocal -> theStart;
       theEnd -> private.translateToLocal -> theEnd;
    else
       theStart -> private.translateToLocal -> theStart -> theEnd;
   if);
   (id,EM_SETSEL,theEnd,theStart) -> SendMessage -> result;
#)

-- GUIENVtextFieldSetDefaultStyle: descriptor --
(# windowID: @integer;
do (if style[]<>NONE then
       style.create;
       style[] -> textFieldDefaultStyle;
       interfaceObjectID -> windowID;
       (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   if);
#)

-- GUIENVtextFieldGetDefaultStyle: descriptor --
(#
do textFieldDefaultStyle -> style[];
#)

-- GUIENVtextFieldIsOneStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetOneSize: descriptor --
(# 
do <<SLOT GUIENVtextFieldSetOneSize2: descriptor>>
#)

-- GUIENVtextFieldSetOneFont: descriptor --
(#
do <<SLOT GUIENVtextFieldSetOneFont2: descriptor>>
#)

-- GUIENVtextFieldSetOneFace: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetOneStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldScanTextWithStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetMargin: descriptor --
(#
do (leftMargin,topMargin) -> textFieldMargin;
   setTextFieldMargins;
   
#)

-- GUIENVtextFieldGetMargin: descriptor --
(#
do textFieldMargin -> (leftMargin,topMargin);
#)

-- GUIENVtextFieldInsert: descriptor --
(# result: @integer;
   cstr: @cString; localCstr: ^cString;
   start, end: @integer;
do theText[] -> cstr.set;
   cstr.toLocal -> localCstr[];
   selection -> (start,end);
   (if (start<>end) then 
       (start,start) -> selection;
   if);
   (interfaceObjectID,EM_REPLACESEL, 0, localCstr.charPtr) 
     -> sendMessage -> result;
   (result,'textFieldInsert')-> checkSetTextError;
   (if (start<>end) then 
       theText.lgth + start -> start;
       theText.lgth + end -> end; 
       (start,end) -> selection;
   if);
   cstr.free; localCstr.free;
#)

-- GUIENVtextFieldDelete: descriptor --
(# 
do (interfaceObjectID,WM_CLEAR, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldCreate: descriptor --
(# libOk: @integer;
   wStyle: @integer;
   LoadLibraryA: external
     (#
        in0: [1] @char; (* LPCSTR *)
        out: @integer; (* HINSTANCE *)
     enter in0
     do callStd;
     exit out
     #);
   ES_DISABLENOSCROLL: (# exit 16x00002000 #); (* 110396 /les *)
do true -> this(windowItem).private.borderHandledLocally;
   'RICHED32.DLL' -> LoadLibraryA -> libOk;
   (if libOk=0 then
       'RICHED32.DLL -> LoadLibraryA failed. Error= ' -> screen.putText;
       GetLastError -> screen.putint; screen.newline;
    else
       &textFieldNotiMethods[] -> theNotiMethods; (* 060396 /les *)
       isSubClass -> windowItemClassStatus;
       'RichEdit' -> windowItemClass;
       (if private.useScrollbars then
           (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
           (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_AUTOVSCROLL,wStyle) -> tos'%or' -> wStyle;
           (WS_HSCROLL,wStyle) -> tos'%or' -> wStyle;
           (WS_VSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_DISABLENOSCROLL,wStyle) -> tos'%or' -> wStyle; 
           wStyle  -> windowItemStyle;
        else
           (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
           (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_AUTOVSCROLL,wStyle) -> tos'%or' -> wStyle;
           wStyle  -> windowItemStyle;
       if);
       &textfieldMethods[] -> theMethods;
       inner create;
   if);
#)

-- GUIENVtextFieldOpen: descriptor --
(# hdc: @integer; tmPtr: @integer; result: @integer; errorcode: @integer;
   style: ^textStyle; t: ^text;
   windowID: @integer;
   
   (* 060396 /les *)
   ENM_MOUSEEVENTS: (# exit 16x00020000 #);
   EM_SETEVENTMASK: (# exit  (WM_USER + 69) #);
   ANSI_FIXED_FONT: (# exit 11 #);
   
   theMask: @integer;
   textLimit: @integer;
do interfaceObjectID -> windowID;
   defaultTextFieldTextStyle -> style[];
   (if style[]=NONE then      
       &textStyle[] -> style[];
       
       'Arial' -> style.name;
       10 -> style.size;
       (* textFaces.bold -> style.face; *)
       style.create;
       (* ANSI_FIXED_FONT -> GetStockObject -> style.textStyleID;
        * style[] -> defaultTextFieldTextStyle;
        *)
   if);
   (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   style[] -> textFieldDefaultStyle;
   
   cursors.iBeam[] -> theCursor; 
   
   windowID -> GetDC -> hdc;
   56 -> malloc -> tmPtr;
   (hdc, tmPtr) -> GetTextMetrics -> result;
   (if result=0 then
       'TextFieldOpen. GetTextMetrics failed. Error: ' ->  screen.putText;
       GetLastError -> putint; newline;
    else
       tmPtr + textmetricTmAveCharWidthOffset -> TOS'%adrGetLong' -> charWidth;
       tmPtr + textmetricTmHeightOffset -> TOS'%adrGetLong' -> charHeight;
   if);
   (* Clean up *)
   (windowID,hdc) -> ReleaseDC;  
   tmPtr -> free;
   true -> border.visible;
   borderStyles.simple -> border.style;
   
   &text[] -> t[]; '' -> t;
   (if ( (windowID,t) -> SetWindowText) = 0  then
       'SetWindowText failed in textField.open. Errorcode: ' -> screen.putText;
       GetLastError -> screen.putInt; screen.newline;
   if);
   (windowID,EM_LIMITTEXT,0,0) -> SendMessage;
   (if private.useScrollbars then
       (* We have a textEditor, enable large texts *)
       1024 * 1024 -1 -> textLimit;
       (windowID,EM_EXLIMITTEXT,0,textLimit) -> Sendmessage; 
   if);
   
   (4,4) -> textFieldMargin;
   
   private.makeRichEditI_O;
   (NONE,SF_RTF) -> private.theRichEditI_O.init;
   SCF_SELECTION -> private.formatFlags;
   
   inner open;
   
   (windowID,EM_SETEVENTMASK,0,ENM_MOUSEEVENTS) -> SendMessage -> theMask;
   (theMask,ENM_MOUSEEVENTS) -> tos'%or' -> theMask;
   (windowID,EM_SETEVENTMASK,0,theMask) -> SendMessage -> theMask;
   
   setTextFieldMargins;
   true -> private.firstFocus;
   private.theActivateAction[] -> AppendAction;
   private.theAboutToCloseAction[] -> AppendAction;
   private.theVisibleChangedAction[] -> AppendAction;
#)

-- GUIENVtextFieldClose: descriptor --
(# 
do inner close;
   private.theActivateAction[] -> deleteAction; (* 110396 /les *)
   private.theAboutToCloseAction[] -> deleteAction;
   private.theVisibleChangedAction[] -> deleteAction;
   true -> private.closeAction;
#)

-- textFieldLib: attributes --
ES_SELECTIONBAR: (# exit 0x01000000 #);
WS_EX_CLIENTEDGE: (# exit 0x00000200 #);
EM_EXLIMITTEXT: (# exit (WM_USER + 53) #);
EM_SETOLECALLBACK: (# exit (WM_USER + 70) #); 

SendMessage2: external
  (# hwnd: @integer; 
     uMsg: @integer; 
     wParam: @integer; 
     lParam: ^cStruct; 
     out: @integer; (* LRESULT *)
  enter (hwnd,uMsg,wParam,lParam[])
  do 'SendMessageA' -> callStd;
  exit out
  #);

scrollIntoView2:
  (# iStart,iend, iFirstLine, windowID: @integer;
     EM_EXLINEFROMCHAR: (# exit WM_USER + 54 #);
     EM_EXGETSEL: (# exit WM_USER + 52 #);
     CHARRANGE: cstruct
       (# bytesize::< (# do 8 -> value; #);
          cpMin: @long (# pos::< (# do 0 -> value; #); #); 
          cpMax: @long (# pos::< (# do 4 -> value; #); #); 
       enter(cpMin,cpMax)
       exit(cpMin,cpMax)
       #);
     theSel: @CHARRANGE;
     theTextStyle: ^textStyle;
     widht,height,noOfLines,halfNoOfLines,delta: @integer;
  do this(textField).interfaceObjectID -> windowID;
     defaultStyle -> theTextStyle[];
     (if theTextStyle[]<>NONE then
         this(textField).size -> (widht,height);
         height div theTextSTyle.lineHeight -> noOfLines;
         noOfLines div 2 -> halfNoOfLines;
     if);
     
     (windowID,EM_EXGETSEL,0,theSel[]) -> SendMessage2;
     
     (windowID,EM_EXLINEFROMCHAR,0,theSel.cpMin) -> sendMessage -> iStart;
     (windowID,EM_EXLINEFROMCHAR,0,theSel.cpMax) -> sendMessage -> iEnd;
     (windowID,EM_GETFIRSTVISIBLELINE,0,0) -> sendMessage -> iFirstLine;
     
     (if (iStart < iFirstLine) or (iStart > (iFirstLine + noOfLines)) then
         (if iStart=iEnd then
             -iFirstLine -halfNoOfLines + iStart - 1 -> delta;             
          else
             -iFirstLine + iStart - 1 -> delta;
         if);
         (windowID,EM_LINESCROLL,0, delta ) ->SendMessage;
      else
         (if iStart=iEnd then
             -iFirstLine -halfNoOfLines + iStart - 1 -> delta;
             (windowID,EM_LINESCROLL,0, delta ) ->SendMessage;
         if);
     if);
  #);


setTextFieldMargins:
  (# width,height: @integer;
     scrollbarWidth, scrollbarHeight,delta1,delta2: @integer;
  do size -> (width,height);
     (if private.useScrollbars then
         SM_CXVSCROLL -> GetSystemMetrics -> scrollbarWidth;
         SM_CYHSCROLL -> GetSystemMetrics -> scrollbarHeight;
         width - scrollbarWidth -> width;
         height - scrollbarHeight -> height;
     if);
     
     3 -> delta1; 4 -> delta2;
     (if border.visible then
         (if border.style=borderStyles.simple then
             (private.leftMargin + delta1,private.topMargin + delta1,
             width-delta1,height-delta1,interfaceObjectID) -> setEditRect; 
          else
             (private.leftMargin + delta1,private.topMargin + delta1,
             width-delta1,height-delta1,interfaceObjectID) -> setEditRect; 
         if);
      else
         (private.leftMargin,private.topMargin,
         width,height,interfaceObjectID) -> setEditRect; 
     if);
  #);
setEditRect: external
  (# x,y,width,height,hWnd: @integer;
  enter (x,y,width,height,hWnd)
  do callC;
  #);
handleTextChanged:
  (# 
  do theEventHandler.onTextChanged;
  #);

textFieldDefaultStyle:
  (#
  enter private.textFieldDefaultStyle[]
  exit private.textFieldDefaultStyle[]
  #);
textFieldMargin:
  (#
  enter (private.leftMargin,private.topMargin)
  exit (private.leftMargin,private.topMargin)
  #);
textFieldScroller:
  (#
  enter private.textFieldScroller[]
  exit private.textFieldScroller[]
  #);

TextEditGetRange:
  (# theText: ^text; tempText: @text;
     result: @integer;
     cstr: ^cString; localCstr: @cString;
     length: @integer; 
     t,t2,t3: ^text;
     startInx, endInx: @integer;
  enter (startInx, endInx)
  do &text[] -> theText[];
     (interfaceObjectID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
     length+1 -> localCstr.init;
     (interfaceObjectID,WM_GETTEXT, length+1, localCstr.charPtr) 
       -> sendMessage -> result;
     (if (result<>length) then
         'TextField.TextEditGetRange: Did not copy all text!'-> screen.putLine;
     if);
     localCstr.fromLocal -> cstr[];
     localCstr.free;
     
     cstr.get -> t[];
     cstr.free;
     
     t.T.range -> t.pos -> t.lgth;     
     (startInx+1,endInx) -> t.sub -> t[];
     
     &styledText[] -> theText[];
     t -> theText;
     
     theText.T.range -> theText.pos -> theText.lgth;
  exit theText[]
  #);
TextEditGetChar:
  (# inx: @integer;
     ch: @integer;
     theLineNo,lineNo1,lineNo2: @integer;
     cstr: @cString;
     length, lineInx, result: @integer; 
     t: @text;
     textLength: @integer;
  enter inx
  do (if inx<0 then
      else
         (interfaceObjectId,EM_LINEFROMCHAR,inx,0) -> sendMessage -> theLineNo;
         (interfaceObjectId,EM_LINEFROMCHAR,inx+1,0) -> sendMessage -> lineNo2;
         
         (if lineNo2>theLineNo then
             ascii.nl -> ch;
          else
             
             (interfaceObjectId,EM_LINEINDEX,theLineNo,0) 
               -> sendMessage -> lineInx;
             (interfaceObjectID,EM_LINELENGTH,lineInx,0) 
               -> sendMessage -> length;
             
             (if length=0 then ascii.nl -> ch;
              else
                 length+1 -> cstr.init;
                 (interfaceObjectID,EM_GETLINE,theLineNo,cstr.charPtr) 
                   -> sendMessage -> result;
                 (if result=0 then
                     '**WARNING: Bad line number in TextEditGetChar.'->putline;
                 if);
                 
                 inx - lineInx -> cstr.inxGet -> ch;
                 cstr.free;
             if);
         if);
     if);
  exit ch
  #);
charWidth:
  (#
  enter private.cxChar
  exit private.cxChar
  #);  
charHeight:
  (#
  enter private.cyChar
  exit private.cyChar
  #);  

(* 060396 /les *)
EN_MSGFILTER: (# exit 16x0700 #);

textFieldNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# processNotify:
            (# code1: @integer;
               message: @integer;
               newWparam: @integer;
               newLparam: @integer;
               longInt: @CStruct
                 (#	ByteSize:: (# do 4 -> Value; #);
                    loWord: signedShort (# Pos:: (# do 0 -> Value; #); #);
                    hiWord: signedShort (# Pos:: (# do 2 -> Value; #); #);
                 enter R[1]
                 exit R[1]
                 #);
               
               oldInfo: ^messageInfo;
               
            do false -> didSomething;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               (if code1
                //EN_MSGFILTER then
                   info.lParam+12 -> TOS'%adrGetLong' -> message;
                   (if message
                    //WM_LBUTTONUP  then
                       true -> private.notification;
                                           
                       &messageInfo[] -> oldInfo[];
                       info.wParam -> oldInfo.wParam;
                       info.lParam -> oldInfo.lParam;
                       info.message -> oldInfo.message;
                       info.where -> oldInfo.where;
                       info.time -> oldInfo.time;
                       
                       info.lParam+16 -> TOS'%adrGetLong' -> newWparam;
                       info.lParam+20 -> TOS'%adrGetLong' -> newLparam;
                       newWparam -> longInt;
                       longInt.hiWord -> info.wParam.hiWord;
                       longInt.loWord -> info.wParam.loWord;
                       newWparam -> info.wParam;
                       newLparam -> longInt;
                       longInt.hiWord -> info.lParam.hiWord;
                       longInt.loWord -> info.lParam.loWord;
                       newLparam -> info.lParam;
                       message -> info.message;
                       GetMessagePos -> longInt;
                       (longInt.loWord,longInt.hiWord) -> info.where;
                       getMessageTime -> info.time;
                       1 -> info.button;
                       
                       FALSE -> info.callback;
                       
                       theEventHandler.onMouseUp;
                       
                       oldInfo.wParam -> info.wParam;
                       oldInfo.lParam -> info.lParam;
                       oldInfo.message -> info.message;
                       oldInfo.where -> info.where;
                       oldInfo.time -> info.time;
                       false -> private.notification;
                       
                       true -> didSomething;
                       (* 1 -> info.result; *)
                   if);
               if);
            #);
          
          didSomething: @boolean;
       do (if info.message=WM_NOTIFY then processNotify;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);
(* 060396 /les end *)

textFieldMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     
     dispatchMessage::
       (# didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer; length: @integer;
          p: @point; pos: @integer;
          ch: @char;
          
       do true -> didSomething;
          (if info.message 
              
           //WM_KEYDOWN then
              info.wParam -> ch;
              (if ch
               //'V' then 
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,WM_PASTE, 0, 0) -> sendMessage;
                  if);
               //'X' then
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,WM_CUT, 0, 0) -> sendMessage;
                  if);
                  (* //'Z' then
                   *                   (if (VK_CONTROL -> isVKeyDown) then
                   *                       FALSE -> info.callback;
                   *                       true -> info.handled;
                   *                   if);
                   *)
               else
                  false -> didSomething;
              if);
              
           //WM_LBUTTONDOWN  then
              selection -> (start,end);
              (if start<>end then
                  (if (not (VK_SHIFT -> isVKeyDown)) then
                      (if (not (VK_CONTROL -> isVKeyDown)) then
                          (info.lParam.loWord,info.lParam.hiWord) -> p;
                          p -> ptToPos -> pos;
                          (interfaceobjectid,EM_SETSEL,pos,pos) -> SendMessage;
                      if);
                  if);
              if);
              
           //WM_PASTE then 
              FALSE -> info.callback;
              clipboard.textContents -> clipboardText[];
              (if clipboardText[]<>NONE then 
                  clipboardText.length -> clipboardLength;
                  selection -> (start,end);
                  end - start -> length;
                  true -> performEdit;
                  none -> this(guienv).private.textfieldChangeText[];
                  (if (clipboardLength<>0) then
                      (if (length<>0) then
                          (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                      if);
                      (if performEdit then
                          clipboardText[] -> this(guienv).private.textfieldChangeText[];
                           
                          (start,clipboardLength) -> theEventHandler.onBeforeChange 
                            -> performEdit;
                          (if performEdit then
                              callDefaultWindowProc;
                              handleTextChanged;
                          if);
                          none -> clipboardText[];
                          none -> this(guienv).private.textfieldChangeText[];
                      if);
                  if);
              if);
              
           //WM_CUT then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              true -> performEdit;
              
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  
                  (if performEdit then
                      callDefaultWindowProc;
                      handleTextChanged;
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
              
           //WM_CLEAR then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  (if performEdit then
                      callDefaultWindowProc;
                      handleTextChanged;
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);


-- GUIENVtextFieldPrivate: descriptor --
(# OsMajorVersion: @integer;
   
   (* OLE2/COM stuff: begin *)
   
   textOnly,allowDragDrop: @boolean;
   topLevelWindow: ^window;
   theRichEditI_O: ^richEditI_O;
   
   readFromFile:
     (# fileName: ^text;
     enter fileName[]
     <<SLOT richTextFieldReadFromFile: doPart>>
     exit fileName[]
     #);
   
   save:
     (# fileName: ^text;
     <<SLOT richTextFieldSave: doPart>>
     exit fileName[]
     #);
   
   saveAs:
     (# fileName: ^text;
     <<SLOT richTextFieldSaveAs: doPart>>
     exit fileName[]
     #);
   
   print:
     (# <<SLOT richTextFieldPrint: doPart>> #);
   
   selectCharFormat:
     (# theTextColor: @integer;
     do handleFontSelection -> theTextColor; 
     exit theTextColor
     #);
   
   canCut: booleanValue
     (# <<SLOT richTextFieldCancut: doPart>> #);
   
   canCopy: booleanValue
     (# <<SLOT richTextFieldCanCopy: doPart>> #);
   
   canPaste: booleanValue
     (# <<SLOT richTextFieldCanPaste: doPart>> #);
   
   closeAction:
     (# okToClose: @boolean;
     enter okToClose
     do 
     #);
   formatFlags: @integer;
   
   makeRichEditI_O:
     (# do &richEditI_O[] -> theRichEditI_O[]; #);
   
   handleFontSelection:
     (# 
        lf: @LOGFONT2;
        csf: @CHOOSEFONT;
        
        cf: @CHARFORMAT;
        yPerInch: @integer;
        hdc: @integer;
        windowID, topLevelWindowID: @integer;
        
        theTextColor: @integer;
     <<SLOT handleFontSelectionImpl: doPart>>
     exit theTextColor
     #);
   
   (*************************************************
    * *************OLE2/COM stuff: end **************
    * ***********************************************)
   
   
   (* 110396 /les *)
   theActivateAction: @activateAction
     (# 
     do (if private.firstFocus then
            false -> private.firstFocus;
            setTextFieldMargins;
        if);
     #);
   theAboutToCloseAction: @aboutToCloseAction
     (# 
     do theEvent.okToClose -> closeAction;
     #);
   theVisibleChangedAction: @visibleChangedAction
     (# 
     do setTextFieldMargins;
        true -> update;
     #);
   
   firstFocus: @boolean;
   
   longInt: cstruct
     (# byteSize:: (# do 4 -> value; #);
        loWord: short(# pos:: (# do 0 -> value; #); #);
        hiWord: short(# pos:: (# do 2 -> value; #); #);
     enter R[1]
     exit  R[1]
     #);
   cxChar, cyChar: @integer;
   textFieldDefaultStyle: ^textStyle; 
   leftMargin, topMargin: @integer;
   textFieldScroller: ^textEditor;
   useScrollbars: @boolean;
   notification: @boolean; (* 060396 /les *)
   
   translateToLocal:
     (# oldPos, newPos: @integer;
        i,curPos,prevPos,noOfChars: @integer;
        doLeave: @boolean;
        id: @integer;
     enter oldPos
     do interfaceobjectID -> id;
        (id,EM_LINEFROMCHAR,oldPos,0)->SendMessage->i;
        L1: (# 
            do curPos -> prevPos;
               (id,EM_LINEINDEX,i,0)->SendMessage->curPos;
               (id,EM_LINELENGTH,curPos,0)->SendMessage->noOfChars;
               (if curPos=-1 then prevPos->curPos; true -> doLeave; if);
               (if ((curPos<=(oldPos+i)) and ((oldPos+i) <= (curPos+noOfChars)))
                   or doLeave
                   then
                   leave L1
                else 
                   i + 1 -> i;
                   restart L1;;
               if);
            #);
        oldPos + i  -> newPos;
     exit newPos
     #);
   
   translateFromLocal:
     (# oldPos, newPos: @integer;
        lineNo: @integer;
        windowId: @integer;
     enter oldPos
     do interfaceobjectID -> windowId;
        (windowId,EM_LINEFROMCHAR,oldPos,0)->SendMessage->lineNo;
        oldPos - LineNo -> newPos;
     exit newPos
     #);
#)

-- GUIENVabstractScrollerScroll: descriptor --
(#
do inner scroll;
#)

-- GUIENVabstractScrollerCreate: descriptor --
(#
do (* WS_BORDER  -> windowitemStyle; *)
   true -> border.visible;
   borderStyles.simple -> border.style;
   
   inner create;
#)

-- GUIENVabstractScrollerOpen: descriptor --
(#
do ((0,0),(200,200)) -> windowItemFrame;
   true -> updateOnResize;
   inner open;
#)

-- GUIENVabstractScrollerClose: descriptor --
(#
do inner close;
#)



-- GUIENVabstractScrollerPrivate: descriptor --
(# 
#)

-- textEditorLib: attributes --

textEditorMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     
     EM_GETLIMITTEXT: (# exit  16x00D5 #);
     
     dispatchMessage::
       (# didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer; length: @integer;
          type,id: @integer;
       do 
          (if info.message=WM_COMMAND then
              info.wParam.hiWord -> type;
              info.wParam.loWord -> id;
              (if type=EN_MAXTEXT then
                  (* true -> didSomething; *)
              if);
           else
              false -> didSomething;
          if);
       #);
  #);

-- GUIENVtextEditorScroll: descriptor --
(# 
do 
#)

-- GUIENVtextEditorCreate: descriptor --
(#
do FALSE -> border.visible;
   &texteditorMethods[] -> theMethods;
   inner create;
#)

-- GUIENVtextEditorOpen: descriptor --
(# width,height: @integer; 
   t: ^text;
do this(textEditor)[] -> contents.textFieldScroller;
   true -> contents.private.useScrollbars;
   this(textEditor)[] -> contents.open;
   size -> (width,height);
   ((0,0),(width,height)) -> contents.frame;
   true -> contents.bindLeft;
   true -> contents.bindTop;
   true -> contents.bindRight;
   true -> contents.bindBottom;
   inner open;
#)

-- GUIENVtextEditorClose: descriptor --
(#
do inner close;
#)

-- GUIENVtextEditorPrivate: descriptor --
(# 
#)

-- GUIENVscrollerScroll: descriptor --
(# flags: @integer;
   h,v: @integer;
   width,height,contentsWidth,contentsHeight,maxHScroll,maxVScroll: @integer;
   result: @integer;
do contents.position -> (h,v);
   SWP_NOSIZE + SWP_NOZORDER -> flags;
   h + dh -> h;
   v + dv -> v;
   privateViewSize -> (width,height);
   contents.size -> (contentsWidth,contentsHeight);
   
   (if width>contentsWidth then width -> contentsWidth; if);
   (if height>contentsHeight then height -> contentsHeight; if);
   
   contentsHeight - height -> maxVScroll;
   contentsWidth - width -> maxHScroll;
   (-maxHScroll,h,0) -> minMax -> h;
   (-maxVScroll,v,0) -> minMax -> v;
   
   (interfaceObjectID,SB_HORZ,-h,1) -> SetScrollPos;
   (interfaceObjectID,SB_VERT,-v,1) -> SetScrollPos;
   (contents.interfaceObjectID,0,h,v,0,0,flags) -> SetWindowPos -> result;
   (result,'scrollerScroll') -> checkNullError;
#)

-- GUIENVscrollerCreate: descriptor --
(# currentStyle, style: @integer;
do WS_HSCROLL + WS_VSCROLL -> style;
   windowitemStyle -> currentStyle;
   (currentStyle,style) -> tos'%or' -> windowItemStyle;
   &scrollerMethods[] -> theMethods;
   inner create;
#)

-- GUIENVscrollerOpen: descriptor --
(# width,height: @integer;
   borderWidth: @integer;
do (if border.visible then
       (if border.style = borderStyles.simple then 1-> borderWidth;
        else 2 -> borderWidth;
       if);
    else 0 -> borderWidth;
    if);
   this(scroller)[] -> private.view.open;
   private.view[] -> contents.open;
   size -> (width,height); 
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth))) -> private.view.frame;
   true -> private.view.bindLeft;
   true -> private.view.bindTop;
   true -> private.view.bindRight;
   true -> private.view.bindBottom;
   
   (* contents.open; *)
   ((0,0),(1000,1000)) -> contents.frame;
   adjustScrollValues;
   private.contentsFrameChangedAction[] -> contents.AppendAction;
   inner open;
   (if border.visible then
       (if border.style = borderStyles.simple then 1-> borderWidth;
        else 2 -> borderWidth;
       if);
    else 0 -> borderWidth;
   if);
   size -> (width,height); 
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth))) -> private.view.frame;
#)

-- GUIENVscrollerClose: descriptor --
(#
do inner close;
#)

-- scrollerLib: attributes --
adjustScrollValues:
  (# contentsWidth,contentsHeight,viewWidth,viewHeight,
     newWidth,newHeight: @integer;
     newH,newV: @integer; 
     maxHScroll,maxVScroll: @integer;
     result: @integer; 
  do contents.size -> (contentsWidth,contentsHeight);
     privateViewSize -> (viewWidth,viewHeight);
     (if viewWidth>contentsWidth then viewWidth -> contentsWidth; if);
     (if viewHeight>contentsHeight then viewHeight -> contentsHeight; if);
     
     (interfaceObjectID,SB_HORZ, 0, contentsWidth - viewWidth, 0) 
       -> SetScrollRange -> result;
     (result,'scrollerLib.adjustScrollValues(1)') -> checkNullError;

     (interfaceObjectID,SB_VERT,0,contentsHeight - viewHeight, 0)
       -> SetScrollRange -> result;
     (result,'scrollerLib.adjustScrollValues(2)') -> checkNullError;
     
     
     (* Adjust the thumb positions *)
     contents.position -> (newH,newV);
     contentsHeight - viewHeight -> maxVScroll;
     contentsWidth - viewWidth -> maxHScroll;
     (-maxHScroll,newH,0) -> minMax -> newH;
     (-maxVScroll,newV,0) -> minMax -> newV;
     
     (interfaceObjectID,SB_HORZ,-newH,1) -> SetScrollPos;
     (interfaceObjectID,SB_VERT,-newV,1) -> SetScrollPos;
     (contents.interfaceObjectID,0,newH,newV,0,0,SWP_NOSIZE + SWP_NOZORDER) 
       -> SetWindowPos -> result;
  #);

scrollTo:
  (# h,v: @integer;
     pos: @point;
  enter (h,v)
  do contents.position -> pos;
     (h - pos.h,v - pos.v) -> scroll;
  #);
privateViewSize:
  (# scrollbarWidth: @integer;
     scrollbarHeight: @integer;
     width,height: @integer;
  do size -> (width,height);
     SM_CXVSCROLL -> GetSystemMetrics -> scrollbarWidth;
     SM_CYHSCROLL -> GetSystemMetrics -> scrollbarHeight;
     width - scrollbarWidth -> width;
     height - scrollbarHeight -> height;
  exit (width,height)
  #);
scrollerMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     contentsWidth,contentsHeight,viewWidth,viewHeight: @integer;
     dispatchMessage::<
       (# 
          processScroll:
            (# amount: @integer;
               absolute: @boolean;
               width,height: @integer;
               orientation: @integer;
            enter orientation
            do privateViewSize -> (width,height);
               (if info.wParam.loWord
                //SB_LINELEFT
                //SB_LINEUP then
                   16 -> amount;
                //SB_LINERIGHT
                //SB_LINEDOWN then
                   -16  -> amount;
                //SB_PAGELEFT
                //SB_PAGEUP then
                   (if orientation=vertical then
                       height -> amount;
                    else
                       width -> amount;
                   if);
                //SB_PAGERIGHT
                //SB_PAGEDOWN then
                   (if orientation=vertical then
                       -height -> amount
                    else
                       - width -> amount;
                   if);
                //SB_THUMBPOSITION then
                   - info.wParam.hiWord -> amount;
                   true -> absolute;
               if);
               (if orientation=vertical then
                   (if absolute then
                       (0,amount) -> scrollTo;
                    else
                       (0,amount) -> scroll;
                   if);
                else
                   (if absolute then
                       (amount,0) -> scrollTo;
                    else
                       (amount,0) -> scroll;
                   if);
               if);
            #);
          
       do 
          (if info.message
           //WM_HSCROLL then horizontal -> processScroll; 
           //WM_VSCROLL then vertical -> processScroll; 
          if);
       #);
  #);

-- GUIENVscrollerPrivate: descriptor --
(# view: @canvas; 
   contentsFrameChangedAction: @contents.frameChangedAction
     (# 
     do adjustScrollValues;
     #);
#)

-- GUIENVScrollerOnFrameChanged: descriptor --
(#
do adjustScrollValues;
   inner onFrameChanged;
#)

