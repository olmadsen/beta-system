ORIGIN '../fieldsbody';
BODY 'richTextFieldBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)

INCLUDE '../../guienvactions';
INCLUDE 'guienv_ntiprivate';
INCLUDE 'guienvattributes';
INCLUDE '~beta/win32lib/v1.6/scrollbarsupport';
INCLUDE '~beta/win32lib/v1.6/systemmetrics';
INCLUDE '~beta/win32lib/v1.6/dialogcontrolmanagement';
INCLUDE '~beta/win32lib/v1.6/wingdi';
INCLUDE '~beta/win32lib/v1.6/gdistructs';
INCLUDE '~beta/win32lib/v1.6/windowsmisc';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';
INCLUDE '~beta/win32lib/v1.6/memorymanagement';
INCLUDE '~beta/win32lib/v1.6/errorhandling';
INCLUDE '~beta/win32lib/v1.6/clipboardmanager';
INCLUDE '~beta/sysutils/v1.6/cstring';

INCLUDE 'richTextI_O';
INCLUDE 'richTextConsts';

-- lib: attributes --
minMax:
  (# minimum,value,maximum: @integer;
  enter (minimum,value,maximum)
  do ((minimum,value) -> Max,maximum) -> Min -> value;
  exit value
  #);

-- GUIENVmovieFieldSetContents: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldGetContents: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldSetScaleToFit: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldGetScaleToFit: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldCreate: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldOpen: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldClose: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldPrivate: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldBeforeChangeTheText: doPart --
do (if length>0 then this(guienv).private.textfieldChangeText[]->value[]; if);
   
-- GUIENVtextFieldonFrameChanged: descriptor --
(# 
do inner onFrameChanged;
   setTextFieldMargins;
#)

-- GUIENVtextFieldonKeyDown: descriptor --
(# start,end,length: @integer;
   performEdit: @boolean;
   info: ^messageInfo;
do (if not (VK_CONTROL -> isVKeyDown) then
       inner onKeyDown;
       currentMessageInfo -> info[];
       FALSE -> info.callback;
       (if this(textField).isOpen then
           selection -> (start,end);
           end - start -> length;
           true -> performEdit;
           (if (length<>0) then
               (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
           if);
           none -> this(guienv).private.textfieldChangeText[];
           (if performEdit then
               (if ch
                //ascii.bs then
                   (start-1,-1) -> theEventHandler.onBeforeChange -> performEdit;
                //ascii.del then
                   (start,-1) -> theEventHandler.onBeforeChange -> performEdit;
                //ascii.cr
                //ascii.nl then
                   &text[] -> this(guienv).private.textfieldChangeText[];
                   ch -> this(guienv).private.textfieldChangeText.put;
                   (start,1) -> theEventHandler.onBeforeChange -> performEdit;
                else
                   &text[] -> this(guienv).private.textfieldChangeText[];
                   ch -> this(guienv).private.textfieldChangeText.put;
                   (start,1) -> theEventHandler.onBeforeChange -> performEdit;
               if);
               (if performEdit then
                   callDefaultWindowProc;
                   (* handleTextChanged; *)
               if);
           if);
           none -> this(guienv).private.textfieldChangeText[];
       if);
   if);
#)

-- GUIENVtextFieldonMouseDown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVtextFieldonMouseUp: descriptor --
(#
do (if buttonState=1 then
       (if private.notification then 
           inner onMouseUp; 
       if);
    else
       inner onMouseUp; 
   if);
#)

-- GUIENVtextFieldonRefresh: descriptor --
(# width,height: @integer;
   info: ^messageInfo;
do inner onReFresh;
   currentMessageInfo -> info[];
   FALSE -> info.callback;
   callDefaultWindowProc;
   size -> (width,height);
   (this(textField)[],borderStyles.shadowIn,0,0,width,height) -> drawBorder;
#)

-- GUIENVtextFieldOnEnableTarget: descriptor --
(#
do inner onEnableTarget;
#)

-- GUIENVtextFieldOnDisableTarget: descriptor --
(#
do inner onDisableTarget;
#)

-- GUIENVtextFieldDoPaste: descriptor --
(# result: @integer;
do (interfaceObjectID,WM_PASTE, 0, 0) -> sendMessage -> result;
#)

-- GUIENVtextFieldDoCopy: descriptor --
(# 
do (interfaceObjectID,WM_COPY, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldDoCut: descriptor --
(# 
do (interfaceObjectID,WM_CUT, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldDoClear: descriptor --
(# 
do (interfaceObjectID,WM_CLEAR, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldSetContents: descriptor --
(# 
   cstr: @cString; localCstr: ^cString;
   theTextStyle: ^textStyle;
do assertOpen;
   textFieldDefaultStyle -> theTextStyle[];
   setTextFieldMargins;
   theText[] -> cstr.set;
   cstr.toLocal -> localCstr[];
   (interfaceObjectID,WM_SETTEXT, 0, localCstr.charPtr)->sendMessage;
   cstr.free; localCstr.free;
#)

-- GUIENVtextFieldGetContents: descriptor --
(# 
   result: @integer;
   cstr: ^cString; localCstr: @cString;
   length: @integer; 
   t: ^text;
   windowID: @integer;
do assertOpen;
   interfaceObjectID -> windowID;
   (windowID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
   length+1 -> localCstr.init;
   (windowID,WM_GETTEXT, length+1, localCstr.charPtr) -> sendMessage 
      -> result;
   (if (result<>length) then
       'TextField.getContents: Did not copy all text!' -> screen.putLine;
   if);
   localCstr.fromLocal -> cstr[];
   &styledText[] -> theText[];
   cstr.get -> t[];  t -> theText;
   theText.T.range -> theText.pos -> theText.lgth;
   localCstr.free; cstr.free;
#)

-- GUIENVtextFieldGetChar: descriptor --
(# t: ^text;
do assertOpen;
   (if pos>-1 then
       (pos, pos+1) -> TextEditGetRange -> t[];
       (if t.length > 0 then
           t.reset; t.get -> ch;
       if);
   if);
#)

-- GUIENVtextFieldLength: descriptor --
(# 
   windowId: @integer;
   totalNoOfLines: @integer;
do assertOpen;
   interfaceObjectID -> windowId;
   (windowId,WM_GETTEXTLENGTH,0,0) -> SendMessage -> value;
   (windowId,EM_GETLINECOUNT,0,0)-> sendMessage -> totalNoOfLines;
   value - totalNoOfLines+1 -> value;
#)

-- GUIENVtextFieldScanText: descriptor --
(# theText: ^text;
do assertOpen;
   cursors.watch[] -> mouse.busyCursor;
   (0,start,length) -> minMax -> start;
   (0,end,length) -> minMax -> end;
   (if (start<>end) then       
       (if (start<end) then
           (start,end) -> TextEditGetRange -> theText[];
        else
           (end,start) -> TextEditGetRange -> theText[];
       if);
       
       theText.scanAll(# do ch -> this(scanText).ch; inner scanText; #);
   if);
   NONE -> mouse.busyCursor;
#)

-- GUIENVtextFieldPosToPt: descriptor --
(# windowId: @integer;
   thePointPtr: @integer;
do assertOpen;
   interfaceObjectId -> windowId;
   pos -> private.translateToLocal -> pos;
   8 -> malloc -> thePointPtr;
   (if thePointPtr<>0 then
       (windowId,EM_POSFROMCHAR,thePointPtr,pos) -> SendMessage;
       thePointPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
       pt.v + charHeight -> pt.v;
       thePointPtr -> free;
   if);
#)

-- GUIENVtextFieldPtToPos: descriptor --
(# windowId: @integer;
   thePosPtr: @integer;
do assertOpen;
   interfaceObjectId -> windowId;
   pt -> makeNtPointPtr -> thePosPtr;
   (if thePosPtr<>0 then
       (windowId,EM_CHARFROMPOS,0,thePosPtr) -> SendMessage -> pos; 
       pos -> private.translateFromLocal -> pos;
       thePosPtr -> free;
   if);
#)

-- GUIENVtextFieldSelectionStart: descriptor --
(# windowID: @integer;
   theSel: @CHARRANGE;
do interfaceObjectID -> windowID;
   8 -> malloc -> theSel.ptr;
   (if theSel.ptr<>0 then
       (windowID,EM_EXGETSEL,0,theSel.ptr) -> SendMessage;
       theSel.cpMin -> private.translateFromLocal -> value;
       theSel.ptr -> free;
   if);
#)

-- GUIENVtextFieldSelectionEnd: descriptor --
(# windowID: @integer;
   theSel: @CHARRANGE;
do interfaceObjectID -> windowID;
   8 -> malloc -> theSel.ptr;
   (if theSel.ptr<>0 then
       (windowID,EM_EXGETSEL,0,theSel.ptr) -> SendMessage;
       theSel.cpMax -> private.translateFromLocal -> value;
       theSel.ptr -> free;
   if);
#)

-- GUIENVtextFieldSelectionContents: descriptor --
(# theStart, theEnd: @integer;
   localSelCstr: @cString; theSelTxt: ^cString;
   theSel: @CHARRANGE;
   windowID: @integer;
   amount: @integer;
do interfaceObjectID -> windowID;
   &text[] -> theText[];
   8 -> malloc -> theSel.ptr;
   (if theSel.ptr<>0 then
       (windowID,EM_EXGETSEL,0,theSel.ptr) -> SendMessage;
       theSel.cpMax - theSel.cpMin + 1 -> amount;
       
       (if amount > 1 then
           amount -> localSelCstr.init;
           (if localSelCstr<>0 then
               (windowID, EM_GETSELTEXT, 0, localSelCstr) -> SendMessage;
               localSelCstr.fromLocal -> theSelTxt[];
               theSelTxt.get -> theText[];
               
               localSelCstr.free;
               theSelTxt.free;
           if);
       if);
       theSel.ptr -> free;
   if);
#)

-- GUIENVtextFieldSelectionScrollIntoView: descriptor --
(# 
do (* (interfaceObjectID,EM_SCROLLCARET,0,0) -> SendMessage; *)
   scrollIntoView2;
#)

-- GUIENVtextFieldSelectionSet: descriptor --
(# windowID: @integer;
   theSel: @CHARRANGE;
do interfaceObjectID -> windowID;
   (if theStart <> theEnd then
       theStart -> private.translateToLocal -> theStart;
       theEnd -> private.translateToLocal -> theEnd;
    else
       theStart -> private.translateToLocal -> theStart -> theEnd;
   if);
   8 -> malloc -> theSel.ptr;
   (if theSel.ptr<>0 then
       theEnd -> theSel.cpMin;
       theStart -> theSel.cpMax;
       (windowID,EM_EXSETSEL,0,theSel.ptr) -> SendMessage;
       theSel.ptr -> free;
   if);
#)

-- GUIENVtextFieldSetDefaultStyle: descriptor --
(# windowID: @integer;
do (if style[]<>NONE then
       style.create;
       style[] -> textFieldDefaultStyle;
       interfaceObjectID -> windowID;
       (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   if);
#)

-- GUIENVtextFieldGetDefaultStyle: descriptor --
(#
do textFieldDefaultStyle -> style[];
#)

-- GUIENVtextFieldSetMargin: descriptor --
(#
do (leftMargin,topMargin) -> textFieldMargin;
   setTextFieldMargins;
#)

-- GUIENVtextFieldGetMargin: descriptor --
(#
do textFieldMargin -> (leftMargin,topMargin);
#)

-- GUIENVtextFieldInsert: descriptor --
(# cstr: @cString; localCstr: ^cString;
   start, end: @integer;
do theText[] -> cstr.set;
   cstr.toLocal -> localCstr[];
   selection -> (start,end);
   (if (start<>end) then 
       (start,start) -> selection;
   if);
   (interfaceObjectID,EM_REPLACESEL, 0, localCstr.charPtr) 
     -> sendMessage;
   (if (start<>end) then 
       theText.lgth + start -> start;
       theText.lgth + end -> end; 
       (start,end) -> selection;
   if);
   cstr.free; localCstr.free;
#)

-- GUIENVtextFieldDelete: descriptor --
(# 
do (interfaceObjectID,WM_CLEAR, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldCreate: descriptor --
(# libOk: @integer;
   wStyle: @integer;
   LoadLibraryA: external
     (#
        in0: [1] @char; (* LPCSTR *)
        out: @integer; (* HINSTANCE *)
     enter in0
     do callStd;
     exit out
     #);
   
do true -> this(windowItem).private.borderHandledLocally;
   'RICHED32.DLL' -> LoadLibraryA -> libOk;
   (if libOk=0 then
       'RICHED32.DLL -> LoadLibraryA failed. Error= ' -> screen.putText;
       GetLastError -> screen.putint; screen.newline;
    else
       &textFieldNotiMethods[] -> theNotiMethods; (* 060396 /les *)
       isSubClass -> windowItemClassStatus;
       'RichEdit' -> windowItemClass;
       (if private.useScrollbars then
           (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
           (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_AUTOVSCROLL,wStyle) -> tos'%or' -> wStyle;
           (WS_HSCROLL,wStyle) -> tos'%or' -> wStyle;
           (WS_VSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_DISABLENOSCROLL,wStyle) -> tos'%or' -> wStyle; 
           wStyle  -> windowItemStyle;
        else
           (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
           (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_AUTOVSCROLL,wStyle) -> tos'%or' -> wStyle;
           wStyle  -> windowItemStyle;
       if);
       &textfieldMethods[] -> theMethods;
       inner create;
   if);
#)

-- GUIENVtextFieldOpen: descriptor --
(# hdc: @integer; tmPtr: @integer; 
   style: ^textStyle; t: ^text;
   windowID: @integer;
   
   theMask: @integer;
   textLimit: @integer;
do interfaceObjectID -> windowID;
   
   (0xFFFF, 0xFFFF, 0xFFFF) -> backgroundColor;
   
   defaultTextFieldTextStyle -> style[];
   (if style[]=NONE then      
       &textStyle[] -> style[];
       'Arial' -> style.name;
       10 -> style.size;
       style.create;
       
       (* ANSI_FIXED_FONT -> GetStockObject -> style.textStyleID;
        * style[] -> defaultTextFieldTextStyle;
        *)
   if);
   (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   style[] -> textFieldDefaultStyle;
   
   cursors.iBeam[] -> theCursor; 
   
   56 -> malloc -> tmPtr;
   (if tmPtr<>0 then
       windowID -> GetDC -> hdc;
       
       (if ((hdc, tmPtr) -> GetTextMetrics)=0 then
           'TextFieldOpen. GetTextMetrics failed. Error: ' ->  screen.putText;
           GetLastError -> putint; newline;
        else
           tmPtr + textmetricTmAveCharWidthOffset -> TOS'%adrGetLong' -> charWidth;
           tmPtr + textmetricTmHeightOffset -> TOS'%adrGetLong' -> charHeight;
       if);
       (* Clean up *)
       (windowID,hdc) -> ReleaseDC;  
       tmPtr -> free;
   if);
   true -> border.visible;
   borderStyles.shadowIn -> border.style;
   
   &text[] -> t[]; '' -> t;
   (if ( (windowID,t) -> SetWindowText) = 0  then
       'SetWindowText failed in textField.open. Errorcode: ' -> screen.putText;
       GetLastError -> screen.putInt; screen.newline;
   if);
   (windowID,EM_LIMITTEXT,0,0) -> SendMessage;
   (if private.useScrollbars then
       (* We have a textEditor, enable large texts *)
       1024 * 1024 -1 -> textLimit;
       (windowID,EM_EXLIMITTEXT,0,textLimit) -> Sendmessage; 
   if);
   
   (4,4) -> textFieldMargin;
   
   private.makeRichEditI_O;
   (NONE,SF_RTF) -> private.theRichEditI_O.init;
   SCF_SELECTION -> private.formatFlags;
   
   inner open;
   
   (if THIS(interfaceobject).private.isOpen then
       (windowID,EM_SETBKGNDCOLOR,0,(this(windowItem).theBkColorInfo).theColorRef) 
         -> SendMessage;
       (windowID,EM_SETEVENTMASK,0,ENM_MOUSEEVENTS) -> SendMessage -> theMask;
       theMask %Bor ENM_MOUSEEVENTS %Bor ENM_CHANGE %Bor ENM_UPDATE -> theMask;
       (windowID,EM_SETEVENTMASK,0,theMask) -> SendMessage -> theMask;
       
       setTextFieldMargins;
       true -> private.firstFocus;
       private.theActivateAction[] -> AppendAction;
       private.theAboutToCloseAction[] -> AppendAction;
       private.theVisibleChangedAction[] -> AppendAction;
   if);
#)

-- GUIENVtextFieldClose: descriptor --
(# 
do inner close;
   private.theActivateAction[] -> deleteAction; 
   private.theAboutToCloseAction[] -> deleteAction;
   private.theVisibleChangedAction[] -> deleteAction;
   true -> private.closeAction;
#)

-- textFieldLib: attributes --



scrollIntoView2:
  (# iStart,iend, iFirstLine, windowID: @integer;
     theSel: @CHARRANGE;
     theTextStyle: ^textStyle;
     widht,height,noOfLines,halfNoOfLines,delta: @integer;
  do this(textField).interfaceObjectID -> windowID;
     defaultStyle -> theTextStyle[];
     (if theTextStyle[]<>NONE then
         this(textField).size -> (widht,height);
         (if private.useScrollbars then
             height - (SM_CYHSCROLL -> GetSystemMetrics) -> height;
         if);
         height - private.topMargin - 2 -> height;
         height div theTextSTyle.lineHeight -> noOfLines;
         noOfLines div 2 -> halfNoOfLines;
     if);
     
     8 -> malloc -> theSel.ptr;
     (if theSel.ptr<>0 then
         (windowID,EM_EXGETSEL,0,theSel.ptr) -> SendMessage;
         (windowID,EM_EXLINEFROMCHAR,0,theSel.cpMin) -> sendMessage -> iStart;
         (windowID,EM_EXLINEFROMCHAR,0,theSel.cpMax) -> sendMessage -> iEnd;
         (windowID,EM_GETFIRSTVISIBLELINE,0,0) -> sendMessage -> iFirstLine;
         
         (if iStart=iEnd then
             -iFirstLine - halfNoOfLines + iStart - 1 -> delta;             
          else
             -iFirstLine + iStart - 1 -> delta;
             (if iEnd - iStart < noOfLines then
                 delta - ((noOfLines - (iEnd - iStart)) div 2) -> delta;
             if);
         if);
         (windowID,EM_LINESCROLL,0, delta ) ->SendMessage;
         
         theSel.ptr -> free;
     if);
  #);


setTextFieldMargins:
  (# width,height: @integer;
     scrollbarWidth, scrollbarHeight,delta1,delta2: @integer;
  do size -> (width,height);
     (if private.useScrollbars then
         SM_CXVSCROLL -> GetSystemMetrics -> scrollbarWidth;
         SM_CYHSCROLL -> GetSystemMetrics -> scrollbarHeight;
         width - scrollbarWidth -> width;
         height - scrollbarHeight -> height;
     if);
     
     3 -> delta1; 4 -> delta2;
     (private.leftMargin + delta1,private.topMargin + delta1,
     width-delta1,height-delta1,interfaceObjectID) -> setEditRect; 
  #);

setEditRect: external
  (# x,y,width,height,hWnd: @integer;
  enter (x,y,width,height,hWnd)
  do callC;
  #);

printEditRect:
  (# windowID,theRect: @integer;
     r: @rectangle;
  do interfaceObjectId -> windowID;
     16 -> malloc -> theRect;
     (windowID,EM_GETRECT,0,theRect) -> SendMessage;
     theRect -> getRectFromNtRectPtr -> r;
     theRect -> free;
     'The Edit rect for windowid = ' -> screen.putText;
     windowid -> putint; ': ' -> putText;
     
     r -> putRectangle;
     screen.newline;
  #);

handleTextChanged:
  (# 
  do theEventHandler.onTextChanged;
  #);

textFieldDefaultStyle:
  (#
  enter private.textFieldDefaultStyle[]
  exit private.textFieldDefaultStyle[]
  #);
textFieldMargin:
  (#
  enter (private.leftMargin,private.topMargin)
  exit (private.leftMargin,private.topMargin)
  #);
textFieldScroller:
  (#
  enter private.textFieldScroller[]
  exit private.textFieldScroller[]
  #);

TextEditGetRange:
  (# theText: ^text; 
     tr: @TEXTRANGE;
     windowID: @integer;
     cstr: ^cString; localCstr: @cString;
     startInx, endInx: @integer;
  enter (startInx, endInx)
  do 
     &Text[] -> theText[];
     interfaceObjectID -> windowID;
     
     sizeOfTextRange -> malloc -> tr.ptr;
     (if tr.ptr<>0 then
         
         (if startInx <> endInx then
             startInx -> private.translateToLocal -> startInx;
             endInx -> private.translateToLocal -> endInx;
          else
             startInx -> private.translateToLocal -> startInx -> endInx;
         if);
         
         startInx -> tr.cpMin; endInx -> tr.cpMax; 0 -> tr.lpstrText;
         (if startInx < endInx then
             endInx - startInx  + 1 -> localCstr.init;
          else
             startInx - endInx + 1 -> localCstr.init;
         if);
         
         localCstr -> tr.lpstrText;
         
         (windowID, EM_GETTEXTRANGE, 0 , tr.ptr) -> SendMessage;
         localCstr.fromLocal -> cstr[];
         cstr.get -> theText[];
         
         cstr.free;
         localCstr.free;
         tr.ptr -> free;
     if);
     
  exit theText[]
  #);

charWidth:
  (#
  enter private.cxChar
  exit private.cxChar
  #);
charHeight:
  (#
  enter private.cyChar
  exit private.cyChar
  #);  

textFieldNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# processNotify:
            (# code1: @integer;
               message: @integer;
               newWparam: @integer;
               newLparam: @integer;
               longInt: @private.longIntType;
               
               oldInfo: ^messageInfo;
               
            do false -> didSomething;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               (if code1=EN_MSGFILTER then
                   info.lParam+12 -> TOS'%adrGetLong' -> message;
                   (if message
                    //WM_LBUTTONUP then
                       true -> private.notification;
                                           
                       &messageInfo[] -> oldInfo[];
                       info.wParam -> oldInfo.wParam;
                       info.lParam -> oldInfo.lParam;
                       info.message -> oldInfo.message;
                       info.where -> oldInfo.where;
                       info.time -> oldInfo.time;
                       info.button -> oldInfo.button;
                       
                       info.lParam+16 -> TOS'%adrGetLong' -> newWparam;
                       info.lParam+20 -> TOS'%adrGetLong' -> newLparam;
                       newWparam -> longInt;
                       longInt.hiWord -> info.wParam.hiWord;
                       longInt.loWord -> info.wParam.loWord;
                       newWparam -> info.wParam;
                       newLparam -> longInt;
                       longInt.hiWord -> info.lParam.hiWord;
                       longInt.loWord -> info.lParam.loWord;
                       newLparam -> info.lParam;
                       message -> info.message;
                       GetMessagePos -> longInt;
                       (longInt.loWord,longInt.hiWord) -> info.where;
                       getMessageTime -> info.time;
                       1 -> info.button;
                       FALSE -> info.callback;
                       
                       theEventHandler.onMouseUp;
                       
                       oldInfo.wParam -> info.wParam;
                       oldInfo.lParam -> info.lParam;
                       oldInfo.message -> info.message;
                       oldInfo.where -> info.where;
                       oldInfo.time -> info.time;
                       oldInfo.button -> info.button;
                       false -> private.notification;
                       
                       true -> didSomething;
                       (* 1 -> info.result; *)
                   if);
               if);
            #);
          
          didSomething: @boolean;
       do (if info.message
           //WM_NOTIFY then processNotify;
           //WM_COMMAND then
              (if info.wParam.hiWord=EN_CHANGE then
                  handleTextChanged;
                  true -> didSomething;
              if);
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

textFieldMethods: windowItemMethods
  (#      
     dispatchMessage::
       (# didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer; length: @integer;
          p: @point; pos: @integer;
          ch: @char;
          theSel: @CHARRANGE;
          thePosPtr: @integer;
       do true -> didSomething;
          (if info.message 
              
           //WM_KEYDOWN then
              info.wParam -> ch;
              (if ch
               //'V' then 
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,WM_PASTE, 0, 0) -> sendMessage;
                  if);
               //'X' then
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,WM_CUT, 0, 0) -> sendMessage;
                  if);
               //'Z' then
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,EM_UNDO, 0, 0) -> sendMessage;
                  if);
               else
                  false -> didSomething;
              if);
              
           //WM_LBUTTONDOWN  then
              (if not private.allowDragDrop then
                  selection -> (start,end);
                  (if start<>end then
                      (if (not (VK_SHIFT -> isVKeyDown)) then
                          (if (not (VK_CONTROL -> isVKeyDown)) then
                              (info.lParam.loWord,info.lParam.hiWord) -> p;
                              
                              p -> makeNtPointPtr -> thePosPtr;
                              (if thePosPtr<>0 then
                                  (interfaceobjectid,EM_CHARFROMPOS,0,thePosPtr) -> SendMessage -> pos; 
                                  
                                  8 -> malloc -> theSel.ptr;
                                  (if theSel.ptr<>0 then
                                      pos -> theSel.cpMin;
                                      pos -> theSel.cpMax;
                                      (interfaceobjectid,EM_EXSETSEL,0,theSel.ptr) 
                                        -> SendMessage;
                                      theSel.ptr -> free;
                                  if);
                                  
                                  thePosPtr -> free;
                              if);
                          if);
                      if);
                  if);
              if);
              
           //WM_PASTE then 
              FALSE -> info.callback;
              clipboard.textContents -> clipboardText[];
              (if clipboardText[]<>NONE then 
                  clipboardText.length -> clipboardLength;
                  selection -> (start,end);
                  end - start -> length;
                  true -> performEdit;
                  none -> this(guienv).private.textfieldChangeText[];
                  (if (clipboardLength<>0) then
                      (if (length<>0) then
                          (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                      if);
                      (if performEdit then
                          clipboardText[] -> this(guienv).private.textfieldChangeText[];
                           
                          (start,clipboardLength) -> theEventHandler.onBeforeChange 
                            -> performEdit;
                          (if performEdit then
                              callDefaultWindowProc;
                              (* handleTextChanged; *)
                          if);
                          none -> clipboardText[];
                          none -> this(guienv).private.textfieldChangeText[];
                      if);
                  if);
              if);
              
           //WM_CUT then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              true -> performEdit;
              
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  
                  (if performEdit then
                      callDefaultWindowProc;
                      (* handleTextChanged; *)
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
              
           //WM_CLEAR then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  (if performEdit then
                      callDefaultWindowProc;
                      (* handleTextChanged; *)
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
              
           //EM_UNDO then
              FALSE -> info.callback;
              (0,0) -> theEventHandler.onBeforeChange -> performEdit;
              (if performEdit then
                  callDefaultWindowProc;
              if);
              
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);


-- GUIENVtextFieldPrivate: descriptor --
(#    
   (* OLE2/COM stuff: begin *)
   
   textOnly,allowDragDrop: @boolean;
   topLevelWindow: ^window;
   theRichEditI_O: ^richEditI_O;
   
   readFromFile:
     (# fileName: ^text;
     enter fileName[]
     <<SLOT richTextFieldReadFromFile: doPart>>
     exit fileName[]
     #);
   
   save:
     (# fileName: ^text;
     <<SLOT richTextFieldSave: doPart>>
     exit fileName[]
     #);
   
   saveAs:
     (# fileName: ^text;
     <<SLOT richTextFieldSaveAs: doPart>>
     exit fileName[]
     #);
   
   print:
     (# <<SLOT richTextFieldPrint: doPart>> #);
   
   selectCharFormat:
     (# theTextColor: @integer;
     do handleFontSelection -> theTextColor; 
     exit theTextColor
     #);
   
   canCut: booleanValue
     (# <<SLOT richTextFieldCancut: doPart>> #);
   
   canCopy: booleanValue
     (# <<SLOT richTextFieldCanCopy: doPart>> #);
   
   canPaste: booleanValue
     (# <<SLOT richTextFieldCanPaste: doPart>> #);
   
   closeAction:
     (# okToClose: @boolean;
     enter okToClose
     do 
     #);
   formatFlags: @integer;
   
   makeRichEditI_O:
     (# do &richEditI_O[] -> theRichEditI_O[]; #);
   
   handleFontSelection:
     (# 
        lf: @LOGFONT2;
        csf: @CHOOSEFONT;
        
        cf: @CHARFORMAT;
        yPerInch: @integer;
        hdc: @integer;
        windowID, topLevelWindowID: @integer;
        
        theTextColor: @integer;
     <<SLOT handleFontSelectionImpl: doPart>>
     exit theTextColor
     #);
   
   (*************************************************
    * *************OLE2/COM stuff: end **************
    * ***********************************************)
   
   theActivateAction: @activateAction
     (# 
     do (if private.firstFocus then
            false -> private.firstFocus;
            setTextFieldMargins;
        if);
     #);
   theAboutToCloseAction: @aboutToCloseAction
     (# 
     do theEvent.okToClose -> closeAction;
     #);
   theVisibleChangedAction: @visibleChangedAction
     (# 
     do setTextFieldMargins;
        true -> update;
     #);
   
   firstFocus: @boolean;
   
   longIntType: cstruct
     (# byteSize:: (# do 4 -> value; #);
        loWord: signedShort(# pos:: (# do 0 -> value; #); #);
        hiWord: signedShort(# pos:: (# do 2 -> value; #); #);
     enter R[1]
     exit  R[1]
     #);
   cxChar, cyChar: @integer;
   textFieldDefaultStyle: ^textStyle; 
   leftMargin, topMargin: @integer;
   textFieldScroller: ^textEditor;
   useScrollbars: @boolean;
   notification: @boolean; 
   
   translateToLocal:
     (# oldPos, newPos: @integer;
        i,curPos,prevPos,noOfChars: @integer;
        doLeave: @boolean;
        id: @integer;
     enter oldPos
     do interfaceobjectID -> id;
        (id,EM_LINEFROMCHAR,oldPos,0)->SendMessage->i;
        L1: (# 
            do curPos -> prevPos;
               (id,EM_LINEINDEX,i,0)->SendMessage->curPos;
               (id,EM_LINELENGTH,curPos,0)->SendMessage->noOfChars;
               (if curPos=-1 then prevPos->curPos; true -> doLeave; if);
               (if ((curPos<=(oldPos+i)) and ((oldPos+i) <= (curPos+noOfChars)))
                   or doLeave
                   then
                   leave L1
                else 
                   i + 1 -> i;
                   restart L1;;
               if);
            #);
        oldPos + i  -> newPos;
     exit newPos
     #);
   
   translateFromLocal:
     (# oldPos, newPos: @integer;
        lineNo: @integer;
        windowId: @integer;
     enter oldPos
     do interfaceobjectID -> windowId;
        (windowId,EM_LINEFROMCHAR,oldPos,0)->SendMessage->lineNo;
        oldPos - LineNo -> newPos;
     exit newPos
     #);
#)

-- GUIENVabstractScrollerScroll: descriptor --
(#
do inner scroll;
#)

-- GUIENVabstractScrollerCreate: descriptor --
(#
do 
   true -> border.visible;
   borderStyles.simple -> border.style;
   
   inner create;
#)

-- GUIENVabstractScrollerOpen: descriptor --
(#
do ((0,0),(200,200)) -> windowItemFrame;
   inner open;
#)

-- GUIENVabstractScrollerClose: descriptor --
(#
do inner close;
#)



-- GUIENVabstractScrollerPrivate: descriptor --
(# 
#)

-- textEditorLib: attributes --

-- GUIENVtextEditorScroll: descriptor --
(# 
do 
#)

-- GUIENVtextEditorCreate: descriptor --
(#
do FALSE -> border.visible;
   inner create;
#)

-- GUIENVtextEditorOpen: descriptor --
(# width, height: @integer;
   theBColor: ^color;
do this(textEditor)[] -> contents.textFieldScroller;
   true -> contents.private.useScrollbars;
   this(textEditor)[] -> contents.open;
   size -> (width,height);
   ((0,0),(width,height)) -> contents.frame;
   true -> contents.bindLeft;
   true -> contents.bindTop;
   true -> contents.bindRight;
   true -> contents.bindBottom;
   
   inner open;
#)

-- GUIENVtextEditorClose: descriptor --
(#
do inner close;
#)

-- GUIENVtextEditorPrivate: descriptor --
(# 
#)

-- GUIENVscrollerScroll: descriptor --
(# flags: @integer;
   h,v: @integer;
   width,height,contentsWidth,contentsHeight,maxHScroll,maxVScroll: @integer;
do contents.position -> (h,v);
   SWP_NOSIZE + SWP_NOZORDER -> flags;
   h + dh -> h;
   v + dv -> v;
   privateViewSize -> (width,height);
   contents.size -> (contentsWidth,contentsHeight);
   
   (if width>contentsWidth then width -> contentsWidth; if);
   (if height>contentsHeight then height -> contentsHeight; if);
   
   contentsHeight - height -> maxVScroll;
   contentsWidth - width -> maxHScroll;
   (-maxHScroll,h,0) -> minMax -> h;
   (-maxVScroll,v,0) -> minMax -> v;
   
   (interfaceObjectID,SB_HORZ,-h,1) -> SetScrollPos;
   (interfaceObjectID,SB_VERT,-v,1) -> SetScrollPos;
   (contents.interfaceObjectID,0,h,v,0,0,flags) -> SetWindowPos;
#)

-- GUIENVscrollerCreate: descriptor --
(# currentStyle: @integer;
do 
   windowitemStyle -> currentStyle;
   currentStyle %Bor WS_HSCROLL %Bor WS_VSCROLL  -> windowItemStyle;
   &scrollerMethods[] -> theMethods;
   inner create;
#)

-- GUIENVscrollerOpen: descriptor --
(# width,height: @integer;
   borderWidth: @integer;
do (if border.visible then
       (if border.style = borderStyles.simple then 1-> borderWidth;
        else 2 -> borderWidth;
       if);
    else 0 -> borderWidth;
    if);
   this(scroller)[] -> private.view.open;
   private.view[] -> contents.open;
   size -> (width,height); 
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth))) -> private.view.frame;
   true -> private.view.bindLeft;
   true -> private.view.bindTop;
   true -> private.view.bindRight;
   true -> private.view.bindBottom;
   
   (* contents.open; *)
   ((0,0),(1000,1000)) -> contents.frame;
   adjustScrollValues;
   private.contentsFrameChangedAction[] -> contents.AppendAction;
   inner open;
   (if border.visible then
       (if border.style = borderStyles.simple then 1-> borderWidth;
        else 2 -> borderWidth;
       if);
    else 0 -> borderWidth;
   if);
   size -> (width,height); 
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth))) -> private.view.frame;
#)

-- GUIENVscrollerClose: descriptor --
(#
do inner close;
#)

-- scrollerLib: attributes --
adjustScrollValues:
  (# contentsWidth,contentsHeight,viewWidth,viewHeight,
     newWidth,newHeight: @integer;
     newH,newV: @integer; 
     maxHScroll,maxVScroll: @integer;
  do contents.size -> (contentsWidth,contentsHeight);
     privateViewSize -> (viewWidth,viewHeight);
     (if viewWidth>contentsWidth then viewWidth -> contentsWidth; if);
     (if viewHeight>contentsHeight then viewHeight -> contentsHeight; if);
     
     (interfaceObjectID,SB_HORZ, 0, contentsWidth - viewWidth, 0) 
       -> SetScrollRange;
     
     (interfaceObjectID,SB_VERT,0,contentsHeight - viewHeight, 0)
       -> SetScrollRange;
     
     (* Adjust the thumb positions *)
     contents.position -> (newH,newV);
     contentsHeight - viewHeight -> maxVScroll;
     contentsWidth - viewWidth -> maxHScroll;
     (-maxHScroll,newH,0) -> minMax -> newH;
     (-maxVScroll,newV,0) -> minMax -> newV;
     
     (interfaceObjectID,SB_HORZ,-newH,1) -> SetScrollPos;
     (interfaceObjectID,SB_VERT,-newV,1) -> SetScrollPos;
     (contents.interfaceObjectID,0,newH,newV,0,0,SWP_NOSIZE + SWP_NOZORDER) 
       -> SetWindowPos;
  #);

scrollTo:
  (# h,v: @integer;
     pos: @point;
  enter (h,v)
  do contents.position -> pos;
     (h - pos.h,v - pos.v) -> scroll;
  #);
privateViewSize:
  (# scrollbarWidth: @integer;
     scrollbarHeight: @integer;
     width,height: @integer;
  do size -> (width,height);
     SM_CXVSCROLL -> GetSystemMetrics -> scrollbarWidth;
     SM_CYHSCROLL -> GetSystemMetrics -> scrollbarHeight;
     width - scrollbarWidth -> width;
     height - scrollbarHeight -> height;
  exit (width,height)
  #);
scrollerMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     contentsWidth,contentsHeight,viewWidth,viewHeight: @integer;
     dispatchMessage::<
       (# 
          processScroll:
            (# amount: @integer;
               absolute: @boolean;
               width,height: @integer;
               orientation: @integer;
            enter orientation
            do privateViewSize -> (width,height);
               (if info.wParam.loWord
                //SB_LINELEFT
                //SB_LINEUP then
                   16 -> amount;
                //SB_LINERIGHT
                //SB_LINEDOWN then
                   -16  -> amount;
                //SB_PAGELEFT
                //SB_PAGEUP then
                   (if orientation=vertical then
                       height -> amount;
                    else
                       width -> amount;
                   if);
                //SB_PAGERIGHT
                //SB_PAGEDOWN then
                   (if orientation=vertical then
                       -height -> amount
                    else
                       - width -> amount;
                   if);
                //SB_THUMBPOSITION then
                   - info.wParam.hiWord -> amount;
                   true -> absolute;
               if);
               (if orientation=vertical then
                   (if absolute then
                       (0,amount) -> scrollTo;
                    else
                       (0,amount) -> scroll;
                   if);
                else
                   (if absolute then
                       (amount,0) -> scrollTo;
                    else
                       (amount,0) -> scroll;
                   if);
               if);
            #);
          
       do 
          (if info.message
           //WM_HSCROLL then horizontal -> processScroll; 
           //WM_VSCROLL then vertical -> processScroll; 
          if);
       #);
  #);

-- GUIENVscrollerPrivate: descriptor --
(# view: @canvas; 
   contentsFrameChangedAction: @contents.frameChangedAction
     (# 
     do adjustScrollValues;
     #);
#)

-- GUIENVScrollerOnFrameChanged: descriptor --
(#
do adjustScrollValues;
   inner onFrameChanged;
#)

