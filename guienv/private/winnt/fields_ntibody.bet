ORIGIN '../fieldsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)

INCLUDE '../../guienvactions';
INCLUDE 'guienv_ntiprivate';
INCLUDE 'guienvattributes';
INCLUDE '~beta/win32lib/v1.2/scrollbarsupport';
INCLUDE '~beta/win32lib/v1.2/systemmetrics';
INCLUDE '~beta/win32lib/v1.2/dialogcontrolmanagement';
INCLUDE '~beta/win32lib/v1.2/wingdi';
INCLUDE '~beta/win32lib/v1.2/gdistructs';
INCLUDE '~beta/win32lib/v1.2/windowsmisc';
INCLUDE '~beta/win32lib/v1.2/winuserconsts';
INCLUDE '~beta/win32lib/v1.2/memorymanagement';
INCLUDE '~beta/win32lib/v1.2/errorhandling';
INCLUDE '~beta/win32lib/v1.2/clipboardmanager';
INCLUDE '~beta/sysutils/v1.5/cstring';
(* INCLUDE '~beta/basiclib/v1.5/math'; *)
(* INCLUDE '~beta/basiclib/v1.5/numberio'; *)

-- lib: attributes --
minMax:
  (# minimum,value,maximum: @integer;
  enter (minimum,value,maximum)
  do ((minimum,value) -> Max,maximum) -> Min -> value;
  exit value
  #);

-- GUIENVmovieFieldSetContents: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldGetContents: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldSetScaleToFit: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldGetScaleToFit: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldCreate: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldOpen: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldClose: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVmovieFieldPrivate: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldBeforeChangeTheText: doPart --
do (if length>0 then this(guienv).private.textfieldChangeText[]->value[]; if);
   
-- GUIENVtextFieldonFrameChanged: descriptor --
(# 
do inner onFrameChanged;
   setTextFieldMargins;
#)

-- GUIENVtextFieldonKeyDown: descriptor --
(# start,end,length: @integer;
   performEdit: @boolean;
   info: ^messageInfo;
do (if not (VK_CONTROL -> isVKeyDown) then
       inner onKeyDown;
       currentMessageInfo -> info[];
       FALSE -> info.callback;
       (if this(textField).isOpen then
           selection -> (start,end);
           end - start -> length;
           true -> performEdit;
           (if (length<>0) then
               (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
           if);
           none -> this(guienv).private.textfieldChangeText[];
           (if performEdit then
               (if ch
                //ascii.bs then
                   (start-1,-1) -> theEventHandler.onBeforeChange -> performEdit;
                //ascii.del then
                   (start,-1) -> theEventHandler.onBeforeChange -> performEdit;
                //ascii.cr
                //ascii.nl then
                   &text[] -> this(guienv).private.textfieldChangeText[];
                   ch -> this(guienv).private.textfieldChangeText.put;
                   (start,1) -> theEventHandler.onBeforeChange -> performEdit;
                else
                   &text[] -> this(guienv).private.textfieldChangeText[];
                   ch -> this(guienv).private.textfieldChangeText.put;
                   (start,1) -> theEventHandler.onBeforeChange -> performEdit;
               if);
               (if performEdit then
                   callDefaultWindowProc;
                   handleTextChanged;
               if);
           if);
           none -> this(guienv).private.textfieldChangeText[];
       if);
   if);
#)

-- GUIENVtextFieldonMouseDown: descriptor --
(#
do (* this(textField)[] -> target; *)
   inner onMouseDown;
#)

-- GUIENVtextFieldonMouseUp: descriptor --
(#
do (if private.notification then (* 060396 /les *)
       inner onMouseUp; 
   if);
#)

-- GUIENVtextFieldonRefresh: descriptor --
(# 
do inner onReFresh;
#)

-- GUIENVtextFieldOnEnableTarget: descriptor --
(#
do inner onEnableTarget;
#)

-- GUIENVtextFieldOnDisableTarget: descriptor --
(#
do inner onDisableTarget;
#)

-- GUIENVtextFieldonIdle: descriptor --
(#
do INNER onIdle;
   'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldDoPaste: descriptor --
(# result: @integer;
do (interfaceObjectID,WM_PASTE, 0, 0) -> sendMessage -> result;
#)

-- GUIENVtextFieldDoCopy: descriptor --
(# 
do (interfaceObjectID,WM_COPY, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldDoCut: descriptor --
(# 
do (interfaceObjectID,WM_CUT, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldDoClear: descriptor --
(# 
do (interfaceObjectID,WM_CLEAR, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldSetContents: descriptor --
assertOpen
(# location::(# do 'TextField.SetContents'->t[] #);
   result: @integer;
   cstr: @cString; localCstr: ^cString;
   theTextStyle: ^textStyle;
do textFieldDefaultStyle -> theTextStyle[];
   setTextFieldMargins;
   theText[] -> cstr.set;
   cstr.toLocal -> localCstr[];
   (interfaceObjectID,WM_SETTEXT, 0, localCstr.charPtr)->sendMessage->result;
   (result,'textFieldSetContents') -> checkSetTextError;
   cstr.free; localCstr.free;
#)

-- GUIENVtextFieldGetContents: descriptor --
assertOpen
(# location::(# do 'TextField.GetContents'->t[] #);
   result: @integer;
   cstr: ^cString; localCstr: @cString;
   length: @integer; 
   t: ^text;
   windowID: @integer;
do interfaceObjectID -> windowID;
   (windowID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
   length+1 -> localCstr.init;
   (windowID,WM_GETTEXT, length+1, localCstr.charPtr) -> sendMessage 
      -> result;
   (if (result<>length) then
       'TextField.getContents: Did not copy all text!' -> screen.putLine;
   if);
   localCstr.fromLocal -> cstr[];
   &styledText[] -> theText[];
   cstr.get -> t[];  t -> theText;
   theText.T.range -> theText.pos -> theText.lgth;
   localCstr.free; cstr.free;
#)

-- GUIENVtextFieldGetChar: descriptor --
assertOpen
(# location::(# do 'TextField.GetChar'->t[] #); 
do pos -> TextEditGetChar -> ch;
#)

-- GUIENVtextFieldLength: descriptor --
assertOpen
(# location::(# do 'TextField.Length'->t[] #);
   windowId: @integer;
   totalNoOfLines: @integer;
do interfaceObjectID -> windowId;
   (windowId,WM_GETTEXTLENGTH,0,0) -> SendMessage -> value;
   (windowId,EM_GETLINECOUNT,0,0)-> sendMessage -> totalNoOfLines;
   value - totalNoOfLines+1 -> value;
#)

-- GUIENVtextFieldScanText: descriptor --
assertOpen
(# location::(# do 'TextField.ScanText'->t[] #);
   theText: ^text;
do cursors.watch[] -> mouse.busyCursor;
   (0,start,length) -> minMax -> start;
   (0,end,length) -> minMax -> end;
   (if (start<>end) then       
       (if (start<end) then
           (start,end) -> TextEditGetRange -> theText[];
        else
           (end,start) -> TextEditGetRange -> theText[];
       if);
       
       theText.scanAll(# do ch -> this(scanText).ch; inner scanText; #);
   if);
   NONE -> mouse.busyCursor;
#)

-- GUIENVtextFieldPosToPt: descriptor --
assertOpen
(# location::(# do 'TextField.PosToPt'->t[] #);   
   windowId: @integer;
   thePointPtr: @integer;
   EM_POSFROMCHAR: (# exit 16x00D6 #);
   
do interfaceObjectId -> windowId;
   pos -> private.translateToLocal -> pos;
   8 -> malloc -> thePointPtr;
   (windowId,EM_POSFROMCHAR,thePointPtr,pos) -> SendMessage;
   thePointPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
   pt.v + charHeight -> pt.v;
   thePointPtr -> free;
#)

-- GUIENVtextFieldPtToPos: descriptor --
assertOpen
(# location::(# do 'TextField.PtToPos'->t[] #);
   windowId: @integer;
   thePosPtr: @integer;
   EM_CHARFROMPOS: (# exit 16x00D7 #);
   
do interfaceObjectId -> windowId;
   pt -> makeNtPointPtr -> thePosPtr;
   (windowId,EM_CHARFROMPOS,0,thePosPtr) -> SendMessage -> pos; 
   pos -> private.translateToLocal -> pos;
   thePosPtr -> free;
#)

-- GUIENVtextFieldSelectionStart: descriptor --
(# id: @integer;
   translate:
     (# oldPos, newPos: @integer;
        lineNo: @integer;
     enter oldPos
     do (id,EM_LINEFROMCHAR,oldPos,0)->SendMessage->lineNo;
        oldPos - LineNo -> newPos;
     exit newPos
     #);
   h,v: @integer;
do interfaceObjectID -> id;
   (id,EM_GETSEL,@@h,@@v) -> SendMessage;
   h -> translate -> value;
#)

-- GUIENVtextFieldSelectionEnd: descriptor --
(# id: @integer;
   translate:
     (# oldPos, newPos: @integer;
        lineNo: @integer;
     enter oldPos
     do (id,EM_LINEFROMCHAR,oldPos,0)->SendMessage->lineNo;
        oldPos - LineNo -> newPos;
     exit newPos
     #);
   h,v: @integer;
do interfaceObjectID -> id;
   (id,EM_GETSEL,@@h,@@v) -> SendMessage;
   v -> translate -> value;
#)

-- GUIENVtextFieldSelectionContents: descriptor --
(# theStart, theEnd: @integer;
do &text[] -> theText[];
   start -> theStart; end -> theEnd;
   (start,end) -> TextEditGetRange -> theText[];
#)

-- GUIENVtextFieldSelectionScrollIntoView: descriptor --
(# result: @integer;
do (interfaceObjectID,EM_SCROLLCARET,0,0) -> SendMessage -> result;
#)

-- GUIENVtextFieldSelectionSet: descriptor --
(# result: @integer;
   id: @integer;
do interfaceObjectID -> id;
   (if theStart <> theEnd then
       theStart -> private.translateToLocal -> theStart;
       theEnd -> private.translateToLocal -> theEnd;
    else
       theStart -> private.translateToLocal -> theStart -> theEnd;
   if);
   (id,EM_SETSEL,theStart,theEnd) -> SendMessage -> result;
#)

-- GUIENVtextFieldSetDefaultStyle: descriptor --
(# windowID: @integer;
do (if style[]<>NONE then
       style.create;
       style[] -> textFieldDefaultStyle;
       interfaceObjectID -> windowID;
       (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   if);
#)

-- GUIENVtextFieldGetDefaultStyle: descriptor --
(#
do textFieldDefaultStyle -> style[];
#)

-- GUIENVtextFieldIsOneStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetOneSize: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetOneFont: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetOneFace: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetOneStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldScanTextWithStyle: descriptor --
(#
do 'Not implemented.' -> screen.putLine;
#)

-- GUIENVtextFieldSetMargin: descriptor --
(#
do (leftMargin,topMargin) -> textFieldMargin;
   setTextFieldMargins;
   
#)

-- GUIENVtextFieldGetMargin: descriptor --
(#
do textFieldMargin -> (leftMargin,topMargin);
#)

-- GUIENVtextFieldInsert: descriptor --
(# result: @integer;
   cstr: @cString; localCstr: ^cString;
   start, end: @integer;
do theText[] -> cstr.set;
   cstr.toLocal -> localCstr[];
   selection -> (start,end);
   (if (start<>end) then 
       (start,start) -> selection;
   if);
   (interfaceObjectID,EM_REPLACESEL, 0, localCstr.charPtr) 
     -> sendMessage -> result;
   (result,'textFieldInsert')-> checkSetTextError;
   (if (start<>end) then 
       theText.lgth + start -> start;
       theText.lgth + end -> end; 
       (start,end) -> selection;
   if);
   cstr.free; localCstr.free;
#)

-- GUIENVtextFieldDelete: descriptor --
(# 
do (interfaceObjectID,WM_CLEAR, 0, 0) -> sendMessage;
#)

-- GUIENVtextFieldCreate: descriptor --
(# libOk: @integer;
   wStyle: @integer;
   LoadLibraryA: external
     (#
        in0: [1] @char; (* LPCSTR *)
        out: @integer; (* HINSTANCE *)
     enter in0
     do callStd;
     exit out
     #);
   ES_DISABLENOSCROLL: (# exit 16x00002000 #); (* 110396 /les *)
do 'RICHED32.DLL' -> LoadLibraryA -> libOk;
   (if libOk=0 then
       'RICHED32.DLL -> LoadLibraryA failed. Error= ' -> screen.putText;
       GetLastError -> screen.putint; screen.newline;
    else
       &textFieldNotiMethods[] -> theNotiMethods; (* 060396 /les *)
       isSubClass -> windowItemClassStatus;
       'RichEdit' -> windowItemClass;
       (if private.useScrollbars then
           (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
           (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_AUTOVSCROLL,wStyle) -> tos'%or' -> wStyle;
           (WS_HSCROLL,wStyle) -> tos'%or' -> wStyle;
           (WS_VSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_DISABLENOSCROLL,wStyle) -> tos'%or' -> wStyle; (* 110396 /les *)
           wStyle  -> windowItemStyle;
        else
           (ES_MULTILINE,ES_LEFT) -> tos'%or' -> wStyle;
           (ES_AUTOHSCROLL,wStyle) -> tos'%or' -> wStyle;
           (ES_AUTOVSCROLL,wStyle) -> tos'%or' -> wStyle;
           wStyle  -> windowItemStyle;
       if);
       &textfieldMethods[] -> theMethods;
       inner create;
   if);
#)

-- GUIENVtextFieldOpen: descriptor --
(# hdc: @integer; tmPtr: @integer; result: @integer; errorcode: @integer;
   style: ^textStyle; t: ^text;
   windowID: @integer;
   
   (* 060396 /les *)
   ENM_MOUSEEVENTS: (# exit 16x00020000 #);
   EM_SETEVENTMASK: (# exit  (WM_USER + 69) #);
   theMask: @integer;
   
do interfaceObjectID -> windowID;
   defaultTextFieldTextStyle -> style[];
   (if style[]=NONE then      
       &textStyle[] -> style[];
       'Arial' -> style.name;
       10 -> style.size;
       style.create;
       style[] -> defaultTextFieldTextStyle;
   if);
   (windowID,WM_SETFONT,style.textStyleID,1) -> SendMessage;
   style[] -> textFieldDefaultStyle;
   
   cursors.iBeam[] -> theCursor; 
   
   windowID -> GetDC -> hdc;
   56 -> malloc -> tmPtr;
   (hdc, tmPtr) -> GetTextMetrics -> result;
   (if result=0 then
       'TextFieldOpen. GetTextMetrics failed. Error: ' ->  screen.putText;
       GetLastError -> putint; newline;
    else
       tmPtr + textmetricTmAveCharWidthOffset -> TOS'%adrGetLong' -> charWidth;
       tmPtr + textmetricTmHeightOffset -> TOS'%adrGetLong' -> charHeight;
   if);
   (* Clean up *)
   (windowID,hdc) -> ReleaseDC;  
   tmPtr -> free;
   true -> border.visible;
   borderStyles.simple -> border.style;
   
   &text[] -> t[]; '' -> t;
   (if ( (windowID,t) -> SetWindowText) = 0  then
       'SetWindowText failed in textField.open. Errorcode: ' -> screen.putText;
       GetLastError -> screen.putInt; screen.newline;
   if);
   (windowID,EM_LIMITTEXT,0,0) -> SendMessage;
   
   inner open;
   
   (* setTextFieldMargins; *)
   
   (* 060396 /les *)
   (windowID,EM_SETEVENTMASK,0,ENM_MOUSEEVENTS) -> SendMessage -> theMask;
   (theMask,ENM_MOUSEEVENTS) -> tos'%or' -> theMask;
   (windowID,EM_SETEVENTMASK,0,theMask) -> SendMessage -> theMask;
   
   (* 110396 /les *)
   true -> private.firstFocus;
   private.theActivateAction[] -> AppendAction;
#)

-- GUIENVtextFieldClose: descriptor --
(# theTextStyle: ^textStyle;
do inner close;
   textFieldDefaultStyle -> theTextStyle[];
   (if theTextStyle[]<>defaultTextFieldTextStyle then
       (if theTextStyle[]<>NONE then
           theTextSTyle.dispose;
       if);
   if);
   private.theActivateAction[] -> deleteAction; (* 110396 /les *)
#)

-- textFieldLib: attributes --
setTextFieldMargins:
  (# width,height: @integer;
     scrollbarWidth, scrollbarHeight: @integer;
  do size -> (width,height);
     (if private.useScrollbars then
         SM_CXVSCROLL -> GetSystemMetrics -> scrollbarWidth;
         SM_CYHSCROLL -> GetSystemMetrics -> scrollbarHeight;
         width - scrollbarWidth -> width;
         height - scrollbarHeight -> height;
     if);
     
     (if border.visible then
         (if border.style=borderStyles.simple then
             (private.leftMargin + 1,private.topMargin + 2,
             width-1,height-1,interfaceObjectID) -> setEditRect; 
          else
             (private.leftMargin + 2,private.topMargin + 2,
             width-2,height-2,interfaceObjectID) -> setEditRect; 
         if);
      else
         (private.leftMargin,private.topMargin,
         width,height,interfaceObjectID) -> setEditRect; 
     if);
  #);
setEditRect: external
  (# x,y,width,height,hWnd: @integer;
  enter (x,y,width,height,hWnd)
  do callC;
  #);
handleTextChanged:
  (# 
  do theEventHandler.onTextChanged;
  #);

textFieldDefaultStyle:
  (#
  enter private.textFieldDefaultStyle[]
  exit private.textFieldDefaultStyle[]
  #);
textFieldMargin:
  (#
  enter (private.leftMargin,private.topMargin)
  exit (private.leftMargin,private.topMargin)
  #);
textFieldScroller:
  (#
  enter private.textFieldScroller[]
  exit private.textFieldScroller[]
  #);

TextEditGetRange:
  (# theText: ^text; tempText: @text;
     result: @integer;
     cstr: ^cString; localCstr: @cString;
     length: @integer; 
     t,t2,t3: ^text;
     startInx, endInx: @integer;
  enter (startInx, endInx)
  do &text[] -> theText[];
     (interfaceObjectID,WM_GETTEXTLENGTH,0,0) -> sendMessage -> length;
     length+1 -> localCstr.init;
     (interfaceObjectID,WM_GETTEXT, length+1, localCstr.charPtr) 
       -> sendMessage -> result;
     (if (result<>length) then
         'TextField.TextEditGetRange: Did not copy all text!'-> screen.putLine;
     if);
     localCstr.fromLocal -> cstr[];
     localCstr.free;
     
     cstr.get -> t[];
     cstr.free;
     
     t.T.range -> t.pos -> t.lgth;     
     (startInx+1,endInx) -> t.sub -> t[];
     
     &styledText[] -> theText[];
     t -> theText;
     
     theText.T.range -> theText.pos -> theText.lgth;
  exit theText[]
  #);
TextEditGetChar:
  (# inx: @integer;
     ch: @integer;
     theLineNo,lineNo1,lineNo2: @integer;
     cstr: @cString;
     length, lineInx, result: @integer; 
     t: @text;
     textLength: @integer;
  enter inx
  do (if inx<0 then
      else
         (interfaceObjectId,EM_LINEFROMCHAR,inx,0) -> sendMessage -> theLineNo;
         (interfaceObjectId,EM_LINEFROMCHAR,inx+1,0) -> sendMessage -> lineNo2;
         
         (if lineNo2>theLineNo then
             ascii.nl -> ch;
          else
             
             (interfaceObjectId,EM_LINEINDEX,theLineNo,0) 
               -> sendMessage -> lineInx;
             (interfaceObjectID,EM_LINELENGTH,lineInx,0) 
               -> sendMessage -> length;
             
             (if length=0 then ascii.nl -> ch;
              else
                 length+1 -> cstr.init;
                 (interfaceObjectID,EM_GETLINE,theLineNo,cstr.charPtr) 
                   -> sendMessage -> result;
                 (if result=0 then
                     '**WARNING: Bad line number in TextEditGetChar.'->putline;
                 if);
                 
                 inx - lineInx -> cstr.inxGet -> ch;
                 cstr.free;
             if);
         if);
     if);
  exit ch
  #);
charWidth:
  (#
  enter private.cxChar
  exit private.cxChar
  #);  
charHeight:
  (#
  enter private.cyChar
  exit private.cyChar
  #);  

(* 060396 /les *)
EN_MSGFILTER: (# exit 16x0700 #);

textFieldNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# processNotify:
            (# code1: @integer;
               message: @integer;
               newWparam: @integer;
               newLparam: @integer;
               longInt: @CStruct
                 (#	ByteSize:: (# do 4 -> Value; #);
                    loWord: signedShort (# Pos:: (# do 0 -> Value; #); #);
                    hiWord: signedShort (# Pos:: (# do 2 -> Value; #); #);
                 enter R[1]
                 exit R[1]
                 #);
               
               oldInfo: ^messageInfo;
               
            do false -> didSomething;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               (if code1
                //EN_MSGFILTER then
                   info.lParam+12 -> TOS'%adrGetLong' -> message;
                   (if message
                    //WM_LBUTTONUP  then
                       true -> private.notification;
                       
                       
                       
                       &messageInfo[] -> oldInfo[];
                       info.wParam -> oldInfo.wParam;
                       info.lParam -> oldInfo.lParam;
                       info.message -> oldInfo.message;
                       info.where -> oldInfo.where;
                       info.time -> oldInfo.time;
                       
                       info.lParam+16 -> TOS'%adrGetLong' -> newWparam;
                       info.lParam+20 -> TOS'%adrGetLong' -> newLparam;
                       newWparam -> longInt;
                       longInt.hiWord -> info.wParam.hiWord;
                       longInt.loWord -> info.wParam.loWord;
                       newWparam -> info.wParam;
                       newLparam -> longInt;
                       longInt.hiWord -> info.lParam.hiWord;
                       longInt.loWord -> info.lParam.loWord;
                       newLparam -> info.lParam;
                       message -> info.message;
                       GetMessagePos -> longInt;
                       (longInt.loWord,longInt.hiWord) -> info.where;
                       getMessageTime -> info.time;
                       1 -> info.button;
                       
                       FALSE -> info.callback;
                       
                       
                       theEventHandler.onMouseUp;
                       
                       oldInfo.wParam -> info.wParam;
                       oldInfo.lParam -> info.lParam;
                       oldInfo.message -> info.message;
                       oldInfo.where -> info.where;
                       oldInfo.time -> info.time;
                       false -> private.notification;
                       
                       true -> didSomething;
                       (* 1 -> info.result; *)
                   if);
               if);
            #);
          
          didSomething: @boolean;
       do (if info.message=WM_NOTIFY then processNotify;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);
(* 060396 /les end *)

textFieldMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     
     dispatchMessage::
       (# didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer; length: @integer;
          
          processScroll:
            (# amount: @integer;
               absolute: @boolean;
               width,height: @integer;
               orientation: @integer;
            enter orientation
            do size -> (width,height);
               (if info.wParam.loWord
                //SB_LINELEFT
                //SB_LINEUP then
                   7 -> amount;
                //SB_LINERIGHT
                //SB_LINEDOWN then
                   -7  -> amount;
                //SB_PAGELEFT
                //SB_PAGEUP then
                  width -> amount;
                //SB_PAGERIGHT
                //SB_PAGEDOWN then
                   - width -> amount;
                //SB_THUMBPOSITION then
                   - info.wParam.hiWord -> amount;
                   true -> absolute;
               if);
               (if orientation=horizontal then
                   (if (((interfaceObjectID, SB_HORZ)->GetScrollPos)<97) then
                       
                       (if absolute then
                           amount -> private.horizontalOffset;
                        else
                           private.horizontalOffset + amount 
                             -> private.horizontalOffset;
                           (if private.horizontalOffset>0 then
                               0 -> private.horizontalOffset;
                           if);
                       if);
                   if);
               if);
            #);
          
       do true -> didSomething;
          (if info.message 
           //WM_HSCROLL then horizontal -> processScroll; 
           //WM_VSCROLL then vertical -> processScroll; 
           //WM_PASTE then 
              FALSE -> info.callback;
              clipboard.textContents -> clipboardText[];
              (if clipboardText[]<>NONE then 
                  clipboardText.length -> clipboardLength;
                  selection -> (start,end);
                  end - start -> length;
                  true -> performEdit;
                  none -> this(guienv).private.textfieldChangeText[];
                  (if (clipboardLength<>0) then
                      (if (length<>0) then
                          (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                      if);
                      (if performEdit then
                          clipboardText[] -> this(guienv).private.textfieldChangeText[];
                          
                          (start,clipboardLength) -> theEventHandler.onBeforeChange 
                            -> performEdit;
                          (if performEdit then
                              callDefaultWindowProc;
                              handleTextChanged;
                          if);
                          none -> clipboardText[];
                          none -> this(guienv).private.textfieldChangeText[];
                      if);
                  if);
              if);
              
           //WM_CUT then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              true -> performEdit;
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  (if performEdit then
                      callDefaultWindowProc;
                      handleTextChanged;
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
           //WM_CLEAR then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  (if performEdit then
                      callDefaultWindowProc;
                      handleTextChanged;
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);


-- GUIENVtextFieldPrivate: descriptor --
(# (* 110396 /les *)
   theActivateAction: @activateAction
     (# 
     do (if private.firstFocus then
            false -> private.firstFocus;
            setTextFieldMargins;
        if);
     #);
   firstFocus: @boolean;
   
   longInt: cstruct
     (# byteSize:: (# do 4 -> value; #);
        loWord: short(# pos:: (# do 0 -> value; #); #);
        hiWord: short(# pos:: (# do 2 -> value; #); #);
     enter R[1]
     exit  R[1]
     #);
   cxChar, cyChar: @integer;
   textFieldDefaultStyle: ^textStyle; 
   leftMargin, topMargin: @integer;
   textFieldScroller: ^textEditor;
   horizontalOffset: @integer;
   useScrollbars: @boolean;
   notification: @boolean; (* 060396 /les *)
   
   translateToLocal:
     (# oldPos, newPos: @integer;
        i,curPos,prevPos,noOfChars: @integer;
        doLeave: @boolean;
        id: @integer;
     enter oldPos
     do interfaceobjectID -> id;
        (id,EM_LINEFROMCHAR,oldPos,0)->SendMessage->i;
        L1: (# 
            do curPos -> prevPos;
               (id,EM_LINEINDEX,i,0)->SendMessage->curPos;
               (id,EM_LINELENGTH,curPos,0)->SendMessage->noOfChars;
               (if curPos=-1 then prevPos->curPos; true -> doLeave; if);
               (if ((curPos<=(oldPos+i)) and ((oldPos+i) <= (curPos+noOfChars)))
                   or doLeave
                   then
                   leave L1
                else 
                   i + 1 -> i;
                   restart L1;;
               if);
            #);
        oldPos + i  -> newPos;
     exit newPos
     #);
#)

-- GUIENVabstractScrollerScroll: descriptor --
(#
do inner scroll;
#)

-- GUIENVabstractScrollerCreate: descriptor --
(#
do (* WS_BORDER  -> windowitemStyle; *)
   true -> border.visible;
   borderStyles.simple -> border.style;
   
   inner create;
#)

-- GUIENVabstractScrollerOpen: descriptor --
(#
do ((0,0),(200,200)) -> windowItemFrame;
   true -> updateOnResize;
   inner open;
#)

-- GUIENVabstractScrollerClose: descriptor --
(#
do inner close;
#)



-- GUIENVabstractScrollerPrivate: descriptor --
(# 
#)

-- textEditorLib: attributes --

textEditorMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     
     EM_GETLIMITTEXT: (# exit  16x00D5 #);
     
     dispatchMessage::
       (# didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer; length: @integer;
          type,id: @integer;
       do 
          (if info.message=WM_COMMAND then
              info.wParam.hiWord -> type;
              info.wParam.loWord -> id;
              (if type=EN_MAXTEXT then
                  (* true -> didSomething; *)
              if);
           else
              false -> didSomething;
          if);
       #);
  #);

-- GUIENVtextEditorScroll: descriptor --
(# 
do 
#)

-- GUIENVtextEditorCreate: descriptor --
(#
do FALSE -> border.visible;
   &texteditorMethods[] -> theMethods;
   inner create;
#)

-- GUIENVtextEditorOpen: descriptor --
(# width,height: @integer; 
   t: ^text;
do this(textEditor)[] -> contents.textFieldScroller;
   true -> contents.private.useScrollbars;
   this(textEditor)[] -> contents.open;
   size -> (width,height);
   ((0,0),(width,height)) -> contents.frame;
   true -> contents.bindLeft;
   true -> contents.bindTop;
   true -> contents.bindRight;
   true -> contents.bindBottom;
   inner open;
#)

-- GUIENVtextEditorClose: descriptor --
(#
do inner close;
#)

-- GUIENVtextEditorPrivate: descriptor --
(# 
#)

-- GUIENVscrollerScroll: descriptor --
(# flags: @integer;
   h,v: @integer;
   width,height,contentsWidth,contentsHeight,maxHScroll,maxVScroll: @integer;
   result: @integer;
do contents.position -> (h,v);
   SWP_NOSIZE + SWP_NOZORDER -> flags;
   h + dh -> h;
   v + dv -> v;
   privateViewSize -> (width,height);
   contents.size -> (contentsWidth,contentsHeight);
   
   (if width>contentsWidth then width -> contentsWidth; if);
   (if height>contentsHeight then height -> contentsHeight; if);
   
   contentsHeight - height -> maxVScroll;
   contentsWidth - width -> maxHScroll;
   (-maxHScroll,h,0) -> minMax -> h;
   (-maxVScroll,v,0) -> minMax -> v;
   
   (interfaceObjectID,SB_HORZ,-h,1) -> SetScrollPos;
   (interfaceObjectID,SB_VERT,-v,1) -> SetScrollPos;
   (contents.interfaceObjectID,0,h,v,0,0,flags) -> SetWindowPos -> result;
   (result,'scrollerScroll') -> checkNullError;
#)

-- GUIENVscrollerCreate: descriptor --
(# currentStyle, style: @integer;
do WS_HSCROLL + WS_VSCROLL -> style;
   windowitemStyle -> currentStyle;
   (currentStyle,style) -> tos'%or' -> windowItemStyle;
   &scrollerMethods[] -> theMethods;
   inner create;
#)

-- GUIENVscrollerOpen: descriptor --
(# width,height: @integer;
   borderWidth: @integer;
do (if border.visible then
       (if border.style = borderStyles.simple then 1-> borderWidth;
        else 2 -> borderWidth;
       if);
    else 0 -> borderWidth;
    if);
   this(scroller)[] -> private.view.open;
   private.view[] -> contents.open;
   size -> (width,height); 
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth))) -> private.view.frame;
   true -> private.view.bindLeft;
   true -> private.view.bindTop;
   true -> private.view.bindRight;
   true -> private.view.bindBottom;
   
   (* contents.open; *)
   ((0,0),(1000,1000)) -> contents.frame;
   adjustScrollValues;
   private.contentsFrameChangedAction[] -> contents.AppendAction;
   inner open;
   (if border.visible then
       (if border.style = borderStyles.simple then 1-> borderWidth;
        else 2 -> borderWidth;
       if);
    else 0 -> borderWidth;
   if);
   size -> (width,height); 
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth))) -> private.view.frame;
#)

-- GUIENVscrollerClose: descriptor --
(#
do inner close;
#)

-- scrollerLib: attributes --
adjustScrollValues:
  (# contentsWidth,contentsHeight,viewWidth,viewHeight,
     newWidth,newHeight: @integer;
     newH,newV: @integer; 
     maxHScroll,maxVScroll: @integer;
     result: @integer; 
  do contents.size -> (contentsWidth,contentsHeight);
     privateViewSize -> (viewWidth,viewHeight);
     (if viewWidth>contentsWidth then viewWidth -> contentsWidth; if);
     (if viewHeight>contentsHeight then viewHeight -> contentsHeight; if);
     
     (interfaceObjectID,SB_HORZ, 0, contentsWidth - viewWidth, 0) 
       -> SetScrollRange -> result;
     (result,'scrollerLib.adjustScrollValues(1)') -> checkNullError;

     (interfaceObjectID,SB_VERT,0,contentsHeight - viewHeight, 0)
       -> SetScrollRange -> result;
     (result,'scrollerLib.adjustScrollValues(2)') -> checkNullError;
     
     
     (* Adjust the thumb positions *)
     contents.position -> (newH,newV);
     contentsHeight - viewHeight -> maxVScroll;
     contentsWidth - viewWidth -> maxHScroll;
     (-maxHScroll,newH,0) -> minMax -> newH;
     (-maxVScroll,newV,0) -> minMax -> newV;
     
     (interfaceObjectID,SB_HORZ,-newH,1) -> SetScrollPos;
     (interfaceObjectID,SB_VERT,-newV,1) -> SetScrollPos;
     (contents.interfaceObjectID,0,newH,newV,0,0,SWP_NOSIZE + SWP_NOZORDER) 
       -> SetWindowPos -> result;
     
		
     (* contents.position -> (h,v);  
      *      
      *      
      *      'H, V(0)= ' -> puttext; (H,V) -> putPoint; newline; 
      *      'width, height(0)= ' -> puttext; (width,height) -> putPoint; newline; 
      *      'viewWidth, viewHeight(0)= ' -> puttext; (viewWidth,viewHeight) -> putPoint; newline; 
      *      
      *      (width - viewWidth,-h,0) -> MinMax -> h;
      *      (height - viewHeight,-v,0) -> MinMax -> v;
      *      
      *      'H, V(1)= ' -> puttext; (H,V) -> putPoint; newline;
      *      
      *      (h,v) -> setScroll; 
      *)
  #);

(* setScroll:
 *   (# h,v: @integer;
 *      contH,contV: @integer;
 *   enter (h,v)
 *   do contents.position -> (contH,contV);
 *      (if ( (h<>contH) or (v<>contV) ) then
 *          (contH - h,contV -v ) -> tempScroll;
 *      if);
 *   #);
 * 
 * tempScroll:
 *   (# width,height,contentsWidth,contentsHeight,maxHScroll,maxVScroll: @integer;
 *      result: @integer;
 *      contH,contV: @integer; newH, newV, dh, dv: @integer;
 *   enter (dh,dv)
 *   do contents.position -> (contH,contV);
 *      2*contH -> newH;
 *      2*contV -> newV;
 *      
 *      {* 'contH, contV= ' -> puttext; (contH,contV) -> putPoint; newline;
 *      'dH, dV= ' -> puttext; (dH,dV) -> putPoint; newline;
 *       'newH, newV= ' -> puttext; (newH,newV) -> putPoint; newline; *}
 *      
 *      privateViewSize -> (width,height);
 *      contents.size -> (contentsWidth,contentsHeight);
 *      
 *      (if width>contentsWidth then width -> contentsWidth; if);
 *      (if height>contentsHeight then height -> contentsHeight; if);
 *      
 *      contentsHeight - height -> maxVScroll;
 *      contentsWidth - width -> maxHScroll;
 *      (-maxHScroll,newH,0) -> minMax -> newH;
 *      (-maxVScroll,newV,0) -> minMax -> newV;
 *      (interfaceObjectID,SB_HORZ,-newH,1) -> SetScrollPos;
 *      (interfaceObjectID,SB_VERT,-newV,1) -> SetScrollPos;
 *   #);
 *)

scrollTo:
  (# h,v: @integer;
     pos: @point;
  enter (h,v)
  do contents.position -> pos;
     (h - pos.h,v - pos.v) -> scroll;
  #);
privateViewSize:
  (# scrollbarWidth: @integer;
     scrollbarHeight: @integer;
     width,height: @integer;
  do size -> (width,height);
     SM_CXVSCROLL -> GetSystemMetrics -> scrollbarWidth;
     SM_CYHSCROLL -> GetSystemMetrics -> scrollbarHeight;
     width - scrollbarWidth -> width;
     height - scrollbarHeight -> height;
  exit (width,height)
  #);
scrollerMethods: windowItemMethods
  (# vertical: (# exit 0 #);
     horizontal: (# exit 1 #);
     contentsWidth,contentsHeight,viewWidth,viewHeight: @integer;
     dispatchMessage::<
       (# 
          processScroll:
            (# amount: @integer;
               absolute: @boolean;
               width,height: @integer;
               orientation: @integer;
            enter orientation
            do privateViewSize -> (width,height);
               (if info.wParam.loWord
                //SB_LINELEFT
                //SB_LINEUP then
                   16 -> amount;
                //SB_LINERIGHT
                //SB_LINEDOWN then
                   -16  -> amount;
                //SB_PAGELEFT
                //SB_PAGEUP then
                   (if orientation=vertical then
                       height -> amount;
                    else
                       width -> amount;
                   if);
                //SB_PAGERIGHT
                //SB_PAGEDOWN then
                   (if orientation=vertical then
                       -height -> amount
                    else
                       - width -> amount;
                   if);
                //SB_THUMBPOSITION then
                   - info.wParam.hiWord -> amount;
                   true -> absolute;
               if);
               (if orientation=vertical then
                   (if absolute then
                       (0,amount) -> scrollTo;
                    else
                       (0,amount) -> scroll;
                   if);
                else
                   (if absolute then
                       (amount,0) -> scrollTo;
                    else
                       (amount,0) -> scroll;
                   if);
               if);
            #);
          
       do 
          (if info.message
           //WM_HSCROLL then horizontal -> processScroll; 
           //WM_VSCROLL then vertical -> processScroll; 
          if);
       #);
  #);

-- GUIENVscrollerPrivate: descriptor --
(# view: @canvas; 
   contentsFrameChangedAction: @contents.frameChangedAction
     (# 
     do adjustScrollValues;
     #);
#)

-- GUIENVScrollerOnFrameChanged: descriptor --
(#
do adjustScrollValues;
   inner onFrameChanged;
#)

-- GUIENVputmovieFieldLayout: doPart --
do
   
-- GUIENVgetmovieFieldLayout: doPart --
do
   
-- GUIENVtextFieldputLayout: doPart --
do
   
-- GUIENVtextFieldgetLayout: doPart --
do
   
-- GUIENVabstractScrollerputLayout: doPart --
do
   
-- GUIENVabstractScrollergetLayout: doPart --
do
   
-- GUIENVtextEditorputLayout: doPart --
do
   
-- GUIENVtextEditorgetLayout: doPart --
do
   
-- GUIENVscrollerputLayout: doPart --
do
   
-- GUIENVscrollergetLayout: doPart --
do
   
