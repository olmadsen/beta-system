ORIGIN '../fieldsbody';
INCLUDE '../../guienvactions'
        'guienv_ntiprivate'
        'guienvattributes'
        '~beta/win32lib/scrollbarsupport'
        '~beta/win32lib/systemmetrics'
        '~beta/win32lib/dialogcontrolmanagement'
        '~beta/win32lib/wingdi'
        '~beta/win32lib/gdistructs'
        '~beta/win32lib/windowsmisc'
        '~beta/win32lib/winuserconsts'
        '~beta/win32lib/memorymanagement'
        (*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
        '~beta/win32lib/errorhandling'
        '~beta/win32lib/clipboardmanager'
        '~beta/sysutils/cstring'
        'richTextI_O'
        'richTextConsts';
BODY 'richTextFieldBody';
-- lib: Attributes --
minMax:
  (# minimum,value,maximum: @integer; 
  enter (minimum,value,maximum)
  do ((minimum,value)->Max,maximum)->Min->value; 
  exit value
  #);
  

-- GUIENVmovieFieldSetContents: Descriptor --
(#  do 'Not implemented. '->screen.putLine;  #)  

-- GUIENVmovieFieldGetContents: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVmovieFieldSetScaleToFit: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVmovieFieldGetScaleToFit: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVmovieFieldCreate: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVmovieFieldOpen: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVmovieFieldClose: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVmovieFieldPrivate: Descriptor --
(#  do 'Not implemented.'->screen.putLine;  #)  

-- GUIENVtextFieldBeforeChangeTheText: DoPart --
do
   (if length > 0 then
       THIS(guienv).private.textfieldChangeText[]->value[]; 
   if);
     

-- GUIENVtextFieldonFrameChanged: Descriptor --
(#  do INNER onFrameChanged; setTextFieldMargins;  #)  

-- GUIENVtextFieldonKeyDown: Descriptor --
(# start,end,length: @integer; performEdit: @boolean; info: ^messageInfo; 
do
   (if THIS(textField).isOpen then
       true->private.performEdit;
       INNER onKeyDown;
       
       currentMessageInfo -> info[];
       
       FALSE->info.callback;
       (if (not (info.message = WM_KEYDOWN)) or (ch = ascii.bs) or
       (ch = ascii.del) then
           selection->(start,end);
           end-start->length;
           (if (length <> 0) then
               (start,- length)->theEventHandler.onBeforeChange
                 ->private.performEdit;
               
           if);
           none ->THIS(guienv).private.textfieldChangeText[];
           (if private.performEdit then
               (if ch
                // ascii.bs then
                   (if (start > 0) and (length = 0) then
                       (start-1,- 1)->theEventHandler.onBeforeChange
                         ->private.performEdit;
                       
                   if);
                   
                //ascii.del then
                   (if (start <
                       ((interfaceObjectID,WM_GETTEXTLENGTH,0,0)->sendMessage)) and
                       (length = 0) then
                       (start,- 1)->theEventHandler.onBeforeChange
                         -> private.performEdit;
                   if);
                //9 then
                   false -> private.performEdit;
                   theEventHandler.onTab;
                // ascii.cr // ascii.nl then
                   &text[]->THIS(guienv).private.textfieldChangeText[];
                   ch->THIS(guienv).private.textfieldChangeText.put;
                   (start,1)->theEventHandler.onBeforeChange
                     ->private.performEdit;
                   
                else
                   &text[]->THIS(guienv).private.textfieldChangeText[];
                   ch->THIS(guienv).private.textfieldChangeText.put;
                   (start,1)->theEventHandler.onBeforeChange
                     ->private.performEdit;
                   
               if);
               
           if);
           
       if);
       (if private.performEdit then callDefaultWindowProc;  if);
       none ->THIS(guienv).private.textfieldChangeText[];
       
   if);
   
#)  

-- GUIENVtextFieldonMouseDown: Descriptor --
(#  do INNER onMouseDown;  #)  

-- GUIENVtextFieldonMouseUp: Descriptor --
(# 
do
   (if buttonState = 1 then
       (if private.notification then INNER onMouseUp;  if); 
    else
       INNER onMouseUp; 
   if);
   
#)  

-- GUIENVtextFieldonRefresh: Descriptor --
(# width,height: @integer; info: ^messageInfo; 
do
   INNER onReFresh;
   currentMessageInfo->info[];
   FALSE->info.callback;
   callDefaultWindowProc;
   (if not (getOsMajorVersionId >= 4) then
       size->(width,height);
       (THIS(textField)[],borderStyles.shadowIn,0,0,width,height)->drawBorder;
       
   if);
   
#)  

-- GUIENVtextFieldOnEnableTarget: Descriptor --
(#  do INNER onEnableTarget;  #)  

-- GUIENVtextFieldOnDisableTarget: Descriptor --
(#  do INNER onDisableTarget;  #)  

-- GUIENVtextFieldDoPaste: Descriptor --
(# result: @integer; 
do (interfaceObjectID,WM_PASTE,0,0)->sendMessage->result; 
#)  

-- GUIENVtextFieldDoCopy: Descriptor --
(#  do (interfaceObjectID,WM_COPY,0,0)->sendMessage;  #)  

-- GUIENVtextFieldDoCut: Descriptor --
(#  do (interfaceObjectID,WM_CUT,0,0)->sendMessage;  #)  

-- GUIENVtextFieldDoClear: Descriptor --
(#  do (interfaceObjectID,WM_CLEAR,0,0)->sendMessage;  #)  

-- GUIENVtextFieldSetContents: Descriptor --
(# cstr: @cString; localCstr: ^cString; 
do
   assertOpen;
   theText[]->THIS(guienv).private.textfieldChangeText[];
   (if ((0,theText.length)->theEventHandler.onBeforeChange) then
       setTextFieldMargins;
       theText[]->cstr.set;
       cstr.toLocal->localCstr[];
       (interfaceObjectID,WM_SETTEXT,0,localCstr.charPtr)->sendMessage;
       cstr.free;
       localCstr.free;
       
   if);
   
#)  

-- GUIENVtextFieldGetContents: Descriptor --
(#
   result: @integer;
   cstr: ^cString;
   localCstr: @cString;
   length: @integer;
   t: ^text;
   windowID: @integer;
   
do
   assertOpen;
   interfaceObjectID->windowID;
   (windowID,WM_GETTEXTLENGTH,0,0)->sendMessage->length;
   length+1->localCstr.init;
   (windowID,WM_GETTEXT,length+1,localCstr.charPtr)->sendMessage->result;
   (if (result <> length) then
       'TextField.getContents: Did not copy all text!'->screen.putLine; 
   if);
   localCstr.fromLocal->cstr[];
   &styledText[]->theText[];
   cstr.get->t[];
   t->theText;
   theText.T.range->theText.pos->theText.lgth;
   localCstr.free;
   cstr.free;
   
#)  

-- GUIENVtextFieldGetChar: Descriptor --
(# t: ^text; 
do
   assertOpen;
   (if pos > - 1 then
       (pos,pos+1)->TextEditGetRange->t[];
       (if t.length > 0 then t.reset; t.get->ch;  if);
       
   if);
   
#)  

-- GUIENVtextFieldLength: Descriptor --
(# windowId: @integer; totalNoOfLines: @integer; 
do
   assertOpen;
   interfaceObjectID->windowId;
   (windowId,WM_GETTEXTLENGTH,0,0)->SendMessage->value;
   (windowId,EM_GETLINECOUNT,0,0)->sendMessage->totalNoOfLines;
   value-totalNoOfLines+1->value;
   
#)  

-- GUIENVtextFieldScanText: Descriptor --
(# theText: ^text; 
do
   assertOpen;
   cursors.watch[]->mouse.busyCursor;
   (0,start,length)->minMax->start;
   (0,end,length)->minMax->end;
   (if (start <> end) then
       (if (start < end) then
           (start,end)->TextEditGetRange->theText[]; 
        else
           (end,start)->TextEditGetRange->theText[]; 
       if);
       theText.scanAll
         (#  do ch->THIS(scanText).ch; INNER scanText;  #);
       
   if);
   none ->mouse.busyCursor;
   
#)  

-- GUIENVtextFieldPosToPt: Descriptor --
(# windowId: @integer; thePointPtr: @integer; 
do
   assertOpen;
   interfaceObjectId->windowId;
   pos->private.translateToLocal->pos;
   8->malloc->thePointPtr;
   (if thePointPtr <> 0 then
       (windowId,EM_POSFROMCHAR,thePointPtr,pos)->SendMessage;
       thePointPtr->getPointFromNtPointPtr->(pt.h,pt.v);
       pt.v+charHeight->pt.v;
       thePointPtr->free;
       
   if);
   
#)  

-- GUIENVtextFieldPtToPos: Descriptor --
(# windowId: @integer; thePosPtr: @integer; 
do
   assertOpen;
   interfaceObjectId->windowId;
   pt->makeNtPointPtr->thePosPtr;
   (if thePosPtr <> 0 then
       (windowId,EM_CHARFROMPOS,0,thePosPtr)->SendMessage->pos;
       pos->private.translateFromLocal->pos;
       thePosPtr->free;
       
   if);
   
#)  

-- GUIENVtextFieldSelectionStart: Descriptor --
(# windowID: @integer; theSel: @CHARRANGE; 
do
   interfaceObjectID->windowID;
   8->malloc->theSel.ptr;
   (if theSel.ptr <> 0 then
       (windowID,EM_EXGETSEL,0,theSel.ptr)->SendMessage;
       theSel.cpMin->private.translateFromLocal->value;
       theSel.ptr->free;
       
   if);
   
#)  

-- GUIENVtextFieldSelectionEnd: Descriptor --
(# windowID: @integer; theSel: @CHARRANGE; 
do
   interfaceObjectID->windowID;
   8->malloc->theSel.ptr;
   (if theSel.ptr <> 0 then
       (windowID,EM_EXGETSEL,0,theSel.ptr)->SendMessage;
       theSel.cpMax->private.translateFromLocal->value;
       theSel.ptr->free;
       
   if);
   
#)  

-- GUIENVtextFieldSelectionContents: Descriptor --
(#
   theStart,theEnd: @integer;
   localSelCstr: @cString;
   theSelTxt: ^cString;
   theSel: @CHARRANGE;
   windowID: @integer;
   amount: @integer;
   
do
   interfaceObjectID->windowID;
   &text[]->theText[];
   8->malloc->theSel.ptr;
   (if theSel.ptr <> 0 then
       (windowID,EM_EXGETSEL,0,theSel.ptr)->SendMessage;
       theSel.cpMax-theSel.cpMin+1->amount;
       (if amount > 1 then
           amount->localSelCstr.init;
           (if localSelCstr <> 0 then
               (windowID,EM_GETSELTEXT,0,localSelCstr)->SendMessage;
               localSelCstr.fromLocal->theSelTxt[];
               theSelTxt.get->theText[];
               localSelCstr.free;
               theSelTxt.free;
               
           if);
           
       if);
       theSel.ptr->free;
       
   if);
   
#)  

-- GUIENVtextFieldSelectionScrollIntoView: Descriptor --
(# 
do (* (interfaceObjectID,EM_SCROLLCARET,0,0) -> SendMessage; *)
   scrollIntoView2; 
#)  

-- GUIENVtextFieldSelectionSet: Descriptor --
(# windowID: @integer; theSel: @CHARRANGE; 
do
   interfaceObjectID->windowID;
   (if theStart <> theEnd then
       theStart->private.translateToLocal->theStart;
       theEnd->private.translateToLocal->theEnd;
       
    else
       theStart->private.translateToLocal->theStart->theEnd; 
   if);
   8->malloc->theSel.ptr;
   (if theSel.ptr <> 0 then
       theEnd->theSel.cpMin;
       theStart->theSel.cpMax;
       (windowID,EM_EXSETSEL,0,theSel.ptr)->SendMessage;
       theSel.ptr->free;
       
   if);
   
#)  

-- GUIENVtextFieldSetDefaultStyle: Descriptor --
(# windowID: @integer; 
do
   (if style[] <> none then
       style.create;
       style[]->textFieldDefaultStyle;
       interfaceObjectID->windowID;
       (windowID,WM_SETFONT,style.textStyleID,1)->SendMessage;
       
   if);
   
#)  

-- GUIENVtextFieldGetDefaultStyle: Descriptor --
(#  do textFieldDefaultStyle->style[];  #)  

-- GUIENVtextFieldSetMargin: Descriptor --
(#  do (leftMargin,topMargin)->textFieldMargin; setTextFieldMargins;  #)  

-- GUIENVtextFieldGetMargin: Descriptor --
(#  do textFieldMargin->(leftMargin,topMargin);  #)  

-- GUIENVtextFieldInsert: Descriptor --
(# cstr: @cString; localCstr: ^cString; start,end: @integer; 
do
   selection->(start,end);
   theText[]->THIS(guienv).private.textfieldChangeText[];
   (if ((start,theText.length)->theEventHandler.onBeforeChange) then
       theText[]->cstr.set;
       cstr.toLocal->localCstr[];
       (if (start <> end) then (start,start)->selection;  if);
       (interfaceObjectID,EM_REPLACESEL,0,localCstr.charPtr)->sendMessage;
       (if (start <> end) then
           theText.lgth+start->start;
           theText.lgth+end->end;
           (start,end)->selection;
           
       if);
       cstr.free;
       localCstr.free;
       
   if);
   
#)  

-- GUIENVtextFieldDelete: Descriptor --
(#  do (interfaceObjectID,WM_CLEAR,0,0)->sendMessage;  #)  

-- GUIENVtextFieldCreate: Descriptor --
(#
   libOk: @integer;
   wStyle: @integer;
   LoadLibraryA: external
     (# in0: [1] @char; (* LPCSTR *) out: @integer; (* HINSTANCE *) 
     enter in0
     do callStd; 
     exit out
     #);
   
do
   true->THIS(windowItem).private.borderHandledLocally;
   'RICHED32.DLL'->LoadLibraryA->libOk;
   (if libOk = 0 then
       'RICHED32.DLL -> LoadLibraryA failed. Error= '->screen.putText;
       GetLastError->screen.putint;
       screen.newline;
       
    else
       &textFieldNotiMethods[]->theNotiMethods;
       (* 060396 /les *)
       isSubClass->windowItemClassStatus;
       'RichEdit'->windowItemClass;
       (if private.useScrollbars then
           ES_MULTILINE %Bor ES_LEFT->wStyle;
           (* Above line tos_converted from: (ES_MULTILINE,ES_LEFT)->tos'%or'->wStyle; *)
           ES_AUTOHSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (ES_AUTOHSCROLL,wStyle)->tos'%or'->wStyle; *)
           ES_AUTOVSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (ES_AUTOVSCROLL,wStyle)->tos'%or'->wStyle; *)
           WS_HSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (WS_HSCROLL,wStyle)->tos'%or'->wStyle; *)
           WS_VSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (WS_VSCROLL,wStyle)->tos'%or'->wStyle; *)
           ES_DISABLENOSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (ES_DISABLENOSCROLL,wStyle)->tos'%or'->wStyle; *)
           wStyle->windowItemStyle;
           
        else
           ES_MULTILINE %Bor ES_LEFT->wStyle;
           (* Above line tos_converted from: (ES_MULTILINE,ES_LEFT)->tos'%or'->wStyle; *)
           ES_AUTOHSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (ES_AUTOHSCROLL,wStyle)->tos'%or'->wStyle; *)
           ES_AUTOVSCROLL %Bor wStyle->wStyle;
           (* Above line tos_converted from: (ES_AUTOVSCROLL,wStyle)->tos'%or'->wStyle; *)
           wStyle->windowItemStyle;
           
       if);
       (if getOsMajorVersionId >= 4 then
           WS_EX_CLIENTEDGE->windowItemExStyle; 
       if);
       &textfieldMethods[]->theMethods;
       INNER create;
       
   if);
   
#)  

-- GUIENVtextFieldOpen: Descriptor --
(#
   hdc: @integer;
   tmPtr: @integer;
   style: ^textStyle;
   t: ^text;
   windowID: @integer;
   theMask: @integer;
   textLimit: @integer;
   
do
   interfaceObjectID->windowID;
   (0xFFFF,0xFFFF,0xFFFF)->backgroundColor;
   defaultTextFieldTextStyle->style[];
   (if style[] = none then
       &textStyle[]->style[];
       'Arial'->style.name;
       10->style.size;
       style.create;
       (* ANSI_FIXED_FONT -> GetStockObject -> style.textStyleID;
        * style[] -> defaultTextFieldTextStyle;
        *)
       
   if);
   (windowID,WM_SETFONT,style.textStyleID,1)->SendMessage;
   style[]->textFieldDefaultStyle;
   cursors.iBeam[]->theCursor;
   56->malloc->tmPtr;
   (if tmPtr <> 0 then
       windowID->GetDC->hdc;
       (if ((hdc,tmPtr)->GetTextMetrics) = 0 then
           'TextFieldOpen. GetTextMetrics failed. Error: '->screen.putText;
           GetLastError->putint;
           newline;
           
        else
           (%getLongAt(tmPtr+textmetricTmAveCharWidthOffset))->charWidth;
           (* Above line tos_converted from: tmPtr+textmetricTmAveCharWidthOffset->tos'%adrGetLong'->charWidth; *)
           (%getLongAt(tmPtr+textmetricTmHeightOffset))->charHeight;
           (* Above line tos_converted from: tmPtr+textmetricTmHeightOffset->tos'%adrGetLong'->charHeight; *)
           
       if);
       (* Clean up *)
       (windowID,hdc)->ReleaseDC;
       tmPtr->free;
       
   if);
   true->border.visible;
   borderStyles.shadowIn->border.style;
   &text[]->t[];
   ''->t;
   (if ((windowID,t)->SetWindowText) = 0 then
       'SetWindowText failed in textField.open. Errorcode: '->screen.putText;
       GetLastError->screen.putInt;
       screen.newline;
       
   if);
   (windowID,EM_LIMITTEXT,0,0)->SendMessage;
   (if private.useScrollbars then (* We have a textEditor, enable large texts *)
       1024*1024-1->textLimit;
       (windowID,EM_EXLIMITTEXT,0,textLimit)->Sendmessage;
       
   if);
   (0,0)->textFieldMargin;
   private.makeRichEditI_O;
   (none ,SF_RTF)->private.theRichEditI_O.init;
   SCF_SELECTION->private.formatFlags;
   INNER open;
   (if THIS(interfaceobject).private.isOpen then
       (windowID,EM_SETBKGNDCOLOR,0,
        (THIS(windowItem).theBkColorInfo).theColorRef)->SendMessage;
       (windowID,EM_SETEVENTMASK,0,ENM_MOUSEEVENTS)->SendMessage->theMask;
       theMask %Bor ENM_MOUSEEVENTS %Bor ENM_CHANGE %Bor ENM_UPDATE->theMask;
       (windowID,EM_SETEVENTMASK,0,theMask)->SendMessage->theMask;
       setTextFieldMargins;
       true->private.firstFocus;
       private.theActivateAction[]->AppendAction;
       private.theAboutToCloseAction[]->AppendAction;
       private.theVisibleChangedAction[]->AppendAction;
       
   if);
   
#)  

-- GUIENVtextFieldClose: Descriptor --
(# 
do
   INNER close;
   private.theActivateAction[]->deleteAction;
   private.theAboutToCloseAction[]->deleteAction;
   private.theVisibleChangedAction[]->deleteAction;
   true->private.closeAction;
   
#)  

-- textFieldLib: Attributes --
scrollIntoView2:
  (#
     iStart,iend,iFirstLine,windowID: @integer;
     theSel: @CHARRANGE;
     theTextStyle: ^textStyle;
     widht,height,noOfLines,halfNoOfLines,delta: @integer;
     
  do
     THIS(textField).interfaceObjectID->windowID;
     defaultStyle->theTextStyle[];
     (if theTextStyle[] <> none then
         THIS(textField).size->(widht,height);
         (if private.useScrollbars then
             height-(SM_CYHSCROLL->GetSystemMetrics)->height; 
         if);
         height-private.topMargin-2->height;
         height div theTextSTyle.lineHeight->noOfLines;
         noOfLines div 2->halfNoOfLines;
         
     if);
     8->malloc->theSel.ptr;
     (if theSel.ptr <> 0 then
         (windowID,EM_EXGETSEL,0,theSel.ptr)->SendMessage;
         (windowID,EM_EXLINEFROMCHAR,0,theSel.cpMin)->sendMessage->iStart;
         (windowID,EM_EXLINEFROMCHAR,0,theSel.cpMax)->sendMessage->iEnd;
         (windowID,EM_GETFIRSTVISIBLELINE,0,0)->sendMessage->iFirstLine;
         (if iStart = iEnd then
             - iFirstLine-halfNoOfLines+iStart-1->delta; 
          else
             - iFirstLine+iStart-1->delta;
             (if iEnd-iStart < noOfLines then
                 delta-((noOfLines-(iEnd-iStart)) div 2)->delta; 
             if);
             
         if);
         (windowID,EM_LINESCROLL,0,delta)->SendMessage;
         theSel.ptr->free;
         
     if);
     
  #);
setTextFieldMargins:
  (# width,height: @integer; delta1,delta2: @integer; wStyle: @integer; 
  do
     size->(width,height);
     (interfaceObjectID,GWL_STYLE)->GetWindowLong->wStyle;
     (if (wStyle %Band WS_VSCROLL) <> 0 then
         width-(SM_CXVSCROLL->GetSystemMetrics)->width; 
     if);
     (if (wStyle %Band WS_HSCROLL) <> 0 then
         height-(SM_CYHSCROLL->GetSystemMetrics)->height; 
     if);
     (private.leftMargin,private.topMargin,width,height,interfaceObjectID)
       ->setEditRect;
     
  #);
setEditRect: external
  (# x,y,right,bottom,hWnd: @integer; 
  enter (x,y,right,bottom,hWnd)
  do callC; 
  #);
printEditRect:
  (# windowID,theRect: @integer; r: @rectangle; 
  do
     interfaceObjectId->windowID;
     16->malloc->theRect;
     (windowID,EM_GETRECT,0,theRect)->SendMessage;
     theRect->getRectFromNtRectPtr->r;
     theRect->free;
     'The Edit rect for windowid = '->screen.putText;
     windowid->putint;
     ': '->putText;
     r->putRectangle;
     screen.newline;
     
  #);
handleTextChanged: (#  do theEventHandler.onTextChanged;  #);
textFieldDefaultStyle:
  (# 
  enter private.textFieldDefaultStyle[]
  exit private.textFieldDefaultStyle[]
  #);
textFieldMargin:
  (# 
  enter (private.leftMargin,private.topMargin)
  exit (private.leftMargin,private.topMargin)
  #);
textFieldScroller:
  (#  enter private.textFieldScroller[] exit private.textFieldScroller[] #);
TextEditGetRange:
  (#
     theText: ^text;
     tr: @TEXTRANGE;
     windowID: @integer;
     cstr: ^cString;
     localCstr: @cString;
     startInx,endInx: @integer;
     
  enter (startInx,endInx)
  do
     &Text[]->theText[];
     interfaceObjectID->windowID;
     sizeOfTextRange->malloc->tr.ptr;
     (if tr.ptr <> 0 then
         (if startInx <> endInx then
             startInx->private.translateToLocal->startInx;
             endInx->private.translateToLocal->endInx;
             
          else
             startInx->private.translateToLocal->startInx->endInx; 
         if);
         startInx->tr.cpMin;
         endInx->tr.cpMax;
         0->tr.lpstrText;
         (if startInx < endInx then
             endInx-startInx+1->localCstr.init; 
          else
             startInx-endInx+1->localCstr.init; 
         if);
         localCstr->tr.lpstrText;
         (windowID,EM_GETTEXTRANGE,0,tr.ptr)->SendMessage;
         localCstr.fromLocal->cstr[];
         cstr.get->theText[];
         cstr.free;
         localCstr.free;
         tr.ptr->free;
         
     if);
     
  exit theText[]
  #);
charWidth: (#  enter private.cxChar exit private.cxChar #);
charHeight: (#  enter private.cyChar exit private.cyChar #);
textFieldNotiMethods: windowItemNotificationMethods
  (#
     handleNotification:: 
       (#
          processNotify:
            (#
               code1: @integer;
               message: @integer;
               newWparam: @integer;
               newLparam: @integer;
               longInt: @private.longIntType;
               oldInfo: ^messageInfo;
               
            do
               false->didSomething;
               (%getLongAt(info.lParam+8))->code1;
               (* Above line tos_converted from: info.lParam+8->tos'%adrGetLong'->code1; *)
               (if code1 = EN_MSGFILTER then
                   (%getLongAt(info.lParam+12))->message;
                   (* Above line tos_converted from: info.lParam+12->tos'%adrGetLong'->message; *)
                   (if message
                    // WM_LBUTTONUP then
                       true->private.notification;
                       &messageInfo[]->oldInfo[];
                       info.wParam->oldInfo.wParam;
                       info.lParam->oldInfo.lParam;
                       info.message->oldInfo.message;
                       info.where->oldInfo.where;
                       info.time->oldInfo.time;
                       info.button->oldInfo.button;
                       (%getLongAt(info.lParam+16))->newWparam;
                       (* Above line tos_converted from: info.lParam+16->tos'%adrGetLong'->newWparam; *)
                       (%getLongAt(info.lParam+20))->newLparam;
                       (* Above line tos_converted from: info.lParam+20->tos'%adrGetLong'->newLparam; *)
                       newWparam->longInt;
                       longInt.hiWord->info.wParam.hiWord;
                       longInt.loWord->info.wParam.loWord;
                       newWparam->info.wParam;
                       newLparam->longInt;
                       longInt.hiWord->info.lParam.hiWord;
                       longInt.loWord->info.lParam.loWord;
                       newLparam->info.lParam;
                       message->info.message;
                       GetMessagePos->longInt;
                       (longInt.loWord,longInt.hiWord)->info.where;
                       getMessageTime->info.time;
                       1->info.button;
                       FALSE->info.callback;
                       theEventHandler.onMouseUp;
                       oldInfo.wParam->info.wParam;
                       oldInfo.lParam->info.lParam;
                       oldInfo.message->info.message;
                       oldInfo.where->info.where;
                       oldInfo.time->info.time;
                       oldInfo.button->info.button;
                       false->private.notification;
                       true->didSomething;
                       (* 1 -> info.result; *)
                       
                   if);
                   
               if);
               
            #);
          didSomething: @boolean;
          
       do
          (if info.message
           // WM_NOTIFY then
              processNotify; 
           // WM_COMMAND then
              (if info.wParam.hiWord = EN_CHANGE then
                  handleTextChanged; true->didSomething; 
              if);
              
           else
              false->didSomething; 
          if);
          didSomething or info.handled->info.handled;
          
       #);
     
  #);
textFieldMethods: windowItemMethods
  (#
     dispatchMessage:: 
       (#
          didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer;
          length: @integer;
          p: @point;
          pos: @integer;
          ch: @char;
          theSel: @CHARRANGE;
          thePosPtr: @integer;
          
       do
          true->didSomething;
          (if info.message
           // WM_KEYDOWN then
              info.wParam->ch;
              (if ch
               // 'V' then
                  (if (VK_CONTROL->isVKeyDown) then
                      FALSE->info.callback;
                      true->info.handled;
                      (interfaceObjectID,WM_PASTE,0,0)->sendMessage;
                      
                  if);
                  
               // 'X' then
                  (if (VK_CONTROL->isVKeyDown) then
                      FALSE->info.callback;
                      true->info.handled;
                      (interfaceObjectID,WM_CUT,0,0)->sendMessage;
                      
                  if);
                  
               // 'Z' then
                  (if (VK_CONTROL->isVKeyDown) then
                      FALSE->info.callback;
                      true->info.handled;
                      (interfaceObjectID,EM_UNDO,0,0)->sendMessage;
                      
                  if);
                  
               else
                  false->didSomething; 
              if);
              
           // WM_LBUTTONDOWN then
              (if not private.allowDragDrop then
                  selection->(start,end);
                  (if start <> end then
                      (if (not (VK_SHIFT->isVKeyDown)) then
                          (if (not (VK_CONTROL->isVKeyDown)) then
                              (info.lParam.loWord,info.lParam.hiWord)->p;
                              p->makeNtPointPtr->thePosPtr;
                              (if thePosPtr <> 0 then
                                  (interfaceobjectid,EM_CHARFROMPOS,0,thePosPtr)
                                    ->SendMessage->pos;
                                  8->malloc->theSel.ptr;
                                  (if theSel.ptr <> 0 then
                                      pos->theSel.cpMin;
                                      pos->theSel.cpMax;
                                      (interfaceobjectid,EM_EXSETSEL,0,
                                       theSel.ptr)->SendMessage;
                                      theSel.ptr->free;
                                      
                                  if);
                                  thePosPtr->free;
                                  
                              if);
                              
                          if);
                          
                      if);
                      
                  if);
                  
              if);
              
           // WM_PASTE then
              FALSE->info.callback;
              clipboard.textContents->clipboardText[];
              (if clipboardText[] <> none then
                  clipboardText.length->clipboardLength;
                  selection->(start,end);
                  end-start->length;
                  true->performEdit;
                  none ->THIS(guienv).private.textfieldChangeText[];
                  (if (clipboardLength <> 0) then
                      (if (length <> 0) then
                          (start,- length)->theEventHandler.onBeforeChange
                            ->performEdit;
                          
                      if);
                      (if performEdit then
                          clipboardText[]
                            ->THIS(guienv).private.textfieldChangeText[];
                          (start,clipboardLength)
                            ->theEventHandler.onBeforeChange->performEdit;
                          (if performEdit then
                              callDefaultWindowProc; (* handleTextChanged; *) 
                          if);
                          none ->clipboardText[];
                          none ->THIS(guienv).private.textfieldChangeText[];
                          
                      if);
                      
                  if);
                  
              if);
              
           // WM_CUT then
              FALSE->info.callback;
              selection->(start,end);
              end-start->length;
              true->performEdit;
              (if (length <> 0) then
                  selection.contents
                    ->THIS(guienv).private.textfieldChangeText[];
                  (start,- length)->theEventHandler.onBeforeChange->performEdit;
                  (if performEdit then
                      callDefaultWindowProc; (* handleTextChanged; *) 
                  if);
                  none ->THIS(guienv).private.textfieldChangeText[];
                  
              if);
              
           // WM_CLEAR then
              FALSE->info.callback;
              selection->(start,end);
              end-start->length;
              (if (length <> 0) then
                  selection.contents
                    ->THIS(guienv).private.textfieldChangeText[];
                  (start,- length)->theEventHandler.onBeforeChange->performEdit;
                  (if performEdit then
                      callDefaultWindowProc; (* handleTextChanged; *) 
                  if);
                  none ->THIS(guienv).private.textfieldChangeText[];
                  
              if);
              
           // EM_UNDO then
              FALSE->info.callback;
              (0,0)->theEventHandler.onBeforeChange->performEdit;
              (if performEdit then callDefaultWindowProc;  if);
              
           else
              false->didSomething; 
          if);
          didSomething or info.handled->info.handled;
          
       #);
     
  #);
  

-- GUIENVtextFieldPrivate: Descriptor --
(#
   performEdit: @boolean;
   (* OLE2/COM stuff: begin *)
   textOnly,allowDragDrop: @boolean;
   topLevelWindow: ^window;
   theRichEditI_O: ^richEditI_O;
   readFromFile:
     (# fileName: ^text; 
     enter fileName[]
     <<SLOT richTextFieldReadFromFile:DoPart>>
     exit fileName[]
     #);
   save:
     (# fileName: ^text; 
     <<SLOT richTextFieldSave:DoPart>>
     exit fileName[]
     #);
   saveAs:
     (# fileName: ^text; 
     <<SLOT richTextFieldSaveAs:DoPart>>
     exit fileName[]
     #);
   print:
     (# 
     <<SLOT richTextFieldPrint:DoPart>>
     #);
   selectCharFormat:
     (# theTextColor: @integer; 
     do handleFontSelection->theTextColor; 
     exit theTextColor
     #);
   canCut: booleanValue (#  <<SLOT richTextFieldCancut:DoPart>> #);
   canCopy: booleanValue
     (# 
     <<SLOT richTextFieldCanCopy:DoPart>>
     #);
   canPaste: booleanValue (#  <<SLOT richTextFieldCanPaste:DoPart>> #);
   closeAction:
     (# okToClose: @boolean; 
     enter okToClose
     do 
     #);
   formatFlags: @integer;
   makeRichEditI_O:
     (# 
     do &richEditI_O[]->theRichEditI_O[]; 
     #);
   handleFontSelection:
     (#
        lf: @LOGFONT2;
        csf: @CHOOSEFONT;
        cf: @CHARFORMAT;
        yPerInch: @integer;
        hdc: @integer;
        windowID,topLevelWindowID:
          @integer;
        theTextColor: @integer;
        
     <<SLOT handleFontSelectionImpl:DoPart>>
     exit theTextColor
     #);
   (*************************************************
    * *************OLE2/COM stuff: end **************
    * ***********************************************)
   theActivateAction: @activateAction
     (# 
     do
        (if private.firstFocus then
            false->private.firstFocus; setTextFieldMargins; 
        if);
        
     #);
   theAboutToCloseAction: @aboutToCloseAction
     (#  do theEvent.okToClose->closeAction;  #);
   theVisibleChangedAction: @visibleChangedAction
     (#  do setTextFieldMargins; true->update;  #);
   firstFocus: @boolean;
   longIntType: cstruct
     (#
        byteSize::  (#  do 4->value;  #);
        loWord: signedShort (# pos::  (#  do 0->value;  #);  #);
        hiWord: signedShort (# pos::  (#  do 2->value;  #);  #);
        
     enter R[1]
     exit R[1]
     #);
   cxChar,cyChar: @integer;
   textFieldDefaultStyle: ^textStyle;
   leftMargin,topMargin: @integer;
   textFieldScroller: ^textEditor;
   useScrollbars: @boolean;
   notification: @boolean;
   translateToLocal:
     (#
        oldPos,newPos: @integer;
        i,curPos,prevPos,noOfChars: @integer;
        doLeave: @boolean;
        id: @integer;
        
     enter oldPos
     do
        interfaceobjectID->id;
        (id,EM_LINEFROMCHAR,oldPos,0)->SendMessage->i;
        L1:
          (# 
          do
             curPos->prevPos;
             (id,EM_LINEINDEX,i,0)->SendMessage->curPos;
             (id,EM_LINELENGTH,curPos,0)->SendMessage->noOfChars;
             (if curPos = - 1 then prevPos->curPos; true->doLeave;  if);
             (if
             ((curPos <= (oldPos+i)) and ((oldPos+i) <= (curPos+noOfChars))) or
             doLeave then
                 leave L1
              else
                 i+1->i; restart L1; ; 
             if);
             
          #);
        oldPos+i->newPos;
        
     exit newPos
     #);
   translateFromLocal:
     (# oldPos,newPos: @integer; lineNo: @integer; windowId: @integer; 
     enter oldPos
     do
        interfaceobjectID->windowId;
        (windowId,EM_LINEFROMCHAR,oldPos,0)->SendMessage->lineNo;
        oldPos-LineNo->newPos;
        
     exit newPos
     #);
   
#)  

-- GUIENVabstractScrollerScroll: Descriptor --
(#  do INNER scroll;  #)  

-- GUIENVabstractScrollerCreate: Descriptor --
(# 
do true->border.visible; borderStyles.simple->border.style; INNER create; 
#)  

-- GUIENVabstractScrollerOpen: Descriptor --
(#  do ((0,0),(20,20))->windowItemFrame; INNER open;  #)  

-- GUIENVabstractScrollerClose: Descriptor --
(#  do INNER close;  #)  

-- GUIENVabstractScrollerPrivate: Descriptor --
(#  #)  

-- textEditorLib: Attributes --
  

-- GUIENVtextEditorScroll: Descriptor --
(#  do  #)  

-- GUIENVtextEditorCreate: Descriptor --
(#  do FALSE->border.visible; INNER create;  #)  

-- GUIENVtextEditorOpen: Descriptor --
(# width,height: @integer; theBColor: ^color; 
do
   THIS(textEditor)[]->contents.textFieldScroller;
   true->contents.private.useScrollbars;
   THIS(textEditor)[]->contents.open;
   size->(width,height);
   ((0,0),(width,height))->contents.frame;
   true->contents.bindLeft;
   true->contents.bindTop;
   true->contents.bindRight;
   true->contents.bindBottom;
   INNER open;
   
#)  

-- GUIENVtextEditorClose: Descriptor --
(#  do INNER close;  #)  

-- GUIENVtextEditorPrivate: Descriptor --
(#  #)  

-- GUIENVscrollerScroll: Descriptor --
(#
   flags: @integer;
   h,v: @integer;
   width,height,contentsWidth,contentsHeight,maxHScroll,maxVScroll: @integer;
   
do
   contents.position->(h,v);
   SWP_NOSIZE+SWP_NOZORDER->flags;
   h+dh->h;
   v+dv->v;
   privateViewSize->(width,height);
   contents.size->(contentsWidth,contentsHeight);
   (if width > contentsWidth then width->contentsWidth;  if);
   (if height > contentsHeight then height->contentsHeight;  if);
   contentsHeight-height->maxVScroll;
   contentsWidth-width->maxHScroll;
   (- maxHScroll,h,0)->minMax->h;
   (- maxVScroll,v,0)->minMax->v;
   (interfaceObjectID,SB_HORZ,- h,1)->SetScrollPos;
   (interfaceObjectID,SB_VERT,- v,1)->SetScrollPos;
   (contents.interfaceObjectID,0,h,v,0,0,flags)->SetWindowPos;
   
#)  

-- GUIENVscrollerCreate: Descriptor --
(# currentStyle: @integer; 
do
   windowitemStyle->currentStyle;
   currentStyle %Bor WS_HSCROLL %Bor WS_VSCROLL->windowItemStyle;
   &scrollerMethods[]->theMethods;
   INNER create;
   
#)  

-- GUIENVscrollerOpen: Descriptor --
(#
   width,height,contentsWidth,contentsHeight: @integer;
   borderWidth: @integer;
   
do
   (if border.visible then
       (if border.style = borderStyles.simple then
           1->borderWidth; 
        else
           2->borderWidth; 
       if);
       
    else
       0->borderWidth; 
   if);
   THIS(scroller)[]->private.view.open;
   private.view[]->contents.open;
   true->private.view.bindLeft;
   true->private.view.bindTop;
   true->private.view.bindRight;
   true->private.view.bindBottom;
   INNER open;
   contents.size->(contentsWidth,contentsHeight);
   size->(width,height);
   (width,contentsWidth)->max->width;
   (height,contentsHeight)->max->height;
   ((0,0),(width,height))->contents.frame;
   private.contentsFrameChangedAction[]->contents.AppendAction;
   adjustScrollValues;
   (if border.visible then
       (if border.style = borderStyles.simple then
           1->borderWidth; 
        else
           2->borderWidth; 
       if);
       
    else
       0->borderWidth; 
   if);
   ((borderWidth,borderWidth),(width-(2*borderWidth),height-(2*borderWidth)))
     ->private.view.frame;
   
#)  

-- GUIENVscrollerClose: Descriptor --
(#  do INNER close;  #)  

-- scrollerLib: Attributes --
adjustScrollValues:
  (#
     width,height,contentsWidth,contentsHeight: @Integer;
     viewWidth,viewHeight,minWidth,minHeight,newWidth,newHeight: @integer;
     newH,newV: @integer;
     maxHScroll,maxVScroll: @integer;
     changed: @Boolean;
     testPrints:
       (# 
       do
          'AdjustScrollValues'->putline;
          'viewwidth: '->puttext;
          viewWidth->putint;
          ', contentswidth:'->puttext;
          contentswidth->putint;
          'minwidth: '->puttext;
          minWidth->putint;
          newline;
          
       #);
     
  do
     contents.size->(contentsWidth,contentsHeight);
     size->(viewWidth,viewHeight);
     minSize->(minWidth,minHeight);
     (if viewWidth > contentsWidth then
         viewWidth->contentsWidth; FALSE->private.horisontalScrollbarVisible; 
     if);
     (if viewHeight > contentsHeight then
         viewHeight->contentsHeight; FALSE->private.verticalScrollbarVisible; 
     if);
     (interfaceObjectID,SB_HORZ,0,contentsWidth-viewWidth,0)->SetScrollRange;
     (interfaceObjectID,SB_VERT,0,contentsHeight-viewHeight,0)->SetScrollRange;
     (* Adjust the thumb positions *)
     contents.position->(newH,newV);
     contentsHeight-viewHeight->maxVScroll;
     contentsWidth-viewWidth->maxHScroll;
     (- maxHScroll,newH,0)->minMax->newH;
     (- maxVScroll,newV,0)->minMax->newV;
     (interfaceObjectID,SB_HORZ,- newH,1)->SetScrollPos;
     (interfaceObjectID,SB_VERT,- newV,1)->SetScrollPos;
     (contents.interfaceObjectID,0,newH,newV,0,0,SWP_NOSIZE+SWP_NOZORDER)
       ->SetWindowPos;
     
  #);
scrollTo:
  (# h,v: @integer; pos: @point; 
  enter (h,v)
  do contents.position->pos; (h-pos.h,v-pos.v)->scroll; 
  #);
privateViewSize:
  (#
     scrollbarWidth: @integer;
     scrollbarHeight: @integer;
     width,height: @integer;
     
  do
     size->(width,height);
     (if (private.horisontalScrollbarVisible) then
         SM_CYHSCROLL->GetSystemMetrics->scrollbarHeight;
         height-scrollbarHeight->height;
         
     if);
     (if (private.verticalScrollbarVisible) then
         SM_CXVSCROLL->GetSystemMetrics->scrollbarWidth;
         width-scrollbarWidth->width;
         
     if);
     
  exit (width,height)
  #);
scrollerMethods: windowItemMethods
  (#
     vertical: (#  exit 0 #);
     horizontal: (#  exit 1 #);
     contentsWidth,contentsHeight,viewWidth,viewHeight: @integer;
     dispatchMessage::< 
       (#
          processScroll:
            (#
               amount: @integer;
               absolute: @boolean;
               width,height: @integer;
               orientation: @integer;
               doProcess: @boolean;
               curH,curV: @integer;
               
            enter orientation
            do
               TRUE->doProcess;
               privateViewSize->(width,height);
               (if info.wParam.loWord
                // SB_LINELEFT // SB_LINEUP then
                   16->amount; 
                // SB_LINERIGHT // SB_LINEDOWN then
                   - 16->amount; 
                // SB_PAGELEFT // SB_PAGEUP then
                   (if orientation = vertical then
                       height->amount; 
                    else
                       width->amount; 
                   if);
                   
                // SB_PAGERIGHT // SB_PAGEDOWN then
                   (if orientation = vertical then
                       - height->amount
                    else
                       - width->amount; 
                   if);
                   
                // SB_THUMBPOSITION then
                   - info.wParam.hiWord->amount;
                   contents.position->(curH,curV);
                   true->absolute;
                   
                else
                   FALSE->doProcess; 
               if);
               (if doProcess then
                   (if orientation = vertical then
                       (if absolute then
                           (0,amount-curV)->scroll;
                           (* (0,amount) -> scrollTo; *)
                           
                        else
                           (0,amount)->scroll; 
                       if);
                       
                    else
                       (if absolute then
                           (amount-curH,0)->scroll;
                           (* (amount,0) -> scrollTo; *)
                           
                        else
                           (amount,0)->scroll; 
                       if);
                       
                   if);
                   
               if);
               
            #);
          
       do
          (if info.message
           // WM_HSCROLL then
              horizontal->processScroll; 
           // WM_VSCROLL then
              vertical->processScroll; 
          if);
          
       #);
     
  #);
  

-- GUIENVscrollerPrivate: Descriptor --
(#
   view: @canvas;
   horisontalScrollbarVisible,verticalScrollbarVisible: @Boolean;
   contentsFrameChangedAction: @contents.frameChangedAction
     (#  do adjustScrollValues;  #);
   
#)  

-- GUIENVScrollerOnFrameChanged: Descriptor --
(#  do adjustScrollValues; INNER onFrameChanged;  #)  

