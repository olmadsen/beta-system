ORIGIN '../../fields';
BODY 'richTextI_OBody';
INCLUDE 'yesnocanceldialog';
INCLUDE 'filemisc';
INCLUDE 'richTextConsts';
INCLUDE '~beta/sysutils/v1.6/cstring';

-- textFieldLib: attributes --

richEditI_O: 
  (# 
     topLevelWindow: ^window;
     gdwFormat: @integer;
     szRTFSig: @text;
     gfReadOnly: @boolean;
     gfileName: ^text;
     gfileTitle: ^text;
     
     debug: @boolean;
     
     EDITSTREAM: ExternalRecord
       (# dwCookie: @long (# pos::< (# do 0 -> value; #); #);  
          dwError: @long (# pos::< (# do 4 -> value; #); #); 
          pfnCallback: @long (# pos::< (# do 8 -> value; #); #);  (* EDITSTREAMCALLBACK *)
       #);
     
     sizeOf_EDITSTREAM: (# exit 12 #);          
     
     init:
       (# 
       enter (topLevelWindow[],gdwFormat)
       <<SLOT richEditI_Oinit: doPart>>       
       #);          

     OpenReDoc:
       (# 
          dwError: @integer;
          errMsg: ^text;
          ofn: @OPENFILENAME;
          szFilterLoad: @cString;
          szTitle: @cString;
          szT: @cString;
          
          fInsert: @boolean;
          result: @boolean;
          
       <<SLOT richEditI_OopenReDoc: doPart>>
       exit result
       #);

     myRead2Ptr: external
       (# func: ##myRead;
          int: @integer;
       enter func##
       do 'copyinput' -> callC;
       exit int
       #);
     myRead: external
       (# hf: @integer;
          pbBuffer: @integer;
          cb: @integer;
          pcb: @integer;
          pcbTemp: @integer;
          result: @integer;
       enter (hf, pbBuffer, cb, pcb)
       do StdExternalEntry;
          
          (if (hf = HFILE_ERROR) then
              E_FAIL -> result;
           else
              (hf, pbBuffer,cb) -> myReadFile -> pcbTemp;
              (pcb,  pcbTemp) -> TOS'%PutLong';

              (if (pcbTemp >= 0) then
                  NOERROR -> result;
               else
                  E_FAIL -> result;
              if);
          if);
       exit result
       #);


     doOpen:
       (# 
          szT, szTitle: ^text;
          fInsert: @boolean;
          dwError: @boolean;
       enter (szT[], szTitle[], fInsert)
       <<SLOT richEditI_OdoOpen: doPart>>
       exit dwError
       #);

     cchRTFSig: (# exit 5 #);
     readReDoc:
       (# fileName, fileTitle: ^text;
          dwFormat: @integer;
          fInsert: @boolean;
          
          cch: @integer;
          es: @EDITSTREAM;
          szType: @cString; szTempType: @text;
          szFile, szTitle: @cString;
          fReadOnlySave: @boolean;
          cb: @integer;
          windowID: @integer;
          result: @boolean;
       enter (fileName[], fileTitle[], dwFormat, fInsert)
       <<SLOT richEditI_OreadReDoc: doPart>>            
       exit result
       #); (* End of ReadReDoc *)



     myWrite2Ptr: external
       (# func: ##myWrite;
          int: @integer;
       enter func##
       do 'copyinput' -> callC;
       exit int
       #);
     myWrite: external
       (# dwCookie: @integer;
          pbBuffer: @integer;
          cb: @integer;
          pcb: @integer;
          pcbTemp: @integer;
          result: @integer;
          
          hf: @integer;
       enter (dwCookie, pbBuffer, cb, pcb)
       do StdExternalEntry;
          dwCookie -> hf;
          
          (if (hf = HFILE_ERROR) then
              E_FAIL -> result;
           else
              (hf, pbBuffer,cb) -> myWriteFile -> pcbTemp;
              (pcb,  pcbTemp) -> TOS'%PutLong';

              (if (pcbTemp = cb) then
                  NOERROR -> result;
               else
                  E_FAIL -> result;
              if);
          if);
       exit result
       #);

     saveREDoc:
       (# errMsg: ^text;      
          hcur: @integer;
          cch: @integer;
          dwError: @integer;
          es: @EDITSTREAM;
          windowID: @integer;
          szT: @cString;
          result: @boolean;
       <<SLOT richEditI_OsaveREDoc: doPart>>
       exit result
       #);

     saveReDocAs:
       (#           
          hcur: @integer;
          cch: @integer;
          
          es: @EDITSTREAM;
          windowID: @integer;
          result,fSelect: @boolean;
          
          ofn: @OPENFILENAME;
          szFilterSave: @cString;
          szTitle: @cString;
          szT: @cString;
          
          errMsg: ^text;
          dwError: @integer;
       enter fSelect
       <<SLOT richEditI_OsaveReDocAs: doPart>>            
       exit result
       #);
     
     printReDoc:
       (# <<SLOT richEditI_OprintReDoc: doPart>> #);

     checkSave:
       (# 
          iMbid: @integer;
          szT: @cString;
          result: @integer;
          theDialog: @this(guienv).simpleMessageBox;
          windowID: @integer;
       <<SLOT richEditI_OcheckSave: doPart>>            
       exit result
       #);          
     
     ioPrivate: @<<SLOT ioPrivateImpl: descriptor>>;
  #);
