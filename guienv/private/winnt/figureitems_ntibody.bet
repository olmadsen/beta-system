ORIGIN '../figureitemsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)

INCLUDE 'guienv_ntiprivate';
INCLUDE '../../graphics';
INCLUDE 'graphics_ntibody';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';


-- GUIENVpenSetForegroundColor: descriptor --
(#
do theColor -> penForegroundColor;
   updateMaybe
#)

-- GUIENVpenGetForegroundColor: descriptor --
(#
do penForegroundColor -> theColor;
#)

-- GUIENVpenSetBackgroundColor: descriptor --
(#
do theColor -> penBackgroundColor;
   updateMaybe
#)

-- GUIENVpenGetBackgroundColor: descriptor --
(#
do penBackgroundColor -> theColor;
#)

-- GUIENVpenSetStipple: descriptor --
(#
do p[] -> penStipple;
   updateMaybe
#)

-- GUIENVpenGetStipple: descriptor --
(#
do penStipple -> p[];
#)

-- GUIENVpenSetSize: descriptor --
(#
do value -> figureItemPenSize;
   updateMaybe
#)

-- GUIENVpenGetSize: descriptor --
(#
do figureItemPenSize -> value;
#)

-- GUIENVfigureItemCreate: descriptor --
(# 
do '' -> windowItemClass;
   isNoClass -> windowItemClassStatus; 
   inner create;
#)

-- GUIENVfigureItemOpen: descriptor --
(#
do (* Set visibleFlag to false to avoid calling update before after inner *)
   false -> this(windowItem).private.visibleFlag;
   
   patterns.black[] -> pen.stipple; 
   1 -> figureItemPenSize;
   
   (* Now reset visibleFlag *)
   true -> this(windowItem).private.visibleFlag;
   inner open;
#)

-- GUIENVfigureItemOnRefresh: descriptor --
(#
do inner onRefresh;
#)

-- figureItemLib: attributes --
penForegroundColor:
  (#
  enter private.penForegroundColor
  exit private.penForegroundColor
  #);
penBackgroundColor:
  (#
  enter private.penBackgroundColor
  exit private.penBackgroundColor
  #);
penStipple:
  (#
  enter private.penStipple[]
  exit private.penStipple[]
  #);
figureItemPenSize:
  (#
  enter private.penSize
  exit private.penSize
  #);
drawWithPen: father.graphics
  (# theColor: @color;
  do (if (this(figureItem).penStipple<>NONE) then 
         this(figureItem).pen.stipple -> pen.stipple;
         this(figureItem).pen.size -> pen.size;
         this(figureItem).pen.backgroundColor -> pen.backgroundColor;
         this(figureItem).pen.foregroundColor -> pen.foregroundColor;
         inner drawWithPen;
     if);
  #);

updateMaybe:
  (# 
  do (if visible then
         update;
     if);
  #);

-- GUIENVfigureItemPrivate: descriptor --
(# penForegroundColor,penBackgroundColor: @color;
   penStipple: ^pixmap;
   penSize: @integer;
#)

-- GUIENVlineSetStart: descriptor --
(#
do theStart -> lineStart;
   adjustFrame;
#)

-- GUIENVlineGetStart: descriptor --
(#
do lineStart -> theStart;
#)

-- GUIENVlineSetEnd: descriptor --
(#
do theEnd -> lineEnd;
   adjustFrame;
#)

-- GUIENVlineGetEnd: descriptor --
(#
do lineEnd -> theEnd;
#)

-- GUIENVLineOpen: descriptor --
(#
do inner open;
#)

-- GUIENVlineOnRefresh: descriptor --
(#
do (if hilite then drawControlPoints; if);
   drawWithPen
   (# 
   do (lineStart,lineEnd) -> drawLine; 
   #);
   inner onRefresh;
#)

-- GUIENVlineonFrameChanged: descriptor --
(# dh,dv: @integer;
do (if not private.stopRecursion then
       newFrame.left - oldFrame.left -> dh;
       newFrame.top - oldFrame.top -> dv;
       (dh,dv) -> private.lineStart.add;
       (dh,dv) -> private.lineEnd.add;
   if);
   inner onFrameChanged;
#)

-- GUIENVlineonHiliteChanged: descriptor --
(#
do (if hilite then
       update;
    else
       clearControlPoints;
       update;
   if);
   inner onHiliteChanged;
#)

-- lineLib: attributes --
lineStart:
	(#
	enter private.lineStart
	exit private.lineStart
	#);
lineEnd:
	(#
	enter private.lineEnd
	exit private.lineEnd
	#);
adjustFrame:
  (# f: @rectangle;
     penSize,d: @integer;
     p1,p2: @point;
  do lineStart -> p1;
     lineEnd -> p2;
     (p1.h,p2.h) -> min -> f.left;
     (p1.h,p2.h) -> max -> f.right;
     (p1.v,p2.v) -> min -> f.top;
     (p1.v,p2.v) -> max -> f.bottom;
     pen.size -> penSize;
     (penSize,3) -> max -> d;
     (-d,-d) -> f.inset;
     true -> private.stopRecursion;
     (frame,f) -> handleFrameChanged;
     false -> private.stopRecursion;
     
     
     
     (* (lineStart, lineEnd) -> f.setFromPoints;
     (1,1) -> f.size;
      f -> frame;
      *)
  #);
drawControlPoints: father.graphics
  (# square: 
       (# p: @point;
          r: @rectangle;
       enter p
       do (p,p) -> r;
          (-3,-3) -> r.inset;
       exit r
       #);
     r: @rectangle;
     oldPenMode: @integer;
     hRgn: @integer;
  do getGraphicsHdc -> GetROP2 -> oldPenMode;
     transferModes.xorBlend-> Pen.mode;  
     start ->  square -> fillRect;
     end -> square -> fillRect;
     (getGraphicsHdc, oldPenMode) -> SetROP2; 
  #);

clearControlPoints: father.graphics
  (# square: 
       (# p: @point;
          r: @rectangle;
       enter p
       do (p,p) -> r;
          (-3,-3) -> r.inset;
       exit r
       #);
     r: @rectangle; ntrPtr: @integer;
     oldPenMode: @integer;
     hRgn: @integer;
     result: @integer;
  do start -> square -> r;
     r[] -> makeNtRectPtr -> ntrPtr;
     (father.interfaceObjectID, ntrPtr, 1) -> InvalidateRect -> result;
     (result,'GUIENVwindowitemUpdate') -> checkNullError;
     ntrPtr -> free;
     
     end -> square -> r;
     r[] -> makeNtRectPtr -> ntrPtr;
     (father.interfaceObjectID, ntrPtr, 1) -> InvalidateRect -> result;
     (result,'GUIENVwindowitemUpdate') -> checkNullError;
     ntrPtr -> free;
  #);

-- GUIENVlinePrivate: descriptor --
(# lineStart,lineEnd: @point;
   stopRecursion: @boolean;
#)

-- GUIENVFillSetTile: descriptor --
(#
do p[] -> fillTile;
   updateMaybe
#)

-- GUIENVfillGetTile: descriptor --
(#
do fillTile -> p[];
#)

-- GUIENVFillSetForegroundColor: descriptor --
(#
do theColor -> fillForegroundColor;
   updateMaybe
#)

-- GUIENVfillGetForegroundColor: descriptor --
(#
do fillForegroundColor -> theColor;
#)

-- GUIENVFillSetBackgroundColor: descriptor --
(#
do theColor -> fillBackgroundColor;
   updateMaybe
#)

-- GUIENVfillGetBackgroundColor: descriptor --
(#
do fillBackgroundColor -> theColor;
#)

-- GUIENVshapeOpen: descriptor --
(#
do inner open;
#)

-- GUIENVshapeOnRefresh: descriptor --
(#
do inner onRefresh;
   (if hilite then
       drawControlPoints
   if);
#)

-- GUIENVshapeonHiliteChanged: descriptor --
(#
do inner onHiliteChanged;
   (if hilite then
       drawControlPoints;
    else
       update;
   if);
#)
-- shapeLib: attributes --
fillTile:
  (#
  enter private.fillTile[]
  exit private.fillTile[]
  #);
fillBackgroundColor:
  (#
  enter private.fillBackgroundColor
  exit private.fillBackgroundColor
  #);
fillForegroundColor:
  (#
  enter private.fillForegroundColor
  exit private.fillForegroundColor
  #);
drawWithFill: father.graphics
  (#
  do (if fill.tile<>none then
         (interfaceObjectID,WM_ERASEBKGND,getGraphicsHdc,0) -> SendMessage; 
         fill.foreGroundColor -> pen.foreGroundColor;
         fill.backgroundColor -> pen.backgroundColor;
         fill.tile -> pen.stipple; 
         inner drawWithFill;
     if);
  #);

drawControlPoints: father.graphics
  (# fillSquare:
       (# p: @point;
          r: @rectangle;
       enter p
       do (p,p) -> r;
          (-3,-3) -> r.inset;
          r -> fillRect;
       #);
     f: @rectangle;
     w,h: @integer;
     oldPenMode: @integer;
  do getGraphicsHdc -> GetROP2 -> oldPenMode;
     transferModes.xorBlend-> Pen.mode;  
      
     patterns.black[] -> pen.stipple;
     frame -> f;
     f.size -> (w,h);
     (if ( (w > 8) and (h > 8) ) then
         (f.left + 3,f.top + 3) -> fillSquare;
         (f.right - 3,f.top + 3) -> fillSquare;
         (f.right - 3,f.bottom - 3) -> fillSquare;
         (f.left + 3,f.bottom - 3) -> fillSquare;
     if);
     (getGraphicsHdc, oldPenMode) -> SetROP2; 
  #);

-- GUIENVshapePrivate: descriptor --
(# fillTile: ^pixmap;
   fillBackgroundColor,fillForegroundColor: @color;
#)

-- GUIENVovalOpen: descriptor --
(#
do inner open;
#)

-- GUIENVovalOnRefresh: descriptor --
(# 
do drawWithFill
   (# 
   do frame -> fillOval;
   #);
   drawWithPen
   (# 
   do frame -> drawOval;
   #);
   inner onRefresh;
#)

-- GUIENVrectOpen: descriptor --
(#
do inner open;
#)

-- GUIENVrectOnRefresh: descriptor --
(#
do drawWithFill
   (# 
   do frame -> fillRect;
   #);
   drawWithPen
   (# 
   do frame -> drawRect; 
   #);
   inner onRefresh;
#)

-- GUIENVRoundRectOpen: descriptor --
(#
do inner open;
#)

-- GUIENVroundRectSetRoundness: descriptor --
(#
do (theOvalHeight,theOvalWidth) ->  roundrectRoundNess;
   updateMaybe
#)

-- GUIENVroundRectGetRoundness: descriptor --
(#
do roundrectRoundNess -> (theOvalHeight,theOvalWidth);
#)

-- GUIENVroundRectOnRefresh: descriptor --
(#
do drawWithFill
   (# 
   do (frame,((0,0),roundness)) -> fillRoundRect;
   #);
   drawWithPen
   (# 
   do (frame,((0,0),roundness)) -> drawRoundRect; 
   #);
   inner onRefresh;
#)

-- roundRectLib: attributes --
roundrectRoundNess:
  (#
  enter private.roundrectRoundNess
  exit private.roundrectRoundNess
  #);

-- GUIENVroundRectPrivate: descriptor --
(# roundrectRoundNess: @point;
#)

-- GUIENVWedgeOpen: descriptor --
(#
do inner open;
#)

-- GUIENVwedgeSetStartAngle: descriptor --
(#
do angle -> wedgeStartAngle;
   updateMaybe
#)

-- GUIENVwedgeGetStartAngle: descriptor --
(#
do wedgeStartAngle -> angle;
#)

-- GUIENVwedgeSetEndAngle: descriptor --
(#
do angle -> wedgeEndAngle;
   updateMaybe
#)

-- GUIENVwedgeGetEndAngle: descriptor --
(#
do wedgeEndAngle -> angle;
#)

-- GUIENVwedgeOnRefresh: descriptor --
(#
do drawWithFill
   (# 
   do (frame,wedgeStartAngle,wedgeEndAngle) -> fillSlice;
   #);
   drawWithPen
   (# 
   do (frame,wedgeStartAngle,wedgeEndAngle) -> drawSlice;
   #);
   inner onRefresh;
#)

-- wedgeLib: attributes --
wedgeStartAngle:
  (# 
  enter private.wedgeStartAngle
  exit private.wedgeStartAngle
  #);
wedgeEndAngle:
  (# 
  enter private.wedgeEndAngle
  exit private.wedgeEndAngle
  #);

-- GUIENVwedgePrivate: descriptor --
(# wedgeStartAngle, wedgeEndAngle: @integer;
#)

-- polygonLib: attributes --
getNtPoints:
  (# ntPoints: [0] @integer; result: @integer;
  do 2 * private.thePoints.range ->  ntPoints.new;
     (for i: private.thePoints.range repeat
          private.thePoints[i].h -> ntPoints[(i*2)-1];
          private.thePoints[i].v -> ntPoints[i*2];
     for);     
  exit ntPoints
  #);
getNtRegion:
  (# ntPoints: [0] @integer;
     hRegion: @integer;
  do getNtPoints -> ntPoints;
     (@@ntPoints[1],private.thePoints.range,ALTERNATE) -> CreatePolygonRgn -> hRegion;
     (hRegion,'getNtRegion') -> checkNullError;
  exit hRegion
  #);

adjustFrame:
  (# f: @rectangle;
     penSize,d: @integer;
     hRegion: @integer;
     theNtRectPtr: @integer;
  do getNtRegion ->  hRegion;
     16 -> malloc -> theNtRectPtr;
     (hRegion,theNtRectPtr) -> GetRgnBox;
     hRegion -> DeleteObject;
     theNtRectPtr -> getRectFromNtRectPtr -> f;
     pen.size -> penSize;
     (penSize, 3) -> min -> d;
     (-d,-d) -> f.inset; 
     true -> private.stopRecursion;
     (frame,f) -> handleFrameChanged;
     false -> private.stopRecursion;
     theNtRectPtr -> free;
  #);
-- GUIENVpolygonSetPoints: descriptor --
(#
do thePoints.range -> private.thePoints.new;
   (for i: thePoints.range repeat
        &point[] -> private.thePoints[i][];
        thePoints[i] -> private.thePoints[i];
   for);
   adjustFrame;
#)

-- GUIENVpolygonGetPoints: descriptor --
(#
do private.thePoints.range -> thePoints.new;
   (for i: thePoints.range repeat
        &point[] -> thePoints[i][];
        private.thePoints[i] -> thePoints[i];
   for);
#)

-- GUIENVpolygonOpen: descriptor --
(#
do inner open;
#)

-- GUIENVpolygonOnRefresh: descriptor --
(# pts: [0] ^point;
do points -> pts;
   drawWithFill
   (# 
   do pts -> fillPolygon;
   #);
   drawWithPen
   (# 
   do pts -> drawPolygon;
   #);
   inner onRefresh;
#)

-- GUIENVpolygononFrameChanged: descriptor --
(# dh,dv: @integer;
do (if not private.stopRecursion then
       newFrame.left - oldFrame.left -> dh;
       newFrame.top - oldFrame.top -> dv;
       (for i: private.thePoints.range repeat
            (dh,dv) -> private.thePoints[i].add;
       for);
   if);
   inner onFrameChanged;
#)

-- GUIENVpolygonPrivate: descriptor --
(# thePoints: [3] ^point;
   stopRecursion: @boolean
#)
