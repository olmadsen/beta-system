ORIGIN '../guienvbody';
BODY 'pixmapbody';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)
INCLUDE '~beta/win32lib/v1.6/windowmanagement';
INCLUDE '~beta/win32lib/v1.6/wingdi';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';
INCLUDE '~beta/win32lib/v1.6/menusupport';
INCLUDE '~beta/win32lib/v1.6/errorhandling';
INCLUDE '~beta/containers/v1.6/hashTable';
INCLUDE '../linkedlist';
INCLUDE '../../stddialogs';
INCLUDE '../../guienvactions';


-- guienvLib: attributes --

mainLoop:
  (# processOne: @processOneEvent;
  do l:
       (if not private.done then
           processOne;
           restart l;
       if);
  #);  
processOneEvent:
  (# continue: @integer;
     idle: @doIdle;
     result: @integer;
     dispatchResult: @integer;
     msg, wParam: @integer;
     
  do idle; 
     (private.message, 0, 0, 0, PM_REMOVE) -> PeekMessage -> result;
     (if result = 0 then
         (* Systemenv version. *)
         (if XsystemEnvPresent then 
             (if private.sysenv_UIIdle then
                 WaitMessage
             if)
          else
             WaitMessage;
         if);         
      else
         (private.message + 4 -> TOS'%adrGetLong') -> msg;
         (private.message + 8 -> TOS'%adrGetLong') -> wParam;
         (if msg  
          // WM_QUIT then
             cleanUp;
             Stop;
          else
             (if this(guienv).private.hAccelTable=0 then 
                 private.message -> TranslateMessage -> result;
                 private.message -> DispatchMessage -> dispatchResult;
              else
                 (if ((GetActiveWindow,hAccelTable,private.message) 
                       -> TranslateAccelerator) = 0 then
                     private.message -> TranslateMessage -> result;
                     private.message -> DispatchMessage -> dispatchResult;
                 if); 
             if);
         if);
     if);
  #);


cleanUp:
  (# 
  do private.colors.cleanUp;
     private.textstyles.cleanUp;
     private.menus.cleanUp;
     private.windows.cleanUp;
     (if private.ghPal<>0 then
         private.ghPal -> DeleteObject;
         0 -> private.ghPal;
     if);
     (if private.curhPal<>0 then
         private.curhPal -> DeleteObject;
         0 -> private.curhPal;
     if);
     (if patterns.black[]<>NONE then patterns.black.dispose; if);
     (if patterns.white[]<>NONE then patterns.white.dispose; if);
     (if patterns.dkGray[]<>NONE then patterns.dkGray.dispose; if);
     (if patterns.gray[]<>NONE then patterns.gray.dispose; if);
     (if patterns.ltGray[]<>NONE then patterns.ltGray.dispose; if);
  #);

toData: external
  (# in: @integer;
     out: ^data;
  enter in
  do 'copyinput' -> callC;
  exit out[]
  #);

doIdle:
  (#
  do 
  #);
CallWindowProc: external
    (# theProc,window,message,wParam,lParam: @integer;
        result: @integer;
    enter (theProc,window,message,wParam,lParam)
    do 'CallWindProc' -> callC
    exit result
    #);


win32Menu: interfaceObject
  (# <<SLOT win32MenuLib: attributes>>;
     theMenu: ^menu;
     append:
       (# theItem: ^menu.menuitem;
       enter theItem[]
       <<SLOT GUIENVwin32Menuappend: doPart>>
       #);
     delete:
       (# theItem: ^menu.menuitem;
       enter theItem[]
       <<SLOT GUIENVwin32Menudelete: doPart>>
       #);
     open::<
       (# create::< (# <<SLOT GUIENVwin32MenuCreate: doPart>> #);
       <<SLOT GUIENVwin32MenuOpen: doPart>>
       #);
     init: (# <<SLOT GUIENVwin32MenuInit: doPart>> #);
     close::<
       (# 
       <<SLOT GUIENVwin32MenuClose: doPart>>
       #);
     private: @<<SLOT GUIENVwin32MenuPrivate: descriptor>>;
  #);
win32Menubar: interfaceObject
  (# <<SLOT win32MenubarLib: attributes>>;
     theWindow: ^window;
     append:
       (# theMenu: ^menu;
       enter theMenu[]
       <<SLOT GUIENVwin32Menubarappend: doPart>>
       #);
     insert:
       (# theMenu: ^menu;
       enter theMenu[]
       <<SLOT GUIENVwin32Menubarinsert: doPart>>
       #);
     delete:
       (# theMenu: ^menu;
       enter theMenu[]
       <<SLOT GUIENVwin32Menubardelete: doPart>>
       #);
     open::<
       (# create::< (# <<SLOT GUIENVwin32Menubarcreate: doPart>> #);
       <<SLOT GUIENVwin32Menubaropen: doPart>>
       #);
     close::<
       (# 
       <<SLOT GUIENVwin32MenubarClose: doPart>>
       #);
     private: @<<SLOT GUIENVwin32Menubarprivate: descriptor>>;
  #);

getOsVersionId: external
  (# osId: @integer;
  do callC;
  exit osId
  #);

getOsMajorVersionId: external
  (# osId: @integer;
  do callC;
  exit osId
  #);

isVKeyDown: external
  (# button: @integer;
     res: @boolean;
  enter button
  do 'isButtonDown' -> callC;
  exit res
  #);

isVKeyToggled: external
  (# button: @integer;
     res: @boolean;
  enter button
  do 'isVKeyToggled' -> callC;
  exit res
  #);

reportLastError:
  (# msg: @text;
     error: @integer;
  enter msg
  <<SLOT GUIENVreportLastError: doPart>>
  #);
checkNullError:
  (# value: @integer;
     msg: @text;
  enter (value, msg)
  do (if value=0 then
         msg -> reportLastError;
     if);
  #);
checkMinusOneError: 
  (# value: @integer;
     msg: @text;
  enter (value,msg)
  do (if value=-1 then
         msg -> reportLastError;
     if);
  #);
checkSetTextError: 
  (# value: @integer;
     msg: @text;
  enter (value,msg)
  do (if value//LB_ERRSPACE//CB_ERRSPACE//CB_ERR then
         msg -> reportLastError;
     if);
  #);
theScreenRectangle:
  (# 
  enter private.theScreenRectangle
  exit private.theScreenRectangle
  #);
doubleClickPossible:
  (# 
  enter private.doubleClickPossible
  exit private.doubleClickPossible
  #);
modalState: 
  (#
  enter private.modalState
  exit private.modalState
  #);
activeWindow:
  (# theWindow: ^window;
     hWnd: @integer;
  <<SLOT GUIENVactiveWindow: doPart>>
  exit theWindow[]
  #);

makeModal:
 (# ID: @integer
 enter ID
 <<SLOT GUIENVwindowsMakeModal: doPart>>
 #);

removeModal:
  (#
  <<SLOT GUIENVwindowsRemoveModal: doPart>>
  #);

lastActiveWindowID:
  (# 
  enter private.lastActiveWindowID
  exit  private.lastActiveWindowID
  #);

findInterfaceObjecById:
  (# id: @integer;
     theInterfaceObject: ^interfaceobject;
  enter id
  do id -> private.interfaceobjects.findById -> theInterfaceObject[]
  exit theInterfaceObject[]
  #);

modeless: (# exit 1 #);
applicationModal: (# exit 2 #);
systemModal: (# exit 3 #);

rectLeftOffset:   (# exit 0 #);
rectTopOffset:    (# exit 4 #);
rectRightOffset:  (# exit 8 #);
rectBottomOffset: (# exit 12 #);

makeNtRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter r[]
  do 16 -> malloc -> ntRectPtr;
     (ntRectPtr + rectLeftOffset,  r.left) -> TOS'%PutLong';
     (ntRectPtr + rectTopOffset,   r.top) -> TOS'%PutLong';
     (ntRectPtr + rectRightOffset, r.right) -> TOS'%PutLong';
     (ntRectPtr + rectBottomOffset,r.bottom) -> TOS'%PutLong';
  exit ntRectPtr
  #);

getRectFromNtRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter ntRectPtr
  do &rectangle[] -> r[];
     ntRectPtr + rectLeftOffset   -> TOS'%adrGetLong' -> r.left;
     ntRectPtr + rectTopOffset    -> TOS'%adrGetLong' -> r.top;
     ntRectPtr + rectRightOffset  -> TOS'%adrGetLong' -> r.right;
     ntRectPtr + rectBottomOffset -> TOS'%adrGetLong' -> r.bottom;
  exit r
  #); 

pointXoffset: (# exit 0 #);
pointYoffset: (# exit 4 #);

makeNtPointPtr:
  (# h,v: @integer;
     ntPointPtr: @integer;
  enter (h,v)
  do 8 -> malloc -> ntPointPtr;
     (ntPointPtr + pointXoffset, h) -> TOS'%PutLong';
     (ntPointPtr + pointYoffset, v) -> TOS'%PutLong';
  exit ntPointPtr
  #);

getPointFromNtPointPtr:
  (# h,v: @integer;
     ntPointPtr: @integer;
  enter ntPointPtr
  do ntPointPtr + pointXoffset -> TOS'%adrGetLong' -> h;
     ntPointPtr + pointYoffset -> TOS'%adrGetLong' -> v;
  exit (h,v)
  #);

std16x4:external
  (# a:@integer;
  enter (a,a,a,a)
  do stdExternalEntry
  exit a
  #);

std16x4toint: external
  (# func: ##StandardWindowProc;
     int: @integer;
  enter func##
  do 'copyinput'->callC
  exit int
  #);

(* StandardWindowProc: external
 *   (# windowHandle,message,wParam,lParam: @integer;
 *      result: @integer;
 *   enter (windowHandle,message,wParam,lParam)
 *   do StdExternalEntry;
 *      (if true//true then <<SLOT GUIENVStandardWindowProc: descriptor>>
 *       else 
 *          (windowHandle,message,wParam,lParam) -> DefWindowProc -> result;
 *      if);
 *   exit result
 *   #);
 *)

StandardWindowProc: external
  (# windowHandle,message,wParam,lParam: @integer;
     result: @integer;               
     dispatch: <<SLOT GUIENVStandardWindowProc: descriptor>>;
  enter (windowHandle,message,wParam,lParam)
  do StdExternalEntry;
     (if XsystemEnvPresent then
         &dispatch[]->XsystemEnvHandleCallback;
      else
         dispatch;
     if);
  exit result
  #);

addInterfaceObject:
  (# theObject: ^interfaceObject;
  enter theObject[]
  <<SLOT GUIENVaddInterfaceObject: doPart>>
  #);
removeInterfaceObject:
  (#	theObject: ^interfaceObject;
  enter theObject[]
  <<SLOT GUIENVremoveInterfaceObject: doPart>>
  #);
addWindow:
  (# theWindow: ^window;
  enter theWindow[]
  <<SLOT GUIENVaddWindow: doPart>>
  #);
removeWindow:
  (# theWindow: ^window;
  enter theWindow[]
  <<SLOT GUIENVremoveWindow: doPart>>
  #);

uienvStandardWindowClass:
  (#
  enter private.uienvStandardWindowClass
  exit private.uienvStandardWindowClass
  #);
uienvDialogWindowClass:
  (#
  enter private.uienvDialogWindowClass
  exit private.uienvDialogWindowClass
  #);
uienvHInstance:
  (#
  enter private.uienvHInstance
  exit private.uienvHInstance
  #);
uienvStandardWindowProcAddress:
  (# 
  enter private.uienvStandardWindowProcAddress
  exit private.uienvStandardWindowProcAddress
  #);
applIconId:
  (# 
  enter private.applIconId
  exit private.applIconId
  #);
uniqueMenuItemID: integerValue
    (#
    do private.lastMenuItemID + 1 -> value -> private.lastMenuItemID;
    #);
messageInfo:
  (# message: @integer;
     param: integerObject
       (# hiWord,loWord: @integer;
       #);
     wParam,lParam: @param;
     result: @integer;
     handled: @boolean;
     callBack: @boolean;
     time: @integer;
     where: @point;
     button: @integer;
     key: @integer;
     next: ^messageInfo;
    #);
currentMessageInfo:
    (#
    enter private.currentMessageInfo[]
    exit private.currentMessageInfo[]
    #);
pushMessageInfo:
    (# info: ^messageInfo;
    enter info[]
    do currentMessageInfo -> info.next[];
       info[] -> currentMessageInfo;
    #);
popMessageInfo:
    (# info: ^messageInfo;
    do currentMessageInfo -> info[];
       (if (info[]<>none) then
           info.next[] -> currentMessageInfo;
       if);
    #);
modalWindowInfo:
  (# theWindow: ^window;
     targetID: @integer;;
     next: ^modalWindowInfo;
  #);
currentModalWindowInfo:
  (# 
  enter private.currentModalWindowInfo[]
  exit private.currentModalWindowInfo[]
  #);
pushModalWindowInfo:
  (# info: ^modalWindowInfo;
  enter info[]
  do currentModalWindowInfo -> info.next[];
     info[] -> currentModalWindowInfo;
  #);
popModalWindowInfo:
  (# info: ^modalWindowInfo;
  do currentModalWindowInfo -> info[];
     (if info[]<>NONE then
         info.next[] -> currentModalWindowInfo;
     if);
  #);
uienvTheMenubar:
  (# 
  enter private.theMenubar[]
  exit private.theMenuBar[]
  #);
backgroundBrush:
  (# 
  enter private.backgroundBrush
  exit private.backgroundBrush
  #);
hAccelTable:
  (#
  enter private.hAccelTable
  exit private.hAccelTable
  #);
setHMainWindow:
  (# hMainWindow: @integer;
  enter hMainWindow
  do (if private.hMainWindow=0 then
     hMainWindow -> private.hMainWindow;
     if);
  #);
getHMainWindow:
  (#
  exit private.hMainWindow
  #);
defaultButtonTextStyle:
  (# 
  enter private.defaultButtonTextStyle[]
  exit private.defaultButtonTextStyle[]
  #);
defaultTextFieldTextStyle:
  (# 
  enter private.defaultTextFieldTextStyle[]
  exit private.defaultTextFieldTextStyle[]
  #);
defaultEditTextTextStyle:
  (# 
  enter private.defaultEditTextTextStyle[]
  exit private.defaultEditTextTextStyle[]
  #);
defaultStaticTextTextStyle:
  (#
  enter private.defaultStaticTextTextStyle[]
  exit private.defaultStaticTextTextStyle[]
  #);
defaultScrollListTextStyle:
  (# 
  enter private.defaultScrollListTextStyle[]
  exit private.defaultScrollListTextStyle[]
  #);
doDebug:
  (#
  enter private.doDebug
  exit private.doDebug
  #);

makeColorRef:
  (# theColor: ^color;
     theColorRef: @integer;
  enter theColor[]
  do (if theColor[]<>NONE then
         (theColor.red div 256,0) -> theColorRef.%putByte;
         (theColor.green div 256,1) -> theColorRef.%putByte;
         (theColor.blue div 256,2) -> theColorRef.%putByte;
         (2,3) -> theColorRef.%putByte;
     if);
  exit theColorRef
  #);

colorInfo: 
  (# red, green, blue: @integer;
     theColorRef: @integer;
     hBrush: @integer;
     equal: booleanValue
       (# theRed, theGreen, theBlue: @integer;
       enter (theRed, theGreen, theBlue)
       do ((red = theRed) and (green = theGreen) and (blue = theBlue))
            -> value;
       #);
     
     dispose:
       (# 
       do (if hBrush<>0 then hBrush -> DeleteObject; if);
       #);
     
     refCount: @integer;
     
  enter (red, green, blue)
  exit (red, green, blue)
  #);

-- GUIENVPrivate: descriptor --
(# doDebug: @boolean;
   
   menuChanged:<
     (# theMenu: ^menu;
     enter theMenu[]
     do inner
     #);
   
   EnumFontFamiliesProcAddress: @integer;
   
   theScreenRectangle: @rectangle;
   hMainWindow: @integer;
   hAccelTable: @integer;
   doubleClickPossible: @boolean;
   lastActiveWindowID: @integer;
   lastCaptureID: @integer;
   uienvStandardWindowClass: @text;
   uienvDialogWindowClass: @text;
   uienvHInstance: @integer;
   uienvStandardWindowProcAddress: @integer;
   isMCIWndClassReg: @boolean;
   applIconId: @integer;
   textfieldChangeText: ^text;
   done: @boolean;
   message: @integer;
   modalState: @integer; 
   currentModalWindowInfo: ^modalWindowInfo;
   lastMenuitemID: @integer;
   currentMessageInfo: ^messageInfo;
   theMenubar: ^menubar;
   backgroundBrush: @integer;
   defaultButtonTextStyle: ^textStyle;
   defaultTextFieldTextStyle: ^textStyle;
   defaultEditTextTextStyle: ^textStyle;
   defaultStaticTextTextStyle: ^textStyle;
   defaultScrollListTextStyle: ^textStyle;
   currentMouseCursor, prevMouseCursor: ^cursor;
   ghPal, curhPal: @integer;      
   
   colors: @hashTable
     (# element:: colorInfo;
        hashfunction:: (# do e.theColorRef mod 31 -> value #);
        equal:: (# do (left -> right.equal) -> value; #);
        rangeInitial:: (# do 31 -> value; INNER #);
        
        findByRGB: @
          (# theColor: @color; theColorRef: @integer;
             foundObject: ^element;
             fi: @findIndexed
               (# predicate:: 
                    (# 
                    do theColor->current.equal -> value 
                    #);
                  notFound:: (# do NONE -> foundObject[]; #);
               do current[] -> foundObject[];
               #);
          enter theColor
          do theColor[] -> makeColorRef -> theColorRef;
             theColorRef mod 31 -> fi;
          exit foundObject[]
          #);
        
        remove:
          (# theColorInfo: ^colorInfo;
          enter theColorInfo[]
          do theColorInfo.refCount - 1 -> theColorInfo.refCount;
             (if theColorInfo.refCount=0 then
                 theColorInfo.dispose;
                 theColorInfo[] -> delete;
             if);
          #);
        
        add:
          (# theColorInfo: ^colorInfo;
          enter theColorInfo[]
          do theColorInfo.refCount + 1 -> theColorInfo.refCount;
             theColorInfo[] -> insert;
          #);
        
        cleanUp:
          (# 
          do scan
               (# 
               do current.dispose;
               #);
          #);
     #);
   
   interfaceObjects: @hashTable
     (# element:: interfaceObject;
        hashfunction:: (# do e.interfaceObjectID -> value #);
        equal:: (# do (left.interfaceObjectID=right.interfaceObjectID) -> value; #);
        rangeInitial::< (# do 317 -> value; INNER #);
        
        findByID: @
          (# ID: @integer;
             foundObject: ^element;
             fi: @findIndexed
               (# predicate:: (# do current.interfaceObjectID = ID -> value #);
                  notFound:: (# do NONE -> foundObject[]; #);
               do current[] -> foundObject[];
               #);
          enter ID
          do ID -> fi;
          exit foundObject[]
          #);
        
        hasObject: @BooleanValue
          (# ID: @Integer;
             anInterfaceObject: ^interfaceobject;
             fi: @findIndexed
               (# predicate:: (# do current.interfaceObjectID = ID -> value #);
               do true -> value;
               #);
          enter anInterfaceObject[]
          do false -> value; 
             anInterfaceObject.interfaceObjectID -> ID;
             ID -> fi;
          #);
     #);
   
   windows: @hashTable
     (# element::< window;
        hashfunction:: (# do e.interfaceObjectID -> value #);
        equal:: (# do (left.interfaceObjectID=right.interfaceObjectID) -> value; #);
        rangeInitial::< (# do 31 -> value; INNER #);
        
        findByID:
          (# ID: @integer;
             foundObject: ^element;
             fi: @findIndexed
               (# predicate:: (# do current.interfaceObjectID = ID -> value #);
                  notFound:: (# do NONE -> foundObject[]; #);
               do current[] -> foundObject[];
               #);
          enter ID
          do ID -> fi;
          exit foundObject[]
          #);
        
        hasWindow: @BooleanValue
          (# ID: @Integer;
             aWindow: ^window;
             fi: @findIndexed
               (# predicate:: (# do current.interfaceObjectID = ID -> value #);
               do true -> value;
               #);
          enter aWindow[]
          do false -> value; 
             aWindow.interfaceObjectID -> ID;
             ID -> fi;
          #);
        
        cleanUp:
          (# 
          do scan
             (# 
             do (if current.isOpen then
                    (current.contents).scan
                    (# 
                    do (if current.theBkColorInfo<>NONE then
                           current.theBkColorInfo 
                             -> this(guienv).private.colors.remove;
                       if);
                    #);
                if);
             #);
          #);
     #); (* End of windows *)
   
   win32Menubars: @linkedList
     (# element:: win32Menubar;
        
        cleanUp:
          (# 
          do scan
             (# do current.close; #);
          #);
     #);
   
   menus: @list
     (# element::< menu;
        findByID:
          (# ID: @integer;
             e: ^element;
             found: @boolean;
          enter ID
          do l: scan
               (#
               do lm: 
                    current.private.win32Menus.scan
                    (# 
                    do (if current.interfaceObjectID=ID then
                           true -> found;
                           leave lm;
                       if);
                    #);
                  (if found then
                      current[] -> e[];
                      leave l;
                  if);
               #);
          exit e[]
          #);
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete
             (# empty::
                  (# 
                  do true -> continue;
                     (none,msg[],none) -> alertUser;
                  #);
             #);
          #);
        cleanUp:
          (# 
          do win32Menubars.cleanUp;
             scan
             (# 
             do current.private.win32Menus.scan
                (# 
                do (if (current.interfaceObjectID -> IsMenu)<>0 then 
                       current.close;
                   if);
                #);
             #);
          #);
     #);
   textStyles: @linkedList
     (# element::< textStyle;
        cleanUp:
          (# 
          do this(textStyles).scan
               (# 
               do (if (current.textStyleID<>0) then
                      (if (current.textStyleID -> DeleteObject)=0 then
                          'Failed to delete font' -> Screen.putline;
                      if);
                  if);
               #);
          #);
        size:
            (#  count: @integer;
          do this(textStyles).scan
               (# 
               do count + 1 -> count;
               #);
          exit count
           #);
     #);
   sysenv_UIIdle: ^BooleanValue;
#)

-- GUIENVmenuPrivate: descriptor --
(# menuName: ^text;
   menuFather: ^menubar;
   menuEnabled: @boolean;
   menuItems: @list
     (# element::< menuItem;
        findByID:
          (# id: @integer;
             found: ^element;
          enter id
          do theScan: scan
               (#
               do (if id=current.interfaceObjectID then
                      current[] -> found[];
                      leave theScan;
                  if);
               #);
          exit found[]
          #);
     #);
   win32PopupMenu: ^win32Menu;
   win32Menus: @list
     (# element::< win32Menu;
        remove:
          (# e: ^element;
          enter e[]
          do (if (e[] -> has) then
                 e[] -> at -> delete;
             if);
          #);
     #);
     
#)

-- interfaceObjectLib: attributes --
interfaceObjectWindProc:
  (#
  enter private.interfaceObjectWindProc
  exit private.interfaceObjectWindProc
  #);
interfaceObjectCursorHandle:
  (# 
  enter private.interfaceObjectCursorHandle
  exit private.interfaceObjectCursorHandle
  #);
actionList: linkedList
  (# element::< action;
  #);
eventSpec:
  (# type: ##theEventHandler.event;
  #);
eventSpecList: linkedList
  (# element::< eventSpec;
     remove:
       (# ev: ##theEventHandler.event;
       enter ev##
       do l: scan
            (# 
            do (if (current.type## = ev##) then
                   current[] -> delete;
                   leave l;
               if);
            #);
       #);
     has: booleanValue
       (# ev: ##theEventHandler.event;
       enter ev##
       do false -> value;
          l: scan
            (# 
            do (if (ev## <= current.type##) then
                   true -> value;
                   leave l;
               if);
            #);
       #);
  #);

interfaceObjectID:
  (#
  enter private.interfaceObjectID
  exit private.interfaceObjectID
  #);
isOpen:
  (# 
  enter private.isOpen
  exit private.isOpen
  #);
theMethods:
  (#
  enter private.methods[]
  exit private.methods[]
  #);
doAddToList:
  (#
  enter private.doAddToList
  exit private.doAddToList
  #);
interfaceObjectMethods:
  (# dispatchMessage:<
       (# info: ^messageInfo;
       do <<SLOT interfaceObjectMethodsdispatchMessage: descriptor>>;
       #);
  #);
dispatchMessage: 
  (#
  do <<SLOT GUIENVinterfaceObjectdispatchMessage: descriptor>>;
  #);
interfaceObjectUpdateRgn:
  (# 
  enter private.interfaceObjectUpdateRgn
  exit private.interfaceObjectUpdateRgn
  #);

-- GUIENVinterfaceObjectPrivate: descriptor --
(# interfaceObjectUpdateRgn: @integer;
   interfaceObjectID: @integer;
   isOpen, doAddToList: @boolean;
   methods: ^interfaceObjectMethods;
   beforeActions,afterActions: ^actionList;
   disabledEvents: ^eventSpecList;
   interfaceObjectWindProc: @integer; (* address of window procedure. Does 
                                       * only contain a valid value
                                       * for windowItems that are subclasses 
                                       * of standard window controls.
                                       *)
   interfaceObjectCursorHandle: @integer;
#)


-- windowLib: attributes --
callOnActivate:
  (# 
  enter private.callOnActivate
  exit private.callOnActivate
  #);
windowMethods: interfaceObjectMethods
  (# dispatchMessage::<
       (#
       do <<SLOT GUIENVwindowMethodsdispatchMessage: descriptor>>;
       #);
  #);
windowFloating:
  (#
  enter private.windowFloating
  exit private.windowFloating
  #);
windowTarget:
  (#
  enter private.windowTarget[]
  exit private.windowTarget[]
  #);
windowContents:
  (# 
  enter private.windowContents[]
  exit private.windowContents[]
  #);
windowMenuBar:
  (#
  enter private.windowMenuBar[]
  exit private.windowMenuBar[]
  #);
windowMinSize:
  (#
  enter private.windowMinSize
  exit private.windowMinSize
  #);
windowMaxSize:
  (#
  enter private.windowMaxSize
  exit private.windowMaxSize
  #);
uniqueID: integerValue
  (#
  do private.lastID + 1 -> value -> private.lastID;
  #);

windowDefaultButton:  (* les *)
  (#
  enter private.windowDefaultButton[]
  exit private.windowDefaultButton[]
  #);
windowFrame:
    (#
    enter private.windowFrame
    exit private.windowFrame
    #);
windowStyle:
  (# 
  enter private.windowStyle
  exit private.windowStyle
  #);
windowExStyle:
  (# 
  enter private.windowExStyle
  exit private.windowExStyle
  #);

-- GUIENVwindowPrivate: descriptor --
(# windowMenuBar: ^menubar;
   theWin32Menubar: ^win32Menubar;
   
   windowStyle,windowExStyle: @integer;
   backGroundColor: @integer;
   owner: @integer;
   
   iconId: @integer;
   visibleFlag: @boolean;
   callOnActivate: @boolean;
   windowFloating: @boolean;
   windowTarget: ^windowItem;
   lastID: @integer;
   windowDefaultButton: ^windowItem;  (* les *)
   windowFrame: @rectangle;
   windowMinSize,windowMaxSize: @point;
   windowContents: @canvas
     (# eventHandler::<
          (# onMouseDown::<
               (# 
               do this(window).theEventHandler.onMouseDown;
                  inner onMouseDown;
               #);
             onMouseUp::<
               (# 
               do this(window).theEventHandler.onMouseUp;
                  inner onMouseUp;
               #);
             onKeyDown::<
               (# 
               do this(window).theEventHandler.onKeyDown;
                  inner onKeyDown;
               #);
          #);
     #);
#)

-- windowItemLib: attributes --
handleframeChanged:
  (# newFrame,oldFrame: @rectangle;
     thisCanvas: ^canvas; 
     windowID: @integer;
     theNtRect: @ntRECTextR;
     w,h: @integer;
  enter (oldFrame,newFrame)
  <<SLOT GUIENVwindowItemHandleFrameChanged: doPart>>
  #);

(* drawBorder:
     (# whitePen, blackPen: @integer;
        theStyle: @integer;
        drawable: @integer;
        topHdc, bottomHdc: @integer;
        width,height: @integer;
        x,y: @integer;
     enter (topHdc,bottomHdc,theStyle,x,y,width,height)
     do <<SLOT drawborderbody: descriptor>>
 #);
 *)

drawBorder:
  (# theStyle: @integer;
     width,height: @integer;
     x,y: @integer;
     theWindowItem: ^windowItem;
  enter (theWindowItem[], theStyle,x,y,width,height)
  do <<SLOT drawborderbody: descriptor>>
  #);

windowItemMethods: interfaceObjectMethods
  (# dispatchMessage::<
       (#
       do <<SLOT GUIENVwindowItemMethodsdispatchMessage: descriptor>>;
       #);
  #);
(* 060396 /les begin *)
windowItemNotificationMethods:
  (# handleNotification:<
       (# info: ^messageInfo; 
       do currentMessageInfo -> info[];
          INNER handleNotification; 
       #);
  #);
handleNotification:
  (# 
  do (if theNotiMethods<>NONE then
         private.theNotiMethods.handleNotification;
     if);
  #);
theNotiMethods:
  (# 
  enter private.theNotiMethods[]
  exit private.theNotiMethods[]
  #);
(* 060396 /les end *)
callDefaultWindowProc:
    (# info: ^messageInfo;
    <<SLOT GUIENVwindowItemCallDefaultWindowProc: doPart>>
    #);
windowItemHilite:
  (#
  enter private.windowItemHilite
  exit private.windowItemHilite
  #);

windowItemClass:
  (#
  enter private.windowItemClass
  exit private.windowItemClass
  #);
windowItemExStyle:
  (#
  enter private.windowItemExStyle
  exit private.windowItemExStyle
  #);
windowItemStyle:
  (#
  enter private.windowItemStyle
  exit private.windowItemStyle
  #);

windowItemDevice:
  (#
  enter private.windowItemDevice
  exit private.windowItemDevice
  #);
windowItemUpdateRgn:
  (# 
  enter private.windowItemUpdateRgn
  exit private.windowItemUpdateRgn
  #);
windowItemClassStatus:
  (#
  enter private.windowItemClassStatus
  exit private.windowItemClassStatus
  #);
isStandardClass: (# exit 1 #);
isSubClass: (# exit 2 #);
isNoClass: (# exit 3 #);

hit: booleanValue
  (# pt: @point;
     r: @rectangle;
  enter pt
  <<SLOT GUIENVWindowItemHit: doPart>>
  #);
windowItemFrame:
    (#
    enter private.windowItemFrame
    exit private.windowItemFrame
    #);
enabledFlag:
  (#
  enter private.enabledFlag
  exit private.enabledFlag
  #);
hiliteFlag:
  (#
  enter private.hiliteFlag
  exit private.hiliteFlag
  #);
windowitemCursor:
  (#
  enter private.windowItemCursor[]
  exit private.windowItemCursor[]
  #);

theBkColorInfo:
  (# 
  enter private.theBkColorInfo[]
  exit private.theBkColorInfo[]
  #);

-- GUIENVwindowItemPrivate: descriptor --
(# 
   uid: @integer;
   theBkColorInfo: ^colorInfo;
   windowItemHilite,borderVisible: @boolean;
   borderStyle: @integer;
   borderHandledLocally: @boolean;
   windowItemClass: @text;
   windowItemDevice: @integer;
   windowItemUpdateRgn: @integer;
   windowItemExStyle: @integer;
   windowItemStyle: @integer;
   windowItemClassStatus: @integer;
   windowItemFrame: @rectangle;
   visibleFlag,enabledFlag,hiliteFlag: @boolean;
   updateOnResize: @boolean;
   disableDefaultEventHandling: @boolean;
   windowItemCursor: ^cursor;
   theNotiMethods: ^windowItemNotificationMethods; 
#)

-- GUIENVcanvasPrivate: descriptor --
(# children: @list
     (# element::< windowItem;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
        findHitObject:
          (# pt: @point;
             e: ^element;
          enter pt
          do l: scanReverse
               (# where::<
                    (#
                    do (if current.enabledFlag then
                           pt -> current.hit -> value;
                        else
                           false -> value;
                       if);
                    #);
               do current[] -> e[];
                  leave l;
               #);
          exit e[]
          #);
     #);
   selection: @list
     (# element::< windowitem;
     #);
   
#)

-- textStyleLib: attributes --

textStyleID: 
  (#
  enter private.textStyleID
  exit private.textStyleID
  #);
textStyleName:
  (#
  enter private.textStyleName
  exit private.textStyleName
  #);
textStyleSize:
  (#
  enter private.textStyleSize
  exit private.textStylesize
  #);
textStyleFace:
  (#
  enter private.textStyleFace
  exit private.textStyleFace
  #);
create:
  (# height,width,escapement,orientation,weight: @integer;
     italic,underline,strikeOut: @integer;
     charSet,outPrecision,clipPrecision,pitchAndFamily: @integer;
     quality: @integer;
     face: @text;
     error: @integer;
  <<SLOT GUIENVtextStyleCreate: doPart>>
  #);
dispose:
  (# <<SLOT GUIENVtextStyleDispose: doPart>> #);

-- GUIENVtextStylePrivate: descriptor --
(# textStyleSize,textStyleFace: @integer;
   textStyleID: @integer; (* HFONT *)
   textStyleName: @text;
#)

-- pixmapLib: attributes --

assertInitialized:
  (# 
  do (if private.handleToPixmap = 0 then
         exception
         (#
         do 'Accesing a pixmap that are not initialized' -> msg.append;
         #);
     if);
  #);


-- pixmapPrivate: descriptor --
(#
   handleToPixmap: @integer;
   handleToDib: @integer;
   isIcon: @boolean;
   width,height: @integer;
   depth: @integer;
   isFromResource: @boolean;
   
   bitMapGetWidth: external
     (# hBitmap: @integer;
        width: @integer;
     enter hBitmap
     do 'bitMapGetWidth' -> callC
     exit width
     #);

   bitMapGetHeight: external
     (# hBitmap: @integer;
        height: @integer;
     enter hBitmap
     do 'bitMapGetHeight' -> callC
     exit height
     #);

#)

