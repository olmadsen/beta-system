ORIGIN 'guienv_ntiprivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-96
 *       All rights reserved.
 *)

BODY 'windowbody';
BODY 'drawborderbody';
BODY 'drawseparatorbody';
BODY 'win32menubarbody';
MAKE default 'external/guienv_nti.make';
OBJFILE default '$/guienv_nti.obj';
INCLUDE '../linkedlist';
INCLUDE '../../controls';
INCLUDE '../../graphics';
INCLUDE 'scrolllists_ntibody';
INCLUDE 'raster_ntiprivate';
INCLUDE '~beta/win32lib/v1.2/winbase';
INCLUDE '~beta/win32lib/v1.2/devicecapabilities';
INCLUDE '~beta/win32lib/v1.2/dcmanagement';
INCLUDE '~beta/win32lib/v1.2/winuserconsts';
INCLUDE '~beta/win32lib/v1.2/bitmapsupport';
INCLUDE '~beta/win32lib/v1.2/wingdi';
INCLUDE '~beta/win32lib/v1.2/wingdiconsts';
INCLUDE '~beta/win32lib/v1.2/windowmanagement';
INCLUDE '~beta/win32lib/v1.2/mousecursorsupport';
INCLUDE '~beta/win32lib/v1.2/keyboardinputsupport';
INCLUDE '~beta/win32lib/v1.2/messageboxsupport';
INCLUDE '~beta/win32lib/v1.2/win32apiinit';
INCLUDE '~beta/win32lib/v1.2/menusupport';
INCLUDE '~beta/win32lib/v1.2/windowsmisc';
INCLUDE '~beta/win32lib/v1.2/systemmetrics';
INCLUDE '~beta/win32lib/v1.2/clipboardmanager';
INCLUDE '~beta/sysutils/v1.5/cstring';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '~beta/basiclib/v1.5/file';
INCLUDE 'resizewindowitem';
INCLUDE 'win32menubarprivate';
INCLUDE 'guienvattributes';


-- GUIENVreportLastError: doPart --
do GetLastError -> error;
   (if error<>0 then
       '***Error: ' -> screen.putText; error -> screen.putInt; 
       ' In: ' -> screen.puttext; msg[] -> screen.putline;
   if);

-- GUIENVStandardWindowProc: descriptor --
(# theInterfaceObject: ^interfaceObject;
   info: ^messageInfo;
   doProcess: @boolean;
   longInt: @CStruct
     (#	ByteSize:: (# do 4 -> Value; #);
        loWord: signedShort (# Pos:: (# do 0 -> Value; #); #);
        hiWord: signedShort (# Pos:: (# do 2 -> Value; #); #);
     enter R[1]
     exit R[1]
     #);
do windowHandle -> private.interfaceObjects.findByID -> theInterfaceObject[];
   (if message
    //WM_SYSCOLORCHANGE
    //WM_COMMAND 
    //WM_NOTIFY
    //WM_LBUTTONDOWN 
    //WM_MBUTTONDOWN 
    //WM_RBUTTONDOWN 
       
    //WM_COPY
    //WM_CUT
    //WM_PASTE
       
    //WM_LBUTTONUP 
    //WM_MBUTTONUP 
    //WM_RBUTTONUP 
       
    //WM_LBUTTONDBLCLK 
    //WM_MBUTTONDBLCLK 
    //WM_RBUTTONDBLCLK 
       
    //WM_CHAR
    //WM_KEYDOWN
    //WM_PAINT 
    //WM_ACTIVATE 
    //WM_KILLFOCUS 
    //WM_SETFOCUS 
       
    //WM_MOVE 
    //WM_SIZE 
    //WM_HSCROLL 
    //WM_VSCROLL 
    //WM_INITMENUPOPUP 
    //WM_GETMINMAXINFO 
    //WM_DESTROY 
    //WM_CLOSE
    //WM_SETCURSOR then 
       true -> doProcess;
       (if doProcess then
           &messageInfo[] -> info[] -> pushMessageInfo;
           wParam -> longInt;
           longInt.hiWord -> info.wParam.hiWord;
           longInt.loWord -> info.wParam.loWord;
           wParam -> info.wParam;
           lParam -> longInt;
           longInt.hiWord -> info.lParam.hiWord;
           longInt.loWord -> info.lParam.loWord;
           lParam -> info.lParam;
           message -> info.message;
           GetMessagePos -> longInt;
           (longInt.loWord,longInt.hiWord) -> info.where;
           getMessageTime -> info.time;
           
           (if theInterfaceObject[]<>none then
               theInterfaceObject.dispatchMessage;
           if);
           
           popMessageInfo;
           (if info.handled then
               info.result -> result;
            else
               (windowHandle,message,wParam,lParam) -> DefWindowProc -> result;
           if);
        else
           (if theInterfaceObject[]<>none then
               (if theInterfaceObject.interfaceObjectWindProc=0 then
                   (windowHandle,message,wParam,lParam) -> DefWindowProc -> result;
                else
                   (theInterfaceObject.interfaceObjectWindProc,windowHandle,message,wParam,lParam) 
                     -> CallWindowProc -> result;
               if);
            else
               (windowHandle,message,wParam,lParam) -> DefWindowProc -> result;
           if);
       if);
    else 
       (if theInterfaceObject[]<>none then
           (if theInterfaceObject.interfaceObjectWindProc=0 then
               (windowHandle,message,wParam,lParam) -> DefWindowProc -> result;
            else
               (theInterfaceObject.interfaceObjectWindProc,windowHandle,message,wParam,lParam) 
                 -> CallWindowProc -> result;
           if);
        else
           (windowHandle,message,wParam,lParam) -> DefWindowProc -> result;
       if);
   if);
   none -> theInterfaceObject[];
#)

-- GUIENVaddInterfaceObject: doPart --
do (if not (theObject.interfaceObjectID=0) then
      (if not (theObject[] -> private.interfaceObjects.hasObject) then
          theObject[] -> private.interfaceObjects.insert;
      else 
        (# msg: @text;
        do 'Warning: trying to add interfaceObject twice. Pattern name: ' -> msg.append;
           theObject[] -> getPatternName -> msg.append;
           (NONE,msg[],NONE) -> alertUser;
        #);
     if);
   if);

-- GUIENVremoveInterfaceObject: doPart --
do (if not (theObject.interfaceObjectID=0) then
      (if theObject[] -> private.interfaceObjects.hasObject then
          theObject[] -> private.interfaceObjects.delete;
      if);
   if);

-- GUIENVaddWindow: doPart --
do (if not (theWindow[] -> private.windows.hasWindow) then
        theWindow[] -> private.windows.insert;
    if);

-- GUIENVremoveWindow: doPart --
do (if theWindow[] -> private.windows.hasWindow then
       theWindow[] -> private.windows.delete;
   if);

-- GUIENVwindowsMakeModal: doPart  --
do private.windows.scan
    (# windowID: @integer;
    do current.interfaceObjectID -> windowID;
       (if windowID<>ID then 
           (if windowID<>0 then
               (windowID,0) -> EnableWindow;
               (if current.floating then
                   (windowID,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE + SWP_NOACTIVATE) 
                     -> SetWindowPos;
               if);
           if);
       if);
    #);

-- GUIENVwindowsRemoveModal: doPart --
do private.windows.scan
    (# windowID: @integer;
    do current.interfaceObjectID -> windowID;
       (if windowID<>0 then
           (windowID,1) -> EnableWindow;
           (if current.floating then
               (windowID,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE + SWP_NOACTIVATE) 
                 -> SetWindowPos;
           if);
       if);
    #);

-- GUIENVterminateBody: descriptor --
(#
do cleanUp;
   Stop;
#)

-- GUIENVsetTheMenubar: descriptor --
(#
do theMenubar[] -> uienvTheMenubar;
#)

-- GUIENVgetTheMenubar: descriptor --
(#
do uienvTheMenubar -> theMenubar[];
#)

-- interfaceObjectMethodsdispatchMessage: descriptor --
(# 
do currentMessageInfo -> info[];
   (if doTrace then
       this(interfaceObject)[] -> getPatternName -> screen.putText;
       ': ' -> screen.putText;
       info.message -> screen.putInt; screen.newLine;
   if);
   inner dispatchMessage;
#)

-- GUIENVinterfaceObjectdispatchMessage: descriptor --
(#
do (if private.methods[]<>none then
       private.methods.dispatchMessage;
   if);
#)

-- GUIENVinterfaceObjectEvent: descriptor --
(#
do (if not (this(event).struc -> eventDisabled) then
       (if private.beforeActions[]<>None then
           private.beforeActions.scan
           (# 
           do (if (current.eventType## >= this(event).struc) then
                  this(event)[] -> current;
              if);
           #);
       if);
       inner event;
       (if private.afterActions[]<>None then
           private.afterActions.scan
           (# 
           do (if (current.eventType## >= this(event).struc) then
                  this(event)[] -> current;
              if);
           #);
       if);
   if);
#)

-- GUIENVbasicEventShiftKey: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   ((info.wParam,MK_SHIFT) -> tos'%and') = MK_SHIFT-> value;
#)

-- GUIENVbasicEventAltKey: descriptor --
(# 
do VK_MENU -> isVKeyDown -> value;
#)

-- GUIENVbasicEventMetaKey: descriptor --
(#
do 
#)

-- GUIENVbasicEventControlKey: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   ((info.wParam,MK_CONTROL) -> tos'%and') = MK_CONTROL -> value;
#)

(* -- GUIENVbasicEventCapsLock: descriptor --
(#
do VK_CAPITAL -> isVKeyToggled -> value;
 #) 
 *)

-- GUIENVbasicEventButtonState: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   info.button -> value;
#)

-- GUIENVbasicEventWhen: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   info.time -> value;
#)

-- GUIENVbasicEventGlobalPosition: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   info.where -> p;
#)

-- GUIENVbasicEventLocalPosition: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   (info.lParam.loWord,info.lParam.hiWord) -> p;
#)

-- GUIENVmouseEventDoubleClick: descriptor --
(#
do doubleClickPossible -> value;
#)

-- GUIENVkeyEventCh: descriptor --
(# info: ^messageInfo;
do currentMessageInfo -> info[];
   info.wParam -> theChar;
   (if theChar
    //VK_LEFT   then ASCII.fs -> theChar;
    //VK_UP     then ASCII.rs -> theChar;
    //VK_RIGHT  then ASCII.gs -> theChar;
    //VK_DOWN   then ASCII.us -> theChar;
    //VK_DELETE then ASCII.del->theChar;
   if);
#)

-- GUIENVmouseDownDelay: descriptor --
(# ticks: @integer;
   start: @integer;
do GetTickCount -> start;
   l:
     (if mouse.buttonState=buttonState then
         GetTickCount -> ticks;
         (if ((ticks - start) < period) then
             restart l;
          else
             inner delay;
         if);
     if);
#)

-- GUIENVupdateRect: doPart --
do (# hRgn: @integer;
      getrgnboxres: @integer;
      theNtRectPtr: @integer;
      NULLREGION: (# exit 1 #);
   do &rectangle[] -> value[]; 
      (if interfaceObjectUpdateRgn<>-1 then
          16 -> malloc -> theNtRectPtr;
          (interfaceObjectUpdateRgn,theNtRectPtr) -> GetRgnBox -> getrgnboxres;
          
          (if getrgnboxres<>NULLREGION then 
              theNtRectPtr -> getRectFromNtRectPtr -> value;
          if);
          theNtRectPtr -> free;
          (* hRgn -> DeleteObject; *)
      if);
   #);
   
   (* this(guienv).private.damaged[] -> value[]; *)      

-- interfaceObjectLib: attributes --

eventDisabled: booleanValue
  (# ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]=none then
         false -> value;
      else
         ev## -> private.disabledEvents.has -> value;
     if); 
  #);
addDisabledEvent:
  (# e: ^eventSpec;
     ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]=none then
        &eventSpecList[] -> private.disabledEvents[];
     if);
     (if not (ev## -> private.disabledEvents.has) then
         &eventSpec[] -> e[];
         ev## -> e.type##;
         e[] -> private.disabledEvents.append;
     if);
  #);
removeDisabledEvent:
  (# ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]<>none then
         ev## -> private.disabledEvents.remove;
     if);
  #);


-- GUIENVinterfaceObjectPrependAction: descriptor --
(#
do  (if private.beforeActions[]=none then
       &actionList[] -> private.beforeActions[];
   if);
   (if not (theAction[] -> private.beforeActions.member) then
       theAction[] -> private.beforeActions.prepend;
   if);
#)

-- GUIENVinterfaceObjectAppendAction: descriptor --
(#
do (if private.afterActions[]=none then
       &actionList[] -> private.afterActions[];
   if);
   (if not (theAction[] -> private.afterActions.member) then
       theAction[] -> private.afterActions.append;
   if);
#)

-- GUIENVinterfaceObjectDeleteAction: descriptor --
(#
do (if private.beforeActions[]<>none then
       theAction[] -> private.beforeActions.delete;
   if);
   (if private.afterActions[]<>none then
       theAction[] -> private.afterActions.delete;
   if);
#)

-- GUIENVintefaceObjectCreate: descriptor --
(#
do &interfaceObjectMethods[] -> theMethods;
   true -> doAddToList;
   inner create;
#)

-- GUIENVinterfaceObjectOpen: descriptor --
(# openTwiceException: exception
     (# 
     do 'Attempt to open interfaceobject twice.' -> msg;
     #);
   (* theMenu: @menu; *)
do (if not private.isOpen then              
       true -> private.isOpen;
       create;
       (if doAddToList then
           this(interfaceObject)[] -> addInterfaceObject; 
       if);
       inner open;
    else
       openTwiceException;
    if);
#)

-- GUIENVinterfaceObjectClose: descriptor --
assertOpen
(# location:: (# do 'InterfaceObject.close' -> t[] #);
do inner close;
   (if doAddToList then
       this(interfaceObject)[] -> removeInterfaceObject;
   if);
   false -> private.isOpen;
#)

-- GUIENVenableEventType: descriptor --
(#
do ev## -> removeDisabledEvent;
#)

-- GUIENVdisableEventType: descriptor --
(#
do ev## -> addDisabledEvent;
#)

-- GUIENVinterfaceObjectGetLayout: descriptor --
(#
do 'GUIENVinterfaceObjectGetLayout: Not implemented !!!' -> screen.putline;
#)

-- GUIENVinterfaceObjectPutLayout: descriptor --
(#
do 'GUIENVinterfaceObjectPutLayout: Not implemented !!!' -> screen.putline;
#)

-- GUIENVinterfaceObjectException: descriptor --
(#
do 'interfaceobject-exception for ' -> msg.putText;
   THIS(interfaceObject)[] -> getPatternName -> msg.putText;
   msg.newline;
   inner interfaceObjectException;
#)

-- GUIENVnotOpenedException: descriptor --
(#
do 'Attempt to use '''->msg.puttext;
   (if location[]<>NONE then
       location[]->msg.puttext;
       ''' in ''' -> msg.puttext;
   if);
   THIS(interfaceobject)[] -> getpatternname -> msg.puttext;
   ''' before calling ''open''' -> msg.putline;
   inner notOpenedException;
#)

-- win32MenuLib: attributes --
popup:
  (# 
  enter private.popup
  exit private.popup
  #);

processWin32MenuSelect:
  (# id: @integer;
     handled: @boolean;
     theMenuItem: ^theMenu.menuitem;
     theWin32MenuItem: ^win32Menuitem;
  enter id
  do id -> getItemById -> theWin32MenuItem[];
     (if theWin32MenuItem[]=none then
         false -> handled;
      else
         theWin32MenuItem.theMenuItem[]  -> theMenuItem[];
         (if theMenuItem[]=none then
             false -> handled;
          else
             theMenuItem.theEventHandler.onSelect;
             true -> handled;
         if);
     if);
  exit handled
  #);

getItemByID:
  (# id: @integer;
     i: @integer;
     theWin32MenuItem: ^win32Menuitem;
  enter id
  do l: private.win32MenuItems.scan
       (# 
       do (if current.interfaceObjectID=id then
              current[] -> theWin32MenuItem[];
              leave l;
          if);
       #);
  exit theWin32MenuItem[]
  #);

getItemByNumber:
  (# position: @integer;
     i: @integer;
     theWin32MenuItem: ^win32Menuitem;
  enter position
  do
     l: private.win32MenuItems.scan
       (# 
       do i + 1 -> i;
          (if (i = position) then
              current[] -> theWin32MenuItem[];
              leave l;
          if);
       #);
  exit theWin32MenuItem[]
  #);

setKey:
  (# position: @integer;
     key: @char;
     theWin32MenuItem: ^win32Menuitem;
     t: @text;
  enter (position,key)
  do position -> getItemByNumber -> theWin32MenuItem[];
     (if theWin32MenuItem[]<>NONE then
         theWin32MenuItem.updateMenuitem;
         theWin32MenuItem.updateAccTable; 
     if);
  #);
setName:
  (# position: @integer;
     name: ^text;
     theWin32MenuItem: ^win32Menuitem;
  enter (position,name[])
  do position -> getItemByNumber -> theWin32MenuItem[];
     (if theWin32MenuItem[]<>NONE then
         theWin32MenuItem.updateMenuitem;
     if);
  #);
setChecked:
  (# position: @integer;
     checked: @boolean;
     theWin32MenuItem: ^win32Menuitem;
  enter (position,checked)
  do position -> getItemByNumber -> theWin32MenuItem[];
     (if theWin32MenuItem[]<>NONE then
         checked -> theWin32MenuItem.checked;
         theWin32MenuItem.updateMenuitem;
     if);
  #);
setSubMenu:
  (# position: @integer;
     theWin32MenuItem: ^win32Menuitem;
     theMenu: ^menu;
     result: @integer;
     
     noOfMenuItems: @integer;
     
  enter(position,theMenu[])
  do position -> getItemByNumber -> theWin32MenuItem[];
     (if theWin32MenuItem[]<>NONE then
         (if theWin32MenuItem.theWin32Submenu[]<>none then
             (if theWin32MenuItem.theWin32Submenu.isOpen then
                 theWin32MenuItem.theWin32Submenu.close;
             if);
         if);
         (if theMenu[]=none then
             none -> theWin32MenuItem.theWin32Submenu[];
             theWin32MenuItem.updateMenuItem;
          else
             &win32Menu[] -> theWin32MenuItem.theWin32Submenu[];
             theMenu[] -> theWin32MenuItem.theWin32SubMenu.theMenu[];
             this(win32Menu).private.theWin32Menubar[] 
               -> theWin32MenuItem.theWin32SubMenu.private.theWin32Menubar[];
             theWin32MenuItem.theWin32SubMenu.open;
             theWin32MenuItem.updateMenuItem;
         if);
     if);
  #);
win32Menuitem: interfaceObject
  (# theMenuitem: ^theMenu.menuItem;
     theWin32SubMenu: ^win32Menu;
     checked: @boolean;
     name: ^text;
     result: @integer;
     open::
       (# 
          create::
            (# 
            do false -> doAddToList;
               uniqueMenuItemID -> interfaceObjectID -> theMenuitem.interfaceObjectID;
               theMenuitem.name -> name[];
               name.copy -> name[];
               '&' -> name.prepend;
               (if theMenuItem.key=0 then
                else
                   '\tCtrl+' -> name.append; theMenuItem.key -> name.put;
               if);
               (if theMenuitem.menuitemIsSeparator then
                   (this(win32Menu).interfaceObjectID,MF_SEPARATOR,interfaceObjectID,name) 
                     -> AppendMenu -> result;
                   (if result=0 then
                       'menuAppend(1) failed!! Error: ' -> screen.puttext;
                       GetLastError -> screen.putint; screen.newline;
                   if);
                else
                   (if theMenuitem.menuItemSubMenu=none then
                       (this(win32Menu).interfaceObjectID,MF_STRING,interfaceObjectID,name) 
                         -> AppendMenu -> result;
                       (if result=0 then
                           'menuAppend(2) failed!! Error: ' -> screen.puttext;
                           GetLastError -> screen.putint; screen.newline;
                       if);
                    else
                       &win32Menu[] -> theWin32Submenu[];
                       theMenuitem.menuItemSubMenu -> theWin32SubMenu.theMenu[];
                       this(win32Menu).private.theWin32Menubar[] 
                         -> theWin32SubMenu.private.theWin32Menubar[];
                       theWin32SubMenu.open;
                       (this(win32Menu).interfaceObjectID,MF_POPUP + MF_STRING,theWin32SubMenu.interfaceObjectID,name) 
                         -> AppendMenu -> result;
                       (if result=0 then
                           'menuAppend(3) failed!! Error: ' -> screen.puttext;
                           GetLastError -> screen.putint; screen.newline;
                       if);
                   if);
               if);
               this(win32Menuitem)[] -> this(win32Menu).private.win32Menuitems.append;
               inner create;
            #);
          name: ^text;
       do 
          inner open;
       #);
     close::
       (# deleteAccel: external
            (# hAccelTableOld, cmd: @integer;
               hAccelTableNew: @integer;
            enter (hAccelTableOld, cmd)
            do callC
            exit hAccelTableNew
            #);
          myWindow: ^window;
          myWin32Menubar: ^win32Menubar;
       do (if theMenuItem.position>0 then
              (if theMenuItem.key<>0 then 
                  this(win32Menu).private.theWin32Menubar[] -> myWin32Menubar[];
                  (if myWin32Menubar[]=none then
                      'myWin32Menubar is none'->screen.putline; 
                      'theMenuItem.name: '->screen.puttext; 
                      theMenuItem.name->screen.putline;
                      'theMenuitem.key: '-> screen.puttext; 
                      theMenuItem.key->screen.put; screen.newline;
                   else
                      (myWin32Menubar.hMenubarAccelTable, this(win32MenuItem).interfaceObjectID) 
                        -> deleteAccel -> myWin32Menubar.hMenubarAccelTable;
                      myWin32Menubar.theWindow[] -> myWindow[];
                      (if GetActiveWindow=myWindow.interfaceObjectID then
                          myWin32Menubar.hMenubarAccelTable -> hAccelTable;
                      if);
                  if);
              if);
              (if theWin32Submenu[]<>NONE then
                  (if theWin32Submenu.isOpen then
                      theWin32Submenu.close;
                  if);
              if);
          if);
       #);
     
     win32MenuItemIsSeparator:
       (# 
       exit theMenuItem.menuItemIsSeparator
       #);

     updateAccTable:
       (# updateAccelTable: external
            (# hAccelTableOld, fVirt, cmd: @integer;
               key: @char;
               hAccelTableNew: @integer;
            enter (hAccelTableOld, fVirt, key, cmd)
            do callC
            exit hAccelTableNew
            #);
          myWindow: ^window;
          myWin32Menubar: ^win32Menubar;
       do (if theMenuItem.position>0 then
              (if theMenuItem.key=0 then else
                  this(win32Menu).private.theWin32Menubar[] -> myWin32Menubar[];
                  (if myWin32Menubar[]=none then
                      'myWin32Menubar is none' -> screen.putline;
                      'theMenuItem.name: '->screen.puttext; 
                      theMenuItem.name->screen.putline;
                      'theMenuitem.key: '->screen.puttext; 
                      theMenuItem.key->screen.put;
                      screen.newline;
                   else
                      (myWin32Menubar.hMenubarAccelTable,FCONTROL,theMenuItem.Key, 
                      this(win32MenuItem).interfaceObjectID) 
                        -> updateAccelTable -> myWin32Menubar.hMenubarAccelTable;
                      myWin32Menubar.theWindow[] -> myWindow[];
                      (if GetActiveWindow=myWindow.interfaceObjectID then 
                          myWin32Menubar.hMenubarAccelTable -> hAccelTable;
                      if);
                  if);
              if);
          if);
       #);
     updateMenuItem:
       (# result: @integer;
          flags: @integer;
          name: ^text;
          ModifyMenu: external
            (#
               in0: @integer; (* HMENU *)
               in1: @integer; (* UINT *)
               in2: @integer; (* UINT *)
               in3: @integer; (* UINT *)
               in4: [1] @char; (* LPCSTR *)
               out: @integer; (* BOOL *)
            enter (in0,in1,in2,in3,in4)
            do 'ModifyMenuA' -> callStd;
            exit out
            #);
          hSubMenu: @integer;
          noOfItemsInSubmenu: @integer;
          
       do (if (theMenuItem.position>0) then
              (if not win32MenuItemIsSeparator then
                  theMenuItem.name -> name[];
                  name.copy -> name[];
                  '&' -> name.prepend;
                  (if theMenuItem.key=0 then
                   else
                      '\tCtrl+' -> name.append; theMenuItem.key -> name.put;
                  if);
                  
                  (if theWin32SubMenu[]=none then
                      (if checked then
                          MF_CHECKED -> flags;
                      if);
                      (this(win32Menu).interfaceObjectID,theMenuItem.position - 1,
                      MF_BYPOSITION + MF_STRING + flags,
                      interfaceObjectID,name) -> ModifyMenu -> result;
                      (if result=0 then
                          'updateMenuItem(1), modifyMenu failed!! Error: ' -> screen.putText;
                          GetLastError -> screen.putint; screen.newline;
                          'Name of menuitem: ' -> screen.puttext; 
                          name[] -> screen.putline;
                      if);
                   else
                      (this(win32Menu).interfaceObjectID,theMenuItem.position - 1) -> GetSubMenu -> hSubMenu;
                      (this(win32Menu).interfaceObjectID,theMenuItem.position - 1,MF_BYPOSITION)
                        -> RemoveMenu -> result;
                      (if result=0 then
                          'Could not remove submenu in modifymenuitem. Error: ' -> screen.puttext;
                          GetLastError -> screen.putint; screen.newline;
                      if);
                      
                      (this(win32Menu).interfaceObjectID,theMenuItem.position - 1,
                      MF_BYPOSITION + MF_POPUP + MF_STRING, theWin32SubMenu.interfaceObjectID,name) 
                        -> InsertMenu -> result;
                      (if result=0 then
                          'InsertMenu failed in modifymenuitem. Error: ' -> screen.puttext;
                          GetLastError -> screen.putint; screen.newline;
                      if);
                  if);
              if);
          if);
       #);
     enabled:
       (# value: @boolean;
          enableFlag: @integer;
          result: @integer;
          noOfItems: @integer;
       enter value
       do (if not win32MenuItemIsSeparator then
              (if (theMenuItem.position>0) then
                  (if value then
                      MF_ENABLED -> enableFlag;
                   else
                      MF_GRAYED -> enableFlag;
                  if);
                  (this(win32Menu).interfaceObjectID,theMenuItem.position - 1,MF_BYPOSITION + enableFlag) 
                    -> EnableMenuItem -> result;
                  (if result//MF_ENABLED//MF_DISABLED//MF_GRAYED then else
                      'enable(1), EnableMenuItem failed!! Error: ' -> screen.puttext;
                      GetLastError -> screen.putint; screen.newline;
                      'theMenuItem.name, theMenu.name: ' -> screen.puttext; 
                      theMenuitem.name -> screen.putline;
                      this(win32Menu).theMenu.name -> screen.putline;
                  if);
               else
                  '**WARNING: enabled: theMenuItem.position=0!!' -> screen.putline;
              if);
          if);
       #); (* end of enabled *)
  #); (* end of win32Menuitem *)

-- GUIENVwin32Menuappend: doPart --
do (# theWin32MenuItem: ^win32Menuitem;
      result: @boolean;
      name: ^text;
   do &win32Menuitem[] -> theWin32MenuItem[];
      theItem[] -> theWin32MenuItem.theMenuitem[];
      theWin32MenuItem.open;
      theWin32MenuItem.updateAccTable; (* 20-1-95 *)
      (* theItem.name -> name[];
      name.copy -> name[];
       '&' -> name.prepend; *)
   #);
   
-- GUIENVwin32MenuDelete: doPart --
do (# theWin32Item: ^win32Menuitem;
      result: @integer;
   do l: private.win32MenuItems.scan
      (# 
      do (if theItem[]=current.theMenuitem[] then
             current[] -> theWin32Item[];
             leave l;
         if);
      #);
      (if (theWin32Item[]<>none) then
          theWin32Item[] ->  private.win32MenuItems.remove;
          theWin32Item.close;
          (interfaceObjectID,theWin32Item.theMenuItem.position - 1,MF_BYPOSITION)  
            -> RemoveMenu -> result;
          (if result=0 then
              'menuDelete(1), modifyMenu failed!! Error: ' -> screen.puttext;
              GetLastError -> screen.putint; screen.newline;
              'Name of menuitem: ' -> screen.puttext; 
              theWin32Item.theMenuItem.name -> screen.putline;
          if);
      if);
   #)

-- GUIENVwin32MenuCreate: doPart --
do false -> doAddToList;
   (if popup then
       CreatePopupMenu -> interfaceObjectID;
   else
      CreateMenu -> interfaceObjectID;
  if);
  theMenu.scan
   (# theWin32Menuitem: ^win32Menuitem;
   do &win32Menuitem[] -> theWin32Menuitem[];
      current[] -> theWin32Menuitem.theMenuitem[];
      theWin32Menuitem.open;
      theWin32MenuItem.updateAccTable; (* 21-1-95 *)
   #);
   this(win32Menu)[] -> theMenu.private.win32Menus.append;
   inner create;


-- GUIENVwin32MenuOpen: doPart --
do inner open;
   
-- GUIENVwin32MenuInit: doPart --
do (if this(win32Menu).isOpen then
       (if theMenu.menuEnabled then
           private.win32MenuItems.scan
           (#
           do current.theMenuitem.theEventHandler.onStatus -> current.enabled; 
           #);
        else
           private.win32MenuItems.scan
           (# do false -> current.enabled; #);                       
       if);
    else
       'WARNING: this(win32Menu) is not open in win32Menu.init' -> screen.putline;
   if);
   
-- GUIENVwin32MenuClose: doPart --
do (# result: @integer;
   do private.win32Menuitems.scan
      (# 
      do current.close;
      #);
      private.win32Menuitems.clear;
      this(win32Menu)[] -> theMenu.private.win32Menus.remove;
      interfaceObjectID -> DestroyMenu -> result;
      (result,'Win32MenuClose, Destroymenu: ') -> checkNullError;
      0 -> interfaceObjectID;
   #);

   
-- GUIENVwin32MenuPrivate: descriptor --
(# win32MenuItems: @list
     (# element:: win32Menuitem;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
     #);
   position: @integer;
   popup: @boolean;
   theWin32menubar: ^win32Menubar;
#)



-- menubarLib: attributes --
menubarInsertMenu:
  (# theMenu,after: ^menu;
  enter (theMenu[],after[])
  do (if not (theMenu[] -> private.menuBarMenus.has) then
         (if (after[] -> private.menuBarMenus.has) then
             (theMenu[], after[] -> private.menuBarMenus.at)
               -> private.menuBarMenus.insertAfter;
         if);
     if);
  #);

menuBarAppendMenu:
    (# theMenu: ^menu;
    enter theMenu[]
    do (if not (theMenu[] -> private.menuBarMenus.has) then
            theMenu[] -> private.menuBarMenus.append;
            this(menubar)[] -> theMenu.menuFather;
        if);
    #);
menuBarDeleteMenu:
    (# theMenu: ^menu;
    enter theMenu[]
    do (if (theMenu[] -> private.menuBarMenus.has) then
            theMenu[] -> private.menuBarMenus.at -> private.menuBarMenus.delete;
        if);
    #);

processMenuselect:
    (# id: @integer;
        handled: @boolean;
    enter id
    do theScan: scan
        (#
        do id -> current.processMenuSelect -> handled;
            (if handled then
               leave theScan;
            if);
        #);
    exit handled
    #);

-- GUIENVmenubarAppend: descriptor --
assertOpen
(# location::(# do 'MenuBar.append'->t[] #);
   result: @integer;
   name: ^text;
do (if this(menubar)[]=applicationMenubar then
       theMenu[] -> menuBarAppendMenu;
       private.windows.scan
       (# 
       do theMenu[] -> current.private.theWin32Menubar.insert;
          current.interfaceObjectID -> DrawMenuBar -> result;
       #);
    else
       theMenu[] -> menuBarAppendMenu;
       (if (private.theWin32Menubar[]<>none) then
           theMenu[] -> private.theWin32Menubar.append;
           private.windows.scan
           (# 
           do current.interfaceObjectID -> DrawMenuBar -> result;
           #);
       if);
   if);
#)

-- GUIENVmenubarDelete: descriptor --
assertOpen
(# location:: (# do 'MenuBar.delete' -> t[] #);
   result: @integer;
do theMenu[] -> menuBarDeleteMenu;
   (if this(menubar)[]=applicationMenubar then
       private.windows.scan
       (# 
       do (if current.interfaceObjectID<>0 then
              theMenu[] -> current.private.theWin32Menubar.delete;
              current.interfaceObjectID -> DrawMenuBar -> result;
          if);
       #);
    else
       theMenu[] -> private.theWin32Menubar.delete;
       private.windows.scan
       (# 
       do current.interfaceObjectID -> DrawMenuBar -> result;
       #);
   if);
#)

-- GUIENVmenubarClear: descriptor --
assertOpen
(# location::(# do 'MenuBar.clear'->t[] #);
do private.menubarMenus.scan
   (#
   do current[] -> delete;
   #);
#)

-- GUIENVmenubarAppendMenubar: descriptor --
assertOpen
(# location::(# do 'MenuBar.appendMenuBar'->t[] #);
do theMenubar.scan
   (#
   do current[] -> this(menuBar).append;
   #);
#)

-- GUIENVmenubarReplaceMenubar: descriptor --
assertOpen
(# location::(# do 'MenuBar.replaceMenuBar'->t[] #);
do theMenubar[] -> deleteMenubar;
   replacementMenubar[] -> appendMenubar;
#)

-- GUIENVmenubarDeleteMenubar: descriptor --
assertOpen
(# location::(# do 'MenuBar.deleteMenuBar'->t[] #);
do theMenubar.scan
   (#
   do current[] -> this(menuBar).delete;
   #);
#)

-- GUIENVmenubarScan: descriptor --
assertOpen
(# location::(# do 'MenuBar.scan'->t[] #);
do private.menubarMenus.scan
    (#
    do current[] -> THIS(scan).current[];
       inner scan;
    #);
#)

-- GUIENVmenubarCreate: descriptor --
(#
do false -> doAddToList;
   inner create;
#)

-- GUIENVmenubarOpen: descriptor --
(#
do inner open;
#) 

-- GUIENVmenubarClose: descriptor --
(# 
do inner close;  
   clear;
#)

-- GUIENVmenubarPutLayout: doPart --
do
   
-- GUIENVmenubarGetLayout: doPart --
do

-- GUIENVmenubarPrivate: descriptor --
(#  menubarMenus: @list
     (# element:: Menu;
     #);
   windows: @list
     (# element:: window;
     #);
   theWin32Menubar: ^win32Menubar;
   hMenubarAccelTable: @integer;
#)

-- menuLib: attributes --
win32PopupMenu:
  (# 
  enter private.win32PopupMenu[]
  exit private.win32PopupMenu[]
  #);
menuName:
  (#
  enter private.menuName[]
  exit private.menuName[]
  #);
menuFather:
  (#
  enter private.menuFather[]
  exit private.menuFather[]
  #);
menuEnabled:
  (#
  enter private.menuEnabled
  exit private.menuEnabled
  #);
menuAppendMenuItem:
    (# theMenuItem: ^menuItem;
    enter theMenuitem[]
    do (if not (theMenuitem[] -> private.menuItems.has) then
           theMenuitem[] -> private.menuItems.append;
           private.menuItems.size -> theMenuItem.menuItemPosition;
           private.win32Menus.scan
           (# 
           do theMenuItem[] -> current.append;
           #);
       if);
    #);
menuDeleteMenuItem:
    (# theMenuItem: ^menuItem; thePosition: @integer;
    enter theMenuitem[]
    do theMenuItem.menuItemPosition -> thePosition;
       (if (theMenuitem[] -> private.menuItems.has) then
            theMenuitem[] -> private.menuItems.at -> private.menuItems.delete;
        if);
       private.menuItems.scan
         (#
         do (if (current.menuItemPosition>thePosition) then
                current.menuItemPosition - 1 -> current.menuItemPosition;
            if);
         #);
    #);
processInitMenu:
    (#
    do this(menu).theEventHandler.onSelect;
       this(menu).private.win32Menus.scan
       (# do current.init; #); 
    #);
processMenuSelect:
  (# id: @integer;
     handled: @boolean;
     theMenuItem: ^menuitem;
  enter id
  do l: this(menu).private.win32Menus.scan
       (# 
       do id -> current.processWin32MenuSelect -> handled;
          (if handled then 
              leave l; 
          if);
       #);
  exit handled
  #);

-- GUIENVmenuSetName: descriptor --
assertOpen
(# location::(# do 'Menu.setName'->t[] #);
do theName.copy -> menuName;
#)

-- GUIENVmenuGetName: descriptor --
assertOpen
(# location::(# do 'Menu.getName'->t[] #);
do menuName -> theName[];
   theName.copy -> theName[];
#)

-- menuItemLib: attributes --
menuitemIsSeparator:
  (#
  enter private.menuitemIsSeparator
  exit private.menuitemIsSeparator
  #);
menuitemKey:
  (#
  enter private.menuitemKey
  exit private.menuitemKey
  #);
menuItemName:
  (#
  enter private.menuItemName[]
  exit private.menuItemName[]
  #);
menuItemChecked:
  (#
  enter private.menuItemChecked
  exit private.menuItemChecked
  #);
menuItemSubMenu:
  (#
  enter private.menuItemSubMenu[]
  exit private.menuItemSubMenu[]
  #);
menuItemPosition:
  (#
  enter private.menuItemPosition
  exit private.menuItemPosition
  #);

-- GUIENVmenuitemSetKey: descriptor --
assertOpen
(# location::(# do 'MenuItem.setkey'->t[] #);
do c -> Ascii.upCase -> private.menuitemKey;
   this(menu).private.win32Menus.scan
   (# 
   do (position,c) -> current.setKey;
   #);
#)

-- GUIENVmenuitemGetKey: descriptor --
assertOpen
(# location::(# do 'MenuItem.getKey'->t[] #);
do private.menuitemKey -> c;
#)

-- GUIENVmenuitemSetName: descriptor --
assertOpen
(# location::(# do 'MenuItem.SetName'->t[] #);
do (if t[]=none then
       't is none in menuitemSetName' -> screen.putline;
    else
       t.copy -> private.menuItemName[];
       this(menu).private.win32Menus.scan
       (# 
       do (position,t[]) -> current.setName;
       #);
   if);
#)

-- GUIENVmenuitemGetName: descriptor --
assertOpen
(# location::(# do 'MenuItem.GetName'->t[] #);
do private.menuItemName.copy -> t[];
#)

-- GUIENVmenuitemSetChecked: descriptor --
assertOpen
(# location::(# do 'MenuItem.SetChecked'->t[] #);
do checked -> private.menuItemChecked;
   this(menu).private.win32Menus.scan
   (# 
   do (position,checked) -> current.setChecked;
   #);
#)

-- GUIENVmenuitemGetChecked: descriptor --
assertOpen
(# location::(# do 'MenuItem.GetChecked'->t[] #);
do private.menuItemChecked -> checked;
#)

-- GUIENVsetSubMenu: descriptor --
assertOpen
(# location::(# do 'MenuItem.SetSubmenu'->t[] #);
do (if (theMenu[]<>private.menuItemSubMenu[]) then 
       theMenu[] -> private.menuItemSubMenu[];
       this(menu).private.win32Menus.scan
       (# 
       do (position,theMenu[]) -> current.setSubMenu;
       #);
   if); 
#)

-- GUIENVgetSubMenu: descriptor --
assertOpen
(# location::(# do 'MenuItem.GetSubMenu'->t[] #);
do private.menuItemSubMenu[] -> theMenu[];
#)

-- GUIENVmenuitemPosition: descriptor --
assertOpen
(# location::(# do 'MenuItem.position'->t[] #);
do private.menuItemPosition -> value;
#)

-- GUIENVmenuitemOnStatus: descriptor --
(#
do true -> value;
   inner onStatus;
#)

-- GUIENVmenuitemCreate: descriptor --
(#
do false -> doAddToList;
   inner create;
#)

-- GUIENVmenuitemOpen: descriptor --
(#
do this(menuItem)[] -> getPatternName -> private.menuItemname[];
   inner open;
#)


-- GUIENVmenuitemPutLayout: doPart --
do 'GUIENVmenuitemPutLayout: Not implemented !!!' -> screen.putline;
   
-- GUIENVmenuitemGetLayout: doPart --
do 'GUIENVmenuitemGetLayout: Not implemented !!!' -> screen.putline;

-- GUIENVmenuitemPrivate: descriptor --
(# menuItemChecked: @boolean;
   menuitemKey, menuitemMark: @char;
   menuItemName: ^text;
   menuItemSubMenu: ^menu;
   menuItemPosition: @integer;
   menuitemIsSeparator: @boolean;
#)

-- GUIENVmenuitemAttach: descriptor --
assertOpen
(# location::(# do 'MenuItem.attach'->t[] #);
do (if (theAction[]<>none) then
       none -> theAction.theMenuitem[];
   if);
   anAction[] -> theAction[];
   (if (theAction[]<>none) then
       this(dynamicMenuitem)[] -> theAction.theMenuitem[];
   if);
#)

-- GUIENVmenuitemDetach: descriptor --
assertOpen
(# location::(# do 'MenuItem.detach'->t[] #);
do (if theAction[]<>none then
       none -> theAction.theMenuitem[];
   if);
   none -> theAction[];
#)

-- GUIENVdynamicMenuitemOnStatus: descriptor --
(#
do (if theAction[]=none then
       false -> value;
   else
       theAction.onStatus -> value;
   if);
#)

-- GUIENVdynamicMenuitemOnSelect: descriptor --
(#
do (if theAction[]=none then 
   else
     theAction.onSelect;
   if);
#)

-- GUIENVactionOnStatus: descriptor --
(#
do true -> value;
   inner onStatus;
#)

-- GUIENVseparatorCreate: descriptor --
(#
do inner create;
#)

-- GUIENVseparatorOpen: descriptor --
(#
do true -> menuitemIsSeparator;
   inner open; 
#)

-- GUIENVseparatorClose: descriptor --
(#
do inner close;
#)

-- GUIENVmenuAppend: descriptor --
assertOpen
(# location::(# do 'Menu.append'->t[] #);
   name: ^text; result: @boolean; noOfItems: @integer;
do theMenuitem[] -> menuAppendMenuItem;
#)

-- GUIENVmenuDelete: descriptor --
assertOpen
(# location::(# do 'Menu.delete'->t[] #); 
   result: @boolean; noOfItems: @integer;
do theMenuitem[] -> menuDeleteMenuItem;
   private.win32Menus.scan
   (# 
   do theMenuItem[] -> current.delete;
   #);
#)

-- GUIENVmenuScan: descriptor --
assertOpen
(# location::(# do 'Menu.scan'->t[] #);
do private.menuItems.scan
   (#
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVmenuClear: descriptor --
assertOpen
(# location::(# do 'Menu.clear'->t[] #);
do scan
   (# 
   do current[] -> delete;
   #);
#)

-- GUIENVmenuNoOfMenuitems: descriptor --
assertOpen
(# location::(# do 'Menu.noOfMenuItems'->t[] #);
do  private.menuitems.size -> value;
#)

-- GUIENVmenuPopUp: descriptor --
assertOpen
(# location::(# do 'Menu.popup'->t[] #); 
   translate:
     (# h,v: @integer;
        ntpPtr: @integer;
        interfaceObjID: @integer;
     enter (interfaceObjID,h,v)
     do (h,v) -> makeNtPointPtr -> ntpPtr;
        (interfaceObjID,ntpPtr) -> ClientToScreen;
        ntpPtr -> getPointFromNtPointPtr -> (h,v);
        ntpPtr -> free;
     exit (h,v)
     #);
   
   TrackPopupMenu: external
     (#
        in0: @integer; (* HMENU *)
        in1: @integer; (* UINT *)
        in2: @integer; (* int *)
        in3: @integer; (* int *)
        in4: @integer; (* int *)
        in5: @integer; (* HWND *)
        in6: @integer; (* const RECT FAR* *)
        out: @boolean; (* BOOL *)
     enter (in0,in1,in2,in3,in4,in5,in6)
     do callStd;
     exit out
     #);
   thePopupMenu: ^win32Menu; thePoupMenuID: @integer;
   theWindowItemID: @integer;
   theItem: ^interfaceObject;
   h_root,v_root: @integer; deltaH: @integer;
do (if (popupIn[]<>NONE) and (mouse.buttonState=3) then
       popupIn.interfaceObjectID -> theWindowItemID;
       (if (theWindowItemID<>0) then
           (if private.win32PopupMenu[]=NONE then
               &win32Menu[] -> private.win32PopupMenu[];
               this(menu)[] -> private.win32PopupMenu.theMenu[];               
               true -> private.win32PopupMenu.popup;
               private.win32PopupMenu[] -> thePopupMenu[];
               thePopupMenu.open;
            else
               private.win32PopupMenu[] -> thePopupMenu[];
           if);
           (theWindowItemID,popupAt.h,popupAt.v) 
             -> translate -> (h_root,v_root);
           popupWith -> thePopupMenu.getItemByNumber -> theItem[];
           (if theItem[]<>none then
               SM_CYMENU -> GetSystemMetrics -> deltaH;
               h_root - 10 -> h_root;
               v_root - ((deltaH * popupWith) - deltaH div 2) -> v_root;
           if);
           thePopupMenu.interfaceObjectID -> thePoupMenuID;
           (thePoupMenuID,TPM_LEFTALIGN+TPM_RIGHTBUTTON,
           h_root,v_root,0,theWindowItemID,0) -> TrackPopupMenu;
       if);
   if);
#)

-- GUIENVmenuGetMenuitemByNumber: descriptor --
assertOpen
(# location::(# do 'Menu.getMenuItemByNumber'->t[] #); 
   count: @integer;
do l: private.menuItems.scan
     (#
     do count + 1 -> count;
        (if count=number then
            current[] -> theMenuitem[];
            leave l;
        if);
     #);
#)

-- GUIENVmenuEnable: descriptor --
assertOpen
(# location::(# do 'Menu.enable'->t[] #); 
do true -> menuEnabled;
#)

-- GUIENVmenuDisable: descriptor --
assertOpen
(# location::(# do 'Menu.disable'->t[] #);
do false -> menuEnabled;
#)

-- GUIENVmenuEnabled: descriptor --
assertOpen
(# location::(# do 'Menu.enabled'->t[] #);
do menuEnabled -> value;
#)

-- GUIENVmenuCreate: descriptor --
(#
do false -> doAddToList;
   inner create;
#)

-- GUIENVmenuOpen: descriptor --
(#
do this(menu)[] -> getPatternName -> menuName;
   this(menu)[] -> this(guienv).private.menus.append;
   true -> menuEnabled;
   inner open;
#)

-- GUIENVmenuClose: descriptor --
(# 
do inner close;
   this(menu).private.win32menus.scan
   (# do current.close; #);
   this(menu)[] -> this(guienv).private.menus.remove;
#)
-- GUIENVmenuPutLayout: doPart --
do
   
-- GUIENVmenuGetLayout: doPart --
do

-- GUIENVstandardFileMenuOpen: descriptor --
(#
do 'File' -> name;
   
   newMenuitem.open;
   'New' -> newMenuitem.name;
   newMenuitem[] -> append;
   
   openMenuitem.open;
   'Open...' -> openMenuitem.name;
   openMenuitem[] -> append;
   
   closeMenuitem.open;
   'Close' -> closeMenuitem.name;
   closeMenuitem[] -> append;
   
   saveMenuitem.open;
   'Save as...' -> saveAsMenuitem.name;
   saveAsMenuitem[] -> append;
   
   revertMenuitem.open;
   'Revert' -> revertMenuitem.name;
   revertMenuitem[] -> append;
   
   printMenuitem.open;
   'Print...' -> printMenuitem.name;
   printMenuitem[] -> append;
   
   pageSetUpMenuitem.open;
   'Page setup' -> pageSetUpMenuitem.name;
   pageSetUpMenuitem[] -> append;
   
   quitMenuitem.open;
   'Quit' -> quitMenuitem.name;
   quitMenuitem[] -> append;
   inner open;
    
#)

-- GUIENVstandardEditMenuOpen: descriptor --
(#
do 'Edit' -> name;
   
   undoMenuItem.open;
   'Undo' -> undoMenuItem.name;
   undoMenuItem[] -> append;
   
   cutMenuItem.open;
   'Cut' -> cutMenuItem.name;
   cutMenuItem[] -> append;
   
   copyMenuItem.open;
   'Copy' -> copyMenuItem.name;
   copyMenuItem[] -> append;
   
   pasteMenuItem.open;
   'Paste' -> pasteMenuItem.name;
   pasteMenuItem[] -> append;
   
   clearMenuItem.open;
   'Clear' -> clearMenuItem.name;
   clearMenuItem[] -> append;
#)

-- GUIENVstandardMenubarOpen: descriptor --
(#
do &fileMenu[] -> theFileMenu[];
   (if theFileMenu.struc <> menu## then
       theFileMenu.open;
       theFileMenu[] -> append;
    else
       none -> theFileMenu[];
   if);
   &editMenu[] -> theEditMenu[];
   (if theEditMenu.struc <> menu## then
       theEditMenu.open;
       theEditMenu[] -> append;
    else
       none -> theEditMenu[];
   if);
   inner open;
#)



-- windowItemLib: attributes --


updateArea:
  (# r: ^rectangle;
     theNtRectPtr: @integer; result: @integer;
  enter r[]
  do r[] -> makeNtRectPtr -> theNtRectPtr;
     (interfaceObjectID,theNtRectPtr,1) -> InvalidateRect -> result;
     (result,'updateArea') -> checkNullError;
     theNtRectPtr -> free;
  #);


processFatherFrameChanged:
  (# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
  enter (oldFrame,newFrame)
  do newFrame.size -> delta;
     oldFrame.size -> delta.subTract;
     (if not ((0,0) -> delta.isEqual) then
         windowItemFrame -> chainRect -> itsFrame;
         delta -> chainRect.offset;
         (if not bindLeft then
             chainRect.left -> itsFrame.left;
         if);
         (if bindBottom then
             chainRect.bottom -> itsFrame.bottom;
         if);
         (if bindRight then
             chainRect.right -> itsFrame.right;
         if);
         (if not bindTop then
             chainRect.top -> itsFrame.top;
         if);
         itsFrame -> frame;
     if);
     (oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
  #);

-- GUIENVwindowItemHandleFrameChanged: doPart --
do (# thisCanvas: ^canvas; 
      updateBorderRect: @rectangle;
      w,h: @integer;
      putRectangle:
        (# r: @rectangle;
        enter r
        do '( ' -> screen.putText;
           r.topLeft -> putPoint; ' , ' -> screen.putText;
           r.bottomRight -> putPoint; ' )' -> screen.putLine;
        #);
      
   do (if not (oldFrame -> newFrame.isEqual) then
          newFrame -> private.windowItemFrame;
          (if interfaceObjectID<>0 then 
              oldFrame.size -> (w,h);
              (* top border *)
              (0,0) -> updateBorderRect.topLeft;
              (w,2) -> updateBorderRect.size;
              updateBorderRect[] -> updateArea;
              
              (* left border *)
              (0,0) -> updateBorderRect.topLeft;
              (2,h) -> updateBorderRect.size;
              updateBorderRect[] -> updateArea;
              
              (* bottom border *)
              (0,h-2) -> updateBorderRect.topLeft;
              (w,2) -> updateBorderRect.size;
              updateBorderRect[] -> updateArea;
              
              (* right border *)
              (w-2,0) -> updateBorderRect.topLeft;
              (2,h) -> updateBorderRect.size; 
              updateBorderRect[] -> updateArea;
          if);
          
          (oldFrame,newFrame) -> theEventHandler.onframeChanged;
          (if (father[]<>none) then
              (oldFrame,newFrame) -> father.handleChildframeChanged;
          if);
          (if interfaceObjectID=0 then
              (# 
              do oldFrame[] -> father.updateArea;
                 newFrame[] -> father.updateArea;
                 (* updateRect[] -> father.updateArea; *)
              #);
          if);
      if);
   #)
   
-- GUIENVwindowItemMethodsdispatchMessage: descriptor --
(# button: @integer;
   shiftKey,controlKey: @boolean;
   pt: @point;
   key: @char;
   VirtualKey: @integer;
   extractInfo:
     (#
     do (info.lParam.loWord,info.lParam.hiWord) -> pt;
        ((info.wParam,MK_CONTROL) -> tos'%and') = MK_CONTROL -> controlKey;
        ((info.wParam,MK_SHIFT) -> tos'%and') = MK_SHIFT -> shiftKey;
     #);
   processMouseDown:
     (# 
     do extractInfo;
        interfaceObjectID -> SetCapture;
        interfaceObjectID -> this(guienv).private.lastCaptureID;
        false -> doubleClickPossible;
        theEventHandler.onMouseDown;
     #);
   processMouseUp:
     (# w,h: @integer;
        currentCapture: @integer;
     do extractInfo;
        GetCapture -> currentCapture;
        (if currentCapture = interfaceObjectID then
            ReleaseCapture; 
        if);
        
        (if (this(guienv).private.lastCaptureID = interfaceObjectID)
            or doubleClickPossible then 
            size -> (w,h);
            (* Call onMouseUp only if mouse pointer is positioned over this 
             * windowItem. 
             *)
            (if ( (0 < pt.h) and (pt.h < w) and (0 < pt.v) and (pt.v < h) ) then
                0 -> this(guienv).private.lastCaptureID;
                theEventHandler.onMouseUp;
            if);
        if); 
     #);
   processDoubleClick:
     (#
     do extractInfo;
        true -> doubleClickPossible;
        theEventHandler.onMouseDown;
     #);
   processBeforeWM_CHAR:
     (#
     do info.wParam.loWord -> VirtualKey;
        (if VirtualKey
         //VK_HOME   
         //VK_PRIOR  
         //VK_NEXT  
         //VK_END    
         //VK_LEFT   
         //VK_UP      
         //VK_RIGHT    
         //VK_DOWN
         //VK_DELETE 
         //VK_BACK     then
            theEventHandler.onKeyDown;
         else
            false -> didSomething;
        if);
     #);
   processKeyDown:
     (# defaultButton: ^windowItem;    
     do info.wParam -> key;
        (if key<>VK_BACK then
            windowDefaultButton -> defaultButton[];
            (if (defaultButton[]<>None) then
                (if key=ascii.cr  then
                    defaultButton.theEventHandler.onMouseUp;
                if);
            if);
            theEventHandler.onKeyDown;
        if);
     #);
   processRefresh:
     (# ps: @integer;
        hRgn: @integer;
        result: @integer;
     do (0,0,0,0) -> CreateRectRgn -> hRgn;
        (interfaceObjectID,hRgn,0) -> GetUpdateRgn -> result;
        hRgn -> interfaceObjectUpdateRgn;
        
        (if windowItemClassStatus=isSubClass then
            theEventHandler.onRefresh;
         else
            64 -> malloc -> ps;
            (interfaceObjectID,ps) -> BeginPaint -> windowItemDevice;
            theEventHandler.onRefresh;
            (interfaceObjectID,ps) -> EndPaint;
            ps -> free;
            0 -> windowItemDevice;            
        if);
        
        hRgn -> DeleteObject;
        -1 -> interfaceObjectUpdateRgn;
     #);
   processDrawItem:
     (#
     do (* processRefresh; *)
        'processDrawItem is called' -> screen.putline;
     #);
   processActivate:
     (#	activation: @boolean;
     do info.wParam <> 0 -> activation;
        (if activation then
            theEventHandler.onActivate;
         else
            theEventHandler.onDeactivate;
        if);
     #);
   processEnableTarget:
     (#
     do theEventHandler.onEnableTarget;
     #);
   processDisableTarget:
     (#
     do theEventHandler.onDisableTarget;
     #);
   processMove:
     (# newPosition: @point;
        r: @rectangle;
     do (info.lParam.loWord,info.lParam.hiWord) -> newPosition;
        windowitemFrame -> r;
        r.topLeft -> newPosition.subTract;
        newPosition -> r.offset;
        r -> windowItemFrame;
     #);
   processResize:
     (#	width,height: @integer;
        r: @rectangle;
        wStyle: @integer;
        hasVScroll: external
          (# wStyle: @integer;
             res: @integer;
          enter wStyle
          do callC;
          exit res
          #);
        hasHScroll: external
          (# wStyle: @integer;
             res: @integer;
          enter wStyle
          do callC;
          exit res
          #);
     do (info.lParam.loWord,info.lParam.hiWord) ->  (width,height);
        (interfaceObjectID,GWL_STYLE) -> GetWindowLong -> wStyle;
        (if (wStyle -> hasVScroll)<>0 then
            width + (SM_CXVSCROLL -> GetSystemMetrics) -> width;
        if);
        (if (wStyle -> hasHScroll)<>0 then
            height + (SM_CYHSCROLL -> GetSystemMetrics) -> height;
        if);
        windowItemFrame -> r;
        (width,height) -> r.size;
        r -> windowItemFrame;
     #);
   processHscroll:
     (# scrollCode: @integer;
        currentValue,pos: @integer;
        theScrollbar: ^scrollbar;
        theInterfaceObject: ^interfaceObject;
     do info.wParam.hiWord -> pos;
        info.wParam.loWord -> scrollCode;
        info.lParam -> findInterfaceObjecById -> theInterfaceObject[];
        &scrollbar[] -> theScrollbar[];
        (if (theInterfaceObject[]<>none) then
            (if (theInterfaceObject.struc<=theScrollbar##) then
                theInterfaceObject[] -> theScrollbar[];
                (if (theScrollbar[]<>none) then
                    (if scrollCode
                     //SB_BOTTOM then 'Got sb_bottom' -> screen.putline;
                     //SB_LINELEFT then 
                        theScrollbar.theEventHandler.onButtonUp;
                     //SB_LINERIGHT then 
                        theScrollbar.theEventHandler.onButtonDown;
                     //SB_PAGELEFT then 
                        theScrollbar.theEventHandler.onPageUp;
                     //SB_PAGERIGHT then 
                        theScrollbar.theEventHandler.onPageDown;
                     //SB_THUMBPOSITION then 
                        theScrollbar.value -> currentValue;
                        (pos - currentValue) 
                          -> theScrollbar.theEventHandler.onThumbMoved;
                    if);
                if);
            if);
        if);
     #);
   processVscroll:
     (# scrollCode: @integer;
        currentValue,pos: @integer;
        theScrollbar: ^scrollbar;
        theInterfaceObject: ^interfaceObject;
     do info.wParam.hiWord -> pos;
        info.wParam.loWord -> scrollCode;
        info.lParam -> findInterfaceObjecById -> theInterfaceObject[];
        &scrollbar[] -> theScrollbar[];
        (if (theInterfaceObject[]<>none) then
            (if (theInterfaceObject.struc<=theScrollbar##) then
                theInterfaceObject[] -> theScrollbar[];
                (if (theScrollbar[]<>none) then
                    (if scrollCode
                     //SB_BOTTOM then 'Got sb_bottom' -> screen.putline;
                     //SB_LINEUP then 
                        theScrollbar.theEventHandler.onButtonUp;
                     //SB_LINEDOWN then 
                        theScrollbar.theEventHandler.onButtonDown;
                     //SB_PAGEUP then 
                        theScrollbar.theEventHandler.onPageUp;
                     //SB_PAGEDOWN then 
                        theScrollbar.theEventHandler.onPageDown;
                     //SB_THUMBPOSITION then 
                        theScrollbar.value -> currentValue;
                        (pos - currentValue) 
                          -> theScrollbar.theEventHandler.onThumbMoved;
                    if);
                if);
            if);
        if);
     #);
    processDestroy:
        (#
        do (if (interfaceObjectID<>0) then
                0 -> interfaceObjectID;
                this(windowItem).close;
            if);
        #);
   processCommand:
     (# type: @integer;
        id: @integer;
        theInterfaceObject: ^interfaceObject;
        theScrollList: ^scrollList;
     do info.wParam.hiWord -> type;
        info.wParam.loWord -> id;
        
        (* 'Command - Notification(1): ' -> screen.putText;
         *         type -> screen.putInt;
         *         ' ID: ' -> screen.putText;
         *         id -> screen.putInt;
         *         screen.newLine;
         *)
        
        (if type
         //LBN_DBLCLK
         //LBN_ERRSPACE
         //LBN_SELCANCEL
         //LBN_SELCHANGE
         //LBN_SETFOCUS then
            info.lParam -> findInterfaceObjecById -> theInterfaceObject[];
            (if theInterfaceObject[]<>none then 
                (if theInterfaceObject## <= scrollList## then
                    theInterfaceObject[] -> theScrollList[];
                    type -> theScrollList.handleNotification;
                if);   
            if);
         //0
         //1 then
            (if info.lParam=0 then
                id -> processMenuSelect
            if);
        if);
     #);
   processNotify:
     (# theFather: ^canvas;
        hwndFrom: @integer;
        idCtrl: @integer;
        code1: @integer;
     do (if this(windowItem)## <= canvas## then
            this(windowItem)[] -> theFather[];
            
            info.lParam -> TOS'%adrGetLong' -> hwndFrom;
            info.lParam+4 -> TOS'%adrGetLong' -> idCtrl;
            info.lParam+8 -> TOS'%adrGetLong' -> code1;
            
            L: theFather.private.children.scan
              (# 
              do (if hwndFrom=current.interfaceObjectID then
                     current.handleNotification;
                     leave L;
                 if);
              #);
        if);
     #);
   processMenuSelect:
    (# id: @integer;
       handled: @boolean;
    enter id
    do theScan: this(guienv).private.menus.scan
         (#
         do id -> current.processMenuSelect -> handled;
            (if handled then
                leave theScan;
            if);
         #);
    #);
   processSetCursor:
     (# theCur: ^cursor; 
        HTCLIENT: (#  exit 1 #); (* Hittest code. *) 
     do (if THIS(guienv).private.currentMouseCursor[] = none then
            (if info.lParam.loWord = HTCLIENT then
                (if (windowItemCursor <> none ) then
                    windowItemCursor->theCur[];
                    (if (theCur.cursorHandle <> 0) then
                        theCur.cursorHandle->SetCursor; 
                    if);
                    1->info.result;
                    false->info.callBack;
                 else
                    false->didSomething; 
                if);
             else
                false->didSomething; 
            if);
         else
            (* We have a busy cursor. *)
            THIS(guienv).private.currentMouseCursor.cursorHandle->SetCursor;
            1->info.result;
            false->info.callBack;
        if);
     #);
   didSomething: @boolean;
do true -> didSomething;
   windowItemClassStatus = isSubClass -> info.callBack;
   
   (if info.message
    //WM_COMMAND then processCommand;
    //WM_NOTIFY then processNotify;
    //WM_LBUTTONDOWN then 1 -> info.button; processMouseDown;
    //WM_MBUTTONDOWN then 2 -> info.button; processMouseDown;
    //WM_RBUTTONDOWN then 3 -> info.button; processMouseDown;
       
    //WM_LBUTTONUP then 1 -> info.button; processMouseUp;
    //WM_MBUTTONUP then 2 -> info.button; processMouseUp;
    //WM_RBUTTONUP then 3 -> info.button; processMouseUp;
       
    //WM_LBUTTONDBLCLK then 1 -> info.button; processDoubleClick;
    //WM_MBUTTONDBLCLK then 2 -> info.button; processDoubleClick;
    //WM_RBUTTONDBLCLK then 3 -> info.button; processDoubleClick;
       
    //WM_KEYDOWN then processBeforeWM_CHAR;
    //WM_CHAR then	processKeyDown;
    //WM_PAINT then processRefresh; 
    //WM_ACTIVATE then processActivate;
    //WM_KILLFOCUS then processDisableTarget;
    //WM_SETFOCUS then processEnableTarget;
    //WM_DRAWITEM then processDrawItem;
       
    //WM_MOVE then	processMove;
    //WM_SIZE then processResize;
    //WM_HSCROLL then processHscroll;
    //WM_VSCROLL then processVscroll;
    //WM_DESTROY then processDestroy;
    //WM_SETCURSOR then processSetCursor;
    else false -> didSomething;
   if);
   
   inner dispatchMessage;
   
   info.handled or didSomething -> info.handled;
   (if info.callBack then
       callDefaultWindowProc;
   if);   
#)

-- GUIENVwindowitemOnRefresh: descriptor --
(# 
   (* theStyle: @integer; *)
   width,height: @integer;
   x,y: @integer;
   info: ^messageInfo;
do (if windowItemClassStatus=isStandardClass then
       currentMessageInfo -> info[];
       true -> info.handled;
       (interfaceObjectID,info.message,info.wParam,info.lParam) -> DefWindowProc -> info.result;
   if);
   
   inner onRefresh;
   (if border.visible then
       (if windowItemClassStatus=isSubClass then
           currentMessageInfo -> info[];
           FALSE -> info.callback;
           callDefaultWindowProc;
       if);
       
       size -> (width,height);
       (* (if border.style
        *         //borderStyles.simple then 1 -> theStyle;
        *         //borderStyles.shadowIn then 2 -> theStyle;
        *         //borderStyles.shadowOut then 3 -> theStyle;
        *         //borderStyles.etchedIn then 4 -> theStyle;
        *         //borderStyles.etchedOut then 5 -> theStyle;
        *        if);
        *)
       
       (if interfaceObjectID=0 then
           position -> (x,y);
           (father[],border.style,x,y,width,height) -> drawBorder;
        else
           (this(windowItem)[],border.style,0,0,width,height) -> drawBorder;
       if);
       
   if);
#)

-- GUIENVwindowitemSetFrame: descriptor --
(# x,y,oldX,oldY,width,height: @integer;
   result: @integer;
   oldFrame: @rectangle;
   onlyResize: @boolean;
do windowItemFrame -> oldFrame;
   theFrame.topLeft -> (x,y);
   theFrame.size -> (width,height);
   oldFrame.topLeft -> (oldX,oldY);
   ((x = oldX) and (y = oldY)) -> onlyResize;
   
   (if not (theFrame -> oldFrame.isEqual) then
       (if (windowItemClassStatus<>isNoClass) then
           (if updateOnResize then
               (if onlyResize then
                   (interfaceObjectID,x,y,width,height,1)->MoveWindow->result;
                   (result,'windowItemSetFrame') -> checkNullError;
                else
                   (interfaceObjectID,x,y,width,height,1)->MoveWindow->result;
                   (result,'windowItemSetFrame') -> checkNullError;
               if);
            else
               (if onlyResize then
                   (interfaceObjectID,x,y,width,height,1)->MoveWindow->result;
                   (result,'windowItemSetFrame') -> checkNullError;
                else
                   (interfaceObjectID,x,y,width,height,1)->MoveWindow->result;
                   (result,'windowItemSetFrame') -> checkNullError;
               if);
           if);
       if);
       (oldFrame,theFrame) -> handleFrameChanged;
   if);
#)

-- GUIENVwindowitemGetFrame: descriptor --
(# 
do windowItemFrame -> theFrame;
#)

-- GUIENVwindowitemSetPosition: descriptor --
(# newFrame: @rectangle;
do pt -> newFrame.topLeft;
   size -> newFrame.size;
   newFrame -> frame;
#)

-- GUIENVwindowitemGetPosition: descriptor --
(#  r: @rectangle;
do windowItemframe -> r;
   r.topLeft -> pt;
#)

-- GUIENVwindowitemMove: descriptor --
(# pt: @point;
do position -> pt;
   (dh,dv) -> pt.add;
   pt -> position;
#)

-- GUIENVwindowitemSetSize: descriptor --
(# newFrame: @rectangle;
do position -> newFrame.topLeft;
   (width,height) -> newFrame.size;
   newFrame -> frame;
#)

-- GUIENVwindowitemGetSize: descriptor --
(#  r: @rectangle;
do windowItemframe -> r;
   r.size -> (width,height);
#)

-- GUIENVwindowitemSetVisible: descriptor --
(# opCode: @integer; result: @integer;
do value -> private.visibleFlag;
   (if (windowItemClassStatus<>isNoClass) then
       (if value then
           SW_SHOW -> opCode; 
        else
           SW_HIDE -> opCode; 
       if);
       (interfaceObjectID,opCode) -> ShowWindow->result;
   if);
   theEventHandler.onVisibleChanged;
#)

-- GUIENVwindowitemGetVisible: descriptor --
(#
do private.visibleFlag -> value;
#)

-- GUIENVwindowitemSetHilite: descriptor --
(#
do (if (value<>windowItemHilite) then
       value -> windowItemHilite;
       theEventHandler.onHiliteChanged;
   if);
#)

-- GUIENVwindowitemGetHilite: descriptor --
(#
do windowItemHilite -> value;
#)

-- GUIENVwindowitemShow: descriptor --
(#
do true -> visible;
#)

-- GUIENVwindowitemHide: descriptor --
(#
do false -> visible;
#)

-- GUIENVwindowitemSetEnabled: descriptor --
(#
do (if (windowItemClassStatus<>isNoClass) then
       (if value then
           (interfaceObjectID,1) -> EnableWindow;
        else
           (interfaceObjectID,0) -> EnableWindow;
       if);
   if);
#)

-- GUIENVwindowitemGetEnabled: descriptor --
(#
do (if (windowItemClassStatus<>isNoClass) then
       (if (interfaceObjectID -> IsWindowEnabled)<>0 then
           true -> value;
        else 
           false -> value;
       if);
   if);
#)

-- GUIENVwindowitemEnable: descriptor --
(#
do true -> enabled;
#)

-- GUIENVwindowitemDisable: descriptor --
(#
do false -> enabled;
#)

-- GUIENVwindowitemBorderSetVisible: doPart --
do value -> private.borderVisible;
   theEventHandler.onVisibleChanged;
   
-- GUIENVwindowitemBorderGetVisible: doPart --
do private.borderVisible -> value;
   
-- GUIENVwindowitemBorderSetStyle: doPart --
do value -> private.borderStyle;
   theEventHandler.onBorderStyleChanged;
   
-- GUIENVwindowitemBorderGetStyle: doPart --
do private.borderStyle -> value;
   
-- GUIENVwindowiteminsideRectangle: doPart --
do ((0,0),size) -> theRectangle;
   (if border.visible then
       (if border.style=borderStyles.simple then
           (1,1) -> theRectangle.inset;
        else
           (2,2) -> theRectangle.inset;
       if);
   if); 

-- GUIENVwindowitemSetTheCursor: descriptor --
(# 
do (if theCur[]<>NONE then
       theCur.cursorHandle -> interfaceObjectCursorHandle;
    else
       0 -> interfaceObjectCursorHandle;
   if);
   theCur[] -> windowItemCursor;
#)

-- GUIENVwindowitemGetTheCursor: descriptor --
(#  
do windowItemCursor -> theCur[];
#)

-- GUIENVwindowItemTrackMouse: descriptor --
(# stillDown:
     (# exists: @boolean;
     do (m,0,ButtonCode,ButtonCode,PM_NOREMOVE) -> PeekMessage -> exists;
     exit (not exists)
     #);
   move:
     (# exists: @boolean;
     do (m,0,WM_MOUSEMOVE,WM_MOUSEMOVE,PM_REMOVE) -> PeekMessage -> exists;
     exit exists
     #);
   PeekMessage: external
     (#
        theMesage: @integer; (* address of structure with message,  MSG FAR* *)
        hwnd: @integer; (* handle of the window, HWND *)
        wMsgFilterMin: @integer; (* first message, UINT *)
        wMsgFilterMax: @integer; (* last message, UINT *)
        fulRemoveMsg: @integer; (* removal flags UINT *)
        out: @boolean; (* BOOL *)
     enter (theMesage,hwnd,wMsgFilterMin,wMsgFilterMax,fulRemoveMsg)
     do 'PeekMessageA' -> callStd;
     exit out
     #);
   translate:
     (#
        h,v: @integer;
     enter (h,v)
     do -origin.v + v -> v;
        -origin.h + h -> h;
     exit (h,v)
     #);
   longInt: @CStruct
     (#	ByteSize:: (# do 4 -> Value; #);
        loWord: signedShort (# Pos:: (# do 0 -> Value; #); #);
        hiWord: signedShort (# Pos:: (# do 2 -> Value; #); #);
     enter R[1]
     exit R[1]
     #);
   m: @integer;
   ButtonCode: @integer;
   info: ^messageInfo;
   theNtRectPtr: @integer;
   windowItemRect: ^rectangle;
   origin: @point;
   result: @integer;
do 28 -> malloc -> m;
   16 -> malloc -> theNtRectPtr;
   (interfaceObjectID,theNtRectPtr) -> GetWindowRect -> result;
   (result,'GUIENVwindowItemTrackMouse') -> checkNullError;
   &rectangle[] -> windowItemRect[]; 
   theNtRectPtr -> getRectFromNtRectPtr -> windowItemRect;
   windowItemRect.top -> origin.v;
   windowItemRect.left -> origin.h;
   
   GetMessagePos -> longInt;
   (longInt.loWord,longInt.hiWord) -> translate -> curPt -> prevPt;
   mousePress;
   (if mouse.buttonState//1//2//3 then
       (if mouse.buttonState
        //1 then WM_LBUTTONUP -> ButtonCode; 
        //2 then WM_MBUTTONUP -> ButtonCode;
        //3 then WM_RBUTTONUP -> ButtonCode;
       if);
       l: (if stillDown then
              (if move then
                  m + 20 -> TOS'%adrGetLong' -> curPt.h;
                  m + 24 -> TOS'%adrGetLong' -> curPt.v;
                  curPt -> translate -> curPt;
                  (curPt.h - prevPt.h,curPt.v - prevPt.v) -> mouseMove;
                  curPt -> prevPt;
              if);
              restart l;
          if);
   if);
   mouseRelease;
   m -> free;
   theNtRectPtr -> free;
#)

-- GUIENVwindowitemDrag: descriptor --
(# prevMode: @integer;
   dc: @integer;
   pen,prevPen: @integer;
   brush,prevBrush: @integer;
do father.interfaceObjectID -> GetDC -> dc;
   (dc,R2_XORPEN) -> SetROP2 -> prevMode;
   (PS_DOT,1,0) -> CreatePen -> pen;
   (dc,pen) -> SelectObject -> prevPen;
   NULL_BRUSH -> GetStockObject -> brush;
   (dc,brush) -> SelectObject -> prevBrush;
   father.trackMouse
   (#  
      currentFrame: @rectangle;
      drawFrame:
        (# 
        do (dc,currentFrame.left,
           currentFrame.top,
           currentFrame.right,
           currentFrame.bottom) -> ntRectangle;
        #);
      
      mousePress::<
        (#
        do frame -> currentFrame;
           drawFrame;
        #);
      mouseMove::<
        (#
        do drawFrame;
           (h,v) -> currentFrame.offset;
           drawFrame;
        #);
      mouseRelease::<
        (#
        do drawFrame;
           currentFrame -> frame;
        #);
   #); 
   (dc,prevPen) -> SelectObject;
   (dc,prevBrush) -> SelectObject;
   pen -> DeleteObject;
   (father.interfaceObjectID,dc) -> ReleaseDC;
   
#)

-- GUIENVwindowitemResize: descriptor --
(# newFrame: @rectangle;
   w,h: @Integer;
do frame -> father.defineRect -> newFrame;
   newFrame.size -> (w,h);
   (w,1) -> max -> w;
   (h,1) -> max -> h;
   (w,h) -> newFrame.size;
   newFrame -> frame;
#)

-- GUIENVwindowitemUpdate: descriptor --
(# ntrPtr: @integer; r: @rectangle; result,updateWinRes: @integer; 
do (if interfaceObjectID=0 then
       frame -> r;
       r[] -> makeNtRectPtr -> ntrPtr;
       (father.interfaceObjectID, ntrPtr, 1) -> InvalidateRect -> result;
       (result,'GUIENVwindowitemUpdate') -> checkNullError;
       (if immediate then
           father.interfaceObjectID -> UpdateWindow -> updateWinRes;
           (updateWinRes,'GUIENVwindowindowItemUpdate(2)') -> checkNullError;
       if);
    else
       ((0,0),size) -> r;
       r[] -> makeNtRectPtr -> ntrPtr;
       (interfaceObjectID, ntrPtr, 1) -> InvalidateRect -> result;
       (result,'GUIENVwindowitemUpdate') -> checkNullError;
       (if immediate then
           interfaceObjectID -> UpdateWindow -> updateWinRes;
           (updateWinRes,'GUIENVwindowindowItemUpdate(2)') -> checkNullError;
       if);
   if);
   ntrPtr -> free;
#)

-- GUIENVwindowitemCreate: descriptor --
(# origin: ^object;
   
   class,name: @text;
   fatherID,ID: @integer;
   hInstance: @integer;
   exStyle, style: @integer;
   errorcode: @integer;
   
   getWndProcAddr: external
     (# hWnd: @integer;
        addr: @integer;
     enter hWnd
     do callC;
     exit addr
     #);
   
   a2o: @addressToObject;
do uienvStandardWindowClass -> windowItemClass;
   isStandardClass -> windowItemClassStatus;
   &windowItemmethods[] -> theMethods;
   inner create;
   
   (if father[]=none then
       (if this(windowitem)[]=windowContents then
        else
           this(windowitem)[] -> getOrigin -> origin[];
           l:
             (if origin[]=none then
                 windowContents -> father[];
              else
                 (if (origin[] -> getPrototype) = -9 (* DopartObject *) then
                     (* Go one more out !! *)
                     (@@origin->tos'%AdrGetLong')+8->tos'%AdrGetLong'
                       -> a2o -> origin[];
                 if);
                 
                 (if (origin## <= canvas##) then
                     origin[] -> father[];
                  else
                     (if (origin## <= window##) then
                         (* We have found the window of this(windowItem). *)
                         NONE -> origin[];
                      else
                         origin[] -> getOrigin -> origin[];
                     if);
                     restart l;
                 if);
             if);
       if);
   if);
      
   
   windowItemClass -> class;
   windowItemExStyle -> exStyle;
   windowItemStyle -> style;
   uienvHInstance -> hInstance;
   'WindowItem' -> name;
   (if father[]=none then
       this(window).interfaceObjectID -> fatherID;
    else
       father.interfaceObjectID -> fatherID;
       this(windowItem)[] -> father.private.children.append;
   if);
   uniqueID -> ID;
   (if windowItemClassStatus//isSubClass//isStandardClass then
       WS_CHILDWINDOW + WS_CLIPSIBLINGS + style -> style;
       (exStyle, class,name,style,0,0,100,100,fatherID,ID,hInstance,0) 
         -> CreateWindowEx
         -> interfaceObjectID;
       (if (interfaceObjectID -> isWindow)=0 then
           'Create Child Window failed. Error: ' -> screen.puttext;
           GetLastError -> screen.putInt; screen.newline;
       if);
   if);
   
   ((0,0),(100,100)) -> windowItemFrame;
   (if windowItemClassStatus=isSubClass then
       (interfaceObjectID,GWL_WNDPROC,uienvStandardWindowProcAddress)
         -> SetWindowLong -> interfaceObjectWindProc;       
   if);
   
   (interfaceObjectID,GCL_HCURSOR,0) -> SetClassLong;
   cursors.arrow[] -> theCursor;
#)

-- GUIENVwindowitemOpen: descriptor --
(# windowID: @integer;
do interfaceObjectID -> windowID;
   true -> updateOnResize;
   true -> automaticUpdate;
   true -> bindTop;
   true -> bindLeft;
   true -> private.visibleFlag;
   inner open;
   (windowID,HWND_TOP,0,0,0,0,SWP_NOMOVE + SWP_NOSIZE + SWP_NOACTIVATE) 
     -> SetWindowPos;
   (if private.visibleFlag then show; if);
#)

-- GUIENVwindowitemClose: descriptor --
(# result: @integer;
   id: @integer;
do inner close;
   (if (father[]<>NONE) then
       this(windowitem)[] -> father.selection.remove;
       this(windowItem)[] -> father.private.children.remove;
   if);
   this(windowItem)[] -> removeInterfaceObject;
   (if (interfaceObjectID<>0) then
       interfaceObjectID -> id;
       0 -> interfaceobjectID;
       ID -> DestroyWindow -> result;
   if);
   NONE -> windowItemCursor;
#)

-- GUIENVwindowitemPutLayout: doPart --
do
   
-- GUIENVwindowitemGetLayout: doPart --
do
   
-- GUIENVWindowItemHit: doPart --
do frame -> r;
   pt -> r.containsPoint -> value;

-- separatorLib: attributes --
singleLine: (# exit 1 #);
doubleLine: (# exit 2 #);
singleDashedLine: (# exit 3 #);
doubleDashedLine: (# exit 4 #);
etchedIn: (# exit 5 #);
etchedOut: (# exit 6 #);

theStyle:
  (# 
  enter private.style
  exit private.style
  #);

-- GUIENVwindowSeparatorOnRefresh: doPart --
do (# blackHdc, whiteHdc: @integer;
      width,height: @integer;
      x,y,y2: @integer;
      blackPen, whitePen: @integer;
      lineStyle, noLines: @integer;
   do <<SLOT drawseparatorbody: descriptor>>
   #)

-- GUIENVseparatorSetStyle: doPart --
do value -> theStyle;
   
-- GUIENVseparatorGetStyle: doPart --
do theStyle -> value;
   
-- GUIENVwindowseparatorCreate: doPart --
do uienvStandardWindowClass -> windowItemClass;
   isStandardClass  -> windowItemClassStatus;
   
   separatorStyles.singleLine -> private.style;
   inner create;
   
-- GUIENVwindowseparatorOpen: doPart --
do (if vertical then
       (2,500) -> size; 
    else
       (500,2) -> size; 
   if);
   inner open;
   
-- GUIENVwindowseparatorClose: doPart --
do inner close;
   
-- GUIENVseparatorPutLayout: doPart --
do 'GUIENVseparatorPutLayout: Not implemented !!!' -> screen.putline;
   
-- GUIENVseparatorGetLayout: doPart --
do 'GUIENVseparatorGetLayout: Not implemented !!!' -> screen.putline;
   
-- GUIENVwindowseparatorPrivate: descriptor --
(# style: @integer;
#)

-- canvasLib: attributes --
handleChildframeChanged:
  (# oldFrame,newFrame: @rectangle;
  enter (oldFrame,newFrame)
  do (oldFrame,newFrame) -> theEventHandler.onChildframeChanged;
  #);

-- GUIENVcanvasOnActivate: descriptor --
(#
do scan
   (#
   do current.theEventHandler.onActivate;
   #);
   inner onActivate;
#)

-- GUIENVcanvasOnDeactivate: descriptor --
(#
do scan
   (#
   do current.theEventHandler.onDeactivate;
   #);
   inner onDeactivate;
#)

-- GUIENVcanvasOnMouseDown: descriptor --
(# hitObject: ^windowItem;
do theScan: scan
   (# 
   do (if current.windowItemClassStatus=isNoClass then
          (if current.visible then
              (if (localPosition -> current.hit) then
                  current[] -> hitObject[];
                  leave theScan;
              if);
          if);
      if);
   #);
   (if hitObject[]=none then
       inner onMouseDown;
    else
       hitObject.theEventHandler.onMouseDown;
   if);
#)

-- GUIENVcanvasOnRefresh: descriptor --
(# r: @rectangle; doPaint: @integer;
   theNtRectPtr: @integer;
do inner onRefresh;
   scan
   (# 
   do (if current.windowItemClassStatus=isNoClass then
          (if interfaceObjectUpdateRgn = -1 then
              current.theEventHandler.onRefresh;
           else
              current.frame -> r;
              r[] -> makeNtRectPtr -> theNtRectPtr;
              (windowItemDevice, theNtRectPtr) -> RectVisible -> doPaint;
              (if doPaint<>0 then 
                  current.theEventHandler.onRefresh;
              if); 
              theNtRectPtr -> free;
          if);   
      if);
   #);
#) 

-- GUIENVcanvasOnMouseUp: descriptor --
(#
do inner onMouseUp;
#)

-- GUIENVcanvasOnFrameChanged: descriptor --
(#
do private.children.scan
   (#
   do (oldFrame,newFrame) -> current.processFatherFrameChanged;
   #);
   inner onFrameChanged;
#)

-- GUIENVcanvasSelectionAdd: descriptor --
(#
do (if not (theWindowitem[] -> private.selection.has) then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionSet: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;
#)

-- GUIENVcanvasSelectionRemove: descriptor --
(#
do (if (theWindowitem[] -> private.selection.has) then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionEmpty: descriptor --
(#
do private.selection.empty -> value;
#)

-- GUIENVcanvasSelectionScan: descriptor --
(#
do private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVcanvasSelectionClear: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
#)

-- GUIENVcanvasScan: descriptor --
(#
do private.children.scan
   (#
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVcanvasCreate: descriptor --
(#
do inner create;
#)

-- GUIENVcanvasOpen: descriptor --
(#
do false -> updateOnResize;
   inner open;
#)

-- GUIENVcanvasClose: descriptor --
(#
do inner close;
   private.children.scan
   (# do (if current.isOpen then current.close; if); #);
#)

-- GUIENVcanvasPutLayout: doPart --
do 'GUIENVcanvasPutLayout: Not implemented !!!' -> screen.putline;
   
-- GUIENVcanvasGetLayout: doPart --
do 'GUIENVcanvasGetLayout: Not implemented !!!' -> screen.putline;
   
-- GUIENVcanvasPrintOpenPage: descriptor --
(#
do 'GUIENVcanvasPrintOpenPage: Not implemented !!!' -> screen.putline;
#)

-- GUIENVsharedWindowAddDisplay: descriptor --
(#
do 'GUIENVsharedWindowAddDisplay: Not implemented !!!' -> screen.putline;
#)

-- GUIENVsharedWindowRemoveDisplay: descriptor --
(#
do 'GUIENVsharedWindowRemoveDisplay: Not implemented !!!' -> screen.putline;
#)

-- cursorLib: attributes --
cursorHandle:
  (#
  enter private.cursorHandle
  exit private.cursorHandle
  #);
load:
  (# LoadCursorInt: external
       (#
          in0: @integer; (* HINSTANCE *)
          in1: @integer; (* LPCSTR *)
          out: @integer; (* HCURSOR *)
       enter (in0,in1)
       do 'LoadCursorA' -> callStd;
       exit out
       #);
     name: @integer; (* LPCSTR *)
     result: @integer;
  enter name
  do (0,name) -> LoadCursorInt -> cursorHandle -> result;
     (result,'cursorLib.load') -> checkNullError;
  #);
-- GUIENVcursorPrivate: descriptor --
(# cursorHandle: @integer;
#)

-- textStyleLib: attributes --

useTextStyle:
  (# dc,deskTop: @integer;
     saved: @integer;
     infoPtr: @integer;
  do 53 -> malloc -> infoPtr;
     create;
     GetDeskTopWindow -> deskTop;
     deskTop -> GetDC -> dc;
     (dc,textStyleID) -> SelectObject -> saved;
     (dc,infoPtr) -> GetTextMetrics;
     inner;
     (dc,saved) -> SelectObject;
     (deskTop,dc) -> ReleaseDC;
     infoPtr -> free;
  #);
-- GUIENVtextStyleCreate: doPart --
do (# activeWndHdc: @integer; (* 110396 /les *)
      activeHwnd: @integer;
   do (if textStyleID=0 then
          textStyleSize -> height;
          0 -> width;
          0 -> escapement;
          0 -> orientation;
          FW_NORMAL -> weight;
          0 -> italic;
          (if textStyleFace=textFaces.bold then
              FW_BOLD -> weight;
          if);
          (if textStyleFace=textFaces.italic then
              1 -> italic;
          if);
          (if textStyleFace=textFaces.italic + textFaces.bold then
              FW_BOLD -> weight;
              1 -> italic;
          if);
          0 -> underline;
          0 -> strikeOut;
          ANSI_CHARSET -> charSet;
          OUT_DEFAULT_PRECIS -> outPrecision;
          CLIP_DEFAULT_PRECIS -> clipPrecision;
          PROOF_QUALITY -> quality;
          DEFAULT_PITCH + FF_DONTCARE + 16x04 -> pitchAndFamily; (* the 16x04 is to get a true type font *)
          textStyleName -> face;
          
          GetActiveWindow -> activeHwnd; (* 110396 /les *)
          activeHwnd -> GetDC -> activeWndHdc;
          (height, (activeWndHdc, LOGPIXELSY) -> GetDeviceCaps, 72) -> MulDiv -> height;
          
          (-height,width,escapement,orientation,weight,
          italic,underline,strikeout,charSet,outPrecision,
          clipPrecision,quality,pitchAndFamily,face) -> CreateFont -> textStyleID;
          
          (if textStyleID=0 then
              GetLastError -> error;
              'Failed to create font. Error: ' -> screen.putText; 
              error -> screen.putInt; screen.newLine;
           else 
              this(textStyle)[] -> this(guienv).private.textStyles.append;
          if);
          (activeHwnd,activeWndHdc) -> ReleaseDC; (* 110396 /les *)
      if);
   #);

-- GUIENVtextStyleDispose: doPart --
do (if textStyleID<>0 then
       this(textStyle)[] 
         -> this(guienv).private.textStyles.delete;
       (if (textStyleID<>0) then
           (if ((textStyleID -> DeleteObject)=0) then            
               'Failed to delete font.' -> screen.putline;
            else
               0 -> textStyleID; 
           if);
       if);
   if);
   
-- GUIENVtextStyleSetName: descriptor --
(# 
do theName -> textStyleName;
#)

-- GUIENVtextStyleGetName: descriptor --
(#
do textStyleName -> theName;
#)

-- GUIENVtextStyleSetSize: descriptor --
(#
do value -> textStyleSize;
#)

-- GUIENVtextStyleGetSize: descriptor --
(#
do textStyleSize -> value;
#)

-- GUIENVtextStyleSetFace: descriptor --
(#
do value -> textStyleFace;
#)

-- GUIENVtextStyleGetFace: descriptor --
(#
do textStyleFace -> value;
#)

-- GUIENVtextStyleAscent: descriptor --
(# 
do useTextStyle
    (#
    do infoPtr + textmetricTmAscentOffset -> TOS'%adrGetLong' -> value;
    #);
#)

-- GUIENVtextStyleDescent: descriptor --
(#
do useTextStyle
    (#
    do infoPtr + textmetricTmDescentOffset -> TOS'%adrGetLong' -> value;
    #);
#)

-- GUIENVtextStyleLeading: descriptor --
(#
do useTextStyle
   (#
   do infoPtr + textmetricTmExternalLeadingOffset -> TOS'%adrGetLong' -> value;
   #);
#)

-- GUIENVtextStyleHeight: descriptor --
(#
do useTextStyle
   (#
   do infoPtr + textmetricTmHeightOffset -> TOS'%adrGetLong' -> value;
   #);
#)

-- GUIENVtextStyleMaxChWidth: descriptor --
(#
do useTextStyle
   (#
   do infoPtr + textmetricTmMaxCharWidthOffset -> TOS'%adrGetLong' -> value;
   #);
#)

-- GUIENVtextStyleWidthOfChar: descriptor --
(# 
do useTextStyle
   (# tempCharWidth: @integer; result: @integer;
   do 4 -> malloc -> tempCharWidth;
      (dc,ch,ch,tempCharWidth) -> GetCharWidth32 -> result;
      tempCharWidth -> TOS'%adrGetLong' -> value;
      tempCharWidth -> free;
   #);
#)

-- GUIENVtextStyleStringWidth: descriptor --
(#
do useTextStyle
   (# theSize: @point;
      theSizePtr: @integer;
      cstr: @cstring;
   do (if str.length > 0 then
          8 -> malloc -> theSizePtr;
          str[] -> cstr.set;
          (dc,cstr.charPtr,cstr.length,theSizePtr) -> GetTextExtentPoint32;
          theSizePtr -> getPointFromNtPointPtr -> (theSize.h,theSize.v);
          theSize.h -> value;
          
          cstr.free;
          theSizePtr -> free;
       else
          0 -> value;
      if);
   #);
#)

-- GUIENVtextStyleFamilySizes: descriptor --
(#
do (* Not implemented !!! Use EnumFont *)
   'GUIENVtextStyleFamilySizes: Not implemented !!!' -> screen.putline;
#)

-- clipBoardLib: attributes --
(* BOOL TextToClipboard( LPSTR Txt ) *)
TextToClipboard: external
  (# theText: [1] @char; (* LPCSTR *)
     result: @boolean
  enter theText
  do callC;
  exit result
  #);

(* LPSTR TextFromClipboard() *)
TextFromClipboard: external
  (# theText: [1] @char; (* LPCSTR *)
  do callC;
  exit theText
  #);

-- GUIENVclipBoardHasText: descriptor --
(#
do CF_TEXT -> IsClipboardFormatAvailable -> value;
#)

-- GUIENVclipBoardSetText: descriptor --
(# res: @boolean;
do (if txt[]=none then else txt -> TextToClipboard -> res; if);
#)

-- GUIENVclipBoardGetText: descriptor --
(#
do (if ( CF_TEXT -> IsClipboardFormatAvailable ) then
      &text[] -> txt[];
      TextFromClipboard -> txt;
      txt.T.range -> txt.lgth -> txt.pos;
   if);
#)

-- GUIENVclipBoardClearContents: descriptor --
(#
do (if (0 -> OpenClipboard) then
      EmptyClipboard;
      CloseClipboard;
   if);
#)

-- GUIENVmouseGlobalPosition: descriptor --
(# ntpPtr: @integer; result: @integer;
do 8 -> malloc -> ntpPtr;
   ntpPtr -> GetCursorPos -> result;
   ntpPtr -> getPointFromNtPointPtr -> (pt.h,pt.v);
   ntpPtr -> free;
#)

-- GUIENVmouseButtonState: descriptor --
(# isButtonDown: external
     (# button: @integer;
        res: @boolean;
     enter button
     do callC;
     exit res
     #);
do l:
     (# 
     do (if (VK_LBUTTON -> isButtonDown) then 1 -> value; leave l; if);
        (if (VK_MBUTTON -> isButtonDown) then 2 -> value; leave l; if);
        (if (VK_RBUTTON -> isButtonDown) then 3 -> value; leave l; if);
     #);

#)

-- GUIENVmouseTheCursorSet: descriptor --
(# 
do (if theCur[]<>NONE then
       &cursor[] -> private.prevMouseCursor[];
       theCur.cursorHandle 
         -> SetCursor -> private.prevMouseCursor.cursorHandle;
    else
       (if private.prevMouseCursor[]<>NONE then
           private.prevMouseCursor.cursorHandle -> SetCursor;
        else
           0 -> SetCursor;
       if);
   if);
   theCur[] -> private.currentMouseCursor[];
#)

-- GUIENVmouseTheCursorGet: descriptor --
(#
do private.currentMouseCursor[] -> theCur[];
#)

-- GUIENVsystemScreenRectangle: descriptor --
(# 
do theScreenRectangle -> theRectangle;
#)

-- GUIENVsystemScreenRgn: descriptor --
(#
do &region[] -> rgn[];
   theScreenRectangle -> rgn.setFromRectangle;
#)

-- GUIENVsystemBeepBody: descriptor --
(#
do MB_OK -> MessageBeep;
#)

-- GUIENVsystemWaitBody: descriptor --
(#
do (ticks * 1000) div 60 -> Sleep;
#)

-- GUIENVdoSetUp: descriptor --
(# getScreenRectangle:
     (# widthOfScreen, heightOfScreen: @integer; 
     do SM_CXSCREEN -> GetSystemMetrics -> widthOfScreen;
        SM_CYSCREEN -> GetSystemMetrics -> heightOfScreen;
        ((0,0), (widthOfScreen,heightOfScreen)) -> theScreenRectangle;
     #);
   loadDIBitmapFile: external
     (# hdc: @integer;
        filename: @integer;
        hbitmap: @integer;
     enter (hdc,filename)
     do 'LoadDIBitmapFile'->callC
     exit hbitmap
     #);
   getGray: external
     (# hBitmap: @integer; hdcLocal: @integer;
     enter hdcLocal
     do callC;
     exit hBitmap
     #);
   getLightGray: external
     (# hBitmap: @integer; hdcLocal: @integer;
     enter hdcLocal
     do callC;
     exit hBitmap
     #);
   getDarkGray: external
     (# hBitmap: @integer; hdcLocal: @integer;
     enter hdcLocal
     do callC;
     exit hBitmap
     #);
   getWhite: external
     (# hBitmap: @integer; hdcLocal: @integer;
     enter hdcLocal
     do callC;
     exit hBitmap
     #);
   getBlack: external
     (# hBitmap: @integer;
        hdcLocal: @integer;
     enter hdcLocal
     do callC;
     exit hBitmap
     #);
   
   initBP:
     (# hWnd, hdc: @integer; didRelease: @integer; result: @integer;
     do GetDesktopWindow -> hWnd;
        hWnd -> GetDC -> hdc -> result; (result,'initBP.getDC') -> checkNullError;
        
        &raster[] -> patterns.black[];
        hdc -> getBlack -> patterns.black.handleToBitmap;
        
        &raster[] -> patterns.white[];
        hdc -> getWhite -> patterns.white.handleToBitmap;
        
        &raster[] -> patterns.dkGray[];
        hdc -> getDarkGray -> patterns.dkgray.handleToBitmap;
        
        &raster[] -> patterns.gray[];
        hdc -> getGray -> patterns.gray.handleToBitmap;
        
        &raster[] -> patterns.ltGray[];
        hdc -> getLightGray -> patterns.ltgray.handleToBitmap;
        
        (* Clean up memory *)
        (hWnd, hdc) -> ReleaseDC -> didRelease;
        (if didRelease=0 then
            'initPatterns. Did not release DC!!!' -> screen.putline;
        if);
     #);
   initMenubar:
     (# theBar: ^menubar;
     do &menubarType[] -> theBar[];
        (if theBar.struc <> menubar## then
            theBar.open;
            theBar[] -> applicationMenubar;
        if);
     #);
   initCursors:
     (# 
     do IDC_ARROW -> cursors.arrow.load;
        IDC_CROSS -> cursors.cross.load;
        IDC_IBEAM -> cursors.iBeam.load;
        IDC_WAIT -> cursors.watch.load;
        (* No plus cursor !!! *)
     #);
   registerUienvClass:
     (# cstr: @cString;
        theClass: @WndClass;
        result: @integer;
        makeIntResource: external
          (# in: @integer;
             out: [1] @char;
          enter in
          do 'copyinput' -> callC;
          exit out
          #);
     do 'guienvWindowClass' -> uienvStandardWindowClass;
        'guienvWindowClass' -> cstr.set;
        (* CS_HREDRAW + CS_VREDRAW + *) CS_DBLCLKS -> theClass.style;
        StandardWindowProc## -> std16x4toint -> uienvStandardWindowProcAddress;
        uienvStandardWindowProcAddress -> theClass.lpfnWndProc;
        uienvHInstance -> theClass.hInstance;
        (if applIconId=0 then
            (0,IDI_APPLICATION)-> LoadIconInteger -> theClass.hIcon -> result;
         else
            (uienvHInstance,applIconId) -> LoadIconInteger -> theClass.hIcon -> result;
        if);
        (result,'registerUIEnvClass.LoadIconInteger')  -> checkNullError;
        (0,IDC_ARROW) -> LoadCursorInteger -> theClass.hCursor -> result; 
        (result,'registerUIEnvClass.loadCursorInteger')  -> checkNullError;
        COLOR_WINDOW -> GetSysColor -> CreateSolidBrush -> backgroundBrush;
        (backgroundBrush,'registerUIEnvClass.createSolidBrush')  -> checkNullError;
        backgroundBrush -> theClass.hbrBackGround;
        0 -> theClass.lpszMenuName;
        cstr.charPtr -> theClass.lpszClassName;
        theClass[] -> RegisterClass -> result; (result,'registerClass') -> checkNullError;
     #);
do modeless -> modalState; 
   get_beta_instance -> uienvHInstance;
   (* get_beta_previnstance -> hPrevInstance; *)
   32 -> malloc -> private.message;
   registerUienvClass;
   initBP; 
   initCursors;
   initMenubar;
   getScreenRectangle;
   (* true -> doTrace; *)
#)


-- GUIENVDoPart: descriptor --
(# 
do doSetup;
   inner guienv;
   mainLoop;
#)

-- GUIENVactiveWindow: doPart --
do GetActiveWindow -> hWnd;
   (if hWnd=0 then
       none -> theWindow[];
    else
       hWnd -> private.windows.findById -> theWindow[];
   if);
