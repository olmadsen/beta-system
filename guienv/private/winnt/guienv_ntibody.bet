ORIGIN 'guienv_ntiprivate' (*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-97
 *       All rights reserved.
 *)
;
INCLUDE '../linkedlist'
        '../../controls'
        '../../graphics'
        '~beta/win32lib/winbase'
        '~beta/win32lib/devicecapabilities'
        '~beta/win32lib/dcmanagement'
        '~beta/win32lib/winuserconsts'
        '~beta/win32lib/bitmapsupport'
        '~beta/win32lib/wingdi'
        '~beta/win32lib/wingdiconsts'
        '~beta/win32lib/windowmanagement'
        '~beta/win32lib/mousecursorsupport'
        '~beta/win32lib/keyboardinputsupport'
        '~beta/win32lib/messageboxsupport'
        '~beta/win32lib/win32apiinit'
        '~beta/win32lib/menusupport'
        '~beta/win32lib/windowsmisc'
        '~beta/win32lib/systemmetrics'
        '~beta/win32lib/clipboardmanager'
        '~beta/sysutils/cstring'
        '~beta/sysutils/objinterface'
        '~beta/basiclib/file'
        'resizewindowitem'
        'win32menubarprivate'
        'guienvattributes'
        '../../utils/guienvadds';
BODY 'windowbody';
BODY 'drawborderbody';
BODY 'drawseparatorbody';
BODY 'win32menubarbody';
BUILD default '$$/guienv_nti.obj' 'external/guienv_nti.c' 'betacc $0 $1';
-- GUIENVreportLastError: DoPart --
do
   GetLastError->error;
   (if error <> 0 then
       '***Error: '->screen.putText;
       error->screen.putInt;
       ' In: '->screen.puttext;
       msg[]->screen.putline;
       
   if);
     

-- GUIENVStandardWindowProc: Descriptor --
(#
   theInterfaceObject: ^interfaceObject;
   info: ^messageInfo;
   doProcess: @boolean;
   longInt: @CStruct
     (#
        ByteSize:: (#  do 4->Value;  #);
        loWord: signedShort (# Pos:: (#  do 0->Value;  #);  #);
        hiWord: signedShort (# Pos:: (#  do 2->Value;  #);  #);
        
     enter R[1]
     exit R[1]
     #);
   processWM_ENDSESSION:
     (# 
     do
        (if wParam <> 0 then (* The session is beeing ended. *)  if);
        0->result;
        
     #);
   processWM_QUERYENDSESSION:
     (#  do (if onQuit then 1->result;  else 0->result;  if);  #);
   handlePalette:
     (# hdc,hPal,hOldPal,uMappedColors: @integer; 
     do
        (if THIS(guienv).private.curhPal <> 0 then
            THIS(guienv).private.curhPal->hPal; 
         else
            THIS(guienv).private.ghPal->hPal; 
        if);
        (if (hPal <> 0) then
            windowHandle->GetDC->hdc;
            (hdc,hPal,0)->SelectPalette->hOldPal;
            hdc->RealizePalette->uMappedColors;
            (hdc,hOldPal,1)->SelectPalette;
            hdc->RealizePalette;
            (windowHandle,hdc)->ReleaseDC;
            (if (uMappedColors <> 0) then
                (windowHandle,0,1)->InvalidateRect; 1->result; 
             else
                0->result; ; 
            if);
            
         else
            (windowHandle,message,wParam,lParam)->DefWindowProc->result; 
        if);
        
     #);
   
do
   (if message
    // WM_QUERYENDSESSION then
       processWM_QUERYENDSESSION; 
    // WM_ENDSESSION then
       processWM_ENDSESSION; 
    // WM_PALETTECHANGED then
       (if (wParam <> windowHandle) then handlePalette;  else 0->result;  if);
       
    // WM_QUERYNEWPALETTE then
       handlePalette; 
    else
       (if IsMakingDump then
           (windowHandle,message,wParam,lParam)->DefWindowProc->result; 
        else
           windowHandle->private.interfaceObjects.findByID
             ->theInterfaceObject[];
           (if theInterfaceObject[] <> none then
               &messageInfo[]->info[]->pushMessageInfo;
               wParam->longInt;
               longInt.hiWord->info.wParam.hiWord;
               longInt.loWord->info.wParam.loWord;
               wParam->info.wParam;
               lParam->longInt;
               longInt.hiWord->info.lParam.hiWord;
               longInt.loWord->info.lParam.loWord;
               lParam->info.lParam;
               message->info.message;
               GetMessagePos->longInt;
               (longInt.loWord,longInt.hiWord)->info.where;
               getMessageTime->info.time;
               theInterfaceObject.dispatchMessage;
               popMessageInfo;
               (if info.handled then
                   info.result->result; 
                else
                   (windowHandle,message,wParam,lParam)->DefWindowProc->result; 
               if);
               
            else
               (windowHandle,message,wParam,lParam)->DefWindowProc->result; 
           if);
           none ->theInterfaceObject[];
           
       if);
       
   if);
   
#)  

-- GUIENVaddInterfaceObject: DoPart --
do
   (if not (theObject.interfaceObjectID = 0) then
       (if not (theObject[]->private.interfaceObjects.hasObject) then
           theObject[]->private.interfaceObjects.insert; 
        else
             (# msg: @text; 
             do
                'Warning: trying to add interfaceObject twice. Pattern name: '
                  ->msg.append;
                theObject[]->getPatternName->msg.append;
                (none ,msg[],none )->alertUser;
                
             #);
           
       if);
       
   if);
     

-- GUIENVremoveInterfaceObject: DoPart --
do
   (if not (theObject.interfaceObjectID = 0) then
       (if theObject[]->private.interfaceObjects.hasObject then
           theObject[]->private.interfaceObjects.delete; 
       if);
       
   if);
     

-- GUIENVaddWindow: DoPart --
do
   (if not (theWindow[]->private.windows.hasWindow) then
       theWindow[]->private.windows.insert; 
   if);
     

-- GUIENVremoveWindow: DoPart --
do
   (if theWindow[]->private.windows.hasWindow then
       theWindow[]->private.windows.delete; 
   if);
     

-- GUIENVwindowsMakeModal: DoPart --
do
   private.windows.scan
     (# windowID: @integer; 
     do
        current.interfaceObjectID->windowID;
        (if windowID <> ID then
            (if windowID <> 0 then
                (windowID,0)->EnableWindow;
                (if current.type = windowTypes.palette then
                    (windowID,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE+
                     SWP_NOACTIVATE)->SetWindowPos;
                    
                if);
                
            if);
            
        if);
        
     #);
     

-- GUIENVwindowsRemoveModal: DoPart --
do
   private.windows.scan
     (# windowID: @integer; 
     do
        current.interfaceObjectID->windowID;
        (if windowID <> 0 then
            (windowID,1)->EnableWindow;
            (if current.type = windowTypes.palette then
                (windowID,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE+
                 SWP_NOACTIVATE)->SetWindowPos;
                
            if);
            
        if);
        
     #);
     

-- GUIENVterminateBody: DoPart --
do (if onQuit then 0->PostQuitMessage;  if);   

-- GUIENVsetTheMenubar: DoPart --
do theMenubar[]->uienvTheMenubar;   

-- GUIENVgetTheMenubar: DoPart --
do uienvTheMenubar->theMenubar[];   

-- interfaceObjectMethodsdispatchMessage: Descriptor --
(# 
do
   currentMessageInfo->info[];
   (* (if doTrace then
    *        this(interfaceObject)[] -> getPatternName -> screen.putText;
    *        ': ' -> screen.putText;
    *        info.message -> screen.putInt; screen.newLine;
    *    if);
    *)
   INNER dispatchMessage;
   
#)  

-- GUIENVinterfaceObjectdispatchMessage: Descriptor --
(# 
do
   (if private.methods[] <> none then private.methods.dispatchMessage;  if); 
#)  

-- GUIENVinterfaceObjectEvent: DoPart --
do
   (if not (THIS(event)##->eventDisabled) then
       (if private.beforeActions[] <> none then
           private.beforeActions.scan
             (# 
             do
                (if (current.eventType## >= THIS(event)##) then
                    THIS(event)[]->current; 
                if);
                
             #);
           
       if);
       INNER event;
       (if private.afterActions[] <> none then
           private.afterActions.scan
             (# 
             do
                (if (current.eventType## >= THIS(event)##) then
                    THIS(event)[]->current; 
                if);
                
             #);
           
       if);
       
   if);
     

-- GUIENVbasicEventShiftKey: DoPart --
do
     (# info: ^messageInfo; 
     do
     (* currentMessageInfo -> info[];
      * ((info.wParam,MK_SHIFT) -> tos'%and') = MK_SHIFT-> value;
      *) VK_SHIFT->isVKeyDown->value; 
     #)  

-- GUIENVbasicEventAltKey: DoPart --
do VK_MENU->isVKeyDown->value;   

-- GUIENVbasicEventMetaKey: DoPart --
do VK_MENU->isVKeyDown->value;   

-- GUIENVbasicEventControlKey: DoPart --
do
     (# info: ^messageInfo; 
     do
     (* currentMessageInfo -> info[];
      * ((info.wParam,MK_CONTROL) -> tos'%and') = MK_CONTROL -> value;
      *) VK_CONTROL->isVKeyDown->value; 
     #)
     (* -- GUIENVbasicEventCapsLock: doPart --
      do VK_CAPITAL -> isVKeyToggled -> value;
      #) 
      *)  

-- GUIENVbasicEventButtonState: DoPart --
do
     (# info: ^messageInfo; 
     do currentMessageInfo->info[]; info.button->value; 
     #)  

-- GUIENVbasicEventWhen: DoPart --
do
     (# info: ^messageInfo; 
     do currentMessageInfo->info[]; info.time->value; 
     #)  

-- GUIENVbasicEventGlobalPosition: DoPart --
do
     (# info: ^messageInfo; 
     do currentMessageInfo->info[]; info.where->p; 
     #)  

-- GUIENVbasicEventLocalPosition: DoPart --
do
     (# info: ^messageInfo; 
     do
        currentMessageInfo->info[]; (info.lParam.loWord,info.lParam.hiWord)->p; 
     #)  

-- GUIENVmouseEventDoubleClick: DoPart --
do doubleClickPossible->value;   

-- GUIENVkeyEventCh: DoPart --
do
     (# info: ^messageInfo; 
     do currentMessageInfo->info[]; info.key->theChar; 
     #)  

-- GUIENVkeyEventKey: DoPart --
do
     (# info: ^messageInfo; 
     do currentMessageInfo->info[]; info.speckey->theKey; 
     #)  

-- GUIENVmouseDownDelay: DoPart --
do
     (# ticks: @integer; start: @integer; 
     do
        GetTickCount->start;
        l:
        (if mouse.buttonState = buttonState then
            GetTickCount->ticks;
            (if ((ticks-start) < period) then
                restart l; 
             else
                INNER delay; 
            if);
            
        if);
        
     #)  

-- GUIENVupdateRect: DoPart --
do
     (# getrgnboxres: @integer; theNtRectPtr: @integer; 
     do
        &rectangle[]->value[];
        (if interfaceObjectUpdateRgn <> - 1 then
            16->malloc->theNtRectPtr;
            (interfaceObjectUpdateRgn,theNtRectPtr)->GetRgnBox->getrgnboxres;
            (if getrgnboxres <> NULLREGION then
                theNtRectPtr->getRectFromNtRectPtr->value; 
            if);
            theNtRectPtr->free;
            
        if);
        
     #);
     

-- interfaceObjectLib: Attributes --
extractColor:
  (# theColor: @color; theColorRef: @integer; 
  enter theColorRef
  do
     0->theColorRef.%getByte->theColor.red;
     1->theColorRef.%getByte->theColor.green;
     2->theColorRef.%getByte->theColor.blue;
     
  exit theColor
  #);
eventDisabled: booleanValue
  (# ev: ##theEventHandler.event; 
  enter ev##
  do
     (if private.disabledEvents[] = none then
         false->value; 
      else
         ev##->private.disabledEvents.has->value; 
     if);
     
  #);
addDisabledEvent:
  (# e: ^eventSpec; ev: ##theEventHandler.event; 
  enter ev##
  do
     (if private.disabledEvents[] = none then
         &eventSpecList[]->private.disabledEvents[]; 
     if);
     (if not (ev##->private.disabledEvents.has) then
         &eventSpec[]->e[]; ev##->e.type##; e[]->private.disabledEvents.append; 
     if);
     
  #);
removeDisabledEvent:
  (# ev: ##theEventHandler.event; 
  enter ev##
  do
     (if private.disabledEvents[] <> none then
         ev##->private.disabledEvents.remove; 
     if);
     
  #);
  

-- GUIENVinterfaceObjectPrependAction: DoPart --
do
   (if private.beforeActions[] = none then
       &actionList[]->private.beforeActions[]; 
   if);
   (if not (theAction[]->private.beforeActions.member) then
       theAction[]->private.beforeActions.prepend; 
   if);
     

-- GUIENVinterfaceObjectAppendAction: DoPart --
do
   (if private.afterActions[] = none then
       &actionList[]->private.afterActions[]; 
   if);
   (if not (theAction[]->private.afterActions.member) then
       theAction[]->private.afterActions.append; 
   if);
     

-- GUIENVinterfaceObjectDeleteAction: DoPart --
do
   (if private.beforeActions[] <> none then
       theAction[]->private.beforeActions.delete; 
   if);
   (if private.afterActions[] <> none then
       theAction[]->private.afterActions.delete; 
   if);
     

-- GUIENVintefaceObjectCreate: DoPart --
do &interfaceObjectMethods[]->theMethods; true->doAddToList; INNER create;   

-- GUIENVinterfaceObjectOpen: DoPart --
do
     (#
        openTwiceException: exception
          (#  do 'Attempt to open interfaceobject twice.'->msg;  #);
        (* theMenu: @menu; *)
        
     do
        (if not private.isOpen then
            true->private.isOpen;
            create;
            (if doAddToList then
                THIS(interfaceObject)[]->addInterfaceObject; 
            if);
            INNER open;
            
         else
            openTwiceException; 
        if);
        
     #)  

-- GUIENVinterfaceObjectClose: DoPart --
do
   assertOpen;
   INNER close;
   (if doAddToList then THIS(interfaceObject)[]->removeInterfaceObject;  if);
   false->private.isOpen;
     

-- GUIENVenableEventType: DoPart --
do ev##->removeDisabledEvent;   

-- GUIENVdisableEventType: DoPart --
do ev##->addDisabledEvent;   

-- GUIENVinterfaceObjectException: DoPart --
do
   'interfaceobject-exception for '->msg.putText;
   THIS(interfaceObject)[]->getPatternName->msg.putText;
   msg.newline;
   INNER interfaceObjectException;
     

-- GUIENVnotOpenedException: DoPart --
do
   'Attempt to use ' ''->msg.puttext;
   (if location[] <> none then
       location[]->msg.puttext; '' ' in ' ''->msg.puttext; 
   if);
   THIS(interfaceobject)[]->getpatternname->msg.puttext;
   '' ' before calling ' 'open' ''->msg.putline;
   INNER notOpenedException;
     

-- win32MenuLib: Attributes --
KeysToVK:
  (# key,vk: @integer
  enter key
  do
     (if key
      // specKeys.PG_UP then
         VK_PRIOR->vk
      // specKeys.PG_DOWN then
         VK_NEXT->vk
      // specKeys.HOME then
         VK_HOME->vk
      // specKeys.END then
         VK_END->vk
      // specKeys.INSERT then
         VK_INSERT->vk
      // specKeys.F1 then
         VK_F1->vk
      // specKeys.F2 then
         VK_F2->vk
      // specKeys.F3 then
         VK_F3->vk
      // specKeys.F4 then
         VK_F4->vk
      // specKeys.F5 then
         VK_F5->vk
      // specKeys.F6 then
         VK_F6->vk
      // specKeys.F7 then
         VK_F7->vk
      // specKeys.F8 then
         VK_F8->vk
      // specKeys.F9 then
         VK_F9->vk
      // specKeys.LEFT then
         VK_LEFT->vk
      // specKeys.RIGHT then
         VK_RIGHT->vk
      // specKeys.UP then
         VK_UP->vk
      // specKeys.DOWN then
         VK_DOWN->vk
      // '+' then
         VK_ADD->vk
      // '-' then
         VK_SUBTRACT->vk
      // '/' then
         VK_DIVIDE->vk
      // '*' then
         VK_MULTIPLY->vk
      else
         key->ascii.upCase->vk
     if)
  exit vk
  #);
popup: (#  enter private.popup exit private.popup #);
processWin32MenuSelect:
  (#
     id: @integer;
     handled: @boolean;
     theMenuItem: ^menu.menuitem;
     theWin32MenuItem: ^win32Menuitem;
     
  enter id
  do
     id->getItemById->theWin32MenuItem[];
     (if theWin32MenuItem[] = none then
         false->handled; 
      else
         theWin32MenuItem.theMenuItem[]->theMenuItem[];
         (if theMenuItem[] = none then
             false->handled; 
          else
             theMenuItem.theEventHandler.onSelect; true->handled; 
         if);
         
     if);
     
  exit handled
  #);
getItemByID:
  (# id: @integer; i: @integer; theWin32MenuItem: ^win32Menuitem; 
  enter id
  do
     l: private.win32MenuItems.scan
       (# 
       do
          (if current.interfaceObjectID = id then
              current[]->theWin32MenuItem[]; leave l; 
          if);
          
       #);
     
  exit theWin32MenuItem[]
  #);
getItemByNumber:
  (# position: @integer; i: @integer; theWin32MenuItem: ^win32Menuitem; 
  enter position
  do
     l: private.win32MenuItems.scan
       (# 
       do
          i+1->i;
          (if (i = position) then
              current[]->theWin32MenuItem[]; leave l; 
          if);
          
       #);
     
  exit theWin32MenuItem[]
  #);
setKey:
  (#
     position: @integer;
     key: @char;
     theWin32MenuItem: ^win32Menuitem;
     t: @text;
     
  enter (position,key)
  do
     position->getItemByNumber->theWin32MenuItem[];
     (if theWin32MenuItem[] <> none then
         theWin32MenuItem.updateMenuitem; theWin32MenuItem.updateAccTable; 
     if);
     
  #);
setSpecKey:
  (#
     position: @integer;
     key: @char;
     theWin32MenuItem: ^win32Menuitem;
     t: @text;
     
  enter (position)
  do
     position->getItemByNumber->theWin32MenuItem[];
     (if theWin32MenuItem[] <> none then
         theWin32MenuItem.updateMenuitem; theWin32MenuItem.updateAccTable; 
     if);
     
  #);
setName:
  (# position: @integer; name: ^text; theWin32MenuItem: ^win32Menuitem; 
  enter (position,name[])
  do
     position->getItemByNumber->theWin32MenuItem[];
     (if theWin32MenuItem[] <> none then
         theWin32MenuItem.updateMenuitem; 
     if);
     
  #);
setChecked:
  (#
     position: @integer;
     checked: @boolean;
     theWin32MenuItem: ^win32Menuitem;
     
  enter (position,checked)
  do
     position->getItemByNumber->theWin32MenuItem[];
     (if theWin32MenuItem[] <> none then
         checked->theWin32MenuItem.checked; theWin32MenuItem.updateMenuitem; 
     if);
     
  #);
setSubMenu:
  (#
     position: @integer;
     theWin32MenuItem: ^win32Menuitem;
     theMenu: ^menu;
     noOfMenuItems: @integer;
     
  enter (position,theMenu[])
  do
     position->getItemByNumber->theWin32MenuItem[];
     (if theWin32MenuItem[] <> none then
         (if theWin32MenuItem.theWin32Submenu[] <> none then
             (if theWin32MenuItem.theWin32Submenu.isOpen then
                 theWin32MenuItem.theWin32Submenu.close; 
             if);
             
         if);
         (if theMenu[] = none then
             none ->theWin32MenuItem.theWin32Submenu[];
             theWin32MenuItem.updateMenuItem;
             
          else
             &win32Menu[]->theWin32MenuItem.theWin32Submenu[];
             theMenu[]->theWin32MenuItem.theWin32SubMenu.theMenu[];
             THIS(win32Menu).private.theWin32Menubar[]
               ->theWin32MenuItem.theWin32SubMenu.private.theWin32Menubar[];
             theWin32MenuItem.theWin32SubMenu.open;
             theWin32MenuItem.updateMenuItem;
             
         if);
         
     if);
     
  #);
win32Menuitem: interfaceObject
  (#
     theMenuitem: ^menu.menuItem;
     theWin32SubMenu: ^win32Menu;
     checked: @boolean;
     name: ^text;
     result: @integer;
     open::
       (#
          create::
            (# 
            do
               false->doAddToList;
               uniqueMenuItemID->interfaceObjectID
                 ->theMenuitem.interfaceObjectID;
               theMenuitem.name->name[];
               name.copy->name[];
               (if theMenuItem.key = 0 then
                   (if theMenuitem.private.menuitemspeckey > 0 then
                       '\t'->name.put;
                       themenuitem.modifierstotext->name.append;
                       theMenuitem.menuitemspeckey->specKeys.keyToText
                         ->name.append;
                       
                   if)
                else
                   '\tCtrl+'->name.append; theMenuItem.key->name.put; 
               if);
               (if theMenuitem.menuitemIsSeparator then
                   (THIS(win32Menu).interfaceObjectID,MF_SEPARATOR,
                    interfaceObjectID,name)->AppendMenu->result;
                   (if result = 0 then
                       'menuAppend(1) failed!! Error: '->screen.puttext;
                       GetLastError->screen.putint;
                       screen.newline;
                       
                   if);
                   
                else
                   (if theMenuitem.menuItemSubMenu = none then
                       (THIS(win32Menu).interfaceObjectID,MF_STRING,
                        interfaceObjectID,name)->AppendMenu->result;
                       (if result = 0 then
                           'menuAppend(2) failed!! Error: '->screen.puttext;
                           GetLastError->screen.putint;
                           screen.newline;
                           
                       if);
                       
                    else
                       &win32Menu[]->theWin32Submenu[];
                       theMenuitem.menuItemSubMenu->theWin32SubMenu.theMenu[];
                       THIS(win32Menu).private.theWin32Menubar[]
                         ->theWin32SubMenu.private.theWin32Menubar[];
                       theWin32SubMenu.open;
                       (THIS(win32Menu).interfaceObjectID,MF_POPUP+MF_STRING,
                        theWin32SubMenu.interfaceObjectID,name)->AppendMenu
                         ->result;
                       (if result = 0 then
                           'menuAppend(3) failed!! Error: '->screen.puttext;
                           GetLastError->screen.putint;
                           screen.newline;
                           
                       if);
                       
                   if);
                   
               if);
               THIS(win32Menuitem)[]
                 ->THIS(win32Menu).private.win32Menuitems.append;
               INNER create;
               
            #);
          name: ^text;
          
       do INNER open; 
       #);
     close::
       (#
          deleteAccel: external
            (# hAccelTableOld,cmd: @integer; hAccelTableNew: @integer; 
            enter (hAccelTableOld,cmd)
            do callC
            exit hAccelTableNew
            #);
          myWindow: ^window;
          myWin32Menubar: ^win32Menubar;
          
       do
          (if theMenuItem.position > 0 then
              (if theMenuItem.key <> 0 then
                  THIS(win32Menu).private.theWin32Menubar[]->myWin32Menubar[];
                  (if myWin32Menubar[] = none then
                      (if doDebug then
                          'myWin32Menubar is none'->screen.putline;
                          'theMenuItem.name: '->screen.puttext;
                          theMenuItem.name->screen.putline;
                          'theMenuitem.key: '->screen.puttext;
                          theMenuItem.key->screen.put;
                          screen.newline;
                          
                      if);
                      
                   else
                      (myWin32Menubar.hMenubarAccelTable,
                       THIS(win32MenuItem).interfaceObjectID)->deleteAccel
                        ->myWin32Menubar.hMenubarAccelTable;
                      myWin32Menubar.theWindow[]->myWindow[];
                      (if GetActiveWindow = myWindow.interfaceObjectID then
                          myWin32Menubar.hMenubarAccelTable->hAccelTable; 
                      if);
                      
                  if);
                  
              if);
              (if theWin32Submenu[] <> none then
                  (if theWin32Submenu.isOpen then theWin32Submenu.close;  if);
                  
              if);
              
          if);
          
       #);
     win32MenuItemIsSeparator: (#  exit theMenuItem.menuItemIsSeparator #);
     updateAccTable:
       (#
          updateAccelTable: external
            (#
               hAccelTableOld,fVirt,cmd: @integer;
               key: @char;
               hAccelTableNew: @integer;
               
            enter (hAccelTableOld,fVirt,key,cmd)
            do callC
            exit hAccelTableNew
            #);
          myWindow: ^window;
          myWin32Menubar: ^win32Menubar;
          
       do
          (if theMenuItem.position > 0 then
              (if theMenuItem.key = 0 then
                  (if themenuitem.private.menuitemspeckey > 0 then
                      THIS(win32Menu).private.theWin32Menubar[]
                        ->myWin32Menubar[];
                      (if myWin32Menubar[] <> none then
                          (myWin32Menubar.hMenubarAccelTable,
                           themenuitem.modifiersToWin32const,
                           theMenuItem.private.menuitemspecKey->KeysToVK,
                           THIS(win32MenuItem).interfaceObjectID)
                            ->updateAccelTable
                            ->myWin32Menubar.hMenubarAccelTable;
                          myWin32Menubar.theWindow[]->myWindow[];
                          (if GetActiveWindow = myWindow.interfaceObjectID then
                              myWin32Menubar.hMenubarAccelTable->hAccelTable; 
                          if)
                      if)
                  if)
               else
                  THIS(win32Menu).private.theWin32Menubar[]->myWin32Menubar[];
                  (if myWin32Menubar[] = none then
                      (if doDebug then
                          'myWin32Menubar is none'->screen.putline;
                          'theMenuItem.name: '->screen.puttext;
                          theMenuItem.name->screen.putline;
                          'theMenuitem.key: '->screen.puttext;
                          theMenuItem.key->screen.put;
                          screen.newline;
                          
                      if);
                      
                   else
                      (myWin32Menubar.hMenubarAccelTable,FCONTROL,
                       theMenuItem.Key->KeysToVK,
                       THIS(win32MenuItem).interfaceObjectID)->updateAccelTable
                        ->myWin32Menubar.hMenubarAccelTable;
                      myWin32Menubar.theWindow[]->myWindow[];
                      (if GetActiveWindow = myWindow.interfaceObjectID then
                          myWin32Menubar.hMenubarAccelTable->hAccelTable; 
                      if);
                      
                  if);
                  
              if);
              
          if);
          
       #);
     updateMenuItem:
       (#
          result: @integer;
          flags: @integer;
          name: ^text;
          hSubMenu: @integer;
          noOfItemsInSubmenu: @integer;
          
       do
          (if (theMenuItem.position > 0) then
              (if not win32MenuItemIsSeparator then
                  theMenuItem.name->name[];
                  name.copy->name[];
                  (if theMenuItem.key = 0 then
                      (if theMenuitem.private.menuitemspeckey > 0 then
                          '\t'->name.put;
                          themenuitem.modifierstotext->name.append;
                          theMenuitem.private.menuitemspeckey
                            ->specKeys.keyToText->name.append
                      if)
                   else
                      '\tCtrl+'->name.append; theMenuItem.key->name.put; 
                  if);
                  (if theWin32SubMenu[] = none then
                      (if checked then MF_CHECKED->flags;  if);
                      (THIS(win32Menu).interfaceObjectID,theMenuItem.position-1,
                       MF_BYPOSITION+MF_STRING+flags,interfaceObjectID,name)
                        ->ModifyMenu->result;
                      (if result = 0 then
                          'updateMenuItem(1), modifyMenu failed!! Error: '
                            ->screen.putText;
                          GetLastError->screen.putint;
                          screen.newline;
                          'Name of menuitem: '->screen.puttext;
                          name[]->screen.putline;
                          
                      if);
                      
                   else
                      (THIS(win32Menu).interfaceObjectID,theMenuItem.position-1)
                        ->GetSubMenu->hSubMenu;
                      (THIS(win32Menu).interfaceObjectID,theMenuItem.position-1,
                       MF_BYPOSITION)->RemoveMenu->result;
                      (if result = 0 then
                          'Could not remove submenu in modifymenuitem. Error: '
                            ->screen.puttext;
                          GetLastError->screen.putint;
                          screen.newline;
                          
                      if);
                      (THIS(win32Menu).interfaceObjectID,theMenuItem.position-1,
                       MF_BYPOSITION+MF_POPUP+MF_STRING,
                       theWin32SubMenu.interfaceObjectID,name)->InsertMenu
                        ->result;
                      (if result = 0 then
                          'InsertMenu failed in modifymenuitem. Error: '
                            ->screen.puttext;
                          GetLastError->screen.putint;
                          screen.newline;
                          
                      if);
                      
                  if);
                  
              if);
              
          if);
          
       #);
     enabled:
       (#
          value: @boolean;
          enableFlag: @integer;
          result: @integer;
          noOfItems: @integer;
          
       enter value
       do
          (if not win32MenuItemIsSeparator then
              (if (theMenuItem.position > 0) then
                  (if value then
                      MF_ENABLED->enableFlag; 
                   else
                      MF_GRAYED->enableFlag; 
                  if);
                  (THIS(win32Menu).interfaceObjectID,theMenuItem.position-1,
                   MF_BYPOSITION+enableFlag)->EnableMenuItem->result;
                  (if result
                   // MF_ENABLED // MF_DISABLED // MF_GRAYED then 
                   else
                      'enable(1), EnableMenuItem failed!! Error: '
                        ->screen.puttext;
                      GetLastError->screen.putint;
                      screen.newline;
                      'theMenuItem.name, theMenu.name: '->screen.puttext;
                      theMenuitem.name->screen.putline;
                      THIS(win32Menu).theMenu.name->screen.putline;
                      
                  if);
                  
               else
                  '**WARNING: enabled: theMenuItem.position=0!!'
                    ->screen.putline;
                  
              if);
              
          if);
          
       #);
     (* end of enabled *)
     
  #);
(* end of win32Menuitem *)
  

-- GUIENVwin32Menuappend: DoPart --
do
     (# theWin32MenuItem: ^win32Menuitem; 
     do
        &win32Menuitem[]->theWin32MenuItem[];
        theItem[]->theWin32MenuItem.theMenuitem[];
        theWin32MenuItem.open;
        theWin32MenuItem.updateAccTable;
        (* 20-1-95 *)
        
     #);
     

-- GUIENVwin32MenuDelete: DoPart --
do
     (# theWin32Item: ^win32Menuitem; result: @integer; 
     do
        l: private.win32MenuItems.scan
          (# 
          do
             (if theItem[] = current.theMenuitem[] then
                 current[]->theWin32Item[]; leave l; 
             if);
             
          #);
        (if (theWin32Item[] <> none ) then
            theWin32Item[]->private.win32MenuItems.remove;
            theWin32Item.close;
            (interfaceObjectID,theWin32Item.theMenuItem.position-1,
             MF_BYPOSITION)->RemoveMenu->result;
            (if result = 0 then
                'menuDelete(1), modifyMenu failed!! Error: '->screen.puttext;
                GetLastError->screen.putint;
                screen.newline;
                'Name of menuitem: '->screen.puttext;
                theWin32Item.theMenuItem.name->screen.putline;
                
            if);
            
        if);
        
     #)  

-- GUIENVwin32MenuCreate: DoPart --
do
   false->doAddToList;
   (if popup then
       CreatePopupMenu->interfaceObjectID; 
    else
       CreateMenu->interfaceObjectID; 
   if);
   theMenu.scan
     (# theWin32Menuitem: ^win32Menuitem; 
     do
        &win32Menuitem[]->theWin32Menuitem[];
        current[]->theWin32Menuitem.theMenuitem[];
        theWin32Menuitem.open;
        theWin32MenuItem.updateAccTable;
        (* 21-1-95 *)
        
     #);
   THIS(win32Menu)[]->theMenu.private.win32Menus.append;
   INNER create;
     

-- GUIENVwin32MenuOpen: DoPart --
do INNER open;   

-- GUIENVwin32MenuInit: DoPart --
do
   (if THIS(win32Menu).isOpen then
       (if theMenu.menuEnabled then
           private.win32MenuItems.scan
             (# 
             do current.theMenuitem.theEventHandler.onStatus->current.enabled; 
             #);
           
        else
           private.win32MenuItems.scan (#  do false->current.enabled;  #); 
       if);
       
   if);
     

-- GUIENVwin32MenuClose: DoPart --
do
   private.win32Menuitems.scan
     (#  do current.close;  #);
   private.win32Menuitems.clear;
   THIS(win32Menu)[]->theMenu.private.win32Menus.remove;
   interfaceObjectID->DestroyMenu;
   0->interfaceObjectID;
     

-- GUIENVwin32MenuPrivate: Descriptor --
(#
   win32MenuItems: @list
     (#
        element:: win32Menuitem;
        remove: (# e: ^element;  enter e[] do e[]->at->delete;  #);
        
     #);
   position: @integer;
   popup: @boolean;
   theWin32menubar: ^win32Menubar;
   
#)  

-- menubarLib: Attributes --
menubarInsertMenu:
  (# theMenu,after: ^menu; 
  enter (theMenu[],after[])
  do
     (if not (theMenu[]->private.menuBarMenus.has) then
         (if (after[]->private.menuBarMenus.has) then
             (theMenu[],after[]->private.menuBarMenus.at)
               ->private.menuBarMenus.insertAfter;
             
         if);
         
     if);
     
  #);
menuBarAppendMenu:
  (# theMenu: ^menu; 
  enter theMenu[]
  do
     (if not (theMenu[]->private.menuBarMenus.has) then
         theMenu[]->private.menuBarMenus.append;
         THIS(menubar)[]->theMenu.menuFather;
         
     if);
     
  #);
menuBarDeleteMenu:
  (# theMenu: ^menu; 
  enter theMenu[]
  do
     (if (theMenu[]->private.menuBarMenus.has) then
         theMenu[]->private.menuBarMenus.at->private.menuBarMenus.delete; 
     if);
     
  #);
processMenuselect:
  (# id: @integer; handled: @boolean; 
  enter id
  do
     theScan: scan
       (# 
       do
          id->current.processMenuSelect->handled;
          (if handled then leave theScan;  if);
          
       #);
     
  exit handled
  #);
  

-- GUIENVmenubarAppend: DoPart --
do
   assertOpen;
   (if THIS(menubar)[] = applicationMenubar then
       theMenu[]->menuBarAppendMenu;
       private.windows.scan
         (# 
         do
            theMenu[]->current.private.theWin32Menubar.insert;
            current.interfaceObjectID->DrawMenuBar;
            
         #);
       
    else
       theMenu[]->menuBarAppendMenu;
       (if (private.theWin32Menubar[] <> none ) then
           theMenu[]->private.theWin32Menubar.append;
           private.windows.scan
             (#  do current.interfaceObjectID->DrawMenuBar;  #);
           
       if);
       
   if);
     

-- GUIENVmenubarDelete: DoPart --
do
   assertOpen;
   theMenu[]->menuBarDeleteMenu;
   (if THIS(menubar)[] = applicationMenubar then
       private.windows.scan
         (# 
         do
            (if current.interfaceObjectID <> 0 then
                theMenu[]->current.private.theWin32Menubar.delete;
                current.interfaceObjectID->DrawMenuBar;
                
            if);
            
         #);
       
    else
       theMenu[]->private.theWin32Menubar.delete;
       private.windows.scan
         (#  do current.interfaceObjectID->DrawMenuBar;  #);
       
   if);
     

-- GUIENVmenubarClear: DoPart --
do assertOpen; private.menubarMenus.scan (#  do current[]->delete;  #);   

-- GUIENVmenubarAppendMenubar: DoPart --
do
   assertOpen; theMenubar.scan (#  do current[]->THIS(menuBar).append;  #);   

-- GUIENVmenubarReplaceMenubar: DoPart --
do
   assertOpen;
   theMenubar[]->deleteMenubar;
   replacementMenubar[]->appendMenubar;
     

-- GUIENVmenubarDeleteMenubar: DoPart --
do
   assertOpen; theMenubar.scan (#  do current[]->THIS(menuBar).delete;  #);   

-- GUIENVmenubarScan: DoPart --
do
   assertOpen;
   private.menubarMenus.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVmenubarCreate: DoPart --
do false->doAddToList; INNER create;   

-- GUIENVmenubarOpen: DoPart --
do INNER open;   

-- GUIENVmenubarClose: DoPart --
do INNER close; clear;   

-- GUIENVmenubarPrivate: Descriptor --
(#
   menubarMenus: @list (# element:: Menu;  #);
   windows: @list (# element:: window;  #);
   theWin32Menubar: ^win32Menubar;
   hMenubarAccelTable: @integer;
   
#)  

-- menuLib: Attributes --
win32PopupMenu:
  (#  enter private.win32PopupMenu[] exit private.win32PopupMenu[] #);
menuName: (#  enter private.menuName[] exit private.menuName[] #);
menuFather: (#  enter private.menuFather[] exit private.menuFather[] #);
menuEnabled: (#  enter private.menuEnabled exit private.menuEnabled #);
menuAppendMenuItem:
  (# theMenuItem: ^menuItem; 
  enter theMenuitem[]
  do
     (if not (theMenuitem[]->private.menuItems.has) then
         theMenuitem[]->private.menuItems.append;
         private.menuItems.size->theMenuItem.menuItemPosition;
         private.win32Menus.scan
           (#  do theMenuItem[]->current.append;  #);
         
     if);
     
  #);
menuDeleteMenuItem:
  (# theMenuItem: ^menuItem; thePosition: @integer; 
  enter theMenuitem[]
  do
     theMenuItem.menuItemPosition->thePosition;
     (if (theMenuitem[]->private.menuItems.has) then
         theMenuitem[]->private.menuItems.at->private.menuItems.delete; 
     if);
     private.menuItems.scan
       (# 
       do
          (if (current.menuItemPosition > thePosition) then
              current.menuItemPosition-1->current.menuItemPosition; 
          if);
          
       #);
     
  #);
processInitMenu:
  (# 
  do
     THIS(menu).theEventHandler.onSelect;
     THIS(menu).private.win32Menus.scan
       (#  do current.init;  #);
     
  #);
processMenuSelect:
  (# id: @integer; handled: @boolean; theMenuItem: ^menuitem; 
  enter id
  do
     l: THIS(menu).private.win32Menus.scan
       (# 
       do
          id->current.processWin32MenuSelect->handled;
          (if handled then leave l;  if);
          
       #);
     
  exit handled
  #);
  

-- GUIENVmenuSetName: DoPart --
do assertOpen; theName.copy->menuName;   

-- GUIENVmenuGetName: DoPart --
do assertOpen; menuName->theName[]; theName.copy->theName[];   

-- menuItemLib: Attributes --
modifiersToWin32Const:
  (# const: @integer
  do
  (*  MBE: Changed to be able to have more than one modifier
   * (if private.shift then
   FSHIFT->const
   else
   (if private.ctrl then
   FCONTROL->const
   else
   (if private.alt then FALT->const if)
   if)
   if) *)
     (if private.shift then FSHIFT->const if);
     (if private.ctrl then FCONTROL+const->const if);
     (if private.alt then FALT+const->const if)
  exit const
  #);
modifiersToText:
  (# t: ^text; 
  do (* MBE: Changed to be able to have more than one modifier *)
  (* (if private.shift then
   'Shift+'->t[]
   else
   (if private.ctrl then
   'Ctrl+'->t[]; 
   else
   (if private.alt then 'Alt+'->t[] if)
   if)
   if) *)
     &text[]->t[];
     (if private.ctrl then 'Ctrl+'->t[] if);
     (if private.alt then 'Alt+'->t.append if);
     (if private.shift then 'Shift+'->t.append if)
  exit t[]
  #);
menuitemIsSeparator:
  (#  enter private.menuitemIsSeparator exit private.menuitemIsSeparator #);
menuitemKey: (#  enter private.menuitemKey exit private.menuitemKey #);
menuitemSpecKey:
  (#  enter private.menuitemSpecKey exit private.menuitemSpecKey #);
menuItemName:
  (#  enter private.menuItemName[] exit private.menuItemName[] #);
menuItemChecked:
  (#  enter private.menuItemChecked exit private.menuItemChecked #);
menuItemSubMenu:
  (#  enter private.menuItemSubMenu[] exit private.menuItemSubMenu[] #);
menuItemPosition:
  (#  enter private.menuItemPosition exit private.menuItemPosition #);
  

-- GUIENVmenuitemSetKey: DoPart --
do
   assertOpen;
   c->Ascii.upCase->private.menuitemKey;
   THIS(menu).private.win32Menus.scan
     (#  do (position,c)->current.setKey;  #);
     

-- GUIENVmenuitemGetKey: DoPart --
do assertOpen; private.menuitemKey->c;   

-- GUIENVmenuitemSetSpecialKey: DoPart --
do
   key->private.menuitemspeckey;
   shift->private.shift;
   ctrl->private.ctrl;
   alt->private.alt;
   ctrl %Bor alt %Bor shift->private.hasmod;
   THIS(menu).private.win32Menus.scan
     (#  do (position)->current.setSpecKey;  #);
     

-- GUIENVmenuitemSetName: DoPart --
do
   assertOpen;
   (if t[] <> none then
       t.copy->private.menuItemName[];
       THIS(menu).private.win32Menus.scan
         (#  do (position,t[])->current.setName;  #);
       
   if);
     

-- GUIENVmenuitemGetName: DoPart --
do assertOpen; private.menuItemName.copy->t[];   

-- GUIENVmenuitemSetChecked: DoPart --
do
   assertOpen;
   checked->private.menuItemChecked;
   THIS(menu).private.win32Menus.scan
     (#  do (position,checked)->current.setChecked;  #);
     

-- GUIENVmenuitemGetChecked: DoPart --
do assertOpen; private.menuItemChecked->checked;   

-- GUIENVsetSubMenu: DoPart --
do
   assertOpen;
   (if (theMenu[] <> private.menuItemSubMenu[]) then
       theMenu[]->private.menuItemSubMenu[];
       THIS(menu).private.win32Menus.scan
         (#  do (position,theMenu[])->current.setSubMenu;  #);
       
   if);
     

-- GUIENVgetSubMenu: DoPart --
do assertOpen; private.menuItemSubMenu[]->theMenu[];   

-- GUIENVmenuitemPosition: DoPart --
do assertOpen; private.menuItemPosition->value;   

-- GUIENVmenuitemOnStatus: DoPart --
do true->value; INNER onStatus;   

-- GUIENVmenuitemCreate: DoPart --
do false->doAddToList; INNER create;   

-- GUIENVmenuitemOpen: DoPart --
do THIS(menuItem)[]->getPatternName->private.menuItemname[]; INNER open;   

-- GUIENVmenuitemPrivate: Descriptor --
(#
   menuItemChecked: @boolean;
   menuitemKey,menuitemMark: @char;
   menuItemName: ^text;
   menuItemSubMenu: ^menu;
   menuItemPosition: @integer;
   menuitemIsSeparator: @boolean;
   menuitemSpecKey: @integer;
   alt,shift,ctrl,hasmod: @boolean;
   
#)  

-- GUIENVmenuitemAttach: DoPart --
do
   assertOpen;
   (if (theAction[] <> none ) then none ->theAction.theMenuitem[];  if);
   anAction[]->theAction[];
   (if (theAction[] <> none ) then
       THIS(dynamicMenuitem)[]->theAction.theMenuitem[]; 
   if);
     

-- GUIENVmenuitemDetach: DoPart --
do
   assertOpen;
   (if theAction[] <> none then none ->theAction.theMenuitem[];  if);
   none ->theAction[];
     

-- GUIENVdynamicMenuitemOnStatus: DoPart --
do
   (if theAction[] = none then
       false->value; 
    else
       theAction.onStatus->value; 
   if);
     

-- GUIENVdynamicMenuitemOnSelect: DoPart --
do (if theAction[] = none then  else theAction.onSelect;  if);   

-- GUIENVactionOnStatus: DoPart --
do true->value; INNER onStatus;   

-- GUIENVseparatorCreate: DoPart --
do INNER create;   

-- GUIENVseparatorOpen: DoPart --
do true->menuitemIsSeparator; INNER open;   

-- GUIENVseparatorClose: DoPart --
do INNER close;   

-- GUIENVmenuAppend: DoPart --
do assertOpen; theMenuitem[]->menuAppendMenuItem;   

-- GUIENVmenuDelete: DoPart --
do
   assertOpen;
   theMenuitem[]->menuDeleteMenuItem;
   private.win32Menus.scan
     (#  do theMenuItem[]->current.delete;  #);
   THIS(menu)[]->THIS(guienv).private.menuChanged;
     

-- GUIENVmenuScan: DoPart --
do
   assertOpen;
   private.menuItems.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVmenuClear: DoPart --
do assertOpen; scan (#  do current[]->delete;  #);   

-- GUIENVmenuNoOfMenuitems: DoPart --
do assertOpen; private.menuitems.size->value;   

-- GUIENVmenuPopUp: DoPart --
do
     (#
        translate:
          (# h,v: @integer; ntpPtr: @integer; interfaceObjID: @integer; 
          enter (interfaceObjID,h,v)
          do
             (h,v)->makeNtPointPtr->ntpPtr;
             (interfaceObjID,ntpPtr)->ClientToScreen;
             ntpPtr->getPointFromNtPointPtr->(h,v);
             ntpPtr->free;
             
          exit (h,v)
          #);
        thePopupMenu: ^win32Menu;
        thePoupMenuID: @integer;
        theWindowItemID: @integer;
        theItem: ^interfaceObject;
        h_root,v_root: @integer;
        deltaH: @integer;
        
     do
        assertOpen;
        (if (popupIn[] <> none ) then
            popupIn.interfaceObjectID->theWindowItemID;
            (if (theWindowItemID <> 0) then
                (if private.win32PopupMenu[] = none then
                    &win32Menu[]->private.win32PopupMenu[];
                    THIS(menu)[]->private.win32PopupMenu.theMenu[];
                    true->private.win32PopupMenu.popup;
                    private.win32PopupMenu[]->thePopupMenu[];
                    thePopupMenu.open;
                    
                 else
                    private.win32PopupMenu[]->thePopupMenu[]; 
                if);
                (theWindowItemID,popupAt.h,popupAt.v)->translate
                  ->(h_root,v_root);
                popupWith->thePopupMenu.getItemByNumber->theItem[];
                (if theItem[] <> none then
                    SM_CYMENU->GetSystemMetrics->deltaH;
                    h_root-10->h_root;
                    v_root-((deltaH*popupWith)-deltaH div 2)->v_root;
                    
                if);
                thePopupMenu.interfaceObjectID->thePoupMenuID;
                (thePoupMenuID,TPM_LEFTALIGN+TPM_RIGHTBUTTON,h_root,v_root,0,
                 theWindowItemID,0)->TrackPopupMenu;
                
            if);
            
        if);
        
     #)  

-- GUIENVmenuGetMenuitemByNumber: DoPart --
do
     (# count: @integer; 
     do
        assertOpen;
        l: private.menuItems.scan
          (# 
          do
             count+1->count;
             (if count = number then current[]->theMenuitem[]; leave l;  if);
             
          #);
        
     #)  

-- GUIENVmenuEnable: DoPart --
do assertOpen; true->menuEnabled;   

-- GUIENVmenuDisable: DoPart --
do assertOpen; false->menuEnabled;   

-- GUIENVmenuEnabled: DoPart --
do assertOpen; menuEnabled->value;   

-- GUIENVmenuCreate: DoPart --
do false->doAddToList; INNER create;   

-- GUIENVmenuOpen: DoPart --
do
   THIS(menu)[]->getPatternName->menuName;
   THIS(menu)[]->THIS(guienv).private.menus.append;
   true->menuEnabled;
   INNER open;
     

-- GUIENVmenuClose: DoPart --
do
   INNER close;
   THIS(menu).private.win32menus.scan
     (#  do current.close;  #);
   THIS(menu)[]->THIS(guienv).private.menus.remove;
     

-- GUIENVstandardFileMenuOpen: DoPart --
do
   'File'->name;
   newMenuitem.open;
   'New'->newMenuitem.name;
   newMenuitem[]->append;
   openMenuitem.open;
   'Open...'->openMenuitem.name;
   openMenuitem[]->append;
   closeMenuitem.open;
   'Close'->closeMenuitem.name;
   closeMenuitem[]->append;
   saveMenuitem.open;
   'Save'->saveMenuitem.name;
   saveMenuitem[]->append;
   saveAsMenuitem.open;
   'Save as...'->saveAsMenuitem.name;
   saveAsMenuitem[]->append;
   revertMenuitem.open;
   'Revert'->revertMenuitem.name;
   revertMenuitem[]->append;
   printMenuitem.open;
   'Print...'->printMenuitem.name;
   printMenuitem[]->append;
   pageSetUpMenuitem.open;
   'Page setup'->pageSetUpMenuitem.name;
   pageSetUpMenuitem[]->append;
   quitMenuitem.open;
   'Quit'->quitMenuitem.name;
   quitMenuitem[]->append;
   INNER open;
     

-- GUIENVstandardEditMenuOpen: DoPart --
do
   'Edit'->name;
   undoMenuItem.open;
   'Undo'->undoMenuItem.name;
   undoMenuItem[]->append;
   cutMenuItem.open;
   'Cut'->cutMenuItem.name;
   cutMenuItem[]->append;
   copyMenuItem.open;
   'Copy'->copyMenuItem.name;
   copyMenuItem[]->append;
   pasteMenuItem.open;
   'Paste'->pasteMenuItem.name;
   pasteMenuItem[]->append;
   clearMenuItem.open;
   'Clear'->clearMenuItem.name;
   clearMenuItem[]->append;
     

-- GUIENVstandardMenubarOpen: DoPart --
do
   &fileMenu[]->theFileMenu[];
   (if theFileMenu## <> menu## then
       theFileMenu.open; theFileMenu[]->append; 
    else
       none ->theFileMenu[]; 
   if);
   &editMenu[]->theEditMenu[];
   (if theEditMenu## <> menu## then
       theEditMenu.open; theEditMenu[]->append; 
    else
       none ->theEditMenu[]; 
   if);
   INNER open;
     

-- windowItemLib: Attributes --
updateArea:
  (# r: ^rectangle; theNtRectPtr: @integer; 
  enter r[]
  do
     r[]->makeNtRectPtr->theNtRectPtr;
     (interfaceObjectID,theNtRectPtr,1)->InvalidateRect;
     theNtRectPtr->free;
     
  #);
processFatherFrameChanged:
  (# oldFrame,newFrame,chainRect,itsFrame: @rectangle; delta: @Point; 
  enter (oldFrame,newFrame)
  do
     newFrame.size->delta;
     oldFrame.size->delta.subTract;
     (if not ((0,0)->delta.isEqual) then
         windowItemFrame->chainRect->itsFrame;
         delta->chainRect.offset;
         (if not bindLeft then chainRect.left->itsFrame.left;  if);
         (if bindBottom then chainRect.bottom->itsFrame.bottom;  if);
         (if bindRight then chainRect.right->itsFrame.right;  if);
         (if not bindTop then chainRect.top->itsFrame.top;  if);
         itsFrame->frame;
         
     if);
     (oldFrame,newFrame)->theEventHandler.onFatherframeChanged;
     
  #);
  

-- GUIENVwindowItemHandleFrameChanged: DoPart --
do
   (if not (oldFrame->newFrame.isEqual) then
       newFrame->private.windowItemFrame;
       (oldFrame,newFrame)->theEventHandler.onframeChanged;
       (if (father[] <> none ) then
           (oldFrame,newFrame)->father.handleChildframeChanged; 
       if);
       (if THIS(windowItem)## <= canvas## then
           THIS(windowItem)[]->thisCanvas[];
           thisCanvas.private.children.scan
             (# 
             do (oldFrame,newFrame)->current.processFatherFrameChanged; 
             #);
           
       if);
       (if (interfaceObjectID = 0) and private.visibleFlag then
           oldFrame[]->father.updateArea; newFrame[]->father.updateArea; 
       if);
       (if private.updateOnResize or
       ((isStandardClass = windowItemClassStatus) and border.visible) then
           (if interfaceObjectID <> 0 then
               (if (interfaceObjectID->IsWindowVisible) <> 0 then
                   update; 
               if);
               
           if);
           
       if);
       
   if);
     

-- GUIENVwindowItemMethodsdispatchMessage: Descriptor --
(#
   button: @integer;
   pt: @point;
   key: @char;
   VirtualKey: @integer;
   WM_MOUSELEAVE: (#  exit 0x02A3 #);
   mouseTrackPtr: @integer;
   extractInfo: (#  do (info.lParam.loWord,info.lParam.hiWord)->pt;  #);
   processMouseDown:
     (# 
     do
        extractInfo;
        interfaceObjectID->THIS(guienv).private.lastCaptureID;
        false->doubleClickPossible;
        theEventHandler.onMouseDown;
        (if private.disableDefaultEventHandling then
            false->info.callback; true->didSomething; 0->info.result; 
        if);
        
     #);
   processMouseUp:
     (# w,h: @integer; 
     do
        extractInfo;
        (if (THIS(guienv).private.lastCaptureID = interfaceObjectID) then
            size->(w,h);
            (* Call onMouseUp only if mouse pointer is positioned over this 
             * windowItem. 
             *)
            (if ((0 < pt.h) and (pt.h < w) and (0 < pt.v) and (pt.v < h)) then
                (if doubleClickPossible then
                    0->THIS(guienv).private.lastCaptureID; 
                if);
                theEventHandler.onMouseUp;
                
            if);
            
        if);
        
     #);
   processDoubleClick:
     (# 
     do extractInfo; true->doubleClickPossible; theEventHandler.onMouseDown; 
     #);
   processBeforeWM_CHAR:
     (# callEventHandler: @boolean; spk: @specialKeys
     do
        info.wParam->VirtualKey;
        false->callEventHandler;
        0->info.speckey;
        VirtualKey->info.key;
        (if VirtualKey
         // VK_LEFT then
            ASCII.fs->info.key; true->callEventHandler; 
         // VK_UP then
            ASCII.rs->info.key; true->callEventHandler; 
         // VK_RIGHT then
            ASCII.gs->info.key; true->callEventHandler; 
         // VK_DOWN then
            ASCII.us->info.key; true->callEventHandler; 
         // VK_DELETE then
            ASCII.del->info.key; true->callEventHandler; 
         // VK_HOME then
            spk.HOME->info.speckey; true->callEventHandler
         // VK_PRIOR then
            spk.PG_UP->info.speckey; true->callEventHandler
         // VK_NEXT then
            spk.PG_DOWN->info.speckey; true->callEventHandler
         // VK_END then
            spk.END->info.speckey; true->callEventHandler
         // VK_BACK then
            true->callEventHandler; 
        if);
        (if callEventHandler then
            theEventHandler.onKeyDown; 
         else
            false->didSomething; 
        if);
        (if private.disableDefaultEventHandling then
            false->info.callback; true->didSomething; 0->info.result; 
        if);
        
     #);
   processKeyDown:
     (# defaultButton: ^windowItem; 
     do
        info.wParam->key;
        key->info.key;
        (if key <> VK_BACK then
            windowDefaultButton->defaultButton[];
            (if (defaultButton[] <> none ) then
                (if key = ascii.cr then
                    defaultButton.theEventHandler.onMouseUp; 
                if);
                
            if);
            theEventHandler.onKeyDown;
            
        if);
        
     #);
   processRefresh:
     (# ps: @integer; hRgn: @integer; 
     do
        (0,0,0,0)->CreateRectRgn->hRgn;
        (interfaceObjectID,hRgn,0)->GetUpdateRgn;
        hRgn->interfaceObjectUpdateRgn;
        (if windowItemClassStatus = isSubClass then
            theEventHandler.onRefresh; 
         else
            64->malloc->ps;
            (interfaceObjectID,ps)->BeginPaint->windowItemDevice;
            theEventHandler.onRefresh;
            (interfaceObjectID,ps)->EndPaint;
            ps->free;
            0->windowItemDevice;
            
        if);
        hRgn->DeleteObject;
        - 1->interfaceObjectUpdateRgn;
        
     #);
   processActivate:
     (# activation: @boolean; 
     do
        info.wParam <> 0->activation;
        (if activation then
            theEventHandler.onActivate; 
         else
            theEventHandler.onDeactivate; 
        if);
        
     #);
   processEnableTarget: (#  do theEventHandler.onEnableTarget;  #);
   processDisableTarget: (#  do theEventHandler.onDisableTarget;  #);
   processMove:
     (# newPosition: @point; r: @rectangle; 
     do
        (info.lParam.loWord,info.lParam.hiWord)->newPosition;
        windowitemFrame->r;
        r.topLeft->newPosition.subTract;
        newPosition->r.offset;
        r->windowItemFrame;
        
     #);
   processResize:
     (#
        width,height: @integer;
        r: @rectangle;
        wStyle: @integer;
        hasVScroll: external
          (# wStyle: @integer; res: @integer; 
          enter wStyle
          do callC; 
          exit res
          #);
        hasHScroll: external
          (# wStyle: @integer; res: @integer; 
          enter wStyle
          do callC; 
          exit res
          #);
        
     do
        (info.lParam.loWord,info.lParam.hiWord)->(width,height);
        (interfaceObjectID,GWL_STYLE)->GetWindowLong->wStyle;
        (if (wStyle->hasVScroll) <> 0 then
            width+(SM_CXVSCROLL->GetSystemMetrics)->width; 
        if);
        (if (wStyle->hasHScroll) <> 0 then
            height+(SM_CYHSCROLL->GetSystemMetrics)->height; 
        if);
        windowItemFrame->r;
        (width,height)->r.size;
        r->windowItemFrame;
        
     #);
   processHscroll:
     (#
        scrollCode: @integer;
        currentValue,pos: @integer;
        theScrollbar: ^scrollbar;
        theInterfaceObject: ^interfaceObject;
        
     do
        info.wParam.hiWord->pos;
        info.wParam.loWord->scrollCode;
        info.lParam->findInterfaceObjecById->theInterfaceObject[];
        &scrollbar[]->theScrollbar[];
        (if (theInterfaceObject[] <> none ) then
            (if (theInterfaceObject## <= theScrollbar##) then
                theInterfaceObject[]->theScrollbar[];
                (if (theScrollbar[] <> none ) then
                    (if scrollCode
                     // SB_BOTTOM then
                        
                     // SB_LINELEFT then
                        theScrollbar.theEventHandler.onButtonUp;
                        theScrollbar.theEventHandler.onValueChanged;
                        
                     // SB_LINERIGHT then
                        theScrollbar.theEventHandler.onButtonDown;
                        theScrollbar.theEventHandler.onValueChanged;
                        
                     // SB_PAGELEFT then
                        theScrollbar.theEventHandler.onPageUp;
                        theScrollbar.theEventHandler.onValueChanged;
                        
                     // SB_PAGERIGHT then
                        theScrollbar.theEventHandler.onPageDown;
                        theScrollbar.theEventHandler.onValueChanged;
                        
                     // SB_THUMBPOSITION then
                        theScrollbar.value->currentValue;
                        (pos-currentValue)
                          ->theScrollbar.theEventHandler.onThumbMoved;
                        theScrollbar.theEventHandler.onValueChanged;
                        
                    if);
                    
                if);
                
            if);
            
        if);
        
     #);
   processVscroll:
     (#
        scrollCode: @integer;
        currentValue,pos: @integer;
        theScrollbar: ^scrollbar;
        theInterfaceObject: ^interfaceObject;
        
     do
        info.wParam.hiWord->pos;
        info.wParam.loWord->scrollCode;
        info.lParam->findInterfaceObjecById->theInterfaceObject[];
        &scrollbar[]->theScrollbar[];
        (if (theInterfaceObject[] <> none ) then
            (if (theInterfaceObject## <= theScrollbar##) then
                theInterfaceObject[]->theScrollbar[];
                (if (theScrollbar[] <> none ) then
                    (if scrollCode
                     // SB_BOTTOM then
                        
                     // SB_LINEUP then
                        theScrollbar.theEventHandler.onButtonUp; 
                     // SB_LINEDOWN then
                        theScrollbar.theEventHandler.onButtonDown; 
                     // SB_PAGEUP then
                        theScrollbar.theEventHandler.onPageUp; 
                     // SB_PAGEDOWN then
                        theScrollbar.theEventHandler.onPageDown; 
                     // SB_THUMBPOSITION then
                        theScrollbar.value->currentValue;
                        (pos-currentValue)
                          ->theScrollbar.theEventHandler.onThumbMoved;
                        
                    if);
                    
                if);
                
            if);
            
        if);
        
     #);
   processDestroy:
     (# 
     do
        (if (interfaceObjectID <> 0) then
            0->interfaceObjectID; THIS(windowItem).close; 
        if);
        
     #);
   processCommand:
     (# type: @integer; id: @integer; theFather: ^canvas; 
     do
        info.wParam.hiWord->type;
        info.wParam.loWord->id;
        (* 'Command - Notification(1): ' -> screen.putText;
         *         type -> screen.putInt;
         *         ' ID: ' -> screen.putText;
         *         id -> screen.putInt;
         *         screen.newLine;
         *)
        (if info.lParam = 0 then
            (if type
             // 0 // 1 then
                (if info.lParam = 0 then id->processMenuSelect if); 
            if);
            
         else
            (if THIS(windowItem)## <= canvas## then
                THIS(windowItem)[]->theFather[];
                L: theFather.private.children.scan
                  (# 
                  do
                     (if info.lParam = current.interfaceObjectID then
                         current.handleNotification; leave L; 
                     if);
                     
                  #);
                
            if);
            
        if);
        
     #);
   processNotify:
     (# theFather: ^canvas; hwndFrom: @integer; 
     do
        (if THIS(windowItem)## <= canvas## then
            THIS(windowItem)[]->theFather[];
            info.lParam->tos'%adrGetLong'->hwndFrom;
            L: theFather.private.children.scan
              (# 
              do
                 (if hwndFrom = current.interfaceObjectID then
                     current.handleNotification; leave L; 
                 if);
                 
              #);
            
        if);
        
     #);
   processDrawItem:
     (# theFather: ^canvas; 
     do
        (if THIS(windowItem)## <= canvas## then
            THIS(windowItem)[]->theFather[];
            L: theFather.private.children.scan
              (# 
              do
                 (if info.wParam = current.private.uid then
                     current.handleNotification; leave L; 
                 if);
                 
              #);
            
        if);
        
     #);
   processMeasureItem:
     (# theFather: ^canvas; 
     do
        (if THIS(windowItem)## <= canvas## then
            THIS(windowItem)[]->theFather[];
            L: theFather.private.children.scan
              (# 
              do
                 (if info.wParam = current.private.uid then
                     current.handleNotification; leave L; 
                 if);
                 
              #);
            
        if);
        
     #);
   processMouseMove:
     (#
        _TrackMouseEvent: external
          (# result: @boolean; lptrack: @integer
          enter lptrack
          do CallStd
          exit result
          #);
        TrackMouseEventStruct: ExternalRecord
          (#
             cbSize: @long (# pos::< (#  do 0->value;  #);  #);
             (* DWORD cbSize *)
             dwFlags: @long (# pos::< (#  do 4->value;  #);  #);
             (* DWORD dwFlags *)
             hwndTrack: @long (# pos::< (#  do 8->value;  #);  #);
             (* HWND hwndTrack *)
             dwHoverTime: @long (# pos::< (#  do 12->value;  #);  #);
             (* DWORD dwHowerTime *)
             
          #);
        sizeof_TrackMouseEvent: (#  exit 16 #);
        (* typedef struct tagTRACKMOUSEEVENT {
         DWORD cbSize;
         DWORD dwFlags;
         HWND  hwndTrack;
         DWORD dwHoverTime;
         } TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;
         *)
        TME_LEAVE: (#  exit 0x00000002 #);
        theMouseTrack: @TrackMouseEventStruct;
        
     do
        true->THIS(windowitem).private.mouseOver;
        sizeof_TrackMouseEvent->malloc->theMouseTrack.ptr;
        sizeof_TrackMouseEvent->theMouseTrack.cbSize;
        TME_LEAVE->theMouseTrack.dwFlags;
        interfaceobjectid->theMouseTrack.hwndTrack;
        theEventhandler.onMouseEnter;
        theMouseTrack.ptr->mouseTrackptr->_TrackMouseEvent;
        
     #);
   processMenuSelect:
     (# id: @integer; handled: @boolean; 
     enter id
     do
        theScan: THIS(guienv).private.menus.scan
          (# 
          do
             id->current.processMenuSelect->handled;
             (if handled then leave theScan;  if);
             
          #);
        
     #);
   processSetCursor:
     (# theCur: ^cursor; HTCLIENT: (#  exit 1 #); (* Hittest code. *) 
     do
        (if THIS(guienv).private.currentMouseCursor[] = none then
            (if info.lParam.loWord = HTCLIENT then
                (if (windowItemCursor <> none ) then
                    windowItemCursor->theCur[];
                    (if (theCur.cursorHandle <> 0) then
                        theCur.cursorHandle->SetCursor; 
                    if);
                    1->info.result;
                    false->info.callBack;
                    
                 else
                    false->didSomething; 
                if);
                
             else
                false->didSomething; 
            if);
            
         else
        (* We have a busy cursor. *)
            THIS(guienv).private.currentMouseCursor.cursorHandle->SetCursor;
            1->info.result;
            false->info.callBack;
            
        if);
        
     #);
   processWM_CTLCOLORBTN:
     (#
        foColor: @integer;
        hdc: @integer;
        theWindowItem: ^windowItem;
        OsMajorVersionId: @integer;
        
     do
        info.lParam->THIS(guienv).private.interfaceObjects.findByID
          ->theWindowItem[];
        (if theWindowItem[] <> none then
            (if theWindowItem.theBkColorInfo <> none then
                (theWindowItem.theBkColorInfo).hBrush->info.result;
                info.wParam->hdc;
                (hdc,(theWindowItem.theBkColorInfo).theColorRef)->SetBkColor;
                getOsMajorVersionId->OsMajorVersionId;
                (if true
                 // (OsMajorVersionId = 3) then
                    COLOR_WINDOWTEXT->GetSysColor->foColor;
                    (hdc,foColor)->SetTextColor;
                    
                 // (OsMajorVersionId >= 4) then
                    COLOR_BTNTEXT->GetSysColor->foColor;
                    (hdc,foColor)->SetTextColor;
                    
                if);
                
             else
                false->didSomething; 
            if);
            
         else
            false->didSomething; 
        if);
        
     #);
   processWM_CTLCOLORSTATIC:
   (* check boxes, radio buttons, group boxes, static text, read-only or 
    * disabled edit controls, and disabled combo boxes (all styles).
    *)
     (#
        foColor: @integer;
        hdc: @integer;
        theWindowItem: ^windowItem;
        OsMajorVersionId: @integer;
        
     do
        info.lParam->THIS(guienv).private.interfaceObjects.findByID
          ->theWindowItem[];
        (if theWindowItem[] <> none then
            (if theWindowItem.theBkColorInfo <> none then
                (theWindowItem.theBkColorInfo).hBrush->info.result;
                info.wParam->hdc;
                (hdc,(theWindowItem.theBkColorInfo).theColorRef)->SetBkColor;
                getOsMajorVersionId->OsMajorVersionId;
                (if true
                 // (OsMajorVersionId = 3) then
                    COLOR_WINDOWTEXT->GetSysColor->foColor;
                    (hdc,foColor)->SetTextColor;
                    
                 // (OsMajorVersionId >= 4) then
                    COLOR_BTNTEXT->GetSysColor->foColor;
                    (hdc,foColor)->SetTextColor;
                    
                if);
                
             else
                false->didSomething; 
            if);
            
         else
            false->didSomething; 
        if);
        
     #);
   processWM_ERASEBKGND:
     (#
        theNtRectPtr: @integer;
        windowID: @integer;
        hbr,hbrOld: @integer;
        hPal,hOldPal: @integer;
        
     do
        (if theBkColorInfo <> none then
            interfaceObjectID->windowID;
            16->malloc->theNtRectPtr;
            (if theNtRectPtr <> 0 then
                (if (not (windowItemClassStatus = isSubClass)) and
                (interfaceObjectID <> 0) then
                    (if THIS(guienv).private.curhPal <> 0 then
                        THIS(guienv).private.curhPal->hPal; 
                     else
                        THIS(guienv).private.ghPal->hPal; 
                    if);
                    (if (hPal <> 0) then
                        (info.wParam,hPal,1)->SelectPalette->hOldPal;
                        info.wParam->RealizePalette;
                        
                    if);
                    
                if);
                (windowID,theNtRectPtr)->GetClientRect;
                private.theBkColorInfo.hBrush->hbr;
                (info.wParam,hbr)->SelectObject->hbrOld;
                (info.wParam,theNtRectPtr,hbr)->ntFillRect;
                (info.wParam,hbrOld)->SelectObject;
                (if hPal <> 0 then
                    (info.wParam,hOldPal,1)->SelectPalette;
                    info.wParam->RealizePalette;
                    
                if);
                theNtRectPtr->free;
                1->info.result;
                
             else
                false->didSomething; 
            if);
            
         else
            false->didSomething; 
        if);
        
     #);
   processInitMenu:
     (# theMenu: ^menu; 
     do
        info.wParam->THIS(guienv).private.menus.findByID->theMenu[];
        (if (theMenu[] <> none ) then theMenu.processInitMenu;  if);
        
     #);
   didSomething: @boolean;
   
do
   true->didSomething;
   windowItemClassStatus = isSubClass->info.callBack;
   (if info.message
    // WM_COMMAND then
       processCommand; 
    // WM_NOTIFY then
       processNotify; 
    // WM_DRAWITEM then
       processDrawItem; 
    // WM_MEASUREITEM then
       processMeasureItem; 
    // WM_MOUSEMOVE then
       (if not THIS(windowitem).private.mouseOver then processMouseMove if)
    // WM_MOUSELEAVE then
       false->THIS(windowitem).private.mouseOver;
       mouseTrackPtr->free;
       theEventhandler.onMouseLeave
    // WM_LBUTTONDOWN then
       1->info.button; processMouseDown; 
    // WM_MBUTTONDOWN then
       2->info.button; processMouseDown; 
    // WM_RBUTTONDOWN then
       3->info.button; processMouseDown; 
    // WM_LBUTTONUP then
       1->info.button; processMouseUp; 
    // WM_MBUTTONUP then
       2->info.button; processMouseUp; 
    // WM_RBUTTONUP then
       3->info.button; processMouseUp; 
    // WM_LBUTTONDBLCLK then
       1->info.button; processDoubleClick; 
    // WM_MBUTTONDBLCLK then
       2->info.button; processDoubleClick; 
    // WM_RBUTTONDBLCLK then
       3->info.button; processDoubleClick; 
    // WM_KEYDOWN then
       processBeforeWM_CHAR; 
    // WM_CHAR then
       processKeyDown; 
    // WM_PAINT then
       processRefresh; 
    // WM_ACTIVATE then
       processActivate; 
    // WM_KILLFOCUS then
       processDisableTarget; 
    // WM_SETFOCUS then
       processEnableTarget; 
    // WM_INITMENUPOPUP then
       processInitMenu; 
    // WM_MOVE then
       processMove; 
    // WM_SIZE then
       processResize; 
    // WM_HSCROLL then
       processHscroll; 
    // WM_VSCROLL then
       processVscroll; 
    // WM_DESTROY then
       processDestroy; 
    // WM_SETCURSOR then
       processSetCursor; 
    // WM_CTLCOLORSTATIC then
       processWM_CTLCOLORSTATIC; 
    // WM_CTLCOLORBTN then
       processWM_CTLCOLORBTN; 
    // WM_CTLCOLOREDIT then
       processWM_CTLCOLORSTATIC; 
    // WM_ERASEBKGND then
       processWM_ERASEBKGND; 
    else
       false->didSomething
   if);
   INNER dispatchMessage;
   info.handled or didSomething->info.handled;
   (if info.callBack then callDefaultWindowProc;  if);
   
#)  

-- GUIENVwindowitemOnRefresh: DoPart --
do
     (#
        width,height: @integer;
        x,y: @integer;
        info: ^messageInfo;
        hPal,hOldPal: @integer;
        
     do
        (if (not (windowItemClassStatus = isSubClass)) and
        (interfaceObjectID <> 0) then
            (if THIS(guienv).private.curhPal <> 0 then
                THIS(guienv).private.curhPal->hPal; 
             else
                THIS(guienv).private.ghPal->hPal; 
            if);
            (if (hPal <> 0) then
                (windowItemDevice,hPal,1)->SelectPalette->hOldPal;
                windowItemDevice->RealizePalette;
                
            if);
            
        if);
        (if windowItemClassStatus = isStandardClass then
            currentMessageInfo->info[];
            true->info.handled;
            (interfaceObjectID,info.message,info.wParam,info.lParam)
              ->DefWindowProc->info.result;
            
        if);
        INNER onRefresh;
        (if (border.visible) and (not private.borderHandledLocally) then
            (if windowItemClassStatus = isSubClass then
                currentMessageInfo->info[];
                FALSE->info.callback;
                callDefaultWindowProc;
                
            if);
            size->(width,height);
            (if interfaceObjectID = 0 then
                position->(x,y);
                (father[],border.style,x,y,width,height)->drawBorder;
                
             else
                (THIS(windowItem)[],border.style,0,0,width,height)->drawBorder; 
            if);
            
        if);
        (if hPal <> 0 then
            (windowItemDevice,hOldPal,1)->SelectPalette;
            windowItemDevice->RealizePalette;
            
        if);
        
     #)  

-- GUIENVwindowitemSetFrame: DoPart --
do
     (#
     (* calcRealRectangle:
      *      (# theNTRectPtr: @integer;
      *         style,exStyle: @integer;
      *         hasMenubar: @boolean;
      *         r: ^rectangle;
      *      enter r[]
      *      do r[] -> makeNtRectPtr -> theNtRectPtr;
      *         (interfaceObjectID,GWL_STYLE) -> GetWindowLong -> style;
      *         (interfaceObjectID,GWL_EXSTYLE) -> GetWindowLong -> exStyle;
      *         (theNTRectPtr,style,0,exStyle) -> AdjustWindowRectEx;
      *         theNtRectPtr -> getRectFromNtRectPtr -> r;
      *         theNtRectPtr -> free;
      *      #);
      *) x,y,width,height: @integer; oldFrame: @rectangle; 
     do
        windowItemFrame->oldFrame;
        theFrame.topLeft->(x,y);
        theFrame.size->(width,height);
        (if not (theFrame->oldFrame.isEqual) then
            (if (windowItemClassStatus <> isNoClass) then
                (interfaceObjectID,x,y,width,height,1)->MoveWindow; 
            if);
            (oldFrame,theFrame)->handleFrameChanged;
            
        if);
        
     #)  

-- GUIENVwindowitemGetFrame: DoPart --
do windowItemFrame->theFrame;   

-- GUIENVwindowitemSetPosition: DoPart --
do
     (# newFrame: @rectangle; 
     do pt->newFrame.topLeft; size->newFrame.size; newFrame->frame; 
     #)  

-- GUIENVwindowitemGetPosition: DoPart --
do private.windowItemframe.topLeft->pt;   

-- GUIENVwindowitemMove: DoPart --
do (# pt: @point;  do position->pt; (dh,dv)->pt.add; pt->position;  #)  

-- GUIENVwindowitemSetSize: DoPart --
do
     (# newFrame: @rectangle; 
     do
        position->newFrame.topLeft;
        (width,height)->newFrame.size;
        newFrame->frame;
        
     #)  

-- GUIENVwindowitemGetSize: DoPart --
do private.windowItemframe.size->(width,height);   

-- GUIENVwindowitemSetVisible: DoPart --
do
     (# opCode: @integer; 
     do
        value->private.visibleFlag;
        (if (windowItemClassStatus <> isNoClass) then
            (if value then SW_SHOW->opCode;  else SW_HIDE->opCode;  if);
            (interfaceObjectID,opCode)->ShowWindow;
            
        if);
        theEventHandler.onVisibleChanged;
        
     #);
     

-- GUIENVwindowitemGetVisible: DoPart --
do private.visibleFlag->value;   

-- GUIENVwindowitemSetHilite: DoPart --
do
   (if (value <> windowItemHilite) then
       value->windowItemHilite; theEventHandler.onHiliteChanged; 
   if);
     

-- GUIENVwindowitemGetHilite: DoPart --
do windowItemHilite->value;   

-- GUIENVwindowitemShow: DoPart --
do assertopen; true->visible;   

-- GUIENVwindowitemHide: DoPart --
do assertopen; false->visible;   

-- GUIENVwindowitemSetEnabled: DoPart --
do
   (if (windowItemClassStatus <> isNoClass) then
       (if value then
           (interfaceObjectID,1)->EnableWindow; 
        else
           (interfaceObjectID,0)->EnableWindow; 
       if);
       
   if);
     

-- GUIENVwindowitemGetEnabled: DoPart --
do
   (if (windowItemClassStatus <> isNoClass) then
       (if (interfaceObjectID->IsWindowEnabled) <> 0 then
           true->value; 
        else
           false->value; 
       if);
       
   if);
     

-- GUIENVwindowitemEnable: DoPart --
do true->enabled;   

-- GUIENVwindowitemDisable: DoPart --
do false->enabled;   

-- windowItemEnterBackgroundColor: DoPart --
do
   assertOpen;
   (if theBkColorInfo <> none then
       theBkColorInfo->THIS(guienv).private.colors.remove; 
   if);
   theColor->THIS(guienv).private.colors.findByRGB->theBkColorInfo;
   (if theBkColorInfo = none then
       &colorInfo[]->theBkColorInfo;
       theColor[]->makeColorRef->private.theBkColorInfo.theColorRef;
       theColor->private.theBkColorInfo;
       (if THIS(windowItem)[] = THIS(window).contents then
           private.theBkColorInfo.theColorRef
             ->THIS(window).private.backGroundColor;
           
       if);
       private.theBkColorInfo.theColorRef->CreateSolidBrush
         ->private.theBkColorInfo.hBrush;
       theBkColorInfo->THIS(guienv).private.colors.add;
       
   if);
   update;
     

-- windowItemExitBackgroundColor: DoPart --
do
     (# theColorRef: @integer; 
     do
        assertOpen;
        (if theBkColorInfo <> none then
            private.theBkColorInfo->theColor; 
         else
            COLOR_BTNFACE->GetSysColor->theColorRef;
            theColorRef->extractColor->theColor;
            theColor.red*256->theColor.red;
            theColor.green*256->theColor.green;
            theColor.blue*256->theColor.blue;
            
        if)
     #);
     

-- GUIENVwindowitemBorderSetVisible: DoPart --
do value->private.borderVisible; theEventHandler.onVisibleChanged;   

-- GUIENVwindowitemBorderGetVisible: DoPart --
do private.borderVisible->value;   

-- GUIENVwindowitemBorderSetStyle: DoPart --
do value->private.borderStyle; theEventHandler.onBorderStyleChanged;   

-- GUIENVwindowitemBorderGetStyle: DoPart --
do private.borderStyle->value;   

-- GUIENVwindowiteminsideRectangle: DoPart --
do
   ((0,0),size)->theRectangle;
   (if border.visible then
       (if border.style = borderStyles.simple then
           (1,1)->theRectangle.inset; 
        else
           (2,2)->theRectangle.inset; 
       if);
       
   if);
     

-- GUIENVwindowitemSetTheCursor: DoPart --
do
   (if theCur[] <> none then
       theCur.cursorHandle->interfaceObjectCursorHandle; 
    else
       0->interfaceObjectCursorHandle; 
   if);
   theCur[]->windowItemCursor;
     

-- GUIENVwindowitemGetTheCursor: DoPart --
do windowItemCursor->theCur[];   

-- GUIENVwindowItemTrackMouse: DoPart --
do
     (#
        stillDown:
          (# exists: @boolean; 
          do (m,0,ButtonCode,ButtonCode,PM_NOREMOVE)->PeekMessage->exists; 
          exit (not exists)
          #);
        move:
          (# exists: @boolean; 
          do (m,0,WM_MOUSEMOVE,WM_MOUSEMOVE,PM_REMOVE)->PeekMessage->exists; 
          exit exists
          #);
        PeekMessage: external
          (#
             theMesage: @integer;
             (* address of structure with message,  MSG FAR* *)
             hwnd: @integer;
             (* handle of the window, HWND *)
             wMsgFilterMin: @integer;
             (* first message, UINT *)
             wMsgFilterMax: @integer;
             (* last message, UINT *)
             fulRemoveMsg: @integer;
             (* removal flags UINT *)
             out: @boolean;
             (* BOOL *)
             
          enter (theMesage,hwnd,wMsgFilterMin,wMsgFilterMax,fulRemoveMsg)
          do 'PeekMessageA'->callStd; 
          exit out
          #);
        translate:
          (# h,v: @integer; 
          enter (h,v)
          do - origin.v+v->v; - origin.h+h->h; 
          exit (h,v)
          #);
        longInt: @CStruct
          (#
             ByteSize:: (#  do 4->Value;  #);
             loWord: signedShort (# Pos:: (#  do 0->Value;  #);  #);
             hiWord: signedShort (# Pos:: (#  do 2->Value;  #);  #);
             
          enter R[1]
          exit R[1]
          #);
        m: @integer;
        ButtonCode: @integer;
        info: ^messageInfo;
        theNtRectPtr: @integer;
        windowItemRect: ^rectangle;
        origin: @point;
        result: @integer;
        
     do
        28->malloc->m;
        16->malloc->theNtRectPtr;
        (interfaceObjectID,theNtRectPtr)->GetWindowRect->result;
        (result,'GUIENVwindowItemTrackMouse')->checkNullError;
        &rectangle[]->windowItemRect[];
        theNtRectPtr->getRectFromNtRectPtr->windowItemRect;
        windowItemRect.top->origin.v;
        windowItemRect.left->origin.h;
        GetMessagePos->longInt;
        (longInt.loWord,longInt.hiWord)->translate->curPt->prevPt;
        mousePress;
        (if mouse.buttonState
         // 1 // 2 // 3 then
            (if mouse.buttonState
             // 1 then
                WM_LBUTTONUP->ButtonCode; 
             // 2 then
                WM_MBUTTONUP->ButtonCode; 
             // 3 then
                WM_RBUTTONUP->ButtonCode; 
            if);
            l:
            (if stillDown then
                (if move then
                    m+20->tos'%adrGetLong'->curPt.h;
                    m+24->tos'%adrGetLong'->curPt.v;
                    curPt->translate->curPt;
                    (curPt.h-prevPt.h,curPt.v-prevPt.v)->mouseMove;
                    curPt->prevPt;
                    
                if);
                restart l;
                
            if);
            
        if);
        mouseRelease;
        m->free;
        theNtRectPtr->free;
        
     #)  

-- GUIENVwindowitemDrag: DoPart --
do
     (#
        prevMode: @integer;
        dc: @integer;
        pen,prevPen: @integer;
        brush,prevBrush: @integer;
        
     do
        father.interfaceObjectID->GetDC->dc;
        (dc,R2_XORPEN)->SetROP2->prevMode;
        (PS_DOT,1,0)->CreatePen->pen;
        (dc,pen)->SelectObject->prevPen;
        NULL_BRUSH->GetStockObject->brush;
        (dc,brush)->SelectObject->prevBrush;
        father.trackMouse
          (#
             currentFrame: @rectangle;
             drawFrame:
               (# 
               do
                  (dc,currentFrame.left,currentFrame.top,currentFrame.right,
                   currentFrame.bottom)->ntRectangle;
                  
               #);
             mousePress::< (#  do frame->currentFrame; drawFrame;  #);
             mouseMove::<
               (#  do drawFrame; (h,v)->currentFrame.offset; drawFrame;  #);
             mouseRelease::< (#  do drawFrame; currentFrame->frame;  #);
             
          #);
        (dc,prevPen)->SelectObject;
        (dc,prevBrush)->SelectObject;
        pen->DeleteObject;
        (father.interfaceObjectID,dc)->ReleaseDC;
        
     #)  

-- GUIENVwindowitemResize: DoPart --
do
     (# newFrame: @rectangle; w,h: @Integer; 
     do
        frame->father.DefineResizeRect->newFrame;
        newFrame.size->(w,h);
        (w,1)->max->w;
        (h,1)->max->h;
        (w,h)->newFrame.size;
        newFrame->frame;
        
     #)  

-- GUIENVwindowitemUpdate: DoPart --
do
     (# ntrPtr: @integer; r: @rectangle; 
     do
        (if interfaceObjectID = 0 then
            frame->r;
            r[]->makeNtRectPtr->ntrPtr;
            (father.interfaceObjectID,ntrPtr,1)->InvalidateRect;
            (if immediate then father.interfaceObjectID->UpdateWindow;  if);
            
         else
            ((0,0),size)->r;
            r[]->makeNtRectPtr->ntrPtr;
            (interfaceObjectID,ntrPtr,1)->InvalidateRect;
            (if immediate then interfaceObjectID->UpdateWindow;  if);
            
        if);
        ntrPtr->free;
        
     #)  

-- GUIENVwindowitemCreate: DoPart --
do
     (#
        origin: ^object;
        class,name: @text;
        fatherID: @integer;
        hInstance: @integer;
        exStyle,style,defaultStyle: @integer;
        a2o: @addressToObject;
        
     do
        uienvStandardWindowClass->windowItemClass;
        isStandardClass->windowItemClassStatus;
        &windowItemmethods[]->theMethods;
        INNER create;
        (if father[] = none then
            (if THIS(windowitem)[] = windowContents then
                
             else
                THIS(windowitem)[]->getOrigin->origin[];
                l:
                (if origin[] = none then
                    windowContents->father[]; 
                 else
                    (if (origin## <= canvas##) then
                        origin[]->father[]; 
                     else
                        (if (origin## <= window##) then
                        (* We have found the window of this(windowItem). *)
                            none ->origin[]; 
                         else
                            origin[]->getOrigin->origin[]; 
                        if);
                        restart l;
                        
                    if);
                    
                if);
                
            if);
            
        if);
        windowItemClass->class;
        windowItemExStyle->exStyle;
        windowItemStyle->style;
        uienvHInstance->hInstance;
        'WindowItem'->name;
        (if father[] = none then
            THIS(window).interfaceObjectID->fatherID; 
         else
            father.interfaceObjectID->fatherID;
            THIS(windowItem)[]->father.private.children.append;
            
        if);
        uniqueID->private.uid;
        (if windowItemClassStatus
         // isSubClass // isStandardClass then
            WS_CHILDWINDOW %Bor WS_CLIPSIBLINGS->defaultStyle;
            WS_CLIPCHILDREN %Bor defaultStyle->defaultStyle;
            defaultStyle %Bor style->style;
            (exStyle,class,name,style,0,0,100,100,fatherID,private.uid,
             hInstance,0)->CreateWindowEx->interfaceObjectID;
            (if (interfaceObjectID->isWindow) = 0 then
                'Create Child Window failed. Error: '->screen.puttext;
                GetLastError->screen.putInt;
                screen.newline;
                
            if);
            
        if);
        ((0,0),(100,100))->windowItemFrame;
        (if windowItemClassStatus = isSubClass then
            (interfaceObjectID,GWL_WNDPROC,uienvStandardWindowProcAddress)
              ->SetWindowLong->interfaceObjectWindProc;
            
        if);
        (if (windowItemClassStatus <> isNoClass) then
            (interfaceObjectID,GCL_HCURSOR,0)->SetClassLong; 
        if);
        cursors.arrow[]->theCursor;
        
     #)  

-- GUIENVwindowitemOpen: DoPart --
do
   true->bindTop;
   true->bindLeft;
   true->private.visibleFlag;
   (if windowItemClassStatus <> isSubClass then
       true->THIS(windowItem).private.updateOnResize; 
   if);
   (if (windowItemClassStatus <> isNoClass) then
       (THIS(interfaceObject).private.interfaceObjectID,HWND_TOP,0,0,0,0,
        SWP_NOMOVE+SWP_NOSIZE+SWP_NOACTIVATE)->SetWindowPos;
       
   if);
   INNER open;
   (if private.visibleFlag then show;  if);
     

-- GUIENVwindowitemClose: DoPart --
do
     (# id: @integer; 
     do
        INNER close;
        (if theBkColorInfo <> none then
            theBkColorInfo->THIS(guienv).private.colors.remove; 
        if);
        (if (father[] <> none ) then
            THIS(windowitem)[]->father.selection.remove;
            THIS(windowItem)[]->father.private.children.remove;
            
        if);
        THIS(windowItem)[]->removeInterfaceObject;
        (if (interfaceObjectID <> 0) then
            interfaceObjectID->id; 0->interfaceobjectID; ID->DestroyWindow; 
        if);
        none ->windowItemCursor;
        
     #)  

-- GUIENVWindowItemHit: DoPart --
do frame->r; pt->r.containsPoint->value;   

-- separatorLib: Attributes --
theStyle: (#  enter private.style exit private.style #);   

-- GUIENVwindowSeparatorOnRefresh: DoPart --
do
     (#
        blackHdc,whiteHdc: @integer;
        width,height: @integer;
        x,y,y2: @integer;
        blackPen,whitePen,oldPen1,oldPen2: @integer;
        lineStyle,noLines: @integer;
        
     <<SLOT drawseparatorbody:DoPart>>
     #)  

-- GUIENVseparatorSetStyle: DoPart --
do value->theStyle;   

-- GUIENVseparatorGetStyle: DoPart --
do theStyle->value;   

-- GUIENVwindowseparatorCreate: DoPart --
do
   uienvStandardWindowClass->windowItemClass;
   isStandardClass->windowItemClassStatus;
   separatorStyles.singleLine->private.style;
   INNER create;
     

-- GUIENVwindowseparatorOpen: DoPart --
do
   (if vertical then (2,500)->size;  else (500,2)->size;  if);
   true->THIS(windowItem).private.updateOnResize;
   INNER open;
     

-- GUIENVwindowseparatorClose: DoPart --
do INNER close;   

-- GUIENVwindowseparatorPrivate: Descriptor --
(# style: @integer;  #)  

-- canvasLib: Attributes --
handleChildframeChanged:
  (# oldFrame,newFrame: @rectangle; 
  enter (oldFrame,newFrame)
  do (oldFrame,newFrame)->theEventHandler.onChildframeChanged; 
  #);
  

-- GUIENVcanvasOnActivate: DoPart --
do scan (#  do current.theEventHandler.onActivate;  #); INNER onActivate;   

-- GUIENVcanvasOnDeactivate: DoPart --
do
   scan
     (#  do current.theEventHandler.onDeactivate;  #);
   INNER onDeactivate;
     

-- GUIENVcanvasOnMouseDown: DoPart --
do
     (# hitObject: ^windowItem; 
     do
        theScan: private.children.scanReverse
          (# 
          do
             (if current.windowItemClassStatus = isNoClass then
                 (if current.visible then
                     (if (localPosition->current.hit) then
                         current[]->hitObject[]; leave theScan; 
                     if);
                     
                 if);
                 
             if);
             
          #);
        hitobject[]->private.hit[];
        (if hitObject[] = none then
            INNER onMouseDown; 
         else
            hitObject.theEventHandler.onMouseDown; 
        if);
        
     #)  

-- GUIENVcanvasOnRefresh: DoPart --
do
     (# r: @rectangle; doPaint: @integer; theNtRectPtr: @integer; 
     do
        INNER onRefresh;
        scan
          (# 
          do
             (if current.windowItemClassStatus = isNoClass then
                 (if current.visible then
                     (if interfaceObjectUpdateRgn = - 1 then
                         current.theEventHandler.onRefresh; 
                      else
                         current.frame->r;
                         r[]->makeNtRectPtr->theNtRectPtr;
                         (windowItemDevice,theNtRectPtr)->RectVisible->doPaint;
                         (if doPaint <> 0 then
                             current.theEventHandler.onRefresh; 
                         if);
                         theNtRectPtr->free;
                         
                     if);
                     
                 if);
                 
             if);
             
          #);
        
     #)  

-- GUIENVcanvasOnMouseUp: DoPart --
do
   (if private.hit[] <> none then
       private.hit.theEventHandler.onMouseUp; none ->private.hit[]; 
    else
       INNER onMouseUp; 
   if);
     

-- GUIENVcanvasOnFrameChanged: DoPart --
do INNER onFrameChanged;   

-- GUIENVcanvasOnVisibleChanged: DoPart --
do
   private.children.scan
     (# 
     do
        (if current.visible then
            current.theEventHandler.onVisibleChanged; 
        if);
        
     #);
   INNER onVisibleChanged;
     

-- GUIENVcanvasSelectionAdd: DoPart --
do
   (if not (theWindowitem[]->private.selection.has) then
       theWindowitem[]->private.selection.append; true->theWindowitem.hilite; 
   if);
     

-- GUIENVcanvasSelectionSet: DoPart --
do
   private.selection.scan
     (# 
     do
        false->current.hilite;
        current[]->private.selection.at->private.selection.delete;
        
     #);
   theWindowitem[]->private.selection.append;
   true->theWindowitem.hilite;
     

-- GUIENVcanvasSelectionRemove: DoPart --
do
   (if (theWindowitem[]->private.selection.has) then
       theWindowitem[]->private.selection.at->private.selection.delete;
       false->theWindowitem.hilite;
       
   if);
     

-- GUIENVcanvasSelectionEmpty: DoPart --
do private.selection.empty->value;   

-- GUIENVcanvasSelectionScan: DoPart --
do
   private.selection.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVcanvasSelectionClear: DoPart --
do
   private.selection.scan
     (# 
     do
        false->current.hilite;
        current[]->private.selection.at->private.selection.delete;
        
     #);
     

-- GUIENVcanvasScan: DoPart --
do
   private.children.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVcanvasCreate: DoPart --
do INNER create;   

-- GUIENVcanvasOpen: DoPart --
do INNER open;   

-- GUIENVcanvasClose: DoPart --
do
   INNER close;
   private.children.scan
     (#  do (if current.isOpen then current.close;  if);  #);
     

-- cursorLib: Attributes --
cursorHandle: (#  enter private.cursorHandle exit private.cursorHandle #);
load:
  (# name: @integer; (* LPCSTR *) 
  enter name
  do (0,name)->LoadCursorInteger->cursorHandle; 
  #);
  

-- GUIENVcursorPrivate: Descriptor --
(# cursorHandle: @integer;  #)  

-- textStyleLib: Attributes --
useTextStyle:
  (# dc,deskTop: @integer; saved: @integer; infoPtr: @integer; 
  do
     56->malloc->infoPtr;
     create;
     GetDeskTopWindow->deskTop;
     deskTop->GetDC->dc;
     (dc,textStyleID)->SelectObject->saved;
     (dc,infoPtr)->GetTextMetrics;
     INNER ;
     (dc,saved)->SelectObject;
     (deskTop,dc)->ReleaseDC;
     infoPtr->free;
     
  #);
  

-- GUIENVtextStyleCreate: DoPart --
do
     (# activeWndHdc: @integer; activeHwnd: @integer; 
     do
        (if textStyleID = 0 then
            scanL:
              (# 
              do
                 THIS(guienv).private.textStyles.scan
                   (# 
                   do
                      (if THIS(textStyle)[]->current.equal then
                          current.textStyleID->textStyleID; leave scanL
                      if);
                      
                   #);
                 
              #);
            (if textStyleID = 0 then
                textStyleSize->height;
                0->width;
                0->escapement;
                0->orientation;
                FW_NORMAL->weight;
                0->italic;
                (if textStyleFace = textFaces.bold then FW_BOLD->weight;  if);
                (if textStyleFace = textFaces.italic then 1->italic;  if);
                (if textStyleFace = textFaces.italic+textFaces.bold then
                    FW_BOLD->weight; 1->italic; 
                if);
                0->underline;
                0->strikeOut;
                ANSI_CHARSET->charSet;
                OUT_DEFAULT_PRECIS->outPrecision;
                CLIP_DEFAULT_PRECIS->clipPrecision;
                PROOF_QUALITY->quality;
                DEFAULT_PITCH+FF_DONTCARE+16x04->pitchAndFamily;
                (* the 16x04 is to get a true type font *)
                textStyleName->face;
                GetActiveWindow->activeHwnd;
                (* 110396 /les *)
                activeHwnd->GetDC->activeWndHdc;
                (height,(activeWndHdc,LOGPIXELSY)->GetDeviceCaps,72)->MulDiv
                  ->height;
                (- height,width,escapement,orientation,weight,italic,underline,
                 strikeout,charSet,outPrecision,clipPrecision,quality,
                 pitchAndFamily,face)->CreateFont->textStyleID;
                (if textStyleID = 0 then
                    GetLastError->error;
                    'Failed to create font. Error: '->screen.putText;
                    error->screen.putInt;
                    screen.newLine;
                    
                 else
                    THIS(textStyle)[]->THIS(guienv).private.textStyles.append; 
                if);
                (activeHwnd,activeWndHdc)->ReleaseDC;
                (* 110396 /les *)
                
            if);
            
        if);
        
     #);
     

-- GUIENVtextStyleDispose: DoPart --
do
   (if textStyleID <> 0 then
       THIS(textStyle)[]->THIS(guienv).private.textStyles.delete;
       (if (textStyleID <> 0) then
           (if ((textStyleID->DeleteObject) = 0) then
               'Failed to delete font.'->screen.putline; 
            else
               0->textStyleID; 
           if);
           
       if);
       
   if);
     

-- GUIENVtextStyleEqual: DoPart --
do
   (if theTextStyle[] <> none then
       (if (theTextStyle.name->private.textStyleName.equalNCS) and
       (theTextStyle.size = size) and (theTextStyle.face = face) then
           true->value; 
       if);
       
   if);
     

-- GUIENVtextStyleSetName: DoPart --
do theName->textStyleName;   

-- GUIENVtextStyleGetName: DoPart --
do &text[]->theName[]; textStyleName->theName;   

-- GUIENVtextStyleSetSize: DoPart --
do value->textStyleSize;   

-- GUIENVtextStyleGetSize: DoPart --
do textStyleSize->value;   

-- GUIENVtextStyleSetFace: DoPart --
do value->textStyleFace;   

-- GUIENVtextStyleGetFace: DoPart --
do textStyleFace->value;   

-- GUIENVtextStyleAscent: DoPart --
do
   useTextStyle
     (#  do infoPtr+textmetricTmAscentOffset->tos'%adrGetLong'->value;  #);
     

-- GUIENVtextStyleDescent: DoPart --
do
   useTextStyle
     (#  do infoPtr+textmetricTmDescentOffset->tos'%adrGetLong'->value;  #);
     

-- GUIENVtextStyleLeading: DoPart --
do
   useTextStyle
     (# 
     do infoPtr+textmetricTmExternalLeadingOffset->tos'%adrGetLong'->value; 
     #);
     

-- GUIENVtextStyleHeight: DoPart --
do
   useTextStyle
     (#  do infoPtr+textmetricTmHeightOffset->tos'%adrGetLong'->value;  #);
     

-- GUIENVtextStyleMaxChWidth: DoPart --
do
   useTextStyle
     (# 
     do infoPtr+textmetricTmMaxCharWidthOffset->tos'%adrGetLong'->value; 
     #);
     

-- GUIENVtextStyleWidthOfChar: DoPart --
do
   useTextStyle
     (# tempCharWidth: @integer; 
     do
        4->malloc->tempCharWidth;
        (dc,ch,ch,tempCharWidth)->GetCharWidth32;
        tempCharWidth->tos'%adrGetLong'->value;
        tempCharWidth->free;
        
     #);
     

-- GUIENVtextStyleStringWidth: DoPart --
do
   useTextStyle
     (#
        theSize: @point;
        theSizePtr: @integer;
        cstr: @cstring;
        (* overhang: @integer; *)
        
     do
        (if str.length > 0 then
            8->malloc->theSizePtr;
            str[]->cstr.set;
            (dc,cstr.charPtr,cstr.length,theSizePtr)->GetTextExtentPoint32;
            theSizePtr->getPointFromNtPointPtr->(theSize.h,theSize.v);
            theSize.h->value;
            (* infoPtr + textmetricTmOverhangOffset -> TOS'%adrGetLong' -> overhang;
             value + overhang -> value; *)
            cstr.free;
            theSizePtr->free;
            
         else
            0->value; 
        if);
        
     #);
     

-- GUIENVtextStyleFamilySizes: DoPart --
do
     (#
        EnumFontFamiliesProcToPtr: external
          (# func: ##EnumFontFamiliesProc; int: @integer; 
          enter func##
          do 'copyinput'->callC
          exit int
          #);
        EnumFontFamiliesProc: external
          (#
             ptr2elf: @integer;
             ptr2ntm: @integer;
             fontType: @integer;
             requestedPointSize: @integer;
             result: @integer;
             theENUMLOGFONTA: @ENUMLOGFONTA;
             lfHeight: @integer;
             
          enter (ptr2elf,ptr2ntm,fontType,requestedPointSize)
          do
             StdExternalEntry;
             ptr2elf->theENUMLOGFONTA.ptr;
             (* Calculate pointSize/lfHeight *)
             (if fontType
              // TRUETYPE_FONTTYPE then
                 8->theSizes.insert;
                 9->theSizes.insert;
                 10->theSizes.insert;
                 11->theSizes.insert;
                 12->theSizes.insert;
                 14->theSizes.insert;
                 16->theSizes.insert;
                 18->theSizes.insert;
                 20->theSizes.insert;
                 22->theSizes.insert;
                 24->theSizes.insert;
                 26->theSizes.insert;
                 28->theSizes.insert;
                 36->theSizes.insert;
                 48->theSizes.insert;
                 72->theSizes.insert;
                 0->result;
                 
              // DEVICE_FONTTYPE then
                 0->result; 
              // RASTER_FONTTYPE then
                 theENUMLOGFONTA.lfHeight->lfHeight;
                 (72,lfHeight,(hdc,LOGPIXELSY)->GetDeviceCaps)->MulDiv
                   ->theSizes.insert;
                 1->result;
                 
             if);
             
          exit result
          #);
        hdc: @integer;
        theSizes: @list
          (#
             element:: integerObject;
             insert:
               (# iObj: ^integerObject; i: @integer; 
               enter i
               do &integerObject[]->iObj[]; i->iObj; iObj[]->append; 
               #);
             
          #);
        
     do
        0->GetDC->hdc;
        theSizes.init;
        EnumFontFamiliesProc##->EnumFontFamiliesProcToPtr
          ->THIS(guienv).private.EnumFontFamiliesProcAddress;
        (hdc,textStyleName,THIS(guienv).private.EnumFontFamiliesProcAddress,0)
          ->EnumFontFamilies;
        (0,hdc)->ReleaseDC;
        theSizes.scan
          (# 
          do current->THIS(availableSizes).thisSize; INNER availableSizes; 
          #);
        theSizes.clear;
        
     #)  

-- clipBoardLib: Attributes --
(* BOOL TextToClipboard( LPSTR Txt ) *)
TextToClipboard: external
  (# theText: @integer; (* LPCSTR *) result: @boolean
  enter theText
  do callC; 
  exit result
  #);
(* LPSTR TextFromClipboard() *)
TextFromClipboard: external
  (# theText: @integer; (* LPCSTR *)  do callC;  exit theText #);
  

-- GUIENVclipBoardHasText: DoPart --
do CF_TEXT->IsClipboardFormatAvailable->value;   

-- GUIENVclipBoardSetText: DoPart --
do
     (# res: @boolean; theText: ^cString; tempText: @cString; 
     do
        (if txt[] <> none then
            txt[]->tempText.set;
            tempText.toLocal->theText[];
            theText->TextToClipboard->res;
            tempText.free;
            theText.free;
            
        if);
        
     #)  

-- GUIENVclipBoardGetText: DoPart --
do
     (# theText: ^cString; tempText: @cString; 
     do
        (if (CF_TEXT->IsClipboardFormatAvailable) then
            TextFromClipboard->tempText;
            tempText.fromLocal->theText[];
            theText.get->txt[];
            tempText.free;
            theText.free;
            
        if);
        
     #)  

-- GUIENVclipBoardClearContents: DoPart --
do (if (0->OpenClipboard) then EmptyClipboard; CloseClipboard;  if);   

-- GUIENVmouseGlobalPosition: DoPart --
do
     (# ntpPtr: @integer; 
     do
        8->malloc->ntpPtr;
        ntpPtr->GetCursorPos;
        ntpPtr->getPointFromNtPointPtr->(pt.h,pt.v);
        ntpPtr->free;
        
     #)  

-- GUIENVmouseButtonState: DoPart --
do
     (#
        isButtonDown: external
          (# button: @integer; res: @boolean; 
          enter button
          do callC; 
          exit res
          #);
        
     do
        l:
          (# 
          do
             (if (VK_LBUTTON->isButtonDown) then 1->value; leave l;  if);
             (if (VK_MBUTTON->isButtonDown) then 2->value; leave l;  if);
             (if (VK_RBUTTON->isButtonDown) then 3->value; leave l;  if);
             
          #);
        
     #)  

-- GUIENVmouseTheCursorSet: DoPart --
do
   (if theCur[] <> none then
       &cursor[]->private.prevMouseCursor[];
       theCur.cursorHandle->SetCursor->private.prevMouseCursor.cursorHandle;
       
    else
       (if private.prevMouseCursor[] <> none then
           private.prevMouseCursor.cursorHandle->SetCursor; 
        else
           0->SetCursor; 
       if);
       
   if);
   theCur[]->private.currentMouseCursor[];
     

-- GUIENVmouseTheCursorGet: DoPart --
do private.currentMouseCursor[]->theCur[];   

-- GUIENVsystemScreenRectangle: DoPart --
do theScreenRectangle->theRectangle;   

-- GUIENVsystemScreenRgn: DoPart --
do &region[]->rgn[]; theScreenRectangle->rgn.setFromRectangle;   

-- GUIENVsystemBeepBody: DoPart --
do MB_OK->MessageBeep;   

-- GUIENVsystemWaitBody: DoPart --
do (ticks*1000) div 60->Sleep;   

-- GUIENVdoSetUp: Descriptor --
(#
   getScreenRectangle:
     (# widthOfScreen,heightOfScreen: @integer; 
     do
        SM_CXSCREEN->GetSystemMetrics->widthOfScreen;
        SM_CYSCREEN->GetSystemMetrics->heightOfScreen;
        ((0,0),(widthOfScreen,heightOfScreen))->theScreenRectangle;
        
     #);
   getGray: external
     (# hBitmap: @integer; hdcLocal: @integer; 
     enter hdcLocal
     do callC; 
     exit hBitmap
     #);
   getLightGray: external
     (# hBitmap: @integer; hdcLocal: @integer; 
     enter hdcLocal
     do callC; 
     exit hBitmap
     #);
   getDarkGray: external
     (# hBitmap: @integer; hdcLocal: @integer; 
     enter hdcLocal
     do callC; 
     exit hBitmap
     #);
   getWhite: external
     (# hBitmap: @integer; hdcLocal: @integer; 
     enter hdcLocal
     do callC; 
     exit hBitmap
     #);
   getBlack: external
     (# hBitmap: @integer; hdcLocal: @integer; 
     enter hdcLocal
     do callC; 
     exit hBitmap
     #);
   makePixmap:
     (# handleToPixmap: @integer; thePixmap: ^pixmap; 
     enter handleToPixmap
     do
        &pixmap[]->thePixmap[];
        handleToPixmap->thePixmap.private.handleToPixmap;
        1->thePixmap.private.depth;
        
     exit thePixmap[]
     #);
   initBP:
     (# hWnd,hdc: @integer; didRelease: @integer; 
     do
        GetDesktopWindow->hWnd;
        hWnd->GetDC->hdc;
        hdc->getBlack->makePixmap->patterns.black[];
        hdc->getWhite->makePixmap->patterns.white[];
        hdc->getDarkGray->makePixmap->patterns.dkGray[];
        hdc->getGray->makePixmap->patterns.gray[];
        hdc->getLightGray->makePixmap->patterns.ltGray[];
        (* Clean up memory *)
        (hWnd,hdc)->ReleaseDC->didRelease;
        (if didRelease = 0 then
            'initPatterns. Did not release DC!!!'->screen.putline; 
        if);
        
     #);
   initMenubar:
     (# theBar: ^menubar; 
     do
        &menubarType[]->theBar[];
        (if theBar## <> menubar## then
            theBar.open; theBar[]->applicationMenubar; 
        if);
        
     #);
   initCursors:
     (# 
     do
        IDC_ARROW->cursors.arrow.load;
        IDC_CROSS->cursors.cross.load;
        IDC_IBEAM->cursors.iBeam.load;
        IDC_WAIT->cursors.watch.load;
        (* No plus cursor !!! *)
        IDC_ARROW->cursors.plus.load;
        (* No hand cursor !!! *)
        IDC_ARROW->cursors.hand.load;
        
     #);
   registerStandardWindowClass:
     (# cstr: @cString; theClass: @WndClass; result: @integer; 
     do
        'guienvWindowClass'->uienvStandardWindowClass;
        'guienvWindowClass'->cstr.set;
        (* CS_HREDRAW + CS_VREDRAW  + *)
        CS_DBLCLKS->theClass.style;
        StandardWindowProc##->std16x4toint->uienvStandardWindowProcAddress;
        uienvStandardWindowProcAddress->theClass.lpfnWndProc;
        uienvHInstance->theClass.hInstance;
        (if applIconId = 0 then
            (0,IDI_APPLICATION)->LoadIconInteger->theClass.hIcon->result; 
         else
            (uienvHInstance,applIconId)->LoadIconInteger->theClass.hIcon
              ->result;
            
        if);
        (result,'registerStandardWindowClass.LoadIconInteger')->checkNullError;
        (0,IDC_ARROW)->LoadCursorInteger->theClass.hCursor->result;
        (result,'registerStandardWindowClass.loadCursorInteger')
          ->checkNullError;
        COLOR_BTNFACE->GetSysColor->CreateSolidBrush->theClass.hbrBackGround;
        0->theClass.lpszMenuName;
        cstr.charPtr->theClass.lpszClassName;
        0->theClass.cbClsExtra;
        0->theClass.cbWndExtra;
        theClass[]->RegisterClass->result;
        (result,'registerClass')->checkNullError;
        cstr.free;
        
     #);
   registerDialogWindowClass:
     (# cstr: @cString; theClass: @WndClass; result: @integer; 
     do
        'guienvDialogClass'->uienvDialogWindowClass;
        'guienvDialogClass'->cstr.set;
        (* CS_HREDRAW + CS_VREDRAW + *)
        CS_DBLCLKS->theClass.style;
        (if uienvStandardWindowProcAddress = 0 then
            StandardWindowProc##->std16x4toint->uienvStandardWindowProcAddress; 
        if);
        uienvStandardWindowProcAddress->theClass.lpfnWndProc;
        uienvHInstance->theClass.hInstance;
        (0,IDC_ARROW)->LoadCursorInteger->theClass.hCursor->result;
        (result,'registerDialogWindowClass.loadCursorInteger')->checkNullError;
        COLOR_BTNFACE->GetSysColor->CreateSolidBrush->theClass.hbrBackGround;
        0->theClass.lpszMenuName;
        cstr.charPtr->theClass.lpszClassName;
        0->theClass.cbClsExtra;
        0->theClass.cbWndExtra;
        theClass[]->RegisterClass->result;
        (result,'registerDialogWindowClass.registerClass')->checkNullError;
        cstr.free;
        
     #);
   initBifrost:
     (#  do (* true -> displaywarnings; *) bifrostprivate.PH.init;  #);
   
do
   modeless->modalState;
   get_beta_instance->uienvHInstance;
   (* get_beta_previnstance -> hPrevInstance; *)
   28->malloc->private.message;
   28->malloc->private.peek;
   registerStandardWindowClass;
   registerDialogWindowClass;
   initBP;
   initCursors;
   initMenubar;
   getScreenRectangle;
   initBifrost;
   (* true -> doTrace; *)
   
#)  

-- GUIENVDoPart: DoPart --
do doSetup; onStartApplication; INNER guienv; mainLoop;   

-- GUIENVactiveWindow: DoPart --
do
   GetActiveWindow->hWnd;
   (if hWnd = 0 then
       none ->theWindow[]; 
    else
       hWnd->private.windows.findById->theWindow[]; 
   if);
     

-- timerLib: Attributes --
unInitialized: (#  exit 0 #);
active: (#  exit 1 #);
sleeping: (#  exit 2 #);
  

-- GUIenvTimerStart: DoPart --
do
   interval->private.interval;
   (if private.status
    // active then (* Nothing *)
       
    // unInitialized then
       private.init; active->private.status; private.install; 
    // sleeping then
       active->private.status; private.install; 
   if);
     

-- GUIenvTimerStop: DoPart --
do
   (if private.status = active then
       private.delete; sleeping->private.status; 
   if);
     

-- GUIenvTimerPrivate: Descriptor --
(#
   theAction: @action;
   status: @integer;
   interval: @integer;
   appcontext: @integer;
   callbackPtr: @integer;
   timerID: @integer;
   std16x4toint: external
     (# func: ##theTimerProc; int: @integer; 
     enter func##
     do 'copyinput'->callC
     exit int
     #);
   theTimerProcAddress: @integer;
   theTimerProc: external
     (#
        windowHandle,message,uTimerID,dwTime: @integer;
        dispatch:
          (# 
          do
             (if uTimerId = timerID then
                 (if status
                  // active then
                     (if once then stop;  if); theAction; 
                  // sleeping then (* Nothing *)
                     
                 if);
                 
             if);
             
          #);
        
     enter (windowHandle,message,uTimerId,dwTime)
     do
        StdExternalEntry;
        (if XsystemEnvPresent then
            &dispatch[]->XsystemEnvHandleCallback; 
         else
            dispatch; 
        if);
        
     #);
   install: @
     (# (* UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC); *)
        SetTimer: external
          (#
             windowHandle: @integer;
             (* HWND *)
             timerID: @integer;
             (* UINT *)
             timeOutValue: @integer;
             (* UINT *)
             theTimerProcAddress: @integer;
             (* TIMERPROC *)
             result: @integer;
             (* UINT *)
             
          enter (windowHandle,timerID,timeOutValue,theTimerProcAddress)
          do callStd; 
          exit result
          #);
        msg: ^text;
        
     do
        (0,0,interval,theTimerProcAddress)->SetTimer->timerID;
        (if timerID = 0 then
            &text[]->msg[];
            'SetTimer failed. Error: '->msg.append;
            GetLastError->msg.putInt;
            '. '->msg.append;
            (none ,msg[],none )->noteUser;
            
        if);
        
     #);
   delete: @
     (# (* BOOL    WINAPI KillTimer(HWND, UINT); *)
        KillTimer: external
          (#
             windowHandle: @integer;
             (* HWND *)
             timerID: @integer;
             (* UINT *)
             result: @integer;
             (* BOOL *)
             
          enter (windowHandle,timerID)
          do callStd; 
          exit result
          #);
        msg: ^text;
        
     do
        (if ((0,timerID)->KillTimer) = 0 then
            &text[]->msg[];
            'KillTimer failed. Error: '->msg.append;
            GetLastError->msg.putInt;
            '. '->msg.append;
            (none ,msg[],none )->noteUser;
            
         else
            0->timerID; 
        if);
        
     #);
   init:
     (# 
     do (* Get a pointer to the timer proc. *)
        theTimerProc##->std16x4toint->theTimerProcAddress; 
     #);
   
#)  

-- guienvFitToContents: DoPart --
do preferredSize->size; INNER ;   

-- GUIENVPrependAction: DoPart --
do theAction[]->private.beforeKeyDown.prepend;   

-- GUIENVAppendAction: DoPart --
do theAction[]->private.afterKeyDown.append;   

