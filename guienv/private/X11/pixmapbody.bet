ORIGIN 'guienv_unixprivate';
INCLUDE '../datastructures/association'
        '../pathmanager'
        '~beta/toollibs/utils/PNG/private/xpnginterface';
LIB_ITEM 'guienv';
MAKE default 'external/xpm/Makefile';
LIBFILE default '$/libXpm.a';
-- lib: Attributes --
getPixmapPathManager: objectPool.get
  (#
     type:: pixmapPathManager;
     exact::  (#  do true->value #);
     init::  (#  do obj.init #);
     
  #);
pixmapPathManager: pathManager
  (#
     init:: 
       (# betalib: ^text; pixmapDir: ^text; 
       do
          '$(BETALIB)'
            ->expandEnvVar
              (#
                 defaultValue:: 
                   (#  do '/usr/local/lib/beta'->envvarvalue[];  #);
                 
              #)->betalib[];
          '.'->add;
          './pixmaps'->add;
          '/bitmap/interfacebuilders'->(betalib.copy).append->add;
          '/bitmap/objectbrowser'->(betalib.copy).append->add;
          '/bitmap/guienv'->(betalib.copy).append->add;
          '/bitmap'->(betalib.copy).append->add;
          '$(PIXMAPS)'->expandEnvVar (#  #)->pixmapDir[];
          (if pixmapDir[] <> none then
              (if pixmapDir.length > 0 then
                  (if (pixmapDir.length->pixmapDir.inxGet) = '/' then
                      (pixmapDir.length,pixmapDir.length)->pixmapDir.delete; 
                  if);
                  pixmapDir[]->add;
                  
              if);
              
          if);
          
       #);
     
  #);
XpmAttributes:
  (#
     valuemask: @integer;
     (* Specifies which attributes are defined *)
     visual: @integer;
     (* Specifies the visual to use *)
     colormap: @integer;
     (* Specifies the colormap to use *)
     depth: @integer;
     (* Specifies the depth *)
     width: @integer;
     (* Returns the width of the created pixmap *)
     height: @integer;
     (* Returns the height of the created pixmap *)
     i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15,i16,i17,i18,i19,i20,i21,
       i22,i23,i24,i25,i26: @integer;
     (* The rest - I don't need it *)
     
  #);
XpmSuccess: (#  exit 0 #);
XpmColorError: (#  exit 1 #);
XpmOpenFailed: (#  exit - 1 #);
XpmFileInvalid: (#  exit - 2 #);
XpmNoMemory: (#  exit - 3 #);
XpmColorFailed: (#  exit - 4 #);
XpmDepth: (#  exit 1 %sll 2 #);
XpmReadFileToPixmap: external
  (#
     display,drawable,pixmap_return,shapemask_return,attributes: @integer;
     filename: [0] @char;
     status: @integer;
     
  enter (display,drawable,filename,pixmap_return,shapemask_return,attributes)
  exit status
  #);
  

-- pixmapLib: Attributes --
search:
  (# name: ^text; expandedName: ^text; 
  enter name[]
  do
       (# thePixmapPathManager: ^pixmapPathManager; 
       do
          getPixmapPathManager->thePixmapPathManager[];
          name[]->thePixmapPathManager.lookup->expandedName[];
          
       #);
     
  exit expandedName[]
  #);
expandPixmapName:
  (#
     name: ^text;
     expandedName: ^text;
     error:< (# msg: ^text;  enter msg[] do INNER ;  #);
     
  enter name[]
  do
       (#
          isPath: @boolean;
          hasExtension: @boolean;
          doesNotExists:
            (# msg: ^text; 
            do
               &text[]->msg[];
               'pixmap file "'->msg.putText;
               name[]->msg.putText;
               '" does not exist'->msg.putLine;
               msg[]->error;
               
            #);
          wasNotFound:
            (# msg: ^text; 
            do
               &text[]->msg[];
               'pixmap file "'->msg.putText;
               name[]->msg.putText;
               '" was not found in any of the pixmap directories'->msg.putLine;
               msg[]->error;
               
            #);
          
       do
          (if (name[] <> none ) and (not name.empty) then
              name.reset;
              l: '/'->name.find (#  do true->isPath; leave l;  #);
              (if isPath then
                  (if name[]->exists then
                      name.copy->expandedName[]; 
                   else
                      doesNotExists; 
                  if);
                  
               else
                  l: '.'->name.find (#  do true->hasExtension; leave l #);
                  (if not hasExtension then
                      '.png'->(name.copy).append->name[]; 
                  if);
                  name[]->search->expandedName[];
                  (if expandedName[] = none then
                        (# file: @diskentry; 
                        do
                           applDirectory->name.prepend;
                           name[]->putline;
                           name[]->file.path;
                           (if file.exists then
                               name.copy->expandedName[]; 
                            else
                               wasNotFound; 
                           if)
                        #)
                  if);
                  
              if);
              
          if);
          
       #);
     
  exit expandedName[]
  #);
guessPixmapFormat:
  (# name: ^text; format: @integer; 
  enter name[]
  do
     l:
       (#
          isOpen: @boolean;
          fail:
            (# 
            do unknown->format; (if isOpen then f.close;  if); leave l; 
            #);
          f: @file
            (#
               OtherError::  (#  do fail #);
               AccessError::  (#  do fail #);
               ReadError::  (#  do fail #);
               EOSerror::  (#  do fail #);
               
            #);
          ch: @char;
          accept:
            (# token: @char; 
            enter token
            do f.get->ch; (if ch <> token then fail;  if); 
            #);
          
       do
          name[]->f.name;
          f.openRead;
          true->isOpen;
          f.get->ch;
          (if ch
           // 0x89 then
              'P'->accept; 'N'->accept; 'G'->accept; PNGformat->format; 
           // '/' then
              '*'->accept;
              ' '->accept;
              'X'->accept;
              'P'->accept;
              'M'->accept;
              XPMformat->format;
              
           // '#' then
              'd'->accept;
              'e'->accept;
              'f'->accept;
              'i'->accept;
              'n'->accept;
              'e'->accept;
              XBMformat->format
           else
              fail; 
          if);
          f.close;
          
       #);
     
  exit format
  #);
unknown: (#  exit 0 #);
XPMformat: (#  exit 1 #);
XBMformat: (#  exit 2 #);
PNGformat: (#  exit 3 #);
readXBMfile:
  (# name: ^text; error:< (# msg: ^text;  enter msg[] do INNER ;  #); 
  enter name[]
  do
       (#
          dpy,root: @integer;
          width,height,bmap: @integer;
          status: @integer;
          msg: ^text;
          makeErrorMessage:
            (# msg: ^text;  do &text[]->msg[]; INNER ; msg[]->error;  #);
          
       do
          THIS(guienv).private.display->dpy;
          THIS(guienv).private.display->XDefaultRootWindow->root;
          (dpy,root,name,@@ width,@@ height,@@ bmap,0,0)->XReadBitmapFile
            ->status;
          (if status
           // XBitmapOpenFailed then
              makeErrorMessage
                (# 
                do
                   'Cannot open bitmap file '->msg.puttext;
                   name[]->msg.putline;
                   
                #);
              
           // XBitmapFileInvalid then
              makeErrorMessage
                (# 
                do
                   name[]->msg.puttext;
                   ' is not a valid bitmap file'->msg.putline;
                   
                #);
              
           // XBitmapNoMemory then
              makeErrorMessage
                (# 
                do
                   'Not enough memory to hold bitmap file '->msg.puttext;
                   name[]->putline;
                   
                #)
           // XBitmapSuccess then
              bmap->private.pixmapID;
              0->private.maskID;
              width->private.width;
              height->private.height;
              1->private.depth;
              
          if);
          
       #)
  #);
readXPMfile:
  (# name: ^text; error:< (# msg: ^text;  enter msg[] do INNER ;  #); 
  enter name[]
  do
       (#
          att: @XpmAttributes;
          dpy,root: @integer;
          pmap: @integer;
          status: @integer;
          mask: @integer;
          makeErrorMessage:
            (# msg: ^text;  do &text[]->msg[]; INNER ; msg[]->error;  #);
          
       do
          THIS(guienv).private.display->dpy;
          dpy->XDefaultRootWindow->root;
          (dpy,root,name,@@ pmap,@@ mask,@@ att.valuemask)->XpmReadFileToPixmap
            ->status;
          (if status
           // XpmSuccess then
              pmap->private.pixmapID;
              att.width->private.width;
              att.height->private.height;
              mask->private.maskID;
              THIS(guienv).private.defaultDepth->private.depth;
              
           // XpmOpenFailed then
              makeErrorMessage
                (# 
                do
                   'cannot open pixmap file '->msg.putText;
                   name[]->msg.putLine;
                   
                #);
              
           // XpmFileInvalid then
              makeErrorMessage
                (# 
                do
                   name[]->msg.puttext;
                   ' is not a valid pixmap file'->msg.putline;
                   
                #);
              
           // XpmNoMemory then
              makeErrorMessage
                (# 
                do
                   'Not enough memory to hold pixmap file '->msg.puttext;
                   name[]->msg.putline;
                   
                #)
           // XpmColorError then
              makeErrorMessage
                (# 
                do
                   'Could not open pixmap file'->msg.puttext;
                   name[]->msg.putline;
                   ' - exact colors could not be allocated'->msg.putLine;
                   
                #)
           // XpmColorFailed then
              makeErrorMessage
                (# 
                do
                   'Could not open pixmap file'->msg.puttext;
                   name[]->msg.putline;
                   ' - the necessary colors could not be allocated'
                     ->msg.putLine;
                   
                #)
           else
              makeErrorMessage
                (# 
                do
                   'Cannot create pixmap from file '->msg.putText;
                   name[]->msg.putText;
                   ' because of unknown error = '->msg.putText;
                   status->msg.putInt;
                   msg.newLine;
                   
                #);
              
          if);
          
       #)
  #);
XImage: data
  (#
     width: @integer;
     height: @integer;
     xoffset: @integer;
     format: @integer;
     data: @integer;
     byte_order: @integer;
     bitmap_unit: @integer;
     bitmap_bit_order: @integer;
     bitmap_pat: @integer;
     depth: @integer;
     bytes_per_line: @integer;
     bits_per_pixel: @integer;
     red_mask: @integer;
     green_mask: @integer;
     blue_mask: @integer;
     obdata: @integer;
     hook1,hook2,hook3,hook4,hook5,hook6: @integer;
     
  #);
XPutImage: External (* 6.7 *)
  (#
     display,drawable,gc,srcX,srcY,dstX,dstY,width,height: @integer;
     image: ^XImage;
     
  enter (display,drawable,gc,image[],srcX,srcY,dstX,dstY,width,height)
  #);
YAllocColor: external
  (# display: @integer; cmap: @integer; c: ^XColor; result: @integer; 
  enter (display,cmap,c[])
  exit result
  #);
readPNG: external
  (#
     display: @integer;
     name: [1] @char;
     image: @integer;
     mask: @integer;
     error: @integer;
     
  enter (display,name,image,mask)
  exit error
  #);
readPNGfile:
  (#
     name: ^text;
     error:< (# msg: ^text;  enter msg[] do INNER ;  #);
     gc,errorCode,dpy: @integer;
     image: ^XImage;
     mask: @integer;
     
  enter name[]
  do
     THIS(guienv).private.display->dpy;
     (dpy,name,@@ image,@@ mask)->readPNG->errorCode;
     (if errorCode
      // 0 then
         (image.width,image.height)->init;
         (dpy,private.pixmapID,0,0)->XCreateGC->gc;
         (dpy,private.pixmapID,gc,image[],0,0,0,0,image.width,image.height)
           ->XPutImage;
         dpy->XFlush;
         (dpy,gc)->XFreeGC;
         %getLongAt (@@ image)->XDestroyImage;
         mask->private.maskID;
         
      // 1 then
         'No such file'->error; 
      // 2 then
         'Wrong format'->error; 
      // 3 then
         'Not enough memory'->error; 
     if);
     
  #);
  

-- pixMapRead: DoPart --
do
   l:
     (# theExpandedName: ^text; format: @integer; msg: ^text; 
     do
        name[]
          ->expandPixmapName
            (#
               error::<
                 (# originalMsg: ^text; 
                 do
                    msg[]->originalMsg[];
                    'brokenImageImage.png'
                      ->expandPixmapName
                        (#
                           error::<
                             (# 
                             do originalMsg[]->THIS(read).error; leave l; 
                             #);
                           
                        #)->expandedName[];
                 #);
            #)->theExpandedName[];
        (if theExpandedName[] <> none then
            theExpandedName[]->guessPixmapFormat->format;
            (if format
             // XBMformat then
                theExpandedName[]
                  ->readXBMfile
                    (# error:: (#  do msg[]->THIS(read).error #) #);
                
             // XPMformat then
                theExpandedName[]
                  ->readXPMfile
                    (# error::  (#  do msg[]->THIS(read).error #) #);
                
             // PNGformat then
                theExpandedName[]
                  ->readPNGfile
                    (# error::  (#  do msg[]->THIS(read).error #) #);
                
             // unknown then
                &text[]->msg[];
                'file "'->msg.putText;
                theExpandedName[]->msg.putText;
                '" has an unknown format!'->msg.putLine;
                msg[]->error;
                
            if);
            
        if);
        
     #);
     

-- pixmapClear: DoPart --
do
     (#
        pixel: @integer;
        theXColor: @XColor;
        dpy: @integer;
        cmap: @integer;
        screen: @integer;
        result: @integer;
        myGc: @integer;
        
     do
        theColor.red->theXColor.red;
        theColor.green->theXColor.green;
        theColor.blue->theXColor.blue;
        THIS(guienv).private.display->dpy;
        dpy->XDefaultScreen->screen;
        (dpy,screen)->XDefaultColorMap->cmap;
        (dpy,cmap,theXColor[])->YAllocColor->result;
        (if result = 0 then
            'XAllocColor failed in "pixmap.clear'->putLIne; 
         else
            theXColor.pixel->pixel;
            (THIS(guienv).private.display,private.pixmapID,0,0)->XCreateGC
              ->myGC;
            (dpy,myGC,pixel)->XSetForeground;
            (dpy,private.pixmapID,myGC,0,0,private.width,private.height)
              ->XFillRectangle;
            dpy->XFlush;
            (THIS(guienv).private.display,myGC)->XFreeGC;
            
        if)
     #);
     

-- pixmapInit: DoPart --
do
   (THIS(guienv).private.display,THIS(guienv).private.defaultdrawable,width,
    height,THIS(guienv).private.defaultdepth)->XCreatePixmap->private.pixmapID;
   THIS(guienv).private.defaultdepth->private.depth;
   width->private.width;
   height->private.height;
     

-- pixmapDispose: DoPart --
do
   assertInitialized;
   (if private.stippleID <> 0 then
       (if private.stippleID <> private.pixmapID then
           (THIS(guienv).private.display,private.stippleID)->XFreePixmap; 
       if);
       
   if);
   (THIS(guienv).private.display,private.pixmapID)->XFreePixmap;
   0->private.pixmapID;
   0->private.stippleID;
   0->private.width;
   0->private.height;
   0->private.depth;
   (if private.maskID <> 0 then
       (THIS(guienv).private.display,private.maskID)->XFreePixmap; 
   if);
     

-- pixmapWidth: DoPart --
do assertInitialized; private.width->value;   

-- pixmapHeight: DoPart --
do assertInitialized; private.height->value;   

-- pixmapAsStipple: DoPart --
do
   assertInitialized;
   (if private.stippleID = 0 then
       (if private.depth = 1 then
           private.pixmapID->private.stippleID; 
        else
             (# dpy,root,bitmapGC: @integer; 
             do
                THIS(guienv).private.display->dpy;
                THIS(guienv).private.display->XDefaultRootWindow->root;
                (dpy,root,private.width,private.height,1)->XCreatePixmap
                  ->private.stippleID;
                (dpy,private.stippleID,0,0)->XCreateGC->bitmapGC;
                (if bitmapGC = 0 then
                    'Cannot create GC for pixmap.asStipple operation'->putline; 
                 else
                    (dpy,bitmapGC,0)->XSetForeground;
                    (dpy,bitmapGC,maxint)->XSetBackground;
                    (dpy,bitmapGC,0)->XSetGraphicsExposures;
                    (dpy,private.pixmapID,private.stippleID,bitmapGC,0,0,
                     private.width,private.height,0,0,1)->XCopyPlane;
                    (dpy,bitmapGC)->XFreeGC;
                    
                if);
                
             #);
           
       if);
       
   if);
   private.stippleID->stippleID;
     

-- pixmapSettransparent: DoPart --
do   

-- pixmapGettransparent: DoPart --
do   

-- pixMapSettransparentColor: DoPart --
do   

-- pixMapGettransparentColor: DoPart --
do   

-- pixmapSetMask: DoPart --
do   

-- pixmapGetMask: DoPart --
do   

-- pixmapDrawPixmap: DoPart --
do   

