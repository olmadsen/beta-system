ORIGIN 'guienv_unixprivate';
INCLUDE '../../keys';
LIB_ITEM 'guienv';
-- GUIenvLib: Attributes --
callbackProcessor: external (* prefix for callbackentries *)
  (#
     w,clientdata,calldataAddress: @integer;
     status: @integer;
     cb: ^callbackSelector;
     
  enter (w,clientdata,calldataAddress)
  do
     cexternalEntry;
     INNER ;
     (w,clientdata,calldataAddress)
       ->(cb.widget,cb.clientdata,cb.calldataAddress);
     (if XSystemEnvPresent then
         cb[]->XsystemEnvHandleCallback; 
      else
         cb; 
     if);
     
  exit status
  #);
callbackSelector:
  (# widget: @integer; clientData: @integer; callDataAddress: @integer; 
  do INNER ; 
  #);
motifCallbackSelector: callbackSelector
  (# reason,eventAddress: @integer; 
  do
     callDataAddress+reasonOffset->tos'%adrGetLong'->reason;
     callDataAddress+eventOffset->tos'%adrGetLong'->eventAddress;
     INNER ;
     
  #);
textCallBackSelector: motifCallbackSelector
  (#
     doit:
       (# value: @boolean; 
       enter value
       do (callDataAddress+textDoitOffset,value)->tos'%putByte'; 
       #);
     currInsert,newInsert,startPos,endPos,textP: @integer;
     
  do
     callDataAddress+textCurrInsertOffset->tos'%adrGetLong'->currInsert;
     callDataAddress+textNewInsertOffset->tos'%adrGetLong'->newInsert;
     callDataAddress+textStartPosOffset->tos'%adrGetLong'->startPos;
     callDataAddress+textEndPosOffset->tos'%adrGetLong'->endPos;
     callDataAddress+textTextOffset->tos'%adrGetLong'->textP;
     INNER ;
     
  #);
eventProcessor: external
  (#
     widget: @integer;
     clientData: @integer;
     eventAddress: @integer;
     continueP: @integer;
     status: @integer;
     es: ^eventSelector;
     
  enter (widget,clientData,eventAddress,continueP)
  do
     cExternalEntry;
     eventAddress->THIS(guienv).private.lastEvent;
     INNER ;
     (widget,clientData,eventAddress)
       ->(es.widget,es.clientData,es.eventAddress);
     (if XSystemEnvPresent then es[]->XsystemEnvHandleCallback else es;  if);
     0->THIS(guienv).private.lastEvent;
     
  #);
eventSelector:
  (# clientData,eventAddress: @integer; widget: @integer; type: @integer; 
  do eventAddress->tos'%adrGetLong'->type; INNER ; 
  #);
DeviceEventSelector: eventSelector
  (#
     x,y,x_root,y_root: @integer;
     dh,dv: @integer;
     state: @integer;
     detail: @integer;
     time: @integer;
     
  do
     eventAddress+xOffset->tos'%adrGetLong'->x->private.x;
     eventAddress+yOffset->tos'%adrGetLong'->y->private.y;
     eventAddress+x_rootOffset->tos'%adrGetLong'->x_root;
     eventAddress+y_rootOffset->tos'%adrGetLong'->y_root;
     eventAddress+stateOffset->tos'%adrGetLong'->state->private.state;
     eventAddress+detailOffset->tos'%adrGetLong'->detail;
     eventAddress+timeOffset->tos'%adrGetLong'->time;
     (if type
      // XButtonRelease then
         private.lastDoubleClick->private.doubleClick; 
      // XButtonPress then
         false->private.doubleClick;
         (if detail = private.detail then
             (if (time-private.time) < 300 then
                 x_root-private.x_root->dh;
                 y_root-private.y_root->dv;
                 (if (dh*dh+dv*dv) < 10 then true->private.doubleClick;  if);
                 
             if);
             
         if);
         
     if);
     time->private.time;
     detail->private.detail;
     x_root->private.x_root;
     y_root->private.y_root;
     private.doubleClick->private.lastDoubleClick;
     INNER ;
     
  #);
KeyEventSelector: DeviceEventSelector
  (#
     chBuffer: [20] @char;
     theKeySym: @integer;
     NoOfChars: @integer;
     theChar: @char;
     spk:@specialKeys;
  do
     (if (state %band controlMask) = controlMask then
         (state %band (%bnot controlMask))
         %putLongAt
           (eventAddress+stateOffset);
         
     if);
     (eventAddress,@@ chbuffer[1],20,@@ theKeySym,0)->XLookupString->noOfChars;
     (if theKeySym
      // xkLeft then
         ASCII.fs->theChar; 
      // xkRight then
         ASCII.gs->theChar; 
      // xkUp then
         ASCII.rs->theChar; 
      // xkDown then
         ASCII.us->theChar; 
      else
         (if noOfChars <> 0 then (* use only first character *)
             chBuffer[1]->theChar; 
         if);
         'Xkey:'->puttext;
         theKeySym->putint;
         newline
     if);
     theChar->private.theChar;
     0->private.theKey;
     (if theChar>0 then
         theChar+65536->private.theKey
      else
         (if theKeySym
          // XKHome then
             spk.HOME->private.theKey
          // XKEnd then
             spk.END->private.theKey
          // XKInsert then
             spk.INSERT->private.theKey
          // XKPageUp then
             spk.PG_UP->private.theKey
          // XKPageDown then
             spk.PG_DOWN->private.theKey
          // XKHelp 
          // XKF1 then
             spk.F1->private.theKey
          // XKF2 then
             spk.F2->private.theKey
          // XKF3 then
             spk.F3->private.theKey
          // XKF4 then
             spk.F4->private.theKey
          // XKF5 then
             spk.F5->private.theKey
          // XKF6 then
             spk.F6->private.theKey
          // XKF7 then
             spk.F7->private.theKey
          // XKF8 then
             spk.F8->private.theKey
          // XKF9 then
             spk.F9->private.theKey
         if)
     if);
     INNER 
  #);

ButtonEventSelector: DeviceEventSelector (#  do INNER ;  #);
MotionEventSelector: DeviceEventSelector (#  do INNER ;  #);
CrossingEventSelector: eventSelector (#  do INNER ;  #);
FocusChangeEventSelector: eventSelector
  (# detail,mode: @integer; 
  do
     eventAddress+focusModeOffset->tos'%adrGetLong'->mode;
     eventAddress+focusDetailOffset->tos'%adrGetLong'->detail;
     INNER ;
     
  #);
ExposeEventSelector: eventSelector
  (# count: @integer; x,y,width,height: @integer; 
  do
     eventAddress+exposeXOffset->tos'%adrGetLong'->x;
     eventAddress+exposeYOffset->tos'%adrGetLong'->y;
     eventAddress+exposeWidthOffset->tos'%adrGetLong'->width;
     eventAddress+exposeHeightOffset->tos'%adrGetLong'->height;
     eventAddress+countOffset->tos'%adrGetLong'->count;
     INNER ;
     
  #);
VisibilityEventSelector: eventSelector (#  do INNER ;  #);
CreateWindowEventSelector: eventSelector (#  do INNER ;  #);
DestroyWindowEventSelector: eventSelector (#  do INNER ;  #);
UnmapEventSelector: eventSelector (#  do INNER ;  #);
MapEventSelector: eventSelector (#  do INNER ;  #);
ConfigureEventSelector: eventSelector (#  do INNER ;  #);
typeOffset: (#  exit 0 #);
serialOffset: (#  exit 4 #);
send_eventOffset: (#  exit 8 #);
displayOffset: (#  exit 12 #);
windowOffset: (#  exit 16 #);
rootOffset: (#  exit 20 #);
sub_windowOffset: (#  exit 24 #);
timeOffset: (#  exit 28 #);
xOffset: (#  exit 32 #);
yOffset: (#  exit 36 #);
x_rootOffset: (#  exit 40 #);
y_rootOffset: (#  exit 44 #);
stateOffset: (#  exit 48 #);
detailOffset: (#  exit 52 #);
key_codeOffset: (#  exit 52 #);
buttonOffset: (#  exit 52 #);
same_screenOffset: (#  exit 56 #);
focusModeOffset: (#  exit 20 #);
focusDetailOffset: (#  exit 24 #);
exposeXOffset: (#  exit 20 #);
exposeYOffset: (#  exit 24 #);
exposeWidthOffset: (#  exit 28 #);
exposeHeightOffset: (#  exit 32 #);
countOffset: (#  exit 36 #);
reasonOffset: (#  exit 0 #);
eventOffset: (#  exit 4 #);
pushButtonClickCount: (#  exit 8 #);
listItemOffset: (#  exit 8 #);
listItemPositionOffset: (#  exit 16 #);
textDoitOffset: (#  exit 8 #);
textCurrInsertOffset: (#  exit 12 #);
textNewInsertOffset: (#  exit 16 #);
textStartPosOffset: (#  exit 20 #);
textEndPosOffset: (#  exit 24 #);
textTextOffset: (#  exit 28 #);
  

