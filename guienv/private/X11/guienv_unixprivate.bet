ORIGIN '../guienvbody';
BODY 'pixmapbody';

INCLUDE 'guienvattributes';
INCLUDE 'deviceinfo';
INCLUDE '../linkedlist';
INCLUDE 'xevents';
[[

-- guienvLib: attributes --

motifMenu: interfaceObject
  (# <<SLOT motifMenuLib: attributes>>;
     theMenu: ^menu;
     owner: ^interfaceObject;
     popup: @boolean;
     append:
       (# theItem: ^menu.menuitem;
       enter theItem[]
       <<SLOT GUIENVmotifMenuappend: doPart>>
       #);
     delete:
       (# theItem: ^menu.menuitem;
       enter theItem[]
       <<SLOT GUIENVmotifMenudelete: doPart>>
       #);
     
     motifMenuitem: interfaceObject
       (# <<SLOT motifMenuItemLib: attributes>>;
	  theMenuitem: ^menu.menuItem;
	  theMotifSubMenu: ^motifMenu;
	  checked: @boolean;
	  
	  open::<
	    (# create::<
		 (# <<SLOT GUIENVmotifMenuItemCreate: doPart>>
		 #);
	    #);
	  close::<
	    (# 
	    <<SLOT GUIENVmotifMenuItemClose: doPart>> 
	    #);
       #);

     open::<
       (# create::< (# <<SLOT GUIENVmotifMenuCreate: doPart>> #);
       <<SLOT GUIENVmotifMenuOpen: doPart>>
       #);
     close::<
       (# 
       <<SLOT GUIENVmotifMenuClose: doPart>>
       #);
     getItemByNumber:
       (# position: @integer;
	  theMotifMenuItem: ^motifMenuitem;
       enter position
       <<SLOT GUIENVmotifMenuGetItemByNumber: doPart>>
       exit theMotifMenuItem[]
       #);
     getNumberOfWidget:
       (# position: @integer;
	  widget: @integer;
       enter widget
       <<SLOT GUIENVmotifMenugetNumberOfWidget: doPart>>
       exit position
       #);
     
     private: @<<SLOT GUIENVmotifMenuPrivate: descriptor>>;
  #);
motifMenubar: interfaceObject
  (# <<SLOT motifMenubarLib: attributes>>;
     theWindow: ^window;
     append:
       (# theMenu: ^menu;
       enter theMenu[]
       <<SLOT GUIENVmotifMenubarappend: doPart>>
       #);
     delete:
       (# theMenu: ^menu;
       enter theMenu[]
       <<SLOT GUIENVmotifMenubardelete: doPart>>
       #);
     open::<
       (# create::< (# <<SLOT GUIENVmotifMenubarcreate: doPart>> #);
       <<SLOT GUIENVmotifMenubaropen: doPart>>
       #);
     close::<
       (# 
       <<SLOT GUIENVmotifMenubarClose: doPart>>
       #);
     private: @<<SLOT GUIENVmotifMenubarprivate: descriptor>>;
  #);

--- GUIENVPrivate: descriptor ---
(# (* bifrost begin *)
   damaged: @rectangle;
   xcolormap: @integer;
   defaultscreen: @integer;
   defaultScreenNumber: @integer;
   defaultDepth: @integer;
   defaultVisual: @integer;
   defaultDrawable: @integer;
   blackpixelvalue, whitepixelvalue: @integer;
   screenHeight, screenWidth: @integer;
   pixelsPerMillimeterHeight, pixelsPerMillimeterWidth: @Real;
   xfont: 
     (# name: @Text;
	loaded: @Boolean;
	maxdescent: @Integer;
	fixedwidth : @ boolean; (* true iff the font is fixed-width *)
	
	(* The height, width and baseline of the font. width is only
	 * defined if fixedWidth is true
	 *)
	width,height,baseline : @integer;
	XfontId: @ integer;
	fi: @fontinfo;
	
	(* the first and last chars in the font *)
	firstCharInFont,LastCharInFont : @ char;
	
	upos: @
	  (# p: @integer
	  do (fi, XaUnderlinePosition, @@p) -> XGetFontProperty;
	     (if p=0 then 3 -> p if)
	  exit p 
	  #);
	uthick: @
	  (# t: @integer 
	  do (if t=0 then
		 (fi, XaUnderlineThickness, @@t) -> XGetFontProperty;
		 (if t=0 then 1 -> t if);
	     if);
	  exit t 
	  #);
	letterWidth: @
	  (* returns the width of a letter *)
	  (# ch: @char; w: @integer;
	  enter ch
	  do
	     (if Xfontid=0 then 
		 'ERROR: XLetterWidth: trying to use uninitialized font' -> putline;
	     if);
	     (if ((ch >= firstCharInFont ) AND 
		 (ch<= lastCharInFont))
	       then
		 (if FixedWidth then
		     width -> w;
		  else
		     ch -> fi.perCharWidth -> w;
		 if)
	      else 0->w
	     if)
	  exit w 
	  #);
     #);
   fonts: @
     (* Declaration of a 3-dimensional array for fontspecifications.  A lot of
      * trouble caused by the fact that multidimensional repetitions isn't
      * possible in BETA, and that repetitions of arbitrary patterns is not
      * implemented.
      *)
     (# sizearray: (# size: [40] ^xfont #);
	stylearray: (# style: [3] ^sizearray #);
	xfonts: [3] ^stylearray;
	defaultfont: @xfont;
	initialized: @integer;
     #);
   (* bifrost end *)
   display: @integer;
   gc: @integer; (* A gc for the ROOT window of the display *)
   dontRunLoop: @boolean;
   wargs: @argList;
   theXtLib: @xtlib;
   appName: ^Text;
   (* the name of the application *)
   appClass: ^Text;
   (* the class of the application *)
   fallBackResources: @StringArray
     (# 
	init::<
	  (# 
	  do '*Background: grey75' -> addText;
	     '*Foreground: black' -> addText;
	     (* disable Motif drag & drop *)
	     '*dragInitiatorProtocolStyle: XmDRAG_NONE' -> addText;
	     '*dragReceiverProtocolStyle:  XmDRAG_NONE' -> addText;
	     '*popupEnabled: False' -> addText;
	  #);
     #);
   options: @XrmOptionDescRecList;
   
   appCon: @XtAppContext;
   
   
   doubleClick: @Boolean;
   x, y, x_root, y_root, state, detail: @integer;
   theChar: @char;
   time: @integer;
   textP: @integer;
   
   (* Refresh event compression BEGIN: *)
   updateLeft, updateTop, updateRight, updateBottom: @integer;
   
   updateRectAdd: @
     (# left, top, right, bottom: @integer;
	maxOp: @max;
	minOp: @min;
     enter ((left, top), (right, bottom))
     do (left, updateLeft) -> minOp -> updateLeft;
	(top, updateTop) -> minOp -> updateTop;
	(right, updateRight) -> maxOp -> updateRight;
	(bottom, updateBottom) -> maxOp -> updateBottom;
     #);
   
   updateRectFlush: @
     (# 
     do ((updateLeft, updateTop), (updateRight, updateBottom)) -> damaged;
	MaxInt -> updateLeft -> updateTop;
	MinInt -> updateRight -> updateBottom;
     #);
   (* END*)
   
   theWindow: ^window;
   
   theMenubar: ^menubarType;
   
   
   windows: @list
     (# element::< window;
     #);
   lastButtonPress,lastButton: @integer;
   lastX, lastY: @integer;
   lastDoubleClick: @boolean;
  
   
   lastEvent: @integer;
   
   theDeviceInfo: ^deviceInfo;
   busyCursor: ^cursor;
   wmDeleteWindowAtom, wmProtocolsAtom: @integer;
#)

-- interfaceObjectLib: attributes --
actionList: linkedList
  (# element:: action;
  #);
eventSpec:
  (# type: ##theEventHandler.event;
  #);
eventSpecList: linkedList
  (# element:: eventSpec;
     remove:
       (# ev: ##theEventHandler.event;
       enter ev##
       do l: scan
	    (# 
	    do (if current.type## = ev## then
		   current[] -> delete;
		   leave l;
	       if);
	    #);
       #);
     has: booleanValue
       (# ev: ##theEventHandler.event;
       enter ev##
       do false -> value;
	  l: scan
	    (# 
	    do (if ev## <= current.type## then
		   true -> value;
		   leave l;
	       if);
	    #);
       #);
  #);

addCallbackPrefix:
  (# callback: ##external;
     type: @integer;
     address: @integer;
  enter (callback##, type)
  <<SLOT GUIENVinterfaceObjectAddCallbackPrefix: doPart>>
  exit address
  #);
appendEventProcessor: addCallbackPrefix
  (#  <<SLOT GUIENVinterfaceObjectappendEventProcessor: doPart>>  #);
appendEventProcessorForSubWidget: addCallbackPrefix
  (# widget: @integer;
  enter widget
  <<SLOT GUIENVinterfaceObjectappendEventProcessorForSubWidget: doPart>>
  #);
prependEventProcessor: addCallbackPrefix
  (#  <<SLOT GUIENVinterfaceObjectPrependEventProcessor: doPart>> #);
addCallbackProcessor: addCallbackPrefix
  (# <<SLOT GUIENVinterfaceObjectAddCallbackProcessor: doPart>>
  #);
addCallbackProcessorForSubWidget: addCallbackPrefix
  (# subWidget: @integer;
  enter subWidget
  <<SLOT GUIENVinterfaceObjectAddCallbackProcessorForSubWidget: doPart>>
  #);

--- GUIENVinterfaceObjectPrivate: descriptor ---
(# widgetID: @integer;
   isOpen, beingClosed: @boolean;
   callbacks: [0] @integer;
   beforeActions,afterActions: ^actionList;
   disabledEvents: ^eventSpecList;
#)

-- menuLib: attributes --
buildMenu:
  (# fatherWidget: @integer;
  enter fatherWidget
  do <<SLOT GUIENVmenuBuildMenu: descriptor>>;
  #);
buildPopupmenu:
  (#  fatherWidget: @integer;
  enter fatherWidget
  do <<SLOT GUIENVmenuBuildPopupmenu: descriptor>>;
  #);
destroyMenu:
  (# 
  do <<SLOT GUIENVmenuDestroyMenu: descriptor>>
  #);

--- GUIENVmenuPrivate: descriptor ---
(# menuitems: @List
     (# element::< menuItem;
     #);
   motifMenus: @list
     (# element::< motifMenu;
	remove:
	  (# e: ^element;
	  enter e[]
	  do (if e[] -> has then
		 e[] -> at -> delete;
	     if);
	  #);
     #);
   name: ^text;
   enabled: @boolean;
   theMenubar: ^menubar;
   theEntry: ^menubar.menubarEntry;
   
   (* For use when used as popup menu *)
   motifPopupMenu: ^motifmenu;
   popupbutton: @integer; (* 0, 1, 2, 3, 4, or 5; 0 means 3 corresponding to default BMenu in Motif *)
   popupevent: ^XButtonEvent;
#)

-- menuitemLib: attributes --
doExpose:
  (# 
  <<SLOT GUIENVmenuItemDoExpose: doPart>>
  #);
scanMotifMenuItems:
  (# currentMotifMenu: ^motifMenu;
     current: ^motifMenu.motifMenuItem;
  <<SLOT GUIENVmenuitemscanMotifMenuItems: doPart>>
  #);

--- GUIENVmenuItemPrivate: descriptor ---
(# key: @char;
   name: ^text;
   checked: @boolean;
   theSubMenu: ^menu;
#)

-- menubarLib: attributes --
menubarEntry:
  (# <<SLOT menubarEntryLib: attributes>>;
     theMenu: ^menu;
     cascadeButtonWidget: @integer;
     buildEntry: 
       (# position: @integer;
       enter position
       <<SLOT GUIENVmenubarEntryDoBuildEntry: doPart>>
       #);
     destroyEntry:
       (# <<SLOT GUIENVmenubarEntrydestroyEntry: doPart>> #);
     rebuildEntry: 
       (# <<SLOT GUIENVmenubarEntryRebuildEntry: doPart>> #);
  #);

-- windowLib: attributes --
theTarget:
  (# 
  enter private.theTarget[]
  exit private.theTarget[]
  #);
adjustContents: 
  (#
  <<SLOT GUIENVwindowadjustContents: doPart>>
  #);

-- GUIENVwindowPrivate: descriptor --
(# theMenubar: ^menuBarType;
   theMotifmenubar: ^motifMenubar;
   theTarget: ^windowitem;
   contentsForm: @interfaceObject;
   
   isModal,floating,visible: @boolean;
   contents: @canvas
     (# eventHandler::<
	  (# onMouseDown::<
	       (#
	       do this(window).theEventHandler.onMouseDown;
	       #);
	     onMouseUp::<
	       (# 
	       do this(window).theEventHandler.onMouseUp
	       #);
	     onKeyDown::<
	       (# 
	       do this(window).theEventHandler.onKeyDown;
	       #);
	     onRefresh::<
	       (# 
	       do this(window).theEventHandler.onRefresh;
	       #);
	  #);
	open::<
	  (# create::<
	       (#
	       do (XbCanvasWidgetClass,contentsForm.widgetID) -> createSimple; 
		  (# 
		  do (XtNwidth,300) -> setIntegerResource;
		     (XtNheight,200) -> setIntegerResource;
		  #);
	       #);
	  #);
     #);
#)

-- windowitemLib: attributes --

getFrame: 
  (# h,v,width,height: @integer;
     bottom,right: @integer;
     f: @rectangle;
  do 
     XtNx -> getShortResource -> h;
     XtNy -> getShortResource -> v;
     XtNwidth -> getShortResource -> width;
     XtNheight -> getShortResource -> height;
     h + width -> right;
     v + height -> bottom;
     ((h,v),(right,bottom)) -> f;
  exit f
  #);

handleframeChanged:
  (# newFrame,oldFrame: @rectangle;
  enter (oldFrame,newFrame)
  <<SLOT GUIENVwindowItemHandleFrameChanged: doPart>>
  #);
setXBorder:
  (# width: @integer;
  enter width
  <<SLOT GUIENVwindowItemSetXBorder: doPart>>
  #);

--- GUIENVwindowitemPrivate: descriptor ---
(# visible,frameChangedHandled,hilite,borderVisible: @boolean;
   needsWidget, delegate: @boolean;
   borderStyle: @integer;
   left, top, bottom, right: @integer;
   mouseUpProcessorAddress: @integer;
   theCursor: ^cursor;
   
   hit: ##hitMethod;
#)

-- GUIENVtextStylePrivate: descriptor --
(# size,face: @integer;
   name: @text;
   fontStruct: @integer;
#)


-- pixmapLib: attributes --

assertInitialized:
  (# 
  do (if private.pixmapID = 0 then
	 exception
	 (#
	 do 'Accesing a pixmap that are not initialized' -> msg.append;
	 #);
     if);
  #);

asStipple:
  (# stippleID: @integer;
     gc: @integer;
  enter gc
  <<SLOT pixmapAsStipple: doPart>>
  exit stippleID
  #);

-- pixmapPrivate: descriptor --
(# pixmapID: @integer;
   stippleID: @integer;
   maskID: @integer;
   depth: @integer;
   width, height: @integer;
#)

--]]
