ORIGIN '../guienvbody';
INCLUDE 'guienvattributes'
        'deviceinfo'
        '../linkedlist';
LIB_ITEM 'guienv';
BODY 'pixmapbody'
     'timerbody';
-- guienvLib: Attributes --
(* SetAnswer is trick that works as follows:
 * When the answer is FALSE, the canvas widget
 * will not allow any child to change geometry.
 * when answer is TRUE, all children are allowed
 * to change geometry. Answer is normally FALSE,
 * but is changed to TRUE before any intended change
 * in the childrens geometry. 
 * 
 * SetAnswer controls a global variable, defined
 * in CanvasP.c
 *)
SetAnswer: external (# value: @Boolean;  enter value #);
motifMenu: interfaceObject
  (#
     <<SLOT motifMenuLib:Attributes>>;
     theMenu: ^menu;
     owner: ^interfaceObject;
     popup: @boolean;
     append:
       (# theItem: ^menu.menuitem; 
       enter theItem[]
       <<SLOT GUIENVmotifMenuappend:DoPart>>
       #);
     delete:
       (# theItem: ^menu.menuitem; 
       enter theItem[]
       <<SLOT GUIENVmotifMenudelete:DoPart>>
       #);
     motifMenuitem: interfaceObject
       (#
          <<SLOT motifMenuItemLib:Attributes>>;
          theMenuitem: ^menu.menuItem;
          theMotifSubMenu: ^motifMenu;
          checked: @boolean;
          open::< 
            (#
               create::<  (#  <<SLOT GUIENVmotifMenuItemCreate:DoPart>> #); 
            #);
          close::<  (#  <<SLOT GUIENVmotifMenuItemClose:DoPart>> #);
          
       #);
     open::< 
       (#
          create::< 
            (# 
            <<SLOT GUIENVmotifMenuCreate:DoPart>>
            #);
          
       <<SLOT GUIENVmotifMenuOpen:DoPart>>
       #);
     close::< 
       (# 
       <<SLOT GUIENVmotifMenuClose:DoPart>>
       #);
     getItemByNumber:
       (# position: @integer; theMotifMenuItem: ^motifMenuitem; 
       enter position
       <<SLOT GUIENVmotifMenuGetItemByNumber:DoPart>>
       exit theMotifMenuItem[]
       #);
     getNumberOfWidget:
       (#
          position: @integer;
          widget: @integer;
          
       enter widget
       <<SLOT GUIENVmotifMenugetNumberOfWidget:DoPart>>
       exit position
       #);
     popdownHook: ^object;
     private: @<<SLOT GUIENVmotifMenuPrivate:Descriptor>>;
     
  #);
motifMenubar: interfaceObject
  (#
     <<SLOT motifMenubarLib:Attributes>>;
     theWindow: ^window;
     append:
       (# theMenu: ^menu; 
       enter theMenu[]
       <<SLOT GUIENVmotifMenubarappend:DoPart>>
       #);
     delete:
       (# theMenu: ^menu; 
       enter theMenu[]
       <<SLOT GUIENVmotifMenubardelete:DoPart>>
       #);
     open::< 
       (# create::<  (#  <<SLOT GUIENVmotifMenubarcreate:DoPart>> #); 
       <<SLOT GUIENVmotifMenubaropen:DoPart>>
       #);
     close::<  (#  <<SLOT GUIENVmotifMenubarClose:DoPart>> #);
     private:
       @<<SLOT GUIENVmotifMenubarprivate:Descriptor>>;
     
  #);
  

-- GUIENVPrivate: Descriptor --
(# ActionList: List
     (# element:: globalKeyDownAction;
     #);
   
   beforeKeyDown: @ActionList;
   afterKeyDown: @ActionList;
   
   
   (* bifrost begin *)
   damaged: @rectangle;
   xcolormap: @integer;
   defaultscreen: @integer;
   defaultScreenNumber: @integer;
   defaultDepth: @integer;
   defaultVisual: @integer;
   defaultDrawable: @integer;
   blackpixelvalue,whitepixelvalue: @integer;
   screenHeight,screenWidth: @integer;
   pixelsPerMillimeterHeight,pixelsPerMillimeterWidth: @Real;
   xfont:
     (#
        name: @Text;
        loaded: @Boolean;
        maxascent: @Integer;
        maxdescent: @Integer;
        lineheight: (#  exit maxascent+maxdescent #);
        fixedwidth: @boolean;
        (* true iff the font is fixed-width *)
        (* The height, width and baseline of the font. width is only
         * defined if fixedWidth is true
         *)
        width,height,baseline: @integer;
        XfontId: @integer;
        fi: @fontinfo;
        (* the first and last chars in the font *)
        firstCharInFont,LastCharInFont: @char;
        upos: @
          (# p: @integer
          do
             (fi,XaUnderlinePosition,@@ p)->XGetFontProperty;
             (if p = 0 then 3->p if)
          exit p
          #);
        uthick: @
          (# t: @integer
          do
             (if t = 0 then
                 (fi,XaUnderlineThickness,@@ t)->XGetFontProperty;
                 (if t = 0 then 1->t if);
                 
             if);
             
          exit t
          #);
        letterWidth: @ (* returns the width of a letter *)
          (# ch: @char; w: @integer; 
          enter ch
          do
             (if Xfontid = 0 then
                 'ERROR: XLetterWidth: trying to use uninitialized font'
                   ->putline;
                 
             if);
             (if ((ch >= firstCharInFont) and (ch <= lastCharInFont)) then
                 (if FixedWidth then
                     width->w; 
                  else
                     ch->fi.perCharWidth->w; 
                 if)
              else
                 0->w
             if)
          exit w
          #);
     #);
   fonts: @
     (* Declaration of a 3-dimensional array for fontspecifications.  A lot of
      * trouble caused by the fact that multidimensional repetitions isn't
      * possible in BETA, and that repetitions of arbitrary patterns is not
      * implemented.
      *)
     (# sizearray: (# size: [60] ^xfont #);
	stylearray: (# style: [3] ^sizearray #);
	xfonts: [3] ^stylearray;
        defaultfont: @xfont;
        scalableName: ^text;
        scalableExists,	initialized: @boolean;
     #);
   (* bifrost end *)
   display: @integer;
   gc: @integer;
   (* A gc for the ROOT window of the display *)
   dontRunLoop: @boolean;
   running: @boolean;
   wargs: @argList;
   theXtLib: @xtlib;
   appName: ^Text;
   (* the name of the application *)
   appClass: ^Text;
   (* the class of the application *)
   fallBackResources: @StringArray
     (#
        init::< 
          (# 
          do
             '*Foreground: black'->addText;
             '*Background: #DDDDDD'->addText;
             '*TopShadowColor: white'->addText;
             '*BottomShadowColor: #888888'->addText;
             '*XmText*Background: white'->addText;
             '*XmList*Background: white'->addText;
             '*XmTextField*Background: white'->addText;
             '*XmText*TopShadowColor: #EEEEEE'->addText;
             '*XmList*TopShadowColor: #EEEEEE'->addText;
             '*XmTextField*TopShadowColor: #EEEEEE'->addText;
             (* disable Motif drag & drop *)
             '*dragInitiatorProtocolStyle: XmDRAG_NONE'->addText;
             '*dragReceiverProtocolStyle:  XmDRAG_NONE'->addText;
             '*popupEnabled: False'->addText;
             
          #);
        
     #);
   options: @XrmOptionDescRecList;
   appCon: @XtAppContext;
   doubleClick: @Boolean;
   x,y,x_root,y_root,state,detail: @integer;
   theChar: @char;
   theKey:@int32;
   time: @integer;
   textP: @integer;
   (* Refresh event compression BEGIN: *)
   updateLeft,updateTop,updateRight,updateBottom: @integer;
   updateRectAdd: @
     (# left,top,right,bottom: @integer; maxOp: @max; minOp: @min; 
     enter ((left,top),(right,bottom))
     do
        (left,updateLeft)->minOp->updateLeft;
        (top,updateTop)->minOp->updateTop;
        (right,updateRight)->maxOp->updateRight;
        (bottom,updateBottom)->maxOp->updateBottom;
        
     #);
   updateRectFlush: @
     (# 
     do
        ((updateLeft,updateTop),(updateRight,updateBottom))->damaged;
        MaxInt->updateLeft->updateTop;
        MinInt->updateRight->updateBottom;
        
     #);
   (* END*)
   theWindow: ^window;
   theMenubar: ^menubarType;
   windows: @list (# element::< window;  #);
   lastButtonPress,lastButton: @integer;
   lastX,lastY: @integer;
   lastDoubleClick: @boolean;
   lastEvent: @integer;
   theDeviceInfo: ^deviceInfo;
   busyCursor: ^cursor;
   wmDeleteWindowAtom,wmProtocolsAtom: @integer;
   
#)  

-- interfaceObjectLib: Attributes --
actionList: linkedList (# element:: action;  #);
eventSpec: (# type: ##theEventHandler.event;  #);
eventSpecList: linkedList
  (#
     element:: eventSpec;
     remove:
       (# ev: ##theEventHandler.event; 
       enter ev##
       do
          l: scan
            (# 
            do
               (if current.type## = ev## then
                   current[]->delete; leave l; 
               if);
               
            #);
          
       #);
     has: booleanValue
       (# ev: ##theEventHandler.event; 
       enter ev##
       do
          false->value;
          l: scan
            (# 
            do (if ev## <= current.type## then true->value; leave l;  if); 
            #);
          
       #);
     
  #);
addCallbackPrefix:
  (# callback: ##external; type: @integer; address: @integer; 
  enter (callback##,type)
  <<SLOT GUIENVinterfaceObjectAddCallbackPrefix:DoPart>>
  exit address
  #);
appendEventProcessor: addCallbackPrefix
  (#  <<SLOT GUIENVinterfaceObjectappendEventProcessor:DoPart>> #);
appendEventProcessorForSubWidget: addCallbackPrefix
  (# widget: @integer; 
  enter widget
  <<SLOT GUIENVinterfaceObjectappendEventProcessorForSubWidget:DoPart>>
  #);
prependEventProcessor: addCallbackPrefix
  (#  <<SLOT GUIENVinterfaceObjectPrependEventProcessor:DoPart>> #);
addCallbackProcessor:
 addCallbackPrefix
  (#  <<SLOT GUIENVinterfaceObjectAddCallbackProcessor:DoPart>> #);
addCallbackProcessorForSubWidget: addCallbackPrefix
  (# subWidget: @integer; 
  enter subWidget
  <<SLOT GUIENVinterfaceObjectAddCallbackProcessorForSubWidget:DoPart>>
  #);
  

-- GUIENVinterfaceObjectPrivate: Descriptor --
(#
   widgetID: @integer;
   isOpen,beingClosed: @boolean;
   callbacks: [0] @integer;
   beforeActions,afterActions: ^actionList;
   disabledEvents: ^eventSpecList;
   
#)  

-- menuLib: Attributes --
buildMenu:
  (# fatherWidget: @integer; 
  enter fatherWidget
  do <<SLOT GUIENVmenuBuildMenu:Descriptor>>; 
  #);
buildPopupmenu:
  (# fatherWidget: @integer; 
  enter fatherWidget
  do
     <<SLOT GUIENVmenuBuildPopupmenu:Descriptor>>;
     
  #);
destroyMenu: (#  do <<SLOT GUIENVmenuDestroyMenu:Descriptor>> #);
  

-- GUIENVmenuPrivate: Descriptor --
(#
   menuitems: @List (# element::< menuItem;  #);
   motifMenus: @list
     (#
        element::< motifMenu;
        remove:
          (# e: ^element; 
          enter e[]
          do (if e[]->has then e[]->at->delete;  if); 
          #);
        
     #);
   name: ^text;
   enabled: @boolean;
   theMenubar: ^menubar;
   theEntry: ^menubar.menubarEntry;
   (* For use when used as popup menu *)
   motifPopupMenu: ^motifmenu;
   popupbutton: @integer;
   (* 0, 1, 2, 3, 4, or 5; 0 means 3 corresponding to default BMenu in Motif *)
   popupevent: ^XButtonEvent;
   
#)  

-- menuitemLib: Attributes --
doExpose: (#  <<SLOT GUIENVmenuItemDoExpose:DoPart>> #);
scanMotifMenuItems:
  (#
     currentMotifMenu: ^motifMenu;
     current: ^motifMenu.motifMenuItem;
     
  <<SLOT GUIENVmenuitemscanMotifMenuItems:DoPart>>
  #);
  

-- GUIENVmenuItemPrivate: Descriptor --
(# key: @char; name: ^text; checked: @boolean; theSubMenu: ^menu; speckey:@integer; ctrl,shift,alt,hasmod:@boolean #)  

-- menubarLib: Attributes --
menubarEntry:
  (#
     <<SLOT menubarEntryLib:Attributes>>;
     theMenu: ^menu;
     cascadeButtonWidget: @integer;
     buildEntry:
       (# position: @integer; 
       enter position
       <<SLOT GUIENVmenubarEntryDoBuildEntry:DoPart>>
       #);
     destroyEntry: (#  <<SLOT GUIENVmenubarEntrydestroyEntry:DoPart>> #);
     rebuildEntry:
       (# 
       <<SLOT GUIENVmenubarEntryRebuildEntry:DoPart>>
       #);
     
  #);
  

-- windowLib: Attributes --
theTarget: (#  enter private.theTarget[] exit private.theTarget[] #);
adjustContents: (#  <<SLOT GUIENVwindowadjustContents:DoPart>> #);
  

-- GUIENVwindowPrivate: Descriptor --
(#
   theToolTipControl: ^object;
   theMenubar: ^menuBarType;
   theMotifmenubar: ^motifMenubar;
   theTarget: ^windowitem;
   contentsForm: @interfaceObject;
   theDefaultButton: ^windowItem;
   isModal,floating,visible: @boolean;
   contents: @canvas
     (#
        eventHandler::< 
          (#
             onMouseDown::< 
               (#  do THIS(window).theEventHandler.onMouseDown;  #);
             onMouseUp::<  (#  do THIS(window).theEventHandler.onMouseUp #);
             onKeyDown::< 
               (#  do THIS(window).theEventHandler.onKeyDown;  #);
             onRefresh::< 
               (#  do THIS(window).theEventHandler.onRefresh;  #);
             
          #);
        open::< 
          (#
             create::< 
               (# 
               do
                  (XbCanvasWidgetClass,contentsForm.widgetID)->createSimple;
                    (# 
                    do
                       (XtNwidth,300)->setIntegerResource;
                       (XtNheight,200)->setIntegerResource;
                       
                    #);
                  
               #);
             
          #);
        
     #);
   
#)  

-- windowitemLib: Attributes --
drawBorder:
  (# r: @rectangle; type: @integer; 
  enter (r,type)
  do
       (#
          GetTopShadowGC: external
          (* The widget must be a manager widget or descendant thereof *)
            (#
               w: @integer;
               (* The Manager widget *)
               gc: @integer;
               (* The gc that should be used for the top shadow *)
               
            enter w
            exit gc
            #);
          GetBottomShadowGC: external
          (* The widget must be a manager widget or descendant thereof *)
            (#
               w: @integer;
               (* The Manager widget *)
               gc: @integer;
               (* The gc that should be used for the bottom shadow *)
               
            enter w
            exit gc
            #);
          _XmDrawShadows: external
            (#
               display,drawable,topgc,bottomgc,x,y,width,height,thickness,type:
                 @integer;
               
            enter
            (display,drawable,topgc,bottomgc,x,y,width,height,thickness,type)
            #);
          drawable: @integer;
          xmType: @integer;
          topGC,bottomGC: @integer;
          displayID: @integer;
          x,y,width,height: @integer;
          
       do
          windowID->drawable;
          THIS(guienv).private.display->displayID;
          father.widgetID->GetTopShadowGC->topGC;
          father.widgetID->GetBottomShadowGC->bottomGC;
          r.topLeft->(x,y);
          r.size->(width,height);
          (if type
           // borderStyles.simple then
              XmSHADOW_IN->xmType; 
           // borderStyles.shadowIn then
              XmSHADOW_IN->xmType; 
           // borderStyles.shadowOut then
              XmSHADOW_OUT->xmType; 
           // borderStyles.etchedIn then
              XmSHADOW_ETCHED_IN->xmType; 
           // borderStyles.etchedOut then
              XmSHADOW_ETCHED_OUT->xmType; 
          if);
          (if private.borderVisible then
              (displayID,drawable,topGC,bottomGC,x,y,width,height,2,xmType)
                ->_XmDrawShadows;
          if);
          
       #)
  #);
getFrame:
  (# h,v,width,height: @integer; bottom,right: @integer; f: @rectangle; 
  do
     XtNx->getShortResource->h;
     XtNy->getShortResource->v;
     XtNwidth->getShortResource->width;
     XtNheight->getShortResource->height;
     h+width->right;
     v+height->bottom;
     ((h,v),(right,bottom))->f;
     
  exit f
  #);
handleframeChanged:
  (# newFrame,oldFrame: @rectangle; 
  enter (oldFrame,newFrame)
  <<SLOT GUIENVwindowItemHandleFrameChanged:DoPart>>
  #);
setXBorder:
  (# width: @integer; 
  enter width
  <<SLOT GUIENVwindowItemSetXBorder:DoPart>>
  #);
  

-- GUIENVwindowitemPrivate: Descriptor --
(#
   visible,frameChangedHandled,hilite,borderVisible: @boolean;
   disableDefaultBehaviour: @boolean;
   needsWidget,delegate: @boolean;
   borderStyle: @integer;
   left,top,bottom,right: @integer;
   mouseUpProcessorAddress: @integer;
   theCursor: ^cursor;
   backgroundPixel: @integer;
   hit: ##hitMethod;
   
#)  

-- GUIENVtextStylePrivate: Descriptor --
(# size,face: @integer; name: @text; fontStruct: @integer;  #)  

-- pixmapLib: Attributes --
assertInitialized:
  (# 
  do
     (if private.pixmapID = 0 then
         exception
           (# 
           do 'Accesing a pixmap that are not initialized'->msg.append; 
           #);
         
     if);
     
  #);
asStipple:
  (# stippleID: @integer; gc: @integer; 
  enter gc
  <<SLOT pixmapAsStipple:DoPart>>
  exit stippleID
  #);
  

-- pixmapPrivate: Descriptor --
(#
   pixmapID: @integer;
   myGC: @integer;
   stippleID: @integer;
   maskID: @integer;
   depth: @integer;
   width, height: @integer;
#)


