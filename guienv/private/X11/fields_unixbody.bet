ORIGIN '../fieldsbody';

INCLUDE 'widget';
INCLUDE 'guienvattributes';
INCLUDE 'motifstuff';
INCLUDE 'guienv_unixprivate';
INCLUDE '~beta/sysutils/v1.4.2/objinterface';
INCLUDE 'callbacks';
INCLUDE '../../graphics';

[[
-- textFieldLib: attributes --
getselection: external
  (# w: @integer;
     leftP, rightP: @integer;
     result: @boolean;
  enter (w,leftP,rightP)
  exit result
  #);

handleTextFieldValueChanged: motifCallbackSelector
  (#
  do theEventHandler.onTextChanged;
  #);
textFieldValueChangedProcessor: callbackProcessor
  (# 
  do &handleTextFieldValueChanged[] -> cb[];
  #);

handleTextFieldBeforeChange: textCallbackSelector
  (# allow: @boolean;
     position: @integer;
     length: @integer;
     textBlock: @XmTextBlockRec;
  do startPos -> position;
     textP -> this(guienv).private.textP;
     (if startPos=endPos then
         textP -> textBlock;
         textBlock.length -> length;
      else
         startPos - endPos -> length;
     if);
     (position,length) -> theEventHandler.onBeforeChange -> allow;
     (* datpete feb 14 1996: removed use of 'doit' because of
      * Motif bug in connection with delete button
      *)
     (*allow -> doit;*)
     (if not allow then
         (* set textblock.length to 0 in case there is some text to
          * insert
          *)
         textP -> textBlock;
         0 -> textBlock.length;
         (* set endpos to startpos in case it is a deletion/paste *)
         (%getLongAt (callDataAddress + textStartPosOffset))
         %putLongAt (callDataAddress + textEndPosOffset);
     if)
  #);
textFielVerifyProcessor: callbackProcessor
  (#
  do &handleTextFieldBeforeChange[] -> cb[];
  #);

-- GUIENVtextFieldBeforeChangeTheText: doPart --
do (# textBlock: @XmTextBlockRec;
      textAddress: @integer;
      textLength: @integer;
      memcpy: external
        (# dstAddress, srcAddress, size: @integer;
        enter (dstAddress, srcAddress, size)
        #);
   do this(guienv).private.textP -> textBlock;
      textBlock.length -> textLength;
      (if textLength > 0 then
          textBlock.ptr -> textAddress;
          &text[] -> value[];
          textLength -> value.T.new;
          (@@value.T[1], textAddress, textLength) -> memcpy;
          textLength -> value.lgth -> value.pos;
       else
          none -> value[];
      if);
   #);
-- GUIENVmovieFieldSetContents: descriptor --
(#
do
#)

-- GUIENVmovieFieldGetContents: descriptor --
(#
do
#)

-- GUIENVmovieFieldSetScaleToFit: descriptor --
(#
do
#)

-- GUIENVmovieFieldGetScaleToFit: descriptor --
(#
do
#)

-- GUIENVmovieFieldCreate: descriptor --
(#
do
#)

-- GUIENVmovieFieldOpen: descriptor --
(#
do inner open;
#)

-- GUIENVmovieFieldClose: descriptor --
(#
do inner close;
#)

-- GUIENVmovieFieldPrivate: descriptor --
(#

#)

-- GUIENVtextFieldDoPaste: descriptor --
(#
do widgetID -> XmTextPaste;
#)

-- GUIENVtextFieldDoCopy: descriptor --
(#
do (widgetID,0) -> XmTextCopy;
#)

-- GUIENVtextFieldDoCut: descriptor --
(#
do (widgetID,0) -> XmTextCut;
#)

-- GUIENVtextFieldDoClear: descriptor --
(# XmTextClearSelection: external
     (# widget, time: @integer;
     enter (widget, time)
     #);
do (widgetID,0) -> XmTextCut;
#)

-- GUIENVtextFieldSetContents: descriptor --
assertOpen
(# location::(# do 'TextField.SetContents'->t[] #);
do (XmNvalue,theText[]) -> setStringResource;
#)

-- GUIENVtextFieldGetContents: descriptor --
assertOpen
(# location::(# do 'TextField.GetContents'->t[] #);
   t: ^text;
do XmNvalue -> getStringResourceCopy -> t[];
   &styledText[] -> theText[];
   t -> theText;
#)

-- GUIENVtextFieldGetChar: descriptor --
assertOpen
(# location::(# do 'TextField.GetChar'->t[] #);
   charPtr: @integer;
do XmNvalue -> getPointerResource -> charPtr;
   (if charPtr <> 0 then
       charPtr + pos -> TOS'%adrGetByte' -> ch;
       charPtr -> XtFree;
    else
       '"XmNvalue -> getPointerResource" failed' -> putLine;
   if);
#)

-- GUIENVtextFieldLength: descriptor --
assertOpen
(# location::(# do 'TextField.Length'->t[] #);
   charPtr: @integer;
do XmNvalue -> getPointerResource -> charPtr;
   (if charPtr <> 0 then
       charPtr -> strlen -> value;
       charPtr -> XtFree;
    else
       '"XmNvalue -> getPointerResource" failed' -> putLine;
   if);
#)

-- GUIENVtextFieldScanText: descriptor --
assertOpen
(# location::(# do 'TextField.ScanText'->t[] #);
   amount: @integer;
   charPtr: @integer;
   lastPosition: @Integer;
do (if Start<>End then
       XmNvalue -> getPointerResource -> charPtr;
       (if charPtr <> 0 then
           charPtr -> strlen -> lastPosition;
           (if (end>lastPosition) then lastPosition -> end if);
           (if (start<0) then 0 -> start; if);
           (if (start>end) 
               then 
               -1 -> amount;
               start - 1 -> start;
               end - 1 -> end;
            else 
               1 -> amount 
           if);
           
           loop:
             (if (start<>end) then
                 charPtr + start -> TOS'%adrGetByte' -> ch;
                 inner scanText;
                 start + amount -> start;
                 restart loop
             if);
           charPtr -> XtFree;
        else
           '"XmNvalue -> getPointerResource" failed' -> putLine;
       if);
   if);
#)
-- GUIENVtextFieldPosToPt: descriptor --
assertOpen
(# location::(# do 'TextField.PosToPt'->t[] #);
   x,y: @integerRef;
   status: @boolean;
do (if ((widgetID,pos,x,y) -> XmTextPosToXY)<>0 then
       x.shortValue -> pt.h;
       y.shortValue -> pt.v;
    else
       (-1,-1) -> pt;
   if);
#)

-- GUIENVtextFieldPtToPos: descriptor --
assertOpen
(# location::(# do 'TextField.PtToPos'->t[] #);
do (widgetID,pt.h,pt.v) -> XmTextXYtoPos -> pos;
#)

-- GUIENVtextFieldSelectionStart: descriptor --
assertOpen
(# location::(# do 'TextField.SelectionStart'->t[] #);
   left,right: @integer;
   result: @boolean;
do (widgetID,@@left,@@right) -> getselection -> result;
   (if result then
       left -> value;
    else
      XmNcursorPosition -> getPointerResource -> value;
   if);
#)

-- GUIENVtextFieldSelectionEnd: descriptor --
assertOpen
(# location::(# do 'TextField.SelectionEnd'->t[] #);
   left,right: @integer;
   result: @boolean;
do (widgetID,@@left,@@right) -> getselection -> result;
   (if result then
       right -> value;
    else
       XmNcursorPosition -> getPointerResource -> value;
   if);
#)

-- GUIENVtextFieldSelectionContents: descriptor --
assertOpen
(# location::(# do 'TextField.SelectionContents'->t[] #);
   str: @cstring;
do widgetID -> XmTextGetSelection -> str;
   str.get -> theText[];
   str.free;
   theText.T.range -> theText.pos -> theText.lgth;
#)

-- GUIENVtextFieldSelectionScrollIntoView: descriptor --
assertOpen
(# location::(# do 'TextField.ScrollIntoView'->t[] #);
   start: @integer;
   ID: @integer;
do selection.start -> start;
   widgetID -> ID;
   (ID, start) -> XmTextShowPosition;
#)

-- GUIENVtextFieldSelectionSet: descriptor --
assertOpen
(# location::(# do 'TextField.SelectionSet'->t[] #);
   currentTime: (# exit 0 #); (* Special constant *)
do (if theStart = theEnd then
       (widgetID, currentTime) -> XmTextClearSelection;
       (widgetID, theStart) -> XmTextSetInsertionPosition;
    else
       (widgetID,theStart,theEnd, currentTime) -> XmTextSetSelection;
   if);
#)

-- GUIENVtextFieldSetDefaultStyle: descriptor --
assertOpen
(# location::(# do 'TextField.SetDefaultStyle'->t[] #);
do (* getTextStyleResource -> style[]; *)
#)

-- GUIENVtextFieldGetDefaultStyle: descriptor --
assertOpen
(# location::(# do 'TextField.GetDefaultStyle'->t[] #);
do (* style[] -> setTextStyleResource; *)
#)

-- GUIENVtextFieldIsOneStyle: descriptor --
(#
do
#)

-- GUIENVtextFieldSetOneSize: descriptor --
(#
do
#)

-- GUIENVtextFieldSetOneFont: descriptor --
(#
do
#)

-- GUIENVtextFieldSetOneFace: descriptor --
(#
do
#)

-- GUIENVtextFieldSetOneStyle: descriptor --
(#
do
#)

-- GUIENVtextFieldScanTextWithStyle: descriptor --
(#
do
#)

-- GUIENVtextFieldSetMargin: descriptor --
assertOpen
(# location::(# do 'TextField.SetMargin'->t[] #);
do (XmNmarginWidth,leftMargin) -> setIntegerResource;
   (XmNmarginHeight,topMargin) -> setIntegerResource;
#)

-- GUIENVtextFieldGetMargin: descriptor --
assertOpen
(# location::(# do 'TextField.GetMargin'->t[] #);
do XmNmarginWidth -> getPointerResource -> leftMargin;
   XmNmarginHeight -> getPointerResource -> topMargin;
#)

-- GUIENVtextFieldInsert: descriptor --
assertOpen
(# location::(# do 'TextField.Insert'->t[] #);
   pos: @integer;
   XmTextInsert: external
     (# widget, position: @integer;
        charP: @integer;
     enter (widget, position, charP)
     #);
   cstr: @cString;
   left,right: @integer;
   result: @boolean;
do (widgetID,@@left,@@right) -> getselection -> result;
   (if result then
       left -> pos;
    else
      XmNcursorPosition -> getPointerResource -> pos;
   if);
   theText[] -> cstr.set;
   (widgetID,pos,cstr) -> XmTextInsert;
   cstr.free;
#)

-- GUIENVtextFieldDelete: descriptor --
assertOpen
(# location::(# do 'TextField.Delete'->t[] #);
do widgetID -> XmTextRemove;
#)

-- GUIENVtextFieldCreate: descriptor --
(# 
do inner create;
   (if widgetID=0 then
       (xmTextWidgetClass,father.widgetID) -> createSimple;
       (XmNeditMode,XmMULTI_LINE_EDIT) -> setIntegerResource;
       (XmNhighlightThickness,0) -> setIntegerResource;
       (XmNautoShowCursorPosition,true) ->  setBooleanResource;
       (XmNverifyBell, false) -> setBooleanResource;
   if);
#)

-- GUIENVtextFieldOpen: descriptor --
(#
do (textFieldValueChangedProcessor##, XmNvalueChangedCallback)
     -> addCallbackProcessor;
   (textFielVerifyProcessor##, XmNModifyVerifyCallback) 
     -> addCallbackProcessor;
   inner open;
#)

-- GUIENVtextFieldClose: descriptor --
(#
do inner close;
#)

-- GUIENVtextfieldonframechanged: descriptor --
(#
do inner onFrameChanged;
#)

-- GUIENVtextfieldonrefresh: descriptor --
(#
do inner onRefresh;
#)


-- GUIENVtextfieldonidle: descriptor --
(#
do inner onIdle;
#)

-- GUIENVtextfieldonmouseup: descriptor --
(#
do inner onMouseUp;
#)

-- GUIENVtextfieldondisabletarget: descriptor --
(#
do inner onDisableTarget;
#)

-- GUIENVtextfieldonmousedown: descriptor --
(#
do inner onMouseDown;
#)

-- GUIENVtextfieldonkeydown: descriptor --
(#
do inner onKeyDown;
#)

-- GUIENVtextfieldonenabletarget: descriptor --
(#
do inner onEnableTarget;
#)


-- GUIENVtextFieldPrivate: descriptor --
(#
#)

-- GUIENVabstractScrollerScroll: descriptor --
(#
do inner Scroll;
#)

-- GUIENVabstractScrollerCreate: descriptor --
(#
do inner create;
#)

-- GUIENVabstractScrollerOpen: descriptor --
(#
do this(abstractScroller)[] -> contents.open;
   inner open;
#)

-- GUIENVabstractScrollerClose: descriptor --
(#
do inner close;
#)

-- GUIENVabstractScrollerPrivate: descriptor --
(#
   
#)


-- GUIENVtextEditorScroll: descriptor --
(#
do inner scroll;
#)

-- GUIENVtextEditorCreate: descriptor --

(# args: @argList;
   textFieldWidget: @integer;
do inner create;
   (if widgetID=0 then
       (1,XmNeditMode,XmMULTI_LINE_EDIT) -> args.set;
       (2,XmNverifyBell, 0) -> args.set;
       (father.widgetID, 'scrolledtext', args[], 2)
         -> XmCreateScrolledText -> textFieldWidget;
       textFieldWidget -> XtManageChild;
       textFieldWidget -> XtParent -> widgetID;
       textFieldWidget -> contents.widgetID;
   if)
#)

-- GUIENVtextEditorOpen: descriptor --
(#
do 
  inner open;
#)

-- GUIENVtextEditorClose: descriptor --
(#
do inner close;
#)

-- GUIENVtexteditorprivate: descriptor --
(#
#)

-- GUIENVscrollerScroll: descriptor --
(#
do inner scroll;
#)

-- GUIENVscrollerCreate: descriptor --

(# args: @argList;
   name: ^text;
do inner create;
   (if widgetID=0 then
       this(scroller)[] -> getPatternName -> name[];
       (1,XmNscrollingPolicy,XmAUTOMATIC) -> args.set;
       (2,XmNscrollbarDisplayPolicy,XmSTATIC) -> args.set;
       (* (3,XmNvisualPolicy,XmVARIABLE) -> args.set; *)
       (name,xmScrolledWindowWidgetClass,father.widgetID,args[],2) 
         -> XtCreateManagedWidget -> widgetID;
       (scrollerExposeProcessor##, XExposureMask) -> appendEventProcessor;
      
   if);
#)

-- GUIENVscrollerOpen: descriptor --

(#
do (1000,1000) -> contents.size;
   (XmNworkWindow,contents.widgetID) -> setIntegerResource;
   inner open;
#)

-- GUIENVscrollerClose: descriptor --
(#
do inner close;
#)

-- GUIENVscrollerOnFrameChanged: descriptor --
(#
do inner onFrameChanged;
#)

-- scrollerLib: attributes --

scrollerExposeProcessor: eventProcessor
  (# 
  do &refreshSelector[] -> es[];
  #);
refreshSelector: exposeEventSelector
  (#  ID: @integer;
      args: @argList;
      itsWidth, itsHeight, itsX, itsY: @shortInt;
  do (if count=0 then
         (if private.hiliteContents then
             XmNclipWindow -> getIntegerResource -> ID;
             (1, XtNwidth, @@itsWidth) -> args.set;
             (2, XtNheight, @@itsHeight) -> args.set;
             (3, XtNx, @@itsX) -> args.set;
             (4, XtNy, @@itsY) -> args.set;
             (ID, args[], 4) -> XtGetValues;
             graphics
             (# 
             do 
                
                ((itsX - 4, itsY - 4), (itsX + itsWidth + 3, itsY + itsHeight + 3))
                  -> drawRect;
                ((itsX - 3, itsY - 3), (itsX + itsWidth + 2, itsY + itsHeight + 2))
                  -> drawRect;
             #);
         if);
     if);
  #);

hiliteContents:
  (# value: @boolean
  enter value
  do (if value <> private.hiliteContents then
         value -> private.hiliteContents;
         update;
     if);
  #);

-- GUIENVscrollerPrivate: descriptor --
(# hiliteContents: @boolean;
   
#)

-- GUIENVputmovieFieldLayout: doPart --
do

-- GUIENVgetmovieFieldLayout: doPart --
do

-- GUIENVtextFieldputLayout: doPart --
do

-- GUIENVtextFieldgetLayout: doPart --
do

-- GUIENVabstractScrollerputLayout: doPart --
do

-- GUIENVabstractScrollergetLayout: doPart --
do

-- GUIENVtextEditorputLayout: doPart --
do

-- GUIENVtextEditorgetLayout: doPart --
do

-- GUIENVscrollerputLayout: doPart --
do

-- GUIENVscrollergetLayout: doPart --
do


--]]
