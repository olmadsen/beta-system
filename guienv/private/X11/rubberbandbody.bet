Origin 'rubberband';
INCLUDE '../../graphics';

-- GUIENVDefineRectBody: Descriptor --
(# 
do 
   graphics
   (# 
   do trackMouse
      (# wasOutside: @Boolean;
         dl,dr,dt,db,dtl,dbl,dtr,dbr,nearest: @Integer;
         h1,v1,h2,v2: @integer;
         corner: @Integer;
         chkPt: @point;
         
         MousePress::
           (#
           do Patterns.gray[] -> Pen.stipple; 
              TransferModes.xorBlend[] -> Pen.mode;
              2 -> pen.size;
              theRect -> drawRect;
           #);
         
         MouseMove::
           (#
           do 
              (if curPt -> prevPt.isEqual then 
                  leave MouseMove 
              if);
              
              (if not (curPt -> theRect.containsPoint) then
                  true -> wasOutside;
              if);
              
              (if wasOutside then
                  theRect -> drawRect;
                  
                  (if corner 
                   // 0 then
                      (curPt.h - theRect.left) -> abs -> dl;
                      (curPt.h - theRect.right) -> abs -> dr;
                      (curPt.v - theRect.top) -> abs -> dt;
                      (curPt.v - theRect.bottom) -> abs -> db;
                  
                      dl*dl+dt*dt -> dtl;
                      dl*dl+db*db -> dbl;
                      dr*dr+dt*dt -> dtr;
                      dr*dr+db*db -> dbr;
                  
                      dtl -> nearest;
                      (if dbl < nearest then dbl -> nearest if);
                      (if dtr < nearest then dtr -> nearest if);
                      (if dbr < nearest then dbr -> nearest if);
                      
                      (if nearest
                       //dtl then
                          (if dl < dt then curPt.h -> theRect.left;
                           else curPt.v -> theRect.top;
                          if);
                          curPt -> chkPt;
                          (if not (curPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dl < dt then curPt.v -> theRect.top;
                               else curPt.h -> theRect.left;
                              if);
                              1 -> corner;
                          if);
                       //dbl then
                          (if dl < db then curPt.h -> theRect.left;
                           else curPt.v -> theRect.bottom;
                          if);
                          (curPt.h,curPt.v-1) -> chkPt;
                          (if not (chkPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dl < db then curPt.v -> theRect.bottom;
                               else curPt.h -> theRect.left;
                              if);
                              2 -> corner;
                          if);
                       //dtr then
                          (if dr < dt then curPt.h -> theRect.right;
                           else curPt.v -> theRect.top;
                          if);
                          (curPt.h-1,curPt.v) -> chkPt;
                          (if not (chkPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dr < dt then curPt.v -> theRect.top;
                               else curPt.h -> theRect.right;
                              if);
                              3 -> corner;
                          if);
                       //dbr then
                          (if dr < db then curPt.h -> theRect.right;
                           else curPt.v -> theRect.bottom;
                          if);
                          (curPt.h-1,curPt.v-1) -> chkPt;
                          (if not (chkPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dr < db then curPt.v -> theRect.bottom;
                               else curPt.h -> theRect.right;
                              if);
                              4 -> corner;
                          if);
                      if);
                      
                   // 1 then curPt.h->theRect.left; curPt.v->theRect.top;
                   // 2 then curPt.h->theRect.left; curPt.v->theRect.bottom;
                   // 3 then curPt.h->theRect.right; curPt.v->theRect.top;
                   // 4 then curPt.h->theRect.right; curPt.v->theRect.bottom;
                  if);
                  (theRect.top, theRect.bottom) -> min -> h1;
                  (theRect.Left, theRect.Right) -> min -> v1;
                  (theRect.top, theRect.bottom) -> max -> h2;
                  (theRect.Left, theRect.Right) -> max -> v2;
                  (v1,h1,v2,h2) -> theRect.set;     
                  theRect -> drawRect;
              if);
           #);
         MouseRelease::
           (# 
           do theRect -> drawRect;
           #);
      #);
   #);
#)
