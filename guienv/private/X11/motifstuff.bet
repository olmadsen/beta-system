ORIGIN '~beta/Xt/v1.8/motif/motiflib';
(* OBJFILE default '$/canvas.o'; *)
BODY 'motifstuffbody';
[[
-- lib: attributes --

XtToolkitInitialize: external
  (#
  #);
XtCreateApplicationContext: external
  (# appcon: @integer;
  exit appcon
  #);

XtInsertEventHandler  : external
  (# w : @integer;
     eventMask :@integer;
     nonmaskable :@integer;
     callBack :@ integer;
     data : @integer;
     where: @integer;
  enter (w,eventMask,nonmaskable,callBack,data,where)
  do callC
  #);

(* Rectangles *)

XRectangle: cstruct
  (# 
     bytesize::< (# do 8 -> value; #);
     x: @signedShort (# pos::< (# do 0 -> value #)#);
     y: @signedShort (# pos::< (# do 2 -> value #)#);
     width: @short (# pos::< (# do 4 -> value #)#);
     height: @short (# pos::< (# do 6 -> value #)#);
  #);
XClipBox: external
  (# r: @integer;
     rect: ^XRectangle;
  enter (r,rect[])
  #);

(* Regions *)

XCreateRegion: external
  (# r: @integer;
  exit r
  #);
XDestroyRegion: external
  (# r: @integer;
  enter r
  #);
XUnionRegion: external
  (# src1,src2,dst: @integer;
  enter (src1,src2,dst)
  #);
XIntersectRegion: external
  (# src1,src2,dst: @integer;
  enter (src1,src2,dst)

  #);
XXorRegion: external
  (# src1,src2,dst: @integer;
  enter (src1,src2,dst)

  #);
XSubtractRegion: external
  (# src1,src2,dst: @integer;
  enter (src1,src2,dst)
  #);
XEmptyRegion: external
  (# r: @integer;
     b: @boolean;
  enter r
  exit b
  #);
XPointInRegion: external
  (# r: @integer;
     x,y: @integer;
     b: @boolean;
  enter (r,x,y)
  exit b
  #);
XRectInRegion: external
  (# r: @integer;
     x,y,width,height: @integer;
     b: @boolean;
  enter (r,x,y,width,height)
  exit b
  #);
XEqualRegion: external
  (# r1,r2: @integer;
     b: @boolean;
  enter (r1,r2)
  exit b
  #);
XShrinkRegion: external
  (# r: @integer;
     dx,dy: @integer;
  enter (r,dx,dy)
  #);
XOffsetRegion: external
  (# r: @integer;
     dx,dy: @integer;
  enter (r,dx,dy)
  #);
XUnionRectWithRegion: external
  (# rect: ^XRectangle;
     src,dst: @integer;
  enter (rect[],src,dst)
  #);

XtListHead: (# exit 0 #);
XtListTail: (# exit 1 #);

XtGetGC: external
  (# w,values_mask,values: @integer;
     gc: @integer;
  enter (w,values_mask,values)
  exit gc
  #);

XmTextPosToXY: external
  (# widget,position: @integer;
     xP,yP: @integer;
     status: @boolean;
  enter (widget,position,xP,yP)
  exit status
  #);
XmTextXYToPos: external
  (# widget,position: @integer;
     x,y: @integer;
  enter (widget,x,y)
  exit position
  #);

xbCanvasWidgetClass: external
  (# class: @integer;
  do 'getXbCanvasWidgetClass' -> callC;
  exit class
  #);
xbButtonWidgetClass: external
  (# class: @integer;
  do 'getXbButtonWidgetClass' -> callC;
  exit class
  #);
xbIconButtonWidgetClass: external
  (# class: @integer;
  do 'getXbIconButtonWidgetClass' -> callC;
  exit class
  #);
xbToggleButtonWidgetClass: external
  (# class: @integer;
  do 'getXbToggleButtonWidgetClass' -> callC;
  exit class
  #);

XtSetMappedWhenManaged: external
  (# 
     w: @integer;
     map_when_managed: @boolean;
  enter (w,map_when_managed)
  #);
XtResizeWidget: external
  (# w,width,height,borderwidth: @integer;
  enter (w,width,height,borderwidth)
  #);
XtAppProcessEvent: external
  (# appcontext,inputmask: @integer
  enter (appcontext,inputmask)
  #);
XtAddGrab: external
  (# w: @integer;
     exclusive: @boolean;
     springloaded: @boolean;
  enter (w,exclusive,springloaded)
  #);
XtIsSensitive: external
  (# w: @integer;
     b: @boolean;
  enter w
  exit b
  #);
XtIsRealized: external
  (# w: @integer;
     b: @boolean;
  enter w
  exit b
  #);
XtSetSensitive: external
  (# w: @integer;
     b: @boolean;
  enter (w,b)
  #);
XtConfigureWidget: external
  (# w,x,y,width,height,border: @integer;
  enter (w,x,y,width,height,border)
  #);
XtRemoveGrab: external
  (# w: @integer;
  enter w
  #);
XtIMXEvent: (# exit 1 #);
XtIMTimer: (# exit 2 #);
XtIMAlternateInput: (# exit 4 #);
XtIMAll: (# exit XtIMXEvent + XtIMTimer + XtIMAlternateInput #);


MWM_INPUT_MODELESS: (# exit 0 #);
MWM_INPUT_PRIMARY_APPLICATION_MODAL: (# exit 1 #);
MWM_INPUT_SYSTEM_MODAL: (# exit 2 #);
MWM_INPUT_FULL_APPLICATION_MODAL: (# exit 3 #);

Button1Mask: (# exit 256 #);
Button2Mask: (# exit 512 #);
Button3Mask: (# exit 1024 #);

MotifString: IntegerObject
  (* A MotifString is a compound string made of segments with three elements: 
   * a character set, a direction, and a text.
   *)
  (# init:< Object;
     setText: 
       (* Initialize THIS(MotifString) from the text t, using the
        * default character set and direction.
        *)
       (# t: ^Text;
       enter t[] 
       do <<SLOT MotifStringSetText: descriptor>> 
       #);
     setTextSegment: 
       (* Initialize THIS(MotifString) from the text t, using the
        * given character set, and direction.
        *)
       (# t: ^Text;
          charset: ^text;
          direction: @integer;
       enter (t[], charset[], direction) 
       do <<SLOT MotifStringSetSegment: descriptor>> 
       #);
     getText: 
       (* Get the string segments of THIS(MotifString) composed from the
        * default character set, and default direction.
        *)
       (# t: ^text;
       do <<SLOT MotifStringGetText: descriptor>>
       exit t[]
       #);
     set: (* Set THIS(MotifString) directly *)
       (# enter value #);
     get: (* Get the external pointer for THIS(MotifString) *)
       (# exit value #);
     destroy:
       (* Free the  memory externally allocated for THIS(MotifString) *)
       (# do <<SLOT MotifStringDestroy: descriptor>> #);
     append:
       (* Append the MotifString S to THIS(MotifString) *)
       (# S: @MotifString
       enter S
       do <<SLOT MotifStringAppend: descriptor>>
       #);
     prepend:
       (* Prepend the MotifString S to THIS(MotifString) *)
       (# S: @MotifString
       enter S
       do <<SLOT MotifStringPrepend: descriptor>>
       #);
     appendText:
       (* Append to THIS(MotifString) a MotifString, constructed from the text t,
        * using the default character set, and direction
        *)
       (# t: ^text
       enter t[]
       do <<SLOT MotifStringAppendText: descriptor>>
       #);
     appendSegment: 
       (* Append to THIS(MotifString) a MotifString, constructed from the text t, 
        * using the given character set, and direction.
        *)
       (# t: ^Text;
          charset: ^text;
          direction: @integer;
       enter (t[], charset[], direction) 
       do <<SLOT MotifStringAppendSegment: descriptor>> 
       #);
     prependText:
       (* Prepend to THIS(MotifString) a MotifString, constructed from the text t,
        * using the default character set, and direction
        *)
       (# t: ^text
       enter t[]
       do <<SLOT MotifStringPrependText: descriptor>>
       #);
     prependSegment: 
       (* Prepend to THIS(MotifString) a MotifString, constructed from the text t, 
        * using the given character set, and direction.
        *)
       (# t: ^Text;
          charset: ^text;
          direction: @integer;
       enter (t[], charset[], direction) 
       do <<SLOT MotifStringPrependSegment: descriptor>> 
       #);
     copyAppend: 
       (* Exit the external pointer for a MotifString which is a concatenation
        * of THIS(MotifString) and S.
        *)
       (# S, copy: @MotifString;
       enter S 
       do <<SLOT MotifStringCopyAppend: descriptor>>
       exit copy
       #);
     copyPrepend: 
       (* Exit the external pointer for a MotifString which is a concatenation
        * of S and THIS(MotifString).
        *)
       (# S, copy: @MotifString;
       enter S 
       do <<SLOT MotifStringCopyPrepend: descriptor>>
       exit copy
       #);
     copy:
       (* Exit a copy of THIS(MotifString) *)
       (# S: @MotifString;
       do <<SLOT MotifStringCopy: descriptor>>
       exit S
       #);
     hasSubString: BooleanValue
       (* Exit true iff S is a substring of THIS(MotifString) *)
       (# S: @MotifString
       enter S
       do <<SLOT MotifStringHasSubString: descriptor>>
       #);
     equal: BooleanValue
       (* Exit true iff THIS(MotifString) and S have the same components *)
       (# S: @MotifString
       enter S
       do <<SLOT MotifStringEqual: descriptor>>
       #);
     eq: BooleanValue
       (* Exit true iff THIS(MotifString) and S are equal on a byte-by-byte
        * basis.
        *)
       (# S: @MotifString
       enter S
       do <<SLOT MotifStringEq: descriptor>>
       #);
     empty: BooleanValue
       (* Exit true iff there are no non-zero length text components in 
        * THIS(MotifString).
        *)
       (# do <<SLOT MotifStringEmpty: descriptor>> #);
     extent:
       (* Exit the width and height, in pixels, of the smallest rectangle, 
        * that will enclose THIS(MotifString) in a window with the given fontlist.
        *)
       (# width, height: @integer;
          fontlist: @integer;
       enter fontlist
       do <<SLOT MotifStringExtent: descriptor>>
       exit (width, height)
       #);
     baseline: IntegerValue
       (* Exit the number of pixels between the top of the character box and
        * the baseline of the first line of text in THIS(MotifString).
        *)
       (# do <<SLOT MotifStringBaseline: descriptor>> #);
     lineHeight: IntegerValue
       (* Exit the line height of THIS(MotifString) *)
       (# do <<SLOT MotifStringHeight: descriptor>> #);
     size: IntegerValue
       (* Exit the number of bytes in the external representation of 
        * THIS(MotifString), including the text, tags, direction indicators, 
        * and separators.
        *)
       (# do <<SLOT MotifStringSize: descriptor>> #);
     noOfLines: IntegerValue
       (* Exit the number of lines in THIS(MotifString). This is computed
        * as the number of separators plus one.
        *)
       (# do <<SLOT MotifStringLines: descriptor>> #);
     
  #);
MotifFontList: IntegerObject
  (* MotifFontLists are used to specify character sets for widgets displaying
   * MotifStrings. Example:
   *   fontlst: @MotifFontList
   *     (# init::<
   *          (# 
   *          do ('-*-courier-*-r-*--12-*', 'charset1')      -> addText;
   *             ('-*-courier-bold-o-*--14-*', 'charset2')   -> addText;
   *             ('-*-courier-medium-r-*--18-*', 'charset3') -> addText;
   *      #)#);
   *)
  (# add:
       (* Add one entry to THIS(MotifFontList). Here the font enter parameter
        * must be a pointer to an XFontStruct
        *)
       (# font: @integer; charset: ^text;
       enter (font, charset[])
       do <<SLOT MotifFontListAdd: descriptor>>
       #);
     scan:
       (* Scan the fonts in the the font list *)
       (# fontStruct: @integer;
          charSet: ^Text;
       do <<SLOT MotifFontListScan: descriptor>>;
       #);
     <<SLOT MotifFontListLib: attributes>>;
  #);
StringArray: 
  (* A StringArray is a list of externally allocated text's. *)
  (# initialSize:< integerObject(# do 25 -> value; INNER #);
     init:< 
       (* Initializes THIS(StringArray) *)
       (# do <<SLOT StringArrayInit: descriptor>>; INNER #);
     clear:< (* Reset THIS(StringArray) *)
       (# do <<SLOT StringArrayClear: descriptor>>; INNER #);
     number:
       (* Number of texts currently in THIS(StringArray) *)
       IntegerValue(# <<SLOT StringArrayNumber: dopart>> #);
     getText: 
       (* Exits a copy of the text of THIS(stringArray) added as number n *)
       (# n: @integer;
          t: ^text;
       enter n
       do <<SLOT StringArrayGetText: descriptor>>;
       exit t[]
       #);
     changeText: 
       (* Changes the text of THIS(stringArray) added as number n *)
       (# n: @integer;
          newtext: ^text;
       enter (n, newtext[]) 
       do <<SLOT StringArrayChangeText: descriptor>>;
       #);
     addText: 
       (* Adds a new text to THIS(stringArray). THIS(StringArray) is extended
        * if needed.
        *)
       (# t: ^text;
       enter t[] 
       do <<SLOT StringArrayAddText: descriptor>>;
       #);
     <<SLOT StringArrayLib: attributes>>;
     private: @<<SLOT StringArrayPrivate: descriptor>>;
     address:
       (* Address of externally allocated string array  *)
       IntegerValue(# <<SLOT StringArrayAddress: dopart>> #);
  exit address
  #);

XC_num_glyphs: (# exit  154 #);
XC_X_cursor: (# exit  0 #);
XC_arrow: (# exit  2 #);
XC_based_arrow_down: (# exit  4 #);
XC_based_arrow_up: (# exit  6 #);
XC_boat: (# exit  8 #);
XC_bogosity: (# exit  10 #);
XC_bottom_left_corner: (# exit  12 #);
XC_bottom_right_corner: (# exit  14 #);
XC_bottom_side: (# exit  16 #);
XC_bottom_tee: (# exit  18 #);
XC_box_spiral: (# exit  20 #);
XC_center_ptr: (# exit  22 #);
XC_circle: (# exit  24 #);
XC_clock: (# exit  26 #);
XC_coffee_mug: (# exit  28 #);
XC_cross: (# exit  30 #);
XC_cross_reverse: (# exit  32 #);
XC_crosshair: (# exit  34 #);
XC_diamond_cross: (# exit  36 #);
XC_dot: (# exit  38 #);
XC_dotbox: (# exit  40 #);
XC_double_arrow: (# exit  42 #);
XC_draft_large: (# exit  44 #);
XC_draft_small: (# exit  46 #);
XC_draped_box: (# exit  48 #);
XC_exchange: (# exit  50 #);
XC_fleur: (# exit  52 #);
XC_gobbler: (# exit  54 #);
XC_gumby: (# exit  56 #);
XC_hand1: (# exit  58 #);
XC_hand2: (# exit  60 #);
XC_heart: (# exit  62 #);
XC_icon: (# exit  64 #);
XC_iron_cross: (# exit  66 #);
XC_left_ptr: (# exit  68 #);
XC_left_side: (# exit  70 #);
XC_left_tee: (# exit  72 #);
XC_leftbutton: (# exit  74 #);
XC_ll_angle: (# exit  76 #);
XC_lr_angle: (# exit  78 #);
XC_man: (# exit  80 #);
XC_middlebutton: (# exit  82 #);
XC_mouse: (# exit  84 #);
XC_pencil: (# exit  86 #);
XC_pirate: (# exit  88 #);
XC_plus: (# exit  90 #);
XC_question_arrow: (# exit  92 #);
XC_right_ptr: (# exit  94 #);
XC_right_side: (# exit  96 #);
XC_right_tee: (# exit  98 #);
XC_rightbutton: (# exit  100 #);
XC_rtl_logo: (# exit  102 #);
XC_sailboat: (# exit  104 #);
XC_sb_down_arrow: (# exit  106 #);
XC_sb_h_double_arrow: (# exit  108 #);
XC_sb_left_arrow: (# exit  110 #);
XC_sb_right_arrow: (# exit  112 #);
XC_sb_up_arrow: (# exit  114 #);
XC_sb_v_double_arrow: (# exit  116 #);
XC_shuttle: (# exit  118 #);
XC_sizing: (# exit  120 #);
XC_spider: (# exit  122 #);
XC_spraycan: (# exit  124 #);
XC_star: (# exit  126 #);
XC_target: (# exit  128 #);
XC_tcross: (# exit  130 #);
XC_top_left_arrow: (# exit  132 #);
XC_top_left_corner: (# exit  134 #);
XC_top_right_corner: (# exit  136 #);
XC_top_side: (# exit  138 #);
XC_top_tee: (# exit  140 #);
XC_trek: (# exit  142 #);
XC_ul_angle: (# exit  144 #);
XC_umbrella: (# exit  146 #);
XC_ur_angle: (# exit  148 #);
XC_watch: (# exit  150 #);
XC_xterm: (# exit  152 #);

--]]
