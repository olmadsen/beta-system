ORIGIN '../figureitemsbody'
[[
-- Include '../../graphics'
-- Include 'guienv_unixprivate'
-- Include '~beta/basiclib/v1.4/math'
-- figureItemLib: attributes --

drawWithPen: father.graphics
  (# 
  do (if this(figureItem).pen.stipple<>none//true then
         this(figureItem).pen.size -> pen.size;
         this(figureItem).pen.backgroundColor -> pen.backgroundColor;
         this(figureItem).pen.foregroundColor -> pen.foregroundColor;
         this(figureItem).pen.stipple -> pen.stipple;
     if);
     inner;
  #);
-- GUIENVpenSetForegroundColor: descriptor --
(#
do theColor -> private.foreground;
   update;
#)

-- GUIENVpenGetForegroundColor: descriptor --
(#
do private.foreground -> theColor;
#)

-- GUIENVpenSetBackgroundColor: descriptor --
(#
do theColor -> private.background;
   update;
#)

-- GUIENVpenGetBackgroundColor: descriptor --
(#
do private.background -> theColor;
#)

-- GUIENVpenSetStipple: descriptor --
(#
do p[] -> private.stipple[];
   update;
#)

-- GUIENVpenGetStipple: descriptor --
(#
do private.stipple[] -> p[];
#)

-- GUIENVpenSetSize: descriptor --
(#
do value -> private.penSize;
   update;
#)

-- GUIENVpenGetSize: descriptor --
(#
do private.penSize -> value;
#)


-- GUIENVfigureitemcreate: descriptor --
(#
do inner create;
#)

-- GUIENVfigureItemOpen: descriptor --
(# thisWI: ^windowitem;
do patterns.black[] -> pen.stipple;
   this(figureItem)[] -> thisWI[];
   0 -> thisWI.private.left;
   0 -> thisWI.private.right;
   0 -> thisWI.private.bottom;
   0 -> thisWI.private.top;
   1 -> private.penSize;
   (65535, 65535, 65535) -> private.backGround;
   (0, 0, 0) -> private.foreground;
   inner open;
#)

-- GUIENVfigureItemOnRefresh: descriptor --
(#
do inner onRefresh;
#)

-- GUIENVfigureItemPrivate: descriptor --
(# stipple: ^raster;
   penSize: @integer;
   foreGround,backGround: @color;
#)

-- lineLib: attributes --
drawControlPoints: father.graphics
  (# square: 
       (# p: @point;
          r: @rectangle;
       enter p
       do (p,p) -> r;
          (-3,-3) -> r.inset;
       exit r
       #);
  do start ->  square -> fillRect;
     end -> square -> fillRect;
  #);
adjustFrame:
  (# p1,p2: @point;
     f: @rectangle;
     penSize: @integer;
     d: @integer;
  do start -> p1;
     end -> p2;
     (p1.h,p2.h) -> min -> f.left;
     (p1.h,p2.h) -> max -> f.right;
     (p1.v,p2.v) -> min -> f.top;
     (p1.v,p2.v) -> max -> f.bottom;
     pen.size -> penSize;
     (penSize,3) -> max -> d;
     (-d,-d) -> f.inset;
     true -> private.stopRecursion;
     (frame,f) -> handleFrameChanged;
     false -> private.stopRecursion;
  #);
calcNormal:
  (# a,b,c: @integer;
     p1,p2: @point;
  do start -> p1;
     end -> p2;
     (-(p1.v - p2.v),p1.h - p2.h) -> (a,b);
     -(a * p1.h + b * p1.v) -> c;
  exit (a,b,c)
  #);
calcK:
  (# a,b,c: @integer;
     d: @integer;
     penSize: @integer;
  do calcNormal -> (a,b,c);
     pen.size -> penSize;
     (3,(penSize + 1) div 2) -> max -> d;
     ((a * a + b * b) -> sqrt) * d -> ceil -> private.k;
  #);

-- GUIENVlineonFrameChanged: descriptor --
(# dh,dv: @integer;
do (if private.stopRecursion//false then
       newFrame.left - oldFrame.left -> dh;
       newFrame.top - oldFrame.top -> dv;
       (dh,dv) -> private.start.add;
       (dh,dv) -> private.end.add;
   if);
   calcK;
   inner onFrameChanged;
#)

-- GUIENVlineonHiliteChanged: descriptor --
(# 
do (if hilite//true then
       drawControlPoints;
    else
       update;
   if);
   inner onHiliteChanged;
#)

-- GUIENVlineSetStart: descriptor --
(#
do theStart -> private.start;
   adjustFrame;
#)

-- GUIENVlineGetStart: descriptor --
(#
do private.start -> theStart;
#)

-- GUIENVlineSetEnd: descriptor --
(#
do theEnd -> private.end;
   adjustFrame;
#)

-- GUIENVlineGetEnd: descriptor --
(#
do private.end -> theEnd;
#)

-- GUIENVLineOpen: descriptor --
(# lineHit: hitMethod
     (# a,b,c: @integer;
        n: @integer;
        f: @rectangle;
     do frame -> f;
        (if p -> f.containsPoint//true then
            calcNormal -> (a,b,c);
            a * p.h + b * p.v + c -> n;
            n -> abs -> n;
            n <= private.k -> value;
         else
            false -> value;
        if);
     #);
do lineHit## -> setHit;
   inner open;
#)

-- GUIENVlineOnRefresh: descriptor --
(#
do drawWithPen
   (# 
   do (start,end) -> drawLine;
   #);
   (if hilite//true then
       drawControlPoints;
   if);
   inner onRefresh;
#)

-- GUIENVlinePrivate: descriptor --
(# start,end: @point;
   stopRecursion: @boolean;
   k: @integer;
#)

-- GUIENVFillSetTile: descriptor --
(#
do p[] -> private.tile[];
   update;
#)

-- GUIENVfillGetTile: descriptor --
(#
do private.tile[] -> p[];
#)

-- GUIENVFillSetForegroundColor: descriptor --
(#
do theColor -> private.fillForeGround;
   update;
#)

-- GUIENVfillGetForegroundColor: descriptor --
(#
do private.fillForeGround -> theColor;
#)

-- GUIENVFillSetBackgroundColor: descriptor --
(#
do theColor -> private.fillBackground;
   update;
#)

-- GUIENVfillGetBackgroundColor: descriptor --
(#
do private.fillBackground -> theColor;
#)

-- shapeLib: attributes --
drawWithFill: father.graphics
  (# 
  do (if fill.tile<>none//true then
         fill.foreGroundColor -> pen.foreGroundColor;
         fill.backgroundColor -> pen.backgroundColor;
         fill.tile -> pen.stipple; 
         inner;
     if);
  #);
extend:
  (# f: @rectangle;
     d: @integer;
     penSize: @integer;
  do frame -> f;
     pen.size -> penSize;
     ((penSize + 1) div 2,3) -> max -> d;
     (d,d) -> f.inset;
  exit f
  #);
drawControlPoints: father.graphics
  (# fillSquare:
       (# p: @point;
          r: @rectangle;
       enter p
       do (p,p) -> r;
          (-3,-3) -> r.inset;
          r -> fillRect;
       #);
     f: @rectangle;
     w,h: @integer;
  do 
     patterns.black[] -> pen.stipple;
     frame -> f;
     f.size -> (w,h);
     (if (w > 8) and (h > 8)//true then
         (f.left + 3,f.top + 3) -> fillSquare;
         (f.right - 3,f.top + 3) -> fillSquare;
         (f.right - 3,f.bottom - 3) -> fillSquare;
         (f.left + 3,f.bottom - 3) -> fillSquare;
     if);
  #);

-- GUIENVshapeOpen: descriptor --
(#
do (65535, 65535, 65535) -> private.fillBackground;
   (0, 0, 0) -> private.fillForeground;
   inner open;
#)

-- GUIENVshapeOnRefresh: descriptor --
(#
do inner onRefresh;
   (if hilite//true then
       drawControlPoints
   if);
#)

-- GUIENVshapeonHiliteChanged: descriptor --
(# 
do (if hilite//true then
       drawControlPoints;
    else
       update;
   if);
   inner onHiliteChanged;
#)

-- GUIENVshapePrivate: descriptor --
(# tile: ^raster;
   fillForeGround: @color;
   fillBackground: @color;
#)

-- GUIENVovalOpen: descriptor --
(#
do inner open;
#)

-- GUIENVovalOnRefresh: descriptor --
(#
do drawWithFill
   (# 
   do extend -> fillOval;
   #);
   drawWithPen
   (# 
   do extend -> drawOval;
   #);
   inner onRefresh;
#)

-- GUIENVrectOpen: descriptor --
(#
do inner open;
#)

-- GUIENVrectOnRefresh: descriptor --
(#
do drawWithFill
   (# 
   do extend  -> fillRect;
   #);
   drawWithPen
   (# 
   do extend -> drawRect;
   #);
   inner onRefresh;
#)

-- GUIENVRoundRectOpen: descriptor --
(#
do inner open;
#)

-- GUIENVroundRectSetRoundness: descriptor --
(#
do (theOvalHeight,theOvalWidth) -> private.roundness;
   update;
#)

-- GUIENVroundRectGetRoundness: descriptor --
(#
do  private.roundness -> (theOvalHeight,theOvalWidth);
#)

-- GUIENVroundRectOnRefresh: descriptor --
(#
do drawWithFill
   (# 
   do (extend,((0,0),roundness)) -> fillRoundRect;
   #);
   drawWithPen
   (# 
   do (extend,((0,0),roundness)) -> drawRoundRect;
   #);
   inner onRefresh;
#)

-- GUIENVroundRectPrivate: descriptor --
(#
   roundness: @point;
#)

-- GUIENVWedgeOpen: descriptor --
(#
do inner open;
#)

-- GUIENVwedgeSetStartAngle: descriptor --
(#
do angle -> private.startAngle;
   update;
#)

-- GUIENVwedgeGetStartAngle: descriptor --
(#
do private.startAngle -> angle;
#)

-- GUIENVwedgeSetEndAngle: descriptor --
(#
do angle -> private.endAngle;
   update;
#)

-- GUIENVwedgeGetEndAngle: descriptor --
(#
do private.endAngle -> angle;
#)

-- GUIENVwedgeOnRefresh: descriptor --
(#
do drawWithPen
   (# 
   do (extend,startAngle,endAngle) -> drawSlice;
   #);
   drawWithFill
   (# 
   do (extend,startAngle,endAngle) -> fillSlice;
   #);
   inner onRefresh;
#)

-- GUIENVwedgePrivate: descriptor --
(# startAngle,endAngle: @integer;
#)

-- polygonLib: attributes --

getXPoints:
  (# xpoints: [0] @integer;
  do private.thePoints.range ->  xpoints.new;
     (for i: private.thePoints.range repeat
          (@@xpoints[i],private.thePoints[i].h)-> TOS'%putshort[0]';
          (@@xpoints[i],private.thePoints[i].v)-> TOS'%putshort[1]';
     for);
  exit xpoints
  #);
getXRegion:
  (# xpoints: [0] @integer;
     xregion: @integer;
  do getXPoints -> xpoints;
     (@@xpoints[1],xpoints.range,0) -> XPolygonRegion -> xregion
  exit xregion
  #);
adjustFrame:
  (# xregion: @integer;
     xrect: @XRectangle;
     f: @rectangle;
     penSize,d: @integer;
     XClipBox: external
       (# r: @integer;
          rect: ^XRectangle;
       enter (r,rect[])
       #);
  do getXRegion ->  xregion;
     (xregion,xrect[]) -> XClipBox;
     xregion -> XDestroyRegion;
     xrect.x -> f.left;
     xrect.y -> f.top;
     xrect.x + xrect.width -> f.right;
     xrect.y + xrect.height -> f.bottom;
     pen.size -> penSize;
     (penSize, 3) -> min -> d;
     (-d,-d) -> f.inset;
     true -> private.stopRecursion;
     (frame,f) -> handleFrameChanged;
     false -> private.stopRecursion;
  #);

-- GUIENVpolygonSetPoints: descriptor --
(# 
do thePoints.range -> private.thePoints.new;
   (for i: thePoints.range repeat
        &point[] -> private.thePoints[i][];
        thePoints[i] -> private.thePoints[i];
   for);
   adjustFrame;
#)

-- GUIENVpolygonGetPoints: descriptor --
(#
do private.thePoints.range -> thePoints.new;
   (for i: thePoints.range repeat
        &point[] -> thePoints[i][];
        private.thePoints[i] -> thePoints[i];
   for);
#)

-- GUIENVpolygonOpen: descriptor --
(# 
   polyhit: hitMethod
     (# xregion: @integer;
     do getXRegion -> xregion;
        (xregion,p.h,p.v) -> XPointInRegion -> value;
        xregion -> XDestroyRegion;
     #);
do polyHit## -> setHit;
   inner open;
#)

-- GUIENVpolygonOnRefresh: descriptor --
(# pts: [0] ^point;
do points -> pts;
   1 -> pts.extend;
   pts[1][] -> pts[pts.range][];
   drawWithPen
   (# 
   do pts -> drawPolygon;
   #);
   drawWithFill
   (# 
   do pts -> fillPolygon;
   #);
   inner onRefresh;
#)

-- GUIENVpolygonPrivate: descriptor --
(# thePoints: [3] ^point;
   stopRecursion: @boolean
#)

-- GUIENVpolygononFrameChanged: descriptor --
(# dh,dv: @integer;
do (if private.stopRecursion//false then
       newFrame.left - oldFrame.left -> dh;
       newFrame.top - oldFrame.top -> dv;
       (for i: private.thePoints.range repeat
            (dh,dv) -> private.thePoints[i].add;
       for);
   if);
   inner onFrameChanged;
#)
-- GUIENVfigureItemputLayout: doPart --
do

-- GUIENVfigureItemgetLayout: doPart --
do

-- GUIENVlineputLayout: doPart --
do

-- GUIENVlinegetLayout: doPart --
do

-- GUIENVshapeputLayout: doPart --
do

-- GUIENVshapegetLayout: doPart --
do

-- GUIENVovalputLayout: doPart --
do

-- GUIENVovalgetLayout: doPart --
do

-- GUIENVrectputLayout: doPart --
do

-- GUIENVrectgetLayout: doPart --
do

-- GUIENVroundRectputLayout: doPart --
do

-- GUIENVroundRectgetLayout: doPart --
do

-- GUIENVwedgeputLayout: doPart --
do

-- GUIENVwedgegetLayout: doPart --
do

-- GUIENVpolygonputLayout: doPart --
do

-- GUIENVpolygongetLayout: doPart --
do


--]]

