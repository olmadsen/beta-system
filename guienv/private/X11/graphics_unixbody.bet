ORIGIN '../graphicsbody';
INCLUDE 'motifstuff'
        'widget'
        'guienvattributes'
        'guienv_unixprivate'
        '~beta/sysutils/objinterface';
LIB_ITEM 'guienv';
-- guienvLib: Attributes --
maxValue: (#  exit 65535 #);
whiteColor: (#  exit (maxValue,maxValue,maxValue) #);
blackColor: (#  exit (0,0,0) #);
YAllocColor: external
  (# display: @integer; cmap: @integer; c: ^XColor; result: @integer; 
  enter (display,cmap,c[])
  exit result
  #);
isBlack: booleanValue
  (# theColor: ^color; 
  enter theColor[]
  do
     (theColor.red = 0) and (theColor.green = 0) and (theColor.blue = 0)->value;
     
  #);
isWhite: booleanValue
  (# theColor: ^color; 
  enter theColor[]
  do
     (theColor.red = maxValue) and (theColor.green = maxValue) and
     (theColor.blue = maxValue)->value;
     
  #);
allocateColor:
  (# theColor: ^color; thePixel: @integer; 
  enter theColor[]
  do
     (if true
      // theColor[]->isWhite then
         whitePixelValue->thePixel; 
      // theColor[]->isBlack then
         blackPixelValue->thePixel; 
      else
           (# theXColor: @XColor; cmap,screen: @integer; result: @integer; 
           do
              private.display->XDefaultScreen->screen;
              (private.display,screen)->XDefaultColorMap->cmap;
              theColor.red->theXColor.red;
              theColor.blue->theXColor.blue;
              theColor.green->theXColor.green;
              (* NB CStruct[] is same as @@ - insecure: No alloc in parameteres allowed! *)
              (private.display,cmap,theXColor[])->YAllocColor->result;
              (if result = 0 then (* failure *)
                  
               else
                  theXColor.pixel->thePixel; 
              if);
              
           #);
         
     if);
     
  exit thePixel
  #);
  

-- graphicsLib: Attributes --
XClipRect: external
  (# dpy,gc,x,y,width,height: @integer; 
  enter (dpy,gc,x,y,width,height)
  #);
setClipRect:
  (#
     XRect: data
       (# x: @shortInt; y: @shortInt; width: @shortInt; height: @shortInt; 
       #);
     r: @rectangle;
     x,y,width,height: @integer;
     
  enter r
  do
  (* r.topLeft -> (xr.x,xr.y);
   *      r.size -> (xr.width,xr.height);
   *      xr.x -> putInt;
   *      newLine;
   *      (private.display,private.gc,0,0,@@xr.x,1,Unsorted) -> XSetClipRectangles;
   *)
     r.topLeft->(x,y);
     r.size->(width,height);
     (private.display,private.gc,x,y,width,height)->XClipRect;
     
  #);
  

-- GUIENVgraphicsPenSize: Descriptor --
(#
   LineSolid: (#  exit 0 #);
   CapProjecting: (#  exit 3 #);
   JoinBevel: (#  exit 2 #);
   
do
   (private.display,private.gc,value,LineSolid,CapProjecting,JoinBevel)
     ->XSetLineAttributes;
   
#)  

-- GUIENVgraphicsPenForegroundColor: Descriptor --
(# pixel: @integer; 
do
   theColor[]->allocateColor->pixel;
   (private.display,private.gc,pixel)->XSetForeGround;
   
#)  

-- GUIENVgraphicsPenBackgroundColor: Descriptor --
(# pixel: @integer; 
do
   theColor[]->allocateColor->pixel;
   (private.display,private.gc,pixel)->XSetBackGround;
   
#)  

-- GUIENVgraphicsPenStipple: Descriptor --
(# stippleID: @integer; 
do
   (if b[] = patterns.black[] then
       (private.display,private.gc,FillSolid)->XSetFillStyle; 
    else
       private.gc->b.asStipple->stippleID;
       (if stippleID <> 0 then
           (private.display,private.gc,FillOpaqueStippled)->XSetFillStyle;
           (private.display,private.gc,stippleID)->XSetStipple;
           
        else
           exception
             (#  do 'Error: failed to create stipple'->msg.append;  #);
           
       if);
       
   if);
   
#)  

-- GUIENVgraphicsPenMode: Descriptor --
(# xmode: @integer; mask: @integer; 
do
%Bnot 0->mask;
   (* Above line tos_converted from: 0->tos'%not'->mask; *)
   (if m
    // transferModes.xorBlend then
       GXinvert->xmode; whitePixelValue %bxor blackPixelValue->mask; 
    // transferModes.copy then
       GXCopy->xmode; 
    // transferModes.orBlend then
       GXOr->xmode; 
    // transferModes.andBlend then
       GXAnd->xmode; 
    // transferModes.erase then
       GXAndInverted->xmode; 
    // transferModes.invertCopy then
       GXCopyInverted->xmode; 
    // transferModes.notAndBlend then
       GXnand->xmode; 
    // transferModes.notOrBlend then
       GXnor->xmode; 
   if);
   (private.display,private.gc,0,1,xmode,mask)->XSetState;
   
#)  

-- GUIENVgraphicsStyle: Descriptor --
(# 
do
   theTextStyle.allocate;
   (if theTextStyle.fontID <> 0 then
       (private.display,private.gc,theTextStyle.fontID)->XSetFont; 
   if);
   
#)  

-- GUIENVgraphicsMove: Descriptor --
(#  do p->private.pos.add;  #)  

-- GUIENVgraphicsMoveTo: Descriptor --
(#  do p->private.pos;  #)  

-- GUIENVgraphicsDraw: Descriptor --
(# fromX,fromY,toX,toY: @integer; 
do
   private.pos->(fromX,fromY);
   (fromX+p.h,fromY+p.v)->(toX,toY);
   (private.display,private.window,private.gc,fromX+private.translateX,fromY+
    private.translateY,toX+private.translateX,toY+private.translateY)
     ->XDrawLine;
   (toX,toY)->private.pos;
   
#)  

-- GUIENVgraphicsDrawTo: Descriptor --
(# fromX,fromY,toX,toY: @integer; 
do
   private.pos->(fromX,fromY);
   p->(toX,toY);
   (private.display,private.window,private.gc,fromX+private.translateX,fromY+
    private.translateY,toX+private.translateX,toY+private.translateY)
     ->XDrawLine;
   (toX,toY)->private.pos;
   
#)  

-- GUIENVgraphicsDrawSpot: Descriptor --
(# 
do
   (private.display,private.window,private.gc,p.h+private.translateX,p.v+
    private.translateY)->XDrawPoint;
   
#)  

-- GUIENVgraphicsDrawLine: Descriptor --
(# 
do
   (private.display,private.window,private.gc,p1.h+private.translateX,p1.v+
    private.translateY,p2.h+private.translateX,p2.v+private.translateY)
     ->XDrawLine;
   
#)  

-- GUIENVgraphicsDrawText: Descriptor --
(#
   x,y: @integer;
   length: @integer;
   XDrawString: External (* 6.6.2 *)
     (# display,drawable,gc,x,y,length: @integer; string: @integer; 
     enter (display,drawable,gc,x,y,string,length)
     #);
   
do
   private.pos->(x,y);
   t.length->length;
   (if length > 0 then
       (private.display,private.window,private.gc,x+private.translateX,y+
        private.translateY,@@ t.T[1],length)->XDrawString;
       
   if);
   
#)  

-- GUIENVgraphicsDrawPolygon: Descriptor --
(# xpoints: [0] @integer; 
do
   (if (points.range >= 3) then
       points.range->xpoints.new;
       (for i: points.range repeat
         points[i].h+private.translateX %putShortAt(@@ xpoints[i]+2*0);
         (* Above line tos_converted from: (@@ xpoints[i],points[i].h+private.translateX)->tos'%putshort[0]'; *)
         points[i].v+private.translateY %putShortAt(@@ xpoints[i]+2*1);
         (* Above line tos_converted from: (@@ xpoints[i],points[i].v+private.translateY)->tos'%putshort[1]'; *)
         
       for);
       (private.display,private.window,private.gc,@@ xpoints[1],xpoints.range,
        CoordModeOrigin)->XDrawLines;
       
   if);
   
#)  

-- GUIENVgraphicsDrawRect: Descriptor --
(# x,y,width,height: @integer; 
do
   r.topLeft->(x,y);
   r.size->(width,height);
   (private.display,private.window,private.gc,x+private.translateX,y+
    private.translateY,width-1,height-1)->XDrawRectangle;
   
#)  

-- GUIENVgraphicsDrawRoundRect: Descriptor --
(#  do 'GUIENVgraphicsDrawRoundRect: descriptor'->putLine;  #)  

-- GUIENVgraphicsDrawOval: Descriptor --
(# x,y,width,height: @integer; 
do
   r.topLeft->(x,y);
   r.size->(width,height);
   (private.display,private.window,private.gc,x+private.translateX,y+
    private.translateY,width,height,0,23040)->XDrawArc;
   
#)  

-- GUIENVgraphicsDrawSlice: Descriptor --
(# x,y,width,height: @integer; 
do
   r.topLeft->(x,y);
   r.size->(width,height);
   (private.display,private.window,private.gc,x+private.translateX,y+
    private.translateY,width,height,fromAngle div 64,toAngle div 64)->XDrawArc;
   
#)  

-- GUIENVgraphicsFillPolygon: Descriptor --
(# xpoints: [0] @integer; 
do
   (if (points.range >= 3) then
       points.range->xpoints.new;
       (for i: points.range repeat
         points[i].h+private.translateX %putShortAt(@@ xpoints[i]+2*0);
         (* Above line tos_converted from: (@@ xpoints[i],points[i].h+private.translateX)->tos'%putshort[0]'; *)
         points[i].v+private.translateY %putShortAt(@@ xpoints[i]+2*1);
         (* Above line tos_converted from: (@@ xpoints[i],points[i].v+private.translateY)->tos'%putshort[1]'; *)
         
       for);
       (private.display,private.window,private.gc,@@ xpoints[1],xpoints.range,
        Complex,CoordModeOrigin)->XFillPolygon;
       
   if);
   
#)  

-- GUIENVgraphicsFillRect: Descriptor --
(# x,y,width,height: @integer; 
do
   r.topLeft->(x,y);
   r.size->(width,height);
   (private.display,private.window,private.gc,x+private.translateX,y+
    private.translateY,width,height)->XFillRectangle;
   
#)  

-- GUIENVgraphicsFillRoundRect: Descriptor --
(#  do  #)  

-- GUIENVgraphicsFillOval: Descriptor --
(# x,y,width,height: @integer; 
do
   r.topLeft->(x,y);
   r.size->(width,height);
   (private.display,private.window,private.gc,x+private.translateX,y+
    private.translateY,width,height,0,23040)->XFillArc;
   
#)  

-- GUIENVgraphicsFillSlice: Descriptor --
(# x,y,width,height: @integer; 
do
   r.topLeft->(x,y);
   r.size->(width,height);
   (private.display,private.window,private.gc,x+private.translateX,y+
    private.translateY,width,height,fromAngle*64,toAngle*64)->XDrawArc;
   
#)  

-- GUIENVgraphicsDrawRaster: Descriptor --
(#
   drawBrokenImage:
     (#
        drawBackground:
          (# bottomRight: @point; 
          do
             to->bottomRight;
             (width,height)->bottomRight.add;
             (maxInt,maxInt,maxInt)->pen.foregroundColor;
             (to,bottomRight)->fillRect;
             
          #);
        drawCross:
          (# x,y: @Integer
          do
             to->(x,y);
             (maxInt,0,0)->pen.foregroundColor;
             10->pen.size;
             (to,(x+width,y+height))->drawLine;
             ((x,y+height),(x+width,y))->drawLine;
             
          #);
        
     do drawBackground; drawCross; 
     #)
do
   (if p.private.pixmapID = - 1 then
       drawBrokenImage
    else
       (if p.private.maskID <> 0 then
           (private.display,private.gc,p.private.maskID)->XSetClipMask;
           (private.display,private.gc,to.h+private.translateX,to.v+
            private.translateY)->XSetClipOrigin;
           
       if);
       (if (p.private.depth < THIS(guienv).private.defaultDepth) then
           (private.display,p.private.pixmapID,private.window,private.gc,from.h+
            private.translateX,from.v+private.translateY,width,height,to.h+
            private.translateX,to.v+private.translateY,p.private.depth)
             ->XCopyPlane;
           
        else
           (private.display,p.private.pixmapID,private.window,private.gc,from.h+
            private.translateX,from.v+private.translateY,width,height,to.h+
            private.translateX,to.v+private.translateY)->XCopyArea;
           
       if);
       (if p.private.maskID <> 0 then
           (private.display,private.gc,0)->XSetClipMask;
           (private.display,private.gc,0,0)->XSetClipOrigin;
           (if private.clip[] <> none then private.clip->SetClipRect;  if);
           
       if);
       
   if);
   
#)  

-- GUIENVgraphicsBody: Descriptor --
(# subWindowMode: @integer; 
do
   (if widgetID = 0 then
       father.windowID->private.window;
       father.displayID->private.display;
       position->(private.translateX,private.translateY);
       
    else
       windowID->private.window;
       displayID->private.display;
       (0,0)->(private.translateX,private.translateY);
       
   if);
   (private.display,private.window,0,0)->XCreateGC->private.gc;
   (* this(guienv).private.gc -> private.gc; *)
   (private.display,private.gc,blackPixelValue)->XSetForeGround;
   (private.display,private.gc,whitePixelValue)->XSetBackGround;
   (if overrideChildren then
       IncludeInferiors->subWindowMode; 
    else
       ClipByChildren->subWindowMode; 
   if);
   (private.display,private.gc,subWindowMode)->XSetSubWindowMode;
   INNER graphics;
   private.display->XFlush;
   (private.display,private.gc)->XFreeGC;
   
#)  

-- GUIENVgraphicsPrivate: Descriptor --
(#
   pos: @point;
   window,display,gc: @integer;
   translateX,translateY: @integer;
   clip: ^rectangle;
   
#)  

-- GUIENVgraphicsDrawSpots: DoPart --
do
   (if points.range > 0 then
         (# xpoints: [points.range*2] @shortInt; 
         do
            (for inx: points.range repeat
              points[inx].h+private.translateX->xpoints[inx*2-1];
              points[inx].v+private.translateY->xpoints[inx*2];
              
            for);
            (private.display,private.window,private.gc,@@ xpoints[1],
             points.range,CoordModeOrigin)->XDrawPoints;
            
         #);
       
   if);
     

