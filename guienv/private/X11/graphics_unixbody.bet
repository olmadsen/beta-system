ORIGIN '../graphicsbody';

Include 'motifstuff';
Include 'widget';
Include 'raster_unixbody';
Include 'guienvattributes';
INCLUDE 'guienv_unixprivate';
[[
-- guienvLib: attributes --

maxValue: (# exit 65535 #);
whiteColor: (# exit (maxValue, maxValue, maxValue) #);
blackColor: (# exit (0, 0, 0) #);

isBlack: booleanValue
  (# theColor: ^color;
  enter theColor[]
  do (theColor.red = 0) 
     and (theColor.green = 0) 
     and (theColor.blue = 0) -> value;
  #);

isWhite: booleanValue
  (# theColor: ^color;
  enter theColor[]
  do (theColor.red = maxValue) 
     and (theColor.green = maxValue) 
     and (theColor.blue = maxValue) -> value;
  #);

allocateColor:
  (# theColor: ^color;
     thePixel: @integer;
  enter theColor[]
  do (if true 
      //theColor[] -> isWhite then
         whitePixelValue -> thePixel;
      //theColor[] -> isBlack then
         blackPixelValue -> thePixel;
      else
         (# theXColor: @XColor;
            cmap, screen: @integer;
            result: @integer;
         do private.display -> XDefaultScreen -> screen;
            (display, screen) -> XDefaultColorMap -> cmap;
            theColor.red -> theXColor.red;
            theColor.blue -> theXColor.blue;
            theColor.green -> theXColor.green;
            (display, cmap, theXColor[]) -> XAllocColor -> result;
            (if result=0 then
                (* failure *)
             else
                theXColor.pixel -> thePixel;
            if);
         #);
     if);
  exit thePixel
  #);

-- GUIENVgraphicsPenSize: descriptor --
(# LineSolid: (# exit 0 #);
   CapProjecting: (# exit 3 #);
   JoinBevel: (# exit 2 #);
do (private.display,private.gc,value,LineSolid,CapProjecting,JoinBevel) -> XSetLineAttributes;
#)

-- GUIENVgraphicsPenForegroundColor: descriptor --
(# pixel: @integer;
do theColor[] -> allocateColor  -> pixel;
   (private.display, private.gc, pixel) -> XSetForeGround;
#)

-- GUIENVgraphicsPenBackgroundColor: descriptor --
(# pixel: @integer;
do theColor[] -> allocateColor -> pixel;
   (private.display, private.gc, pixel) -> XSetBackGround;
#)

-- GUIENVgraphicsPenStipple: descriptor --
(#
do (if b[]=patterns.black[] then
       (private.display,private.gc,FillSolid) -> XSetFillStyle;
    else
       (private.display,private.gc,FillOpaqueStippled) -> XSetFillStyle;
       (private.display,private.gc,b.rasterPrivatePart.xpixmap) -> XSetStipple;
   if);
#)

-- GUIENVgraphicsPenMode: descriptor --
(# xmode: @integer;
   mask: @integer;
do 0 -> TOS'%not' -> mask;
   
   (if m[]
    //transferModes.copy[] then GXCopy -> xmode;
    //transferModes.orBlend[] then GXOr -> xmode;
    //transferModes.xorBlend[] then 
       GXxor  -> xmode; 
       (whitePixelValue,blackPixelValue) -> TOS'%xor' -> mask;
    //transferModes.andBlend[] then GXAnd -> xmode;
    //transferModes.erase[] then  GXAndInverted -> xmode;
    //transferModes.invertCopy[] then GXCopyInverted -> xmode;
    //transferModes.notAndBlend[] then GXnand -> xmode;
    //transferModes.notOrBlend[] then  GXnor -> xmode;
   if);
   (private.display,private.gc,xmode) -> XSetFunction;
   (private.display,private.gc,mask) -> XSetPlaneMask;
   (private.display,private.gc,0) -> XSetBackGround;
   (private.display,private.gc,0 -> TOS'%not') -> XSetForeGround;
#)

-- GUIENVgraphicsStyle: descriptor --
(# 
do theTextStyle.allocate;
   (private.display,private.gc,theTextStyle.fontID) ->  XSetFont;
#)

-- GUIENVgraphicsMove: descriptor --
(#
do p -> private.pos.add;
#)

-- GUIENVgraphicsMoveTo: descriptor --
(#
do p -> private.pos;
#)

-- GUIENVgraphicsDraw: descriptor --
(# fromX,fromY,toX,toY: @integer;
   
do private.pos -> (fromX,fromY);
   (fromX+p.h,fromY+p.v) -> (toX,toY);
   (private.display,private.window,private.gc,
   fromX + private.translateX,fromY + private.translateY,
   toX + private.translateX,toY + private.translateY) -> XDrawLine;
   (toX,toY) -> private.pos;
#)

-- GUIENVgraphicsDrawTo: descriptor --
(# fromX,fromY,toX,toY: @integer;
do private.pos -> (fromX,fromY);
   p -> (toX,toY);
   (private.display,private.window,private.gc,
   fromX + private.translateX,fromY + private.translateY,
   toX + private.translateX,toY + private.translateY) -> XDrawLine;
   (toX,toY) -> private.pos;
#)

-- GUIENVgraphicsDrawSpot: descriptor --
(#
do (private.display,private.window,private.gc,
   p.h + private.translateX,p.v + private.translateY) -> XDrawPoint;
#)

-- GUIENVgraphicsDrawLine: descriptor --
(#
do (private.display,private.window,private.gc,
   p1.h + private.translateX,p1.v + private.translateY,
   p2.h + private.translateX,p2.v + private.translateY) -> XDrawLine;
#)

-- GUIENVgraphicsDrawText: descriptor --
(# x,y: @integer;
   length: @integer;
   XDrawString: External (* 6.6.2 *)
     (# display,drawable,gc,x,y,length: @integer;
        string: @integer;
     enter (display,drawable,gc,x,y,string,length)
     #);

do private.pos -> (x,y);
   t.length -> length;
   (if length > 0 then
       (private.display,private.window,private.gc,
       x + private.translateX,y + private.translateY,@@t.T[1],length) -> XDrawString;
   if);
#)

-- GUIENVgraphicsDrawPolygon: descriptor --
(# xpoints: [0] @integer;
do (if (points.range >= 3) then
       points.range ->  xpoints.new;
       (for i: points.range repeat
            (@@xpoints[i],points[i].h + private.translateX)-> TOS'%putshort[0]';
            (@@xpoints[i],points[i].v + private.translateY)-> TOS'%putshort[1]';
       for);
       (private.display,private.window,private.gc,@@xpoints[1],xpoints.range,CoordModeOrigin) -> XDrawLines;
   if);
#)

-- GUIENVgraphicsDrawRect: descriptor --
(# x,y,width,height: @integer;
do r.topLeft -> (x,y);
   r.size -> (width,height);
   (private.display,private.window,private.gc,
   x + private.translateX,y + private.translateY,width,height) -> XDrawRectangle;
#)

-- GUIENVgraphicsDrawRoundRect: descriptor --
(#
do
#)

-- GUIENVgraphicsDrawOval: descriptor --
(# x,y,width,height: @integer;
do r.topLeft -> (x,y);
   r.size -> (width,height);
   (private.display,private.window,private.gc,
   x + private.translateX,y + private.translateY,width,height,0,23040) -> XDrawArc;
#)

-- GUIENVgraphicsDrawSlice: descriptor --
(# x,y,width,height: @integer;
do r.topLeft -> (x,y);
   r.size -> (width,height);
   (private.display,private.window,private.gc,
   x + private.translateX,y + private.translateY,width,height,fromAngle div 64, toAngle div 64) -> XDrawArc;
#)

-- GUIENVgraphicsFillPolygon: descriptor --
(# xpoints: [0] @integer;
do (if (points.range >= 3) then
       points.range ->  xpoints.new;
       (for i: points.range repeat
            (@@xpoints[i],points[i].h + private.translateX)->TOS'%putshort[0]';
            (@@xpoints[i],points[i].v + private.translateY)->TOS'%putshort[1]';
       for);
       (private.display,private.window,private.gc,@@xpoints[1],xpoints.range,Complex,CoordModeOrigin) -> XFillPolygon;
   if);
#)

-- GUIENVgraphicsFillRect: descriptor --
(# x,y,width,height: @integer;
do r.topLeft -> (x,y);
   r.size -> (width,height);
   (private.display,private.window,private.gc,
   x + private.translateX,y + private.translateY,width,height) -> XFillRectangle;
#)

-- GUIENVgraphicsFillRoundRect: descriptor --
(#
do 
#)

-- GUIENVgraphicsFillOval: descriptor --
(# x,y,width,height: @integer;
do r.topLeft -> (x,y);
   r.size -> (width,height);
   (private.display,private.window,private.gc,
   x + private.translateX,y + private.translateY,width,height,0,23040) -> XFillArc;
#)

-- GUIENVgraphicsFillSlice: descriptor --
(# x,y,width,height: @integer;
do r.topLeft -> (x,y);
   r.size -> (width,height);
   (private.display,private.window,private.gc,
   x + private.translateX,y + private.translateY,width,height,fromAngle * 64, toAngle * 64) -> XDrawArc;
#)

-- GUIENVgraphicsDrawRaster: descriptor --
(# 
do (if r.rasterPrivatePart.mask <> 0 then
       (private.display, private.gc, r.rasterPrivatePart.mask) -> XSetClipMask;
       (private.display, private.gc, to.h + private.translateX, to.v + private.translateY) -> XSetClipOrigin;
   if);
   (if not r.rasterprivatepart.newstyle then
       (private.display,r.rasterPrivatePart.xpixmap,
       private.window,private.gc,
       from.h + private.translateX,from.v + private.translateY,
       width,height,
       to.h + private.translateX,to.v + private.translateY, 1) -> XCopyPlane;
    else
       (private.display,r.rasterPrivatePart.xpixmap,
       private.window,private.gc,
       from.h + private.translateX,from.v + private.translateY,
       width,height,
       to.h + private.translateX,to.v + private.translateY) -> XCopyArea;
   if);
#)

-- GUIENVgraphicsBody: descriptor --
(#
do (if widgetID=0 then
       father.windowID -> private.window;
       father.displayID -> private.display;
       position ->( private.translateX, private.translateY);
    else
       
       windowID -> private.window;
       displayID -> private.display;
       (0,0) -> ( private.translateX, private.translateY);
   if);
   (private.display,private.window,0,0) -> XCreateGC -> private.gc;
   (* this(guienv).private.gc -> private.gc; *)
   (private.display,private.gc,blackPixelValue) -> XSetForeGround;
   (private.display,private.gc,whitePixelValue) -> XSetBackGround;
   inner graphics;
   private.display -> XFlush;
   (private.display,private.gc) -> XFreeGC;
#)

-- GUIENVgraphicsPrivate: descriptor --
(# 
   pos: @point;
   window,display,gc: @integer;
   translateX,translateY: @integer;
#)
--]]
