ORIGIN 'guienv_unixprivate';
BUILD default '$$/guienv_unix.o' 'external/guienv_unix.c' 
'$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/Canvas.o' 'external/Canvas.c' 
'$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/Button.o' 'external/Button.c' 
'$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/IconButton.o' 'external/IconButton.c' 
'$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/ToggleButton.o' 'external/ToggleButton.c' 
'$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BODY 'develop';
INCLUDE '~beta/Xt/v1.10/events';
INCLUDE '~beta/sysutils/v1.6/cstring';
INCLUDE 'widget';
INCLUDE 'guienvattributes';
INCLUDE 'motifstuff';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '../../graphics';
INCLUDE 'rubberband';
INCLUDE 'callbacks';
INCLUDE 'error';
INCLUDE '../../utils/guienvadds';

-- GUIENVwindowLocalCoordsToGlobal: doPart --
do (# x_root, y_root: @shortRef;
      ID: @integer;
      x, y: @integer;
   do widgetID -> ID;
      (ID, local.h, local.v, x_root[], y_root[]) -> XtTranslateCoords;
      x_root -> uShort2Short -> x;
      y_root -> uShort2Short -> y;
      (x, y) -> global;
   #);

-- GUIENVwindowGlobalToLocal: doPart --
do global -> local;
   (0, 0) -> localToGlobal -> local.subtract;


-- lib: attributes --

uShort2Short:
  (# value: @integer;
  enter value
  do  (if value > 32768 then
          value - 65536 -> value;
      if);
  exit value
  #);


putPoint:
  (# p: @point
  enter p
  do '(' -> put;
     p.h -> putInt;
     ',' -> put;
     p.v -> putInt;
     ')' -> put;
  #);
putRectangle:
  (# r: @rectangle;
  enter r
  do r.topLeft -> putPoint;
     r.bottomRight -> putPoint;
  #);

-- guienvLib: attributes --

initX:
  (# XtAppSetFallbackResources: external
       (# appcontext: @integer;
          resources: @integer;
       enter (appcontext,resources)
       #);
     initAppName:
       (* initializes private.appName to the name of the executed file
        * with the first letter in uppercase
        *)
       (# lastSlash: @integer;
       do 1 -> arguments -> private.appName[];
          '/' -> private.appName.findAll(# do inx->lastSlash #);
          (if lastSlash<>0 then (1,lastSlash)->private.appName.delete if);
          (1->private.appName.inxGet->ascii.upcase, 1) -> private.appName.inxPut;
          trace
          (#
          do 'initAppName: ' -> putText;
             private.appName[] -> putLine;
          #);
       #);
     initAppClass:
       (* initializes private.appClass to the name of the executed file with
        * the first letter in uppercase. If the first letter i X the second 
        * letter is also converted to uppercase
        *)
       (# lastSlash: @integer;
       do 1 -> arguments -> private.appClass[];
          '/' -> private.appClass.findAll(# do inx->lastSlash #);
          (if lastSlash<>0 then (1,lastSlash)->private.appClass.delete if);
          (1->private.appClass.inxGet->ascii.upcase, 1) -> private.appClass.inxPut;
          (if ((1->private.appClass.inxGet)='X') and (private.appClass.length>1) then 
              (2->private.appClass.inxGet->ascii.upcase, 2) -> private.appClass.inxPut;
          if);
          trace
          (#
          do 'initAppClass: ' -> putText;
             private.appClass[] -> putLine;
          #);
       #);
     XtOpenDisplay: external
       (# appContext: @integer;
          displayString: @integer;
          name,class: [1]@char;
          options: ^cStruct; 
          nOptions: @integer;
          argcaddr,argvaddr: @integer;
          display: @integer
       enter (appContext,displayString,name,class,options[],nOptions,argcaddr,argvaddr)
       do callC
       exit display
       #);
  do XtToolkitInitialize;
     XtCreateApplicationContext -> private.appCon;
     initAppName;
     initAppClass;
     private.fallBackResources.init;
     (private.appCon,private.fallBackResources.address) -> XtAppSetFallbackResources;
     (private.appCon,0,
     private.appName,private.appClass,private.options[],0,getargc,getargv) 
       -> XtOpenDisplay -> private.display;
     (&errorHandler[]).install;
  #);
init:
  (# 
     initMenubar:
       (# theBar: ^menubarType;
       do &menubarType[] -> theBar[];
          (if theBar## <> menubar## then
              theBar.open;
              theBar[] -> applicationMenubar;
          if);
       #);
     initCursors:
       (# 
       do (display,XC_left_ptr) -> XCreateFontCursor -> cursors.arrow.private.id;
          (display,XC_xterm) -> XCreateFontCursor -> cursors.ibeam.private.id;
          (display,XC_watch) -> XCreateFontCursor -> cursors.watch.private.id;
          (display,XC_crosshair) -> XCreateFontCursor -> cursors.cross.private.id;
          (display,XC_cross) -> XCreateFontCursor -> cursors.plus.private.id;
       #);
     initBitmaps:
       (# bm: ^pixmap;
          getblack: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getwhite: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getgray: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getlightgray: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getdarkgray: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          root: @integer;
          makePixmap:
            (# pixmapID: @integer;
               thePixmap: ^pixmap;
            enter pixmapID
            do &pixmap[] -> thePixmap[];
               pixmapID -> thePixmap.private.pixmapID;
               1 -> thePixmap.private.depth;
            exit thePixmap[]
            #);
       do display -> XDefaultRootWindow -> root;
          (display, root) -> getwhite -> makePixmap -> patterns.white[];
          (display,root) -> getblack -> makePixmap  -> patterns.black[];
          (display,root) -> getlightgray -> makePixmap -> patterns.ltgray[];
          (display,root) -> getgray -> makePixmap -> patterns.gray[];
          (display,root) -> getdarkgray -> makePixmap -> patterns.dkgray[]; 
       #);
     internAtoms:
       (# 
       do (private.display, 'WM_DELETE_WINDOW', 0) 
            -> XInternAtom -> private.wmDeleteWindowAtom;
          (private.display, 'WM_PROTOCOLS', 0) 
            -> XInternAtom -> private.wmProtocolsAtom;
       #);
     
     argv,argc: @integer;
     
     initUpdateCompression:
       (# 
       do MaxInt -> private.updateLeft -> private.updateTop;
          MinInt -> private.updateRight -> private.updateBottom;
       #);
     
     (* bifrost begin *)
     initDeviceInfo: 
       (# 
       do 
          (if debugGraphic then 'InitDevice ... ' -> puttext if);
          private.display -> XDefaultScreenOfDisplay 
            -> private.defaultScreen;
          private.display -> XDefaultScreen
            -> private.defaultScreenNumber;
          private.defaultScreen -> XDefaultDepthOfScreen
            -> private.defaultdepth;
          private.defaultScreen -> XDefaultVisualOfScreen 
            -> private.defaultVisual;
          private.defaultScreen -> XRootWindowOfScreen
            -> private.defaultDrawable; 
          
          private.defaultScreen -> XDefaultColorMapOfScreen
            -> private.xcolormap;
          private.defaultScreen -> XBlackPixelOfScreen
            -> private.blackpixelvalue;
          private.defaultScreen -> XWhitePixelOfScreen
            -> private.whitepixelvalue;
          
          (private.defaultScreen->XHeightOfScreen->private.screenHeight) div
          ((private.display,private.defaultScreenNumber)-> XDisplayHeightMM)
            -> Private.pixelsPerMillimeterHeight;
          
          (private.defaultScreen->XWidthOfScreen->private.screenWidth) div
          ((private.display, private.defaultScreenNumber) -> XDisplayWidthMM)
            -> Private.pixelsPerMillimeterWidth;
          
          (if debugGraphic then 'done' -> putline if);
       #);
     initBifrost:
       (# 
       do true -> displaywarnings;
          bifrostprivate.PH.init;
       #);
     (* bifrost end *)
     
     initGC:
       (#
       do (private.display, private.theDeviceInfo.defaultDrawable,
          0, 0) -> XCreateGC -> private.gc;
       #);
  do inittickcount;
     private.theXtlib.init;
     
     private.options.init;
     &deviceInfo[] -> private.theDeviceInfo[] -> objectPool.put;
     
     (if private.display=0 then
         (normal, 'Cannot open display') -> stop;
      else
         private.display -> private.theDeviceInfo.init;
         initGC;
         initCursors;
         initBitmaps;
         initMenubar;
         internAtoms;
         initUpdateCompression;
         initDeviceInfo; (* bifrost *)
         initBifrost; (* bifrost *)
         (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
         true -> setupDone;
         (* private.handleIdle.add; *)
     if);
  #);

DestroyWidget:
  (# ID: @integer; (* T:@text; *)
  enter ID
  do (if ID=0 then
         (* (failureTrace, 'Attempt to destroy NULL widget') -> stop; *)
      else
         (* 'DestroyWidget: ID='->puttext; ID->putint; 
          * ', name='''->puttext; ID->XtName->T;t[]->puttext;
          * ''''->puttext; newline;
          *)
         ID -> XtDestroyWidget;
         (* (display,0) -> XSync; *)
     if);
  #);

SetAnswer: external
  (# value: @Boolean;
  enter value
  #);

menubarHeight: (# exit 30 #);
inittickcount: external
  (# 
  #);
tickcount: external
  (# ticks: @integer;
  exit ticks
  #);
appendTickRef:
  (# t: ^text;
  enter t[]
  do '_'->T.append;
     tickcount->T.putint;
  exit t[]
  #);
appendtick:
  (# T: ^text
  enter t[]
  do t[]->appendtickref->t[]
  exit t
  #);
GetTopShadowGC: external
  (* The widget must be a manager widget or descendant thereof *)
  (# w: @integer; (* The Manager widget *)
     gc: @integer; (* The gc that should be used for the top shadow *)
  enter w
  exit gc
  #);
GetBottomShadowGC: external
  (* The widget must be a manager widget or descendant thereof *)
  (# w: @integer; (* The Manager widget *)
     gc: @integer; (* The gc that should be used for the bottom shadow *)
  enter w
  exit gc
  #);
_XmDrawShadows: external
  (# display,drawable,topgc,bottomgc,x,y,width,height,thickness,type: @integer;
  enter (display,drawable,topgc,bottomgc,x,y,width,height,thickness,type)
     
  #);
-- interfaceObjectLib: attributes --
XtAddCallback: external
  (# widget: @integer;
     name: @integer;
     callbackP: @integer;
     clientData: @integer;
  enter (widget, name, callbackP, clientData)
  #);
destroyCallbackSelector: callbackSelector
  (# T:@text;
  do (* 'DestroyCallback: guienv ID='->puttext; private.widgetID->putint; 
      * ' motif ID='->puttext; widget->putint;
      * ', name='''->puttext; widget->XtName->T;t[]->puttext;
      * ''''->puttext; newline;
      *)
     (for inx: private.callbacks.range repeat
          private.callbacks[inx] -> freeCBF;
     for);
     0 -> private.callbacks.new;
     false -> private.beingClosed;
     0 -> private.widgetID;
     
  #);
destroyCallbackProcessor: callbackProcessor
  (# 
  do &destroyCallbackSelector[] -> cb[];
  #);

eventDisabled: booleanValue
  (# ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]=none then
         false -> value;
      else
         ev## -> private.disabledEvents.has -> value;
     if); 
  #);
addDisabledEvent:
  (# e: ^eventSpec;
     ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]=none then
         &eventSpecList[] -> private.disabledEvents[];
     if);
     (if not (ev## -> private.disabledEvents.has) then
         &eventSpec[] -> e[];
         ev## -> e.type##;
         e[] -> private.disabledEvents.append;
     if);
  #);
removeDisabledEvent:
  (# ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]<>none then
         ev## -> private.disabledEvents.remove;
     if);
  #);
addCBF:
  (# cbf: @integer;
  enter cbf
  do 1 -> private.callbacks.extend;
     cbf -> private.callbacks[private.callbacks.range];
  #);

-- motifMenuLib: attributes --

unmapcallbackSelector: callbackSelector
  (# 
  do (if popdownHook[] <> NONE then
         popdownHook;
     if);
     
     (* enable all motifmenuitems to make keyboard shortcuts work without having to
      * post the menu first to evaluate item.onStatus.
      *)
     private.motifMenuitems.scan
     (# 
     do (current.widgetID,1) -> XtSetSensitive;
     #);
     false -> private.isVisible;
  #);
unmapCallbackProcessor: callbackProcessor
  (# 
  do &unmapCallbackSelector[] -> cb[];
  #);

handleOnSelect:
  (# 
  do true -> private.isVisible;
     theMenu.theEventHandler.onSelect;
     private.motifMenuItems.scan
     (# 
     do current.handleOnStatus; 
     #)
  #);
setKey:
  (# position: @integer;
     key: @char;
     theMotifMenuItem: ^motifMenuitem;
     t: @text;
  enter (position,key)
  do position -> getItemByNumber -> theMotifMenuItem[];
     t.clear;
     'Ctrl-' -> t.putText;
     key -> t.put;
     (XmNacceleratorText,t[]) -> theMotifMenuItem.setMotifStringResource;
     t.clear;
     'Ctrl<Key>' -> t.putText;
     key -> t.put;
     (XmNaccelerator,t[]) -> theMotifMenuItem.setStringResource;
  #);
setName:
  (# position: @integer;
     name: ^text;
     theMotifMenuItem: ^motifMenuitem;
  enter (position,name[])
  do position -> getItemByNumber -> theMotifMenuItem[];
     (XmNlabelString,name[]) -> theMotifMenuItem.setMotifStringResource;
  #);
setChecked:
  (# position: @integer;
     checked: @boolean;
     theMotifMenuItem: ^motifMenuitem;
  enter (position,checked)
  do position -> getItemByNumber -> theMotifMenuItem[];
     checked -> theMotifMenuItem.checked;
  #);
setSubMenu:
  (# position: @integer;
     theMotifMenuItem: ^motifMenuitem;
     theMenu: ^menu;
  enter(position,theMenu[])
  do position -> getItemByNumber -> theMotifMenuItem[];
     (if theMotifMenuItem.theMotifSubmenu[]<>none then
         theMotifMenuItem.theMotifSubmenu.close;
     if);
     (if theMenu[]=none then
         none -> theMotifMenuItem.theMotifSubmenu[];
         (XmNsubMenuID,0) -> theMotifMenuItem.setIntegerResource;
      else
         &motifMenu[] -> theMotifMenuItem.theMotifSubmenu[];
         theMenu[] -> theMotifMenuItem.theMotifSubMenu.theMenu[];
         this(motifMenu)[] -> theMotifMenuItem.theMotifSubMenu.owner[];
         theMotifMenuItem.theMotifSubMenu.open;
         (XmNsubMenuID,theMotifMenuItem.theMotifSubMenu.widgetID) 
           -> theMotifMenuItem.setIntegerResource;
     if);
  #);


-- GUIENVmotifMenuappend: doPart --
do (# theMotifMenuItem: ^motifMenuitem;
   do &motifMenuitem[] -> theMotifMenuItem[];
      theItem[] -> theMotifMenuItem.theMenuitem[];
      theMotifMenuItem.open;
   #);
   
-- GUIENVmotifMenudelete: doPart --
do (# theMotifItem: ^motifMenuitem;
   do l: private.motifMenuItems.scan
        (# 
        do (if theItem[]=current.theMenuitem[] then
               current[] -> theMotifItem[];
               leave l;
           if);
        #);
      (if theMotifItem[]<>none then
          theMotifItem[] ->  private.motifMenuItems.remove;
          theMotifItem.close;
      if);
   #)

-- GUIENVmotifMenuCreate: doPart --
do (# name: ^text;
      args: @argList;
   do theMenu.name -> name[];
      tickCount -> name.putInt;
      (if popup then
          (owner.widgetID,name,args[],0) -> XmCreatePopupMenu -> widgetID;
          (* 'Created motif popup menu widget: ID = ' -> putText;
           * widgetID -> putInt;
           * ' name = ' -> putText;
           * name[] -> putline;
           *)
       else
          (owner.widgetID,name,args[],0) -> XmCreatePullDownMenu -> widgetID;
          (* 'Created pulldown menu widget: ID = ' -> putText;
           * widgetID -> putInt;
           * ' name = ' -> putText;
           * name[] -> putline;
           *)
          (unmapCallbackProcessor##, XmNunmapCallback) -> addCallbackProcessor;
      if);
      theMenu.scan
      (# theMotifMenuitem: ^motifMenuitem;
      do &motifMenuitem[] -> theMotifMenuitem[];
         current[] -> theMotifMenuitem.theMenuitem[];
         theMotifMenuitem.open;
      #);
      (if themenu.enabled then
          (widgetID,1) -> XtSetSensitive;
       else
          (widgetID,0) -> XtSetSensitive;
      if);
      this(motifMenu)[] -> theMenu.private.motifMenus.append;
   #);

-- GUIENVmotifMenuOpen: doPart --
do inner open;
   
-- GUIENVmotifMenuClose: doPart --
do private.motifMenuitems.scan
   (# 
   do current.close;
   #);
   private.motifMenuitems.clear;
   this(motifMenu)[] -> theMenu.private.motifMenus.remove;
   widgetID -> DestroyWidget; 
   
-- GUIENVmotifMenugetNumberOfWidget: doPart --
do (# inx: @integer;
   do 0 -> inx;
      l: private.motifMenuitems.scan
        (# 
        do inx + 1 -> inx;
           (if current.widgetID=widget then
               inx -> position;
               leave l
           if);
        #);
      
   #);
   
   
-- GUIENVmotifMenuPrivate: descriptor --
(# motifMenuItems: @list
        (# element::< motifMenuitem;
           remove:
             (# e: ^element;
             enter e[]
             do e[] -> at -> delete;
             #);
        #);
      isVisible: @boolean;
#)

-- motifMenubarLib: attributes --

cascadeButton: interfaceObject
  (# theMotifmenu: ^motifMenu;
     open::<
       (# create::<
            (# args: @argList;
               mstr: @motifString;
            do theMotifmenu.theMenu.name -> mstr.setText;
               ('cascadebutton',xmCascadeButtonWidgetClass,this(motifMenubar).widgetID,args[],0) 
                 -> XtCreateWidget -> widgetID;
               manage;
               (cascadingProcessor##, XmNcascadingCallback) -> addCallbackProcessor;
               (1,XmNlabelString,mstr) -> args.set;
               (2,XmNsubMenuId,theMotifMenu.widgetID) -> args.set;
               (widgetID,args[],2) -> XtSetValues;
               ;
            #);
       #);
     close::<
       (# 
       do widgetID -> DestroyWidget;
       #);
     handleCascading: MotifcallbackSelector
       (# 
       do theMotifmenu.handleOnSelect;
       #);
     cascadingProcessor: callbackProcessor
       (# 
       do &handleCascading[] -> cb[];
       #);
  #);

-- GUIENVmotifMenubarappend: doPart --
do (# theCascadeButton: ^cascadeButton;
      theMotifMenu: ^motifMenu;
   do &motifMenu[] -> theMotifMenu[];
      this(motifMenubar)[] -> theMotifMenu.owner[];
      theMenu[] -> theMotifMenu.theMenu[];
      theMotifMenu.open;
      &cascadeButton[] -> theCascadeButton[];
      theMotifMenu[] -> theCascadeButton.theMotifMenu[];
      theCascadeButton.open;
      theMotifMenu[] -> private.motifMenus.append;
      theCascadeButton[] -> private.cascadeButtons.append;
   #);

-- GUIENVmotifMenubardelete: doPart --
do (# theCascadeButton: ^cascadeButton;
      theMotifMenu: ^motifMenu;
   do theMenu[] -> private.motifMenus.findMenu -> theMotifMenu[];
      theMotifMenu[] -> private.cascadeButtons.findButton -> theCascadeButton[];
      (if theCascadeButton[]<>none then
          theCascadeButton.close;
          theCascadeButton[] -> private.cascadeButtons.remove;
      if);
      theMotifMenu[] -> private.motifMenus.remove;
      theMotifMenu.close;
   #)

-- GUIENVmotifMenubarcreate: doPart --
do (# args: @argList;
      theFuncPtr: @integer;
      T: @text;
   do (1,XtNheight,menubarHeight) -> args.set;
      (theWindow.private.contentsForm.widgetID,'Menubar'->appendTick->T,args[],1) 
        -> XmCreateMenuBar -> widgetID;
      (* 'Created menubar widget: ID = ' -> putText;
       * widgetID -> putInt;
       * ' name = ' -> putText;
       * T[] -> putline;
       *)
      (XmNresizeWidth,0) -> setIntegerResource;
      (XmNresizeHeight,0) -> setIntegerResource;
      (XmNresizable,true) -> setBooleanResource;
      widgetID -> XtManageChild;
   #)

-- GUIENVmotifMenubaropen: doPart --
do
   
-- GUIENVmotifMenubarClose: doPart --
do private.motifMenus.scan
   (# 
   do (current[] -> private.cascadeButtons.findButton).close;
      current.close;
   #);
   private.motifMenus.clear;
   widgetID -> DestroyWidget;
   
   
-- GUIENVmotifMenubarprivate: descriptor --
(# motifmenus: @list
     (# element::< motifMenu;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
        findMenu:
          (# theMotifMenu: ^motifMenu;
             theMenu: ^menu;
          enter theMenu[]
          do l: scan
               (# 
               do (if current.theMenu[]=theMenu[] then
                      current[] -> theMotifMenu[];
                      leave l;
                  if);
               #);
          exit theMotifMenu[]
          #);
     #);
   cascadeButtons: @list
     (# element::< cascadeButton;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
        findButton:
          (# theMotifMenu: ^motifMenu;
             theButton: ^cascadeButton;
          enter theMotifMenu[]
          do l: scan
               (# 
               do (if current.theMotifMenu[]=theMotifMenu[] then
                      current[] -> theButton[];
                      leave l;
                  if);
               #);
          exit theButton[]
          #);
     #);
#)

-- GUIENVterminateBody: doPart --
do Stop;

-- GUIENVsetTheMenubar: doPart --
do
   (# XtAppCreateShell: external
        (# name: [1] @char;
           class: [1] @char;
           widgetClass: @integer;
           display: @integer;
           args: ^argList;
           nArgs: @integer;
           newWidget: @integer;
        enter (name,class,widgetclass,display,args[],nArgs)
        do callC
        exit newWidget
        #);
   do themenubar[] -> private.theMenubar[];
      
   #)
-- GUIENVgetTheMenubar: doPart --
do private.theMenubar[] -> themenubar[];


-- GUIENVdoSetUp: descriptor --
(#
do initX;
   init;
#)

-- GUIENVdoPart: doPart --
do
   (# aWindow: @window
        (#
           open::
             (#
             do '' -> Title;
                (680, 20) -> size;
             #);
        #);
   do 
      (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
      (if not setupDone then 
          doSetUp;
      if);
      onStartApplication;
      inner guienv;
      (if applicationMenuBar <> NONE then
          (if private.windows.empty then
              aWindow.open;
          if);
      if);
      
      (if not private.dontRunLoop then
          private.appcon -> XtAppMainLoop;
          (* the control is transferred to xtoolkit
           * the rest is handled via callbacks
           *)
      if);
   #)

-- GUIENVmouseDownDelay: doPart --
do
   (# ticks: @integer;
      start: @integer;
   do tickCount -> start;
      l:
        (if mouse.buttonState=buttonState then
            tickCount -> ticks;
            (if ((ticks - start) < period) then
                restart l;
             else
                inner delay;
            if);
        if);
   #)

-- GUIENVinterfaceObjectEvent: doPart --
do (if not (this(event)## -> eventDisabled) then
       (if private.beforeActions[]<>None then
           private.beforeActions.scan
           (# 
           do (if (current.eventType## >= this(event)##) then
                  this(event)[] -> current;
              if);
           #);
       if);
       inner event;
       (if private.afterActions[]<>None then
           private.afterActions.scan
           (# 
           do (if (current.eventType## >= this(event)##) then
                  this(event)[] -> current;
              if);
           #);
       if);
   if);


-- GUIENVbasicEventShiftKey: doPart --
do (((this(guienv).private.state,shiftMask) -> tos'%and')=shiftMask) -> value;


-- GUIENVbasicEventAltKey: doPart --
do (* Not Implemented !!! *)


-- GUIENVbasicEventMetaKey: doPart --
do (((this(guienv).private.state,mod1Mask) -> tos'%and')=mod1Mask) -> value;


-- GUIENVbasicEventControlKey: doPart --
do (((this(guienv).private.state,controlMask) -> tos'%and')=controlMask) -> value;


-- GUIENVbasicEventButtonState: doPart --
do this(guienv).private.detail -> value;


-- GUIENVbasicEventWhen: doPart --
do this(guienv).private.time -> value;


-- GUIENVbasicEventGlobalPosition: doPart --
do (this(guienv).private.x_root, this(guienv).private.y_root) -> p;


-- GUIENVbasicEventLocalPosition: doPart --
do (this(guienv).private.x, this(guienv).private.y) -> p;


-- GUIENVmouseEventDoubleClick: doPart --
do this(guienv).private.doubleClick -> value;


-- GUIENVkeyEventCh: doPart --
do this(guienv).private.theChar -> theChar;  


-- GUIENVinterfaceObjectPrependAction: doPart --
do (if private.beforeActions[]=none then
       &actionList[] -> private.beforeActions[];
   if);
   (if not (theAction[] -> private.beforeActions.member) then
       theAction[] -> private.beforeActions.prepend;
   if);


-- GUIENVinterfaceObjectAppendAction: doPart --
do (if private.afterActions[]=none then
       &actionList[] -> private.afterActions[];
   if);
   (if not (theAction[] -> private.afterActions.member) then
       theAction[] -> private.afterActions.append;
   if);


-- GUIENVinterfaceObjectDeleteAction: doPart --
do 
   (if private.beforeActions[]<>none then
       theAction[] -> private.beforeActions.delete;
   if);
   (if private.afterActions[]<>none then
       theAction[] -> private.afterActions.delete;
   if);



-- GUIENVinterfaceObjectOpen: doPart --
do
   (# openTwiceException: exception
        (# 
        do 'Attempt to open interfaceobject twice: ' -> msg;
           THIS(InterfaceObject)[]->getpatternname->msg.append
        #);
   do  (if not private.isOpen then
           true -> private.isOpen;
           create;
           (if private.widgetID<>0 then
               (destroyCallbackProcessor##, XtNdestroyCallback) -> addCallbackProcessor;
           if);
           inner open;
        else
           openTwiceException;
       if);
   #)

-- GUIENVintefaceObjectCreate: doPart --
do inner create;


-- GUIENVinterfaceObjectClose: doPart --
do
   (# do assertOpen;
      inner close;
      false -> private.isOpen;
      true -> private.beingClosed;
   #)
-- GUIENVenableEventType: doPart --
do ev## -> removeDisabledEvent;

-- GUIENVdisableEventType: doPart --
do ev## -> addDisabledEvent;



-- GUIENVinterfaceObjectException: doPart --
do 'interfaceobject-exception for ' -> msg.putText;
   THIS(interfaceObject)[] -> getPatternName -> msg.putText;
   msg.newline;
   inner interfaceObjectException;


-- GUIENVnotOpenedException: doPart --
do 'Attempt to use '''->msg.puttext;
   (if location[]<>NONE then
       location[]->msg.puttext;
       ''' in ''' -> msg.puttext;
   if);
   THIS(interfaceobject)[] -> getpatternname -> msg.puttext;
   ''' which is not ''open''' -> msg.putline;
   inner notOpenedException;


-- GUIENVseparatorSetStyle: doPart --
do (# xmStyle: @integer;
   do value -> private.style;
      (if value
       //separatorStyles.singleLine then XmSINGLE_LINE -> xmStyle;
       //separatorStyles.doubleLine then XmDOUBLE_LINE -> xmStyle;
       //separatorStyles.singleDashedLine then XmSINGLE_DASHED_LINE -> xmStyle;
       //separatorStyles.doubleDashedLine then XmDOUBLE_DASHED_LINE -> xmStyle;
       //separatorStyles.etchedIn then XmSHADOW_ETCHED_IN -> xmStyle;
       //separatorStyles.etchedOut then XmSHADOW_ETCHED_OUT -> xmStyle;
      if);
      (XmNseparatorType,xmStyle) -> setIntegerResource;
   #)

-- GUIENVseparatorGetStyle: doPart --
do private.style -> value;

-- GUIENVwindowseparatorCreate: doPart --
do (# args: @argList;
      width,height: @integer;
   do father.size -> (width,height);
      (if vertical then
          (1,XmNorientation,XmVERTICAL) -> args.set;
          (2,XtNheight,height) -> args.set;
       else
          (1,XmNorientation,XmHORIZONTAL) -> args.set;
          (2,XtNwidth,width) -> args.set;
      if);
      (XmSeparatorWidgetClass,father.widgetID,'Separator'->appendtickref,args[],2)
        -> createManagedArgs;
      separatorStyles.etchedIn -> private.style;
   #);

-- GUIENVwindowseparatorOpen: doPart --
do inner open;

-- GUIENVwindowseparatorClose: doPart --
do inner close;


-- GUIENVwindowseparatorPrivate: descriptor --
(# style: @integer;
#)



-- canvasLib: attributes --
appendChild:
  (# theWindowitem: ^windowitem;
  enter theWindowitem[]
  do theWindowitem[] -> private.children.append;
  #);
deleteChild:
  (# theWindowitem: ^windowitem;
  enter theWindowitem[]
  do theWindowitem[] -> private.children.at -> private.children.delete;
  #);
handleChildframeChanged:
  (# oldFrame,newFrame: @rectangle;
  enter (oldFrame,newFrame)
  do (oldFrame,newFrame) -> theEventHandler.onChildframeChanged;
  #);

-- GUIENVcanvasSelectionAdd: doPart --
do (if not (theWindowitem[] -> private.selection.has) then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);


-- GUIENVcanvasSelectionSet: doPart --
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;


-- GUIENVcanvasSelectionRemove: doPart --
do (if theWindowitem[] -> private.selection.has then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);


-- GUIENVcanvasSelectionEmpty: doPart --
do private.selection.empty -> value;


-- GUIENVcanvasSelectionScan: doPart --
do private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);


-- GUIENVcanvasSelectionClear: doPart --
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);



-- GUIENVcanvasScan: doPart --
do private.children.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);


-- GUIENVcanvasCreate: doPart --
do
   (# args: @argList;
   do inner create;
      (if widgetID=0 then
          (XbCanvasWidgetClass,father.widgetID) -> createSimple;
      if);

   #)
-- GUIENVcanvasOpen: doPart --
do inner open;


-- GUIENVcanvasClose: doPart --
do inner close;
   private.children.scan
   (# 
   do current.close;
   #);




-- GUIENVcanvasOnActivate: doPart --
do private.children.scan
   (# 
   do current.theEventHandler.onActivate;
   #);
   inner onActivate;


-- GUIENVcanvasOnDeactivate: doPart --
do private.children.scan
   (# 
   do current.theEventHandler.onDeactivate;
   #);
   inner onDeactivate;


-- GUIENVcanvasOnFrameChanged: doPart --
do update;
   inner onFrameChanged;


-- GUIENVcanvasOnVisibleChanged: doPart --
do assertOpen;
   private.children.scan
   (# 
   do (if current.visible then
          current.theEventHandler.onVisibleChanged;
      if);
   #);
   INNER;
   
-- GUIENVcanvasPrivate: descriptor --
(# children: @list
     (# element::< windowitem;
        scanNonWidgets: scan
          (# where::<
               (# 
               do (current.widgetID = 0) -> value;
               #);
          do inner;
          #);
        scanNonWidgetsReverse: scanReverse
          (# where::<
               (# 
               do (current.widgetID = 0) -> value;
               #);
          do inner;
          #)
     #);
   selectionList: list
     (# 
        element::< windowitem;
     #);
   selection: @selectionList;
#)
-- GUIENVcanvasOnMouseDown: doPart --
do
   (# obj: ^windowitem;
   do l: private.children.scanNonWidgetsReverse
        (# 
        do (if localPosition -> current.hit then
               current[] -> obj[];
               leave l;
           if);
        #);
      (if obj[]=none then
          inner onMouseDown;
       else
          obj.theEventHandler.onMouseDown;
      if);
   #)

-- GUIENVcanvasOnRefresh: doPart --
do inner onRefresh;
   private.children.scanNonWidgets
   (# 
   do (if current.visible then
          current.theEventHandler.onRefresh;
      if);
   #);


-- GUIENVcanvasOnMouseUp: doPart --
do inner onMouseUp;


-- GUIENVclipBoardHasText: doPart --
do

-- GUIENVclipBoardSetText: doPart --
do

-- GUIENVclipBoardGetText: doPart --
do

-- GUIENVclipBoardClearContents: doPart --
do

--- GUIENVcursorPrivate: descriptor ---
(# id: @integer;
#)

-- menubarLib: attributes --
buildMenubar: 
  (# fatherWidget: @integer;
     
  enter fatherWidget
  do
  #);
destroyMenubar: 
  (# 
  do 
  #);

-- menubarEntryLib: attributes --

entryHandleCasading: motifCallbackSelector
  (# subMenuId: @integer;
     theMenu: ^menu;
     args: @argList;
     w: @integer;
  do cascadeButtonWidget->w;
     (1, XmNsubMenuId, @@subMenuId) -> args.set;
     (w, args[],1) -> XtGetValues;
     subMenuId -> private.menus.findById -> theMenu[];
     (if theMenu[]=none then
         trace
         (# 
         do 'handleCascading: theMenu was not found in menu list' -> putLine;
         #);
      else
         theMenu.handleOnSelect;
     if);
  #);
entryCascadingProcessor: callbackProcessor
  (# 
  do &entryHandleCasading[] -> cb[];
  #);

(* -- GUIENVmenuBarEntryHandlCascading: doPart --
 do (# subMenuId: @widget;
 theMenu: ^menu;
 do
 XmNsubMenuId -> getIntegerResource -> subMenuID;
 subMenuId -> private.menus.findById -> theMenu[];
 (if theMenu[]=none then
 trace
 (# 
 do 'handleCascading: theMenu was not found in menu list' -> putLine;
 #);
 else
 theMenu.handleOnSelect;
 if);
 #);
 *)
-- GUIENVmenubarEntryDoBuildEntry: doPart --
do (#args: @argList;
      mstr: @motifString;
   do 
      widgetID -> theMenu.buildMenu;
      theMenu.name -> mstr.setText;
      ('cascadebutton'->appendtick,xmCascadeButtonWidgetClass,widgetID,args[],0) 
        -> XtCreateWidget -> cascadeButtonWidget;
      cascadeButtonWidget -> XtManageChild;
      (entryCascadingProcessor##, XmNcascadingCallback, cascadeButtonWidget) -> addCallbackProcessorForSubWidget;
      (1,XmNlabelString,mstr) -> args.set;
      (2,XmNsubMenuId,theMenu.widgetID) -> args.set;
      (cascadeButtonWidget,args[],2) -> XtSetValues;
      this(menubar)[] -> theMenu.private.theMenubar[];
      this(menubarEntry)[] -> theMenu.private.theEntry[];
   #);
   
-- GUIENVmenubarEntrydestroyEntry: doPart --
do  (# args: @argList;
    do
       (1,XmNsubMenuId,0) -> args.set;
       (cascadeButtonWidget,args[],1) -> XtSetValues;
       cascadeButtonWidget -> DestroyWidget;
       theMenu.destroyMenu;
       0 -> cascadeButtonWidget;
    #);
-- GUIENVmenubarEntryRebuildEntry: doPart --
do (# args: @argList;
   do
      theMenu.destroyMenu;
      widgetID -> theMenu.buildMenu;
      (1,XmNsubMenuId,theMenu.widgetID) -> args.set;
      (cascadeButtonWidget,args[],1) -> XtSetValues;
   #);

--- GUIENVmenubarPrivate: descriptor ---
(# menus: @list
     (# element::< menu;
        findById:
          (# widgetId: @integer;
             theMenu: ^menu;
          enter widgetId
          do l: scan
               (# 
               do (if current.widgetID=widgetId then
                      current[] -> theMenu[];
                      leave l;
                  if);
               #);
          exit theMenu[]
          #);
     #);
   windows: @list
     (# 
        element::< window;
     #);
#)
-- GUIENVmenubarAppend: doPart --
do assertOpen;
   (if not (theMenu[] -> private.menus.has) then
       theMenu[] -> private.menus.append;
       private.windows.scan
       (# 
       do theMenu[] -> current.private.theMotifMenubar.append;
       #);
   if)


-- GUIENVmenubarDelete: doPart --
do assertOpen;
   (if theMenu[] -> private.menus.has then
       theMenu[] -> private.menus.at -> private.menus.delete;
       private.windows.scan
       (# 
       do theMenu[] -> current.private.theMotifMenubar.delete;
       #);
   if);

-- GUIENVmenubarClear: doPart --
do assertOpen;
   private.menus.scan
   (# 
   do current[] -> delete;
   #);

-- GUIENVmenubarAppendMenubar: doPart --
do assertOpen;
   theMenubar.scan
   (# 
   do current[] -> append;
   #);


-- GUIENVmenubarReplaceMenubar: doPart --
do assertOpen;
   theMenubar[] -> deleteMenubar;
   replacementMenubar[] -> appendMenubar;

-- GUIENVmenubarDeleteMenubar: doPart --
do assertOpen;
   theMenubar.scan
   (# 
   do current[] -> delete;
   #);


-- GUIENVmenubarScan: doPart --
do assertOpen;
   private.menus.scan
   (# 
   do current[] -> THIS(scan).current[];
      inner scan;
   #);


-- GUIENVmenubarOpen: doPart --
do private.menus.init;
   inner open;

-- GUIENVmenubarCreate: doPart --
do inner create; 


-- GUIENVmenubarClose: doPart --
do inner Close;
   clear;
   (* widgetID -> XtParent -> DestroyWidget *)



-- GUIENVmenuBuildMenu: descriptor --
(#  #)


-- GUIENVmenuBuildPopupmenu: descriptor --
(#  #)


-- GUIENVmenuDestroyMenu: descriptor --
(#  #)


-- GUIENVmenuSetName: doPart --
do assertOpen;
   theName.copy -> private.name[];


-- GUIENVmenuGetName: doPart --
do assertOpen;
   (if private.name[]=none then
       &text[] -> theName[];
    else
       private.name.copy -> theName[];
   if);


-- GUIENVseparatorCreate: doPart --
do inner create


-- GUIENVseparatorOpen: doPart --
do inner open;   


-- GUIENVseparatorClose: doPart --
do inner close;


-- GUIENVmenuAppend: doPart --
do assertOpen;
   (if not (theMenuItem[] -> private.menuitems.has) then
       theMenuItem[] -> private.menuitems.append;
       private.motifMenus.scan
       (# 
       do theMenuItem[] -> current.append;
       #);
   if);


-- GUIENVmenuDelete: doPart --
do assertOpen;
   (if theMenuitem[] -> private.menuitems.has then
       theMenuItem[] -> private.menuitems.at -> private.menuitems.delete;
       private.motifMenus.scan
       (# 
       do theMenuItem[] -> current.delete;
       #);
    else
       trace
       (# 
       do 'menu.delete: the menuitem is not in the menu' -> putLine;
       #);
   if);

-- GUIENVmenuScan: doPart --
do assertOpen;
   private.menuitems.scan
   (# 
   do current[] -> THIS(scan).current[];
      inner scan;
   #);

-- GUIENVmenuClear: doPart --
do assertOpen;
   scan
   (# 
   do current[] -> delete;
   #)

-- GUIENVmenuNoOfMenuitems: doPart --
do assertOpen;
   private.menuitems.size -> value;


-- GUIENVmenuGetMenuItemByNumber: doPart --
do
   (# 
      count: @integer;
   do assertOpen;
      0 -> count;
      l: private.menuitems.iterate
        (# 
        do count + 1 -> count;
           (if count=number then
               current.elm[] -> theMenuItem[];
               leave l;
           if);
        #);
   #)
-- GUIENVmenuEnable: doPart --
do assertOpen;
   true -> private.enabled;
   (if widgetID<>0 then
       (widgetID,1) -> XtSetSensitive;
   if);

-- GUIENVmenuDisable: doPart --
do assertOpen;
   false -> private.enabled;
   (if widgetID<>0 then
       (widgetID,0) -> XtSetSensitive;
   if);

-- GUIENVmenuEnabled: doPart --
do assertOpen;
   private.enabled -> value;


-- GUIENVmenuOpen: doPart --
do this(Menu)[] -> getPatternName -> private.name[];
   true -> private.enabled;
   inner open;


-- GUIENVmenuCreate: doPart --
do inner create;


-- GUIENVmenuClose: doPart --
do (if private.popupevent[]<>NONE then private.popupevent -> XtFree if);
   inner close;

-- MenuLib: attributes --
handleOnSelect:
  (# 
  do theEventHandler.onSelect;
  #);

-- GUIENVmenuPopUp: doPart --
do
   (# 
      id: @integer;
      x_root,y_root: @shortRef;
      x, y: @integer;
      theItem: ^Motifmenu.motifMenuItem;
      menuPost: ^text;
   do assertOpen;
      (if (private.motifpopupmenu[]=NONE) 
          (* create motif menu *)
          or (popupin[]<>private.motifPopupMenu.owner[]) then
          (if private.motifPopupMenu[]<>NONE then
              (* destroy old motif menu *)
              private.motifPopupMenu.close;
          if);
          &motifmenu[] -> private.MotifpopupMenu[];
          popupIn[] -> private.MotifpopupMenu.owner[];
          this(menu)[] -> private.MotifpopupMenu.theMenu[];
          true -> private.MotifpopupMenu.popup;
          private.MotifpopupMenu.open;
          (if (private.popupbutton=0) then 3 -> private.popupbutton if);
          '<Btn' -> menupost[];
          private.popupbutton -> menuPost.putint;
          '>' -> menupost.put;
          (XmNmenuPost, menuPost[]) -> private.MotifpopupMenu.setStringResource;
          (if private.popupevent[]=NONE then
              &XButtonEvent[] -> private.popupevent[];
              private.popupevent.init;
              XButtonPress -> private.popupevent.type;
          if);
      if);
      
      private.MotifpopupMenu.handleOnSelect;
      popupIn.widgetID -> id;
      
      (* translate to root coordinates *)
      (id,popupAt.h,popupAt.v,x_root[],y_root[]) -> XtTranslateCoords;
      x_root -> uShort2Short -> x;
      y_root -> uShort2Short -> y;
      
      (* Adjust for the popupWith item *)
      popupWith -> private.MotifpopupMenu.getItemByNumber -> theItem[];
      (if theItem[]<>None then
          y - (XtNy -> theItem.getShortResource) -> y;
      if);
      
      (* Place menu using XmMenuPosition - ensures that menu is on screen *)
      y     -> private.popupevent.y_root;
      x + 2 -> private.popupevent.x_root     (* + 2 to ensure that we are outside the item
                                              * - otherwise highlight does not work for this 
                                              * item before another has been selected
                                              *);
      (private.MotifpopupMenu.widgetID, private.popupevent) -> XmMenuPosition;
      
      (* manage menu *)
      private.MotifpopupMenu.widgetID -> XtManageChild;
      
   #)


-- GUIENVactionOnStatus: doPart --
do true -> value;
   inner onStatus;


   (*
    * menuitem
    *)




-- GUIENVmenuItemDoExpose: doPart --
do

-- GUIENVmenuItemSetKey: doPart --
do
   (#
      t: @text;
   do assertOpen;
      c -> private.key;
      this(menu).private.motifMenus.scan
      (# 
      do (position,c) -> current.setKey;
      #);
      
   #)
-- GUIENVmenuItemGetKey: doPart --
do assertOpen;
   private.key -> c;


-- GUIENVmenuItemSetName: doPart --
do assertOpen;
   
   
   t.copy -> private.name[];
   
   scanMotifMenuItems
   (# 
   do (if current[] = NONE then
          'CURRENT is NONE in scanMotifMenuItems' -> putLine;
       else
          (XmNlabelString,t[]) -> current.setMotifStringResource;
      if);
   #);


-- GUIENVmenuItemGetName: doPart --
do assertOpen;
   private.name.copy -> t[];


-- GUIENVmenuitemSetChecked: doPart --
do assertOpen;
   checked -> private.checked;
   this(menu).private.motifMenus.scan
   (# 
   do (position,checked) -> current.setChecked;
   #);

-- GUIENVmenuitemGetChecked: doPart --
do assertOpen;
   private.checked -> checked;
   


-- GUIENVsetSubMenu: doPart --
do assertOpen;
   
   (if theMenu[]<>private.theSubMenu[] then
       theMenu[] -> private.theSubMenu[];
       this(menu).private.motifMenus.scan
       (# 
       do (position,theMenu[]) -> current.setSubMenu;
       #);
   if);
   
-- GUIENVgetSubMenu: doPart --
do assertOpen;
   private.theSubMenu[] -> theMenu[];

-- GUIENVmenuItemPosition: doPart --
do
   (#    count: @integer;
   do assertOpen;
      l: scan
        (# 
        do count + 1 -> count;
           (if THIS(menuitem)[]=current[] then
               leave l;
           if);
        #);
      count -> value;
      trace
      (# 
      do (if count=0 then
             'menuitem.position: the menuitem was not found in the menu' -> putLine;
         if);
      #);
   #)

-- GUIENVmenuitemCreate: doPart --
do inner create;


-- GUIENVmenuitemOpen: doPart --
do this(menuitem)[] -> getPatternName -> private.name[];
   inner open;





-- GUIENVmenuItemOnStatus: doPart --
do true -> value;
   inner onStatus;


-- GUIENVmenuItemAttach: doPart --
do assertOpen;
   (if theAction[]<>none then
       none -> theAction.theMenuitem[];
   if);
   anAction[] -> theAction[];
   (if theAction[]<>none then
       THIS(dynamicMenuitem)[] -> theAction.theMenuitem[];
   if);

-- GUIENVmenuItemDetach: doPart --
do assertOpen;
   (if theAction[]<>none then
       none -> theAction.theMenuitem[];
   if);
   none -> theAction[];

-- GUIENVdynamicMenuItemOnStatus: doPart --
do (if theAction[]=none then
       false -> value;
    else
       theAction.onStatus -> value;
   if);

-- GUIENVdynamicMenuItemOnSelect: doPart --
do (if theAction[]<>none then
       theAction.onSelect;
   if);


-- GUIENVmouseGlobalPosition: doPart --
do
   (# info: ^mouseInfo;
   do display -> XDefaultRootWindow -> getMouseInfo -> info[];
      info.global -> pt;
   #)

-- GUIENVmouseButtonState: doPart --
do
   (# info: ^mouseInfo;
   do display -> XDefaultRootWindow -> getMouseInfo -> info[];
      info.button -> value;
   #)

-- GUIENVmouseTheCursorSet: doPart --
do
   (# cursorID: @integer;
   do (if theCur[]=none then
          0 -> cursorID;
       else
          theCur.private.ID -> cursorID;
      if);
      this(guienv).private.windows.scan
      (# displayID,windowID: @integer;
      do current.displayID -> displayID;
         current.windowID -> windowID;
         (displayID,windowID,cursorID) -> XDefineCursor;
         current.widgetID -> XmUpdateDisplay;
      #);
      theCur[] -> private.busyCursor[]
   #)

-- GUIENVmouseTheCursorGet: doPart --
do private.busyCursor[] -> theCur[];



-- GUIENVsystemScreenRectangle: doPart --
do
   (# rootID: @integer;
      displayID: @integer;
      ignore_root,x,y,width,height,ignore_border,ignore_depth: @integer;
   do display -> displayID;
      displayID -> XDefaultRootWindow -> rootID;
      (displayID,rootID,@@ignore_root,@@x,@@y,@@width,@@height,@@ignore_border,@@ignore_depth)
        -> XGetGeometry;
      (x,y) -> theRectangle.topLeft;
      (width,height) -> theRectangle.size;
   #)
-- GUIENVsystemScreenRgn: doPart --
do &region[] -> rgn[];
   rgn.allocate;
   screenRectangle -> rgn.setFromrectangle;

-- GUIENVsystemBeepBody: doPart --
do (private.display, 100) -> XBell;

-- GUIENVsystemWaitBody: doPart --
do
   (# timeVal: data
        (# tv_sec: @integer;
           tv_usec: @integer;
        #);
      select: external
        (# nfds, readfds, writefds, exceptfds: @integer;
           timeout: ^timeVal;
           result: @integer;
        enter (nfds, readfds, writefds, exceptfds, timeout[])
        exit result
        #);
      tv: @timeVal;
   do ticks div 60 -> tv.tv_sec;
      ticks mod 60 -> tv.tv_usec;
      (0, 0, 0, 0, tv[]) -> select;
   #)

-- textStyleLib: attributes --
gettextwidth: external
  (# buffer: @integer;
     count: @integer;
     fontStruct: @integer;
     width: @integer;
  enter (buffer,count,fontStruct)
  exit width
  #);

-- GUIENVtextStyleAscent: doPart --
do
   (# info: ^fontInfo;
   do allocate;
      getFontInfo -> info[];
      info.ascent -> value;
   #)
-- GUIENVtextStyleDescent: doPart --
do
   (# info: ^fontInfo;
   do allocate;
      getFontInfo -> info[];
      info.descent -> value;
   #)
-- GUIENVtextStyleLeading: doPart --
do 0 -> value;

-- GUIENVtextStyleHeight: doPart --
do
   (# info: ^fontInfo;
   do allocate;
      getFontInfo -> info[];
      info.descent + info.ascent -> value;
   #)
-- GUIENVtextStyleMaxChWidth: doPart --
do
   (# getcharinfo: external
        (# width: @integer;
           fontStruct: @integer;
        enter fontStruct
        exit width
        #);
   do allocate;
      private.fontStruct -> getcharinfo -> value;
   #)
-- GUIENVtextStyleWidthOfChar: doPart --
do allocate;
   (@@ch,1,private.fontStruct) -> gettextwidth -> value;

-- GUIENVtextStyleStringWidth: doPart --
do
   (# length: @integer;
   do allocate;
      str.length -> length;
      (if length > 0 then
          (@@str.T[1],length,private.fontStruct) -> gettextwidth -> value;
       else
          0 -> value;
      if);
   #)
-- GUIENVtextStyleSetName: doPart --
do (if not (theName[] -> private.name.equalNCS) then
       theName -> private.name;
       dispose;
   if);

-- GUIENVtextStyleGetName: doPart --
do private.name.copy -> theName[];


-- GUIENVtextStyleSetSize: doPart --
do (if value<>private.size then
       value -> private.size;
       dispose;
   if);


-- GUIENVtextStyleGetSize: doPart --
do private.size -> value;


-- GUIENVtextStyleSetFace: doPart --
do (if value<>private.face then
       value -> private.face;
       dispose;
   if);


-- GUIENVtextStyleGetFace: doPart --
do private.face -> value;



-- GUIENVtextStyleFamilySizes: doPart --
do



-- windowLib: attributes --

handleDeleteWindow: callbackSelector
  (# 
  do (if theEventHandler.onAboutToClose then
         this(window).close;
     if);
  #);
deleteWindowProcessor: callbackProcessor
  (# 
  do &handleDeleteWindow[] -> cb[];
  #);

handleWindowFocusChanged: focusChangeEventSelector
  (# (* notify modes *)
     NotifyNormal: (# exit 0 #);
     NotifyGrab: (# exit 1 #);
     NotifyUngrab: (# exit 2 #);
     NotifyWhileGrabbed: (# exit 3 #);
     
     (* Notify detail *)
     NotifyAncestor: (# exit 0 #);
     NotifyVirtual: (# exit 1 #);
     NotifyInferior: (# exit 2 #);
     NotifyNonlinear: (# exit 3 #);
     NotifyNonlinearVirtual: (# exit 4 #);
     NotifyPointer: (# exit 5 #);
     NotifyPointerRoot: (# exit 6 #);
     NotifyDetailNone: (# exit 7 #);
     
  do (* WidgetId -> putint; ' '->put;
      *      'handleWindowFocusChanged: mode, detail, type: '->puttext;
      *      mode -> putint; ' '->put;
      *      detail -> putint; ' '->put;
      *      type -> putint; ' '->put;
      *      newline;
      *)
     (* (if mode
      *       // NotifyNormal 
      *       // NotifyUngrab then
      *          (if detail
      *           // NotifyAncestor
      *           // NotifyPointer
      *           // NotifyVirtual
      *           // NotifyNonLinear
      *           // NotifyNonLinearVirtual then
      *              (if type
      *               // XFocusIn then
      *                  theEventHandler.onActivate;
      *               // XFocusOut then
      *                  theEventHandler.onDeactivate;
      *               else
      *                  {* WidgetId -> putint; ' '->put;
      *                   * 'handleWindowFocusChanged: type='->puttext; type->putint; newline;
      *                   *}
      *              if);
      *           else
      *              {* WidgetId -> putint; ' '->put;
      *               * 'handleWindowFocusChanged: detail='->puttext; detail->putint; newline;
      *               *}
      *          if);
      *       else
      *          {* WidgetId -> putint; ' '->put;
      *           * 'handleWindowFocusChanged: mode='->puttext; mode->putint; newline;
      *           *}
      *      if);
      *)
     (if type=XFocusIn then
         theEventHandler.onActivate;
      else
         theEventHandler.onDeactivate;
     if); 
  #);
focusChangeEventProcessor: eventProcessor
  (# 
  do &handleWindowFocusChanged[] -> es[];
  #);
handleContentsResize: configureEventSelector
  (# 
  do (if type=XConfigureNotify then
         adjustContents;
     if);
  #);
configureEventProcessor: eventProcessor
  (# 
  do &handleContentsResize[] -> es[];
  #);

appendMenubar:
  (# theMenubar: ^menubar;
     theMotifMenubar: ^motifMenubar;
  enter theMenubar[]
  do private.theMotifMenubar[] -> theMotifMenubar[];
     (if theMotifMenubar[]=none then
         &motifMenubar[] -> theMotifMenubar[];
         this(window)[] -> theMotifMenubar.theWindow[];
         theMotifMenubar.open;
         theMotifMenubar[] -> private.theMotifMenubar[];
     if);
     theMenubar.scan
     (# 
     do current[] -> theMotifMenubar.append;
     #);
     this(window)[] -> theMenubar.private.windows.append;
  #);
hasWindow: booleanValue
  (#
  do (widgetID -> XtWindow) <> 0 -> value;
  #);
resizeMenubar:
  (# itsHeight,itsBorderWidth: @integer;
     width,height: @integer;
  do 
     (if private.theMenubar[]<>none then
         size -> (width,height);
         XtNborderWidth -> private.theMenubar.getShortResource -> itsBorderWidth;
         XtNheight -> private.theMenubar.getShortResource -> itsHeight;
         (private.theMenubar.widgetID,width,itsHeight,itsBorderWidth)
           -> XtResizeWidget;
     if);
  #);

-- GUIENVwindowadjustContents: doPart --
do assertOpen
   (# width,height: @integer;
   do XtNwidth -> private.contentsForm.getShortResource -> width;
      XtNheight -> private.contentsForm.getShortResource -> height;
      
      (if private.theMotifMenubar[]=none then
          (0,0) -> private.contents.position;
          (width,height) -> private.contents.size;
       else
          (0,menubarHeight) -> private.contents.position;
          true -> SetAnswer;
          (XtNwidth,width) -> private.theMotifMenubar.setIntegerResource;
          false -> SetAnswer;
          (width,height-menubarHeight) -> private.contents.size;
      if);
      
   #);
   
-- GUIENVwindowOnActivate: doPart --
do private.contents.theEventHandler.onActivate;
   inner onActivate;


-- GUIENVwindowOnDeactivate: doPart --
do private.contents.theEventHandler.onDeactivate;
   inner onDeactivate;


-- GUIENVwindowSetTheMenubar: doPart --
do
   (# 
      theMotifMenubar: ^motifMenubar;
      applMenubar: ^menubar;
   do assertOpen;
      (if theBar[]<>private.theMenubar[] then
          (* (if private.theMenubar[]<>none then
           *            private.theMotifMenubar.close;
           *            none -> private.theMotifMenubar[];
           *        if);
           *)
          (if theBar[]=none then
              (if private.theMenubar[]<>none then
                  (if menubarVisible then
                      private.theMenubar.scan
                      (# 
                      do current[] -> private.theMotifMenubar.delete;
                      #);
                  if);
                  none -> private.theMenubar[];
              if);
           else
              theBar[] -> private.theMenubar[];
              (if menubarVisible then
                  theBar[] -> appendMenubar;
              if);
          if);
      if);
   #)
-- GUIENVwindowGetTheMenubar: doPart --
do assertOpen;
   private.theMenubar[] -> theBar[];


-- GUIENVwindowSetTitle: doPart --
do assertOpen;
   (XtNtitle,theTitle[]) -> setStringResource;

-- GUIENVwindowGetTitle: doPart --
do assertOpen;
   XtNtitle -> getStringResource -> theTitle[];

-- GUIENVwindowSetPosition: doPart --
do
   (# 
      (* geometry: @text(# p: @put; pi: @putint #); *)
   do assertOpen;
      (* This does not convince certain window managers.*)
      (XtNx,pt.h) -> setIntegerResource;
      (XtNy,pt.v) -> setIntegerResource;
      
      (* But this does not work?
       * '+'->geometry.p;
       * pt.h->geometry.pi;
       * '+'->geometry.p;
       * pt.v->geometry.pi;
       * 'geometry: '->puttext; geometry[]->putline;
       * (XtNgeometry, geometry[]) -> setStringResource;
       *)
   #)
-- GUIENVwindowGetPosition: doPart --
do
   (# 
      x,y: @shortRef;
   do assertOpen;
      (widgetID,0,0,x[],y[]) -> XtTranslateCoords;
      
      x -> uShort2Short -> pt.h;
      y -> uShort2Short -> pt.v;
   #)
-- GUIENVwindowSetSize: doPart --
do
   (# 
      h: @integer;
   do assertOpen;
      (if private.theMotifMenubar[]=none then
          height -> h;
       else
          height + menubarHeight -> h;
      if);
      (XtNwidth,width) -> setIntegerResource;
      (XtNheight,h) -> setIntegerResource;
      (XtNwidth,width) -> private.contentsForm.setIntegerResource;
      (XtNheight,h) -> private.contentsForm.setIntegerResource;
      adjustContents;
   #)
-- GUIENVwindowGetSize: doPart --
do assertOpen;
   private.contents.size -> (width,height);

-- GUIENVwindowSetFrame: doPart --
do theFrame.topLeft -> position;
   theFrame.size -> size;

-- GUIENVwindowGetFrame: doPart --
do position -> theFrame.topLeft;
   size -> theFrame.size;

-- GUIENVwindowInsideRectangle: doPart --
do size -> theRectangle.bottomRight;


-- GUIENVshowWindow: doPart --
do assertOpen;
   
   widgetID -> XtMapWidget;
   true -> private.visible;

-- GUIENVwindowShowModal: doPart --
do assertOpen;
   (if not private.isModal then
       true -> private.isModal;
       (XmNmwmInputMode,MWM_INPUT_PRIMARY_APPLICATION_MODAL) 
         -> setIntegerResource;
       show;
       bringToFront;
       (widgetID,true,true) -> XtAddGrab;
       l: 
         (if private.isModal then
             (this(guienv).private.appCon,XtIMAll) -> XtAppProcessEvent;
             restart l;
         if);
   if);

-- GUIENVhideWindow: doPart --
do assertOpen;
   (if private.isModal then
       false -> private.isModal;
       widgetID -> XtRemoveGrab;
       (XmNmwmInputMode,MWM_INPUT_MODELESS) -> setIntegerResource;
   if);
   widgetID -> XtUnmapWidget;
   false -> private.visible;


-- GUIENVwindowSetMaxSize: doPart --
do assertOpen;
   (if widgetID<>0 then
       (XtNmaxWidth,width) -> setIntegerResource;
       (XtNmaxHeight,height) -> setIntegerResource;
   if);

-- GUIENVwindowGetMaxSize: doPart --
do assertOpen;
   (if widgetID<>0 then
       XtNmaxWidth  -> getIntegerResource -> width;
       XtNmaxHeight  -> getIntegerResource -> height;
   if);

-- GUIENVwindowSetMinSize: doPart --
do assertOpen;
   (if widgetID<>0 then
       (XtNminWidth,width) -> setIntegerResource;
       (XtNminHeight,height) -> setIntegerResource;
   if);

-- GUIENVwindowGetMinSize: doPart --
do assertOpen;
   (if widgetID<>0 then
       XtNminWidth  -> getIntegerResource -> width;
       XtNminHeight  -> getIntegerResource -> height;
   if);

-- GUIENVwindowBringToFront: doPart --
do assertOpen;
   (if widgetID<>0 then
       (widgetID -> XtDisplay,widgetID -> XtWindow) -> XRaiseWindow;
   if);

-- GUIENVwindowBringToBack: doPart --
do assertOpen;
   (if widgetID<>0 then
       (widgetID -> XtDisplay,widgetID -> XtWindow) -> XLowerWindow;
   if);

-- GUIENVwindowBringBehind: doPart --
do
   (# 
      windowIDs: [2] @integer;
      displayID: @integer;
   do assertOpen;
      (if widgetID<>0 then
          widgetID -> XtWindow -> windowIDs[2];
          widgetID -> XtDisplay -> displayID;
          (if theWindow[]<>none then
              (if theWindow.widgetID<>0 then
                  theWindow.widgetID -> XtWindow -> windowIDs[1];
                  (displayID,@@windowIDs[1],2) -> XRestackWindows;
              if);
          if);
      if);
   #)
-- GUIENVwindowUpdate: doPart --
do assertOpen;
   immediate -> private.contents.update;

-- GUIENVwindowCreate: doPart --
do
   (# args: @argList;
      XtAppCreateShell: external
        (# name: [1] @char;
           class: [1] @char;
           widgetClass: @integer;
           display: @integer;
           args: ^argList;
           nArgs: @integer;
           newWidget: @integer;
        enter (name,class,widgetclass,display,args[],nArgs)
        do callC
        exit newWidget
        #);
      ID: @integer;
   do inner create;
      (if widgetID=0 then
          (1,XtNwidth,300) -> args.set;
          (2,XtNheight,200) -> args.set;
          (this(guienv).private.appName,
          this(guienv).private.appClass,
          TopLevelShellWidgetClass,
          display,
          args[],
          2) -> XtAppCreateShell -> ID;
          ID -> widgetID;
          (widgetID,false) -> XtSetMappedWhenManaged;
          widgetID -> XtRealizeWidget;
      if);
   #)
-- GUIENVwindowOpen: doPart --
do
   (# parent,contentsWidget: @widget;
      aMenubar: ^menubarType;
      applMenubar: ^menubar;
      args: @argList;
      SetWindowDeleteAction: external
        (# shell: @integer;
           callback: @integer;
        enter (shell, callback)
        #);
      callbackAddress: @integer;
   do this(window)[] -> getPatternName -> title;
      (1,XtNwidth,300) -> args.set;
      (2,XtNheight,200) -> args.set;
      ('contentsform'->appendtick,XbCanvasWidgetClass,widgetID,args[],2) -> XtCreateManagedWidget 
        -> private.contentsForm.widgetID;
      (configureEventProcessor##, XStructureNotifyMask) -> appendEventProcessor;
      (focusChangeEventProcessor##, XFocusChangeMask) -> appendEventProcessor;
      deleteWindowProcessor## -> makeCBF -> callbackAddress;
      (widgetID, callbackAddress) -> SetWindowDeleteAction;
      callbackAddress -> addCBF;
      (XmNdeleteResponse, XmDO_NOTHING) -> setIntegerResource;
      true -> private.visible;
      THIS(window)[] -> this(guienv).private.windows.append;
      private.contents.open;
      private.contents.widgetID -> contentsWidget;
      (if menubarVisible then
          applicationMenubar -> applMenubar[];
          (if applMenubar[]<>none then
              applMenubar[] -> appendMenubar;
          if);
      if);
      &menubarType[] -> aMenubar[];
      (if aMenubar## <> menubar## then
          aMenubar.open;
          aMenubar[] -> theMenubar;
      if);
      (XtNwidth,300) -> setIntegerResource;
      (XtNheight,200) -> setIntegerResource;
      INNER open;
      (if private.visible then
          (if THIS(interfaceobject).private.isOpen then
              widgetID -> XtMapWidget;
           else
              (* closed in INNER, e.g. via a showmodal *)
          if)
      if);
   #)



-- GUIENVwindowClose: doPart --
do assertOpen;
   inner close;
   widgetID -> XtUnmapWidget;
   (if (private.themenubar[]<>none) then
       THIS(window)[] -> private.themenubar.private.windows.at 
         -> private.themenubar.private.windows.delete;
       private.theMotifMenubar.close;
       none -> private.theMotifMenubar[];
       none -> private.themenubar[];
   if);
   private.contents.close;
   0 -> private.contentsForm.widgetID;
   (if private.isModal then
       false -> private.isModal;
       widgetID -> XtRemoveGrab;
   if);
   widgetID -> DestroyWidget;
   THIS(window)[] -> this(guienv).private.windows.at 
     -> this(guienv).private.windows.delete;



-- GUIENVwindowSetTarget: doPart --
do
   (# 
      XmIsTraversable: external
        (# w: @integer;
           result: @integer;
        enter w
        exit result
        #);

      result: @integer;
   do (if theTarget[]=None then
          (private.contents.widgetID,XmTRAVERSE_CURRENT) ->  XmProcessTraversal;
       else
          theTarget.widgetID -> XmIsTraversable -> result;
          (if result <> 0 then
              (* Kald en exception eller hvad ??? *)
          if);
          (theTarget.widgetID,XmTRAVERSE_CURRENT) ->  XmProcessTraversal -> result;
          (if result <> 0 then
              (* Kald en exception eller hvad ??? *)
          if);
      if);
   #)
-- GUIENVwindowGetTarget: doPart --
do private.theTarget[] -> theTarget[];


-- windowitemLib: attributes --

exposeProcessor: eventProcessor
  (# 
  do &refreshSelector[] -> es[];
  #);
buttonPressProcessor: eventProcessor
  (# 
  do &mouseDownSelector[] -> es[];
  #);
buttonReleaseProcessor: eventProcessor
  (# 
  do &mouseUpSelector[] -> es[];
  #);
keyPressProcessor: eventProcessor
  (# 
  do &keyDownSelector[] -> es[];
  #);
focusChangeProcessor: eventProcessor
  (# 
  do &selectTarget[] -> es[];
  #);

refreshSelector: exposeEventSelector
  (# 
  do ((x, y), (x + width, y + height)) -> this(guienv).private.updateRectAdd;
     (if count=0 then
         this(guienv).private.updateRectFlush;
         
         theEventHandler.onRefresh;
     if);
  #);

handleMouseDown:
  (# 
  do 
     (if private.delegate then
         (if father[] <> none then
             this(guienv).private.x + private.left 
               -> this(guienv).private.x;
             this(guienv).private.y + private.top 
               -> this(guienv).private.y;
             father.handleMouseDown;
         if);
      else
         theEventHandler.onMouseDown;
     if);
  #);
mouseDownSelector: buttonEventSelector
  (# 
  do handleMouseDown;
  #);

handleMouseUp:
  (# 
  do 
     (if private.delegate then
         (if father[] <> none then
             this(guienv).private.x + private.left 
               -> this(guienv).private.x;
             this(guienv).private.y + private.top 
               -> this(guienv).private.y;
             father.handleMouseUp;
         if);
      else
         theEventHandler.onMouseUp;
     if);
  #);
mouseUpSelector: buttonEventSelector
  (# 
  do handleMouseUp;
  #);
keyDownSelector: KeyEventSelector
  (# 
  do theEventHandler.onKeyDown;
  #);


selectTarget: focusChangeEventSelector
  (# 
  do (if type=XFocusIn then
         this(windowitem)[] -> theTarget;
         theEventHandler.onEnableTarget;
      else
         theEventHandler.onDisableTarget;
         none -> theTarget;
     if);
  #);
handleConfigure: configureEventSelector
  (# 
  do (if type=XConfigureNotify then
         (if not this(windowItem).private.frameChangedHandled then
             (frame,getFrame) -> handleframeChanged;
         if);
         false -> this(windowItem).private.frameChangedHandled;
     if);
  #);
configureProcessor: eventProcessor
  (# 
  do &handleConfigure[] -> es[];
  #);

handleFatherframeChanged:
  (# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
  enter (oldFrame,newFrame)
  do newFrame.size -> delta;
     oldFrame.size -> delta.subTract;
     (if not ((0,0) -> delta.isEqual) then
         frame -> chainRect -> itsFrame;
         delta -> chainRect.offset;
         (if not bindLeft then
             chainRect.left -> itsFrame.left;
         if);
         (if bindBottom then
             chainRect.bottom -> itsFrame.bottom
         if);
         (if bindRight then
             chainRect.right -> itsFrame.right
         if);
         (if not bindTop then
             chainRect.top -> itsFrame.top
         if);
         itsFrame -> frame;
     if);
     (oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
  #);

-- GUIENVwindowItemHandleFrameChanged: doPart --
do (# thisCanvas: ^canvas;
   do (if not (oldFrame -> newFrame.isEqual) then
          newFrame.left -> private.left;
          newFrame.right -> private.right;
          newFrame.bottom -> private.bottom;
          newFrame.top -> private.top;
          (oldFrame,newFrame) -> theEventHandler.onframeChanged;
          (if father[]<>none then
              (oldFrame,newFrame) -> father.handleChildframeChanged;
          if);
          (if this(windowitem)## <= canvas## then
              this(windowitem)[] -> thisCanvas[];
              thisCanvas.private.children.scan
              (# 
              do (oldFrame,newFrame) -> current.handleFatherframeChanged;
              #);
           else
              (if widgetID=0 then
                  (# 
                  do (father.displayID,father.windowID,
                     oldFrame.left,oldFrame.top,
                     oldFrame.right - oldFrame.left,oldFrame.bottom - oldFrame.top,
                     1) -> XClearArea;
                     (father.displayID,father.windowID,
                     newFrame.left,newFrame.top,
                     newFrame.right - newFrame.left,newFrame.bottom - newFrame.top,
                     1) -> XClearArea;
                  #);
              if);
          if);
      if);
   #)

-- GUIENVwindowitemOnRefresh: doPart --
do
   (# xmType: @integer;
      topGC: @integer;
      bottomGC: @integer;
      width,height: @integer;
      x,y: @integer;
      drawable: @integer;
   do inner onRefresh;
      (if border.visible then
          father.widgetID -> GetTopShadowGC -> topGC;
          father.widgetID -> GetBottomShadowGC -> bottomGC;
          size -> (width,height);
          (if border.style
           //borderStyles.simple then XmSHADOW_IN -> xmType;
           //borderStyles.shadowIn then XmSHADOW_IN -> xmType;
           //borderStyles.shadowOut then XmSHADOW_OUT -> xmType;
           //borderStyles.etchedIn then XmSHADOW_ETCHED_IN -> xmType;
           //borderStyles.etchedOut then XmSHADOW_ETCHED_OUT -> xmType;
          if);
          (if widgetID=0 then
              position -> (x,y);
              father.windowID -> drawable;
              (display,drawable,topGC,bottomGC,x,y,width,height,2,xmType) -> _XmDrawShadows;
           else
              windowID -> drawable;
              (display,drawable,topGC,bottomGC,0,0,width,height,2,xmType) -> _XmDrawShadows;
          if);
      if);
   #)

-- GUIENVwindowitemSetFrame: doPart --
do
   (# 
      oldFrame: @rectangle;
      h,v,width,height: @integer;
   do assertOpen;
      frame -> oldFrame;
      (if not (theFrame -> oldFrame.isEqual) then
          theFrame.topLeft -> (h,v);
          theFrame.size -> (width,height);
          (if widgetID<>0 then
              true -> SetAnswer;
              (XtNx,h) -> setIntegerResource;
              (XtNy,v) -> setIntegerResource;
              (XtNwidth,width) -> setIntegerResource;
              (XtNheight,height) -> setIntegerResource;
              false -> SetAnswer;
          if);
          (oldFrame,theFrame) -> handleFrameChanged;
          true -> private.frameChangedHandled;
      if);
   #)

-- GUIENVwindowitemGetFrame: doPart --
do assertOpen;
   private.left-> theFrame.left;
   private.right -> theFrame.right;
   private.top -> theFrame.top;
   private.bottom -> theFrame.bottom;
   

-- GUIENVwindowitemSetPosition: doPart --
do
   (# 
      theFrame: @rectangle;
   do assertOpen;
      pt -> theFrame.topLeft;
      size -> theFrame.size;
      theFrame -> frame;
   #)
-- GUIENVwindowitemGetPosition: doPart --
do assertOpen;
   private.left -> pt.h;
   private.top -> pt.v;

-- GUIENVwindowitemMove: doPart --
do
   (# 
      pt: @point;
   do assertOpen;
      position -> pt;
      (dh,dv) -> pt.add;
      pt -> position;
   #)
-- GUIENVwindowitemSetSize: doPart --
do
   (# 
      theFrame: @rectangle;
   do assertOpen;
      position -> theFrame.topLeft;
      (width,height) -> theFrame.size;
      theFrame -> frame;
   #)

-- GUIENVwindowitemGetSize: doPart --
do assertOpen;
   private.right - private.left -> width;
   private.bottom - private.top -> height;


-- GUIENVwindowitemSetVisible: doPart --
do assertOpen;
   (if value<>private.visible then
       value -> private.visible;
       (if widgetID <> 0 then
           (if value then
               widgetID -> XtMapWidget;
            else
               widgetID -> XtUnmapWidget;
           if);
        else
           update;
       if);
       theEventHandler.onVisibleChanged;
   if);


-- GUIENVwindowitemGetVisible: doPart --
do assertOpen;
   private.visible -> value;


-- GUIENVwindowitemSetHilite: doPart --
do assertOpen;
   value -> private.hilite;
   theEventHandler.onHiliteChanged;


-- GUIENVwindowitemGetHilite: doPart --
do assertOpen;
   private.hilite -> value;


-- GUIENVwindowitemSetEnabled: doPart --
do assertOpen;
   (if value=enabled then
       (* not changed *)
    else
       (if widgetID <> 0 then
           (if value then
               (widgetID,1) -> XtSetSensitive;
            else
               (widgetID,0) -> XtSetSensitive;
           if);
       if);
       theEventHandler.onEnabledChanged;
   if);


-- GUIENVwindowitemGetEnabled: doPart --
do assertOpen;
   (if widgetID <> 0 then
       widgetID -> XtIsSensitive -> value;
   if);


-- GUIENVwindowitemShow: doPart --
do assertOpen;
   true -> visible;

-- GUIENVwindowitemHide: doPart --
do assertOpen;
   false -> visible;

-- GUIENVwindowitemEnable: doPart --
do assertOpen;
   true -> enabled;

-- GUIENVwindowitemDisable: doPart --
do assertOpen;
   false -> enabled;


-- windowItemEnterBackgroundColor: doPart --
do assertOpen;
   (# pixel: @integer;
      theXColor: @XColor;
      dpy: @integer;
      cmap: @integer;
      screen: @integer;
      result: @integer;
   do theColor.red -> theXColor.red;
      theColor.green -> theXColor.green;
      theColor.blue -> theXColor.blue;
      
      displayID -> dpy;
      
      dpy -> XDefaultScreen -> screen;
      (dpy, screen) -> XDefaultColorMap -> cmap;
      
      (dpy, cmap, theXColor[]) -> XAllocColor -> result;
      (if result = 0 then
          'XAllocColor failed in "windowItem.backgroundColor"' -> putLIne;
       else
          theXColor.pixel -> pixel;
          
          (if widgetID <> 0 then
              (XtNbackground, pixel) -> setIntegerResource;
          if);
      if)
   #);
   
-- windowItemExitBackgroundColor: doPart --
do assertOpen;
   (# pixel: @integer;
      theXColor: @XColor;
      dpy: @integer;
      colorMap: @integer;
   do (if widgetID = 0 then
          XtNbackground -> father.getIntegerResource -> pixel;
          XtNcolorMap -> father.getIntegerResource -> colorMap;
       else
          XtNbackground -> getIntegerResource -> pixel;
          XtNcolorMap -> getIntegerResource -> colorMap;
      if);
      pixel -> theXColor.pixel;
      displayID -> dpy;
      (dpy, colorMap, theXColor[]) -> XQueryColor;
      theXColor.red -> theColor.red;
      theXColor.green -> theColor.green;
      theXColor.blue -> theColor.blue;
   #);
   
-- GUIENVwindowitemBorderSetVisible: doPart --
do value -> private.borderVisible;
   theEventHandler.onBorderVisibleChanged;
   true -> update;

-- GUIENVwindowitemBorderGetVisible: doPart --
do private.borderVisible -> value;

-- GUIENVwindowitemBorderSetStyle: doPart --
do value -> private.borderStyle;
   theEventHandler.onBorderStyleChanged;
   true -> update;

-- GUIENVwindowitemBorderGetStyle: doPart --
do private.borderStyle -> value;

-- GUIENVwindowiteminsideRectangle: doPart --
do ((0,0),size) -> theRectangle;
   (if border.visible then
       (2,2) -> theRectangle.inset;
   if);
   
-- GUIENVwindowitemSetTheCursor: doPart --
do
   (# 
      id: @integer;
   do assertOpen;
      theCur[] -> private.theCursor[];
      (if theCur[]=none then
          0 -> ID;
       else
          theCur.private.id -> ID;
      if);
      (displayID, windowID, ID)
        -> XDefineCursor;
      theEventHandler.onTheCursorChanged;
      (if widgetID <> 0 then
          widgetID -> XmUpdateDisplay;
      if);
   #)
-- GUIENVwindowitemGetTheCursor: doPart --
do private.theCursor[] -> theCur[];


-- GUIENVwindowItemTrackMouse: doPart --
do
   (# info: ^mouseInfo;
      theWindow: @integer;
   do (if widgetID <> 0 then
          widgetID -> XtWindow -> theWindow;
          theWindow -> mouse.getMouseInfo -> info[];
          info.local -> curPt -> prevPt;
          mousePress;
          l: (if info.button<>0 then
                 info.local -> curPt;
                 (if (not (curPt -> prevPt.isEqual)) then
                     (curPt.h - prevPt.h,curPt.v - prevPt.v) -> mouseMove;
                     curPt -> prevPt;
                 if);
                 theWindow -> mouse.getMouseInfo -> info[];
                 restart l;
             if);
          mouseRelease;
      if);
   #)

-- GUIENVwindowitemDrag: doPart --
do father.graphics
   (# r: @rectangle;
   do transferModes.xorBlend -> pen.mode;
      father.trackMouse
      (# r: @rectangle;
         mousePress::<
           (# 
           do frame -> r;
              r -> drawRect;
           #);
         mouseMove::<
           (# 
           do (if ((h<>0) or (v<>0)) then
                  r -> drawRect;
                  (h,v) -> r.offset;
                  r -> drawRect;
              if);
           #);
         mouseRelease::<
           (# 
           do r -> drawRect;
              r -> frame;
           #);
      #);
   #);

-- GUIENVwindowitemResize: doPart --
do
   (#
      newFrame: @rectangle;
      w,h: @Integer;
   do frame -> father.defineRect1 -> newFrame;
      newFrame.size -> (w,h);
      (w,1) -> max -> w;
      (h,1) -> max -> h;
      (w,h) -> newFrame.size;
      newFrame -> frame;
   #)

-- GUIENVwindowitemUpdate: doPart --
do assertOpen;
   (if widgetID=0 then
       (# f: @rectangle;
       do frame -> f;
          (father.displayID,father.windowID,
          f.left,f.top,
          f.right - f.left + 1,f.bottom - f.top + 1,
          1) -> XClearArea;
          (if immediate then
              father.widgetID -> XmUpdateDisplay;
          if);
       #);
    else
       (displayID,windowID,0,0,0,0,1) -> XClearArea;
       (if immediate then
           widgetID -> XmUpdateDisplay;
       if);
   if);


-- GUIENVwindowitemCreate: doPart --
do
   (# origin: ^object;
      args: @argList;
      a2o: @addressToObject;
   do true -> private.needsWidget;
      (if father[]=none then
          THIS(windowitem)[] -> getOrigin -> origin[];
          l:
            (if origin[]=none then
                (if THIS(windowitem)[]<>THIS(window).private.contents[] then
                    THIS(window).private.contents[] -> father[];
                if);
             else 
                (if (origin## <= canvas##) then 
                    origin[] -> father[];
                 else 
                    origin[] -> getOrigin -> origin[];
                    restart l;
                if)
            if);
      if);
      inner create;
      
      (if widgetID=0 then
          (if private.needsWidget then
              (xmDrawingAreaWidgetClass,father.widgetID) -> createSimple;
          if);
      if);
   #)

-- GUIENVwindowitemOpen: doPart --
do
   (# frameHitMethod: hitMethod
        (# f: @rectangle;
        do frame -> f;
           p -> f.containsPoint -> value;
        #);
      f: @rectangle;
   do true -> private.visible;
      false -> private.hilite;
      (if father[]<>none then
          this(windowitem)[] -> father.appendChild;
      if);
      true -> bindLeft -> bindTop;
      false -> private.borderVisible;
      borderStyles.simple -> private.borderStyle;
      (if widgetID<>0 then
          getFrame -> f;
          f.left -> private.left;
          f.right -> private.right;
          f.bottom -> private.bottom;
          f.top -> private.top;
          (exposeProcessor##, XExposureMask) -> appendEventProcessor;
          (configureProcessor##, XStructureNotifyMask) -> appendEventProcessor;
          (keyPressProcessor##, XKeyPressMask) -> appendEventProcessor;
          (focusChangeProcessor##, XFocusChangeMask) -> appendEventProcessor;
          (buttonPressProcessor##, XButtonPressMask) -> appendEventProcessor;
          (buttonReleaseProcessor##, XButtonReleaseMask) 
            -> appendEventProcessor -> private.mouseUpProcessorAddress;
       else
          100 -> private.right;
          100 -> private.bottom;
          frameHitMethod## -> private.hit##;
      if);
      inner open;
   #)

-- GUIENVwindowitemClose: doPart --
do assertOpen;
   inner close;
   (if father[]<>none then
       this(windowitem)[] -> father.selection.remove;
       this(windowitem)[] -> father.deleteChild;
   if);
   widgetID -> DestroyWidget;
   none -> private.theCursor[];



-- GUIENVstandardMenubarOpen: doPart --
do &fileMenu[] -> theFileMenu[];
   (if theFileMenu## <> menu## then
       theFileMenu.open;
       theFileMenu[] -> append;
    else
       none -> theFileMenu[];
   if);
   &editMenu[] -> theEditMenu[];
   (if theEditMenu## <> menu## then
       theEditMenu.open;
       theEditMenu[] -> append;
    else
       none -> theEditMenu[];
   if);
   inner open;


-- GUIENVstandardFileMenuOpen: doPart --
do 'File' -> name;
   newMenuitem.open;
   'New' -> newMenuitem.name;
   newMenuitem[] -> append;
   openMenuitem.open;
   'Open' -> openMenuitem.name;
   openMenuitem[] -> append;
   closeMenuitem.open;
   'Close' -> closeMenuitem.name;
   closeMenuitem[] -> append;
   saveMenuitem.open;
   'Save' -> saveMenuitem.name;
   saveMenuitem[] -> append;
   saveAsMenuitem.open;
   'Save as' -> saveAsMenuitem.name;
   saveAsMenuitem[] -> append;
   revertMenuitem.open;
   'Revert' -> revertMenuitem.name;
   revertMenuitem[] -> append;
   printMenuitem.open;
   'Print' -> printMenuitem.name;
   printMenuitem[] -> append;
   pageSetupMenuitem.open;
   'Page setup' -> pageSetupMenuitem.name;
   pageSetupMenuitem[] -> append;
   quitMenuitem.open;
   'Quit' -> quitMenuitem.name;
   quitMenuitem[] -> append;
   inner open;

-- GUIENVstandardEditMenuOpen: doPart --
do 'Edit' -> name;
   undoMenuItem.open;
   'Undo' -> undoMenuItem.name;
   undoMenuItem[] -> append;
   cutMenuItem.open;
   'Cut' -> cutMenuItem.name;
   cutMenuItem[] -> append;
   copyMenuItem.open;
   'Copy' -> copyMenuItem.name;
   copyMenuItem[] -> append;
   pasteMenuItem.open;
   'Paste' -> pasteMenuItem.name;
   pasteMenuItem[] -> append;
   clearMenuItem.open;
   'Clear' -> clearMenuItem.name;
   clearMenuItem[] -> append;
   inner open;

-- GUIENVwindowGetContents: doPart --
do private.contents[] -> theContents[];

-- GUIENVwindowSeparatorOnRefresh: doPart --
do inner onRefresh;
   

-- motifMenuItemLib: attributes --

handleActivate: motifCallbackSelector
  (# 
  do (if this(motifMenu).private.isVisible or theMenuitem.theEventHandler.onStatus then
         theMenuitem.theEventHandler.onSelect
     if)
  #);
motifMenuItemActivateProcessor: callbackProcessor
  (#
  do &handleActivate[] -> cb[];
  #);

handleCascading: motifCallbackSelector
  (# 
  do theMotifSubmenu.handleOnSelect;
  #);
motifMenuItemCascadingProcessor: callbackProcessor
  (#
  do &handleCascading[] -> cb[];
  #);

handleExpose: exposeEventSelector
  (# 
  do (if theMenuitem.checked then
         drawCheckMark;
     if);
  #);
motifMenuItemExposeProcessor: eventProcessor
  (# 
  do &handleExpose[] -> es[];
  #);



handleOnStatus:
  (# enabled: @boolean;
  do (if theMenuitem.theEventHandler.onStatus -> enabled then
         (widgetID,1) -> XtSetSensitive;
      else
         (widgetID,0) -> XtSetSensitive;
     if);
  #);
drawCheckMark:
  (# windowID,displayID,gcID,screenNumber: @integer;
     black: @integer;
  do widgetID -> XtWindow -> windowID;
     widgetID -> XtDisplay -> displayID;
     displayID -> XDefaultScreen -> screenNumber;
     (displayID,windowID,0,0) -> XCreateGC -> gcID;
     (displayID,screenNumber) -> XBlackPixel -> black;
     (displayID,gcID,black) -> XSetForeGround;
     (displayID,windowID,gcID,4,8,6,14) -> XDrawLine;
     (displayID,windowID,gcID,6,14,9,4) -> XDrawLine;
     (displayID,gcID) -> XFreeGC;
  #);

-- GUIENVmotifMenuItemCreate: doPart --
do (# args: @argList;
      buildSeparator: 
        (# args: @argList;
        do (XmSeparatorWidgetClass,this(motifMenu).widgetID,'menuseparator'->appendtickref)
             -> createManaged;
        #);
      buildCascadeButtonItem: 
        (# args: @argList;
           
        do (XmCascadeButtonWidgetClass,
           this(motifMenu).widgetID,
           'menucascade'->appendtickref) -> createManaged;
           (motifMenuItemCascadingProcessor##, XmNcascadingCallback)
             -> addCallbackProcessor;
           &motifMenu[] -> theMotifSubMenu[];
           theMenuitem.subMenu -> theMotifSubMenu.theMenu[];
           this(motifMenu)[] -> theMotifSubMenu.owner[];
           theMotifSubMenu.open;
           (XmNsubMenuID,theMotifSubMenu.widgetID) -> setIntegerResource;
        #);
      buildPushButtonItem: 
        (#
        do (XmPushButtonWidgetClass,
           this(motifmenu).widgetID,
           'pushbuttonitem'->appendTickref) -> createManaged;
           (* 'The above menuitem is "'->puttext;
            * themenuitem.name->puttext;
            * '" belonging to menu "'->puttext;
            * themenu.name->puttext;
            * '" '-> putline;
            *)
           (motifMenuItemExposeProcessor##, XExposureMask) 
             -> appendEventProcessor;
           (motifMenuItemActivateProcessor##, XmNActivateCallback)
             -> addCallbackProcessor;
        #);
      t: @text;
   do (if theMenuitem## <= theMenu.separator## then
          buildSeparator;
       else
          (if theMenuitem.subMenu=none then
              buildPushButtonItem;
           else
              buildCascadeButtonItem;
          if);
      if);
      (XmNlabelString,theMenuitem.name) -> setMotifStringResource;
      (XmNmarginLeft,15) -> setIntegerResource;
      (if theMenuitem.key<>0 then
          t.clear;
          'Ctrl<Key>' -> t.append;
          theMenuitem.key -> t.put;
          (XmNaccelerator,t[]) -> setStringResource;
          'Ctrl-' -> t;
          theMenuitem.key -> t.put;
          (XmNacceleratorText,t[]) -> setMotifStringResource;
      if);
      this(motifMenuitem)[] -> this(motifMenu).private.motifMenuitems.append;
   #)
   
-- GUIENVmotifMenuItemClose: doPart --
do widgetID -> DestroyWidget;

-- GUIENVmotifMenuGetItemByNumber: doPart --
do (# i: @integer;
   do l: private.motifMenuItems.scan
        (# 
        do i + 1 -> i;
           (if i = position then
               current[] -> theMotifMenuItem[];
               leave l;
           if);
        #);
   #);
   
-- GUIENVmenuitemscanMotifMenuItems: doPart --
do this(menu).private.motifMenus.scan
   (# 
   do current[] -> currentMotifMenu[];
      position  -> current.getItemByNumber -> this(scanMotifMenuItems).current[];
      inner scanMotifMenuItems;
   #);

-- GUIENVinterfaceObjectappendEventProcessor: doPart --
do (private.widgetID,type,0,address,0,XtListTail) 
     -> XtInsertEventHandler;
-- GUIENVinterfaceObjectPrependEventProcessor: doPart --
do (private.widgetID,type,0,address,0,XtListHead)
     -> XtInsertEventHandler;
   
-- GUIENVinterfaceObjectAddCallbackProcessor: doPart --
do (private.widgetID,type,address,0) -> XtAddCallback;
-- GUIENVinterfaceObjectAddCallbackProcessorForSubWidget: doPart --
do (subWidget,type,address,0) -> XtAddCallback;
   
   
-- GUIENVinterfaceObjectappendEventProcessorForSubWidget: doPart -- 
do (widget,type,0,address,0,XtListTail) -> XtInsertEventHandler;
   
-- GUIENVinterfaceObjectAddCallbackPrefix: doPart --
do callback## -> makeCBF -> address;
   inner;
   1 -> private.callbacks.extend; (* FIXME: kvadratisk samlet tid !! *)
   address -> private.callbacks[private.callbacks.range];
   
-- GUIENVupdateRect: doPart --
do this(guienv).private.damaged[] -> value[];
   
-- GUIENVwindowItemSetXBorder: doPart --
do true -> SetAnswer;
   (XtNborderWidth, width) -> setIntegerResource;
   false -> SetAnswer;

-- guienvQuit: doPart --
do true -> okToQuit;
   INNER;
   (if okToQuit then
       Terminate;
   if);
   
-- windowEnterVisible: doPart --
do assertOpen;
   (if value <> private.visible then
       (if value then
           show;
        else
           hide;
       if);
   if);
-- windowExitVisible: doPart --
do assertOpen;
   private.visible -> value;
   
-- guienvFitToContents: doPart --
do preferredSize -> size;
   INNER;
