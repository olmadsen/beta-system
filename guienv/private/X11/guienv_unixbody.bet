ORIGIN 'guienv_unixprivate';
INCLUDE '~beta/Xt/events'
        '~beta/sysutils/cstring'
        'widget'
        'guienvattributes'
        'motifstuff'
        '~beta/sysutils/objinterface'
        '../../graphics'
        'rubberband'
        'callbacks'
        'error'
        '../../utils/guienvadds';
LIB_ITEM 'guienv';
BUILD default '$$/guienv_unix.o' 'external/guienv_unix.c' '$CC -D$$ -I$MOTIFINC -I/usr/include -c -o $0 $1';
BUILD default '$$/Canvas.o' 'external/Canvas.c' '$CC -D$$ -I$MOTIFINC -I/usr/include -c -o $0 $1';
BUILD default '$$/Button.o' 'external/Button.c' '$CC -D$$ -I$MOTIFINC -I/usr/include -c -o $0 $1';
BUILD default '$$/IconButton.o' 'external/IconButton.c' '$CC -D$$ -I$MOTIFINC -I/usr/include -c -o $0 $1';
BUILD default '$$/ToggleButton.o' 'external/ToggleButton.c' '$CC -D$$ -I$MOTIFINC -I/usr/include -c -o $0 $1';
BODY 'develop';
-- GUIENVwindowLocalCoordsToGlobal: DoPart --
do
     (# x_root,y_root: @shortRef; ID: @integer; x,y: @integer; 
     do
        (contents).widgetID->ID;
        (ID,local.h,local.v,x_root[],y_root[])->XtTranslateCoords;
        x_root->uShort2Short->x;
        y_root->uShort2Short->y;
        (x,y)->global;
        
     #);
     

-- GUIENVwindowGlobalToLocal: DoPart --
do global->local; (0,0)->localToGlobal->local.subtract;   

-- lib: Attributes --
uShort2Short:
  (# value: @integer; 
  enter value
  do (if value > 32768 then value-65536->value;  if); 
  exit value
  #);
putPoint:
  (# p: @point
  enter p
  do '('->put; p.h->putInt; ','->put; p.v->putInt; ')'->put; 
  #);
putRectangle:
  (# r: @rectangle; 
  enter r
  do r.topLeft->putPoint; r.bottomRight->putPoint; 
  #);
  

-- guienvLib: Attributes --
initX:
  (#
     XtAppSetFallbackResources: external
       (# appcontext: @integer; resources: @integer; 
       enter (appcontext,resources)
       #);
     initAppName:
     (* initializes private.appName to the name of the executed file
      * with the first letter in uppercase
      *)
       (# lastSlash: @integer; 
       do
          1->arguments->private.appName[];
          '/'->private.appName.findAll (#  do inx->lastSlash #);
          (if lastSlash <> 0 then (1,lastSlash)->private.appName.delete if);
          (1->private.appName.inxGet->ascii.upcase,1)->private.appName.inxPut;
          trace
            (# 
            do 'initAppName: '->putText; private.appName[]->putLine; 
            #);
          
       #);
     initAppClass:
     (* initializes private.appClass to the name of the executed file with
      * the first letter in uppercase. If the first letter i X the second 
      * letter is also converted to uppercase
      *)
       (# lastSlash: @integer; 
       do
          1->arguments->private.appClass[];
          '/'->private.appClass.findAll (#  do inx->lastSlash #);
          (if lastSlash <> 0 then (1,lastSlash)->private.appClass.delete if);
          (1->private.appClass.inxGet->ascii.upcase,1)->private.appClass.inxPut;
          (if ((1->private.appClass.inxGet) = 'X') and
          (private.appClass.length > 1) then
              (2->private.appClass.inxGet->ascii.upcase,2)
                ->private.appClass.inxPut;
              
          if);
          trace
            (# 
            do 'initAppClass: '->putText; private.appClass[]->putLine; 
            #);
          
       #);
     GetRidOfStupidWarningsFromX: external
       (# appContext: @integer;  enter (appContext) do callC #);
     XtOpenDisplay: external
       (#
          appContext: @integer;
          displayString: @integer;
          name,class: [1] @char;
          options: ^cStruct;
          nOptions: @integer;
          argcaddr,argvaddr: @integer;
          display: @integer
       enter
       (appContext,displayString,name,class,options[],nOptions,argcaddr,
        argvaddr)
       do callC
       exit display
       #);
     
  do
     XtToolkitInitialize;
     XtCreateApplicationContext->private.appCon;
     initAppName;
     initAppClass;
     (if not displayWarnings then
         private.appCon->GetRidOfStupidWarningsFromX; 
     if);
     private.fallBackResources.init;
     (private.appCon,private.fallBackResources.address)
       ->XtAppSetFallbackResources;
     (private.appCon,0,private.appName,private.appClass,private.options[],0,
      getargc,getargv)->XtOpenDisplay->private.display;
     (&errorHandler[]).install;
     
  #);
init:
  (#
     initMenubar:
       (# theBar: ^menubarType; 
       do
          &menubarType[]->theBar[];
          (if theBar## <> menubar## then
              theBar.open; theBar[]->applicationMenubar; 
          if);
          
       #);
     initCursors:
       (# 
       do
          (private.display,XC_left_ptr)->XCreateFontCursor
            ->cursors.arrow.private.id;
          (private.display,XC_xterm)->XCreateFontCursor
            ->cursors.ibeam.private.id;
          (private.display,XC_watch)->XCreateFontCursor
            ->cursors.watch.private.id;
          (private.display,XC_crosshair)->XCreateFontCursor
            ->cursors.cross.private.id;
          (private.display,XC_cross)->XCreateFontCursor
            ->cursors.plus.private.id;
          (private.display,XC_hand2)->XCreateFontCursor
            ->cursors.hand.private.id;
          
       #);
     initBitmaps:
       (#
          bm: ^pixmap;
          getblack: external
            (# dpy,root: @integer; pix: @integer; 
            enter (dpy,root)
            exit pix
            #);
          getwhite: external
            (# dpy,root: @integer; pix: @integer; 
            enter (dpy,root)
            exit pix
            #);
          getgray: external
            (# dpy,root: @integer; pix: @integer; 
            enter (dpy,root)
            exit pix
            #);
          getlightgray: external
            (# dpy,root: @integer; pix: @integer; 
            enter (dpy,root)
            exit pix
            #);
          getdarkgray: external
            (# dpy,root: @integer; pix: @integer; 
            enter (dpy,root)
            exit pix
            #);
          root: @integer;
          makePixmap:
            (# pixmapID: @integer; thePixmap: ^pixmap; 
            enter pixmapID
            do
               &pixmap[]->thePixmap[];
               pixmapID->thePixmap.private.pixmapID;
               1->thePixmap.private.depth;
               
            exit thePixmap[]
            #);
          
       do
          private.display->XDefaultRootWindow->root;
          (private.display,root)->getwhite->makePixmap->patterns.white[];
          (private.display,root)->getblack->makePixmap->patterns.black[];
          (private.display,root)->getlightgray->makePixmap->patterns.ltgray[];
          (private.display,root)->getgray->makePixmap->patterns.gray[];
          (private.display,root)->getdarkgray->makePixmap->patterns.dkgray[];
          
       #);
     internAtoms:
       (# 
       do
          (private.display,'WM_DELETE_WINDOW',0)->XInternAtom
            ->private.wmDeleteWindowAtom;
          (private.display,'WM_PROTOCOLS',0)->XInternAtom
            ->private.wmProtocolsAtom;
          
       #);
     argv,argc: @integer;
     initUpdateCompression:
       (# 
       do
          MaxInt->private.updateLeft->private.updateTop;
          MinInt->private.updateRight->private.updateBottom;
          
       #);
     (* bifrost begin *)
     initDeviceInfo:
       (# 
       do
          private.display->XDefaultScreenOfDisplay->private.defaultScreen;
          private.display->XDefaultScreen->private.defaultScreenNumber;
          private.defaultScreen->XDefaultDepthOfScreen->private.defaultdepth;
          private.defaultScreen->XDefaultVisualOfScreen->private.defaultVisual;
          private.defaultScreen->XRootWindowOfScreen->private.defaultDrawable;
          private.defaultScreen->XDefaultColorMapOfScreen->private.xcolormap;
          private.defaultScreen->XBlackPixelOfScreen->private.blackpixelvalue;
          private.defaultScreen->XWhitePixelOfScreen->private.whitepixelvalue;
          (private.defaultScreen->XHeightOfScreen->private.screenHeight) div
          ((private.display,private.defaultScreenNumber)->XDisplayHeightMM)
            ->Private.pixelsPerMillimeterHeight;
          (private.defaultScreen->XWidthOfScreen->private.screenWidth) div
          ((private.display,private.defaultScreenNumber)->XDisplayWidthMM)
            ->Private.pixelsPerMillimeterWidth;
          
       #);
     initBifrost:
       (#  do true->displaywarnings; bifrostprivate.PH.init;  #);
     (* bifrost end *)
     initGC:
       (# 
       do
          (private.display,private.theDeviceInfo.defaultDrawable,0,0)->XCreateGC
            ->private.gc;
          
       #);
     
  do
     inittickcount;
     private.theXtlib.init;
     private.options.init;
     &deviceInfo[]->private.theDeviceInfo[];
     (* -> objectPool.put; *)
     (if private.display = 0 then
         (normal,'Cannot open display')->stop; 
      else
         private.display->private.theDeviceInfo.init;
         initGC;
         initCursors;
         initBitmaps;
         initMenubar;
         internAtoms;
         initUpdateCompression;
         initDeviceInfo;
         (* bifrost *)
         initBifrost;
         (* bifrost *)
         (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
         true->setupDone;
         (* private.handleIdle.add; *)
         
     if);
     
  #);
DestroyWidget:
  (# ID: @integer; (* T:@text; *) 
  enter ID
  do
     (if ID = 0 then
     (* (failureTrace, 'Attempt to destroy NULL widget') -> stop; *)
         
      else
     (* 'DestroyWidget: ID='->puttext; ID->putint; 
      * ', name='''->puttext; ID->XtName->T;t[]->puttext;
      * ''''->puttext; newline;
      *)
         ID->XtDestroyWidget; (* (private.display,0) -> XSync; *) 
     if);
     
  #);
menubarHeight: (#  exit 30 #);
inittickcount: external (#  #);
tickcount: external (# ticks: @integer;  exit ticks #);
appendTickRef:
  (# t: ^text; 
  enter t[]
  do '_'->T.append; tickcount->T.putint; 
  exit t[]
  #);
appendtick: (# T: ^text enter t[] do t[]->appendtickref->t[] exit t #);
GetTopShadowGC: external
(* The widget must be a manager widget or descendant thereof *)
  (#
     w: @integer;
     (* The Manager widget *)
     gc: @integer;
     (* The gc that should be used for the top shadow *)
     
  enter w
  exit gc
  #);
GetBottomShadowGC: external
(* The widget must be a manager widget or descendant thereof *)
  (#
     w: @integer;
     (* The Manager widget *)
     gc: @integer;
     (* The gc that should be used for the bottom shadow *)
     
  enter w
  exit gc
  #);
_XmDrawShadows: external
  (#
     display,drawable,topgc,bottomgc,x,y,width,height,thickness,type: @integer;
     
  enter
  (private.display,drawable,topgc,bottomgc,x,y,width,height,thickness,type)
  #);
  

-- interfaceObjectLib: Attributes --
XtAddCallback: external
  (#
     widget: @integer;
     name: @integer;
     callbackP: @integer;
     clientData: @integer;
     
  enter (widget,name,callbackP,clientData)
  #);
destroyCallbackSelector: callbackSelector
  (# T: @text; 
  do
  (* 'DestroyCallback: guienv ID='->puttext; private.widgetID->putint; 
   * ' motif ID='->puttext; widget->putint;
   * ', name='''->puttext; widget->XtName->T;t[]->puttext;
   * ''''->puttext; newline;
   *)
     (for inx: private.callbacks.range repeat
       private.callbacks[inx]->freeCBF; 
     for);
     0->private.callbacks.new;
     false->private.beingClosed;
     0->private.widgetID;
     
  #);
destroyCallbackProcessor: callbackProcessor
  (#  do &destroyCallbackSelector[]->cb[];  #);
eventDisabled: booleanValue
  (# ev: ##theEventHandler.event; 
  enter ev##
  do
     (if private.disabledEvents[] = none then
         false->value; 
      else
         ev##->private.disabledEvents.has->value; 
     if);
     
  #);
addDisabledEvent:
  (# e: ^eventSpec; ev: ##theEventHandler.event; 
  enter ev##
  do
     (if private.disabledEvents[] = none then
         &eventSpecList[]->private.disabledEvents[]; 
     if);
     (if not (ev##->private.disabledEvents.has) then
         &eventSpec[]->e[]; ev##->e.type##; e[]->private.disabledEvents.append; 
     if);
     
  #);
removeDisabledEvent:
  (# ev: ##theEventHandler.event; 
  enter ev##
  do
     (if private.disabledEvents[] <> none then
         ev##->private.disabledEvents.remove; 
     if);
     
  #);
addCBF:
  (# cbf: @integer; 
  enter cbf
  do
     1->private.callbacks.extend;
     cbf->private.callbacks[private.callbacks.range];
     
  #);
  

-- motifMenuLib: Attributes --
unmapcallbackSelector: callbackSelector
  (# 
  do
     (if popdownHook[] <> none then popdownHook;  if);
     (* enable all motifmenuitems to make keyboard shortcuts work without having to
      * post the menu first to evaluate item.onStatus.
      *)
     private.motifMenuitems.scan
       (#  do (current.widgetID,1)->XtSetSensitive;  #);
     false->private.isVisible;
     
  #);
unmapCallbackProcessor: callbackProcessor
  (#  do &unmapCallbackSelector[]->cb[];  #);
handleOnSelect:
  (# 
  do
     true->private.isVisible;
     theMenu.theEventHandler.onSelect;
     private.motifMenuItems.scan
       (#  do current.handleOnStatus;  #)
  #);
setKey:
  (#
     position: @integer;
     key: @char;
     theMotifMenuItem: ^motifMenuitem;
     t: @text;
     spk: @specialKeys;
     
  enter (position,key)
  do
     position->getItemByNumber->theMotifMenuItem[];
     t.clear;
     'Ctrl+'->t.putText;
     key->spk.keyToText->t.append;
     (XmNacceleratorText,t[])->theMotifMenuItem.setMotifStringResource;
     t.clear;
     'Ctrl<Key>'->t.putText;
     (*     'Ctrl-'->t.putText;*)
     key-> keyToMotifVK->t.append;
     (XmNaccelerator,t[])->theMotifMenuItem.setStringResource;
     
  #);
setName:
  (# position: @integer; name: ^text; theMotifMenuItem: ^motifMenuitem; 
  enter (position,name[])
  do
     position->getItemByNumber->theMotifMenuItem[];
     (XmNlabelString,name[])->theMotifMenuItem.setMotifStringResource;
     
  #);
setChecked:
  (#
     position: @integer;
     checked: @boolean;
     theMotifMenuItem: ^motifMenuitem;
     
  enter (position,checked)
  do
     position->getItemByNumber->theMotifMenuItem[];
     checked->theMotifMenuItem.checked;
     
  #);
setSubMenu:
  (# position: @integer; theMotifMenuItem: ^motifMenuitem; theMenu: ^menu; 
  enter (position,theMenu[])
  do
     position->getItemByNumber->theMotifMenuItem[];
     (if theMotifMenuItem.theMotifSubmenu[] <> none then
         theMotifMenuItem.theMotifSubmenu.close; 
     if);
     (if theMenu[] = none then
         none ->theMotifMenuItem.theMotifSubmenu[];
         (XmNsubMenuID,0)->theMotifMenuItem.setIntegerResource;
         
      else
         &motifMenu[]->theMotifMenuItem.theMotifSubmenu[];
         theMenu[]->theMotifMenuItem.theMotifSubMenu.theMenu[];
         THIS(motifMenu)[]->theMotifMenuItem.theMotifSubMenu.owner[];
         theMotifMenuItem.theMotifSubMenu.open;
         (XmNsubMenuID,theMotifMenuItem.theMotifSubMenu.widgetID)
           ->theMotifMenuItem.setIntegerResource;
         
     if);
     
  #);
  

keyToMotifVK:
  (# key: @integer; name: ^text; 
  enter key
  do
     (if key
      // specKeys.PG_UP then
         'Prior'->name[]
      // specKeys.PG_DOWN then
         'Next'->name[]
      // specKeys.HOME then
         'Home'->name[]
      // specKeys.END then
         'End'->name[]
      // specKeys.INSERT then
         'Insert'->name[]
      // specKeys.F1 then
         'F1'->name[]
      // specKeys.F2 then
         'F2'->name[]
      // specKeys.F3 then
         'F3'->name[]
      // specKeys.F4 then
         'F4'->name[]
      // specKeys.F5 then
         'F5'->name[]
      // specKeys.F6 then
         'F6'->name[]
      // specKeys.F7 then
         'F7'->name[]
      // specKeys.F8 then
         'F8'->name[]
      // specKeys.F9 then
         'F9'->name[]
      // specKeys.BACKSPACE then
         'BackSpace'->name[]
      // specKeys.TAB then
         'Tab'->name[]
      // specKeys.RETURN then
         'Return'->name[]
      // specKeys.ESCAPE then
         'Escape'->name[]
      // specKeys.LEFT then
         'Left'->name[]
      // specKeys.RIGHT then
         'Right'->name[]
      // specKeys.UP then
         'Up'->name[]
      // specKeys.DOWN then
         'Down'->name[]
      // specKeys.SPACE then
         'Space'->name[]
      // specKeys.DELETE then
         'Remove'->name[]
      // '+' then
         'KP_Add'->name[]
      // '-' then
         'KP_Subtract'->name[]
      // '*' then 
         'KP_Multiply'->name[]
      // '/' then 
         'KP_Divide'->name[]
      else
         (if key < 255 then &text[]->name[]; key->name.put if); 
     if);
  exit name[]
  #)  

-- GUIENVmotifMenuappend: DoPart --
do
     (# theMotifMenuItem: ^motifMenuitem; 
     do
        &motifMenuitem[]->theMotifMenuItem[];
        theItem[]->theMotifMenuItem.theMenuitem[];
        theMotifMenuItem.open;
        
     #);
     

-- GUIENVmotifMenudelete: DoPart --
do
     (# theMotifItem: ^motifMenuitem; 
     do
        l: private.motifMenuItems.scan
          (# 
          do
             (if theItem[] = current.theMenuitem[] then
                 current[]->theMotifItem[]; leave l; 
             if);
             
          #);
        (if theMotifItem[] <> none then
            theMotifItem[]->private.motifMenuItems.remove; theMotifItem.close; 
        if);
        
     #)  

-- GUIENVmotifMenuCreate: DoPart --
do
     (# name: ^text; args: @argList; ID: @integer; 
     do
        theMenu.name->name[];
        tickCount->name.putInt;
        owner.widgetID->ID;
        (if popup then
            (ID,name,args[],0)->XmCreatePopupMenu->widgetID;
            (* 'Created motif popup menu widget: ID = ' -> putText;
             * widgetID -> putInt;
             * ' name = ' -> putText;
             * name[] -> putline;
             *)
            
         else
            (ID,name,args[],0)->XmCreatePullDownMenu->widgetID;
            (* 'Created pulldown menu widget: ID = ' -> putText;
             * widgetID -> putInt;
             * ' name = ' -> putText;
             * name[] -> putline;
             *)
            (unmapCallbackProcessor##,XmNunmapCallback)->addCallbackProcessor;
            
        if);
        theMenu.scan
          (# theMotifMenuitem: ^motifMenuitem; 
          do
             &motifMenuitem[]->theMotifMenuitem[];
             current[]->theMotifMenuitem.theMenuitem[];
             theMotifMenuitem.open;
             
          #);
        (if themenu.enabled then
            (widgetID,1)->XtSetSensitive; 
         else
            (widgetID,0)->XtSetSensitive; 
        if);
        THIS(motifMenu)[]->theMenu.private.motifMenus.append;
        
     #);
     

-- GUIENVmotifMenuOpen: DoPart --
do INNER open;   

-- GUIENVmotifMenuClose: DoPart --
do
   private.motifMenuitems.scan
     (#  do current.close;  #);
   private.motifMenuitems.clear;
   THIS(motifMenu)[]->theMenu.private.motifMenus.remove;
   widgetID->DestroyWidget;
     

-- GUIENVmotifMenugetNumberOfWidget: DoPart --
do
     (# inx: @integer; 
     do
        0->inx;
        l: private.motifMenuitems.scan
          (# 
          do
             inx+1->inx;
             (if current.widgetID = widget then inx->position; leave l if);
             
          #);
        
     #);
     

-- GUIENVmotifMenuPrivate: Descriptor --
(#
   motifMenuItems: @list
     (#
        element::< motifMenuitem;
        remove: (# e: ^element;  enter e[] do e[]->at->delete;  #);
        
     #);
   isVisible: @boolean;
   
#)  

-- motifMenubarLib: Attributes --
cascadeButton: interfaceObject
  (#
     theMotifmenu: ^motifMenu;
     open::< 
       (#
          create::< 
            (# args: @argList; mstr: @motifString; ID: @integer; 
            do
               theMotifmenu.theMenu.name->mstr.setText;
               THIS(motifMenubar).widgetID->ID;
               ('cascadebutton',xmCascadeButtonWidgetClass,ID,args[],0)
                 ->XtCreateWidget->widgetID;
               manage;
               (cascadingProcessor##,XmNcascadingCallback)
                 ->addCallbackProcessor;
               (1,XmNlabelString,mstr)->args.set;
               (2,XmNsubMenuId,theMotifMenu.widgetID)->args.set;
               widgetID->ID;
               (ID,args[],2)->XtSetValues;
               ;
               
            #);
          
       #);
     close::<  (#  do widgetID->DestroyWidget;  #);
     handleCascading: MotifcallbackSelector
       (#  do theMotifmenu.handleOnSelect;  #);
     cascadingProcessor: callbackProcessor
       (#  do &handleCascading[]->cb[];  #);
     
  #);
  

-- GUIENVmotifMenubarappend: DoPart --
do
     (# theCascadeButton: ^cascadeButton; theMotifMenu: ^motifMenu; 
     do
        &motifMenu[]->theMotifMenu[];
        THIS(motifMenubar)[]->theMotifMenu.owner[];
        theMenu[]->theMotifMenu.theMenu[];
        theMotifMenu.open;
        &cascadeButton[]->theCascadeButton[];
        theMotifMenu[]->theCascadeButton.theMotifMenu[];
        theCascadeButton.open;
        theMotifMenu[]->private.motifMenus.append;
        theCascadeButton[]->private.cascadeButtons.append;
        
     #);
     

-- GUIENVmotifMenubardelete: DoPart --
do
     (# theCascadeButton: ^cascadeButton; theMotifMenu: ^motifMenu; 
     do
        theMenu[]->private.motifMenus.findMenu->theMotifMenu[];
        theMotifMenu[]->private.cascadeButtons.findButton->theCascadeButton[];
        (if theCascadeButton[] <> none then
            theCascadeButton.close;
            theCascadeButton[]->private.cascadeButtons.remove;
            
        if);
        theMotifMenu[]->private.motifMenus.remove;
        theMotifMenu.close;
        
     #)  

-- GUIENVmotifMenubarcreate: DoPart --
do
     (# args: @argList; theFuncPtr: @integer; T: @text; ID: @integer; 
     do
        (1,XtNheight,menubarHeight)->args.set;
        'Menubar'->appendTick->T;
        theWindow.private.contentsForm.widgetID->ID;
        (ID,T,args[],1)->XmCreateMenuBar->widgetID;
        (* 'Created menubar widget: ID = ' -> putText;
         * widgetID -> putInt;
         * ' name = ' -> putText;
         * T[] -> putline;
         *)
        (XmNresizeWidth,0)->setIntegerResource;
        (XmNresizeHeight,0)->setIntegerResource;
        (XmNresizable,true)->setBooleanResource;
        widgetID->XtManageChild;
        
     #)  

-- GUIENVmotifMenubaropen: DoPart --
do   

-- GUIENVmotifMenubarClose: DoPart --
do
   private.motifMenus.scan
     (# 
     do (current[]->private.cascadeButtons.findButton).close; current.close; 
     #);
   private.motifMenus.clear;
   widgetID->DestroyWidget;
     

-- GUIENVmotifMenubarprivate: Descriptor --
(#
   motifmenus: @list
     (#
        element::< motifMenu;
        remove: (# e: ^element;  enter e[] do e[]->at->delete;  #);
        findMenu:
          (# theMotifMenu: ^motifMenu; theMenu: ^menu; 
          enter theMenu[]
          do
             l: scan
               (# 
               do
                  (if current.theMenu[] = theMenu[] then
                      current[]->theMotifMenu[]; leave l; 
                  if);
                  
               #);
             
          exit theMotifMenu[]
          #);
        
     #);
   cascadeButtons: @list
     (#
        element::< cascadeButton;
        remove: (# e: ^element;  enter e[] do e[]->at->delete;  #);
        findButton:
          (# theMotifMenu: ^motifMenu; theButton: ^cascadeButton; 
          enter theMotifMenu[]
          do
             l: scan
               (# 
               do
                  (if current.theMotifMenu[] = theMotifMenu[] then
                      current[]->theButton[]; leave l; 
                  if);
                  
               #);
             
          exit theButton[]
          #);
        
     #);
   
#)  

-- GUIENVterminateBody: DoPart --
do (if onQuit then FALSE->private.running; Stop;  if);   

-- GUIENVsetTheMenubar: DoPart --
do
     (#
        XtAppCreateShell: external
          (#
             name: [1] @char;
             class: [1] @char;
             widgetClass: @integer;
             display: @integer;
             args: ^argList;
             nArgs: @integer;
             newWidget: @integer;
             
          enter (name,class,widgetclass,display,args[],nArgs)
          do callC
          exit newWidget
          #);
        
     do themenubar[]->private.theMenubar[]; 
     #)  

-- GUIENVgetTheMenubar: DoPart --
do private.theMenubar[]->themenubar[];   

-- GUIENVdoSetUp: Descriptor --
(#  do initX; init;  #)  

-- GUIENVdoPart: DoPart --
do
     (#
        aWindow: @window
          (# open::  (#  do ''->Title; (680,20)->size;  #);  #);
        anyevent: @XAnyEvent;
        dispatch:
          (#
             done: @boolean;
             xkey: @XKeyEvent;
             control: @boolean;
             key: @int32u;
             
          do
             dispatch:
             (if anyevent.type = XKeyPress then
                 anyevent->xkey;
                 xkey.controlModified->control;
                 xkey.translate
                   (#  do theKeySym.value->key;  #);
                 private.beforeKeyDown.scan
                   (# 
                   do
                      (key,control)->current->done;
                      (if done then leave dispatch;  if);
                      
                   #);
                 (control,key)->THIS(GUIenv).onKeyDown->done;
                 (if done then leave dispatch;  if);
                 private.afterKeyDown.scan
                   (# 
                   do
                      (key,control)->current->done;
                      (if done then leave dispatch;  if);
                      
                   #);
                 
             if);
             
          exit done
          #);
        
     do (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
        (if not setupDone then doSetUp;  if);
        onStartApplication;
        INNER guienv;
        (if applicationMenuBar <> none then
            (if private.windows.empty then aWindow.open;  if); 
        if);
        (if not private.dontRunLoop then
            TRUE->private.running;
            anyevent.init;
            l:
            (if private.running then
                (THIS(guienv).private.appCon,anyevent)->XtAppNextEvent;
                (if not dispatch then anyevent->XtDispatchEvent;  if);
                restart l;
                
            if);
            private.display->XtCloseDisplay;
            
        if);
        
     #)  

-- GUIENVmouseDownDelay: DoPart --
do
     (# ticks: @integer; start: @integer; 
     do
        tickCount->start;
        l:
        (if mouse.buttonState = buttonState then
            tickCount->ticks;
            (if ((ticks-start) < period) then
                restart l; 
             else
                INNER delay; 
            if);
            
        if);
        
     #)  

-- GUIENVinterfaceObjectEvent: DoPart --
do
   (if not (THIS(event)##->eventDisabled) then
       (if private.beforeActions[] <> none then
           private.beforeActions.scan
             (# 
             do
                (if (current.eventType## >= THIS(event)##) then
                    THIS(event)[]->current; 
                if);
                
             #);
           
       if);
       INNER event;
       (if private.afterActions[] <> none then
           private.afterActions.scan
             (# 
             do
                (if (current.eventType## >= THIS(event)##) then
                    THIS(event)[]->current; 
                if);
                
             #);
           
       if);
       
   if);
     

-- GUIENVbasicEventShiftKey: DoPart --
do (((THIS(guienv).private.state,shiftMask)->tos'%and') = shiftMask)->value;   

-- GUIENVbasicEventAltKey: DoPart --
do (* Not Implemented !!! *)   

-- GUIENVbasicEventMetaKey: DoPart --
do (((THIS(guienv).private.state,mod1Mask)->tos'%and') = mod1Mask)->value;   

-- GUIENVbasicEventControlKey: DoPart --
do
   (((THIS(guienv).private.state,controlMask)->tos'%and') = controlMask)->value;
     

-- GUIENVbasicEventButtonState: DoPart --
do THIS(guienv).private.detail->value;   

-- GUIENVbasicEventWhen: DoPart --
do THIS(guienv).private.time->value;   

-- GUIENVbasicEventGlobalPosition: DoPart --
do (THIS(guienv).private.x_root,THIS(guienv).private.y_root)->p;   

-- GUIENVbasicEventLocalPosition: DoPart --
do (THIS(guienv).private.x,THIS(guienv).private.y)->p;   

-- GUIENVmouseEventDoubleClick: DoPart --
do THIS(guienv).private.doubleClick->value;   

-- GUIENVkeyEventCh: DoPart --
do THIS(guienv).private.theChar->theChar;   

-- GUIENVkeyEventKey: DoPart --
do THIS(guienv).private.theKey->theKey  

-- GUIENVinterfaceObjectPrependAction: DoPart --
do
   (if private.beforeActions[] = none then
       &actionList[]->private.beforeActions[]; 
   if);
   (if not (theAction[]->private.beforeActions.member) then
       theAction[]->private.beforeActions.prepend; 
   if);
     

-- GUIENVinterfaceObjectAppendAction: DoPart --
do
   (if private.afterActions[] = none then
       &actionList[]->private.afterActions[]; 
   if);
   (if not (theAction[]->private.afterActions.member) then
       theAction[]->private.afterActions.append; 
   if);
     

-- GUIENVinterfaceObjectDeleteAction: DoPart --
do
   (if private.beforeActions[] <> none then
       theAction[]->private.beforeActions.delete; 
   if);
   (if private.afterActions[] <> none then
       theAction[]->private.afterActions.delete; 
   if);
     

-- GUIENVinterfaceObjectOpen: DoPart --
do
     (#
        openTwiceException: exception
          (# 
          do
             'Attempt to open interfaceobject twice: '->msg;
             THIS(InterfaceObject)[]->getpatternname->msg.append
          #);
        
     do
        (if not private.isOpen then
            true->private.isOpen;
            create;
            (if private.widgetID <> 0 then
                (destroyCallbackProcessor##,XtNdestroyCallback)
                  ->addCallbackProcessor;
                
            if);
            INNER open;
            
         else
            openTwiceException; 
        if);
        
     #)  

-- GUIENVintefaceObjectCreate: DoPart --
do INNER create;   

-- GUIENVinterfaceObjectClose: DoPart --
do
     (# 
     do
        assertOpen;
        INNER close;
        false->private.isOpen;
        true->private.beingClosed;
        
     #)  

-- GUIENVenableEventType: DoPart --
do ev##->removeDisabledEvent;   

-- GUIENVdisableEventType: DoPart --
do ev##->addDisabledEvent;   

-- GUIENVinterfaceObjectException: DoPart --
do
   'interfaceobject-exception for '->msg.putText;
   THIS(interfaceObject)[]->getPatternName->msg.putText;
   msg.newline;
   INNER interfaceObjectException;
     

-- GUIENVnotOpenedException: DoPart --
do
   'Attempt to use ' ''->msg.puttext;
   (if location[] <> none then
       location[]->msg.puttext; '' ' in ' ''->msg.puttext; 
   if);
   THIS(interfaceobject)[]->getpatternname->msg.puttext;
   '' ' which is not ' 'open' ''->msg.putline;
   INNER notOpenedException;
     

-- GUIENVseparatorSetStyle: DoPart --
do
     (# xmStyle: @integer; 
     do
        value->private.style;
        (if value
         // separatorStyles.singleLine then
            XmSINGLE_LINE->xmStyle; 
         // separatorStyles.doubleLine then
            XmDOUBLE_LINE->xmStyle; 
         // separatorStyles.singleDashedLine then
            XmSINGLE_DASHED_LINE->xmStyle; 
         // separatorStyles.doubleDashedLine then
            XmDOUBLE_DASHED_LINE->xmStyle; 
         // separatorStyles.etchedIn then
            XmSHADOW_ETCHED_IN->xmStyle; 
         // separatorStyles.etchedOut then
            XmSHADOW_ETCHED_OUT->xmStyle; 
        if);
        (XmNseparatorType,xmStyle)->setIntegerResource;
        
     #)  

-- GUIENVseparatorGetStyle: DoPart --
do private.style->value;   

-- GUIENVwindowseparatorCreate: DoPart --
do
     (# args: @argList; width,height: @integer; ID: @integer; 
     do
        father.size->(width,height);
        (if vertical then
            (1,XmNorientation,XmVERTICAL)->args.set;
            (2,XtNheight,height)->args.set;
            
         else
            (1,XmNorientation,XmHORIZONTAL)->args.set;
            (2,XtNwidth,width)->args.set;
            
        if);
        father.widgetID->ID;
        (XmSeparatorWidgetClass,ID,'Separator'->appendtickref,args[],2)
          ->createManagedArgs;
        separatorStyles.etchedIn->private.style;
        
     #);
     

-- GUIENVwindowseparatorOpen: DoPart --
do INNER open;   

-- GUIENVwindowseparatorClose: DoPart --
do INNER close;   

-- GUIENVwindowseparatorPrivate: Descriptor --
(# style: @integer;  #)  

-- GUIENVwindowbackgroundcolor: DoPart --
do theColor->private.contents.backgroundcolor;   

-- canvasLib: Attributes --
appendChild:
  (# theWindowitem: ^windowitem; 
  enter theWindowitem[]
  do theWindowitem[]->private.children.append; 
  #);
deleteChild:
  (# theWindowitem: ^windowitem; 
  enter theWindowitem[]
  do theWindowitem[]->private.children.at->private.children.delete; 
  #);
handleChildframeChanged:
  (# oldFrame,newFrame: @rectangle; 
  enter (oldFrame,newFrame)
  do (oldFrame,newFrame)->theEventHandler.onChildframeChanged; 
  #);
  

-- GUIENVcanvasSelectionAdd: DoPart --
do
   (if not (theWindowitem[]->private.selection.has) then
       theWindowitem[]->private.selection.append; true->theWindowitem.hilite; 
   if);
     

-- GUIENVcanvasSelectionSet: DoPart --
do
   private.selection.scan
     (# 
     do
        false->current.hilite;
        current[]->private.selection.at->private.selection.delete;
        
     #);
   theWindowitem[]->private.selection.append;
   true->theWindowitem.hilite;
     

-- GUIENVcanvasSelectionRemove: DoPart --
do
   (if theWindowitem[]->private.selection.has then
       theWindowitem[]->private.selection.at->private.selection.delete;
       false->theWindowitem.hilite;
       
   if);
     

-- GUIENVcanvasSelectionEmpty: DoPart --
do private.selection.empty->value;   

-- GUIENVcanvasSelectionScan: DoPart --
do
   private.selection.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVcanvasSelectionClear: DoPart --
do
   private.selection.scan
     (# 
     do
        false->current.hilite;
        current[]->private.selection.at->private.selection.delete;
        
     #);
     

-- GUIENVcanvasScan: DoPart --
do
   private.children.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVcanvasCreate: DoPart --
do
     (# args: @argList; 
     do
        INNER create;
        (if widgetID = 0 then
            (XbCanvasWidgetClass,father.widgetID)->createSimple; 
        if);
        
     #)  

-- GUIENVcanvasOpen: DoPart --
do INNER open;   

-- GUIENVcanvasClose: DoPart --
do INNER close; private.children.scan (#  do current.close;  #);   

-- GUIENVcanvasOnActivate: DoPart --
do
   private.children.scan
     (#  do current.theEventHandler.onActivate;  #);
   INNER onActivate;
     

-- GUIENVcanvasOnDeactivate: DoPart --
do
   private.children.scan
     (#  do current.theEventHandler.onDeactivate;  #);
   INNER onDeactivate;
     

-- GUIENVcanvasOnFrameChanged: DoPart --
do update; INNER onFrameChanged;   

-- GUIENVcanvasOnVisibleChanged: DoPart --
do
   assertOpen;
   private.children.scan
     (# 
     do
        (if current.visible then
            current.theEventHandler.onVisibleChanged; 
        if);
        
     #);
   INNER ;
     

-- GUIENVcanvasPrivate: Descriptor --
(#
   hit: ^windowItem;
   children: @list
     (#
        element::< windowitem;
        scanNonWidgets: scan
          (# where::<  (#  do (current.widgetID = 0)->value;  #); 
          do INNER ; 
          #);
        scanNonWidgetsReverse: scanReverse
          (# where::<  (#  do (current.widgetID = 0)->value;  #); 
          do INNER ; 
          #)
     #);
   selectionList: list (# element::< windowitem;  #);
   selection: @selectionList;
   
#)  

-- GUIENVcanvasOnMouseDown: DoPart --
do
     (# obj: ^windowitem; 
     do
        l: private.children.scanNonWidgetsReverse
          (# 
          do
             (if localPosition->current.hit then
                 current[]->obj[]; leave l; 
             if);
             
          #);
        obj[]->private.hit[];
        (if obj[] = none then
            INNER onMouseDown; 
         else
            obj.theEventHandler.onMouseDown; 
        if);
        
     #)  

-- GUIENVcanvasOnRefresh: DoPart --
do
   INNER onRefresh;
   private.children.scanNonWidgets
     (# 
     do (if current.visible then current.theEventHandler.onRefresh;  if); 
     #);
   (if THIS(window).private.theDefaultButton[] <> none then
       (if THIS(window).private.theDefaultButton.father[] = THIS(canvas)[] then
             (# topGC,bottomGC: @integer; x,y,width,height: @integer; 
             do
                widgetID->GetTopShadowGC->topGC;
                widgetID->GetBottomShadowGC->bottomGC;
                THIS(window).private.theDefaultButton.size->(width,height);
                THIS(window).private.theDefaultButton.position->(x,y);
                (THIS(guienv).private.display,windowID,topGC,bottomGC,x-4,y-4,
                 width+8,height+8,1,XmSHADOW_IN)->_XmDrawShadows;
                
             #);
           
       if);
       
   if);
     

-- GUIENVcanvasOnMouseUp: DoPart --
do
   (if private.hit[] <> none then
       private.hit.theEventHandler.onMouseUp; none ->private.hit[]; 
    else
       INNER onMouseUp; 
   if);
     

-- GUIENVclipBoardHasText: DoPart --
do   

-- GUIENVclipBoardSetText: DoPart --
do   

-- GUIENVclipBoardGetText: DoPart --
do   

-- GUIENVclipBoardClearContents: DoPart --
do   

-- GUIENVcursorPrivate: Descriptor --
(# id: @integer;  #)  

-- menubarLib: Attributes --
buildMenubar: (# fatherWidget: @integer;  enter fatherWidget do  #);
destroyMenubar: (#  do  #);
  

-- menubarEntryLib: Attributes --
entryHandleCasading: motifCallbackSelector
  (# subMenuId: @integer; theMenu: ^menu; args: @argList; w: @integer; 
  do
     cascadeButtonWidget->w;
     (1,XmNsubMenuId,@@ subMenuId)->args.set;
     (w,args[],1)->XtGetValues;
     subMenuId->private.menus.findById->theMenu[];
     (if theMenu[] = none then
         trace
           (# 
           do 'handleCascading: theMenu was not found in menu list'->putLine; 
           #);
         
      else
         theMenu.handleOnSelect; 
     if);
     
  #);
entryCascadingProcessor: callbackProcessor
  (#  do &entryHandleCasading[]->cb[];  #);
(* -- GUIENVmenuBarEntryHandlCascading: doPart --
 do (# subMenuId: @widget;
 theMenu: ^menu;
 do
 XmNsubMenuId -> getIntegerResource -> subMenuID;
 subMenuId -> private.menus.findById -> theMenu[];
 (if theMenu[]=none then
 trace
 (# 
 do 'handleCascading: theMenu was not found in menu list' -> putLine;
 #);
 else
 theMenu.handleOnSelect;
 if);
 #);
 *)
  

-- GUIENVmenubarEntryDoBuildEntry: DoPart --
do
     (# args: @argList; mstr: @motifString; ID: @integer; t: @text; 
     do
        widgetID->theMenu.buildMenu;
        theMenu.name->mstr.setText;
        'cascadebutton'->appendtick->t;
        widgetID->id;
        (t,xmCascadeButtonWidgetClass,id,args[],0)->XtCreateWidget
          ->cascadeButtonWidget;
        cascadeButtonWidget->XtManageChild;
        (entryCascadingProcessor##,XmNcascadingCallback,cascadeButtonWidget)
          ->addCallbackProcessorForSubWidget;
        (1,XmNlabelString,mstr)->args.set;
        (2,XmNsubMenuId,theMenu.widgetID)->args.set;
        cascadeButtonWidget->id;
        (id,args[],2)->XtSetValues;
        THIS(menubar)[]->theMenu.private.theMenubar[];
        THIS(menubarEntry)[]->theMenu.private.theEntry[];
        
     #);
     

-- GUIENVmenubarEntrydestroyEntry: DoPart --
do
     (# args: @argList; id: @integer; 
     do
        (1,XmNsubMenuId,0)->args.set;
        cascadeButtonWidget->id;
        (ID,args[],1)->XtSetValues;
        cascadeButtonWidget->DestroyWidget;
        theMenu.destroyMenu;
        0->cascadeButtonWidget;
        
     #);
     

-- GUIENVmenubarEntryRebuildEntry: DoPart --
do
     (# args: @argList; id: @integer; 
     do
        theMenu.destroyMenu;
        widgetID->theMenu.buildMenu;
        (1,XmNsubMenuId,theMenu.widgetID)->args.set;
        cascadeButtonWidget->id;
        (id,args[],1)->XtSetValues;
        
     #);
     

-- GUIENVmenubarPrivate: Descriptor --
(#
   menus: @list
     (#
        element::< menu;
        findById:
          (# widgetId: @integer; theMenu: ^menu; 
          enter widgetId
          do
             l: scan
               (# 
               do
                  (if current.widgetID = widgetId then
                      current[]->theMenu[]; leave l; 
                  if);
                  
               #);
             
          exit theMenu[]
          #);
        
     #);
   windows: @list (# element::< window;  #);
   
#)  

-- GUIENVmenubarAppend: DoPart --
do
   assertOpen;
   (if not (theMenu[]->private.menus.has) then
       theMenu[]->private.menus.append;
       private.windows.scan
         (#  do theMenu[]->current.private.theMotifMenubar.append;  #);
       
   if)  

-- GUIENVmenubarDelete: DoPart --
do
   assertOpen;
   (if theMenu[]->private.menus.has then
       theMenu[]->private.menus.at->private.menus.delete;
       private.windows.scan
         (#  do theMenu[]->current.private.theMotifMenubar.delete;  #);
       
   if);
     

-- GUIENVmenubarClear: DoPart --
do assertOpen; private.menus.scan (#  do current[]->delete;  #);   

-- GUIENVmenubarAppendMenubar: DoPart --
do assertOpen; theMenubar.scan (#  do current[]->append;  #);   

-- GUIENVmenubarReplaceMenubar: DoPart --
do
   assertOpen;
   theMenubar[]->deleteMenubar;
   replacementMenubar[]->appendMenubar;
     

-- GUIENVmenubarDeleteMenubar: DoPart --
do assertOpen; theMenubar.scan (#  do current[]->delete;  #);   

-- GUIENVmenubarScan: DoPart --
do
   assertOpen;
   private.menus.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVmenubarOpen: DoPart --
do private.menus.init; INNER open;   

-- GUIENVmenubarCreate: DoPart --
do INNER create;   

-- GUIENVmenubarClose: DoPart --
do INNER Close; clear; (* widgetID -> XtParent -> DestroyWidget *)   

-- GUIENVmenuBuildMenu: Descriptor --
(#  #)  

-- GUIENVmenuBuildPopupmenu: Descriptor --
(#  #)  

-- GUIENVmenuDestroyMenu: Descriptor --
(#  #)  

-- GUIENVmenuSetName: DoPart --
do assertOpen; theName.copy->private.name[];   

-- GUIENVmenuGetName: DoPart --
do
   assertOpen;
   (if private.name[] = none then
       &text[]->theName[]; 
    else
       private.name.copy->theName[]; 
   if);
     

-- GUIENVseparatorCreate: DoPart --
do INNER create  

-- GUIENVseparatorOpen: DoPart --
do INNER open;   

-- GUIENVseparatorClose: DoPart --
do INNER close;   

-- GUIENVmenuAppend: DoPart --
do
   assertOpen;
   (if not (theMenuItem[]->private.menuitems.has) then
       theMenuItem[]->private.menuitems.append;
       private.motifMenus.scan
         (#  do theMenuItem[]->current.append;  #);
       
   if);
     

-- GUIENVmenuDelete: DoPart --
do
   assertOpen;
   (if theMenuitem[]->private.menuitems.has then
       theMenuItem[]->private.menuitems.at->private.menuitems.delete;
       private.motifMenus.scan
         (#  do theMenuItem[]->current.delete;  #);
       
    else
       trace
         (# 
         do 'menu.delete: the menuitem is not in the menu'->putLine; 
         #);
       
   if);
     

-- GUIENVmenuScan: DoPart --
do
   assertOpen;
   private.menuitems.scan
     (#  do current[]->THIS(scan).current[]; INNER scan;  #);
     

-- GUIENVmenuClear: DoPart --
do assertOpen; scan (#  do current[]->delete;  #)  

-- GUIENVmenuNoOfMenuitems: DoPart --
do assertOpen; private.menuitems.size->value;   

-- GUIENVmenuGetMenuItemByNumber: DoPart --
do
     (# count: @integer; 
     do
        assertOpen;
        0->count;
        l: private.menuitems.iterate
          (# 
          do
             count+1->count;
             (if count = number then
                 current.elm[]->theMenuItem[]; leave l; 
             if);
             
          #);
        
     #)  

-- GUIENVmenuEnable: DoPart --
do
   assertOpen;
   true->private.enabled;
   (if widgetID <> 0 then (widgetID,1)->XtSetSensitive;  if);
     

-- GUIENVmenuDisable: DoPart --
do
   assertOpen;
   false->private.enabled;
   (if widgetID <> 0 then (widgetID,0)->XtSetSensitive;  if);
     

-- GUIENVmenuEnabled: DoPart --
do assertOpen; private.enabled->value;   

-- GUIENVmenuOpen: DoPart --
do
   THIS(Menu)[]->getPatternName->private.name[];
   true->private.enabled;
   INNER open;
     

-- GUIENVmenuCreate: DoPart --
do INNER create;   

-- GUIENVmenuClose: DoPart --
do
   (if private.popupevent[] <> none then private.popupevent->XtFree if);
   INNER close;
     

-- MenuLib: Attributes --
handleOnSelect: (#  do theEventHandler.onSelect;  #);   

-- GUIENVmenuPopUp: DoPart --
do
     (#
        id: @integer;
        x_root,y_root: @shortRef;
        x,y: @integer;
        theItem: ^Motifmenu.motifMenuItem;
        menuPost: ^text;
        
     do
        assertOpen;
        (if (private.motifpopupmenu[] = none ) (* create motif menu *) or
        (popupin[] <> private.motifPopupMenu.owner[]) then
            (if private.motifPopupMenu[] <> none then
            (* destroy old motif menu *)
                private.motifPopupMenu.close; 
            if);
            &motifmenu[]->private.MotifpopupMenu[];
            popupIn[]->private.MotifpopupMenu.owner[];
            THIS(menu)[]->private.MotifpopupMenu.theMenu[];
            true->private.MotifpopupMenu.popup;
            private.MotifpopupMenu.open;
            (if (private.popupbutton = 0) then 3->private.popupbutton if);
            '<Btn'->menupost[];
            private.popupbutton->menuPost.putint;
            '>'->menupost.put;
            (XmNmenuPost,menuPost[])->private.MotifpopupMenu.setStringResource;
            (if private.popupevent[] = none then
                &XButtonEvent[]->private.popupevent[];
                private.popupevent.init;
                XButtonPress->private.popupevent.type;
                
            if);
            
        if);
        private.MotifpopupMenu.handleOnSelect;
        popupIn.widgetID->id;
        (* translate to root coordinates *)
        (id,popupAt.h,popupAt.v,x_root[],y_root[])->XtTranslateCoords;
        x_root->uShort2Short->x;
        y_root->uShort2Short->y;
        (* Adjust for the popupWith item *)
        popupWith->private.MotifpopupMenu.getItemByNumber->theItem[];
        (if theItem[] <> none then
            y-(XtNy->theItem.getShortResource)->y; 
        if);
        (* Place menu using XmMenuPosition - ensures that menu is on screen *)
        y->private.popupevent.y_root;
        x+2
          ->
            private.popupevent.x_root
            (* + 2 to ensure that we are outside the item
             * - otherwise highlight does not work for this 
             * item before another has been selected
             *) ;
        (private.MotifpopupMenu.widgetID,private.popupevent)->XmMenuPosition;
        (* manage menu *)
        private.MotifpopupMenu.widgetID->XtManageChild;
        
     #)  

-- GUIENVactionOnStatus: DoPart --
do true->value; INNER onStatus; (*
                                 * menuitem
                                 *)   

-- GUIENVmenuItemDoExpose: DoPart --
do   

-- GUIENVmenuItemSetKey: DoPart --
do
     (# t: @text; 
     do
        assertOpen;
        c->ascii.upcase->private.key;
        THIS(menu).private.motifMenus.scan
          (#  do (position,c)->current.setKey;  #);
        
     #)  

-- GUIENVmenuitemSetSpecialKey: DoPart --
do
   key->private.speckey;
   ctrl->private.ctrl;
   shift->private.shift;
   alt->private.alt;
   ctrl %Bor alt %Bor shift->private.hasmod  

-- GUIENVmenuItemGetKey: DoPart --
do assertOpen; private.key->c;   

-- GUIENVmenuItemSetName: DoPart --
do
   assertOpen;
   t.copy->private.name[];
   scanMotifMenuItems
     (# 
     do
        (if current[] = none then
            'CURRENT is NONE in scanMotifMenuItems'->putLine; 
         else
            (XmNlabelString,t[])->current.setMotifStringResource; 
        if);
        
     #);
     

-- GUIENVmenuItemGetName: DoPart --
do assertOpen; private.name.copy->t[];   

-- GUIENVmenuitemSetChecked: DoPart --
do
   assertOpen;
   checked->private.checked;
   THIS(menu).private.motifMenus.scan
     (#  do (position,checked)->current.setChecked;  #);
     

-- GUIENVmenuitemGetChecked: DoPart --
do assertOpen; private.checked->checked;   

-- GUIENVsetSubMenu: DoPart --
do
   assertOpen;
   (if theMenu[] <> private.theSubMenu[] then
       theMenu[]->private.theSubMenu[];
       THIS(menu).private.motifMenus.scan
         (#  do (position,theMenu[])->current.setSubMenu;  #);
       
   if);
     

-- GUIENVgetSubMenu: DoPart --
do assertOpen; private.theSubMenu[]->theMenu[];   

-- GUIENVmenuItemPosition: DoPart --
do
     (# count: @integer; 
     do
        assertOpen;
        l: scan
          (# 
          do
             count+1->count;
             (if THIS(menuitem)[] = current[] then leave l;  if);
             
          #);
        count->value;
        trace
          (# 
          do
             (if count = 0 then
                 'menuitem.position: the menuitem was not found in the menu'
                   ->putLine;
                 
             if);
             
          #);
        
     #)  

-- GUIENVmenuitemCreate: DoPart --
do INNER create;   

-- GUIENVmenuitemOpen: DoPart --
do THIS(menuitem)[]->getPatternName->private.name[]; INNER open;   

-- GUIENVmenuItemOnStatus: DoPart --
do true->value; INNER onStatus;   

-- GUIENVmenuItemAttach: DoPart --
do
   assertOpen;
   (if theAction[] <> none then none ->theAction.theMenuitem[];  if);
   anAction[]->theAction[];
   (if theAction[] <> none then
       THIS(dynamicMenuitem)[]->theAction.theMenuitem[]; 
   if);
     

-- GUIENVmenuItemDetach: DoPart --
do
   assertOpen;
   (if theAction[] <> none then none ->theAction.theMenuitem[];  if);
   none ->theAction[];
     

-- GUIENVdynamicMenuItemOnStatus: DoPart --
do
   (if theAction[] = none then
       false->value; 
    else
       theAction.onStatus->value; 
   if);
     

-- GUIENVdynamicMenuItemOnSelect: DoPart --
do (if theAction[] <> none then theAction.onSelect;  if);   

-- GUIENVmouseGlobalPosition: DoPart --
do
     (# info: ^mouseInfo; 
     do
        private.display->XDefaultRootWindow->getMouseInfo->info[];
        info.global->pt;
        
     #)  

-- GUIENVmouseButtonState: DoPart --
do
     (# info: ^mouseInfo; 
     do
        private.display->XDefaultRootWindow->getMouseInfo->info[];
        info.button->value;
        
     #)  

-- GUIENVmouseTheCursorSet: DoPart --
do
     (# cursorID: @integer; 
     do
        (if theCur[] = none then
            0->cursorID; 
         else
            theCur.private.ID->cursorID; 
        if);
        THIS(guienv).private.windows.scan
          (# dpy,win: @integer; 
          do
             current.displayID->dpy;
             current.windowID->win;
             (dpy,win,cursorID)->XDefineCursor;
             current.widgetID->XmUpdateDisplay;
             
          #);
        theCur[]->private.busyCursor[]
     #)  

-- GUIENVmouseTheCursorGet: DoPart --
do private.busyCursor[]->theCur[];   

-- GUIENVsystemScreenRectangle: DoPart --
do
     (#
        root: @integer;
        dpy: @integer;
        ignore_root,x,y,width,height,ignore_border,ignore_depth: @integer;
        
     do
        private.display->dpy;
        dpy->XDefaultRootWindow->root;
        (dpy,root,@@ ignore_root,@@ x,@@ y,@@ width,@@ height,@@ ignore_border,
         @@ ignore_depth)->XGetGeometry;
        (x,y)->theRectangle.topLeft;
        (width,height)->theRectangle.size;
        
     #)  

-- GUIENVsystemScreenRgn: DoPart --
do &region[]->rgn[]; rgn.allocate; screenRectangle->rgn.setFromrectangle;   

-- GUIENVsystemBeepBody: DoPart --
do (private.display,100)->XBell;   

-- GUIENVsystemWaitBody: DoPart --
do
     (#
        timeVal: data (# tv_sec: @integer; tv_usec: @integer;  #);
        select: external
          (#
             nfds,readfds,writefds,exceptfds: @integer;
             timeout: ^timeVal;
             result: @integer;
             
          enter (nfds,readfds,writefds,exceptfds,timeout[])
          exit result
          #);
        x: @COM (# tv: @timeVal;  #);
        
     do
        ticks div 60->x.tv.tv_sec;
        ticks mod 60->x.tv.tv_usec;
        (0,0,0,0,x.tv[])->select;
        
     #)  

-- textStyleLib: Attributes --
gettextwidth: external
  (#
     buffer: @integer;
     count: @integer;
     fontStruct: @integer;
     width: @integer;
     
  enter (buffer,count,fontStruct)
  exit width
  #);
  

-- GUIENVtextStyleAscent: DoPart --
do
     (# info: ^fontInfo; 
     do
        allocate;
        getFontInfo->info[];
        (if info[] <> none then info.ascent->value;  if);
        
     #)  

-- GUIENVtextStyleDescent: DoPart --
do
     (# info: ^fontInfo; 
     do
        allocate;
        getFontInfo->info[];
        (if info[] <> none then info.descent->value;  if);
        
     #)  

-- GUIENVtextStyleLeading: DoPart --
do 0->value;   

-- GUIENVtextStyleHeight: DoPart --
do
     (# info: ^fontInfo; 
     do
        allocate;
        getFontInfo->info[];
        (if info[] <> none then info.descent+info.ascent->value;  if);
        
     #)  

-- GUIENVtextStyleMaxChWidth: DoPart --
do
     (#
        getcharinfo: external
          (# width: @integer; fontStruct: @integer; 
          enter fontStruct
          exit width
          #);
        
     do
        allocate;
        (if private.fontStruct <> 0 then
            private.fontStruct->getcharinfo->value; 
        if);
        
     #)  

-- GUIENVtextStyleWidthOfChar: DoPart --
do
   allocate;
   (if private.fontstruct <> 0 then
       (@@ ch,1,private.fontStruct)->gettextwidth->value; 
   if);
     

-- GUIENVtextStyleStringWidth: DoPart --
do
     (# length: @integer; 
     do
        allocate;
        (if private.fontStruct <> 0 then
            str.length->length;
            (if length > 0 then
                (@@ str.T[1],length,private.fontStruct)->gettextwidth->value; 
             else
                0->value; 
            if);
            
        if);
        
     #)  

-- GUIENVtextStyleSetName: DoPart --
do
   (if not (theName[]->private.name.equalNCS) then
       theName->private.name; dispose; 
   if);
     

-- GUIENVtextStyleGetName: DoPart --
do private.name.copy->theName[];   

-- GUIENVtextStyleSetSize: DoPart --
do (if value <> private.size then value->private.size; dispose;  if);   

-- GUIENVtextStyleGetSize: DoPart --
do private.size->value;   

-- GUIENVtextStyleSetFace: DoPart --
do (if value <> private.face then value->private.face; dispose;  if);   

-- GUIENVtextStyleGetFace: DoPart --
do private.face->value;   

-- GUIENVtextStyleFamilySizes: DoPart --
do   

-- windowLib: Attributes --
handleDeleteWindow: callbackSelector
  (# 
  do (if theEventHandler.onAboutToClose then THIS(window).close;  if); 
  #);
deleteWindowProcessor: callbackProcessor
  (#  do &handleDeleteWindow[]->cb[];  #);
handleWindowFocusChanged: focusChangeEventSelector
  (# (* notify modes *)
     NotifyNormal: (#  exit 0 #);
     NotifyGrab: (#  exit 1 #);
     NotifyUngrab: (#  exit 2 #);
     NotifyWhileGrabbed: (#  exit 3 #);
     (* Notify detail *)
     NotifyAncestor: (#  exit 0 #);
     NotifyVirtual: (#  exit 1 #);
     NotifyInferior: (#  exit 2 #);
     NotifyNonlinear: (#  exit 3 #);
     NotifyNonlinearVirtual: (#  exit 4 #);
     NotifyPointer: (#  exit 5 #);
     NotifyPointerRoot: (#  exit 6 #);
     NotifyDetailNone: (#  exit 7 #);
     
  do
  (* WidgetId -> putint; ' '->put;
   *      'handleWindowFocusChanged: mode, detail, type: '->puttext;
   *      mode -> putint; ' '->put;
   *      detail -> putint; ' '->put;
   *      type -> putint; ' '->put;
   *      newline;
   *)
  (* (if mode
   *       // NotifyNormal 
   *       // NotifyUngrab then
   *          (if detail
   *           // NotifyAncestor
   *           // NotifyPointer
   *           // NotifyVirtual
   *           // NotifyNonLinear
   *           // NotifyNonLinearVirtual then
   *              (if type
   *               // XFocusIn then
   *                  theEventHandler.onActivate;
   *               // XFocusOut then
   *                  theEventHandler.onDeactivate;
   *               else
   *                  {* WidgetId -> putint; ' '->put;
   *                   * 'handleWindowFocusChanged: type='->puttext; type->putint; newline;
   *                   *}
   *              if);
   *           else
   *              {* WidgetId -> putint; ' '->put;
   *               * 'handleWindowFocusChanged: detail='->puttext; detail->putint; newline;
   *               *}
   *          if);
   *       else
   *          {* WidgetId -> putint; ' '->put;
   *           * 'handleWindowFocusChanged: mode='->puttext; mode->putint; newline;
   *           *}
   *      if);
   *)
     (if type = XFocusIn then
         theEventHandler.onActivate; 
      else
         theEventHandler.onDeactivate; 
     if);
     
  #);
focusChangeEventProcessor: eventProcessor
  (#  do &handleWindowFocusChanged[]->es[];  #);
handleContentsResize: configureEventSelector
  (#  do (if type = XConfigureNotify then adjustContents;  if);  #);
configureEventProcessor: eventProcessor
  (#  do &handleContentsResize[]->es[];  #);
appendMenubar:
  (# theMenubar: ^menubar; theMotifMenubar: ^motifMenubar; 
  enter theMenubar[]
  do
     private.theMotifMenubar[]->theMotifMenubar[];
     (if theMotifMenubar[] = none then
         &motifMenubar[]->theMotifMenubar[];
         THIS(window)[]->theMotifMenubar.theWindow[];
         theMotifMenubar.open;
         theMotifMenubar[]->private.theMotifMenubar[];
         
     if);
     theMenubar.scan
       (#  do current[]->theMotifMenubar.append;  #);
     THIS(window)[]->theMenubar.private.windows.append;
     
  #);
hasWindow: booleanValue (#  do (widgetID->XtWindow) <> 0->value;  #);
resizeMenubar:
  (# itsHeight,itsBorderWidth: @integer; width,height: @integer; 
  do
     (if private.theMenubar[] <> none then
         size->(width,height);
         XtNborderWidth->private.theMenubar.getShortResource->itsBorderWidth;
         XtNheight->private.theMenubar.getShortResource->itsHeight;
         (private.theMenubar.widgetID,width,itsHeight,itsBorderWidth)
           ->XtResizeWidget;
         
     if);
     
  #);
  

-- GUIENVwindowadjustContents: DoPart --
do
   assertOpen
     (# width,height: @integer; 
     do
        XtNwidth->private.contentsForm.getShortResource->width;
        XtNheight->private.contentsForm.getShortResource->height;
        (if private.theMotifMenubar[] = none then
            (0,0)->private.contents.position;
            (width,height)->private.contents.size;
            
         else
            (0,menubarHeight)->private.contents.position;
            true->SetAnswer;
            (XtNwidth,width)->private.theMotifMenubar.setIntegerResource;
            false->SetAnswer;
            (width,height-menubarHeight)->private.contents.size;
            
        if);
        
     #);
     

-- GUIENVwindowOnActivate: DoPart --
do private.contents.theEventHandler.onActivate; INNER onActivate;   

-- GUIENVwindowOnDeactivate: DoPart --
do private.contents.theEventHandler.onDeactivate; INNER onDeactivate;   

-- GUIENVwindowSetTheMenubar: DoPart --
do
     (# theMotifMenubar: ^motifMenubar; applMenubar: ^menubar; 
     do
        assertOpen;
        (if theBar[] <> private.theMenubar[] then
        (* (if private.theMenubar[]<>none then
         *            private.theMotifMenubar.close;
         *            none -> private.theMotifMenubar[];
         *        if);
         *)
            (if theBar[] = none then
                (if private.theMenubar[] <> none then
                    (if menubarVisible then
                        private.theMenubar.scan
                          (# 
                          do current[]->private.theMotifMenubar.delete; 
                          #);
                        
                    if);
                    none ->private.theMenubar[];
                    
                if);
                
             else
                theBar[]->private.theMenubar[];
                (if menubarVisible then theBar[]->appendMenubar;  if);
                
            if);
            
        if);
        
     #)  

-- GUIENVwindowGetTheMenubar: DoPart --
do assertOpen; private.theMenubar[]->theBar[];   

-- GUIENVwindowSetTitle: DoPart --
do assertOpen; (XtNtitle,theTitle[])->setStringResource;   

-- GUIENVwindowGetTitle: DoPart --
do assertOpen; XtNtitle->getStringResource->theTitle[];   

-- GUIENVwindowSetPosition: DoPart --
do
     (# (* geometry: @text(# p: @put; pi: @putint #); *) 
     do
        assertOpen;
        (* This does not convince certain window managers.*)
        (XtNx,pt.h)->setIntegerResource;
        (XtNy,pt.v)->setIntegerResource;
        (* But this does not work?
         * '+'->geometry.p;
         * pt.h->geometry.pi;
         * '+'->geometry.p;
         * pt.v->geometry.pi;
         * 'geometry: '->puttext; geometry[]->putline;
         * (XtNgeometry, geometry[]) -> setStringResource;
         *)
        
     #)  

-- GUIENVwindowGetPosition: DoPart --
do
     (# x,y: @shortRef; 
     do
        assertOpen;
        (THIS(InterfaceObject).private.widgetID,0,0,x[],y[])->XtTranslateCoords;
        x->uShort2Short->pt.h;
        y->uShort2Short->pt.v;
        
     #)  

-- GUIENVwindowSetSize: DoPart --
do
     (# h: @integer; 
     do
        assertOpen;
        (if private.theMotifMenubar[] = none then
            height->h; 
         else
            height+menubarHeight->h; 
        if);
        (if width = 0 then 1->width;  if);
        (if height = 0 then 1->height;  if);
        (XtNwidth,width)->setIntegerResource;
        (XtNheight,h)->setIntegerResource;
        (XtNwidth,width)->private.contentsForm.setIntegerResource;
        (XtNheight,h)->private.contentsForm.setIntegerResource;
        adjustContents;
        
     #)  

-- GUIENVwindowGetSize: DoPart --
do assertOpen; private.contents.size->(width,height);   

-- GUIENVwindowSetFrame: DoPart --
do theFrame.topLeft->position; theFrame.size->size;   

-- GUIENVwindowGetFrame: DoPart --
do position->theFrame.topLeft; size->theFrame.size;   

-- GUIENVwindowInsideRectangle: DoPart --
do size->theRectangle.bottomRight;   

-- GUIENVshowWindow: DoPart --
do assertOpen; widgetID->XtMapWidget; true->private.visible;   

-- GUIENVwindowShowModal: DoPart --
do
   assertOpen;
   (if not private.isModal then
       true->private.isModal;
       (XmNmwmInputMode,MWM_INPUT_PRIMARY_APPLICATION_MODAL)
         ->setIntegerResource;
       show;
       bringToFront;
       (widgetID,1,1)->XtAddGrab;
       l:
       (if private.isModal then
           (THIS(guienv).private.appCon,XtIMAll)->XtAppProcessEvent; restart l; 
       if);
       
   if);
     

-- GUIENVhideWindow: DoPart --
do
   assertOpen;
   (if private.isModal then
       false->private.isModal;
       widgetID->XtRemoveGrab;
       (XmNmwmInputMode,MWM_INPUT_MODELESS)->setIntegerResource;
       
   if);
   widgetID->XtUnmapWidget;
   false->private.visible;
     

-- GUIENVwindowSetMaxSize: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then
       (XtNmaxWidth,width)->setIntegerResource;
       (XtNmaxHeight,height)->setIntegerResource;
       
   if);
     

-- GUIENVwindowGetMaxSize: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then
       XtNmaxWidth->getIntegerResource->width;
       XtNmaxHeight->getIntegerResource->height;
       
   if);
     

-- GUIENVwindowSetMinSize: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then
       (XtNminWidth,width)->setIntegerResource;
       (XtNminHeight,height)->setIntegerResource;
       
   if);
     

-- GUIENVwindowGetMinSize: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then
       XtNminWidth->getIntegerResource->width;
       XtNminHeight->getIntegerResource->height;
       
   if);
     

-- GUIENVwindowBringToFront: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then
       (widgetID->XtDisplay,widgetID->XtWindow)->XRaiseWindow; 
   if);
     

-- GUIENVwindowBringToBack: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then
       (widgetID->XtDisplay,widgetID->XtWindow)->XLowerWindow; 
   if);
     

-- GUIENVwindowBringBehind: DoPart --
do
     (# windowIDs: [2] @integer; dpy: @integer; 
     do
        assertOpen;
        (if widgetID <> 0 then
            widgetID->XtWindow->windowIDs[2];
            widgetID->XtDisplay->dpy;
            (if theWindow[] <> none then
                (if theWindow.widgetID <> 0 then
                    theWindow.widgetID->XtWindow->windowIDs[1];
                    (dpy,@@ windowIDs[1],2)->XRestackWindows;
                    
                if);
                
            if);
            
        if);
        
     #)  

-- GUIENVwindowUpdate: DoPart --
do assertOpen; immediate->private.contents.update;   

-- GUIENVwindowCreate: DoPart --
do
     (#
        args: @argList;
        XtAppCreateShell: external
          (#
             name: [1] @char;
             class: [1] @char;
             widgetClass: @integer;
             display: @integer;
             args: ^argList;
             nArgs: @integer;
             newWidget: @integer;
             
          enter (name,class,widgetclass,display,args[],nArgs)
          do callC
          exit newWidget
          #);
        ID: @integer;
        dpy: @integer;
        
     do
        INNER create;
        (if widgetID = 0 then
            (1,XtNwidth,300)->args.set;
            (2,XtNheight,200)->args.set;
            THIS(guienv).private.display->dpy;
            (THIS(guienv).private.appName,THIS(guienv).private.appClass,
             TopLevelShellWidgetClass,dpy,args[],2)->XtAppCreateShell->ID;
            ID->widgetID;
            (widgetID,0)->XtSetMappedWhenManaged;
            widgetID->XtRealizeWidget;
            
        if);
        
     #)  

-- GUIENVwindowOpen: DoPart --
do
     (#
        parent,contentsWidget: @widget;
        aMenubar: ^menubarType;
        applMenubar: ^menubar;
        args: @argList;
        SetWindowDeleteAction: external
          (# shell: @integer; callback: @integer; 
          enter (shell,callback)
          #);
        callbackAddress: @integer;
        id: @integer;
        t: @text;
        
     do
        THIS(window)[]->getPatternName->title;
        (1,XtNwidth,300)->args.set;
        (2,XtNheight,200)->args.set;
        widgetID->id;
        'contentsform'->appendtick->t;
        (t,XbCanvasWidgetClass,id,args[],2)->XtCreateManagedWidget
          ->private.contentsForm.widgetID;
        (configureEventProcessor##,XStructureNotifyMask)->appendEventProcessor;
        (focusChangeEventProcessor##,XFocusChangeMask)->appendEventProcessor;
        deleteWindowProcessor##->makeCBF->callbackAddress;
        (widgetID,callbackAddress)->SetWindowDeleteAction;
        callbackAddress->addCBF;
        (XmNdeleteResponse,XmDO_NOTHING)->setIntegerResource;
        true->private.visible;
        THIS(window)[]->THIS(guienv).private.windows.append;
        private.contents.open;
        private.contents.widgetID->contentsWidget;
        (if menubarVisible then
            applicationMenubar->applMenubar[];
            (if applMenubar[] <> none then
                applMenubar[]->appendMenubar; 
            if);
            
        if);
        &menubarType[]->aMenubar[];
        (if aMenubar## <> menubar## then
            aMenubar.open; aMenubar[]->theMenubar; 
        if);
        (XtNwidth,300)->setIntegerResource;
        (XtNheight,200)->setIntegerResource;
        INNER open;
        (if private.visible then
            (if THIS(interfaceobject).private.isOpen then
                (if type = windowTypes.dialog then
                    showModal; 
                 else
                    show; 
                if);
                
             else
            (* closed in INNER, e.g. via a showmodal *)
                
            if)
        if);
        
     #)  

-- GUIENVwindowClose: DoPart --
do
   assertOpen;
   INNER close;
   widgetID->XtUnmapWidget;
   (if (private.themenubar[] <> none ) then
       THIS(window)[]->private.themenubar.private.windows.at
         ->private.themenubar.private.windows.delete;
       private.theMotifMenubar.close;
       none ->private.theMotifMenubar[];
       none ->private.themenubar[];
       
   if);
   private.contents.close;
   0->private.contentsForm.widgetID;
   (if private.isModal then
       false->private.isModal; widgetID->XtRemoveGrab; 
   if);
   widgetID->DestroyWidget;
   THIS(window)[]->THIS(guienv).private.windows.at
     ->THIS(guienv).private.windows.delete;
     

-- GUIENVwindowSetTarget: DoPart --
do
     (#
        XmIsTraversable: external
          (# w: @integer; result: @integer;  enter w exit result #);
        result: @integer;
        
     do
        (if theTarget[] = none then
            (private.contents.widgetID,XmTRAVERSE_CURRENT)->XmProcessTraversal; 
         else
            theTarget.widgetID->XmIsTraversable->result;
            (if result <> 0 then (* Kald en exception eller hvad ??? *)  if);
            (theTarget.widgetID,XmTRAVERSE_CURRENT)->XmProcessTraversal->result;
            (if result <> 0 then (* Kald en exception eller hvad ??? *)  if);
            
        if);
        
     #)  

-- GUIENVwindowGetTarget: DoPart --
do private.theTarget[]->theTarget[];   

-- windowitemLib: Attributes --
crossingProcessor: eventProcessor (#  do &crossingSelector[]->es[];  #);
exposeProcessor: eventProcessor (#  do &refreshSelector[]->es[];  #);
buttonPressProcessor: eventProcessor (#  do &mouseDownSelector[]->es[];  #);
buttonReleaseProcessor: eventProcessor (#  do &mouseUpSelector[]->es[];  #);
keyPressProcessor: eventProcessor (#  do &keyDownSelector[]->es[];  #);
focusChangeProcessor: eventProcessor (#  do &selectTarget[]->es[];  #);
crossingSelector: crossingEventSelector
  (# 
  do
     (if type
      // XEnterNotify then
         theEventHandler.onMouseEnter; 
      // XLeaveNotify then
         theEventHandler.onMouseLeave; 
     if);
     
  #);
refreshSelector: exposeEventSelector
  (# 
  do
     ((x,y),(x+width,y+height))->THIS(guienv).private.updateRectAdd;
     (if count = 0 then
         THIS(guienv).private.updateRectFlush; theEventHandler.onRefresh; 
     if);
     
  #);
handleMouseDown:
  (# 
  do
     (if private.delegate then
         (if father[] <> none then
             THIS(guienv).private.x+private.left->THIS(guienv).private.x;
             THIS(guienv).private.y+private.top->THIS(guienv).private.y;
             father.handleMouseDown;
             
         if);
         
      else
         theEventHandler.onMouseDown; 
     if);
     
  #);
mouseDownSelector: buttonEventSelector (#  do handleMouseDown;  #);
handleMouseUp:
  (# 
  do
     (if private.delegate then
         (if father[] <> none then
             THIS(guienv).private.x+private.left->THIS(guienv).private.x;
             THIS(guienv).private.y+private.top->THIS(guienv).private.y;
             father.handleMouseUp;
             
         if);
         
      else
         theEventHandler.onMouseUp; 
     if);
     
  #);
mouseUpSelector: buttonEventSelector (#  do handleMouseUp;  #);
keyDownSelector: KeyEventSelector
  (# skip: @boolean; 
  do
     false->skip;
     (if theChar = 13 then
         (if THIS(window).private.theDefaultButton[] <> none then
             THIS(window).private.theDefaultButton.theEventHandler.onMouseUp;
             true->skip;
             
         if);
         
     if);
     (if not skip then theEventHandler.onKeyDown;  if);
     
  #);
selectTarget: focusChangeEventSelector
  (# 
  do
     (if type = XFocusIn then
         THIS(windowitem)[]->theTarget; theEventHandler.onEnableTarget; 
      else
         theEventHandler.onDisableTarget; none ->theTarget; 
     if);
     
  #);
handleConfigure: configureEventSelector
  (# 
  do
     (if type = XConfigureNotify then
         (if not THIS(windowItem).private.frameChangedHandled then
             (frame,getFrame)->handleframeChanged; 
         if);
         false->THIS(windowItem).private.frameChangedHandled;
         
     if);
     
  #);
configureProcessor: eventProcessor (#  do &handleConfigure[]->es[];  #);
handleFatherframeChanged:
  (# oldFrame,newFrame,chainRect,itsFrame: @rectangle; delta: @Point; 
  enter (oldFrame,newFrame)
  do
     newFrame.size->delta;
     oldFrame.size->delta.subTract;
     (if not ((0,0)->delta.isEqual) then
         frame->chainRect->itsFrame;
         delta->chainRect.offset;
         (if not bindLeft then chainRect.left->itsFrame.left;  if);
         (if bindBottom then chainRect.bottom->itsFrame.bottom if);
         (if bindRight then chainRect.right->itsFrame.right if);
         (if not bindTop then chainRect.top->itsFrame.top if);
         itsFrame->frame;
         
     if);
     (oldFrame,newFrame)->theEventHandler.onFatherframeChanged;
     
  #);
  

-- GUIENVwindowItemHandleFrameChanged: DoPart --
do
     (# thisCanvas: ^canvas; 
     do
        (if not (oldFrame->newFrame.isEqual) then
            newFrame.left->private.left;
            newFrame.right->private.right;
            newFrame.bottom->private.bottom;
            newFrame.top->private.top;
            (oldFrame,newFrame)->theEventHandler.onframeChanged;
            (if father[] <> none then
                (oldFrame,newFrame)->father.handleChildframeChanged; 
            if);
            (if THIS(windowitem)## <= canvas## then
                THIS(windowitem)[]->thisCanvas[];
                thisCanvas.private.children.scan
                  (# 
                  do (oldFrame,newFrame)->current.handleFatherframeChanged; 
                  #);
                
             else
                (if widgetID = 0 then
                      (# 
                      do
                         (father.displayID,father.windowID,oldFrame.left,
                          oldFrame.top,oldFrame.right-oldFrame.left,
                          oldFrame.bottom-oldFrame.top,1)->XClearArea;
                         (father.displayID,father.windowID,newFrame.left,
                          newFrame.top,newFrame.right-newFrame.left,
                          newFrame.bottom-newFrame.top,1)->XClearArea;
                         
                      #);
                    
                 else
                    (displayID,windowID,0,0,newFrame.right-newFrame.left,
                     newFrame.bottom-newFrame.top,1)->XClearArea;
                    
                if);
                
            if);
            
        if);
        
     #)  

-- GUIENVwindowitemOnRefresh: DoPart --
do
     (#
        xmType: @integer;
        topGC: @integer;
        bottomGC: @integer;
        width,height: @integer;
        x,y: @integer;
        drawable: @integer;
        
     do
        INNER onRefresh;
        (if border.visible then
            father.widgetID->GetTopShadowGC->topGC;
            father.widgetID->GetBottomShadowGC->bottomGC;
            size->(width,height);
            (if border.style
             // borderStyles.simple then
                XmSHADOW_IN->xmType; 
             // borderStyles.shadowIn then
                XmSHADOW_IN->xmType; 
             // borderStyles.shadowOut then
                XmSHADOW_OUT->xmType; 
             // borderStyles.etchedIn then
                XmSHADOW_ETCHED_IN->xmType; 
             // borderStyles.etchedOut then
                XmSHADOW_ETCHED_OUT->xmType; 
            if);
            (if widgetID = 0 then
                position->(x,y);
                father.windowID->drawable;
                (THIS(guienv).private.display,drawable,topGC,bottomGC,x,y,width,
                 height,2,xmType)->_XmDrawShadows;
                
             else
                windowID->drawable;
                (THIS(guienv).private.display,drawable,topGC,bottomGC,0,0,width,
                 height,2,xmType)->_XmDrawShadows;
                
            if);
            
        if);
        
     #)  

-- GUIENVwindowitemSetFrame: DoPart --
do
     (# oldFrame: @rectangle; h,v,width,height: @integer; 
     do
        assertOpen;
        frame->oldFrame;
        (if not (theFrame->oldFrame.isEqual) then
            theFrame.topLeft->(h,v);
            theFrame.size->(width,height);
            (if widgetID <> 0 then
                (if width = 0 then 1->width;  if);
                (if height = 0 then 1->height;  if);
                true->SetAnswer;
                (XtNx,h)->setIntegerResource;
                (XtNy,v)->setIntegerResource;
                (XtNwidth,width)->setIntegerResource;
                (XtNheight,height)->setIntegerResource;
                false->SetAnswer;
                
            if);
            (oldFrame,theFrame)->handleFrameChanged;
            true->private.frameChangedHandled;
            
        if);
        
     #)  

-- GUIENVwindowitemGetFrame: DoPart --
do
   assertOpen;
   private.left->theFrame.left;
   private.right->theFrame.right;
   private.top->theFrame.top;
   private.bottom->theFrame.bottom;
     

-- GUIENVwindowitemSetPosition: DoPart --
do
     (# theFrame: @rectangle; 
     do
        assertOpen; pt->theFrame.topLeft; size->theFrame.size; theFrame->frame; 
     #)  

-- GUIENVwindowitemGetPosition: DoPart --
do assertOpen; private.left->pt.h; private.top->pt.v;   

-- GUIENVwindowitemMove: DoPart --
do
     (# pt: @point; 
     do assertOpen; position->pt; (dh,dv)->pt.add; pt->position; 
     #)  

-- GUIENVwindowitemSetSize: DoPart --
do
     (# theFrame: @rectangle; 
     do
        assertOpen;
        position->theFrame.topLeft;
        (width,height)->theFrame.size;
        theFrame->frame;
        
     #)  

-- GUIENVwindowitemGetSize: DoPart --
do
   assertOpen;
   private.right-private.left->width;
   private.bottom-private.top->height;
     

-- GUIENVwindowitemSetVisible: DoPart --
do
   assertOpen;
   (if value <> private.visible then
       value->private.visible;
       (if widgetID <> 0 then
           (if value then
               widgetID->XtMapWidget; 
            else
               widgetID->XtUnmapWidget; 
           if);
           
        else
           update; 
       if);
       theEventHandler.onVisibleChanged;
       
   if);
     

-- GUIENVwindowitemGetVisible: DoPart --
do assertOpen; private.visible->value;   

-- GUIENVwindowitemSetHilite: DoPart --
do assertOpen; value->private.hilite; theEventHandler.onHiliteChanged;   

-- GUIENVwindowitemGetHilite: DoPart --
do assertOpen; private.hilite->value;   

-- GUIENVwindowitemSetEnabled: DoPart --
do
   assertOpen;
   (if value = enabled then (* not changed *)
       
    else
       (if widgetID <> 0 then
           (if value then
               (widgetID,1)->XtSetSensitive; 
            else
               (widgetID,0)->XtSetSensitive; 
           if);
           
       if);
       theEventHandler.onEnabledChanged;
       
   if);
     

-- GUIENVwindowitemGetEnabled: DoPart --
do
   assertOpen;
   (if widgetID <> 0 then (widgetID->XtIsSensitive) <> 0->value;  if);
     

-- GUIENVwindowitemShow: DoPart --
do assertOpen; true->visible;   

-- GUIENVwindowitemHide: DoPart --
do assertOpen; false->visible;   

-- GUIENVwindowitemEnable: DoPart --
do assertOpen; true->enabled;   

-- GUIENVwindowitemDisable: DoPart --
do assertOpen; false->enabled;   

-- windowItemEnterBackgroundColor: DoPart --
do
   assertOpen;
     (#
        pixel: @integer;
        theXColor: @XColor;
        dpy: @integer;
        cmap: @integer;
        screen: @integer;
        result: @integer;
        AllocColor: external
          (# c: ^XColor; dpy: @integer; pixel: @integer; 
          enter (dpy,c[])
          exit pixel
          #);
        
     do
        theColor.red->theXColor.red;
        theColor.green->theXColor.green;
        theColor.blue->theXColor.blue;
        displayID->dpy;
        (dpy,theXColor[])->AllocColor->pixel;
        (if widgetID <> 0 then
            (XtNbackground,pixel)->setIntegerResource; 
        if);
        
     #);
     

-- windowItemExitBackgroundColor: DoPart --
do
   assertOpen;
     (#
        pixel: @integer;
        theXColor: @XColor;
        dpy: @integer;
        colorMap: @integer;
        
     do
        (if widgetID = 0 then
            XtNbackground->father.getIntegerResource->pixel;
            XtNcolorMap->father.getIntegerResource->colorMap;
            
         else
            XtNbackground->getIntegerResource->pixel;
            XtNcolorMap->getIntegerResource->colorMap;
            
        if);
        pixel->theXColor.pixel;
        displayID->dpy;
        (dpy,colorMap,theXColor[])->XQueryColor;
        theXColor.red->theColor.red;
        theXColor.green->theColor.green;
        theXColor.blue->theColor.blue;
        
     #);
     

-- GUIENVwindowitemBorderSetVisible: DoPart --
do
   value->private.borderVisible;
   theEventHandler.onBorderVisibleChanged;
   true->update;
     

-- GUIENVwindowitemBorderGetVisible: DoPart --
do private.borderVisible->value;   

-- GUIENVwindowitemBorderSetStyle: DoPart --
do
   value->private.borderStyle;
   theEventHandler.onBorderStyleChanged;
   true->update;
     

-- GUIENVwindowitemBorderGetStyle: DoPart --
do private.borderStyle->value;   

-- GUIENVwindowiteminsideRectangle: DoPart --
do
   ((0,0),size)->theRectangle;
   (if border.visible then (2,2)->theRectangle.inset;  if);
     

-- GUIENVwindowitemSetTheCursor: DoPart --
do
     (# id: @integer; 
     do
        assertOpen;
        theCur[]->private.theCursor[];
        (if theCur[] = none then 0->ID;  else theCur.private.id->ID;  if);
        (displayID,windowID,ID)->XDefineCursor;
        theEventHandler.onTheCursorChanged;
        (if widgetID <> 0 then widgetID->XmUpdateDisplay;  if);
        
     #)  

-- GUIENVwindowitemGetTheCursor: DoPart --
do private.theCursor[]->theCur[];   

-- GUIENVwindowItemTrackMouse: DoPart --
do
     (#
        typeOffset: (#  exit 0 #);
        serialOffset: (#  exit 4 #);
        send_eventOffset: (#  exit 8 #);
        displayOffset: (#  exit 12 #);
        windowOffset: (#  exit 16 #);
        rootOffset: (#  exit 20 #);
        sub_windowOffset: (#  exit 24 #);
        timeOffset: (#  exit 28 #);
        xOffset: (#  exit 32 #);
        yOffset: (#  exit 36 #);
        x_rootOffset: (#  exit 40 #);
        y_rootOffset: (#  exit 44 #);
        stateOffset: (#  exit 48 #);
        detailOffset: (#  exit 52 #);
        key_codeOffset: (#  exit 52 #);
        buttonOffset: (#  exit 52 #);
        dpy: @integer;
        ID: @integer;
        originX,originY: @integer;
        eventAddress: @integer;
        type: @integer;
        dh,dv,x,y: @integer;
        move: @mouseMove;
        uShort2Short:
          (# value: @integer; 
          enter value
          do (if value > 32768 then value-65536->value;  if); 
          exit value
          #);
        initialize:
          (# x_root,y_root: @shortRef; mask: @integer; status: @integer; 
          do
             displayID->dpy;
             widgetID->ID;
             100->malloc->eventAddress;
             (ID,0,0,x_root[],y_root[])->XtTranslateCoords;
             x_root->uShort2Short->originX;
             y_root->uShort2Short->originY;
             THIS(guienv).private.x_root-originX->curPt.h;
             THIS(guienv).private.y_root-originY->curPt.v;
             curPt->prevPt;
             (if true then
                 XButtonReleaseMask+XButtonPressMask+XPointerMotionMask->mask;
                 (ID,1,mask,grabModeASync,grabModeAsync,0,0,currentTime)
                   ->XtGrabPointer->status;
                 
             if);
             
          #);
        finalize:
          (# 
          do
             eventAddress->free;
             (if true then (ID,currentTime)->XtUnGrabPointer;  if);
             
          #);
        
     do
        initialize;
        mousePress;
        l:
          (# 
          do
             (dpy,eventAddress)->XNextEvent;
             eventAddress+typeOffset->tos'%adrGetLong'->type;
             (if type
              // XMotionNotify then
                 eventAddress+x_rootOffset->tos'%adrGetLong'->x;
                 eventAddress+y_rootOffset->tos'%adrGetLong'->y;
                 x-originX->x;
                 y-originY->y;
                 x-curPt.h->dh;
                 y-curPt.v->dv;
                 curPt->prevPt;
                 (x,y)->curPt;
                 (dh,dv)->move;
                 
              // XButtonrelease then
                 leave l; 
             if);
             restart l;
             
          #);
        mouseRelease;
        finalize;
        
     #)  

-- GUIENVwindowitemDrag: DoPart --
do
   father.graphics
     (# r: @rectangle; overrideChildren:: trueObject
     do
        transferModes.xorBlend->pen.mode;
        father.trackMouse
          (#
             r: @rectangle;
             mousePress::<  (#  do frame->r; r->drawRect;  #);
             mouseMove::< 
               (# 
               do
                  (if ((h <> 0) or (v <> 0)) then
                      r->drawRect; (h,v)->r.offset; r->drawRect; 
                  if);
                  
               #);
             mouseRelease::<  (#  do r->drawRect; r->frame;  #);
             
          #);
        
     #);
     

-- GUIENVwindowitemResize: DoPart --
do
     (# newFrame: @rectangle; w,h: @Integer; 
     do
        frame->father.defineRect1->newFrame;
        newFrame.size->(w,h);
        (w,1)->max->w;
        (h,1)->max->h;
        (w,h)->newFrame.size;
        newFrame->frame;
        
     #)  

-- GUIENVwindowitemUpdate: DoPart --
do
   assertOpen;
   (if widgetID = 0 then
         (# f: @rectangle; 
         do
            frame->f;
            (father.displayID,father.windowID,f.left,f.top,f.right-f.left+1,
             f.bottom-f.top+1,1)->XClearArea;
            (if immediate then father.widgetID->XmUpdateDisplay;  if);
            
         #);
       
    else
       (displayID,windowID,0,0,0,0,1)->XClearArea;
       (if immediate then widgetID->XmUpdateDisplay;  if);
       
   if);
     

-- GUIENVwindowitemCreate: DoPart --
do
     (# origin: ^object; args: @argList; a2o: @addressToObject; 
     do
        true->private.needsWidget;
        (if father[] = none then
            THIS(windowitem)[]->getOrigin->origin[];
            l:
            (if origin[] = none then
                (if THIS(windowitem)[] <> THIS(window).private.contents[] then
                    THIS(window).private.contents[]->father[]; 
                if);
                
             else
                (if (origin## <= canvas##) then
                    origin[]->father[]; 
                 else
                    origin[]->getOrigin->origin[]; restart l; 
                if)
            if);
            
        if);
        INNER create;
        (if widgetID = 0 then
            (if private.needsWidget then
                (xmDrawingAreaWidgetClass,father.widgetID)->createSimple; 
            if);
            
        if);
        
     #)  

-- GUIENVwindowitemOpen: DoPart --
do
     (#
        frameHitMethod: hitMethod
          (# f: @rectangle;  do frame->f; p->f.containsPoint->value;  #);
        f: @rectangle;
        
     do
        true->private.visible;
        false->private.hilite;
        (if father[] <> none then
            THIS(windowitem)[]->father.appendChild; 
        if);
        true->bindLeft->bindTop;
        false->private.borderVisible;
        borderStyles.simple->private.borderStyle;
        (if widgetID <> 0 then
            getFrame->f;
            f.left->private.left;
            f.right->private.right;
            f.bottom->private.bottom;
            f.top->private.top;
            (crossingProcessor##,XEnterWindowMask %bor XLeaveWindowMask)
              ->appendEventProcessor;
            (exposeProcessor##,XExposureMask)->appendEventProcessor;
            (configureProcessor##,XStructureNotifyMask)->appendEventProcessor;
            (keyPressProcessor##,XKeyPressMask)->appendEventProcessor;
            (focusChangeProcessor##,XFocusChangeMask)->appendEventProcessor;
            (buttonPressProcessor##,XButtonPressMask)->appendEventProcessor;
            (buttonReleaseProcessor##,XButtonReleaseMask)->appendEventProcessor
              ->private.mouseUpProcessorAddress;
            
         else
            100->private.right;
            100->private.bottom;
            frameHitMethod##->private.hit##;
            
        if);
        INNER open;
        
     #)  

-- GUIENVwindowitemClose: DoPart --
do
   assertOpen;
   INNER close;
   (if father[] <> none then
       THIS(windowitem)[]->father.selection.remove;
       THIS(windowitem)[]->father.deleteChild;
       
   if);
   widgetID->DestroyWidget;
   none ->private.theCursor[];
     

-- GUIENVstandardMenubarOpen: DoPart --
do
   &fileMenu[]->theFileMenu[];
   (if theFileMenu## <> menu## then
       theFileMenu.open; theFileMenu[]->append; 
    else
       none ->theFileMenu[]; 
   if);
   &editMenu[]->theEditMenu[];
   (if theEditMenu## <> menu## then
       theEditMenu.open; theEditMenu[]->append; 
    else
       none ->theEditMenu[]; 
   if);
   INNER open;
     

-- GUIENVstandardFileMenuOpen: DoPart --
do
   'File'->name;
   newMenuitem.open;
   'New'->newMenuitem.name;
   newMenuitem[]->append;
   openMenuitem.open;
   'Open'->openMenuitem.name;
   openMenuitem[]->append;
   closeMenuitem.open;
   'Close'->closeMenuitem.name;
   closeMenuitem[]->append;
   saveMenuitem.open;
   'Save'->saveMenuitem.name;
   saveMenuitem[]->append;
   saveAsMenuitem.open;
   'Save as'->saveAsMenuitem.name;
   saveAsMenuitem[]->append;
   revertMenuitem.open;
   'Revert'->revertMenuitem.name;
   revertMenuitem[]->append;
   printMenuitem.open;
   'Print'->printMenuitem.name;
   printMenuitem[]->append;
   pageSetupMenuitem.open;
   'Page setup'->pageSetupMenuitem.name;
   pageSetupMenuitem[]->append;
   quitMenuitem.open;
   'Quit'->quitMenuitem.name;
   quitMenuitem[]->append;
   INNER open;
     

-- GUIENVstandardEditMenuOpen: DoPart --
do
   'Edit'->name;
   undoMenuItem.open;
   'Undo'->undoMenuItem.name;
   undoMenuItem[]->append;
   cutMenuItem.open;
   'Cut'->cutMenuItem.name;
   cutMenuItem[]->append;
   copyMenuItem.open;
   'Copy'->copyMenuItem.name;
   copyMenuItem[]->append;
   pasteMenuItem.open;
   'Paste'->pasteMenuItem.name;
   pasteMenuItem[]->append;
   clearMenuItem.open;
   'Clear'->clearMenuItem.name;
   clearMenuItem[]->append;
   INNER open;
     

-- GUIENVwindowGetContents: DoPart --
do private.contents[]->theContents[];   

-- GUIENVwindowSeparatorOnRefresh: DoPart --
do INNER onRefresh;   

-- motifMenuItemLib: Attributes --
handleActivate: motifCallbackSelector
  (# 
  do
     (if THIS(motifMenu).private.isVisible or
     theMenuitem.theEventHandler.onStatus then
         theMenuitem.theEventHandler.onSelect
     if)
  #);
motifMenuItemActivateProcessor: callbackProcessor
  (#  do &handleActivate[]->cb[];  #);
handleCascading: motifCallbackSelector
  (#  do theMotifSubmenu.handleOnSelect;  #);
motifMenuItemCascadingProcessor: callbackProcessor
  (#  do &handleCascading[]->cb[];  #);
handleExpose: exposeEventSelector
  (#  do (if theMenuitem.checked then drawCheckMark;  if);  #);
motifMenuItemExposeProcessor: eventProcessor
  (#  do &handleExpose[]->es[];  #);
handleOnStatus:
  (# enabled: @boolean; 
  do
     (if theMenuitem.theEventHandler.onStatus->enabled then
         (widgetID,1)->XtSetSensitive; 
      else
         (widgetID,0)->XtSetSensitive; 
     if);
     
  #);
drawCheckMark:
  (# windowID,displayID,gcID,screenNumber: @integer; black: @integer; 
  do
     widgetID->XtWindow->windowID;
     widgetID->XtDisplay->displayID;
     displayID->XDefaultScreen->screenNumber;
     (displayID,windowID,0,0)->XCreateGC->gcID;
     (displayID,screenNumber)->XBlackPixel->black;
     (displayID,gcID,black)->XSetForeGround;
     (displayID,windowID,gcID,4,8,6,14)->XDrawLine;
     (displayID,windowID,gcID,6,14,9,4)->XDrawLine;
     (displayID,gcID)->XFreeGC;
     
  #);
  

-- menuitemlib: Attributes --
modifiersToX11Constants:
  (# t: ^text; 
  do
  (* (if private.shift then
   *     'Shift'->t[]
   *  else
   *     (if private.ctrl then
   *         'Ctrl'->t[]; 
   *      else
   *         (if private.alt then 'Alt'->t[] if)
   *     if)
   * if) *)
     &text[]->t[];
     (if private.ctrl then 'Ctrl'->t[];  if);
     (if private.alt then
         (if t.length > 0 then ' '->t.append if); 'Alt'->t.append; 
     if);
     (if private.shift then
         (if t.length > 0 then ' '->t.append if); 'Shift'->t.append; 
     if);
     
  exit t[]
  #);
modifiersToText:
  (# t: ^text; 
  do
     &text[]->t[];
     (if private.ctrl then 'Ctrl+'->t.append;  if);
     (if private.alt then 'Alt+'->t.append;  if);
     (if private.shift then 'Shift+'->t.append;  if);
     
  exit t[]
  #)  

-- GUIENVmotifMenuItemCreate: DoPart --
do
     (#
        args: @argList;
        spk: @specialKeys;
        buildSeparator:
          (# args: @argList; 
          do
             (XmSeparatorWidgetClass,THIS(motifMenu).widgetID,
              'menuseparator'->appendtickref)->createManaged;
             
          #);
        buildCascadeButtonItem:
          (# args: @argList; 
          do
             (XmCascadeButtonWidgetClass,THIS(motifMenu).widgetID,
              'menucascade'->appendtickref)->createManaged;
             (motifMenuItemCascadingProcessor##,XmNcascadingCallback)
               ->addCallbackProcessor;
             &motifMenu[]->theMotifSubMenu[];
             theMenuitem.subMenu->theMotifSubMenu.theMenu[];
             THIS(motifMenu)[]->theMotifSubMenu.owner[];
             theMotifSubMenu.open;
             (XmNsubMenuID,theMotifSubMenu.widgetID)->setIntegerResource;
             
          #);
        buildPushButtonItem:
          (# 
          do
             (XmPushButtonWidgetClass,THIS(motifmenu).widgetID,
              'pushbuttonitem'->appendTickref)->createManaged;
             (* 'The above menuitem is "'->puttext;
              * themenuitem.name->puttext;
              * '" belonging to menu "'->puttext;
              * themenu.name->puttext;
              * '" '-> putline;
              *)
             (motifMenuItemExposeProcessor##,XExposureMask)
               ->appendEventProcessor;
             (motifMenuItemActivateProcessor##,XmNActivateCallback)
               ->addCallbackProcessor;
             
          #);
        t: @text;
        
     do
        (if theMenuitem## <= theMenu.separator## then
            buildSeparator; 
         else
            (if theMenuitem.subMenu = none then
                buildPushButtonItem; 
             else
                buildCascadeButtonItem; 
            if);
            
        if);
        (XmNlabelString,theMenuitem.name)->setMotifStringResource;
        (XmNmarginLeft,15)->setIntegerResource;
        (if theMenuitem.key <> 0 then
            t.clear;
            'Ctrl<Key>'->t.append;
            theMenuitem.key->keytoMotifVK->t.append;
            (XmNaccelerator,t[])->setStringResource;
            'Ctrl+'->t;
            theMenuitem.key->spk.keytotext->t.append;
            (XmNacceleratorText,t[])->setMotifStringResource;
            
        if);
        (if theMenuitem.private.speckey <> 0 then
            t.clear;
            (if theMenuitem.private.hasmod then
                theMenuitem.modifiersToText->t.append; 
            if);
            theMenuitem.private.speckey->spk.keyToText->t.append;
            (XmNacceleratorText,t[])->setMotifStringResource;
            t.clear;
            theMenuitem.modifiersToX11Constants->t.append;
            '<Key>'->t.append;
            theMenuitem.private.speckey->keytoMotifVK->t.append;
            (XmNaccelerator,t[])->setStringResource
        if);
        THIS(motifMenuitem)[]->THIS(motifMenu).private.motifMenuitems.append;
        
     #)  

-- GUIENVmotifMenuItemClose: DoPart --
do widgetID->DestroyWidget;   

-- GUIENVmotifMenuGetItemByNumber: DoPart --
do
     (# i: @integer; 
     do
        l: private.motifMenuItems.scan
          (# 
          do
             i+1->i;
             (if i = position then
                 current[]->theMotifMenuItem[]; leave l; 
             if);
             
          #);
        
     #);
     

-- GUIENVmenuitemscanMotifMenuItems: DoPart --
do
   THIS(menu).private.motifMenus.scan
     (# 
     do
        current[]->currentMotifMenu[];
        position->current.getItemByNumber->THIS(scanMotifMenuItems).current[];
        INNER scanMotifMenuItems;
        
     #);
     

-- GUIENVinterfaceObjectappendEventProcessor: DoPart --
do (private.widgetID,type,0,address,0,XtListTail)->XtInsertEventHandler;   

-- GUIENVinterfaceObjectPrependEventProcessor: DoPart --
do (private.widgetID,type,0,address,0,XtListHead)->XtInsertEventHandler;   

-- GUIENVinterfaceObjectAddCallbackProcessor: DoPart --
do (private.widgetID,type,address,0)->XtAddCallback;   

-- GUIENVinterfaceObjectAddCallbackProcessorForSubWidget: DoPart --
do (subWidget,type,address,0)->XtAddCallback;   

-- GUIENVinterfaceObjectappendEventProcessorForSubWidget: DoPart --
do (widget,type,0,address,0,XtListTail)->XtInsertEventHandler;   

-- GUIENVinterfaceObjectAddCallbackPrefix: DoPart --
do
   callback##->makeCBF->address;
   INNER ;
   1->private.callbacks.extend;
   (* FIXME: kvadratisk samlet tid !! *)
   address->private.callbacks[private.callbacks.range];
     

-- GUIENVupdateRect: DoPart --
do THIS(guienv).private.damaged[]->value[];   

-- GUIENVwindowItemSetXBorder: DoPart --
do
   true->SetAnswer;
   (XtNborderWidth,width)->setIntegerResource;
   false->SetAnswer;
     

-- windowEnterVisible: DoPart --
do
   assertOpen;
   (if value <> private.visible then
       (if value then show;  else hide;  if); 
   if);
     

-- windowExitVisible: DoPart --
do assertOpen; private.visible->value;   

-- guienvFitToContents: DoPart --
do INNER ; (if not doneInInner then preferredSize->size;  if);   

-- GUIENVPrependAction: DoPart --
do theAction[]->private.beforeKeyDown.prepend;   

-- GUIENVAppendAction: DoPart --
do theAction[]->private.afterKeyDown.append;   

