ORIGIN 'guienv_unixprivate';
BUILD default '$$/guienv_unix.o' 'external/guienv_unix.c' 
      '$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/Canvas.o' 'external/Canvas.c' 
      '$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/Button.o' 'external/Button.c' 
      '$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/IconButton.o' 'external/IconButton.c' 
      '$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BUILD default '$$/ToggleButton.o' 'external/ToggleButton.c' 
      '$CC -D$$ -I/usr/include -I$MOTIFINC -c -o $0 $1';
BODY 'develop';
INCLUDE '~beta/Xt/v1.10/events';
INCLUDE '~beta/sysutils/v1.6/cstring';
INCLUDE 'widget';
INCLUDE 'guienvattributes';
INCLUDE 'motifstuff';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '../../graphics';
INCLUDE 'rubberband';
INCLUDE 'callbacks';
INCLUDE 'error';
INCLUDE '../../utils/guienvadds';

-- GUIENVwindowLocalCoordsToGlobal: doPart --
do (# x_root, y_root: @shortRef;
      ID: @integer;
      x, y: @integer;
   do widgetID -> ID;
      (ID, local.h, local.v, x_root[], y_root[]) -> XtTranslateCoords;
      x_root -> uShort2Short -> x;
      y_root -> uShort2Short -> y;
      (x, y) -> global;
   #);

-- GUIENVwindowGlobalToLocal: doPart --
do global -> local;
   (0, 0) -> localToGlobal -> local.subtract;


-- lib: attributes --

uShort2Short:
  (# value: @integer;
  enter value
  do  (if value > 32768 then
           value - 65536 -> value;
      if);
  exit value
  #);


putPoint:
  (# p: @point
  enter p
  do '(' -> put;
     p.h -> putInt;
     ',' -> put;
     p.v -> putInt;
     ')' -> put;
  #);
putRectangle:
  (# r: @rectangle;
  enter r
  do r.topLeft -> putPoint;
     r.bottomRight -> putPoint;
  #);

-- guienvLib: attributes --

initX:
  (# XtAppSetFallbackResources: external
       (# appcontext: @integer;
          resources: @integer;
       enter (appcontext,resources)
       #);
     initAppName:
       (* initializes private.appName to the name of the executed file
        * with the first letter in uppercase
        *)
       (# lastSlash: @integer;
       do 1 -> arguments -> private.appName[];
          '/' -> private.appName.findAll(# do inx->lastSlash #);
          (if lastSlash<>0 then (1,lastSlash)->private.appName.delete if);
          (1->private.appName.inxGet->ascii.upcase, 1) -> private.appName.inxPut;
          trace
          (#
          do 'initAppName: ' -> putText;
             private.appName[] -> putLine;
          #);
       #);
     initAppClass:
       (* initializes private.appClass to the name of the executed file with
        * the first letter in uppercase. If the first letter i X the second 
        * letter is also converted to uppercase
        *)
       (# lastSlash: @integer;
       do 1 -> arguments -> private.appClass[];
          '/' -> private.appClass.findAll(# do inx->lastSlash #);
          (if lastSlash<>0 then (1,lastSlash)->private.appClass.delete if);
          (1->private.appClass.inxGet->ascii.upcase, 1) -> private.appClass.inxPut;
          (if ((1->private.appClass.inxGet)='X') and (private.appClass.length>1) then 
              (2->private.appClass.inxGet->ascii.upcase, 2) -> private.appClass.inxPut;
          if);
          trace
          (#
          do 'initAppClass: ' -> putText;
             private.appClass[] -> putLine;
          #);
       #);
     XtOpenDisplay: external
       (# appContext: @integer;
          displayString: @integer;
          name,class: [1]@char;
          options: ^cStruct; 
          nOptions: @integer;
          argcaddr,argvaddr: @integer;
          display: @integer
       enter (appContext,displayString,name,class,options[],nOptions,argcaddr,argvaddr)
       do callC
       exit display
       #);
  do XtToolkitInitialize;
     XtCreateApplicationContext -> private.appCon;
     initAppName;
     initAppClass;
     private.fallBackResources.init;
     (private.appCon,private.fallBackResources.address) -> XtAppSetFallbackResources;
     (private.appCon,0,
     private.appName,private.appClass,private.options[],0,getargc,getargv) 
       -> XtOpenDisplay -> private.display;
     (&errorHandler[]).install;
  #);
init:
  (# 
     initMenubar:
       (# theBar: ^menubarType;
       do &menubarType[] -> theBar[];
          (if theBar## <> menubar## then
              theBar.open;
              theBar[] -> applicationMenubar;
          if);
       #);
     initCursors:
       (# 
       do (display,XC_left_ptr) -> XCreateFontCursor -> cursors.arrow.private.id;
          (display,XC_xterm) -> XCreateFontCursor -> cursors.ibeam.private.id;
          (display,XC_watch) -> XCreateFontCursor -> cursors.watch.private.id;
          (display,XC_crosshair) -> XCreateFontCursor -> cursors.cross.private.id;
          (display,XC_cross) -> XCreateFontCursor -> cursors.plus.private.id;
       #);
     initBitmaps:
       (# bm: ^pixmap;
          getblack: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getwhite: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getgray: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getlightgray: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          getdarkgray: external
            (# dpy,root: @integer;
               pix: @integer;
            enter (dpy,root)
            exit pix
            #);
          root: @integer;
          makePixmap:
            (# pixmapID: @integer;
               thePixmap: ^pixmap;
            enter pixmapID
            do &pixmap[] -> thePixmap[];
               pixmapID -> thePixmap.private.pixmapID;
               1 -> thePixmap.private.depth;
            exit thePixmap[]
            #);
       do display -> XDefaultRootWindow -> root;
          (display, root) -> getwhite -> makePixmap -> patterns.white[];
          (display,root) -> getblack -> makePixmap  -> patterns.black[];
          (display,root) -> getlightgray -> makePixmap -> patterns.ltgray[];
          (display,root) -> getgray -> makePixmap -> patterns.gray[];
          (display,root) -> getdarkgray -> makePixmap -> patterns.dkgray[]; 
       #);
     internAtoms:
       (# 
       do (private.display, 'WM_DELETE_WINDOW', 0) 
            -> XInternAtom -> private.wmDeleteWindowAtom;
          (private.display, 'WM_PROTOCOLS', 0) 
            -> XInternAtom -> private.wmProtocolsAtom;
       #);
     
     argv,argc: @integer;
     
     initUpdateCompression:
       (# 
       do MaxInt -> private.updateLeft -> private.updateTop;
          MinInt -> private.updateRight -> private.updateBottom;
       #);
     
     (* bifrost begin *)
     initDeviceInfo: 
       (# 
       do 
          (if debugGraphic then 'InitDevice ... ' -> puttext if);
          private.display -> XDefaultScreenOfDisplay 
            -> private.defaultScreen;
          private.display -> XDefaultScreen
            -> private.defaultScreenNumber;
          private.defaultScreen -> XDefaultDepthOfScreen
            -> private.defaultdepth;
          private.defaultScreen -> XDefaultVisualOfScreen 
            -> private.defaultVisual;
          private.defaultScreen -> XRootWindowOfScreen
            -> private.defaultDrawable; 
          
          private.defaultScreen -> XDefaultColorMapOfScreen
            -> private.xcolormap;
          private.defaultScreen -> XBlackPixelOfScreen
            -> private.blackpixelvalue;
          private.defaultScreen -> XWhitePixelOfScreen
            -> private.whitepixelvalue;
          
          (private.defaultScreen->XHeightOfScreen->private.screenHeight) div
          ((private.display,private.defaultScreenNumber)-> XDisplayHeightMM)
            -> Private.pixelsPerMillimeterHeight;
          
          (private.defaultScreen->XWidthOfScreen->private.screenWidth) div
          ((private.display, private.defaultScreenNumber) -> XDisplayWidthMM)
            -> Private.pixelsPerMillimeterWidth;
          
          (if debugGraphic then 'done' -> putline if);
       #);
     initBifrost:
       (# 
       do true -> displaywarnings;
          bifrostprivate.PH.init;
       #);
     (* bifrost end *)
     
     initGC:
       (#
       do (private.display, private.theDeviceInfo.defaultDrawable,
          0, 0) -> XCreateGC -> private.gc;
       #);
  do inittickcount;
     private.theXtlib.init;
     
     private.options.init;
     &deviceInfo[] -> private.theDeviceInfo[] -> objectPool.put;
     
     (if private.display=0 then
         (normal, 'Cannot open display') -> stop;
      else
         private.display -> private.theDeviceInfo.init;
         initGC;
         initCursors;
         initBitmaps;
         initMenubar;
         internAtoms;
         initUpdateCompression;
         initDeviceInfo; (* bifrost *)
         initBifrost; (* bifrost *)
         (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
         true -> setupDone;
         (* private.handleIdle.add; *)
     if);
  #);

DestroyWidget:
  (# ID: @integer; (* T:@text; *)
  enter ID
  do (if ID=0 then
         (* (failureTrace, 'Attempt to destroy NULL widget') -> stop; *)
      else
         (* 'DestroyWidget: ID='->puttext; ID->putint; 
          * ', name='''->puttext; ID->XtName->T;t[]->puttext;
          * ''''->puttext; newline;
          *)
         ID -> XtDestroyWidget;
         (* (display,0) -> XSync; *)
     if);
  #);

SetAnswer: external
  (# value: @Boolean;
  enter value
  #);

menubarHeight: (# exit 30 #);
inittickcount: external
  (# 
  #);
tickcount: external
  (# ticks: @integer;
  exit ticks
  #);
appendTickRef:
  (# t: ^text;
  enter t[]
  do '_'->T.append;
     tickcount->T.putint;
  exit t[]
  #);
appendtick:
  (# T: ^text
  enter t[]
  do t[]->appendtickref->t[]
  exit t
  #);
GetTopShadowGC: external
  (* The widget must be a manager widget or descendant thereof *)
  (# w: @integer; (* The Manager widget *)
     gc: @integer; (* The gc that should be used for the top shadow *)
  enter w
  exit gc
  #);
GetBottomShadowGC: external
  (* The widget must be a manager widget or descendant thereof *)
  (# w: @integer; (* The Manager widget *)
     gc: @integer; (* The gc that should be used for the bottom shadow *)
  enter w
  exit gc
  #);
_XmDrawShadows: external
  (# display,drawable,topgc,bottomgc,x,y,width,height,thickness,type: @integer;
  enter (display,drawable,topgc,bottomgc,x,y,width,height,thickness,type)
     
  #);
-- interfaceObjectLib: attributes --
XtAddCallback: external
  (# widget: @integer;
     name: @integer;
     callbackP: @integer;
     clientData: @integer;
  enter (widget, name, callbackP, clientData)
  #);
destroyCallbackSelector: callbackSelector
  (# T:@text;
  do (* 'DestroyCallback: guienv ID='->puttext; private.widgetID->putint; 
      * ' motif ID='->puttext; widget->putint;
      * ', name='''->puttext; widget->XtName->T;t[]->puttext;
      * ''''->puttext; newline;
      *)
     (for inx: private.callbacks.range repeat
          private.callbacks[inx] -> freeCBF;
     for);
     0 -> private.callbacks.new;
     false -> private.beingClosed;
     0 -> private.widgetID;
     
  #);
destroyCallbackProcessor: callbackProcessor
  (# 
  do &destroyCallbackSelector[] -> cb[];
  #);

eventDisabled: booleanValue
  (# ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]=none then
         false -> value;
      else
         ev## -> private.disabledEvents.has -> value;
     if); 
  #);
addDisabledEvent:
  (# e: ^eventSpec;
     ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]=none then
        &eventSpecList[] -> private.disabledEvents[];
     if);
     (if not (ev## -> private.disabledEvents.has) then
         &eventSpec[] -> e[];
         ev## -> e.type##;
         e[] -> private.disabledEvents.append;
     if);
  #);
removeDisabledEvent:
  (# ev: ##theEventHandler.event;
  enter ev##
  do (if private.disabledEvents[]<>none then
         ev## -> private.disabledEvents.remove;
     if);
  #);
addCBF:
  (# cbf: @integer;
  enter cbf
  do 1 -> private.callbacks.extend;
     cbf -> private.callbacks[private.callbacks.range];
  #);

-- motifMenuLib: attributes --

unmapcallbackSelector: callbackSelector
  (# 
  do (if popdownHook[] <> NONE then
         popdownHook;
     if);
     
     (* enable all motifmenuitems to make keyboard shortcuts work without having to
      * post the menu first to evaluate item.onStatus.
      *)
     private.motifMenuitems.scan
     (# 
     do (current.widgetID,1) -> XtSetSensitive;
     #);
     false -> private.isVisible;
  #);
unmapCallbackProcessor: callbackProcessor
  (# 
  do &unmapCallbackSelector[] -> cb[];
  #);

handleOnSelect:
  (# 
  do true -> private.isVisible;
     theMenu.theEventHandler.onSelect;
     private.motifMenuItems.scan
     (# 
     do current.handleOnStatus; 
     #)
  #);
setKey:
  (# position: @integer;
     key: @char;
     theMotifMenuItem: ^motifMenuitem;
     t: @text;
  enter (position,key)
  do position -> getItemByNumber -> theMotifMenuItem[];
     t.clear;
     'Ctrl-' -> t.putText;
     key -> t.put;
     (XmNacceleratorText,t[]) -> theMotifMenuItem.setMotifStringResource;
     t.clear;
     'Ctrl<Key>' -> t.putText;
     key -> t.put;
     (XmNaccelerator,t[]) -> theMotifMenuItem.setStringResource;
  #);
setName:
  (# position: @integer;
     name: ^text;
     theMotifMenuItem: ^motifMenuitem;
  enter (position,name[])
  do position -> getItemByNumber -> theMotifMenuItem[];
     (XmNlabelString,name[]) -> theMotifMenuItem.setMotifStringResource;
  #);
setChecked:
  (# position: @integer;
     checked: @boolean;
     theMotifMenuItem: ^motifMenuitem;
  enter (position,checked)
  do position -> getItemByNumber -> theMotifMenuItem[];
     checked -> theMotifMenuItem.checked;
  #);
setSubMenu:
  (# position: @integer;
     theMotifMenuItem: ^motifMenuitem;
     theMenu: ^menu;
  enter(position,theMenu[])
  do position -> getItemByNumber -> theMotifMenuItem[];
     (if theMotifMenuItem.theMotifSubmenu[]<>none then
         theMotifMenuItem.theMotifSubmenu.close;
     if);
     (if theMenu[]=none then
         none -> theMotifMenuItem.theMotifSubmenu[];
         (XmNsubMenuID,0) -> theMotifMenuItem.setIntegerResource;
      else
         &motifMenu[] -> theMotifMenuItem.theMotifSubmenu[];
         theMenu[] -> theMotifMenuItem.theMotifSubMenu.theMenu[];
         this(motifMenu)[] -> theMotifMenuItem.theMotifSubMenu.owner[];
         theMotifMenuItem.theMotifSubMenu.open;
         (XmNsubMenuID,theMotifMenuItem.theMotifSubMenu.widgetID) 
           -> theMotifMenuItem.setIntegerResource;
     if);
  #);


-- GUIENVmotifMenuappend: doPart --
do (# theMotifMenuItem: ^motifMenuitem;
   do &motifMenuitem[] -> theMotifMenuItem[];
      theItem[] -> theMotifMenuItem.theMenuitem[];
      theMotifMenuItem.open;
   #);
   
-- GUIENVmotifMenudelete: doPart --
do (# theMotifItem: ^motifMenuitem;
   do l: private.motifMenuItems.scan
      (# 
      do (if theItem[]=current.theMenuitem[] then
             current[] -> theMotifItem[];
             leave l;
         if);
      #);
      (if theMotifItem[]<>none then
          theMotifItem[] ->  private.motifMenuItems.remove;
          theMotifItem.close;
      if);
   #)

-- GUIENVmotifMenuCreate: doPart --
do (# name: ^text;
      args: @argList;
   do theMenu.name -> name[];
      tickCount -> name.putInt;
      (if popup then
          (owner.widgetID,name,args[],0) -> XmCreatePopupMenu -> widgetID;
          (* 'Created motif popup menu widget: ID = ' -> putText;
           * widgetID -> putInt;
           * ' name = ' -> putText;
           * name[] -> putline;
           *)
       else
          (owner.widgetID,name,args[],0) -> XmCreatePullDownMenu -> widgetID;
          (* 'Created pulldown menu widget: ID = ' -> putText;
           * widgetID -> putInt;
           * ' name = ' -> putText;
           * name[] -> putline;
           *)
          (unmapCallbackProcessor##, XmNunmapCallback) -> addCallbackProcessor;
      if);
      theMenu.scan
      (# theMotifMenuitem: ^motifMenuitem;
      do &motifMenuitem[] -> theMotifMenuitem[];
         current[] -> theMotifMenuitem.theMenuitem[];
         theMotifMenuitem.open;
      #);
      (if themenu.enabled then
          (widgetID,1) -> XtSetSensitive;
       else
          (widgetID,0) -> XtSetSensitive;
      if);
      this(motifMenu)[] -> theMenu.private.motifMenus.append;
   #);

-- GUIENVmotifMenuOpen: doPart --
do inner open;
   
-- GUIENVmotifMenuClose: doPart --
do private.motifMenuitems.scan
   (# 
   do current.close;
   #);
   private.motifMenuitems.clear;
   this(motifMenu)[] -> theMenu.private.motifMenus.remove;
   widgetID -> DestroyWidget; 
   
-- GUIENVmotifMenugetNumberOfWidget: doPart --
do (# inx: @integer;
   do 0 -> inx;
      l: private.motifMenuitems.scan
      (# 
      do inx + 1 -> inx;
         (if current.widgetID=widget then
             inx -> position;
             leave l
         if);
      #);
      
   #);
   
   
-- GUIENVmotifMenuPrivate: descriptor --
(# motifMenuItems: @list
     (# element::< motifMenuitem;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
     #);
   isVisible: @boolean;
#)

-- motifMenubarLib: attributes --

cascadeButton: interfaceObject
  (# theMotifmenu: ^motifMenu;
     open::<
       (# create::<
            (# args: @argList;
               mstr: @motifString;
            do theMotifmenu.theMenu.name -> mstr.setText;
               ('cascadebutton',xmCascadeButtonWidgetClass,this(motifMenubar).widgetID,args[],0) 
                 -> XtCreateWidget -> widgetID;
               manage;
               (cascadingProcessor##, XmNcascadingCallback) -> addCallbackProcessor;
               (1,XmNlabelString,mstr) -> args.set;
               (2,XmNsubMenuId,theMotifMenu.widgetID) -> args.set;
               (widgetID,args[],2) -> XtSetValues;
              ;
            #);
       #);
     close::<
       (# 
       do widgetID -> DestroyWidget;
       #);
      handleCascading: MotifcallbackSelector
       (# 
       do theMotifmenu.handleOnSelect;
       #);
     cascadingProcessor: callbackProcessor
       (# 
       do &handleCascading[] -> cb[];
       #);
  #);

-- GUIENVmotifMenubarappend: doPart --
do (# theCascadeButton: ^cascadeButton;
      theMotifMenu: ^motifMenu;
   do &motifMenu[] -> theMotifMenu[];
      this(motifMenubar)[] -> theMotifMenu.owner[];
      theMenu[] -> theMotifMenu.theMenu[];
      theMotifMenu.open;
      &cascadeButton[] -> theCascadeButton[];
      theMotifMenu[] -> theCascadeButton.theMotifMenu[];
      theCascadeButton.open;
      theMotifMenu[] -> private.motifMenus.append;
      theCascadeButton[] -> private.cascadeButtons.append;
   #);

-- GUIENVmotifMenubardelete: doPart --
do (# theCascadeButton: ^cascadeButton;
      theMotifMenu: ^motifMenu;
   do theMenu[] -> private.motifMenus.findMenu -> theMotifMenu[];
      theMotifMenu[] -> private.cascadeButtons.findButton -> theCascadeButton[];
      (if theCascadeButton[]<>none then
          theCascadeButton.close;
          theCascadeButton[] -> private.cascadeButtons.remove;
      if);
      theMotifMenu[] -> private.motifMenus.remove;
      theMotifMenu.close;
   #)

-- GUIENVmotifMenubarcreate: doPart --
do (# args: @argList;
      theFuncPtr: @integer;
      T: @text;
   do (1,XtNheight,menubarHeight) -> args.set;
      (theWindow.private.contentsForm.widgetID,'Menubar'->appendTick->T,args[],1) 
        -> XmCreateMenuBar -> widgetID;
      (* 'Created menubar widget: ID = ' -> putText;
       * widgetID -> putInt;
       * ' name = ' -> putText;
       * T[] -> putline;
       *)
      (XmNresizeWidth,0) -> setIntegerResource;
      (XmNresizeHeight,0) -> setIntegerResource;
      (XmNresizable,true) -> setBooleanResource;
      widgetID -> XtManageChild;
   #)

-- GUIENVmotifMenubaropen: doPart --
do
   
-- GUIENVmotifMenubarClose: doPart --
do private.motifMenus.scan
   (# 
   do (current[] -> private.cascadeButtons.findButton).close;
      current.close;
   #);
   private.motifMenus.clear;
   widgetID -> DestroyWidget;
   
   
-- GUIENVmotifMenubarprivate: descriptor --
(# motifmenus: @list
     (# element::< motifMenu;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
        findMenu:
          (# theMotifMenu: ^motifMenu;
             theMenu: ^menu;
          enter theMenu[]
          do l: scan
               (# 
               do (if current.theMenu[]=theMenu[] then
                      current[] -> theMotifMenu[];
                      leave l;
                  if);
               #);
          exit theMotifMenu[]
          #);
     #);
   cascadeButtons: @list
     (# element::< cascadeButton;
        remove:
          (# e: ^element;
          enter e[]
          do e[] -> at -> delete;
          #);
        findButton:
          (# theMotifMenu: ^motifMenu;
             theButton: ^cascadeButton;
          enter theMotifMenu[]
          do l: scan
               (# 
               do (if current.theMotifMenu[]=theMotifMenu[] then
                      current[] -> theButton[];
                      leave l;
                  if);
               #);
          exit theButton[]
          #);
     #);
#)

--- GUIENVterminateBody: descriptor ---
(#
do Stop;
#)
--- GUIENVsetTheMenubar: descriptor ---
(# XtAppCreateShell: external
     (# name: [1] @char;
        class: [1] @char;
        widgetClass: @integer;
        display: @integer;
        args: ^argList;
        nArgs: @integer;
        newWidget: @integer;
     enter (name,class,widgetclass,display,args[],nArgs)
     do callC
     exit newWidget
     #);
do themenubar[] -> private.theMenubar[];
   
#)
--- GUIENVgetTheMenubar: descriptor ---
(# 
do private.theMenubar[] -> themenubar[];
#)

--- GUIENVdoSetUp: descriptor ---
(#
do initX;
   init;
#)

-- GUIENVdoPart: descriptor --
(# aWindow: @window
     (#
        open::
          (#
          do '' -> Title;
             (680, 20) -> size;
          #);
     #);
do 
   (* SBRANDT 19/4/94: To avoid doSetUp from being called twice. *)
   (if not setupDone then 
       doSetUp;
   if);
   onStartApplication;
   inner guienv;
   (if applicationMenuBar <> NONE then
       (if private.windows.empty then
           aWindow.open;
       if);
   if);
   
   (if not private.dontRunLoop then
       private.appcon -> XtAppMainLoop;
       (* the control is transferred to xtoolkit
        * the rest is handled via callbacks
        *)
   if);
#)

--- GUIENVmouseDownDelay: descriptor ---
(# ticks: @integer;
   start: @integer;
do tickCount -> start;
   l:
     (if mouse.buttonState=buttonState then
         tickCount -> ticks;
         (if ((ticks - start) < period) then
             restart l;
          else
             inner delay;
         if);
     if);
#)

-- GUIENVinterfaceObjectEvent: descriptor --
(# 
do (if not (this(event)## -> eventDisabled) then
       (if private.beforeActions[]<>None then
           private.beforeActions.scan
           (# 
           do (if (current.eventType## >= this(event)##) then
                  this(event)[] -> current;
              if);
           #);
       if);
       inner event;
       (if private.afterActions[]<>None then
           private.afterActions.scan
           (# 
           do (if (current.eventType## >= this(event)##) then
                  this(event)[] -> current;
              if);
           #);
       if);
   if);
#)

-- GUIENVbasicEventShiftKey: descriptor --
(#
do (((this(guienv).private.state,shiftMask) -> tos'%and')=shiftMask) -> value;
#)

-- GUIENVbasicEventAltKey: descriptor --
(#
do (* Not Implemented !!! *)
#)

-- GUIENVbasicEventMetaKey: descriptor --

(#  
do (((this(guienv).private.state,mod1Mask) -> tos'%and')=mod1Mask) -> value;
#)

-- GUIENVbasicEventControlKey: descriptor --

(#
do (((this(guienv).private.state,controlMask) -> tos'%and')=controlMask) -> value;
#)

-- GUIENVbasicEventButtonState: descriptor --

(#
do this(guienv).private.detail -> value;
#)

-- GUIENVbasicEventWhen: descriptor --

(#
do this(guienv).private.time -> value;
#)

-- GUIENVbasicEventGlobalPosition: descriptor --

(#
do (this(guienv).private.x_root, this(guienv).private.y_root) -> p;
#)

-- GUIENVbasicEventLocalPosition: descriptor --

(#
do (this(guienv).private.x, this(guienv).private.y) -> p;
#)

-- GUIENVmouseEventDoubleClick: descriptor --
(# 
do this(guienv).private.doubleClick -> value;
#)

-- GUIENVkeyEventCh: descriptor --
(#   
do this(guienv).private.theChar -> theChar;  
#)

-- GUIENVinterfaceObjectPrependAction: descriptor --
(# 
do (if private.beforeActions[]=none then
       &actionList[] -> private.beforeActions[];
   if);
   (if not (theAction[] -> private.beforeActions.member) then
       theAction[] -> private.beforeActions.prepend;
   if);
#)

-- GUIENVinterfaceObjectAppendAction: descriptor --
(# 
do (if private.afterActions[]=none then
       &actionList[] -> private.afterActions[];
   if);
   (if not (theAction[] -> private.afterActions.member) then
       theAction[] -> private.afterActions.append;
   if);
#)

-- GUIENVinterfaceObjectDeleteAction: descriptor --
(# 
do 
   (if private.beforeActions[]<>none then
       theAction[] -> private.beforeActions.delete;
   if);
   (if private.afterActions[]<>none then
       theAction[] -> private.afterActions.delete;
   if);
#)


--- GUIENVinterfaceObjectOpen: descriptor ---
(# openTwiceException: exception
     (# 
     do 'Attempt to open interfaceobject twice: ' -> msg;
        THIS(InterfaceObject)[]->getpatternname->msg.append
     #);
do  (if not private.isOpen then
        true -> private.isOpen;
        create;
        (if private.widgetID<>0 then
            (destroyCallbackProcessor##, XtNdestroyCallback) -> addCallbackProcessor;
        if);
        inner open;
     else
        openTwiceException;
    if);
#)

-- GUIENVintefaceObjectCreate: descriptor --
(#
do inner create;
#)

--- GUIENVinterfaceObjectClose: descriptor ---
assertOpen
(# location::(# do 'InterfaceObject.close'->t[] #);
do inner close;
   false -> private.isOpen;
   true -> private.beingClosed;
#)
--- GUIENVenableEventType: descriptor ---
(#
do ev## -> removeDisabledEvent;
#)
--- GUIENVdisableEventType: descriptor ---
(# 
do ev## -> addDisabledEvent;
#)


--- GUIENVinterfaceObjectException: descriptor ---
(# 
do 'interfaceobject-exception for ' -> msg.putText;
   THIS(interfaceObject)[] -> getPatternName -> msg.putText;
   msg.newline;
   inner interfaceObjectException;
#)

-- GUIENVnotOpenedException: descriptor --
(# 
do 'Attempt to use '''->msg.puttext;
   (if location[]<>NONE then
       location[]->msg.puttext;
       ''' in ''' -> msg.puttext;
   if);
   THIS(interfaceobject)[] -> getpatternname -> msg.puttext;
   ''' which is not ''open''' -> msg.putline;
   inner notOpenedException;
#)

-- GUIENVseparatorSetStyle: doPart --
do (# xmStyle: @integer;
   do value -> private.style;
      (if value
       //separatorStyles.singleLine then XmSINGLE_LINE -> xmStyle;
       //separatorStyles.doubleLine then XmDOUBLE_LINE -> xmStyle;
       //separatorStyles.singleDashedLine then XmSINGLE_DASHED_LINE -> xmStyle;
       //separatorStyles.doubleDashedLine then XmDOUBLE_DASHED_LINE -> xmStyle;
       //separatorStyles.etchedIn then XmSHADOW_ETCHED_IN -> xmStyle;
       //separatorStyles.etchedOut then XmSHADOW_ETCHED_OUT -> xmStyle;
      if);
      (XmNseparatorType,xmStyle) -> setIntegerResource;
   #)

-- GUIENVseparatorGetStyle: doPart --
do private.style -> value;

-- GUIENVwindowseparatorCreate: doPart --
do (# args: @argList;
      width,height: @integer;
   do father.size -> (width,height);
      (if vertical then
          (1,XmNorientation,XmVERTICAL) -> args.set;
          (2,XtNheight,height) -> args.set;
       else
          (1,XmNorientation,XmHORIZONTAL) -> args.set;
          (2,XtNwidth,width) -> args.set;
      if);
      (XmSeparatorWidgetClass,father.widgetID,'Separator'->appendtickref,args[],2)
        -> createManagedArgs;
      separatorStyles.etchedIn -> private.style;
   #);

-- GUIENVwindowseparatorOpen: doPart --
do inner open;

-- GUIENVwindowseparatorClose: doPart --
do inner close;


-- GUIENVwindowseparatorPrivate: descriptor --
(# style: @integer;
#)



-- canvasLib: attributes --
appendChild:
  (# theWindowitem: ^windowitem;
  enter theWindowitem[]
  do theWindowitem[] -> private.children.append;
  #);
deleteChild:
  (# theWindowitem: ^windowitem;
  enter theWindowitem[]
  do theWindowitem[] -> private.children.at -> private.children.delete;
  #);
handleChildframeChanged:
  (# oldFrame,newFrame: @rectangle;
  enter (oldFrame,newFrame)
  do (oldFrame,newFrame) -> theEventHandler.onChildframeChanged;
  #);

-- GUIENVcanvasSelectionAdd: descriptor --
(#
do (if not (theWindowitem[] -> private.selection.has) then
       theWindowitem[] -> private.selection.append;
       true -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionSet: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
   theWindowitem[] -> private.selection.append;
   true -> theWindowitem.hilite;
#)

-- GUIENVcanvasSelectionRemove: descriptor --
(#
do (if theWindowitem[] -> private.selection.has then
       theWindowitem[] -> private.selection.at -> private.selection.delete;
       false -> theWindowitem.hilite;
   if);
#)

-- GUIENVcanvasSelectionEmpty: descriptor --
(#
do private.selection.empty -> value;
#)

-- GUIENVcanvasSelectionScan: descriptor --
(#
do private.selection.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVcanvasSelectionClear: descriptor --
(#
do private.selection.scan
   (# 
   do false -> current.hilite;
      current[] -> private.selection.at -> private.selection.delete;
   #);
#)


-- GUIENVcanvasScan: descriptor --
(# 
do private.children.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan;
   #);
#)

-- GUIENVcanvasCreate: descriptor --
(# args: @argList;
do inner create;
   (if widgetID=0 then
       (XbCanvasWidgetClass,father.widgetID) -> createSimple;
   if);
#)

--- GUIENVcanvasOpen: descriptor ---
(#
do inner open;
#)

--- GUIENVcanvasClose: descriptor ---
(# 
do inner close;
   private.children.scan
   (# 
   do current.close;
   #);
#)



-- GUIENVcanvasOnActivate: descriptor --
(# 
do private.children.scan
   (# 
   do current.theEventHandler.onActivate;
   #);
   inner onActivate;
#)

-- GUIENVcanvasOnDeactivate: descriptor --
(# 
do private.children.scan
   (# 
   do current.theEventHandler.onDeactivate;
   #);
   inner onDeactivate;
#)

-- GUIENVcanvasOnFrameChanged: descriptor --
(#
do update;
   inner onFrameChanged;
#)

-- GUIENVcanvasOnVisibleChanged: doPart --
do assertOpen;
   private.children.scan
   (# 
   do (if current.visible then
          current.theEventHandler.onVisibleChanged;
      if);
   #);
   INNER;
   
-- GUIENVcanvasPrivate: descriptor --
(# children: @list
     (# element::< windowitem;
        scanNonWidgets: scan
          (# where::<
               (# 
               do (current.widgetID = 0) -> value;
               #);
          do inner;
          #);
        scanNonWidgetsReverse: scanReverse
          (# where::<
               (# 
               do (current.widgetID = 0) -> value;
               #);
          do inner;
          #)
     #);
   selectionList: list
     (# 
        element::< windowitem;
     #);
   selection: @selectionList;
#)
-- GUIENVcanvasOnMouseDown: descriptor --
(# obj: ^windowitem;
do l: private.children.scanNonWidgetsReverse
     (# 
     do (if localPosition -> current.hit then
            current[] -> obj[];
            leave l;
        if);
     #);
   (if obj[]=none then
       inner onMouseDown;
    else
       obj.theEventHandler.onMouseDown;
   if);
#)

-- GUIENVcanvasOnRefresh: descriptor --
(#
do inner onRefresh;
   private.children.scanNonWidgets
   (# 
   do (if current.visible then
          current.theEventHandler.onRefresh;
      if);
   #);
#)

-- GUIENVcanvasOnMouseUp: descriptor --
(#
do inner onMouseUp;
#)

--- GUIENVclipBoardHasText: descriptor ---
(# do
#)
--- GUIENVclipBoardSetText: descriptor ---
(# do
#)
--- GUIENVclipBoardGetText: descriptor ---
(# do
#)
--- GUIENVclipBoardClearContents: descriptor ---
(# do
#)
--- GUIENVcursorPrivate: descriptor ---
(# id: @integer;
#)

-- menubarLib: attributes --
buildMenubar: 
  (# fatherWidget: @integer;
     
  enter fatherWidget
  do
  #);
destroyMenubar: 
  (# 
  do 
  #);

-- menubarEntryLib: attributes --

entryHandleCasading: motifCallbackSelector
  (# subMenuId: @integer;
     theMenu: ^menu;
     args: @argList;
     w: @integer;
  do cascadeButtonWidget->w;
     (1, XmNsubMenuId, @@subMenuId) -> args.set;
     (w, args[],1) -> XtGetValues;
     subMenuId -> private.menus.findById -> theMenu[];
     (if theMenu[]=none then
         trace
         (# 
         do 'handleCascading: theMenu was not found in menu list' -> putLine;
         #);
      else
         theMenu.handleOnSelect;
     if);
  #);
entryCascadingProcessor: callbackProcessor
  (# 
  do &entryHandleCasading[] -> cb[];
  #);

(* -- GUIENVmenuBarEntryHandlCascading: doPart --
do (# subMenuId: @widget;
      theMenu: ^menu;
   do
      XmNsubMenuId -> getIntegerResource -> subMenuID;
      subMenuId -> private.menus.findById -> theMenu[];
      (if theMenu[]=none then
          trace
          (# 
          do 'handleCascading: theMenu was not found in menu list' -> putLine;
          #);
       else
          theMenu.handleOnSelect;
      if);
 #);
 *)
-- GUIENVmenubarEntryDoBuildEntry: doPart --
do (#args: @argList;
      mstr: @motifString;
   do 
      widgetID -> theMenu.buildMenu;
      theMenu.name -> mstr.setText;
      ('cascadebutton'->appendtick,xmCascadeButtonWidgetClass,widgetID,args[],0) 
        -> XtCreateWidget -> cascadeButtonWidget;
      cascadeButtonWidget -> XtManageChild;
      (entryCascadingProcessor##, XmNcascadingCallback, cascadeButtonWidget) -> addCallbackProcessorForSubWidget;
      (1,XmNlabelString,mstr) -> args.set;
      (2,XmNsubMenuId,theMenu.widgetID) -> args.set;
      (cascadeButtonWidget,args[],2) -> XtSetValues;
      this(menubar)[] -> theMenu.private.theMenubar[];
      this(menubarEntry)[] -> theMenu.private.theEntry[];
   #);
   
-- GUIENVmenubarEntrydestroyEntry: doPart --
do  (# args: @argList;
    do
       (1,XmNsubMenuId,0) -> args.set;
       (cascadeButtonWidget,args[],1) -> XtSetValues;
       cascadeButtonWidget -> DestroyWidget;
       theMenu.destroyMenu;
       0 -> cascadeButtonWidget;
    #);
-- GUIENVmenubarEntryRebuildEntry: doPart --
do (# args: @argList;
   do
      theMenu.destroyMenu;
      widgetID -> theMenu.buildMenu;
      (1,XmNsubMenuId,theMenu.widgetID) -> args.set;
      (cascadeButtonWidget,args[],1) -> XtSetValues;
   #);

--- GUIENVmenubarPrivate: descriptor ---
(# menus: @list
     (# element::< menu;
        findById:
          (# widgetId: @integer;
             theMenu: ^menu;
          enter widgetId
          do l: scan
             (# 
             do (if current.widgetID=widgetId then
                    current[] -> theMenu[];
                    leave l;
                if);
             #);
          exit theMenu[]
          #);
     #);
   windows: @list
     (# 
        element::< window;
     #);
#)
--- GUIENVmenubarAppend: descriptor ---
assertOpen
(# location::(# do 'MenuBar.append'->t[] #);
do (if not (theMenu[] -> private.menus.has) then
       theMenu[] -> private.menus.append;
       private.windows.scan
       (# 
       do theMenu[] -> current.private.theMotifMenubar.append;
       #);
   if)
#)

--- GUIENVmenubarDelete: descriptor ---
assertOpen
(# location::(# do 'MenuBar.delete'->t[] #);
do (if theMenu[] -> private.menus.has then
       theMenu[] -> private.menus.at -> private.menus.delete;
       private.windows.scan
       (# 
       do theMenu[] -> current.private.theMotifMenubar.delete;
       #);
   if);
#)
--- GUIENVmenubarClear: descriptor ---
assertOpen
(# location::(# do 'MenuBar.clear'->t[] #);
do private.menus.scan
   (# 
   do current[] -> delete;
   #);
#)
--- GUIENVmenubarAppendMenubar: descriptor ---
assertOpen
(# location::(# do 'MenuBar.appendMenuBar'->t[] #);
do theMenubar.scan
   (# 
   do current[] -> append;
   #);
#)

--- GUIENVmenubarReplaceMenubar: descriptor ---
assertOpen
(# location::(# do 'MenuBar.replaceMenuBar'->t[] #);
do theMenubar[] -> deleteMenubar;
   replacementMenubar[] -> appendMenubar;
#)
--- GUIENVmenubarDeleteMenubar: descriptor ---
assertOpen
(# location::(# do 'MenuBar.deleteMenuBar'->t[] #);
do theMenubar.scan
   (# 
   do current[] -> delete;
   #);
#)

--- GUIENVmenubarScan: descriptor ---
assertOpen
(# location::(# do 'MenuBar.scan'->t[] #);
do private.menus.scan
   (# 
   do current[] -> THIS(scan).current[];
      inner scan;
   #);
#)

-- GUIENVmenubarOpen: descriptor --
(# 
do private.menus.init;
   inner open;
#)

-- GUIENVmenubarCreate: descriptor --
(#
do inner create; 
#)

-- GUIENVmenubarClose: descriptor --

(# 
do inner Close;
   clear;
   (* widgetID -> XtParent -> DestroyWidget *)
#)


-- GUIENVmenuBuildMenu: descriptor --
(# #)

-- GUIENVmenuBuildPopupmenu: descriptor --
(# #)

-- GUIENVmenuDestroyMenu: descriptor --
(# #)

-- GUIENVmenuSetName: descriptor --
assertOpen
(# location::(# do 'Menu.setName'->t[] #);
do theName.copy -> private.name[];
#)

-- GUIENVmenuGetName: descriptor --
assertOpen
(# location::(# do 'Menu.getName'->t[] #);
do (if private.name[]=none then
       &text[] -> theName[];
    else
       private.name.copy -> theName[];
   if);
#)

-- GUIENVseparatorCreate: descriptor --
(#
do inner create
#)

-- GUIENVseparatorOpen: descriptor -- 
(# 
do inner open;   
#)

-- GUIENVseparatorClose: descriptor --
(# 
do inner close;
#)

--- GUIENVmenuAppend: descriptor ---
assertOpen
(# location::(# do 'Menu.append'->t[] #);
do (if not (theMenuItem[] -> private.menuitems.has) then
       theMenuItem[] -> private.menuitems.append;
       private.motifMenus.scan
       (# 
       do theMenuItem[] -> current.append;
       #);
   if);
#)

--- GUIENVmenuDelete: descriptor ---
assertOpen
(# location::(# do 'Menu.delete'->t[] #);
do (if theMenuitem[] -> private.menuitems.has then
       theMenuItem[] -> private.menuitems.at -> private.menuitems.delete;
       private.motifMenus.scan
       (# 
       do theMenuItem[] -> current.delete;
       #);
    else
       trace
       (# 
       do 'menu.delete: the menuitem is not in the menu' -> putLine;
       #);
   if);
#)
--- GUIENVmenuScan: descriptor ---
assertOpen
(# location::(# do 'Menu.scan'->t[] #);
do private.menuitems.scan
   (# 
   do current[] -> THIS(scan).current[];
      inner scan;
   #);
#)
--- GUIENVmenuClear: descriptor ---
assertOpen
(# location::(# do 'Menu.clear'->t[] #);
do scan
   (# 
   do current[] -> delete;
   #)
#)
--- GUIENVmenuNoOfMenuitems: descriptor ---
assertOpen
(# location::(# do 'Menu.noOfMenuItems'->t[] #);
do private.menuitems.size -> value;
#)

--- GUIENVmenuGetMenuItemByNumber: descriptor ---
assertOpen
(# location::(# do 'Menu.getMenuItemByNumber'->t[] #);
   count: @integer;
do 0 -> count;
   l: private.menuitems.iterate
   (# 
   do count + 1 -> count;
      (if count=number then
          current.elm[] -> theMenuItem[];
          leave l;
      if);
   #);
#)
--- GUIENVmenuEnable: descriptor ---
assertOpen
(# location::(# do 'Menu.enable'->t[] #);
do true -> private.enabled;
   (if widgetID<>0 then
       (widgetID,1) -> XtSetSensitive;
   if);
#)
--- GUIENVmenuDisable: descriptor ---
assertOpen
(# location::(# do 'Menu.disable'->t[] #);
do false -> private.enabled;
   (if widgetID<>0 then
       (widgetID,0) -> XtSetSensitive;
   if);
#)
--- GUIENVmenuEnabled: descriptor ---
assertOpen
(# location::(# do 'Menu.enabled'->t[] #);
do private.enabled -> value;
#)

--- GUIENVmenuOpen: descriptor ---
(# 
do this(Menu)[] -> getPatternName -> private.name[];
   true -> private.enabled;
   inner open;
#)

-- GUIENVmenuCreate: descriptor --
(#
do inner create;
#)

--- GUIENVmenuClose: descriptor ---
(#
do (if private.popupevent[]<>NONE then private.popupevent -> XtFree if);
   inner close;
#)
-- MenuLib: attributes --
handleOnSelect:
  (# 
  do theEventHandler.onSelect;
  #);

--- GUIENVmenuPopUp: descriptor ---
assertOpen
(# location::(# do 'Menu.popup'->t[] #);
   id: @integer;
   x_root,y_root: @shortRef;
   x, y: @integer;
   theItem: ^Motifmenu.motifMenuItem;
   menuPost: ^text;
do (if (private.motifpopupmenu[]=NONE) 
       (* create motif menu *)
       or (popupin[]<>private.motifPopupMenu.owner[]) then
       (if private.motifPopupMenu[]<>NONE then
           (* destroy old motif menu *)
           private.motifPopupMenu.close;
       if);
       &motifmenu[] -> private.MotifpopupMenu[];
       popupIn[] -> private.MotifpopupMenu.owner[];
       this(menu)[] -> private.MotifpopupMenu.theMenu[];
       true -> private.MotifpopupMenu.popup;
       private.MotifpopupMenu.open;
       (if (private.popupbutton=0) then 3 -> private.popupbutton if);
       '<Btn' -> menupost[];
       private.popupbutton -> menuPost.putint;
       '>' -> menupost.put;
       (XmNmenuPost, menuPost[]) -> private.MotifpopupMenu.setStringResource;
       (if private.popupevent[]=NONE then
           &XButtonEvent[] -> private.popupevent[];
           private.popupevent.init;
           XButtonPress -> private.popupevent.type;
       if);
   if);
   
   private.MotifpopupMenu.handleOnSelect;
   popupIn.widgetID -> id;
   
   (* translate to root coordinates *)
   (id,popupAt.h,popupAt.v,x_root[],y_root[]) -> XtTranslateCoords;
   x_root -> uShort2Short -> x;
   y_root -> uShort2Short -> y;
   
   (* Adjust for the popupWith item *)
   popupWith -> private.MotifpopupMenu.getItemByNumber -> theItem[];
   (if theItem[]<>None then
       y - (XtNy -> theItem.getShortResource) -> y;
   if);
   
   (* Place menu using XmMenuPosition - ensures that menu is on screen *)
   y     -> private.popupevent.y_root;
   x + 2 -> private.popupevent.x_root     (* + 2 to ensure that we are outside the item
                                           * - otherwise highlight does not work for this 
                                           * item before another has been selected
                                           *);
   (private.MotifpopupMenu.widgetID, private.popupevent) -> XmMenuPosition;
   
   (* manage menu *)
   private.MotifpopupMenu.widgetID -> XtManageChild;
   
#)


-- GUIENVactionOnStatus: descriptor --
(#
do true -> value;
   inner onStatus;
#)

(*
 * menuitem
 *)




-- GUIENVmenuItemDoExpose: doPart --
do

--- GUIENVmenuItemSetKey: descriptor ---
assertOpen
(# location::(# do 'MenuItem.setkey'->t[] #);
   t: @text;
do c -> private.key;
   this(menu).private.motifMenus.scan
   (# 
   do (position,c) -> current.setKey;
   #);
   
#)
--- GUIENVmenuItemGetKey: descriptor ---
assertOpen
(# location::(# do 'MenuItem.getKey'->t[] #);
do private.key -> c;
#)

--- GUIENVmenuItemSetName: descriptor ---
assertOpen
(# location::(# do 'MenuItem.SetName'->t[] #);
do 
   
   t.copy -> private.name[];
   
   scanMotifMenuItems
   (# 
   do (if current[] = NONE then
          'CURRENT is NONE in scanMotifMenuItems' -> putLine;
       else
          (XmNlabelString,t[]) -> current.setMotifStringResource;
      if);
   #);
#)

--- GUIENVmenuItemGetName: descriptor ---
assertOpen
(# location::(# do 'MenuItem.GetName'->t[] #);
do private.name.copy -> t[];
#)

-- GUIENVmenuitemSetChecked: descriptor --
assertOpen
(# location::(# do 'MenuItem.SetChecked'->t[] #);
do checked -> private.checked;
   this(menu).private.motifMenus.scan
   (# 
   do (position,checked) -> current.setChecked;
   #);
#)
-- GUIENVmenuitemGetChecked: descriptor --
assertOpen
(# location::(# do 'MenuItem.GetChecked'->t[] #);
do private.checked -> checked;
   
#)

--- GUIENVsetSubMenu: descriptor ---
assertOpen
(# location::(# do 'MenuItem.SetSubmenu'->t[] #);
do (* (if private.theSubMenu[]<>theMenu[] then
    *        (if widgetID=0 then
    *            theMenu[] -> private.theSubMenu[];
    *         else
    *            (if private.theSubMenu[]<>none then
    *                private.theSubMenu.destroyMenu;
    *            if);
    *            theMenu[] -> private.theSubMenu[];
    *            this(menu).rebuildItems;
    *            {* (if private.theSubMenu[]=none then
    *             *            position -> thePosition;
    *             *            destroyItem;
    *             *            theMenu[] -> private.theSubMenu[];
    *             *            thePosition - 1 -> buildItem;
    *             *         else
    *             *            (XmNsubMenuID,0) -> setIntegerResource;
    *             *            private.theSubMenu.destroyMenu;
    *             *            (if theMenu[]<>none then
    *             *                this(menu).widgetID -> theMenu.buildMenu;
    *             *                (XmNsubMenuID,theMenu.widgetID) -> setIntegerResource;
    *             *            if);
    *             *            theMenu[] -> private.theSubMenu[];
    *             *        if);
    *             *}
    *        if);
    *    if)
    *)
   (if theMenu[]<>private.theSubMenu[] then
       theMenu[] -> private.theSubMenu[];
       this(menu).private.motifMenus.scan
       (# 
       do (position,theMenu[]) -> current.setSubMenu;
       #);
   if);
#)
--- GUIENVgetSubMenu: descriptor ---
assertOpen
(# location::(# do 'MenuItem.GetSubMenu'->t[] #);
do private.theSubMenu[] -> theMenu[];
#)
--- GUIENVmenuItemPosition: descriptor ---
assertOpen
(# location::(# do 'MenuItem.position'->t[] #);
   count: @integer;
do l: scan
   (# 
   do count + 1 -> count;
      (if THIS(menuitem)[]=current[] then
          leave l;
      if);
   #);
   count -> value;
   trace
   (# 
   do (if count=0 then
          'menuitem.position: the menuitem was not found in the menu' -> putLine;
      if);
   #);
#)

-- GUIENVmenuitemCreate: descriptor --
(# 
do inner create;
#)

-- GUIENVmenuitemOpen: descriptor --
(# 
do this(menuitem)[] -> getPatternName -> private.name[];
   inner open;
#)




--- GUIENVmenuItemOnStatus: descriptor ---
(# 
do true -> value;
   inner onStatus;
#)

--- GUIENVmenuItemAttach: descriptor ---
assertOpen
(# location::(# do 'MenuItem.attach'->t[] #);
do (if theAction[]<>none then
       none -> theAction.theMenuitem[];
   if);
   anAction[] -> theAction[];
   (if theAction[]<>none then
       THIS(dynamicMenuitem)[] -> theAction.theMenuitem[];
   if);
#)
--- GUIENVmenuItemDetach: descriptor ---
assertOpen
(# location::(# do 'MenuItem.detach'->t[] #);
do (if theAction[]<>none then
       none -> theAction.theMenuitem[];
   if);
   none -> theAction[];
#)
--- GUIENVdynamicMenuItemOnStatus: descriptor ---
(# 
do (if theAction[]=none then
       false -> value;
    else
       theAction.onStatus -> value;
   if);
#)
--- GUIENVdynamicMenuItemOnSelect: descriptor ---
(# 
do (if theAction[]<>none then
       theAction.onSelect;
   if);
#)

--- GUIENVmouseGlobalPosition: descriptor ---
(# info: ^mouseInfo;
do display -> XDefaultRootWindow -> getMouseInfo -> info[];
   info.global -> pt;
#)

-- GUIENVmouseButtonState: descriptor --
(# info: ^mouseInfo;
do display -> XDefaultRootWindow -> getMouseInfo -> info[];
   info.button -> value;
#)

--- GUIENVmouseTheCursorSet: descriptor ---
(# cursorID: @integer;
do (if theCur[]=none then
       0 -> cursorID;
    else
       theCur.private.ID -> cursorID;
   if);
   this(guienv).private.windows.scan
   (# displayID,windowID: @integer;
   do current.displayID -> displayID;
      current.windowID -> windowID;
      (displayID,windowID,cursorID) -> XDefineCursor;
      current.widgetID -> XmUpdateDisplay;
   #);
   theCur[] -> private.busyCursor[]
#)

--- GUIENVmouseTheCursorGet: descriptor ---
(# 
do private.busyCursor[] -> theCur[];
#)


--- GUIENVsystemScreenRectangle: descriptor ---
(# rootID: @integer;
   displayID: @integer;
   ignore_root,x,y,width,height,ignore_border,ignore_depth: @integer;
do display -> displayID;
   displayID -> XDefaultRootWindow -> rootID;
   (displayID,rootID,@@ignore_root,@@x,@@y,@@width,@@height,@@ignore_border,@@ignore_depth)
     -> XGetGeometry;
   (x,y) -> theRectangle.topLeft;
   (width,height) -> theRectangle.size;
#)
--- GUIENVsystemScreenRgn: descriptor ---
(# 
do &region[] -> rgn[];
   rgn.allocate;
   screenRectangle -> rgn.setFromrectangle;
#)
--- GUIENVsystemBeepBody: descriptor ---
(# 
do (private.display, 100) -> XBell;
#)
--- GUIENVsystemWaitBody: descriptor ---
(# timeVal: data
     (# tv_sec: @integer;
        tv_usec: @integer;
     #);
   select: external
     (# nfds, readfds, writefds, exceptfds: @integer;
        timeout: ^timeVal;
        result: @integer;
     enter (nfds, readfds, writefds, exceptfds, timeout[])
     exit result
     #);
   tv: @timeVal;
do ticks div 60 -> tv.tv_sec;
   ticks mod 60 -> tv.tv_usec;
   (0, 0, 0, 0, tv[]) -> select;
#)

-- textStyleLib: attributes --
gettextwidth: external
  (# buffer: @integer;
     count: @integer;
     fontStruct: @integer;
     width: @integer;
  enter (buffer,count,fontStruct)
  exit width
  #);

--- GUIENVtextStyleAscent: descriptor ---
(# info: ^fontInfo;
do allocate;
   getFontInfo -> info[];
   info.ascent -> value;
#)
--- GUIENVtextStyleDescent: descriptor ---
(# info: ^fontInfo;
do allocate;
   getFontInfo -> info[];
   info.descent -> value;
#)
--- GUIENVtextStyleLeading: descriptor ---
(# 
do 0 -> value;
#)
--- GUIENVtextStyleHeight: descriptor ---
(# info: ^fontInfo;
do allocate;
   getFontInfo -> info[];
   info.descent + info.ascent -> value;
#)
--- GUIENVtextStyleMaxChWidth: descriptor ---
(# getcharinfo: external
     (# width: @integer;
        fontStruct: @integer;
     enter fontStruct
     exit width
     #);
do allocate;
   private.fontStruct -> getcharinfo -> value;
#)
--- GUIENVtextStyleWidthOfChar: descriptor ---
(# 
do allocate;
   (@@ch,1,private.fontStruct) -> gettextwidth -> value;
#)
--- GUIENVtextStyleStringWidth: descriptor ---
(# length: @integer;
do allocate;
   str.length -> length;
   (if length > 0 then
       (@@str.T[1],length,private.fontStruct) -> gettextwidth -> value;
    else
       0 -> value;
   if);
#)
--- GUIENVtextStyleSetName: descriptor ---
(# 
do (if not (theName[] -> private.name.equalNCS) then
       theName -> private.name;
       dispose;
   if);
#)
--- GUIENVtextStyleGetName: descriptor ---
(# 
do private.name.copy -> theName[];
#)

-- GUIENVtextStyleSetSize: descriptor --
(# 
do (if value<>private.size then
       value -> private.size;
       dispose;
   if);
#)

-- GUIENVtextStyleGetSize: descriptor --
(#
do private.size -> value;
#)

-- GUIENVtextStyleSetFace: descriptor --
(#
do (if value<>private.face then
       value -> private.face;
       dispose;
   if);
#)

-- GUIENVtextStyleGetFace: descriptor --
(#
do private.face -> value;
#)


--- GUIENVtextStyleFamilySizes: descriptor ---
(# do
#)


-- windowLib: attributes --

handleDeleteWindow: callbackSelector
  (# 
  do (if theEventHandler.onAboutToClose then
         this(window).close;
     if);
  #);
deleteWindowProcessor: callbackProcessor
  (# 
  do &handleDeleteWindow[] -> cb[];
  #);

handleWindowFocusChanged: focusChangeEventSelector
  (# (* notify modes *)
     NotifyNormal: (# exit 0 #);
     NotifyGrab: (# exit 1 #);
     NotifyUngrab: (# exit 2 #);
     NotifyWhileGrabbed: (# exit 3 #);
     
     (* Notify detail *)
     NotifyAncestor: (# exit 0 #);
     NotifyVirtual: (# exit 1 #);
     NotifyInferior: (# exit 2 #);
     NotifyNonlinear: (# exit 3 #);
     NotifyNonlinearVirtual: (# exit 4 #);
     NotifyPointer: (# exit 5 #);
     NotifyPointerRoot: (# exit 6 #);
     NotifyDetailNone: (# exit 7 #);
     
  do (* WidgetId -> putint; ' '->put;
      *      'handleWindowFocusChanged: mode, detail, type: '->puttext;
      *      mode -> putint; ' '->put;
      *      detail -> putint; ' '->put;
      *      type -> putint; ' '->put;
      *      newline;
      *)
     (* (if mode
      *       // NotifyNormal 
      *       // NotifyUngrab then
      *          (if detail
      *           // NotifyAncestor
      *           // NotifyPointer
      *           // NotifyVirtual
      *           // NotifyNonLinear
      *           // NotifyNonLinearVirtual then
      *              (if type
      *               // XFocusIn then
      *                  theEventHandler.onActivate;
      *               // XFocusOut then
      *                  theEventHandler.onDeactivate;
      *               else
      *                  {* WidgetId -> putint; ' '->put;
      *                   * 'handleWindowFocusChanged: type='->puttext; type->putint; newline;
      *                   *}
      *              if);
      *           else
      *              {* WidgetId -> putint; ' '->put;
      *               * 'handleWindowFocusChanged: detail='->puttext; detail->putint; newline;
      *               *}
      *          if);
      *       else
      *          {* WidgetId -> putint; ' '->put;
      *           * 'handleWindowFocusChanged: mode='->puttext; mode->putint; newline;
      *           *}
      *      if);
      *)
     (if type=XFocusIn then
         theEventHandler.onActivate;
      else
         theEventHandler.onDeactivate;
     if); 
  #);
focusChangeEventProcessor: eventProcessor
  (# 
  do &handleWindowFocusChanged[] -> es[];
  #);
handleContentsResize: configureEventSelector
  (# 
  do (if type=XConfigureNotify then
         adjustContents;
     if);
  #);
configureEventProcessor: eventProcessor
  (# 
  do &handleContentsResize[] -> es[];
  #);

appendMenubar:
  (# theMenubar: ^menubar;
     theMotifMenubar: ^motifMenubar;
  enter theMenubar[]
  do private.theMotifMenubar[] -> theMotifMenubar[];
     (if theMotifMenubar[]=none then
         &motifMenubar[] -> theMotifMenubar[];
         this(window)[] -> theMotifMenubar.theWindow[];
         theMotifMenubar.open;
         theMotifMenubar[] -> private.theMotifMenubar[];
     if);
     theMenubar.scan
     (# 
     do current[] -> theMotifMenubar.append;
     #);
     this(window)[] -> theMenubar.private.windows.append;
  #);
hasWindow: booleanValue
  (#
  do (widgetID -> XtWindow) <> 0 -> value;
  #);
resizeMenubar:
  (# itsHeight,itsBorderWidth: @integer;
     width,height: @integer;
  do 
     (if private.theMenubar[]<>none then
        size -> (width,height);
         XtNborderWidth -> private.theMenubar.getShortResource -> itsBorderWidth;
         XtNheight -> private.theMenubar.getShortResource -> itsHeight;
         (private.theMenubar.widgetID,width,itsHeight,itsBorderWidth)
           -> XtResizeWidget;
     if);
  #);

-- GUIENVwindowadjustContents: doPart --
do assertOpen
   (# width,height: @integer;
   do XtNwidth -> private.contentsForm.getShortResource -> width;
      XtNheight -> private.contentsForm.getShortResource -> height;
      
      (if private.theMotifMenubar[]=none then
          (0,0) -> private.contents.position;
          (width,height) -> private.contents.size;
       else
          (0,menubarHeight) -> private.contents.position;
          true -> SetAnswer;
          (XtNwidth,width) -> private.theMotifMenubar.setIntegerResource;
          false -> SetAnswer;
          (width,height-menubarHeight) -> private.contents.size;
      if);
      
   #);
   
-- GUIENVwindowOnActivate: descriptor --
(# 
do private.contents.theEventHandler.onActivate;
   inner onActivate;
#)

-- GUIENVwindowOnDeactivate: descriptor --
(#
do private.contents.theEventHandler.onDeactivate;
   inner onDeactivate;
#)

--- GUIENVwindowSetTheMenubar: descriptor ---
assertOpen
(# location::(# do 'Window.setMenuBar'->t[] #);
   theMotifMenubar: ^motifMenubar;
   applMenubar: ^menubar;
do (if theBar[]<>private.theMenubar[] then
       (* (if private.theMenubar[]<>none then
        *            private.theMotifMenubar.close;
        *            none -> private.theMotifMenubar[];
        *        if);
        *)
       (if theBar[]=none then
           (if private.theMenubar[]<>none then
               (if menubarVisible then
                   private.theMenubar.scan
                   (# 
                   do current[] -> private.theMotifMenubar.delete;
                   #);
               if);
               none -> private.theMenubar[];
           if);
        else
           theBar[] -> private.theMenubar[];
           (if menubarVisible then
               theBar[] -> appendMenubar;
           if);
       if);
   if);
#)
--- GUIENVwindowGetTheMenubar: descriptor ---
assertOpen
(# location::(# do 'Window.getMenubar'->t[] #);
do private.theMenubar[] -> theBar[];
#)

--- GUIENVwindowSetTitle: descriptor ---
assertOpen
(# location::(# do 'Window.setTitle'->t[] #);
do (XtNtitle,theTitle[]) -> setStringResource;
#)
--- GUIENVwindowGetTitle: descriptor ---
assertOpen
(# location::(# do 'Window.getTitle'->t[] #);
do XtNtitle -> getStringResource -> theTitle[];
#)
--- GUIENVwindowSetPosition: descriptor ---
assertOpen
(# location::(# do 'Window.setPosition'->t[] #);
   (* geometry: @text(# p: @put; pi: @putint #); *)
do 
   (* This does not convince certain window managers.*)
   (XtNx,pt.h) -> setIntegerResource;
   (XtNy,pt.v) -> setIntegerResource;
   
   (* But this does not work?
    * '+'->geometry.p;
    * pt.h->geometry.pi;
    * '+'->geometry.p;
    * pt.v->geometry.pi;
    * 'geometry: '->puttext; geometry[]->putline;
    * (XtNgeometry, geometry[]) -> setStringResource;
    *)
#)
--- GUIENVwindowGetPosition: descriptor ---
assertOpen
(# location::(# do 'Window.getPosition'->t[] #);
   x,y: @shortRef;
do (widgetID,0,0,x[],y[]) -> XtTranslateCoords;
   
   x -> uShort2Short -> pt.h;
   y -> uShort2Short -> pt.v;
#)
--- GUIENVwindowSetSize: descriptor ---
assertOpen
(# location::(# do 'Window.setSize'->t[] #);
   h: @integer;
do 
   (if private.theMotifMenubar[]=none then
       height -> h;
    else
       height + menubarHeight -> h;
   if);
   (XtNwidth,width) -> setIntegerResource;
   (XtNheight,h) -> setIntegerResource;
   (XtNwidth,width) -> private.contentsForm.setIntegerResource;
   (XtNheight,h) -> private.contentsForm.setIntegerResource;
   adjustContents;
#)
--- GUIENVwindowGetSize: descriptor ---
assertOpen
(# location::(# do 'Window.getSize'->t[] #);
do private.contents.size -> (width,height);
#)
--- GUIENVwindowSetFrame: descriptor ---
(# 
do theFrame.topLeft -> position;
   theFrame.size -> size;
#)
--- GUIENVwindowGetFrame: descriptor ---
(# 
do position -> theFrame.topLeft;
   size -> theFrame.size;
#)
--- GUIENVwindowInsideRectangle: descriptor ---
(# 
do size -> theRectangle.bottomRight;
#)

--- GUIENVshowWindow: descriptor ---
assertOpen
(# location::(# do 'Window.show'->t[] #);
do 
   widgetID -> XtMapWidget;
   true -> private.visible;
#)
--- GUIENVwindowShowModal: descriptor ---
assertOpen
(# location::(# do 'Window.showModal'->t[] #);
do (if not private.isModal then
       true -> private.isModal;
       (XmNmwmInputMode,MWM_INPUT_PRIMARY_APPLICATION_MODAL) 
         -> setIntegerResource;
       show;
       bringToFront;
       (widgetID,true,true) -> XtAddGrab;
       l: 
         (if private.isModal then
             (this(guienv).private.appCon,XtIMAll) -> XtAppProcessEvent;
             restart l;
         if);
   if);
#)
--- GUIENVhideWindow: descriptor ---
assertOpen
(# location::(# do 'Window.hide'->t[] #);
do (if private.isModal then
       false -> private.isModal;
       widgetID -> XtRemoveGrab;
       (XmNmwmInputMode,MWM_INPUT_MODELESS) -> setIntegerResource;
   if);
   widgetID -> XtUnmapWidget;
   false -> private.visible;
#)

--- GUIENVwindowSetMaxSize: descriptor ---
assertOpen
(# location::(# do 'Window.setMaxSize'->t[] #);
do (if widgetID<>0 then
       (XtNmaxWidth,width) -> setIntegerResource;
       (XtNmaxHeight,height) -> setIntegerResource;
   if);
#)
--- GUIENVwindowGetMaxSize: descriptor ---
assertOpen
(# location::(# do 'Window.getMaxSize'->t[] #);
do (if widgetID<>0 then
       XtNmaxWidth  -> getIntegerResource -> width;
       XtNmaxHeight  -> getIntegerResource -> height;
   if);
#)
--- GUIENVwindowSetMinSize: descriptor ---
assertOpen
(# location::(# do 'Window.setMinSize'->t[] #);
do (if widgetID<>0 then
       (XtNminWidth,width) -> setIntegerResource;
       (XtNminHeight,height) -> setIntegerResource;
   if);
#)
--- GUIENVwindowGetMinSize: descriptor ---
assertOpen
(# location::(# do 'Window.getMinSize'->t[] #);
do (if widgetID<>0 then
       XtNminWidth  -> getIntegerResource -> width;
       XtNminHeight  -> getIntegerResource -> height;
   if);
#)
--- GUIENVwindowBringToFront: descriptor ---
assertOpen
(# location::(# do 'Window.bringToFront'->t[] #);
do (if widgetID<>0 then
       (widgetID -> XtDisplay,widgetID -> XtWindow) -> XRaiseWindow;
   if);
#)
--- GUIENVwindowBringToBack: descriptor ---
assertOpen
(# location::(# do 'Window.bringToBack'->t[] #);
do (if widgetID<>0 then
       (widgetID -> XtDisplay,widgetID -> XtWindow) -> XLowerWindow;
   if);
#)
--- GUIENVwindowBringBehind: descriptor ---
assertOpen
(# location::(# do 'Window.BringBehind'->t[] #);
   windowIDs: [2] @integer;
   displayID: @integer;
do (if widgetID<>0 then
       widgetID -> XtWindow -> windowIDs[2];
       widgetID -> XtDisplay -> displayID;
       (if theWindow[]<>none then
          (if theWindow.widgetID<>0 then
              theWindow.widgetID -> XtWindow -> windowIDs[1];
              (displayID,@@windowIDs[1],2) -> XRestackWindows;
          if);
       if);
   if);
#)
--- GUIENVwindowUpdate: descriptor ---
assertOpen
(# location::(# do 'Window.update'->t[] #);
do immediate -> private.contents.update;
#)
-- GUIENVwindowCreate: descriptor --
(# args: @argList;
   XtAppCreateShell: external
     (# name: [1] @char;
        class: [1] @char;
        widgetClass: @integer;
        display: @integer;
        args: ^argList;
        nArgs: @integer;
        newWidget: @integer;
     enter (name,class,widgetclass,display,args[],nArgs)
     do callC
     exit newWidget
     #);
   ID: @integer;
do inner create;
   (if widgetID=0 then
       (1,XtNwidth,300) -> args.set;
       (2,XtNheight,200) -> args.set;
       (this(guienv).private.appName,
       this(guienv).private.appClass,
       TopLevelShellWidgetClass,
       display,
       args[],
       2) -> XtAppCreateShell -> ID;
       ID -> widgetID;
       (widgetID,false) -> XtSetMappedWhenManaged;
       widgetID -> XtRealizeWidget;
   if);
#)
--- GUIENVwindowOpen: descriptor ---
(# parent,contentsWidget: @widget;
   aMenubar: ^menubarType;
   applMenubar: ^menubar;
   args: @argList;
   SetWindowDeleteAction: external
     (# shell: @integer;
        callback: @integer;
     enter (shell, callback)
     #);
   callbackAddress: @integer;
do this(window)[] -> getPatternName -> title;
   (1,XtNwidth,300) -> args.set;
   (2,XtNheight,200) -> args.set;
   ('contentsform'->appendtick,XbCanvasWidgetClass,widgetID,args[],2) -> XtCreateManagedWidget 
     -> private.contentsForm.widgetID;
   (configureEventProcessor##, XStructureNotifyMask) -> appendEventProcessor;
   (focusChangeEventProcessor##, XFocusChangeMask) -> appendEventProcessor;
   deleteWindowProcessor## -> makeCBF -> callbackAddress;
   (widgetID, callbackAddress) -> SetWindowDeleteAction;
   callbackAddress -> addCBF;
   (XmNdeleteResponse, XmDO_NOTHING) -> setIntegerResource;
   true -> private.visible;
   THIS(window)[] -> this(guienv).private.windows.append;
   private.contents.open;
   private.contents.widgetID -> contentsWidget;
   (if menubarVisible then
       applicationMenubar -> applMenubar[];
       (if applMenubar[]<>none then
           applMenubar[] -> appendMenubar;
       if);
   if);
   &menubarType[] -> aMenubar[];
   (if aMenubar## <> menubar## then
       aMenubar.open;
       aMenubar[] -> theMenubar;
   if);
   (XtNwidth,300) -> setIntegerResource;
   (XtNheight,200) -> setIntegerResource;
   INNER open;
   (if private.visible then
       (if THIS(interfaceobject).private.isOpen then
           widgetID -> XtMapWidget;
        else
           (* closed in INNER, e.g. via a showmodal *)
       if)
   if);
#)



--- GUIENVwindowClose: descriptor ---
assertOpen
(# location::(# do 'Window.close'->t[] #);
do inner close;
   widgetID -> XtUnmapWidget;
   (if (private.themenubar[]<>none) then
       THIS(window)[] -> private.themenubar.private.windows.at 
         -> private.themenubar.private.windows.delete;
       private.theMotifMenubar.close;
       none -> private.theMotifMenubar[];
       none -> private.themenubar[];
   if);
   private.contents.close;
   0 -> private.contentsForm.widgetID;
   (if private.isModal then
       false -> private.isModal;
       widgetID -> XtRemoveGrab;
   if);
   widgetID -> DestroyWidget;
   THIS(window)[] -> this(guienv).private.windows.at 
     -> this(guienv).private.windows.delete;
#)


--- GUIENVwindowSetTarget: descriptor ---
(# 
   XmIsTraversable: external
     (# w: @integer;
        result: @integer;
     enter w
     exit result
     #);

   result: @integer;
do (if theTarget[]=None then
       (private.contents.widgetID,XmTRAVERSE_CURRENT) ->  XmProcessTraversal;
    else
       theTarget.widgetID -> XmIsTraversable -> result;
       (if result <> 0 then
           (* Kald en exception eller hvad ??? *)
       if);
       (theTarget.widgetID,XmTRAVERSE_CURRENT) ->  XmProcessTraversal -> result;
       (if result <> 0 then
           (* Kald en exception eller hvad ??? *)
       if);
   if);
#)
--- GUIENVwindowGetTarget: descriptor ---
(# 
do private.theTarget[] -> theTarget[];
#)

-- windowitemLib: attributes --

exposeProcessor: eventProcessor
  (# 
  do &refreshSelector[] -> es[];
  #);
buttonPressProcessor: eventProcessor
  (# 
  do &mouseDownSelector[] -> es[];
  #);
buttonReleaseProcessor: eventProcessor
  (# 
  do &mouseUpSelector[] -> es[];
  #);
keyPressProcessor: eventProcessor
  (# 
  do &keyDownSelector[] -> es[];
  #);
focusChangeProcessor: eventProcessor
  (# 
  do &selectTarget[] -> es[];
  #);

refreshSelector: exposeEventSelector
  (# 
  do ((x, y), (x + width, y + height)) -> this(guienv).private.updateRectAdd;
     (if count=0 then
         this(guienv).private.updateRectFlush;
    
         theEventHandler.onRefresh;
     if);
  #);

handleMouseDown:
  (# 
  do 
     (if private.delegate then
         (if father[] <> none then
             this(guienv).private.x + private.left 
               -> this(guienv).private.x;
             this(guienv).private.y + private.top 
               -> this(guienv).private.y;
             father.handleMouseDown;
         if);
      else
         theEventHandler.onMouseDown;
     if);
  #);
mouseDownSelector: buttonEventSelector
  (# 
  do handleMouseDown;
  #);

handleMouseUp:
  (# 
  do 
     (if private.delegate then
         (if father[] <> none then
             this(guienv).private.x + private.left 
               -> this(guienv).private.x;
             this(guienv).private.y + private.top 
               -> this(guienv).private.y;
             father.handleMouseUp;
         if);
      else
         theEventHandler.onMouseUp;
     if);
  #);
mouseUpSelector: buttonEventSelector
  (# 
  do handleMouseUp;
  #);
keyDownSelector: KeyEventSelector
  (# 
  do theEventHandler.onKeyDown;
  #);


selectTarget: focusChangeEventSelector
  (# 
  do (if type=XFocusIn then
         this(windowitem)[] -> theTarget;
         theEventHandler.onEnableTarget;
      else
         theEventHandler.onDisableTarget;
         none -> theTarget;
     if);
  #);
handleConfigure: configureEventSelector
  (# 
  do (if type=XConfigureNotify then
         (if not this(windowItem).private.frameChangedHandled then
             (frame,getFrame) -> handleframeChanged;
         if);
         false -> this(windowItem).private.frameChangedHandled;
     if);
  #);
configureProcessor: eventProcessor
  (# 
  do &handleConfigure[] -> es[];
  #);

handleFatherframeChanged:
  (# oldFrame,newFrame,chainRect,itsFrame: @rectangle;
     delta: @Point;
  enter (oldFrame,newFrame)
  do newFrame.size -> delta;
     oldFrame.size -> delta.subTract;
     (if not ((0,0) -> delta.isEqual) then
         frame -> chainRect -> itsFrame;
         delta -> chainRect.offset;
         (if not bindLeft then
             chainRect.left -> itsFrame.left;
         if);
         (if bindBottom then
             chainRect.bottom -> itsFrame.bottom
         if);
         (if bindRight then
             chainRect.right -> itsFrame.right
         if);
         (if not bindTop then
             chainRect.top -> itsFrame.top
         if);
         itsFrame -> frame;
     if);
     (oldFrame,newFrame) -> theEventHandler.onFatherframeChanged;
  #);

-- GUIENVwindowItemHandleFrameChanged: doPart --
do (# thisCanvas: ^canvas;
   do (if not (oldFrame -> newFrame.isEqual) then
          newFrame.left -> private.left;
          newFrame.right -> private.right;
          newFrame.bottom -> private.bottom;
          newFrame.top -> private.top;
          (oldFrame,newFrame) -> theEventHandler.onframeChanged;
          (if father[]<>none then
              (oldFrame,newFrame) -> father.handleChildframeChanged;
          if);
          (if this(windowitem)## <= canvas## then
              this(windowitem)[] -> thisCanvas[];
              thisCanvas.private.children.scan
              (# 
              do (oldFrame,newFrame) -> current.handleFatherframeChanged;
              #);
           else
              (if widgetID=0 then
                  (# 
                  do (father.displayID,father.windowID,
                     oldFrame.left,oldFrame.top,
                     oldFrame.right - oldFrame.left,oldFrame.bottom - oldFrame.top,
                     1) -> XClearArea;
                     (father.displayID,father.windowID,
                     newFrame.left,newFrame.top,
                     newFrame.right - newFrame.left,newFrame.bottom - newFrame.top,
                     1) -> XClearArea;
                  #);
              if);
          if);
      if);
   #)

-- GUIENVwindowitemOnRefresh: descriptor --
(# xmType: @integer;
   topGC: @integer;
   bottomGC: @integer;
   width,height: @integer;
   x,y: @integer;
   drawable: @integer;
do inner onRefresh;
   (if border.visible then
       father.widgetID -> GetTopShadowGC -> topGC;
       father.widgetID -> GetBottomShadowGC -> bottomGC;
       size -> (width,height);
       (if border.style
        //borderStyles.simple then XmSHADOW_IN -> xmType;
        //borderStyles.shadowIn then XmSHADOW_IN -> xmType;
        //borderStyles.shadowOut then XmSHADOW_OUT -> xmType;
        //borderStyles.etchedIn then XmSHADOW_ETCHED_IN -> xmType;
        //borderStyles.etchedOut then XmSHADOW_ETCHED_OUT -> xmType;
       if);
       (if widgetID=0 then
           position -> (x,y);
           father.windowID -> drawable;
           (display,drawable,topGC,bottomGC,x,y,width,height,2,xmType) -> _XmDrawShadows;
        else
           windowID -> drawable;
           (display,drawable,topGC,bottomGC,0,0,width,height,2,xmType) -> _XmDrawShadows;
       if);
   if);
#)

--- GUIENVwindowitemSetFrame: descriptor ---
assertOpen
(# location::(# do 'WindowItem.setFrame'->t[] #);
   oldFrame: @rectangle;
   h,v,width,height: @integer;
do frame -> oldFrame;
   (if not (theFrame -> oldFrame.isEqual) then
       theFrame.topLeft -> (h,v);
       theFrame.size -> (width,height);
       (if widgetID<>0 then
           true -> SetAnswer;
           (XtNx,h) -> setIntegerResource;
           (XtNy,v) -> setIntegerResource;
           (XtNwidth,width) -> setIntegerResource;
           (XtNheight,height) -> setIntegerResource;
           false -> SetAnswer;
       if);
       (oldFrame,theFrame) -> handleFrameChanged;
       true -> private.frameChangedHandled;
   if);
#)

--- GUIENVwindowitemGetFrame: descriptor ---
assertOpen
(# location::(# do 'WindowItem.getFrame'->t[] #);
do private.left-> theFrame.left;
   private.right -> theFrame.right;
   private.top -> theFrame.top;
   private.bottom -> theFrame.bottom;
   
#)
--- GUIENVwindowitemSetPosition: descriptor ---
assertOpen
(# location::(# do 'WindowItem.SetPosition'->t[] #);
   theFrame: @rectangle;
do pt -> theFrame.topLeft;
   size -> theFrame.size;
   theFrame -> frame;
#)
--- GUIENVwindowitemGetPosition: descriptor ---
assertOpen
(# location::(# do 'WindowItem.GetPosition'->t[] #);
do private.left -> pt.h;
   private.top -> pt.v;
#)
--- GUIENVwindowitemMove: descriptor ---
assertOpen
(# location::(# do 'WindowItem.move'->t[] #);
   pt: @point;
do position -> pt;
   (dh,dv) -> pt.add;
   pt -> position;
#)
--- GUIENVwindowitemSetSize: descriptor ---
assertOpen
(# location::(# do 'WindowItem.setSize'->t[] #);
   theFrame: @rectangle;
do position -> theFrame.topLeft;
   (width,height) -> theFrame.size;
   theFrame -> frame;
#)

--- GUIENVwindowitemGetSize: descriptor ---
assertOpen
(# location::(# do 'WindowItem.getSize'->t[] #);
do private.right - private.left -> width;
   private.bottom - private.top -> height;
#)

-- GUIENVwindowitemSetVisible: descriptor --
assertOpen
(# location::(# do 'WindowItem.SetVisible'->t[] #);
do (if value<>private.visible then
       value -> private.visible;
       (if widgetID <> 0 then
           (if value then
               widgetID -> XtMapWidget;
            else
               widgetID -> XtUnmapWidget;
           if);
        else
           update;
       if);
       theEventHandler.onVisibleChanged;
   if);
#)

-- GUIENVwindowitemGetVisible: descriptor --
assertOpen
(# location::(# do 'WindowItem.getVisible'->t[] #);
do private.visible -> value;
#)

-- GUIENVwindowitemSetHilite: descriptor --
assertOpen
(# location::(# do 'WindowItem.setHilite'->t[] #);
do value -> private.hilite;
   theEventHandler.onHiliteChanged;
#)

-- GUIENVwindowitemGetHilite: descriptor --
assertOpen
(# location::(# do 'WindowItem.getHilite'->t[] #);
do private.hilite -> value;
#)

-- GUIENVwindowitemSetEnabled: descriptor --
assertOpen
(# location::(# do 'WindowItem.setEnabled'->t[] #);
do (if value=enabled then
       (* not changed *)
    else
       (if widgetID <> 0 then
           (if value then
               (widgetID,1) -> XtSetSensitive;
            else
               (widgetID,0) -> XtSetSensitive;
           if);
       if);
       theEventHandler.onEnabledChanged;
   if);
#)

-- GUIENVwindowitemGetEnabled: descriptor --
assertOpen
(# location::(# do 'WindowItem.getEnabled'->t[] #);
do (if widgetID <> 0 then
       widgetID -> XtIsSensitive -> value;
   if);
#)

--- GUIENVwindowitemShow: descriptor ---
assertOpen
(# location::(# do 'WindowItem.show'->t[] #);
do true -> visible;
#)
--- GUIENVwindowitemHide: descriptor ---
assertOpen
(# location::(# do 'WindowItem.hide'->t[] #);
do false -> visible;
#)
--- GUIENVwindowitemEnable: descriptor ---
assertOpen
(# location::(# do 'WindowItem.enable'->t[] #);
do true -> enabled;
#)
--- GUIENVwindowitemDisable: descriptor ---
assertOpen
(# location::(# do 'WindowItem.disable'->t[] #);
do false -> enabled;
#)

-- windowItemEnterBackgroundColor: doPart --
do assertOpen;
   
-- windowItemExitBackgroundColor: doPart --
do assertOpen;
   
-- GUIENVwindowitemBorderSetVisible: doPart --
do value -> private.borderVisible;
   theEventHandler.onBorderVisibleChanged;
   true -> update;

-- GUIENVwindowitemBorderGetVisible: doPart --
do private.borderVisible -> value;

-- GUIENVwindowitemBorderSetStyle: doPart --
do value -> private.borderStyle;
   theEventHandler.onBorderStyleChanged;
   true -> update;

-- GUIENVwindowitemBorderGetStyle: doPart --
do private.borderStyle -> value;

-- GUIENVwindowiteminsideRectangle: doPart --
do ((0,0),size) -> theRectangle;
   (if border.visible then
       (2,2) -> theRectangle.inset;
   if);
   
--- GUIENVwindowitemSetTheCursor: descriptor ---
assertOpen
(# location::(# do 'WindowItem.setCursor'->t[] #);
   id: @integer;
do theCur[] -> private.theCursor[];
   (if theCur[]=none then
       0 -> ID;
    else
       theCur.private.id -> ID;
   if);
   (displayID, windowID, ID)
     -> XDefineCursor;
   theEventHandler.onTheCursorChanged;
   (if widgetID <> 0 then
       widgetID -> XmUpdateDisplay;
   if);
#)
--- GUIENVwindowitemGetTheCursor: descriptor ---
(# 
do private.theCursor[] -> theCur[];
#)

-- GUIENVwindowItemTrackMouse: descriptor --
(# info: ^mouseInfo;
   theWindow: @integer;
do (if widgetID <> 0 then
      widgetID -> XtWindow -> theWindow;
      theWindow -> mouse.getMouseInfo -> info[];
      info.local -> curPt -> prevPt;
       mousePress;
       l: (if info.button<>0 then
              info.local -> curPt;
              (if (not (curPt -> prevPt.isEqual)) then
                  (curPt.h - prevPt.h,curPt.v - prevPt.v) -> mouseMove;
                  curPt -> prevPt;
              if);
              theWindow -> mouse.getMouseInfo -> info[];
              restart l;
          if);
       mouseRelease;
   if);
#)

--- GUIENVwindowitemDrag: descriptor ---
(# 
do father.graphics
   (# r: @rectangle;
   do transferModes.xorBlend -> pen.mode;
      father.trackMouse
      (# r: @rectangle;
         mousePress::<
           (# 
           do frame -> r;
              r -> drawRect;
           #);
         mouseMove::<
           (# 
           do (if ((h<>0) or (v<>0)) then
                  r -> drawRect;
                  (h,v) -> r.offset;
                  r -> drawRect;
              if);
           #);
         mouseRelease::<
           (# 
           do r -> drawRect;
              r -> frame;
           #);
      #);
   #);
#)
--- GUIENVwindowitemResize: descriptor ---
(# newFrame: @rectangle;
   w,h: @Integer;
do frame -> father.defineRect -> newFrame;
   newFrame.size -> (w,h);
   (w,1) -> max -> w;
   (h,1) -> max -> h;
   (w,h) -> newFrame.size;
   newFrame -> frame;
#)

--- GUIENVwindowitemUpdate: descriptor ---
assertOpen
(# location::(# do 'WindowItem.update'->t[] #);
do (if widgetID=0 then
       (# f: @rectangle;
       do frame -> f;
          (father.displayID,father.windowID,
          f.left,f.top,
          f.right - f.left + 1,f.bottom - f.top + 1,
          1) -> XClearArea;
          (if immediate then
              father.widgetID -> XmUpdateDisplay;
          if);
       #);
    else
       (displayID,windowID,0,0,0,0,1) -> XClearArea;
       (if immediate then
           widgetID -> XmUpdateDisplay;
       if);
   if);
#)

-- GUIENVwindowitemCreate: descriptor --
(# origin: ^object;
   args: @argList;
   a2o: @addressToObject;
do true -> private.needsWidget;
   (if father[]=none then
       THIS(windowitem)[] -> getOrigin -> origin[];
       l:
         (if origin[]=none then
             (if THIS(windowitem)[]<>THIS(window).private.contents[] then
                 THIS(window).private.contents[] -> father[];
             if);
          else 
             (if (origin## <= canvas##) then 
                 origin[] -> father[];
              else 
                 origin[] -> getOrigin -> origin[];
                 restart l;
             if)
         if);
   if);
   inner create;
   
   (if widgetID=0 then
       (if private.needsWidget then
           (xmDrawingAreaWidgetClass,father.widgetID) -> createSimple;
       if);
   if);
#)

--- GUIENVwindowitemOpen: descriptor ---
(# frameHitMethod: hitMethod
     (# f: @rectangle;
     do frame -> f;
        p -> f.containsPoint -> value;
     #);
   f: @rectangle;
do true -> private.visible;
   false -> private.hilite;
   (if father[]<>none then
       this(windowitem)[] -> father.appendChild;
   if);
   true -> bindLeft -> bindTop;
   false -> private.borderVisible;
   borderStyles.simple -> private.borderStyle;
   (if widgetID<>0 then
       getFrame -> f;
       f.left -> private.left;
       f.right -> private.right;
       f.bottom -> private.bottom;
       f.top -> private.top;
       (exposeProcessor##, XExposureMask) -> appendEventProcessor;
       (configureProcessor##, XStructureNotifyMask) -> appendEventProcessor;
       (keyPressProcessor##, XKeyPressMask) -> appendEventProcessor;
       (focusChangeProcessor##, XFocusChangeMask) -> appendEventProcessor;
       (buttonPressProcessor##, XButtonPressMask) -> appendEventProcessor;
       (buttonReleaseProcessor##, XButtonReleaseMask) 
         -> appendEventProcessor -> private.mouseUpProcessorAddress;
    else
       100 -> private.right;
       100 -> private.bottom;
       frameHitMethod## -> private.hit##;
   if);
   inner open;
#)

--- GUIENVwindowitemClose: descriptor ---
assertOpen
(# location::(# do 'WindowItem.close'->t[] #);
do inner close;
   (if father[]<>none then
       this(windowitem)[] -> father.selection.remove;
       this(windowitem)[] -> father.deleteChild;
   if);
   widgetID -> DestroyWidget;
   none -> private.theCursor[];
#)


-- GUIENVstandardMenubarOpen: descriptor --
(#
do &fileMenu[] -> theFileMenu[];
   (if theFileMenu## <> menu## then
       theFileMenu.open;
       theFileMenu[] -> append;
    else
       none -> theFileMenu[];
   if);
   &editMenu[] -> theEditMenu[];
   (if theEditMenu## <> menu## then
       theEditMenu.open;
       theEditMenu[] -> append;
    else
       none -> theEditMenu[];
   if);
   inner open;
#)

--- GUIENVstandardFileMenuOpen: descriptor ---
(#
do 'File' -> name;
   newMenuitem.open;
   'New' -> newMenuitem.name;
   newMenuitem[] -> append;
   openMenuitem.open;
   'Open' -> openMenuitem.name;
   openMenuitem[] -> append;
   closeMenuitem.open;
   'Close' -> closeMenuitem.name;
   closeMenuitem[] -> append;
   saveMenuitem.open;
   'Save' -> saveMenuitem.name;
   saveMenuitem[] -> append;
   saveAsMenuitem.open;
   'Save as' -> saveAsMenuitem.name;
   saveAsMenuitem[] -> append;
   revertMenuitem.open;
   'Revert' -> revertMenuitem.name;
   revertMenuitem[] -> append;
   printMenuitem.open;
   'Print' -> printMenuitem.name;
   printMenuitem[] -> append;
   pageSetupMenuitem.open;
   'Page setup' -> pageSetupMenuitem.name;
   pageSetupMenuitem[] -> append;
   quitMenuitem.open;
   'Quit' -> quitMenuitem.name;
   quitMenuitem[] -> append;
   inner open;
#)
--- GUIENVstandardEditMenuOpen: descriptor ---
(#
do 'Edit' -> name;
   undoMenuItem.open;
   'Undo' -> undoMenuItem.name;
   undoMenuItem[] -> append;
   cutMenuItem.open;
   'Cut' -> cutMenuItem.name;
   cutMenuItem[] -> append;
   copyMenuItem.open;
   'Copy' -> copyMenuItem.name;
   copyMenuItem[] -> append;
   pasteMenuItem.open;
   'Paste' -> pasteMenuItem.name;
   pasteMenuItem[] -> append;
   clearMenuItem.open;
   'Clear' -> clearMenuItem.name;
   clearMenuItem[] -> append;
   inner open;
#)
-- GUIENVwindowGetContents: doPart --
do private.contents[] -> theContents[];

-- GUIENVwindowSeparatorOnRefresh: doPart --
do inner onRefresh;
   

-- motifMenuItemLib: attributes --

handleActivate: motifCallbackSelector
  (# 
  do (if this(motifMenu).private.isVisible or theMenuitem.theEventHandler.onStatus then
         theMenuitem.theEventHandler.onSelect
     if)
  #);
motifMenuItemActivateProcessor: callbackProcessor
  (#
  do &handleActivate[] -> cb[];
  #);

handleCascading: motifCallbackSelector
  (# 
  do theMotifSubmenu.handleOnSelect;
  #);
motifMenuItemCascadingProcessor: callbackProcessor
  (#
  do &handleCascading[] -> cb[];
  #);

handleExpose: exposeEventSelector
  (# 
  do (if theMenuitem.checked then
         drawCheckMark;
     if);
  #);
motifMenuItemExposeProcessor: eventProcessor
  (# 
  do &handleExpose[] -> es[];
  #);



handleOnStatus:
  (# enabled: @boolean;
  do (if theMenuitem.theEventHandler.onStatus -> enabled then
         (widgetID,1) -> XtSetSensitive;
      else
         (widgetID,0) -> XtSetSensitive;
     if);
  #);
drawCheckMark:
  (# windowID,displayID,gcID,screenNumber: @integer;
     black: @integer;
  do widgetID -> XtWindow -> windowID;
     widgetID -> XtDisplay -> displayID;
     displayID -> XDefaultScreen -> screenNumber;
     (displayID,windowID,0,0) -> XCreateGC -> gcID;
     (displayID,screenNumber) -> XBlackPixel -> black;
     (displayID,gcID,black) -> XSetForeGround;
     (displayID,windowID,gcID,4,8,6,14) -> XDrawLine;
     (displayID,windowID,gcID,6,14,9,4) -> XDrawLine;
     (displayID,gcID) -> XFreeGC;
  #);

-- GUIENVmotifMenuItemCreate: doPart --
do (# args: @argList;
      buildSeparator: 
        (# args: @argList;
        do (XmSeparatorWidgetClass,this(motifMenu).widgetID,'menuseparator'->appendtickref)
             -> createManaged;
        #);
      buildCascadeButtonItem: 
        (# args: @argList;
           
        do (XmCascadeButtonWidgetClass,
           this(motifMenu).widgetID,
           'menucascade'->appendtickref) -> createManaged;
           (motifMenuItemCascadingProcessor##, XmNcascadingCallback)
             -> addCallbackProcessor;
           &motifMenu[] -> theMotifSubMenu[];
           theMenuitem.subMenu -> theMotifSubMenu.theMenu[];
           this(motifMenu)[] -> theMotifSubMenu.owner[];
           theMotifSubMenu.open;
           (XmNsubMenuID,theMotifSubMenu.widgetID) -> setIntegerResource;
        #);
      buildPushButtonItem: 
        (#
        do (XmPushButtonWidgetClass,
           this(motifmenu).widgetID,
           'pushbuttonitem'->appendTickref) -> createManaged;
           (* 'The above menuitem is "'->puttext;
            * themenuitem.name->puttext;
            * '" belonging to menu "'->puttext;
            * themenu.name->puttext;
            * '" '-> putline;
            *)
           (motifMenuItemExposeProcessor##, XExposureMask) 
             -> appendEventProcessor;
           (motifMenuItemActivateProcessor##, XmNActivateCallback)
             -> addCallbackProcessor;
        #);
      t: @text;
   do (if theMenuitem## <= theMenu.separator## then
          buildSeparator;
       else
          (if theMenuitem.subMenu=none then
              buildPushButtonItem;
           else
              buildCascadeButtonItem;
          if);
      if);
      (XmNlabelString,theMenuitem.name) -> setMotifStringResource;
      (XmNmarginLeft,15) -> setIntegerResource;
      (if theMenuitem.key<>0 then
          t.clear;
          'Ctrl<Key>' -> t.append;
          theMenuitem.key -> t.put;
          (XmNaccelerator,t[]) -> setStringResource;
          'Ctrl-' -> t;
          theMenuitem.key -> t.put;
          (XmNacceleratorText,t[]) -> setMotifStringResource;
      if);
      this(motifMenuitem)[] -> this(motifMenu).private.motifMenuitems.append;
   #)
   
-- GUIENVmotifMenuItemClose: doPart --
do widgetID -> DestroyWidget;

-- GUIENVmotifMenuGetItemByNumber: doPart --
do (# i: @integer;
   do l: private.motifMenuItems.scan
     (# 
     do i + 1 -> i;
        (if i = position then
            current[] -> theMotifMenuItem[];
            leave l;
        if);
     #);
   #);
   
-- GUIENVmenuitemscanMotifMenuItems: doPart --
do this(menu).private.motifMenus.scan
   (# 
   do current[] -> currentMotifMenu[];
      position  -> current.getItemByNumber -> this(scanMotifMenuItems).current[];
      inner scanMotifMenuItems;
   #);

-- GUIENVinterfaceObjectappendEventProcessor: doPart --
do (private.widgetID,type,0,address,0,XtListTail) 
     -> XtInsertEventHandler;
-- GUIENVinterfaceObjectPrependEventProcessor: doPart --
do (private.widgetID,type,0,address,0,XtListHead)
     -> XtInsertEventHandler;
   
-- GUIENVinterfaceObjectAddCallbackProcessor: doPart --
do (private.widgetID,type,address,0) -> XtAddCallback;
-- GUIENVinterfaceObjectAddCallbackProcessorForSubWidget: doPart --
do (subWidget,type,address,0) -> XtAddCallback;
   
   
-- GUIENVinterfaceObjectappendEventProcessorForSubWidget: doPart -- 
do (widget,type,0,address,0,XtListTail) -> XtInsertEventHandler;
   
-- GUIENVinterfaceObjectAddCallbackPrefix: doPart --
do callback## -> makeCBF -> address;
   inner;
   1 -> private.callbacks.extend; (* FIXME: kvadratisk samlet tid !! *)
   address -> private.callbacks[private.callbacks.range];
   
-- GUIENVupdateRect: doPart --
do this(guienv).private.damaged[] -> value[];
   
-- GUIENVwindowItemSetXBorder: doPart --
do true -> SetAnswer;
   (XtNborderWidth, width) -> setIntegerResource;
   false -> SetAnswer;

-- guienvQuit: doPart --
do true -> okToQuit;
	INNER;
   (if okToQuit then
       Terminate;
   if);
   
-- windowEnterVisible: doPart --
do assertOpen;
	(if value <> private.visible then
		(if value then
			show;
		else
			hide;
		if);
	if);
-- windowExitVisible: doPart --
do assertOpen;
	private.visible -> value;
	
-- guienvFitToContents: doPart --
do preferredSize -> size;
   INNER;
