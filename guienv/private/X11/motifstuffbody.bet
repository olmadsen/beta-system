ORIGIN 'motifstuff'
[[
-- Include '~beta/sysutils/v1.4/cstring'


--MotifStringSetText: descriptor--
(# charset: @Integer;
   XmStringCreateLtoR: external
     (# stringP: @integer;
        charSet: @integer;
        result: @integer;
     enter (stringP, charSet)
     exit result
     #);
Do (if value//0 then else
       value -> XmStringFree
   if);
   XmSTRING_DEFAULT_CHARSET -> charset;
   (if t.T.range = 0 then
       1 -> t.T.new;
   if);
   (if t.lgth < t.T.range then
       0 -> t.T[t.lgth+1];
   if);
   (@@t.T[1],charset) -> XmStringCreateLtoR -> Value
#)

--MotifStringSetSegment: descriptor--
(# chset: @integer;
Do (if value//0 then else
       value -> XmStringFree
   if);
   (if t[]//NONE then &text[]->t[] if);
   (if charset[] // NONE 
       then XmSTRING_DEFAULT_CHARSET -> chset;
       (t, chset, direction, 0) -> XmStringSegmentCreate -> value;
    else
       (if charset.length//0 then
           XmSTRING_DEFAULT_CHARSET -> chset;
           (t, chset, direction, 0) -> XmStringSegmentCreate -> value;
        else
           (t, @@charset.T[1], direction, 0) -> XmStringSegmentCreate -> value;
       if)
   if)
#)
--MotifStringGetText: descriptor--
(# ptr: @integer;
do &text[] -> t[];
   (value, XmSTRING_DEFAULT_CHARSET, @@ptr)
     -> XmStringGetLtoR;
   ptr -> CStringToCharRep -> t;
   ptr -> XtFree;
#)

--MotifStringDestroy: descriptor--
(# do value -> XmStringFree #)

--MotifStringAppend: descriptor--
(# new: @integer;
do (Value,S) -> XmStringConcat -> new;
   (if value//0 then else value -> XmStringFree if);
   new -> value
#)

--MotifStringPrepend: descriptor--
(# new: @integer;
do (S,Value) -> XmStringConcat -> new;
   (if value//0 then else value -> XmStringFree if);
   new -> value
#)

--MotifStringAppendText: descriptor--
(# s, new, charset: @Integer;
do XmSTRING_DEFAULT_CHARSET -> charset;
   (t,charset) -> XmStringCreateLtoR -> s;
   (value,s) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value//0 then else value -> XmStringFree if);
   new -> value
#)

--MotifStringPrependText: descriptor--
(# s, new, charset: @Integer;
do XmSTRING_DEFAULT_CHARSET -> charset;
   (t,charset) -> XmStringCreateLtoR -> s;
   (s,value) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value//0 then else value -> XmStringFree if);
   new -> value
#)

--MotifStringAppendSegment: descriptor--
(# s, new, chset: @Integer;
do (if t[]//NONE then &text[]->t[] if);
   (if charset[] // NONE 
       then XmSTRING_DEFAULT_CHARSET -> chset;
       (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
    else
       (if charset.length//0 then
           XmSTRING_DEFAULT_CHARSET -> chset;
           (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
        else
           (t, @@charset.T[1], direction, 0) -> XmStringSegmentCreate -> s;
       if)
   if);
   (value, s) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value//0 then else value -> XmStringFree if);
   new -> value
#)

--MotifStringPrependSegment: descriptor--
(# s, new, chset: @Integer;
do (if t[]//NONE then &text[]->t[] if);
   (if charset[] // NONE 
       then XmSTRING_DEFAULT_CHARSET -> chset;
       (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
    else
       (if charset.length//0 then
           XmSTRING_DEFAULT_CHARSET -> chset;
           (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
        else
           (t, @@charset.T[1], direction, 0) -> XmStringSegmentCreate -> s;
       if)
   if);
   (s, value) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value//0 then else value -> XmStringFree if);
   new -> value
#)
  
--MotifStringCopyAppend: descriptor--
(# do (Value,S) -> XmStringConcat -> copy #)

--MotifStringCopyPrepend: descriptor--
(# do (S,Value) -> XmStringConcat -> copy #)

--MotifStringCopy: descriptor--
(# do THIS(MotifString) -> XmStringCopy -> S #)

--MotifStringHasSubString: descriptor--
(# do (THIS(MotifString), S) -> XmStringHasSubString -> value #)

--MotifStringEqual: descriptor--
(# do (THIS(MotifString), S) -> XmStringCompare -> value #)

--MotifStringEq: descriptor--
(# do (THIS(MotifString), S) -> XmStringByteCompare -> value #)

--MotifStringEmpty: descriptor--
(# do THIS(MotifString) -> XmStringEmpty -> value #)

--MotifStringExtent: descriptor--
(# do (fontlist, value, @@width, @@height) -> XmStringExtent #)

--MotifStringBaseline: descriptor--
(# do (THIS(MotifString), @@value) -> XmStringBaseline #)

--MotifStringHeight: descriptor--
(# do (THIS(MotifString), @@value) -> XmStringHeight #)

--MotifStringSize: descriptor--
(# do THIS(MotifString) -> XmStringLength -> value #)

--MotifStringLines: descriptor--
(# do THIS(MotifString) -> XmStringLineCount -> value #)

--MotifFontListAdd: descriptor--
(# 
do (if (font<>0) and (charset[]<>NONE) 
    // true then
       (if (charset.length>0)
        // true then
           (if value
            // 0 then
               (font, @@charset.T[1])
                 -> XmFontListCreate -> value
            else
               (value, font, @@charset.T[1])
                 -> XmFontListAdd -> value
           if)
       if)
   if)
#)           

-- MotifFontListScan: descriptor --
(# fontContext: @integer; (* a c pointer *)
   status: @boolean;
   str: @cstring;
do (if value<>0//true then
       (@@fontContext,value) -> XmFontListInitFontContext -> status;
       (if status//true then
           loop: 
             (if true//true then
                 (fontContext,@@str.charPtr,@@fontStruct) -> XmFontListGetNextFont -> status;
                 (if status//true then
                     str.get -> charSet[];
                     str.free;
                     charSet.T.range -> charSet.lgth -> charSet.pos;
                     inner scan;
                     restart loop;
                 if);
             if);
           fontContext -> XmFontListFreeFontContext;
        else
           (* !!! Handle exception *)
       if);
   if);
#)

--- StringArrayInit: descriptor ---
(# 
do initialSize -> private.max; (private.max+1)*4 -> xtmalloc -> private.address; 
   (private.address,0) -> private.putlong; 
#)

--- StringArrayClear: descriptor ---
(# 
do (for i:private.number repeat
        private.address+(i-1)*4 -> TOS'%adrGetLong' -> XtFree;
   for);
   0 -> private.number;
   (private.address,0) -> private.putlong; 
#)

--StringArrayNumber: dopart--
do private.number -> value;

--StringArrayAddress: dopart--
do private.address -> value;

-- StringArrayGetText: descriptor --
(# c: ^cstring;
   msg: ^text;
do
   (if (n>private.number) or (n<1)
    // true then
       'StringArray.getText: n=' -> msg[];
       n->msg.putint;
       ' out of range'->msg.puttext;
       (FAILURE, msg[]) -> stop;
   if);
   &cstring[] -> c[];
   private.address+4*(n-1) -> TOS'%adrGetLong' -> c;
   c.get -> t[]
#)

-- StringArrayAddText: descriptor --
(# c: ^cstring 
do
   (if t[]//NONE then (failuretrace, 'StringArray.addtext: t is NONE')->stop if);
   (if (private.number>private.max)
    //true then private.extend
   if);
   &cstring[] -> c[];
   t[] -> c.set;
   (private.address+4*private.number,c) -> private.putLong;
   private.number + 1 -> private.number; 
   (private.address+4*private.number,0) -> private.putLong;
#)

--StringArrayChangeText: descriptor--
(# c: ^cstring;
   msg: ^text;
do
   (if newtext[]//NONE then &text[]->newtext[]; if);
   (if (n>private.number) or (n<1)
    // true then
       'StringArray.changeText: n=' -> msg[];
       n->msg.putint;
       ' out of range'->msg.puttext;
       (FAILURE, msg[]) -> stop;
   if);
   &cstring[] -> c[];
   newtext[] -> c.set;
   private.address+4*(n-1) -> TOS'%adrGetLong' -> XtFree;
   (private.address+4*(n-1),c) -> private.putLong;
#)
-- StringArrayPrivate: descriptor --
(# 
   number,max: @integer; 
   PutLong: @(# enter TOS'%putLong' #);
   address: @integer;
   extend: 
     (# new, newmax: @integer;
     do (if private.max//0 then 25 -> newmax
         else 2*private.max -> newmax;
        if);
        (newmax+1)*4 -> xtmalloc -> new; 
        (for n:private.max repeat
             (new+4*(n-1),
             private.address+4*(n-1) -> TOS'%adrGetLong')
               -> TOS'%putLong'
        for);
        (new+4*private.max, 0) -> TOS'%putLong';
        newmax -> private.max;
        private.address -> xtfree;
        new -> private.address;
     #)
#)

--]]
