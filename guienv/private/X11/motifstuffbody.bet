ORIGIN 'motifstuff';
LIB_ITEM 'guienvmotifstuff';
INCLUDE '~beta/sysutils/cstring';


--MotifStringSetText: descriptor--
(# charset: @Integer;
   XmStringCreateLtoR: external
     (# stringP: @integer;
        charSet: @integer;
        result: @integer;
     enter (stringP, charSet)
     exit result
     #);
Do (if value<>0 then
       value -> XmStringFree
   if);
   (if t[]=NONE then
       ''->t[];
   if);
   XmSTRING_DEFAULT_CHARSET -> charset;
   (if t.T.range = 0 then
       1 -> t.T.new;
   if);
   (* we need to ensure there is space for the trailing NULL for C string -EC*)
   (if t.lgth = t.T.range then
       1 -> t.extend;
   if);
   0 -> t.T[t.lgth+1];
   (@@t.T[1],charset) -> XmStringCreateLtoR -> Value
#)

--MotifStringSetSegment: descriptor--
(# chset: @integer;
Do (if value<>0 then
       value -> XmStringFree
   if);
   (if t[]=NONE then &text[]->t[] if);
   (if charset[] = NONE 
       then XmSTRING_DEFAULT_CHARSET -> chset;
       (t, chset, direction, 0) -> XmStringSegmentCreate -> value;
    else
       (if charset.length=0 then
           XmSTRING_DEFAULT_CHARSET -> chset;
           (t, chset, direction, 0) -> XmStringSegmentCreate -> value;
        else
           (t, @@charset.T[1], direction, 0) -> XmStringSegmentCreate -> value;
       if)
   if)
#)
--MotifStringGetText: descriptor--
(# ptr: @integer;
do &text[] -> t[];
   (value, XmSTRING_DEFAULT_CHARSET, @@ptr)
     -> XmStringGetLtoR;
   ptr -> CStringToCharRep -> t;
   ptr -> XtFree;
#)

--MotifStringDestroy: descriptor--
(# do value -> XmStringFree #)

--MotifStringAppend: descriptor--
(# new: @integer;
do (Value,S) -> XmStringConcat -> new;
   (if value<>0 then value -> XmStringFree if);
   new -> value
#)

--MotifStringPrepend: descriptor--
(# new: @integer;
do (S,Value) -> XmStringConcat -> new;
   (if value<>0 then value -> XmStringFree if);
   new -> value
#)

--MotifStringAppendText: descriptor--
(# s, new, charset: @Integer;
do XmSTRING_DEFAULT_CHARSET -> charset;
   (t,charset) -> XmStringCreateLtoR -> s;
   (value,s) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value<>0 then value -> XmStringFree if);
   new -> value
#)

--MotifStringPrependText: descriptor--
(# s, new, charset: @Integer;
do XmSTRING_DEFAULT_CHARSET -> charset;
   (t,charset) -> XmStringCreateLtoR -> s;
   (s,value) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value<>0 then value -> XmStringFree if);
   new -> value
#)

--MotifStringAppendSegment: descriptor--
(# s, new, chset: @Integer;
do (if t[]=NONE then &text[]->t[] if);
   (if charset[] = NONE 
       then XmSTRING_DEFAULT_CHARSET -> chset;
       (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
    else
       (if charset.length=0 then
           XmSTRING_DEFAULT_CHARSET -> chset;
           (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
        else
           (t, @@charset.T[1], direction, 0) -> XmStringSegmentCreate -> s;
       if)
   if);
   (value, s) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value<>0 then value -> XmStringFree if);
   new -> value
#)

--MotifStringPrependSegment: descriptor--
(# s, new, chset: @Integer;
do (if t[]=NONE then &text[]->t[] if);
   (if charset[] = NONE 
       then XmSTRING_DEFAULT_CHARSET -> chset;
       (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
    else
       (if charset.length=0 then
           XmSTRING_DEFAULT_CHARSET -> chset;
           (t, chset, direction, 0) -> XmStringSegmentCreate -> s;
        else
           (t, @@charset.T[1], direction, 0) -> XmStringSegmentCreate -> s;
       if)
   if);
   (s, value) -> XmStringConcat -> new;
   s -> XmStringFree;
   (if value<>0 then value -> XmStringFree if);
   new -> value
#)
  
--MotifStringCopyAppend: descriptor--
(# do (Value,S) -> XmStringConcat -> copy #)

--MotifStringCopyPrepend: descriptor--
(# do (S,Value) -> XmStringConcat -> copy #)

--MotifStringCopy: descriptor--
(# do THIS(MotifString) -> XmStringCopy -> S #)

--MotifStringHasSubString: descriptor--
(# 
do ((THIS(MotifString), S) -> XmStringHasSubString) <> 0  -> value 
#)

--MotifStringEqual: descriptor--
(# 
do ((THIS(MotifString), S) -> XmStringCompare) <> 0  -> value #)

--MotifStringEq: descriptor--
(# 
do ((THIS(MotifString), S) -> XmStringByteCompare) <> 0 -> value 
#)

--MotifStringEmpty: descriptor--
(# result: @integer;
do THIS(MotifString) -> XmStringEmpty -> result;
   (result <> 0) -> value;
#)

--MotifStringExtent: descriptor--
(# do (fontlist, value, @@width, @@height) -> XmStringExtent #)

--MotifStringBaseline: descriptor--
(# do (THIS(MotifString), @@value) -> XmStringBaseline #)

--MotifStringHeight: descriptor--
(# do (THIS(MotifString), @@value) -> XmStringHeight #)

--MotifStringSize: descriptor--
(# do THIS(MotifString) -> XmStringLength -> value #)

--MotifStringLines: descriptor--
(# do THIS(MotifString) -> XmStringLineCount -> value #)

--MotifFontListAdd: descriptor--
(# 
do (if (font<>0) and (charset[]<>NONE) 
     then
       (if (charset.length>0)
         then
           (if value
            = 0 then
               (font, @@charset.T[1])
                 -> XmFontListCreate -> value
            else
               (value, font, @@charset.T[1])
                 -> XmFontListAdd -> value
           if)
       if)
   if)
#)           

-- MotifFontListScan: descriptor --
(# fontContext: @integer; (* a c pointer *)
   status: @integer;
   str: @cstring;
do (if value<>0 then
       (@@fontContext,value) -> XmFontListInitFontContext -> status;
       (if status <> 0 then
           loop: 
             (if true then
                 (fontContext,@@str.charPtr,@@fontStruct) -> XmFontListGetNextFont -> status;
                 (if status <> 0 then
                     str.get -> charSet[];
                     (*str.free; NO - it's XtMalloc'ed *)
                     str.charptr  -> XtFree;
                     charSet.T.range -> charSet.lgth -> charSet.pos;
                     inner scan;
                     restart loop;
                 if);
             if);
           fontContext -> XmFontListFreeFontContext;
        else
           (* !!! Handle exception *)
       if);
   if);
#)

--- StringArrayInit: descriptor ---
(# 
do initialSize -> private.max; (private.max+1)*4 -> xtmalloc -> private.address; 
   0 %putLongAt (private.address)
#)

--- StringArrayClear: descriptor ---
(# 
do (for i:private.number repeat
        (%getLongAt(private.address+(i-1)*4)) -> XtFree;
        (* Above line tos_converted from: private.address+(i-1)*4 -> TOS'%adrGetLong' -> XtFree; *)
   for);
   0 -> private.number;
   0 %putLongAt (private.address)
#)

--StringArrayNumber: dopart--
do private.number -> value;

--StringArrayAddress: dopart--
do private.address -> value;

-- StringArrayGetText: descriptor --
(# c: ^cstring;
   msg: ^text;
do
   (if (n>private.number) or (n<1)
     then
       'StringArray.getText: n=' -> msg[];
       n->msg.putint;
       ' out of range'->msg.puttext;
       (FAILURE, msg[]) -> stop;
   if);
   &cstring[] -> c[];
   (%getLongAt(private.address+4*(n-1))) -> c;
   (* Above line tos_converted from: private.address+4*(n-1) -> TOS'%adrGetLong' -> c; *)
   c.get -> t[]
#)

-- StringArrayAddText: descriptor --
(# c: ^cstring 
do
   (if t[]=NONE then (failuretrace, 'StringArray.addtext: t is NONE')->stop if);
   (if (private.number>private.max)
     then private.extend
   if);
   &cstring[] -> c[];
   t[] -> c.set;
   c %putLongAt (private.address+4*private.number);
   private.number + 1 -> private.number; 
   0 %putLongAt (private.address+4*private.number);
#)

--StringArrayChangeText: descriptor--
(# c: ^cstring;
   msg: ^text;
do
   (if newtext[]=NONE then &text[]->newtext[]; if);
   (if (n>private.number) or (n<1)
     then
       'StringArray.changeText: n=' -> msg[];
       n->msg.putint;
       ' out of range'->msg.puttext;
       (FAILURE, msg[]) -> stop;
   if);
   &cstring[] -> c[];
   newtext[] -> c.set;
   (%getLongAt(private.address+4*(n-1))) -> XtFree;
   (* Above line tos_converted from: private.address+4*(n-1) -> TOS'%adrGetLong' -> XtFree; *)
   c %putLongAt (private.address+4*(n-1));
#)
-- StringArrayPrivate: descriptor --
(# 
   number,max: @integer; 
   address: @integer;
   extend: 
     (# new, newmax: @integer;
     do (if private.max=0 then 25 -> newmax
         else 2*private.max -> newmax;
        if);
        (newmax+1)*4 -> xtmalloc -> new; 
        (for n:private.max repeat
             (%getLongAt(new+4*(n-1))) %putLongAt(private.address+4*(n-1));
             (* Above line tos_converted from: (new+4*(n-1), private.address+4*(n-1) -> TOS'%adrGetLong') -> TOS'%putLong' *)
        for);
        0 %putLongAt (new+4*private.max);
        (* Above line tos_converted from: (new+4*private.max, 0) -> TOS'%putLong'; *)
        newmax -> private.max;
        private.address -> xtfree;
        new -> private.address;
     #)
#)
