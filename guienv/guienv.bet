ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list'
        'graphmath'
        'keys';
LIB_DEF 'guienv' '../lib';
BODY 'private/guienvbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: Attributes --
(* idx=3 *)
GUIenv:
  (#
     <<SLOT guienvLib:Attributes>>;
     onStartApplication:<
     (* is called when this application is started with no
      * documents. You can for example further bind this to show a
      * splash screen
      *) (#  do INNER #);
     onOpenDocument:<
     (* is called whenever a user opens a document created by this
      * application
      *) (# fileName: ^text;  enter fileName[] do INNER #);
     onQuit:<
     (* is called when application is going to quit, either
      * because terminate is called or because the system are
      * are going to shut down.
      * If okToQuit is set to false the application will
      * not quit.
      *)
       (# okToQuit: @boolean; 
       do true->okToQuit; INNER ; 
       exit okToQuit
       #);
     onKeyDown:<
     (* is called when the user presses a key. This global keydown handler
      * is called before the normal event-dispatch mechanism is used. This
      * gives the application a chance to handle the key event in some special
      * way.
      * 
      * Set done to true to stop the application from handling the key event in
      * the normal way.
      *)
       (# control: @boolean; key: @int32u; done: @boolean; 
       enter (control,key)
       do INNER ; 
       exit done
       #);
     terminate:
     (* will terminate the entire application if invoked 
      * Terminate calls onQuit and will only quit if
      * onQuit returns true.
      *) (#  <<SLOT GUIENVterminateBody:DoPart>> #);
     applicationMenubar:
     (* applicationMenubar is used to install a menubar with
      * functionality that is common for all parts for the
      * application.
      *)
       (# theMenubar: ^menubarType
       enter (#  enter theMenubar[] <<SLOT GUIENVsetTheMenubar:DoPart>> #)
       exit
         (# 
         <<SLOT GUIENVgetTheMenubar:DoPart>>
         exit theMenuBar[]
         #)
       #);
     menubarType:<
     (* if further bound, an instance of menubarType is
      * automatically installed for the application. Further bind it
      * to standardMenubar if you want the standard menubar (file
      * and edit menu)
      *) menubar;
     interfaceObject:
     (* superpattern for all objects used for interaction with the
      * user
      *)
       (#
          <<SLOT interfaceObjectLib:Attributes>>;
          (* idx+ *)
          theEventhandler:
          (* The only instance of the eventhandler virtual *) @eventhandler;
          eventhandler:<
          (* Encapsulates the patterns related to event handling *)
            (#
               <<SLOT eventhandlerLib:Attributes>>;
               event:
               (* the abstract superpattern of all events *)
                 (# <<SLOT eventLib:Attributes>>; 
                 <<SLOT GUIENVinterfaceObjectEvent:DoPart>>
                 #)
                 (* event *)
                 ;
               basicEvent: event
               (* abstract superpattern for all events
                * originating directly from the OS 
                *)
                 (#
                    <<SLOT basicEventLib:Attributes>>;
                    (* idx+ *)
                    shiftKey: booleanValue
                    (* true if the shiftkey was the down, when
                     * THIS(basicEvent) occurred
                     *) (#  <<SLOT GUIENVbasicEventShiftKey:DoPart>> #);
                    altKey:
                     booleanValue
                    (* true if the altkey was the down, when
                     * THIS(basicEvent) occurred
                     *) (#  <<SLOT GUIENVbasicEventAltKey:DoPart>> #);
                    metaKey: booleanValue
                    (* true if the metakey was the down, when
                     * THIS(basicEvent) occurred
                     *) (#  <<SLOT GUIENVbasicEventMetaKey:DoPart>> #);
                    controlKey:
                     booleanValue
                    (* true if the controlkey was the down, when
                     * THIS(basicEvent) occurred
                     *) (#  <<SLOT GUIENVbasicEventControlKey:DoPart>> #);
                    buttonState:
                     integerValue
                    (* the number designating the button, which was
                     * pressed down, when THIS(basicEvent) occurred
                     * - 0 means 'no button'.  This value depe nds
                     * on the number of buttons on the mouse -
                     * Typically 1, 2 or 3.
                     *) (#  <<SLOT GUIENVbasicEventButtonState:DoPart>> #);
                    when:
                     integerValue
                    (* the tick count when THIS(basicEvent)
                     * occurred.  1 tick = 1/60 sec.
                     *) (#  <<SLOT GUIENVbasicEventWhen:DoPart>> #);
                    globalPosition:
                    (* global coordinates of the mouse, when
                     * THIS(basicEvent) occurred
                     *)
                      (# p: @point; 
                      <<SLOT GUIENVbasicEventGlobalPosition:DoPart>>
                      exit p
                      #);
                    localPosition:
                    (* local coordinates of the mouse, when
                     * THIS(basicEvent) occurred - relative to
                     * THIS(inteefaceObject)
                     *)
                      (# p: @point; 
                      <<SLOT GUIENVbasicEventLocalPosition:DoPart>>
                      exit p
                      #);
                    (* idx- *)
                    
                 do INNER ; 
                 #);
               mouseEvent:
                basicEvent
               (* abstract superpattern for events related to the
                * mouse
                *)
                 (#
                    <<SLOT mouseEventLib:Attributes>>;
                    (* idx+ *)
                    doubleClick: booleanValue
                    (* true if THIS(mouseEvent) is a doubleclick.
                     * For a mouse click to qualify as doubleclick
                     * it must happen close in time and space, and
                     * with the same mouse button
                     *) (#  <<SLOT GUIENVmouseEventDoubleClick:DoPart>> #);
                    (* idx- *)
                    
                 do INNER ; 
                 #);
               keyEvent: basicEvent
               (* abstract superpattern for events related to the
                * keyboard.
                *)
                 (#
                    <<SLOT keyEventLib:Attributes>>;
                    (* idx+ *)
                    ch:
                    (* the key on the keyboard, related to
                     * THIS(keyEvent)
                     *)
                      (# theChar: @char; 
                      <<SLOT GUIENVkeyEventCh:DoPart>>
                      exit theChar
                      #);
                    key:
                    (* the specialkey on the keyboard, related to
                     * THIS(keyEvent).
                     * See keys.bet for descriptions.
                     *)
                      (# theKey: @int32; 
                      <<SLOT GUIENVkeyEventKey:DoPart>>
                      exit theKey
                      #)
                      (* idx- *)
                 do INNER
                 #);
               mouseDown: mouseEvent
               (* This event occurs when the user presses any mouse
                * button down on THIS(interfaceObject)
                *)
                 (#
                    <<SLOT mouseDownLib:Attributes>>;
                    (* idx+ *)
                    delay:
                    (* used to wait for period ticks to pass, while
                     * mouse.isStillDown is true, and then execute
                     * inner.  If mouseStillDown becomes false
                     * before period ticks, inner is not executed
                     *)
                      (# period: @integer
                      enter period
                      <<SLOT GUIENVmouseDownDelay:DoPart>>
                      #)
                      (* idx- *)
                 do INNER
                 #);
               onMouseDown:< mouseDown;
               mouseUp: mouseEvent
               (* This event occurs when the user releases any
                * mouse button after having pressed it on
                * THIS(interfaceObject)
                *) (#  do INNER #);
               onMouseUp:< mouseUp;
               keyDown: keyEvent
               (* Occurs when the user presses a key, related to
                * THIS(interfaceObject)
                *) (#  do INNER #);
               onKeyDown:< keyDown;
               refresh: basicEvent
               (* This event tells THIS(interfaceobject), that it
                * needs to redraw itself. UpdateRect is the 
                * rectangle that needs to be updated expressed
                * in the coordinate system of this(interfaceObject).
                *)
                 (#
                    updateRect:
                      (# value: ^rectangle; 
                      <<SLOT GUIENVupdateRect:DoPart>>
                      exit value[]
                      #)
                 do INNER
                 #);
               onRefresh:< refresh;
               activate: basicEvent
               (* Send when THIS(interfaceObject) becomes active *)
                 (#  do INNER #);
               onActivate:< activate;
               deactivate: basicEvent
               (* Send when THIS(interfaceObject) becomes inactive
                *) (#  do INNER #);
               onDeactivate:< deactivate;
               
            #);
          (* idx- *)
          action:
          (* Actions is a means of subscribing to events.  The
           * desired event is specified by further binding
           * eventType.  Actions can be prepended or appended to
           * THIS(interfaceobject).  When some event is called, the
           * prepended actions for the event is called *before* the
           * inner and the appended actions are called after.
           *)
            (#
               <<SLOT actionLib:Attributes>>;
               eventType:< theEventhandler.event;
               theEvent: ^eventType;
               
            enter theEvent[]
            do INNER ; 
            #);
          prependAction:
          (* Prepends the action, so it will be executed before the
           * event is subscribes to
           *)
            (# theAction: ^action; 
            enter theAction[]
            <<SLOT GUIENVinterfaceObjectPrependAction:DoPart>>
            #);
          appendAction:
          (* Appends the action, so it will be executed after the
           * event is subscribes to.
           *)
            (# theAction: ^action; 
            enter theAction[]
            <<SLOT GUIENVinterfaceObjectAppendAction:DoPart>>
            #);
          deleteAction:
          (* Remove the action *)
            (# theAction: ^action; 
            enter theAction[]
            <<SLOT GUIENVinterfaceObjectDeleteAction:DoPart>>
            #);
          open:<
          (* must be called before any other operation on
           * THIS(interfaceObject).
           *)
            (#
               create:< (#  <<SLOT GUIENVintefaceObjectCreate:DoPart>> #); 
            <<SLOT GUIENVinterfaceObjectOpen:DoPart>>
            #);
          close:<
          (* closes THIS(interfaceObject) and dispose all related
           *              structures
           *) (#  <<SLOT GUIENVinterfaceObjectClose:DoPart>> #);
          enableEventType:<
          (* makes THIS(interfaceObject) sensible to the specified
           * type of events
           *)
            (# ev: ##theEventhandler.event
            enter ev##
            <<SLOT GUIENVenableEventType:DoPart>>
            #);
          disableEventType:<
          (* makes THIS(interfaceObject) insensible to the
           * specified type of events
           *)
            (# ev: ##theEventhandler.event
            enter ev##
            <<SLOT GUIENVdisableEventType:DoPart>>
            #);
          interfaceObjectException:
           exception
          (* abstract superpattern for exceptiosn related to
           * THIS(interfaceObject).
           *) (#  <<SLOT GUIENVinterfaceObjectException:DoPart>> #);
          notOpenedException:
           interfaceObjectException
            (# location: ^text
            enter location[]
            <<SLOT GUIENVnotOpenedException:DoPart>>
            #);
          notOpenedError:<
          (* this exception is raised if any operation is performed
           * on THIS(interfaceObject) is called before open is
           * called.  This will also happen if "close" is called
           * twice
           *) notOpenedException;
          private: @<<SLOT GUIENVinterfaceObjectPrivate:Descriptor>>;
          
       do INNER
       #)
       (* interfaceObject *)
       ;
     menubar: interfaceObject
     (* menubar is a bar containing the titles of the contained
      * menus. A menu is pulled down by clicking at the title,
      * allowing the user to select a menuitem in the menu.  A
      * menubar is only visible if it is installed - either as the
      * global menubar or as the menubar in some window.
      *)
       (#
          <<SLOT menubarLib:Attributes>>;
          append:
          (* inserts a menu after all menues in the menubar.  If
           * the menu is already in the menu bar, nothing happens
           *)
            (# theMenu: ^menu; 
            enter theMenu[]
            <<SLOT GUIENVmenubarAppend:DoPart>>
            #);
          delete:
          (* deletes a menu from the menu bar. The menu titles
           * following the deleted menu will move over to fill the
           * vacancy
           *)
            (# theMenu: ^menu
            enter theMenu[]
            <<SLOT GUIENVmenubarDelete:DoPart>>
            #);
          clear:
          (* removes all menues from the menu bar when you want to
           * start with new menues
           *) (#  <<SLOT GUIENVmenubarClear:DoPart>> #);
          appendMenubar:
          (* inserts all menues in another menubar after all menues
           * in THIS(menubar).  This is the same as calling
           * insertMenubar with NONE as afterMenu.
           *)
            (# theMenubar: ^menubartype; 
            enter theMenubar[]
            <<SLOT GUIENVmenubarAppendMenubar:DoPart>>
            #);
          replaceMenubar:
          (* replace all menues in theMenubar with all menues in
           * replacementMenubar in THIS(menubar).
           *)
            (# theMenubar,replacementMenubar: ^menubartype
            enter (theMenubar[],replacementMenubar[])
            <<SLOT GUIENVmenubarReplaceMenubar:DoPart>>
            #);
          deleteMenubar:
          (* deletes all menues in theMenubar from
           * THIS(menubar). The menu titles following the menues in
           * the deleted menubar will move over to fill the vacancy
           *)
            (# theMenubar: ^menubartype
            enter theMenubar[]
            <<SLOT GUIENVmenubarDeleteMenubar:DoPart>>
            #);
          scan:
          (* iterates over all menues currently inserted in the
           * menubar
           *) (# current: ^menu;  <<SLOT GUIENVmenubarScan:DoPart>> #);
          open::< 
            (#
               create::< 
                 (# 
                 <<SLOT GUIENVmenubarCreate:DoPart>>
                 #);
               
            <<SLOT GUIENVmenubarOpen:DoPart>>
            #);
          close::< 
            (# 
            <<SLOT GUIENVmenubarClose:DoPart>>
            #);
          private: @<<SLOT GUIENVmenubarPrivate:Descriptor>>;
          
       #)
       (* menubar *)
       ;
     menu: interfaceObject
     (* menu contains a group of menuitems and is usefull for
      * letting the user perform commands or set settings in the
      * application. A menu can be installed in a menubar, as a
      * submenu to some menuitem or simply be popped up on the
      * screen.
      *)
       (#
          <<SLOT menuLib:Attributes>>;
          (* idx+ *)
          name:
          (* the name of the menu as shown in the menubar.  if the
           * menu is not in a menubar, the name is not visible
           *)
            (# theName: ^text
            enter (#  enter theName[] <<SLOT GUIENVmenuSetName:DoPart>> #)
            exit
              (# 
              <<SLOT GUIENVmenuGetName:DoPart>>
              exit theName[]
              #)
            #);
          (* idx+ *)
          eventhandler::< 
            (#
               select: event
               (* executed when the user selects THIS(menu) (or
                * pops it up) just before the menu is shown.
                *) (#  do INNER #);
               onSelect:< select;
               
            #);
          (* idx- *)
          menuitem: interfaceObject
          (* menuitem is used for letting the user perform commands
           * in the application or display the state of some option,
           * by checking and unchecking the menuitem. It can also
           * serve as the title of a submenu.
           *)
            (#
               <<SLOT menuitemLib:Attributes>>;
               key:
               (* the key shortcut of THIS(menuitem), allows the
                * user to select THIS(menuitem) without using the
                * mouse.
                *)
                 (# c: @char
                 enter (#  enter c <<SLOT GUIENVmenuitemSetKey:DoPart>> #)
                 exit
                   (# 
                   <<SLOT GUIENVmenuitemGetKey:DoPart>>
                   exit c
                   #)
                 #);
               specialkey:
               (* Extendend version of key. 
                * key is the shortcut, if less than 255 used as char. 
                *)
                 (#
                    key: @integer;
                    (* from special keys in keys.bet *)
                    ctrl,shift,alt: @boolean;
                    
                 enter
                   (# 
                   enter (key,shift,ctrl,alt)
                   <<SLOT GUIENVmenuitemSetSpecialKey:DoPart>>
                   #)
                 #);
               name:
               (* models the name of THIS(menuitem).  Evaluate the
                * enter-part to set the name.  Evaluate the
                * exit-part to get the name
                *)
                 (# t: ^text; 
                 enter
                   (#  enter t[] <<SLOT GUIENVmenuitemSetName:DoPart>> #)
                 exit
                   (# 
                   <<SLOT GUIENVmenuitemGetName:DoPart>>
                   exit t[]
                   #)
                 #);
               checked:
               (* when THIS(menuitem) is checked, a check mark is
                * displayed at the left side the menuitem
                *)
                 (# checked: @boolean
                 enter
                   (# 
                   enter checked
                   <<SLOT GUIENVmenuitemSetChecked:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVmenuitemGetChecked:DoPart>>
                   exit checked
                   #)
                 #);
               subMenu:
               (* if a submenu is attached to THIS(menuitem), that
                * menu is pulled down by selecting
                * THIS(menuitem). In that case onSelect is never
                * issued for THIS(menuitem)
                *)
                 (# theMenu: ^menu; 
                 enter
                   (#  enter theMenu[] <<SLOT GUIENVsetSubMenu:DoPart>> #)
                 exit
                   (# 
                   <<SLOT GUIENVgetSubMenu:DoPart>>
                   exit theMenu[]
                   #)
                 #);
               position: IntegerValue
               (* the position of THIS(menuitem) in its menu,
                * separator items are counted as well
                *) (#  <<SLOT GUIENVmenuitemPosition:DoPart>> #);
               (* idx+ *)
               eventhandler::< 
                 (#
                    onStatus:<
                     booleanValue
                    (* executed just before THIS(menuitem) is
                     * shown.  should return true if THIS(menuitem)
                     * is enabled.  Default is true
                     *) (#  <<SLOT GUIENVmenuitemOnStatus:DoPart>> #);
                    select: event
                    (* executed when THIS(menuitem) is selected in
                     * the menu.  If a submenu is attached, it will
                     * not be executed - instead the submenu is
                     * pulled down
                     *) (#  do INNER #);
                    onSelect:< select;
                    
                 #);
               (* idx- *)
               open::< 
                 (#
                    create::<  (#  <<SLOT GUIENVmenuitemCreate:DoPart>> #); 
                 <<SLOT GUIENVmenuitemOpen:DoPart>>
                 #);
               private:
                 @<<SLOT GUIENVmenuitemPrivate:Descriptor>>;
               
            do INNER
            #)
            (* menuitem *)
            ;
          dynamicMenuitem: menuitem
          (* dynamic menuitem does not call its own onStatus and
           * onSelect events, instead these events are called on the
           * attached action, if any is attached
           *)
            (#
               <<SLOT dynamicItemLib:Attributes>>;
               theAction: ^menuAction;
               attach:
               (* anAction is attached to THIS(menuitem) *)
                 (# anAction: ^menuAction; 
                 enter anAction[]
                 <<SLOT GUIENVmenuitemAttach:DoPart>>
                 #);
               detach:
               (* the menuitemHandler that is currently attached to
                * THIS(menuitem) is detached, meaning that no action
                * is attached
                *) (#  <<SLOT GUIENVmenuitemDetach:DoPart>> #);
               (* idx+ *)
               eventhandler::< 
                 (#
                    onStatus::< 
                      (# 
                      <<SLOT GUIENVdynamicMenuitemOnStatus:DoPart>>
                      #);
                    onSelect::< 
                      (#  <<SLOT GUIENVdynamicMenuitemOnSelect:DoPart>> #);
                    
                 #);
               (* idx- *)
               
            #)
            (* dynamicMenuitem *)
            ;
          menuAction:
          (* a menuAction can dynamicly be attached to
           * dynamicMenuitems within THIS(menu), meaning that the
           * onStatus and onSelect events of THIS(menuAction) will
           * be executed instead of these events of the
           * dynamicMenuitem. The pointer "theMenuitem" refers to
           * the dynamicMenuitem THIS(menuAction) is currently
           * attached to
           *)
            (#
               theMenuitem: (* the menuitem THIS(menuAction) is attached to *)
                 ^dynamicMenuitem;
               onStatus:< booleanValue
               (* this status is evaluated instead of the status of
                * the actual menuitem (theMenuitem) THIS(menuAction)
                * is attached to.  Default returns true
                *) (#  <<SLOT GUIENVactionOnStatus:DoPart>> #);
               onSelect:<
               (* onSelect is executed from the hit of the actual
                * dynamicMenuitem THIS(action) is attached to
                *) object;
               
            #)
            (* action *)
            ;
          (* idx- *)
          separator: menuitem
          (* defines a menu separator, which is a unselectable line
           * in the menu, dividing groups of menuitems.
           *)
            (#
               open::< 
                 (#
                    create::<  (#  <<SLOT GUIENVseparatorCreate:DoPart>> #);
                    
                 <<SLOT GUIENVseparatorOpen:DoPart>>
                 #);
               close::< 
                 (# 
                 <<SLOT GUIENVseparatorClose:DoPart>>
                 #);
               
            #);
          append: (* appends the menuitem to THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            <<SLOT GUIENVmenuAppend:DoPart>>
            #);
          delete:
          (* deletes the menuitem from THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            <<SLOT GUIENVmenuDelete:DoPart>>
            #);
          scan:
          (* iterates over all menuitems in THIS(menu) *)
            (# current: ^menuitem <<SLOT GUIENVmenuScan:DoPart>> #);
          clear:
          (* deletes all menuitems in  THIS(menu) *)
            (#  <<SLOT GUIENVmenuClear:DoPart>> #);
          noOfMenuitems: integerValue
          (* returns the number of menuitems in THIS(menu) *)
            (#  <<SLOT GUIENVmenuNoOfMenuitems:DoPart>> #);
          popUp:
          (* THIS(menu) is popped up as follows: The menuitem
           * indexed by "popupWith" is selected (not checked but
           * hilited) and popupAt is the top left corner of that
           * menuitem in the coordinate system of the popupIn
           * window.
           *)
            (#
               popupWith: @integer;
               popupAt: @point;
               popupIn: ^window.windowitem;
               
            enter (popupWith,popupAt,popupIn[])
            <<SLOT GUIENVmenuPopUp:DoPart>>
            #);
          getMenuitemByNumber:
          (* returns a reference to the menuitem at the specified
           * position in the menu
           *)
            (# number: @integer; theMenuitem: ^menuitem; 
            enter number
            <<SLOT GUIENVmenuGetMenuitemByNumber:DoPart>>
            exit theMenuitem[]
            #);
          enable:
          (* enable THIS(menu) *) (#  <<SLOT GUIENVmenuEnable:DoPart>> #);
          disable: (* disable THIS(menu) *)
            (#  <<SLOT GUIENVmenuDisable:DoPart>> #);
          enabled:< booleanValue
          (* should return true if THIS(menu) is enabled *)
            (#  <<SLOT GUIENVmenuEnabled:DoPart>> #);
          open::<
          (* the menu is not automatically inserted in the
           * menubar. You have to do this yourself
           *) 
            (# create::<  (#  <<SLOT GUIENVmenuCreate:DoPart>> #); 
            <<SLOT GUIENVmenuOpen:DoPart>>
            #);
          close::<
            (#  <<SLOT GUIENVmenuClose:DoPart>> #);
          private:
            @<<SLOT GUIENVmenuPrivate:Descriptor>>;
          
       #)
       (* menu *)
       ;
     standardMenubar: menubar (* idx+ *)
       (#
          standardFileMenu: menu
            (#
               newMenuitem: @dynamicMenuitem;
               openMenuitem: @dynamicMenuitem;
               closeMenuitem: @dynamicMenuitem;
               saveMenuitem: @dynamicMenuitem;
               saveAsMenuitem: @dynamicMenuitem;
               revertMenuitem: @dynamicMenuitem;
               printMenuitem: @dynamicMenuitem;
               pageSetUpMenuitem: @dynamicMenuitem;
               quitMenuitem: @dynamicMenuitem;
               open::<  (#  <<SLOT GUIENVstandardFileMenuOpen:DoPart>> #);
               
            #)
            (* standardFileMenu *)
            ;
          fileMenu:< menu;
          theFileMenu: ^fileMenu;
          standardEditMenu: menu
            (#
               undoMenuitem:
                 @dynamicMenuitem;
               cutMenuitem: @dynamicMenuitem;
               copyMenuitem: @dynamicMenuitem;
               pasteMenuitem: @dynamicMenuitem;
               clearMenuitem: @dynamicMenuitem;
               open::<  (#  <<SLOT GUIENVstandardEditMenuOpen:DoPart>> #)
            #)
            (* standardEditMenu *)
            ;
          editMenu:< menu;
          theEditMenu: ^editMenu;
          open::< 
            (# 
            <<SLOT GUIENVstandardMenubarOpen:DoPart>>
            #);
          
       #);
     (* idx- *)
     window: interfaceObject
     (* user interaction with the window such as dragging and
      * resizing is taken care of by the window manager.  Anything
      * visible you may want to place in the window is subpatterns
      * of the abstract pattern windowitem, which is a subpattern of
      * interfaceObject. The window can be used as a modal dialog by
      * means of the pattern "showModal"
      *)
       (#
          <<SLOT windowLib:Attributes>>;
          AutomaticTarget:< BooleanValue;
          (* idx+ *)
          eventhandler::< 
            (#
               aboutToClose: event
               (* is called whenever the user has performed an
                * action that causes THIS(window) to close.  Further
                * bind this to perform actions before the window is
                * actually closed.  You can prevent the window from
                * closing by assigning false to the boolean
                * 'okToClose'
                *)
                 (# okToClose: @boolean
                 do true->okToClose; INNER
                 exit okToClose
                 #);
               onAboutToClose:< aboutToClose;
               onActivate::<
               (* is send to contents, which takes care of sending
                * the event to all children
                *)  (#  <<SLOT GUIENVwindowOnActivate:DoPart>> #);
               onDeactivate::<
               (* is send to contents, which takes care of sending
                * the event to all children
                *)  (#  <<SLOT GUIENVwindowOnDeactivate:DoPart>> #);
               
            #);
          (* idx- *)
          theMenubar:
          (* is used to install a menubar for THIS(window), and to
           * gain access to the menubar of THIS(window)
           *)
            (# theBar: ^menubartype
            enter
              (#  enter theBar[] <<SLOT GUIENVwindowSetTheMenubar:DoPart>> #)
            exit
              (#  <<SLOT GUIENVwindowGetTheMenubar:DoPart>> exit theBar[] #)
            #);
          menubarType:<
          (* if further bound, an instance of menubarType is
           * automatically installed for THIS(window)
           *) menubar;
          menubarVisible:< (* Specifies if the menubar should be visible. *)
           trueObject;
          type:<
          (* The type can be one of the following:
           *   windowTypes.normal  <- default
           *   windowTypes.dialog
           *   windowTypes.palette
           *) integerValue;
          resizeable:< booleanValue
            (# 
            do (if type = windowTypes.normal then true->value; INNER if); 
            #);
          title:
          (* the title of the window is displayed in the windows
           * title-bar if the window has one.
           *)
            (# theTitle: ^text
            enter
              (#  enter theTitle[] <<SLOT GUIENVwindowSetTitle:DoPart>> #)
            exit
              (# 
              <<SLOT GUIENVwindowGetTitle:DoPart>>
              exit theTitle[]
              #)
            #);
          position:
          (* the window's position is the coordinates of the
           * topLeft corner of the window's inside rectangle on the
           * screen
           *)
            (# pt: @point; 
            enter (#  enter pt <<SLOT GUIENVwindowSetPosition:DoPart>> #)
            exit
              (# 
              <<SLOT GUIENVwindowGetPosition:DoPart>>
              exit pt
              #)
            #);
          size:
          (* the size is the size of the inside rectangle of the
           * window
           *)
            (# width,height: @integer; 
            enter
              (#  enter (width,height) <<SLOT GUIENVwindowSetSize:DoPart>> #)
            exit
              (#  <<SLOT GUIENVwindowGetSize:DoPart>> exit (width,height) #)
            #);
          frame:
          (* the frame is defined as the rectangle THIS(window)
           * occupies on the screen = (position,position + size)
           *)
            (# theFrame: @rectangle; 
            enter (#  enter theFrame <<SLOT GUIENVwindowSetFrame:DoPart>> #)
            exit (#  <<SLOT GUIENVwindowGetFrame:DoPart>> exit theFrame #)
            #);
          insideRectangle:
          (* the inside rectangle is the window's content rectangle
           * in terms of local coordinates in the window.  The top
           * left corner is (0, 0) and the bottom right corner is
           * the window's size
           *)
            (# theRectangle: @rectangle; 
            <<SLOT GUIENVwindowInsideRectangle:DoPart>>
            exit theRectangle
            #);
          show:
          (* shows THIS(window) in front of other windows *)
            (#  <<SLOT GUIENVshowWindow:DoPart>> #);
          showModal:
          (* shows THIS(window) in a modal way. Interaction with
           * other windows is prevented until THIS(window) is either
           * closed or hidden, and then showModal returns to the
           * caller
           *) (#  <<SLOT GUIENVwindowShowModal:DoPart>> #);
          hide:
          (* hides THIS(window), i.e. make it invisible without
           * destroying it. Can be made visible again using show
           *) (#  <<SLOT GUIENVhideWindow:DoPart>> #);
          visible:
          (* The visibility of the window. *)
            (# value: @boolean; 
            enter (#  enter value <<SLOT windowEnterVisible:DoPart>> #)
            exit
              (# 
              <<SLOT windowExitVisible:DoPart>>
              exit value
              #)
            #);
          maxSize:
          (* use this to set the maximum size THIS(window) is
           * allowed to get, when resized by the user. maxSize
           * doesn't affect the behaviour of setSize.
           *)
            (# width,height: @integer; 
            enter
              (# 
              enter (width,height)
              <<SLOT GUIENVwindowSetMaxSize:DoPart>>
              #)
            exit
              (# 
              <<SLOT GUIENVwindowGetMaxSize:DoPart>>
              exit (width,height)
              #)
            #);
          minSize:
          (* use this to set the minimum size THIS(window) is
           * allowed to get, when resized by the user. minSize
           * doesn't affect the behaviour of setSize
           *)
            (# width,height: @integer; 
            enter
              (# 
              enter (width,height)
              <<SLOT GUIENVwindowSetMinSize:DoPart>>
              #)
            exit
              (# 
              <<SLOT GUIENVwindowGetMinSize:DoPart>>
              exit (width,height)
              #)
            #);
          bringToFront:
          (* THIS(window) is brought to the front of all other
           * windows
           *) (#  <<SLOT GUIENVwindowBringToFront:DoPart>> #);
          bringBack:
          (* THIS(window) is placed behind all other windows *)
            (#  <<SLOT GUIENVwindowBringToBack:DoPart>> #);
          bringBehind:
          (* THIS(window) is placed behind the window referred to
           * by "theWindow"
           *)
            (# theWindow: ^window; 
            enter theWindow[]
            <<SLOT GUIENVwindowBringBehind:DoPart>>
            #);
          update:
          (* Updates the window by posting a refresh event.  If
           * emmediate is true, the refresh event will be processed
           * immediately.
           *)
            (# immediate: @boolean; 
            enter immediate
            <<SLOT GUIENVwindowUpdate:DoPart>>
            #);
          backgroundColor:
          (* Sets backgroundcolor of this window *)
            (# theColor: @color
            enter theColor
            <<SLOT GUIENVwindowbackgroundColor:DoPart>>
            #);
          contents:
          (* The contents of THIS(window) is the father of all
           * other windowitems in THIS(window).
           *)
            (# theContents: ^canvas; 
            <<SLOT GUIENVwindowGetContents:DoPart>>
            exit theContents[]
            #);
          target:
          (* the window's target is a reference to the windowitem
           * that receives keyDown. You are responsible for making
           * sure the window's target is the windowitem that is
           * affected by menu commands. The eventhandler of
           * windowitem has two events: "enableTarget" and
           * "disableTarget". When a windowitem is becomming the new
           * target, first "disableTarget" is called for the old
           * target then "enableTarget" is called for the new target
           *)
            (# theTarget: ^windowitem; 
            enter
              (#  enter theTarget[] <<SLOT GUIENVwindowSetTarget:DoPart>> #)
            exit
              (# 
              <<SLOT GUIENVwindowGetTarget:DoPart>>
              exit theTarget[]
              #)
            #);
          (* idx+ *)
          windowitem: interfaceObject
          (* superclass for all interfaceobjects in this window.  A
           * windowitem is always part of a canvas (father)
           *)
            (#
               <<SLOT windowitemLib:Attributes>>;
               automaticTarget:< BooleanValue;
               (* idx+ *)
               eventhandler::< 
                 (#
                    visibleChanged: event
                    (* is called, when THIS(windowitem) is hidden
                     * or shown
                     *) (#  do INNER #);
                    onVisibleChanged:< visibleChanged;
                    frameChanged: event
                    (* is called whenever the frame of
                     * THIS(windowitem) is changed
                     *)
                      (# oldFrame,newFrame: @rectangle; 
                      enter (oldFrame,newFrame)
                      do INNER
                      #);
                    onFrameChanged:< frameChanged;
                    fatherFrameChanged: event
                    (* is called when the frame of the father of
                     * THIS(windowitem) is changed
                     *)
                      (# oldFrame,newFrame: @rectangle; 
                      enter (oldFrame,newFrame)
                      do INNER
                      #);
                    onFatherFrameChanged:< fatherFrameChanged;
                    enabledChanged: event
                    (* is called, when THIS(windowitem) is
                     * enabled/disabled
                     *) (#  do INNER #);
                    onEnabledChanged:< enabledChanged;
                    enableTarget: event
                    (* is called when THIS(windowitem) is becomming
                     * target in the window
                     *) (#  do INNER #);
                    onEnableTarget:< enableTarget;
                    disableTarget: event
                    (* is called when THIS(windowitem) was target
                     * and another windowitem is becomming target
                     *) (#  do INNER #);
                    onDisableTarget:< disableTarget;
                    borderVisibleChanged: event
                    (* is called, when the border of 
                     * THIS(windowitem) is shown or hidden
                     *) (#  do INNER #);
                    onBorderVisibleChanged:< borderVisibleChanged;
                    borderStyleChanged: event
                    (* is called, when the border style of
                     * THIS(windowitem) is changed
                     *) (#  do INNER #);
                    onBorderStyleChanged:< borderStyleChanged;
                    theCursorChanged: event
                    (* is called, when THIS(windowitem) is assigned
                     * a new cursor
                     *) (#  do INNER #);
                    onTheCursorChanged:< theCursorChanged;
                    hiliteChanged: event
                    (* Is called when THIS(windowitem) is hilited
                     * or dehilited
                     *) (#  do INNER ;  #);
                    onHiliteChanged:< hiliteChanged;
                    onRefresh::< 
                      (#  <<SLOT GUIENVwindowitemOnRefresh:DoPart>> #);
                    mouseEnter: event
                    (* Is called when the mouse enters THIS(windowitem) *)
                      (#  do INNER #);
                    onMouseEnter:< mouseEnter;
                    mouseLeave: event
                    (* Is called when the mouse leaves THIS(windowitem) *)
                      (#  do INNER #);
                    onMouseLeave:< mouseLeave;
                    
                 #);
               (* idx- *)
               father: ^
               (* father is the canvas that THIS(windowitem) is a
                * child of
                *) canvas;
               frame:
               (* the frame is defined as the rectangle
                * THIS(windowitem) occupies in the coordinate system
                * of the father. When the frame is changed
                * THIS(windowitem) is updated and the father is
                * informed about the change.  If you need other
                * actions to take place, when changing the frame,
                * you must further bind the event onFrameChanged
                *)
                 (# theFrame: @rectangle; 
                 enter
                   (# 
                   enter theFrame
                   <<SLOT GUIENVwindowitemSetFrame:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetFrame:DoPart>>
                   exit theFrame
                   #)
                 #);
               position:
               (* the position of THIS(windowitem) is defined as
                * the topLeft corner of the bounding frame. When the
                * position is changed, the frame is changed, so the
                * onFrameChanged event is called
                *)
                 (# pt: @point; 
                 enter
                   (# 
                   enter pt
                   <<SLOT GUIENVwindowitemSetPosition:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetPosition:DoPart>>
                   exit pt
                   #)
                 #);
               move:
               (* moves THIS(windowitem) relative (dh, dv), by
                * setting the position, meaning that the
                * onFrameChanged event is called
                *)
                 (# dh,dv: @integer; 
                 enter (dh,dv)
                 <<SLOT GUIENVwindowitemMove:DoPart>>
                 #);
               size:
               (* the size of THIS(windowitem) is defined as the
                * height and width of the bounding frame. When the
                * size is changed, the frame is changed, so the
                * onFrameChanged event is called
                *)
                 (# width,height: @integer; 
                 enter
                   (# 
                   enter (width,height)
                   <<SLOT GUIENVwindowitemSetSize:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetSize:DoPart>>
                   exit (width,height)
                   #)
                 #);
               fitToContents:<
               (* Adjusts the size of THIS(windowItem) to 
                * fit the contents
                *)
                 (# doneInInner: @boolean; 
                 <<SLOT guienvFitToContents:DoPart>>
                 #);
               bindLeft,bindRight,bindBottom,
                 bindTop: @
               (* these attributes specify how THIS(windowitem)
                * shall behave when the father changes it's
                * frame. If e.g. "bindLeft" is true, the leftSide
                * will have the same constant distance to the
                * leftSide of the father, when the father is resized
                *) boolean;
               visible:
               (* an invisible windowitem will be ingored w.r.t.
                * user interaction (it is not visible on the screen)
                *)
                 (# value: @boolean; 
                 enter
                   (# 
                   enter value
                   <<SLOT GUIENVwindowitemSetVisible:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetVisible:DoPart>>
                   exit value
                   #)
                 #);
               hilite:
                 (# value: @boolean; 
                 enter
                   (# 
                   enter value
                   <<SLOT GUIENVwindowitemSetHilite:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetHilite:DoPart>>
                   exit value
                   #)
                 #);
               show: (* makes THIS(windowitem) visible *)
                 (#  <<SLOT GUIENVwindowitemShow:DoPart>> #);
               hide:
               (* makes THIS(windowitem) invisible *)
                 (#  <<SLOT GUIENVwindowitemHide:DoPart>> #);
               enabled:
               (* if THIS(windowitem) is enabled it receives mouse
                * events or key events
                *)
                 (# value: @boolean
                 enter
                   (# 
                   enter value
                   <<SLOT GUIENVwindowitemSetEnabled:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetEnabled:DoPart>>
                   exit value
                   #)
                 #);
               enable:
               (* enables THIS(windowitem) so it can receive mouse
                * or key events
                *) (#  <<SLOT GUIENVwindowitemEnable:DoPart>> #);
               disable:
               (* disables THIS(windowitem) so it does not receive
                * any mouse or key events
                *) (#  <<SLOT GUIENVwindowitemDisable:DoPart>> #);
               backgroundColor:
                 (# theColor: @color; 
                 enter
                   (# 
                   enter theColor
                   <<SLOT windowItemEnterBackgroundColor:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT windowItemExitBackgroundColor:DoPart>>
                   exit theColor
                   #)
                 #);
               border: @
               (* the border around THIS(windowitem) makes it 
                * apparent, where it is located on the screen.
                *) (* idx+ *)
                 (#
                    visible:
                    (* if the border is visible, the insideRect of
                     * THIS(windowitem) is inset depending on the
                     * style of the border.
                     *)
                      (# value: @boolean; 
                      enter
                        (# 
                        enter value
                        <<SLOT GUIENVwindowitemBorderSetVisible:DoPart>>
                        #)
                      exit
                        (# 
                        <<SLOT GUIENVwindowitemBorderGetVisible:DoPart>>
                        exit
                        value
                        #)
                      #);
                    style:
                    (* the border style can be one of the
                     * following:
                     *   borderStyles.simple: 
                     *      A simple one pixel wide border.
                     *   borderStyles.shadowIn:
                     *      Draws the border so THIS(windowitem)
                     *      appears inset.
                     *   borderStyles.shadowOut:
                     *      Draws the border so THIS(windowitem)
                     *      appears outset.
                     *   borderStyles.etchedIn:
                     *      Draws the border using a double line
                     *      giving the effect of a line etched
                     *      into the window.
                     *   borderStyles.etchedOut:
                     *      Draws the border using a double line
                     *      giving the effect of a line comming
                     *      out of the window.
                     *)
                      (# value: @integer; 
                      enter
                        (# 
                        enter value
                        <<SLOT GUIENVwindowitemBorderSetStyle:DoPart>>
                        #)
                      exit
                        (# 
                        <<SLOT GUIENVwindowitemBorderGetStyle:DoPart>>
                        exit
                        value
                        #)
                      #);
                    
                 #);
               (* idx- *)
               insideRectangle:
               (* insideRectangle is the area inside the border of
                * THIS(windowitem).
                *)
                 (# theRectangle: @rectangle; 
                 <<SLOT GUIENVwindowiteminsideRectangle:DoPart>>
                 exit
                 theRectangle
                 #);
               theCursor:
               (* theCursor is used to install a cursor for
                * THIS(windowitem), and to gain access to the cursor
                * of THIS(windowitem)
                *)
                 (# theCur: ^cursor; 
                 enter
                   (# 
                   enter theCur[]
                   <<SLOT GUIENVwindowitemSetTheCursor:DoPart>>
                   #)
                 exit
                   (# 
                   <<SLOT GUIENVwindowitemGetTheCursor:DoPart>>
                   exit theCur[]
                   #)
                 #);
               cursorType:<
               (* if further bound, an instance of cursorType is
                * automatically installed for THIS(windowitem)
                *) cursor;
               (* idx+ *)
               trackMouse:
               (* this is a control pattern usually evaluated from
                * a mouseDown eventhandler. Initially 'mousePress'
                * is evaluated, then 'mouseMove' is evaluated
                * whenever the mouse moves as long as the mouse is
                * stillDown - (h, v) will be the horizontal and
                * vertical distance the mouse has moved since the
                * last call to 'mouseMove'.  When the user releases
                * the mouse, 'mouseRelease' is evaluated.  If the
                * mouse isn't stillDown (see stillDown) when track
                * is called nothing will happen.  All the
                * coordinates are local to THIS(WindowItem).
                *)
                 (#
                    mousePress:< object;
                    mouseMove:<
                      (# h,v: @integer;  enter (h,v) do INNER #);
                    mouseRelease:< object;
                    curPt,prevPt: @point;
                    
                 <<SLOT GUIENVwindowItemTrackMouse:DoPart>>
                 #);
               (* idx- *)
               drag:
               (* lets the user drag a gray outline of this
                * windowitem
                *) (#  <<SLOT GUIENVwindowitemDrag:DoPart>> #);
               resize:
               (* lets the user resize this windowitem by dragging
                * a gray outline
                *) (#  <<SLOT GUIENVwindowitemResize:DoPart>> #);
               update:
               (* THIS(windowitem) is updated, by posting an
                * refresh event to the window. If "immediate" is
                * true the update is performed immediately,
                * otherwise the update is performed, when there is
                * no other event waiting (this is normally what you
                * want)
                *)
                 (# immediate: @boolean; 
                 enter immediate
                 <<SLOT GUIENVwindowitemUpdate:DoPart>>
                 #);
               open::<
               (* initially a windowitem is visible and active *) 
                 (#
                    create::<  (#  <<SLOT GUIENVwindowitemCreate:DoPart>> #);
                    
                 enter father[]
                 <<SLOT GUIENVwindowitemOpen:DoPart>>
                 #);
               close::<
               (* no actions are performed at this level *) 
                 (#  <<SLOT GUIENVwindowitemClose:DoPart>> #);
               private:
                 @<<SLOT GUIENVwindowitemPrivate:Descriptor>>;
               
            #);
          (* windowitem *)
          separator: windowitem
          (* a separator is a horzontal or vertical separating line
           *)
            (#
               <<SLOT separatorLib:Attributes>>;
               (* idx+ *)
               eventhandler::< 
                 (#
                    styleChanged: event
                    (* Called when the style is changed *)
                      (#  do INNER #);
                    onStyleChanged:< styleChanged;
                    onRefresh::< 
                      (#  <<SLOT GUIENVwindowSeparatorOnRefresh:DoPart>> #);
                    
                 #);
               (* idx- *)
               vertical:<
               (* Further bind to specify the orientation of
                * THIS(separator) default is horizontal
                *) booleanObject;
               style:
               (* the  style can be one of the following:
                *   lineStyles.singleLine: 
                *     A single line is drawn.
                *   lineStyles.doubleLine:
                *     A double line is drawn.
                *   lineStyles.dashedSingleLine:
                *     A dashed single line is drawn.
                *   lineStyles.dashedDoubleLine:
                *     A dashed double line is drawn.
                *   lineStyles.etchedIn:
                *     A double line is drawn giving the effect of
                *     a line etched into the window.
                *   lineStyles.etchedOut:
                *     A double line is drawn giving the effect of
                *     a line comming of of the window.
                *)
                 (# value: @integer; 
                 enter
                   (#  enter value <<SLOT GUIENVseparatorSetStyle:DoPart>> #)
                 exit
                   (#  <<SLOT GUIENVseparatorGetStyle:DoPart>> exit value #)
                 #);
               open::< 
                 (#
                    create::< 
                      (#  <<SLOT GUIENVwindowseparatorCreate:DoPart>> #);
                    
                 <<SLOT GUIENVwindowseparatorOpen:DoPart>>
                 #);
               close::<  (#  <<SLOT GUIENVwindowseparatorClose:DoPart>> #);
               private:
                 @<<SLOT GUIENVwindowseparatorPrivate:Descriptor>>;
               
            #);
          canvas: windowitem
          (* A canvas is a sub-window in the window.  Only the
           * windowitems located inside the frame of THIS(canvas)
           * will be visible
           *)
            (#
               <<SLOT canvasLib:Attributes>>;
               (* idx+ *)
               eventhandler::< 
                 (#
                    childFrameChanged: event
                    (* is called when a child of THIS(canvas) has
                     * changed frame
                     *)
                      (# oldFrame,newFrame: @rectangle; 
                      enter (oldFrame,newFrame)
                      do INNER
                      #);
                    onChildFrameChanged:< childFrameChanged;
                    onActivate::< 
                      (#  <<SLOT GUIENVcanvasOnActivate:DoPart>> #);
                    onDeactivate::< 
                      (# 
                      <<SLOT GUIENVcanvasOnDeactivate:DoPart>>
                      #);
                    onMouseDown::< 
                      (#  <<SLOT GUIENVcanvasOnMouseDown:DoPart>> #);
                    onRefresh::< 
                      (# 
                      <<SLOT GUIENVcanvasOnRefresh:DoPart>>
                      #);
                    onMouseUp::< 
                      (#  <<SLOT GUIENVcanvasOnMouseUp:DoPart>> #);
                    onFrameChanged::< 
                      (# 
                      <<SLOT GUIENVcanvasOnFrameChanged:DoPart>>
                      #);
                    onVisibleChanged::< 
                      (#  <<SLOT GUIENVcanvasOnVisibleChanged:DoPart>> #);
                    
                 #);
               (* idx- *)
               selection: @
               (* idx+ *)
                 (#
                    add:
                      (# theWindowitem: ^windowitem; 
                      enter theWindowitem[]
                      <<SLOT GUIENVcanvasSelectionAdd:DoPart>>
                      #);
                    set:
                      (# theWindowitem: ^windowitem; 
                      enter theWindowitem[]
                      <<SLOT GUIENVcanvasSelectionSet:DoPart>>
                      #);
                    remove:
                      (# theWindowitem: ^windowitem; 
                      enter theWindowitem[]
                      <<SLOT GUIENVcanvasSelectionRemove:DoPart>>
                      #);
                    empty: booleanValue
                      (#  <<SLOT GUIENVcanvasSelectionEmpty:DoPart>> #);
                    scan:
                      (#
                         current:
                           ^windowitem;
                         
                      <<SLOT GUIENVcanvasSelectionScan:DoPart>>
                      #);
                    clear:
                      (# 
                      <<SLOT GUIENVcanvasSelectionClear:DoPart>>
                      #);
                    
                 #);
               (* idx- *)
               scan: (* Scan operation on the children of THIS(canvas) *)
                 (# current: ^windowitem; 
                 <<SLOT GUIENVcanvasScan:DoPart>>
                 #);
               open::<
               (* The canvas is opened and displayed. *) 
                 (# create::<  (#  <<SLOT GUIENVcanvasCreate:DoPart>> #); 
                 <<SLOT GUIENVcanvasOpen:DoPart>>
                 #);
               close::<
               (* close is called for all the children of
                * THIS(canvas)
                *)  (#  <<SLOT GUIENVcanvasClose:DoPart>> #);
               private:
                 @<<SLOT GUIENVcanvasPrivate:Descriptor>>;
               
            #)
            (* canvas *)
            ;
          localToGlobal:
          (* Translate the point from global coordinates to window
           * coordinates.
           *)
            (# local,global: @point; 
            enter local
            <<SLOT GUIENVwindowLocalCoordsToGlobal:DoPart>>
            exit global
            #);
          globalToLocal:
          (* Translates the point to window coordinates to global
           * local coordinates
           *)
            (# global,local: @point; 
            enter global
            <<SLOT GUIENVwindowGlobalToLocal:DoPart>>
            exit local
            #);
          addTarget:
            (# item: ^windowitem
            enter item[]
            <<SLOT GUIENVwindowAddTarget:DoPart>>
            #);
          (* idx- *)
          open::< 
            (# create::<  (#  <<SLOT GUIENVwindowCreate:DoPart>> #); 
            <<SLOT GUIENVwindowOpen:DoPart>>
            #);
          close::<
          (* the windows close operation is normally automatically
           * called from the content's aboutToGoAway event.  You can
           * also call it directly. theContents.close is called to
           * close all of the windows internal structures
           *)  (#  <<SLOT GUIENVwindowClose:DoPart>> #);
          <<SLOT BifrostAttributes:Attributes>>;
          private: @<<SLOT GUIENVwindowPrivate:Descriptor>>;
          
       #)
       (* window *)
       ;
     cursor:
     (* A cursor is the raster attached to the mouse pointer *)
       (#
          <<SLOT cursorLib:Attributes>>;
          private:
            @<<SLOT GUIENVcursorPrivate:Descriptor>>
       #);
     pixmap: (* Pixmap pattern *)
       (#
          <<SLOT pixmapLib:Attributes>>;
          read:
          (* Reads the specified file into THIS(pixmap). 
           * The type of the  file are guessed by looking 
           * at the extension, or the the first few bytes,
           * or the macintosh file type - all depending
           * on the platform
           *)
            (#
               name: ^text;
               error:< exception
                 (# what: ^text; 
                 enter what[]
                 do what[]->msg.append; INNER ; 
                 #);
               
            enter name[]
            <<SLOT pixMapRead:DoPart>>
            #);
          clear:
          (* Clear the Pixmap with the specified color *)
            (# theColor: @Color; 
            enter theColor
            <<SLOT pixmapClear:DoPart>>
            #);
          init:<
          (* Intializes the raster to have the specified width 
           * and height. Allocates any data needed - 
           * you have to call dispose to free that data.
           *)
            (# width,height: @integer; 
            enter (width,height)
            <<SLOT pixmapInit:DoPart>>
            #);
          dispose:<
          (* call this to dispose the memory occupied 
           * by THIS(pixmap) when completely done with 
           * THIS(pixmap)
           *) (#  <<SLOT pixmapDispose:DoPart>> #);
          width: integerValue
          (* returns the width set by init or by 
           * read operations 
           *) (#  <<SLOT pixmapWidth:DoPart>> #);
          height: integerValue
          (* returns the height set by init or 
           * by read operations 
           *) (#  <<SLOT pixmapHeight:DoPart>> #);
          transparent:
          (* Specifies that the "background" of this(pixmap) is
           * transparent.
           * This attribute is automatically set to TRUE 
           * If a transparentColor or a mask is specified.
           * If "transparent" is set to FALSE, the transparentColor
           * or mask will be cleared.
           *)
            (# value: @boolean; 
            enter (#  enter value <<SLOT pixmapSettransparent:DoPart>> #)
            exit
              (# 
              <<SLOT pixmapGettransparent:DoPart>>
              exit value
              #)
            #);
          transparentColor:
          (* Specify which color in the pixmap should be transparent.
           * This will normally be the background color in the pixmap.
           * When a transparentColor is specified the "transparent" 
           * attribute will be set to TRUE.
           * If the "transparent" is set to FALSE, any transparentColor
           * will be cleared.
           *)
            (# theColor: @color; 
            enter
              (#  enter theColor <<SLOT pixmapSettransparentColor:DoPart>> #)
            exit
              (#  <<SLOT pixmapGettransparentColor:DoPart>> exit theColor #)
            #);
          mask:
          (* Specify a mask for this(pixmap). A mask is a one-depth
           * pixmap. Only the pixels in this(pixmap) that has 
           * corresponding pixel in the mask with the value 1, will
           * be drawn on the screen, when drawing this(pixmap).
           * If a mask is specified the "transparent" attribute will
           * be set to TRUE. If transparent is set to FALSE, any mask
           * will be cleared.
           *)
            (# theMask: ^pixmap; 
            enter (#  enter theMask[] <<SLOT pixmapSetMask:DoPart>> #)
            exit
              (# 
              <<SLOT pixmapGetMask:DoPart>>
              exit
              theMask[]
              #)
            #);
          drawPixmap: (* Draw the pixmap "other" on this(pixmap) *)
            (# other: ^pixmap; from,to: @point; width,height: @integer; 
            enter (other[],from,to,width,height)
            <<SLOT pixmapDrawPixmap:DoPart>>
            #);
          private: @<<SLOT pixmapPrivate:Descriptor>>;
          
       #);
     textStyle:
     (* textStyle is font, size and face. You can use this pattern
      * to communicate stylic changes to layout-text and
      * document-text - or to get information about the dimension of
      * text drawn in a specific textStyle
      *)
       (#
          <<SLOT textStyleLib:Attributes>>;
          name:
          (* models the name of the font of THIS(textStyle). *)
            (# theName: ^text; 
            enter
              (#  enter theName[] <<SLOT GUIENVtextStyleSetName:DoPart>> #)
            exit
              (# 
              <<SLOT GUIENVtextStyleGetName:DoPart>>
              exit theName[]
              #)
            #);
          size:
            (# value: @integer; 
            enter (#  enter value <<SLOT GUIENVtextStyleSetSize:DoPart>> #)
            exit (#  <<SLOT GUIENVtextStyleGetSize:DoPart>> exit value #)
            #);
          face:
            (# value: @integer; 
            enter (#  enter value <<SLOT GUIENVtextStyleSetFace:DoPart>> #)
            exit (#  <<SLOT GUIENVtextStyleGetFace:DoPart>> exit value #)
            #);
          ascent: integerValue
          (* ascent is the maximum amount of pixels a character
           * drawn in THIS(textStyle) will go above the base line
           *) (#  <<SLOT GUIENVtextStyleAscent:DoPart>> #);
          descent: integerValue
          (* descent is the maximum amount of pixels a character
           * drawn in THIS(textStyle) will go below the base line
           *) (#  <<SLOT GUIENVtextStyleDescent:DoPart>> #);
          leading: integerValue
          (* leading is the vertical distance between the descent
           * of one line and the ascent of the next line
           *) (#  <<SLOT GUIENVtextStyleLeading:DoPart>> #);
          lineHeight: integerValue
          (* the line height (in pixels) is determined by adding
           * the ascent, descent, and leading
           *) (#  <<SLOT GUIENVtextStyleHeight:DoPart>> #);
          maxChWidth: integerValue
          (* the greatest distance the pen will move when a
           * character is drawn
           *) (#  <<SLOT GUIENVtextStyleMaxChWidth:DoPart>> #);
          widthOfChar: integerValue
          (* in most fonts the width of the characters
           * differs. This method returns the width of the character
           * "ch" when drawn in THIS(textStyle)
           *)
            (# ch: @char
            enter ch
            <<SLOT GUIENVtextStyleWidthOfChar:DoPart>>
            #);
          widthOfText: integerValue
          (* widthOfText returns the width of the given text
           * string, when drawn in THIS(textStyle), which it
           * calculates by adding the charWidths of all the
           * characters in the string
           *)
            (# str: ^text
            enter str[]
            <<SLOT GUIENVtextStyleWidthOfTextCommon:DoPart>>
            #);
          availableSizes:
          (* an inner is executed for all available sizes in the
           * font of THIS(textStyle)
           *)
            (# thisSize: @integer; 
            <<SLOT GUIENVtextStyleFamilySizes:DoPart>>
            #);
          private:
            @<<SLOT GUIENVtextStylePrivate:Descriptor>>;
          
       #)
       (* textStyle *)
       ;
     color: (* A Color has three components: red, green and blue. *)
       (# <<SLOT colorLib:Attributes>>; red,green,blue: @integer; 
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     timer:
       (#
          <<SLOT timerLib:Attributes>>;
          once:<
           booleanValue;
          start:
            (# interval: @integer
            enter interval
            <<SLOT GUIenvTimerStart:DoPart>>
            #);
          stop:
            (# 
            <<SLOT GUIenvTimerStop:DoPart>>
            #);
          action:< object;
          private: @<<SLOT GUIenvTimerPrivate:Descriptor>>;
          
       #);
     clipboard: @
     (* models the clipboard, which is used to transport pictures
      * and text between applications
      *)
       (#
          <<SLOT clipBoardLib:Attributes>>;
          hasText: booleanValue
          (* returns true if the contents of the clipBoard is text
           *) (#  <<SLOT GUIENVclipBoardHasText:DoPart>> #);
          textContents:
          (* evaluate the enter-part to set the clipboards
           * text-contents, and evaluate the exit-part to get the
           * clipboards text-contents.  If the clipboard doesn't
           * contain text, NONE is returned.  You can call hasText,
           * before calling getTextContents to determine if there is
           * text to get
           *)
            (# txt: ^text; 
            enter (#  enter txt[] <<SLOT GUIENVclipBoardSetText:DoPart>> #)
            exit (#  <<SLOT GUIENVclipBoardGetText:DoPart>> exit txt[] #)
            #);
          clearContents: (* call this to empty all contents of the clipboard *)
           (#  <<SLOT GUIENVclipBoardClearContents:DoPart>> #);
          
       #)
       (* clipboard *)
       ;
     mouse: @ (* models the mouse *)
       (#
          <<SLOT mouseLib:Attributes>>;
          globalPosition:
          (* the global position of the mouse is returned. You
           * can't set the position
           *)
            (# pt: @point; 
            <<SLOT GUIENVmouseGlobalPosition:DoPart>>
            exit pt
            #);
          buttonState: integerValue
          (* the number designating the button, currently pressed
           * down - 0 means 'no button'.  This value depends on the
           * number of buttons on the mouse - Typically 1, 2 or 3.
           *) (#  <<SLOT GUIENVmouseButtonState:DoPart>> #);
          busyCursor:
          (* A busy cursor is a sign to the user that the
           * application are doing some processing. You will
           * normally use cursors.watch for this purpose. Set
           * busyCursor to none, when done processing.
           *)
            (# theCur: ^cursor; 
            enter
              (#  enter theCur[] <<SLOT GUIENVmouseTheCursorSet:DoPart>> #)
            exit
              (# 
              <<SLOT GUIENVmouseTheCursorGet:DoPart>>
              exit theCur[]
              #)
            #);
          
       #)
       (* mouse *)
       ;
     globalKeyDownAction:
     (* GlobalKeyDownAction handles keydown events globally before or after
      * any other handling of the event.
      * 
      * Assigning 'true -> done' prevents any other handling of the event.
      * 
      * If the action is appended, other handling of the event can not be
      * prevented.
      *)
       (# key: @char; control: @boolean; done: @boolean; 
       enter (key,control)
       do false->done; INNER ; 
       exit done
       #);
     prependAction:
     (* Prepends the global action, which means the action
      * will be executed before any other handling of a keydown
      * event.
      *)
       (# theAction: ^globalKeyDownAction; 
       enter theAction[]
       <<SLOT GUIENVPrependAction:DoPart>>
       #);
     appendAction:
     (* Appends the action, which means that the action will
      * be executed after any other handling of the event.
      *)
       (# theAction: ^globalKeyDownAction; 
       enter theAction[]
       <<SLOT GUIENVAppendAction:DoPart>>
       #);
     (* These models different properties of the current system 
      * next 5 patterns was formerly in a systempattern      
      *)
     screenRectangle: (* the rectangle of the main screen. *)
       (# theRectangle: @rectangle; 
       <<SLOT GUIENVsystemScreenRectangle:DoPart>>
       exit theRectangle
       #);
     screenRgn:
     (* the region defining the screen(s) *)
       (# rgn: ^region; 
       <<SLOT GUIENVsystemScreenRgn:DoPart>>
       exit rgn[]
       #);
     standardTextStyle:
     (* the textStyle used by the system to draw menutitles
      * etc.
      *) @textStyle;
     beep: (* beeps using the current beep in the system *)
       (#  <<SLOT GUIENVsystemBeepBody:DoPart>> #);
     guienvWait:
     (* delays the specified number of ticks (1 tick = 1/60
      * sec.)
      *)
       (# ticks: @integer; 
       enter ticks
       <<SLOT GUIENVsystemWaitBody:DoPart>>
       #);
     transferModes: @
       (#
          copy: (#  exit 0 #);
          invertCopy: (#  exit 1 #);
          erase: (#  exit 2 #);
          andBlend: (#  exit 3 #);
          orBlend: (#  exit 4 #);
          xorBlend: (#  exit 5 #);
          notAndBlend: (#  exit 6 #);
          notOrBlend: (#  exit 7 #);
          
       #);
     textFaces: @
       (#
          <<SLOT textFacesLib:Attributes>>;
          plain: (#  exit 0 #);
          bold: (#  exit 1 #);
          italic: (#  exit 2 #);
          
       #);
     patterns: @ (# black,dkGray,gray,ltGray,white: ^pixmap #);
     cursors: @ (# arrow,iBeam,watch,cross,plus,hand: @cursor #);
     borderStyles: @
       (#
          simple: (#  exit 1 #);
          etchedOut: (#  exit 2 #);
          etchedIn: (#  exit 3 #);
          shadowIn: (#  exit 4 #);
          shadowOut: (#  exit 5 #);
          
       #);
     separatorStyles: @
       (#
          singleLine: (#  exit 1 #);
          doubleLine: (#  exit 2 #);
          singleDashedLine: (#  exit 3 #);
          doubleDashedLine: (#  exit 4 #);
          etchedIn: (#  exit 5 #);
          etchedOut: (#  exit 6 #);
          
       #);
     windowTypes: @
       (#
          normal: integerValue (#  do 0->value #);
          dialog: integerValue (#  do 1->value #);
          palette: integerValue (#  do 2->value #);
          modelessDialog: integerValue (#  do 3->value #);
          
       #);
     specKeys: @specialKeys;
     private: @<<SLOT GUIENVPrivate:Descriptor>>;
     trace:
     (* For debugging. If doTrace is true, inner is called. *)
       (#  do (if doTrace then INNER if);  #);
     doTrace: @Boolean;
     (* Additions needed for bifrost *)
     bifrostprivate: @<<SLOT BifrostPrivate:Descriptor>>;
     displaywarnings: @boolean
     (* If displayWarnings is true, various warnings about bifrost
      * errors that are not fatal, but may affect the behaviour, is
      * displayed. Defaults to true.
      *) ;
     warnStream: ^stream
     (* The stream bifrost warnings are put to. Defaults to
      * screen.
      *) ;
     (* Additions needed for systemenv *)
     doSetup:
       (# 
       do
          (if not setupDone then
              <<SLOT GUIENVdoSetUp:Descriptor>>; true->setupDone
          if)
       #);
     setupDone: @Boolean;
     XsystemEnvPresent: @Boolean;
     (* TRUE if this is a XsystemEnv program.  In this case,
      * callbacks are executed by a separate thread as synchronisation
      * via semaphores between x-callbacks and other coroutines would
      * not be possible otherwise. (It could lead to suspend of
      * coroutines with C stackparts.  If TRUE,
      * XsystemEnvHandleCallback should not be NONE.
      *)
     XsystemEnvHandleCallbackP: (# cb: ^Object;  enter cb[] do INNER #);
     XsystemEnvHandleCallback: ^XsystemEnvHandleCallbackP;
     
  <<SLOT GUIENVDoPart:DoPart>>
  #)
  (* GUIenv *)  

