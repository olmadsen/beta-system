ORIGIN '~beta/basiclib/v1.6/betaenv';
INCLUDE '~beta/containers/v1.6/list';
INCLUDE 'graphmath';
BODY  'private/guienvbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: attributes --
(* idx=3 *)
GUIenv: 
  (# <<SLOT guienvLib: attributes>>;
     onStartApplication:< 
       (* is called when this application is started with no
        * documents. You can for example further bind this to show a
        * splash screen
        *)
       (# do INNER #);
     onOpenDocument:<
       (* is called whenever a user opens a document created by this
        * application
        *)
       (# fileName: ^text;
       enter fileName[]
       do INNER
       #);
     onQuit:<
       (* is called when application is going to quit, either
        * because terminate is called or because the system are
	* are going to shut down.
	* If okToQuit is set to false the application will
	* not quit.
	*)
       (# okToQuit: @boolean;
       do true -> okToQuit;
       	  INNER;
       exit okToQuit
       #);
     terminate:
       (* will terminate the entire application if invoked 
        * Terminate calls onQuit and will only quit if
	* onQuit returns true.
	*) 
       (# <<SLOT GUIENVterminateBody: doPart>> #);
     applicationMenubar:
       (* applicationMenubar is used to install a menubar with
        * functionality that is common for all parts for the
        * application.
        *)
       (# theMenubar: ^menubarType
       enter (# enter theMenubar[] <<SLOT GUIENVsetTheMenubar: doPart>> #)
       exit (# <<SLOT GUIENVgetTheMenubar: doPart>> exit theMenuBar[] #)
       #);
     menubarType:<
       (* if further bound, an instance of menubarType is
        * automatically installed for the application. Further bind it
        * to standardMenubar if you want the standard menubar (file
        * and edit menu)
        *)
       menubar;
     interfaceObject: 
       (* superpattern for all objects used for interaction with the
        * user
        *)
       (# <<SLOT interfaceObjectLib: attributes>>;
          (* idx+ *)
          theEventhandler: 
            (* The only instance of the eventhandler virtual *)
            @eventhandler;
          eventhandler:<
            (* Encapsulates the patterns related to event handling *)
            (# <<SLOT eventhandlerLib: attributes>>;
               event: 
                 (* the abstract superpattern of all events *)
                 (# <<SLOT eventLib: attributes>>;
                 <<SLOT GUIENVinterfaceObjectEvent: doPart>>
                 #) (* event *);
               basicEvent: event 
                 (* abstract superpattern for all events
                  * originating directly from the OS 
                  *)
                 (# <<SLOT basicEventLib: attributes>>;
                    (* idx+ *)
                    shiftKey: booleanValue
                      (* true if the shiftkey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      <<SLOT GUIENVbasicEventShiftKey: doPart>>
                      #);
                    altKey: booleanValue
                      (* true if the altkey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      <<SLOT GUIENVbasicEventAltKey: doPart>>
                      #);
                    metaKey: booleanValue
                      (* true if the metakey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      <<SLOT GUIENVbasicEventMetaKey: doPart>>
                      #);
                    controlKey: booleanValue
                      (* true if the controlkey was the down, when
                       * THIS(basicEvent) occurred
                       *)
                      (# 
                      <<SLOT GUIENVbasicEventControlKey: doPart>>
                      #);
                    buttonState: integerValue
                      (* the number designating the button, which was
                       * pressed down, when THIS(basicEvent) occurred
                       * - 0 means 'no button'.  This value depe nds
                       * on the number of buttons on the mouse -
                       * Typically 1, 2 or 3.
                       *)
                      (# 
                      <<SLOT GUIENVbasicEventButtonState: doPart>>
                      #);
                    when: integerValue
                      (* the tick count when THIS(basicEvent)
                       * occurred.  1 tick = 1/60 sec.
                       *)
                      (# 
                      <<SLOT GUIENVbasicEventWhen: doPart>>
                      #);
                    globalPosition: 
                      (* global coordinates of the mouse, when
                       * THIS(basicEvent) occurred
                       *)
                      (# p: @point;
                      <<SLOT GUIENVbasicEventGlobalPosition: doPart>>
                      exit p
                      #);
                    localPosition: 
                      (* local coordinates of the mouse, when
                       * THIS(basicEvent) occurred - relative to
                       * THIS(inteefaceObject)
                       *)
                      (# p: @point;
                      <<SLOT GUIENVbasicEventLocalPosition: doPart>>
                      exit p
                      #);
                    (* idx- *)
                 do inner;
                 #);
               mouseEvent: basicEvent
                 (* abstract superpattern for events related to the
                  * mouse
                  *)
                 (# <<SLOT mouseEventLib: attributes>>;
                    (* idx+ *)
                    doubleClick: booleanValue
                      (* true if THIS(mouseEvent) is a doubleclick.
                       * For a mouse click to qualify as doubleclick
                       * it must happen close in time and space, and
                       * with the same mouse button
                       *)
                      (# 
                      <<SLOT GUIENVmouseEventDoubleClick: doPart>>
                      #);
                    (* idx- *)
                 do inner;
                 #);
               keyEvent: basicEvent
                 (* abstract superpattern for events related to the
                  * keyboard.
                  *)
                 (# <<SLOT keyEventLib: attributes>>;
                    (* idx+ *)
                    ch:
                      (* the key on the keyboard, related to
                       * THIS(keyEvent)
                       *)
                      (# theChar: @char;
                      <<SLOT GUIENVkeyEventCh: doPart>>
                      exit theChar
                      #);
                    (* idx- *)
                do inner
                 #);
               mouseDown: mouseEvent
                 (* This event occurs when the user presses any mouse
                  * button down on THIS(interfaceObject)
                  *)
                 (# <<SLOT mouseDownLib: attributes>>;
                    (* idx+ *)
                    delay:
                      (* used to wait for period ticks to pass, while
                       * mouse.isStillDown is true, and then execute
                       * inner.  If mouseStillDown becomes false
                       * before period ticks, inner is not executed
                       *)
                      (# period: @integer
                      enter period
                      <<SLOT GUIENVmouseDownDelay: doPart>>
                      #)
                    (* idx- *)
                 do inner
                 #);
               onMouseDown:< mouseDown;
               mouseUp: mouseEvent 
                 (* This event occurs when the user releases any
                  * mouse button after having pressed it on
                  * THIS(interfaceObject)
                  *)
                 (# do inner #);
               onMouseUp:< mouseUp;
               keyDown: keyEvent
                 (* Occurs when the user presses a key, related to
                  * THIS(interfaceObject)
                  *)
                 (# do inner #);
               onKeyDown:< keyDown;
               refresh: basicEvent
                 (* This event tells THIS(interfaceobject), that it
                  * needs to redraw itself. UpdateRect is the 
                  * rectangle that needs to be updated expressed
                  * in the coordinate system of this(interfaceObject).
                  *)
                 (# updateRect:
                      (# value: ^rectangle;
                      <<SLOT GUIENVupdateRect: doPart>>
                      exit value[]
                      #)
                 do inner 
                 #);
               onRefresh:< refresh;
               activate: basicEvent
                 (* Send when THIS(interfaceObject) becomes active *)
                 (# do inner #);
               onActivate:< activate;
               deactivate: basicEvent
                 (* Send when THIS(interfaceObject) becomes inactive
                  *)
                 (# do inner #);
               onDeactivate:< deactivate;
            #);
          (* idx- *)
          action:
            (* Actions is a means of subscribing to events.  The
             * desired event is specified by further binding
             * eventType.  Actions can be prepended or appended to
             * THIS(interfaceobject).  When some event is called, the
             * prepended actions for the event is called *before* the
             * inner and the appended actions are called after.
             *)
            (# <<SLOT actionLib: attributes>>;
               eventType:< theEventhandler.event;
               theEvent: ^eventType;
            enter theEvent[]
            do inner;
            #);
          prependAction:
            (* Prepends the action, so it will be executed before the
             * event is subscribes to
             *)
            (# theAction: ^action;
            enter theAction[]
            <<SLOT GUIENVinterfaceObjectPrependAction: doPart>>
            #);
          appendAction:
            (* Appends the action, so it will be executed after the
             * event is subscribes to.
             *)
            (# theAction: ^action;
            enter theAction[]
            <<SLOT GUIENVinterfaceObjectAppendAction: doPart>>
            #);
          deleteAction:
            (* Remove the action *)
            (# theAction: ^action;
            enter theAction[]
            <<SLOT GUIENVinterfaceObjectDeleteAction: doPart>>
            #);
          open:< 
            (* must be called before any other operation on
             * THIS(interfaceObject).
             *)
            (# create:< (# <<SLOT GUIENVintefaceObjectCreate: doPart>> #);
            <<SLOT GUIENVinterfaceObjectOpen: doPart>>
            #);
          close:< 
            (* closes THIS(interfaceObject) and dispose all related
             *              structures
             *)
            (# <<SLOT GUIENVinterfaceObjectClose: doPart>> #);
          enableEventType:<
            (* makes THIS(interfaceObject) sensible to the specified
             * type of events
             *)
            (# ev: ##theEventhandler.event
            enter ev##
            <<SLOT GUIENVenableEventType: doPart>>
            #);
          disableEventType:<
            (* makes THIS(interfaceObject) insensible to the
             * specified type of events
             *)
            (# ev: ##theEventhandler.event
            enter ev##
            <<SLOT GUIENVdisableEventType: doPart>>
            #);
          interfaceObjectException: exception
            (* abstract superpattern for exceptiosn related to
             * THIS(interfaceObject).
             *)
            (# 
            <<SLOT GUIENVinterfaceObjectException: doPart>> 
            #);
          notOpenedException: interfaceObjectException
            (# location: ^text
            enter location[]
            <<SLOT GUIENVnotOpenedException: doPart>>
            #);
          notOpenedError:< 
            (* this exception is raised if any operation is performed
             * on THIS(interfaceObject) is called before open is
             * called.  This will also happen if "close" is called
             * twice
             *)
            notOpenedException;
          private: @<<SLOT GUIENVinterfaceObjectPrivate: descriptor>>;
       do inner
       #) (* interfaceObject *);
     menubar: interfaceObject
       (* menubar is a bar containing the titles of the contained
        * menus. A menu is pulled down by clicking at the title,
        * allowing the user to select a menuitem in the menu.  A
        * menubar is only visible if it is installed - either as the
        * global menubar or as the menubar in some window.
        *)
       (# <<SLOT menubarLib: attributes>>;
          append: 
            (* inserts a menu after all menues in the menubar.  If
             * the menu is already in the menu bar, nothing happens
             *)
            (# theMenu: ^menu;
            enter theMenu[]
            <<SLOT GUIENVmenubarAppend: doPart>>
            #);
          delete: 
            (* deletes a menu from the menu bar. The menu titles
             * following the deleted menu will move over to fill the
             * vacancy
             *)
            (# theMenu: ^menu
            enter theMenu[]
            <<SLOT GUIENVmenubarDelete: doPart>>
            #);
          clear: 
            (* removes all menues from the menu bar when you want to
             * start with new menues
             *)
            (# <<SLOT GUIENVmenubarClear: doPart>> #);
          appendMenubar: 
            (* inserts all menues in another menubar after all menues
             * in THIS(menubar).  This is the same as calling
             * insertMenubar with NONE as afterMenu.
             *)
            (# theMenubar: ^menubartype;
            enter theMenubar[]
            <<SLOT GUIENVmenubarAppendMenubar: doPart>>
            #);
          replaceMenubar: 
            (* replace all menues in theMenubar with all menues in
             * replacementMenubar in THIS(menubar).
             *)
            (# theMenubar, replacementMenubar: ^menubartype
            enter (theMenubar[], replacementMenubar[])
            <<SLOT GUIENVmenubarReplaceMenubar: doPart>>
            #);
          deleteMenubar: 
            (* deletes all menues in theMenubar from
             * THIS(menubar). The menu titles following the menues in
             * the deleted menubar will move over to fill the vacancy
             *)
            (# theMenubar: ^menubartype
            enter theMenubar[]
            <<SLOT GUIENVmenubarDeleteMenubar: doPart>>
            #);
          scan: 
            (* iterates over all menues currently inserted in the
             * menubar
             *)
            (# current: ^menu;
            <<SLOT GUIENVmenubarScan: doPart>> #);
          open::<
            (# create::< (# <<SLOT GUIENVmenubarCreate: doPart>> #);
            <<SLOT GUIENVmenubarOpen: doPart>>
            #);
          close::<
            (# 
            <<SLOT GUIENVmenubarClose: doPart>>
            #);
          private: @<<SLOT GUIENVmenubarPrivate: descriptor>>; 
       #) (* menubar *);
     menu: interfaceObject
       (* menu contains a group of menuitems and is usefull for
        * letting the user perform commands or set settings in the
        * application. A menu can be installed in a menubar, as a
        * submenu to some menuitem or simply be popped up on the
        * screen.
        *)
       (# <<SLOT menuLib: attributes>>;
          (* idx+ *)
          name:
            (* the name of the menu as shown in the menubar.  if the
             * menu is not in a menubar, the name is not visible
             *)
            (# theName: ^text
            enter (# enter theName[] <<SLOT GUIENVmenuSetName: doPart>> #)
            exit (# <<SLOT GUIENVmenuGetName: doPart>> exit theName[] #)
            #);
          (* idx+ *)
          eventhandler::<
            (# select: event
                 (* executed when the user selects THIS(menu) (or
                  * pops it up) just before the menu is shown.
                  *)
                 (# 
                 do inner
                 #);
               onSelect:< select;
            #);
          (* idx- *)
          menuitem: interfaceObject
            (* menuitem is used for letting the user perform commands
             * in the application or display the state of some option,
             * by checking and unchecking the menuitem. It can also
             * serve as the title of a submenu.
             *)
            (# <<SLOT menuitemLib: attributes>>;
               key: 
                 (* the key shortcut of THIS(menuitem), allows the
                  * user to select THIS(menuitem) without using the
                  * mouse.
                  *)
                 (# c: @char
                 enter (# enter c <<SLOT GUIENVmenuitemSetKey: doPart>> #)
                 exit (# <<SLOT GUIENVmenuitemGetKey: doPart>> exit c #)
                 #);
               name: 
                 (* models the name of THIS(menuitem).  Evaluate the
                  * enter-part to set the name.  Evaluate the
                  * exit-part to get the name
                  *)
                 (# t: ^text;
                 enter (# enter t[] <<SLOT GUIENVmenuitemSetName: doPart>> #)
                 exit (# <<SLOT GUIENVmenuitemGetName: doPart>> exit t[] #)
                 #);
               checked:
                 (* when THIS(menuitem) is checked, a check mark is
                  * displayed at the left side the menuitem
                  *)
                 (# checked: @boolean
                 enter (# enter checked <<SLOT GUIENVmenuitemSetChecked: doPart>> #)
                 exit (# <<SLOT GUIENVmenuitemGetChecked: doPart>> exit checked #)
                 #);
               subMenu:
                 (* if a submenu is attached to THIS(menuitem), that
                  * menu is pulled down by selecting
                  * THIS(menuitem). In that case onSelect is never
                  * issued for THIS(menuitem)
                  *)
                 (# theMenu: ^menu;
                 enter (# enter theMenu[] <<SLOT GUIENVsetSubMenu: doPart>> #)
                 exit (# <<SLOT GUIENVgetSubMenu: doPart>> exit theMenu[] #)
                 #);
               position: IntegerValue
                 (* the position of THIS(menuitem) in its menu,
                  * separator items are counted as well
                  *)
                 (# 
                 <<SLOT GUIENVmenuitemPosition: doPart>>
                 #);
               (* idx+ *)
               eventhandler::<
                 (# onStatus:< booleanValue
                      (* executed just before THIS(menuitem) is
                       * shown.  should return true if THIS(menuitem)
                       * is enabled.  Default is true
                       *)
                      (# <<SLOT GUIENVmenuitemOnStatus: doPart>> #);
                    select: event
                      (* executed when THIS(menuitem) is selected in
                       * the menu.  If a submenu is attached, it will
                       * not be executed - instead the submenu is
                       * pulled down
                       *)
                      (# do inner #);
                    onSelect:< select;
                 #);
               (* idx- *)
               open::<
                 (# create::< (# <<SLOT GUIENVmenuitemCreate: doPart>> #);
                 <<SLOT GUIENVmenuitemOpen: doPart>>
                 #);
               private: @<<SLOT GUIENVmenuitemPrivate: descriptor>>;
            do inner
            #) (* menuitem *);
          dynamicMenuitem: menuitem
            (* dynamic menuitem does not call its own onStatus and
             * onSelect events, instead these events are called on the
             * attached action, if any is attached
             *)
            (# <<SLOT dynamicItemLib: attributes>>;
               theAction: ^menuAction;
               attach: 
                 (* anAction is attached to THIS(menuitem) *)
                 (# anAction: ^menuAction;
                 enter anAction[]
                 <<SLOT GUIENVmenuitemAttach: doPart>>
                 #);
               detach:
                 (* the menuitemHandler that is currently attached to
                  * THIS(menuitem) is detached, meaning that no action
                  * is attached
                  *)
                 (# <<SLOT GUIENVmenuitemDetach: doPart>> #);
               (* idx+ *)
               eventhandler::<
                 (# onStatus::< (# <<SLOT GUIENVdynamicMenuitemOnStatus: doPart>> #);
                    onSelect::< (# <<SLOT GUIENVdynamicMenuitemOnSelect: doPart>> #);
                 #);
               (* idx- *)
            #) (* dynamicMenuitem *);
          menuAction:
            (* a menuAction can dynamicly be attached to
             * dynamicMenuitems within THIS(menu), meaning that the
             * onStatus and onSelect events of THIS(menuAction) will
             * be executed instead of these events of the
             * dynamicMenuitem. The pointer "theMenuitem" refers to
             * the dynamicMenuitem THIS(menuAction) is currently
             * attached to
             *)
            (# theMenuitem:
                 (* the menuitem THIS(menuAction) is attached to *)
                 ^dynamicMenuitem;
               onStatus:< booleanValue
                 (* this status is evaluated instead of the status of
                  * the actual menuitem (theMenuitem) THIS(menuAction)
                  * is attached to.  Default returns true
                  *)
                 (# <<SLOT GUIENVactionOnStatus: doPart>> #);
               onSelect:< 
                 (* onSelect is executed from the hit of the actual
                  * dynamicMenuitem THIS(action) is attached to
                  *)
                 object;
            #) (* action *);
          (* idx- *)
          separator: menuitem
            (* defines a menu separator, which is a unselectable line
             * in the menu, dividing groups of menuitems.
             *)
            (# open::<
                 (# create::< (# <<SLOT GUIENVseparatorCreate: doPart>> #);
                 <<SLOT GUIENVseparatorOpen: doPart>>
                 #);
               close::< (# <<SLOT GUIENVseparatorClose: doPart>> #);
            #);
          append:
            (* appends the menuitem to THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            <<SLOT GUIENVmenuAppend: doPart>>
            #);
          delete: 
            (* deletes the menuitem from THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            <<SLOT GUIENVmenuDelete: doPart>>
            #);
          scan: 
            (* iterates over all menuitems in THIS(menu) *)
            (# current: ^menuitem
            <<SLOT GUIENVmenuScan: doPart>>
            #);
          clear:
            (* deletes all menuitems in  THIS(menu) *)
            (#
            <<SLOT GUIENVmenuClear: doPart>>
            #);
          noOfMenuitems: integerValue
            (* returns the number of menuitems in THIS(menu) *)
            (# <<SLOT GUIENVmenuNoOfMenuitems: doPart>> #);
          popUp: 
            (* THIS(menu) is popped up as follows: The menuitem
             * indexed by "popupWith" is selected (not checked but
             * hilited) and popupAt is the top left corner of that
             * menuitem in the coordinate system of the popupIn
             * window.
             *)
            (# popupWith: @integer;
               popupAt: @point;
               popupIn: ^window.windowitem;
            enter (popupWith,popupAt,popupIn[])
            <<SLOT GUIENVmenuPopUp: doPart>>
            #);
          getMenuitemByNumber: 
            (* returns a reference to the menuitem at the specified
             * position in the menu
             *)
            (# number: @integer;
               theMenuitem: ^menuitem;
            enter number
            <<SLOT GUIENVmenuGetMenuitemByNumber: doPart>>
            exit theMenuitem[]
            #);
          enable: (* enable THIS(menu) *)
            (# <<SLOT GUIENVmenuEnable: doPart>> #);
          disable: (* disable THIS(menu) *)
            (# <<SLOT GUIENVmenuDisable: doPart>> #);
          enabled:< booleanValue
            (* should return true if THIS(menu) is enabled *)
            (# <<SLOT GUIENVmenuEnabled: doPart>> #);
          open::< 
            (* the menu is not automatically inserted in the
             * menubar. You have to do this yourself
             *)
            (# create::< (# <<SLOT GUIENVmenuCreate: doPart>> #);
            <<SLOT GUIENVmenuOpen: doPart>> 
            #);
          close::< (# <<SLOT GUIENVmenuClose: doPart>> #);
          private: @<<SLOT GUIENVmenuPrivate: descriptor>>;
       #) (* menu *);
     standardMenubar: menubar
       (* idx+ *)
       (# standardFileMenu: menu
            (# newMenuitem: @dynamicMenuitem;
               openMenuitem: @dynamicMenuitem;
               closeMenuitem: @dynamicMenuitem;
               saveMenuitem: @dynamicMenuitem;
               saveAsMenuitem: @dynamicMenuitem;
               revertMenuitem: @dynamicMenuitem;
               printMenuitem: @dynamicMenuitem;
               pageSetUpMenuitem: @dynamicMenuitem;
               quitMenuitem: @dynamicMenuitem;
               open::< (# <<SLOT GUIENVstandardFileMenuOpen: doPart>> #);    
            #) (* standardFileMenu *);
          fileMenu:< menu;
          theFileMenu: ^fileMenu;
          standardEditMenu: menu
            (# undoMenuitem: @dynamicMenuitem;
               cutMenuitem: @dynamicMenuitem;
               copyMenuitem: @dynamicMenuitem;
               pasteMenuitem: @dynamicMenuitem;
               clearMenuitem: @dynamicMenuitem;
               open::< (# <<SLOT GUIENVstandardEditMenuOpen: doPart>> #)
            #) (* standardEditMenu *);
          editMenu:< menu;
          theEditMenu: ^editMenu;
          open::<
            (# 
            <<SLOT GUIENVstandardMenubarOpen: doPart>>
            #);
       #);
     (* idx- *)
     window: interfaceObject
       (* user interaction with the window such as dragging and
        * resizing is taken care of by the window manager.  Anything
        * visible you may want to place in the window is subpatterns
        * of the abstract pattern windowitem, which is a subpattern of
        * interfaceObject. The window can be used as a modal dialog by
        * means of the pattern "showModal"
        *)
       (# <<SLOT windowLib: attributes>>;
       (* idx+ *)
          eventhandler::<
            (# aboutToClose: event
                 (* is called whenever the user has performed an
                  * action that causes THIS(window) to close.  Further
                  * bind this to perform actions before the window is
                  * actually closed.  You can prevent the window from
                  * closing by assigning false to the boolean
                  * 'okToClose'
                  *)
                 (# okToClose: @boolean
                 do true -> okToClose;
                    inner
                 exit okToClose
                 #);
               onAboutToClose:<  aboutToClose;
               onActivate::<
                 (* is send to contents, which takes care of sending
                  * the event to all children
                  *)
                 (# <<SLOT GUIENVwindowOnActivate: doPart>> #);
               onDeactivate::<
                 (* is send to contents, which takes care of sending
                  * the event to all children
                  *)
                 (# <<SLOT GUIENVwindowOnDeactivate: doPart>> #);
            #);
          (* idx- *)
          theMenubar:
            (* is used to install a menubar for THIS(window), and to
             * gain access to the menubar of THIS(window)
             *)
            (# theBar: ^menubartype
            enter (# enter theBar[] <<SLOT GUIENVwindowSetTheMenubar: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetTheMenubar: doPart>> exit theBar[] #)
            #);
          menubarType:<
            (* if further bound, an instance of menubarType is
             * automatically installed for THIS(window)
             *)
            menubar;
          menubarVisible:< 
            (* Specifies if the menubar should be visible. *)
            trueObject;
          type:<
            (* The type can be one of the following:
             *   windowTypes.normal  <- default
             *   windowTypes.dialog
             *   windowTypes.palette
             *)
            integerValue;
	  resizeable:< booleanValue
	     (# do true -> value; INNER #);
          title: 
            (* the title of the window is displayed in the windows
             * title-bar if the window has one.
             *)
            (# theTitle: ^text
            enter (# enter theTitle[] <<SLOT GUIENVwindowSetTitle: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetTitle: doPart>> exit theTitle[] #)
            #);
          position: 
            (* the window's position is the coordinates of the
             * topLeft corner of the window's inside rectangle on the
             * screen
             *)
            (# pt: @point;
            enter (# enter pt <<SLOT GUIENVwindowSetPosition: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetPosition: doPart>> exit pt #)
            #);
          size: 
            (* the size is the size of the inside rectangle of the
             * window
             *)
            (# width, height: @integer;
            enter (# enter (width, height) <<SLOT GUIENVwindowSetSize: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetSize: doPart>>  exit (width, height) #)
            #);
          frame:
            (* the frame is defined as the rectangle THIS(window)
             * occupies on the screen = (position,position + size)
             *)
            (# theFrame: @rectangle;
            enter (# enter theFrame <<SLOT GUIENVwindowSetFrame: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetFrame: doPart>> exit theFrame #)
            #);
          insideRectangle: 
            (* the inside rectangle is the window's content rectangle
             * in terms of local coordinates in the window.  The top
             * left corner is (0, 0) and the bottom right corner is
             * the window's size
             *)
            (# theRectangle: @rectangle;
            <<SLOT GUIENVwindowInsideRectangle: doPart>>
            exit theRectangle
            #);
          show: 
            (* shows THIS(window) in front of other windows *)
            (# <<SLOT GUIENVshowWindow: doPart>> #);
          showModal:
            (* shows THIS(window) in a modal way. Interaction with
             * other windows is prevented until THIS(window) is either
             * closed or hidden, and then showModal returns to the
             * caller
             *)
            (# <<SLOT GUIENVwindowShowModal: doPart>> #);
          hide: 
            (* hides THIS(window), i.e. make it invisible without
             * destroying it. Can be made visible again using show
             *)
            (# <<SLOT GUIENVhideWindow: doPart>> #);
	  visible:
	     (* The visibility of the window. *)
	     (# value: @boolean;
	     enter (# enter value <<SLOT windowEnterVisible: doPart>> #)
	     exit (# <<SLOT windowExitVisible: doPart>> exit value #)
	     #);
          maxSize: 
            (* use this to set the maximum size THIS(window) is
             * allowed to get, when resized by the user. maxSize
             * doesn't affect the behaviour of setSize.
             *)
            (# width, height: @integer;
            enter (# enter (width, height) <<SLOT GUIENVwindowSetMaxSize: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetMaxSize: doPart>> exit (width, height) #)
            #);
          minSize: 
            (* use this to set the minimum size THIS(window) is
             * allowed to get, when resized by the user. minSize
             * doesn't affect the behaviour of setSize
             *)
            (#  width, height: @integer;
            enter (# enter (width, height) <<SLOT GUIENVwindowSetMinSize: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetMinSize: doPart>>  exit (width, height) #)
            #);
          bringToFront: 
            (* THIS(window) is brought to the front of all other
             * windows
             *)
            (# <<SLOT GUIENVwindowBringToFront: doPart>> #);
          bringBack: 
            (* THIS(window) is placed behind all other windows *)
            (# <<SLOT GUIENVwindowBringToBack: doPart>> #);
          bringBehind: 
            (* THIS(window) is placed behind the window referred to
             * by "theWindow"
             *)
            (# theWindow: ^window;
            enter theWindow[]
            <<SLOT GUIENVwindowBringBehind: doPart>>
            #);
          update: 
            (* Updates the window by posting a refresh event.  If
             * emmediate is true, the refresh event will be processed
             * immediately.
             *)
            (# immediate: @boolean;
            enter immediate
            <<SLOT GUIENVwindowUpdate: doPart>>
            #);
          contents:
            (* The contents of THIS(window) is the father of all
             * other windowitems in THIS(window).
             *)
            (# theContents: ^canvas;
            <<SLOT GUIENVwindowGetContents: doPart>>
            exit theContents[]
            #);
          target: 
            (* the window's target is a reference to the windowitem
             * that receives keyDown. You are responsible for making
             * sure the window's target is the windowitem that is
             * affected by menu commands. The eventhandler of
             * windowitem has two events: "enableTarget" and
             * "disableTarget". When a windowitem is becomming the new
             * target, first "disableTarget" is called for the old
             * target then "enableTarget" is called for the new target
             *)
            (# theTarget: ^windowitem;
            enter (# enter theTarget[] <<SLOT GUIENVwindowSetTarget: doPart>> #)
            exit (# <<SLOT GUIENVwindowGetTarget: doPart>>  exit theTarget[] #)
            #);
          (* idx+ *)
          windowitem: interfaceObject
            (* superclass for all interfaceobjects in this window.  A
             * windowitem is always part of a canvas (father)
             *)
            (# <<SLOT windowitemLib: attributes>>;
               (* idx+ *)
               eventhandler::<
                 (# visibleChanged: event
                      (* is called, when THIS(windowitem) is hidden
                       * or shown
                       *)
                      (# do inner #);
                    onVisibleChanged:< visibleChanged;
                    frameChanged: event
                      (* is called whenever the frame of
                       * THIS(windowitem) is changed
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame)
                      do inner 
                      #);
                    onFrameChanged:< frameChanged;
                    fatherFrameChanged: event
                      (* is called when the frame of the father of
                       * THIS(windowitem) is changed
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame)
                      do inner 
                      #);
                    onFatherFrameChanged:< fatherFrameChanged;
                    enabledChanged: event
                      (* is called, when THIS(windowitem) is
                       * enabled/disabled
                       *)
                      (# do inner #);
                    onEnabledChanged:< enabledChanged;
                    enableTarget: event
                      (* is called when THIS(windowitem) is becomming
                       * target in the window
                       *)
                      (# do inner #);
                    onEnableTarget:< enableTarget;
                    disableTarget: event
                      (* is called when THIS(windowitem) was target
                       * and another windowitem is becomming target
                       *)
                      (# do inner #);
                    onDisableTarget:< disableTarget;
		    borderVisibleChanged: event
		      (* is called, when the border of 
                       * THIS(windowitem) is shown or hidden
                       *)
		      (# do inner #);
		    onBorderVisibleChanged:< borderVisibleChanged;
		    borderStyleChanged: event
		      (* is called, when the border style of
                       * THIS(windowitem) is changed
                       *)
		      (# do inner #);
		    onBorderStyleChanged:< borderStyleChanged;
                    theCursorChanged: event
                      (* is called, when THIS(windowitem) is assigned
                       * a new cursor
                       *)
                      (# do inner #);
                    onTheCursorChanged:< theCursorChanged;
                    hiliteChanged: event
                      (* Is called when THIS(windowitem) is hilited
                       * or dehilited
                       *)
                      (# do inner; #);
                    onHiliteChanged:< hiliteChanged;
                    onRefresh::< (# <<SLOT GUIENVwindowitemOnRefresh: doPart>> #);
                 #);
               (* idx- *)
               father: ^
                 (* father is the canvas that THIS(windowitem) is a
                  * child of
                  *)
                 canvas;
               frame: 
                 (* the frame is defined as the rectangle
                  * THIS(windowitem) occupies in the coordinate system
                  * of the father. When the frame is changed
                  * THIS(windowitem) is updated and the father is
                  * informed about the change.  If you need other
                  * actions to take place, when changing the frame,
                  * you must further bind the event onFrameChanged
                  *)
                 (# theFrame: @rectangle;
                 enter (# enter theFrame <<SLOT GUIENVwindowitemSetFrame: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetFrame: doPart>> exit theFrame #)
                 #);
               position: 
                 (* the position of THIS(windowitem) is defined as
                  * the topLeft corner of the bounding frame. When the
                  * position is changed, the frame is changed, so the
                  * onFrameChanged event is called
                  *)
                 (# pt: @point;
                 enter (# enter pt <<SLOT GUIENVwindowitemSetPosition: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetPosition: doPart>> exit pt #)
                 #);
               move: 
                 (* moves THIS(windowitem) relative (dh, dv), by
                  * setting the position, meaning that the
                  * onFrameChanged event is called
                  *)
                 (# dh, dv: @integer;
                 enter (dh, dv)
                 <<SLOT GUIENVwindowitemMove: doPart>>
                 #);
               size: 
                 (* the size of THIS(windowitem) is defined as the
                  * height and width of the bounding frame. When the
                  * size is changed, the frame is changed, so the
                  * onFrameChanged event is called
                  *)
                 (# width, height: @integer;
                 enter (# enter (width, height) <<SLOT GUIENVwindowitemSetSize: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetSize: doPart>> exit (width, height) #)
                 #);
	       fitToContents:<
	          (* Adjusts the size of THIS(windowItem) to fit the content *)
	          (# doneInInner: @boolean;
		  <<SLOT guienvFitToContents: doPart>>
		  #);
               bindLeft, bindRight, bindBottom, bindTop: @
                 (* these attributes specify how THIS(windowitem)
                  * shall behave when the father changes it's
                  * frame. If e.g. "bindLeft" is true, the leftSide
                  * will have the same constant distance to the
                  * leftSide of the father, when the father is resized
                  *)
                 boolean;
               visible:
                 (* an invisible windowitem will be ingored w.r.t.
                  * user interaction (it is not visible on the screen)
                  *)
                 (# value: @boolean;
                 enter (# enter value <<SLOT GUIENVwindowitemSetVisible: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetVisible: doPart>> exit value #)
                 #);
               hilite:
                 (# value: @boolean;
                 enter (# enter value <<SLOT GUIENVwindowitemSetHilite: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetHilite: doPart>> exit value #)
                 #);
               show: 
                 (* makes THIS(windowitem) visible *)
                 (# <<SLOT GUIENVwindowitemShow: doPart>> #);
               hide: 
                 (* makes THIS(windowitem) invisible *)
                 (# <<SLOT GUIENVwindowitemHide: doPart>> #);
               enabled:
                 (* if THIS(windowitem) is enabled it receives mouse
                  * events or key events
                  *)
                 (# value: @boolean
                 enter (# enter value <<SLOT GUIENVwindowitemSetEnabled: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetEnabled: doPart>> exit value #)
                 #);
               enable:
                 (* enables THIS(windowitem) so it can receive mouse
                  * or key events
                  *)
                 (# <<SLOT GUIENVwindowitemEnable: doPart>> #);
               disable:
                 (* disables THIS(windowitem) so it does not receive
                  * any mouse or key events
                  *)
                 (# <<SLOT GUIENVwindowitemDisable: doPart>> #);
               backgroundColor:
                 (# theColor: @color;
                 enter (# enter theColor <<SLOT windowItemEnterBackgroundColor: doPart>> #)
                 exit (# <<SLOT windowItemExitBackgroundColor: doPart>> exit theColor #)
                 #);
               border: @
	         (* the border around THIS(windowitem) makes it 
                  * apparent, where it is located on the screen.
                  *)
                 (* idx+ *)
                 (# visible:
		      (* if the border is visible, the insideRect of
                       * THIS(windowitem) is inset depending on the
                       * style of the border.
                       *) 
		      (# value: @boolean;
		      enter (# enter value <<SLOT GUIENVwindowitemBorderSetVisible: doPart>> #)
		      exit (# <<SLOT GUIENVwindowitemBorderGetVisible: doPart>> exit value #)
		      #);
		    style:
		      (* the border style can be one of the
                       * following:
		       *   borderStyles.simple: 
		       *      A simple one pixel wide border.
		       *   borderStyles.shadowIn:
		       *      Draws the border so THIS(windowitem)
                       *      appears inset.
		       *   borderStyles.shadowOut:
		       *      Draws the border so THIS(windowitem)
                       *      appears outset.
                       *   borderStyles.etchedIn:
                       *      Draws the border using a double line
                       *      giving the effect of a line etched
                       *      into the window.
                       *   borderStyles.etchedOut:
                       *      Draws the border using a double line
                       *      giving the effect of a line comming
                       *      out of the window.
		       *)
		      (# value: @integer;
		      enter (# enter value <<SLOT GUIENVwindowitemBorderSetStyle: doPart>> #)
		      exit (# <<SLOT GUIENVwindowitemBorderGetStyle: doPart>> exit value #)
		      #);
		 #);
               (* idx- *)
               insideRectangle:
                 (* insideRectangle is the area inside the border of
                  * THIS(windowitem).
                  *)
                 (# theRectangle: @rectangle;
                 <<SLOT GUIENVwindowiteminsideRectangle: doPart>>
                 exit theRectangle
                 #);
               theCursor:
                 (* theCursor is used to install a cursor for
                  * THIS(windowitem), and to gain access to the cursor
                  * of THIS(windowitem)
                  *)
                 (# theCur: ^cursor;
                 enter (# enter theCur[] <<SLOT GUIENVwindowitemSetTheCursor: doPart>> #)
                 exit (# <<SLOT GUIENVwindowitemGetTheCursor: doPart>> exit theCur[] #)
                 #);
               cursorType:<
                 (* if further bound, an instance of cursorType is
                  * automatically installed for THIS(windowitem)
                  *)
                 cursor;
               (* idx+ *)
               trackMouse: 
                 (* this is a control pattern usually evaluated from
                  * a mouseDown eventhandler. Initially 'mousePress'
                  * is evaluated, then 'mouseMove' is evaluated
                  * whenever the mouse moves as long as the mouse is
                  * stillDown - (h, v) will be the horizontal and
                  * vertical distance the mouse has moved since the
                  * last call to 'mouseMove'.  When the user releases
                  * the mouse, 'mouseRelease' is evaluated.  If the
                  * mouse isn't stillDown (see stillDown) when track
                  * is called nothing will happen.  All the
                  * coordinates are local to THIS(WindowItem).
                  *)
                 (# mousePress:< object;
                    mouseMove:< 
                      (# h, v: @integer;
                      enter (h, v)
                      do inner
                      #);
                    mouseRelease:< object;
                    curPt, prevPt: @point;
                 <<SLOT GUIENVwindowItemTrackMouse: doPart>>
                 #);
               (* idx- *)
               drag: 
                 (* lets the user drag a gray outline of this
                  * windowitem
                  *)
                 (# <<SLOT GUIENVwindowitemDrag: doPart>> #);
               resize: 
                 (* lets the user resize this windowitem by dragging
                  * a gray outline
                  *)
                 (# <<SLOT GUIENVwindowitemResize: doPart>> #);
               update: 
                 (* THIS(windowitem) is updated, by posting an
                  * refresh event to the window. If "immediate" is
                  * true the update is performed immediately,
                  * otherwise the update is performed, when there is
                  * no other event waiting (this is normally what you
                  * want)
                  *)
                 (# immediate: @boolean;
                 enter immediate
                 <<SLOT GUIENVwindowitemUpdate: doPart>>
                 #);
               open::< 
                 (* initially a windowitem is visible and active *)
                 (# create::< (# <<SLOT GUIENVwindowitemCreate: doPart>> #);
                 enter father[]
                 <<SLOT GUIENVwindowitemOpen: doPart>>
                 #);
               close::< 
                 (* no actions are performed at this level *)
                 (# <<SLOT GUIENVwindowitemClose: doPart>> #);
               private: @<<SLOT GUIENVwindowitemPrivate: descriptor>>;
            #); (* windowitem *)
          separator: windowitem
            (* a separator is a horzontal or vertical separating line
             *)
            (# <<SLOT separatorLib: attributes>>;
               (* idx+ *)
	       eventhandler::<
	         (# styleChanged: event
	              (* Called when the style is changed *)
		      (# do inner #);
	            onStyleChanged:< styleChanged;
                    onRefresh::< (# <<SLOT GUIENVwindowSeparatorOnRefresh: doPart>> #);
		 #);
                 (* idx- *)
	       vertical:< 
                 (* Further bind to specify the orientation of
                  * THIS(separator) default is horizontal
                  *)
                 booleanObject;
               style:
		 (* the  style can be one of the following:
		  *   lineStyles.singleLine: 
		  *     A single line is drawn.
		  *   lineStyles.doubleLine:
		  *     A double line is drawn.
		  *   lineStyles.dashedSingleLine:
		  *     A dashed single line is drawn.
 	          *   lineStyles.dashedDoubleLine:
		  *     A dashed double line is drawn.
		  *   lineStyles.etchedIn:
		  *     A double line is drawn giving the effect of
                  *     a line etched into the window.
		  *   lineStyles.etchedOut:
		  *     A double line is drawn giving the effect of
                  *     a line comming of of the window.
		  *)
		 (# value: @integer;
		 enter (# enter value <<SLOT GUIENVseparatorSetStyle: doPart>> #)
		 exit (# <<SLOT GUIENVseparatorGetStyle: doPart>> exit value #)
		 #);
               open::<
	         (# create::< (# <<SLOT GUIENVwindowseparatorCreate: doPart>> #);
		 <<SLOT GUIENVwindowseparatorOpen: doPart>>
		 #);
	       close::<
	         (# <<SLOT GUIENVwindowseparatorClose: doPart>> #);
	       private: @<<SLOT GUIENVwindowseparatorPrivate: descriptor>>;
            #);
          canvas: windowitem
            (* A canvas is a sub-window in the window.  Only the
             * windowitems located inside the frame of THIS(canvas)
             * will be visible
             *)
            (# <<SLOT canvasLib: attributes>>;
               (* idx+ *)
               eventhandler::<
                 (# childFrameChanged: event
                      (* is called when a child of THIS(canvas) has
                       * changed frame
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame) 
                      do inner 
                      #);
                    onChildFrameChanged:< childFrameChanged;
                    onActivate::< (# <<SLOT GUIENVcanvasOnActivate: doPart>> #);
                    onDeactivate::< (# <<SLOT GUIENVcanvasOnDeactivate: doPart>> #);
                    onMouseDown::< (# <<SLOT GUIENVcanvasOnMouseDown: doPart>> #);
                    onRefresh::< (# <<SLOT GUIENVcanvasOnRefresh: doPart>> #);
                    onMouseUp::< (# <<SLOT GUIENVcanvasOnMouseUp: doPart>> #);
                    onFrameChanged::< (# <<SLOT GUIENVcanvasOnFrameChanged: doPart>> #);
                    onVisibleChanged::< (# <<SLOT GUIENVcanvasOnVisibleChanged: doPart>> #);
                 #);
                 (* idx- *)
               selection: @
                 (* idx+ *)
                 (# add:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      <<SLOT GUIENVcanvasSelectionAdd: doPart>>
                      #);
                    set:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      <<SLOT GUIENVcanvasSelectionSet: doPart>>
                      #);
                    remove:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      <<SLOT GUIENVcanvasSelectionRemove: doPart>>
                      #);
                    empty: booleanValue
                      (# 
                      <<SLOT GUIENVcanvasSelectionEmpty: doPart>>
                      #);
                    scan:
                      (# current: ^windowitem;
                      <<SLOT GUIENVcanvasSelectionScan: doPart>>
                      #);
                    clear:
                      (# 
                      <<SLOT GUIENVcanvasSelectionClear: doPart>>
                      #);
                 #);
                 (* idx- *)
               scan:
                 (* Scan operation on the children of THIS(canvas) *)
                 (# current: ^windowitem;
                 <<SLOT GUIENVcanvasScan: doPart>>
                 #);
               open::< 
                 (* The canvas is opened and displayed. *)
                 (# create::< (# <<SLOT GUIENVcanvasCreate: doPart>> #);
                 <<SLOT GUIENVcanvasOpen: doPart>> 
                 #);
               close::< 
                 (* close is called for all the children of
                  * THIS(canvas)
                  *)
                 (# <<SLOT GUIENVcanvasClose: doPart>> #);
               private: @<<SLOT GUIENVcanvasPrivate: descriptor>>;
            #) (* canvas *);
          localToGlobal:
            (* Translate the point from global coordinates to window
             * coordinates.
             *)
            (# local, global: @point;
            enter local
            <<SLOT GUIENVwindowLocalCoordsToGlobal: doPart>>
            exit global
            #);
          globalToLocal:
            (* Translates the point to window coordinates to global
             * local coordinates
             *)
            (# global, local: @point;
            enter global
            <<SLOT GUIENVwindowGlobalToLocal: doPart>>
            exit local
            #);
            (* idx- *)
          open::< 
            (# create::< (# <<SLOT GUIENVwindowCreate: doPart>> #);
            <<SLOT GUIENVwindowOpen: doPart>> 
            #);
          close::< 
            (* the windows close operation is normally automatically
             * called from the content's aboutToGoAway event.  You can
             * also call it directly. theContents.close is called to
             * close all of the windows internal structures
             *)
            (# <<SLOT GUIENVwindowClose: doPart>> #);
          <<SLOT BifrostAttributes: attributes>>;
          private: @<<SLOT GUIENVwindowPrivate: descriptor>>;
       #) (* window *);
     cursor: 
       (* A cursor is the raster attached to the mouse pointer *)
       (# <<SLOT cursorLib: attributes>>;
          private: @<<SLOT GUIENVcursorPrivate: descriptor>> 
       #);  
     pixmap:
       (* Pixmap pattern *)
       (# <<SLOT pixmapLib: attributes>>;
          read:
            (* Reads the specified file into THIS(pixmap). The type of the
             * file are guessed by looking at the extension, the first
             * few bytes or the finder info (On the macintos platform).
             *)
            (# name: ^text;
               error:< exception
                 (# what: ^text;
                 enter what[]
                 do what[] -> msg.append;
				 	INNER;
                 #);
             enter name[]
             <<SLOT pixMapRead: doPart>>
             #);
           init:<
             (* Intializes the raster to have the specified width and
              * height. Allocates any data needed - you have to call dispose
              * to free that data.
              *)
             (# width, height: @integer;
       	     enter (width, height)
             <<SLOT pixmapInit: doPart>>
             #);
	   dispose:<
             (* call this to dispose the memory occupied by THIS(raster)
       	      * when completely done with THIS(raster)
       	      *)
             (#
             <<SLOT pixmapDispose: doPart>>
             #);
	   width: integerValue
             (* returns the width set by init or by read operations *)
             (# <<SLOT pixmapWidth: doPart>> #);
           height: integerValue
             (* returns the height set by init or by read operations *)
             (# <<SLOT pixmapHeight: doPart>> #);
	   private: @<<SLOT pixmapPrivate: descriptor>>;
	#);
     textStyle: 
       (* textStyle is font, size and face. You can use this pattern
        * to communicate stylic changes to layout-text and
        * document-text - or to get information about the dimension of
        * text drawn in a specific textStyle
        *)
       (# <<SLOT textStyleLib: attributes>>;
          name:
            (* models the name of the font of THIS(textStyle). *)
            (# theName: ^text;
            enter (# enter theName[] <<SLOT GUIENVtextStyleSetName: doPart>> #)
            exit (#  <<SLOT GUIENVtextStyleGetName: doPart>> exit theName[] #)
            #);
          size:
            (# value: @integer;
            enter (# enter value <<SLOT GUIENVtextStyleSetSize: doPart>> #)
            exit (# <<SLOT GUIENVtextStyleGetSize: doPart>> exit value #)
            #);
          face:
            (# value: @integer;
            enter (# enter value <<SLOT GUIENVtextStyleSetFace: doPart>> #)
            exit (# <<SLOT GUIENVtextStyleGetFace: doPart>> exit value #)
            #);
          ascent: integerValue
            (* ascent is the maximum amount of pixels a character
             * drawn in THIS(textStyle) will go above the base line
             *)
            (# <<SLOT GUIENVtextStyleAscent: doPart>> #);
          descent: integerValue
            (* descent is the maximum amount of pixels a character
             * drawn in THIS(textStyle) will go below the base line
             *)
            (# <<SLOT GUIENVtextStyleDescent: doPart>> #);
          leading: integerValue
            (* leading is the vertical distance between the descent
             * of one line and the ascent of the next line
             *)
            (# <<SLOT GUIENVtextStyleLeading: doPart>> #);
          lineHeight: integerValue
            (* the line height (in pixels) is determined by adding
             * the ascent, descent, and leading
             *)
            (# <<SLOT GUIENVtextStyleHeight: doPart>> #);
          maxChWidth: integerValue
            (* the greatest distance the pen will move when a
             * character is drawn
             *)
            (# <<SLOT GUIENVtextStyleMaxChWidth: doPart>> #);
          widthOfChar: integerValue
            (* in most fonts the width of the characters
             * differs. This method returns the width of the character
             * "ch" when drawn in THIS(textStyle)
             *)
            (# ch: @char
            enter ch
            <<SLOT GUIENVtextStyleWidthOfChar: doPart>>
            #);
          widthOfText: integerValue
            (* widthOfText returns the width of the given text
             * string, when drawn in THIS(textStyle), which it
             * calculates by adding the charWidths of all the
             * characters in the string
             *)
            (# str: ^text
            enter str[]
            <<SLOT GUIENVtextStyleStringWidth: doPart>>
            #);
          availableSizes: 
            (* an inner is executed for all available sizes in the
             * font of THIS(textStyle)
             *)
            (# thisSize: @integer;
            <<SLOT GUIENVtextStyleFamilySizes: doPart>>
            #);
          private: @<<SLOT GUIENVtextStylePrivate: descriptor>>;
       #) (* textStyle *);
     color:
       (* A Color has three components: red, green and blue. *)
       (# <<SLOT colorLib: attributes>>;
          red,green,blue: @integer;
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     
     timer:
       (# <<SLOT timerLib: attributes>>;
          repeating:< booleanValue;
          
          start:
            (# interval: @integer
            enter interval
            <<SLOT GUIenvTimerStart: doPart>>
            #);
          stop:
            (# <<SLOT GUIenvTimerStop: doPart>> #);
          action:<
            object;
          private: @<<SLOT GUIenvTimerPrivate: descriptor>>;
       #);

     clipboard: @
       (* models the clipboard, which is used to transport pictures
        * and text between applications
        *)
       (# <<SLOT clipBoardLib: attributes>>;
          hasText: booleanValue 
            (* returns true if the contents of the clipBoard is text
             *) 
            (# <<SLOT GUIENVclipBoardHasText: doPart>> #);
          textContents: 
            (* evaluate the enter-part to set the clipboards
             * text-contents, and evaluate the exit-part to get the
             * clipboards text-contents.  If the clipboard doesn't
             * contain text, NONE is returned.  You can call hasText,
             * before calling getTextContents to determine if there is
             * text to get
             *)
            (# txt: ^text;
            enter (# enter txt[] <<SLOT GUIENVclipBoardSetText: doPart>> #)
            exit (# <<SLOT GUIENVclipBoardGetText: doPart>> exit txt[] #)
            #);
          clearContents:
            (* call this to empty all contents of the clipboard *)
            (# <<SLOT GUIENVclipBoardClearContents: doPart>> #);
       #) (* clipboard *);
     mouse: @
       (* models the mouse *)
       (# <<SLOT mouseLib: attributes>>;
          globalPosition: 
            (* the global position of the mouse is returned. You
             * can't set the position
             *)
            (# pt: @point;
            <<SLOT GUIENVmouseGlobalPosition: doPart>>
            exit pt
            #);
          buttonState: integerValue
            (* the number designating the button, currently pressed
             * down - 0 means 'no button'.  This value depends on the
             * number of buttons on the mouse - Typically 1, 2 or 3.
             *) 
            (# 
            <<SLOT GUIENVmouseButtonState: doPart>>
            #);
          busyCursor:
            (* A busy cursor is a sign to the user that the
             * application are doing some processing. You will
             * normally use cursors.watch for this purpose. Set
             * busyCursor to none, when done processing.
             *)
            (# theCur: ^cursor;
            enter (#  enter theCur[] <<SLOT GUIENVmouseTheCursorSet: doPart>> #)
            exit (# <<SLOT GUIENVmouseTheCursorGet: doPart>> exit theCur[] #)
            #);
       #) (* mouse *);
     system: @
       (* models different properties of the current system *)
       (# <<SLOT systemLib: attributes>>;
          screenRectangle: 
            (* the rectangle of the main screen. *)
            (# theRectangle: @rectangle;
            <<SLOT GUIENVsystemScreenRectangle: doPart>>
            exit theRectangle
            #);
          screenRgn: 
            (* the region defining the screen(s) *)
            (# rgn: ^region;
            <<SLOT GUIENVsystemScreenRgn: doPart>>
            exit rgn[]
            #);
          systemTextStyle: 
            (* the textStyle used by the system to draw menutitles
             * etc.
             *)
            @textStyle;
          beep:
            (* beeps using the current beep in the system *)
            (# <<SLOT GUIENVsystemBeepBody: doPart>> #);
          wait: 
            (* delays the specified number of ticks (1 tick = 1/60
             * sec.)
             *)
            (# ticks: @integer;
            enter ticks
            <<SLOT GUIENVsystemWaitBody: doPart>>
            #);
       #) (* system *);
     transferModes: @
       (# copy: (# exit 0 #);
          invertCopy: (# exit 1 #);
          erase: (# exit 2 #);
          andBlend: (# exit 3 #);
          orBlend: (# exit 4 #);
          xorBlend: (# exit 5 #);
          notAndBlend: (# exit 6 #);
          notOrBlend: (# exit 7 #);
       #);
     textFaces: @
       (# <<SLOT textFacesLib: attributes>>;
          plain: (# exit  0 #);
          bold: (# exit  1 #);
          italic: (# exit  2 #);
       #);
     patterns: @
       (# black, dkGray, gray, ltGray, white: ^pixmap #);
     cursors: @
       (# arrow, iBeam, watch, cross, plus: @cursor #);
     borderStyles: @
       (# simple: (# exit 1 #);
	  etchedOut: (# exit 2 #);
	  etchedIn: (# exit 3 #);
          shadowIn: (# exit 4 #);
          shadowOut: (# exit 5 #);
       #);
     separatorStyles: @
       (# singleLine: (# exit 1 #);
	  doubleLine: (# exit 2 #);
          singleDashedLine: (# exit 3 #);
          doubleDashedLine: (# exit 4 #);
          etchedIn: (# exit 5 #);
          etchedOut: (# exit 6 #);
       #);
     windowTypes: @
       (# normal: integerValue (# do 0 -> value #);
          dialog: integerValue (# do 1 -> value #);
          palette: integerValue (# do 2 -> value #);
       #);
     private: @<<SLOT GUIENVPrivate: descriptor>>;
     bifrostprivate: @<<SLOT BifrostPrivate: descriptor>>;
     trace:
       (* For debugging. If doTrace is true, inner is called. *)
       (#
       do (if doTrace then inner if);
       #);
     doTrace: @Boolean;
     debuggraphic: @boolean
       (* If true, display verbose bifrost debug trace. Defaults to
        * false
        *);
     displaywarnings: @boolean
       (* If displayWarnings is true, various warnings about bifrost
        * errors that are not fatal, but may affect the behaviour, is
        * displayed. Defaults to true.
        *);
     
     (* Additions needed for systemenv *)
     doSetup: 
       (# 
       do (if not setupDone then
              <<SLOT GUIENVdoSetUp: descriptor>>; 
              true -> setupDone 
          if)
       #);
     setupDone: @Boolean;
     XsystemEnvPresent: @Boolean; 
     (* TRUE if this is a XsystemEnv program.  In this case,
      * callbacks are executed by a separate thread as synchronisation
      * via semaphores between x-callbacks and other coroutines would
      * not be possible otherwise. (It could lead to suspend of
      * coroutines with C stackparts.  If TRUE,
      * XsystemEnvHandleCallback should not be NONE.
      *)
     XsystemEnvHandleCallbackP: 
       (# cb: ^Object; enter cb[] do INNER #);
     XsystemEnvHandleCallback: 
       ^XsystemEnvHandleCallbackP;
  <<SLOT GUIENVDoPart: doPart>>
  #) (* GUIenv *)
