ORIGIN '~beta/basiclib/v1.5/betaenv';
BODY 'private/graphmathbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: attributes --
(* idx=2 *)
point: 
  (* A point is defined as the intersection between a vertical line
   * and a horisontal line in the coordinate plane
   *)
  (# <<SLOT pointLib: attributes>>;
     v, h: @integer;
     add: 
       (* adds the coordinates of p to the coordinates THIS(point) *)
       (# p: @point
       enter p
       do <<SLOT GUIENVpointAdd: descriptor>>
       #);
     subtract: 
       (* subtracts the coordinates of p from the coordinates of
        * THIS(point)
        *)
       (# p: @point
       enter p
       do <<SLOT GUIENVpointSubtract: descriptor>>
       #);
     isEqual: booleanValue
       (* compares THIS(point) to p and returns true if they are
        * equal or false if not
        *)
       (# p: @point
       enter p
       do <<SLOT GUIENVpointIsEqual: descriptor>>
       #);
  enter (h, v)
  exit  (h, v)
  #) (* point *);
rectangle: 
  (* rectangles are used to define areas on the screen, to assign
   * coordinate systems to graphic entities, and to specify the
   * location and sizes for various drawing commands.  A rectangle is
   * defined by two points topLeft, bottomRight, which denote the
   * top-left corner and the bottom-right corner of the rectangle
   *)
  (# <<SLOT rectangleLib: attributes>>;
     topLeft:
       (# 
       enter (left, top)
       exit (left, top)
       #);
     bottomRight:
       (# 
       enter (right, bottom)
       exit (right, bottom)
       #);
     left, top, right, bottom: @integer;
     
     set:
       (* assigns the four boundary coordinates to THIS(rectangle) *)
       (# left, top, right, bottom: @integer
       enter (left, top, right, bottom)
       do <<SLOT GUIENVrectangleSet: descriptor>>
       #);
     setFromPoints: 
       (* sets THIS(rectangle) to the smallest rectangle that
        * encloses the two given points p1, p2
        *)
       (# p1, p2: @point;
       enter (p1, p2)
       do <<SLOT GUIENVrectangleSetFromPts: descriptor>>
       #);
     size: 
       (* evaluate the enter part to set the width and height.
        * Evaluate the exit part to get the width and height
        *)
       (# w, h: @integer;
       enter (#  enter (w, h) do <<SLOT GUIENVrectSetSize: descriptor>> #)
       exit (# do <<SLOT GUIENVrectangleGetSize: descriptor>> exit (w, h)  #)
       #);
     offset: 
       (* moves THIS(rectangle) by adding delta.h to each horizontal
        * coordinate and delta.v to each vertical coordinate
        *)
       (# delta: @point
       enter delta
       do <<SLOT GUIENVrectangleOffset: descriptor>>
       #);
     inset: 
       (* shrinks or expands THIS(rectangle). The left and right
        * sides are moved in by the amount specified by delta.h; the
        * top and bottom are moved toward the center by the amount
        * specified by delta.v.  If delta.h or delta.v is negative,
        * the appropriate pair of sides is moved outward instead of
        * inward
        *)
       (# delta: @point
       enter delta
       do <<SLOT GUIENVrectangleInSet: descriptor>>
       #);
     intersection: booleanValue
       (* calculates the rectangle that is the intersection of src1
        * and src2, sets THIS(rectangle) to the intersection. Result
        * is set to true iff src1 and src2 indeed intersect
        *)
       (# src1, src2: @rectangle
       enter (src1, src2)
       do <<SLOT GUIENVrectangleIntersection: descriptor>>
       #);
     union: 
       (* calculates the smallest rectangle that encloses src1 and
        * src2, and sets THIS(rectangle) to the result
        *)
       (# src1, src2: @rectangle
       enter (src1, src2)
       do <<SLOT GUIENVrectangleUnion: descriptor>>
       #);
     containsPoint: booleanValue
       (* determines whether the pixel below and to the right of the
        * given coordinate point is enclosed in the specified
        * rectangle, and returns true if so or false if not
        *)
       (# p: @point
       enter p
       do <<SLOT GUIENVrectangleContainsPoint: descriptor>>
       #);
     pToAngle: 
       (* calculates an integer angle between a line from the center
        * of the rectangle to thePoint and a line from the center of
        * the rectangle pointing straight up (12 o'clock high). The
        * angle is in degrees from 0 to 359, measured clockwise from
        * 12 oUclock, with 90 degrees at 3 o'clock, 180 at 6 o'clock,
        * and 270 at 9 o'clock
        *)
       (# thePoint: @point; angle: @integer
       enter thePoint
       do <<SLOT GUIENVrectanglePToAngle: descriptor>>
       exit angle
       #);
     isEqual: booleanValue
       (* compares theRectangle to THIS(rectangle) and returns true
        * if they are equal or false if not. The two rectangles must
        * have identical boundary coordinates to be considered equal
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do <<SLOT GUIENVrectangleIsEqual: descriptor>>
       #);
     isEmpty: booleanValue
       (* returns true if THIS(rectangle) is an empty rectangle or
        * false if not.  A rectangle is considered empty if the bottom
        * coordinate is less than or equal to the top or the right
        * coordinate is less than or equal to the left
        *)
       (# do <<SLOT GUIENVrectangleIsEmpty: descriptor>> #);
  enter (topLeft, bottomRight)
  exit  (topLeft, bottomRight)
  #) (* rectangle *);
matrix: 
  (# << slot matrixLib: attributes>>;
     (* a  b  0
      * c  d  0
      * tx ty 1
      *)
     a, b, c, d, tx, ty: @real;
     inverse: ^matrix;
     mult: (* Multiply two matrices *)
       (# A, B, res: ^matrix;
       enter (A[], B[])
       do <<SLOT GUIENVmultiplyMatrixBody: descriptor>>
       exit res[]
       #);
     transformPoint: @
       (# p, result: @point;
       enter p
       do <<SLOT GUIENVtransformPointMatrixBody: descriptor>>
       exit result
       #);
     inverseTransformPoint: @
       (# p1, p2: @point;
       enter p1
       do <<SLOT GUIENVinverseTransformPointMatrixBody: descriptor>>
       exit p2
       #);
     transformRectangle: @
       (# r, result: @rectangle;
       enter r
       do <<SLOT GUIENVtransformRectangleMatrixBody: descriptor>>
       exit result
       #);
     inverseTransformRectangle: 
       (# r, result: @rectangle;
       enter r
       do <<SLOT GUIENVinverseTransformRectangleMatrixBody: descriptor>>
       exit result
       #);
     getInverse: @
       (# get: @<<SLOT GUIENVcalcInverseMatrixBody: descriptor>>;
       do get;
       exit inverse[]
       #);
  enter (a, b, c, d, tx, ty)
  do INNER;
  exit (a, b, c, d, tx, ty)
  #);
IDmatrix: 
  (# ID: ^matrix 
  do <<SLOT GUIENVIDmatrixBody: descriptor>>
  exit ID[]
  #);
moveMatrix: matrix   (* A matrix specifying a translation *)
  (# itx, ity: @integer;
  enter (itx, ity)
  do <<SLOT GUIENVmoveMatrixBody: descriptor>>
  #);
scaleMatrix: matrix  (* A matrix specifying a scaling *)
  (# 
  enter (a, d)
  do <<SLOT GUIENVscaleMatrixBody: descriptor>>
  #);
rotateMatrix: matrix (* A matrix specifying a rotation *)
  (# theta: @real;
  enter theta
  do <<SLOT GUIENVrotateMatrixBody: descriptor>>
  #);
ovalAngle: 
  (* Returns the angle a (in radians) and cos(a), sin(a), assuming
   * that (x,y) is a point on the oval with center in (cx,cy) and
   * horizontal radius hr and verticalradius vr, i.e.
   *    (x,y) = (cx,cy) + (hr*cos(a),vr*sin(a))
   *)
  (# cx, cy, hr, vr, x, y: @integer;
     a, cos_a, sin_a: @real;
     angle: @<<SLOT GUIENVovalAngle: descriptor>>;
  enter (cx, cy, hr, vr, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
circleAngle: 
  (* Returns the angle a (in radians) and cos(a), sin(a), assuming
   * that (x,y) is a point on the circle with center in (cx,cy) and
   * radius r, for some r i.e. (x,y) = (cx,cy) + (r*cos(a),r*sin(a))
   *)
  (# cx, cy, x, y: @integer;
     a, cos_a, sin_a: @real;
     angle: @<<SLOT GUIENVcircleAngle: descriptor>>;
  enter (cx, cy, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
region: 
  (* A region is a collection of spatially coherent points *)
  (# <<SLOT regionLib: attributes>>;
     bounds: 
       (# theRectangle: @rectangle;
       do <<SLOT GUIENVregionBounds: descriptor>>
       exit theRectangle
       #);
     allocate: 
       (* allocates space for a new, variable-size region,
        * initializes it to the empty region defined by the rectangle
        * (0, 0)(0, 0)
        *)
       <<SLOT GUIENVregionAllocate: descriptor>>;
     dispose: 
       (* releases the memory occupied by THIS(region). Use this only
        * after you are completely through with a temporary region
        *)
       <<SLOT GUIENVregionDispose: descriptor>>;
     empty: 
       (* destroys the previous structure of the given region, then
        * sets THIS(region) new to the empty region.
        *)
       <<SLOT GUIENVregionEmpty: descriptor>>;
     setFromRectangle: 
       (* destroys the previous structure of THIS(region), and then
        * sets the new structure to the rectangle specified by
        * theRectangle
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do <<SLOT GUIENVregionSetFromRectangle: descriptor>>
       #);
     offset: 
       (* moves THIS(region) on the coordinate plane, a distance of
        * delta.h horizontally and delta.v vertically
        *)
       (# delta: @point
       enter delta
       do <<SLOT GUIENVregionOffset: descriptor>>
       #);
     inset: 
       (* shrinks or expands THIS(region). All points on the region
        * boundary are moved inwards a distance of dv vertically and
        * dh horizontally; if dh or dv is negative, the points are
        * moved outwards in that direction.  It leaves THIS(region)
        * centered at the same position, but moves the outline in -
        * for positive values of dh and dv - or out - for negative
        * values of dh and dv
        *)
       (# delta: @point
       enter delta
       do <<SLOT GUIENVregionInset: descriptor>>
       #);
     intersection: 
       (* calculates the intersection of two regions src1 and src2,
        * and sets THIS(region) to the intersection. This does not
        * create THIS(region); space must already have been allocated
        * for it.  THIS(region) can be one of the source regions, if
        * desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do <<SLOT GUIENVregionIntersection: descriptor>>
       #);
     union: 
       (* calculates the union of two regions src1 and src2, and sets
        * THIS(region) to the union. This does not create
        * THIS(region); space must already have been allocated for
        * THIS(region).  THIS(region) can be one of the source
        * regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do <<SLOT GUIENVregionUnion: descriptor>>
       #);
     difference: 
       (* subtracts src2 from src1 and sets THIS(region) to the
        * difference.  This does not create THIS(region); space must
        * already have been allocated for it. THIS(region) can be one
        * of the source regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do <<SLOT GUIENVregionDifference: descriptor>>
       #);
     symDiff: 
       (* calculates the difference between the union and the
        * intersection of src1 and src2 and places the result in
        * dstRgn.  This does not create THIS(region); space must
        * already have been allocated for it. THIS(region) can be one
        * of the source regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do <<SLOT GUIENVregionXOr: descriptor>>
       #);
     containsPoint: booleanValue
       (* checks whether the pixel below and to the right of pt is
        * within THIS(region), and returns true if so or false if not
        *)
       (# pt: @point
       enter pt
       do <<SLOT GUIENVregionContainsPoint: descriptor>>
       #);
     containsRectangle: booleanValue
       (* checks whether theRectangle intersects the specified
        * region, and returns true if the intersection encloses at
        * least one bit or false if not
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do <<SLOT GUIENVregionContainsRectangle: descriptor>>
       #);
     isEqual: booleanValue
       (* compares THIS(region) to theRegion and returns true if they
        * are equal or false if not. THIS(region) and theRegion must
        * have identical sizes, shapes, and locations to be considered
        * equal.  If THIS(region) and theRegion are empty regions true
        * is returned as well
        *)
       (# theRegion: ^region
       enter theRegion
       do <<SLOT GUIENVregionIsEqual: descriptor>>
       #);
     isEmpty: booleanValue
       (* returns true if THIS(region) is an empty region or false if
        * not
        *)
       (# do <<SLOT GUIENVregionIsEmpty: descriptor>> #);
     private: @<<SLOT GUIENVregionPrivate: descriptor>>;
  enter (# r: ^region  enter r[] do <<SLOT GUIENVregionEnter: descriptor>> #)
  exit  (# r: ^region do <<SLOT GUIENVregionExit: descriptor>>  exit r[] #)
  #) (* region *);
