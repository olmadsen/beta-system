ORIGIN '../bpButtonsBody';

INCLUDE '~beta/guienv/v1.6/graphics'
'~beta/win32lib/v1.6/wingdi'
'~beta/containers/v1.6/list'
'drawBorderLine';

-- lib: attributes --
DrawFocusRect: External
  (#
     hDC: @integer;
     (* handle to device context *)
     lprc: @integer;
     result: @integer;
     
  enter (hDC,lprc)
  do callStd; 
  exit result
  #);

allocRectPtr:
  (# ntRectPtr: @integer;
  do 16 -> malloc -> ntRectPtr;
  exit ntRectPtr
  #);

fillInRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter (r[],ntRectPtr)
  do (if ntRectPtr<>0 then
         (ntRectPtr + 0,  r.left) -> TOS'%PutLong';
         (ntRectPtr + 4,   r.top) -> TOS'%PutLong';
         (ntRectPtr + 8, r.right) -> TOS'%PutLong';
         (ntRectPtr + 12,r.bottom) -> TOS'%PutLong';
     if);
  #);

-- bpButtonOnMouseDown: doPart --
do inner;
   
-- bpButtonOnMouseUp: doPart --
do inner;
   
-- bpButtonCreate: doPart --
do inner;
   
-- bpButtonOpen: doPart --
do borderStyles.shadowOut -> buttonStyle;
   buttonStates.red -> state;
   inner;
   (if label[]<>NONE then
       (if this(bpButtons).private.theTextStyle[]<>NONE then           
           label[]-> this(bpButtons).private.theTextStyle.widthOfText -> width;
           width div 2 -> width; 
           width * 2 + 4 -> width;
        else
           100 -> width;
       if);
    else
       100 -> width;
   if);
   
-- bpButtonUpdate: doPart --
do (immediate,private.frame) -> private.updateArea;

   
-- bpButtonPrivate: descriptor --
(# selected: @boolean;
   ntPoints: [12] @integer;
   intPoints: [12] @integer;
   
   fillInPoints:
     (# h2,dx: @integer;
     do height div 2 -> h2;
        this(bpButtons).private.dx -> dx;
        
        x -> ntPoints[1];
        y -> ntPoints[2];
        
        x+dx+width -> ntPoints[3];
        y -> ntPoints[4];
        
        x+2*dx+width -> ntPoints[5];
        y+h2 -> ntPoints[6];
        
        x+dx+width -> ntPoints[7];
        y+height -> ntPoints[8];
        
        x -> ntPoints[9];
        y+height -> ntPoints[10];
        
        x+dx -> ntPoints[11];
        y+h2 -> ntPoints[12];
        
        fillInIntPoints;
     #);
   
   fillInIntPoints:
     (# h2,dx: @integer;
     do height div 2 -> h2;
        this(bpButtons).private.dx -> dx;
        
        x+4 -> intPoints[1];
        y+2 -> intPoints[2];
        
        x+dx+width+1 -> intPoints[3];
        y+2 -> intPoints[4];
        
        x+2*dx+width-1 -> intPoints[5];
        y+h2 -> intPoints[6];
        
        x+dx+width -> intPoints[7];
        y+height-1 -> intPoints[8];
        
        x+3 -> intPoints[9];
        y+height-1 -> intPoints[10];
        
        x+dx+2 -> intPoints[11];
        y+h2 -> intPoints[12];
     #);
   
   frame:
     (# r: ^rectangle; dx: @integer;
     do &rectangle[] -> r[];
        2 * this(bpButtons).private.dx -> dx;
        ((x,y),(x+width+dx,y+height)) -> r;
     exit r[]
     #);      
   
   updateArea:
     (# r: ^rectangle;
        theNtRectPtr: @integer; result: @integer;
        immediate: @boolean;
     enter (immediate,r[])
     do allocRectPtr -> theNtRectPtr;
        (if theNtRectPtr<>0 then
            (r[],theNtRectPtr) -> fillInRectPtr;
            (this(bpButtons).interfaceObjectID,theNtRectPtr,1) 
              -> InvalidateRect -> result;
            (if immediate then
                this(bpButtons).interfaceObjectID -> UpdateWindow; 
            if);
            theNtRectPtr -> free;
        if);
     #);
   
   draw:
     (# r: @rectangle; 
        lh2,dx: @integer;
        doPaint: @integer;
        theNtRectPtr: @integer;
        hdc: @integer;
        hRgn,hbr: @integer;
     enter theNtRectPtr
     do 
        this(bpButtons).private.theTextStyle.lineHeight div 2 - 2 -> lh2;
        this(bpButtons).private.dx -> dx;
        (private.frame,theNtRectPtr) -> fillInRectPtr;
        interfaceObjectId -> GetDC -> hdc;
        (if theNtRectPtr<>0 then
            (hdc, theNtRectPtr) -> RectVisible -> doPaint;
        if);
        (if doPaint<>0 then 
            
            (this(bpButtons)[],buttonStyle,x,y,width,height,dx)
              ->drawBorderLine; 
            
            state -> CreateSolidBrush -> hbr;
            (@@private.intPoints[1],6,2) -> CreatePolygonRgn-> hRgn;
            (hdc,hRgn,hbr) -> FillRgn;
            
            (if this(bpButton)[] = this(bpButtons).private.targetButton[] then
                ((x+dx+2,y+3),(x+dx+width,y+height-2)) -> r;
                (r[],theNtRectPtr) -> fillInRectPtr;
                (if theNtRectPtr<>0 then
                    (hdc,theNtRectPtr) -> DrawFocusRect;
                if);
            if);
            
            hRgn -> DeleteObject;
            hbr -> DeleteObject;
            
            
            
            (if label[]<>NONE then
                graphics
                (# 
                do (if buttonStyle=borderStyles.shadowOut then
                       (x+dx+4,y+(height div 2) + lh2) -> moveTo;
                    else
                       (x+dx + 6,y+(height div 2) + lh2 +2) -> moveTo;
                   if);
                   this(bpButtons).private.theTextStyle[] -> style;
                   label[] -> drawText;
                #);
            if);
        if);
        (interfaceObjectID,hdc) -> ReleaseDC;
     #);
#)
   
-- bpButtonsOnRefresh: doPart --
do inner;
   (# theNtRectPtr: @integer;
   do 
      allocRectPtr -> theNtRectPtr;
      L: private.theButtons.scan
        (# 
        do allocRectPtr -> current.private.draw;
        #);
      (if theNtRectPtr<>0 then
          theNtRectPtr -> free;
          0 -> theNtRectPtr;
      if);
   #);
   
-- bpButtonsOnMouseDown: doPart --
do (# hRgn: @integer;
      selected: ^bpButton;
      mx,my: @integer;
      theNtRectPtr: @integer;
   do this(bpButtons)[] -> target;
      NONE  -> selected[];
      L: private.theButtons.scan
        (# 
        do 
           (@@current.private.ntPoints[1],6,2) -> CreatePolygonRgn -> hRgn;
           
           localPosition -> (mx,my);
           (if ((hRgn,mx,my) -> PtInRegion)<>0 then
               
               (buttonState,globalPosition) -> current.onMouseDown;
               (if buttonState=1 then
                   current[] -> private.theButtons.setCurFocus;
                   borderStyles.shadowIn -> current.buttonStyle;
                   true -> current.update;
               if);
               
               allocRectPtr -> theNtRectPtr;
               (if theNtRectPtr<>0 then
                   trackMouse
                   (# mousePress::
                        (# 
                        do curPt -> (mx,my);
                           (if ((hRgn,mx,my) -> PtInRegion)<>0 then
                               current[] -> selected[];
                           if);
                        #);
                      mouseMove::
                        (# 
                        do (if current[]=selected[] then
                               curPt -> (mx,my);
                               (if ((hRgn,mx,my) -> PtInRegion)<>0 then
                                   (if current.buttonStyle=borderStyles.shadowOut 
                                       then
                                       borderStyles.shadowIn->current.buttonStyle;
                                       theNtRectPtr -> current.private.draw;
                                       (* true -> update; *)
                                   if);
                                else
                                   (if current.buttonStyle=borderStyles.shadowIn 
                                       then
                                       borderStyles.shadowOut->current.buttonStyle;
                                       theNtRectPtr -> current.private.draw;
                                       (* true -> update; *)
                                   if);
                               if);
                           if);
                        #);
                      MouseRelease::
                        (#
                        do (if current[]=selected[] then
                               borderStyles.shadowOut->current.buttonStyle;
                               curPt -> (mx,my);
                               (if ((hRgn,mx,my) -> PtInRegion)<>0 then
                                   (buttonState,globalPosition) -> current.onMouseUp;
                               if);
                               false -> current.update;
                           if);
                        #); 
                   #);
                   theNtRectPtr -> free;
                else
                   'Failed to allocate rectangel in bpButtonsOnMouseDown.'
                     -> screen.putLine;
               if);
               hRgn -> DeleteObject;
               leave L;
           if);
           hRgn -> DeleteObject;
        #);
   #);
   
   inner;
   
-- bpButtonsOnMouseUp: doPart --
do inner;
   
-- bpButtonsOnKeyDown: doPart --
do (if ch
    //ascii.ht then 
       (if ShiftModifier->isModifierOn then 
           (if (-1 -> private.theButtons.onTab)=private.callInnerOnKeyDown then
               inner onKeyDown;
           if);
        else
           (if (1->private.theButtons.onTab)=private.callInnerOnKeyDown then
               inner onKeyDown;
           if);
       if);
    //ascii.sp then
       
   if); 
   
-- bpButtonsOnEnableTarget: doPart --
do private.theButtons.selectFirst;   
   inner;
   
-- bpButtonsOnDisableTarget: doPart --
do (# tb: ^bpButton;
   do (if private.targetButton[]<>NONE then
          private.targetButton[] -> tb[];
          NONE -> private.targetButton[];
          tb.update;
      if);
   #);
   inner;
   
-- bpButtonsAdd: doPart --
do (# w,h: @integer;
   do theButton.open;
      private.prevX + 4 -> theButton.x;
      theButton.x + theButton.width + 2*private.dx -> private.prevX;
      private.buttonHeight -> theButton.height;
      theButton.private.fillInPoints;
      theButton[] -> private.theButtons.add;
      
      size -> (w,h);
      (if w < private.prevX then
          (private.prevX+2,h) -> size;
      if);
   #);
   
-- bpButtonsCreate: doPart --
do inner;
   
-- bpButtonsOpen: doPart --
do 
   (* true -> border.visible;
    borderStyles.simple -> border.style; *)
   &textStyle[] -> private.theTextStyle[];
   'MS Sans Serif' -> private.theTextStyle.name;
   8 -> private.theTextStyle.size;
   private.theTextStyle.create;
   private.theTextStyle.lineHeight -> private.buttonHeight;
   private.buttonHeight div 2 -> private.buttonHeight; 
   private.buttonHeight * 2 + 8 -> private.buttonHeight;
   
   private.buttonHeight div 2 -> private.dx;
   (200,private.buttonHeight+4) -> size;
   
   inner;
   
   
-- bpButtonsPrivate: descriptor --
(#
   targetButton,prevTargetButton: ^bpButton;
   setTargetButton:
     (# tb: ^bpButton;
     enter tb[]
     do 
        targetButton[] -> prevTargetButton[];
        tb[] -> targetButton[];
        (if prevTargetButton[]<>NONE then
            prevTargetButton.update;
        if);
        (if private.targetButton[]<>NONE then
            private.targetButton.update;
        if);
     #);
   callInnerOnKeyDown: (# exit 1 #);
   
   theButtons: @cyclicList
     (# element:: bpButton;
        
        curFocus: ^theCellType;
        noOfControls: @integer;
        add:
          (# thebpButton: ^bpButton; 
          enter thebpButton[]
          do noOfControls+1-> noOfControls; 
             thebpButton[]-> append; 
          #);
        onTab:
          (# direction: @integer; (* 1 = forward, -1 = backward *) 
             result: @integer;
          enter direction
          do (if curFocus[] = none then selectFirst;  if);
             (if curFocus[] <> none then
                 (if direction = 1 then
                     (if curFocus[]=last then
                         callInnerOnKeyDown -> result;
                      else
                         (curFocus.next).elm[]->setTargetButton;
                         curFocus.next->curFocus[];
                     if);
                  else
                     (if curFocus[]=head then
                         callInnerOnKeyDown -> result;
                      else
                         (curFocus.prev).elm[]->setTargetButton;
                         curFocus.prev->curFocus[];
                     if);
                 if);
             if);
          exit result
          #);
        setCurFocus:
          (# thebpButton: ^bpButton; 
          enter thebpButton[]
          do
             L: scan
               (# 
               do (if current[] = thebpButton[] then
                      current[]->at->curFocus[];
                      curFocus.elm[]->setTargetButton;
                      
                      (* 'setCurFocus. Focus is: '->puttext;
                       curFocus.elm.label[]->putline; *)
                      
                      leave L
                  if);
               #);
             
          #);
        selectFirst:
          (# 
          do (if head <> none then
                 head->curFocus[]; (head).elm[]->setTargetButton; 
             if);
          #);
        
        selectLast:
          (# 
          do (if last <> none then
                 head ->curFocus[]; (last).elm[] -> setTargetButton;
             if);
          #);
     #);
   
   selectedButton: ^bpButton;
   theTextStyle: ^textStyle;
   buttonHeight: @integer;
   dx: @integer;
   prevX: @integer;
#)
