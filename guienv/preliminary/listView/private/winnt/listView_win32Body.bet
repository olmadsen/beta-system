ORIGIN '../listViewBody';

INCLUDE 
'../../../imageList/imageList'
'~beta/guienv/v1.6/private/datastructures/sequence'
'~beta/guienv/v1.6/private/winnt/guienv_ntiprivate'
'~beta/guienv/v1.6/private/winnt/guienvattributes'
'~beta/win32lib/v1.6/commctrl'
'~beta/win32lib/v1.6/systemmetrics'
'~beta/win32lib/v1.6/windowsmisc'
'~beta/sysutils/v1.6/cstring'
'~beta/sysutils/v1.6/objinterface';

-- lib: attributes --

WM_UPDATEHEADERWIDTH: (# exit WM_USER+10 #);

PostMessage: external
  (* The PostMessage function posts (places) a message in the message queue 
   * associated with the thread that created the given window and then returns 
   * without waiting for the thread to process the message. Messages in a message 
   * queue are retrieved by calls to the GetMessage or PeekMessage function.
   *)
  (# hwnd: @integer; (* Identifies the window whose window procedure will receive the
                      * message. If this parameter is 16xFFFFFFFF, the message will be
                      * posted to all overlapped or pop-up windows in the system. The
                      * message is not posted to child windows. HWND *)
     uMsg: @integer; (* Specifies the message to be posted. UINT *)
     wParam: @integer; (* Specifies additional message-dependent information. WPARAM *)
     lParam: @integer; (* Specifies additional message-dependent information. LPARAM *)
     out: @integer; (* BOOL *)
  enter (hwnd,uMsg,wParam,lParam)
  do 'PostMessageA' -> callStd;
  exit out
  #);

ImageList_Draw: external
  (# himl, i,hdcDst,x,y,fStyle: @integer;
     result: @integer;
  enter (himl, i,hdcDst,x,y,fStyle)
  do callStd;
  exit result
  #);

ImageList_GetIconSize: external
  (# himl, cx, cy: @integer;
     result: @integer;
  enter (himl, cx, cy)
  do callStd
  exit result
  #);

HD_ITEM_extR: externalRecord
  (# mask: @long (# pos::< (# do 0 -> value; #); #); 
     cxy: @long (# pos::< (# do 4 -> value; #); #); 
     pszText: @long (# pos::< (# do 8 -> value; #); #); 
     hbm: @long (# pos::< (# do 12 -> value; #); #); 
     cchTextMax: @long (# pos::< (# do 16 -> value; #); #); 
     fmt: @long (# pos::< (# do 20 -> value; #); #); 
     lParam: @long (# pos::< (# do 24 -> value; #); #); 
  #);



LV_ITEMA_ext: externalRecord
  (# (* bytesize::< (# do 36 -> value; #); *)
     mask: @long (# pos::< (# do 0 -> value; #); #); 
     iItem: @long (# pos::< (# do 4 -> value; #); #); 
     iSubItem: @long (# pos::< (# do 8 -> value; #); #);  
     state: @long (# pos::< (# do 12 -> value; #); #);  
     stateMask: @long (# pos::< (# do 16 -> value; #); #);   
     pszText: @long (# pos::< (# do 20 -> value; #); #);       
     cchTextMax: @long (# pos::< (# do 24 -> value; #); #);
     iImage: @long (# pos::< (# do 28 -> value; #); #);
     lParam: @long (# pos::< (# do 32 -> value; #); #);
  #);
sizeOf_LV_ITEMA_ext: (# exit 36 #);

TEXTMETRIC_extR: externalRecord
  (# 
     tmHeight: @long (# pos::< (# do 0 -> value; #); #);  
     tmAscent: @long (# pos::< (# do 4 -> value; #); #);  
     tmDescent: @long (# pos::< (# do 8 -> value; #); #);  
     tmInternalLeading: @long (# pos::< (# do 12 -> value; #); #);  
     tmExternalLeading: @long (# pos::< (# do 16 -> value; #); #);  
     tmAveCharWidth: @long (# pos::< (# do 20 -> value; #); #);  
     tmMaxCharWidth: @long (# pos::< (# do 24 -> value; #); #);  
     tmWeight: @long (# pos::< (# do 28 -> value; #); #);  
     tmOverhang: @long (# pos::< (# do 32 -> value; #); #);  
     tmDigitizedAspectX: @long (# pos::< (# do 36 -> value; #); #);  
     tmDigitizedAspectY: @long (# pos::< (# do 40 -> value; #); #);  
     tmFirstChar: @byte (# pos::< (# do 44 -> value; #); #);  
     tmLastChar: @byte (# pos::< (# do 45 -> value; #); #);  
     tmDefaultChar: @byte (# pos::< (# do 46 -> value; #); #);  
     tmBreakChar: @byte (# pos::< (# do 47 -> value; #); #);  
     tmItali: @byte (# pos::< (# do 48 -> value; #); #);  
     tmUnderlined: @byte (# pos::< (# do 49 -> value; #); #);  
     tmStruckOut: @byte (# pos::< (# do 50 -> value; #); #);  
     tmPitchAndFamily: @byte (# pos::< (# do 51 -> value; #); #);  
     tmCharSet: @byte (# pos::< (# do 52 -> value; #); #);  
  #);
sizeOf_TEXTMETRIC: (# exit 56 #);

ListView_InsertItem_ext:
  (# hwnd: @integer; 
     pitem: @integer;
     result: @integer;
     errorMsg: ^text;
  enter (hwnd, pitem)  
  do (hwnd, LVM_INSERTITEM, 0, pitem) -> SendMessage -> result;
     
     (if result=-1 then
         &text[] -> errorMsg[];
         'ListView_InsertItem failed. Errorcode = ' -> errorMsg.putText;
         GetLastError -> errorMsg.putint; errorMsg.newline;
     if);
  exit result
  #);

ListView_GetItem:
  (# hwnd: @integer;
     pitem: @integer;
     result: @integer;
  enter (hwnd, pitem) 
  do (hwnd, LVM_GETITEMA, 0, pitem) -> SendMessage -> result;
  exit result
  #);

memset: external
  (# dest,c,count: @integer;
     result: @integer;
  enter (dest,c,count)
  do callC;
  exit result
  #);


HDN_FIRST: (# exit -300 #);
HDN_ENDTRACK: (# exit (HDN_FIRST-27) #);

HDI_WIDTH: (# exit          0x0001 #);

HDM_FIRST: (# exit                 0x1200  #);    (* Header messages *)

HDM_GETITEMA: (# exit              (HDM_FIRST + 3) #);
HDM_GETITEMW: (# exit             (HDM_FIRST + 11) #);

Header_GetItem:
  (# hwndHD, i, phdi: @integer;
  enter (hwndHD, i, phdi)
  do (hwndHD, HDM_GETITEMW, i, phdi)
       -> SendMessage
  #);

-- listItemLib: attributes --
getIndex:
  (# index: @integer;
     uid: @integer;
     listViewId: @integer;
     plvfi: @LV_FINDINFOA;
  enter uid
  do this(listView).interfaceObjectID -> listViewId;
     LVFI_PARAM -> plvfi.flags;
     uid -> plvfi.lParam;
     (listViewId, -1, plvfi[]) -> ListView_FindItem -> index;
  exit index
  #);

-- GUIEnvListItemSetName: doPart --
do (if theName[]<>NONE then
       (if theName.length>0 then
           theName.copy -> private.name[];
           (if private.isOpen then
               (# listViewId: @integer;
               do this(listView).interfaceObjectID -> listViewId;
                  (listViewId,private.uid->getIndex,0,private.name[]) 
                    -> ListView_SetItemText;
               #);
           if);
        else
           (if private.name[]<>NONE then
               private.name.clear;
           if);
       if);
   if);

-- GUIEnvListItemGetName: doPart --
do (if private.name[]<>NONE then
       private.name.copy -> theName[];
   if);
   
-- GUIEnvListItemSetIcon: doPart --
do (if theIcon[]<>NONE then
       theIcon[] -> this(listView).private.icons.getIndex -> private.ImageId;
       theIcon[] -> private.theIcon[];
       (if private.isOpen then
           (# listViewId: @integer;
              lvI: @LV_ITEMA_ext;
              res: @integer;
           do sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
              (if lvI.ptr<>0 then
                  this(listView).interfaceObjectID -> listViewId;
                  0 -> lvI.state; 
                  0 -> lvI.stateMask; 
                  0 -> lvI.iSubItem;
                  
                  LVIF_IMAGE -> lvI.mask;
                  private.uid->getIndex -> lvI.iItem;
                  private.imageID -> lvI.iImage;
                  
                  (listViewId,lvI.ptr) -> ListView_SetItem -> res;
                  (if res=0 then
                      'ListView_SetItem failed. Error = ' -> screen.putText;
                      GetLastError -> screen.putInt; newline;
                  if);
                  lvI.ptr -> free;
               else
                  'Failed to allocate LV_ITEMA structure in ListItem.setIcon'
                    -> resourceAllocationError;
              if);
           #);
       if);
   if);
   
-- GUIEnvListItemGetIcon: doPart --
do private.theIcon[] -> theIcon[];
   
-- GUIEnvListItemAddSubText: doPart --
do (if subText[]<>NONE then
       (if private.noOfSubItems+1 > private.subItems.range then
           1 -> private.subItems.extend;
       if);
       private.noOfSubItems+1 -> private.noOfSubItems;
       subText.copy -> private.subItems[private.noOfSubItems][];
   if);
 
-- GUIEnvListItemDelete: doPart --
do (if (this(listItem)[] -> this(listView).private.items.has) then
       (if ((this(listView).interfaceObjectID,private.uid->getIndex)
             -> ListView_DeleteItem) <> 0 then
           this(listItem)[] -> this(listView).private.items.remove;
       if);
   if);
   
-- GUIEnvListItemCreate: doPart --
do FALSE -> doAddToList;
   inner;
   
-- GUIEnvListItemOpen: doPart --
do this(listView).private.columnIndex-1 -> private.subItems.extend;
   inner;

-- GUIEnvListItemSelect: doPart --
do (# iState: @integer;
      listViewId: @integer;
   do (LVIS_FOCUSED, LVIS_SELECTED) -> tos'%or' -> iState; 
      this(listView).interfaceObjectId -> listViewId;
      (listViewId,    (* handle to listview *)
      private.uid->getIndex,         (* index to listview item *)
      iState,                (*  item state *)
      16x000F)               (*  mask *)
        -> ListView_SetItemState;
      
   #);

-- GUIEnvListItemDeSelect: doPart --
do (# iState: @integer;
      listViewId: @integer;
   do this(listView).interfaceObjectId -> listViewId;
      
      (LVIS_FOCUSED, LVIS_SELECTED) -> tos'%or' -> iState; 
      (iState,16x000F) -> bitComp -> iState;
      
      (listViewId,    (* handle to listview *)
      private.uid->getIndex,         (* index to listview item *)
      iState,                (*  item state *)
      16x000F)               (*  mask *)
        -> ListView_SetItemState;
      
   #);

-- GUIEnvListItemPrivate: descriptor --
(# uid: @integer;
   name: ^text;
   isOpen: @boolean;
   theIcon: ^pixmap;
   imageId: @integer; (* The index of the corresponding
                       * image in the image list. *)
   noOfSubItems: @integer;
   subItems: [0]^text;
#)

-- listViewLib: attributes --
lstrcpy: External
  (# charptr1, charptr2: @integer;
     result_ptr: @integer;
  enter (charptr1, charptr2)
  do 'lstrcpyA' -> callStd;
  exit result_ptr
  #);

lstrcat: External
  (# charptr1, charptr2: @integer;
     result_ptr: @integer;
  enter (charptr1, charptr2)
  do 'lstrcatA' -> callStd;
  exit result_ptr
  #);
  
listViewNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# processCommand:
            (# type: @integer;
               id: @integer;
               index: @integer;
               windowID: @integer;
            do false -> didSomething;
            #);
          processNotify:
            (# hwndFrom, idCtrl, code1: @integer;
               uChanged,uNewState,uOldState,iItem: @integer;
               uid: @integer;
               strAddr: @integer;
               theText: ^text;
               tempText: @cstring;
               iSubItem: @integer;
               theItem: ^listItem;
               theMask: @integer;
               doProcess: @integer;
            do info.lParam -> TOS'%adrGetLong' -> hwndFrom;
               info.lParam+4 -> TOS'%adrGetLong' -> idCtrl;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               (if code1
                //LVN_GETDISPINFO then
                   (* LV_DISPINFO *)
                   info.lParam+12 -> TOS'%adrGetLong' -> theMask;
                   (theMask,LVIF_TEXT) -> tos'%and' -> doProcess;
                   (if doProcess<>0 then
                       info.lParam+44 -> TOS'%adrGetLong' -> uid;
                       info.lParam + 32 -> TOS'%adrGetLong' -> strAddr;
                       uid -> private.findListItem -> theItem[];  
                       info.lParam+20 -> TOS'%adrGetLong' -> iSubItem;
                       
                       (if theItem[]<>NONE then
                           (if (iSubItem>=0) and (iSubItem<=theItem.private.subItems.range)
                               then
                               theItem.private.subItems[iSubItem][] -> theText[];
                               (if theText[]<>NONE then
                                   theText[] -> tempText.set;
                                   (strAddr, tempText) -> lstrcpy;
                                   tempText.free;
                               if);
                           if);
                       if);
                    if);
                //LVN_ITEMCHANGED then
                   info.lParam+28 -> TOS'%adrGetLong' -> uChanged;
                   (if uChanged>0 then
                       info.lParam+20 -> TOS'%adrGetLong' -> uNewState;
                       (uNewState,LVIS_SELECTED) -> tos'%and' -> uNewState;
                       
                       info.lParam+24 -> TOS'%adrGetLong' -> uOldState;
                       (uOldState,LVIS_SELECTED) -> tos'%and' -> uOldState;
                       
                       (if (uNewState>0) and (uOldState=0) then
                           info.lParam+40 -> TOS'%adrGetLong' -> uid;
                           uid -> private.items.doCallOnSelect;
                       if);
                    if);
                //NM_DBLCLK then
                   processNM_Dblclk;
                   
                //LVN_COLUMNCLICK then
                   (* NM_LISTVIEW *)
                   (*The user clicked a column header - sort by this criterion.*)
                   info.lParam+16 -> TOS'%adrGetLong' -> iSubItem;
                   (hwndFrom,private.ListViewCompareProcAddress,iSubItem)
                     -> ListView_SortItems;
                   
               if);
               false -> didSomething;
            #);
          processNM_Dblclk:
            (# lvI: @LV_ITEMA_ext;
               itemInx: @integer;
               theItem: ^listItem;
               state: @integer;
               res: @integer; errMsg: ^text;
            do (interfaceObjectId, -1, LVNI_SELECTED) 
                 -> ListView_GetNextItem ->itemInx;
               (if itemInx<>-1 then
                   (interfaceObjectID,itemInx,LVIS_SELECTED)
                     -> ListView_GetItemState -> state;
                   (if state<>0 then
                       sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
                       (if lvI.ptr<>0 then
                           (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                           itemInx -> lvi.iItem;
                           LVIF_PARAM -> lvi.mask;
                           (interfaceObjectId,lvI.ptr) 
                             -> ListView_GetItem 
                             -> res;
                           (if res=0 then
                               &text[] -> errMsg[];
                               'ListView_GetItem failed. Error = ' 
                                 -> errMsg.putText;
                               GetLastError -> errMsg.putInt; 
                               errMsg[] -> apiError;
                           if);
                           lvI.lParam -> private.findListItem -> theItem[];
                           lvI.ptr -> free;
                        else
                           'Failled to allocate LV_ITEM  while processing NM_Dblclk.'
                             -> resourceAllocationError;
                       if);
                       (if theItem[]<>NONE then
                           theItem.onDoubleClick;
                       if);
                   if);
               if);
            #);
          
          CalcStringEllipsis:
            (# 
               szEllipsis: @cString;
               sizeString: @ntPOINTextR;
               sizeEllipsis: @ntPOINTextR;
               lpszTemp: @cString;
               fSuccess: @boolean;
               cbString: @integer;
               hdc,cchMax,uColWidth: @integer;
               lpszString: ^text;
               
            enter (hdc, lpszString[],cchMax, uColWidth)
            do
               (* Adjust the column width to take into account the edges *)
               uColWidth - 4 -> uColWidth;
               
               '...' -> szEllipsis.set;
               
               lpszString[] -> lpszTemp.set;
               8 -> malloc -> sizeString.ptr;
               8 -> malloc -> sizeEllipsis.ptr;
               
               (if (lpszTemp<>0) and (sizeString.ptr<>0) and (sizeEllipsis.ptr<>0) 
                   and (szEllipsis<>0) then
                   (* Get the width of the string in pixels *)
                   lpszTemp.length -> cbString;
                   (if ((hdc, lpszTemp, cbString, sizeString.ptr)->GetTextExtentPoint32)<>0
                       then
                       (* If the width of the string is greater than the column width shave
                        * the string and add the ellipsis *)
                       (if (sizeString.x > uColWidth) then
                           (hdc, szEllipsis, szEllipsis.length,sizeEllipsis.ptr) 
                             -> GetTextExtentPoint32;
                           
                           L:
                             (# 
                             do (if (cbString > 0) then
                                    cbString - 1 -> cbString;
                                    
                                    (cbString,ascii.nul) -> lpszTemp.inxPut;
                                    
                                    (hdc, lpszTemp, cbString, sizeString.ptr)
                                      ->GetTextExtentPoint32;
                                    
                                    (if ((sizeString.x + sizeEllipsis.x) <= uColWidth) then
                                        (* The string with the ellipsis finally fits, now 
                                         * make sure there is enough room in the string for 
                                         * the ellipsis *)
                                        (if (cchMax >= (cbString + szEllipsis.length)) then
                                            (* Concatenate the two strings and break out of 
                                             * the loop *)
                                            
                                            lpszString.clear;
                                            lpszTemp.get -> lpszString.append;
                                            '...' -> lpszString.append;
                                            
                                            TRUE -> fSuccess;
                                            leave L
                                        if);
                                    if);
                                    restart L
                                 else
                                    leave L
                                if);
                             #);
                        else
                           (* No need to do anything, everything fits great. *)
                           TRUE -> fSuccess;
                       if);
                   if);
                   (* CleanUp *)
                   szEllipsis.free;
                   sizeEllipsis.ptr -> free;
                   sizeString.ptr -> free;
                   lpszTemp.free;
                else
                   'Failed to allocate structs in CalcStringEllipsis.'
                     -> resourceAllocationError;
               if);
            exit fSuccess
            #); 
          
          
          DrawItemColumn:
            (# 
               hdc: @integer;
               theText: ^text;
               szString: @cString;
               prcClip: ^ntRECTextR;
            enter (hdc,theText[], prcClip[])
            do
               (* Check to see if the string fits in the clip rect.  If not, truncate
                * the string and add "...". *)
               theText.copy -> theText[];
               (hdc, theText[], theText.length, prcClip.right - prcClip.left) 
                -> CalcStringEllipsis; 
               theText[] -> szString.set;
               
               (* print the text *)
               (hdc, prcClip.left + 2, prcClip.top + 1, ETO_CLIPPED %Bor ETO_OPAQUE,
               prcClip.ptr, szString, szString.length, 0)
                 -> ExtTextOut;
               
               szString.free;
            #);
          
          processDrawItem:
            (# itemAction, itemID, itemState,hdc,top, left, right, bottom: @integer;
               lvI: @LV_ITEMA_ext;
               listViewId: @integer;
               theItem: ^listItem;
               cxImage, cyImage: @integer;
               uiFlags: @integer;
               himl: @integer;
               uFirstColWidth: @integer;
               rcClip: @ntRECTextR;
            do 
               (if ((info.lParam -> TOS'%adrGetLong') = ODT_LISTVIEW) then
                   
                   sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
                   (if lvI.ptr<>0 then
                       (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                       
                       info.lParam+8 -> TOS'%adrGetLong' -> itemID;
                       info.lParam+12 -> TOS'%adrGetLong' -> itemAction;
                       info.lParam+16 -> TOS'%adrGetLong' -> itemState;
                       
                       info.lParam+24 -> TOS'%adrGetLong' -> hdc;
                       
                       info.lParam+28 -> TOS'%adrGetLong' -> left;
                       info.lParam+32 -> TOS'%adrGetLong' -> top;
                       info.lParam+36 -> TOS'%adrGetLong' -> right;
                       info.lParam+40 -> TOS'%adrGetLong' -> bottom;
                       
                       ILD_TRANSPARENT -> uiFlags;
                       
                       (if itemAction
                        //ODA_DRAWENTIRE
                        //ODA_FOCUS
                        //ODA_SELECT then
                           
                           this(listView).interfaceObjectId -> listViewId;
                           itemID -> lvi.iItem;
                           LVIF_PARAM %Bor LVIF_IMAGE %Bor LVIF_STATE -> lvi.mask;
                           0 -> lvi.iSubItem;
                           (listViewId,lvI.ptr) -> ListView_GetItem;
                           lvI.lParam -> private.findListItem -> theItem[];
                           
                           (* Item selected ?? *)
                           (if (itemState %Band ODS_SELECTED) > 0 then
                               (hdc,(COLOR_HIGHLIGHTTEXT->GetSysColor)) -> SetTextColor;
                               (hdc,(COLOR_HIGHLIGHT->GetSysColor)) -> SetBkColor;
                               uiFlags %Bor ILD_BLEND50 -> uiFlags;
                            else
                               (hdc,(COLOR_WINDOWTEXT->GetSysColor)) -> SetTextColor;
                               (hdc,(COLOR_WINDOW->GetSysColor)) -> SetBkColor;
                           if);
                           
                           himlSmall -> himl;
                           (if himl<>0 then
                               (himl, lvi.iImage, hDC,left, top,uiFlags)
                                 -> ImageList_Draw;
                               
                               (himl, @@cxImage, @@cyImage) -> ImageList_GetIconSize; 
                           if);
                           
                           private.columnWidths[1] - cxImage -> uFirstColWidth;
                           16 -> malloc -> rcClip.ptr;
                           (if rcClip.ptr<>0 then
                               left + cxImage -> rcClip.left;
                               left + private.columnWidths[1] -> rcClip.right;
                               top -> rcClip.top;
                               bottom -> rcClip.bottom;
                               
                               (if theItem[]<>NONE then
                                   (hDC, theItem.private.name[],rcClip[])
                                     -> DrawItemColumn;
                                   
                                   (for i:theItem.private.subItems.range repeat
                                        
                                        rcClip.right -> rcClip.left;
                                        rcClip.left + private.columnWidths[i+1] -> rcClip.right;
                                        (if theItem.private.subItems[i][]<>NONE then
                                            (hDC, theItem.private.subItems[i][],rcClip[])
                                              -> DrawItemColumn; 
                                        if);
                                   for);
                                   
                                   (* If we changed the colors for the selected item, undo
                                    * it *)
                                   (if (itemState %Band ODS_SELECTED)>0 then
                                       (* Set the text background and foreground colors *)
                                       (hDC, COLOR_WINDOWTEXT->GetSysColor) -> SetTextColor;
                                       (hDC, COLOR_WINDOW->GetSysColor) -> SetBkColor;
                                   if);
                                   
                                   (* If the item is focused, now draw a focus rect around the 
                                    * entire row *)
                                   (if (itemState %Band ODS_FOCUS)>0 then
                                       (* Adjust the left edge to exclude the image *)
                                       left + cxImage -> rcClip.left;
                                       top -> rcClip.top;
                                       right -> rcClip.right;
                                       bottom -> rcClip.bottom;
                                       
                                       (* Draw the focus rect *)
                                       (hDC, rcClip.ptr) -> DrawFocusRect;
                                   if);
                                   
                                else
                                   'theitem is none for lvI.lParam = ' -> screen.putText;
                                   lvI.lParam -> putint; newline;
                                   'and itemID = ' -> puttext; itemID -> putint; newline;
                               if);
                               
                               rcClip.ptr -> free;
                               0 -> rcClip.ptr;
                            else
                               'Failed to allocate clipping rect while processing WM_DRAWITEM.'
                                 -> resourceAllocationError;
                           if);
                       if);
                       lvI.ptr -> free;
                    else
                       'Failed to allocate LV_ITEM while processing WM_DRAWITEM.'
                         -> resourceAllocationError;
                   if);
               if);    
            #);
          
          processMeasureItem:
            (# CtlType,itemHeight: @integer;
               tm: @TEXTMETRIC_extR;
               hdc: @integer;
               hFont: @integer;
               hwndLV: @integer;
               iconHeight: @integer;
            do 
               this(listView).interfaceObjectId -> hwndLV;
               info.lParam -> TOS'%adrGetLong' -> CtlType;
               
               (* Make sure the control is the listview control *)
               (if (CtlType = ODT_LISTVIEW) then
                   
                   (* Get the font the control is currently using *)
                   (hwndLV, WM_GETFONT, 0, 0) -> SendMessage -> hFont;
                   sizeOf_TEXTMETRIC -> malloc -> tm.ptr;
                   (if tm.ptr<>0 then
                       (* Set the font of the DC to the same font the control is 
                        * using *)
                       hwndLV -> GetDC -> hdc;
                       (hdc, hFont) -> SelectObject;
                       
                       (* Get the height of the font used by the control *)
                       (if ((hdc, tm.ptr) -> GetTextMetrics)<>0 then
                           
                           (* Add a little extra space between items *)
                           tm.tmHeight + 1 -> itemHeight;
                           
                           (* Make sure there is enough room for the images *)
                           SM_CXSMICON -> GetSystemMetrics -> iconHeight;
                           (if (itemHeight < (iconHeight + 1)) then
                               iconHeight + 1 -> itemHeight;
                           if);
                           itemHeight %putLongAt (info.lParam+16);
                       if);
                       
                       (* Clean up *)
                       (hwndLV, hdc) -> ReleaseDC;
                       tm.ptr -> free;
                       0 -> tm.ptr;
                    else
                       'Failled to allocate TEXTMETRIC while processing WM_MEASUREITEM.'
                         -> resourceAllocationError;
                   if);
               if);
               true -> didSomething;
            #);
          
          didSomething: @boolean;
          hwndItem: @integer;
       do true -> didSomething;
          (if info.message 
           //WM_COMMAND then processCommand;            
           //WM_NOTIFY then processNotify;
           //WM_DRAWITEM then
              info.lParam+20 -> TOS'%adrGetLong' -> hwndItem;
              (if hwndItem=this(listView).interfaceObjectID then                  
                  (if not private.dontDrawItems then
                      processDrawitem;
                  if);
               else
                  false -> didSomething;
              if);
           //WM_MEASUREITEM then processMeasureItem;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
          false -> info.handled;
       #);
  #);

listViewMethods: windowItemMethods
  (# 
     dispatchMessage::
       (# didSomething: @boolean;
          
          processNotify:
            (# hwndFrom, idCtrl, code1: @integer;
               iItem: @integer;
               
            do info.lParam -> TOS'%adrGetLong' -> hwndFrom;
               info.lParam+4 -> TOS'%adrGetLong' -> idCtrl;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               
               false -> didSomething;
               (if code1=HDN_ENDTRACK then
                   info.lParam+12 -> TOS'%adrGetLong' -> iItem;
                   true -> private.dontDrawItems;
                   (this(listView).interfaceObjectId,WM_UPDATEHEADERWIDTH, hwndFrom,iItem)
                     -> PostMessage;
               if);
               
            #);
          
          processUpdateHeaderWidth:
            (# theHD_ITEM_extR: @HD_ITEM_extR;
            do 
               28 -> malloc -> theHD_ITEM_extR.ptr;
               (if theHD_ITEM_extR.ptr<>0 then
                   HDI_WIDTH -> theHD_ITEM_extR.mask;
                   (info.wParam,info.lParam,theHD_ITEM_extR.ptr) -> Header_GetItem;
                   theHD_ITEM_extR.cxy -> private.columnWidths[info.lParam+1]; 
                   theHD_ITEM_extR.ptr -> free;
                   true -> didSomething;
                   false -> private.dontDrawItems;
                   update;
                else
                   'Failled to allocate HD_ITEM  while processing WM_UPDATEHEADERWIDTH.'
                     -> resourceAllocationError;
               if);
            #);
       do 
          (if info.message
           //WM_NOTIFY then processNotify
           //WM_UPDATEHEADERWIDTH then processUpdateHeaderWidth;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

himlLarge:        (* image list for icon view *)
  (# exit private.largeImageList.theHandle #);

himlSmall:       (* image list for other views *)
  (# exit private.smallImageList.theHandle #);

SM_CXSMICON: (# exit 49 #);
SM_CYSMICON: (# exit 50 #);

bitComp: 
  (# style: @integer;
     mask: @integer;
  enter (style, mask)
  do style %Band (%Bnot mask) -> style;
  exit style
  #);

-- GUIEnvListViewSelectionFirst: doPart --
do (# lvI: @LV_ITEMA_ext;
      itemInx: @integer;
      state: @integer;
      listViewId: @integer;
   do this(listView).interfaceObjectId -> listViewId;
      (listViewId, -1, LVNI_SELECTED) 
        -> ListView_GetNextItem ->itemInx;
      (if itemInx<>-1 then                    
          (listViewId,itemInx,LVIS_SELECTED)
            -> ListView_GetItemState -> state;
          (if state<>0 then
              sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
              (if lvI.ptr<>0 then
                  (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                  itemInx -> lvi.iItem;
                  LVIF_PARAM -> lvi.mask;
                  (listViewId,lvI.ptr) -> ListView_GetItem;
                  lvI.lParam -> private.findListItem -> theItem[];
                  lvI.ptr -> free;
               else
                  'Failled to allocate LV_ITEM  in selection.first.'
                    -> resourceAllocationError;
              if);
          if);
      if);
   #);
   
-- GUIEnvListViewNoOfItems: doPart --
do private.items.size -> value;
   
-- GUIEnvListViewClear: doPart --
do interfaceObjectID->ListView_DeleteAllItems;
   private.items.clear;
   private.items.init;

-- setLayOutStyle: doPart --
do (interfaceObjectID,lStyle) -> SetView;  
   
-- getLayOutStyle: doPart --
do (# listViewId: @integer;
   do interfaceObjectID -> listViewId;
      (listViewId, GWL_STYLE) -> GetWindowLong -> lStyle; 
      (lStyle,LVS_TYPEMASK) -> tos'%and' -> lStyle;
   #);
   
   
   
-- GUIEnvListViewAddColumn: doPart --
do (# lvC: @LV_COLUMNA;
      szText: @cString;
      columnInx: @integer;
      listviewID: @integer;
      result: @integer;
   do interfaceObjectID -> listviewID;
      LVCF_FMT + LVCF_WIDTH + LVCF_TEXT + LVCF_SUBITEM -> lvC.mask; 
      LVCFMT_LEFT -> lvC.fmt;  (* left-align column *)
      theColumnInfo.width -> lvC.cx;        
      (* Add the column. *)
      private.nextColumnIndex -> columnInx;
      
      columnInx -> lvC.iSubItem; 
      (if theColumnInfo.title[]<>NONE then
          theColumnInfo.title[] -> szText.set;
       else
          '' -> szText.set;
      if);
      (if szText.charPtr<>0 then
          szText.charPtr -> lvC.pszText;
          (listviewID, columnInx, lvC[]) 
            -> ListView_InsertColumn -> result;
          (if result=-1 then
              'ListView_InsertColumn failed. Error= ' -> puttext;
              GetLastError -> putint; newline;
           else
              lvC.cx -> private.columnWidths[columnInx+1];
          if);
          szText.charPtr -> free;
      if);
   #);      
   
-- GUIEnvListViewAddListItem: doPart --
do (# lvI: @LV_ITEMA_ext;		(* list view item structure *)
      cstrLabel: @cstring;
      aLabel: ^text;
      inx: @integer; (* Index of this(listItem). *)
      listViewId: @integer;
      result: @integer;
   do interfaceObjectID -> listViewId;
      (if theItem[]<>NONE then
          theItem[] -> getPatternName -> theItem.private.name[];
          theItem.open;
          (if not 
              (theItem[] -> this(listView).private.items.has)
              then
              this(listView).private.items.size  -> inx;
              
              sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
              (if lvI.ptr<>0 then
                  (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                  theItem[] -> this(listView).private.items.insert;
                  LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM + LVIF_STATE
                    -> lvI.mask;
                  0 -> lvI.state; 
                  0 -> lvI.stateMask; 
                  
                  theItem.private.name[] -> cstrLabel.set;
                  cStrLabel.charPtr -> lvI.pszText;
                  (if cStrLabel.charPtr=0 then
                      'cStrLabel.charPtr=0' -> screen.putline;
                  if);
                  
                  theItem.private.imageID -> lvI.iImage;    (* image list index *)
                  inx -> lvI.iItem; (* items index in the listview control*)
                  0 -> lvI.iSubItem;
                  0 -> lvI.lParam;
                  this(listView).private.getUid->theItem.private.uid->lvI.lParam;
                  
                  (listViewId, lvI.ptr) -> ListView_InsertItem_ext;
                  cstrLabel.free;
                  lvI.ptr -> free;
               else
                  'Failled to allocate LV_ITEM  while adding listItem.'
                    -> resourceAllocationError;
              if);
          if);
          
          TRUE -> theItem.private.isOpen;
      if);
   #); 
   
-- GUIEnvListViewCreate: doPart --
do (# wStyle: @integer;
   do InitCommonControls;
      
      true -> this(windowItem).private.borderHandledLocally;
      
      private.ListViewCompareProc## 
        -> private.std16x3toint  (* private.makeCBF *)
        -> private.ListViewCompareProcAddress;                
      
      &listViewNotiMethods[] -> theNotiMethods;
      &listViewMethods[] -> theMethods;
      
      isSubClass  -> windowItemClassStatus; 
      (* isStandardClass -> windowItemClassStatus; *)
      'SysListView32' -> windowItemClass;
      WS_EX_CLIENTEDGE -> windowItemExStyle; 
      (if report_view then
          (LVS_SINGLESEL %Bor LVS_REPORT) -> wStyle; 
       else
          (if icon_view then
              (LVS_SINGLESEL %Bor LVS_ICON) -> wStyle; 
           else
              (if smallIcon_view then
                  (LVS_SINGLESEL %Bor LVS_SMALLICON) -> wStyle; 
               else
                  (if list_view then
                      (LVS_SINGLESEL %Bor LVS_LIST) -> wStyle; 
                   else
                      (LVS_SINGLESEL %Bor LVS_LIST) -> wStyle; 
                      '*** ERROR: At least one of report_view, smallIcon_view, icon_view, or list_view must be TRUE to create the list view.' -> screen.putLine;
                  if);
              if);
          if);
      if);
      
      wStyle %Bor WS_BORDER %Bor LVS_SHOWSELALWAYS %Bor LVS_OWNERDRAWFIXED 
        -> windowItemStyle;
      inner create;
   #);

   
-- GUIEnvListViewOpen: doPart --
do private.icons.init;
   private.items.init;
   inner;
   true -> border.visible;
   borderStyles.shadowIn -> border.style;
   (interfaceObjectID,initialRange) -> ListView_SetItemCount;
   
-- GUIEnvListViewClose: doPart --
do inner;
   private.ListViewCompareProcAddress -> private.freeCBF;
   
-- GUIEnvListViewPrivate: descriptor --
(# ListViewCompareProcAddress: @integer;
   std16x3toint: external
     (# func: ##ListViewCompareProc;
        int: @integer;
     enter func##
     do 'copyinput'->callC
     exit int
     #);
   
   makeCBF: External
     (# pat: ##External;
        cb: @integer;
     enter pat##
     exit cb
    #);
    
   
   freeCBF: External
     (# cbf: @integer;
     enter cbf
     #);
   
   dontDrawItems: @boolean;
   
   columnIndex: @integer; (* Zero based *)
   nextColumnIndex: integerValue
     (# 
     do columnIndex -> value;
        columnIndex + 1 -> columnIndex;
        1 -> columnWidths.extend;
     #);
   columnWidths: [0]@integer;
   
   ListViewCompareProc: external
     (# lParam1, lParam2, lParamSort: @integer;
        theItem1,theItem2: ^listItem;
        subItem1, subItem2: ^text;
        result: @integer;                       
     enter (lParam1, lParam2, lParamSort)
     do StdExternalEntry;
        
        lParam1 -> private.findListItem -> theItem1[];
        lParam2 -> private.findListItem -> theItem2[];
        
        (if (theItem1[]<>NONE) and (theItem2[]<>NONE) then
            (if lParamSort
             //0 then
                (if theItem1.private.name[] -> theItem2.private.name.equal then
                    0 -> result;
                 else
                    (if theItem1.private.name[]->theItem2.private.name.less then
                        -1 -> result;
                     else
                        1 -> result;
                    if);
                if);
                (* //1 then
                 *                 (if theItem1.type = theItem2.type then
                 *                     0 -> result;
                 *                  else
                 *                     (if theItem1.type < theItem2.type then
                 *                         -1 -> result;
                 *                      else
                 *                         1 -> result;
                 *                     if);  
                 *                 if);
                 *)
             else
                (if theItem1.private.subItems.range>= lParamSort then
                    theItem1.private.subItems[lParamSort][] -> subItem1[];
                if);
                (if theItem2.private.subItems.range>= lParamSort then
                    theItem2.private.subItems[lParamSort][] -> subItem2[];
                if);
                (if (subItem1[]<>NONE) and (subItem2[]<>NONE) then
                    (if subItem1[] -> subItem2.equal then
                        0 -> result;
                     else
                        (if subItem1[]->subItem2.less then
                            -1 -> result;
                         else
                            1 -> result;
                        if);
                    if);
                if);
            if);
        if);
     exit result   
     #);
   
   guid: @integer;
   getUid:
     (# do guid + 1 -> guid;
     exit guid
     #);
   largeImageList, smallImageList: @imageList;
   
   iconElm:
     (# theIcon: ^pixmap;
        index: @integer;
     #);
   icons: @sequence
     (# element:: iconElm;

        init::
          (# do 0 -> currentIndex; #);
        
        currentIndex: @integer; (* Zero based *);
        getIndex:
          (# theIcon: ^pixmap;
             index: @integer;
             anElm: ^iconElm;
          enter theIcon[]
          do -1 -> index;
             L:
               scan
               (# 
               do (if (theIcon[]=current.theIcon[]) then
                      current.index -> index;
                      leave L
                  if);
               #);
             (if index=-1 then (* new icon *)
                 &iconElm[] -> anElm[];
                 theIcon[] -> anElm.theIcon[];
                 currentIndex -> anElm.index -> index;
                 currentIndex + 1 -> currentIndex;
                 anElm[] -> append;
                 theIcon[] -> addIconToImageList;
             if);
          exit index
          #);
        
     #); (* End of icons *)
   
   items: @list
     (# element:: listItem;
        insert:
          (# elm: ^element;
          enter elm[]
          do elm[] -> append;
          #);
        remove:
          (# elm: ^element;
             theCell: ^theCellType;
          enter elm[]
          do elm[] -> at -> delete;
          #);
        doCallOnSelect:
          (# uid: @integer;
             theItem: ^element;
          enter uid
          do l: scan
               (# 
               do (if current.private.uid=uid then
                      current[] -> theItem[];
                      leave l;
                  if);
               #); 
             (if theItem[]<>NONE then
                 theItem.onSelect
             if);
          #);
     #);
   findListItem:
     (# uid: @integer;
        theItem: ^listItem;
     enter uid
     do l: 
          items.scan
          (# 
          do (if current.private.uid=uid then
                 current[] -> theItem[];
                 leave l;
             if);
          #); 
     exit theItem[]
     #);
   
   imageListInitialized: @boolean;
   initImageLists:
     (# listViewId: @integer;
     do interfaceObjectID -> listViewId;
        (if icon_view then
            (* Create the full sized image list. *)
            (SM_CXICON->GetSystemMetrics, 
            SM_CYICON->GetSystemMetrics, 1,initialNoOfIcons, 1) 
              -> private.largeImageList.create;
        if);
        (if smallicon_view or report_view or list_view then
            (* Create the small sized icon image lists. *)
            (SM_CXSMICON->GetSystemMetrics, 
            SM_CYSMICON->GetSystemMetrics, 1, initialNoOfIcons, 1) 
              -> private.smallImageList.create;
        if);
        
        (* Assign the image lists to the list view control. *)
        (if icon_view then
            (listViewId,himlLarge,LVSIL_NORMAL)
              ->ListView_SetImageList; 
        if);
        (if smallicon_view or report_view or list_view then
            (listViewId,himlSmall,LVSIL_SMALL)
              ->ListView_SetImageList;
        if);
        
        true -> imageListInitialized;
     #); (* End of initImageLists *)
   
   addIconToImageList:
     (# theIcon: ^pixmap;
     enter theIcon[]
     do (if not imageListInitialized then
            initImageLists;
        if);
        (if icon_view then
            theIcon.private.handleToPixmap->private.largeImageList.addIcon;
        if);
        (if smallicon_view or report_view or list_view then
            theIcon.private.handleToPixmap -> private.smallImageList.addIcon;
        if);
     #);
#)

-- GUIEnvListViewEventHandlerOnMouseUp: doPart --
do (* iCurSel = ListView_GetNextItem (ghwndLV, -1, LVNI_SELECTED); *)
   inner;

-- GUIEnvListViewEventHandlerOnMouseDown: doPart --
do inner;
