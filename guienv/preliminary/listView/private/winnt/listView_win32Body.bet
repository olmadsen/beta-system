ORIGIN '../listViewBody';

INCLUDE 
'../../../imageList/imageList'
       '~beta/guienv/private/datastructures/sequence'
       '~beta/guienv/private/winnt/guienv_ntiprivate'
       '~beta/guienv/private/winnt/guienvattributes'
       '~beta/win32lib/commctrl'
       '~beta/win32lib/systemmetrics'
       '~beta/win32lib/windowsmisc'
       '~beta/win32lib/keyboardinputsupport'
       '~beta/sysutils/cstring'
       '~beta/sysutils/objinterface';

BUILD default '$$/misc.obj' 'external/misc.c' 'betacc $0 $1';

-- lib: attributes --
ICC_LISTVIEW_CLASSES: (# exit 0x00000001 #);

InitCommonControlsEx: external
  (# lpInitCtrls: @integer; (* LPINITCOMMONCONTROLSEX *)
  enter lpInitCtrls
  do callStd;
  #);

INITCOMMONCONTROLSEX_ext: externalRecord
  (# 
     dwSize: @long (# pos::< (# do 0 -> value; #); #); 
     dwICC: @long (# pos::< (# do 4 -> value; #); #); 
  #);

sizeOf_INITCOMMONCONTROLSEX_ext: (# exit 8 #);

GetComCtlVersion: external
  (# pdwMajor, pdwMinor: @integer;
     hres: @integer;
  enter (pdwMajor, pdwMinor)
  do callC
  exit hres
  #);

isFullDragSet: external
  (# hwnd: @integer;
     res: @integer;
  enter hwnd
  do callC;
  exit res
  #);

WM_UPDATEHEADERWIDTH: (# exit WM_USER+10 #);

PostMessage: external
  (* The PostMessage function posts (places) a message in the message queue 
   * associated with the thread that created the given window and then returns 
   * without waiting for the thread to process the message. Messages in a message 
   * queue are retrieved by calls to the GetMessage or PeekMessage function.
   *)
  (# hwnd: @integer; (* Identifies the window whose window procedure will receive the
                      * message. If this parameter is 16xFFFFFFFF, the message will be
                      * posted to all overlapped or pop-up windows in the system. The
                      * message is not posted to child windows. HWND *)
     uMsg: @integer; (* Specifies the message to be posted. UINT *)
     wParam: @integer; (* Specifies additional message-dependent information. WPARAM *)
     lParam: @integer; (* Specifies additional message-dependent information. LPARAM *)
     out: @integer; (* BOOL *)
  enter (hwnd,uMsg,wParam,lParam)
  do 'PostMessageA' -> callStd;
  exit out
  #);

ImageList_Draw: external
  (# himl, i,hdcDst,x,y,fStyle: @integer;
     result: @integer;
  enter (himl, i,hdcDst,x,y,fStyle)
  do callStd;
  exit result
  #);

ImageList_GetIconSize: external
  (# himl, cx, cy: @integer;
     result: @integer;
  enter (himl, cx, cy)
  do callStd
  exit result
  #);

HD_ITEM_extR: externalRecord
  (# mask: @long (# pos::< (# do 0 -> value; #); #); 
     cxy: @long (# pos::< (# do 4 -> value; #); #); 
     pszText: @long (# pos::< (# do 8 -> value; #); #); 
     hbm: @long (# pos::< (# do 12 -> value; #); #); 
     cchTextMax: @long (# pos::< (# do 16 -> value; #); #); 
     fmt: @long (# pos::< (# do 20 -> value; #); #); 
     lParam: @long (# pos::< (# do 24 -> value; #); #); 
  #);



LV_ITEMA_ext: externalRecord
  (# (* bytesize::< (# do 36 -> value; #); *)
     mask: @long (# pos::< (# do 0 -> value; #); #); 
     iItem: @long (# pos::< (# do 4 -> value; #); #); 
     iSubItem: @long (# pos::< (# do 8 -> value; #); #);  
     state: @long (# pos::< (# do 12 -> value; #); #);  
     stateMask: @long (# pos::< (# do 16 -> value; #); #);   
     pszText: @long (# pos::< (# do 20 -> value; #); #);       
     cchTextMax: @long (# pos::< (# do 24 -> value; #); #);
     iImage: @long (# pos::< (# do 28 -> value; #); #);
     lParam: @long (# pos::< (# do 32 -> value; #); #);
     iIndent: @long (# pos::< (# do 36 -> value; #); #);
  #);
sizeOf_LV_ITEMA_ext: (# exit 40 #);

TEXTMETRIC_extR: externalRecord
  (# 
     tmHeight: @long (# pos::< (# do 0 -> value; #); #);  
     tmAscent: @long (# pos::< (# do 4 -> value; #); #);  
     tmDescent: @long (# pos::< (# do 8 -> value; #); #);  
     tmInternalLeading: @long (# pos::< (# do 12 -> value; #); #);  
     tmExternalLeading: @long (# pos::< (# do 16 -> value; #); #);  
     tmAveCharWidth: @long (# pos::< (# do 20 -> value; #); #);  
     tmMaxCharWidth: @long (# pos::< (# do 24 -> value; #); #);  
     tmWeight: @long (# pos::< (# do 28 -> value; #); #);  
     tmOverhang: @long (# pos::< (# do 32 -> value; #); #);  
     tmDigitizedAspectX: @long (# pos::< (# do 36 -> value; #); #);  
     tmDigitizedAspectY: @long (# pos::< (# do 40 -> value; #); #);  
     tmFirstChar: @byte (# pos::< (# do 44 -> value; #); #);  
     tmLastChar: @byte (# pos::< (# do 45 -> value; #); #);  
     tmDefaultChar: @byte (# pos::< (# do 46 -> value; #); #);  
     tmBreakChar: @byte (# pos::< (# do 47 -> value; #); #);  
     tmItali: @byte (# pos::< (# do 48 -> value; #); #);  
     tmUnderlined: @byte (# pos::< (# do 49 -> value; #); #);  
     tmStruckOut: @byte (# pos::< (# do 50 -> value; #); #);  
     tmPitchAndFamily: @byte (# pos::< (# do 51 -> value; #); #);  
     tmCharSet: @byte (# pos::< (# do 52 -> value; #); #);  
  #);
sizeOf_TEXTMETRIC: (# exit 56 #);

LV_HITTESTINFO_ext: externalRecord
  (# 
     pt: @
       (# x: @long (# pos::< (# do 0 -> value #); #);
          y: @long (# pos::< (# do 4 -> value #); #);
       enter (x,y)
       exit (x,y)
       #);
     flags: @long (# pos::< (# do 8 -> value; #); #); 
     iItem: @long (# pos::< (# do 12 -> value; #); #);
     iSubItem: @long (# pos::< (# do 12 -> value; #); #);
  #);
sizeOf_LV_HITTESTINFO: (# exit 20 #);

NMLVKEYDOWN_ext: externalRecord
  (# hdr: @
       (# hwndFrom: @long (# pos::< (# do 0 -> value; #); #);
          idFrom: @long (# pos::< (# do 4 -> value; #); #);
          nCode: @long (# pos::< (# do 8 -> value; #); #); 
       #); (* NMHDR *)
     wVKey: @short(# pos::< (# do 12 -> value; #); #); (* WORD *)
     flags: @long (# pos::< (# do 14 -> value; #); #);  (* UINT *)
  #);
sizeOf_NMLVKEYDOWN_ext: (# exit 18 #);

NMLVCUSTOMDRAW_ext: externalRecord
  (# nmcd: @
       (# hdr: @
            (# hwndFrom: @long (# pos::< (# do 0 -> value; #); #);
               idFrom: @long (# pos::< (# do 4 -> value; #); #);
               nCode: @long (# pos::< (# do 8 -> value; #); #); 
            #); (* NMHDR *)
          dwDrawStage: @long (# pos::< (# do 12 -> value; #); #);
          hdc: @long (# pos::< (# do 16 -> value; #); #);
          rc: @
            (# left: @long (# pos::< (# do 20 -> value; #); #); (* int left *)
               top: @long (# pos::< (# do 24 -> value; #); #); (* int top *)
               right: @long (# pos::< (# do 28 -> value; #); #); (* int right *)
               bottom: @long (# pos::< (# do 32 -> value; #); #); (* int bottom *)
            #);
          dwItemSpec: 
            (*
             * this is control specific, but it is how to specify an 
             * item.  valid only with CDDS_ITEM bit set 
             *)
            @long (# pos::< (# do 36 -> value; #); #);
          
          uItemState: @long (# pos::< (# do 40 -> value; #); #);
          lItemlParam: @long (# pos::< (# do 44 -> value; #); #);
       #);
     clrText: @long (# pos::< (# do 48 -> value; #); #); (* COLORREF *)
     clrTextBk: @long (# pos::< (# do 52 -> value; #); #); (* COLORREF *)
     iSubItem: @long (# pos::< (# do 56 -> value; #); #);
  #);

sizeOf_NMLVCUSTOMDRAW_ext: (# exit 60 #);

ListView_HitTest_ext:
  (# hwndLV: @integer;
     pinfo: @integer;
     result: @integer;
     temp: @integer;
  enter (hwndLV, pinfo) 
  do LVM_HITTEST -> temp;
     (hwndLV, temp, 0, pinfo) -> SendMessage -> result;
  exit result
  #);

ListView_InsertItem_ext:
  (# hwnd: @integer; 
     pitem: @integer;
     result: @integer;
     errorMsg: ^text;
  enter (hwnd, pitem)  
  do (hwnd, LVM_INSERTITEM, 0, pitem) -> SendMessage -> result;
     
     (if result=-1 then
         &text[] -> errorMsg[];
         'ListView_InsertItem failed. Errorcode = ' -> errorMsg.putText;
         GetLastError -> errorMsg.putint; errorMsg.newline;
     if);
  exit result
  #);

ListView_GetItem:
  (# hwnd: @integer;
     pitem: @integer;
     result: @integer;
  enter (hwnd, pitem) 
  do (hwnd, LVM_GETITEMA, 0, pitem) -> SendMessage -> result;
  exit result
  #);

memset: external
  (# dest,c,count: @integer;
     result: @integer;
  enter (dest,c,count)
  do callC;
  exit result
  #);

HDN_FIRST: (# exit -300 #);
HDN_BEGINTRACKA: (# exit (HDN_FIRST-6) #);
HDN_BEGINTRACKW: (# exit         (HDN_FIRST-26) #);
HDN_BEGINTRACK: (# exit HDN_BEGINTRACKA #);
HDN_ENDTRACK: (# exit (HDN_FIRST-27) #);
HDN_TRACKA: (# exit   (HDN_FIRST-8) #);
HDN_TRACKW: (# exit              (HDN_FIRST-28) #);
HDN_TRACK: (# exit HDN_TRACKA #);
HDN_ITEMCHANGEDA: (# exit (HDN_FIRST-1) #);
HDN_ITEMCHANGEDW: (# exit (HDN_FIRST-21) #);
HDN_ITEMCHANGED: (# exit (HDN_FIRST-1) #);

HDI_WIDTH: (# exit          0x0001 #);

HDM_FIRST: (# exit                 0x1200  #);    (* Header messages *)

HDM_GETITEMA: (# exit              (HDM_FIRST + 3) #);
HDM_GETITEMW: (# exit             (HDM_FIRST + 11) #);

NM_CUSTOMDRAW: (# exit (NM_FIRST-12) #);

LVM_SETEXTENDEDLISTVIEWSTYLE: (# exit (LVM_FIRST + 54) #);

LVS_EX_HEADERDRAGDROP: (# exit   0x00000010 #);
LVS_EX_FULLROWSELECT: (# exit 0x00000020 #);

CDRF_NOTIFYPOSTPAINT: (# exit    0x00000010 #);
CDRF_NOTIFYITEMDRAW: (# exit     0x00000020 #);
(* (_WIN32_IE >= 0x0400) *)
CDRF_NOTIFYSUBITEMDRAW:
  (* flags are the same, we can distinguish by context *)
  (# exit 0x00000020 #);

CDRF_NOTIFYPOSTERASE: (# exit    0x00000040 #);

CDRF_DODEFAULT: (# exit           0x00000000 #);
CDRF_NEWFONT: (# exit             0x00000002 #);
CDRF_SKIPDEFAULT: (# exit         0x00000004 #);

CDDS_PREPAINT: (# exit 0x00000001 #);
CDDS_POSTPAINT: (# exit 0x00000002 #);
CDDS_PREERASE: (# exit  0x00000003 #);
CDDS_POSTERASE: (# exit 0x00000004 #);

CDDS_ITEM:           (# exit      0x00010000 #);
CDDS_ITEMPREPAINT:   (# exit      (CDDS_ITEM %Bor CDDS_PREPAINT) #);
CDDS_ITEMPOSTPAINT:  (# exit      (CDDS_ITEM %Bor CDDS_POSTPAINT) #);
CDDS_ITEMPREERASE:   (# exit      (CDDS_ITEM %Bor CDDS_PREERASE) #);
CDDS_ITEMPOSTERASE:  (# exit      (CDDS_ITEM %Bor CDDS_POSTERASE) #);
(* (_WIN32_IE >= 0x0400) *)
CDDS_SUBITEM:       (# exit            0x00020000 #);

Header_GetItem:
  (# hwndHD, i, phdi: @integer;
  enter (hwndHD, i, phdi)
  do (hwndHD, HDM_GETITEMW, i, phdi)
       -> SendMessage
  #);

-- listItemLib: attributes --
getIndex:
  (# index: @integer;
     uid: @integer;
     listViewId: @integer;
     plvfi: @LV_FINDINFOA;
  enter uid
  do this(listView).interfaceObjectID -> listViewId;
     LVFI_PARAM -> plvfi.flags;
     uid -> plvfi.lParam;
     (listViewId, -1, plvfi[]) -> ListView_FindItem -> index;
  exit index
  #);

-- GUIEnvListItemSetName: doPart --
do (if theName[]<>NONE then
       (if theName.length>0 then
           theName[] -> private.name[];
           (if private.isOpen then
               (# listViewId: @integer;
               do this(listView).interfaceObjectID -> listViewId;
                  (listViewId,private.uid->getIndex,0,private.name[]) 
                    -> ListView_SetItemText;
               #);
           if);
        else
           (if private.name[]<>NONE then
               private.name.clear;
           if);
       if);
   if);

-- GUIEnvListItemGetName: doPart --
do private.name[] -> theName[];
   
-- GUIEnvListItemSetIcon: doPart --
do (if theIcon[]<>NONE then
       theIcon[] -> this(listView).private.icons.getIndex -> private.ImageId;
       theIcon[] -> private.theIcon[];
       (if private.isOpen then
           (# listViewId: @integer;
              lvI: @LV_ITEMA_ext;
              res: @integer;
           do sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
              (if lvI.ptr<>0 then
                  this(listView).interfaceObjectID -> listViewId;
                  0 -> lvI.state; 
                  0 -> lvI.stateMask; 
                  0 -> lvI.iSubItem;
                  
                  LVIF_IMAGE -> lvI.mask;
                  private.uid->getIndex -> lvI.iItem;
                  private.imageID -> lvI.iImage;
                  
                  (listViewId,lvI.ptr) -> ListView_SetItem -> res;
                  (if res=0 then
                      'ListView_SetItem failed. Error = ' -> screen.putText;
                      GetLastError -> screen.putInt; newline;
                  if);
                  lvI.ptr -> free;
               else
                  'Failed to allocate LV_ITEMA structure in ListItem.setIcon'
                    -> resourceAllocationError;
              if);
           #);
       if);
   if);
   
-- GUIEnvListItemGetIcon: doPart --
do private.theIcon[] -> theIcon[];
   
-- GUIEnvListItemAddSubText: doPart --
do (if subText[]<>NONE then
       (if private.noOfSubItems+1 > private.subItems.range then
           1 -> private.subItems.extend;
       if);
       private.noOfSubItems+1 -> private.noOfSubItems;
       subText[] -> private.subItems[private.noOfSubItems][];
   if);
 
-- GUIEnvListItemDelete: doPart --
do (if (this(listItem)[] -> this(listView).private.items.has) then
       (if ((this(listView).interfaceObjectID,private.uid->getIndex)
             -> ListView_DeleteItem) <> 0 then
           this(listItem)[] -> this(listView).private.items.remove;
       if);
   if);
   
-- GUIEnvListItemCreate: doPart --
do FALSE -> doAddToList;
   inner;
   
-- GUIEnvListItemOpen: doPart --
do this(listView).private.columnIndex-1 -> private.subItems.extend;
   inner;
   
-- GUIEnvListItemClose: doPart --
do inner;
   0 -> private.noOfSubItems;
   0 -> private.subItems.new;
   FALSE -> private.isOpen;

-- GUIEnvListItemSelect: doPart --
do (# iState: @integer;
      listViewId: @integer;
   do (LVIS_FOCUSED, LVIS_SELECTED) -> tos'%or' -> iState; 
      this(listView).interfaceObjectId -> listViewId;
      (listViewId,    (* handle to listview *)
      private.uid->getIndex,         (* index to listview item *)
      iState,                (*  item state *)
      16x000F)               (*  mask *)
        -> ListView_SetItemState;
      
   #);

-- GUIEnvListItemDeSelect: doPart --
do (# iState: @integer;
      listViewId: @integer;
   do this(listView).interfaceObjectId -> listViewId;
      
      LVIS_FOCUSED %Bor LVIS_SELECTED -> iState; 
      (iState,16x000F) -> bitComp -> iState;
      
      (listViewId,    (* handle to listview *)
      private.uid->getIndex,         (* index to listview item *)
      iState,                (*  item state *)
      16x000F)               (*  mask *)
        -> ListView_SetItemState;
      
   #);

-- GUIEnvListItemPrivate: descriptor --
(# uid: @integer;
   name: ^text;
   isOpen: @boolean;
   theIcon: ^pixmap;
   imageId: @integer; (* The index of the corresponding
                       * image in the image list. *)
   noOfSubItems: @integer;
   subItems: [0]^text;
#)

-- listViewLib: attributes --
InitListViewControl:
  (# lpInitCtrls: @INITCOMMONCONTROLSEX_ext;
  do private.getDllVersion;
     (if (private.dllMajor>=4) and (private.dllMinor>=70) then
         sizeOf_INITCOMMONCONTROLSEX_ext -> malloc -> lpInitCtrls.ptr;
         (if lpInitCtrls.ptr<>0 then
             sizeOf_INITCOMMONCONTROLSEX_ext -> lpInitCtrls.dwSize;
             ICC_LISTVIEW_CLASSES -> lpInitCtrls.dwICC;
             lpInitCtrls.ptr -> InitCommonControlsEx;
             lpInitCtrls.ptr -> free;
          else
             InitCommonControls;
         if);
      else
         InitCommonControls;
     if);
  #);

lstrcpy: External
  (# charptr1, charptr2: @integer;
     result_ptr: @integer;
  enter (charptr1, charptr2)
  do 'lstrcpyA' -> callStd;
  exit result_ptr
  #);

lstrcat: External
  (# charptr1, charptr2: @integer;
     result_ptr: @integer;
  enter (charptr1, charptr2)
  do 'lstrcatA' -> callStd;
  exit result_ptr
  #);
  
listViewNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# processCommand:
            (# type: @integer;
               id: @integer;
               index: @integer;
               windowID: @integer;
            do false -> didSomething;
            #);
          processNotify:
            (# hwndFrom, idCtrl, code1: @integer;
               uChanged,uNewState,uOldState,iItem: @integer;
               uid: @integer;
               strAddr: @integer;
               theText: ^text;
               tempText: @cstring;
               iSubItem: @integer;
               theItem: ^listItem;
               theMask: @integer;
               doProcess: @integer;
            do info.lParam -> TOS'%adrGetLong' -> hwndFrom;
               info.lParam+4 -> TOS'%adrGetLong' -> idCtrl;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               (if code1
                //LVN_GETDISPINFO then
                   (* LV_DISPINFO *)
                   info.lParam+12 -> TOS'%adrGetLong' -> theMask;
                   (theMask,LVIF_TEXT) -> tos'%and' -> doProcess;
                   (if doProcess<>0 then
                       info.lParam+44 -> TOS'%adrGetLong' -> uid;
                       info.lParam + 32 -> TOS'%adrGetLong' -> strAddr;
                       uid -> private.findListItem -> theItem[];  
                       info.lParam+20 -> TOS'%adrGetLong' -> iSubItem;
                       
                       (if theItem[]<>NONE then
                           (if (iSubItem>=0) and (iSubItem<=theItem.private.subItems.range)
                               then
                               theItem.private.subItems[iSubItem][] -> theText[];
                               (if theText[]<>NONE then
                                   theText[] -> tempText.set;
                                   (strAddr, tempText) -> lstrcpy;
                                   tempText.free;
                               if);
                           if);
                       if);
                    if);
                //LVN_ITEMCHANGED then
                   info.lParam+28 -> TOS'%adrGetLong' -> uChanged;
                   (if uChanged>0 then
                       info.lParam+20 -> TOS'%adrGetLong' -> uNewState;
                       (uNewState,LVIS_SELECTED) -> tos'%and' -> uNewState;
                       
                       info.lParam+24 -> TOS'%adrGetLong' -> uOldState;
                       (uOldState,LVIS_SELECTED) -> tos'%and' -> uOldState;
                       
                       (if (uNewState>0) and (uOldState=0) then
                           info.lParam+40 -> TOS'%adrGetLong' -> uid;
                           uid -> private.items.doCallOnSelect;
                       if);
                    if);
                //NM_DBLCLK then
                   processNM_Dblclk;
                   
                //NM_CLICK then
                   1 -> info.button;
                   this(listView).theEventHandler.onMouseUp;
                   
                //NM_RCLICK then
                   3 -> info.button;
                   processNM_RCLICK;
                   
                   (* //NM_CUSTOMDRAW then
                    * CDRF_DODEFAULT -> info.result;
                    * processNM_CUSTOMDRAW;
                    * true -> didSomething; 
                    *)
                                      
                //LVN_COLUMNCLICK then
                   (* NM_LISTVIEW *)
                   (*The user clicked a column header - sort by this criterion.*)
                   info.lParam+16 -> TOS'%adrGetLong' -> iSubItem;
                   (hwndFrom,private.ListViewCompareProcAddress,iSubItem)
                     -> ListView_SortItems;
                   
                (* //LVN_KEYDOWN then
                 *  processLVN_KEYDOWN;
                 *)
               if);
               false -> didSomething;
            #);
          
          processNM_CUSTOMDRAW:
            (# ptr2CustD: @NMLVCUSTOMDRAW_ext;
               theTextStyle: ^textStyle;
               textColor: @color;
               textBkColor: @color;
               dwItemSpec: @integer;
            do custdrawL:
                 (# 
                 do screen.newline; 
                    '>>>>>>>>> processNM_CUSTOMDRAW' -> screen.putline;
                    'NM_CUSTOMDRAW' -> screen.putline; 
                    info.lParam -> ptr2CustD.ptr;
                    (* CDDS_PREPAINT is at the beginning of the paint 
                     * cycle. You implement custom draw by returning the 
                     * proper value. In this case, we are requesting 
                     * item-specific notifications.
                     *)
                    
                    'ptr2CustD.nmcd.dwDrawStage = ' -> screen.putText;
                    ptr2CustD.nmcd.dwDrawStage -> putint; newline;
                    
                    info.lParam+12 -> TOS'%adrGetLong' -> putint; newline;
                    
                    (if (ptr2CustD.nmcd.dwDrawStage = CDDS_PREPAINT) then
                        
                        'CDDS_PREPAINT' -> screen.putLine;
                        
                        (* Request prepaint notifications for each item. *)
                        (* CDRF_NOTIFYITEMDRAW *) 
                        CDRF_NOTIFYSUBITEMDRAW -> info.result;
                        leave custdrawL;
                    if);
                    
                    (if (ptr2CustD.nmcd.dwDrawStage = CDDS_SUBITEM) then
                        'CDDS_SUBITEM' -> screen.putLine;
                    if);
                        
                    (* Because we returned CDRF_NOTIFYITEMDRAW in response
                     * to CDDS_PREPAINT, CDDS_ITEMPREPAINT is sent when 
                     * the control is about to paint an item.         
                     *)
                    (if (ptr2CustD.nmcd.dwDrawStage = CDDS_ITEMPREPAINT) then
                        (*
                         * To change the font, select the desired font into
                         * the provided HDC. We're changing the font for 
                         * every third item in the control, starting with 
                         * item zero.
                         *)
                        ptr2CustD.nmcd.dwItemSpec -> dwItemSpec;
                        (if ((dwItemSpec mod 3)=0) then 
                            &textStyle[] -> theTextStyle[];
                            'Arial' -> theTextStyle.name;
                            10 -> theTextStyle.size;
                            textFaces.bold -> theTextStyle.face;
                            theTextStyle.create;
                            (ptr2CustD.nmcd.hdc,theTextStyle.textStyleID) 
                              -> SelectObject;
                         else
                            CDRF_DODEFAULT -> info.result;
                            leave custdrawL;
                        if);
                        (*
                         * To change the text and background colors in a 
                         * list view control, set the clrText and 
                         * clrTextBk members of the NMLVCUSTOMDRAW 
                         * structure to the desired color.
                         * This differs from most other controls that 
                         * support CustomDraw. To change the text and 
                         * background colors for the others, call 
                         * SetTextColor and SetBkColor on the provided HDC.
                         *)  
                        (65280, 65280,     0) -> textColor;
                        (    0, 65280,     0) -> textBkColor;
                        textColor[] -> makeColorRef -> ptr2CustD.clrText;
                        textBkColor[] -> makeColorRef -> ptr2CustD.clrTextBk;
                        'ptr2CustD.iSubItem = ' -> screen.putText;
                        ptr2CustD.iSubItem -> putint; newline;
                        (*
                         * We changed the font, so we're returning 
                         * CDRF_NEWFONT. This tells the control to 
                         * recalculate the extent of the text.
                         *)            
                        CDRF_NEWFONT -> info.result;
                    if);
                    
                    '<<<<<<<<<< processNM_CUSTOMDRAW' -> screen.putline;
                    screen.newline; 
                 #);   
            #);
          
          processLVN_KEYDOWN:
            (# theItem: ^listItem;
               theNMLVKEYDOWN_ext: @NMLVKEYDOWN_ext;
            do 
               info.lParam -> theNMLVKEYDOWN_ext.ptr;
               theNMLVKEYDOWN_ext.wvKey -> info.key;
               selection.first -> theItem[];
               (if theItem[]<>NONE then
                   theItem.theEventHandler.onKeyDown;
               if);
               NONE -> theItem[];
            #);
          
          processNM_RCLICK:
            (# theLV_HITTESTINFO_ext: @LV_HITTESTINFO_ext;
               idx: @integer;
               ntp: @ntPOINTextR;
               lvI: @LV_ITEMA_ext;
               theItem: ^listItem;
               listViewId: @integer;
            do 8 -> malloc -> ntp.ptr;
               sizeOf_LV_HITTESTINFO -> malloc -> theLV_HITTESTINFO_ext.ptr;
               (if (theLV_HITTESTINFO_ext.ptr<>0) and (ntp.ptr<>0) then
                   this(listView).interfaceObjectId -> listViewId;
                   mouse.globalPosition -> (ntp.x, ntp.y);
                   (listViewId,ntp.ptr) -> ScreenToClient;
                   (ntp.x, ntp.y) -> theLV_HITTESTINFO_ext.pt;
                   
                   (interfaceObjectId, theLV_HITTESTINFO_ext.ptr) 
                     -> ListView_HitTest_ext -> idx;
                   
                   (if idx<>-1 then
                       sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
                       (if lvI.ptr<>0 then
                           (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                           idx -> lvi.iItem;
                           LVIF_PARAM -> lvi.mask;
                           (listViewId,lvI.ptr) -> ListView_GetItem;
                           lvI.lParam -> private.findListItem -> theItem[];
                           lvI.ptr -> free;
                        else
                           'Failled to allocate LV_ITEM  in processNM_RCLICK.'
                             -> resourceAllocationError;
                       if);
                       
                       (if theItem[]<>NONE then
                           mouse.globalPosition -> theItem.onRMouseUp;
                       if);
                    else
                       this(listView).theEventHandler.onMouseUp;
                   if);
                   
                   (* Clean up *);
                   theLV_HITTESTINFO_ext.ptr -> free;
                   ntp.ptr -> free;
                   
                else
                   'Failled to allocate LV_HITTESTINFO while processing NM_RCLICK.'
                     -> resourceAllocationError;
               if);

            #);
          
          processNM_Dblclk:
            (# lvI: @LV_ITEMA_ext;
               itemInx: @integer;
               theItem: ^listItem;
               state: @integer;
               res: @integer; errMsg: ^text;
            do (interfaceObjectId, -1, LVNI_SELECTED) 
                 -> ListView_GetNextItem ->itemInx;
               (if itemInx<>-1 then
                   (interfaceObjectID,itemInx,LVIS_SELECTED)
                     -> ListView_GetItemState -> state;
                   (if state<>0 then
                       sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
                       (if lvI.ptr<>0 then
                           (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                           itemInx -> lvi.iItem;
                           LVIF_PARAM -> lvi.mask;
                           (interfaceObjectId,lvI.ptr) 
                             -> ListView_GetItem 
                             -> res;
                           (if res=0 then
                               &text[] -> errMsg[];
                               'ListView_GetItem failed. Error = ' 
                                 -> errMsg.putText;
                               GetLastError -> errMsg.putInt; 
                               errMsg[] -> apiError;
                           if);
                           lvI.lParam -> private.findListItem -> theItem[];
                           lvI.ptr -> free;
                        else
                           'Failled to allocate LV_ITEM  while processing NM_Dblclk.'
                             -> resourceAllocationError;
                       if);
                       (if theItem[]<>NONE then
                           theItem.onDoubleClick;
                       if);
                   if);
               if);
            #);
          
          CalcStringEllipsis:
            (# 
               szEllipsis: @cString;
               sizeString: @ntPOINTextR;
               sizeEllipsis: @ntPOINTextR;
               lpszTemp: @cString;
               fSuccess: @boolean;
               cbString: @integer;
               hdc,cchMax,uColWidth: @integer;
               lpszString: ^text;
               
            enter (hdc, lpszString[],cchMax, uColWidth)
            do
               (* Adjust the column width to take into account the edges *)
               uColWidth - 4 -> uColWidth;
               
               '...' -> szEllipsis.set;
               
               lpszString[] -> lpszTemp.set;
               8 -> malloc -> sizeString.ptr;
               8 -> malloc -> sizeEllipsis.ptr;
               
               (if (lpszTemp<>0) and (sizeString.ptr<>0) and (sizeEllipsis.ptr<>0) 
                   and (szEllipsis<>0) then
                   (* Get the width of the string in pixels *)
                   lpszTemp.length -> cbString;
                   (if ((hdc, lpszTemp, cbString, sizeString.ptr)->GetTextExtentPoint32)<>0
                       then
                       (* If the width of the string is greater than the column width shave
                        * the string and add the ellipsis *)
                       (if (sizeString.x > uColWidth) then
                           (hdc, szEllipsis, szEllipsis.length,sizeEllipsis.ptr) 
                             -> GetTextExtentPoint32;
                           
                           L:
                             (# 
                             do (if (cbString > 0) then
                                    cbString - 1 -> cbString;
                                    
                                    (cbString,ascii.nul) -> lpszTemp.inxPut;
                                    
                                    (hdc, lpszTemp, cbString, sizeString.ptr)
                                      ->GetTextExtentPoint32;
                                    
                                    (if ((sizeString.x + sizeEllipsis.x) <= uColWidth) then
                                        (* The string with the ellipsis finally fits, now 
                                         * make sure there is enough room in the string for 
                                         * the ellipsis *)
                                        (if (cchMax >= (cbString + szEllipsis.length)) then
                                            (* Concatenate the two strings and break out of 
                                             * the loop *)
                                            
                                            lpszString.clear;
                                            lpszTemp.get -> lpszString.append;
                                            '...' -> lpszString.append;
                                            
                                            TRUE -> fSuccess;
                                            leave L
                                        if);
                                    if);
                                    restart L
                                 else
                                    leave L
                                if);
                             #);
                        else
                           (* No need to do anything, everything fits great. *)
                           TRUE -> fSuccess;
                       if);
                   if);
                   (* CleanUp *)
                   szEllipsis.free;
                   sizeEllipsis.ptr -> free;
                   sizeString.ptr -> free;
                   lpszTemp.free;
                else
                   'Failed to allocate structs in CalcStringEllipsis.'
                     -> resourceAllocationError;
               if);
            exit fSuccess
            #); 
          
          
          DrawItemColumn:
            (# 
               hdc: @integer;
               theText: ^text;
               szString: @cString;
               prcClip: ^ntRECTextR;
            enter (hdc,theText[], prcClip[])
            do
               (* Check to see if the string fits in the clip rect.  If not, truncate
                * the string and add "...". *)
               theText.copy -> theText[];
               (hdc, theText[], theText.length, prcClip.right - prcClip.left) 
                 -> CalcStringEllipsis; 
               theText[] -> szString.set;
               
               (* print the text *)
               (hdc, prcClip.left + 2, prcClip.top + 1, ETO_CLIPPED %Bor ETO_OPAQUE,
               prcClip.ptr, szString, szString.length, 0)
                 -> ExtTextOut;
               
               szString.free;
            #);
          
          processDrawItem:
            (# itemAction, itemID, itemState,hdc,top, left, right, bottom: @integer;
               lvI: @LV_ITEMA_ext;
               listViewId: @integer;
               theItem: ^listItem;
               cxImage, cyImage: @integer;
               uiFlags: @integer;
               himl: @integer;
               uFirstColWidth: @integer;
               rcClip: @ntRECTextR;
               
               (* For custom draw. *)
               theTextStyle: ^textStyle;
               textColor,textBgColor: ^color;
               custDrawAction: @integer;
               origHFont: @integer;
               
               setColorAndFont:
                 (# 
                 do (* Item selected ?? *)
                    (* (if not ((itemState %Band ODS_SELECTED) > 0) then *)
                        (if textColor[]<> NONE then
                            (hdc,(textColor[] -> makeColorRef)) -> SetTextColor;
                        if);
                        (if textBgColor[]<>NONE then
                            (hdc,(textBgColor[] -> makeColorRef)) -> SetBkColor;
                        if);
                            (* if); *)
                    (if theTextStyle[]<>NONE then
                        theTextStyle.create;
                        (if origHFont=0 then
                            (hdc,theTextStyle.textStyleID) 
                              -> SelectObject -> origHFont;;
                         else
                            (hdc,theTextStyle.textStyleID) -> SelectObject;
                        if);
                    if);
                 #);
               
               resetColorAndFont:
                 (# 
                 do (* Item selected ?? *)
                    (if ((itemState %Band ODS_SELECTED) > 0)
                        and
                        (this(listView).interfaceObjectID=GetFocus) then
                        
                        (hdc,(COLOR_HIGHLIGHTTEXT->GetSysColor)) -> SetTextColor;
                        (hdc,(COLOR_HIGHLIGHT->GetSysColor)) -> SetBkColor;
                        uiFlags %Bor ILD_BLEND50 -> uiFlags;
                     else
                        (hdc,(COLOR_WINDOWTEXT->GetSysColor)) -> SetTextColor;
                        (hdc,(COLOR_WINDOW->GetSysColor)) -> SetBkColor;
                    if);
                    (if origHFont<>0 then
                        (hdc,origHFont) -> SelectObject;
                        0 -> origHFont;
                    if);
                 #);
            do 
               (if ((info.lParam -> TOS'%adrGetLong') = ODT_LISTVIEW) then
                   
                   sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
                   (if lvI.ptr<>0 then
                       (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                       
                       info.lParam+8 -> TOS'%adrGetLong' -> itemID;
                       info.lParam+12 -> TOS'%adrGetLong' -> itemAction;
                       info.lParam+16 -> TOS'%adrGetLong' -> itemState;
                       
                       info.lParam+24 -> TOS'%adrGetLong' -> hdc;
                       
                       info.lParam+28 -> TOS'%adrGetLong' -> left;
                       info.lParam+32 -> TOS'%adrGetLong' -> top;
                       info.lParam+36 -> TOS'%adrGetLong' -> right;
                       info.lParam+40 -> TOS'%adrGetLong' -> bottom;
                       
                       ILD_TRANSPARENT -> uiFlags;
                       
                       (if itemAction
                        //ODA_DRAWENTIRE
                        //ODA_FOCUS
                        //ODA_SELECT then
                           
                           this(listView).interfaceObjectId -> listViewId;
                           itemID -> lvi.iItem;
                           LVIF_PARAM %Bor LVIF_IMAGE %Bor LVIF_STATE -> lvi.mask;
                           0 -> lvi.iSubItem;
                           (listViewId,lvI.ptr) -> ListView_GetItem;
                           lvI.lParam -> private.findListItem -> theItem[];
                           
                           (* Item selected ?? *)
                           (if ((itemState %Band ODS_SELECTED) > 0)
                               and
                               (this(listView).interfaceObjectID=GetFocus) then
                               (hdc,(COLOR_HIGHLIGHTTEXT->GetSysColor)) -> SetTextColor;
                               (hdc,(COLOR_HIGHLIGHT->GetSysColor)) -> SetBkColor;
                               uiFlags %Bor ILD_BLEND50 -> uiFlags;
                            else
                               (hdc,(COLOR_WINDOWTEXT->GetSysColor)) -> SetTextColor;
                               (hdc,(COLOR_WINDOW->GetSysColor)) -> SetBkColor;
                           if);
                           
                           himlSmall -> himl;
                           (if himl<>0 then
                               (himl, lvi.iImage, hDC,left, top,uiFlags)
                                 -> ImageList_Draw;
                               
                               (himl, @@cxImage, @@cyImage) -> ImageList_GetIconSize; 
                           if);
                           
                           (if private.columnWidths.range>0 then
                               private.columnWidths[1] - cxImage -> uFirstColWidth;
                            else
                               40 -> uFirstColWidth;
                           if);
                           16 -> malloc -> rcClip.ptr;
                           (if rcClip.ptr<>0 then
                               left + cxImage -> rcClip.left;
                               (if private.columnWidths.range>0 then
                                   left + private.columnWidths[1] -> rcClip.right;
                                else
                                   left + 40 -> rcClip.right;
                               if);
                               top -> rcClip.top;
                               bottom -> rcClip.bottom;
                               
                               (if theItem[]<>NONE then
                                   
                                   (theItem[],0) 
                                     -> onCustumDraw 
                                     -> (custDrawAction,theTextStyle[],textColor[],textBgColor[]);
                                   
                                   (if custDrawAction<>CDRF_DODEFAULT then
                                       setColorAndFont;
                                   if);
                                   
                                   (hDC, theItem.private.name[],rcClip[])
                                     -> DrawItemColumn;
                                   
                                   (if custDrawAction<>CDRF_DODEFAULT then
                                       resetColorAndFont;
                                   if);
                                   
                                   (for i:theItem.private.subItems.range repeat
                                        
                                        rcClip.right -> rcClip.left;
                                        rcClip.left + private.columnWidths[i+1] -> rcClip.right;
                                        (if theItem.private.subItems[i][]<>NONE then
                                            
                                            (theItem[],i) 
                                              -> onCustumDraw 
                                              -> (custDrawAction,theTextStyle[],textColor[],textBgColor[]);
                                            
                                            (if custDrawAction<>CDRF_DODEFAULT then
                                                setColorAndFont;
                                            if);
                                            
                                            (hDC,theItem.private.subItems[i][],rcClip[])
                                              -> DrawItemColumn; 
                                            
                                            (if custDrawAction<>CDRF_DODEFAULT then
                                                resetColorAndFont;
                                            if);
                                        if);
                                   for);
                                   
                                   (* If we changed the colors for the selected item, undo
                                    * it *)
                                   (if (itemState %Band ODS_SELECTED)>0 then
                                       (* Set the text background and foreground colors *)
                                       (hDC, COLOR_WINDOWTEXT->GetSysColor) -> SetTextColor;
                                       (hDC, COLOR_WINDOW->GetSysColor) -> SetBkColor;
                                   if);
                                   
                                   (* If the item is focused, now draw a focus rect around the 
                                    * entire row *)
                                   (if (itemState %Band ODS_FOCUS)>0 then
                                       (* Adjust the left edge to exclude the image *)
                                       left + cxImage -> rcClip.left;
                                       top -> rcClip.top;
                                       right -> rcClip.right;
                                       bottom -> rcClip.bottom;
                                       
                                       (* Draw the focus rect *)
                                       (hDC, rcClip.ptr) -> DrawFocusRect;
                                   if);
                                   
                                else
                                   'theitem is none for lvI.lParam = ' -> screen.putText;
                                   lvI.lParam -> putint; newline;
                                   'and itemID = ' -> puttext; itemID -> putint; newline;
                               if);
                               
                               rcClip.ptr -> free;
                               0 -> rcClip.ptr;
                            else
                               'Failed to allocate clipping rect while processing WM_DRAWITEM.'
                                 -> resourceAllocationError;
                           if);
                       if);
                       lvI.ptr -> free;
                    else
                       'Failed to allocate LV_ITEM while processing WM_DRAWITEM.'
                         -> resourceAllocationError;
                   if);
               if);    
            #);
          
          processMeasureItem:
            (# CtlType,itemHeight: @integer;
               tm: @TEXTMETRIC_extR;
               hdc: @integer;
               hFont: @integer;
               hwndLV: @integer;
               iconHeight: @integer;
            do 
               this(listView).interfaceObjectId -> hwndLV;
               info.lParam -> TOS'%adrGetLong' -> CtlType;
               
               (* Make sure the control is the listview control *)
               (if (CtlType = ODT_LISTVIEW) then
                   
                   (* Get the font the control is currently using *)
                   (hwndLV, WM_GETFONT, 0, 0) -> SendMessage -> hFont;
                   sizeOf_TEXTMETRIC -> malloc -> tm.ptr;
                   (if tm.ptr<>0 then
                       (* Set the font of the DC to the same font the control is 
                        * using *)
                       hwndLV -> GetDC -> hdc;
                       (hdc, hFont) -> SelectObject;
                       
                       (* Get the height of the font used by the control *)
                       (if ((hdc, tm.ptr) -> GetTextMetrics)<>0 then
                           
                           (* Add a little extra space between items *)
                           tm.tmHeight + 1 -> itemHeight;
                           
                           (* Make sure there is enough room for the images *)
                           SM_CXSMICON -> GetSystemMetrics -> iconHeight;
                           (if (itemHeight < (iconHeight + 1)) then
                               iconHeight + 1 -> itemHeight;
                           if);
                           itemHeight %putLongAt (info.lParam+16);
                       if);
                       
                       (* Clean up *)
                       (hwndLV, hdc) -> ReleaseDC;
                       tm.ptr -> free;
                       0 -> tm.ptr;
                    else
                       'Failled to allocate TEXTMETRIC while processing WM_MEASUREITEM.'
                         -> resourceAllocationError;
                   if);
               if);
               true -> didSomething;
            #);
          
          didSomething: @boolean;
          hwndItem: @integer;
       do true -> didSomething;
          (if info.message 
              (* //WM_COMMAND then processCommand;            *)
           //WM_NOTIFY then 
              processNotify;
           //WM_DRAWITEM then
              info.lParam+20 -> TOS'%adrGetLong' -> hwndItem;
              (if hwndItem=this(listView).interfaceObjectID then
                  processDrawitem;
               else
                  false -> didSomething;
              if);
           //WM_MEASUREITEM then 
              processMeasureItem;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
          false -> info.handled;
       #);
  #);

listViewMethods: windowItemMethods
  (# 
     dispatchMessage::
       (# didSomething: @boolean;
          
          processNotify:
            (# hwndFrom, idCtrl, code1: @integer;
               iItem: @integer;
               
            do info.lParam -> TOS'%adrGetLong' -> hwndFrom;
               info.lParam+4 -> TOS'%adrGetLong' -> idCtrl;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               
               false -> didSomething;
               (if code1
                //HDN_ENDTRACK then
                   info.lParam+12 -> TOS'%adrGetLong' -> iItem;
                   (this(listView).interfaceObjectId,WM_UPDATEHEADERWIDTH, hwndFrom,iItem)
                    -> PostMessage;
                   true -> didSomething;
                   (if private.dragfullwindows then
                       true -> update; 
                   if);
                //HDN_ITEMCHANGED
                //HDN_ITEMCHANGEDW then
                   info.lParam+12 -> TOS'%adrGetLong' -> iItem;
                   (this(listView).interfaceObjectId,WM_UPDATEHEADERWIDTH, hwndFrom,iItem)
                    -> PostMessage; 
                   true -> didSomething;
               if);
               
            #);
          
          processUpdateHeaderWidth:
            (# theHD_ITEM_extR: @HD_ITEM_extR;
            do 
               28 -> malloc -> theHD_ITEM_extR.ptr;
               (if theHD_ITEM_extR.ptr<>0 then
                   HDI_WIDTH -> theHD_ITEM_extR.mask;
                   (info.wParam,info.lParam,theHD_ITEM_extR.ptr) -> Header_GetItem;
                   theHD_ITEM_extR.cxy -> private.columnWidths[info.lParam+1]; 
                   theHD_ITEM_extR.ptr -> free;
                   true -> didSomething;
                   (if (not private.dragfullwindows) then
                       true -> update; 
                   if); 
                else
                   'Failled to allocate HD_ITEM  while processing WM_UPDATEHEADERWIDTH.'
                     -> resourceAllocationError;
               if);
            #);
       do  
          (if info.message
           //WM_NOTIFY then processNotify 
           //WM_UPDATEHEADERWIDTH then processUpdateHeaderWidth;
           if); 
          didSomething or info.handled -> info.handled;
       #);
  #);

himlLarge:        (* image list for icon view *)
  (# exit private.largeImageList.theHandle #);

himlSmall:       (* image list for other views *)
  (# exit private.smallImageList.theHandle #);

SM_CXSMICON: (# exit 49 #);
SM_CYSMICON: (# exit 50 #);

bitComp: 
  (# style: @integer;
     mask: @integer;
  enter (style, mask)
  do style %Band (%Bnot mask) -> style;
  exit style
  #);

-- GUIEnvListViewSelectionFirst: doPart --
do (# lvI: @LV_ITEMA_ext;
      itemInx: @integer;
      state: @integer;
      listViewId: @integer;
   do this(listView).interfaceObjectId -> listViewId;
      (listViewId, -1, LVNI_SELECTED) 
        -> ListView_GetNextItem ->itemInx;
      (if itemInx<>-1 then                    
          (listViewId,itemInx,LVIS_SELECTED)
            -> ListView_GetItemState -> state;
          (if state<>0 then
              sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
              (if lvI.ptr<>0 then
                  (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                  itemInx -> lvi.iItem;
                  LVIF_PARAM -> lvi.mask;
                  (listViewId,lvI.ptr) -> ListView_GetItem;
                  lvI.lParam -> private.findListItem -> theItem[];
                  lvI.ptr -> free;
               else
                  'Failled to allocate LV_ITEM  in selection.first.'
                    -> resourceAllocationError;
              if);
          if);
      if);
   #);
   
-- GUIEnvListViewSelectionClear: doPart --
do scan
   (# 
   do current.deselect;
   #);
   
-- GUIEnvListViewSelectionScan: doPart --
do (# lvI: @LV_ITEMA_ext;
      itemInx: @integer;
      theItem: ^listItem;
      state: @integer;
      listViewId: @integer;

   do this(listView).interfaceObjectId -> listViewId;
      -1 -> itemInx;
      scanL:
        (# 
        do (listViewId, itemInx, LVNI_SELECTED) 
             -> ListView_GetNextItem ->itemInx;
           (if itemInx<>-1 then                    
               (listViewId,itemInx,LVIS_SELECTED)
                 -> ListView_GetItemState -> state;
               (if state<>0 then
                   sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
                   (if lvI.ptr<>0 then
                       (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                       itemInx -> lvi.iItem;
                       LVIF_PARAM -> lvi.mask;
                       (listViewId,lvI.ptr) -> ListView_GetItem;
                       lvI.lParam -> private.findListItem -> theItem[];
                       lvI.ptr -> free;
                    else
                       'Failled to allocate LV_ITEM  in selection.scan.'
                         -> resourceAllocationError;
                   if);
                   (if theItem[]<>NONE then
                       theItem[] -> current[];
                       inner scan;
                   if);
               if);
               restart scanL
           if);
        #);
      
   #)
   
-- GUIEnvListViewNoOfItems: doPart --
do private.items.size -> value;
   
-- GUIEnvListViewScan: doPart --
do (if private.items[]<>NONE then
       private.items.scan
       (# 
       do current[] -> THIS(scan).current[];
          inner scan;
       #);
   if);
   
-- GUIEnvListViewClear: doPart --
do interfaceObjectID->ListView_DeleteAllItems;
   private.items.clear;
   private.items.init;

-- setLayOutStyle: doPart --
do (interfaceObjectID,lStyle) -> SetView;  
   
-- getLayOutStyle: doPart --
do (# listViewId: @integer;
   do interfaceObjectID -> listViewId;
      (listViewId, GWL_STYLE) -> GetWindowLong -> lStyle; 
      (lStyle,LVS_TYPEMASK) -> tos'%and' -> lStyle;
   #);
   
   
   
-- GUIEnvListViewAddColumn: doPart --
do (# lvC: @LV_COLUMNA;
      szText: @cString;
      columnInx: @integer;
      listviewID: @integer;
      result: @integer;
   do interfaceObjectID -> listviewID;
      LVCF_FMT + LVCF_WIDTH + LVCF_TEXT + LVCF_SUBITEM -> lvC.mask; 
      LVCFMT_LEFT -> lvC.fmt;  (* left-align column *)
      theColumnInfo.width -> lvC.cx;        
      (* Add the column. *)
      private.nextColumnIndex -> columnInx;
      
      columnInx -> lvC.iSubItem; 
      (if theColumnInfo.title[]<>NONE then
          theColumnInfo.title[] -> szText.set;
       else
          '' -> szText.set;
      if);
      (if szText.charPtr<>0 then
          szText.charPtr -> lvC.pszText;
          (listviewID, columnInx, lvC[]) 
            -> ListView_InsertColumn -> result;
          (if result=-1 then
              'ListView_InsertColumn failed. Error= ' -> puttext;
              GetLastError -> putint; newline;
           else
              lvC.cx -> private.columnWidths[columnInx+1];
          if);
          szText.charPtr -> free;
      if);
   #);      
   
-- GUIEnvListViewAddListItem: doPart --
do (# lvI: @LV_ITEMA_ext;		(* list view item structure *)
      cstrLabel: @cstring;
      aLabel: ^text;
      inx: @integer; (* Index of this(listItem). *)
      listViewId: @integer;
      result: @integer;
   do interfaceObjectID -> listViewId;
      (if theItem[]<>NONE then
          theItem[] -> getPatternName -> theItem.private.name[];
          theItem.open;
          (if not 
              (theItem[] -> this(listView).private.items.has)
              then
              this(listView).private.items.size  -> inx;
              
              sizeOf_LV_ITEMA_ext -> malloc -> lvI.ptr;
              (if lvI.ptr<>0 then
                  (lvI.ptr,0,sizeOf_LV_ITEMA_ext)->memset;
                  theItem[] -> this(listView).private.items.insert;
                  LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM + LVIF_STATE
                    -> lvI.mask;
                  0 -> lvI.state; 
                  0 -> lvI.stateMask; 
                  
                  theItem.private.name[] -> cstrLabel.set;
                  cStrLabel.charPtr -> lvI.pszText;
                  (if cStrLabel.charPtr=0 then
                      'cStrLabel.charPtr=0' -> screen.putline;
                  if);
                  
                  theItem.private.imageID -> lvI.iImage;    (* image list index *)
                  inx -> lvI.iItem; (* items index in the listview control*)
                  0 -> lvI.iSubItem;
                  0 -> lvI.lParam;
                  this(listView).private.getUid->theItem.private.uid->lvI.lParam;
                  
                  (listViewId, lvI.ptr) -> ListView_InsertItem_ext;
                  cstrLabel.free;
                  lvI.ptr -> free;
               else
                  'Failled to allocate LV_ITEM  while adding listItem.'
                    -> resourceAllocationError;
              if);
          if);
          
          TRUE -> theItem.private.isOpen;
      if);
   #); 
   
-- GUIEnvListViewCreate: doPart --
do (# wStyle: @integer;
   do InitListViewControl;
      
      true -> this(windowItem).private.borderHandledLocally;
      
      private.ListViewCompareProc## 
        -> private.std16x3toint  (* private.makeCBF *)
        -> private.ListViewCompareProcAddress;                
      
      &listViewNotiMethods[] -> theNotiMethods;
      &listViewMethods[] -> theMethods;
      
      isSubClass  -> windowItemClassStatus; 
      (* isStandardClass -> windowItemClassStatus; *)
      'SysListView32' -> windowItemClass;
      WS_EX_CLIENTEDGE -> windowItemExStyle; 
      (if report_view then
          LVS_REPORT -> wStyle; 
       else
          (if icon_view then
              LVS_ICON -> wStyle; 
           else
              (if smallIcon_view then
                  LVS_SMALLICON -> wStyle; 
               else
                  (if list_view then
                      LVS_LIST -> wStyle; 
                   else
                      LVS_LIST -> wStyle; 
                      '*** ERROR: At least one of report_view, smallIcon_view, icon_view, or list_view must be TRUE to create the list view.' -> screen.putLine;
                  if);
              if);
          if);
      if);
      
      (if not multipleSelection then
          LVS_SINGLESEL %Bor wStyle -> wStyle;
      if);
      
      wStyle %Bor WS_BORDER %Bor LVS_SHOWSELALWAYS  
        -> windowItemStyle;
      
      (if report_view then
          wStyle %Bor LVS_OWNERDRAWFIXED -> windowItemStyle;
      if);
      
      inner create;
   #);

   
-- GUIEnvListViewOpen: doPart --
do private.open;
   inner;
   true -> border.visible;
   borderStyles.shadowIn -> border.style;
   (interfaceObjectID,initialRange) -> ListView_SetItemCount;
   (if (private.dllMajor>=4) and (private.dllMinor>=70) then
       (interfaceObjectID,LVM_SETEXTENDEDLISTVIEWSTYLE,0,LVS_EX_FULLROWSELECT )
         -> SendMessage;
   if);
   
   (if (interfaceObjectID -> isFullDragSet)<>0 then
       true -> private.dragfullwindows;
   if);
   
-- GUIEnvListViewClose: doPart --
do inner;
   private.close;
   
-- GUIEnvListViewPrivate: descriptor --
(# 
   (* Version of commctrl.dll *)
   dllMajor, dllMinor: @int32u;
   getDllVersion:
     (# 
     do (@@dllMajor,@@dllMinor) -> GetComCtlVersion;
     #);
   
   ListViewCompareProcAddress: @integer;
   std16x3toint: external
     (# func: ##ListViewCompareProc;
        int: @integer;
     enter func##
     do 'copyinput'->callC
     exit int
     #);
   
   makeCBF: External
     (# pat: ##External;
        cb: @integer;
     enter pat##
     exit cb
    #);
    
   
   freeCBF: External
     (# cbf: @integer;
     enter cbf
     #);
   
   open:
     (# 
     do icons.init;
        items.init;
        0 -> columnIndex;
        0 -> columnWidths.new;
        0 -> guid;
     #);
   
   close:
     (# 
     do FALSE -> imageListInitialized;
        ListViewCompareProcAddress -> freeCBF;
        icons.clear;
        items.clear;
        0 -> columnIndex;
        0 -> columnWidths.new;
        0 -> guid;
     #);
   
   dragfullwindows: @boolean;
   
   columnIndex: @integer; (* Zero based *)
   nextColumnIndex: integerValue
     (# 
     do columnIndex -> value;
        columnIndex + 1 -> columnIndex;
        1 -> columnWidths.extend;
     #);
   columnWidths: [0]@integer;
   
   ListViewCompareProc: external
     (# lParam1, lParam2, lParamSort: @integer;
        theItem1,theItem2: ^listItem;
        subItem1, subItem2: ^text;
        result: @integer;                       
     enter (lParam1, lParam2, lParamSort)
     do StdExternalEntry;
        
        lParam1 -> private.findListItem -> theItem1[];
        lParam2 -> private.findListItem -> theItem2[];
        
        (if (theItem1[]<>NONE) and (theItem2[]<>NONE) then
            (if lParamSort
             //0 then
                (if theItem1.private.name[] -> theItem2.private.name.equal then
                    0 -> result;
                 else
                    (if theItem1.private.name[]->theItem2.private.name.less then
                        -1 -> result;
                     else
                        1 -> result;
                    if);
                if);
                (* //1 then
                 *                 (if theItem1.type = theItem2.type then
                 *                     0 -> result;
                 *                  else
                 *                     (if theItem1.type < theItem2.type then
                 *                         -1 -> result;
                 *                      else
                 *                         1 -> result;
                 *                     if);  
                 *                 if);
                 *)
             else
                (if theItem1.private.subItems.range>= lParamSort then
                    theItem1.private.subItems[lParamSort][] -> subItem1[];
                if);
                (if theItem2.private.subItems.range>= lParamSort then
                    theItem2.private.subItems[lParamSort][] -> subItem2[];
                if);
                (if (subItem1[]<>NONE) and (subItem2[]<>NONE) then
                    (if subItem1[] -> subItem2.equal then
                        0 -> result;
                     else
                        (if subItem1[]->subItem2.less then
                            -1 -> result;
                         else
                            1 -> result;
                        if);
                    if);
                if);
            if);
        if);
     exit result   
     #);
   
   guid: @integer;
   getUid:
     (# do guid + 1 -> guid;
     exit guid
     #);
   largeImageList, smallImageList: @imageList;
   
   iconElm:
     (# theIcon: ^pixmap;
        index: @integer;
     #);
   icons: @sequence
     (# element:: iconElm;

        init::
          (# do 0 -> currentIndex; #);
        
        currentIndex: @integer; (* Zero based *);
        getIndex:
          (# theIcon: ^pixmap;
             index: @integer;
             anElm: ^iconElm;
          enter theIcon[]
          do -1 -> index;
             L:
               scan
               (# 
               do (if (theIcon[]=current.theIcon[]) then
                      current.index -> index;
                      leave L
                  if);
               #);
             (if index=-1 then (* new icon *)
                 &iconElm[] -> anElm[];
                 theIcon[] -> anElm.theIcon[];
                 currentIndex -> anElm.index -> index;
                 currentIndex + 1 -> currentIndex;
                 anElm[] -> append;
                 theIcon[] -> addIconToImageList;
             if);
          exit index
          #);
        
     #); (* End of icons *)
   
   items: @list
     (# element:: listItem;
        insert:
          (# elm: ^element;
          enter elm[]
          do elm[] -> append;
          #);
        remove:
          (# elm: ^element;
             theCell: ^theCellType;
          enter elm[]
          do elm[] -> at -> delete;
          #);
        doCallOnSelect:
          (# uid: @integer;
             theItem: ^element;
          enter uid
          do l: scan
               (# 
               do (if current.private.uid=uid then
                      current[] -> theItem[];
                      leave l;
                  if);
               #); 
             (if theItem[]<>NONE then
                 theItem.onSelect
             if);
          #);
     #);
   findListItem:
     (# uid: @integer;
        theItem: ^listItem;
     enter uid
     do l: 
          items.scan
          (# 
          do (if current.private.uid=uid then
                 current[] -> theItem[];
                 leave l;
             if);
          #); 
     exit theItem[]
     #);
   
   imageListInitialized: @boolean;
   initImageLists:
     (# listViewId: @integer;
     do interfaceObjectID -> listViewId;
        (if icon_view then
            (* Create the full sized image list. *)
            (SM_CXICON->GetSystemMetrics, 
            SM_CYICON->GetSystemMetrics, 1,initialNoOfIcons, 1) 
              -> private.largeImageList.create;
        if);
        (if smallicon_view or report_view or list_view then
            (* Create the small sized icon image lists. *)
            (SM_CXSMICON->GetSystemMetrics, 
            SM_CYSMICON->GetSystemMetrics, 1, initialNoOfIcons, 1) 
              -> private.smallImageList.create;
        if);
        
        (* Assign the image lists to the list view control. *)
        (if icon_view then
            (listViewId,himlLarge,LVSIL_NORMAL)
              ->ListView_SetImageList; 
        if);
        (if smallicon_view or report_view or list_view then
            (listViewId,himlSmall,LVSIL_SMALL)
              ->ListView_SetImageList;
        if);
        
        true -> imageListInitialized;
     #); (* End of initImageLists *)
   
   addIconToImageList:
     (# theIcon: ^pixmap;
     enter theIcon[]
     do (if not imageListInitialized then
            initImageLists;
        if);
        (if icon_view then
            theIcon.private.handleToPixmap->private.largeImageList.addIcon;
        if);
        (if smallicon_view or report_view or list_view then
            theIcon.private.handleToPixmap -> private.smallImageList.addIcon;
        if);
     #);
#)

-- GUIEnvListViewEventHandlerOnMouseUp: doPart --
do (* iCurSel = ListView_GetNextItem (ghwndLV, -1, LVNI_SELECTED); *)
   inner;

-- GUIEnvListViewEventHandlerOnMouseDown: doPart --
do inner;
