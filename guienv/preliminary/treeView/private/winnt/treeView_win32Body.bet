ORIGIN '../treeViewBody';

INCLUDE       '~beta/guienv/private/datastructures/sequence'
'../../../imageList/imageList'
       '~beta/guienv/private/winnt/guienv_ntiprivate'
       '~beta/guienv/private/winnt/guienvattributes';

INCLUDE       '~beta/win32lib/commctrl'
       '~beta/win32lib/systemmetrics'
       '~beta/win32lib/mousecursorsupport'
       '~beta/win32lib/gdistructs'
       '~beta/sysutils/cstring'
       '~beta/sysutils/objinterface';

-- lib: attributes --
memset: external
  (# dest,c,count: @integer;
     result: @integer;
  enter (dest,c,count)
  do callC;
  exit result
  #);

TVM_EDITLABEL: (# exit TV_FIRST + 14 #);

TVSIL_NORMAL: (# exit    0 #);
TVSIL_STATE: (# exit     2 #);
TVS_TRACKSELECT: (# exit 0x0200 #);
TVS_FULLROWSELECT: (# exit       0x1000 #);

EM_SETLIMITTEXT: (# exit EM_LIMITTEXT   (* ;win40 Name change *) #);

LPSTR_TEXTCALLBACK: (# exit -1 #);

-- GUIEnvTreeItemSetName: doPart --
do (if theName[]<>NONE then
       theName[] -> tiPrivate.name[];
       (if tiPrivate.isOpen then
           (# tvi: @TV_ITEM;
              cStrLabel: @cString;
           do sizeOf_TV_ITEM -> malloc -> tvi.ptr;
              (if tvi.ptr<>0 then
                  TVIF_TEXT ->  tvi.mask;
                  0 -> tvi.state; 
                  0 -> tvi.stateMask; 
                  tiPrivate.hItem -> tvi.hItem;
                  
                  (if 1=2 (* tiPrivate.isRoot *) then
                      tiPrivate.name[] -> cstrLabel.set;
                      cStrLabel.charPtr -> tvi.pszText; 
                      cstrLabel.length -> tvi.cchTextMax;
                   else
                      LPSTR_TEXTCALLBACK -> tvi.pszText;
                      0 -> tvi.cchTextMax; 
                  if);
                  
                  0 -> tvi.lParam;
                  
                  (tvPrivate.treeViewId,tvi.ptr) -> TreeView_SetItem;
                  tvi.ptr -> free;
                  (if 1=2 (* tiPrivate.isRoot *) then
                      cstrLabel.free 
                  if);
              if);
           #);
       if);
   if);

-- GUIEnvTreeItemGetName: doPart --
do tiPrivate.name[] -> theName[];
   
-- GUIEnvTreeItemSetIcons: doPart --
do selectedIcon[] -> tiPrivate.selectedIcon[];
   (if selectedIcon[]<>NONE then
       selectedIcon[] -> tvPrivate.normalIcons.getIndex -> tiPrivate.selectedIconInx;
    else
       -1 -> tiPrivate.selectedIconInx;
   if);
   
   notSelectedIcon[] -> tiPrivate.notSelectedIcon[];
   (if notSelectedIcon[]<>NONE then
       notSelectedIcon[]->tvPrivate.normalIcons.getIndex->tiPrivate.notSelectedIconInx;
    else
       -1 -> tiPrivate.notSelectedIconInx;
   if);
   
   overlayIcon[] -> tiPrivate.overlayIcon[];
   (if overlayIcon[]<>NONE then
       overlayIcon[] -> tvPrivate.normalIcons.getIndex-> tiPrivate.overlayIconInx;
    else
       -1 ->  tiPrivate.overlayIconInx;
   if);
   
   stateIcon[] -> tiPrivate.stateIcon[];
   (if stateIcon[]<>NONE then
       stateIcon[] -> tvPrivate.stateIcons.getIndex-> tiPrivate.stateIconInx;
    else
       0 -> tiPrivate.stateIconInx;
   if);
   
   (if tiPrivate.isOpen then
       (# treeViewId: @integer;
          tvI: @TV_ITEM;
          res: @integer;
       do sizeOf_TV_ITEM -> malloc -> tvI.ptr;
          (if tvI.ptr<>0 then
              tvPrivate.treeViewId -> treeViewId;
              0 -> tvI.mask; 
              0 -> tvI.hItem;
              0 -> tvI.state; 
              0 -> tvI.stateMask; 
              0 -> tvI.pszText;
              0 -> tvI.cchTextMax;
              0 -> tvI.iImage;
              0 -> tvI.iSelectedImage;
              0 -> tvI.cChildren;
              0 -> tvI.lParam;
              
              tiPrivate.hItem -> tvI.hItem;
              
              (if tiPrivate.selectedIconInx<>-1 then
                  tvI.mask %Bor TVIF_SELECTEDIMAGE -> tvI.mask;
                  tiPrivate.selectedIconInx -> tvI.iSelectedImage;
              if);
              
              (if tiPrivate.notSelectedIconInx<>-1 then
                  tvI.mask %Bor TVIF_IMAGE -> tvI.mask;
                  tiPrivate.notSelectedIconInx -> tvI.iImage;
              if);
              
              tvI.mask %Bor TVIF_STATE -> tvI.mask;
              TVIS_STATEIMAGEMASK -> tvI.stateMask; 
              
              tiPrivate.stateIconInx %sll 12 -> tvI.state; 
              
              (tvPrivate.treeViewId,tvi.ptr) -> TreeView_SetItem;
              tvi.ptr -> free;
          if);
       #);
   if);
   
-- GUIEnvTreeItemGetIcons: doPart --
do (tiPrivate.selectedIcon[], tiPrivate.notSelectedIcon[], 
   tiPrivate.overlayIcon[], tiPrivate.stateIcon[])
     -> (selectedIcon[], notSelectedIcon[], overlayIcon[], stateIcon[]);
   
   
-- GUIEnvTreeItemAppend: doPart --
do (if tiPrivate.childItems[]=NONE then
       &tvPrivate.items[] -> tiPrivate.childItems[];
       tiPrivate.childItems.init;
   if);
   (if not (theItem[] -> tiPrivate.childItems.has) then
       (theItem[],this(TreeItem)[],TVI_LAST) -> tvPrivate.addItem;
       theItem[] -> tiPrivate.childItems.append;
       this(treeItem)[] -> theItem.tiPrivate.parentItem[];
       theItem.open;
   if);
   
-- GUIEnvTreeItemPrepend: doPart --
do (if tiPrivate.childItems[]=NONE then
       &tvPrivate.items[] -> tiPrivate.childItems[];
       tiPrivate.childItems.init;
   if);
   (if not (theItem[] -> tiPrivate.childItems.has) then
       (theItem[],this(TreeItem)[],TVI_FIRST) -> tvPrivate.addItem;
       theItem[] -> tiPrivate.childItems.prepend;
       this(treeItem)[] -> theItem.tiPrivate.parentItem[];
       theItem.open;
   if);
   
-- GUIEnvTreeItemInsert: doPart --
do (if tiPrivate.childItems[]=NONE then
       &tvPrivate.items[] -> tiPrivate.childItems[];
       tiPrivate.childItems.init;
   if);
   (if not (theItem[] -> tiPrivate.childItems.has) then
       (theItem[],this(TreeItem)[],theAfterItem.tiPrivate.hItem) 
         -> tvPrivate.addItem;
       (theItem[], theAfterItem[]->tiPrivate.childItems.at) 
         -> tiPrivate.childItems.insertAfter;
       this(treeItem)[] -> theItem.tiPrivate.parentItem[];
       theItem.open;
   if);
   
-- GUIEnvTreeItemInplaceEditLabel: doPart --
do (tvPrivate.treeViewId, TVM_EDITLABEL, 0, tiPrivate.hItem)
     -> SendMessage;
   
-- GUIEnvTreeItemDelete: doPart --
do (if tiPrivate.isRoot then
       (if this(treeItem)[]->tvPrivate.rootItems.has then
           (if ((tvPrivate.treeViewId,tiPrivate.hItem)
                 -> TreeView_DeleteItem) <> 0 then
               tiPrivate.remove;
               this(treeItem)[]
                 -> tvPrivate.rootItems.remove;
           if);
       if);
    else
       (if this(treeItem)[]->tiPrivate.parentItem.tiPrivate.childItems.has then
           (if ((tvPrivate.treeViewId,tiPrivate.hItem)
                 -> TreeView_DeleteItem) <> 0 then
               tiPrivate.remove;
               this(treeItem)[] 
                 -> tiPrivate.parentItem.tiPrivate.childItems.remove;
           if);
       if);
   if);
   
   
-- GUIEnvTreeItemCreate: doPart --
do (* FALSE -> doAddToList; *)
   inner;

-- GUIEnvTreeItemOpen: doPart --
do inner;
   
-- GUIEnvTreeItemScan: doPart --
do (if tiPrivate.childItems[]<>NONE then
       tiPrivate.childItems.scan
       (# 
       do current[] -> THIS(scan).current[];
          inner scan;
       #);
   if);

-- GUIEnvTreeItemSelect: doPart --
do (tvPrivate.treeViewId,tiPrivate.hItem,TVGN_CARET) -> TreeView_Select;

-- GUIEnvTreeItemDeSelect: doPart --
do (tvPrivate.treeViewId,0,TVGN_CARET) -> TreeView_Select;
   
-- GUIEnvTreeItemExpand: doPart --
do (tvPrivate.treeViewId, tiPrivate.hitem, TVE_EXPAND) -> TreeView_Expand;

   
-- GUIEnvTreeItemCollapse: doPart --
do (tvPrivate.treeViewId, tiPrivate.hitem, TVE_COLLAPSE) -> TreeView_Expand;
   

-- GUIEnvTreeItemPrivate: descriptor --
(# hItem: @integer;
   name: ^text;
   isOpen,isRoot: @boolean;
   
   parentItem: ^treeItem;      
   selectedIcon, notSelectedIcon, overlayIcon, stateIcon: ^pixmap;
   selectedIconInx, notSelectedIconInx, overlayIconInx, stateIconInx: @integer;
   
   childItems: ^tvPrivate.items;
   findChildItem:
     (# hItem: @integer;
        theItem: ^treeItem;
     enter hItem
     do (if childItems[]<>NONE then
            l: 
              childItems.scan
              (# 
              do (if current.tiPrivate.hItem=hItem then
                     current[] -> theItem[];
                     leave l;
                  else
                     hItem -> current.tiPrivate.findChildItem -> theItem[];
                     (if theItem[]<>NONE then
                         leave l;
                     if);
                 if);
              #); 
        if);
     exit theItem[]
     #);
   
   remove:
     (# 
     do (if childItems[]<>NONE then
            childItems.scan
            (# 
            do current.tiPrivate.remove;
            #);
            tiPrivate.childItems.clear;
        if);
     #);
#)

-- TreeViewLib: attributes --
lstrcpy: External
  (# charptr1, charptr2: @integer;
     result_ptr: @integer;
  enter (charptr1, charptr2)
  do 'lstrcpyA' -> callStd;
  exit result_ptr
  #);

lstrcpyn: external
  (# lpString1: @integer;  (* address of target buffer *)
     lpString2: @integer;  (* address of source string *)
     iMaxLength: @integer; (* number of bytes to copy *)
     result_ptr: @integer;
  enter (lpString1, lpString2, iMaxLength)
  do 'lstrcpynA' -> callStd;
  exit result_ptr
  #);
  
treeViewMethods: windowItemNotificationMethods
  (# handleNotification::
       (# processCommand:
            (# type: @integer;
               id: @integer;
               index: @integer;
               windowID: @integer;
            do false -> didSomething;
            #);
          processNotify:
            (# hwndFrom, idCtrl, code1: @integer;
               hItemNew: @integer; 
               hitem: @integer;
               tempItem: ^treeItem;
               strAddr: @integer;
               theText: ^text;
               theItem: ^treeItem;
               theMask: @integer;
               doProcess: @integer;
               tempText: @cstring;
               uid: @integer;
               theTV_DISPINFO: @TV_DISPINFO;
               bytesToCopy: @integer;
            do info.lParam -> TOS'%adrGetLong' -> hwndFrom;
               info.lParam+4 -> TOS'%adrGetLong' -> idCtrl;
               info.lParam+8 -> TOS'%adrGetLong' -> code1;
               
               (if code1
                //TVN_GETDISPINFO then
                   %getLongAt (info.lParam+12) -> theMask; 
                   theMask %Band TVIF_TEXT  -> doProcess;
                   (if doProcess<>0 then
                       %getLongAt (info.lParam+16) -> hItem;
                       %getLongAt (info.lParam + 28) -> strAddr;
                       
                       hItem -> tvPrivate.findtreeItem -> theItem[];  
                       
                       (if theItem[]<>NONE then
                           (if theItem.tiPrivate.name[]<>NONE then
                               (if theItem.tiPrivate.name.length>0 then
                                   theItem.tiPrivate.name.length +1 
                                     -> bytesToCopy;
                                   (strAddr, @@theItem.tiPrivate.name.T[1],
                                   bytesToCopy) 
                                     -> lstrcpyn;
                                else
                                   theItem.tiPrivate.name[] -> tempText.set; 
                                   (strAddr, tempText) -> lstrcpy; 
                                   tempText.free;
                               if);
                           if);
                       if);
                       true -> didSomething;
                    else
                       false -> didSomething;
                   if);
                   
                //TVN_SELCHANGED then
                   (* lParam = pointer to NM_TREEVIEW *)
                   info.lParam+60 -> TOS'%adrGetLong' -> hItemNew;
                   hItemNew -> tvPrivate.findtreeItem -> tempItem[];
                   (if tempItem[]<>NONE then
                       tempItem.onSelect;
                   if);
                   
                //TVN_ITEMEXPANDED then
                   info.lParam+60 -> TOS'%adrGetLong' -> hItemNew;
                   hItemNew -> tvPrivate.findtreeItem -> tempItem[];
                   (if tempItem[]<>NONE then
                       (if (info.lParam+12 -> TOS'%adrGetLong') (* action *)
                        //TVE_EXPAND then
                           tempItem.onExpand;
                        //TVE_COLLAPSE then
                           tempItem.onCollapse;
                       if);
                   if);
                   
                //TVN_ITEMEXPANDING then
                   info.lParam+60 -> TOS'%adrGetLong' -> hItemNew;
                   hItemNew -> tvPrivate.findtreeItem -> tempItem[];
                   (if tempItem[]<>NONE then
                       (if (info.lParam+12 -> TOS'%adrGetLong') (* action *)
                        //TVE_EXPAND then
                           (if tempItem.onBeforeExpand then
                               0 -> info.result;
                            else
                               1 -> info.result;
                           if);
                        //TVE_COLLAPSE then
                           (if tempItem.onBeforeCollapse then
                               0 -> info.result;
                            else
                               1 -> info.result;
                           if);
                       if);
                   if);
                   
                //TVN_BEGINLABELEDIT then
                   info.lParam+16 -> TOS'%adrGetLong' 
                     -> tvPrivate.findtreeItem -> tempItem[];
                   (if tempItem[]<>NONE then
                       (if tempItem.onBeforeNameChange then
                           (* Allow editing *)
                           0 -> info.result;
                           (# hWndEdit: @integer;
                           do (* Get the handle to the edit box. *)
                              (tvPrivate.treeViewId, TVM_GETEDITCONTROL, 0, 0)
                                -> SendMessage
                                -> hWndEdit;
                              (* Limit the amount of text that can be entered.*)
                              (hWndEdit, EM_SETLIMITTEXT, 255, 0)
                                -> SendMessage;
                           #);
                        else
                           1 -> info.result;
                       if);
                   if);
                   true -> didSomething;
                   
                //TVN_ENDLABELEDIT then
                   info.lParam+16 -> TOS'%adrGetLong' 
                     -> tvPrivate.findtreeItem -> tempItem[];
                   (if tempItem[]<>NONE then
                       (# cstr: @cString;
                       do 256 -> cstr.init;
                          (if cstr.charptr<>0 then
                              info.lParam+28 -> TOS'%adrGetLong' -> strAddr;
                              (if strAddr<>0 then
                                  (cstr, strAddr) -> lstrcpy;
                                  (if tempItem.tiPrivate.name[]<>NONE then
                                      tempItem.tiPrivate.name.clear;
                                      cstr.get -> tempItem.tiPrivate.name.append;
                                      tempItem.onNameChanged;
                                  if);
                                  1 -> info.result;
                              if);
                              cstr.free;
                          if);
                       #);
                   if);
                   
                //NM_DBLCLK then
                   (# hItem: @integer;
                   do (tvPrivate.treeViewId, 0, TVGN_CARET) -> TreeView_GetNextItem -> hItem;
                      hItem -> tvPrivate.findtreeItem -> tempItem[];
                      (if tempItem[]<>NONE then
                          tempItem.onDoubleClick;
                      if);
                   #);
                   
                //NM_RCLICK then
                   mouse.globalPosition 
                     -> tvPrivate.itemFromPoint -> tempItem[];
                   (if tempItem[]<>NONE then
                       mouse.globalPosition -> tempItem.onRMouseUp;
                    else
                       3 -> info.button;
                       this(treeView).theEventHandler.onMouseUp;
                   if);
                else
                   false -> didSomething;
               if);
            #);
          
          didSomething: @boolean;
       do true -> didSomething;
          (if info.message 
           //WM_COMMAND then processCommand; 
           //WM_NOTIFY then processNotify;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

hImlNormal:        (* image list for icon view *)
  (# exit tvPrivate.normalImageList.theHandle #);

hImlState:       (* image list for other views *)
  (# exit tvPrivate.stateImageList.theHandle #);

SM_CXSMICON: (# exit 49 #);
SM_CYSMICON: (# exit 50 #);

bitComp: 
  (# style: @integer;
     mask: @integer;
  enter (style, mask)
  do style %Band (%Bnot mask) -> style;
  exit style
  #);

-- GUIEnvTreeViewAppend: doPart --
do (if not (theItem[] -> tvPrivate.rootItems.has) then
       (theItem[],NONE,TVI_LAST) -> tvPrivate.addItem;
       theItem[] -> tvPrivate.rootItems.append;
       true -> theItem.tiPrivate.isRoot;
       theItem.open;
   if);
   
-- GUIEnvTreeViewPrepend: doPart --
do (if not (theItem[] -> tvPrivate.rootItems.has) then
       (theItem[],NONE,TVI_LAST) -> tvPrivate.addItem;
       theItem[] -> tvPrivate.rootItems.prepend;
       true -> theItem.tiPrivate.isRoot;
       theItem.open;
   if);
   
-- GUIEnvTreeViewInsert: doPart --
do (if not (theItem[] -> tvPrivate.rootItems.has) then
       (theItem[],NONE,theAfterItem.tiPrivate.hItem) -> tvPrivate.addItem;
       (theItem[], theAfterItem[]->tvPrivate.rootItems.at) 
         -> tvPrivate.rootItems.insertAfter;
       true -> theItem.tiPrivate.isRoot;
       theItem.open;
   if);
   
-- GUIEnvTreeViewScan: doPart --
do tvPrivate.rootItems.scan
   (# 
   do current[] -> THIS(scan).current[];
      inner scan;
   #);

-- GUIENVTreeViewSelectionFirst: doPart --
do (tvPrivate.treeViewId, 0, TVGN_CARET) 
     -> TreeView_GetNextItem 
     -> tvPrivate.findtreeItem -> theItem[];
   
-- GUIEnvTreeViewNoOfElms: doPart --
do tvPrivate.treeViewId -> TreeView_GetCount -> value;
   
-- GUIEnvTreeViewClear: doPart --
do tvPrivate.treeViewId->TreeView_DeleteAllItems;
   tvPrivate.rootItems.clear;
   tvPrivate.rootItems.init;

-- GUIenvTreeViewCreate: doPart --
do InitCommonControls;
   
   tvPrivate.treeViewCompareProc## 
     -> tvPrivate.std16x3toint  
     -> tvPrivate.treeViewCompareProcAddress;                
   
   &treeViewMethods[] -> theNotiMethods;
   isSubClass  -> windowItemClassStatus; 
   'SysTreeView32' -> windowItemClass;
   
   TVS_HASLINES %Bor TVS_LINESATROOT %Bor TVS_HASBUTTONS %Bor WS_BORDER 
   % Bor TVS_SHOWSELALWAYS %Bor TVS_EDITLABELS %Bor TVS_TRACKSELECT
     -> windowItemStyle; 
   
   inner create;
   
   
-- GUIenvTreeViewOpen: doPart --
do interfaceObjectID -> tvPrivate.treeViewId;
   tvPrivate.normalIcons.init;
   tvPrivate.stateIcons.init;
   inner;   
   
-- GUIenvTreeViewClose: doPart --
do inner;
   tvPrivate.treeViewCompareProcAddress -> tvPrivate.freeCBF;
   
-- GUIenvTreeViewPrivate: descriptor --
(# treeViewId: @integer;
   treeViewCompareProcAddress: @integer;
   std16x3toint: external
     (# func: ##treeViewCompareProc;
        int: @integer;
     enter func##
     do 'copyinput'->callC
     exit int
     #);
   
   makeCBF: External
     (# pat: ##External;
        cb: @integer;
     enter pat##
     exit cb
    #);
    
   
   freeCBF: External
     (# cbf: @integer;
     enter cbf
     #);                
   
   treeViewCompareProc: external
     (# lParam1, lParam2, lParamSort: @integer;
        theItem1,theItem2: ^treeItem;
        subItem1, subItem2: ^text;
        result: @integer;                       
     enter (lParam1, lParam2, lParamSort)
     do StdExternalEntry;
        (* lParam1 -> tvPrivate.findtreeItem -> theItem1[];
         *         lParam2 -> tvPrivate.findtreeItem -> theItem2[];
         *         
         *         (if (theItem1[]<>NONE) and (theItem2[]<>NONE) then
         *             (if lParamSort
         *              //0 then
         *                 (if theItem1.tvPrivate.name[] -> theItem2.tvPrivate.name.equal then
         *                     0 -> result;
         *                  else
         *                     (if theItem1.tvPrivate.name[]->theItem2.tvPrivate.name.less then
         *                         -1 -> result;
         *                      else
         *                         1 -> result;
         *                     if);
         *                 if);
         *              //1 then
         *                 (if theItem1.type = theItem2.type then
         *                     0 -> result;
         *                  else
         *                     (if theItem1.type < theItem2.type then
         *                         -1 -> result;
         *                      else
         *                         1 -> result;
         *                     if);  
         *                 if);
         *             if);
         *         if);
         *)
     exit result   
     #);
   
   itemFromPoint:
     (# TV_HITTESTINFO: ExternalRecord
          (# pt: @
               (# x: @long (# pos::< (# do 0 -> value #); #);
                  y: @long (# pos::< (# do 4 -> value #); #);
               enter (x,y)
               exit (x,y)
               #);
             flags: @long (# pos::< (# do 8 -> value #); #);
             hItem: @long (# pos::< (# do 12 -> value #); #); 
          #);
        sizeOf_TV_HITTESTINFO: (# exit 16 #);
        
        TVM_HITTEST: (# exit (TV_FIRST + 17) #);
        TreeView_HitTest:
          (# hwndTV: @integer;
             pinfo: @integer;
             result: @integer;
             temp: @integer;
          enter (hwndTV, pinfo) 
          do (hwndTV, TVM_HITTEST, 0, pinfo) -> SendMessage -> result;
          exit result
          #);
        
        theTV_HITTESTINFO: @TV_HITTESTINFO;
        result: @integer;
        x,y,x2,y2: @integer;
        theItem: ^treeItem;
        ntp: @ntPOINTextR;
     enter (x,y)
     do 
        8 -> malloc -> ntp.ptr;
        sizeOf_TV_HITTESTINFO -> malloc -> theTV_HITTESTINFO.ptr;
        (if (theTV_HITTESTINFO.ptr<>0) and (ntp.ptr<>0) then
            (x,y) -> (ntp.x, ntp.y);
            (treeViewId,ntp.ptr) -> ScreenToClient;
            ntp.ptr -> getPointFromNtPointPtr -> (x,y);
            
            (theTV_HITTESTINFO.ptr,0,sizeOf_TV_HITTESTINFO)->memset;
            this(treeView).position -> (x2,y2);
            (x,y) -> theTV_HITTESTINFO.pt;
            
            (treeViewId,theTV_HITTESTINFO.ptr) ->  TreeView_HitTest -> result;
            (if result<>0 then
                theTV_HITTESTINFO.hItem->tvPrivate.findtreeItem->theItem[]
            if);
            
            (* Clean up *)
            theTV_HITTESTINFO.ptr -> free;
            ntp.ptr -> free;
         else
            'Failed to allocate TV_HITTESTINFO in itemFromPoint.'
              -> resourceAllocationError;
        if);
     exit theItem[]
     #);
   
   
   guid: @integer;
   getUid:
     (# do guid + 1 -> guid;
     exit guid
     #);
   
   addItem:
     (# 
        tvins: @TV_INSERTSTRUCT;
        cstrLabel: @cstring;
        doFreeCstr: @boolean;
        aLabel: ^text;
        treeViewId: @integer;
        result: @integer;
        theItem, parentItem: ^treeItem;
        afterItem: @integer;
        failure:< exception
          (# errMsg: ^text;
          enter errMsg[]
          do (if errMsg[]<>NONE then
                 errMsg[] -> msg.append;
             if);
          #);
     enter (theItem[],parentItem[],afterItem)
     do tvPrivate.treeViewId -> treeViewId;
        theItem[] -> getPatternName -> theItem.tiPrivate.name[];

        sizeOf_TV_INSERTSTRUCT -> malloc -> tvins.ptr;
        (if (tvins.ptr<>0) then
            
            TVIF_PARAM %Bor TVIF_TEXT -> tvins.item.mask;
            0 -> tvins.item.state; 
            0 -> tvins.item.stateMask; 
            
            (if 1=2 (* parentItem[]=NONE *) then
                theItem.tiPrivate.name[] -> cstrLabel.set;
                cStrLabel.charPtr -> tvins.item.pszText; 
                cstrLabel.length+1 -> tvins.item.cchTextMax; 
                true -> doFreeCstr;
             else 
                LPSTR_TEXTCALLBACK -> tvins.item.pszText;
                0 -> tvins.item.cchTextMax; 
            if);
            
            0 -> tvins.item.iImage;    (* image list index *)
            0 -> tvins.item.lParam;
            
            
            afterItem -> tvins.hInsertAfter;
            
            (if (parentItem[]=NONE) then
                TVI_ROOT -> tvins.hParent; 
             else
                (if parentItem.tiPrivate.isOpen then
                    parentItem.tiPrivate.hItem -> tvins.hParent; 
                 else 
                    'parentItem must be open.' -> failure;
                if);
            if);
            (* getUid -> theItem.tiPrivate.uid -> tvins.item.lParam; *)
            
            (treeViewId, tvins.ptr)->TreeView_InsertItem
              ->theItem.tiPrivate.hItem;
            
            (if doFreeCstr then
                cstrLabel.free;
            if);
            tvins.ptr -> free;
            TRUE -> theItem.tiPrivate.isOpen;
        if);
     #);
   
   items: list
     (# element:: treeItem;
        remove:
          (# elm: ^element;
          enter elm[]
          do elm[] -> at -> delete;
          #);        
     #);
   rootItems: @items;
   findtreeItem:
     (# hItem: @integer;
        theItem: ^treeItem;
     enter hItem
     do l: 
          rootItems.scan
          (# 
          do (if current.tiPrivate.hItem=hItem then
                 current[] -> theItem[];
                 leave l;
              else
                 hItem -> current.tiPrivate.findChildItem -> theItem[];
                 (if theItem[]<>NONE then
                     leave l;
                 if);
             if);
          #); 
     exit theItem[]
     #);
   
   normalImageList, stateImageList: @imageList;
   normalImageListInitialized, stateImageListInitialized: @boolean;
   
   iconElm:
     (# theIcon: ^pixmap;
        index: @integer;
     #);
   normalIcons: @sequence
     (# element:: iconElm;

        init::
          (# do 0 -> currentIndex; #);
        
        currentIndex: @integer; (* Zero based *);
        getIndex:
          (# theIcon: ^pixmap;
             index: @integer;
             anElm: ^iconElm;
          enter theIcon[]
          do -1 -> index;
             L:
               scan
               (# 
               do (if (theIcon[]=current.theIcon[]) then
                      current.index -> index;
                      leave L
                  if);
               #);
             (if index=-1 then (* new icon *)
                 &iconElm[] -> anElm[];
                 theIcon[] -> anElm.theIcon[];
                 currentIndex -> anElm.index -> index;
                 currentIndex + 1 -> currentIndex;
                 anElm[] -> append;
                 theIcon[] -> addIconToNormalImageList;
             if);
          exit index
          #);
        
     #); (* End of icons *)
   
   stateIcons: @sequence
     (# element:: iconElm;
        
        init::
          (# do 0 -> currentIndex; #);
        
        currentIndex: @integer; (* One based *);
        getIndex:
          (# theIcon: ^pixmap;
             index: @integer;
             anElm: ^iconElm;
          enter theIcon[]
          do -1 -> index;
             L:
               scan
               (# 
               do (if (theIcon[]=current.theIcon[]) then
                      current.index -> index;
                      leave L
                  if);
               #);
             (if index=-1 then (* new icon *)
                 &iconElm[] -> anElm[];
                 theIcon[] -> anElm.theIcon[];
                 currentIndex + 1 -> currentIndex;
                 currentIndex -> anElm.index -> index;
                 anElm[] -> append;
                 theIcon[] -> addIconToStateImageList;
             if);
          exit index
          #);
        
     #); (* End of stateIcons *)
   
   addIconToNormalImageList:
     (# theIcon: ^pixmap;
        res: @integer;
     enter theIcon[]
     do (if not normalImageListInitialized then
            initNormalImageList;
        if);
        theIcon.private.handleToPixmap -> normalImageList.addIcon->res;
     #);
   
   addIconToStateImageList:
     (# theIcon: ^pixmap;
        res: @integer;
     enter theIcon[]
     do (if not stateImageListInitialized then
            initStateImageList;
        if);
        theIcon.private.handleToPixmap -> stateImageList.addIcon->res;
     #);
   
   initNormalImageList:
     (# 
     do 
        (* Create Image List *)
        (SM_CXSMICON->GetSystemMetrics, 
        SM_CYSMICON->GetSystemMetrics, 1, initialNoOfIcons, 1) 
          -> normalImageList.create;
        
        (* Assign the image lists to the treeview control. *)
        (treeViewId,hImlNormal,TVSIL_NORMAL) -> TreeView_SetImageList; 
        
        true -> normalImageListInitialized;
     #);
   
   initStateImageList:
     (# 
     do (* Create Image List *)
        (SM_CXSMICON->GetSystemMetrics, 
        SM_CYSMICON->GetSystemMetrics, 1, initialNoOfStateIcons+1, 1) 
          -> stateImageList.create;
        
        (0,IDI_APPLICATION) -> LoadIconInteger -> stateImageList.addIcon;
        
        (* Assign the image lists to the treeview control. *)
        (treeViewId,hImlState,TVSIL_STATE) -> TreeView_SetImageList; 
        
        true -> stateImageListInitialized;
        
     #);
#)

-- GUIEnvTreeViewEventHandlerOnMouseUp: doPart --
do inner;

-- GUIEnvTreeViewEventHandlerOnMouseDown: doPart --
do inner;

-- treeViewOnRefresh: doPart --
do inner;
