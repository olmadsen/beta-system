ORIGIN '../cdaudiodevicebody';
INCLUDE 
       '~beta/win32lib/win32apiinit'
       '~beta/win32lib/windowmanagement'
       '~beta/win32lib/winuserconsts'
       '~beta/sysutils/cstring';

INCLUDE '~beta/basiclib/formatio';

BUILD default '$$/cdaudiodevicehelp.obj' 'external/cdaudiodevicehelp.c' 'betacc $0 $1';

LINKOPT nti 'winmm.lib';

-- cdAudioDeviceLib: attributes --
(* Driver messages *)
DRV_LOAD: (# exit                0x0001 #);
DRV_ENABLE: (# exit              0x0002 #);
DRV_OPEN: (# exit                0x0003 #);
DRV_CLOSE: (# exit               0x0004 #);
DRV_DISABLE: (# exit             0x0005 #);
DRV_FREE: (# exit                0x0006 #);
DRV_CONFIGURE: (# exit           0x0007 #);
DRV_QUERYCONFIGURE: (# exit      0x0008 #);
DRV_INSTALL: (# exit             0x0009 #);
DRV_REMOVE: (# exit              0x000A #);
DRV_EXITSESSION: (# exit         0x000B #);
DRV_POWER: (# exit               0x000F #);
DRV_RESERVED: (# exit            0x0800 #);
DRV_USER: (# exit                0x4000 #);

MM_MCINOTIFY: (# exit        0x3B9 #);

(* flags for wParam of MM_MCINOTIFY message *)
MCI_NOTIFY_SUCCESSFUL: (# exit           0x0001 #);
MCI_NOTIFY_SUPERSEDED: (# exit           0x0002 #);
MCI_NOTIFY_ABORTED: (# exit              0x0004 #);
MCI_NOTIFY_FAILURE: (# exit              0x0008 #);

(* common flags for dwFlags parameter of MCI command messages *)
MCI_NOTIFY: (# exit                      0x00000001 #);
MCI_WAIT: (# exit                        0x00000002 #);
MCI_FROM: (# exit                        0x00000004 #);
MCI_TO: (# exit                          0x00000008 #);
MCI_TRACK: (# exit                       0x00000010 #);

(* flags for dwFlags parameter of MCI_OPEN command message *)
MCI_OPEN_SHAREABLE: (# exit                0x00000100 #);
MCI_OPEN_ELEMENT: (# exit                  0x00000200 #);
MCI_OPEN_ALIAS: (# exit                    0x00000400 #);
MCI_OPEN_ELEMENT_ID: (# exit               0x00000800 #);
MCI_OPEN_TYPE_ID: (# exit                  0x00001000 #);
MCI_OPEN_TYPE: (# exit                     0x00002000 #);

(* flags for dwFlags parameter of MCI_SEEK command message *)
MCI_SEEK_TO_START: (# exit                 0x00000100 #);
MCI_SEEK_TO_END: (# exit                   0x00000200 #);

(* flags for dwFlags parameter of MCI_STATUS command message *)
MCI_STATUS_ITEM: (# exit                   0x00000100 #);
MCI_STATUS_START: (# exit                  0x00000200 #);

(* flags for dwItem field of the MCI_STATUS_PARMS parameter block *)
MCI_STATUS_LENGTH: (# exit                 0x00000001 #);
MCI_STATUS_POSITION: (# exit               0x00000002 #);
MCI_STATUS_NUMBER_OF_TRACKS: (# exit       0x00000003 #);
MCI_STATUS_MODE: (# exit                  0x00000004 #);
MCI_STATUS_MEDIA_PRESENT: (# exit          0x00000005 #);
MCI_STATUS_TIME_FORMAT: (# exit            0x00000006 #);
MCI_STATUS_READY: (# exit                  0x00000007 #);
MCI_STATUS_CURRENT_TRACK: (# exit          0x00000008 #);

(* flags for dwFlags parameter of MCI_INFO command message *)
MCI_INFO_PRODUCT: (# exit                  0x00000100 #);
MCI_INFO_FILE: (# exit                     0x00000200 #);
MCI_INFO_MEDIA_UPC: (# exit                0x00000400 #);
MCI_INFO_MEDIA_IDENTITY: (# exit           0x00000800 #);
MCI_INFO_NAME: (# exit                     0x00001000 #);
MCI_INFO_COPYRIGHT: (# exit                0x00002000 #);

(* flags for dwFlags parameter of MCI_GETDEVCAPS command message *)
MCI_GETDEVCAPS_ITEM: (# exit               0x00000100 #);

(* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block *)
MCI_GETDEVCAPS_CAN_RECORD: (# exit         0x00000001 #);
MCI_GETDEVCAPS_HAS_AUDIO: (# exit          0x00000002 #);
MCI_GETDEVCAPS_HAS_VIDEO: (# exit          0x00000003 #);
MCI_GETDEVCAPS_DEVICE_TYPE: (# exit        0x00000004 #);
MCI_GETDEVCAPS_USES_FILES: (# exit         0x00000005 #);
MCI_GETDEVCAPS_COMPOUND_DEVICE: (# exit    0x00000006 #);
MCI_GETDEVCAPS_CAN_EJECT: (# exit          0x00000007 #);
MCI_GETDEVCAPS_CAN_PLAY: (# exit           0x00000008 #);
MCI_GETDEVCAPS_CAN_SAVE: (# exit           0x00000009 #);

(* flags for dwFlags parameter of MCI_SYSINFO command message *)
MCI_SYSINFO_QUANTITY: (# exit              0x00000100 #);
MCI_SYSINFO_OPEN: (# exit                  0x00000200 #);
MCI_SYSINFO_NAME: (# exit                  0x00000400 #);
MCI_SYSINFO_INSTALLNAME: (# exit           0x00000800 #);

(* flags for dwFlags parameter of MCI_SET command message *)
MCI_SET_DOOR_OPEN: (# exit                 0x00000100 #);
MCI_SET_DOOR_CLOSED: (# exit               0x00000200 #);
MCI_SET_TIME_FORMAT: (# exit               0x00000400 #);
MCI_SET_AUDIO: (# exit                     0x00000800 #);
MCI_SET_VIDEO: (# exit                     0x00001000 #);
MCI_SET_ON: (# exit                        0x00002000 #);
MCI_SET_OFF: (# exit                       0x00004000 #);

(* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS *)
MCI_SET_AUDIO_ALL: (# exit                 0x00000000 #);
MCI_SET_AUDIO_LEFT: (# exit                0x00000001 #);
MCI_SET_AUDIO_RIGHT: (# exit               0x00000002 #);

(* flags for dwFlags parameter of MCI_BREAK command message *)
MCI_BREAK_KEY: (# exit                     0x00000100 #);
MCI_BREAK_HWND: (# exit                    0x00000200 #);
MCI_BREAK_OFF: (# exit                     0x00000400 #);

(* flags for dwFlags parameter of MCI_RECORD command message *)
MCI_RECORD_INSERT: (# exit                 0x00000100 #);
MCI_RECORD_OVERWRITE: (# exit              0x00000200 #);

(* flags for dwFlags parameter of MCI_SAVE command message *)
MCI_SAVE_FILE: (# exit                     0x00000100 #);

(* flags for dwFlags parameter of MCI_LOAD command message *)
MCI_LOAD_FILE: (# exit                     0x00000100 #);

DRV_MCI_FIRST: (# exit DRV_RESERVED #);
DRV_MCI_LAST: (# exit (DRV_RESERVED + 0xFFF) #);

MCI_FIRST: (# exit DRV_MCI_FIRST #);   (* 0x0800 *)

(* MCI command message identifiers *)
MCI_OPEN: (# exit                        0x0803 #);
MCI_CLOSE: (# exit                       0x0804 #);
MCI_ESCAPE: (# exit                      0x0805 #);
MCI_PLAY: (# exit                        0x0806 #);
MCI_SEEK : (# exit                       0x0807 #);
MCI_STOP: (# exit                        0x0808 #);
MCI_PAUSE: (# exit                       0x0809 #);
MCI_INFO: (# exit                        0x080A #);
MCI_GETDEVCAPS: (# exit                  0x080B #);
MCI_SPIN: (# exit                        0x080C #);
MCI_SET: (# exit                         0x080D #);
MCI_STEP: (# exit                        0x080E #);
MCI_RECORD: (# exit                      0x080F #);
MCI_SYSINFO: (# exit                     0x0810 #);
MCI_BREAK: (# exit                       0x0811 #);
MCI_SAVE: (# exit                        0x0813 #);
MCI_STATUS: (# exit                      0x0814 #);
MCI_CUE: (# exit                         0x0830 #);
MCI_REALIZE: (# exit                     0x0840 #);
MCI_WINDOW: (# exit                      0x0841 #);
MCI_PUT: (# exit                         0x0842 #);
MCI_WHERE: (# exit                       0x0843 #);
MCI_FREEZE: (# exit                      0x0844 #);
MCI_UNFREEZE: (# exit                    0x0845 #);
MCI_LOAD: (# exit                        0x0850 #);
MCI_CUT: (# exit                         0x0851 #);
MCI_COPY: (# exit                        0x0852 #);
MCI_PASTE: (# exit                       0x0853 #);
MCI_UPDATE: (# exit                      0x0854 #);
MCI_RESUME: (# exit                      0x0855 #);
MCI_DELETE: (# exit                      0x0856 #);

(* all custom MCI command messages must be >= than this value *)
MCI_USER_MESSAGES: (# exit               (DRV_MCI_FIRST + 0x400)  #);
MCI_LAST: (# exit                        0x0FFF  #);

(* device ID for "all devices" *)
MCI_ALL_DEVICE_ID: (# exit               -1 #);

(* constants for predefined MCI device types *)
MCI_DEVTYPE_VCR: (# exit                 513 #); (* (MCI_STRING_OFFSET + 1) *)
MCI_DEVTYPE_VIDEODISC: (# exit           514 #); (* (MCI_STRING_OFFSET + 2) *)
MCI_DEVTYPE_OVERLAY: (# exit             515 #); (* (MCI_STRING_OFFSET + 3) *)
MCI_DEVTYPE_CD_AUDIO: (# exit            516 #); (* (MCI_STRING_OFFSET + 4) *)
MCI_DEVTYPE_DAT: (# exit                 517 #); (* (MCI_STRING_OFFSET + 5) *)
MCI_DEVTYPE_SCANNER: (# exit             518 #); (* (MCI_STRING_OFFSET + 6) *)
MCI_DEVTYPE_ANIMATION: (# exit           519 #); (* (MCI_STRING_OFFSET + 7) *)
MCI_DEVTYPE_DIGITAL_VIDEO: (# exit       520 #); (* (MCI_STRING_OFFSET + 8) *)
MCI_DEVTYPE_OTHER: (# exit               521 #); (* (MCI_STRING_OFFSET + 9) *)
MCI_DEVTYPE_WAVEFORM_AUDIO: (# exit      522 #); (* (MCI_STRING_OFFSET + 10) *)
MCI_DEVTYPE_SEQUENCER: (# exit           523 #); (* (MCI_STRING_OFFSET + 11) *)

MCI_DEVTYPE_FIRST: (# exit               MCI_DEVTYPE_VCR  #);
MCI_DEVTYPE_LAST: (# exit                MCI_DEVTYPE_SEQUENCER #);

(* constants used in "set time format" and "status time format" commands *)
MCI_FORMAT_MILLISECONDS: (# exit         0 #);
MCI_FORMAT_HMS: (# exit                  1 #);
MCI_FORMAT_MSF: (# exit                  2 #);
MCI_FORMAT_FRAMES: (# exit               3 #);
MCI_FORMAT_SMPTE_24: (# exit             4 #);
MCI_FORMAT_SMPTE_25: (# exit             5 #);
MCI_FORMAT_SMPTE_30: (# exit             6 #);
MCI_FORMAT_SMPTE_30DROP: (# exit         7 #);
MCI_FORMAT_BYTES: (# exit                8 #);
MCI_FORMAT_SAMPLES: (# exit              9 #);
MCI_FORMAT_TMSF: (# exit                 10 #);


MCI_OPEN_PARMS: externalRecord
  (# dwCallback: @long (# pos::< (# do 0 -> value; #); #);  (* DWORD *)
     wDeviceID: @long (# pos::< (# do 4 -> value; #); #);     (* MCIDEVICEID *)
     lpstrDeviceType: @long (# pos::< (# do 8 -> value; #); #);   (* LPCSTR *)
     lpstrElementName: @long (# pos::< (# do 12 -> value; #); #);  (* LPCSTR *)
     lpstrAlias: @long (# pos::< (# do 16 -> value; #); #);        (* LPCSTR *)
  #);

sizeOf_MCI_OPEN_PARMS: (# exit 20 #);

MCI_SET_PARMS: externalRecord
  (# dwCallback: @long (# pos::< (# do 0 -> value; #); #);  (* DWORD *)
     dwTimeFormat: @long (# pos::< (# do 4 -> value; #); #);  (* DWORD *)
     dwAudio: @long (# pos::< (# do 8 -> value; #); #);  (* DWORD *)
  #);
sizeOf_MCI_SET_PARMS: (# exit 12 #);

MCI_PLAY_PARMS: externalRecord
  (# dwCallback: @long (# pos::< (# do 0 -> value; #); #);  (* DWORD *)
     dwFrom: @long (# pos::< (# do 4 -> value; #); #);  (* DWORD *)
     dwTo: @long (# pos::< (# do 8 -> value; #); #);  (* DWORD *)
  #);
sizeOf_MCI_PLAY_PARMS: (# exit 12 #);

MCI_INFO_PARMS: externalRecord
  (# dwCallback: @long (# pos::< (# do 0 -> value; #); #);  (* DWORD *)
     lpstrReturn: @long (# pos::< (# do 4 -> value; #); #);  (* LPSTR *)
     dwRetSize: @long (# pos::< (# do 8 -> value; #); #);  (* DWORD *)
  #);
sizeOf_MCI_INFO_PARMS: (# exit 12 #);

(* parameter block for MCI_STATUS command message *)
MCI_STATUS_PARMS: externalRecord
  (# dwCallback: @long (# pos::< (# do 0 -> value; #); #);  (* DWORD *)
     dwReturn: @long (# pos::< (# do 4 -> value; #); #);  (* DWORD *)
     dwItem: @long (# pos::< (# do 8 -> value; #); #);  (* DWORD *)
     dwTrack: @long (# pos::< (# do 12 -> value; #); #);  (* DWORD *)
  #);
sizeOf_MCI_STATUS_PARMS: (# exit 16 #);

MCI_GENERIC_PARMS: externalRecord
  (# dwCallback: @long (# pos::< (# do 0 -> value; #); #);
  #);

sizeOf_MCI_GENERIC_PARMS: (# exit 4 #);

mciSendCommand: external
  (# IDDevice, uMsg, fdwCommand, dwParam: @integer;
     result: @integer;
  enter (IDDevice, uMsg, fdwCommand, dwParam)
  do 'mciSendCommandA' -> callStd;
  exit result
  #);

mciGetErrorString: external
  (# mcierr: @integer;
     pszText: @integer;
     cchText: @integer;
     res: @integer;
  enter(mcierr, pszText, cchText)
  do 'mciGetErrorStringA' -> callStd;
  exit res
  #);

windowClassName: (# exit 'cdAudioDeviceWindowClass' #);

MCI_MAKE_TMSF: external
  (# t, m, s, f: @integer;
     value: @integer;
  enter (t, m, s, f) 
  do 'MCI_MAKE_TMSF_priv' -> callC
  exit value
  #);

lstrcpy: External
  (# charptr1, charptr2: @integer;
     result_ptr: @integer;
  enter (charptr1, charptr2)
  do 'lstrcpyA' -> callStd;
  exit result_ptr
  #);

std16x4toint: external
  (# func: ##cdAudioDeviceWindowProc;
     int: @integer;
  enter func##
  do 'copyinput'->callC
  exit int
  #);

cdAudioDeviceWindowProc: external
  (# windowHandle,message,wParam,lParam: @integer;
     result: @integer;               
     dispatch:
       (# 
       do 1 -> result;
     
          (if message
           //MM_MCINOTIFY then
              (if wParam 
               //MCI_NOTIFY_ABORTED  then
                  'MCI_NOTIFY_ABORTED' -> screen.putline;
               //MCI_NOTIFY_FAILURE  then
                  'MCI_NOTIFY_FAILURE' -> screen.putline;
               //MCI_NOTIFY_SUCCESSFUL then
                  'MCI_NOTIFY_SUCCESSFUL' -> screen.putline;
               //MCI_NOTIFY_SUPERSEDED then
                  'MCI_NOTIFY_SUPERSEDED' -> screen.putline;
              if);
           else
              (windowHandle,message,wParam,lParam)
                -> DefWindowProc -> result;
          if);
       #);
  enter (windowHandle,message,wParam,lParam)
  do StdExternalEntry;
     (if XsystemEnvPresent then
         &dispatch[]->XsystemEnvHandleCallback;
      else
         dispatch;
     if);
  exit result
  #);


registerAudioDeviceWindowClass:
  (# cstr: @cString;
     theClass: @WndClass;
     
  do windowClassName -> cstr.set;
     0 -> theClass.style;
     (if windowProcAddress=0 then
         cdAudioDeviceWindowProc## -> std16x4toint -> windowProcAddress; 
     if);
     windowProcAddress -> theClass.lpfnWndProc;
     hInstance -> theClass.hInstance;
     0 -> theClass.hbrBackGround;
     0 -> theClass.lpszMenuName;
     cstr.charPtr -> theClass.lpszClassName;
     0 -> theClass.cbClsExtra;
     0 -> theClass.cbWndExtra;
     theClass[] -> RegisterClass; 
     cstr.free;
  #);

isCdAudioDeviceWindowClassReg: booleanValue
  (# theClass: @integer;
     result: @integer;
  do 40 -> malloc -> theClass;
     get_beta_instance -> hInstance;
     (if theClass<>0 then
         (hInstance, windowClassName, theClass)
           -> GetClassInfo -> result;
         theClass -> free;
     if);
     (result<>0) -> value;
  #);

createAudioDeviceWindow:
  (# 
  do (0, windowClassName,'cdAudioDevice',WS_OVERLAPPED,
     10,10,400,400,0,0,hInstance,0) -> CreateWindowEx -> hwnd;   
  #);

windowProcAddress:
  (# 
  enter private.windowProcAddress
  exit private.windowProcAddress
  #);

wDeviceID:
  (# 
  enter private.wDeviceID
  exit private.wDeviceID
  #);

hwnd:
  (# 
  enter private.hwnd
  exit private.hwnd
  #);

hInstance:
  (# 
  enter private.hInstance
  exit private.hInstance
  #);

-- cdAudioDeviceOpen: doPart --
do (# theMCI_OPEN_PARMS: @MCI_OPEN_PARMS;
      theMCI_SET_PARMS: @MCI_SET_PARMS;
      deviceTypeCstr: @cString;
      errorCstr: @cString;
      dwReturn: @integer;
   do 28 -> malloc -> private.message;
      openL:
        (# 
        do (if private.message<>0 then
               (if not isCdAudioDeviceWindowClassReg then
                   registerAudioDeviceWindowClass;
               if);
               createAudioDeviceWindow;
               sizeOf_MCI_OPEN_PARMS -> malloc -> theMCI_OPEN_PARMS.ptr;
               (if theMCI_OPEN_PARMS.ptr<>0 then
                   
                   (* Open the CD audio device by specifying the device name. *)
                   'cdaudio' -> deviceTypeCstr.set;
                   deviceTypeCstr -> theMCI_OPEN_PARMS.lpstrDeviceType;
                   (0, MCI_OPEN,
                   MCI_OPEN_TYPE,theMCI_OPEN_PARMS.ptr)
                     -> mciSendCommand
                     -> dwReturn;
                   (if (dwReturn<>0)   then
                       (* Failed to open device. Do not close it; just return error. *)
                       130 -> errorCstr.init;
                       (dwReturn,errorCstr,128) -> mciGetErrorString;
                       errorCstr.get -> deviceError;
                       errorCstr.free;
                       leave openL
                    else
                       (* The device opened successfully; get the device ID. *)
                       theMCI_OPEN_PARMS.wDeviceID -> wDeviceID;
                       
                       sizeOf_MCI_SET_PARMS -> malloc -> theMCI_SET_PARMS.ptr;
                       (if theMCI_SET_PARMS.ptr<> 0 then
                           (* Set the time format to track/minute/second/frame (TMSF). *)
                           MCI_FORMAT_TMSF -> theMCI_SET_PARMS.dwTimeFormat;
                           (wDeviceID, MCI_SET, 
                           MCI_SET_TIME_FORMAT,theMCI_SET_PARMS.ptr)
                             -> mciSendCommand
                             -> dwReturn;
                           (if (dwReturn=0)   then
                            else
                               130 -> errorCstr.init;
                               (dwReturn,errorCstr,128) -> mciGetErrorString;
                               errorCstr.get -> deviceError;
                               errorCstr.free;
                           if);
                        else
                           'Allocation error in open. ' -> allocationError;
                       if);
                   if);
                   
                else
                   'Allocation error in open. ' -> allocationError;
               if);
            else
               130 -> errorCstr.init;
               (dwReturn,errorCstr,128) -> mciGetErrorString;
               errorCstr.get -> deviceError;
               errorCstr.free;
           if);
        #);
      (if theMCI_OPEN_PARMS.ptr<>0 then
          theMCI_OPEN_PARMS.ptr -> free;
          0 -> theMCI_OPEN_PARMS.ptr;
      if);
      (if theMCI_SET_PARMS.ptr<>0 then
          theMCI_SET_PARMS.ptr -> free;
          0 -> theMCI_SET_PARMS.ptr;
      if);
      (if deviceTypeCstr<>0 then
          deviceTypeCstr.free;
      if);
   #);
   inner open;
   
-- cdAudioDeviceClose: doPart --
do inner close;
   
   (wDeviceID, MCI_CLOSE, 0, 0) -> mciSendCommand;
   
   (if private.message<>0 then
       private.message -> free;
       0 -> private.message;
   if);
   
-- cdAudioDevicePlay: doPart --
do (# theMCI_PLAY_PARMS: @MCI_PLAY_PARMS;
      dwReturn: @integer;
      flags: @integer;
      errorCstr: @cString;
   do
      playL:
        (# 
        do sizeOf_MCI_PLAY_PARMS -> malloc -> theMCI_PLAY_PARMS.ptr;
           (if theMCI_PLAY_PARMS.ptr<>0 then
               (* Begin playback from the given track and play until the beginning 
                * of the next track. The window procedure function for the parent 
                * window will be notified with an MM_MCINOTIFY message when 
                * playback is complete. Unless the play command fails, the window 
                * procedure closes the device.    
                *)
               0 -> theMCI_PLAY_PARMS.dwFrom;
               0 -> theMCI_PLAY_PARMS.dwTo;
               (track, 0, 0, 0) -> MCI_MAKE_TMSF -> theMCI_PLAY_PARMS.dwFrom;
               (* (track, 0, 0, 0) -> MCI_MAKE_TMSF -> theMCI_PLAY_PARMS.dwTo; *)
               hwnd -> theMCI_PLAY_PARMS.dwCallback;
               MCI_FROM (* %Bor MCI_TO *) %Bor MCI_NOTIFY -> flags;
               (wDeviceID, MCI_PLAY,flags, theMCI_PLAY_PARMS.ptr)
                 -> mciSendCommand
                 -> dwReturn;
               (if dwReturn<>0 then
                   (* error *)
                   130 -> errorCstr.init;
                   (dwReturn,errorCstr,128) -> mciGetErrorString;
                   errorCstr.get -> deviceError;
                   errorCstr.free;
               if);
            else
               'Allocation error in play.' -> allocationError;
           if);
        #);
      
      (if theMCI_PLAY_PARMS.ptr<>0 then
          theMCI_PLAY_PARMS.ptr -> free;
      if);
   #);
   
-- cdAudioDeviceStop: doPart --
do (# theMCI_GENERIC_PARMS: @MCI_GENERIC_PARMS;
      dwReturn: @integer;
   do sizeOf_MCI_GENERIC_PARMS -> malloc -> theMCI_GENERIC_PARMS.ptr;
      (wDeviceID, MCI_STOP,MCI_NOTIFY, theMCI_GENERIC_PARMS.ptr)
        -> mciSendCommand
        -> dwReturn;
      
      theMCI_GENERIC_PARMS.ptr -> free;
   #);
   
-- cdAudioDeviceNoOfTracks: doPart --
do (# theMCI_STATUS_PARMS: @MCI_STATUS_PARMS;
      dwReturn: @integer;
      errorCstr: @cString;
   do sizeOf_MCI_STATUS_PARMS -> malloc -> theMCI_STATUS_PARMS.ptr;
      (if theMCI_STATUS_PARMS.ptr<>0 then
          MCI_STATUS_NUMBER_OF_TRACKS -> theMCI_STATUS_PARMS.dwItem;
          (wDeviceID, MCI_STATUS, MCI_STATUS_ITEM , theMCI_STATUS_PARMS.ptr)
            -> mciSendCommand
            -> dwReturn;
          (if dwReturn = 0 then
              theMCI_STATUS_PARMS.dwReturn -> value;
           else
              (* error *)
              130 -> errorCstr.init;
              (dwReturn,errorCstr,128) -> mciGetErrorString;
              errorCstr.get -> deviceError;
              errorCstr.free;
          if);
          theMCI_STATUS_PARMS.ptr -> free;
      if);
   #);
   
-- cdAudioDeviceStopPrivate: descriptor --
(# wDeviceID: @integer;
   windowProcAddress: @integer;
   message: @integer;
   hwnd: @integer;
   hInstance: @integer;
#)
