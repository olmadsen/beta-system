ORIGIN '../editSheetBody';

INCLUDE       '~beta/guienv/private/winnt/guienv_ntiprivate'
       '~beta/guienv/private/winnt/fields_ntibody'
       '~beta/win32lib/wingdi'
       '~beta/win32lib/wingdiconsts'
       '~beta/win32lib/systemmetrics'
       '~beta/win32lib/winuserconsts'
       '~beta/guienv/private/winnt/richTextConsts';

-- lib: Attributes --

bitComp:
  (# style: @integer; mask: @integer; 
  enter (style,mask)
  do style %Band (%Bnot mask)->style; 
  exit style
  #);
VK_HOME: (#  exit 0x24 #);
VK_END: (#  exit 0x23 #);
WS_EX_CLIENTEDGE: (#  exit 0x00000200 #);
ENM_MOUSEEVENTS: (#  exit 0x00020000 #);
EM_SETBKGNDCOLOR: (#  exit (WM_USER+67) #);

-- guienvLib: attributes --
extractColor:
  (# theColor: @color;
     theColorRef: @integer;
  enter theColorRef
  do 0 -> theColorRef.%getByte -> theColor.red;
     1 -> theColorRef.%getByte -> theColor.green;
     2 -> theColorRef.%getByte -> theColor.blue;
  exit theColor
  #);

-- getDefaultHighlightTextImpl: doPart --
do COLOR_HIGHLIGHTTEXT -> GetSysColor -> colorRef;
   
   colorRef -> extractColor -> c;
   c.red * 255 -> c.red;
   c.green * 255 -> c.green;
   c.blue * 255 -> c.blue;
   
-- getDefaultHighlightImpl: doPart --
do COLOR_HIGHLIGHT -> GetSysColor -> colorRef;
   colorRef -> extractColor -> c;
   c.red * 255 -> c.red;
   c.green * 255 -> c.green;
   c.blue * 255 -> c.blue;

-- editsheetUpdateRect: doPart --
do (if item[]<>NONE then
       r[] -> makeNtRectPtr -> rectPtr;
       (item.interfaceObjectID, rectPtr, 1) -> InvalidateRect;
       rectPtr -> free;
   if);

-- homeKeyImpl: doPart --
do VK_HOME->theKey
   
-- endKeyImpl: doPart --
do VK_END -> theKey
   
-- platformImpl: doPart --
do win32 -> value;

-- ShiftModifierBody: dopart --
do VK_SHIFT -> m; 
   
-- ControlModifierBody: dopart --
do VK_CONTROL -> m;

-- isModifierOnBody: doPart --
do theModifier->isVKeyDown -> value;
   
-- scrollbarWidthImpl: doPart --
do SM_CXVSCROLL->GetSystemMetrics->w;
   
-- scrollbarHeightImpl: doPart --
do SM_CYHSCROLL->GetSystemMetrics->h;
   
-- createTheEditTextStyleImpl: doPart --
do &textStyle[]->theTextStyle[];
   'Courier New' -> theTextStyle.name;
   8->theTextStyle.size;
   
-- createTheHeaderTextStyleImpl: doPart --
do &textStyle[]->theTextStyle[];
   'MS Sans Serif' -> theTextStyle.name;
   8->theTextStyle.size;
   
-- getDefaultBgColorImpl: doPart --
do COLOR_BTNFACE -> GetSysColor -> theColorRef;
   
   0 -> theColorRef.%getByte -> c.red;
   1 -> theColorRef.%getByte -> c.green;
   2 -> theColorRef.%getByte -> c.blue;
   
   c.red * 255 -> c.red;
   c.green * 255 -> c.green;
   c.blue * 255 -> c.blue;
   
-- theEditTextLib: attributes --
textFieldNotiMethods: windowItemNotificationMethods
  (#
     handleNotification:: 
       (#
          processNotify:
            (#
               code1: @integer;
               message: @integer;
               newWparam: @integer;
               newLparam: @integer;
               longInt: @CStruct
                 (#
                    ByteSize::  (#  do 4->Value;  #);
                    loWord: signedShort
                      (# Pos::  (#  do 0->Value;  #);  #);
                    hiWord: signedShort
                      (# Pos::  (#  do 2->Value;  #);  #);
                    
                 enter R[1]
                 exit R[1]
                 #);
               oldInfo: ^messageInfo;
               
            do
               false->didSomething;
               (%getLongAt(info.lParam+8))->code1;
               (* Above line tos_converted from: info.lParam+8->tos'%adrGetLong'->code1; *)
               (if code1
                // EN_MSGFILTER then
                   (%getLongAt(info.lParam+12))->message;
                   (* Above line tos_converted from: info.lParam+12->tos'%adrGetLong'->message; *)
                   
                   (if (message=WM_LBUTTONUP)
                       or
                       ((message=WM_MBUTTONUP) and reactOnMouseUp)
                       or
                       ((message=WM_RBUTTONUP) and reactOnMouseUp)
                       then
                       
                       true->private.notification;
                       &messageInfo[]->oldInfo[];
                       info.wParam->oldInfo.wParam;
                       info.lParam->oldInfo.lParam;
                       info.message->oldInfo.message;
                       info.where->oldInfo.where;
                       info.time->oldInfo.time;
                       (%getLongAt(info.lParam+16))->newWparam;
                       (* Above line tos_converted from: info.lParam+16->tos'%adrGetLong'->newWparam; *)
                       (%getLongAt(info.lParam+20))->newLparam;
                       (* Above line tos_converted from: info.lParam+20->tos'%adrGetLong'->newLparam; *)
                       newWparam->longInt;
                       longInt.hiWord->info.wParam.hiWord;
                       longInt.loWord->info.wParam.loWord;
                       newWparam->info.wParam;
                       newLparam->longInt;
                       longInt.hiWord->info.lParam.hiWord;
                       longInt.loWord->info.lParam.loWord;
                       newLparam->info.lParam;
                       message->info.message;
                       GetMessagePos->longInt;
                       (longInt.loWord,longInt.hiWord)->info.where;
                       getMessageTime->info.time;
                       
                       (if message
                        //WM_LBUTTONUP then
                           1->info.button; 
                        //WM_MBUTTONUP then
                           2->info.button;
                        //WM_RBUTTONUP then
                           3->info.button; 
                       if);
                       
                       FALSE->info.callback;
                       
                       theEventHandler.onMouseUp;
                       
                       oldInfo.wParam->info.wParam;
                       oldInfo.lParam->info.lParam;
                       oldInfo.message->info.message;
                       oldInfo.where->info.where;
                       oldInfo.time->info.time;
                       false->private.notification;
                       1 -> info.result;
                       true->didSomething;
                   if);
               if);
            #);
          didSomething: @boolean;
          type: @integer;
          
       do
          false->didSomething;
          
          (if info.message
           // WM_COMMAND then
              info.wParam.hiWord->type;
              (if type = EN_CHANGE then onTouched;  if);
              
           // WM_NOTIFY then
              processNotify; 
          if);
          didSomething or info.handled->info.handled;
       #);
  #);

textFieldMethods: windowItemMethods
  (#      
     dispatchMessage::
       (# didSomething: @boolean;
          performEdit: @boolean;
          clipboardLength: @integer;
          clipboardText: ^text;
          start,end: @integer; length: @integer;
          p: @point; pos: @integer;
          ch: @char;
          theSel: @CHARRANGE;
          thePosPtr: @integer;
       do true -> didSomething;
          (if info.message 
              
           //WM_KEYDOWN then
              info.wParam -> ch;
              (if ch
               //'V' then 
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,WM_PASTE, 0, 0) -> sendMessage;
                  if);
               //'X' then
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,WM_CUT, 0, 0) -> sendMessage;
                  if);
               //'Z' then
                  (if (VK_CONTROL -> isVKeyDown) then
                      FALSE -> info.callback;
                      true -> info.handled;
                      (interfaceObjectID,EM_UNDO, 0, 0) -> sendMessage;
                  if);
               else
                  false -> didSomething;
              if);
              
           //WM_MBUTTONUP then
              (if reactOnMouseUp then
                  theEventHandler.onMouseUp;
                  true -> didSomething;
              if);
              
           //WM_LBUTTONDOWN  then
              (if not private.allowDragDrop then
                  selection -> (start,end);
                  (if start<>end then
                      (if (not (VK_SHIFT -> isVKeyDown)) then
                          (if (not (VK_CONTROL -> isVKeyDown)) then
                              (info.lParam.loWord,info.lParam.hiWord) -> p;
                              
                              p -> makeNtPointPtr -> thePosPtr;
                              (if thePosPtr<>0 then
                                  (interfaceobjectid,EM_CHARFROMPOS,0,thePosPtr) -> SendMessage -> pos; 
                                  
                                  8 -> malloc -> theSel.ptr;
                                  (if theSel.ptr<>0 then
                                      pos -> theSel.cpMin;
                                      pos -> theSel.cpMax;
                                      (interfaceobjectid,EM_EXSETSEL,0,theSel.ptr) 
                                        -> SendMessage;
                                      theSel.ptr -> free;
                                  if);
                                  
                                  thePosPtr -> free;
                              if);
                          if);
                      if);
                  if);
              if);
              
           //WM_PASTE then 
              FALSE -> info.callback;
              clipboard.textContents -> clipboardText[];
              (if clipboardText[]<>NONE then 
                  clipboardText.length -> clipboardLength;
                  selection -> (start,end);
                  end - start -> length;
                  true -> performEdit;
                  none -> this(guienv).private.textfieldChangeText[];
                  (if (clipboardLength<>0) then
                      (if (length<>0) then
                          (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                      if);
                      (if performEdit then
                          clipboardText[] -> this(guienv).private.textfieldChangeText[];
                           
                          (start,clipboardLength) -> theEventHandler.onBeforeChange 
                            -> performEdit;
                          (if performEdit then
                              callDefaultWindowProc;
                              (* handleTextChanged; *)
                          if);
                          none -> clipboardText[];
                          none -> this(guienv).private.textfieldChangeText[];
                      if);
                  if);
              if);
              
           //WM_CUT then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              true -> performEdit;
              
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  
                  (if performEdit then
                      callDefaultWindowProc;
                      (* handleTextChanged; *)
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
              
           //WM_CLEAR then
              FALSE -> info.callback;
              selection -> (start,end);
              end - start -> length;
              (if (length<>0) then
                  selection.contents -> this(guienv).private.textfieldChangeText[];
                  (start,-length) -> theEventHandler.onBeforeChange -> performEdit;
                  (if performEdit then
                      callDefaultWindowProc;
                      (* handleTextChanged; *)
                  if);
                  none -> this(guienv).private.textfieldChangeText[];
              if);
              
           //EM_UNDO then
              FALSE -> info.callback;
              (0,0) -> theEventHandler.onBeforeChange -> performEdit;
              (if performEdit then
                  callDefaultWindowProc;
              if);
              
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
     
  #);

-- prohibitKeydownImpl: doPart --
do (* Use in r4.2 *) false -> this(textField).private.performEdit; 

-- theEditTextUpdateMargins: doPart --
do setTextFieldMargins;

-- theEditTextSetReadOnly: doPart --
do
   interfaceObjectID->windowID;
   (if value then
       (windowID,EM_SETREADONLY,1,0)->SendMessage;
       (windowID,EM_SETBKGNDCOLOR,0,COLOR_BTNFACE->GetSysColor)
         ->SendMessage;
       
    else
       (windowID,EM_SETREADONLY,0,0)->SendMessage;
       (windowID,EM_SETBKGNDCOLOR,1,0)->SendMessage;
   if); 
   
   
-- setEditTextColorImpl: doPart --
do (# cf: @CHARFORMAT; windowID: @integer; 
      theColorRef: @integer;
   do
      sizeOfCharFormat->malloc->cf.ptr;
      (if cf.ptr <> 0 then
          THIS(textField).interfaceObjectID->windowID;
          (cf.ptr,0,sizeOfCharFormat)->memset;
          sizeOfCharFormat->cf.cbSize;
          CFM_COLOR->cf.dwMask;
          
          (value.red div 256,0) -> theColorRef.%putByte;
          (value.green div 256,1) -> theColorRef.%putByte;
          (value.blue div 256,2) -> theColorRef.%putByte;
          (2,3) -> theColorRef.%putByte;
          
          theColorRef->cf.crTextColor;
          (windowID,EM_SETCHARFORMAT,0,cf.ptr)->SendMessage;
          cf.ptr->free;
      if);
   #);
   
-- setEditBgColorImpl: doPart --
do (# theColorRef: @integer;
   do (value.red div 256,0) -> theColorRef.%putByte;
      (value.green div 256,1) -> theColorRef.%putByte;
      (value.blue div 256,2) -> theColorRef.%putByte;
      (2,3) -> theColorRef.%putByte; 
      (THIS(textField).interfaceObjectID,EM_SETBKGNDCOLOR,0,theColorRef)
        ->SendMessage;
   #)
   
-- addChangeNotificationsImpl: doPart --
do
   interfaceObjectID->windowID;
   (windowID,EM_GETEVENTMASK,0,0)->SendMessage->theMask;
   theMask %Bor ENM_CHANGE->theMask;
   (* Above line tos_converted from: (theMask,ENM_CHANGE)->tos'%or'->theMask; *)
   theMask %Bor ENM_MOUSEEVENTS->theMask;
   (* Above line tos_converted from: (theMask,ENM_MOUSEEVENTS)->tos'%or'->theMask; *)
   (windowID,EM_SETEVENTMASK,0,theMask)->SendMessage->theMask;
   
   
-- removeChangeNotificationsImpl: doPart --
do
   interfaceObjectID->windowID;
   (windowID,EM_GETEVENTMASK,0,0)->SendMessage->theMask;
   (theMask,ENM_CHANGE)->bitComp->theMask;
   theMask %Bor ENM_MOUSEEVENTS->theMask;
   (* Above line tos_converted from: (theMask,ENM_MOUSEEVENTS)->tos'%or'->theMask; *)
   (windowID,EM_SETEVENTMASK,0,theMask)->SendMessage->theMask;
   
-- theEditTextCreate: doPart --
do &textFieldNotiMethods[]->theNotiMethods;
   &textfieldMethods[] -> theMethods;
   0 -> windowItemExStyle;
   
   
-- theEditTextOpen: doPart --
do interfaceObjectID->windowID;
   ENM_CHANGE %Bor ENM_MOUSEEVENTS->theMask;
   (* Above line tos_converted from: (ENM_CHANGE,ENM_MOUSEEVENTS)->tos'%or'->theMask; *)
   (windowID,EM_SETEVENTMASK,0,theMask)->SendMessage;
   THIS(editSheet).private.theTextStyle[]->defaultStyle;
   (0x00,0x00,32000) -> setEditTextColor;
   hide;
   true->border.visible;
   (0,0) -> margin; 
   (0,gridOffset)->position;
   (100,18)->size;
   true->isOpen;
   
   
-- scroller1Lib: attributes --
scrollerMethods: windowItemMethods
  (#
     vertical: (#  exit 0 #);
     horizontal: (#  exit 1 #);
     contentsWidth,contentsHeight,viewWidth,viewHeight: @integer;
     dispatchMessage::< 
       (#
          processScroll:
            (#
               amount: @integer;
               absolute: @boolean;
               width,height: @integer;
               direction,orientation: @integer;
               doNotProcess: @boolean;
            enter orientation
            do
               -1 -> direction;
               privateViewSize->(width,height);
               (if info.wParam.loWord
                // SB_LINELEFT // SB_LINEUP then
                   lineHeight->amount; 
                   SB_LINELEFT -> direction;
                // SB_LINERIGHT // SB_LINEDOWN then
                   - lineHeight->amount; 
                   SB_LINERIGHT -> direction;
                // SB_PAGELEFT // SB_PAGEUP then
                   (if orientation = vertical then
                       height->amount; 
                    else
                       width->amount; 
                   if);
                // SB_PAGERIGHT // SB_PAGEDOWN then
                   (if orientation = vertical then
                       - height->amount
                    else
                       - width->amount; 
                   if);
                // SB_THUMBPOSITION then
                   - info.wParam.hiWord->amount; true->absolute; 
                //SB_ENDSCROLL then
                   true -> doNotProcess;
               if);
               (if not doNotProcess then
                   (orientation,direction,amount) -> onBeforeScroll -> amount;
                   (if orientation = vertical then
                       (if absolute then
                           (0,amount)->scrollTo; 
                        else
                           (0,amount)->scroll; 
                       if);
                       
                    else
                       (if absolute then
                           (amount,0)->scrollTo; 
                        else
                           (amount,0)->scroll; 
                       if);
                   if);
                   (orientation,direction,amount) -> onAfterScroll;
               if);
               
            #);
       do
          (if info.message
           // WM_HSCROLL then
              horizontal->processScroll; 
           // WM_VSCROLL then
              vertical->processScroll; 
          if);
          
       #);
  #);

-- scroller1Create: doPart --
do WS_HSCROLL->windowItemStyle; &scrollerMethods[]->theMethods; 
   
-- contentsTypePlatformOpen: doPart --
do false -> this(windowItem).private.updateOnResize;
   
