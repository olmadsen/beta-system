ORIGIN '../editSheet';
MDBODY 
mac 'macintosh/editSheet_macBody'
ppc 'macintosh/editSheet_macBody'
ppcmac 'macintosh/editSheet_macBody'
nti 'winnt/editSheet_win32Body'
default 'X11/editSheet_unixBody';

INCLUDE 
       '~beta/guienv/utils/graphicsadds'
       '~beta/guienv/utils/scrolleradds'
       '~beta/guienv/private/datastructures/sequence'
'cell';

-- lib: Attributes --
putPoint:
  (# h,v: @integer; 
  enter (h,v)
  do '('->put; h->putInt; ','->put; v->putInt; ')'->put; 
  #);
putRectangle:
  (# top,left,bottom,right: @integer; 
  enter ((top,left),(bottom,right))
  do
     '( '->putText;
     (top,left)->putPoint;
     ' , '->putText;
     (bottom,right)->putPoint;
     ' )'->putLine;
     
  #);

homeKey:
  (# theKey: @integer <<SLOT homeKeyImpl: doPart>> exit theKey #);

endKey:
  (# theKey: @integer <<SLOT endKeyImpl: doPart>> exit theKey #);

win32: (# exit 1 #);
mac:   (# exit 2 #);
unix:  (# exit 3 #);

platform: integerValue
  (# <<SLOT platformImpl: doPart>> #);

-- editSheetLib: Attributes --

getDefaultHighlightText:
  (* Text color in selected items. *)
  (# c: @color;
     (* private *)
     colorRef: @integer;
  <<SLOT getDefaultHighlightTextImpl: doPart>>
  exit c
  #);

getDefaultHighlight:
  (* Background color of selected items. *)
  (# c: @color;
     (* private *)
     colorRef: @integer;
  <<SLOT getDefaultHighlightImpl: doPart>>
  exit c
  #);

updateRect:
  (# r: @rectangle;
     item: ^windowItem;
     (* private *)
     rectPtr: @integer;
  enter (item[],r)
  <<SLOT editsheetUpdateRect: doPart>>
  #);

toStyledText:
  (# t: ^text; st: ^styledText; 
  enter t[]
  do &styledText[]->st[]; 
     (if t[]<>NONE then t->st; if);
  exit st[]
  #);
toStdText:
  (# t: ^text; st: ^styledText; 
  enter st[]
  do &Text[]->t[]; 
     (if st[]<>NONE then st->t; if);
  exit t[]
  #);

isModifierOn: booleanValue
  (* Tell if theModifier is currently being pressed *)
  (# theModifier: @Modifier;
  enter theModifier
  <<SLOT isModifierOnBody: doPart>>
  #);

Modifier: 
  (# m: @Integer; enter m do INNER exit m #);

ShiftModifier: Modifier
  (# <<SLOT ShiftModifierBody: dopart>> #);

ControlModifier: Modifier
  (# <<SLOT ControlModifierBody: dopart>> #);

scrollbarWidth:
  (# w: @integer;
  <<SLOT scrollbarWidthImpl: doPart>>
  exit w
  #);

scrollbarHeight:
  (# h: @integer;
  <<SLOT scrollbarHeightImpl: doPart>>
  exit h
  #);

createTheEditTextStyle:
  (# theTextStyle: ^textStyle;
  <<SLOT createTheEditTextStyleImpl: doPart>>
  exit theTextStyle[]
  #);

createTheHeaderTextStyle:
  (# theTextStyle: ^textStyle;
  <<SLOT createTheHeaderTextStyleImpl: doPart>>
  exit theTextStyle[]
  #);

getDefaultBgColor:
  (* Use this until we get to r4.2. There is a bug in windowItem.backgroundColor on Win32. *)
  (# c: @color;
     theColorRef: @integer;
  <<SLOT getDefaultBgColorImpl: doPart>>
  exit c
  #);

gridOffset: (#  exit 0 #);

field_info:
  (#
     theCellRect: @cell
       (# isOpen: @boolean;
          
          open::
            (# 
            do hide; 
               true -> isOpen;
            #);
          
          contents: ^styledText;
          
          drawThePixmap:
            (# pmWidth,pmHeight: @integer;
            do (if (privCellPixmap[]<>NONE) and isOpen then
                   father.graphics
                   (# overrideChildren:: 
                        (# do true -> value #);
                      x,y: @integer;
                      width,height: @integer;
                      theFrame: @rectangle;
                   do
                      frame -> theFrame;
                      (1,1) -> theFrame.inset;
                      theFrame -> clipRectangle; 
                      
                      size -> (width,height);
                      privCellPixmap.width -> pmWidth;
                      privCellPixmap.height -> pmHeight;
                      theCellRect.position -> (x,y);
                      
                      (height div 2) - (pmHeight div 2) -> pmHeight;
                      x+1 -> x;
                      y + pmHeight -> y;
                      (privCellPixmap[], (0, 0), (x,y), pmWidth,privCellPixmap.height)
                        -> drawRaster;
                      1 + pmWidth -> pmWidth
                   #)
               if);
            #);
          
          drawTheText:
            (#
               acColor,bgColor: @color;
               w,h,result: @integer;
               pmWidth,pmHeight: @integer;
               selected: @boolean;
            do
               
               cellColor->acColor;
               
               (if (contents[] <> none) or (privCellPixmap[]<>NONE) then
                   
                   (if myRow[]<>NONE then
                       (if myRow.private.selected then
                           selection.textColor->acColor; 
                           true -> selected;
                       if);
                    else
                       (if THIS(editSheet).private.currentFieldInfo[] <> none
                           then
                           (if THIS(editSheet).private.currentFieldInfo.j = j
                               then
                               selection.textColor->acColor; 
                           if);
                       if);
                   if);
                   
                   size->(w,h);
                   
                   (if privCellPixmap[]<>NONE then
                       drawThePixmap;
                       privCellPixmap.width -> pmWidth;
                       privCellPixmap.height -> pmHeight;
                       1 + pmWidth -> pmWidth
                   if);
                   
                   graphics
                   (# overrideChildren:: 
                        (# do true -> value #);
                      tempText: @text;
                      y,delta: @integer;
                      
                   do 
                      frame -> clipRectangle;
                      
                      (if selected then
                          
                          (selection.backgroundColor,
                          position,(w,h))
                            -> myRow.private.eraseBackground;
                          
                          selection.backgroundColor 
                            -> pen.foregroundColor;
                          ((pmWidth,1),(w,h)) -> fillRect;
                       else
                          ((* getDefaultBgColor *) this(editSheet).private.scroller1.contents.backgroundColor,
                          position,(w,h))
                            -> myRow.private.eraseBackground; 
                          
                          (* getDefaultBgColor *) this(editSheet).private.scroller1.contents.backgroundColor
                            -> pen.foregroundColor;
                          ((pmWidth,1),(w,h))  -> fillRect;
                      if);
                      
                      (if contents[]<>NONE then
                          (if not contents.empty then
                              THIS(editSheet).private.textTopOffset -> delta;
                              delta -> y;
                              contents.reset;
                              THIS(editSheet).private.theTextStyle[] -> style;
                              
                              acColor -> pen.foregroundColor;
                              contents.scanAll
                              (# 
                              do (if ch=ascii.nl then
                                     (pmWidth,y) -> moveTo;
                                     tempText[] -> drawText;
                                     tempText.clear;
                                     y+delta -> y;
                                  else
                                     ch -> tempText.put;
                                 if);
                              #);
                              (if not tempText.empty then
                                  (pmWidth,y) -> moveTo;
                                  tempText[] -> drawText;
                              if);
                              
                              
                          if);
                      if);
                   #);
               if);
            #);
          eventHandler:: 
            (#
               privOnRefresh: 
                 (# 
                 do (if THIS(editSheet).private.currentFieldInfo[] <> THIS(field_info)[] then
                        drawTheText; 
                     else
                        (if THIS(editSheet).private.currentFieldInfo[] <> NONE then
                            THIS(editSheet).private.currentFieldInfo.theCellRect.drawThePixmap;
                        if);
                    if);
                 #);
               
               onMouseDown:: 
                 (# 
                 do this(editSheet).theEventHandler.onMouseDown;
                    (i,j)->THIS(editSheet).private.theEditFields.select;
                    true -> THIS(editSheet).private.theEditText.reactOnMouseUp;
                 #);
               onMouseUp::
                 (# 
                 do this(editSheet).theEventHandler.onMouseUp;
                 #);
            #);
       #);
     
     myRow: ^row;
     i,j: @integer;
     cellColor: @color;
     privCellPixmap: ^pixmap;
     
  enter (i,j)
  exit (i,j)
  #);




-- editSheetOnEnableTarget: DoPart --
do
   (if private.theEditText.isOpen then
       (if private.theEditText.visible then
           private.theEditText[]->target; 
       if);
   if);
   
-- editSheetOnMouseDown: doPart --
do inner onMouseDown;
   
-- editSheetOnMouseUp: doPart --
do inner onMouseUp;

-- editSheetOpen: DoPart --
do (# firstRow: ^row; tempHeight: @integer;
      white: (#  exit (65535,65535,65535) #);
   do (0,0)->position;
      (500,230)->size;
      private.theRows.init;
      private.scroller1.open;
      private.scroller1.show;
      createTheEditTextStyle -> private.theTextStyle[];
      private.theTextStyle.lineHeight+2->private.lineHeight;
      (* (if private.lineHeight < 20 then 20->private.lineHeight;  if); *)
      true->border.visible;
      borderStyles.shadowIn->border.style;
      private.scroller1.contents.initTheTextField;
      private.theEditFields.init;
      gridOffset->private.next_vertical_pos;
      
      getDefaultHighlightText -> selection.textColor;
      getDefaultHighlight -> selection.backgroundColor;
      
      white -> private.scroller1.contents.backgroundColor;
      
      INNER open;
      private.header.createHeadingLabels;
      (1,1)->private.theEditFields.select;
      1 -> private.theRows.get -> firstRow[];
      (if firstRow[]<>NONE then
          firstRow.height -> tempHeight;
       else
          private.lineHeight -> tempHeight;
      if);
      L: private.theHeadings.scan
        (# 
        do (current.primInfo.width-1,tempHeight-1)->private.theEditText.size; leave L
        #);
   #);
   

-- editSheetClose: DoPart --
do INNER close;   

-- editSheetSetStyle: DoPart --
do   

-- editSheetGetStyle: DoPart --
do private.theTextStyle[]->theStyle[];   

-- editSheetSetReadOnly: DoPart --
do (if (colNo>0) and (colNo<noOfColumns+1) then
       (colNo,value) -> private.columnsInfoList.setLock;
    else
       value->private.readOnly; value->private.theEditText.setReadOnly; 
   if);

-- editSheetClear: DoPart --
do private.clear; INNER clear;   

-- editSheetRefresh: DoPart --
do private.theEditFields.doRefresh;  

-- editSheetFitToContents: DoPart --
do
   (# w,h,w1,h1: @integer; 
   do
      private.scroller1.contents.size->(w,h);
      private.scroller1.size->(w1,h1);
      (if private.next_vertical_pos+private.lineHeight > h then
          private.next_vertical_pos+private.lineHeight-scrollbarHeight->h; 
       else
          h1+scrollbarHeight+10->h; 
      if);
      (w1-scrollbarWidth,h)->private.scroller1.contents.size;
      true->private.scroller1.contents.bindRight;
   #)

-- editSheetNoOfColumns: DoPart --
do private.noOfColumns->value;   

-- editSheetNoOfRows: DoPart --
do private.noOfRows->value;   

-- editSheetAddHeading: DoPart --
do
   private.noOfColumns+1->private.noOfColumns;
   theHeading[]->private.theHeadings.add;

-- editSheetSetFocus: DoPart --
do (c,r)->private.theEditFields.select;   
   
-- editSheetGetFocus:DoPart --
do (if private.currentFieldInfo[] <> none then
       (private.currentFieldInfo.i,private.currentFieldInfo.j)->(c,r); 
   if);
   
-- setSelTextColor: doPart --
do value -> this(editSheet).private.selTextCol;
   (* value -> this(editSheet).private.theEditText.setEditTextColor; *)
   update;
   
-- getSelTextColor: doPart --
do this(editSheet).private.selTextCol -> value;
   
-- setSelBgColor: doPart --
do value -> this(editSheet).private.selBgCol;
   (* value -> this(editSheet).private.theEditText.setEditBgColor; *)
   update;
   
-- getSelBgColor: doPart --
do this(editSheet).private.selBgCol -> value;
   
-- editSheetSelectionFirst: doPart --
do scanL:
     private.selectionList.scan
     (# 
     do current[] -> theItem[];
        leave scanL
     #);
   
-- editSheetSelectionClear: doPart --
do scan
   (# 
   do current.deselect;
      current.update;
   #);
   
-- editSheetSelectionScan: doPart --
do private.selectionList.scan
   (# 
   do current[] -> this(scan).current[];
      inner scan
   #);
   
-- setCellTextColor: DoPart --
do (# result: @integer;
   do (c,r,value) -> private.theEditFields.setCellColor -> result;
      (if result//CELL_NOT_FOUND//ROW_NOT_FOUND then
          result -> failure;
      if);
   #);

-- getCellTextColor: DoPart --
do (# result: @integer;
   do (c,r) -> private.theEditFields.getCellColor -> (value,result);
      (if result//CELL_NOT_FOUND//ROW_NOT_FOUND then
          result -> failure;
      if);
   #);
   
-- editSheetScanRows: doPart --
do private.theRows.rows.scan
   (# 
   do current[] -> this(scanRows).current[];
      inner scanRows;
   #);
   
-- rowInit: DoPart --
do private.theFieldInfos.init; 
   this(editSheet).private.lineHeight -> height;
   INNER init;   
   
-- rowSetHeight: doPart --
do value -> THIS(row).private.height;
   
-- rowGetHeight: doPart --
do THIS(row).private.height -> value;
   
-- editSheetAddRow: DoPart --
do
   (if theRow[] <> none then 
       private.noOfRows+1->private.noOfRows;
       
       false -> theRow.private.deleted;
       theRow[]->private.theRows.append;  
       
       (if not private.theEditText.visible then
           theRow.select;
           (if private.currentFieldInfo[]<>NONE then
               (if private.currentFieldInfo.theCellRect.contents[] <> none then
                   private.currentFieldInfo.theCellRect.contents[]->private.theEditText.myInsert; 
               if);
           if);
           private.theEditText.show;
       if);
   if);
   private.setContentsSize;
   
-- editSheetDeleteRow: doPart --
do 
   (if theRow[] <> none then 
       private.noOfRows-1->private.noOfRows;
       (if private.noOfRows=0 then
           (if private.theEditText.visible then
               private.theEditText.hide;
           if);
       if);
       true -> theRow.private.deleted;
       theRow[]->private.theRows.remove; 
       (* theRow.private.theFieldInfos.clear; *)
   if);
   
-- editSheetDisableOnTouchedEvents: DoPart --
do private.theEditText.removeChangeNotifications;   

-- editSheetEnableOnTouchedEvents: DoPart --
do private.theEditText.addChangeNotifications;   

-- rowAddValue: DoPart --
do (if private.theFieldInfos.size < noOfColumns then
       (# aField_info: ^field_info;
       do (if (value[] <> none) and (not private.deleted) then
              &field_info[]->aField_info[];
              this(row)[] -> aField_info.myrow[];
              value[]->toStyledText->aField_info.theCellRect.contents[];
              private.theFieldInfos.size+1 -> aField_info.i;
              aField_info[] -> private.theFieldInfos.append;
              (if THIS(editSheet).private.currentFieldInfo[] = none then
                  aField_info[]->THIS(editSheet).private.currentFieldInfo[]; 
              if);
              (if aField_info[] = THIS(editSheet).private.currentFieldInfo[] then
                  value[]->toStyledText->THIS(editSheet).private.theEditText.contents; 
              if);
          if);
       #)
   if);

-- rowGetValue: DoPart --
do
   (if (i > 0) and (i <= private.theFieldInfos.size) 
       (* and (not private.deleted) *) then
       L:
         private.theFieldInfos.scan
         (# 
         do (if current.i=i then 
                (if current[] = THIS(editSheet).private.currentFieldInfo[] then
                    THIS(editSheet).private.theEditText.contents->toStdText->v[];
                 else
                    current.theCellRect.contents[]->toStdText->v[];
                if);
                leave L;
            if);
         #);
   if);
   
-- rowSetValue: DoPart --
do
   (if (i > 0) and (i <= private.theFieldInfos.size) and (v[]<>NONE) then
       L:
         private.theFieldInfos.scan
         (# 
         do (if current.i=i then 
                
                (if THIS(editSheet).private.currentFieldInfo[] = none then
                    current[]->THIS(editSheet).private.currentFieldInfo[]; 
                if);
                (if current[] = THIS(editSheet).private.currentFieldInfo[] then
                    v[]->toStyledText->THIS(editSheet).private.theEditText.contents; 
                if);
                v[]->toStyledText->current.theCellRect.contents[];
                current.theCellRect.update;
                leave L
            if);
         #);
   if);
   
-- setCellPixmap: doPart --
do (if (c>0) and (c<=noOfColumns) then
       (if c>private.theFieldInfos.size then
           (for i:c repeat '' -> addValue; for);
       if);
       (if (c > 0) and (c <= private.theFieldInfos.size) then
           (if ((NONE,value[],c,r)->THIS(editSheet).theEventHandler.onBeforeChange) then
               L:
                 private.theFieldInfos.scan
                 (# 
                 do (if current.i=c then 
                        value[] -> current.privCellPixmap[];
                        current.theCellRect.drawThePixmap;
                        leave L
                    if);
                 #);  
           if);
       if);
   if);
   
-- getCellPixmap: doPart --
do (if (c > 0) and (c <= private.theFieldInfos.size) then
       L:
         private.theFieldInfos.scan
         (# 
         do (if current.i=c then 
                current.privCellPixmap[] -> value[];
                leave L
            if);
         #);    
   if);
   
-- rowSelect: doPart --
do (this(row)[], extend)
     -> this(editSheet).private.selectionList.insert;
   true -> private.selected;
   this(row).update;
   
-- rowDeselect: doPart --
do this(row)[] -> this(editSheet).private.selectionList.remove;
   false -> private.selected;
   
-- rowUpdate: doPart --
do private.theFieldInfos.scan
   (# 
   do (if current.theCellRect.isOpen then
          current.theCellRect.update;
      if);
   #);
   
-- rowPrivate: Descriptor --
(#
   theFieldInfos: @sequence 
     (# element:: field_Info;  
        init::
          (# 
          do (if noOfColumns>0 then
                 noOfColumns -> extendCapacityRight;
             if);
          #);
     #);
   
   getPosition:
     (# h,v: @integer;
     do L:
          theFieldInfos.scan
          (# 
          do current.theCellRect.position -> (h,v);
             leave L
          #);
     exit (h,v)
     #);
   
   selected,deleted: @boolean;
   height: @integer;
   
   eraseBackground:
     (# c: @color;
        left,top,w,h,h2: @integer;
     enter (c,(left,top),(w,h))
     do 
        this(editSheet).private.theHeadings.totalWidth - 1 -> left;
        
        this(editSheet).private.scroller1.size->(w,h2);
        
        this(editSheet).private.scroller1.contents.graphics
        (# 
        do c -> pen.foregroundColor;
           ((left,top+1),(w,top+h)) 
             -> fillRect;
        #);
     #);
#)  


-- editSheetPrivate: descriptor --
(#
   readOnly: @boolean;
   next_vertical_pos: @integer;
   theTextStyle: ^textStyle;
   lineHeight: @integer;
   hdc,thePen,prevPen: @integer;
   textTopOffset: @integer;
   selTextCol: @color;
   selBgCol: @color;
   
   selectionList: @list
     (# element:: row;
        
        insert:
          (# 
             extendSelection: @boolean;
             elm: ^element;
             alreadyIn: @boolean;
          enter (elm[],extendSelection)
          do 
             (if not extendSelection then
                 (if (not multipleSelection)
                     or
                     not (ControlModifier->isModifierOn)
                     then
                     selection.clear;
                     clear;
                 if);
             if);
             (if not (elm[]->has) then
                 elm[] -> append;
             if);
          #);
        
        remove:
          (# elm: ^element;
             okToDelete: @boolean;
          enter elm[]
          do (if (elm[]->has) then
                 elm[] -> at -> delete;
             if);
          #);
        
        has: booleanValue
          (# elm: ^element;
          enter elm[]
          do scanL:
               scan
               (# 
               do (if current[]=elm[] then 
                      true -> value;
                      leave scanL
                  if);
               #);
          #);
     #);
   
   clear:
     (# firstRow: ^row;
        height: @integer;
     do
        theRows.clear;
        theEditFields.myClear;
        none ->currentFieldInfo[];
        none ->prevFieldInfo[];
        (1,1)->private.theEditFields.select;
        0->noOfRows;
        gridOffset->next_vertical_pos;
        private.theEditText.hide;
        (0,gridOffset+1)->private.theEditText.position;
        theRows.get -> firstRow[];
        (if firstRow[]<>NONE then
            firstRow.height -> height;
         else
            private.lineHeight -> height;
        if);
        L: theHeadings.scan
          (# 
          do
             (current.primInfo.width,height-1)->private.theEditText.size;
             leave L
          #);
        ''->toStyledText->private.theEditText.contents;
        true->update;
        theEditText.hide;
        
        (if scroller1.isOpen then
            (scroller1.contents[],((0,0),scroller1.contents.size)) -> updateRect;
        if);
     #);
   noOfRows: @integer;
   noOfColumns: @integer;
   
   columnsInfoList: @sequence
     (# element::
          (# locked: @boolean;
          #);
        
        setLock:
          (# value: @boolean;
             inx: @integer;
             elm: ^element;
          enter (inx,value)
          do (if inx>size then
                 inx - size -> extendCapacityRight;
             if);
             (for i:(inx-size) repeat
                  &element[] -> append;
             for);
             inx -> get -> elm[];
             (if elm[]<>NONE then
                 value -> elm.locked;
             if);
          #);
        
        getLock:
          (# value: @boolean;
             inx: @integer;
             elm: ^element;
          enter inx
          do inx -> get -> elm[];
             (if elm[]<>NONE then
                 elm.locked -> value;
             if);
          exit value
          #);
        
        add:
          (# 
          do &element[] -> append;
          #);
     #);
   
   privHeadingInfo:
     (# primInfo: ^headingInfo;
        x: @integer;
     #);
   
   theHeadings: @sequence
     (#
        element:: privHeadingInfo;
        
        totalWidth: @integer;
        
        add:
          (# theHeading: ^headingInfo; 
             thePrivHeadingInfo: ^privHeadingInfo;
             aPoint: ^point; h: @integer; 
          enter theHeading[]
          do
             &privHeadingInfo[] -> thePrivHeadingInfo[];
             noOfColumns->theHeading.inx;
             theHeading[]-> thePrivHeadingInfo.primInfo[];
             totalWidth -> thePrivHeadingInfo.x;
             thePrivHeadingInfo[] -> append;
             
             theHeading.width + totalWidth -> totalWidth;

             1->sizes.extend;
             &point[]->aPoint[];
             (theHeading.width,lineHeight)->aPoint;
             aPoint[]->sizes[sizes.range][];
             
             columnsInfoList.add;
          #);
        
     #);
   sizes: [0] ^point;
   theRows: @
     (# curR: @integer;
        
        init: (# do rows.init; #);
        
        rows: @sequence
          (# 
             element:: row;
             
             init::
               (# 
               do 31 -> extendCapacityRight;
               #);
             
             remove:
               (# theRow: ^row;
               enter theRow[]
               do (if theRow[]<>NONE then
                      theRow[] -> delete;
                  if);
               #);
             
             indexError::
               (# errMsg: ^text;
               do true -> continue;
                  &text[] -> errMsg[];
                  'Failed to find row: ' -> errMsg.append;
                  curR -> errMsg.putInt; '.' -> errMsg.append;
                  errMsg[] -> rowNotFound;
               #);
          #);
        
        append:
          (# aRow: ^row; 
          enter aRow[]
          do
             noOfRows->aRow.r->curR;
             
             aRow[]->rows.append;
             aRow[]->scroller1.contents.addCellValue;
          #);
        
        insert:
          (# theRow: ^row; 
             inx: @integer;
          enter (theRow[],inx)
          do
             (if true
              //inx<1 then
                 1 -> inx;
              //inx> rows.size then
                 rows.size+1 -> inx;
             if);
             inx -> theRow.r -> curR;
             
             (inx,theRow[])->rows.put;
             (inx,theRow[]) -> theEditFields.insertRow;
             next_vertical_pos + theRow.height+gridOffset -> next_vertical_pos;
             
          #);
        
        remove:
          (# theRow: ^row;
          enter theRow[]
          do (if theRow[]<>NONE then
                 theRow.r -> curR;
                 theRow[] -> rows.remove;
             if);
             rows.scan
             (# 
             do (if current.r > theRow.r then
                    current.r - 1 -> current.r
                if);
             #);
             theRow[] -> theEditFields.removeRow;
             next_vertical_pos - theRow.height+gridOffset -> next_vertical_pos;
          #);
        
        get:
          (# j: @integer; theRow: ^row; 
          enter j
          do 
             j -> curR;
             (if (j>0) and (j<=noOfRows) then
                 j -> rows.get -> theRow[];
             if);
             
          exit theRow[]
          #);
        clear: (#  do rows.clear;  #);
        
     #);
   count: @integer;
   theEditText: @textField
     (#
        <<SLOT theEditTextLib: attributes>>;
        
        prohibitKeydown:
          (# key: @char
          enter key
          <<SLOT prohibitKeydownImpl: doPart>>
          #);
        
        reactOnMouseUp: @boolean; (* TRUE if a cell got a mouseDown. The 
                                   * textfield will then get the mouseUp event
                                   * but guienv does not propagate this event.
                                   *)
        
        
        
        updateMargins:
          (# <<SLOT theEditTextUpdateMargins: doPart>> #);
        
        setReadOnly:
          (# value: @boolean; windowID: @integer; 
          enter value
          <<SLOT theEditTextSetReadOnly: doPart>>
          #);
        
        doNotReactOnChangeEvent: @boolean;
        
        myInsert:
          (# t: ^text;
          enter t[]
          do true -> doNotReactOnChangeEvent;
             t[] -> contents;
             false -> doNotReactOnChangeEvent;
          #);
        
        eventHandler:: 
          (#
             onRefresh::
               (# 
               do (if currentFieldInfo[] <> none then
                      currentFieldInfo.theCellRect.drawThePixmap;
                  if);
               #);
             
             onBeforeChange:: 
               (# txt: ^text;
                  r,c: @integer;
                  doAllow: @boolean;
               do
                  (if (currentFieldInfo[] <> none)
                      and
                      not doNotReactOnChangeEvent
                      then
                      not (currentFieldInfo.i->columnsInfoList.getLock) 
                        -> allow;
                      (if length >= 1 then
                          theText->txt[];
                          (if txt[] <> none then
                              (if currentFieldInfo[] <> none then
                                  (currentFieldInfo.i,currentFieldInfo.j) -> (c,r);
                               else
                                  (1,1) -> (c,r);
                              if);
                              (txt[],NONE,c,r)
                                -> THIS(editSheet).theEventHandler.onBeforeChange
                                -> doAllow;
                              
                              (if 1->txt.inxGet
                               // ascii.nl // ascii.cr then
                                  (if doAllow then
                                      THIS(editSheet).theEventHandler.onKeyDown;
                                   else
                                      false->allow;
                                      1->txt.inxGet->theEditFields.navigate;
                                  if);
                                  
                                  (* // ascii.ht then
                                   *  false->allow;
                                   * THIS(editSheet).theEventHandler.onKeyDown;
                                   *)
                                  
                               // ASCII.fs // ASCII.gs then
                                  (if (ShiftModifier->isModifierOn) then
                                      false->allow;
                                      1->txt.inxGet->theEditFields.navigate;
                                  if);
                                  
                               // ASCII.rs // ASCII.us then
                                  false->allow;
                                  1->txt.inxGet->theEditFields.navigate;
                                  
                               else
                                  (if readOnly or (not allow) then 
                                      false->allow; beep 
                                  if);
                              if);
                           else
                              false -> allow; beep
                          if);
                      if);
                  if);
               #);
             
             (* Use in r4.2.  *)
             onKeydown::
               (# 
               do (if ch
                   // ASCII.fs // ASCII.gs then
                      (if (ShiftModifier->isModifierOn) then
                          prohibitKeydown;
                          ch->theEditFields.navigate;
                      if);
                      
                   // ASCII.rs // ASCII.us then
                      prohibitKeydown;
                      ch->theEditFields.navigate;
                  if);
               #);
             (* Use in r4.2.  End. *)
             
             onEnableTarget:: 
               (# 
               do (if prevFieldInfo[] <> none then
                      (* prevFieldInfo.theCellRect.update; *)
                  if);
               #);
             
             (* onVisibleChanged:: 
              * (#  do (if visible then updateMargins;  if);  #);
              *)
             
             onMouseDown:: 
               (# curRow: ^row; 
               do this(editSheet).theEventHandler.onMouseDown;
                  
                  false -> reactOnMouseUp;
                  (if currentFieldInfo[] <> none then
                      currentFieldInfo.j->theRows.get->curRow[];
                      (if curRow[] <> none then
                          (currentFieldInfo.i,buttonState,globalPosition)
                            ->curRow.onMouseDown;
                      if);
                  if);
               #);
             onMouseUp:: 
               (# curRow: ^row; 
               do this(editSheet).theEventHandler.onMouseUp;
                  (if currentFieldInfo[] <> none then
                      currentFieldInfo.j->theRows.get->curRow[];
                      (if curRow[] <> none then
                          (currentFieldInfo.i,buttonState,globalPosition)
                            ->curRow.onMouseUp;
                      if);
                  if)
               #)
          #);
        isOpen: @boolean;
        
        setEditTextColor:
          (# value: @color;
          enter value
          <<SLOT setEditTextColorImpl: doPart>> 
          #);
        
        setEditBgColor:
          (# value: @color;
          enter value
          <<SLOT setEditBgColorImpl: doPart>> 
          #);
        
        addChangeNotifications:
          (# windowID,theMask: @integer; 
          <<SLOT addChangeNotificationsImpl: doPart>>
          #);
        
        removeChangeNotifications:
          (# windowID,theMask: @integer; 
          <<SLOT removeChangeNotificationsImpl: doPart>>
          #);
        
        open:: 
          (#
             create:: 
               (# <<SLOT theEditTextCreate: doPart>> #);
             windowID: @integer;
             theMask: @integer;
          <<SLOT theEditTextOpen: doPart>>
          #);
        
     #);
   
   currentFieldInfo: ^field_info;
   prevFieldInfo: ^field_info;
   
   fieldInfoList: sequence
     (# rowNo: @integer;
        element:: field_info;
        
        init::
          (# 
          do (if noOfColumns>0 then
                 noOfColumns -> extendCapacityRight;
             if);
          #);
        
        myClear:
          (# 
          do
             scan
             (# 
             do (* ''->toStyledText->current.theCellRect.contents[]; *)
                (* current.theCellRect.update; *)
                (* none ->current.theCellRect.contents[]; *)
                current.theCellRect.close;
                
             #);
             clear;
          #);
        
        add:
          (# elm: ^element; 
          enter elm[]
          do elm[]->append;
          #);
        
        
        setCellColor:
          (# value: @color; c: @integer;
             current: ^element;
             result: @integer;
          enter (c,value)
          do (if (c>0) and (c<=size) then
                 c -> get -> current[];
                 (if current[]<>NONE then
                     value -> current.cellColor;
                  else
                     CELL_NOT_FOUND -> result;
                 if);
              else
                 CELL_NOT_FOUND -> result;
             if);
          exit result
          #);
        
        getCellColor:
          (# value: @color; c: @integer;
             current: ^element;
             result: @integer;
          enter c
          do (if (c>0) and (c<=size) then
                 c -> get -> current[];
                 (if current[]<>NONE then
                     current.cellColor -> value;
                  else
                     CELL_NOT_FOUND -> result;
                 if);
              else
                 CELL_NOT_FOUND -> result;
             if);
          exit (value,result)
          #);
        
        select:
          (#
             i,j: @integer;
             r: @rectangle;
             x,y,w,h: @integer;
             i1,j1,i2,j2: @integer;
             curRow,prevRow: ^row;
             current: ^element;
          enter (i,j)
          do
             (if (i>0) and (i<=size) then
                 theEditText.removeChangeNotifications;
                 setContentsSize;
                 i -> get -> current[];
                 
                 (if (current.i = i) and (current.j = j) then
                     theEditText.hide;
                     currentFieldInfo[]->prevFieldInfo[];
                     current[]->currentFieldInfo[];
                     (if prevFieldInfo[] <> none then
                         theEditText.contents
                           ->prevFieldInfo.theCellRect.contents[];
                         
                     if);
                     
                     current.theCellRect.position->(x,y);
                     current.theCellRect.size->(w,h);
                     (if current.privCellPixmap[]=NONE then
                         (x,y+1)->theEditText.position;
                      else
                         (x+current.privCellPixmap.width+2,y+1)->theEditText.position;
                         w - current.privCellPixmap.width - 2 -> w;
                     if);
                     
                     (w,h-1)->theEditText.size;
                     (if current.theCellRect.contents[] <> none then
                         current.theCellRect.contents[]->theEditText.myInsert; 
                      else
                         ''->toStyledText->theEditText.myInsert; 
                     if);
                     theEditText.show;

                     (* (0,0) -> theEditText.margin; *)
                     (* theEditText.updateMargins; *)
                     theEditText[]->target;
                     (if currentFieldInfo[] <> prevFieldInfo[] then
                         (if currentFieldInfo[] <> none then
                             currentFieldInfo->(i1,j1); 
                         if);
                         (if prevFieldInfo[] <> none then
                             prevFieldInfo->(i2,j2); 
                         if);
                         currentFieldInfo.theCellRect[]
                           ->scroller1.scrollIntoView;
                         (i1,j1,i2,j2)->onFocusChanged;
                         j1->theRows.get->curRow[];
                         (if curRow[] <> none then
                             curRow.select;
                         if);
                         j2->theRows.get->prevRow[];
                         (if prevRow[] <> none then
                             (* (if not multipleSelection then
                              *                                  prevRow.deselect; 
                              *                              if);
                              *)
                         if);
                         (if j1 <> j2 then
                             (if curRow[] <> none then
                                 curRow.private.theFieldInfos.scan
                                 (# 
                                 do (if current.i<>i1 then
                                        current.theCellRect.drawTheText; 
                                    if);
                                 #);
                             if);
                             (if prevRow[] <> none then
                                 prevRow.private.theFieldInfos.scan
                                 (# 
                                 do current.theCellRect.drawTheText; 
                                 #);
                             if);
                          else
                             (if currentFieldInfo[] <> none then
                                 currentFieldInfo.theCellRect.drawThePixmap;
                             if);
                         if);
                     if);
                     
                 if);
                 
                 theEditText.addChangeNotifications;
             if);
          #);
        
        doRefresh:
          (# 
          do scan (#  do current.theCellRect.update;  #); 
          #);
        
        decrementRowNo:
          (# delta: @integer;
          enter delta
          do scan 
             (# x,y: @integer;
             do current.j - 1 -> current.j;
                
                current.theCellRect.position -> (x,y);
                (x,y-delta)->current.theCellRect.position;
                
                (* current.theCellRect.update; *)
             #);
          #);
        
     #); (* End of fieldInfoList *)
   
   theEditFields: @sequence
     (# element:: fieldInfoList;
        
        init::
          (# 
          do 31 -> extendCapacityRight;
          #);
        
        myClear:
          (# 
          do scan
             (# do current.myClear #);
             (* theEditFields.clear; *)
          #);
        
        setCellColor:
          (# value: @color; r,c: @integer;
             aFieldInfoList: ^fieldInfoList;
             result: @integer;
          enter (c,r,value)
          do 
             (if (r>0) and (r<=size) then
                 r -> get -> aFieldInfoList[];
                 (if aFieldInfoList[]<>NONE then
                     (c, value) -> aFieldInfoList.setCellColor -> result;
                  else
                     ROW_NOT_FOUND -> result;
                 if);
              else
                 ROW_NOT_FOUND -> result;
             if);
          exit result
          #);
        
        getCellColor:
          (# value: @color; r,c: @integer;
             aFieldInfoList: ^fieldInfoList;
             result: @integer;
          enter (c,r)
          do (if (r>0) and (r<=size) then
                 r -> get -> aFieldInfoList[];
                 (if aFieldInfoList[]<>NONE then
                     c -> aFieldInfoList.getCellColor -> (value,result)
                  else
                     ROW_NOT_FOUND -> result;
                 if);
              else
                 ROW_NOT_FOUND -> result;
             if);
          exit (value,result)
          #);
        
        
        add:
          (# elm: ^field_info;
             aFieldInfoList: ^fieldInfoList;
          enter elm[]
          do (if elm[]<>NONE then
                 (if elm.j > THIS(theEditFields).size then
                     &fieldInfoList[] -> aFieldInfoList[];
                     aFieldInfoList.init;
                     elm.j -> aFieldInfoList.rowNo;
                     elm[] -> aFieldInfoList.append;
                     aFieldInfoList[] -> append;
                     (if THIS(theEditFields).size = 1 then
                         elm[]->currentFieldInfo[]; 
                     if);
                  else
                     elm.j -> get -> aFieldInfoList[];
                     (if aFieldInfoList[]<>NONE then
                         elm[] -> aFieldInfoList.append;
                     if);
                 if);
             if);
          #);
        
        insertRow:
          (# rowToInsert: ^row;
             inx: @integer;
          enter (inx,rowToInsert[])
          do 
          #);
        
        removeRow:
          (# rowToRemove: ^row;
             rowNo: @integer;
             theRowList: ^element;
             oldFocus: @point;
             topLeft: @point;
             w,h: @integer;
          enter rowToRemove[]
          do rowToRemove.private.getPosition -> topLeft;
             rowToRemove.r -> rowNo;
             focus -> oldFocus;
             NONE -> THIS(editSheet).private.currentFieldInfo[];
             (if oldFocus.v = rowNo then
                 NONE -> THIS(editSheet).private.currentFieldInfo[];
             if);
             scan
             (# 
             do (if true 
                 //(current.rowNo = rowNo) then
                    current[] -> theRowList[];
                 //(current.rowNo > rowNo) then
                    current.rowNo -1 -> current.rowNo;
                    rowToRemove.height -> current.decrementRowNo;
                if);
             #);
             (if theRowList[]<>NONE then
                 theRowList.myClear;
                 theRowList[] -> delete;
             if);
             
             (if oldFocus.v = noOfRows+1 then
                 (oldFocus.h,oldFocus.v-1) -> focus;
              else
                 oldFocus -> focus;
             if);
             
             scroller1.size -> (w,h);
             topLeft.v + h -> h;
             topLeft.h + w -> w;
             (scroller1.contents[],(topLeft,(w,h))) -> updateRect;
          #);
        
        navigate:
          (# ch: @char; i,j: @integer; prevNoOfRows: @integer; 
             aFieldInfoList: ^fieldInfoList;
          enter ch
          do
             first -> aFieldInfoList[];
             (if aFieldInfoList[] <> none then
                 
                 (if currentFieldInfo[] = none then
                     aFieldInfoList.first -> currentFieldInfo[]; 
                 if);
                 (if currentFieldInfo[] <> none then
                     (if ch
                      // ASCII.fs then (* VK_LEFT *)
                         currentFieldInfo.i-1->i; currentFieldInfo.j->j; 
                      // ASCII.rs then (* VK_UP *)
                         currentFieldInfo.i->i; currentFieldInfo.j-1->j; 
                      // ASCII.gs then (* VK_RIGHT *)
                         currentFieldInfo.i+1->i; currentFieldInfo.j->j; 
                      // ASCII.us then (* VK_DOWN *)
                         currentFieldInfo.i->i; currentFieldInfo.j+1->j; 
                      // homeKey then
                         1->i; currentFieldInfo.j->j; 
                      // endKey then
                         noOfColumns->i; currentFieldInfo.j->j; 
                      // ascii.nl // ascii.cr then
                         
                         (if currentFieldInfo.i=noOfColumns then
                             1 -> i;
                             currentFieldInfo.j+1->j;
                          else
                             currentFieldInfo.i+1->i; 
                             currentFieldInfo.j->j; 
                         if);
                     if);
                     (ch,i,j) -> onNavigate ->select;
                 if);
             if);
          #);
        
        select:
          (# rowNo, colNo: @integer;
             aFieldInfoList: ^fieldInfoList;
          enter (colNo, rowNo)
          do (if (rowNo>0) and (rowNo<=size) then
                 rowNo -> get -> aFieldInfoList[];
                 (if aFieldInfoList[]<>NONE then
                     (colNo, rowNo) -> aFieldInfoList.select;
                 if);
             if);
          #);
        
        doRefresh:
          (# 
          do scan
             (# 
             do current.doRefresh;
             #);
             
          #);
        
     #);
   (* End of theEditFields *)

   headerHeight: 
     (#  h: @integer; 
     do (if header.headerTextStyle[]<>NONE then
            header.headerTextStyle.lineHeight + 4 -> h;
         else
            18 -> h;
        if);
     exit h
     #);
   
   header: @canvas
     (#
        headerTextStyle: ^textStyle;
        
        updateLabelText:
          (# l: ^text;
             c: @integer;
             theLabelItem: ^labelItem;
          enter (l[],c)
          do (if (l[]<>NONE) and (c>0) and (c<=labelItems.size) then
                 c -> labelItems.get -> theLabelItem[];
                 (if theLabelItem[]<>NONE then
                     l[] -> theLabelItem.label;
                 if);
             if);
          #);
        
        getLabelText:
          (# l: ^text;
             c: @integer;
             theLabelItem: ^labelItem;
          enter c
          do (if (c>0) and (c<=labelItems.size) then
                 c -> labelItems.get -> theLabelItem[];
                 (if theLabelItem[]<>NONE then
                     theLabelItem.label -> l[];
                 if);
             if);
          exit l[]
          #);
        
        getHeadingLeftPos: integerValue
          (# inx: @integer; item: ^privHeadingInfo; 
          enter inx
          do (if (inx>0) and (inx<=theHeadings.size) then
                 inx -> theHeadings.get -> item[];
                 (if item[]<>NONE then
                     item.x -> value;
                 if);
             if);
          #);
             
        labelItem: staticText
          (# theHeadingInfo: ^privHeadingInfo;
             eventHandler::
               (# 
                  onMouseDown::
                    (# 
                    do (if theHeadingInfo[]<>NONE then
                           (buttonState, localPosition, doubleClick)
                             -> theHeadingInfo.primInfo.onMouseDown;
                       if);
                    #);
                  onMouseUp::
                    (# 
                    do (if theHeadingInfo[]<>NONE then
                           (buttonState, localPosition, doubleClick)
                             -> theHeadingInfo.primInfo.onMouseUp;
                       if);
                    #);
               #);
          #);
        
        labelItems: @sequence
          (# element:: labelItem;
          #);
             
        separatorType: separator
          (#
             open:: 
               (# 
               do
                  (2,headerHeight)->size;
                  (134,0)->position;
                  5->style;
                  false->border.visible;
                  5->border.style;
                  
               #);
             vertical::  (#  do true->value #)
          #);
        open:: 
          (# 
          do createTheHeaderTextStyle ->headerTextStyle[];
             
             (496,headerHeight)->size;
             (2,1)->position;
             true->border.visible;
             borderStyles.shadowOut->border.style; 
             true->bindRight;
          #);
        
        createHeadingLabels:
          (#
             i,w,h: @integer;
             aLabelItem: ^labelItem;
             aSeparator: ^separatorType;
          do
             (if headerTextStyle[]=NONE then
                 createTheHeaderTextStyle ->headerTextStyle[];
             if);
             
             labelItems.init;
             0->h;
             
             theHeadings.scan
             (# x,w: @integer; 
             do
                i+1->i;
                
                &labelItem[]->aLabelItem[];
                aLabelItem[] -> labelItems.append;
                header[] -> aLabelItem.open;
                headerTextStyle[] -> aLabelItem.style;
                current.primInfo.label[]->aLabelItem.label;
                current[] -> aLabelItem.theHeadingInfo[];
                
                true->aLabelItem.border.visible;
                borderStyles.shadowOut->aLabelItem.border.style;
                
                (current.primInfo.width,headerHeight) -> aLabelItem.size;
                (x,0) -> aLabelItem.position;
                x + current.primInfo.width -> x;
                
                
                (* (current.label[]->headerTextStyle.widthOfText)->w;
                 (w+4,headerTextStyle.lineHeight)->aStaticText.size;
                 h+(current.width div 2)-(w div 2)->x;
                 (x+2,2)->aStaticText.position;
                 *)
                
                (* &separatorType[]->aSeparator[];
                 aSeparator.open;
                 (h+current.width+2,0)->aSeparator.position; 
                    h+current.width+4->h;
                 *)
                
             #);
          #);
        
     #); (* End of header *)
   
   scroller1: @scroller
     (#
        <<SLOT scroller1Lib: attributes>>;
        
        onAfterScroll:
          (# direction,orientation,amount: @integer;
             vertical: (#  exit 0 #);
             horizontal: (#  exit 1 #);
             up: (# exit 0 #);
             down: (# exit 1 #);
             headerX,headerY: @integer;
             h,v: @integer;
          enter (orientation,direction,amount)
          do 
             (if (orientation=horizontal) then
                 contents.position -> (h,v);
                 header.position -> (headerX,headerY);
                 (h+2,headerY) -> header.position;
             if);
          #);
        
        onBeforeScroll:
          (# direction,orientation,amount: @integer;
             vertical: (#  exit 0 #);
             horizontal: (#  exit 1 #);
             up: (# exit 0 #);
             down: (# exit 1 #);
             headerX,headerY: @integer;
             h,v: @integer;
          enter (orientation,direction,amount)
          do 
             (if (orientation=vertical) then
                 (if direction//up//down then
                     scanL:
                       theRows.rows.scan
                       (# rh,rv: @integer;
                          prevHeight,height: @integer;
                       do current.private.getPosition -> (rh,rv);
                          height -> prevHeight;
                          current.private.height -> height;
                          contents.position -> (h,v);
                          (if (rv<=-v) and (-v<rv+current.private.height) then
                              (if direction=down then
                                  -height -> amount;
                               else
                                  prevHeight -> amount;
                              if);
                              leave scanL
                          if);
                       #);
                 if);
             if);
          exit amount
          #);
        
        isOpen: @boolean;
        open:: 
          (#
             create:: 
               (# <<SLOT scroller1Create: doPart>> #);
          do
             (496,212+gridOffset)->size;
             (2,headerHeight)->position;
             false->border.visible;
             (* borderStyles.shadowIn->border.style; *)
             true->bindRight;
             true->bindBottom;
             hide;
             true -> isOpen;
          #);
        
        close::
          (# 
          do false -> isOpen;
          #);
        
        contentsType:: 
          (#
             
             eventHandler:: 
               (#
                  onRefresh:: 
                    (# v,w,h,w2,h2: @integer; 
                       upRect: ^rectangle;
                    do  
                       (* createThePen; *)
                       graphics
                       (# overrideChildren:: 
                            (# do true -> value #);
                       do 
                          size->(w,h);
                          (32640,32640, 32640) -> pen.foregroundColor;
                          theHeadings.scan
                          (# 
                          do (current.x-1,gridOffset)->MoveTo;
                             (current.x-1,h+40)->drawTo;
                          #);
                          
                          gridOffset -> v;
                          scanL:
                            this(editSheet).private.theRows.rows.scan
                            (# 
                            do current.height + v -> v;
                               (0,v)->MoveTo;
                               (w+20,v)->drawTo;
                               (if v > h+40 then leave scanL if);
                            #);
                          
                          (if v < h+40 then 
                              v+lineHeight->v;
                              L:
                                (# 
                                do (0,v)->MoveTo;
                                   (w+20,v)->drawTo;
                                   v+lineHeight->v;
                                   
                                   (if v < h+40 then restart L if);
                                #);
                          if);
                       #);
                       (* deleteThePen; *)
                       updateRect -> upRect[];
                       (if upRect[]<>none then
                           scanL:
                             this(editSheet).private.theRows.rows.scan
                             (# 
                             do 
                                current.private.theFieldInfos.scan
                                (# r,r2: @rectangle; 
                                do current.theCellRect.frame -> r;
                                   (if ((r,upRect)->r2.intersection) then 
                                       current.theCellRect.theEventHandler.privOnRefresh;
                                   if);
                                #);
                             #);
                       if);
                    #);
                  onMouseUp::
                    (# do this(editSheet).theEventHandler.onMouseUp #);
                  onMouseDown::
                    (# do this(editSheet).theEventHandler.onMouseDown #);
                    
               #);
             
             open:: 
               (# w1,h1,w2,h2: @integer; 
               do
                  header.open;
                  scroller1.size->(w1,h1);
                  THIS(contentsType).size->(w2,h2);
                  (w1,h2)->size;
                  (# 
                  <<SLOT contentsTypePlatformOpen: doPart>>
                  #)
               #);
             initTheTextField:
               (# 
               do THIS(contentsType)[]->theEditText.open;  
                  
                  THIS(editSheet).private.theTextStyle.lineHeight - 
                  THIS(editSheet).private.theTextStyle.descent + 1
                    -> THIS(editSheet).private.textTopOffset;
               #);
             addCellValue:
               (#
                  aField_info: ^field_info;
                  i,j: @integer;
                  pos: @point;
                  curRow: ^row;
                  curValue: ^styledText;
                  
               enter curRow[]
               do
                  (if curRow[] <> none then
                      noOfRows->j;
                      (if curRow.private.theFieldInfos.size<noOfColumns then
                          (for noOfColumns-curRow.private.theFieldInfos.size repeat
                               '' -> curRow.addValue;
                          for);
                      if);
                      
                      scanL:
                        curRow.private.theFieldInfos.scan
                        (# 
                        do i+1 -> i;
                           (if i>noOfColumns then leave scanL if);
                           
                           current[]->aField_info[];
                           THIS(contentsType)[]->aField_info.theCellRect.open;
                           
                           (if i = 1 then
                               (0,next_vertical_pos)->aField_info.theCellRect.position;
                               
                            else
                               (i->header.getHeadingLeftPos,next_vertical_pos)
                                 ->aField_info.theCellRect.position;
                               
                           if);
                           
                           sizes[i] -> pos;
                           (if i=1 then
                               (pos.h-1,curRow.height) -> pos;
                            else
                               (pos.h-1,curRow.height) -> pos;
                           if);
                           
                           pos ->aField_info.theCellRect.size;
                           
                           i->aField_info.i;
                           j->aField_info.j;
                           aField_info[]->theEditFields.add;
                           
                           
                        #);
                      curRow.private.theFieldInfos.scan
                      (# 
                      do current.theCellRect.show;
                         current.theCellRect.update;
                      #);
                      
                      curRow.height+next_vertical_pos -> next_vertical_pos;
                  if);
               #);
             (* End of addCellValue *)
             
          #); (* End of contentsType *)
        
     #);
   (* End of header *)
   setContentsSize: (* Enlarge scrolling area if necessary *)
     (# w,h: @integer
     do
        scroller1.contents.size->(w,h);
        (if private.next_vertical_pos+private.lineHeight > h then
            private.next_vertical_pos+private.lineHeight-scrollbarHeight->h; 
            (w,h+lineHeight)->scroller1.contents.size;
        if)
     #);
   
#)
