ORIGIN '../editSheet';
MDBODY 
mac 'macintosh/editSheet_macBody'
ppc 'macintosh/editSheet_macBody'
ppcmac 'macintosh/editSheet_macBody'
nti 'winnt/editSheet_win32Body'
default 'X11/editSheet_unixBody';

INCLUDE 
'~beta/guienv/v1.6/utils/graphicsadds'
'~beta/guienv/v1.6/utils/scrolleradds'
'~beta/guienv/v1.6/private/datastructures/sequence'
'cell';

-- lib: Attributes --
putPoint:
  (# h,v: @integer; 
  enter (h,v)
  do '('->put; h->putInt; ','->put; v->putInt; ')'->put; 
  #);
putRectangle:
  (# top,left,bottom,right: @integer; 
  enter ((top,left),(bottom,right))
  do
     '( '->putText;
     (top,left)->putPoint;
     ' , '->putText;
     (bottom,right)->putPoint;
     ' )'->putLine;
     
  #);

homeKey:
  (# theKey: @integer <<SLOT homeKeyImpl: doPart>> exit theKey #);

endKey:
  (# theKey: @integer <<SLOT endKeyImpl: doPart>> exit theKey #);

win32: (# exit 1 #);
mac:   (# exit 2 #);
unix:  (# exit 3 #);

platform: integerValue
  (# <<SLOT platformImpl: doPart>> #);

-- editSheetLib: Attributes --
toStyledText:
  (# t: ^text; st: ^styledText; 
  enter t[]
  do &styledText[]->st[]; 
     (if t[]<>NONE then t->st; if);
  exit st[]
  #);
toStdText:
  (# t: ^text; st: ^styledText; 
  enter st[]
  do &Text[]->t[]; 
     (if st[]<>NONE then st->t; if);
  exit t[]
  #);

Modifier: 
  (# m: @Integer; enter m do INNER exit m #);

ShiftModifier: Modifier
  (# <<SLOT ShiftModifierBody: dopart>> #);

ControlModifier: Modifier
  (# <<SLOT ControlModifierBody: dopart>> #);

scrollbarWidth:
  (# w: @integer;
  <<SLOT scrollbarWidthImpl: doPart>>
  exit w
  #);

scrollbarHeight:
  (# h: @integer;
  <<SLOT scrollbarHeightImpl: doPart>>
  exit h
  #);

createTheEditTextStyle:
  (# theTextStyle: ^textStyle;
  <<SLOT createTheEditTextStyleImpl: doPart>>
  exit theTextStyle[]
  #);

createTheHeaderTextStyle:
  (# theTextStyle: ^textStyle;
  <<SLOT createTheHeaderTextStyleImpl: doPart>>
  exit theTextStyle[]
  #);
     
gridOffset: (#  exit 0 #);

field_info:
  (#
     theCellRect: @cell
       (# open::
            (# do hide; #);
          contents: ^styledText;
          drawTheText:
            (#
               theColor: @color;
               w,h,result: @integer;
               myRow: ^row;
               
            do
               (if contents[] <> none then
                   (if contents.length > 0 then
                       (if THIS(editSheet).private.currentFieldInfo[] <> none
                           then
                           (if THIS(editSheet).private.currentFieldInfo.j = j
                               then
                               (0x00,0x00,32000)->theColor; 
                           if);
                           
                        else
                           j->THIS(editSheet).private.theRows.get->myRow[];
                           myRow.private.theColor->theColor;
                       if);
                       
                       size->(w,h);
                       
                       graphics
                       (# overrideChildren:: 
                            (# do true -> value #);
                       do 
                          frame -> clipRectangle;
                          (3,h-THIS(editSheet).private.textTopOffset)
                            -> moveTo;
                          THIS(editSheet).private.theTextStyle[] -> style;
                          theColor -> pen.foregroundColor;
                          contents[]->drawText;
                       #);
                   if);
               if);
            #);
          eventHandler:: 
            (#
               onRefresh:: 
                 (# 
                 do (if THIS(editSheet).private.currentFieldInfo[] <> THIS(field_info)[] then
                        drawTheText; 
                    if);
                 #);
               
               onMouseDown:: 
                 (# 
                 do (i,j)->THIS(editSheet).private.theEditFields.select;
                    true -> THIS(editSheet).private.theEditText.reactOnMouseUp;
                 #);
            #);
       #);
     i,j: @integer;
     
  enter (i,j)
  exit (i,j)
  #);
  



-- editSheetOnEnableTarget: DoPart --
do
   (if private.theEditText.isOpen then
       (if private.theEditText.visible then
           private.theEditText[]->target; 
       if);
   if);
   
-- editSheetOnMouseDown: doPart --
do inner onMouseDown;
   
-- editSheetOnMouseUp: doPart --
do inner onMouseUp;

-- editSheetOpen: DoPart --
do
   (0,0)->position;
   (500,230)->size;
   private.theRows.init;
   private.scroller1.open;
   private.scroller1.show;
   createTheEditTextStyle -> private.theTextStyle[];
   private.theTextStyle.lineHeight+8->private.lineHeight;
   (if private.lineHeight < 20 then 20->private.lineHeight;  if);
   true->border.visible;
   borderStyles.etchedIn->border.style;
   private.scroller1.contents.initTheTextField;
   private.theEditFields.init;
   gridOffset->private.next_vertical_pos;
   INNER open;
   private.header.createHeadingLabels;
   (1,1)->private.theEditFields.select;
   L: private.theHeadings.scan
     (# 
     do (current.width,private.lineHeight)->private.theEditText.size; leave L
     #);
   (* private.theEditText.show; *)
     

-- editSheetClose: DoPart --
do INNER close;   

-- editSheetSetStyle: DoPart --
do   

-- editSheetGetStyle: DoPart --
do private.theTextStyle[]->theStyle[];   

-- editSheetSetReadOnly: DoPart --
do value->private.readOnly; value->private.theEditText.setReadOnly;   

-- editSheetClear: DoPart --
do private.clear; INNER clear;   

-- editSheetRefresh: DoPart --
do private.theEditFields.doRefresh;  

-- editSheetFitToContents: DoPart --
do
   (# w,h,w1,h1: @integer; 
   do
      private.scroller1.contents.size->(w,h);
      private.scroller1.size->(w1,h1);
      (if private.next_vertical_pos+private.lineHeight > h then
          private.next_vertical_pos+private.lineHeight-scrollbarHeight->h; 
       else
          h1+scrollbarHeight+10->h; 
      if);
      (w1-scrollbarWidth-4,h)->private.scroller1.contents.size;
      true->private.scroller1.contents.bindRight;
   #)

-- editSheetNoOfColumns: DoPart --
do private.noOfColumns->value;   

-- editSheetNoOfRows: DoPart --
do private.noOfRows->value;   

-- editSheetAddHeading: DoPart --
do
   private.noOfColumns+1->private.noOfColumns;
   theHeading[]->private.theHeadings.add;

-- editSheetSetSelection: DoPart --
do (c,r)->private.theEditFields.select;   

-- editSheetGetSelection: DoPart --
do
   (if private.currentFieldInfo[] <> none then
       (private.currentFieldInfo.i,private.currentFieldInfo.j)->(c,r); 
   if);
     
-- rowInit: DoPart --
do private.theFieldInfos.init; 
   INNER init;   
   
-- rowSetColor: DoPart --
do value->THIS(row).private.theColor;   

-- rowGetColor: DoPart --
do THIS(row).private.theColor->value;   
   
-- editSheetAddRow: DoPart --
do
   private.setContentsSize;
   
   (if theRow[] <> none then 
       private.noOfRows+1->private.noOfRows;
       (if not private.theEditText.visible then
           private.theEditText.show;
       if);
       
       false -> theRow.private.deleted;
       theRow[]->private.theRows.append;  
   if)  
   
-- editSheetDeleteRow: doPart --
do 
   (if theRow[] <> none then 
       private.noOfRows-1->private.noOfRows;
       (if private.noOfRows=0 then
           (if private.theEditText.visible then
               private.theEditText.hide;
           if);
       if);
       true -> theRow.private.deleted;
       theRow[]->private.theRows.remove; 
       theRow.private.theFieldInfos.clear;
   if);
   
-- editSheetDisableOnTouchedEvents: DoPart --
do private.theEditText.removeChangeNotifications;   

-- editSheetEnableOnTouchedEvents: DoPart --
do private.theEditText.addChangeNotifications;   

-- rowAddValue: DoPart --
do (# aField_info: ^field_info;
   do (if (value[] <> none) and (not private.deleted) then
          &field_info[]->aField_info[];
          value[]->toStyledText->aField_info.theCellRect.contents[];
          aField_info[] -> private.theFieldInfos.append;
          (if THIS(editSheet).private.currentFieldInfo[] = none then
              aField_info[]->THIS(editSheet).private.currentFieldInfo[]; 
          if);
          (if aField_info[] = THIS(editSheet).private.currentFieldInfo[] then
              value[]->toStyledText->THIS(editSheet).private.theEditText.contents; 
          if);
      if);
   #)

-- rowGetValue: DoPart --
do
   (if (i > 0) and (i <= private.theFieldInfos.size) and (not private.deleted) then
       L:
         private.theFieldInfos.scan
         (# 
         do (if current.i=i then 
                (if current[] = THIS(editSheet).private.currentFieldInfo[] then
                    THIS(editSheet).private.theEditText.contents->toStdText->v[];
                 else
                    current.theCellRect.contents[]->toStdText->v[];
                if);
                leave L;
            if);
         #);
   if);
   
-- rowSetValue: DoPart --
do
   (if (i > 0) and (i <= private.theFieldInfos.size) and (v[]<>NONE) then
       L:
         private.theFieldInfos.scan
         (# 
         do (if current.i=i then 
                
                (if THIS(editSheet).private.currentFieldInfo[] = none then
                    current[]->THIS(editSheet).private.currentFieldInfo[]; 
                if);
                (if current[] = THIS(editSheet).private.currentFieldInfo[] then
                    v[]->toStyledText->THIS(editSheet).private.theEditText.contents; 
                if);
                v[]->toStyledText->current.theCellRect.contents[];
                current.theCellRect.update;
                leave L
            if);
         #);
   if);
   
-- rowPrivate: Descriptor --
(#
   theFieldInfos: @sequence 
     (# element:: field_Info;  
        init::
          (# 
          do (if noOfColumns>0 then
                 noOfColumns -> extendCapacityRight;
             if);
          #);
     #);
   selected,deleted: @boolean;
   theColor: @color;
#)  


-- editSheetPrivate: descriptor --
(#
   readOnly: @boolean;
   next_vertical_pos: @integer;
   theTextStyle: ^textStyle;
   lineHeight: @integer;
   hdc,thePen,prevPen: @integer;
   textTopOffset: @integer;
   clear:
     (# 
     do
        theRows.clear;
        theEditFields.myClear;
        none ->currentFieldInfo[];
        none ->prevFieldInfo[];
        (1,1)->private.theEditFields.select;
        0->noOfRows;
        gridOffset->next_vertical_pos;
        private.theEditText.hide;
        (2,gridOffset)->private.theEditText.position;
        L: theHeadings.scan
          (# 
          do
             (current.width,private.lineHeight)->private.theEditText.size;
             leave L
          #);
        ''->toStyledText->private.theEditText.contents;
        true->update;
        (* private.theEditText.show; *)
        
     #);
   noOfRows: @integer;
   noOfColumns: @integer;
  
   theHeadings: @sequence
     (#
        element:: headingInfo;
        add:
          (# theHeading: ^element; aPoint: ^point; h: @integer; 
          enter theHeading[]
          do
             noOfColumns->theHeading.inx;
             theHeading[]->append;
             1->verticalSeps.extend;
             (if verticalSeps.range > 1 then
                 verticalSeps[verticalSeps.range-1]+theHeading.width+4
                   ->verticalSeps[verticalSeps.range];
                 
              else
                 theHeading.width->verticalSeps[verticalSeps.range]; 
             if);
             1->sizes.extend;
             &point[]->aPoint[];
             (theHeading.width,lineHeight)->aPoint;
             aPoint[]->sizes[sizes.range][];
             
          #);
        
     #);
   sizes: [0] ^point;
   theRows: @
     (# curR: @integer;
        
        init: (# do rows.init; #);
                   
        rows: @sequence
          (# 
             element:: row;
             
             init::
               (# 
               do 31 -> extendCapacityRight;
               #);
             
             remove:
               (# theRow: ^row;
               enter theRow[]
               do (if theRow[]<>NONE then
                      theRow[] -> delete;
                  if);
               #);
             
             indexError::
               (# errMsg: ^text;
               do true -> continue;
                  &text[] -> errMsg[];
                  'Failed to find row: ' -> errMsg.append;
                  curR -> errMsg.putInt; '.' -> errMsg.append;
                  errMsg[] -> rowNotFound;
               #);
          #);
        
        append:
          (# aRow: ^row; 
          enter aRow[]
          do
             noOfRows->aRow.j->curR;
             
             aRow[]->rows.append;
             aRow[]->scroller1.contents.addCellValue;
          #);
        
        remove:
          (# theRow: ^row;
          enter theRow[]
          do (if theRow[]<>NONE then
                 theRow.j -> curR;
                 theRow[] -> rows.remove;
             if);
             rows.scan
             (# 
             do (if current.j > theRow.j then
                    current.j - 1 -> current.j
                if);
                
                (if current[] = theRow[] then
                    'rows.remove failed. theRow.j = ' -> screen.putText;
                    theRow.j -> putint; newline;
                if);
                
             #);
             theRow.j -> theEditFields.removeRow;
             next_vertical_pos - lineHeight+gridOffset -> next_vertical_pos;
          #);
        
        get:
          (# j: @integer; theRow: ^row; 
          enter j
          do 
             j -> curR;
             (if (j>0) and (j<=noOfRows) then
                 j -> rows.get -> theRow[];
             if);
             
          exit theRow[]
          #);
        clear: (#  do rows.clear;  #);
        
     #);
   count: @integer;
   theEditText: @textField
     (#
        <<SLOT theEditTextLib: attributes>>;
        
        reactOnMouseUp: @boolean; (* TRUE if a cell got a mouseDown. The 
                                   * textfield will then get the mouseUp event
                                   * but guienv does not propagate this event.
                                   *)
        
        isModifierOn: @booleanValue
          (* Tell if theModifier is currently being pressed *)
          (# theModifier: @Modifier;
          enter theModifier
          <<SLOT isModifierOnBody: doPart>>
          #);
        
        updateMargins:
          (# <<SLOT theEditTextUpdateMargins: doPart>> #);
        
        setReadOnly:
          (# value: @boolean; windowID: @integer; 
          enter value
          <<SLOT theEditTextSetReadOnly: doPart>>
          #);
        
        eventHandler:: 
          (#
             onBeforeChange:: 
               (# txt: ^text
               do
                  (if length = 1 then
                      theText->txt[];
                      (if txt[] <> none then
                          (if 1->txt.inxGet
                           // ascii.nl // ascii.cr then
                              false->allow;
                              THIS(editSheet).theEventHandler.onKeyDown;
                              1->txt.inxGet->theEditFields.navigate;
                              
                           // ascii.ht then
                              false->allow;
                              THIS(editSheet).theEventHandler.onKeyDown;
                              
                           // ASCII.fs // ASCII.gs then
                              (if (ShiftModifier->isModifierOn) then
                                  false->allow;
                                  1->txt.inxGet->theEditFields.navigate;
                              if);
                              
                           // ASCII.rs // ASCII.us then
                              false->allow;
                              1->txt.inxGet->theEditFields.navigate;
                              
                           else
                              (if readOnly then false->allow; system.beep if);
                              
                          if);
                      if);
                  if);
               #);
             
             onEnableTarget:: 
               (# 
               do (if prevFieldInfo[] <> none then
                      prevFieldInfo.theCellRect.update; 
                  if);
               #);
             
             (* onVisibleChanged:: 
              * (#  do (if visible then updateMargins;  if);  #);
              *)
             
             onMouseDown:: 
               (# curRow: ^row; 
               do false -> reactOnMouseUp;
                  (if currentFieldInfo[] <> none then
                      currentFieldInfo.j->theRows.get->curRow[];
                      (if curRow[] <> none then
                          (currentFieldInfo.i,buttonState,globalPosition)
                            ->curRow.onMouseDown;
                      if);
                  if);
               #);
             onMouseUp:: 
               (# curRow: ^row; 
               do
                  (if currentFieldInfo[] <> none then
                      currentFieldInfo.j->theRows.get->curRow[];
                      (if curRow[] <> none then
                          (currentFieldInfo.i,buttonState,globalPosition)
                            ->curRow.onMouseUp;
                      if);
                  if)
               #)
          #);
        isOpen: @boolean;
        
        setEditTextColor:
          (#  <<SLOT setEditTextColorImpl: doPart>> #);
        
        addChangeNotifications:
          (# windowID,theMask: @integer; 
          <<SLOT addChangeNotificationsImpl: doPart>>
          #);
        
        removeChangeNotifications:
          (# windowID,theMask: @integer; 
          <<SLOT removeChangeNotificationsImpl: doPart>>
          #);
        
        open:: 
          (#
             create:: 
               (# <<SLOT theEditTextCreate: doPart>> #);
             windowID: @integer;
             theMask: @integer;
          <<SLOT theEditTextOpen: doPart>>
          #);
        
     #);
   
   currentFieldInfo: ^field_info;
   prevFieldInfo: ^field_info;
   
   fieldInfoList: sequence
     (# rowNo: @integer;
        element:: field_info;
        
        init::
          (# 
          do (if noOfColumns>0 then
                 noOfColumns -> extendCapacityRight;
             if);
          #);
        
        myClear:
          (# 
          do
             scan
             (# 
             do ''->toStyledText->current.theCellRect.contents[]; 
                current.theCellRect.update;
                current.theCellRect.close;
                none ->current.theCellRect.contents[];
             #);
             clear;
             
          #);
        
        add:
          (# elm: ^element; 
          enter elm[]
          do elm[]->append;
          #);
        
        
        select:
          (#
             i,j: @integer;
             r: @rectangle;
             x,y,w,h: @integer;
             i1,j1,i2,j2: @integer;
             curRow,prevRow: ^row;
             current: ^element;
          enter (i,j)
          do
             (if (i>0) and (i<=size) then
                 theEditText.removeChangeNotifications;
                 setContentsSize;
                 i -> get -> current[];
                 
                 (if (current.i = i) and (current.j = j) then
                     theEditText.hide;
                     currentFieldInfo[]->prevFieldInfo[];
                     current[]->currentFieldInfo[];
                     (if prevFieldInfo[] <> none then
                         theEditText.contents
                           ->prevFieldInfo.theCellRect.contents[];
                         
                     if);
                     current.theCellRect.position->(x,y);
                     (x,y)->theEditText.position;
                     current.theCellRect.size->(w,h);
                     (w+2,h)->theEditText.size;
                     (if current.theCellRect.contents[] <> none then
                         current.theCellRect.contents[]->theEditText.contents; 
                      else
                         ''->toStyledText->theEditText.contents; 
                     if);
                     theEditText.show;

                     (* (0,0) -> theEditText.margin; *)
                     (* theEditText.updateMargins; *)
                     theEditText[]->target;
                     (if currentFieldInfo[] <> prevFieldInfo[] then
                         (if currentFieldInfo[] <> none then
                             currentFieldInfo->(i1,j1); 
                         if);
                         (if prevFieldInfo[] <> none then
                             prevFieldInfo->(i2,j2); 
                         if);
                         currentFieldInfo.theCellRect[]
                           ->scroller1.scrollIntoView;
                         (i1,j1,i2,j2)->onSelectionChanged;
                         j1->theRows.get->curRow[];
                         (if curRow[] <> none then
                             true->curRow.private.selected; 
                         if);
                         j2->theRows.get->prevRow[];
                         (if prevRow[] <> none then
                             false->prevRow.private.selected; 
                         if);
                         (if j1 <> j2 then
                             (if curRow[] <> none then
                                 curRow.private.theFieldInfos.scan
                                 (# 
                                 do (if current.i<>i1 then
                                        current.theCellRect.drawTheText; 
                                    if);
                                 #);
                             if);
                             (if prevRow[] <> none then
                                 prevRow.private.theFieldInfos.scan
                                 (# 
                                 do current.theCellRect.drawTheText; 
                                 #);
                             if);
                         if);
                     if);
                     
                 if);
                 
                 theEditText.addChangeNotifications;
             if);
          #);
        
        doRefresh:
          (# 
          do scan (#  do current.theCellRect.update;  #); 
          #);
        
        decrementRowNo:
          (# 
          do scan 
             (# x,y: @integer;
             do current.j - 1 -> current.j;
                
                current.theCellRect.position -> (x,y);
                (x,y-lineHeight+gridOffset)->current.theCellRect.position;
                
                current.theCellRect.update;
             #);
          #);
        
     #); (* End of fieldInfoList *)
   
   theEditFields: @sequence
     (# element:: fieldInfoList;
        
        init::
          (# 
          do 31 -> extendCapacityRight;
          #);
        
        myClear:
          (# 
          do scan
             (# do current.myClear #);
             theEditFields.clear;
          #);
        
        add:
          (# elm: ^field_info;
             aFieldInfoList: ^fieldInfoList;
          enter elm[]
          do (if elm[]<>NONE then
                 (if elm.j > THIS(theEditFields).size then
                     &fieldInfoList[] -> aFieldInfoList[];
                     aFieldInfoList.init;
                     elm.j -> aFieldInfoList.rowNo;
                     elm[] -> aFieldInfoList.append;
                     aFieldInfoList[] -> append;
                     (if THIS(theEditFields).size = 1 then
                         elm[]->currentFieldInfo[]; 
                     if);
                  else
                     elm.j -> get -> aFieldInfoList[];
                     (if aFieldInfoList[]<>NONE then
                         elm[] -> aFieldInfoList.append;
                     if);
                 if);
             if);
          #);
        
        removeRow:
          (# rowNo: @integer;
             theRowList: ^element;
             oldSelection: @point;
          enter rowNo
          do 
             selection -> oldSelection;
             NONE -> THIS(editSheet).private.currentFieldInfo[];
             (if oldSelection.v = rowNo then
                 NONE -> THIS(editSheet).private.currentFieldInfo[];
             if);
             scan
             (# 
             do (if true 
                 //(current.rowNo = rowNo) then
                    current[] -> theRowList[];
                 //(current.rowNo > rowNo) then
                    current.rowNo -1 -> current.rowNo;
                    current.decrementRowNo;
                if);
             #);
             (if theRowList[]<>NONE then
                 theRowList.myClear;
                 theRowList[] -> delete;
             if);
             
             (if oldSelection.v = noOfRows+1 then
                 (oldSelection.h,oldSelection.v-1) -> selection;
              else
                 oldSelection -> selection;
             if);

          #);
        
        navigate:
          (# ch: @char; i,j: @integer; prevNoOfRows: @integer; 
             aFieldInfoList: ^fieldInfoList;
          enter ch
          do
             first -> aFieldInfoList[];
             (if aFieldInfoList[] <> none then
                 
                 (if currentFieldInfo[] = none then
                     aFieldInfoList.first -> currentFieldInfo[]; 
                 if);
                 (if currentFieldInfo[] <> none then
                     (if ch
                      // ASCII.fs then (* VK_LEFT *)
                         currentFieldInfo.i-1->i; currentFieldInfo.j->j; 
                      // ASCII.rs then (* VK_UP *)
                         currentFieldInfo.i->i; currentFieldInfo.j-1->j; 
                      // ASCII.gs then (* VK_RIGHT *)
                         currentFieldInfo.i+1->i; currentFieldInfo.j->j; 
                      // ASCII.us then (* VK_DOWN *)
                         currentFieldInfo.i->i; currentFieldInfo.j+1->j; 
                      // homeKey then
                         1->i; currentFieldInfo.j->j; 
                      // endKey then
                         noOfColumns->i; currentFieldInfo.j->j; 
                      // ascii.nl // ascii.cr then
                         
                         (if currentFieldInfo.i=noOfColumns then
                             1 -> i;
                             currentFieldInfo.j+1->j;
                          else
                             currentFieldInfo.i+1->i; 
                             currentFieldInfo.j->j; 
                         if);
                     if);
                     (i,j) -> onNavigate ->select;
                 if);
             if);
          #);
        
        select:
          (# rowNo, colNo: @integer;
             aFieldInfoList: ^fieldInfoList;
          enter (colNo, rowNo)
          do (if (rowNo>0) and (rowNo<=size) then
                 rowNo -> get -> aFieldInfoList[];
                 (if aFieldInfoList[]<>NONE then
                     (colNo, rowNo) -> aFieldInfoList.select;
                 if);
             if);
          #);
        
        doRefresh:
          (# 
          do scan
             (# 
             do current.doRefresh;
             #);
             
          #);
        
     #);
   (* End of theEditFields *)
   verticalSeps: [0] @integer;
   headerHeight: (#  exit 20 #);
   header: @canvas
     (#
        myStaticText: staticText (#  #);
        separatorType: separator
          (#
             open:: 
               (# 
               do
                  (4,headerHeight)->size;
                  (134,0)->position;
                  5->style;
                  false->border.visible;
                  5->border.style;
                  
               #);
             vertical::  (#  do true->value #)
          #);
        open:: 
          (# 
          do
             (496,headerHeight)->size;
             (2,2)->position;
             true->border.visible;
             borderStyles.shadowOut->border.style;
             true->bindRight;
             
          #);
        createHeadingLabels:
          (#
             i,w,h: @integer;
             aStaticText: ^myStaticText;
             aSeparator: ^separatorType;
             theTextStyle: ^textStyle;
             
          do
             0->h;
             createTheHeaderTextStyle ->theTextStyle[];
             theHeadings.scan
               (# x,w: @integer; 
               do
                  i+1->i;
                  (if i <= verticalSeps.range then
                      &myStaticText[]->aStaticText[];
                      aStaticText.open;
                      theTextStyle[] -> aStaticText.style;
                      current.label[]->aStaticText.label;
                      (current.label[]->theTextStyle.widthOfText)->w;
                      (w+4,theTextStyle.lineHeight)->aStaticText.size;
                      h+(current.width div 2)-(w div 2)->x;
                      (x+2,2)->aStaticText.position;
                      &separatorType[]->aSeparator[];
                      aSeparator.open;
                      (h+current.width+2,0)->aSeparator.position; 
                      h+current.width+4->h;
                      
                  if);
                  
               #);
          #);
        
     #);
   scroller1: @scroller
     (#
        <<SLOT scroller1Lib: attributes>>;
        
        open:: 
          (#
             create:: 
               (# <<SLOT scroller1Create: doPart>> #);
          do
             (496,204+gridOffset)->size;
             (2,headerHeight+2)->position;
             true->border.visible;
             borderStyles.shadowIn->border.style;
             true->bindRight;
             true->bindBottom;
             hide;
          #);
        contentsType:: 
          (#
             separatorType: separator
               (#
                  open:: 
                    (# 
                    do
                       (4,1000)->size;
                       (1,0)->position;
                       separatorStyles.singleLine->style;
                       false->border.visible;
                       
                    #);
                  vertical::  (#  do true->value #)
               #);
             eventHandler:: 
               (#
                  onRefresh:: 
                    (# v,j,w,h,w2,h2: @integer; r: @rectangle; 
                    do
                       (* createThePen; *)
                       graphics
                       (# overrideChildren:: 
                            (# do true -> value #);
                       do 
                          size->(w,h);
                          (for i: verticalSeps.range-1 repeat
                               (verticalSeps[i]+2,gridOffset)->MoveTo;
                               (verticalSeps[i]+2,h+40)->drawTo;
                          for);
                          2->j;
                          lineHeight+gridOffset->v;
                          L:
                            (# 
                            do (0,v)->MoveTo;
                               (w+20,v)->drawTo;
                               (j*lineHeight+gridOffset)->v;
                               j+1->j;
                               (if v < h+40 then restart L if);
                            #);
                       #);
                       (* deleteThePen; *)
                    #);
               #);
             
             open:: 
               (# w1,h1,w2,h2: @integer; 
               do
                  header.open;
                  scroller1.size->(w1,h1);
                  THIS(contentsType).size->(w2,h2);
                  (w1,h2)->size;
                  
               #);
             initTheTextField:
               (# x,y: @integer;
                  textFieldBorderSize: (# exit 2 #);
               do THIS(contentsType)[]->theEditText.open;  
                  0 -> theEditText.posToPt -> (x,y);
                  THIS(editSheet).private.theTextStyle.descent 
                  + 5
                    -> THIS(editSheet).private.textTopOffset;
               #);
             addCellValue:
               (#
                  aField_info: ^field_info;
                  i,j: @integer;
                  pos: @point;
                  curRow: ^row;
                  curValue: ^styledText;
                  
               enter curRow[]
               do
                  (if curRow[] <> none then
                      noOfRows->j;
                      (if curRow.private.theFieldInfos.size<noOfColumns then
                          (for noOfColumns-curRow.private.theFieldInfos.size repeat
                               '' -> curRow.addValue;
                          for);
                      if);
                      
                      curRow.private.theFieldInfos.scan
                      (# 
                      do i+1 -> i;
                         current[]->aField_info[];
                         THIS(contentsType)[]->aField_info.theCellRect.open;
                         
                         (if i = 1 then
                             (0,next_vertical_pos)->aField_info.theCellRect.position;
                             
                          else
                             (verticalSeps[i-1]+4,next_vertical_pos)
                               ->aField_info.theCellRect.position;
                             
                           if);
                         sizes[i]->pos->aField_info.theCellRect.size;
                         
                         i->aField_info.i;
                         j->aField_info.j;
                         aField_info[]->theEditFields.add;
                         
                         
                      #);
                      curRow.private.theFieldInfos.scan
                      (# 
                      do current.theCellRect.show;
                         current.theCellRect.update;
                      #);
                      
                      (j*lineHeight+gridOffset)->next_vertical_pos;
                  if);
               #);
             (* End of addCellValue *)
             
          #); (* End of contentsType *)
        
     #);
   (* End of header *)
   setContentsSize: (* Enlarge scrolling area if necessary *)
     (# w,h: @integer
     do
        scroller1.contents.size->(w,h);
        (if noOfRows*lineHeight > h then
            (* (w,h+noOfRows*lineHeight+lineHeight)->scroller1.contents.size *)
            (w,h+lineHeight)->scroller1.contents.size
        if)
     #);
   
#)
