ORIGIN '../tabControlBody';
INCLUDE 
       '~beta/guienv/private/datastructures/sequence'
       '~beta/guienv/controls'
       '~beta/guienv/graphics'
       '~beta/guienv/utils/guienvadds';

   
-- tabControlLib: attributes --
 
ON: (# exit 1 #);
OFF: (# exit 2 #);

-- GUIEnvTabSetLabel: doPart --
do theLabel[] -> tabPrivate.label[];
   
-- GUIEnvTabGetLabel: doPart --
do tabPrivate.label[] -> theLabel[];
   
-- GUIEnvTabSetIcon: doPart --
do theIcon[] -> tabPrivate.icon[];
   
-- GUIEnvTabGetIcon: doPart --
do tabPrivate.icon[] -> theIcon[];
   
-- GUIEnvTabSetPage: doPart --
do thePage[] -> tabPrivate.page[];
   
-- GUIEnvTabGetPage: doPart --
do tabPrivate.page[] -> thePage[];
   
-- GUIEnvTabOpen: doPart --
do INNER;
   (# width, height: @integer;
   do 
      THIS(tabControl)[]->tabPrivate.tb.open;
      (0,28)->tabPrivate.page.position;
      tabprivate.page.bringBack;
      size->(width,height);
      (width,height-28)->tabPrivate.page.size;
      (if tabs.tabsPrivate.storage.empty then this(tab)[]->selection if);
      THIS(tab)[]->tabs.tabsPrivate.storage.append;
   #)
   
-- GUIEnvTabClose: doPart --
do INNER;
        
-- GUIEnvTabSelect: doPart --
do this(tab)[] -> selection;
   
-- GUIenvTabPrivate: descriptor --
(# page: ^canvas;
   label: ^text;
   icon: ^pixmap;
   
   lightGray: (# exit (0xDDDD, 0xDDDD, 0xDDDD) #);
   darkGray: (# exit (0xAAAA, 0xAAAA, 0xAAAA) #);
   tb: @windowItem
     (# theState: @integer;
        theStyle: @textStyle;
        
     	state:
          (# value: @integer;
          enter (# enter value
          	    do (if value <> theState then
          	           value -> theState;
          	           (if theState
          	              //ON then
          	                 borderStyles.shadowIn -> border.style;
          	                 darkGray -> backgroundColor;
          	              //OFF then
          	              	 borderStyles.shadowOut -> border.style;
          	                 lightGray -> backgroundColor;
          	           if);
          	        if);
          	    #)
          exit theState
          #);
        fitToContents:: 
          (# width,height: @integer; 
          do (if label[] <> none then
             	label[] -> theStyle.widthOfText->width;
             else
             	60 -> width;
             if);
             (width+16,20)->size;
             true->doneInInner
          #);
        open:: 
          (# width,height: @integer; 
          do 'Geneva' -> theStyle.name;
             10 -> theStyle.size;
             textFaces.bold -> theStyle.face;
             
             OFF -> state;
             fitToContents;
             (this(tabControl).private.currentPosition + 4,4)->position;
             size->(width,height);
             this(tabControl).private.currentPosition+width+4->this(tabControl).private.currentPosition
          #);
        eventHandler::< 
          (# onMouseDown::<  (#  do this(tab)[]->selection #);
             onRefresh::
               (#
               do graphics
                    (# maxComponent: (# exit 0xFFFF #);
                       lighter:
						  (# c: @color;
						     up: integerValue
						       (# comp: @integer;
						       enter comp
						       do comp + (comp * 30) div 100 -> value;
						          (if value > maxComponent then
						              maxComponent -> value;
						          if);
						       #);
						  enter c
						  do c.red -> up -> c.red;
						     c.green -> up -> c.green;
						     c.blue -> up -> c.blue;
						  exit c
						  #);
						darker:
						  (# c: @color;
						     down: integerValue
						       (# comp: @integer;
						       enter comp
						       do comp - (comp * 20) div 100 -> value;
						          (if value < 0 then
						              0 -> value;
						          if);
						       #);
						  enter c
						  do c.red -> down -> c.red;
						     c.green -> down -> c.green;
						     c.blue -> down -> c.blue;
						  exit c
						  #);
						

                    	drawBorder:
		                 (# borderWidth: (# exit 2 #);
		                    left,right,top,bottom: @integer;
		                    topColor,bottomColor: @color;
		                 enter (left,top,right,bottom)
		                 do
		                    (if state
		                     // ON then
		                        backgroundColor->lighter->bottomColor;
		                        backgroundColor->darker->topColor;
		                        
		                     // OFF then
		                        backgroundColor->lighter->topColor;
		                        backgroundColor->darker->bottomColor;
		                        
		                    if);
		                    topColor->pen.foregroundColor;
		                    (for i: borderWidth repeat
		                      ((left+i-1,top+i-1),(right-i,top+i-1))->drawLine;
		                      ((left+i-1,top+i-1),(left+i-1,bottom-i))->drawLine;
		                      
		                    for);
		                    bottomColor->pen.foregroundColor;
		                    (for i: borderWidth repeat
		                      ((right-i,top+i-1),(right-i,bottom-i))->drawLine;
		                      ((left+i-1,bottom-i),(right-i,bottom-i))->drawLine;
		                    for);
		                    
		                 #);
		              width, height: @integer;
		              tw: @integer;
                    do size -> (width, height);
                       ((0, 0), (width, height)) -> drawRect;
                       (if label[] <> none then
                         theStyle[] -> style;
                         label[] -> theStyle.widthOfText -> tw;
                         ((width - tw) div 2, 4 + theStyle.ascent) -> moveTo;
                         label[] -> drawText;
                       if);
                       (1, 1, width-1, height-1) -> drawBorder;
                    #);
               #);
          #)
     #);
#)

-- GUIEnvTabsSize: doPart --
do tabsPrivate.storage.size -> value;
   
-- GUIEnvTabsScan: doPart --
do tabsPrivate.storage.scan
   (#
   do current[] -> THIS(scan).current[];
      INNER scan;
   #);
   
-- GUIenvTabsPrivate: descriptor --
(# storage: @sequence
     (# element:: tab;
     #);
#)

-- GUIenvTabControlCreate: doPart --
do INNER;
   
-- GUIEnvTabControlOpen: doPart --
do tabs.tabsPrivate.storage.init;
   INNER;
   
-- GUIEnvTabControlClose: doPart --
do INNER;
   tabs.scan
   (#
   do current.close
   #);
   tabs.tabsPrivate.storage.clear;
   
   tabs.tabsPrivate.storage.init
-- GUIEnvTabControlSetSelection: doPart --
do (if private.selected[] <> NONE then
       OFF -> private.selected.tabPrivate.tb.state;
   if);
   theTab[] -> private.selected[];
   theTab.tabPrivate.page.bringToFront;
   ON -> private.selected.tabPrivate.tb.state;
   
-- GUIEnvTabControlGetSelection: doPart --
do private.selected[] -> theTab[];
   
-- GUIenvTabControlEventHandlerOnMouseUp: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnMouseDown: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnFatherFrameChanged: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnActivate: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnRefresh: doPart --
do inner;

-- GUIenvTabControlPrivate: descriptor --
(# currentPosition: @integer;
   selected: ^tab;
#)

