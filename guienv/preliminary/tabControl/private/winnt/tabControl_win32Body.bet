ORIGIN '../tabControlBody';
INCLUDE '~beta/guienv/v1.6/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds';

INCLUDE '~beta/win32lib/v1.6/commctrl';

INCLUDE '~beta/basiclib/v1.6/external';
INCLUDE '~beta/win32lib/v1.6/winuserconsts';
INCLUDE '~beta/win32lib/v1.6/wingdi';
INCLUDE '~beta/win32lib/v1.6/windowsmisc.bet';
INCLUDE '~beta/win32lib/v1.6/mousecursorsupport';

INCLUDE '~beta/sysutils/v1.6/objinterface';

-- lib: attributes --
ntPOINT2: ExternalRecord
  (# 
     x: @long (# pos::< (# do 0 -> value; #); #); (* int x *)
     y: @long (# pos::< (# do 4 -> value; #); #); (* int y *)
  enter(x,y)
  exit(x,y)
  #);

ntRECT2: ExternalRecord
  (# 
     left: @long (# pos::< (# do 0 -> value; #); #); (* int left *)
     top: @long (# pos::< (# do 4 -> value; #); #); (* int top *)
     right: @long (# pos::< (# do 8 -> value; #); #); (* int right *)
     bottom: @long (# pos::< (# do 12 -> value; #); #); (* int bottom *)
  enter (left, top, right, bottom)
  exit (left, top, right, bottom)
  #);
sizeOfNtRect2: (# exit 16 #);


-- tabControlLib: attributes --
BeginDeferWindowPos: external
  (# nNumWindows: @integer;  (* number of windows *)
     theHDWP: @integer;
  enter nNumWindows
  do callStd;
  exit theHDWP
  #);
EndDeferWindowPos: external
  (# hWinPosInfo: @integer; (* handle to internal structure *)
     result: @integer;
  enter hWinPosInfo
  do callStd;
  exit result
  #);
DeferWindowPos: external
  (# 
     hWinPosInfo: @integer;     (* handle to internal structure *)
     hWnd: @integer;            (* handle to window to position *)
     hWndInsertAfter: @integer; (* placement-order handle *)
     x: @integer;               (* horizontal position *)
     y: @integer;               (* vertical position *)
     cx: @integer;	      (* width *)
     cy: @integer;	      (* height *)
     uFlags: @integer;          (* window-positioning flags *)
     theHDWP: @integer;
  enter (hWinPosInfo,hWnd,hWndInsertAfter,x,y,cx,cy,uFlags)
  do callStd;
  exit theHDWP
  #);

TC_ITEM: ExternalRecord
  (# (* value specifying which members to retrieve or set *)
     mask: @long (# pos::< (# do 0 -> value; #); #);  
     
     (* reserved; do not use *)
     lpReserved1: @long (# pos::< (# do 4 -> value; #); #);
     
     (* reserved; do not use *)
     lpReserved2: @long (# pos::< (# do 8 -> value; #); #); 
     
     (* pointer to string containing tab text *)
     pszText: @long (# pos::< (# do 12 -> value; #); #); 
     
     (* size of buffer pointed to by the pszText member *)
     cchTextMax: @long (# pos::< (# do 16 -> value; #); #);  
     
     (* index to tab controls image *)
     iImage: @long (# pos::< (# do 20 -> value; #); #); 
     
     (* application-defined data associated with tab *)
     lParam: @long (# pos::< (# do 24 -> value; #); #);
  #);
sizeOfTC_ITEM: (# exit 28 #);

TCS_FORCEICONLEFT: (# exit       0x0010 #);
TCS_FORCELABELLEFT: (# exit      0x0020 #);
TCS_TABS: (# exit                0x0000 #);
TCS_BUTTONS: (# exit             0x0100 #);
TCS_SINGLELINE: (# exit          0x0000 #);
TCS_MULTILINE: (# exit           0x0200 #);
TCS_RIGHTJUSTIFY: (# exit        0x0000 #);
TCS_FIXEDWIDTH: (# exit          0x0400 #);
TCS_RAGGEDRIGHT: (# exit         0x0800 #);
TCS_FOCUSONBUTTONDOWN: (# exit   0x1000 #);
TCS_OWNERDRAWFIXED: (# exit      0x2000 #);
TCS_TOOLTIPS: (# exit            0x4000 #);
TCS_FOCUSNEVER: (# exit          0x8000 #);

TCM_FIRST: (# exit                0x1300 #);

TCM_GETCURSEL: (# exit (TCM_FIRST + 11) #);
TabCtrl_GetCurSel:
  (# hwnd: @integer;
     result: @integer;
  enter hwnd
  do (hwnd, TCM_GETCURSEL, 0, 0) -> SendMessage -> result;
  exit result
  #);

TCM_INSERTITEMc:    (# exit TCM_FIRST + 7 #);
TabCtrl_InsertItem:
  (# hwnd, iItem, pitem: @integer;
     result: @integer;
  enter (hwnd, iItem, pitem)
  do (hwnd, TCM_INSERTITEMc, iItem, pitem) -> SendMessage -> result;
  exit result
  #);

TCM_DELETEITEMc:    (# exit TCM_FIRST + 8 #);
TabCtrl_DeleteItem:
  (# hwnd, iItem: @integer;
     result: @integer;
  enter (hwnd, iItem)
  do (hwnd, TCM_DELETEITEMc, iItem, 0) -> SendMessage -> result;
  exit result
  #);

TCM_ADJUSTRECTc:    (# exit           (TCM_FIRST + 40) #);
TabCtrl_AdjustRect:
  (# hwnd, bLarger, prc: @integer;
     result: @integer;
  enter (hwnd, bLarger, prc)
  do (hwnd, TCM_ADJUSTRECTc, bLarger, prc)
       -> SendMessage -> result;
  #);

TCN_FIRST: (# exit                -550            #);
TCN_LAST: (# exit                 -580            #);
TCN_SELCHANGE: (# exit             (TCN_FIRST - 1) #);
TCN_SELCHANGING: (# exit          (TCN_FIRST - 2) #);

TCIF_TEXT: (# exit                0x0001 #);
TCIF_IMAGE: (# exit               0x0002 #);
TCIF_RTLREADING: (# exit          0x0004 #);
TCIF_PARAM: (# exit               0x0008 #);

TCM_GETITEMCOUNT: (# exit (TCM_FIRST + 4) #);
TabCtrl_GetItemCount:
  (# hwnd,result: @integer;
  enter hwnd
  do (hwnd, TCM_GETITEMCOUNT, 0, 0) -> SendMessage -> result;
  exit result
  #);

TCN_KEYDOWN: (# exit           (TCN_FIRST - 0) #);

TCM_SETCURSEL: (# exit           (TCM_FIRST + 12) #);
TabCtrl_SetCurSel:
  (# hwnd,i,result: @integer;
  enter (hwnd,i)
  do (hwnd, TCM_SETCURSEL, i, 0) -> SendMessage -> result;
  exit result
  #);

PatBlt: external
  (# hdc, left, top, width, height,rasterMode: @integer;
     result: @integer;
  enter (hdc, left, top, width, height, rasterMode)
  do callStd;
  exit result
  #);

tab:
  (# label: ^text;
     icon: ^pixmap;
     inx: @integer;
     theCanvas: ^canvas;
  #);


tabControlNotiMethods: windowItemNotificationMethods
  (# handleNotification::
       (# 
          processNotify:
            (# hwndFrom: @integer;
               theTab: ^tab;
            do info.lParam -> TOS'%adrGetLong' -> hwndFrom;
               (if hwndFrom=private.hwndTab then
                   (if (info.lParam+8 -> TOS'%adrGetLong')
                    //TCN_SELCHANGE then
                       private.hwndTab -> TabCtrl_GetCurSel
                         -> private.theTabs.findTab -> theTab[];
                       (if theTab[]<>NONE then
                           (if private.current_canvas[]<>NONE then
                               (if private.current_canvas.visible then
                                   private.current_canvas.hide;
                               if);
                           if);
                           theTab.theCanvas[] 
                             -> private.current_canvas[];
                           private.current_canvas.interfaceObjectID 
                             -> private.current_hwndDisplay;
                           
                           (if not theTab.theCanvas.visible then
                               theTab.theCanvas.show;
                           if);
                           theTab.theCanvas.bringToFront;
                           theTab.theCanvas[] -> onSelect;
                       if);
                    //TCN_SELCHANGING then
                       (if onBeforeSelect then
                           0 -> info.result;
                        else
                           1 -> info.result;
                       if);
                    //TCN_KEYDOWN then
                       (# vKey: @integer;
                       do info.lParam+12 -> TOS'%adrGetShort' -> vKey;
                          (if vKey=VK_TAB then
                              (if (VK_SHIFT -> isVKeyDown) then
                                  
                               else
                                  (* L:
                                   *                                     private.current_canvas.scan
                                   *                                   (# 
                                   *                                   do current[] -> target;
                                   *                                      leave L 
                                   *                                   #);
                                   *)
                              if);
                           else
                              false -> didSomething;
                          if);
                       #);
                    else
                       false -> didSomething;
                   if);
               if);
            #);
          
          
          didSomething: @boolean;
       do true -> didSomething;
          (if info.message = WM_NOTIFY then processNotify;
           else
              false -> didSomething;
          if);
          didSomething or info.handled -> info.handled;
       #);
  #);

-- GUIEnvTabControlAdd: doPart --
do (# tie: @TC_ITEM; 
      tempLabel: @cString;
      mask: @integer;
      theTab: ^tab;
      insertRes: @integer;
   do (if theCanvas[]<>NONE then
          
          &tab[] -> theTab[];
          theCanvas[] -> theTab.theCanvas[];
          theLabel[] -> theTab.label[];
          theIcon[] -> theTab.icon[];
          
          0 -> mask;
          
          sizeOfTC_ITEM -> malloc -> tie.ptr; 
          
          (if tie.ptr<>0 then
              (if theLabel[]<>NONE then
                  (if theLabel.length>0 then
                      (mask, TCIF_TEXT) -> tos'%or' -> mask; 
                      theLabel[] -> tempLabel.set;
                      tempLabel -> tie.pszText;
                  if);
              if);
              
              (if theIcon[]<>NONE then
                  (mask, TCIF_IMAGE) -> tos'%or' -> mask; 
                  
               else
                  -1 -> tie.iImage; 
              if);
              mask -> tie.mask;
                            
              private.hwndTab -> TabCtrl_GetItemCount -> theTab.inx;
              (private.hwndTab, theTab.inx, tie.ptr) 
                -> TabCtrl_InsertItem -> insertRes;
              
              (if (insertRes = -1) then
                  tempLabel.free;
                  tie.ptr -> free;
                  0 -> tie.ptr;
                  (* failed; *)
               else
                  theTab[] -> private.theTabs.append;
                  
                  (if private.current_canvas[]<>NONE then
                      (if private.current_canvas.visible then
                          private.current_canvas.hide;
                      if);
                  if);
                  theCanvas.interfaceObjectID 
                    -> private.current_hwndDisplay;
                  theCanvas[] -> private.current_canvas[];
                  
                  private.handleSize; 
                  
                  (private.hwndTab, theTab.inx) -> TabCtrl_SetCurSel;
                  (if not theCanvas.visible then
                      theCanvas.show;
                  if);
                  theCanvas.bringToFront;
              if);
              
              (if tempLabel.charPtr<>0 then 
                  tempLabel.free; 
              if);
              (if (tie.ptr<>0) then
                  0 -> tie.ptr;
              if);
          if);
      if);
   #);
   
-- GUIEnvTabControlDelete: doPart --
do (# theTab: ^tab;
      deleteRes: @integer;
   do L:
        private.theTabs.scan
        (# 
        do (if current.theCanvas[]=theCanvas[] then
               current[] -> theTab[];
               leave L
           if);
        #);
      (if theTab[]<>NONE then
          
          (private.hwndTab, theTab.inx) -> TabCtrl_DeleteItem -> deleteRes;
          
          (if deleteRes=0 then
              'TabCtrl_DeleteItem failed. Error= ' -> screen.putText;
              GetLastError -> screen.putInt; newline;
          if);
          
          theTab[] -> private.theTabs.at -> private.theTabs.delete;
          private.theTabs.scan
          (# 
          do (if current.inx > theTab.inx then
                 current.inx - 1 -> current.inx;
             if);
          #);
      if);
   #);

-- GUIenvTabControlCreate: doPart --
do InitCommonControls; 
   
   &tabControlNotiMethods[] -> theNotiMethods;
   isSubClass  -> windowItemClassStatus; 
   'SysTabControl32' -> windowItemClass;
   
   (TCS_MULTILINE,TCS_FOCUSONBUTTONDOWN) -> tos'%or' -> windowItemStyle;
   
   inner;
   
-- GUIEnvTabControlOpen: doPart --
do (# rcClient: @ntRECT2;
      hwndParent: @integer;
      theTextStyle: ^textStyle;
   do interfaceObjectID -> private.hwndTab;
      (if father[]=none then
          this(window).interfaceObjectID -> hwndParent;
       else
          father.interfaceObjectID -> hwndParent;
      if);
      sizeOfNtRect2 -> malloc -> rcClient.ptr;
      (if rcClient.ptr<>0 then
          (hwndParent, rcClient.ptr) -> GetClientRect; 
          ((rcClient.right - rcClient.left),(rcClient.bottom - rcClient.top))
            -> size;
          rcClient.ptr -> free;          
          0 -> rcClient.ptr;
      if);
      
      (if defaultButtonTextStyle=NONE then
          &textStyle[] -> theTextStyle[];
          'MS Sans Serif' -> theTextStyle.name;
          8 -> theTextStyle.size;
          theTextStyle.create;
          theTextStyle[] -> defaultButtonTextStyle;
       else
          defaultButtonTextStyle -> theTextStyle[];
      if);
      
      (private.hwndTab,WM_SETFONT,theTextStyle.textStyleID,1) -> SendMessage;
      inner open;
      
      (* true -> bindTop -> bindLeft -> bindBottom -> bindRight; *)
   #);
   
-- GUIEnvTabControlClose: doPart --
do inner;
   
-- GUIEnvTabControlSelect: doPart --
do theCanvas[] -> selection;
   
-- GUIEnvTabControlSetSelection: doPart --
do (if theCanvas[]<>NONE then
       L: private.theTabs.scan
         (# 
         do (if current.theCanvas[]=theCanvas[] then
                (private.hwndTab, current.inx) -> TabCtrl_SetCurSel;
                
                (if private.current_canvas[]<>NONE then
                    (if private.current_canvas.visible then
                        private.current_canvas.hide;
                    if);
                if);
                
                theCanvas[] -> private.current_canvas[];
                private.current_canvas.interfaceObjectID 
                  -> private.current_hwndDisplay;
                (if not theCanvas.visible then
                    theCanvas.show;
                if);
                theCanvas.bringToFront;
                theCanvas[] -> onSelect;
                leave L;
            if);
         #);
   if);   
   
-- GUIEnvTabControlGetSelection: doPart --
do (# theTab: ^tab;
   do private.hwndTab -> TabCtrl_GetCurSel
        -> private.theTabs.findTab -> theTab[];
      (if theTab[]<>NONE then
          theTab.theCanvas[] -> theCanvas[];
      if);
   #);
   
-- GUIenvTabControlEventHandlerOnMouseUp: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnMouseDown: doPart --
do inner;
   
-- GUIenvTabControlEventHandlerOnFatherFrameChanged: doPart --
do private.handleSize;
   inner;
   
-- GUIenvTabControlEventHandlerOnActivate: doPart --
do (if private.current_canvas[]<>NONE then
       private.current_canvas.bringToFront;
   if);
   inner;
   
-- GUIenvTabControlPrivate: descriptor --
(# 
   
   theTabs: @list
     (# element:: tab;
        findTab:
          (# inx: @integer;
             theTab: ^tab;
          enter inx
          do L:
               scan
               (# 
               do (if current.inx=inx then
                      current[] -> theTab[];
                      leave L
                  if);
               #);
          exit theTab[]
          #);
     #);

   hwndTab: @integer;
   current_hwndDisplay: @integer;
   current_canvas: ^canvas;
   
   handleSize:
     (# rc: @ntRECT2;
        hdwp: @integer;
        width,height: @integer;
     do 
        this(tabControl).size -> (width,height);
        
        sizeOfNtRect2 -> malloc -> rc.ptr;
        (if rc.ptr<>0 then
            (* Calculate the display rectangle, assuming the 
             * tab control is the size of the client area.
             *)
            0 -> rc.left; 0 -> rc.top;
            width -> rc.right;
            height -> rc.bottom;
            (private.hwndTab, 0, rc.ptr) -> TabCtrl_AdjustRect;
            (* Size the tab control to fit the client area. *)            
            theTabs.scan
            (# 
            do (rc.left, rc.top) -> current.theCanvas.position;
               ((rc.right - rc.left),(rc.bottom - rc.top))
                 -> current.theCanvas.size;
            #);
            
            rc.ptr -> free;
        if);
     #);
#)
