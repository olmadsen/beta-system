ORIGIN 'guienv';
INCLUDE 'controls';
INCLUDE 'styledtext';
BODY 'private/fieldsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- windowLib: attributes --
(* idx=2 *)
movie: (# #) (* ONLY defined to make this fragment compilable *);
movieField: windowItem
  (# <<SLOT movieFieldLib: attributes>>;
     contents:
       (* the movie shown in THIS(movieField) *)
       (# theMovie: ^movie
       enter (# enter theMovie[] do <<SLOT GUIENVmovieFieldSetContents: descriptor>> #)
       exit (# do <<SLOT GUIENVmovieFieldGetContents: descriptor>> exit theMovie[] #)
       #);
     scaleToFit:
       (* if true, contents will be scaled to fit in
        * THIS(movieField).  Otherwise, it will be clipped.
        *)
       (# value: @boolean;
       enter (# enter value do <<SLOT GUIENVmovieFieldSetScaleToFit: descriptor>> #)
       exit (# do <<SLOT GUIENVmovieFieldGetScaleToFit: descriptor>> exit value #)
       #);
     open::< 
       (# create::< (# do <<SLOT GUIENVmovieFieldCreate: descriptor>> #);
       do <<SLOT GUIENVmovieFieldOpen: descriptor>> 
       #);
     close::<
       (# 
       do <<SLOT GUIENVmovieFieldClose: descriptor>>;
       #);
     layoutType::< movieFieldLayout;
     putLayout::< (* private *) (# <<SLOT GUIENVputmovieFieldLayout: doPart>> #);
     getLayout::< (* private *) (# <<SLOT GUIENVgetmovieFieldLayout: doPart>> #);
     private: @<<SLOT GUIENVmovieFieldPrivate: descriptor>>;
  #) (* movieField *);
textField: windowItem
  (* this is a simple field that is used to edit styled text.  There
   * is no scroll functionality, use the textEditor pattern, if
   * scrolling is required. The normal editing commands cut, copy,
   * paste, clear are supported. THIS(textField) has to be the
   * window's target, when editing is performed. this can be obtained
   * by calling THIS(textField)[] -> target...  this is automatically
   * done when the user clicks in a textField that isn't the target
   * already
   *)
  (# <<SLOT textFieldLib: attributes>>;
     (* idx+ *)
     eventhandler::<
       (# textChanged: event
            (* this event is called whenever the text in
             * THIS(textField) is changed
             *)
            (# do inner #);
          onTextChanged:< textChanged;
          beforeChange: event
            (* This is called before any change is performed in
             * THIS(textField) If allow is set to false, then change
             * is not performed.  Position indicates where in the
             * textfield, the text is inserted or deleted. Length
             * indicates how many characters is inserted or
             * deleted. If length is negative, then the characters are
             * deleted - otherwise they are inserted.
             *)
            (# position,length: @integer;
               allow: @boolean;
               theText:
                 (* The text beeing inserted when lenght > 0 *)
                 (# value: ^text;
                 <<SLOT GUIENVtextFieldBeforeChangeTheText: doPart>>
                 exit value[]
                 #);
            enter (position,length)
            do true -> allow;
               inner;
            exit allow
            #);
          onBeforeChange:< beforeChange;
          onFrameChanged::<
            (# do <<SLOT GUIENVtextFieldonFrameChanged: descriptor>> #);
          onKeyDown::<
            (# do <<SLOT GUIENVtextFieldonKeyDown: descriptor>> #);
          onMouseDown::<
            (# do <<SLOT GUIENVtextFieldonMouseDown: descriptor>> #);
          onMouseUp::<
           (# do <<SLOT GUIENVtextFieldonMouseUp: descriptor>> #);
    	  onRefresh::<
            (# do <<SLOT GUIENVtextFieldonRefresh: descriptor>> #);
          onEnableTarget::<
            (# do <<SLOT GUIENVtextFieldOnEnableTarget: descriptor>> #);
          onDisableTarget::<
            (# do <<SLOT GUIENVtextFieldOnDisableTarget: descriptor>> #);
          onIdle::<
            (# do <<SLOT GUIENVtextFieldonIdle: descriptor>> #);
       #);
     (* idx- *)
     paste:
       (* this method pastes text from the clipboard into
        * THIS(textField) at the current insertion point or replaces
        * the current selection.  The text is styled according to the
        * style information found in the scrap; if there is none, it
        * is given the same style as the first character of the
        * replaced selection (or that of the preceding character if
        * the selection is an insertion point)
        *)
       (# do <<SLOT GUIENVtextFieldDoPaste: descriptor>> #);
     copy:
       (* the current selection is copied into the clipboard with the
        * associated style information. If the current selection is an
        * insertion point the clipboard is emptied
        *)
       (# do <<SLOT GUIENVtextFieldDoCopy: descriptor>> #);
     cut:
       (* the current selection is first copied into the clipBoard
        * and then deleted
        *)
       (# do <<SLOT GUIENVtextFieldDoCut: descriptor>> #);
     clear:
       (* the current selection is deleted, and the clipboard is not
        * affected.  Calling delete is the same as pressing backspace
        *)
       (# do <<SLOT GUIENVtextFieldDoClear: descriptor>> #);
     contents: 
       (* the text in THIS(textField) *)
       (# theText: ^styledText;
       enter (# enter theText[]  do <<SLOT GUIENVtextFieldSetContents: descriptor>> #)
       exit (# do <<SLOT GUIENVtextFieldGetContents: descriptor>> exit theText[] #) 
       #);
     getChar: 
       (* returns the character at position (pos) in THIS(textField).
        * The return character (ASCII.cr) and other control characters
        * count
        *)
       (# pos: @integer;
          ch: @char;
       enter pos
       do <<SLOT GUIENVtextFieldGetChar: descriptor>>
       exit ch
       #);
     length: integerValue
       (* returns the number of characters in THIS(textField) *)
       (# do <<SLOT GUIENVtextFieldLength: descriptor>> #);
     all: 
       (* if you want to scan all the text in THIS(textField), use:
        * all -> scanText(#...#)
        *)
       (# exit (0,length) #);
     scanText: 
       (* INNER is called for every character from position start to
        * end in THIS(textField). The variable ch is the current
        * character
        *)
       (# start,end: @integer;
          ch: @char;
       enter (start,end)
       do <<SLOT GUIENVtextFieldScanText: descriptor>>
       #);
     posToPt:
       (* Calculates the coordinates of the character number `pos' in
        * the textField.
        *)
       (# pos: @integer;
          pt: @point;
       enter pos
       do <<SLOT GUIENVtextFieldPosToPt: descriptor>>;
       exit pt
       #);
     ptToPos:
       (* Calculates the character that are located at the specified
        * coordinates in the textField.
        *)
       (# pos: @integer;
          pt: @point;
       enter pt
       do <<SLOT GUIENVtextFieldPtToPos: descriptor>>;
       exit pos
       #);
     (* idx+ *)
     selection: @
       (* selection is the current range of characters in this
        * (textField) that is selected. Start is the position in the
        * text of the first character of the selection and end is the
        * position of the last.  If the selection is an insertion
        * point, "start" and "end" will be the position of the
        * character just after the carret
        *)
       (# start: integerValue
            (# do <<SLOT GUIENVtextFieldSelectionStart: descriptor>> #);
          end: integerValue
            (# do <<SLOT GUIENVtextFieldSelectionEnd: descriptor>> #);
          contents: 
            (* returns the text selected in THIS(textField) *)
            (# theText: ^text;
            do <<SLOT GUIENVtextFieldSelectionContents: descriptor>>
            exit theText[]
            #);
          scrollIntoView:
            (* scrollIntoView makes sure the Selection is visible,
             * scrolling the textField, if necesary
             *)
            <<SLOT GUIENVtextFieldSelectionScrollIntoView: descriptor>>;
          set: 
            (* this makes [theStart,theEnd] the new selection *)
            (# theStart,theEnd: @integer;
            enter (theStart,theEnd)
            do <<SLOT GUIENVtextFieldSelectionSet: descriptor>>
            #);
          get: (# exit (start,end) #);
       enter set
       exit get
       #) (* selection *);
     (* idx- *)
     
     defaultStyle:
       (* The default style is the style that is used when the
        * textfield has been completely empty and new text is entered.
        *)
       (# style: ^textStyle;
       enter (# enter style[] do <<SLOT GUIENVtextFieldSetDefaultStyle: descriptor>> #)
       exit (# do <<SLOT GUIENVtextFieldGetDefaultStyle: descriptor>> exit style[] #)
       #);
     isOneStyle: 
       (* this function returns a textStyle if the range of
        * characters [start,end] has the same style - in which case
        * "theStyle" will be set to that textStyle - Otherwise
        * theStyle will be NONE
        *)
       (# start,end: @integer;
          theStyle: ^textStyle;
       enter (start,end)
       do <<SLOT GUIENVtextFieldIsOneStyle: descriptor>>
       exit theStyle[]
       #);
     setOneSize: 
       (* this makes the range of characters [start,end] have the
        * same size specified by "theSize"
        *)
       (# start,end: @integer;
          theSize: @integer;
       enter (start,end,theSize)
       do <<SLOT GUIENVtextFieldSetOneSize: descriptor>>
       #);
     setOneFont: 
       (* this makes the range of characters [start,end] have the
        * same font specified by "theFont"
        *)
       (# start,end: @integer;
          theFont: ^text;
       enter (start,end,theFont[])
       do <<SLOT GUIENVtextFieldSetOneFont: descriptor>>
       #);
     setOneFace: 
       (* this makes the range of characters [start,end] have the
        * same face (textFaces.italic, textFaces.bold etc.) specified
        * by "theFace". If doToggle is true and the face specified
        * exists across the entire selected range, that face is
        * removed (turned off).  Otherwise, all of the selected text
        * is set to include that face
        *)
       (# start,end: @integer;
          doToggle: @boolean;
          theFace: @integer;
       enter (start,end,theFace,doToggle)
       do <<SLOT GUIENVtextFieldSetOneFace: descriptor>>
       #);
     setOneStyle: 
       (* this makes the range of characters [start,end] have the
        * same continous style specified by "theStyle"
        *)
       (# start,end: @integer;
          theStyle: @textStyle;
       enter (start,end,theStyle)
       do <<SLOT GUIENVtextFieldSetOneStyle: descriptor>>
       #);
     scanTextWithStyle: 
       (* this is a control pattern that calls an INNER for all
        * characters in THIS(textField) with the style "theStyle".
        * The variable "ch" is the current character
        *)
       (# theStyle: ^textStyle;
          ch: @char;
       enter theStyle[]
       do <<SLOT GUIENVtextFieldScanTextWithStyle: descriptor>>
       #);
     margin: 
       (* use this pattern to set or retrieve the left- and top
        * margin of the text in THIS(textField).  The left margin is
        * the distance from the left bound of THIS(textField) to the
        * text in THIS(textField).  The top margin is the distance
        * from the upper bound of THIS(textField) to the text in
        * THIS(textField)
        *)
       (# leftMargin,topMargin: @integer;
       enter (# enter (leftMargin,topMargin) do <<SLOT GUIENVtextFieldSetMargin: descriptor>> #)
       exit (# do <<SLOT GUIENVtextFieldGetMargin: descriptor>> exit (leftMargin,topMargin) #)
       #);
     insert: 
       (* insert takes the specified text and inserts it just before
        * the selection range in THIS(textField). Insert doesn't
        * affect either the current selection range or the clipboard
        *)
       (# theText: ^text;
       enter theText[]
       do <<SLOT GUIENVtextFieldInsert: descriptor>>
       #);
     delete: 
       (* deletes the characters in the current selection range *)
       (# do <<SLOT GUIENVtextFieldDelete: descriptor>> #);
     
     open::< 
       (# create::< (# do <<SLOT GUIENVtextFieldCreate: descriptor>> #);
       do <<SLOT GUIENVtextFieldOpen: descriptor>> 
       #);
     close::< (# do <<SLOT GUIENVtextFieldClose: descriptor>> #);
     layoutType::< textFieldLayout;
     putLayout::< (* private *) (# <<SLOT GUIENVtextFieldputLayout: doPart>> #);
     getLayout::< (* private *) (# <<SLOT GUIENVtextFieldgetLayout: doPart>> #);
     private: @<<SLOT GUIENVtextFieldPrivate: descriptor>>;
  #) (* textField *);
abstractScroller: canvas
  (* this is an abstract superpattern for objects with two
   * scrollbars.  The abstractScroller consist of a canvas containing
   * the virtual definition of contents that models the object that is
   * scrolled and the two scrollbars.  It also defines the virtual
   * procedure patterns scroll and adjustscrolling
   *)
  (# <<SLOT abstractScrollerLib: attributes>>;
     contentsType:< (* this describes the object that is scrolled *)
       windowItem;
     contents: @contentsType;
     scroll:<
       (* this is a superpattern for scrolling functionality of
        * THIS(abstractScroller).  The contents are scrolled "dh"
        * pixels to the right and "dv" pixels down
        *)
       (# dh,dv: @integer       
       enter (dh,dv) 
       do <<SLOT GUIENVabstractScrollerScroll: descriptor>>;
       #);
     open::< 
       (# create::< (# do <<SLOT GUIENVabstractScrollerCreate: descriptor>> #);
       do <<SLOT GUIENVabstractScrollerOpen: descriptor>> 
       #);
     close::< (# do <<SLOT GUIENVabstractScrollerClose: descriptor>> #);
     layoutType::< abstractScrollerLayout;
     putLayout::< (* private *) (# <<SLOT GUIENVabstractScrollerputLayout: doPart>> #);
     getLayout::< (* private *) (# <<SLOT GUIENVabstractScrollergetLayout: doPart>> #);
     private: @<<SLOT GUIENVabstractScrollerPrivate: descriptor>>;
  #) (* abstractScroller *);
textEditor: abstractScroller
  (* this models a texteditor, that is a textfield with two
   * scrollbars
   *)
  (# <<SLOT textEditorLib: attributes>>;
     contentsType::< 
       textField;
     scroll::<
       (# do <<SLOT GUIENVtextEditorScroll: descriptor>> #);
     open::< 
       (# create::< (# do <<SLOT GUIENVtextEditorCreate: descriptor>> #);
       do <<SLOT GUIENVtextEditorOpen: descriptor>> 
       #);
     close::<
       (# do <<SLOT GUIENVtextEditorClose: descriptor>> #);
     layoutType::< textEditorLayout;
     putLayout::< (* private *) (# <<SLOT GUIENVtextEditorputLayout: doPart>> #);
     getLayout::< (* private *) (# <<SLOT GUIENVtextEditorgetLayout: doPart>> #);
     private: @<<SLOT GUIENVtextEditorPrivate: descriptor>>;
  #) (* textEditor *);
scroller: abstractScroller
  (* this is a general scroller, which can scroll an entire canvas *)
  (# <<SLOT scrollerLib: attributes>>;
     contentsType::< 
       canvas;
     scroll::< 
       (# do <<SLOT GUIENVscrollerScroll: descriptor>> #);
     open::< 
       (# create::< (# do <<SLOT GUIENVscrollerCreate: descriptor>> #);
       do <<SLOT GUIENVscrollerOpen: descriptor>> 
       #);
     close::<
       (# do <<SLOT GUIENVscrollerClose: descriptor>>; #);
     (* idx+ *)
     eventhandler::<
       (# onFrameChanged::<
            (# 
            do <<SLOT GUIENVScrollerOnFrameChanged: descriptor>>;
            #);
       #);
     (* idx- *)
     layoutType::< scrollerLayout;
     putLayout::< (* private *) (# <<SLOT GUIENVscrollerputLayout: doPart>> #);
     getLayout::< (* private *) (# <<SLOT GUIENVscrollergetLayout: doPart>> #);
     private: @<<SLOT GUIENVscrollerPrivate: descriptor>>;
  #) (* scroller *);
