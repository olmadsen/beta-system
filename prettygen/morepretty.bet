ORIGIN '~beta/basiclib/v1.5/betaenv';
INCLUDE '~beta/mps/v5.1/astlevel';
INCLUDE '~beta/mps/v5.1/metagrammarcfl';
INCLUDE 'prettyprintcfl';
INCLUDE 'pstab';
INCLUDE '~beta/sysutils/v1.5/objinterface'
-- Program: Descriptor --
(# 
do
   AstInterface
     (# (* Per Fack Sorensen, DAIMI: spring 1987: This program adds semantic *)
     (*                    attributes to a pretty-print-specification     *)
     (* PFS: summer 1987: Changed to compile the pretty-print-spec. into  *)
     (*                    a 'fast-access' table                          *)
     (* PFS: 24/8 1987: changed to handle tagfields.                      *)
     (* PFS: 24/8 1987: updated according to pretty-print-spec. grammar   *)
     (* PFS: 16/12 1987: Last parts from first version removed            *)
     (* PFS: 16/12 1987: comments inserted                                *)
     (* ESS: 22/9 1989: one file per group                               *)
        ok: @boolean;
        GrammarName,ppParser: ^Text;
        emptyString: @Text;
        grammarFile: @File;
        ppast: @prettyprint;
        pretty: ^ppast.PrettyPrint;
        productionListP: ^ppast.productionList;
        gast: @metagrammar;
        grammar: ^gast.AGrammar;
        productionListG: ^gast.productionList;
        PST: @PSTable;
        grammarGroup: ^fragmentGroup;
        metaAst,prettyAst: ^fragmentForm;
        metaGroup,prettyGroup: ^fragmentGroup;
        help: ^text;
        
     do
        astLevelInit;
        emptyString.clear;
        (if true
         // (noOfArguments < 2) then
            (failure,'Usage: morepretty grammarName')->&stop; 
         else
            2->Arguments->expandToFullPath->grammarName[]; 
        if);
        (* Open pretty-print-specification *)
          (# grammarWithPath: ^Text; gg: ^FragmentGroup; 
          do
             gast.init;
             gast[]->grammarTable.meta[];
             '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
             ('-meta'->(grammarWithPath.copy).Append,screen[])->top.open->gg[];
             (if gg[]
              // none then
                 'Could not open: '->screen.putText;
                 '-meta'->(grammarWithPath.copy).Append->screen.putLine;
                 (failure,'')->stop;
                 
              else
                 ('metagrammar',screen[])->gg.open->gast.grammarAst[];
                 (if gast.grammarAst[]
                  // none then
                     'No grammarAst for '->screen.putText;
                     grammarWithPath[]->screen.putLine;
                     (failure,'')->stop;
                     
                 if)
             if);
             ppast.init;
             '~beta/grammars/pretty/v2.3/prettyprint'->grammarWithPath[];
             ('-meta'->(grammarWithPath.copy).Append,screen[])->top.open->gg[];
             (if gg[]
              // none then
                 'Could not open: '->screen.putText;
                 '-meta'->(grammarWithPath.copy).Append->screen.putLine;
                 (failure,'')->stop;
                 
              else
                 ('prettyprint',screen[])->gg.open->ppast.grammarAst[];
                 (if ppast.grammarAst[]
                  // none then
                     'No grammarAst for '->screen.putText;
                     grammarWithPath[]->screen.putLine;
                     (failure,'')->stop;
                     
                 if)
             if);
             'ppParser: '->putText;
             '-parser'->help[];
             parserFileExtension->help.append;
             help[]->(grammarWithPath.copy).append->expandToFullPath->ppParser[]
               ->putLine;
             ppParser[]->ppast.parser.initialize;
             
          #);
        (grammarName[],screen[])->top.open->grammarGroup[];
        (if grammarGroup[]
         // none then (failure,'Error. grammar does not exist')->stop
        if);
        doOpen:
        ('pretty',screen[])
          ->grammarGroup.open
            (#
               myException:
                 (# msg: ^text
                 enter msg[]
                 do msg[]->putline; leave doOpen
                 #);
               fragmentNotExisting::< 
                 (#  do 'Non-existent fragment file'->myException #);
               readAccessError::< 
                 (#  do 'Read access error'->myException #);
               grammarNotFound::< 
                 (#  do 'Grammar not found'->myException #);
               badFormat::<  (#  do 'Bad AST format'->myException #);
               startingParsing::< 
                 (# 
                 do
                    'Parsing '->putText;
                    grammarName[]->putText;
                    '-pretty.pgram'->putText;
                    '...'->putLine;
                    
                 #);
               
            #)->prettyGroup[];
        (if prettyGroup[]
         // none then
            (failure,'Could not open prettyprint specification')->&stop; 
        if);
        firstFragment: prettyGroup.fragmentList.scan
          (# 
          do
             (if current.f.type
              // formType then current.f[]->prettyAst[]; leave firstFragment
             if)
          #);
        (if prettyAst[]
         // none then
            (failure,'Error. no pretty-print specification')->stop; 
        if);
        prettyAst.markAsChanged;
        prettyAst.root[]->pretty[];
        pretty.getProductionList->productionListP[];
        (* Open grammar *)
        ('meta',screen[])->grammarGroup.open->metaGroup[];
        (if metaGroup[]
         // none then (failure,'Could not open grammar')->&stop; 
        if);
        firstFragment: metaGroup.fragmentList.scan
          (# 
          do
             (if current.f.type
              // formType then current.f[]->metaAst[]; leave firstFragment
             if)
          #);
        (if metaAst[]
         // none then (failure,'Error. no meta-grammar')->&stop
        if);
        metaAst.root[]->grammar[];
        grammar.getProductionList->productionListG[];
        'Scan productions'->screen.putText;
        PST.initialize;
        PST.create
          (# 
          do (* Scan through productions in pretty-print-specification *)
             productionListP.scan
               (#
                  production: ^ppast.production;
                  productionName: ^lexemText;
                  PText: ^Text;
                  productionNumber: @integer;
                  
               do
                  '.'->screen.put;
                  0->productionNumber;
                  current[]->production[];
                  production (* QUA ppast.Constructor OR QUA ppast.ListProd *) .
                    getSon1 (* .getProductionName *) ->productionName[];
                  productionName.getText->PText[];
                  PText.makeLC;
                  FindProductionInGrammar: productionListG.scan
                    (#
                       prod: ^expanded;
                       leftside: ^gast.LeftSide;
                       synDeclName: ^gast.synDeclName;
                       nameDecl: ^lexemText;
                       GText: ^Text;
                       
                    do
                       current[]->prod[];
                       prod (* QUA Constructor OR QUA ListOne OR QUA ListZero *)
                       .getSon1 (* .getLeftSide *) ->leftside[];
                       leftside.getSynDeclName->synDeclName[];
                       synDeclName.getNameDecl->nameDecl[];
                       nameDecl.getText->GText[];
                       GText.makeLC;
                       (if (PText[]->GText.equal)
                        // false then
                        (* scan to next production (i.e. do nothing here) *)
                           
                        // true then (* corresponding productions found *)
                           currentSonNo->productionNumber;
                           ProcessProduction: (* A Label! *) &
                             (#
                                itemListScan:
                                  (# as: ^AST; itemList: ^ppast.ItemList; 
                                  enter as[]
                                  do
                                     (if (as.symbol = ppast.ItemList)
                                      // false then
                                         (failure,'itemlistscan: list expected')
                                           ->&stop
                                      // true then
                                         as[]->itemList[];
                                         itemList.scan
                                           (# 
                                           do
                                              (if current.symbol
                                               // ppast.DefaultTerm then
                                                    (#
                                                       default:
                                                         ^ppast.DefaultTerm;
                                                       terminalNo: ^const;
                                                       noOfTerms: @integer;
                                                       
                                                    do
                                                       current[]->default[];
                                                       default.getTerminalNo
                                                         ->terminalNo[];
                                                       0->noOfTerms;
                                                       scan: RHS.scan
                                                         (#
                                                            term: ^gast.Term;
                                                            str: ^String;
                                                            sy: @PST.Symbol;
                                                            
                                                         do
                                                            (if current.symbol
                                                             // gast.Term then
                                                             (* current is a terminal-symbol ... *)
                                                                (if
                                                                (noOfTerms+1
                                                                   ->noOfTerms)
                                                                 //
                                                                 terminalNo.
                                                                   getValue then
                                                                 (* ... and has the right number *)
                                                                 (* Get representation of terminal-symbol *)
                                                                    current[]
                                                                      ->term[];
                                                                    term.
                                                                      getString
                                                                      ->str[];
                                                                    PST.Terminal
                                                                      ->
                                                                        NewSymbol
                                                                      ->sy;
                                                                    str.getText
                                                                      ->
                                                                        NewString
                                                                      ->
                                                                        sy.
                                                                          StringRef;
                                                                    leave scan
                                                                if)
                                                            if)
                                                         #);
                                                       
                                                    #);
                                                  (* //ppast.DefaultTerm *)
                                                  
                                               // ppast.AltTerm then
                                                    (#
                                                       altTerm: ^ppast.AltTerm;
                                                       str: ^string;
                                                       sy: @PST.Symbol;
                                                       
                                                    do
                                                    (* Get representation of terminal-symbol *)
                                                       current[]->altTerm[];
                                                       altTerm.
                                                         getAlternativeTerminal
                                                         ->str[];
                                                       PST.Terminal->NewSymbol
                                                         ->sy;
                                                       str.getText->NewString
                                                         ->sy.StringRef;
                                                       
                                                    #);
                                                  (* //ppast.AltTerm *)
                                                  
                                               // ppast.NonTerm then
                                                    (#
                                                       nonterminal:
                                                         ^ppast.NonTerm;
                                                       constant: ^const;
                                                       noOfNonTs: @integer;
                                                       
                                                    do
                                                    (* Get number of nonterminal *)
                                                       current[]->nonterminal[];
                                                       nonterminal.
                                                         getNonTerminalNo
                                                         ->constant[];
                                                       0->noOfNonTs;
                                                       scan: RHS.scan
                                                         (#
                                                            consElem:
                                                              ^gast.ConsElem;
                                                            tagName,nontName:
                                                              ^cons;
                                                            name: ^lexemText;
                                                            ident: ^text;
                                                            sy: @PST.Symbol;
                                                            
                                                         do
                                                            (if current.symbol
                                                             // gast.TaggedSyn
                                                             // gast.SynCat then
                                                             (* current is a nonterminal ... *)
                                                                (if
                                                                (noOfNonTs+1
                                                                   ->noOfNonTs)
                                                                 //
                                                                 constant.
                                                                   getValue then
                                                                 (* ... and has the right number *)
                                                                 (* Get name of nonterminal: *)
                                                                    current[]
                                                                      ->
                                                                        consElem[];
                                                                    (if
                                                                    current.
                                                                      symbol
                                                                     //
                                                                     gast.
                                                                       taggedSyn
                                                                     then
                                                                     (* This fixes TAGFIELD if present! DIRTY! *)
                                                                     (* .getTagName *)
                                                                        consElem
                                                                        .getSon1
                                                                          ->
                                                                            tagName[];
                                                                        tagName.
                                                                          getSon1
                                                                          ->
                                                                            name[];
                                                                        name.
                                                                          getText
                                                                          ->
                                                                            ident[];
                                                                        ': '
                                                                          ->
                                                                            ident
                                                                            .
                                                                              append;
                                                                        consElem
                                                                        .getSon2
                                                                          ->
                                                                            nontName[];
                                                                        nontName
                                                                        .getSon1
                                                                          ->
                                                                            name[];
                                                                        name.
                                                                          getText
                                                                          ->
                                                                            ident
                                                                            .
                                                                              append;
                                                                        
                                                                     //
                                                                     gast.synCat
                                                                     then
                                                                     (* .getSynName *)
                                                                        consElem
                                                                        .getSon1
                                                                          ->
                                                                            nontName[];
                                                                        nontName
                                                                        .getSon1
                                                                          ->
                                                                            name[];
                                                                        name.
                                                                          getText
                                                                          ->
                                                                            ident[];
                                                                        
                                                                    if);
                                                                    PST.
                                                                      NonTerminal
                                                                      ->
                                                                        NewSymbol
                                                                      ->sy;
                                                                    ident[]
                                                                      ->
                                                                        NewString
                                                                      ->
                                                                        sy.
                                                                          StringRef;
                                                                    constant.
                                                                      getValue
                                                                      ->
                                                                        sy.
                                                                          nontNo;
                                                                    leave scan
                                                                if)
                                                            if)
                                                         #)
                                                    #)
                                               // ppast.Block then
                                                    (#
                                                       blck: ^ppast.Block;
                                                       BT: ^ppast.BlockType;
                                                       sy: @PST.Symbol;
                                                       
                                                    do
                                                       current[]->blck[];
                                                       PST.Begin->NewSymbol->sy;
                                                       blck.getBlockType->BT[];
                                                       (if BT.symbol
                                                        // ppast.Consistent then
                                                           PST.Consistent
                                                             ->sy.BlockType;
                                                           
                                                        // ppast.InConsistent
                                                        then
                                                           PST.InConsistent
                                                             ->sy.BlockType;
                                                           
                                                       if);
                                                       blck.getItemList
                                                         ->&itemListScan;
                                                       PST.End->NewSymbol;
                                                       
                                                    #)
                                               // ppast.DefaultBreak then
                                                    (# sy: @PST.Symbol
                                                    do
                                                       PST.Break->NewSymbol->sy;
                                                       1->sy.size;
                                                       0->sy.offset;
                                                       
                                                    #)
                                               // ppast.AltBreak then
                                                    (#
                                                       ab: ^ppast.AltBreak;
                                                       s,i: ^Const;
                                                       sy: @PST.Symbol;
                                                       
                                                    do
                                                       current[]->ab[];
                                                       ab.getSpace->s[];
                                                       ab.getIndention->i[];
                                                       PST.Break->NewSymbol->sy;
                                                       s.getValue->sy.Size;
                                                       i.getValue->sy.Offset
                                                    #)
                                               // ppast.CommentPlace then
                                               (*(  Heavy code  :-)  *)
                                                  PST.Comment->NewSymbol; 
                                              if)
                                              (* current.symbol *)
                                           #)
                                     if);
                                     
                                  #);
                                RHS:
                                (* Referes either a ConsElemList, a ListOne or a ListZero (well?) *)
                                ^expanded (* was prod*) ;
                                myAst: ^AST;
                                
                             do (* ProcessProduction: *)
                                (if production.symbol
                                 // ppast.Constructor then
                                    (if (prod.symbol = gast.Constructor) or
                                    (prod.symbol = gast.alternation) or
                                    (prod.symbol = gast.Opt)
                                     // false then
                                        'addatt: '->screen.putText;
                                        GText[]->screen.putText;
                                        (failure,
                                         ': Constructor or Alternation expected in grammar')
                                          ->&stop
                                    if);
                                    (if prod.symbol
                                     // gast.Constructor // gast.alternation
                                     then
                                        prod (* QUA gast.Constructor *) .getSon2
                                        (* .getConsElemList *) ->myAST[];
                                        (if myAST.struc <= expanded##
                                         // true then myAST[]->RHS[]; 
                                         else
                                            'QUA ERROR 1 '->screen.puttext;
                                            myAST[]->getpatternname
                                              ->screen.putline;
                                            
                                        if);
                                        
                                     // gast.Opt then
                                     (* Can perhaps be removed? *)
                                     (* RHS of a Optional are the last sons of the *)
                                     (* corresponding production-node! Dirty! *)
                                        prod[]->myAST[];
                                        (if myAST.struc <= expanded##
                                         // true then myAST[]->RHS[]
                                         else
                                            'QUA ERROR 2 '->screen.puttext;
                                            myAST[]->getpatternname
                                              ->screen.putline;
                                            
                                        if);
                                        
                                    if);
                                    (PST.Constructor,productionNumber,
                                     emptyString[]->NewString,
                                     productionName.getText->NewString)
                                      ->NewProduction;
                                    production (* QUA ppast.Constructor *) .
                                      getSon2 (* .getStream *) ->itemListScan;
                                    
                                 // ppast.ListProd then
                                      (#
                                         bt: ^ppast.BlockType;
                                         sc: ^gast.SynCat;
                                         sn: ^gast.SynName;
                                         na: ^lexemText;
                                         listSpecification: ^ppast.ListSpec;
                                         sy: @PST.Symbol;
                                         
                                      do
                                         (if (prod.symbol = gast.ListOne) or
                                         (prod.symbol = gast.ListZero)
                                          // false then
                                             'addatt: '->screen.putText;
                                             GText[]->screen.putText;
                                             (failure,
                                              'List or Optional expected in grammar')
                                               ->&stop
                                         if);
                                         prod[]->myAST[];
                                         (if myAST.struc <= expanded##
                                          // true then myAST[]->RHS[]; 
                                          else
                                             'QUA ERROR 3 '->screen.puttext;
                                             myAST[]->getpatternname
                                               ->screen.putline;
                                             
                                         if);
                                         prod
                                         (* QUA gast.ListOne OR QUA gast.ListZero *)
                                         .getSon2 (* .getSynCat *) ->sc[];
                                         sc.getSynName->sn[];
                                         sn.getNameAppl->na[];
                                         (PST.ListProd,productionNumber,
                                          na.getText->NewString,
                                          productionName.getText->NewString)
                                           ->NewProduction;
                                         production (* QUA ppast.ListProd *) .
                                           getSon2 (* .getListSpec *)
                                           ->listSpecification[];
                                         listSpecification.getBeginning
                                           ->itemListScan;
                                         listSpecification.getBlockType->bt[];
                                         PST.lBegin->NewSymbol->sy;
                                         (if bt.symbol
                                          // ppast.Consistent then
                                             PST.Consistent->sy.BlockType; 
                                          // ppast.InConsistent then
                                             PST.InConsistent->sy.BlockType; 
                                         if);
                                         listSpecification.getSeparator
                                           ->itemListScan;
                                         PST.lEnd->NewSymbol;
                                         listSpecification.getEnding
                                           ->itemListScan
                                      #)
                                 else
                                    (failure,
                                     'addatt: Constructor or List expected')
                                      ->&stop
                                if);
                                (* production.symbol *)
                                (* Terminate production *)
                                PST.NULL->NewSymbol
                             #);
                           (* ProcessProduction: *)
                           leave FindProductionInGrammar
                       if)
                       (* PText -> GText.equal *)
                    #);
                  (if productionNumber
                   // 0 then
                      'addatt: '->screen.putText;
                      PText[]->screen.putText;
                      (failure,': Production not found in grammar')->&stop
                  if);
                  
               #);
             (* productionListP.scan *)
             newLine;
             (* Store pretty-print-specification in table *)
             '-pretty'->help[];
             ppFileExtension->help.append;
             help[]->(GrammarName.copy).Append->expandToFullPath->Store;
             (* Print Pretty-print-specification on screen (not needed) *)
             PrintPrettySpec: (* Yet Another Label! *) &
               (#
                  prod: @PST.Production;
                  str: @PST.String;
                  help: ^text;
                  f: @file;
                  
               do
                  '-pretty.lst'->(GrammarName.copy).Append->f.name;
                  f.openWrite;
                  f.newLine;
                  (for i: PST.maxProd repeat
                    i->prod.open;
                    (if (prod <> PST.NULL)
                     // true then
                        i
                          ->f.putInt
                            (# format::<  (#  do 5->width #) #);
                        ' : '->f.PutText;
                        '<'->f.Put;
                        prod.NameRef->str;
                        str.Read->f.putText;
                        '>'->f.Put;
                        ' ::= '->f.putText;
                        prod.StringRef->str;
                        str.Read->help[];
                        (if (help.length) > 0
                         // true then
                            '<'->f.Put; help[]->f.putText; '> '->f.PutText; 
                        if);
                        prod.Scan
                          (#  do f[]->thisSymbol.print; ' '->f.put;  #);
                        f.newLine
                    if);
                    
                  for);
                  f.newLine;
                  'Output on '->screen.putText;
                  f.name->screen.putLine;
                  
               #)
               (* PrintPrettySpec: *)
          #)
          (* PST.create *)
     #)
#)  

