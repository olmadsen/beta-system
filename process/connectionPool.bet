ORIGIN '~beta/process/v1.4.1/systemComm';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1994
 *       All rights reserved.
 *)

BODY 'private/connectionPoolBody';
INCLUDE '~beta/containers/v1.4/list';
INCLUDE '~beta/process/v1.4.1/commAddress';

--- systemLib:attributes ---


(* A connectionPool manages a number of client side
 * communication interfaces (e.g. active sockets), and
 * allows choosing which one of those to use for a
 * communication transfer by means of a
 * portableCommAddress.
 *
 * The communication interfaces are subject to concurrency
 * control, so they must be used in a 'take-it, use-it,
 * give-it-back' fashion. This is achieved by the pattern
 * 'communication' in 'connectionPool'.
 *)


(* The binary connection pool
 *
 * Instances of BinaryConnectionPool are used for managing
 * a number of binary socket connections. The user of a
 * BinaryConnectionPool gives a specification of the
 * receiver, the type of connection, the quality of
 * service etc. in a portableCommAddress to a (specialization
 * of) the control pattern 'communication'. This is used as
 * follows (bcPool is an instance of BinaryConnectionPool):
 *
 *   addr[] -> bcPool.communication
 *     (# /* Furtherbind error callbacks here */
 *     do
 *        /* Within this dopart: use 'sock' to communicate */
 *        /* When leaving, forget 'sock' (don`t bring out ref.s to it) */
 *     #);
 *
 * If you want to 'leave' the dopart of a specialization of
 * a 'communication', use
 *
 *   leaving(# do leave L #);
 *
 * in stead of
 *
 *   leave L;
 *
 * Otherwise some resources may be rendered inaccessible.
 *)
BinaryConnectionPool:
  (#
     (* patterns *)
     socketType:< activeBinarySocket;

     (* operations *)
     init:<
       (#
       do <<SLOT BCPoolInit:descriptor>>
       #);
     communication:
       (# addr: ^portableCommAddress;
          sock: ^socketType; 
          leaving: (# do <<SLOT BCPoolLeaving:descriptor>> #);

          (* hooks *)
          onNewConnection:<
            (* executed when a new connection has been created *)
            (# sock: ^socketType; (* The new connection *)
               context: ^object; (* NB: Should`ve been private *)
               actor: ^|system; (* process to associate with sock *)
            enter (sock[],context[])
            do INNER
            exit actor[]
            #);

          (* operations *)
          removeSock: (* remove sock from this pool *)
            (# dopart: @<<SLOT BCPoolCommunicationRemove:descriptor>>;
            do dopart
            #);

          (* exceptions *)
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then
                   (value,cleanup[])->this(BinaryConnectionPool).error->value;
               if);
            #);
          concrErrCB: hiErrCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then
                   (value,cleanup[])->error->value;
               if);
            #);
          addrHasUnknownType:< exception; (* Considered fatal, for now *)
          internalError:< concrErrCB(# do INNER #);
          unknownError:< concrErrCB(# do INNER #);
          accessError:< concrErrCB(# do INNER #);
          resourceError:< concrErrCB(# do INNER #);
          addressError:< concrErrCB(# do INNER #);
          refusedError:< concrErrCB(# do INNER #);
          intrError:< concrErrCB(# do INNER #);
          getHostError:< concrErrCB(# do INNER #);

          (* private *)
          priv: @<<SLOT BCPoolCommunicationPrivate:descriptor>>;

       enter addr[]
       do <<SLOT BCPoolCommunication:descriptor>>
       #);
     markAsDead:
       (# dopart: @<<SLOT BCPoolMarkAsDead:descriptor>>;
          sock: ^binarySocket;
       enter sock[]
       do dopart
       #);
     removeSomeConnection:
       (* Removes least recently used currently unused connection *)
       (# noConnectionsRemovable:< object;
          dopart: @<<SLOT BCPoolRemoveSomeConnection:descriptor>>;
       do dopart
       #);
     close:<
       (#
       do <<SLOT BCPoolClose:descriptor>>
       #);

     (* top level error callback *)
     error:< hiErrCB(# do INNER #);

     (* private *)
     private: @<<SLOT BCPoolPrivate:descriptor>>;
  #);
