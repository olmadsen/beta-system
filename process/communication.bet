ORIGIN '~beta/basiclib/v1.5/betaenv';
MDBODY mac     'private/communication_macbody'
       nti     'private/communication_ntbody'
       default 'private/communication_unixbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1992,93,94
 *       All rights reserved.
 *)
[[
--- include 'repstream/extendedRepstream'
--- lib:attributes ---

(* Communication concepts:
 * Pipe: Communication channel between two processes.
 *	 For pure standard communication, using standard input/output.
 *	 Both processes are unaware of the identity of their communication
 *	 partner.
 *
 * Socket: A stream, conceptually an endpoint of a two-way comminication line.
 *	   Two endpoints are connected by letting an ActiveSocket connect to a
 *	   PassiveSocket. The PassiveSocket just waits for the ActiveSocket  to
 *	   connect. After connection both sockets can read/write on their
 *	   streams.
 *
 * SocketGenerators are used in client/server type communication.
 * Sockets are divided into the categories stream socket and binary socket.
 *
 * Stream sockets:
 *
 * A stream socket is suitable for transferring data, which is readable for
 * human beings, like the data transferred in a UNIX 'talk' session, or like
 * the more formal communication between a mail program and an SMTP mail
 * server. A stream socket is a stream, so you may 'put', 'get' etc.
 * However, don't rely on this kind of socket when transferring data
 * which may contain zero-valued bytes, such as arbitrary binary data.
 *
 * Binary sockets:
 *
 * A binary socket is guaranteed to transfer any given block of
 * arbitrary bytes unmodified, but you must always specify the
 * length of the data block, both for sending and receiving. You may
 * 'readData' and 'writeData' on a binary socket, which constitutes
 * the lowest level interface.
 *
 * The operations 'getBlock' and 'putBlock' provide support for
 * a very simple, binary data transfer protocol. In this protocol,
 * all data is transferred in blocks with the following layout:
 *
 *      len      header   data
 *      |--------|--------|---------------------------------|
 *
 * The 'len' field is a four byte integer value, in big-endian byte order.
 * The 'header' field is a four byte big-endian integer value,
 * identifying the kind of data in the 'data' field, the purpose
 * of the block, or whatever. The 'data' field length is 4*'len'
 * bytes. The sender and the recipient must agree on the interpretation
 * of the 'header' and 'data' fields, which is left unspecified by
 * this protocol.
 *
 * The operations 'putRep' and 'getRep' are provided for transferring
 * data to and from a ExtendedRepstream object, using this protocol.
 * The usage of this level of functionality is recommended whenever
 * possible, as it encapsulates (and hides) references to raw memory
 * addresses.
 *
 * The 'Idle' patterns:
 *
 * Many operations on sockets have an 'Idle' virtual pattern.
 * It may be executed one or more times if the operation cannot
 * finish right away. This is not guaranteed to happen, so don't
 * rely on 'Idle' being executed even once. Furtherbind this virtual
 * to keep your application "alive" during a (possibly) lenghty
 * operation. Don't execute operations on this(Socket) in an
 * enclosed 'Idle'. Don't stop the operation from within an 'Idle' -
 * the operation is unfinished; you may for instance have received
 * half a block, which makes the stop a serious break wrt the protocol;
 * use 'nonBlockingScope' and 'Blocking' for this purpose.
 *
 * The 'nonBlockingScope' and 'Blocking' patterns:
 *
 * The 'nonBlockingScope' pattern is used for specifying non-blocking
 * communication. This means that operations which cannot begin
 * right away are discontinued. An example is: We try to read from a
 * socket, but no data at all is available to read. If any irreversible
 * actions have been taken in an operation (e.g. reading a few bytes),
 * it will not be interrupted by the 'nonBlockingScope' mechanism. This
 * means it is always safe to interrupt an operation by enclosing it
 * in a 'nonBlockingScope', and to retry it later.
 *
 * With each 'Idle' pattern comes a 'Blocking' virtual. This is executed
 * iff the current operation is blocking, i.e. if nothing can be done right
 * away. You may furtherbind this virtual to take some action in response 
 * to the operation being blocked. If the operation is enclosed in a 
 * 'nonBlockingScope', your 'Blocking'-code gets executed immediately 
 * before the operation is interrupted. If you don't want to interrupt
 * the operation, execute 'continue' in the furtherbinding of 'Blocking'. 
 *
 * USAGE: Normally the communication will be blocking. But if you enclose
 * an operation in a specialization of 'nonBlockingScope', we 'leave' the
 * 'nonBlockingScope' at the first blocking condition. PLEASE NOTE: it is 
 * unsafe to execute a 'leave' statement which leaves a 'nonBlockingScope'.
 * If you need to leave it, execute 'leaveNBScope'. The normal usage with 
 * and without 'nonBlockingScope' looks like this:
 *
 *   /* BLOCKING STYLE */
 *   myStreamSocket.getLine  /* waits until data has arrived */
 *    -> reactOnInput;       /* always executed */
 *   reactSomeMore;          /* always executed */
 *   doOtherThings;
 *
 *   /* NONBLOCKING STYLE */
 *   myStreamSocket.nonBlockingScope
 *      (#
 *      do
 *         myStreamSocket.getLine  /* if no data: leave scope at once */
 *          -> reactOnInput;       /* only executed if data available */
 *         reactSomeMore;          /* only executed if data available */
 *      #);
 *   doOtherThings;
 *
 * With some patterns, it is not possible to have a virtual 'Blocking' or
 * 'Idle' pattern. This is because an enter parameter for the operation
 * is supposedly the address of a beta object. Having taken this, it is 
 * unsafe to create objects during the execution of the operation. An 
 * example is 'BinarySocket.writeData'. However, enclosing such operations 
 * in a 'nonBlockingScope' does cause the operation to behave in a 
 * non-blocking manner.
 *)

waitForIO: 
  (* Make the process sleep until input/output is available, 
   * but at most maxWait seconds. If zero is entered (or the enter 
   * part isn't evaluated), wait for I/O without timeout.
   *)
  (# maxWait: @integer;
  enter maxWait
  do <<SLOT waitForIO:descriptor>> 
  #);

assignGuard: (# assigned: @Boolean do true -> assigned #);

propagateException: (# msg: ^Text enter msg[] do INNER #);

pipe:
  (* The pipe is a composition of two interconnected one way streams.
   * What is written on 'writeEnd' can subsequently be read
   * from 'readEnd'.
   *)
  (#
     (* operations *)
     init:<
       (# error:< propagateException(# do INNER; msg -> pipeError #);
       do <<SLOT PipeInit:descriptor>>;
       #);

     (* exceptions *)
     pipeException: Exception
       (#
       enter msg
       do (if msg.empty//false then msg.newline if);
          INNER;
       #);
     pipeError:< PipeException;

     (* attributes *)
     readEnd: ^Stream;
     writeEnd: ^Stream;

     (* private *)
     private: @<<SLOT PipePrivate:descriptor>>;
  #); (* pipe *)

StreamSocket: Stream
  (#
     (* basics *)
     withPE:
       (# error:< propagateException(# do INNER; msg->otherError #);
       do INNER
       #);
     BasicBlocking:
       (# continue: (# do true->doContinue #);
          doContinue: @boolean;
          doIdle:< Object;
       do
          INNER;
          (if doContinue//false then leaveNBScope if);
          doIdle;
       #);
     Idle:< Object; (* every local 'Idle' executes this global one *)

     (* operations *)
     open: withPE
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketOpen:descriptor>>
       #);
     close:< withPE
       (#
       do <<SLOT SSocketClose:descriptor>>
       #);
     flush:< withPE
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketFlush:descriptor>>
       #);
     put::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketPut:descriptor>>
       #);
     get::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketGet:descriptor>>
       #);
     peek::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketPeek:descriptor>>
       #);
     eos::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketEos:descriptor>>
       #);
     putText::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketPutText:descriptor>>
       #);
     getLine::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketGetLine:descriptor>>
       #);
     getAtom::<
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketGetAtom:descriptor>>
       #);

     (* nonBlockingScope support *)
     (* PLEASE NOTE: don't 'leave' a 'nonBlockingScope'. Use 'leaveNBScope' *)
     nonBlockingScope: (# do <<SLOT SSocketNonBlockingScope:descriptor>> #);
     leaveNBScope: (# do <<SLOT SSocketLeaveNBScope:descriptor>> #);
     
     (* exceptions *)
     sSocketException: streamException
       (#
       enter msg
       do (if msg.empty//false then msg.newline if); INNER
       #);
     otherError::< sSocketException;

     (* attributes *)
     port: @assignGuard(# rep: @integer enter rep exit rep #);

     (* private *)
     private: @<<SLOT SSocketPrivate:descriptor>>;
  #); (* StreamSocket *)

BinarySocket:
  (#
     (* basics *)
     withPE:
       (# error:< propagateException(# do INNER; msg->otherError #);
       do INNER
       #);
     withIdle: withPE
       (# Idle:< (# do INNER; this(BinarySocket).Idle #);
          Blocking:<
            (# continue: (# do true->doContinue #);
               doContinue: @boolean;
            do
               INNER;
               (if doContinue//false then leaveNBScope if);
               Idle;
            #);
       do INNER
       #);
     rawIO: withPE
       (* Abstract pattern. Read/write exactly 'length' bytes of
        * arbitrary data to/from the memory location 'address'.
        * Non-abstract SPECIALIZATIONS MUST BE STATIC items to
        * prevent garbage collection between calculation of 'address'
        * and reference through 'address'.
        *)
       (# address,length: @integer;
       enter (address,length)
       do INNER
       #);
     repIO: withIdle
       (* Abstract pattern. Read/write a block to/from 'rep',
        * returning/using 'header'. The length of the block is
        * stored in/retrived from 'rep.end'.
        *)
       (# rep: ^ExtendedRepstream;
          header: @integer;
       enter rep[]
       do INNER
       #);
     Idle:< Object; (* every local 'Idle' executes this global one *)

     (* operations *)
     open: withIdle(# do <<SLOT BSocketOpen:descriptor>> #);
     close:< withIdle(# do <<SLOT BSocketClose:descriptor>> #);
     writeData: @rawIO(# do <<SLOT BSocketWrite:descriptor>> #);
     readData: @rawIO(# do <<SLOT BSocketRead:descriptor>> #);
     endOfData: 
       (* Returns true iff no data is immediately available for reading *)
       (# value: @boolean;
       do <<SLOT BSocketEndOfData:descriptor>>
       exit value
       #);
     putBlock: @withPE
       (# length,header,address: @integer;
       enter (length,header,address)
       do <<SLOT BSocketPutBlock:descriptor>>
       #);
     getBlock: @withPE
       (* The 'maxlen' enter parameter specifies the maximum allowed
        * length of the 'data' field in the block. If the block is
        * bigger than that, the rest of 'data' is discarded. The
        * 'length' exit parameter always specifies the block length,
        * so such an overflow has occurred iff maxlen<length. If this
        * behaviour is not acceptable, use 'getBlockLen' and
        * 'getBlockRest'.
        *)
       (# address,maxlen,length,header: @integer;
       enter (address,maxlen)
       do <<SLOT BSocketGetBlock:descriptor>>
       exit (length,header)
       #);
     getBlockLen: withIdle
       (* Exits the length of the next block to receive. Make sure
        * the necessary space is available, and then use 'getBlockRest'
        * to read the block.
        *)
       (# length: @integer;
       do <<SLOT BSocketGetBlockLen:descriptor>>
       exit length
       #);
     getBlockRest: @withPE
       (* Reads the next block. IMPORTANT: assumes the
        * length has been read with 'getBlockLen' as the last
        * operation on this(BinarySocket).
        *)
       (# address,header: @integer;
       enter address
       do <<SLOT BSocketGetBlockRest:descriptor>>
       exit header
       #);

     putRep: repIO
       (* Read to ExtendedRepstream using 
        * above mentioned binary protocol 
        *)
       (#
       enter header
       do <<SLOT BSocketPutRep:descriptor>>
       #);
     getRep: repIO
       (* Write ExtendedRepstream contents
        * using above mentioned binary protocol 
        *)
       (#
       do <<SLOT BSocketGetRep:descriptor>>
       exit header
       #);

     (* nonBlockingScope support *)
     (* PLEASE NOTE: don't 'leave' a 'nonBlockingScope'. Use 'leaveNBScope'. *)
     nonBlockingScope: (# do <<SLOT BSocketNonBlockingScope:descriptor>> #);
     leaveNBScope: (# do <<SLOT BSocketLeaveNBScope:descriptor>> #);

     (* exceptions *)
     bSocketException: Exception
       (#
       enter msg
       do (if msg.empty//false then msg.newline if); INNER
       #);
     otherError:< bSocketException;

     (* attributes *)
     port: @assignGuard(# rep: @integer enter rep exit rep #);

     (* private *)
     private: @<<SLOT BSocketPrivate:descriptor>>;
  #); (* BinarySocket *)

ActiveStreamSocket: StreamSocket
  (* Initiator of socket communication. Initialize 'host' and 'port'
   * and 'connect' to a passive socket to establish communication.
   *)
  (#
     (* operations *)
     connect: open
       (# enter (host,port)
       do <<SLOT ActiveSSocketConnect:descriptor>>;
       #);

     (* attributes *)
     host: @assignGuard(# t: @text; enter t exit t #);
  #); (* ActiveStreamSocket *)

ActiveBinarySocket: BinarySocket
  (* Initiator of socket communication. Initialize 'host' and 'port'
   * and 'connect' to a passive socket to establish communication.
   *)
  (#
     (* operations *)
     connect: open
       (# enter (host,port)
       do <<SLOT ActiveBSocketConnect:descriptor>>;
       #);

     (* attributes *)
     host: @assignGuard(# t: @text; enter t exit t #);
  #); (* ActiveBinarySocket *)

PassiveStreamSocket: StreamSocket
  (* 'bind' to port and 'awaitConnection'. Other executions can then
   * connect to the port and communicate through the passive socket.
   * Use a 'nonBlockingScope' to interrupt 'awaitConnection', if no 
   * connections are being requested.
   *)
  (#
     (* operations *)
     bind:
       (# error:< propagateException(# do INNER; msg->otherError #);
       enter port
       do <<SLOT PassiveSSocketBind:descriptor>>;
       #);
     awaitConnection: open(# do <<SLOT PassiveSSocketAwait:descriptor>>; #);
     close::< (# do <<SLOT PassiveSSocketClose:descriptor>> #);

     (* private *)
     private2: @<<SLOT PassiveSSocketPrivate:descriptor>>;
  #); (* PassiveStreamSocket *)

PassiveBinarySocket: BinarySocket
  (* 'bind' to port and 'awaitConnection'. Other executions can then
   * connect to the port and communicate through the passive socket.
   * Use a 'nonBlockingScope' to interrupt 'awaitConnection', if no 
   * connections are being requested.
   *)
  (#
     (* operations *)
     bind:
       (# error:< propagateException(# do INNER; msg->otherError #);
       enter port
       do <<SLOT PassiveBSocketBind:descriptor>>;
       #);
     awaitConnection: open(# do <<SLOT PassiveBSocketAwait:descriptor>>; #);
     close::< (# do <<SLOT PassiveBSocketClose:descriptor>> #);

     (* private *)
     private2: @<<SLOT PassiveBSocketPrivate:descriptor>>;
  #); (* PassiveBinarySocket *)

SocketGenerator:
  (* Supports creating multiple connections on a single port number;
   * typically used in an application acting as a server for a number
   * of clients. Do 'portNumber -> bind' and use "get???Connection"
   * to establish connections to the clients. Use a 'nonBlockingScope'
   * to avoid waiting if no clients are requesting a connection.
   *
   * "get???Connection" exits a reference to a "???Socket" associated
   * with the new connection. You may use this like:
   * 
   *   mySocketGenerator.getStreamConnection -> aStreamSocketRef[];
   * 
   * If you want to work with a specialization of the basic socket patterns, 
   * furtherbind the virtuals 'streamSocketType' and/or 'binarySocketType'.
   *)
  (#
     (* basics *)
     streamSocketType:< streamSocket;
     binarySocketType:< binarySocket;
     withIdleAndPE:
       (# Idle:< (# do INNER; this(socketGenerator).Idle #);
          Blocking:<
            (# continue: (# do true->doContinue #);
               doContinue: @boolean;
            do
               INNER;
               (if doContinue//false then leaveNBScope if);
               Idle;
            #);
          error:< propagateException(# do INNER; msg->otherError #);
       do INNER
       #);
     Idle:< Object; (* every local 'Idle' executes this global one *)

     (* operations *)
     bind: withIdleAndPE
       (#
       enter port
       do <<SLOT SocketGeneratorBind:descriptor>>
       #);
     close: withIdleAndPE
       (#
       do <<SLOT SocketGeneratorClose:descriptor>>
       #);
     getStreamConnection: withIdleAndPE
       (# sock: ^streamSocketType;
       do <<SLOT SocketGeneratorGetStream:descriptor>>;
       exit sock[]
       #);
     getBinaryConnection: withIdleAndPE
       (# sock: ^binarySocketType;
       do <<SLOT SocketGeneratorGetBinary:descriptor>>;
       exit sock[]
       #);

     (* nonBlockingScope support *)
     (* PLEASE NOTE: don't 'leave' a 'nonBlockingScope'. Use 'leaveNBScope'. *)
     nonBlockingScope: (# do <<SLOT SocketGeneratorNBScope:descriptor>> #);
     leaveNBScope: (# do <<SLOT SocketGeneratorLeaveNBScope:descriptor>> #);

     (* exceptions *)
     socketGeneratorException: Exception
       (#
       enter msg
       do (if msg.empty//false then msg.newline if); INNER
       #);
     otherError:< socketGeneratorException;

     (* attributes *)
     port: @assignGuard(# rep: @integer enter rep exit rep #);

     (* private *)
     private: @<<SLOT SocketGeneratorPrivate:descriptor>>;
  #); (* SocketGenerator *)

---]]
