(* Simple test of subprocess IO redirection.  Works on both windows and Unix *)
ORIGIN '~beta/basiclib/systemenv';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/process/commpipe';
INCLUDE '~beta/process/processmanager';
--- program:descriptor ---
systemEnv
(# 
   execReadWriteInit:
     (# name, args: ^text;
        child: @process;
        openRedirection:< Object;
        closeRedirection:< Object;
        
     enter (name[], args[])
     do
        (* initialize (an object to manage) the child process *)
        name[] -> child.init;
        (if args[]<> none then args[] -> child.argument.append if);
        &openRedirection;
        (* run the child process *)
        child.start;
        INNER;
        &closeRedirection;
        (* Await exit of child.
         * Otherwise it will turn into a zombie.
         *)
        child.awaitStopped;
     #);
   
   execReadAndPipeFileIn: execReadWriteInit
     (#
	output: ^stream;
        outchannel: @pipe;
	filename: ^Text;
	infile: @File;
        openRedirection::<
          (# 
          do (* setup communication channel to retrieve output from child *)
	     (* pipe a file into the standard input of the child *)
             outchannel.init;
             outchannel.writeEnd[] -> child.redirectToChannel;
             outchannel.readEnd[] -> output[];
	     filename[] -> infile.name;
	     infile.openRead;
	     infile[] -> child.redirectFromFile;
             INNER;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             outchannel.readEnd.close;
          #);
     enter filename[]
     do INNER;
     #);

   execRead: execReadWriteInit
     (#
	output: ^stream;
        outchannel: @pipe;
        openRedirection::<
          (# 
          do (* setup communication channel to retrieve output from child *)
             outchannel.init;
             outchannel.writeEnd[] -> child.redirectToChannel;
             outchannel.readEnd[] -> output[];
             INNER;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             outchannel.readEnd.close;
          #);
     do INNER;
     #);

   execReadStderr: execReadWriteInit
     (#
	output: ^stream;
        outchannel: @pipe;
        openRedirection::<
          (# 
          do (* setup communication channel to retrieve stderr from child *)
             outchannel.init;
             outchannel.writeEnd[] -> child.redirectErrToChannel;
             outchannel.readEnd[] -> output[];
             INNER;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             outchannel.readEnd.close;
          #);
     do INNER;
     #);
   
   execReadBoth: execReadWriteInit
     (#
	output: ^stream;
        outchannel: @pipe;
        openRedirection::<
          (# 
          do (* setup communication channel to retrieve output and stderr from child *)
             outchannel.init;
             outchannel.writeEnd[] -> child.redirectToChannel;
             outchannel.writeEnd[] -> child.redirectErrToChannel;
             outchannel.readEnd[] -> output[];
             INNER;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             outchannel.readEnd.close;
          #);
     do INNER;
     #);
   
   execReadWrite: execRead
     (# input: ^stream;
        inchannel: @pipe;
        openRedirection::<
          (# 
          do (* setup communication channel to give input to child *)
             inchannel.init;
             inchannel.readEnd[] -> child.redirectFromChannel;
             inchannel.writeEnd[] -> input[];
             INNER;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             inchannel.writeEnd.close;
          #);

     do INNER;
     #);

   execWrite: execReadWriteInit
     (# input: ^stream;
        inchannel: @pipe;
        openRedirection::<
          (# 
          do (* setup communication channel to give input to child *)
             inchannel.init;
             inchannel.readEnd[] -> child.redirectFromChannel;
             inchannel.writeEnd[] -> input[];
             INNER;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             inchannel.close;
          #);

     do INNER;
     #);

   execWriteFile: execReadWriteInit
     (# outchannel: @File;
	filename: ^Text;
        openRedirection::<
          (# 
          do (* setup communication channel to give input to child *)
             filename[] -> outchannel.name;
             outchannel.openWrite;
	     outchannel[] -> child.redirectToFile;
          #);
        closeRedirection::<
          (# 
          do (* Close channel *)
             INNER;
             outchannel.close;
          #);

	enter filename[]
     do INNER;
     #);
   
   execReadText:execRead
     (# T: ^Text;
	Temp: ^Text;
     do &Text[]->T[];
        loop:
          (# 
          do 
	     (* 'Checking for eos' -> putline; *)
             (if not output.eos then
                 output.getline -> Temp[];
		 Temp[] -> T.putLine;
                 restart loop;
             if);
	     (* 'Got eos' -> putline; *)
          #);
     exit T[]
     #);

   execReadTextAndPipeFileIn:execReadAndPipeFileIn
     (# T: ^Text;
	Temp: ^Text;
     do &Text[]->T[];
        loop:
          (# 
          do 
	     (* 'Checking for eos' -> putline; *)
             (if not output.eos then
                 output.getline -> Temp[];
		 Temp[] -> T.putLine;
                 restart loop;
             if);
	     (* 'Got eos' -> putline; *)
          #);
     exit T[]
     #);

   execReadErrText:execReadStderr
     (# T: ^Text;
	Temp: ^Text;
     do &Text[]->T[];
        loop:
          (# 
          do 
	     (* 'Checking for eos' -> putline; *)
             (if not output.eos then
                 output.getline -> Temp[];
		 Temp[] -> T.putLine;
                 restart loop;
             if);
	     (* 'Got eos' -> putline; *)
          #);
     exit T[]
     #);
   
   execReadBothText:execReadBoth
     (# T: ^Text;
	Temp: ^Text;
     do &Text[]->T[];
        loop:
          (# 
          do 
	     (* 'Checking for eos' -> putline; *)
             (if not output.eos then
                 output.getline -> Temp[];
		 Temp[] -> T.putLine;
                 restart loop;
             if);
	     (* 'Got eos' -> putline; *)
          #);
     exit T[]
     #);
   
   execReadWriteText:ExecReadWrite
     (# T: ^Text;
     enter T[]
     do T[]->input.putText;
	'Closing write end' -> screen.putLine;
        inchannel.writeEnd.close;
        &Text[]->T[];
        loop:
          (# 
          do (if not output.eos then
                 output.getline -> T.putLine;
                 restart loop
             if)
          #);
     exit T[]
     #);
   
   first, other: ^Text;

   (*
    * The examples here fail rather inelegantly if the programs called
    * don't exist
    *)
   
do 'This will not work if you do not have . in your path!' -> screen.putline;
   'output of "slowwriter":'->screen.putLine;
   ('slowwriter', '-') -> execReadText -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;

   'output of "slowwriter -s":'->screen.putLine;
   ('slowwriter', '-s') -> execReadText -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;
   
   'output of "slowwriter -n":'->screen.putLine;
   ('slowwriter', '-n') -> execReadText -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;

   'output of "slowwriter -e" goes direct to screen:'->screen.putLine;
   ('slowwriter', '-e') -> execReadText -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;

   'output of "slowwriter -e" lets pick it up:'->screen.putLine;
   ('slowwriter', '-e') -> execReadErrText -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;

   'output of "slowwriter -b" lets pick up both stdout and stderr:'->screen.putLine;
   ('slowwriter', '-b') -> execReadBothText -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;

   'Now lets let slowwriter write to a file:'->screen.putline;
   ('slowwriter', '-', 'slowwriter.out') -> execWriteFile;

   'Now lets read that back through reader:'->screen.putline;
   ('reader', '-', 'slowwriter.out') -> execReadTextAndPipeFileIn -> first[];
   'heres the output' -> putline;
   first[]->screen.putText;
   'there it was' -> putline;
   
   'Writing this output to reader, NOT reading the output:'->screen.putLine;
   ('reader', '-') -> execWrite
   (# 
   do first[]->input.putText;
   #);

   'Writing this output to reader -w, NOT reading the output:'->screen.putLine;
   ('reader', '-w') -> execWrite
   (# 
   do first[]->input.putText;
   #);

   'Writing this output to reader, reading the output:'->screen.putLine;
   ('reader', '-', first[]) -> execReadWriteText -> screen.putLine;
   'done.'->screen.putLine;
   
   screen.newLine;
#)
