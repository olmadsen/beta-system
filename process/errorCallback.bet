ORIGIN '~beta/basiclib/v1.5/betaenv';
BODY 'private/errorCallbackBody';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1994
 *       All rights reserved.
 *)

[[
--- include 'commError'

(* Basic Exception Handling
 * ========================
 *
 * Whenever an error condition is detected on a socket, a
 * corresponding virtual pattern is instantiated and executed.
 * These patterns are specializations of 'errCB', as
 * declared below. Such virtual patterns are hereafter denoted
 * error callback patterns. To catch and treat an error,
 * furtherbind the corresponding error callback.
 *
 * If an error callback is not furtherbound and the
 * corresponding error occurs, an exception is executed
 * and the program terminates. If the error callback
 * is furtherbound, the following holds:
 *
 *   - if 'abort' is executed in the furtherbinding dopart,
 * the operation (but not the program) is aborted. You may
 * execute 'leave' within a specialization of abort. Don't
 * 'leave' an error callback from any other point, as this
 * may put the object or the process into an unstable
 * state. If you 'abort' but do not 'leave', the operation
 * aborts, but control flow is like when the operation succeeds;
 * in this case, any exited values are dummy values, reflecting
 * that the operation failed. Don't use them!
 *
 *   - if 'continue' is executed in the furtherbinding dopart,
 * there will be an attempt to recover and finish the operation,
 * after the execution of the error callback terminates.
 *
 *   - if 'fatal' is executed in the furtherbinding dopart,
 * an exception will be executed and the program terminated,
 * before the execution of the error callback returns. (This
 * is also the default, but with hierarchical error callbacks,
 * you may need 'fatal' to undo a 'continue' at a higher level).
 *
 * In case it happens more than once that an operation
 * from the set {'abort','continue','fatal'} is executed,
 * the one executed as the last takes precedence.
 *
 * Propagating exceptions
 * ======================
 *
 * The error callback patterns are present at three different
 * levels: Concrete error callbacks, operation level error
 * callbacks, and socket level error callbacks.
 *
 * The concrete error callbacks provide the greatest level of
 * detail: their names indicate the kind of error condition
 * detected. This makes it possible to treat different errors
 * differently.
 *
 * The operation level error callback is executed whenever
 * an error condition is detected during the execution of
 * that operation. In a furtherbinding of this kind of error
 * callback, you can adjust the default action for all the
 * concrete error callbacks in this operation.
 *
 * The single socket level error callback is executed whenever
 * any operation detects any error condition. In a furtherbinding
 * of this error callback, you can adjust the default action
 * for all operation level error callbacks.
 *
 * The means for adjusting the behaviour is in all cases to
 * execute 'abort' (probably "abort(# leave L #)") 'continue',
 * or 'fatal', and the semantics of these imperatives are
 * like in concrete error callbacks.
 *
 * Error callback furtherbindings normally take precedence
 * like this: concrete > operation level > socket level.
 * This means that the higher level specifies a default, and
 * the more concrete level overrides this default if it
 * executes 'continue', 'abort', or 'fatal'. This doesn't
 * hold, however, if you "abort(# do leave L #)" at a higher
 * level: In this case, the more concrete levels will never
 * get a chance to undo the 'leave'.
 *)
--- lib:attributes ---


errCB_initialValue: (# exit -1 #);
errCB_abortProgram: (# exit 0 #);
errCB_abortOperation: (# exit 1 #);
errCB_continueOperation: (# exit 2 #);


errCB: IntegerValue
  (# abort: (# do <<SLOT errCBAbort:descriptor>> #);
     continue: (# do <<SLOT errCBContinue:descriptor>> #);
     fatal: (# do <<SLOT errCBFatal:descriptor>> #);
     addMsg: (# t: ^text enter t[] <<SLOT errCBAddMsg:dopart>> #);
     exceptionType:< exception;
     cleanup: ^object;
     private: @<<SLOT errCBPrivate:descriptor>>;
  enter cleanup[]
  do <<SLOT errCB:descriptor>>
  #);

hiErrCB: IntegerObject
  (# abort: (# do <<SLOT hiErrCBAbort:descriptor>> #);
     continue: (# do <<SLOT hiErrCBContinue:descriptor>> #);
     fatal: (# do <<SLOT hiErrCBFatal:descriptor>> #);
     cleanup: ^object;
  enter cleanup[]
  do INNER
  #);

---]]
