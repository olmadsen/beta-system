ORIGIN '~beta/basiclib/basicsystemenv';
LIB_DEF 'processstream' '../lib';

(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

INCLUDE 'basicsocket';
BODY 'private/streamsocketbody';

--- systemlib:attributes ---
StreamSocket: Stream
  (# <<SLOT streamsocketlib:attributes>>;
     
     theSocket: @basicSocket  
       (* The socket communication goes through *)
       (# error::
            (# 
            do (if value=errCB_initialValue then
                   (* Error not handled yet *)
                   (value,cleanup[])->this(StreamSocket).error->value;
                   (if value=errCB_initialValue then
                       this(StreamSocket).otherError;
                       (* If otherError did not terminate the
                        * program, let it continue here as well
                        *)
                       errCB_continueOperation->value;
                   if)
               if)
            #)
       #);

     (* basics *)
     timeoutValue:< 
       (* Length in seconds.  
        * All operations that do not enter a timeout
        * themselves uses this timeout.
        *)
       integerValue(# do waitForever->value; INNER #);
     
     (* operations *)
     sameConnection: booleanValue
       (* do 'this' and 'other' wrap 
        * the same OS level connection? 
        *)
       (# other: ^StreamSocket;
       enter other[]
       <<SLOT SSocketSameConnection:dopart>>
       #);
     
     flush: theSocket.withIdle
       (# 
       <<SLOT SSocketFlush:dopart>> 
       #);
     
     close: theSocket.withPE
       (* Close socket completely. Any further operations are
        * disallowed and the other end gets EOS if it tries *)
       (# <<SLOT SSocketClose:dopart>> #);

     closeRead: theSocket.closeRead
     (* Close socket partially. closeRead makes further reads
      * at this end of the socket and further writes at
      * the other end fail with EOS. *)
       (# #);
     
     closeWrite: theSocket.closeWrite
     (* Close socket partially. closeWrite makes further writes
      * at this end of the socket and further reads at
      * the other end fail with EOS. *)
       (# #);
     
     put::
       (# Idle:< (# do INNER #);
          Blocking:< (#  do INNER #);
       <<SLOT SSocketPut:dopart>>
       #);
     
     puttext::
       (# Idle:< (# do INNER #);
          Blocking:< (#  do INNER #);
       <<SLOT SSocketPutText:dopart>>
       #);
     
     get::
       (# theIdle: @theSocket.withIdle
            (# connBrokenError::
                 (# do errCB_abortOperation -> value;
                    this(Stream).EOSerror;
                 #)
            #);
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
       <<SLOT SSocketGet:dopart>>
       #);
     
     peek::
       (# theIdle: @theSocket.withIdle
            (# connBrokenError::
                 (# do errCB_abortOperation -> value;
                    this(Stream).EOSerror;
                 #)
            #);
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
       <<SLOT SSocketPeek:dopart>>
       #);
     
     getline::
       (# priv: @<<SLOT SSocketGetLinePriv:descriptor>>;
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
          timedOut: @Boolean;
       do priv;
       #);
     
     getAtom::
       (# ch: @Char;
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
       <<SLOT SSocketGetAtom:dopart>>
       #);
     
     eos::
       (# priv: @<<SLOT SSocketEos:descriptor>>
       do priv;
       #);
     
     getPos::
       (# 
       do -1 -> value;
       #);
     
     setPos::
       (# 
       do this(Stream).otherError;
       #);
     
     init:< (# do theSocket.init; INNER #);
     forceTimeout:< (# do theSocket.forceTimeout #);
     usageTimestamp:< integerValue
       (# do theSocket.usageTimestamp -> value #);

     (* nonBlockingScope support *)
     (* Note: don`t 'leave' a 'nonBlockingScope'. 
      * Use 'leaveNBScope' 
      *)
     nonBlockingScope: theSocket.nonBlockingScope(# do INNER #);
     leaveNBScope: theSocket.nonBlockingScope(# do INNER #);

     connect: theSocket.connect(# do INNER #);

     Idle:< Object; (* every local 'Idle' executes this global one *)
     
     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     (* attributes *)
     host: (# enter theSocket.host exit theSocket.host #);
     port: (# enter theSocket.port exit theSocket.port #);
     inetAddr: (# enter theSocket.inetAddr exit theSocket.inetAddr #); 

     (* private *)
     private: @<<SLOT SSocketPrivate:descriptor>>;
  #); (* StreamSocket *)


