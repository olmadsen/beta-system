ORIGIN '~beta/basiclib/v1.6/basicsystemenv';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1995
 *       All rights reserved.
 *)

INCLUDE 'basicsocket';
BODY 'private/streamsocketbody';

--- systemlib:attributes ---

StreamSocket: Stream
  (#
     <<SLOT streamsocketlib:attributes>>;
     
     theSocket: @basicSocket;  (* The socket communication goes through *)

     (* basics *)
     Idle:< Object; (* every local 'Idle' executes this global one *)
     
     timeoutValue:< (* length in seconds.  
                     * All operations that do not enter a timeout
                     * themselves uses this timeout.
                     *)
       integerValue(# do waitForever->value; INNER #);
     
  
     (* operations *)
     sameConnection: booleanValue
       (* do 'this' and 'other' wrap the same OS level connection? *)
       (# other: ^StreamSocket;
       enter other[]
       <<SLOT SSocketSameConnection:dopart>>
       #);
     close:< theSocket.withPE
       (#
       <<SLOT SSocketClose:dopart>>
       #);
     flush: theSocket.withIdle
       (# 
       <<SLOT SSocketFlush:dopart>> 
       #);
     put::
       (# Idle:< (# do INNER #);
          Blocking:< (#  do INNER #);
       <<SLOT SSocketPut:dopart>>
       #);
     puttext::
       (# Idle:< (# do INNER #);
          Blocking:< (#  do INNER #);
       <<SLOT SSocketPutText:dopart>>
       #);
     get::
       (# theIdle: @theSocket.withIdle
            (# connBrokenError::
                 (# do errCB_abortOperation -> value;
                    this(Stream).EOSerror;
                 #)
            #);
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
       <<SLOT SSocketGet:dopart>>
       #);
     peek::
       (# theIdle: @theSocket.withIdle
            (# connBrokenError::
                 (# do errCB_abortOperation -> value;
                    this(Stream).EOSerror;
                 #)
            #);
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
       <<SLOT SSocketPeek:dopart>>
       #);
     getline::
       (# priv: @<<SLOT SSocketGetLinePriv:descriptor>>;
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
          timedOut: @Boolean;
       do priv;
       #);
     getAtom::
       (# ch: @Char;
          Idle:< (# do INNER #);
          Blocking:< (# do INNER #);
       <<SLOT SSocketGetAtom:dopart>>
       #);
     eos::
       (# priv: @<<SLOT SSocketEos:descriptor>>
       do priv;
       #);
     getPos::
       (# 
       do -1 -> value;
       #);
     setPos::
       (# 
       do this(Stream).otherError;
       #);
     
     init:< (# do theSocket.init; INNER #);
     connect: theSocket.connect(# do INNER #);
     forceTimeout:< (# do theSocket.forceTimeout #);
     usageTimestamp:< integerValue(# do theSocket.usageTimestamp -> value #);

     (* nonBlockingScope support *)
     (* PLEASE NOTE: don`t 'leave' a 'nonBlockingScope'. Use 'leaveNBScope' *)
     nonBlockingScope: theSocket.nonBlockingScope(# do INNER #);
     leaveNBScope: theSocket.nonBlockingScope(# do INNER #);

     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     (* attributes *)
     host: (# enter theSocket.host exit theSocket.host #);
     port: (# enter theSocket.port exit theSocket.port #);
     inetAddr: (# enter theSocket.inetAddr exit theSocket.inetAddr #); 

     (* private *)
     private: @<<SLOT SSocketPrivate:descriptor>>;
  #); (* StreamSocket *)


