ORIGIN '~beta/basiclib/v1.5/betaenv';
OBJFILE nti     '$/sockets.obj'
        default '$/sockets.o';
OBJFILE nti     '$/sockSignals.obj'
        default '$/sockSignals.o';
MAKE    nti     'external/sockets_nti.make'
        default 'external/sockets.make';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994
 *       All rights reserved.
 *)
[[
--- lib:attributes ---

initSockets: external
  (#
  do 'initSockets' -> callC
  #);

Errno: external
  (# err: @integer;
  do 'Errno' -> callC
  exit err
  #);

host2inetAddr: external
  (* Find the internet address (in binary format) of the 
   * host named 'host'. In case of failure, -1 is exited. 
   *)
  (# host: [1]@char;
     inetAddr: @integer;
  enter host
  do 'host2inetAddr' -> callC
  exit inetAddr
  #);

nameOfThisHost: external
  (# pointerToErrorCode: @integer;
     hostname: [1]@char;
  enter pointerToErrorCode
  do 'nameOfThisHost' -> callC
  exit hostname
  #);

inetAddrOfThisHost: external
  (# inetAddr: @integer;
  do 'inetAddrOfThisHost' -> callC
  exit inetAddr
  #);

selectReadable: external
  (# fd: @integer;
     readable: @integer;
  enter fd
  do 'selectReadable'->callC
  exit readable
  #);

getTimeStamp: external
  (# fd: @integer;
     timestamp: @integer;
  enter fd
  do 'getTimeStamp'->callC
  exit timestamp
  #);

openActiveSocket: External
  (* Open a socket connection to "port" on "host".
   * The resulting socket is returned by "index"
   *)
  (# inetAddr: @integer;
     port: @integer;
     index: @integer; (* -1 => error *)
  enter(inetAddr,port)
  do 'openActiveSocket' -> callC
  exit index
  #);

createPassiveSocket: external
  (# pointerToPortNumber: @integer;
     pointerToInetAddr: @integer;
     fd: @integer;
  enter (pointerToPortNumber,pointerToInetAddr)
  do 'createPassiveSocket' -> callC;
  exit fd
  #);

acceptConn: External
  (# listenIndex: @integer;
     pointerToBlocked: @integer; (* Blocked is set to 1 iff op. blocked *)
     talkIndex: @integer; (* -1 => error *)
     pointerToInetAddr: @integer;
  enter (listenIndex,pointerToBlocked,pointerToInetAddr)
  do 'acceptConn' -> callC
  exit talkIndex
  #);

sockToRead: external
  (* Returns the number of bytes immediately readable from the
   * socket with file descriptor fd.
   *)
  (# fd,result: @integer;
  enter fd
  do 'sockToRead' -> callC
  exit result
  #);

sockStreamEos: external
  (# fd,fp,result: @integer
  enter (fd,fp)
  do 'sockStreamEos' -> callC
  exit result
  #);

makeNonblocking: external
  (* Make the socket with file descriptor 'index' POSIX-style non-blocking. *)
  (# index,result: @integer;
  enter index
  do 'makeNonblocking' -> callC
  exit result
  #);

makePassiveNonblocking: external
  (* Prepare the passive socket with file descriptor 'index' for
   * accepting connections in a non-blocking manner. NOTE: this is
   * part of the BSD4.2 non-blocking behaviour. Don't do a
   * 'makeNonblocking' on the same socket.
   *)
  (# index,result: @integer;
  enter index
  do 'makePassiveNonblocking' -> callC
  exit result
  #);

doReadDataMax: external
  (* Returns number of bytes read. If 0, no data was available.
   * In case of error, returns -1.
   *)
  (# fd,destbuffer,wanted,result: @integer;
  enter (fd,destbuffer,wanted)
  do 'readDataMax' -> callC
  exit result
  #);

doWriteDataMax: external
  (* Returns number of bytes written. If 0, a buffer full condition
   * was found on first try. In case of error, returns -1.
   *)
  (# fd,srcbuffer,length,result: @integer;
  enter (fd,srcbuffer,length)
  do 'writeDataMax' -> callC
  exit result
  #);

shutdown: external (* clib.a *)
  (# index,how,result: @integer;
  enter (index,how)
  do 'shutdown' -> callC
  exit result
  #);

asynchLevel: external
  (# level: @integer;
  do 'asynchLevel' -> callC
  exit level
  #);

---]]
