ORIGIN '~beta/basiclib/v1.5/betaenv';
BODY 'fdStreamBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1993,94
 *       All rights reserved.
 *)
[[
--- lib:attributes ---

(*	Patterns defined here:
 *
 *	fdStream: encapsulates an association bewteen a UNIX file descriptor
 *	and an ANSI C style stream; it is a specialization af the standard
 *	'stream' pattern. Any UNIX object which has a file descriptor may be
 *	interfaced through an fdStream, e.g. a disk file, a socket etc.
 *
 *	readChannel: an fdStream, for which writes are disallowed.
 *
 *	writeChannel: an fdStream, for which reads are disallowed.
 *
 ******************************************************************************
 *	Information for anybody who needs to understand, to change or to
 *	expand the implementation:
 *
 *	By calling 'fdopen()', an fdStream associates a UNIX file identified
 *	by a file descriptor (a small positive integer, as returned by
 *	non-ANSI low level C functions such as 'open()' and 'socket()')
 *	and a C-stream wrapper object (in C represented by a pointer of
 *	type FILE* to a structure owned by the operating system, which
 *	keeps track of buffering and of the state of the associated file).
 *	Operations through a stream wrapper on a file uses high level
 *	functions such as 'fprintf()', 'fclose()' etc. and supports
 *	buffered i/o, which lowlevel functions do not.
 *
 *	WARNINGS:
 *
 *	(1) It is easy to introduce inconsistencies between the stream
 *	wrapper and the actual file by calling low level C functions,
 *	i.e. any function which refers to the file through the item 'index'.
 *
 *	(2) Although Ritchie & Kernighan "The C programming language"
 *	says it should, reading and writing through a single stream
 *	wrapper does not work properly, at least when the file descriptor
 *	refers to a socket. So, for sockets, don't instantiate an fdStream
 *	and do OpenReadWrite on it.
 *)

fdStream: stream
  (#
     Put::< (# bfPut: @<<SLOT fdStreamPut:descriptor>> do INNER; bfPut #);
     Get::< (# bfGet: @<<SLOT fdStreamGet:descriptor>> do INNER; bfGet #);
     Peek::< (# bfPeek: @<<SLOT fdStreamPeek:descriptor>> do INNER; bfPeek #);
     eos::< (# bfEos: @<<SLOT fdStreamEos:descriptor>> do INNER; bfEos #);

     PutText::<
       (# bfPutText: @<<SLOT fdStreamPutText:descriptor>>;
       do bfPutText;
          INNER;
       #);
     GetLine::< (# do <<SLOT fdStreamGetLine:descriptor>> #);
     GetAtom::< (# do <<SLOT fdStreamGetAtom:descriptor>> #);

     GetRep:
       (# repAdr: @integer; (* @@rep[inx]: start address *)
          length: @integer; (* max. no. of elements to read *)
          doGet: @<<SLOT fdStreamGetRep:descriptor>>;
          (* must be static to prevent garbage collection! *)
       enter(repAdr,length)
       do doGet
       exit(length div 4)
       #);

     PutRep:
       (# repAdr (* @@rep[inx]: start address *),
          length (* no. of rep-elements to be and was written *): @integer;
          doPut: @<<SLOT fdStreamPutRep:descriptor>>;
          (* must be static to prevent garbage collection! *)
       enter(repAdr,length)
       do doPut
       exit(length div 4)
       #);

     OpenRead:< (# do INNER; <<SLOT fdStreamOpenRead:descriptor>> #);
     OpenWrite:< (# do INNER; <<SLOT fdStreamOpenWrite:descriptor>> #);
     OpenReadWrite:< (# do INNER;<<SLOT fdStreamOpenReadWrite:descriptor>>#);
     OpenExeWrite:< (# do INNER; <<SLOT fdStreamOpenExeWrite:descriptor>> #);

     Flush:< (* Flushes THIS(fdStream).
              * Has only an effect on streams opened for output.
              *)
       (# do <<SLOT fdStreamFlush:descriptor>>; INNER; #);

     Close:< (* Closes THIS(fdStream) *)
       (# do <<SLOT fdStreamClose:descriptor>>; INNER; #);

     fdStreamException: StreamException
       (# message: @Text;
       enter message
       do <<SLOT fdStreamException:descriptor>>;
   	  INNER;
       #);

     AccessError:< fdStreamException;
     (* Raised when attempted to access an fdStream. Message: "Insufficient
      * access privilegies".
      *)
     ReadError:< fdStreamException;
     (* Raised from Get and Peek when attempted to read a non-existing
      * block. Message: "Read block error".
      *)
     WriteError:< fdStreamException;
     (* Raised from Put, PutText and Flush when attempted to write on a
      * non-existing block. Message: "Write block error".
      *)
     NoSpaceError:< fdStreamException;
     (* Raised when the file system is full. Message:
      * "File system is full".
      *)
     OtherError::< fdStreamException;

     private: @<<SLOT fdStreamPrivate:descriptor>>;
  #);

readChannel: fdStream
  (#
     openWrite::< (# do 'called openWrite on a readChannel' -> otherError #);

     put::< (# do 'Called put in a readChannel' -> OtherError #);

  #); (* read channel *)

writeChannel: fdStream
  (#
     openRead::< (# do 'called openRead on a WriteChannel' -> otherError #);

     get::< (# do 'Called get in a writeChannel' -> OtherError #);

  #); (* write channel *)

---]]
