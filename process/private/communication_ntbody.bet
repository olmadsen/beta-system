ORIGIN '../communication';
MAKE    default 'external/process.make';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992,93,94
 *       All rights reserved.
 *)

(*******************************************************************************
 * IMPORTANT: IF YOU INCLUDE THIS FRAGMENT, READ THE FOLLOWING.
 *
 * Information for anybody who needs to understand, to change or to
 * expand the implementation, or who intends to manipulate any of the
 * private items 'instream' and 'outstream':
 *
 *      This description assumes knowledge of the 'WARNINGS' comment
 *      in the fragment 'fdStream'.
 *
 *      A StreamSocket object contains two 'fdStream' items, which both wrap
 *      the file descriptor identifying the OS level socket. They are
 *      named 'instream' and 'outstream' and are located in 'private'.
 *      It is necessary to have two, since the actual implementation of
 *      <C/stdio> does not reliably support two-way communication through
 *      a single stream wrapper when the file descriptor refers to a
 *      socket.
 *
 *      All output to the StreamSocket must go through 'outstream' and
 *      all input from the StreamSocket must be received through 'instream'.
 *      The standard 'stream' operations ('get', 'put', 'peek', 'putText'
 *      etc.) do this.
 *
 *      Confine all operations beyond data transfer to one of the two
 *      'fdStream' items - say 'instream' - to minimize the inconsistencies.
 *
 *      Remember that operations on 'instream' influences the OS level
 *      socket which is also wrapped by 'outstream', and vice versa. If
 *      you write data to 'outstream' (like '##' -> mySocket.putText),
 *      don't 'flush' it, and then 'close' the 'instream', the data
 *      usually gets lost in stead of getting sent.
 *
 *      In general: unless very good reasons speak for manipulating
 *      a StreamSocket on a low level, don't do it - use a BinarySocket,
 *      and manipulate it using open()/close()/read()/write() etc.
 *
 ******************************************************************************)
[[
--- include '~beta/ntlib/v1.0/ntinterface'
--- include 'fdStream_nt'
--- include 'fdStream_ntBody'

--- lib:attributes ---

debug: (# do (if false//true then inner if)#);

asynchLevel: external
  (# level: @integer;
  do 'asynchLevel' -> callC
  exit level
  #);

cWaitForIO: external
  (# maxWait: @integer;
  enter maxWait
  do callC
  #);

wouldBlock: external
  (* Returns 1 if the most recent operation on a socket etc. would have 
   * blocked, 0 otherwise.
   *) 
  (# result: @integer;
  do callC
  exit result
  #);
(*
shutdown: external
  (# index,how,result: @integer;
  enter (index,how)
  do callC
  exit result
  #);
*)
sockToRead: external
  (* Returns the number of bytes immediately readable from the 
   * socket with file descriptor fd.
   *)
  (# fd,result: @integer;
  enter fd
  do callC
  exit result     
  #);

sockStreamEos: external
  (# fd,fp,result: @integer
  enter (fd,fp)
  do callC
  exit result
  #);

createPassiveSocket: external
  (# pointerToPortNumber: @integer;
     fd: @integer;
  enter pointerToPortNumber
  do 'createPassiveSocket' -> callC;
  exit fd
  #);

makeNonblocking: external
  (* Make the socket with file descriptor 'index' POSIX-style non-blocking. *)
  (# index,result: @integer;
  enter index
  do callC
  exit result
  #);

makePassiveNonblocking: external
  (* Prepare the passive socket with file descriptor 'index' for
   * accepting connections in a non-blocking manner. NOTE: this is
   * part of the BSD4.2 non-blocking behaviour. Don't do a
   * 'makeNonblocking' on the same socket.
   *)
  (# index,result: @integer;
  enter index
  do callC
  exit result
  #);

acceptConn: External
  (# listenIndex: @integer;
     talkIndex: @integer; (* -1 => error *)
  enter listenIndex
  exit talkIndex
  #);

doReadData: external
  (* Returns number of bytes read. If 0, no data was available.
   * In case of error, returns -1.
   *)
  (# fd,destbuffer,wanted,result: @integer;
  enter (fd,destbuffer,wanted)
  do 'readData' -> callC
  exit result
  #);

doWriteData: external
  (* Returns number of bytes written. If 0, a buffer full condition
   * was found on first try. In case of error, returns -1.
   *)
  (# fd,srcbuffer,length,result: @integer;
  enter (fd,srcbuffer,length)
  do 'writeData' -> callC
  exit result
  #);

--- waitForIO:descriptor ---
(# 
do 
   maxWait -> cWaitForIO;
#)

--- PipePrivate:descriptor ---
(#
   readCh: @readChannel;
   writeCh: @writeChannel;
#)

--- PipeInit:descriptor ---
(#
   descriptors: ^unixPipe;
do
   INNER Init;
   (* get OS level pipe object *)
   &unixPipe[] -> descriptors[];
   (if (descriptors[] -> &openPipe)
    // -1 then 'failed to open pipe' -> error;
   if);

   (* make readCh/writeCh wrap the pipe *)
   descriptors.writeIndex -> private.writeCh.private.Index;
   descriptors.readIndex -> private.readCh.private.Index;
   debug(#
        do 'PipeInit--  writeIndex: '-> screen.puttext;
           descriptors.writeIndex -> screen.putint;
           ' readIndex: ' -> screen.puttext;
           descriptors.readIndex -> screen.putint; screen.newline;
        #);
   private.readCh.openRead;
   private.writeCh.openWrite;

   (* initialize interface *)
   private.readCh[] -> readEnd[];
   private.writeCh[] -> writeEnd[];
#)

--- SSocketPrivate:descriptor ---
(#
   index: @assignGuard(# rep: @integer; enter rep exit rep #);
   instream: @readChannel;
   outstream: @writeChannel;
   untryPatVar: ##Object;
#)

--- SSocketOpen:descriptor ---
(#
do
   INNER open;
   (if private.index.assigned // false then
       'Can not open a socket with unassigned index' -> error
   if);
   private.index -> private.instream.private.index;
   private.index -> private.outstream.private.index;
   private.instream.openRead;
   private.outstream.openWrite;
#)

--- SSocketClose:descriptor ---
(#
do
   INNER close;
(*   (private.instream.private.index,2) -> shutdown; *) (* 2: read & write *)
   private.outstream.flush;
   (* DON'T DO private.outstream.close; SEE WARNING *)
   private.instream.close;
#)

--- SSocketFlush:descriptor ---
(#
do
   INNER flush;
   private.outstream.flush;
#)

--- SSocketPut:descriptor ---
(#
do
   INNER put;
   ch -> private.outstream.put
#)

--- SSocketGet:descriptor ---
(#
do
   INNER get;
   L: (if eos//true then
          Blocking;
          1 -> waitForIO;
          restart L;
       else
          private.instream.get -> ch
      if);
#)

--- SSocketPeek:descriptor ---
(#
do
   INNER peek;
   L: (if eos//true then
          Blocking;
          1 -> waitForIO;
          restart L;
       else
          private.instream.peek -> ch
      if);
#)

--- SSocketEos:descriptor ---
(#
do
   INNER eos;
   (if ((private.instream.private.index,private.instream.private.unixstream)
         ->sockStreamEos)
    //0 then
       false -> value;
    else
       true -> value;
   if);
#)

--- SSocketPutText:descriptor ---
(#
do
   true -> doneInINNER;
   T[] -> private.outstream.putText;
   INNER PutText;
#)

--- SSocketGetLine:descriptor ---
(#
do
   true -> doneInINNER;
   L: (if eos//true then
          Blocking;
          1 -> waitForIO;
          restart L;
       else
          private.instream.getLine -> t[];
      if);
   INNER GetLine;
#)

--- SSocketGetAtom:descriptor ---
(#
do
   true -> doneInINNER;
   L: (if eos//true then
          Blocking;
          1 -> waitForIO;
          restart L;
       else
          private.instream.getAtom -> t[];
      if);
   INNER GetAtom;
#)

--- SSocketNonBlockingScope:descriptor ---
(#
do
   tryLabel:
     (#
        doUntry:
          (#
          do
             NONE -> private.untryPatVar##;  (* Leaving: always "deactivate" *)
             leave tryLabel
          #);
     do
        (if private.untryPatVar##//NONE then (* Outermost NBScope: "activate" *)
            doUntry## -> private.untryPatVar##;
            INNER nonBlockingScope;
            NONE -> private.untryPatVar##;
         else                                (* Nested NBScope: "is active" *)
            INNER nonBlockingScope;
        if);
     #);
#)

--- SSocketLeaveNBScope:descriptor ---
(#
do
   (if private.untryPatVar##//NONE then else private.untryPatVar if)
#)

--- BSocketPrivate:descriptor ---
(#
   index: @assignGuard(# rep: @integer; enter rep exit rep #);
   lastReadLength: @integer;
   untryPatVar: ##Object;
#)

--- BSocketOpen:descriptor ---
(#
do
   INNER open;
   (if private.index.assigned // false then
       'Can not open a socket with unassigned index' -> error;
   if);
#)

--- BSocketClose:descriptor ---
(#
do
   INNER close;
(*   (private.index,2) -> shutdown; *) (* 2: read & write *)
   private.index->closeFileDescriptor; (* no error checks: we must be able to close after error *)
#)

--- BSocketWrite:descriptor ---
(#
do
   L: (if ((private.index,address,length)->doWriteData)
       //-1 then
          'Error during write to socket' -> error;
       //0 then
          (if private.untryPatVar##//NONE then else private.untryPatVar if);
          1 -> waitForIO;
          restart L;
      if);
   INNER writeData;
#)

--- BSocketRead:descriptor ---
(#
   wanted,total: @integer;
do
   (if length//0 then (* do nothing *) 
    else
       L: (if ((private.index,address,length)->doReadData)
           //-1 then
              'Error during read from socket' -> error;
           //0 then
              (if private.untryPatVar##//NONE then else private.untryPatVar if);
              1 -> waitForIO;
              restart L;
          if);
   if);
   INNER readData;
#)

--- BSocketEndOfData:descriptor ---
(#
   result: @integer;
do
   private.index -> sockToRead -> result;
   (* No test for error; it will be discovered later, if it matters *)
   (result>0) -> value;
#)

--- BSocketPutBlock:descriptor ---
(#
do
   L: (if ((private.index,@@length,4)->doWriteData)
       //-1 then
          'Error writing length of block' -> error;
       //0 then
          (if private.untryPatVar##//NONE then else private.untryPatVar if);
          1 -> waitForIO;
          restart L;
       else
          L2: (if ((private.index,@@header,4)->doWriteData)
               //-1 then
                  'Error writing header of block' -> error;
               //0 then
                  (* Never 'leave' from here, would break the protocol *)
                  1 -> waitForIO;
                  restart L2;
               else
                  L3: (if ((private.index,address,length*4)->doWriteData)
                       //-1 then
                          'Error writing data-part of block' -> error;
                       //0 then
                          (* Never 'leave' from here, breaks the protocol *)
                          1 -> waitForIO;
                          restart L3;
                      if);
              if);
      if);
#)

--- BSocketGetBlock:descriptor ---
(#
do
   L: (if ((private.index,@@length,4)->doReadData)
       //-1 then
          'Error reading block length' -> error
       //0 then
          (if private.untryPatVar##//NONE then else private.untryPatVar if);
          1 -> waitForIO;
          restart L;
       else
          L2: (if ((private.index,@@header,4)->doReadData)
               //-1 then
                  'Error reading block header' -> error
               //0 then
                  1 -> waitForIO;
                  restart L2;
               else
                  (if length//0 then leave L if);
                  (if (length>maxlen)//true then
                      (* Special case: overflow, read maxlen; discard rest of
                       * block to ensure we can find beginning of next block.
                       *)
                      L3: (if ((private.index,address,maxlen*4)->doReadData)
                           //-1 then
                              'Error reading data from (overflowing) block'
                                -> error;
                           //0 then
                              1 -> waitForIO;
                              restart L3;
                          if);
                      (# trash: [length-maxlen]@integer;
                      do
                         L4: (if ((private.index,@@trash[1],
                                 4*(length-maxlen)) -> doReadData)
                              //-1 then
                                 'Error reading overflow data from block'
                                   -> error;
                              //0 then
                                 1 -> waitForIO;
                                 restart L4;
                             if);
                      #);
                   else
                      (* Normal case *)
                      L5: (if ((private.index,address,length*4)->doReadData)
                           //-1 then
                              'Error reading data part of block' -> error
                           //0 then
                              1 -> waitForIO;
                              restart L5;
                          if);
                  if);
              if);
      if);
#)

--- BSocketGetBlockLen:descriptor ---
(#
do
   L: (if ((private.index,@@length,4)->doReadData)
       //0 then
          Blocking;
          1 -> waitForIO;
          restart L;
       //-1 then
          'Error reading block length' -> error;
       else
          length->private.lastReadLength
      if);
#)

--- BSocketGetBlockRest:descriptor ---
(#
do
   L: (if ((private.index,@@header,4)->doReadData)
       //-1 then
          'Error reading header of block' -> error
       //0 then
          (if private.untryPatVar##//NONE then else private.untryPatVar if);
          1 -> waitForIO;
          restart L;
       else
          (if private.lastReadLength//0 then leave L if);
          L2: (if ((private.index,address,private.lastReadLength*4)->doReadData)
               //-1 then
                  'Error reading data part of block' -> error
               //0 then
                  1 -> waitForIO;
                  restart L2;
              if);
      if);
#)

--- BSocketPutRep:descriptor ---
(#
do
   L: (if ((private.index,@@rep.lgth,4)->doWriteData)
       //-1 then
          'Error writing length of ExtendedRepstream' -> error
       //0 then
          Blocking;
          1 -> waitForIO;
          restart L;
       else
          L2: (if ((private.index,@@header,4)->doWriteData)
               //-1 then
                  'Error writing header for ExtendedRepstream' -> error
               //0 then
                  Idle;
                  1 -> waitForIO;
                  restart L2;
               else
                  (if rep.length//0 then leave L if);
                  L3: (if ((private.index,@@rep.r[1],rep.lgth*4)->doWriteData)
                       //-1 then
                          'Error writing data from ExtendedRepstream' -> error;
                       //0 then
                          Idle;
                          1 -> waitForIO;
                          restart L3;
                      if);
              if);
      if);
#)

--- BSocketGetRep:descriptor ---
(#
   length: @integer;
do
   (* Get length field *)
   (if ((getBlockLen(# Idle::< (# do 1 -> waitForIO #);
                       error::< (# do this(getRep).error #);
                       Blocking::<
                         (#
                         do this(getRep).Blocking;
                            (* If we reach this spot, the user has
                             * executed a 'continue' in 'this(getRep).Blocking'
                             * or we are not in a 'nonBlockingScope'.
                             * In first case we must do 'continue', in the
                             * second, it does no harm.
                             *)
                            continue;
                         #);
                    #) -> length) > rep.r.range)
    //true then
       length-rep.r.range->rep.r.extend;
   if);

   L: (if ((private.index,@@header,4)->doReadData)
       //-1 then
          'Error reading header in getRep' -> error
       //0 then
          Idle;
          1 -> waitForIO;
          restart L;
       else
          (if private.lastReadLength//0 then leave L if);
          L2: (if ((private.index,@@rep.r[1],private.lastReadLength*4)
                    ->doReadData)
               //-1 then
                  'Error reading data in getRep' -> error
               //0 then
                  Idle;
                  1 -> waitForIO;
                  restart L2;
              if);
      if);
   
   length->rep.lgth; (* Announce how much data received *)
   rep.reset; (* Prepare 'rep' for reading from the beginning *)
#)

--- BSocketNonBlockingScope:descriptor ---
(#
do
   tryLabel:
     (#
        doUntry:
          (#
          do
             NONE -> private.untryPatVar##;  (* Leaving: always "deactivate" *)
             leave tryLabel
          #);
     do
        (if private.untryPatVar##//NONE then (* Outermost NBScope: "activate" *)
            doUntry## -> private.untryPatVar##;
            INNER nonBlockingScope;
            NONE -> private.untryPatVar##;
         else                                (* Nested NBScope: "is active" *)
            INNER nonBlockingScope;
        if);
     #);
#)


--- BSocketLeaveNBScope:descriptor ---
(#
do
   (if private.untryPatVar##//NONE then else private.untryPatVar if)
#)

--- ActiveSSocketConnect:descriptor ---
(#
   h: @Text; p: @Integer;
do
   INNER connect;
   (if port.assigned//false then
       'Can not open an active socket with unassigned port' -> error
   if);
   (if host.assigned//false then
       'Can not open an active socket with unassigned host' -> error
   if);
   host->h;
   port->p;
   (h,p) -> &openActive -> private.index;
   (if private.index // -1 then 'Error in open active' -> error if);
#)

--- ActiveBSocketConnect:descriptor ---
(#
   h: @Text; p: @Integer;
do
   INNER connect;
   (if port.assigned//false then
       'Can not open an active socket with unassigned port' -> error
   if);
   (if host.assigned//false then
       'Can not open an active socket with unassigned host' -> error
   if);
   host->h;
   port->p;
   (h,p) -> &openActive -> private.index;
   (if private.index // -1 then 'Error in open active' -> error if);
   (if private.index -> &makeNonblocking //-1 then
       'Error making socket nonblocking' -> error
   if);
#)

--- PassiveSSocketPrivate:descriptor ---
(#
   listenIndex: @assignGuard(# rep: @integer enter rep exit rep #);
#)

--- PassiveSSocketBind:descriptor ---
(#
   portnumber: @integer;
do
   INNER bind;
   (if port.assigned // false then
       'Can not bind a passive socket with unassigned port' -> error
   if);
   port -> portNumber;
   (if (@@portNumber -> &createPassiveSocket -> private2.listenIndex) //-1 then
       'Error when binding a socket' -> error;
   if);
   portNumber -> port;
   (if (private2.listenIndex -> &makePassiveNonblocking) //-1 then
       'Error when setting passive socket option' -> error;
   if);
#)

---  PassiveSSocketAwait:descriptor  ---
(#
do
   INNER awaitConnection;
   (if private2.listenIndex.assigned // false then
       'Await connection on an unbound passive socket' -> error
   if);
   L: (#
      do
         private2.listenIndex -> &acceptConn -> private.index;
         (if private.index // -1 then
             (if wouldBlock//1 then
                 Blocking;
                 1 -> waitForIO;
                 restart L;
             if);
             'Error in an accept call' -> error;
         if);
      #);
#)

--- PassiveSSocketClose:descriptor ---
(#
do INNER close;
   private2.listenIndex->closeFileDescriptor; (* no error check: we must be able to close after err *)
#)

--- PassiveBSocketPrivate:descriptor ---
(#
   listenIndex: @assignGuard(# rep: @integer enter rep exit rep #);
#)

--- PassiveBSocketBind:descriptor ---
(#
   portnumber: @integer;
do
   INNER bind;
   (if port.assigned // false then
       'Can not bind a passive socket with unassigned port' -> error
   if);
   port -> portNumber;
   (if (@@portNumber -> &createPassiveSocket -> private2.listenIndex) // -1 then
       'Error when binding a socket' -> error;
   if);
   portNumber -> port;
   (if (private2.listenIndex -> &makePassiveNonblocking) //-1 then
       'Error when setting passive socket option' -> error;
   if);
#)

---  PassiveBSocketAwait:descriptor  ---
(#
do
   INNER awaitConnection;
   (if private2.listenIndex.assigned // false then
       'Await connection on an unbound passive socket' -> error
   if);
   L: (#
      do
         private2.listenIndex -> &acceptConn -> private.index;
         (if private.index // -1 then
             (if wouldBlock//1 then
                 Blocking;
                 1 -> waitForIO;
                 restart L;
             if);
             'Error in an accept call' -> error
         if);
      #);
   (if private.index -> &makeNonblocking //-1 then
       'Error making socket nonblocking' -> error
   if);
#)

--- PassiveBSocketClose:descriptor ---
(#
do INNER close;
   private2.listenIndex->closeFileDescriptor; (* no error check: we must be able to close after err *)
#)

--- SocketGeneratorPrivate:descriptor ---
(#
   index: @assignGuard(# rep: @integer enter rep exit rep #);
   untryPatVar: ##Object;
#)

--- SocketGeneratorBind:descriptor ---
(#
   portNumber: @integer;
do
   INNER bind;
   (if port.assigned // false then
       'Can not bind a socket generator with unassigned port' -> error
   if);
   port -> portNumber;
   (if (@@portNumber -> &createPassiveSocket -> private.index) //-1 then
       'Error when binding a socket generator' -> error;
   if);
   portNumber -> port;
   (if (private.index -> &makePassiveNonblocking) //-1 then
       'Error when setting option' -> error;
   if);
#)

--- SocketGeneratorClose:descriptor ---
(#
do INNER close;
(*   (private.index,2) -> shutdown; *) (* 2: read/write. Not important, though! *)
   private.index->closeFileDescriptor; (* no error check: we must be able to close after error *)
#)

--- SocketGeneratorGetStream:descriptor ---
(#
   newIndex: @Integer;
do
   (if private.index.assigned // false then
       'getStreamConnection on an unbound socket generator' -> error;
   if);

   L: (#
      do
         private.index -> &acceptConn -> newIndex;
         (if newIndex // -1 then
             (if wouldBlock//1 then
                 Blocking;
                 1 -> waitForIO;
                 restart L;
              else
                 'Error accepting connection' -> error;
             if);
          else
             &StreamSocketType[] -> sock[];
             newIndex -> sock.private.index;
             sock.open;
             (if newIndex -> &makeNonblocking //-1 then
                 'Error making socket nonblocking' -> error;
             if);
         if);
      #);
   INNER getStreamConnection;
#)

--- SocketGeneratorGetBinary:descriptor ---
(#
   newIndex: @Integer;
do
   (if private.index.assigned // false then
       'getBinaryConnection on an unbound socket generator' -> error
   if);

   L: (#
      do
         private.index -> &acceptConn -> newIndex;
         (if newIndex // -1 then
             (if wouldBlock//1 then
                 Blocking;
                 1 -> waitForIO;
                 restart L;
              else
                 'Error accepting connection' -> error;
             if);
          else
             &BinarySocketType[] -> sock[];
             newIndex -> sock.private.index;
             sock.open;
             (if newIndex -> &makeNonblocking //-1 then
                 'Error making socket nonblocking' -> error;
             if);
         if);
      #);
   INNER getBinaryConnection;
#)

--- SocketGeneratorNBScope:descriptor ---
(#
do
   tryLabel:
     (#
        doUntry:
          (#
          do
             NONE -> private.untryPatVar##;  (* Leaving: always "deactivate" *)
             leave tryLabel
          #);
     do
        (if private.untryPatVar##//NONE then (* Outermost NBScope: "activate" *)
            doUntry## -> private.untryPatVar##;
            INNER nonBlockingScope;
            NONE -> private.untryPatVar##;
         else                                (* Nested NBScope: "is active" *)
            INNER nonBlockingScope;
        if);
     #);
#)

--- SocketGeneratorLeaveNBScope:descriptor ---
(#
do
   (if private.untryPatVar##//NONE then else private.untryPatVar if)
#)

---]]
