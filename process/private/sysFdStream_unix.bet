ORIGIN 'sysFdStream';
INCLUDE '~beta/unixlib/unixinterface'
        '~beta/sysutils/iostate'
        'socketsint'
        '~beta/basiclib/private/betaenvbody'
	'~beta/basiclib/private/filebody'
	'~beta/basiclib/formatio';
LIB_ITEM 'processsysfdstream';
(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)
 
-- fdStreamPrivate: Descriptor --
(#
(* The UNIX filedescriptor index on top of which buffered
 * I/O is provided.
 *)
   memcpy: external
     (#
        adrTarget: @Integer;
        adrSource: @Integer;
        byteCount: @Integer;
        out: @Integer;
        
     enter (adrTarget,adrSource,byteCount)
     exit out
     #);
   state: @IOmask;
   fd: @Integer;
   isClosed: @Boolean;
   
   MaxReadAhead: (#  exit 8096 #);
   (* Max count of bytes to buffer ahead in stream *)
   Buffer: @
     (# (* Copied and extended from Buffer in basicsocketbody.bet *)
        T: [0] @Char;
        putpos,getpos: @Integer;
        Expand: @
          (# len: @Integer; 
          enter len
          do (if putpos+len >= T.range then len->T.extend;  if); 
          #);
        (* put: @
         *  (# c: @char;
         *  enter c
         *  do putpos + 1 -> putpos;
         *     (if putpos > T.range then 16 -> T.extend  if);
         *     c -> T[putpos];
         *  #);
         * 
         *)
        get: @
          (# c: @char; 
          do
             getpos+1->getpos;
             T[getpos]->c;
             (if getpos = putpos then 0->getpos; 0->putpos if)
          exit c
          #);
        AddedBytes: @
          (# len: @Integer;  enter len do len+putpos->putpos;  #);
        getPutAdr: @
          (# adr: @Integer;  do @@ T[putpos+1]->adr;  exit adr #);
        getFreeSpace: @
          (# space: @Integer;  do T.range-putpos->space;  exit space #);
        isEmpty: @ (#  exit (putpos = 0) #);
        peek: @ (#  exit T[getpos+1] #);
        (* Allowed when not isEmpty *)
        
     #);
   FillOrBlock: @
     (#
        TryToFillBuffer: @
          (#
             read: external
               (# fd,bufptr,nbytes,bytesread: @Integer; 
               enter (fd,bufptr,nbytes)
               exit bytesread
               #);
             len: @Integer;
             
          do MaxReadAhead->Buffer.expand;
             (fd,Buffer.getPutAdr,Buffer.getFreeSpace)->read->len;
             (if len > 0 then
                 len->Buffer.AddedBytes; 
              else
                 (if len = 0 then
                     true->isClosed
                  else
                     (* Blocked, but not closed *)
                     (* Maybe need to check errno here? *)
                 if)
             if)
          #)
     do
        check:
        (if (not isClosed) and Buffer.isEmpty then
            TryToFillBuffer;
            (if (not isClosed) and Buffer.isEmpty then
                state.block; restart check; 
            if)
        if)
     #);
   init:
     (#
        setFdNonBlock: external (# fd: @integer enter fd exit fd #);
        setFdCloExec: external (# fd: @integer enter fd exit fd #);
        
     do fd->setFdNonBlock->fd; 
        (if fd < 0 then
            'Warning: Could not get nonblocking descriptor'->screen.putLine;
            0->fd
        if);
	fd->setFdCloExec;
        fd->state.AddReadFD;
     #);
   initWrite:
     (#
        setFdCloExec: external (# fd: @integer enter fd exit fd #);
        
     do fd->setFdCloExec;
     #);
#)  

-- fdStreamGet: Descriptor --
(# 
do
   private.FillOrBlock;
   (if not private.isClosed then Private.Buffer.get->ch if)
#)  

-- fdStreamPeek: Descriptor --
(# 
do
   private.FillOrBlock;
   (if not private.isClosed then Private.Buffer.peek->ch if)
#)  

-- fdStreamEos: Descriptor --
(# 
do
   private.FillOrBlock;
   private.isClosed->value
#)  

-- fdStreamPut: Descriptor --
(# write: external
     (# fd,buf,size,res: @Integer
     enter (fd,buf,size) 
     exit res
     #)
do (private.fd, @@ch, 1)->write;
#)  

-- fdStreamPutText: Descriptor --
(# write: external
     (# fd,buf,size,res: @Integer
     enter (fd,buf,size) 
     exit res
     #);
   res,pos: @Integer;
do 0->pos;
   L:
     (# 
     do (private.fd, @@txt.t[1]+pos, txt.lgth-pos)->write->res;
        res+pos->pos;
        (if pos < txt.lgth then restart L if)
     #)   
#)  

-- fdStreamGetLine: Descriptor --
(# putT: ^text.put; putall: @ScanToNl (#  do ch->putT #); 
do (* FIXME: this could be done more efficiently *)
   &txt.put[]->putT[]; putall; 
#)  

-- fdStreamGetAtom: Descriptor --
(#  do 'warning fdStreamGetAtom'->screen.putline #)  

-- fdStreamGetRep: Descriptor --
(#  do 'warning fdStreamGetRep'->screen.putline #)  

-- fdStreamPutRep: Descriptor --
(#  do 'warning fdStreamGetRep'->screen.putline #)  

-- fdStreamOpenRead: Descriptor --
(# do private.init; #)  

-- fdStreamOpenWrite: Descriptor --
(# do private.initwrite; #)  

-- fdStreamOpenReadWrite: Descriptor --
(#  #)  

-- fdStreamOpenExeWrite: Descriptor --
(#  #)  

-- fdStreamFlush: Descriptor --
(# #)  

-- fdStreamClose: Descriptor --
(#
   close: External (* From libc.a *)
     (#
        descriptor: @integer;
        status: @integer
        (* -1 => error, 0 => succes *)
     enter descriptor
     exit status
     #)
do private.fd->close
#)  

-- fdStreamException: Descriptor --
(#  do 'fdStream exception: '->msg.puttext; message[]->msg.puttext;  #)  

