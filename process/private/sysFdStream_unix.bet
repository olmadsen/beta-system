ORIGIN 'sysFdStream';
INCLUDE '~beta/unixlib/unixinterface'
        '~beta/sysutils/iostate'
        'socketsint'
        '~beta/basiclib/private/betaenvbody'
        '~beta/basiclib/private/filebody' '~beta/basiclib/formatio';
LIB_ITEM (*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1993-97
 *       All rights reserved.
 *)
 'processsysfdstream';
-- fdStreamPrivate: Descriptor --
(#
(* The UNIX filedescriptor index on top of which buffered
 * I/O is provided.
 *)
   memcpy: external
     (#
        adrTarget: @Integer;
        adrSource: @Integer;
        byteCount: @Integer;
        out: @Integer;
        
     enter (adrTarget,adrSource,byteCount)
     exit out
     #);
   state: @IOmask;
   fd: @Integer;
   isClosed: @Boolean;
   MaxReadAhead: (#  exit 8096 #);
   (* Max count of bytes to buffer ahead in stream *)
   Buffer: @
     (# (* Copied and extended from Buffer in basicsocketbody.bet *)
        T: [0] @Char;
        putpos,getpos: @Integer;
        Expand: @
          (# len: @Integer; 
          enter len
          do (if putpos+len >= T.range then len->T.extend;  if); 
          #);
        (* put: @
         *  (# c: @char;
         *  enter c
         *  do putpos + 1 -> putpos;
         *     (if putpos > T.range then 16 -> T.extend  if);
         *     c -> T[putpos];
         *  #);
         * 
         *)
        get: @
          (# c: @char; 
          do
             getpos+1->getpos;
             T[getpos]->c;
             (if getpos = putpos then 0->getpos; 0->putpos if)
          exit c
          #);
        AddedBytes: @
          (# len: @Integer;  enter len do len+putpos->putpos;  #);
        getPutAdr: @
          (# adr: @Integer;  do @@ T[putpos+1]->adr;  exit adr #);
        getFreeSpace: @
          (# space: @Integer;  do T.range-putpos->space;  exit space #);
        (* putMem: @
         *   (# adr,len,tmp: @Integer;
         *   enter (adr,len)
         *   do (@@T[putpos + 1], adr, len) -> memcpy;
         *      putpos + len -> putpos;
         *   #);
         * getMem: @
         *   (# adr,len,tmp: @Integer;
         *   enter len
         *   do @@T[getpos + 1] -> adr;
         *      getpos + len -> getpos;
         *      (if getpos=putpos then 0 -> getpos; 0 -> putpos if)
         *   exit adr
         *   #);
         * skip: @
         *   (# 
         *   do getpos + 1 -> getpos;
         *      (if getpos=putpos then 0 -> getpos; 0 -> putpos if)
         *   #)
         * length: @(# exit putpos-getpos #);
         *)
        isEmpty: @ (#  exit (putpos = 0) #);
        peek: @ (#  exit T[getpos+1] #);
        (* Allowed when not isEmpty *)
        
     #);
   FillOrBlock: @
     (#
        TryToFillBuffer: @
          (#
             read: external
               (# fd,bufptr,nbytes,bytesread: @Integer; 
               enter (fd,bufptr,nbytes)
               exit bytesread
               #);
             len: @Integer;
             
          do
             MaxReadAhead->Buffer.expand;
             (fd,Buffer.getPutAdr,Buffer.getFreeSpace)->read->len;
             (if len > 0 then
                 len->Buffer.AddedBytes; 
              else
                 (if len = 0 then
                     true->isClosed
                  else
                     (* Blocked, but not closed *)
                     (* Maybe need to check errno here? *)
                 if)
             if)
          #)
     do
        check:
        (if (not isClosed) and Buffer.isEmpty then
            TryToFillBuffer;
            (if (not isClosed) and Buffer.isEmpty then
                state.block; restart check; 
            if)
        if)
     #);
   init:
     (#
        getStandardInNonBlock: external (# fd: @Integer exit fd #);
        setFdNonBlock: external (# fd: @integer enter fd exit fd #);
        
     do (* getStandardInNonBlock -> fd; *)
        fd->setFdNonBlock->fd; 
        (if fd < 0 then
            'Warning: Could not get nonblocking descriptor'->screen.putLine;
            0->fd
        if);
        fd->state.AddReadFD
     #)
#)  

-- fdStreamPut: Descriptor --
(#  do 'Warning: attempt to Put to the Keyboard'->screen.putline #)  

-- fdStreamGet: Descriptor --
(# 
do
   private.FillOrBlock;
   (if not private.isClosed then Private.Buffer.get->ch if)
#)  

-- fdStreamPeek: Descriptor --
(# 
do
   private.FillOrBlock;
   (if not private.isClosed then Private.Buffer.peek->ch if)
#)  

-- fdStreamEos: Descriptor --
(# 
do
   private.FillOrBlock;
   private.isClosed->value
#)  

-- fdStreamPutText: Descriptor --
(#
   fputs: external (# t,s,e: @integer;  enter (t,s) exit e #);
   printf: external (# t: @integer enter t #);
   
#)  

-- fdStreamGetLine: Descriptor --
(# putT: ^text.put; putall: @ScanToNl (#  do ch->putT #); 
do (* FIXME: this should be done more efficiently *)
   &txt.put[]->putT[]; putall; 
#)  

-- fdStreamGetAtom: Descriptor --
(#  do 'warning fdStreamGetAtom'->screen.putline #)  

-- fdStreamGetRep: Descriptor --
(#  do 'warning fdStreamGetRep'->screen.putline #)  

-- fdStreamPutRep: Descriptor --
(#  do 'warning fdStreamGetRep'->screen.putline #)  

-- fdStreamOpenRead: Descriptor --
(#  do private.init;  #)  

-- fdStreamOpenWrite: Descriptor --
(#  #)  

-- fdStreamOpenReadWrite: Descriptor --
(#  do  #)  

-- fdStreamOpenExeWrite: Descriptor --
(#  #)  

-- fdStreamFlush: Descriptor --
(#  do  #)  

-- fdStreamClose: Descriptor --
(#
   close: External (* From libc.a *)
     (#
        descriptor: @integer;
        status: @integer
        (* -1 => error, 0 => succes *)
     enter descriptor
     exit status
     #)
do private.fd->close
#)  

-- fdStreamException: Descriptor --
(#  do 'fdStream exception: '->msg.puttext; message[]->msg.puttext;  #)  

