ORIGIN 'processmanagerbody';
LIB_ITEM 'processmanager';

(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

INCLUDE '~beta/basiclib/private/file_unixbody';
INCLUDE 'commpipe_unix';
INCLUDE '~beta/sysutils/cstring';

--- ProcessPrivate:descriptor ---
(#
   assignGuard: (# assigned: @Boolean do true -> assigned #);
   pid: @Integer;
   inputIndex, outputIndex, stderrIndex: @
       assignGuard (# rep: @Integer enter rep exit rep #);

   (* temporary items used within operations *)
   aPipe: ^pipe;
   readCh: ^readChannel;
   writeCh: ^writeChannel;
   pipeIntoParent: @boolean;
   pipeErrIntoParent: @boolean;
#)


--- ProcessStartMDBody:descriptor---
(# a,b,c: @Integer; 
   namestr, argstr: @CString;
do 
   (if not private.inputIndex.assigned  then 0 -> private.inputIndex if);
   (if not private.outputIndex.assigned then 1 -> private.outputIndex if);
   (if not private.stderrIndex.assigned then 2 -> private.stderrIndex if);
   private.inputIndex -> a;
   private.outputIndex -> b;
   private.stderrIndex -> c;
   name[] -> namestr.set;
   argument.argument[] -> argstr.set;
   (namestr,argstr,a,b,c)
     -> startUnixProcess -> private.pid;
   (if private.pid = -1  then 'failed to start process ' -> error if);

   (* now we are in the parent process *)

   (* If the child process has a write fd which it uses to write to us
    * then we had better close our copy of that write fd, otherwise we
    * can't detect EOF
    *)

   (if private.pipeIntoParent then private.outputIndex->close if);
   (if private.pipeErrIntoParent then private.stderrIndex->close if);

   (* If we have a write fd which we are using to write to the child
    * (or another child) then the child should close its copy of that
    * write fd for the same reason.  This is generally achieved with
    * the FD_CLOEXEC to fcntl so no need to do anything here.
    *)
   
   false -> private.inputIndex.assigned;
   false -> private.outputIndex.assigned;
   false -> private.stderrIndex.assigned;
   namestr.free;
   argstr.free;
#)


--- ProcessStopMDBody:descriptor ---
(#
do	
   (if ( private.pid -> &stopUnixProcess)
    // -1 then 'could not stop the process' -> error
   if);
#)


--- ProcessAwaitStopped:dopart ---
do	
   (if stillRunning // true then
       (if (private.pid -> &awaitNotExecuting)
        // -1 then getErrno -> errorstring -> error;
        // 0  then (* ?????? *) 
        // 1  then (* exited *)
        // 2  then (* killed *)
       if)
   if);
   INNER;
   

--- ProcessStillRunning:dopart ---
do (if private.pid > 0 then	
       (if (private.pid -> &stillExecuting)
        // -1 then 'stillRunning failed' -> error
        // 0  then false -> value
        // 1  then true -> value
       if);
    else 
       false -> value;
   if);
   INNER;
   

--- connectToProcess:dopart ---
do
   (* send output to other process *)
   &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> toProcess.redirectFromChannel;
   private.aPipe.writeEnd[] -> redirectToChannel;
   INNER;
   

--- connectErrToProcess:dopart ---
do
   (* send stderr to other process *)
   &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> toProcess.redirectFromChannel;
   private.aPipe.writeEnd[] -> redirectErrToChannel;
   INNER;
   

--- connectInPipe:dopart ---
do
   (* get input from other process *)
   &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> redirectFromChannel;
   private.aPipe.writeEnd[] -> fromProcess.redirectToChannel;
   true -> private.pipeIntoParent;
   INNER;

   
--- redirectFromFile:dopart ---
do	
   (* (THIS(Process),inputFile) => inputFile > THIS(Process) *)
   inputFile.openRead;
   inputFile.private.Index -> THIS(Process).private.inputIndex;
   INNER;
   

--- redirectToFile:dopart ---
do	
   (* (THIS(Process),outputFile) => THIS(Process) > outputFile *)
   outputFile.openWrite;
   outputFile.private.Index -> THIS(Process).private.outputIndex;
   INNER;

   
--- redirectErrToFile:dopart ---
do	
   (* (THIS(Process),stderrFile) => THIS(Process) > outputFile *)
   outputFile.openWrite;
   outputFile.private.Index -> THIS(Process).private.stderrIndex;
   INNER;

   
--- redirectFromChannel:dopart ---
do
   (* (THIS(Process),inputChannel) => 
    * Redirect the input to THIS(Process) from inputChannel.
    *)
   inputChannel[] -> private.readCh[];
   private.readCh.private.fd(*Index*) -> THIS(Process).private.inputIndex;
   INNER;
   

--- redirectToChannel:dopart ---
do
   (* (THIS(Process),outputChannel) => 
    * Redirect the output from This(Process) to outputChannel.
    *)
   outputChannel[] -> private.writeCh[];
   private.writeCh.private.fd(*Index*) -> THIS(Process).private.outputIndex ;
   true -> private.pipeIntoParent;
   INNER;
   

--- redirectErrToChannel:dopart ---
do
   (* (THIS(Process),outputChannel) => 
    * Redirect the stderr from This(Process) to outputChannel.
    *)
   outputChannel[] -> private.writeCh[];
   private.writeCh.private.fd(*Index*) -> THIS(Process).private.stderrIndex ;
   true -> private.pipeErrIntoParent;
   INNER;
   

--- ProcessManagerExceptionMDBody:descriptor ---
(# getErrno: external (# value: @Integer exit value #);
do getErrno -> errorstring -> msg.puttext;
#)

