ORIGIN '../commpool';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1995
 *       All rights reserved.
 *)
INCLUDE 'basicsocketbody';

--- BCPoolInit:dopart ---
do
   private.tcpConnections.init;
   private.tcpConnectionsMutex.V;
   INNER;


--- BCPoolLeaving:dopart ---
do
   (if priv.bsock[] // NONE then else
       priv.bsock.sem.V;
   if);
   INNER;


--- BCPoolCommunicationRemove:dopart ---
do
   private.tcpConnectionsMutex.P;
   L: private.tcpConnections.iterate
   (#
   do (if current.elm.sock[] // sock[] then
          (if current.elm.sem.tryP // true then
              current[]->private.tcpConnections.delete;
              leave L;
          if);
      if);
   #);
   private.tcpConnectionsMutex.V;


--- BCPoolCommunication:dopart ---
do
   (* Create or select a connection; sets up sock and priv.bsock *)
   addr[]->priv.selectConnection;
   INNER;
   leaving;


--- BCPoolCommunicationPrivate:descriptor ---
(#
   bsock: ^private.sharedSocket;

   selectConnection: @
     (* Sets up bsock and this(communication).sock. We have to do 
      * this during the operation instead of exiting bsock, because
      * the user must have access to bsock.sock via
      * this(communication).sock during error handling.
      *)
     (#
        addr: ^portableCommAddress;
        port_addr: ^portablePortAddress;
        tcp_addr: ^tcpPortAddress;
     enter addr[]
     do
        private.tcpConnectionsMutex.P;

        (* !!! Group handling not yet implemented *)
        (if addr## <= portablePortAddress## // true then
            addr[]->port_addr[];
         else
            addrHasUnknownType;
        if);

        (* !!! For now, just handles one special case: tcpPortAddress *)
        port_addr.getTcpPort->tcp_addr[];
        (if tcp_addr[] // NONE then
            addrHasUnknownType;
        if);

        NONE->bsock[];
        L: (if 1//1 then

               private.tcpConnections.scan
               (#
               do
                  (if current.sock.port=tcp_addr.portNo then

                      (if current.sock.inetAddr=tcp_addr.inetAddr then

                          (* Correct dest; check validity *)
                          (if current.invalid then
                              (* Invalid: skip this one *)
                           else
                              (if current.sem.tryP then
                                  (* Valid and available: take it *)
                                  current[]->bsock[];
                                  bsock.sock[]->this(communication).sock[];
                                  leave L;
                               else
                                  (* Not available: skip it *)
                              if);
                          if);
                      if);
                  if);
               #);

               (* Not found: create a new connection *)

               (* !!! This means we create a new socket every
                * time none is available. Sometimes we should
                * perhaps just wait for one to become available?
                *)
               
               &private.sharedSocket[]->bsock[];
               &socketType[]->bsock.sock[];
               tcp_addr.portNo->bsock.sock.port;
               tcp_addr.inetAddr->bsock.sock.inetAddr;
               bsock.sock[]->this(communication).sock[];

               private.tcpConnectionsMutex.V;
               bsock.sock.connect
               (#
                  localCleanup: @
                    (# previousCleanup: ^object;
                    do (if previousCleanup[] // NONE then
                           (* no action *)
                        else
                           previousCleanup
                       if);
                       bsock.sock.close;
                       true->bsock.invalid;
                       leaving;
                    #);
                  register: (# enter localCleanup.previousCleanup[] #);
                  timedOut::<
                    (# (* Not expected. The presence of this
                        * exception in 'connect' is actually
                        * a kind of abstraction overhead ..
                        *)
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).internalError
                         ->value;
                    #);
                  timedOutInTransfer::<
                    (# (* Not expected (etc) *)
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).internalError
                         ->value;
                    #);
                  internalError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).internalError
                         ->value;
                    #);
                  usageError::<
                    (# (* Becomes internal: communication should
                        * treat its sockets correctly when
                        * creating new connections!
                        *)
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).internalError
                         ->value;
                    #);
                  unknownError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).unknownError
                         ->value;
                    #);
                  accessError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).accessError
                         ->value;
                    #);
                  resourceError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).resourceError
                         ->value;
                    #);
                  addressError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).addressError
                         ->value;
                    #);
                  refusedError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).refusedError
                         ->value;
                    #);
                  intrError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).intrError
                         ->value;
                    #);
                  getHostError::<
                    (#
                    do cleanup[]->register;
                       (value,localCleanup[])
                         ->this(communication).getHostError
                         ->value;
                    #);
               #);
               private.tcpConnectionsMutex.P;

               (* Weed out existing connections on same OS-id (file
                * descriptor, in case of TCP/IP & UN*X):
                *
                * This indicates that the connection has died, and that the
                * OS is now reusing the given id.
                *)
               bsock.sock[]->private.markAsDead;

               (* Incorporate the new connection *)
               (* 'bsock.sem.P' done implicitly: semaphores start like that  *)
               bsock[]->private.tcpConnections.append;

               (* Clean up the pool *)
               private.killDeadConnections;

               (* Execute user hook *)
               private.tcpConnectionsMutex.V;
               (bsock.sock[],bsock[])->onNewConnection->bsock.actor[];
               private.tcpConnectionsMutex.P;
           if);

        (* test begin: tell user which connection was selected.
         *
         * (#
         *    addr: ^portablePortAddress;
         * do
         *    'connectionPoolBody.bet/selectConnection ' -> screen.puttext;
         *    bsock.sock.getPortableAddress->addr[];
         *    addr.asText->screen.putline;
         * #);
         *
         * test end *)

        private.tcpConnectionsMutex.V;

     exit bsock[]
     #);
#)


--- BCPoolMarkAsDead:dopart ---
do
   private.tcpConnectionsMutex.P;
   sock[]->private.markAsDead;
   private.tcpConnectionsMutex.V;

   
--- BCPoolRemoveSomeConnection:dopart ---
do
   (#
      lru_cell: ^private.tcpConnections.theCellType;
      lru_timestamp: @integer;
      other_timestamp: @integer;
      
      older: @booleanValue
        (# i1,i2: @integer;
        enter (i1,i2)
        do
           (* 0 is unknown - never used: certainly least-recently-used *)
           (if i1 // 0 then
               true->value;
            else
               (if i2 // 0 then
                   false->value;
                else
                   (* i1 and i2 both non-zero *)
                   (i1<i2)->value;
               if);
           if);
        #);
   do
      NONE->lru_cell[];
      0->lru_timestamp;
      
      private.tcpConnectionsMutex.P;
      private.tcpConnections.iterate
      (#
      do (if current.elm.invalid // false then
             
             (* This connection is valid *)
             (if current.elm.sem.tryP // true then
                 
                 (* Not currently being used in a communication *)
                 (if lru_cell[] // NONE then
                     
                     (* First candidate: taken *)
                     current[]->lru_cell[];
                     lru_cell.elm.sock.usageTimestamp->lru_timestamp;
                     
                  else
                     
                     (* Non-first candidate: compare *)
                     current.elm.sock.usageTimestamp->other_timestamp;
                     (if (other_timestamp,lru_timestamp)->older // true then
                         
                         (* It IS better, take it *)
                         lru_cell.elm.sem.V;
                         current[]->lru_cell[];
                         other_timestamp->lru_timestamp;
                         
                      else
                         
                         (* It`s not better, let it go *)
                         current.elm.sem.V;
                         
                     if);
                 if);
             if);
         if);
      #);
      private.tcpConnectionsMutex.V;
      
      (if lru_cell[] // NONE then
          
          (* No connections could be closed down *)
          noConnectionsRemovable;
          
       else
          
          (* lru_cell chosen *)
          private.tcpConnectionsMutex.P;
          lru_cell[]->private.tcpConnections.delete;
          private.tcpConnectionsMutex.V;
          lru_cell.elm.sock.close;
          
      if);
   #)

   
--- BCPoolClose:dopart ---
do
   INNER;
   private.tcpConnectionsMutex.P;
   private.tcpConnections.scan(# do current.sock.close; #);
   private.tcpConnectionsMutex.V;


--- BCPoolPrivate:descriptor ----
(#
   sharedSocket:
     (#
        sem: @semaphore;
        sock: ^socketType;
        invalid: @boolean; (* sock doesn`t represent a valid connection *)
        actor: ^|system; (* a process associated with this connection *)
     #);
   tcpConnections: @list(# element::< sharedSocket #);
   tcpConnectionsMutex: @semaphore;

   killDeadConnections: @tcpConnections.iterate
     (* Only use when tcpConnectionsMutex has been acquired *)
     (#
     do (if current.elm.invalid // true then
            current[]->tcpConnections.delete;
        if);
     #);

   markAsDead: @tcpConnections.scan
   (# sock: ^socketType;
   enter sock[]
   do (if current.sock[]->sock.sameConnection // true then
          true->current.invalid;
      if);
   #);
#)
