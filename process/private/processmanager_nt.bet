ORIGIN 'processmanagerbody';
LIB_ITEM 'processmanager';

(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

INCLUDE '~beta/basiclib/private/file_ntbody';
INCLUDE '~beta/sysutils/cstring';
INCLUDE 'commpipe_nt';

--- ProcessPrivate:descriptor ---
(#
   assignGuard: (# assigned: @Boolean do true -> assigned #);
   pid: @Integer;
   inputIndex, outputIndex, stderrIndex:
       @assignGuard (# rep: @Integer enter rep exit rep #);
   debug: (# do (if doDebug//true then inner if)#);
   (* debug: (# do inner #);  *)
   pipeIntoParent: @boolean;
   pipeErrIntoParent: @boolean;
   
   (* temporary items used within operations *)
   aPipe: ^pipe;
   readCh: ^readChannel;
   writeCh: ^writeChannel;
   _get_osfhandle: external
   (#
       filedescriptor, windowshandle: @integer;
       enter filedescriptor
       do CallC
       exit windowshandle
   #);
#)


--- ProcessStartMDBody:descriptor---
(# a,b,c: @Integer; 
   namestr, argstr: @CString;
do 
   (if not private.inputIndex.assigned then 0 -> private.inputIndex if);
   (if not private.outputIndex.assigned then 0 -> private.outputIndex if);
   (if not private.stderrIndex.assigned then 0 -> private.stderrIndex if);
   private.inputIndex -> a;
   private.outputIndex -> b;
   private.stderrIndex -> c;
   name[] -> namestr.set;
   argument.argument[] -> argstr.set;
   (namestr,argstr,a,b,c)
     -> startNtProcess -> private.pid;
   (if private.pid=-1 then
       'Failed to start process: ' -> name.prepend -> error;
   if);
   private.debug(# 
                do 'Starting process: '  -> screen.puttext;
                   name[] -> screen.puttext; ' ' -> screen.put;
                   argument.argument[] -> screen.putline;
                   'With input as: ' -> screen.puttext; 
                   private.InputIndex -> screen.putint; screen.newline;
                   'With output as: ' -> screen.puttext; 
                   private.outputIndex -> screen.putint; screen.newline;
                #);

   (* If the child process has a write handle which it uses to write to us
    * then we had better close our copy of that write handle, otherwise we
    * can't detect EOF
    *)
   (if private.pipeIntoParent then private.outputIndex->CloseHandle; if);
   (if private.pipeErrIntoParent then private.stderrIndex->CloseHandle; if);

   false -> private.inputIndex.assigned;
   false -> private.outputIndex.assigned;
   false -> private.stderrIndex.assigned;
   namestr.free;
   argstr.free;
#)


--- ProcessStopMDBody:descriptor ---
(#
do	
   (if ( private.pid -> &stopNtProcess)
    // -1 then 'could not stop the process' -> error
    if);
#)


--- ProcessAwaitStopped:dopart ---
do	
   (if stillRunning then
       (if (private.pid -> &awaitNotExecuting)
        // -1 then getErrno -> errorstring -> error;
        // 0  then (* exited *)
       if)
   if);
   INNER;

   
--- ProcessStillRunning:dopart ---
do (if (private.pid > 0) then
       (if (private.pid -> &stillExecuting)
        // -1 then 'stillRunning failed' -> error
        // 0  then false -> value
        // 1  then true -> value
       if);
    else
       false->value;
   if);
   INNER;
   

--- connectToProcess:dopart ---
(* send output to other process *)
do &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> toProcess.redirectFromChannel;
   private.aPipe.writeEnd[] -> redirectToChannel;
   INNER;

--- connectErrToProcess:dopart ---
(* send output to other process *)
do &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> toProcess.redirectFromChannel;
   private.aPipe.writeEnd[] -> redirectErrToChannel;
   INNER;

--- connectInPipe:dopart ---
(* get input from other process *)
do &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> redirectFromChannel;
   private.aPipe.writeEnd[] -> fromProcess.redirectToChannel;
   true -> private.pipeIntoParent;
   INNER;

   
--- redirectFromFile:dopart ---
(* (THIS(Process),inputFile) => inputFile > THIS(Process) *)
do inputFile.openRead;
   inputFile.private.index -> private._get_osfhandle ->
				THIS(Process).private.inputIndex;
   INNER;
   
--- redirectToFile:dopart ---
(* (THIS(Process),outputFile) => THIS(Process) > outputFile *)
do outputFile.openWrite;
   outputFile.private.index -> private._get_osfhandle ->
				THIS(Process).private.outputIndex;
      
--- redirectErrToFile:dopart ---
(* (THIS(Process),stderrFile) => THIS(Process) > outputFile *)
do outputFile.openWrite;
   outputFile.private.index -> private._get_osfhandle ->
				THIS(Process).private.stderrIndex;

--- redirectFromChannel:dopart ---
(* (THIS(Process),inputChannel) => 
 * Redirect the input to THIS(Process) from inputChannel.
 *)
do inputChannel[] -> private.readCh[];
   private.readCh.private.Index -> THIS(Process).private.inputIndex;
   INNER;
   
--- redirectToChannel:dopart ---
(* (THIS(Process),outputChannel) => 
 * Redirect the output from This(Process) to outputChannel.
 *)
do outputChannel[] -> private.writeCh[];
   private.writeCh.private.Index -> THIS(Process).private.outputIndex ;
   true -> private.pipeIntoParent;
   INNER;

--- redirectErrToChannel:dopart ---
(* (THIS(Process),outputChannel) => 
 * Redirect the stderr from This(Process) to outputChannel.
 *)
do outputChannel[] -> private.writeCh[];
   private.writeCh.private.Index -> THIS(Process).private.stderrIndex ;
   true -> private.pipeErrIntoParent;
   INNER;
   
--- ProcessManagerExceptionMDBody:descriptor ---
(# getErrno: external (# value: @Integer exit value #);
do getErrno -> errorstring -> msg.puttext;
#)

