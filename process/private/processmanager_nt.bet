ORIGIN 'processmanagerbody';
LIB_ITEM 'processmanager';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-97
 *       All rights reserved.
 *)

INCLUDE '~beta/basiclib/private/file_ntbody';
INCLUDE '~beta/sysutils/cstring';
INCLUDE 'commpipe_nt';

--- ProcessPrivate:descriptor ---
(#
   assignGuard: (# assigned: @Boolean do true -> assigned #);
   pid: @Integer;
   inputIndex, outputIndex: @assignGuard(# rep: @Integer enter rep exit rep #);
   debug: (# do (if doDebug//true then inner if)#);
   
   (* temporary items used within operations *)
   aPipe: ^pipe;
   readCh: ^readChannel;
   writeCh: ^writeChannel;
#)


--- ProcessStartMDBody:descriptor---
(# a,b: @Integer; 
   namestr, argstr: @CString;
do 
   (if not private.inputIndex.assigned then 0 -> private.inputIndex if);
   (if not private.outputIndex.assigned then 0 -> private.outputIndex if);
   private.inputIndex -> a;
   private.outputIndex -> b;
   name[] -> namestr.set;
   argument.argument[] -> argstr.set;
   (namestr,argstr,a,b)
     -> startNtProcess -> private.pid;
   (if private.pid // -1  then 'failed to start process ' -> error if);
   private.debug(# 
                do 'Starting process: '  -> screen.puttext;
                   name[] -> screen.puttext; ' ' -> screen.put;
                   argument.argument[] -> screen.putline;
                   'With input as: ' -> screen.puttext; 
                   private.InputIndex -> screen.putint; screen.newline;
                   'With output as: ' -> screen.puttext; 
                   private.outputIndex -> screen.putint; screen.newline;
                #);

   (* If the child process has a write handle which it uses to write to us
    * then we had better close our copy of that write handle, otherwise we
    * can't detect EOF
    *)
   (*(if private.pipeIntoParent then private.outputIndex->CloseHandle if);*)

   false -> private.inputIndex.assigned;
   false -> private.outputIndex.assigned;
   namestr.free;
   argstr.free;
#)


--- ProcessStopMDBody:descriptor ---
(#
do	
   (if ( private.pid -> &stopNtProcess)
    // -1 then 'could not stop the process' -> error
    if);
#)


--- ProcessAwaitStopped:dopart ---
do	
   (if stillRunning then
       (if (private.pid -> &awaitNotExecuting)
        // -1 then getErrno -> errorstring -> error;
        // 0  then (* exited *)
       if)
   if);
   INNER;

   
--- ProcessStillRunning:dopart ---
do (if (private.pid > 0) then
       (if (private.pid -> &stillExecuting)
        // -1 then 'stillRunning failed' -> error
        // 0  then false -> value
        // 1  then true -> value
       if);
    else
       false->value;
   if);
   INNER;
   

--- connectToProcess:dopart ---
(* send output to other process *)
do &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> toProcess.redirectFromChannel;
   private.aPipe.writeEnd[] -> redirectToChannel;
   INNER;


--- connectInPipe:dopart ---
(* get input from other process *)
do &Pipe[] -> private.aPipe[];
   private.aPipe.init;
   private.aPipe.readEnd[] -> redirectFromChannel;
   private.aPipe.writeEnd[] -> fromProcess.redirectToChannel;
   INNER;

   
--- redirectFromFile:dopart ---
(* (THIS(Process),inputFile) => inputFile > THIS(Process) *)
do (failureTrace, 'Input redirection not Implemented on NT/Win95') -> this(systemEnv).BetaEnvStop;
   
--- redirectToFile:dopart ---
(* (THIS(Process),outputFile) => THIS(Process) > outputFile *)
do (failureTrace, 'Output redirection not Implemented on NT/Win95') -> this(systemEnv).BetaEnvStop;
      
--- redirectFromChannel:dopart ---
(* (THIS(Process),inputChannel) => 
 * Redirect the input to THIS(Process) from inputChannel.
 *)
do inputChannel[] -> private.readCh[];
   private.readCh.private.Index -> THIS(Process).private.inputIndex;
   INNER;
   
--- redirectToChannel:dopart ---
(* (THIS(Process),outputChannel) => 
 * Redirect the output from This(Process) to outputChannel.
 *)
do outputChannel[] -> private.writeCh[];
   private.writeCh.private.Index -> THIS(Process).private.outputIndex ;
   INNER;
   
--- ProcessManagerExceptionMDBody:descriptor ---
(# getErrno: external (# value: @Integer exit value #);
do getErrno -> errorstring -> msg.puttext;
#)

