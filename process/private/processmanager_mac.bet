ORIGIN 'processmanagerbody';
LIB_ITEM 'processmanager';
INCLUDE '~beta/maclib/appleevents';
INCLUDE '~beta/maclib/files';
INCLUDE '~beta/maclib/signaturetoapp';
INCLUDE '~beta/containers/sets'

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-97
 *       All rights reserved.
 *)


-- lib: attributes --


FindRunningAppByPSN: external
	(# psn: ^ProcessSerialNumber;
		result: @integer;
	enter psn[]
	exit result
	#);


	
launchDontSwitch: (# exit 0x0200 #);
	
-- systemLib: attributes --



kAEScript: 		(# exit 0x73637074 #);
kAEMPSclass: 	(# exit 0x4D505320 #);
kAEoutp: 		(# exit 0x6F757470 #);
kAEdiag: 		(# exit 0x64696167 #);
kAEstat:		(# exit 0x73746174 #);
keyWho:			(# exit 0x77686F20 #);
keyWhat:		(# exit 0x77686174 #);


SendQuit:
	(# psn: ^ProcessSerialNumber;
		target: @AEAddressDesc;
		error: @integer;
		event, reply: @AppleEvent;
	enter psn[]
	do (target[], psn[]) -> makePSNTarget -> error;
		(if error = 0 then
			(event[], kCoreEventClass, kAEQuitApplication, target[]) -> makeAppleEvent -> error;
			(if error = 0 then
				(event[], reply[], kAEQueueReply) -> sendAppleEvent -> error;
				(if error <> 0 then
					('sending event', error) -> reportToolServerError;
				if);
			else
				('making event', error) -> reportToolServerError
			if);
		else
			('making target', error) -> reportToolServerError
		if);
	#);
	
makePSNTarget:
	(# target: ^AEAddressDesc;
		psn: ^ProcessSerialNumber;
		error: @integer;
	enter (target[], psn[])
	do (typeProcessSerialNumber, @@PSN.R[1], 8, target[]) -> AECreateDesc -> error;
	exit error
	#);
	
installAppleEvent:
	(# handler: ##AppleEventHandler;
		class, type: @integer;
		err: @integer;
	enter (class, type, handler##)
	do (class, type, handler##, 0, false) -> AEInstallEventHandler -> err;
	#);
reportToolServerError:
	(# what: ^text;
		error: @integer;
	enter (what[], error)
	do 'Error when communicating with toolserver:' -> putLine;
		'System error ' -> putText;
		(if error
			//-609 then
				'"connection invalid"' -> putText;
		else
			error -> putInt;
		if);
		', while ' -> putText;
		what[] -> putLine;
		(if error = -609 then
			'You probably need to launch the toolserver' -> putLine;
		if);
	#);
	
	
isScript:
	(# filename: ^Text;
	enter filename[]
	exit true
	#);

textType: (# exit 0x54455854 #);
applType: (# exit 0x4150504c #);

noneFile: (# exit 0 #);
scriptFile: (# exit 1 #);
applicationFile: (# exit 2 #);
otherFile: (# exit 3 #);

FileType: integerValue
      (* Decide if the file is a script file. 
       * We just check if it is a text file.
       *)
		(# fileName: ^text;
		   fs: @FSSpec;
			info: @FInfo;
			result: @integer;
		enter fileName[]
		do (0, 0, fileName, fs[]) -> FSMakeFSSpec -> result; 
		   (if result <> -43 then
				(fs[], info[]) -> FsPGetFInfo -> result;
				(if info.fdType
					//textType then
						scriptFile -> value;
					//applType then
						applicationFile -> value;	
				else
					otherFile -> value;
				if);
			else
				noneFile -> value;
			if);
		#);
makeTarget:
	(# target: ^AEAddressDesc;
		signature: @integer;
		error: @integer;
	enter (target[], signature)
	do (typeApplSignature, @@signature, 4, target[]) -> AECreateDesc -> error;
	exit error
	#);
makeAppleEvent:
	(# event: ^AppleEvent;
		class, ID: @integer;
		target: ^AEAddressDesc;
		error: @integer;
	enter (event[], class, ID, target[])
	do (class, ID, target[], kAutoGenerateReturnID, kAnyTransactionID, event[]) 
			-> AECreateAppleEvent 
			-> error;
	exit error
	#);
putDirectTextParameter:
	(# event: ^AppleEvent;
		param: ^text;
		error: @integer;
	enter (event[], param[])
	do (event[], keyDirectObject, typeChar, @@param.T[1], param.lgth)
			-> AEPutParamPtr
			-> error;
	exit error
	#);
getDirectTextParameter:
	(# event: ^AppleEvent;
		param: ^text;
		error: @integer;
		actualType, actualSize: @longInt;
	enter (event[], param[])
	do 1000 -> param.extend;
		(event[], keyDirectObject, typeChar, actualType[], @@param.T[1], 1000, actualSize[])
			-> AEGetParamPtr
			-> error;
		(if error = 0 then
			(actualSize, 1000) -> Min -> param.lgth -> param.pos;
		if);
	exit error
	#);
getTextParameter:
	(# event: ^AppleEvent;
		key: @integer;
		param: ^text;
		error: @integer;
		actualType, actualSize: @longInt;
	enter (event[], key, param[])
	do 1000 -> param.extend;
		(event[], key, typeChar, actualType[], @@param.T[1], 1000, actualSize[])
			-> AEGetParamPtr
			-> error;
		(if error = 0 then
			(1000, actualSize) -> Min -> param.lgth -> param.pos;
		if);
	exit error
	#);
sendAppleEvent:
	(# event, reply: ^AppleEvent;
		error: @integer;
		action: @integer;
	enter (event[], reply[], action)
	do (event[], reply[], action, kAENormalPriority, 36000, NIL, NIL) 
			-> AESend 
			-> error;
	exit error
	#);
toolserverSignature: (# exit 0x4D505358  #);

toolServer:
	(#  AEGetParamPtr: External
			  (# theAppleEvent: @integer;
			     theAEKeyword,desiredType,dataPtr,maximumSize: @Integer;
			     typeCode,actualSize: ^LongInt;
			     OSErr: @ShortInt;
			     
			  enter (theAppleEvent,theAEKeyword,desiredType,typeCode[],dataPtr,maximumSize,actualSize[])
			  do '{$303C,$0E11,$A816}'->PascalTrap; 
			  exit OSErr
			  #);
			  
		 running: @set
		   (# element:: process;
		   #);
		   
	     executeScript:
		   (# p: ^process;
		   enter p[]
		   do (# 
					target: @AEAddressDesc;
					event, reply: @AppleEvent;
					error: @integer;
					keyDiag: (# exit 0x64696167 #);
					command: ^text;
					actualType, actualSize: @longInt;
					returnID: @integer;
				do p.buildCommand -> command[];
					
					(target[], toolserverSignature) -> makeTarget -> error;
					(if error = 0 then
						(event[], kAEMPSclass, kAEScript, target[]) -> makeAppleEvent -> error;
						(if error = 0 then
							(event[], keyReturnIDAttr, typeInteger, actualType[], @@returnID, 4, actualSize[])
								-> AEGetAttributePtr
								-> error;
							(if error = 0 then
								returnID -> p.private.returnID;
								(event[], command[]) -> putDirectTextParameter -> error;
								(if error = 0 then
									p[] -> running.insert;
									true -> p.private.running;
									(event[], reply[], kAEQueueReply) -> sendAppleEvent -> error;
									(if error = 0 then
									else
										false -> p.private.running;
										0 -> p.private.returnID;
										p[] -> running.delete;
										('sending appleevent', error) -> reportToolServerError;
									if);
								else
									('adding arguments to appleevent', error) -> reportToolServerError;
								if);
							else
								('getting return id appleevent', error) -> reportToolServerError;
							if);
						else
							('creating appleevent', error) -> reportToolServerError;
						if);
					else
						('creating target specification', error) -> reportToolServerError;
					if);	
				#)
		   #);
		   
		   
		 handleOutput: appleEventHandler
			(# 
				returnedType, actualSize: @longInt;
				param: ^text;
				error: @integer;
			do (theAppleEvent, keyDirectObject, typeChar, returnedType[], 0, 0, actualSize[])
					-> AEGetParamPtr
					-> error;
				(if actualSize <> 0 then
					&text[] -> param[];
					actualSize -> param.extend;
					actualSize -> param.pos -> param.lgth;
					(theAppleEvent, keyDirectObject, typeChar, returnedType[], @@param.T[1], param.lgth, actualSize[])
						-> AEGetParamPtr
						-> error;
					param[] -> putText;
				if);
			#);
		handleAnswer: appleEventHandler
			(# returnedType, actualSize: @longInt;
				returnID: @integer;
				error: @integer;
				AEGetAttributePtr: External
				  (# theAppleEvent: @integer;
					 theAEKeyword,desiredType,dataPtr,maximumSize: @Integer;
					 typeCode,actualSize: ^LongInt;
					 OSErr: @ShortInt;
					 
				  enter (theAppleEvent,theAEKeyword,desiredType,typeCode[],dataPtr,maximumSize,actualSize[])
				  do '{$303C,$0E15,$A816}'->PascalTrap; 
				  exit OSErr
				  #);
				p: ^process;
			do 
				(theAppleEvent, keyReturnIDAttr, typeInteger, returnedType[], @@returnID, 4, actualSize[])
							-> AEGetAttributePtr
							-> error;
				search: running.scan
				(#
				do (if current.private.returnID = returnID then
					  current[] -> p[];
					  leave search;
					if);
				#);
				(if p[] <> NONE then
					p[] -> running.delete;
					false -> p.private.running;
					0 -> p.private.returnID;
				if);
			#);
		
		
		toolServerSignature: (# exit 0x4D505358 #);
		psn: @ProcessSerialNumber;
		
		EnsureToolserver:
			(* Verify that the toolserver is running - start it, if not *)
			(# err: @integer;
			do (toolServerSignature, NONE, PSN[], NONE, NONE, Sig2App_LaunchApplication, launchContinue + launchDontSwitch) -> SignatureToApp -> err;
			exit err
			#);
		init:
			(#
			do (kAEMPSclass, kAEoutp, handleOutput##) -> installAppleEvent;
			   (kAEMPSclass, kAEdiag, handleOutput##) -> installAppleEvent;
			   (kCoreEventClass, kAEAnswer, handleAnswer##) -> installAppleEvent;
			   running.init;
			#);
	#);
getToolServer: objectPool.get
	(# type:: toolServer;
	   init:: (# do obj.init #);
	#);
	
	
-- processLib: attributes --

GiveTime:
	(# result: @boolean;
		err: @integer;
	do (everyEvent, private.event.event[], 2, 0) -> WaitNextEvent -> result;
		(if private.event.what
			//kHighLevelEvent then
				private.event.event[] -> AEProcessAppleEvent -> err; 
		if);
	#);
	
buildCommand:
  (#  command: ^text;
  do &text[] -> command[];
  	 '\'' -> command.put;
	name.copy -> command.putText;
	'\'' -> command.put;
	argument.scanArguments
	(#
	do ' "' -> command.putText;
		current[] -> command.putText;
		'"' -> command.put;
	#);
  exit command[]
  #);
--- ProcessPrivate:descriptor ---
(# returnID: @integer;
   running: @boolean;
	application: @boolean;
	psn: @ProcessSerialNumber;
	event: @EventInterface;
#)


--- ProcessStartMDBody:descriptor---
(# 
	startScript:
		(# tool: ^toolServer;
			err: @integer;
		do	getToolServer -> tool[];
			tool.ensureToolServer -> err;
			(if err = 0 then
				this(process)[] -> tool.executeScript;
			else
				error;
			if);
		#);
	startScript1:
		(* The script file is exuted by sending an
		 * appleevent to the tool-server.
		 *)
		(# command: @text;
		do 
			'\'' -> command.put;
			name.copy -> command.putText;
			'\'' -> command.put;
			argument.scanArguments
			(#
			do ' "' -> command.putText;
				current[] -> command.putText;
				'"' -> command.put;
			#);
			
		   (# 
				target: @AEAddressDesc;
				event, reply: @AppleEvent;
				error: @integer;
				keyDiag: (# exit 0x64696167 #);
				tool: ^toolServer;
			do getToolServer -> tool[];
				tool.ensureToolServer -> error;
				(if error = 0 then
					(target[], toolserverSignature) -> makeTarget -> error;
					(if error = 0 then
						(event[], kAEMPSclass, kAEScript, target[]) -> makeAppleEvent -> error;
						(if error = 0 then
							(event[], command[]) -> putDirectTextParameter -> error;
							(if error = 0 then
								(event[], reply[], kAEQueueReply) -> sendAppleEvent -> error;
								(if error = 0 then
								else
									('sending appleevent', error) -> reportToolServerError;
								if);
							else
								('adding arguments to appleevent', error) -> reportToolServerError;
							if);
						else
							('creating appleevent', error) -> reportToolServerError;
						if);
					else
						('creating target specification', error) -> reportToolServerError;
					if);	
				else
					('launching toolserver', error) -> reportToolServerError;
				if);
			#)
		#);
		
		
	
		
	launchProcess: external
		(* Defined in systemenvExt.c in basiclib *)
		(# name: [1] @char;
			psn: ^ProcessSerialNumber;
			status: @integer;
		enter (name, psn[])
		exit status
		#);
	startApplication:
		(# err: @integer;
		do (name, private.psn[]) -> launchProcess -> err;
			(if err = -1 then
				error;
			else
				'process: ' -> puttext;
				private.psn.highLongOfPSN -> putint;
				' ' -> put;
				private.psn.lowLongOfPSN -> putint;
				newline;
				true -> private.running;
			if);
		#);
		
	
do (if name[] -> FileType
		//scriptFile then
			false -> private.application;
			startScript;
		//applicationFile then
			true -> private.application;
			startApplication;
	if);


#)


--- ProcessStopMDBody:descriptor ---
(#
do 
	(if private.application then
			private.psn[] -> SendQuit;
	if);
#)


--- ProcessAwaitStopped:dopart ---
do (if private.application then
		wait: (if stillRunning then restart wait if);
   	onStop;
	else
		
		wait: (if stillRunning then GiveTime; restart wait if);
   	onStop;
	if);

   
--- ProcessStillRunning:dopart ---
do (if private.application then
		(# result: @integer;
		do private.psn[] -> FindRunningAppByPSN -> result;
			(if result = 1 then
				true -> value;
				GiveTime;
			else
				false -> value;
			if);
		#);
	else
		private.running -> value;
		(***
		(# target: @AEAddressDesc;
			event, reply: @AppleEvent;
			error: @integer;
			keyDiag: (# exit 0x64696167 #);
			who: ^text;
		do getToolServer;
			(target[], toolserverSignature) -> makeTarget -> error;
			(if error = 0 then
				(event[], kAEMPSclass, kAEstat, target[]) -> makeAppleEvent -> error;
				(if error = 0 then
					(event[], reply[], kAEWaitReply) -> sendAppleEvent -> error;
					(if error = 0 then
						&text[] -> who[];
						(reply[], keyWho, who[]) -> getTextParameter -> error;
						who[] -> putline;
						(if error <> 0 then
							('reading the who parameter', error) -> reportToolServerError;
						if);
					else
						('sending appleevent', error) -> reportToolServerError;
					if);
				else
					('creating appleevent', error) -> reportToolServerError;
				if);
			else
				('creating target specification', error) -> reportToolServerError;
			if);	
		#);
		***)
	if);
   INNER;
   
--- connectToProcess:dopart ---
(* send output to other process *)
do  'connectToProcess:dopart' -> putLine;

--- connectErrToProcess:dopart ---
(* send output to other process *)
do  'connectErrToProcess:dopart' -> putLine;

--- connectInPipe:dopart ---
(* get input from other process *)
do  'connectInPipe:dopart' -> putLine;
   
--- redirectFromFile:dopart ---
(* (THIS(Process),inputFile) => inputFile > THIS(Process) *)
do 'redirectFromFile:dopart' -> putLine;
   
--- redirectToFile:dopart ---
(* (THIS(Process),outputFile) => THIS(Process) > outputFile *)
do 'redirectToFile:dopart' -> putLine;

--- redirectErrToFile:dopart ---
(* (THIS(Process),outputFile) => THIS(Process) > outputFile *)
do 'redirectErrToFile:dopart' -> putLine;
      
--- redirectFromChannel:dopart ---
(* (THIS(Process),inputChannel) => 
 * Redirect the input to THIS(Process) from inputChannel.
 *)
do 'redirectFromChannel:dopart' -> putLine;
   
--- redirectToChannel:dopart ---
(* (THIS(Process),outputChannel) => 
 * Redirect the output from This(Process) to outputChannel.
 *)
do 'redirectToChannel:dopart' -> putLine;

--- redirectErrToChannel:dopart ---
(* (THIS(Process),outputChannel) => 
 * Redirect the output from This(Process) to outputChannel.
 *)
do 'redirectErrToChannel:dopart' -> putLine;
   
--- ProcessManagerExceptionMDBody:descriptor ---
(# 
do 
#)

