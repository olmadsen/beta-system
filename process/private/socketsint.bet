ORIGIN '~beta/basiclib/v1.5/betaenv';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1995
 *       All rights reserved.
 *)
--- lib:attributes ---

initSockets: external
  (#
  do 'initSockets' -> callC
  #);

Errno: external
  (# err: @integer;
  do 'Errno' -> callC
  exit err
  #);

host2inetAddr: external
  (* Find the internet address (in binary format) of the 
   * host named 'host'. In case of failure, -1 is exited. 
   *)
  (# host: [1]@char;
     inetAddr: @integer;
  enter host
  do 'host2inetAddr' -> callC
  exit inetAddr
  #);

nameOfThisHost: external
  (# pointerToErrorCode: @integer;
     hostname: [1]@char;
  enter pointerToErrorCode
  do 'nameOfThisHost' -> callC
  exit hostname
  #);

inetAddrOfThisHost: external (* NOT 'localhost', ie. 127.0.0.1!  *)
  (# inetAddr: @integer;
  do 'inetAddrOfThisHost' -> callC
  exit inetAddr
  #);

selectReadable: external
  (# fd: @integer;
     readable: @integer;
  enter fd
  do 'selectReadable'->callC
  exit readable
  #);

getTimeStamp: external
  (# fd: @integer;
     timestamp: @integer;
  enter fd
  do 'getTimeStamp'->callC
  exit timestamp
  #);

createActiveSocket: External
  (* Open a socket connection to "port" on "host".
   * The resulting socket is returned by "index"
   *)
  (# inetAddr: @integer;
     port: @integer;
     nonblock: @Integer;
     index: @integer; (* -1 => error *)
  enter(inetAddr,port,nonblock)
  do 'createActiveSocket' -> callC
  exit index
  #);

createPassiveSocket: external
  (# pointerToPortNumber: @integer;
     nonblock: @Integer;
     fd: @integer;
  enter (pointerToPortNumber,nonblock)
  do 'createPassiveSocket' -> callC;
  exit fd
  #);

acceptConn: External
  (# listenIndex: @integer;
     pointerToBlocked: @integer; (* Blocked is set to 1 iff op. blocked *)
     talkIndex: @integer; (* -1 => error *)
     pointerToInetAddr: @integer;
  enter (listenIndex,pointerToBlocked,pointerToInetAddr)
  do 'acceptConn' -> callC
  exit talkIndex
  #);

sockToRead: external
  (* Returns the number of bytes immediately readable from the
   * socket with file descriptor fd.
   *)
  (# fd,result: @integer;
  enter fd
  do 'sockToRead' -> callC
  exit result
  #);

closeSocket: external
  (# fd,result: @integer;
  enter fd
  do 'closeSocket' -> callC
  exit result
  #);

doReadDataMax: external
  (* Returns number of bytes read. If 0, no data was available.
   * In case of error, returns -1.
   *)
  (# fd,destbuffer,wanted,result: @integer;
  enter (fd,destbuffer,wanted)
  do 'readDataMax' -> callC
  exit result
  #);

doWriteDataMax: external
  (* Returns number of bytes written. If 0, a buffer full condition
   * was found on first try. In case of error, returns -1.
   *)
  (# fd,srcbuffer,length,result: @integer;
  enter (fd,srcbuffer,length)
  do 'writeDataMax' -> callC
  exit result
  #);

doshutdown: external
  (* Requests the socket to shudown in a controlled way, flushing buffers
   * first.
   *)
  (# index,how,result: @integer;
  enter (index,how)
  do 'doshutdown' -> callC;
  exit result
  #);

