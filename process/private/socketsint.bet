ORIGIN '~beta/basiclib/v1.5/betaenv';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1995
 *       All rights reserved.
 *)
BUILD default '$$/sockets.o' 'external/sockets.c'
	      'external/arch.h' 'external/sockSignals.h'
	      '$CC -D$$ -c -o $0 $1'
      nti     '$$/sockets.obj' 'external/sockets.c'
	      'external/arch.h' 'external/sockSignals.h'
	      'betacc $0 $1';
BUILD default '$$/sockSignals.o' 'external/sockSignals.c' 'external/arch.h'
	      '$CC -D$$ -c -o $0 $1'
      nti     '$$/sockSignals.obj' 'external/sockSignals.c' 'external/arch.h'
	      'betacc $0 $1';

--- lib:attributes ---

initSockets: external
  (#
  do 'initSockets' -> callC
  #);

Errno: external
  (# err: @integer;
  do 'Errno' -> callC
  exit err
  #);

host2inetAddr: external
  (* Find the internet address (in binary format) of the 
   * host named 'host'. In case of failure, -1 is exited. 
   *)
  (# host: [1]@char;
     inetAddr: @integer;
  enter host
  do 'host2inetAddr' -> callC
  exit inetAddr
  #);

nameOfThisHost: external
  (# pointerToErrorCode: @integer;
     hostname: [1]@char;
  enter pointerToErrorCode
  do 'nameOfThisHost' -> callC
  exit hostname
  #);

inetAddrOfThisHost: external (* NOT! 'localhost', ie. 127.0.0.1. *)
  (# inetAddr: @integer;
  do 'inetAddrOfThisHost' -> callC
  exit inetAddr
  #);

selectReadable: external
  (# fd: @integer;
     readable: @integer;
  enter fd
  do 'selectReadable'->callC
  exit readable
  #);

getTimeStamp: external
  (# fd: @integer;
     timestamp: @integer;
  enter fd
  do 'getTimeStamp'->callC
  exit timestamp
  #);

createActiveSocket: External
  (* Open a socket connection to "port" on "host".
   * The resulting socket is returned by "index"
   *)
  (# inetAddr: @integer;
     port: @integer;
     index: @integer; (* -1 => error *)
  enter(inetAddr,port)
  do 'createActiveSocket' -> callC
  exit index
  #);

createPassiveSocket: external
  (# pointerToPortNumber: @integer;
     fd: @integer;
  enter pointerToPortNumber
  do 'createPassiveSocket' -> callC;
  exit fd
  #);

acceptConn: External
  (# listenIndex: @integer;
     pointerToBlocked: @integer; (* Blocked is set to 1 iff op. blocked *)
     talkIndex: @integer; (* -1 => error *)
     pointerToInetAddr: @integer;
  enter (listenIndex,pointerToBlocked,pointerToInetAddr)
  do 'acceptConn' -> callC
  exit talkIndex
  #);

sockToRead: external
  (* Returns the number of bytes immediately readable from the
   * socket with file descriptor fd.
   *)
  (# fd,result: @integer;
  enter fd
  do 'sockToRead' -> callC
  exit result
  #);

(* removed, as the create-calls above do this themselves...
 *
 * makeNonblocking: external
 *   {* Make the socket with file descriptor 'index' 
 *    *  POSIX-style non-blocking. 
 *    *}   
 *   (# index,result: @integer;
 *   enter index
 *   do 'makeNonblocking' -> callC
 *   exit result
 *   #);
 * 
 * makePassiveNonblocking: external
 *   {* Prepare the passive socket with file descriptor 'index' for
 *    * accepting connections in a non-blocking manner. NOTE: this is
 *    * part of the BSD4.2 non-blocking behaviour. Don't do a
 *    * 'makeNonblocking' on the same socket.
 *    *}
 *   (# index,result: @integer;
 *   enter index
 *   do 'makePassiveNonblocking' -> callC
 *   exit result
 *   #);
 *)

closeSocket: external
  (# fd,result: @integer;
  enter fd
  do 'closeSocket' -> callC
  exit result
  #);

doReadDataMax: external
  (* Returns number of bytes read. If 0, no data was available.
   * In case of error, returns -1.
   *)
  (# fd,destbuffer,wanted,result: @integer;
  enter (fd,destbuffer,wanted)
  do 'readDataMax' -> callC
  exit result
  #);

doWriteDataMax: external
  (* Returns number of bytes written. If 0, a buffer full condition
   * was found on first try. In case of error, returns -1.
   *)
  (# fd,srcbuffer,length,result: @integer;
  enter (fd,srcbuffer,length)
  do 'writeDataMax' -> callC
  exit result
  #);
