ORIGIN 'systemComm_unixbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994
 *       All rights reserved.
 *)
[[
--- include '~beta/unixlib/v1.4/unixinterface'
--- include '~beta/unixlib/v1.4/unixerrno'

--- BSocketPrivate:descriptor ---
(#
   index: @assignGuard(# rep: @integer; enter rep exit rep #);
   lastReadLength: @integer;
   untryPatVar: ##Object;
   ios: @IOstate;
   timeHnd: @timeHandler;
   timerRunning: @boolean;
   timerID: @integer;
   errorCB: ##ErrCB;

   init: (# do initSockets; index -> ios.init; timeHnd.init; #);

   onTimeOut: @(# do ios.timeOut #);

   timerStart: @
     (# timeout: @integer;
     enter timeout
     do
        (if timeout // waitForever then
            (* Noop *)
         else
            (onTimeOut[],timeout)->timeHnd.register->timerId;
            true->timerRunning;
        if);
     #);

   timerStop: @
     (#
     do
        (if timerRunning // true then
            false->timerRunning;
            timerId -> timeHnd.unregister;
        if);
     #);

   forcedTimeout: @boolean;

   readBlock: @
     (# timedOut: @boolean;
     do (if forcedTimeout // true then
            true->timedOut;
         else
            ios.readBlock->timedOut;
        if);
        false->forcedTimeout;
     exit timedOut
     #);

   writeBlock: @
     (# timedOut: @boolean;
     do (if forcedTimeout // true then
            true->timedOut;
         else
            ios.writeBlock->timedOut;
        if);
        false->forcedTimeout;
     exit timedOut
     #);
#)

--- BSocketSameConnection:dopart ---
do
   (private.index=other.private.index)->value;

--- BSocketGetPortableAddress:descriptor ---
(#
   tcp_addr: ^tcpPortAddress;
do
   &portablePortAddress[]->addr[];
   &tcpPortAddress[]->tcp_addr[]->addr.insert;
   inetAddr->tcp_addr.inetAddr;
   port->tcp_addr.portNo;
#)

--- BSocketOpen:descriptor ---
(#
   uerr: @usageError;
do
   INNER open;
   L: (if private.index.assigned // false then
          'Can not open a socket with unassigned index' -> uerr.addMsg;
          (if uerr
           // errCB_abortOperation then
              leave L;
           // errCB_continueOperation then
              (* User _could_ have done the assignment by now *)
              restart L;
           else
              unexpected_error;
          if);
      if);
#)

--- BSocketClose:descriptor ---
(#
do
   INNER close;
   (private.index,2) -> shutdown; (* 2: read & write *)
   private.index->closeFileDescriptor;
   (* no error checks: we must be able to close after error *)
#)

--- BSocketForceTimeout:descriptor ---
(#
do true->private.forcedTimeout;
   private.ios.timeout;
   INNER forceTimeout;
#)

--- BSocketUsageTimestamp:dopart ---
do
   private.index->getTimeStamp->value;
   INNER usageTimestamp;

--- BSocketEndOfData:descriptor ---
(#
   result: @integer;
do
   L: (if (private.index -> sockToRead -> result) // -1 then

          (* Classify error *)
          (if Errno

           (* From ioctl() *)
           // cdef_EBADF then connBrokenError##->private.errorCB##;
           // cdef_EFAULT
           // cdef_EINVAL
           // cdef_ENOTTY then internalError##->private.errorCB##;
           else
              unknownError##->private.errorCB##;
          if);

          (* Invoke selected error callback *)
          (if &private.errorCB
           // errCB_abortOperation then
              leave L;
           // errCB_continueOperation then
              restart L;
           else
              unexpected_error;
          if);

       else
          (result>0) -> value;
      if);
#)

--- BSocketPutRep:descriptor ---
(#
   writeErrClassify:
     (#
     do
        (* Classify error *)
        (if Errno

         (* From write() *)
         // cdef_EBADF (* probably end-of-client *)
         // cdef_ENXIO (* hangup - also indicates end-of-client *)
         // cdef_EPIPE then connBrokenError##->private.errorCB##;
         // cdef_EFAULT
         // cdef_EINVAL then internalError##->private.errorCB##;
         // cdef_ERANGE then resourceError##->private.errorCB##;
         else
            unknownError##->private.errorCB##;
        if);
     #);
   done,				(* Total bytes sent *)
   todo,				(* How many more to send *)
   delta: @integer;			(* How many sent this time *)
do
   timeout -> private.timerStart;

   (4,0)->(todo,done);
   L: (if ((private.index,@@rep.lgth+done,todo)->doWriteDataMax->delta)

       //-1 then

          writeErrClassify;

          (* Invoke selected error callback *)
          (if private.timerStop[]->&private.errorCB
           // errCB_abortOperation then
              leave L;
           // errCB_continueOperation then
              restart L;
           else
              unexpected_error;
          if);

       //0 then

          Blocking;
          (if private.ios.writeBlock // true then
              (if timedOut
               // errCB_abortOperation then
                  leave L;
               // errCB_continueOperation then
                  timeout -> private.timerStart;
                  restart L;
               else
                  unexpected_error;
              if);
          if);
          restart L;

       else

          (if delta<todo // true then
              done+delta -> done;
              todo-delta -> todo;
              Idle;
              (if private.ios.writeBlock // true then
                  (if timedOutInTransfer
                   // errCB_abortOperation then
                      leave L;
                   // errCB_continueOperation then
                      timeout -> private.timerStart;
                      restart L;
                   else
                      unexpected_error;
                  if);
               else
                  restart L;
              if);
          if);

          (4,0)->(todo,done);
          L2: (if ((private.index,@@header+done,todo)->doWriteDataMax->delta)

               //-1 then

                  writeErrClassify;

                  (* Invoke selected error callback *)
                  (if private.timerStop[]->&private.errorCB
                   // errCB_abortOperation then
                      leave L;
                   // errCB_continueOperation then
                      restart L2;
                   else
                      unexpected_error;
                  if);

               //0 then

                  Idle;
                  (if private.ios.writeBlock // true then
                      (if timedOutInTransfer
                       // errCB_abortOperation then
                          leave L;
                       // errCB_continueOperation then
                          timeout -> private.timerStart;
                          restart L2;
                       else
                          unexpected_error;
                      if);
                  if);
                  restart L2;

               else

                  (if delta<todo // true then
                      done+delta -> done;
                      todo-delta -> todo;
                      Idle;
                      (if private.ios.writeBlock // true then
                          (if timedOutInTransfer
                           // errCB_abortOperation then
                              leave L;
                           // errCB_continueOperation then
                              timeout -> private.timerStart;
                              restart L2;
                           else
                              unexpected_error;
                          if);
                       else
                          restart L2;
                      if);
                  if);

                  (if rep.length//0 then
                      private.timerStop;
                      leave L;
                  if);

                  (rep.lgth*4,0) -> (todo,done);
                  L3: (if ((private.index,@@rep.r[1]+done,todo)
                            ->doWriteDataMax->delta)

                       //-1 then

                          writeErrClassify;

                          (* Invoke selected error callback *)
                          (if private.timerStop[]->&private.errorCB
                           // errCB_abortOperation then
                              leave L;
                           // errCB_continueOperation then
                              restart L3;
                           else
                              unexpected_error;
                          if);

                       //0 then

                          Idle;
                          (if private.ios.writeBlock // true then
                              (if timedOutInTransfer
                               // errCB_abortOperation then
                                  leave L;
                               // errCB_continueOperation then
                                  timeout -> private.timerStart;
                                  restart L3;
                               else
                                  unexpected_error;
                              if);
                          if);
                          restart L3;

                       else

                          (if delta<todo // true then
                              done+delta -> done;
                              todo-delta -> todo;
                              Idle;
                              (if private.ios.writeBlock // true then
                                  (if timedOutInTransfer
                                   // errCB_abortOperation then
                                      leave L;
                                   // errCB_continueOperation then
                                      timeout -> private.timerStart;
                                      restart L3;
                                   else
                                      unexpected_error;
                                  if);
                              if);
                              restart L3;
                           else
                              (* That`s it *)
                              private.timerStop;
                          if);

                      if);
              if);
      if);
#)

--- BSocketGetRep:descriptor ---
(#
   readErrClassify:
     (#
     do
        (* Classify error *)
        (if Errno

         (* From waitForIO() *)
         // cdef_EBADF then connBrokenError##->private.errorCB##;
         // cdef_EFAULT
         // cdef_EINVAL then internalError##->private.errorCB##;

         (* From read() *)
         // cdef_EBADF (* probably end-of-client *)
         // cdef_ENXIO (* hangup - also indicates end-of-client *)
         // cdef_EPIPE then connBrokenError##->private.errorCB##;
         // cdef_EBADMSG then badMsgError##->private.errorCB##;
         // cdef_EISDIR then internalError##->private.errorCB##;
         // cdef_ERANGE then resourceError##->private.errorCB##;

         (* End-of-file symptoms = peer closed down *)
         // cdef_ENOTCONN then connBrokenError##->private.errorCB##;

         else
            unknownError##->private.errorCB##;
        if);
     #);
   done,				(* Total bytes received *)
   todo,				(* How many more to receive *)
   delta,				(* How many received this time *)
   length: @integer;
do
   timeout -> private.timerStart;

   L:
     (if 1//1 then

         (* Get length field *)
         (4,0)->(todo,done);
         L1: (if ((private.index,@@length+done,todo)->doReadDataMax->delta)

              //-1 then

                 readErrClassify;

                 (* Invoke selected error callback *)
                 (if private.timerStop[]->&private.errorCB
                  // errCB_abortOperation then
                     leave L;
                  // errCB_continueOperation then
                     restart L1;
                  else
                     unexpected_error;
                 if);

              //0 then

                 Blocking;
                 (if private.readBlock // true then
                     (if timedOut
                      // errCB_abortOperation then
                         leave L;
                      // errCB_continueOperation then
                         timeout -> private.timerStart;
                         restart L1;
                      else
                         unexpected_error;
                     if);
                 if);
                 restart L1;

              else

                 (if delta<todo // true then
                     done+delta -> done;
                     todo-delta -> todo;
                     Idle;
                     (if private.readBlock // true then
                         (if timedOutInTransfer
                          // errCB_abortOperation then
                             leave L;
                          // errCB_continueOperation then
                             timeout -> private.timerStart;
                             restart L1;
                          else
                             unexpected_error;
                         if);
                      else
                         restart L1;
                     if);
                  else
                     length->private.lastReadLength;
                 if);

             if);

         (if (length>rep.r.range) // true then
             length-rep.r.range->rep.r.extend;
         if);

         (4,0)->(todo,done);
         L2: (if ((private.index,@@header+done,todo)->doReadDataMax->delta)

              //-1 then

                 readErrClassify;

                 (* Invoke selected error callback *)
                 (if private.timerStop[]->&private.errorCB
                  // errCB_abortOperation then
                     leave L;
                  // errCB_continueOperation then
                     restart L2;
                  else
                     unexpected_error;
                 if);

              //0 then

                 Idle;
                 (if private.readBlock // true then
                     (if timedOutInTransfer
                      // errCB_abortOperation then
                         leave L;
                      // errCB_continueOperation then
                         timeout -> private.timerStart;
                         restart L2;
                      else
                         unexpected_error;
                     if);
                 if);
                 restart L2;

              else

                 (if delta<todo // true then
                     done+delta -> done;
                     todo-delta -> todo;
                     Idle;
                     (if private.readBlock // true then
                         (if timedOutInTransfer
                          // errCB_abortOperation then
                             leave L;
                          // errCB_continueOperation then
                             timeout -> private.timerStart;
                             restart L2;
                          else
                             unexpected_error;
                         if);
                      else
                         restart L2;
                     if);
                 if);

                 (if private.lastReadLength // 0 then
                     private.timerStop;
                     leave L2;
                 if);

                 (private.lastReadLength*4,0) -> (todo,done);
                 L3: (if ((private.index,@@rep.r[1]+done,todo)
                           ->doReadDataMax->delta)

                      //-1 then

                         readErrClassify;

                         (* Invoke selected error callback *)
                         (if private.timerStop[]->&private.errorCB
                          // errCB_abortOperation then
                             leave L;
                          // errCB_continueOperation then
                             restart L3;
                          else
                             unexpected_error;
                         if);

                      //0 then

                         Idle;
                         (if private.readBlock // true then
                             (if timedOutInTransfer
                              // errCB_abortOperation then
                                 leave L;
                              // errCB_continueOperation then
                                 timeout -> private.timerStart;
                                 restart L3;
                              else
                                 unexpected_error;
                             if);
                         if);
                         restart L3;

                      else

                         (if delta<todo // true then
                             done+delta -> done;
                             todo-delta -> todo;
                             Idle;
                             (if private.readBlock // true then
                                 (if timedOutInTransfer
                                  // errCB_abortOperation then
                                     leave L;
                                  // errCB_continueOperation then
                                     timeout -> private.timerStart;
                                     restart L3;
                                  else
                                     unexpected_error;
                                 if);
                             if);
                             restart L3;
                          else
                             (* That`s it *)
                             private.timerStop;
                         if);

                     if);
             if);

         length->rep.lgth; (* Announce how much data received *)
         rep.reset; (* Prepare 'rep' for reading from the beginning *)
      if);
#)

--- BSocketPutRepObj:descriptor ---
(#
   writeErrClassify:
     (#
     do
        (* Classify error *)
        (if Errno

         (* From write() *)
         // cdef_EBADF (* probably end-of-client *)
         // cdef_ENXIO (* hangup - also indicates end-of-client *)
         // cdef_EPIPE then connBrokenError##->private.errorCB##;
         // cdef_EFAULT
         // cdef_EINVAL then internalError##->private.errorCB##;
         // cdef_ERANGE then resourceError##->private.errorCB##;
         else
            unknownError##->private.errorCB##;
        if);
     #);
   zero,done,todo,delta: @integer;
do
   timeout -> private.timerStart;
   rep.size*4 -> todo;

   L: (if (todo<=0) // true then

          (* Empty or bad RepetitionObject: by convention send "0" *)
          (0,4,0) -> (zero,todo,done);
          L1: (if ((private.index,@@zero+done,todo)->doWriteDataMax->delta)

               //-1 then

                  writeErrClassify;

                  (* Invoke selected error callback *)
                  (if private.timerStop[]->&private.errorCB
                   // errCB_abortOperation then
                      leave L;
                   // errCB_continueOperation then
                      restart L1;
                   else
                      unexpected_error;
                  if);

               //0 then

                  Blocking;
                  (if private.ios.writeBlock // true then
                      (if timedOut
                       // errCB_abortOperation then
                          leave L;
                       // errCB_continueOperation then
                          restart L1;
                       else
                          unexpected_error;
                      if);
                  if);
                  restart L1;

               else

                  (if delta<todo // true then
                      done+delta -> done;
                      todo-delta -> todo;
                      Idle;
                      (if private.ios.writeBlock // true then
                          (if timedOutInTransfer
                           // errCB_abortOperation then
                              leave L;
                           // errCB_continueOperation then
                              timeout -> private.timerStart;
                              restart L1;
                           else
                              unexpected_error;
                          if);
                       else
                          restart L1;
                      if);
                  if);

              if);
       else

          (* Non-empty RepetitionObject *)
          0 -> done;
          L2: (if ((private.index,@@rep.r[1]+done,todo)->doWriteDataMax->delta)

               //-1 then

                  writeErrClassify;

                  (* Invoke selected error callback *)
                  (if private.timerStop[]->&private.errorCB
                   // errCB_abortOperation then
                      leave L;
                   // errCB_continueOperation then
                      restart L2;
                   else
                      unexpected_error;
                  if);

               //0 then

                  Blocking;
                  (if private.ios.writeBlock // true then
                      (if timedOut
                       // errCB_abortOperation then
                          leave L;
                       // errCB_continueOperation then
                          timeout -> private.timerStart;
                          restart L2;
                       else
                          unexpected_error;
                      if);
                  if);
                  restart L2;

               else

                  (if delta<todo // true then
                      done+delta -> done;
                      todo-delta -> todo;
                      Idle;
                      (if private.ios.writeBlock // true then
                          (if timedOutIntransfer
                           // errCB_abortOperation then
                              leave L;
                           // errCB_continueOperation then
                              timeout -> private.timerStart;
                              restart L2;
                           else
                              unexpected_error;
                          if);
                      if);
                      restart L2;
                   else
                      (* That`s it *)
                      private.timerStop;
                  if);

              if);
      if);
#)

--- BSocketGetRepObj:descriptor ---
(#
   readErrClassify:
     (#
     do
        (* Classify error *)
        (if Errno

         (* From waitForIO() *)
         // cdef_EBADF then connBrokenError##->private.errorCB##;
         // cdef_EFAULT
         // cdef_EINVAL then internalError##->private.errorCB##;

         (* From read() *)
         // cdef_EBADF (* probably end-of-client *)
         // cdef_ENXIO (* hangup - also indicates end-of-client *)
         // cdef_EPIPE then connBrokenError##->private.errorCB##;
         // cdef_EBADMSG then badMsgError##->private.errorCB##;
         // cdef_EISDIR then internalError##->private.errorCB##;
         // cdef_ERANGE then resourceError##->private.errorCB##;

         (* End-of-file symptoms = peer closed down *)
         // cdef_ENOTCONN then connBrokenError##->private.errorCB##;

         else
            unknownError##->private.errorCB##;
        if);
     #);
   done,todo,delta,length: @integer;
do
   timeout -> private.timerStart;

   L:
     (if 1//1 then

         (* Get length field *)
         (4,0)->(todo,done);
         L1: (if ((private.index,@@length+done,todo)->doReadDataMax->delta)

              //-1 then

                 readErrClassify;

                 (* Invoke selected error callback *)
                 (if private.timerStop[]->&private.errorCB
                  // errCB_abortOperation then
                     leave L;
                  // errCB_continueOperation then
                     restart L1;
                  else
                     unexpected_error;
                 if);

              //0 then

                 Blocking;
                 (if private.readBlock // true then
                     (if timedOut
                      // errCB_abortOperation then
                         leave L;
                      // errCB_continueOperation then
                         timeout -> private.timerStart;
                         restart L1;
                      else
                         unexpected_error;
                     if);
                 if);
                 restart L1;

              else

                 (if delta<todo // true then
                     done+delta -> done;
                     todo-delta -> todo;
                     Idle;
                     (if private.readBlock // true then
                         (if timedOutInTransfer
                          // errCB_abortOperation then
                             leave L;
                          // errCB_continueOperation then
                             timeout -> private.timerStart;
                             restart L1;
                          else
                             unexpected_error;
                         if);
                      else
                         restart L1;
                     if);
                  else
                     length->private.lastReadLength;
                 if);

             if);

         (if (length>rep.r.range) // true then
             length-rep.r.range->rep.r.extend;
         if);
         (if rep.r.range//0 then 1 -> rep.r.extend if); (* paranoid! *)
         length -> rep.size; (* Announce how much data received *)

         L2: (if length>0 // true then

                 (* How many bytes to read to complete the RepetitionObject *)
                 4*(length-1) -> todo;
                 (if (todo<=0) // true then leave L2 if);

                 (* Read it *)
                 0 -> done;
                 L3: (if ((private.index,@@rep.r[2]+done,todo)
                           ->doReadDataMax->delta)

                      //-1 then

                         readErrClassify;

                         (* Invoke selected error callback *)
                         (if private.timerStop[]->&private.errorCB
                          // errCB_abortOperation then
                             leave L;
                          // errCB_continueOperation then
                             restart L3;
                          else
                             unexpected_error;
                         if);

                      //0 then

                         Idle;
                         (if private.readBlock // true then
                             (if timedOutInTransfer
                              // errCB_abortOperation then
                                 leave L;
                              // errCB_continueOperation then
                                 timeout -> private.timerStart;
                                 restart L3;
                              else
                                 unexpected_error;
                             if);
                         if);
                         restart L3;

                      else

                         (if delta<todo // true then
                             done+delta -> done;
                             todo-delta -> todo;
                             Idle;
                             (if private.readBlock // true then
                                 (if timedOutInTransfer
                                  // errCB_abortOperation then
                                     leave L;
                                  // errCB_continueOperation then
                                     timeout -> private.timerStart;
                                     restart L3;
                                  else
                                     unexpected_error;
                                 if);
                             if);
                             restart L3;
                          else
                             (* That`s it *)
                             private.timerStop;
                         if);

                     if);
              else
                 private.timerStop;
             if);

         (* Prepare 'rep' for reading from the beginning *)
         rep.reset;
     if);
#)

--- BSocketNonBlockingScope:descriptor ---
(#
do
   tryLabel:
     (#
        doUntry:
          (#
          do
             NONE -> private.untryPatVar##;  (* Leaving: always "deactivate" *)
             leave tryLabel
          #);
     do
        (if private.untryPatVar##//NONE then (* Outermost NBScope: "activate" *)
            doUntry## -> private.untryPatVar##;
            INNER nonBlockingScope;
            NONE -> private.untryPatVar##;
         else                                (* Nested NBScope: "is active" *)
            INNER nonBlockingScope;
        if);
     #);
#)

--- BSocketLeaveNBScope:descriptor ---
(#
do
   (if private.untryPatVar##//NONE then else private.untryPatVar if)
#)

--- ActiveBSocketConnect:descriptor ---
(#
   p: @integer;
   a: @integer;
   uerr: ^usageError;
do
   initSockets;
   INNER connect;

   L:
     (if 1//1 then
         (if port.assigned // false then
             &usageError[]->uerr[];
             'Can not connect with unassigned port' -> uerr.addMsg;
             (if uerr
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
         if);

         (if inetAddr.assigned // false then
             (if host.assigned // false then
                 &usageError[]->uerr[];
                 'Can not connect with both host and inetAddr unassigned'
                   -> uerr.addMsg;
                 (if uerr
                  // errCB_abortOperation then
                     leave L;
                  // errCB_continueOperation then
                     restart L;
                  else
                     unexpected_error;
                 if);

              else
                 (* 'host' has a value, but 'inetAddr' doesn`t *)
                 host -> host2inetAddr -> inetAddr;

                 (if inetAddr // -1 then
                     (* No classification of error: OS doesn`t tell *)
                     (if &getHostError
                      // errCB_abortOperation then
                         leave L;
                      // errCB_continueOperation then
                         restart L;
                      else
                         unexpected_error;
                     if);
                 if);
             if);

          else
             (* 'inetAddr' has a value, which then takes precedence *)
         if);

         (* intercept special 'localhost' value *)
         (if inetAddr // localHost_IP_number then
             inetAddrOfThisHost->inetAddr;
         if);

         inetAddr->a;
         port->p;
         L2:
           (if 1//1 then

               (a,p) -> &openActiveSocket -> private.index;
               (if private.index // -1 then

                   (* Classify error *)
                   (if Errno

                    (* From socket() *)
                    // cdef_EACCES then accessError##->private.errorCB##;
                    // cdef_EMFILE
                    // cdef_ENFILE
                    // cdef_ENOBUFS then resourceError##->private.errorCB##;
                    // cdef_EPROTONOSUPPORT
                    // cdef_EPROTOTYPE then internalError##->private.errorCB##;

                    (* From connect() *)
                    // cdef_EADDRINUSE
                    // cdef_EADDRNOTAVAIL then addressError##->private.errorCB##;
                    // cdef_EAFNOSUPPORT
                    // cdef_EALREADY
                    // cdef_EBADF then internalError##->private.errorCB##;
                    // cdef_ECONNREFUSED then refusedError##->private.errorCB##;
                    // cdef_EFAULT
                    // cdef_EINPROGRESS then internalError##->private.errorCB##;
                    // cdef_EINTR then intrError##->private.errorCB##;
                    // cdef_EINVAL
                    // cdef_EISCONN then internalError##->private.errorCB##;
                    // cdef_ENETUNREACH then addressError##->private.errorCB##;
                    // cdef_ENOTSOCK then internalError##->private.errorCB##;
                    // cdef_ETIMEDOUT then refusedError##->private.errorCB##;

                    else
                       unknownError##->private.errorCB##;
                   if);

                   (* Invoke selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L;
                    // errCB_continueOperation then
                       restart L2;
                    else
                       unexpected_error;
                   if);
               if);
           if);
         private.init;

         L3:
           (if (private.index -> &makeNonblocking) // -1 then

               (* Classify error *)
               (if Errno

                (* From fcntl() *)
                // cdef_EACCES then accessError##->private.errorCB##;
                // cdef_EFAULT
                // cdef_EINTR
                // cdef_ENOTSOCK
                // cdef_EINVAL then internalError##->private.errorCB##;
                // cdef_EBADF then connBrokenError##->private.errorCB##;
                else
                   unknownError##->private.errorCB##;
               if);

               (* Invoke selected error callback *)
               (if &private.errorCB
                // errCB_abortOperation then
                   leave L;
                // errCB_continueOperation then
                   restart L3;
                else
                   unexpected_error;
               if);
           if);
     if);
#)

--- PassiveBSocketPrivate:descriptor ---
(#
   listenIndex: @assignGuard(# rep: @integer enter rep exit rep #);
   listenIos: @IOState;
   timeHnd: @timeHandler;
   timerRunning: @boolean;
   timerID: @integer;

   init: (# do listenIndex -> listenIos.init #);

   onTimeOut: @(# do listenIos.timeOut #);

   timerStart: @
     (# timeout: @integer;
     enter timeout
     do
        (if timeout // waitForever then
            (* Noop *)
         else
            (onTimeOut[],timeout)->timeHnd.register->timerId;
            true->timerRunning;
        if);
     #);

   timerStop: @
     (#
     do
        (if timerRunning // true then
            false->timerRunning;
            timerId -> timeHnd.unregister;
        if);
     #);

   listenReadBlock: @
     (# timedOut: @boolean;
     do (if private.forcedTimeout // true then
            true->timedOut;
         else
            listenIos.readBlock->timedOut;
        if);
        false->private.forcedTimeout;
     exit timedOut
     #);
#)

--- PassiveBSocketBind:descriptor ---
(#
   portnumber: @integer;
   inet: @integer;
   uerr: ^usageError;
do
   initSockets;
   INNER bind;

   L:
     (if 1//1 then

         (if port.assigned // false then
             &usageError[]->uerr[];
             'Can not bind socket with unassigned port' -> uerr.addMsg;
             (if uerr
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
         if);

         L2:
           (if 1//1 then
               port -> portNumber;
               (if ((@@portNumber,@@inet) -> &createPassiveSocket
                     -> private2.listenIndex) // -1 then

                   (* Classify error *)
                   (if Errno

                    (* From socket() *)
                    // cdef_EMFILE
                    // cdef_ENFILE
                    // cdef_ENOBUFS then resourceError##->private.errorCB##;
                    // cdef_EPROTONOSUPPORT
                    // cdef_EPROTOTYPE then internalError##->private.errorCB##;

                    (* From socket() or bind() *)
                    // cdef_EACCES then accessError##->private.errorCB##;

                    (* From bind() *)
                    // cdef_EADDRINUSE
                    // cdef_EADDRNOTAVAIL then addressError##->private.errorCB##;
                    // cdef_EINVAL then internalError##->private.errorCB##;

                    (* From bind() or getsockname() *)
                    // cdef_EBADF
                    // cdef_EFAULT
                    // cdef_ENOTSOCK then internalError##->private.errorCB##;

                    (* From getsockname() *)
                    // cdef_ENOBUFS then resourceError##->private.errorCB##;

                    (* From inetAddrOfThisHost() *)
                    // 0 then internalError##->private.errorCB##;

                    else
                       unknownError##->private.errorCB##;
                   if);

                   (* Invoke selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L;
                    // errCB_continueOperation then
                       restart L2;
                    else
                       unexpected_error;
                   if);
               if);
               inet->inetAddr;
           if);

         L3:
           (if 1//1 then
               portNumber -> port;
               (if (private2.listenIndex -> &makePassiveNonblocking) // -1 then

                   (* Classify error *)
                   (if Errno

                    (* From fcntl() *)
                    // cdef_EACCES then accessError##->private.errorCB##;
                    // cdef_EFAULT
                    // cdef_EINTR
                    // cdef_ENOTSOCK
                    // cdef_EINVAL then internalError##->private.errorCB##;
                    // cdef_EBADF then connBrokenError##->private.errorCB##;
                    else
                       unknownError##->private.errorCB##;
                   if);

                   (* Invoke selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L;
                    // errCB_continueOperation then
                       restart L3;
                    else
                       unexpected_error;
                   if);
               if);
           if);

         private2.init;
     if);
#)

---  PassiveBSocketAwait:descriptor  ---
(#
   wouldBlock: @integer;
   dummyInetAddr: @integer; (* inetAddr field means This Host *)
   uerr: ^usageError;
do
   INNER awaitConnection;

   L: (if private2.listenIndex.assigned // false then
          &usageError[]->uerr[];
          'Await connection on an unbound passive socket' -> uerr.addMsg;
          (if uerr
           // errCB_abortOperation then
              leave L;
           // errCB_continueOperation then
              (* User _could_ have done the assignment by now *)
              restart L;
           else
              unexpected_error;
          if);
       else

          timeout -> private2.timerStart;

          L1:
            (if 1//1 then
                (private2.listenIndex,@@wouldBlock,@@dummyInetAddr)
                  -> &acceptConn -> private.index;
                (if private.index // -1 then

                    (* Classify error *)
                    (if Errno

                     (* From waitForIO() *)
                     // cdef_EBADF then connBrokenError##->private.errorCB##;
                     // cdef_EFAULT
                     // cdef_EINVAL then internalError##->private.errorCB##;

                     (* From accept() *)
                     // cdef_EMFILE
                     // cdef_ENFILE then resourceError##->private.errorCB##;
                     // cdef_ENOTSOCK
                     // cdef_EOPNOTSUPP then internalError##->private.errorCB##;
                     else
                        unknownError##->private.errorCB##;
                    if);

                    (* Invoke selected error callback *)
                    (if &private.errorCB
                     // errCB_abortOperation then
                        leave L;
                     // errCB_continueOperation then
                        restart L1;
                     else
                        unexpected_error;
                    if);
                if);

                (if wouldBlock//1 then
                    Blocking;
                    (if private2.listenReadBlock // true then
                        (if private2.timerstop[]->&timedOut
                         // errCB_abortOperation then
                            leave L;
                         // errCB_continueOperation then
                            timeout->private2.timerStart;
                            restart L1;
                         else
                            unexpected_error;
                        if);
                    if);
                    restart L1;
                if);
            if);
          private.init;

          L3:
            (if (private.index -> &makeNonblocking) // -1 then

                (* Classify error *)
                (if Errno

                 (* From fcntl() *)
                 // cdef_EACCES then accessError##->private.errorCB##;
                 // cdef_EFAULT
                 // cdef_EINTR
                 // cdef_ENOTSOCK
                 // cdef_EINVAL then internalError##->private.errorCB##;
                 // cdef_EBADF then connBrokenError##->private.errorCB##;
                 else
                    unknownError##->private.errorCB##;
                if);

                (* Invoke selected error callback *)
                (if &private.errorCB
                 // errCB_abortOperation then
                    leave L;
                 // errCB_continueOperation then
                    restart L3;
                 else
                    unexpected_error;
                if);
            if);
      if);
#)

--- PassiveBSocketClose:descriptor ---
(#
do INNER close;
   (private2.listenIndex,2) -> shutdown; (* 2: read & write *)
   private2.listenIndex->closeFileDescriptor;
   (* no error check: we must be able to close after err *)
#)

--- PassiveBSocketForceTimeout:descriptor ---
(#
do private2.listenIos.timeout;
   INNER forceTimeout;
#)

--- PassiveBSocketUsageTimestamp:dopart ---
do
   private2.listenIndex->getTimeStamp->value;


---]]
