ORIGIN 'systemComm_unixbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994
 *       All rights reserved.
 *)

(*******************************************************************************
 * IMPORTANT: IF YOU INCLUDE THIS FRAGMENT, READ THE FOLLOWING.
 *
 * Information for anybody who needs to understand, to change or to
 * expand the implementation, or who intends to manipulate any of the
 * private items 'instream' and 'outstream':
 *
 *      This description assumes knowledge of the 'WARNINGS' comment
 *      in the fragment 'fdStream'.
 *
 *      A StreamSocket object contains two 'fdStream' items, which both wrap
 *      the file descriptor identifying the OS level socket. They are
 *      named 'instream' and 'outstream' and are located in 'private'.
 *      It is necessary to have two, since the actual implementation of
 *      <C/stdio> does not reliably support two-way communication through
 *      a single stream wrapper when the file descriptor refers to a
 *      socket.
 *
 *      All output to the StreamSocket must go through 'outstream' and
 *      all input from the StreamSocket must be received through 'instream'.
 *      The standard 'stream' operations ('get', 'put', 'peek', 'putText'
 *      etc.) do this.
 *
 *      Confine all operations beyond data transfer to one of the two
 *      'fdStream' items - say 'instream' - to minimize the inconsistencies.
 *
 *      Remember that operations on 'instream' influences the OS level
 *      socket which is also wrapped by 'outstream', and vice versa. If
 *      you write data to 'outstream' (like '##' -> mySocket.putText),
 *      don't 'flush' it, and then 'close' the 'instream', the data
 *      usually gets lost in stead of getting sent.
 *
 *      In general: unless very good reasons speak for manipulating
 *      a StreamSocket on a low level, don't do it - use a BinarySocket,
 *      and manipulate it using open()/close()/read()/write() etc.
 *
 ******************************************************************************)
[[
--- include '~beta/unixlib/v1.4/unixinterface'
--- include '~beta/unixlib/v1.4/unixerrno'
--- include 'sysFdStream'
--- include 'sysFdStreamBody'

--- SSocketPrivate:descriptor ---
(#
   (* We must intercept fdStream error handling to obtain
    * systemComm style err. handling. We can`t change fdStream.
    *)
   rec_readChannel: readChannel (* 'rec' = 'returns error code' *)
     (#
        last_error: @integer;
        fdsExc: fdStreamException(# do true->continue; INNER #);
        AccessError::< fdsExc(# do rec_accessErr->last_error #);
        NoSpaceError::< fdsExc(# do rec_nospaceErr->last_error #);
        ReadError::< fdsExc(# do rec_readErr->last_error #);
        WriteError::< fdsExc(# do rec_writeErr->last_error #);
        EosError::< (# do true->continue; rec_eosErr->last_error #);
     #);
   
   rec_writeChannel: writeChannel (* 'rec' = 'returns error code' *)
     (#
        last_error: @integer;
        fdsExc: fdStreamException(# do true->continue; INNER #);
        AccessError::< fdsExc(# do rec_accessErr->last_error #);
        NoSpaceError::< fdsExc(# do rec_nospaceErr->last_error #);
        ReadError::< fdsExc(# do rec_readErr->last_error #);
        WriteError::< fdsExc(# do rec_writeErr->last_error #);
        EosError::< (# do true->continue; rec_eosErr->last_error #);
     #);

   index: @assignGuard(# rep: @integer; enter rep exit rep #);
   instream: @rec_readChannel;
   outstream: @rec_writeChannel;
   untryPatVar: ##Object;
   ios: @IOstate;
   timeHnd: @timeHandler;
   timerRunning: @boolean;
   timerID: @integer;
   last_error: @integer; (* one of 'rec_.*Err' *)
   errorCB: ##ErrCB;

   init: (# do initSockets; index -> ios.init; timeHnd.init #);
   
   onTimeOut: @(# do ios.timeOut #);
   
   timerStart: @
     (# timeout: @integer;
     enter timeout
     do
        (if timeout // waitForever then
            (* Noop *)
         else
            (onTimeOut[],timeout)->timeHnd.register->timerId;
            true->timerRunning;
        if);
     #);
   
   timerStop: @
     (#
     do
        (if timerRunning // true then
            false->timerRunning;
            timerId->timeHnd.unregister;
        if);
     #);
   
   eos: @ (* true iff no more data available and noErr *)
     (# i: @integer;
     do
        (instream.private.index,instream.private.unixstream)
          ->sockStreamEos
          ->i
     exit i > 0
     #);
   
   clear_error: (# do rec_noErr->last_error #);

   forcedTimeout: @boolean;
   
   readBlock: @
     (# timedOut: @boolean;
     do (if forcedTimeout // true then
            true->timedOut;
         else
            ios.readBlock->timedOut;
        if);
        false->forcedTimeout;
     exit timedOut
     #);
   
   writeBlock: @
     (# timedOut: @boolean;
     do (if forcedTimeout // true then
            true->timedOut;
         else
            ios.writeBlock->timedOut;
        if);
        false->forcedTimeout;
     exit timedOut
     #);
#)

--- SSocketSameConnection:dopart ---
do
   (private.index=other.private.index)->value;

--- SSocketGetPortableAddress:descriptor ---
(#
   tcp_addr: ^tcpPortAddress;
do
   &portablePortAddress[]->addr[];
   &tcpPortAddress[]->tcp_addr[]->addr.insert;
   inetAddr->tcp_addr.inetAddr;
   port->tcp_addr.portNo;
#)

--- SSocketOpen:descriptor ---
(#
   uerr: ^usageError;
do
   INNER open;
   L: (if private.index.assigned // false then
          &usageError[]->uerr[];
          'Can not open a socket with unassigned index' -> uerr.addMsg;
          (if uerr
           // errCB_abortOperation then
              leave L;
           // errCB_continueOperation then
              (* User _could_ have done the assignment by now *)
              restart L;
           else
              unexpected_error;
          if);
       else

          private.index -> private.instream.private.index;
          private.index -> private.outstream.private.index;

          L1:
            (if 1//1 then (* OpenRead; OpenWrite *)

               private.clear_error;		(* initialize error value *)
               private.instream.openRead;	(* do-it, perhaps set error value *)
               (if private.last_error		(* select error callback *)
                // rec_noErr then (* no action *)
                // rec_accessErr then accessError##->private.errorCB##;
                // rec_nospaceErr then nospaceError##->private.errorCB##;
                // rec_otherErr then otherError##->private.errorCB##;
                else
                   unexpected_error;
               if);
               (if private.last_error<>rec_noErr // true then
                   (* execute the selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L1;
                    // errCB_continueOperation then
                       restart L1;
                    else
                       unexpected_error;
                   if);
               if);

               L2:
                 (if 1//1 then (* OpenRead succeeded; now OpenWrite *)

                    private.clear_error;
                    private.outstream.openWrite;
                    (if private.last_error
                     // rec_noErr then (* no action *)
                     // rec_accessErr then accessError##->private.errorCB##;
                     // rec_nospaceErr then nospaceError##->private.errorCB##;
                     // rec_otherErr then otherError##->private.errorCB##;
                     else
                        unexpected_error;
                    if);
                    (if private.last_error<>rec_noErr // true then
                        (* execute the selected error callback *)
                        (if &private.errorCB
                         // errCB_abortOperation then
                            leave L2;
                         // errCB_continueOperation then
                            restart L2;
                         else
                            unexpected_error;
                        if);
                    if);
                 if);
            if);
      if);
#)

--- SSocketClose:descriptor ---
(#
do
   INNER close;
   private.outstream.flush;
   (private.instream.private.index,2) -> shutdown; (* 2: read & write *)
   (* DON`T DO private.outstream.close; SEE WARNING *)
   private.instream.close;
   (* No error checks; closing should be safe even on sick socket *)
#)

--- SSocketFlush:descriptor ---
(#
do
   (* !!! Flush might very well block this process. How to detect? *)
   INNER flush;

   L:
     (if 1//1 then
         private.clear_error;
         private.outstream.flush;
         (if private.last_error
          // rec_noErr then (* no action *)
          // rec_writeErr then writeError##->private.errorCB##;
          else
             unexpected_error;
         if);
         (if private.last_error<>rec_noErr // true then
             (if &private.errorCB
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
         if);
     if);
#)

--- SSocketPut:descriptor ---
(#
do
   (* !!! Put might block this process. How to detect? TimeOut? *)
   INNER put;

   L:
     (if 1//1 then
         private.clear_error;
         ch -> private.outstream.put;
         (if private.last_error
          // rec_noErr then (* no action *)
          // rec_writeErr then writeError##->private.errorCB##;
          else
             unexpected_error;
         if);
         (if private.last_error<>rec_noErr // true then
             (if &private.errorCB
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
         if);
     if);
#)

--- SSocketGet:descriptor ---
(#
   dummy_return: (# exit ' ' #);
do
   INNER get;
   
   timeoutValue->private.timerStart;
   L: (if private.eos//true then
          
          Blocking;
          (if private.readBlock // true then
              (if private.timerstop[]->&timedOut
               // errCB_abortOperation then
                  dummy_return->ch;
                  leave L;
               // errCB_continueOperation then
                  timeoutValue->private.timerStart;
                  restart L;
               else
                  unexpected_error;
              if);
          if);
          (if private.eos//true then
              (* Readblock terminated, but no data => peer closed down *)
              (if private.timerstop[]->&connBrokenError
               // errCB_abortOperation then
                  dummy_return->ch;
                  leave L;
               // errCB_continueOperation then
                  (* This will almost inevitably reproduce the
                   * error condition and detection. One should
                   * probably never have 'continue'd in this
                   * situation. But it`s the responsibility of
                   * the user if he/she loops around here for ever!
                   *)
                  restart L;
               else
                  unexpected_error;
              if);
          if);
          restart L;
       else
          L2:
            (if 1//1 then
                private.clear_error;
                private.instream.get -> ch;
                (if private.last_error
                 // rec_noErr then (* no action *)
                 // rec_eosErr then eosError##->private.errorCB##;
                 // rec_readErr then readError##->private.errorCB##;
                 else
                    unexpected_error;
                if);
                (if private.last_error<>rec_noErr // true then
                    (if private.timerStop[]->&private.errorCB
                     // errCB_abortOperation then
                        dummy_return->ch;
                        leave L2;
                     // errCB_continueOperation then
                        restart L2;
                     else
                        unexpected_error;
                    if);
                if);
            if);
      if);
   private.timerstop;
#)

--- SSocketPeek:descriptor ---
(#
   dummy_return: (# exit ' ' #);
do
   INNER peek;

   timeoutValue->private.timerStart;
   L: (if private.eos//true then

          Blocking;
          (if private.readBlock // true then
              (if private.timerstop[]->&timedOut
               // errCB_abortOperation then
                  dummy_return->ch;
                  leave L;
               // errCB_continueOperation then
                  timeoutValue->private.timerStart;
                  restart L;
               else
                  unexpected_error;
              if);
          if);

          (if private.eos//true then
              (* Readblock terminated, but no data => peer closed down *)
              (if private.timerstop[]->&connBrokenError
               // errCB_abortOperation then
                  dummy_return->ch;
                  leave L;
               // errCB_continueOperation then
                  (* Probably just provokes same error -
                   * but user asked for it
                   *)
                  restart L;
               else
                  unexpected_error;
              if);
          if);
          restart L;
       else
          L2:
            (if 1//1 then
                private.clear_error;
                private.instream.peek -> ch;
                (if private.last_error
                 // rec_noErr then (* no action *)
                 // rec_eosErr then eosError##->private.errorCB##;
                 // rec_readErr then readError##->private.errorCB##;
                 else
                    unexpected_error;
                if);
                (if private.last_error<>rec_noErr // true then
                    (if private.timerStop[]->&private.errorCB
                     // errCB_abortOperation then
                        dummy_return->ch;
                        leave L2;
                     // errCB_continueOperation then
                        restart L2;
                     else
                        unexpected_error;
                    if);
                if);
            if);
      if);
   private.timerstop;
#)

--- SSocketEos:descriptor ---
(#
   dummy_return: (# exit false #); (* Don`t hide error by saying 'sleeps' *)
do
   INNER eos;

   L:
     (if 1//1 then
         (if ((private.instream.private.index,private.instream.private.unixstream)
               ->sockStreamEos)
          // -1 then (* error originates from 'ioctl' *)
             
             (if Errno
              // cdef_EBADF then connBrokenError##->private.errorCB##;
              // cdef_ENOTTY
              // cdef_EFAULT
              // cdef_EINVAL then internalError##->private.errorCB##;
              else
                 unknownError##->private.errorCB##;
             if);
             
             (if &private.errorCB
              // errCB_abortOperation then
                 dummy_return->value;
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
             
          // 0 then
             false -> value;
          else
             (* Can`t read anything now: ask select *)
             (if private.instream.private.index
                   ->selectReadable
                 
              // -1 then
                 (if &connBrokenError
                  // errCB_abortOperation then
                     dummy_return->value;
                     leave L;
                  // errCB_continueOperation then
                     restart L;
                  else
                     unexpected_error;
                 if);

              // 1 then
                 (* select says not readable: connection alive, but no data *)
                 false->value;

              // 0 then
                 (* select says readable: peer closed down *)
                 true -> value;

              else
                 unexpected_error;  
             if);
         if);
     if);
#)

--- SSocketPutText:descriptor ---
(#
do
   (* !!! May block this thread. How to detect? TimeOut? *)
   true -> doneInINNER;

   INNER PutText;
   L:
     (if 1//1 then
         private.clear_error;
         T[] -> private.outstream.putText;
         (if private.last_error
          // rec_noErr then (* no action *)
          // rec_writeErr then writeError##->private.errorCB##;
          else
             unexpected_error;
         if);
         (if private.last_error<>rec_noErr // true then
             (if &private.errorCB
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 (* probably recreates the problem *)
                 restart L;
              else
                 unexpected_error;
             if);
         if);
     if);
#)

--- SSocketGetLine:descriptor ---
(#
   dummy_return: (# exit '' #);
do
   true -> doneInINNER;

   timeoutValue->private.timerStart;
   L: (if private.eos//true then

          Blocking;
          (if private.readBlock // true then
              (if private.timerstop[]->&timedOut
               // errCB_abortOperation then
                  dummy_return->t[];
                  leave L;
               // errCB_continueOperation then
                  timeoutValue->private.timerStart;
                  restart L;
               else
                  unexpected_error;
              if);
          if);

          (if private.eos//true then
              (* Readblock terminated, but no data => peer closed down *)
              (if private.timerstop[]->&connBrokenError
               // errCB_abortOperation then
                  dummy_return->t[];
                  leave L;
               // errCB_continueOperation then
                  (* if user keeps saying 'continue', he/she
                   * will end up in an infinite loop here.
                   *)
                  restart L;
               else
                  unexpected_error;
              if);
          if);
          restart L;
       else
          L2:
            (if 1//1 then
                private.clear_error;
                private.instream.getLine -> t[];
                (if private.last_error
                 // rec_noErr then (* no action *)
                 // rec_eosErr then eosError##->private.errorCB##;
                 // rec_readErr then readError##->private.errorCB##;
                 else
                    unexpected_error;
                if);
                (if private.last_error<>rec_noErr // true then
                    (if private.timerStop[]->&private.errorCB
                     // errCB_abortOperation then
                        dummy_return->t[];
                        leave L2;
                     // errCB_continueOperation then
                        restart L2;
                     else
                        unexpected_error;
                    if);
                if);
            if);
      if);
   private.timerstop;

   INNER GetLine;
#)

--- SSocketGetAtom:descriptor ---
(#
   dummy_return: (# exit '' #);
do
   true -> doneInINNER;

   timeoutValue->private.timerStart;
   L: (if private.eos//true then

          Blocking;
          (if private.readBlock // true then
              (if private.timerstop[]->&timedOut
               // errCB_abortOperation then
                  dummy_return->t[];
                  leave L;
               // errCB_continueOperation then
                  timeoutValue->private.timerStart;
                  restart L;
               else
                  unexpected_error;
              if);
          if);

          (if private.eos//true then
              (* Readblock terminated, but no data => peer closed down *)
              (if private.timerstop[]->&connBrokenError
               // errCB_abortOperation then
                  dummy_return->t[];
                  leave L;
               // errCB_continueOperation then
                  (* if user keeps saying 'continue', he/she
                   * will end up in an infinite loop here.
                   *)
                  restart L;
               else
                  unexpected_error;
              if);
          if);
          restart L;
       else
          L2:
            (if 1//1 then
                private.clear_error;
                private.instream.getAtom -> t[];
                (if private.last_error
                 // rec_noErr then (* no action *)
                 // rec_eosErr then eosError##->private.errorCB##;
                 // rec_readErr then readError##->private.errorCB##;
                 else
                    unexpected_error;
                if);
                (if private.last_error<>rec_noErr // true then
                    (if private.timerStop[]->&private.errorCB
                     // errCB_abortOperation then
                        dummy_return->t[];
                        leave L2;
                     // errCB_continueOperation then
                        restart L2;
                     else
                        unexpected_error;
                    if);
                if);
            if);
      if);
   private.timerstop;
   
   INNER GetAtom;
#)

--- SSocketForceTimeout:descriptor ---
(#
do true->private.forcedTimeout;
   private.ios.timeout;
   INNER forceTimeout;
#)

--- SSocketUsageTimestamp:dopart ---
do
   private.index->getTimeStamp->value;
   INNER usageTimestamp;

--- SSocketNonBlockingScope:descriptor ---
(#
do
   tryLabel:
     (#
        doUntry:
          (#
          do
             NONE -> private.untryPatVar##;  (* Leaving: always "deactivate" *)
             leave tryLabel
          #);
     do
        (if private.untryPatVar##//NONE then (* Outermost NBScope: "activate" *)
            doUntry## -> private.untryPatVar##;
            INNER nonBlockingScope;
            NONE -> private.untryPatVar##;
         else                                (* Nested NBScope: "is active" *)
            INNER nonBlockingScope;
        if);
     #);
#)

--- SSocketLeaveNBScope:descriptor ---
(#
do
   (if private.untryPatVar##//NONE then else private.untryPatVar if)
#)

--- ActiveSSocketConnect:descriptor ---
(#
   p: @Integer;
   a: @integer;
   uerr: ^usageError;
do
   initSockets;
   INNER connect;

   L:
     (if 1//1 then
         (if port.assigned // false then
             &usageError[]->uerr[];
             'Can not connect with unassigned port' -> uerr.addMsg;
             (if uerr
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
         if);

         (if inetAddr.assigned // false then
             (if host.assigned // false then
                 &usageError[]->uerr[];
                 'Can not connect with both host and inetAddr unassigned'
                   -> uerr.addMsg;
                 (if uerr
                  // errCB_abortOperation then
                     leave L;
                  // errCB_continueOperation then
                     restart L;
                  else
                     unexpected_error;
                 if);

              else
                 (* 'host' has a value, but 'inetAddr' doesn`t *)
                 host -> host2inetAddr -> inetAddr;

                 (if inetAddr // -1 then
                     (* No classification of error: OS doesn`t tell *)
                     (if &getHostError
                      // errCB_abortOperation then
                         leave L;
                      // errCB_continueOperation then
                         restart L;
                      else
                         unexpected_error;
                     if);
                 if);
             if);

          else
             (* 'inetAddr' has a value, which then takes precedence *)
         if);

         (* intercept special 'localhost' value *)
         (if inetAddr // localHost_IP_number then
             inetAddrOfThisHost->inetAddr;
         if);

         inetAddr->a;
         port->p;
         L2:
           (if 1//1 then
               (a,p) -> &openActiveSocket -> private.index;
               (if private.index // -1 then

                   (* Classify error *)
                   (if Errno
                       
                    (* From socket() *)
                    // cdef_EACCES then accessError##->private.errorCB##;
                    // cdef_EMFILE
                    // cdef_ENFILE
                    // cdef_ENOBUFS then resourceError##->private.errorCB##;
                    // cdef_EPROTONOSUPPORT
                    // cdef_EPROTOTYPE then internalError##->private.errorCB##;
                       
                    (* From connect() *)
                    // cdef_EADDRINUSE
                    // cdef_EADDRNOTAVAIL then addressError##->private.errorCB##;
                    // cdef_EAFNOSUPPORT
                    // cdef_EALREADY
                    // cdef_EBADF then internalError##->private.errorCB##;
                    // cdef_ECONNREFUSED then refusedError##->private.errorCB##;
                    // cdef_EFAULT
                    // cdef_EINPROGRESS then internalError##->private.errorCB##;
                    // cdef_EINTR then intrError##->private.errorCB##;
                    // cdef_EINVAL
                    // cdef_EISCONN then internalError##->private.errorCB##;
                    // cdef_ENETUNREACH then addressError##->private.errorCB##;
                    // cdef_ENOTSOCK then internalError##->private.errorCB##;
                    // cdef_ETIMEDOUT then refusedError##->private.errorCB##;
                       
                    else
                       unknownError##->private.errorCB##;
                   if);
                   
                   (* Invoke selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L;
                    // errCB_continueOperation then
                       restart L2;
                    else
                       unexpected_error;
                   if);
               if);
           if);
         private.init;

         L3:
           (if (private.index -> &makeNonblocking) // -1 then

               (* Classify error *)
               (if Errno

                (* From fcntl() *)
                // cdef_EACCES then accessError##->private.errorCB##;
                // cdef_EFAULT
                // cdef_EINTR
                // cdef_ENOTSOCK
                // cdef_EINVAL then internalError##->private.errorCB##;
                // cdef_EBADF then connBrokenError##->private.errorCB##;
                else
                   unknownError##->private.errorCB##;
               if);

               (* Invoke selected error callback *)
               (if &private.errorCB
                // errCB_abortOperation then
                   leave L;
                // errCB_continueOperation then
                   restart L3;
                else
                   unexpected_error;
               if);
           if);
     if);
#)

--- PassiveSSocketPrivate:descriptor ---
(#
   listenIndex: @assignGuard(# rep: @integer enter rep exit rep #);
   listenIos: @IOState;
   timeHnd: @timeHandler;
   timerRunning: @boolean;
   timerID: @integer;

   init: (# do listenIndex -> listenIos.init #);
   
   onTimeOut: @(# do listenIos.timeOut #);
   
   timerStart: @
     (# timeout: @integer;
     enter timeout
     do
        (if timeout // waitForever then
            (* Noop *)
         else
            (onTimeOut[],timeout)->timeHnd.register->timerId;
            true->timerRunning;
        if);
     #);
   
   timerStop: @
     (#
     do
        (if timerRunning // true then
            false->timerRunning;
            timerId -> timeHnd.unregister;
        if);
     #);
   
   listenReadBlock: @
     (# timedOut: @boolean;
     do (if private.forcedTimeout // true then
            true->timedOut;
         else
            listenIos.readBlock->timedOut;
        if);
        false->private.forcedTimeout;
     exit timedOut
     #);
#)

--- PassiveSSocketBind:descriptor ---
(#
   portnumber: @integer;
   inet: @integer;
   uerr: ^usageError;
do
   initSockets;
   INNER bind;

   L:
     (if 1//1 then
         (if port.assigned // false then
             &usageError[]->uerr[];
             'Can not bind socket with unassigned port' -> uerr.addMsg;
             (if uerr
              // errCB_abortOperation then
                 leave L;
              // errCB_continueOperation then
                 restart L;
              else
                 unexpected_error;
             if);
         if);

         L2:
           (if 1//1 then
               port -> portNumber;
               (if ((@@portNumber,@@inet) -> &createPassiveSocket
                     -> private2.listenIndex) // -1 then
                   
                   (* Classify error *)
                   (if Errno
                       
                    (* From socket() *)
                    // cdef_EMFILE
                    // cdef_ENFILE
                    // cdef_ENOBUFS then resourceError##->private.errorCB##;
                    // cdef_EPROTONOSUPPORT
                    // cdef_EPROTOTYPE then internalError##->private.errorCB##;
                       
                    (* From socket() or bind() *)
                    // cdef_EACCES then accessError##->private.errorCB##;
                       
                    (* From bind() *)
                    // cdef_EADDRINUSE
                    // cdef_EADDRNOTAVAIL then addressError##->private.errorCB##;
                    // cdef_EINVAL then internalError##->private.errorCB##;
                       
                    (* From bind() or getsockname() *)
                    // cdef_EBADF
                    // cdef_EFAULT
                    // cdef_ENOTSOCK then internalError##->private.errorCB##;
                       
                    (* From getsockname() *)
                    // cdef_ENOBUFS then resourceError##->private.errorCB##;
                       
                    (* From inetAddrOfThisHost() *)
                    // 0 then internalError##->private.errorCB##;
                       
                    else
                       unknownError##->private.errorCB##;
                   if);
                   
                   (* Invoke selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L;
                    // errCB_continueOperation then
                       restart L2;
                    else
                       unexpected_error;
                   if);
               if);
               inet->inetAddr;
           if);

         L3:
           (if 1//1 then
               portNumber -> port;
               (if (private2.listenIndex -> &makePassiveNonblocking) // -1 then
                   
                   (* Classify error *)
                   (if Errno
                       
                    (* From fcntl() *)
                    // cdef_EACCES then accessError##->private.errorCB##;
                    // cdef_EFAULT 
                    // cdef_EINTR
                    // cdef_ENOTSOCK
                    // cdef_EINVAL then internalError##->private.errorCB##;
                    // cdef_EBADF then connBrokenError##->private.errorCB##;
                    else
                       unknownError##->private.errorCB##;
                   if);
                   
                   (* Invoke selected error callback *)
                   (if &private.errorCB
                    // errCB_abortOperation then
                       leave L;
                    // errCB_continueOperation then
                       restart L3;
                    else
                       unexpected_error;
                   if);
               if);
           if);

         private2.init;
      if);
#)

---  PassiveSSocketAwait:descriptor  ---
(#
   wouldBlock: @integer;
   dummyInetAddr: @integer; (* inetAddr field means This Host *)
   uerr: ^usageError;
do
   INNER awaitConnection;

   L: (if private2.listenIndex.assigned // false then
          &usageError[]->uerr[];
          'Await connection on an unbound passive socket' -> uerr.addMsg;
          (if uerr
           // errCB_abortOperation then
              leave L;
           // errCB_continueOperation then
              (* User _could_ have done the assignment by now *)
              restart L;
           else
              unexpected_error;
          if);
       else

          timeoutValue -> private2.timerStart;

          L1:
            (if 1//1 then
                (private2.listenIndex,@@wouldBlock,@@dummyInetAddr)
                  -> &acceptConn -> private.index;
                (if private.index // -1 then
                    
                    (* Classify error *)
                    (if Errno
                        
                     (* From waitForIO() *)
                     // cdef_EBADF then connBrokenError##->private.errorCB##;
                     // cdef_EFAULT
                     // cdef_EINVAL then internalError##->private.errorCB##;
                        
                     (* From accept() *)
                     // cdef_EMFILE
                     // cdef_ENFILE then resourceError##->private.errorCB##;
                     // cdef_ENOTSOCK
                     // cdef_EOPNOTSUPP then internalError##->private.errorCB##;
                     else
                        unknownError##->private.errorCB##;
                    if);
                    
                    (* Invoke selected error callback *)
                    (if &private.errorCB
                     // errCB_abortOperation then
                        leave L;
                     // errCB_continueOperation then
                        restart L1;
                     else
                        unexpected_error;
                    if);
                if);
                (if wouldBlock//1 then
                    Blocking;
                    (if private2.listenReadBlock // true then
                        (if private2.timerstop[]->&timedOut
                         // errCB_abortOperation then
                            leave L;
                         // errCB_continueOperation then
                            timeoutValue->private2.timerStart;
                            restart L1;
                         else
                            unexpected_error;
                        if);
                    if);
                    restart L1;
                if);
            if);
          private.init;
          
          L3:
            (if (private.index -> &makeNonblocking) // -1 then
                
                (* Classify error *)
                (if Errno
                    
                 (* From fcntl() *)
                 // cdef_EACCES then accessError##->private.errorCB##;
                 // cdef_EFAULT
                 // cdef_EINTR
                 // cdef_ENOTSOCK
                 // cdef_EINVAL then internalError##->private.errorCB##;
                 // cdef_EBADF then connBrokenError##->private.errorCB##;
                 else
                    unknownError##->private.errorCB##;
                if);

                (* Invoke selected error callback *)
                (if &private.errorCB
                 // errCB_abortOperation then
                    leave L;
                 // errCB_continueOperation then
                    restart L3;
                 else
                    unexpected_error;
                if);
            if);
      if);
#)

--- PassiveSSocketClose:descriptor ---
(#
do INNER close;
   (private2.listenIndex,2) -> shutdown; (* 2: read & write *)
   private2.listenIndex->closeFileDescriptor;
   (* no error check: we must be able to close after err *)
#)

--- PassiveSSocketForceTimeout:descriptor ---
(#
do private2.listenIos.timeout;
   INNER forceTimeout;
#)

--- PassiveSSocketUsageTimestamp:dopart ---
do
   private2.listenIndex->getTimeStamp->value;
   
---]]
