ORIGIN '~beta/basiclib/v1.5/basicsystemenv';

INCLUDE '~beta/sysutils/v1.5/RepetitionObject';
INCLUDE 'repstream/extendedRepstream';
INCLUDE 'errorCallback';
INCLUDE 'commAddress';

MDBODY nti     'private/systemComm_ntbody'
       mac     'private/systemComm_macbody'
       default 'private/systemComm_unixbody';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1994
 *       All rights reserved.
 *)

[[
--- systemLib:attributes ---

(* Expected context:
 * =================
 *
 * Instances of the patterns of this fragment are expected to be
 * executed from components (co-routines). Whenever an operation
 * is about to block, the current component will be suspended.
 * It will be resumed some time later, when the requested IO
 * is available. This means that communication related
 * functionality can be written in a simple, blocking style; it
 * will behave approximately as if the scheduler were preemptive.
 *
 * Communication concepts:
 * =======================
 *
 * Pipe: Communication channel between two processes.
 *	 For pure standard communication, using standard input/output.
 *	 Both processes are unaware of the identity of their communication
 *	 partner.
 *
 * Socket: A stream, conceptually an endpoint of a two-way comminication line.
 *	   Two endpoints are connected by letting an ActiveSocket connect to a
 *	   PassiveSocket. The PassiveSocket just waits for the ActiveSocket  to
 *	   connect. After connection both sockets can read/write on their
 *	   streams.
 *
 * SocketGenerators are used in client/server type communication.
 * Sockets are divided into the categories stream socket and binary socket.
 *
 * Stream sockets:
 *
 * A stream socket is suitable for transferring data, which is readable for
 * human beings, like the data transferred in a UNIX 'talk' session, or like
 * the more formal communication between a mail program and an SMTP mail
 * server. A stream socket is a stream, so you may 'put', 'get' etc.
 * However, don't use this kind of socket when transferring data which
 * may contain zero-valued bytes, such as arbitrary binary data.
 *
 * Binary sockets:
 *
 * A binary socket is guaranteed to transfer any given block of
 * arbitrary bytes unmodified, but you must always specify the
 * length of the data block, both for sending and receiving. You may
 * 'readData' and 'writeData' on a binary socket, which constitutes
 * the lowest level interface.
 *
 * The operations 'getBlock' and 'putBlock' provide support for
 * a very simple, binary data transfer protocol. In this protocol,
 * all data is transferred in blocks with the following layout:
 *
 *      len      header   data
 *      |--------|--------|---------------------------------|
 *
 * The 'len' field is a four byte integer value, in big-endian byte order.
 * The 'header' field is a four byte big-endian integer value,
 * identifying the kind of data in the 'data' field, the purpose
 * of the block, or whatever. The 'data' field length is 4*'len'
 * bytes. The sender and the recipient must agree on the interpretation
 * of the 'header' and 'data' fields, which is left unspecified by
 * this protocol.
 *
 * The operations 'putRep' and 'getRep' are provided for transferring
 * data to and from a ExtendedRepstream object, using this protocol.
 * The usage of this level of functionality is recommended whenever
 * possible, as it encapsulates (and hides) references to raw memory
 * addresses.
 *
 * The operations 'putRepObj' and 'getRepObj' are similar to 'putRep'
 * and 'getRep', apart from: (1) The objects sent or received are
 * instances of the pattern RepetitionObject. (2) the protocol has
 * no header field, and the length field is the first element in
 * the repetition from the repetitionObject:
 *
 *      len      data
 *      |--------|---------------------------------|
 *
 * Otherwise, it's like the above protocol.
 *
 * The 'Idle' patterns:
 * ====================
 *
 * Many operations on sockets have an 'Idle' virtual pattern.
 * It may be executed one or more times if the operation cannot
 * finish right away. This is not guaranteed to happen, so don't
 * rely on 'Idle' being executed even once. Furtherbind this virtual
 * to keep your application "alive" during a (possibly) lenghty
 * operation. Don't execute operations on this(Socket) in an
 * enclosed 'Idle'. Don't stop the operation from within an 'Idle' -
 * the operation is unfinished; you may for instance have received
 * half a block, which makes the stop a serious break wrt the protocol;
 * use 'nonBlockingScope' and 'Blocking' for this purpose.
 *
 * The 'nonBlockingScope' and 'Blocking' patterns:
 * ===============================================
 *
 * The 'nonBlockingScope' pattern is used for specifying non-blocking
 * communication. This means that operations which cannot begin
 * right away are discontinued. An example is: We try to read from a
 * socket, but no data at all is available to read. If any irreversible
 * actions have been taken in an operation (e.g. reading a few bytes),
 * it will not be interrupted by the 'nonBlockingScope' mechanism. This
 * means it is always safe to interrupt an operation by enclosing it
 * in a 'nonBlockingScope', and to retry it later.
 *
 * With each 'Idle' pattern comes a 'Blocking' virtual. This is executed
 * iff the current operation is blocking, i.e. if nothing can be done right
 * away. You may furtherbind this virtual to take some action in response
 * to the operation being blocked. If the operation is enclosed in a
 * 'nonBlockingScope', your 'Blocking'-code gets executed immediately
 * before the operation is interrupted. If you don't want to interrupt
 * the operation, execute 'continue' in the furtherbinding of 'Blocking'.
 *
 * USAGE: Normally the communication will be blocking. But if you enclose
 * an operation in a specialization of 'nonBlockingScope', we 'leave' the
 * 'nonBlockingScope' at the first blocking condition. PLEASE NOTE: it is
 * unsafe to execute a 'leave' statement which leaves a 'nonBlockingScope'.
 * If you need to leave it, execute 'leaveNBScope'. The normal usage with
 * and without 'nonBlockingScope' looks like this:
 *
 *   /* BLOCKING STYLE */
 *   myStreamSocket.getLine  /* waits until data has arrived */
 *    -> reactOnInput;       /* always executed */
 *   reactSomeMore;          /* always executed */
 *   doOtherThings;
 *
 *   /* NONBLOCKING STYLE */
 *   myStreamSocket.nonBlockingScope
 *      (#
 *      do
 *         myStreamSocket.getLine  /* if no data: leave scope at once */
 *          -> reactOnInput;       /* only executed if data available */
 *         reactSomeMore;          /* only executed if data available */
 *      #);
 *   doOtherThings;
 *
 * With some patterns, it is not possible to have a virtual 'Blocking' or
 * 'Idle' pattern. This is because an enter parameter for the operation
 * is supposedly the address of a beta object. Having taken this, it is
 * unsafe to create objects during the execution of the operation. An
 * example is 'BinarySocket.writeData'. However, enclosing such operations
 * in a 'nonBlockingScope' does cause the operation to behave in a
 * non-blocking manner.
 *
 * Exception Handling
 * ==================
 *
 * Uses error callbacks. Read about these in 'errorCallback.bet'.
 *
 * The error callbacks used have the following meaning:
 *
 *
 *   Error callback name      Meaning
 * -----------------------------------------------------
 *   accessError              Insufficient access rights
 *   addressError             Address (i.e. (host,port)) in use or invalid
 *   badMsgError              (hardly documented in man page)
 *   connBrokenError          The connection has become unusable
 *   eosError                 End-of-stream
 *   getHostError             Error when getting hostname
 *   internalError            Should not happen; please report if it does!
 *   intrError                Operation interrupted by signal
 *   refusedError             Connection refused by peer
 *   resourceError            Too few file descriptors/buffers etc.
 *   timedOut                 Specified timeout period has expired
 *   timedOutInTransfer       Timed out, and some data have been transferred
 *   unknownError             OS reports unknown errno (new OS?)
 *   usageError               Eg: you must initialize port before connecting
 * 
 *   nospaceError             (StreamSocket) returned by op. on fdStream
 *   otherError               (StreamSocket) from fdStream
 *   readError                (StreamSocket) from fdStream
 *   writeError               (StreamSocket) from fdStream
 *   accessError              (also occurs as an fdStream error)
 *)

waitForever: (* Default for timeouts *)
  IntegerValue(# do -1->value; INNER #);

assignGuard: (# assigned: @Boolean do true -> assigned #);

propagateException: (# msg: ^Text enter msg[] do INNER #);

pipe:
  (* The pipe is a composition of two interconnected one way streams.
   * What is written on 'writeEnd' can subsequently be read
   * from 'readEnd'.
   *)
  (#
     (* operations *)
     init:<
       (# error:< propagateException(# do INNER; msg -> pipeError #);
       do <<SLOT PipeInit:descriptor>>
       #);

     (* !!!! exceptions *)
     pipeException: Exception
       (#
       enter msg
       do (if msg.empty//false then msg.newline if);
          INNER;
       #);
     pipeError:< PipeException;

     (* attributes *)
     readEnd: ^Stream;
     writeEnd: ^Stream;

     (* private *)
     private: @<<SLOT PipePrivate:descriptor>>;
  #); (* pipe *)

StreamSocket: Stream
  (#
     (* basics *)
     withPE:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          accessError:< loErrCB(# do INNER #);
          nospaceError:< loErrCB(# do INNER #);
          writeError:< loErrCB(# do INNER #);
          usageError:< loErrCB(# do INNER #); 
          otherError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          timeout: @integer;
          enter timeout
       do INNER
       #);
     BasicBlocking:
       (# continue: (# do true->doContinue #);
          doContinue: @boolean;
          doIdle:< Object;
       do
          INNER;
          (if doContinue//false then leaveNBScope if);
          doIdle;
       #);
     Idle:< Object; (* every local 'Idle' executes this global one *)
     timeoutValue:< waitForever; (* length in seconds, all operations *)

     (* operations *)
     sameConnection: booleanValue
       (* do 'this' and 'other' wrap the same OS level connection? *)
       (# other: ^StreamSocket;
       enter other[]
       <<SLOT SSocketSameConnection:dopart>>
       #);
     getPortableAddress:
       (# addr: ^portablePortAddress;
          dopart: @<<SLOT SSocketGetPortableAddress:descriptor>>;
       do dopart
       exit addr[]
       #);
     open: withPE
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
       do <<SLOT SSocketOpen:descriptor>>
       #);
     close:< withPE
       (#
       do <<SLOT SSocketClose:descriptor>>
       #);
     flush: withPE
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          dopart: @<<SLOT SSocketFlush:descriptor>>;
       do dopart
       #);
     put::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          writeError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketPut:descriptor>>;
       do dopart
       #);
     get::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          readError:< loErrCB(# do INNER #);
          eosError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketGet:descriptor>>;
       do dopart
       #);
     peek::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          readError:< loErrCB(# do INNER #);
          eosError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketPeek:descriptor>>;
       do dopart
       #);
     eos::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          connBrokenError:< loErrCB(# do INNER #); 
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketEos:descriptor>>;
       do dopart
       #);
     putText::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then
                   (value,cleanup[])->error->value;
               if);
            #);
          writeError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketPutText:descriptor>>;
       do dopart
       #);
     getLine::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          readError:< loErrCB(# do INNER #);
          eosError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketGetLine:descriptor>>;
       do dopart
       #);
     getAtom::
       (# Idle:< (# do INNER; this(StreamSocket).Idle #);
          Blocking:< BasicBlocking(# doIdle::< (# do Idle #) do INNER #);
          error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(StreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then
                   (value,cleanup[])->error->value;
               if);
            #);
          readError:< loErrCB(# do INNER #);
          eosError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          dopart: @<<SLOT SSocketGetAtom:descriptor>>;
       do dopart
       #);
     forceTimeout:< (# do <<SLOT SSocketForceTimeout:descriptor>> #);
     usageTimestamp:< integerValue(# <<SLOT SSocketUsageTimestamp:dopart>> #);

     (* nonBlockingScope support *)
     (* PLEASE NOTE: don`t 'leave' a 'nonBlockingScope'. Use 'leaveNBScope' *)
     nonBlockingScope: (# do <<SLOT SSocketNonBlockingScope:descriptor>> #);
     leaveNBScope: (# do <<SLOT SSocketLeaveNBScope:descriptor>> #);

     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     (* attributes *)
     host: @assignGuard(# t: @text; enter t exit t #);
     port: @assignGuard(# rep: @integer enter rep exit rep #);
     inetAddr: @assignGuard(# rep: @integer enter rep exit rep #); 

     (* private *)
     private: @<<SLOT SSocketPrivate:descriptor>>;
  #); (* StreamSocket *)

BinarySocket:
  (#
     (* basics *)
     withPE:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(BinarySocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          timedOut:< loErrCB(# do INNER #);
          timedOutInTransfer:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          usageError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          timeout: @integer;
       enter timeout
       do INNER
       #);
     withIdle: withPE
       (# Idle:< (# do INNER; this(BinarySocket).Idle #);
          Blocking:<
            (# continue: (# do true->doContinue #);
               doContinue: @boolean;
            do
               INNER;
               (if doContinue//false then leaveNBScope if);
               Idle;
            #);
       do INNER
       #);
     repIO: withIdle
       (* Abstract pattern. Read/write a block to/from 'rep',
        * returning/using 'header'. The length of the block is
        * stored in/retrived from 'rep.end'.
        *)
       (# resourceError:< loErrCB(# do INNER #);
          badMsgError:< loErrCB(# do INNER #);
          rep: ^ExtendedRepstream;
          header: @integer;
       enter rep[]
       do INNER
       #);
     repObjIO: withIdle
       (* Abstract pattern. Read/write a block to/from 'rep',
        * The length of the block is stored in/retrived from 'rep.end'.
        *)
       (# resourceError:< loErrCB(# do INNER #);
          badMsgError:< loErrCB(# do INNER #);
          rep: ^RepetitionObject;
       enter rep[]
       do INNER
       #);
     Idle:< Object; (* every local 'Idle' executes this global one *)

     (* operations *)
     sameConnection: booleanValue
       (* do 'this' and 'other' wrap the same OS level connection? *)
       (# other: ^BinarySocket;
       enter other[]
       <<SLOT BSocketSameConnection:dopart>>
       #);
     getPortableAddress:
       (# addr: ^portablePortAddress;
          dopart: @<<SLOT BSocketGetPortableAddress:descriptor>>;
       do dopart
       exit addr[]
       #);
     open: withIdle(# do <<SLOT BSocketOpen:descriptor>> #);
     close:< withIdle(# do <<SLOT BSocketClose:descriptor>> #);
     endOfData: @endOfDataPattern;
     putRep: @putRepPattern;
     getRep: @getRepPattern;
     putRepObj: @putRepObjPattern;
     getRepObj: @getRepObjPattern;
     forceTimeout:< (# do <<SLOT BSocketForceTimeout:descriptor>> #);
     usageTimestamp:< integerValue(# <<SLOT BSocketUsageTimestamp:dopart>> #);
     
     endOfDataPattern:
       (* Returns true iff no data is immediately available for reading *)
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(BinarySocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          connBrokenError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          value: @boolean;
          dopart: @<<SLOT BSocketEndOfData:descriptor>>;
       do dopart
       exit value
       #);
     putRepPattern: repIO
       (* Read to ExtendedRepstream using
        * above mentioned binary protocol
        *)
       (# dopart: @<<SLOT BSocketPutRep:descriptor>>;
       enter header
       do dopart
       #);
     getRepPattern: repIO
       (* Write ExtendedRepstream contents
        * using above mentioned binary protocol
        *)
       (# dopart: @<<SLOT BSocketGetRep:descriptor>>;
       do dopart
       exit header
       #);
     putRepObjPattern: repObjIO
       (* Read to RepetitionObject, using headerless protocol *)
       (# dopart: @<<SLOT BSocketPutRepObj:descriptor>>;
       do dopart
       #);
     getRepObjPattern: repObjIO
       (* Write RepetitionObject, using headerless protocol *)
       (# dopart: @<<SLOT BSocketGetRepObj:descriptor>>;
       do dopart
       #);

     (* nonBlockingScope support *)
     (* PLEASE NOTE: don`t 'leave' a 'nonBlockingScope'. Use 'leaveNBScope'. *)
     nonBlockingScope: (# do <<SLOT BSocketNonBlockingScope:descriptor>> #);
     leaveNBScope: (# do <<SLOT BSocketLeaveNBScope:descriptor>> #);

     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     (* attributes *)
     host: @assignGuard(# t: @text; enter t exit t #);
     port: @assignGuard(# rep: @integer enter rep exit rep #);
     inetAddr: @assignGuard(# rep: @integer enter rep exit rep #); 

     (* private *)
     private: @<<SLOT BSocketPrivate:descriptor>>;
  #); (* BinarySocket *)

ActiveStreamSocket: StreamSocket
  (* Initiator of socket communication. Initialize 'host' and 'port'
   * and 'connect' to a passive socket to establish communication.
   *)
  (#
     (* operations *)
     connect: open
       (# resourceError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          refusedError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          getHostError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          dopart: @<<SLOT ActiveSSocketConnect:descriptor>>;
       enter (host,port)
       do dopart
       #);
  #); (* ActiveStreamSocket *)

ActiveBinarySocket: BinarySocket
  (* Initiator of socket communication. Initialize 'host' and 'port'
   * and 'connect' to a passive socket to establish communication.
   *)
  (#
     (* operations *)
     connect: open
       (# accessError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          refusedError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          getHostError:< loErrCB(# do INNER #);
          dopart: @<<SLOT ActiveBSocketConnect:descriptor>>;
       enter (host,port)
       do dopart
       #);
  #); (* ActiveBinarySocket *)

PassiveStreamSocket: StreamSocket
  (* 'bind' to port and 'awaitConnection'. Other executions can then
   * connect to the port and communicate through the passive socket.
   * Use a 'nonBlockingScope' to interrupt 'awaitConnection', if no
   * connections are being requested.
   *)
  (#
     (* operations *)
     bind:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(PassiveStreamSocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          connBrokenError:< loErrCB(# do INNER #);
          accessError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          usageError:< loErrCB(# do INNER #);
          dopart: @<<SLOT PassiveSSocketBind:descriptor>>;
       enter port
       do dopart          
       #);
     awaitConnection: open
       (# connBrokenError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          dopart: @<<SLOT PassiveSSocketAwait:descriptor>>;
       do dopart
       #);
     close::< (# do <<SLOT PassiveSSocketClose:descriptor>> #);
     forceTimeout::< (# do <<SLOT PassiveSSocketForceTimeout:descriptor>> #);
     usageTimestamp::< (# <<SLOT PassiveSSocketUsageTimestamp:dopart>> #);
     
     (* private *)
     private2: @<<SLOT PassiveSSocketPrivate:descriptor>>;
  #); (* PassiveStreamSocket *)

PassiveBinarySocket: BinarySocket
  (* 'bind' to port and 'awaitConnection'. Other executions can then
   * connect to the port and communicate through the passive socket.
   * Use a 'nonBlockingScope' to interrupt 'awaitConnection', if no
   * connections are being requested.
   *)
  (#
     (* operations *)
     bind:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(PassiveBinarySocket).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          connBrokenError:< loErrCB(# do INNER #);
          accessError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          usageError:< loErrCB(# do INNER #);
          dopart: @<<SLOT PassiveBSocketBind:descriptor>>;
       enter port
       do dopart
       #);
     awaitConnection: open
       (# accessError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          dopart: @<<SLOT PassiveBSocketAwait:descriptor>>;
       do dopart
       #);
     close::< (# do <<SLOT PassiveBSocketClose:descriptor>> #);
     forceTimeout::< (# do <<SLOT PassiveBSocketForceTimeout:descriptor>> #);
     usageTimestamp::< (# <<SLOT PassiveBSocketUsageTimestamp:dopart>> #);
     
     (* private *)
     private2: @<<SLOT PassiveBSocketPrivate:descriptor>>;
  #); (* PassiveBinarySocket *)

SocketGenerator:
  (* Supports creating multiple connections on a single port number;
   * typically used in an application acting as a server for a number
   * of clients. Do 'portNumber -> bind' and use "get???Connection"
   * to establish connections to the clients. Use a 'nonBlockingScope'
   * to avoid waiting if no clients are requesting a connection.
   *
   * "get???Connection" exits a reference to a "???Socket" associated
   * with the new connection. You may use this like:
   *
   *   mySocketGenerator.getStreamConnection -> aStreamSocketRef[];
   *
   * If you want to work with a specialization of the basic socket patterns,
   * furtherbind the virtuals 'streamSocketType' and/or 'binarySocketType'.
   *)
  (#
     (* basics *)
     streamSocketType:< streamSocket;
     binarySocketType:< binarySocket;
     withIdleAndPE:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(socketGenerator).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          usageError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          accessError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          Idle:< (# do INNER; this(socketGenerator).Idle #);
          Blocking:<
            (# continue: (# do true->doContinue #);
               doContinue: @boolean;
            do
               INNER;
               (if doContinue//false then leaveNBScope if);
               Idle;
            #);
       do INNER
       #);
     Idle:< Object; (* every local 'Idle' executes this global one *)

     (* operations *)
     getPortableAddress:
       (# addr: ^portablePortAddress;
          dopart: @<<SLOT SocketGeneratorGetPortableAddress:descriptor>>;
       do dopart
       exit addr[]
       #);
     bind: withIdleAndPE
       (# dopart: @<<SLOT SocketGeneratorBind:descriptor>>;
       enter port
       do dopart
       #);
     close: withIdleAndPE
       (# dopart: @<<SLOT SocketGeneratorClose:descriptor>>;
       do dopart
       #);
     getStreamConnection: withIdleAndPE
       (# sock: ^streamSocketType;
          timeout: @integer;
          dopart: @<<SLOT SocketGeneratorGetStream:descriptor>>;
       enter timeout
       do dopart
       exit sock[]
       #);
     getBinaryConnection: withIdleAndPE
       (# sock: ^binarySocketType;
          timeout: @integer;
          dopart: @<<SLOT SocketGeneratorGetBinary:descriptor>>;
       enter timeout
       do dopart
       exit sock[]
       #);
     forceTimeout: @
       (# dopart: @<<SLOT SocketGeneratorForceTimeout:descriptor>>
       do dopart
       #);
     usageTimestamp: @integerValue
       (#
       <<SLOT SocketGeneratorUsageTimestamp:dopart>>
       #);
     
     (* nonBlockingScope support *)
     (* PLEASE NOTE: don`t 'leave' a 'nonBlockingScope'. Use 'leaveNBScope'. *)
     nonBlockingScope: (# do <<SLOT SocketGeneratorNBScope:descriptor>> #);
     leaveNBScope: (# do <<SLOT SocketGeneratorLeaveNBScope:descriptor>> #);

     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     (* attributes *)
     host: @assignGuard(# t: @text; enter t exit t #);
     port: @assignGuard(# rep: @integer enter rep exit rep #);
     inetAddr: @assignGuard(# rep: @integer enter rep exit rep #); 

     (* private *)
     private: @<<SLOT SocketGeneratorPrivate:descriptor>>;
  #); (* SocketGenerator *)

---]]
