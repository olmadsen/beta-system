ORIGIN '~beta/basiclib/v1.5/basicsystemenv';
INCLUDE 'basicsocket';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1995
 *       All rights reserved.
 *)

BODY 'private/socketgenbody';

--- systemlib:attributes ---

SocketGenerator:
  (#
     <<SLOT socketgeneratorlib:attributes>>;

     
     (* OPERATIONS
      * ==========
      *)

     (* construct portable address for this generator *)
     getPortableAddress:
       (# addr: ^portablePortAddress;
       <<SLOT SocketGeneratorGetPortableAddress:dopart>>
       exit addr[]
       #);

     (* register this generator for others to connect to *)
     bind: withIdleAndPE
       (# 
       enter port
       <<SLOT SocketGeneratorBind:dopart>>
       #);
     
     (* De-register the bind *)
     close: withIdleAndPE
       (# 
       <<SLOT SocketGeneratorClose:dopart>>
       #);

     (* provoke a timeout error in the current operation *)
     forceTimeout: @
       (#
       <<SLOT SocketGeneratorForceTimeout:dopart>>
       #);
     
     (* return timestamp of latest operation on this generator *)
     usageTimestamp: @integerValue
       (#
       <<SLOT SocketGeneratorUsageTimestamp:dopart>>
       #);

     
     (* CALLBACKS
      * =========
      *)

     (* every local 'idle' executes this global one *)
     idle:< object;

     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     
     (* EXPLICIT SCHEDULING
      * ===================
      *)

     (* NB: don`t 'leave' a 'nonBlockingScope'. Use 'leaveNBScope'. *)
     nonBlockingScope: (# <<SLOT SocketGeneratorNBScope:dopart>> #);
     leaveNBScope: (# <<SLOT SocketGeneratorLeaveNBScope:dopart>> #);

     
     (* ATTRIBUTES
      * ==========
      *)
     
     port: @assignGuard(# rep: @integer enter rep exit rep #);


     (* AUXILIARY PATTERNS
      * ==================
      *)
     
     withIdleAndPE:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->this(socketGenerator).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for concrete error callbacks *)
            (#
            do INNER;
               (if errCB_initialValue // value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          usageError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          accessError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          Idle:< (# do INNER; this(socketGenerator).Idle #);
          Blocking:<
            (# continue: (# do true->doContinue #);
               doContinue: @boolean;
            do
               INNER;
               (if doContinue//false then leaveNBScope if);
               Idle;
            #);
       do INNER
       #);


     (* PRIVATE
      * =======
      *)
     
     private: @<<SLOT SocketGeneratorPrivate:descriptor>>;
  #); 

