ORIGIN '~beta/basiclib/basicsystemenv';
LIB_DEF 'processsockgen' '../lib';

(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

INCLUDE 'basicsocket';
BODY 'private/socketgenbody';

--- systemlib:attributes ---

SocketGenerator:
  (# <<SLOT socketgeneratorlib:attributes>>;

     (* OPERATIONS
      * ==========
      *)

     (* Setting 'port'=0 and executing 'bind' gives you 
      * a SocketGeneratorthat accepts connections on a 
      * randomly chosen portnumer, which may be found in 'port'.
      *)
     bind: withIdleAndPE
       (# 
       enter port
       <<SLOT SocketGeneratorBind:dopart>>
       #);
     
     (* construct portable address for this generator *)
     getPortableAddress:
       (# addr: ^portablePortAddress;
       <<SLOT SocketGeneratorGetPortableAddress:dopart>>
       exit addr[]
       #);

     (* De-register the bind *)
     close: withIdleAndPE
       (# 
       <<SLOT SocketGeneratorClose:dopart>>
       #);

     (* provoke a timeout error in the current operation *)
     forceTimeout: @
       (#
       <<SLOT SocketGeneratorForceTimeout:dopart>>
       #);
     
     (* return timestamp of latest operation on this generator *)
     usageTimestamp: @integerValue
       (#
       <<SLOT SocketGeneratorUsageTimestamp:dopart>>
       #);

     
     (* CALLBACKS
      * =========
      *)

     (* every local 'idle' executes this global one *)
     idle:< object;

     (* socket level error callback *)
     error:< hiErrCB(# do INNER #);

     
     (* EXPLICIT SCHEDULING
      * ===================
      *)

     (* NB: don`t 'leave' a 'nonBlockingScope'. 
      * Use 'leaveNBScope'. 
      *)
     nonBlockingScope: (# <<SLOT SocketGeneratorNBScope:dopart>> #);
     leaveNBScope: (# <<SLOT SocketGeneratorLeaveNBScope:dopart>> #);

     
     (* ATTRIBUTES
      * ==========
      *)
     
     port: @assignGuard(# rep: @integer enter rep exit rep #);


     (* AUXILIARY PATTERNS
      * ==================
      *)
     
     withIdleAndPE:
       (# error:< hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if errCB_initialValue=value then 
                   (value,cleanup[])->
                   this(socketGenerator).error->value;
               if);
            #);
          loErrCB: errCB (* superpattern for 
                          * concrete error callbacks 
                          *)
            (#
            do INNER;
               (if errCB_initialValue=value then 
                   (value,cleanup[])->error->value;
               if);
            #);
          usageError:< loErrCB(# do INNER #);
          resourceError:< loErrCB(# do INNER #);
          accessError:< loErrCB(# do INNER #);
          addressError:< loErrCB(# do INNER #);
          connBrokenError:< loErrCB(# do INNER #);
          intrError:< loErrCB(# do INNER #);
          internalError:< loErrCB(# do INNER #);
          unknownError:< loErrCB(# do INNER #);
          timedOut:< loErrCB(# do INNER #);
          Idle:< (# do INNER; this(socketGenerator).Idle #);
          Blocking:<
            (# continue: (# do true->doContinue #);
               doContinue: @boolean;
            do
               INNER;
               (if not doContinue then leaveNBScope if);
               Idle;
            #);
       do INNER
       #);


     (* PRIVATE
      * =======
      *)
     
     private: @<<SLOT SocketGeneratorPrivate:descriptor>>;
  #); 
