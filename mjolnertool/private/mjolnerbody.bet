ORIGIN '../mjolner';
LIB_ITEM 'mjolnertool';
MDBODY nti 'mjolner_ntibody'
       mac 'mjolner_macbody'
       ppc 'mjolner_macbody'
       ppcmac 'mjolner_macbody'
       default 'mjolner_unixbody';
(* ************************************
 * WARNING: this is the new mjolnerbody 
 * ************************************)
-- askKillPrograms: DoPart --
do
   programs.scan
     (# 
     do
        (if current.stillRunning then
            current.name.copy->msg[];
            ' is still running, should this program be killed?'->msg.append;
            (none ,'Kill program',msg[])
              ->gui.promptForBoolean
                (#
                   ok::< 
                     (# 
                     do
                        current.stop;
                        current.awaitStopped;
                        current[]->programs.at->programs.delete
                     #);
                   notOK::<  (#  do  #);
                   cancel::<  (#  do  #)
                #)
         else
            current[]->programs.at->programs.delete
        if)
     #)  

-- killProgram: DoPart --
do
   programs.scan
     (# 
     do
        (if current.name[]->name.equal then
            current.stop;
            current.awaitStopped;
            current[]->programs.at->programs.delete
        if)
     #)  

-- isProgramRunning: DoPart --
do
   programs.scan
     (# 
     do
        (if current.name[]->name.equal then
            current.stillRunning->value;
            (if not value then current[]->programs.at->programs.delete if)
        if)
     #)  

-- valhallaKillProgram: DoPart --
do
   sif.programs.scan
     (# 
     do
        (if current.name[]->name.equal then
            current.stop;
            current.awaitStopped;
            current[]->sif.programs.at->sif.programs.delete
        if)
     #)  

-- valhallaIsProgramRunning: DoPart --
do
   sif.programs.scan
     (# 
     do
        (if current.name[]->name.equal then
            current.stillRunning->value;
            (if not value then
                current[]->sif.programs.at->sif.programs.delete
            if)
        if)
     #)  

-- executeProgram: DoPart --
do
   name[]->p.init;
   p.start
     (#
        error:: 
          (# msg: ^text
          do
             'Error: Could not start: '->msg;
             name[]->msg.append;
             (none ,msg[],'Run')->gui.alertUser
          #);
        twoCurrent:: 
          (# 
          do
             'Two current processes: Could not start: '->msg;
             name[]->msg.append;
             (none ,msg[],'Run')->gui.alertUser
          #)
     #);
   p[]->programs.append  

-- readArguments: DoPart --
do
   (for i: noOfArguments-1 repeat
     i+1->argumenthandler.getArgByNumber->arguments.append; ' '->arguments.put
   for);
   arguments.reset;
   '--freja'->arguments.findText (#  do inx->frejapos;  #);
   '--valhalla'->arguments.findText (#  do inx->valhallapos #);
   (if frejapos > 0 then
       (if valhallapos > 0 then
           (frejapos+7,valhallapos-1)->arguments.sub->frejaarguments[];
           (valhallapos,arguments.length)->arguments.sub->valhallaarguments[];
           valhallaarguments->valhallaprefs.ValhallaArguments
        else
           (frejapos+7,arguments.length)->arguments.sub->frejaarguments[]
       if)
    else
       (if valhallapos > 0 then
           (valhallapos+10,arguments.length)->arguments.sub
             ->valhallaarguments[];
           valhallaarguments.reset;
           valhallaarguments->valhallaprefs.ValhallaArguments
       if)
   if);
   (if frejapos > 0 then
       frejapos-1->mjolnerend (* find out where mjolners options ends *)
    else
       (if valhallapos > 0 then
           valhallapos-1->mjolnerend
        else
           arguments.length->mjolnerend
       if)
   if);
   (0,mjolnerend)->arguments.sub->mjolnerarguments[];
     

-- theSystemEnv: DoPart --
do
   &| mjolnerDoitHandler[]->fork;
   gui[]->ymer.init;
   welcome[]->putLine;
   setupValhalla;
   compilerPrefs.open
     (# 
     do
        compilerPrefs.registerCompileroptions;
        compilerPrefs.registerCompilerCmdoptions;
        true->compilerPrefs.debuginformation;
        true->compilerPrefs.quacheck;
        true->compilerPrefs.warnings
     #);
   compilerPrefs[]->objectpool.put;
   editorPrefs.open
     (#  do editorPrefs.registerEditoroptions;  #);
   editorPrefs[]->objectpool.put;
   (mjolneroptionsname,editorPrefs.sectionname)
     ->editorPrefs.load
       (# Optionserror::  (#  do (*  msg[]->screen.puttext; *)  #); 
       #);
   (if editorPrefs.OpenLogWindow then ymer.logwin.show if);
   (mjolneroptionsname,valhallaPrefs.sectionname)
     ->valhallaPrefs.load
       (# Optionserror::  (#  do (*  msg[]->screen.puttext; *)  #); 
       #);
   (mjolneroptionsname,compilerPrefs.sectionname)
     ->compilerPrefs.load
       (# Optionserror::  (#  do (*  msg[]->screen.puttext; *)  #); 
       #);
   frejaPrefs.open
     (#  do frejaPrefs.registerFrejaCmdOptions;  #);
   frejaPrefs[]->objectPool.put;
   readArguments;
   mjolnerarguments[]->mjolnerPrefs.readArguments;
   frejaarguments[]->frejaPrefs.readArguments;
   ymer.getInterface->sif.init;
   ymer.getInterface->frigg.init;
   ymer.getInterface->frej.init;
   (* ymer.getInterface->knight.init; *)
   Setup;
   setupMenus;
   ymer.newbrowser;
   writeCompilerAndRuntimeSystemVersion;
   (if mjolnerprefs.noOfArgs > 0 then
       mjolnerprefs.scanArguments
         (# fgname,ffname: ^text; f: @file; 
         do current[]->ExternalAppendProject
         #)
   if)  

-- untitledExists: DoPart --
do
   'untitled1'->f.name;
   'untitled1'->astFileName[];
   ymerBrowser.edenv.mps.astFileExtension->astFileName.append;
   astFileName[]->astFile.name;
   'untitled1'->textFileName[];
   '.bet'->textFileName.append;
   textFileName[]->textFile.name;
   (if f.entry.exists or astFile.entry.exists or textFile.entry.exists then
       true->value
   if)  

-- ExternalAppendProject: DoPart --
do
   name[]->sif.analyzeArg->(fgname[],ffname[]);
   (if fgname.length > 0 then
       (if ffname.length > 0 then
           fgname[]->f.name;
           (if f.entry.exists then
               (if ffname.length > 0 then
                   fgname[]->ymerBrowser.appendProject;
                   (fgname[],ffname[])->ymerBrowser.selectFragmentform
                else
                   fgname[]->ymerbrowser.appendProject
               if);
               
           if)
        else
           fgname[]->ymerbrowser.appendProject
       if)
   if);
   ymerbrowser.appendDone  

-- myCallBack: DoPart --
do
   browserInt[]->ymerBrowser[];
   (* freja setup *)
   frej.theExternalInterface[]->browserInt.edenv.frejaExternalInterface[];
   (* sif setup *)
   &sif.sifBrowserWindowExt[]->lastWEXT[];
   lastWEXT.externalInterface[]->browserInt.sifExternalInterface[];
   BrowserInt[]->lastWEXT.init;
   lastWEXT.ymerCallBack[]->ymerCallBack[];
   (* frigginterface *)
   (*    browserInt[]->frej.initFrejaWindow;  *)
   &frigg.friggBrowserWindowExt[]->lastFriggExt[];
   frigg.externalInterface[]->browserInt.friggExternalInterface[];
   BrowserInt[]->lastFriggExt.init;
   lastWEXT.setupFileMenu;
   (if not firstBrowser then
       browserInt[]->frej.initFrejaWindow;
       browserInt.Ymerbrowser.SetMjolnerIcon;
       BrowserInt[]->valhalla.sources[];
       valhalla.valhallainit;
       true->firstBrowser;
       (* fileMenu *)
       &gui.menuAppendItemAction
         (#
            iOptions: theMenu.item
              (#
                 prefwin: @gui.preferencesDialog
                   (#
                      isopened,ishidden: @boolean;
                      onCloseOK:: 
                        (# 
                        do
                           prefwin.tabcontrols.valhallaPreferences.pcanvas.
                             booloptions.savestate;
                           prefwin.tabcontrols.compilerPreferences.savestate;
                           prefwin.tabcontrols.editorPreferences.savestate;
                           (mjolneroptionsname,valhallaprefs.sectionname)
                             ->valhallaprefs.save;
                           (mjolneroptionsname,compilerprefs.sectionname)
                             ->compilerprefs.save;
                           (mjolneroptionsname,editorprefs.sectionname)
                             ->editorprefs.save
                        #);
                      onHide::  (#  do true->ishidden;  #)
                   #);
                 onSelect:: 
                   (# 
                   do
                      valhallaPrefs[]
                        ->
                          prefwin.tabcontrols.valhallaPreferences.pcanvas.
                            Prefs[];
                      compilerPrefs[]
                        ->
                          prefwin.tabcontrols.compilerPreferences.pcanvas.
                            Prefs[];
                      editorPrefs[]
                        ->prefwin.tabcontrols.editorPreferences.pcanvas.Prefs[];
                      (if not prefwin.isopened then
                          prefwin.open; true->prefwin.isopened; 
                       else
                          prefwin.show; prefwin.bringtofront; 
                      if)
                   #)
              #);
            item: ^themenu.item;
            
         do &iOptions[]->item[]; 'Preferences...'->item.new; 
         #)[]->ymer.fileMenuActionList.append
   if);
   (* valhalla *)
   valhalla.ExternalInterface[]->browserInt.debuggerExternalInterface[]  

-- SetUpMenus: DoPart --
do (* Fragmentbrowser, appends to list *)
   sif.setupMenus;
   &gui.MenubarAppendMenuAction
     (#  do theMenuBar[]->lastWEXT.setupMenus;  #)[]
     ->ymer.menuActionList.append;
   (* frigg.setupmenus;
    frej.setupmenus;*)
     

-- setupValhalla: DoPart --
do
   &myvalhalla[]->valhalla[];
   valhallaPrefs.open
     (# 
     do
        valhallaprefs.registerVALHALLAoptions;
        true->valhallaprefs.dynamiccompilation;
        true->valhallaprefs.showEvaluator
     #);
   valhallaPrefs[]->objectpool.put;
   valhallaPrefs[]->valhalla.valhallaPrefs[];
   valhalla.globaloptions.init;
   valhalla.globaloptions[]->objectpool.put;
   valhallaprefs[]->obp.p[];
   obp[]->objectpool.put  

-- valhallainit: DoPart --
do
   ymer.gui[]->gui[];
   ymer.mps[]->mps[];
   false->isStandAloneValhalla->isDebugging;
   init;
   main.open;
   main.theMenuBar->main.mainMenuBar[];
     

-- myvalhalla: DoPart --
do
   true->isStandAloneValhalla;
   true->valhallaPrefs.dynamiccompilation;
   true->valhallaPrefs.showEvaluator;
     

-- MjolnerDoitHandler: DoPart --
do
   port
     ->streamGen.bind
       (#
          error:: 
            (#  do true->SocketFailedFlag; errCB_abortOperation->value #)
       #);
   (if SocketFailedFlag then
       THIS(MjolnerDoitHandler)[]->ObjectToComponent->kill
   if);
   cycle
     (# 
     do
        false->SocketFailedFlag;
        waitForever
          ->streamGen.getStreamConnection (# sockType:: ClientSockType #)
          ->clientSock[];
        (if not SocketFailedFlag then
            clientSock.getLine->t[];
            (if not SocketFailedFlag then
                t.reset;
                t.getAtom->cmd[];
                (if true
                 // 'Start'->cmd.equal then (* Ignore *)
                    
                 // 'OpenFile'->cmd.equal then
                    (t.getpos+2,99999)->t.sub->ExternalAppendProject; 
                 else
                    'Mjolner: Got "'->screen.putText;
                    t[]->screen.putText;
                    '" which is not a legal command'->screen.putLine;
                    
                if);
                
             else
                'MjolnerDoitHandler: failed to getLine'->screen.putLine; 
            if);
            clientSock.close;
            
        if);
        
     #);
     

-- MjolnerSetCompilerOptions: DoPart --
do
   compiler[]->sifcompiler[];
   &sifcompiler.setswitch[]->sw[];
   (not compilerPrefs.warnings,90)->sw;
   (not compilerPrefs.warnings,19)->sw;
   (not compilerPrefs.QuaCheck,19)->sw;
   (not compilerPrefs.link,6)->sw;
   (compilerPrefs.static,17)->sw;
   (compilerPrefs.dynamic,17)->sw;
   &text[]->swtext[];
   (compilerPrefs.switch).scan
     (#  do current[]->swtext.append; ' '->swtext.put;  #);
   '0 '->swtext.append;
   swtext.reset;
   swtext[]->sifcompiler.trans.readswitches;
   &text[]->swtext[];
   (compilerPrefs.betarun).scan
     (#  do current->swtext;  #);
   (if swtext.length > 0 then swtext.copy->sifcompiler.betarunSwitch[];  if)  

