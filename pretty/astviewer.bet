ORIGIN '~beta/mps/v4.9.1/astlevel';
BODY 'private/ppImpl'
     'private/doupdatelist'
     'private/unparser';
INCLUDE '~beta/mps/v4.9.1/metagrammarcfl';
(* COPYRIGHT
 *      Copyright (C) Mjolner Informatics, 1986-94
 *       All rights reserved.
 *)
-- astInterfaceLib: Attributes --
(* The prettyprinter uses the adaptive prettyprinting algorithm by
 * D.C. Oppen: Prettyprinting,
 * ACM Transaction on Programming Languages and Systems Vol 2. No. 4,
 * October 1980, Pages 465-483.
 * 
 * Per Fack S|rensen, DAIMI, 24. aug. 1987 *)
(* PFS: 2/12: converted to new syntax *)
(* PSF: 11/12: comment-specification added *)
(* PFS: 11/12: not compatible with 'addatt' versions before v2.1 (incl.) *)
(* PFS: 11/12: not compatible with 'pretty.gram' versions before v1.0 (incl.) *)
(* PFS: 21/12: incremental update of list-elements *)
(* ESS: 28/1/88: added new token type: COMMENTMARK *)
(* ESS: 04/2/90: added new token type: COMMENTLINK *)
ASTViewer:
  (#
     frag: ^fragmentform;
     pp: @Viewer;
     isAnchor:<
       (# node: @integer; value: @boolean
       enter node
       do INNER
       exit value
       #);
     Viewer:
       (#
          point: (# x,y: @integer;  enter (x,y) exit (x,y) #);
          width: @integer;
          ppDebug,ppTrace: @boolean;
          editorMode: @boolean;
          (* If true shadow trees and hashtables are generated.
           * When producing the text file from the ast these
           * data structures are not needed.
           * This will hopefully speed up the prettyprinter
           * when used in the compiler or when updating the text file
           * in the editor.
           *)
          noComment: (#  exit - 1 #);
          normalComment: (#  exit 1 #);
          holoComment: (#  exit 2 #);
          holoCommentOff: (#  exit 3 #);
          breakpointComment: (#  exit 4 #);
          propertyComment: (#  exit 17 #);
          (* The following booleans are added by ESS 11-01-88 *)
          includeComments: @boolean;
          (* if true comments are included in the pretty print *)
          parsingInformation: @boolean;
          (* if true parsing information is included in the holocomment
           * like: <<4711@synCatName>> 
           * 4711 is a reference to the supressed AST node
           * if false it is presented like described
           * under synCatInformation
           *)
          synCatInformation: @boolean;
          (* if true the syntactic category is included in the holocomment,
           * like: ...synCatName... else it is presented as: ...
           *)
          abstractPresentation: @boolean;
          (* if false holocomments are ignored  ESS 12-2-88 *)
          specialLexemTreatment: @boolean;
          (* OA, 12/9-88 *)
          (* if true, lexems are handled through out.printLexem *)
          specialCommentTreatment: @boolean;
          (* OA, 12/9-88 *)
          (* if true, comments are handled through out.printComment *)
          (* added by JLK to prepare for making the PP use the correct symbols
           * for comments, string-quotes and fragment syntax
           *)
          comBegin,comEnd,EOSchar: @text;
          stringChar: @char;
          comBeginLength,comEndLength: @integer;
          init:
            (#
               ppSpecification:<
                 (# 
                 do grammarName[]->ppSpecName[]; INNER
                 exit ppSpecName[]
                 #);
               grammarName,ppSpecName: ^text;
               
            enter grammarName[]
            do <<SLOT doInit:Descriptor>>
            #);
          reInit:
            (#
               ppSpecName: ^text;
               (* can be used to alternate between pp specs *)
               
            enter ppSpecName[]
            do <<SLOT doReInit:Descriptor>>
            #);
          present:
            (#
               theAST: ^ast;
               depth: @integer;
               (* No of levels in theAST to print. *)
               
            enter (theAST[],depth)
            do <<SLOT doPresent:Descriptor>>
            #);
          Update:
            (# oldAST,newAST,theAST: ^ast; 
            enter (oldAST[],newAST[])
            do <<SLOT doUpdate:Descriptor>>
            #);
          Hit:
            (#
               x,y,x0,
                 y0: @integer;
               theAST: ^ast;
               subCommentInx1,subCommentInx2: @integer;
               
            enter (x0,y0)
            do (x0-1,y0-1)->(x,y); <<SLOT doHit:Descriptor>>
            exit (theAST[],subCommentInx1,subCommentInx2)
            #);
          Select:
            (#
               theAST: ^ast;
               subCommentInx1,subCommentInx2: @integer;
               UL,LR: @point;
               
            enter (theAST[],subCommentInx1,subCommentInx2)
            do <<SLOT doSelect:Descriptor>>
            exit (UL.X+1,UL.y+1,LR.x+1,LR.y+1)
            #);
          Resized:
            (# theAST: ^ast; dx,dy: @integer; 
            enter (theAST[],dx,dy)
            do <<SLOT doResize:Descriptor>>
            #);
          UpdateList:
            (#
               theList:
                 ^ast;
               sonNumber,deleted,added: @integer;
               
            enter (theList[],sonNumber,deleted,added)
            do <<SLOT doUpdateList:Descriptor>>
            #);
          createEmptyComment:
            (#
            (* creates a text with the right number of separators *)
               node: ^ast; t: ^text
            enter node[]
            do <<SLOT CreateEmptyComment:Descriptor>>
            exit t[]
            #);
          ppInsertSubcomment:
            (#
            (* Inserts 'theText' as subcomment before son number 'inx'
             * of 'node' (noOfSons+1 if after last son)
             * 'subinx' is the subsequence number, if subinx>1, 
             * several subcomments exists in sequence e.g. between 
             * sons of 'node'
             * If doupdate is true the prettyprint is updated
             *)
               node: ^ast;
               inx,subinx: @integer;
               theText: ^text;
               doupdate: @boolean;
               
            enter (node[],inx,subinx,theText[],doupdate)
            do <<SLOT ppInsertSubcomment:Descriptor>>
            #);
          ppAppendSubcomment:
            (#
            (* Appends 'theText' as the first subcomment after 
             * the last son of 'node'. 
             * If doupdate is true the prettyprint is updated
             * The actual position between the sons of 'node'
             * is returned in 'inx'
             *)
               node: ^ast; theText: ^text; doupdate: @boolean; inx: @integer
            enter (node[],theText[],doupdate)
            do <<SLOT ppAppendSubcomment:Descriptor>>
            exit inx
            #);
          ppClearSubcomment:
            (#
            (* Deletes the subcomment at the position (inx,subinx)
             * If doupdate is true the prettyprint is updated
             * *) node: ^ast; inx,subinx: @integer; doupdate: @boolean
            enter (node[],inx,subinx,doupdate)
            do <<SLOT ppClearSubcomment:Descriptor>>
            #);
          startDebug:
            (# 
            do
               <<SLOT debugInit:Descriptor>>
            #);
          SaveState:
          (* Save the state of the pretty-printer.
           NOTE: The prettyprint specification table,
           PST, is NOT saved.
           The state will be saved on files 
           xx.*, where xx is the name entered.
           *)
            (# fileName: ^text; 
            enter fileName[]
            do <<SLOT savestate:Descriptor>>
            #);
          LoadState:
          (* Restore a previously saved state.
           The entered filename must be one, which
           has been used in SaveState earlier.
           *)
            (# fileName: ^text; 
            enter fileName[]
            do <<SLOT loadstate:Descriptor>>
            #);
          EraseState:
          (* Erase the files from a previously saved state.
           The entered filename must be one, which
           has been used in SaveState earlier.
           *)
            (# fileName: ^text; 
            enter fileName[]
            do <<SLOT erasestate:Descriptor>>
            #);
          (* Private. *)
          (* Token identifications *)
          BEGINPROD: (#  exit 2000 #);
          ENDPROD: (#  exit 2001 #);
          UNEXP: (#  exit 2002 #);
          IDENTIFIER: (#  exit 2003 #);
          STRING: (#  exit 2004 #);
          CONSTANT: (#  exit 2005 #);
          CONSISTENTBLOCK: (#  exit 2006 #);
          INCONSISTENTBLOCK:
            (#  exit 2007 #);
          ENDBLOCK: (#  exit 2008 #);
          BREAK: (#  exit 2009 #);
          FITTINGBLOCK: (#  exit 2010 #);
          TERM: (#  exit 2011 #);
          NONT: (#  exit 2012 #);
          FULLCOMMENT: (#  exit 2013 #);
          HOLOCOMMENTBEGIN: (#  exit 2014 #);
          HOLOCOMMENTNODE: (#  exit 2015 #);
          HOLOCOMMENTEND: (#  exit 2016 #);
          COMPANYON: (#  exit 2017 #);
          COMPANYOFF: (#  exit 2018 #);
          COMMENTMARK: (#  exit 2019 #);
          SLOTTOKEN: (#  exit 2020 #);
          SPECIALLEXEM: (#  exit 2021 #);
          (* OA, 12/09-88 *)
          SPECIALCOMMENT: (#  exit 2022 #);
          (* OA, 12/09-88 *)
          COMMENTLINK: (#  exit 2023 #);
          OPTIONAL: (#  exit 2024 #);
          (* ESS, 15/08-90 *)
          COMPRESSED: (#  exit 2025 #);
          (* ESS, 08/11-91 *)
          COMMENTLINKANDMARK:
            (#  exit 2026 #);
          (* ESS, 14/05-92 *)
          COMMENTPROP: (#  exit 2027 #);
          (* ESS, 16/06-92 *)
          BEGINCOM: (#  exit 2028 #);
          (* ESS, 09/09-93 *)
          ENDCOM: (#  exit 2029 #);
          (* ESS, 16/5/94 *)
          SEMANTICERROR: (#  exit 2030 #);
          COMMENTBREAKPOINT:
            (#  exit 2031 #);
          DEBUG:
            (# n: @integer; 
            enter n
            do
               (if DS[n]
                // true then INNER
               if)
            #);
          TokenEnv: <<SLOT tokenEnv:Descriptor>>;
          ListEnv: <<SLOT listEnv:Descriptor>>;
          hashtable:
           <<SLOT hashTableImpl:Descriptor>>;
          shadowAst: <<SLOT shadowAst:Descriptor>>;
          PSTable: <<SLOT PSTable:Descriptor>>;
          unparser:
           <<SLOT unparser:Descriptor>>;
          scanner: <<SLOT scanner:Descriptor>>;
          printer: <<SLOT printer:Descriptor>>;
          updatePositions:
           <<SLOT updatePositions:Descriptor>>;
          Stack: <<SLOT stack:Descriptor>>;
          SAST: ^shadowAST;
          PST: ^PSTable;
          TE: ^TokenEnv;
          LE: ^ListEnv;
          NT: ^hashtable;
          theUnparser: ^unparser;
          theScanner: ^Scanner;
          thePrinter: ^printer;
          DS: [100] @boolean;
          
       do INNER ; 
       #);
     out: ^output;
     output:
       (#
          lineNo: @integer;
          beforePresent:< (#  do INNER #);
          afterPresent:< (#  do INNER #);
          beforeUpdate:< (#  do INNER #);
          afterUpdate:< (#  do INNER #);
          put:<
            (# ch: @char enter ch do INNER #);
          putText:<
            (# s: ^text enter s[] do INNER #);
          putInt:<
            (# n,w: @integer
            enter (n,w)
            do INNER
            #);
          printError:<
            (# theAst: ^ast
            enter theAst[]
            do INNER
            #);
          measureSpecialLexem:<
            (# lt: ^lexemText; length: @integer
            enter lt[]
            do INNER
            exit length
            #);
          printSpecialLexem:<
            (#
               lt: ^lexemText;
               margin,lineNo,noOfLines,
                 lengthOfLastLine: @integer
            enter (lt[],lineNo,margin)
            do INNER
            exit (noOfLines,lengthOfLastLine)
            #);
          measureSpecialComment:<
            (# com: ^text; length: @integer
            enter com[]
            do INNER
            exit length
            #);
          printSpecialComment:<
            (#
               com: ^text;
               margin,lineNo,noOfLines,
                 lengthOfLastLine: @integer
            enter (com[],lineNo,margin)
            do INNER
            exit (noOfLines,lengthOfLastLine)
            #);
          measureCommentProp:<
            (# prop: ^propertyList; length: @integer
            enter prop[]
            do INNER
            exit length
            #);
          printCommentProp:<
            (#
               prop: ^propertyList;
               margin,lineNo,noOfLines,
                 lengthOfLastLine: @integer
            enter (prop[],lineNo,margin)
            do INNER
            exit (noOfLines,lengthOfLastLine)
            #);
          selectArea:<
            (# row1,col1,row2,col2: @integer
            enter (row1,col1,row2,col2)
            do INNER
            #);
          startBold:< (#  do INNER #);
          endBold:< (#  do INNER #);
          startSmall:< (#  do INNER #);
          endSmall:< (#  do INNER #);
          clear:< (#  do INNER #);
          newLine:<
            (#  enter lineNo do INNER #);
          init:< (#  do INNER #);
          finish:< (#  do INNER #);
          insertLine:<
            (# lineNo: @integer; 
            enter lineNo
            do INNER
            #);
          deleteLine:<
            (# lineNo: @integer; 
            enter lineNo
            do INNER
            #);
          deleteLines:<
            (# lineNo,number: @integer; 
            enter (lineNo,number)
            do INNER
            #);
          deleteArea:<
            (# line1,line2,pos1,pos2: @integer
            enter (line1,pos1,line2,pos2)
            do INNER
            #);
          getLine:<
            (# lineNo: @integer; s: ^text
            enter lineNo
            do INNER
            exit s[]
            #);
          Sput: @put;
          SputText: @putText;
          SputInt: @putInt;
          SnewLine: @newLine;
          
       do INNER
       #);
     (* Private. *)
     SaveArray:
     (* Pattern to save a repetition on a file. *)
       (# FR: @FileRep; filename: ^text; r: [1] @integer; 
       enter (filename[],r)
       do r.range+1->FR.Top; r->FR.R; filename[]->FR.Save; 
       #);
     LoadArray: (* Pattern to load a repetition from a file. *)
       (# FR: @FileRep;  enter FR.Restore exit FR.R #);
     DeleteFile: (* Pattern to delete a named file. *)
       (# F: @File;  enter F.name do F.Delete;  #);
     
  do INNER
  #);
(* astEnv *)
  

