ORIGIN 'astviewer';
INCLUDE '~beta/betaast/semanticerrortext'
        '~beta/basiclib/file'
        '~beta/basiclib/textUtils';
BODY 'private/pplibbody';
LIB_DEF 'prettyprinterpplib' '../lib';
(* COPYRIGHT
 *      Copyright (C) Aarhus University
 *       All rights reserved.
 *)
-- Lib: Attributes --
prettyprintFragment: booleanValue
  (#
     mps: ^astInterface;
     f: ^mps.fragment;
     outStream: ^stream;
     (* if none then if streamName is empty then on screen else on file *)
     streamName: ^text;
     node: (# aNode: ^mps.ast do INNER exit aNode[] #);
     width:< (# value: @integer do 80->value; INNER exit value #);
     abstractPresentation:< booleanValue;
     showSemanticErrors:< booleanValue;
     includeComments:< trueObject;
     onlyProperties:< booleanValue;
     test:< booleanValue
  enter (mps[],f[],outStream[],streamName[])
  <<SLOT prettyprintFragment:DoPart>>
  #);
ppFragment: booleanValue
  (#
     mps: ^astInterface;
     f: ^mps.fragment;
     node: ^mps.ast;
     astView: ^mps.astviewer;
     outStream: ^stream;
     outputStream: astView.output
       (#
          put::< 
            (#  do ch->outStream.put #);
          putText::< 
            (# 
            do s[]->outStream.putText
            #);
          putInt::< 
            (# 
            do n->outStream.putInt
            #);
          newLine::< 
            (#  do outStream.newLine #);
          printError::< 
            (# 
            do
               (if showSemanticErrors then
                   newLine;
                   '***** '->putText;
                   theAst.semanticError
                     -> mps.semanticErrorText
                     -> putText;
                   newLine;
                   
               if)
            #);
          printSpecialComment::< 
            (#
               skipLeadingBlanks: @boolean; 
            do
               0->noOfLines;
               astView.pp.comBegin.lgth
                 ->lengthOfLastLine;
               astView.pp.comBegin[]
                 ->putText;
               false->skipLeadingBlanks;
               com.scanAll
                 (# 
                 do
                    (if ch = ascii.newLine
                     then
                        noOfLines+1->noOfLines;
                        1->lengthOfLastLine;
                        lineNo+1->lineNo;
                        lineNo->newLine;
                        (for margin+1 repeat ' '->put for);
                        true->skipLeadingBlanks;
                        
                     else
                        (if skipLeadingBlanks then
                            (if not (ch->ascii.isSpace) then
                                ch->put;
                                lengthOfLastLine+1->lengthOfLastLine;
                                false->skipLeadingBlanks
                            if)
                         else
                        (* skipping tabs *)
                            (if (ch->ascii.isSpace) then
                                (if ch = ascii.sp then
                                    ch->put;
                                    lengthOfLastLine+1->lengthOfLastLine;
                                    
                                 else
                                    'eating tabs in comment: '->screen.putText;
                                    ch->screen.putInt;
                                    screen.newLine;
                                    ' '->put;
                                    
                                if)
                             else
                                ch->put; lengthOfLastLine+1->lengthOfLastLine; 
                            if);
                            
                        if);
                        
                    if);
                    
                 #);
               lengthOfLastLine+astView.pp.comEnd.lgth->lengthOfLastLine;
               astView.pp.comEnd[]->putText;
               
            #);
          measureSpecialComment::< 
            (# 
            do
               (if (com.lgth > 40) then
                   100
                     ->length
                     (* only used to provoke a break
                      * the length 
                      *)
               if);
               
            #);
          scanWords:
            (# t: ^text; word: ^text; 
            enter t[]
            do (*'scanWords begin on:'->putL;
                t[]->putL;*)
               t.reset;
               loop:
                 (# 
                 do
                    t.getAtom->word[];
                    INNER scanWords;
                    (if not t.eos then restart loop if);
                    
                 #);
               (*'scanWords end'->putL;*)
               
            #);
          printSpecialLexem::< 
            (# t,outt: ^text; firstWord,isString: @boolean; 
            do
               false->isString;
               (if lt.kind = mps.kinds.string then true->isString if);
               0->noOfLines;
               lt.getText->t[];
               &text[]->outt[];
               outt.reset;
               true->firstWord;
               (if LongLexemsWithQuote and IsString then
                   1->lengthOfLastLine
                else
                   0->lengthOfLastLine
               if);
               t[]
                 ->scanWords
                   (# 
                   do
                      (if not
                      (outt.length+word.length+margin > astView.pp.width-5
                       (*scroll bar*) ) then
                          (if not firstWord then
                              ' '->outt.put;
                              lengthOfLastLine+1->lengthOfLastLine;
                              
                           else
                              (if LongLexemsWithQuote and IsString then
                                  astView.pp.stringChar->outt.put; 
                              if)
                          if);
                          lengthOfLastLine+word.length->lengthOfLastLine;
                          word[]->outt.putText;
                          false->firstWord;
                          
                       else
                      (* break line and empty outt *)
                          outt[]->putText;
                          &text[]->outt[];
                          outt.reset;
                          lineNo+1->lineNo;
                          lineNo->newLine;
                          noOfLines+1->noOfLines;
                          (for margin repeat ' '->put;  for);
                          word[]->outt.putText;
                          word.length->lengthOfLastLine;
                          
                      if);
                      
                   #);
               (if (outt.length > 0) then
                   (if LongLexemsWithQuote and IsString then
                       astView.pp.stringChar->outt.put;
                       lengthOfLastLine+1->lengthOfLastLine;
                       
                   if);
                   outt[]->putText;
                   
               if);
               
            #);
          measureSpecialLexem::< 
            (# t: ^text; 
            do
               lt.getText->t[];
               (if (t.lgth > 40) then
                   100
                     ->length
                     (* only used to provoke a break
                      * the length 
                      *)
               if);
               
            #)
       #);
     streamName: ^text;
     width,depth: @integer;
     abstractPresentation,showSemanticErrors,includeComments,parsingInformation,
       specialLexemTreatment,specialCommentTreatment,longLexemsWithQuote:
       @boolean;
     ppSpec: ^text;
     onlyProperties,astDump,test: @boolean
  enter
  (mps[],f[],node[],outStream[],streamName[],width,depth,abstractPresentation,
   showSemanticErrors,includeComments,parsingInformation,specialLexemTreatment,
   longLexemsWithQuote,specialCommentTreatment,ppSpec[],onlyProperties,astDump,
   test)
  <<SLOT ppFragment:DoPart>>
  #)  

