origin '../astviewer'
(* COPYRIGHT
 *      Copyright (C) Mjolner Informatics, 1986-94
 *       All rights reserved.
 *)
--listEnv: DescriptorForm--
(* Per Fack S|rensen, DAIMI, 24. aug. 1987 *)
  (# (* List element:  ( value next )                          *)
  (* next is a reference to the next list-element           *)
  (* next = freeValue:	element is free               *)
  (* NULL is the reference to the empty list                *)
  (* Storage-administration is attended by the attributes   *)
  (* new and kill                                           *)
     NULL: (# exit 0 #);
     initialListSize: (# exit 1500 (* was 8000!!! *) #);
     (*A measurement has shown that to print the fragment
      unparser.bet, between 11000 and 17000 entries are
      needed in the list. Now unparser is a rather large
      fragment, so ...
      *)
     Initialize:
       (#
       do
          initialListSize->maxList;
          (for i: maxList repeat freeValue->nxt[i] for);
          1->firstFree;
          (if ppTrace
           // true then
              'List.initialSize     = '->putText;
              initialListSize->putInt;
              newLine
          if);
       #);
     List:
       (#
          Value: (# enter val[index] exit val[index] #);
          Next: (# enter nxt[index] exit nxt[index] #);
          Clear: (# do NULL->index #);
          Prepend:
            (# aList,L: @integer
            enter aList->L
            do
               (if (L <> NULL)
                // true then
                   findEnd :
                   (if (nxt[L] <> NULL)
                    // true then nxt[L]->L; restart findEnd;
                   if);
                   index (* self *) ->nxt[L];
                   aList->index;
               if);
            #);
          Scan: (* don't change list within scan *)
            (# thisList: @list;
            do
               index (* self *) ->thisList;
               loop :
               (if (thisList <> NULL)
                // true then INNER ; nxt[thisList]->thisList; restart loop;
               if);
            #);
          New:
            (# i,n: @integer
            do
               firstFree->i;
               findFree :
               (if (i <= maxList)
                // true then
                   (if nxt[i]
                    // freeValue then
                       i->index; i+1->firstfree; 0->value; NULL->next
                    else
                       i+1->i; restart findFree
                   if)
                else
                   (if (maxList < nxt.range)
                    // true then
                    (* here we are if the pretty-printer 
                     has been re-initialised *)
                       (for i: nxt.range-maxlist repeat
                         freeValue->nxt[maxList+i]
                       for);
                       nxt.range->maxlist;
                    else
                       maxlist->n;
                       2*maxList->maxList;
                       (if ppTrace
                        // true then
                           screen.newline;
                           '=======> List.maxList = '->screen.puttext;
                           maxList->screen.putint;
                           screen.newline;
                       if);
                       (* Old version. Replaced to improve performance.
                        OA, 4/5-89.
                        (# b : [maxList]  @integer 
                        do (for j:nxt.range repeat nxt[j] -> b[j] for);
                        (for j:b.range-nxt.range repeat
                        freeValue -> b[j+nxt.range]
                        for);
                        b -> nxt;
                        (for j:val.range repeat val[j] -> b[j] for);
                        b -> val
                        #);
                        *)
                       maxlist-nxt.range->nxt.extend;
                       maxlist-val.range->val.extend;
                       (for j: maxlist-n repeat freeValue->nxt[j+n] for);
                   if);
                   restart findFree
               if);
            #);
          Kill: (* don't use within scan *)
            (#
            do
               freeValue->nxt[index];
               (if (index < firstFree) // true then index->firstFree if);
               0->index;
            #);
          (* privat *)
          index: @integer;
       enter index
       exit index
       #);
     SaveState: (* Saves the state of this List on file(s). *)
       (# filename: ^text; ff: [2] @integer;
       enter filename[]
       do
          firstFree->ff[1];
          maxList->ff[2];
          ('.ff'->filename.CopyAppend,ff)->SaveArray;
          ('.val'->filename.CopyAppend,val)->SaveArray;
          ('.nxt'->filename.CopyAppend,nxt)->SaveArray;
       #);
     LoadState: (* Saves the state of this shadowAst on file(s). *)
       (# filename: ^text; ff: [2] @integer;
       enter filename[]
       do
          '.ff'->filename.CopyAppend->LoadArray->ff;
          ff[1]->firstFree;
          ff[2]->maxList;
          '.val'->filename.CopyAppend->LoadArray->val;
          '.nxt'->filename.CopyAppend->LoadArray->nxt;
       #);
     EraseState: (* Erases the files from a SaveSate. *)
       (# filename: ^text; F: @File;
       enter filename[]
       do
          '.ff'->filename.CopyAppend->DeleteFile;
          '.val'->filename.CopyAppend->DeleteFile;
          '.nxt'->filename.CopyAppend->DeleteFile;
       #);
     (* privat *)
     freeValue: (# exit - 1 #);
     maxList: @integer;
     firstFree: @integer;
     val,nxt: [initialListSize] @integer;
  #)  

