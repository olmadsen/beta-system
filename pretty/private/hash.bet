ORIGIN '../astviewer';
LIB_ITEM 'prettyprinter';
(* COPYRIGHT
 *      Copyright (C) Aarhus University
 *       All rights reserved.
 *)
-- hashTableImpl: Descriptor --
(* Per Fack S|rensen, DAIMI, 24. aug. 1987 *)
(* PFS: 2/12: converted to new syntax *)
  (# (* Hash Table Element:   ( key, value )                *)
  (* key = -1:	element never used                 *)
  (* key = 0:		element has been used, but not now *)
  (* key > 0:		element in use now                 *)
  (* Elements are inserted preferrebly at index equal    *)
  (* to  (key mod hashSize)+1, alternativly at indeces   *)
  (* succesing this index (mod hashSize +1 ).            *)
  (* When hash table is 60% full rehash into table that  *)
  (* is 100% larger.                                     *)
     initialSize: (#  exit 587 (* was 2001 *) #);
     Initialize:
       (# 
       do
          0->size;
          (if hashSize = 0 then initialSize->hashSize;  if);
          (* Not rehash. *)
          60*hashSize div 100->rehashLimit;
          (for i: hashSize repeat - 1->hashKey[i] for);
          (if ppTrace then
              'Hash.initialSize     = '->putText; initialSize->putInt; newLine
          if);
          
       #);
     Rehash:
       (# hashKeyOld,hashValueOld: [1] @integer; hashSizeOld: @integer; 
       do
          hashKey->hashKeyOld;
          hashValue->hashValueOld;
          hashSize->hashSizeOld;
          2*hashSize->hashSize;
          60*hashSize div 100->rehashLimit;
          (if ppTrace then
              screen.newline;
              '=======> Hash.hashSize = '->screen.puttext;
              hashSize->screen.putint;
              screen.newline;
              '=======> Hash.rehashLimit = '->screen.puttext;
              rehashLimit->screen.putint;
              screen.newline;
              
          if);
          hashSize-hashKey.range->hashKey.extend;
          hashSize-hashValue.range->hashValue.extend;
          Initialize;
          (for i: hashSizeOld repeat
            (if (hashKeyOld[i] > 0) then
                (hashKeyOld[i],hashValueOld[i])->&Insert; 
            if);
            
          for);
          (*&(# a,b: [hashSize]@integer do a -> hashKey; b -> hashValue #);
           Initialize;
           (for i:hashSizeOld repeat 
           (if (hashKeyOld[i]>0) then
           (hashKeyOld[i],hashValueOld[i]) -> &Insert;
           if);
           for);
           *)
          
       #);
     Insert:
       (# newKey,newValue,i,i0: @integer; 
       enter (newKey,newValue)
       do
          (if size = rehashLimit then &rehash if);
          (newKey mod hashSize)+1->i->i0;
          findFree:
          (if (hashKey[i] > 0) then
              (i mod hashSize)+1->i; restart findFree
           else
              newKey->hashKey[i]; newValue->hashValue[i]; size+1->size
          if);
          (*
           'size=' -> screen.puttext;
           (Size) -> screen.putint; '   ' -> screen.puttext;
           'i-i0=' -> screen.puttext;
           (if (i<i0) then
           ((i-i0+hashSize)) -> screen.putint; screen.newline; 
           else
           ((i-i0)) -> screen.putint; screen.newline; 
           if);
           *)
          
       #);
     Find: @
       (# key,inx,val: @integer
       enter key
       do
          (if (key->findIndex->inx) = 0 then
              0->val
           else
              hashValue[inx]->val
          if)
       exit val
       #);
     Remove: @
       (# key: @integer; i: @integer; 
       enter Key
       do
          (if (key->findIndex->i) = 0 then
              'PP.Hash.Remove: index is 0'->screen.putLine
           else
              0->hashKey[i]; size-1->size
          if)
       #);
     (* private *)
     hashSize: @integer;
     (* Current  size of entire hash table.           *)
     rehashLimit: @integer;
     (* Rehash when this many elements in hash table. *)
     size: @integer;
     (* No of elms. currently in hash table.          *)
     hashKey,hashValue: [initialSize] @integer;
     findIndex: @
       (# key,i,i0: @integer; 
       enter key
       do
          (key mod hashSize)+1->i->i0;
          findKey:
          (if (hashKey[i] <> key) then
              (i mod hashSize)+1->i;
              (if i = i0 then
              (*'PP: hash: findIndex: '->putText;
               key->putInt;*)
              (* (failureTrace,'. Reorganize?/Not inserted?') -> &stop; *)
                  0->i; leave findKey
              if);
              restart findKey
          if)
       exit i
       #);
     
  #)  

