origin '../astviewer'
(* COPYRIGHT
 *      Copyright (C) Mjolner Informatics, 1986-94
 *       All rights reserved.
 *)
--hashTableImpl: DescriptorForm--
(* Per Fack S|rensen, DAIMI, 24. aug. 1987 *)
(* PFS: 2/12: converted to new syntax *)
  (# (* Hash Table Element:   ( key, value )                *)
  (* key = -1:	element never used                 *)
  (* key = 0:		element has been used, but not now *)
  (* key > 0:		element in use now                 *)
  (* Elements are inserted preferrebly at index equal    *)
  (* to  (key mod hashSize)+1, alternativly at indeces   *)
  (* succesing this index (mod hashSize +1 ).            *)
  (* When hash table is 60% full rehash into table that  *)
  (* is 100% larger.                                     *)
     initialSize: (# exit 587 (* was 2001 *) #);
     Initialize:
       (#
       do
          0->size;
          (if hashSize // 0 then initialSize->hashSize; if);
          (* Not rehash. *)
          60*hashSize div 100->rehashLimit;
          (for i: hashSize repeat - 1->hashKey[i] for);
          (if ppTrace
           // true then
              'Hash.initialSize     = '->putText; initialSize->putInt; newLine
          if);
       #);
     Rehash:
       (# hashKeyOld,hashValueOld: [1] @integer; hashSizeOld: @integer;
       do
          hashKey->hashKeyOld;
          hashValue->hashValueOld;
          hashSize->hashSizeOld;
          2*hashSize->hashSize;
          60*hashSize div 100->rehashLimit;
          (if ppTrace
           // true then
              screen.newline;
              '=======> Hash.hashSize = '->screen.puttext;
              hashSize->screen.putint;
              screen.newline;
              '=======> Hash.rehashLimit = '->screen.puttext;
              rehashLimit->screen.putint;
              screen.newline;
          if);
          hashSize-hashKey.range->hashKey.extend;
          hashSize-hashValue.range->hashValue.extend;
          Initialize;
          (for i: hashSizeOld repeat
            (if (hashKeyOld[i] > 0)
             // true then (hashKeyOld[i],hashValueOld[i])->&Insert;
            if);
          for);
          (*&(# a,b: [hashSize]@integer do a -> hashKey; b -> hashValue #);
           Initialize;
           (for i:hashSizeOld repeat 
           (if (hashKeyOld[i]>0)//true then
           (hashKeyOld[i],hashValueOld[i]) -> &Insert;
           if);
           for);
           *)
       #);
     Insert:
       (# newKey,newValue,i,i0: @integer;
       enter (newKey,newValue)
       do
          (if size // rehashLimit then &rehash if);
          (newKey mod hashSize)+1->i->i0;
          findFree :
          (if (hashKey[i] <= 0)
           // false then (i mod hashSize)+1->i; restart findFree;
           else
              newKey->hashKey[i]; newValue->hashValue[i]; size+1->size;
          if);
          (*
           'size=' -> screen.puttext;
           (Size) -> screen.putint; '   ' -> screen.puttext;
           'i-i0=' -> screen.puttext;
           (if true//(i<i0) then
           ((i-i0+hashSize)) -> screen.putint; screen.newline; 
           else
           ((i-i0)) -> screen.putint; screen.newline; 
           if);
           *)
       #);
     Find: @
       (# key,inx,val: @integer
       enter key
       do
          (if (key->findIndex->inx)
           // 0 then 0->val
           else
              hashValue[inx]->val
          if)
       exit val
       #);
     Remove: @
       (# key: @integer; i: @integer;
       enter Key
       do 0->hashKey[key->findIndex->i]; size-1->size;
       #);
     SaveState: (* Saves the state of this hashtable on file(s). *)
       (# filename: ^text; ff: [1] @integer;
       enter filename[]
       do
          hashSize->ff[1];
          ('.ff'->filename.CopyAppend,ff)->SaveArray;
          ('.key'->filename.CopyAppend,hashkey)->SaveArray;
          ('.val'->filename.CopyAppend,hashvalue)->SaveArray;
       #);
     LoadState: (* Loads the state of this hashtable from file(s). *)
       (# filename: ^text; ff: [1] @integer;
       enter filename[]
       do
          '.ff'->filename.CopyAppend->LoadArray->ff;
          ff[1]->hashSize;
          '.key'->filename.CopyAppend->LoadArray->hashkey;
          '.val'->filename.CopyAppend->LoadArray->hashvalue;
       #);
     EraseState: (* Erases the files from a SaveState. *)
       (# filename: ^text; F: @File;
       enter filename[]
       do
          '.ff'->filename.CopyAppend->DeleteFile;
          '.key'->filename.CopyAppend->DeleteFile;
          '.val'->filename.CopyAppend->DeleteFile;
       #);
     (* private *)
     hashSize: @integer;
     (* Current  size of entire hash table.           *)
     rehashLimit: @integer;
     (* Rehash when this many elements in hash table. *)
     size: @integer;
     (* No of elms. currently in hash table.          *)
     hashKey,hashValue: [initialSize] @integer;
     findIndex: @
       (# key,i,i0: @integer;
       enter key
       do
          (key mod hashSize)+1->i->i0;
          findKey :
          (if (hashKey[i] <> key)
           // true then
              (i mod hashSize)+1->i;
              (if i
               // i0 then
                  'PP: hash: findIndex: '->putText;
                  key->putInt;
                  (* (failureTrace,'. Reorganize?/Not inserted?') -> &stop; *)
                  0->i;
                  leave findKey
              if);
              restart findKey
          if)
       exit i
       #);
  #)  

