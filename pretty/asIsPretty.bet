ORIGIN '~beta/mps/astlevel';
INCLUDE '~beta/basiclib/file'
        '~beta/betaast/semanticerrortext'
        '~beta/bobs/bobs';
-- lib: Attributes --
(* IText and LText are new general pattens to be used
 * for representing exact prettey print information for
 * structure editing in the Mjølner System.
 * IText is intended to be a general superpattern for
 * the 'old' pattern 'Text' and the new pattern 'LText' 
 * defined below
 *)
trace: (#  exit false #);
IText: stream
(* General superpattern for Text and LText
 * the text-operations should be made virtual
 * and defined in IText as shown below for
 * a few operations
 *)
  (#
     insert:<
       (# T1: ^text; inx: @integer
       enter (T1[],inx)
       do INNER
       exit THIS(IText)[]
       #);
     delete:<
       (# first,last: @integer
       enter (first,last)
       do INNER
       exit THIS(IText)[]
       #)
  #);
LText: IText
(* LText for LargeText;
 * an efficient representation of a large text
 * in terms of lines of text
 *)
  (#
     put::<  (#  do 'LText::put is not defined'->screen.putline #);
     get::< 
       (# 
       do
          (if trace then
              'get: linePos:'->screen.puttext;
              linePos->screen.putint;
              ' top:'->screen.puttext;
              top->screen.putint;
              screen.newline
          if);
          L:
          (if linePos > top then
              (if trace then 'Get:eos'->screen.putline if); ascii.fs->ch
           else
              (if T[linePos].eos then
                  (if trace then 'get:line:eos'->screen.putline if);
                  linePos+1->linePos;
                  restart L
               else
                  (if trace then
                      T[linePos].pos->screen.putint; ' '->screen.put; 
                  if);
                  T[linePos].get->ch;
                  (if trace then ch->screen.put if)
              if)
          if)
       #);
     (************ private representation *********)
     L: [10] @integer;
     T: [10] ^text;
     top: @integer;
     linePos,charPos: @integer;
     (* current position in text for put/get, etc *)
     (***************** operations ****************)
     setPos::< 
       (# 
       do
          p->findLine->linePos;
          (if trace then
              'setPos: '->screen.puttext;
              p->screen.putint;
              ' line: '->screen.puttext;
              linePos->screen.putint;
              screen.newline
          if);
          p-L[linePos]-1->T[linePos].setPos;
          (*'setPos: ' -> screen.puttext; linePos -> screen.putint;
           ' ' -> screen.put; 
           L[linePos] -> screen.putint;
           ' ' -> screen.put;
           p-L[linePos] -> screen.putint; 
           screen.newline;*)
          
       #);
     addLine:
       (# pos: @integer
       enter pos
       do
          (if (top+1->top) > L.range then
              L.range->L.extend; T.range->T.extend; 
          if);
          pos->L[top];
          &text[]->T[top][];
          
       #);
     clearPos: (#  do (for i: top repeat 0->T[i].setPos for) #);
     findLine: (* requiere  0 < cPos <= L[top] *)
       (# cPos,linePos: @integer
       enter cPos
       do
          find:
            (# 
            do
               linePos+1->linePos;
               (if linePos <= top then
                   (if L[linePos] < cPos then restart find if)
               if)
            #);
          linePos-1->linePos
       exit linePos
       #);
     findLines:
       (# first,last,firstLine,lastLine: @integer; 
       enter (first,last)
       do
          findFirstLine:
            (# 
            do
               firstLine+1->firstLine;
               (if L[firstLine] < first then restart findFirstLine if)
            #);
          firstLine-1->firstLine->lastLine;
          findLastLine:
            (# 
            do
               lastLine+1->lastLine;
               (if L[lastLine] < last then restart findLastLine if)
            #);
          lastLine-1->lastLine;
          
       exit (firstLine,lastLine)
       #);
     printLine:
       (# lineNo: @integer; S: ^stream
       enter (lineNo,S[])
       do T[lineNo][]->S.puttext
       #);
     print:
       (#
          first,last,errorPos: @integer;
          firstLine,lastLine: @integer;
          done: @boolean;
          S: ^stream;
          sPutInt:
            (#
               size:
                 (# N,s: @integer
                 enter N
                 do N div 10->N; (if N > 0 then (n->size)+1->s else 1->s if)
                 exit s
                 #);
               N: @integer
            enter N
            do (for i: 4-(N->size) repeat ' '->S.put for); N->S.putint
            #);
          currentLine: @integer;
          indentPos: (#  exit errorPos-L[currentLine]-1+11 #)
       enter (first,last,errorPos,S[])
       do
          (first,last)->findLines->(firstLine,lastLine);
          (if false then
              'print: '->S.puttext;
              firstLine->S.putint;
              ' '->put;
              lastLine->S.putint;
              S.newline;
              
          if);
          (for i: lastLine-firstLine+1 repeat
            (if not done and (errorPos < L[firstLine+i-1]) then
                firstLine+i-2->currentLine; true->done; INNER
            if);
            'Line '->S.puttext;
            (* 5 chars *)
            firstLine+i-1->sPutInt;
            (* 4 chars *)
            ':'->S.put;
            (* 1 char *)
            ' '->S.put;
            (* 1 char *)
            (firstLine+i-1,S[])->printLine;
            
          for);
          (if not done then lastLine->currentLine; INNER if)
       #);
     f: @file;
     B: @BOBS;
     last: (#  exit f.length #);
     readFile:
       (# fn: ^text; pos: @integer; 
       enter fn[]
       do (* initialize a BOBS parser*)
          ('/users/olm/beta/grammars/beta/beta-parser.btab',true,true,false,
           false,false,false,true)->B.init;
          (* open .bet-file for reading *)
          '.bet'->fn.append->f.name;
          f.openRead;
          0->pos;
          0->top;
          readFile:
          (if not f.eos then
              pos->addLine;
              Read:
                (# ch: @char
                do
                   f.get->ch->T[top].put;
                   pos+1->pos;
                   (if (ch <> ascii.newline) and not f.eos then
                       restart Read
                   if)
                #);
              restart readFile
          if);
          pos+1->addLine;
          (* an extra empty line *)
          f.close;
          (if false then
              'no of lines: '->puttext;
              top->putint;
              newline;
              (for i: top-1 repeat i->putint; ':'->put; T[i][]->puttext;  for)
          if)
       #);
     printExact:
       (#
          first,last,firstLine,lastLine,pos,goalSymbol: @integer;
          S: ^stream;
          ch: @char
       enter (first,last,goalSymbol,S[])
       do
          clearPos;
          (if trace then
              '\nTestPos: goal='->screen.puttext;
              goalSymbol->screen.putint;
              ' '->screen.put;
              goalSymbol->B.LabLhs->screen.putint;
              ' first: '->screen.puttext;
              first->screen.putint;
              screen.newline;
              
          if);
          first->setPos;
          (if false then
              (for i: 10 repeat get->screen.put for); screen.newline; 
           else
              (goalSymbol->B.LabLhs,THIS(lText)[])
                ->B.parse
                  (#
                     shift:: 
                       (# 
                       do
                          (if false then
                              'shift: '->screen.puttext;
                              scan
                                (#  do ch->screen.put #);
                              screen.newline;
                              
                          if)
                       #);
                     reduce:: 
                       (# 
                       do
                          (if false then
                              'reduce: prodNo='->screen.puttext;
                              prodNo->screen.putint;
                              ' endPos='->screen.puttext;
                              endPos->screen.putint;
                              screen.newline;
                              
                          if);
                          first+endPos-1->last;
                          
                       #)
                  #);
              
          if);
          clearPos;
          first->setPos;
          ;
          (first,last)->findLines->(firstLine,lastLine);
          (if trace then
              'exact:'->Screen.puttext;
              first->Screen.putint;
              ' '->Screen.put;
              last->Screen.putint;
              Screen.newline;
              
          if);
          ;
          (for i: last-first+1 repeat
            (if false then (first-L[firstLine]+i-1)->pos if);
            (if trace then
                'pos:'->Screen.puttext;
                pos->Screen.putint;
                ' '->Screen.put;
                T[firstLine].length->Screen.putint;
                Screen.newline;
                
            if);
            (if true then
                get->ch;
                (if trace then
                    'printExact: ch: "'->screen.puttext;
                    ch->screen.put;
                    '"'->screen.put
                if);
                ch->S.put
             else
                (if pos <= T[firstLine].length then
                    pos->T[firstLine].inxGet->ch; ch->S.put
                if)
            if)
          for)
       #);
     
  #)  

-- ASTLib: Attributes --
(* astlevel attributes for excact pretty-printer *)
trace: (#  exit false #);
getPos:
(* the char position of the start of an ast-node
 * is represented in the comment field
 *)
  (# start: @integer do 1->frag.a[index].%getShort->start;  exit start #);
brotherPos: (* get the position of my brother ast-node *)
  (# node,br: ^AST; pos: @integer
  enter node[]
  do
     node.nextBrother->br[];
     (if br[] = none then
         node.father->br[];
         (if br[] = none then
             - 1->pos; (*'!pos=-1'->puttext*) 
          else
             br[]->brotherPos->pos; (if pos = 0 then '!pos=0!'->puttext if)
         if)
      else
         br.getPos->pos
     if)
  exit pos
  #);
  

-- astInterfaceLib: Attributes --
trace: (#  exit false #);
asIsViewer:
  (#
     output:< stream
       (#
          eos::<  (#  do false->value #);
          putText::< 
            (#  do txt.scanAll (#  do ch->THIS(output).put #) #)
       #);
     out: @output;
     init:< (#  enter fn[] do fn[]->lines.readFile; INNER #);
     (****************** pretty-print operations *********)
     present:
       (# theAst: ^AST; depth: @integer
       enter (theAst[],depth)
       do (theAst[],depth,out[],0,true)->showAst
       #);
     update:
       (# oldAST,newAST: ^AST
       enter (oldAST[],newAST[])
       do 'asIsViewer:update: is not implemented'->screen.putline
       #);
     (*************** private operations *****************)
     showAst:
       (#
          theAst: ^AST;
          depth: @integer;
          S: ^stream;
          exact: @boolean;
          first,last,errorPos: @integer;
          markError:
            (# lineNo,indentPos: @integer; node: ^AST; S: ^stream
            enter (lineNo,indentPos,node[],S[])
            do
               (for i: indentPos repeat ' '->S.put for);
               '^\n*** '->S.puttext;
               (*node.semanticerror -> S.putint; *)
               node.semanticerror->semanticErrorText->S.putline
            #)
       enter (theAst[],depth,S[],errorPos,exact)
       do
          theAst.getPos->first;
          theAst[]->theAst.brotherPos->last;
          (if trace then
              'asIsPretty: '->screen.puttext;
              fn[]->screen.puttext;
              ' '->screen.put;
              first->screen.putint;
              ' '->screen.put;
              last->screen.putint;
              screen.newline
          if);
          (if first = 0 then 1->first if);
          (if last = - 1 then lines.last->last if);
          (if trace then
              'Pos:'->screen.puttext;
              first->screen.putint;
              ','->screen.put;
              last->screen.putint;
              screen.newline
          if);
          (if exact then
              (first,last,theAst.symbol,S[])->lines.printExact
           else
              (first,last,errorPos,S[])
                ->lines.print
                  (# 
                  do (currentLine,indentPos,theAst[],S[])->markError; 
                  #)
          if);
          
       #);
     fn: ^text;
     lines: @lText
  #);
asIsPretty:
(* an exact pretty printer; 
 * prints in two modes:
 * exact = true : print the exact list of chars representing node;
 * exact = false: print the lines conatining errorPos and mark
 *                the error saved at this node.
 *)
  (#
     fn: ^text; node: ^AST; S: ^Stream; errorPos: @integer; exact: @boolean
  enter (fn[],node[],S[],errorPos,exact)
  do
       (# theViewer: @asIsViewer
       do
          fn[]->theViewer.init;
          (node[],500,S[],errorPos,exact)->theViewer.showAst
       #)
  #);
  

