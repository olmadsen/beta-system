ORIGIN '~beta/basiclib/v1.6/betaenv';
INCLUDE '~beta/mps/v5.2/findgrammar'
	'~beta/mps/v5.2/metagrammarcfl'
	'~beta/mps/v5.2/grammarinit'
	'~beta/mps/v5.2/private/astparser'
	'~beta/betaast/v5.2/betacfl'
	'~beta/basiclib/v1.6/textUtils'
	'pplib';
(* COPYRIGHT
 *      Copyright (C) Mjolner Informatics, 1986-96
 *       All rights reserved.
 *)
-- PROGRAM: Descriptor --
(#
   mps: @astinterface(# defaultGrammarFinder:: findGrammar #);
   betagrammar: @mps.treelevel;
   isDocumentGrammar:
     (#
	value1,value2: @boolean;
	ff: ^astInterface.fragmentform;
	grammarGroup: ^astInterface.fragmentGroup
     enter ff[]
     do
	ff.grammar.grammarAst.father->grammarGroup[];
	(if grammarGroup.prop[] <> none then
	    'longLexems'
	      ->grammarGroup.prop.getProp
		(# doProp::<  (#  do true->value1 #) #);
	    'longLexemsWithQuote'
	      ->grammarGroup.prop.getProp
		(# doProp::<  (#  do true->value1->value2 #) #)
	if)
     exit (value1,value2)
     #);
   getGrammarPath:
     (#
	ff: ^astInterface.fragmentform;
	grammarGroup: ^astInterface.fragmentGroup;
	path,theGrammarName: ^text;
	e: @diskEntry
     enter ff[]
     do
	ff.grammar.grammarAst.father->grammarGroup[];
	grammarGroup.father->grammarGroup[];
	grammarGroup.fullName->e.path;
	e.path.head->theGrammarName[];
	'/'->theGrammarName.put;
	ff.grammar.grammarIdentification->theGrammarName.append;
	theGrammarName[]->mps.expandToFullPath->path[]
     exit path[]
     #);
   incArgumentNo:
     (#
     do
     (*noOfArguments->putInt;
      ' '->put;
      argumentNo->putInt;
      newLine;*)
	(if (argumentNo < noOfArguments) then
	    argumentNo+1->argumentNo (*->putInt*) ;
	    argumentNo->Arguments (*->putLine*) ;

	 else
	    (failure,
	     'Usage: pp [-p ppSpec] [-w ppWidth] [-d ppDepth] [-dump] groupOrTextFile')
	      ->stop;

	if);

     exit argumentNo
     #);
   input,theArgument,ppSpec: ^text;
   fg: ^mps.fragmentGroup;
   ff: ^mps.fragmentForm;
   argumentNo,width,depth: @integer;
   specialLexemTreatment,longLexemsWithQuote,astDump: @boolean;

do
   mps;
   ('~beta/grammars/beta/v2.6/beta','beta',screen[])
     ->betagrammar.betagrammarInit
   (#
      MPSerror::
	(# do (failure,msg[])->stop #);
      noParserAvailable::
	(# do (failure,msg[])->stop #)
   #);
   (if (noOfArguments < 2) then
       (failure,
       'Usage: pp [-p ppSpec] [-w ppWidth] [-d ppDepth] [-dump] astOrTextFile')
	 ->stop
   if);
   1->argumentNo;
   noOfArguments->Arguments->mps.expandToFullPath->input[];
   100->width;
   - 1->depth;
   scanArguments:
     (#
     do
	incArgumentNo->Arguments->theArgument[];
	(if argumentNo < noOfArguments then
	    theArgument.MakeUC;
	    (if true
	     // '-P'->theArgument.equal then
		incArgumentNo->Arguments->mps.expandToFullPath->ppSpec[];
		restart scanArguments
	     // '-W'->theArgument.equal then
		incArgumentNo->Arguments->theArgument[];
		' '->theArgument.put;
		theArgument.reset;
		theArgument.getInt->width;
		restart scanArguments
	     // '-D'->theArgument.equal then
		incArgumentNo->Arguments->theArgument[];
		' '->theArgument.put;
		theArgument.reset;
		theArgument.getInt->depth;
		restart scanArguments
	     // '-DUMP'->theArgument.equal then
		true->astDump; restart scanArguments
	     else
		'Unknown argument: '->putText; theArgument[]->putLine
	    if)
	if)
     #);
   (input[],screen[])
     ->mps.top.open
       (#
	  fil: @file;
	  myException:
	    (# msg,help: ^text
	    enter msg[]
	    do
	       '\nFile name: '->help[];
	       input[]->help.append;
	       help.newLine;
	       help[]->msg.append;
	       (normal,msg[])->stop;

	    #);
	  readAccessError::<  (#  do 'Read access error'->myException #);
	  fragmentNotExisting::<
	    (#  do 'Non-existent fragment file'->myException #);
	  grammarNotFound::<  (#  do 'Grammar not found'->myException #);
	  badFormat::<  (#  do 'Bad AST format'->myException #);
	  WriteAccessOnLstFileError::<
	    (#  do 'Access error on .lst file'->myException #);
	  writeAccessError::<  (#  do 'No write access'->myException #);
	  ParseErrors::<  (#  do 'Parse errors'->myException #);
	  DoubleFormDeclaration::<
	    (#
	    do 'Two forms are declared with the same name'->myException
	    #);
	  fatalParseError::<  (#  do 'Fatal parse errors'->myException #);
	  OtherFileError::<
	    (#
	    do
	       input[]->fil.name;
	       (if fil.entry.exists then
		   (if fil.entry.isDirectory then
		       'Is a directory'->myException
		    else
		       'Other file error'->myException
		   if)
	       if)
	    #);

       #)->fg[];
   (if fg[] = none then
       input[]->screen.putText; ' not found '->screen.putLine; (normal,'')->stop
   if);
   fg.fragmentList.scan
     (#  do (if current.type = mps.formType then current.f[]->ff[] if) #);
   (if ff[] = none then
       input[]->screen.putText;
       ' is not a fragment file'->screen.putLine;
       (normal,'')->stop
   if);
   ff[]->isDocumentGrammar->(specialLexemTreatment,longLexemsWithQuote);
   (*enter
    * (mps[],fg[],node[],outStream[],streamName[],width,depth,abstractPresentation,showSemanticErrors,
    * includeComments,parsingInformation,specialLexemTreatment,longLexemsWithQuote,
    * specialCommentTreatment,ppSpec[],onlyProperties,test)
    *)
   (if ppSpec[] = none then ff[]->getGrammarPath->ppSpec[];  if);
   (mps[],fg[],none ,none ,'' (*screen*) ,width,depth,false,false,true,false,
    specialLexemTreatment,longLexemsWithQuote,false,ppSpec[],false,astDump,
   false)->ppFragment;
#)
