ORIGIN '~beta/basiclib/v1.4/betaenv';
INCLUDE '~beta/mps/v5.0/findgrammar'
        '~beta/betaast/v5.0/betacfl'
        '~beta/mps/v5.0/metagrammarcfl'
        '~beta/mps/v5.0/private/astparser'
        'pplib';
(* COPYRIGHT
 *      Copyright (C) Mjolner Informatics, 1986-94
 *       All rights reserved.
 *)
-- PROGRAM: Descriptor --
(#
   mps: @astinterface;
   grammarName: ^text;
   meta: @mps.metagrammar;
   outFile: ^stream;
   theComments: (* in the fragment syntax *) ^text;
   isDocumentGrammar:
     (# grammarGroup: ^mps.fragmentGroup; boo1,boo2: @boolean; 
     enter grammarGroup[]
     do
        (if grammarGroup.prop[]
         // none then 
         else
            'longLexems'
              ->grammarGroup.prop.getProp
                (# doProp::<  (#  do true->boo1 #) #);
            'longLexemsWithQuote'
              ->grammarGroup.prop.getProp
                (# doProp::<  (#  do true->boo2 #) #);
            
        if);
        
     exit (boo1,boo2)
     #);
   betaGrammarInit:
     (#
        betaGrammar,theMetaGrammar: ^mps.treelevel;
        grammarWithPath,help: ^text;
        gg: ^mps.fragmentGroup;
        bobsfile: @file;
        
     do
        &mps.metaGrammar[]->theMetaGrammar[]->mps.grammarTable.meta[];
        theMetaGrammar.init;
        '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('metagrammar',screen[])->gg.open->theMetagrammar.grammarAst[];
            (if theMetagrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                grammarWithPath[]->mps.expandToFullPath->help[];
                '-parser'->help.append;
                mps.parserFileExtension->help.append;
                help[]->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->theMetagrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        &mps.beta[]->betaGrammar[];
        betaGrammar.init;
        '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('beta',screen[])->gg.open->betaGrammar.grammarAst[];
            (if betaGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->betaGrammar.parser.initialize;
                    ('objectdescriptor','descriptor')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    ('attributedecl','attributes')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if);
                
            if);
            
        if);
        
     #);
   incArgumentNo:
     (# 
     do (*noOfArguments->putInt; ' '->put; argumentNo->putInt;newLine;*)
        (if (argumentNo < noOfArguments)
         // true then
            argumentNo+1->argumentNo (*->putInt*) ;
            argumentNo->Arguments (*->putLine*) ;
            
         else
            (failure,
             'Usage: pp [-p ppSpec] [-w ppWidth] [-d ppDepth] groupOrTextFile')
              ->stop;
            
        if);
        
     exit argumentNo
     #);
   input,theArgument,ppSpec,path,localName,prefix,suffix,theGrammarName,
     ppSpecName: ^text;
   e: @diskEntry;
   f: ^mps.fragment;
   fg,fg2: ^mps.fragmentGroup;
   ff: ^mps.fragmentForm;
   bobsfile,astfile,textfile: @file;
   argumentNo,width,depth: @integer;
   options,isDocuGrammar,longlexemswithquote,specialLexemTreatment: @boolean;
   
do
   mps;
   (*(mps.trace.fragmentOpen,true)->mps.trace.set;
    (mps.trace.grammars,true)->mps.trace.set;
    (mps.trace.parser,true) -> mps.trace.set;*)
   (if true
    // (noOfArguments < 2) then
       (failure,
        'Usage: pp [-p ppSpec] [-w ppWidth] [-d ppDepth] groupOrTextFile')
         ->stop;
       
   if);
   2->argumentNo;
   false->options;
   argumentNo->Arguments->theArgument[];
   theArgument.MakeUC;
   (if ('-P'->theArgument.equal)
    // true then
       incArgumentNo->Arguments->mps.expandToFullPath->ppSpec[];
       incArgumentNo->Arguments->theArgument[];
       theArgument.MakeUC;
       true->options;
       
   if);
   80->width;
   (if ('-W'->theArgument.equal)
    // true then
       incArgumentNo->Arguments->theArgument[];
       ' '->theArgument.put;
       theArgument.reset;
       theArgument.getInt->width;
       incArgumentNo->Arguments->theArgument[];
       theArgument.MakeUC;
       true->options;
       
   if);
   - 1->depth;
   (* full depth *)
   (if ('-D'->theArgument.equal)
    // true then
       incArgumentNo->Arguments->theArgument[];
       ' '->theArgument.put;
       theArgument.reset;
       theArgument.getInt->depth;
       true->options;
       
    else
       false->options
   if);
   (if options // true then incArgumentNo if);
   argumentNo->Arguments->mps.expandToFullPath->input[];
   input[]->e.path;
   (e.path.head,e.path.name)->(path[],localName[]);
   localName[]->e.path;
   (e.path.name.prefix,e.path.name.suffix)->(prefix[],suffix[]);
   (if true
    // ('.bet'->suffix.equal) then
       mps.astFileExtension->prefix.copyAppend->astfile.name;
       (if astfile.entry.exists
        // true then
           (if (path.length > 0)
            // true then
               path.copy->input[]; '/'->input.put; prefix[]->input.putText
            else
               prefix[]->input[]
           if);
           
       if);
       betagrammarinit;
       
    // (mps.astFileExtension->suffix.equal) then
       (if (path.length > 0)
        // true then
           path.copy->input[]; '/'->input.put; prefix[]->input.putText
        else
           prefix[]->input[]
       if);
       
    else
       (if suffix.length > 0 then
           input[]->textfile.name;
           (if textfile.entry.exists then
               mps.astFileExtension->prefix.copyAppend->astfile.name;
               (if astfile.entry.exists
                // true then
                   (if astfile.entry.modtime < textfile.entry.modtime then
                       astfile.delete;
                       (* Big hack, because of bug in open in mps!!!!!! *)
                       
                   if)
               if)
            else
               input[]->screen.putText;
               ' not found '->screen.putLine;
               (normal,'')->stop;
               
           if);
           
        else
           '.bet'->input.append
       if)
   if);
   (* if not beta *)
   &mps.FindGrammar (# notFound::<  (#  do true->continue #) #)[]
     ->mps.grammarMissing[];
   mps.grammarMissing.registerGrammars;
   (input[],screen[])
     ->mps.top.open
       (#
          fil: @file;
          myException:
            (# msg,help: ^text
            enter msg[]
            do
               'File name: '->help[];
               input[]->help.putLine;
               help[]->msg.append;
               (normal,msg[])->stop;
               
            #);
          readAccessError::<  (#  do 'Read access error'->myException #);
          fragmentNotExisting::< 
            (#  do 'Non-existent fragment file'->myException #);
          grammarNotFound::<  (#  do 'Grammar not found'->myException #);
          badFormat::<  (#  do 'Bad AST format'->myException #);
          WriteAccessOnLstFileError::< 
            (#  do 'Access error on .lst file'->myException #);
          writeAccessError::<  (#  do 'No write access'->myException #);
          ParseErrors::<  (#  do myException #);
          DoubleFormDeclaration::< 
            (# 
            do 'Two forms are declared with the same name'->myException
            #);
          fatalParseError::<  (#  do 'Fatal parse errors'->myException #);
          OtherFileError::< 
            (# 
            do
               input[]->fil.name;
               (if fil.entry.exists
                // true then
                   (if fil.entry.isDirectory
                    // true then 'Is a directory'->myException
                    else
                       'Other file error'->myException
                   if)
               if)
            #);
          
       #)->f[];
   (if f[]
    // none then
       input[]->screen.putText;
       ' not found '->screen.putLine;
       (normal,'')->stop;
       
   if);
   (if f.type
    // mps.formType then
       f[]->ff[]
    // mps.groupType then
       f[]->fg[];
       fg.fragmentList.scan
         (# 
         do (if current.type // mps.formType then current.f[]->ff[] if)
         #);
       
   if);
   ff.grammar.grammarAst.father->fg[]->isDocumentGrammar
     ->(isDocuGrammar,longLexemsWithQuote);
   fg.father->fg[];
   fg.fullName->e.path;
   e.path.head->theGrammarName[];
   '/'->theGrammarName.put;
   ff.grammar.grammarIdentification->theGrammarName.append;
   
   (if ppSpec[]
    // none then theGrammarName[]->mps.expandToFullPath->ppSpec[]; 
   if);
   (* don't understand this: *)
   isDocuGrammar->specialLexemTreatment;
   (if longLexemsWithQuote // true then true->specialLexemTreatment if);
   
(*      ff.root.dump;
   
 (mps.trace.getNextComment,true)->mps.trace.set;
 *)
   
   (*enter 
    * (mps[],fg[],node[],outStream[],streamName[],width,depth,abstractPresentation,showSemanticErrors,
    * includeComments,parsingInformation,specialLexemTreatment,longLexemsWithQuote,
    * specialCommentTreatment,ppSpec[],onlyProperties,test)
    *)
   (if false
    // true then
       'ppfragment: '->putLine;
       '<'->put;
       f.name->putText;
       '>'->put;
       newLine;
       '<'->put;
       ''->putText;
       '>'->put;
       newLine;
       width->putInt;
       newLine;
       depth->putInt;
       newLine;
       'abstractPresentation: '->putText;
       false->putInt;
       newLine;
       'showSemanticErrors: '->putText;
       true->putInt;
       newLine;
       'includeComments: '->putText;
       true->putInt;
       newLine;
       'parsingInformation: '->putText;
       false->putInt;
       newLine;
       'specialLexemTreatment: '->putText;
       specialLexemTreatment->putInt;
       newLine;
       'longLexemsWithQuote: '->putText;
       longLexemsWithQuote->putInt;
       newLine;
       'specialCommentTreatment: '->putText;
       false->putInt;
       newLine;
       '<'->put;
       ''->putText;
       '>'->put;
       newLine;
       
   if);
   (mps[],f[],none ,none ,'' (*screen*) ,width,depth,false,false,true,false,
    specialLexemTreatment,longLexemsWithQuote,false,ppSpec[],false,false)
     ->ppFragment;
   (*sample use:
    * (mps[],f[],none,''[*screen*])->prettyprintFragment
    * (#
    *   showSemanticErrors::<trueObject;
    *   includeComments::< (# do false->value#)
    * #);
    *)
   
#)  

