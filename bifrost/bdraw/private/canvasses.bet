ORIGIN '../bdrawenv';
INCLUDE 'thepalette';

---- InitializeLogo: dopart ----
do (80,49) -> Size;
   0 -> BorderWidth;
   true -> defaultbackground;

---- Logo:descriptor ----
(# anArc: ^Arc;
   aSolidColor: ^SolidColor;
   delta: @integer;
   center: @Point;
   radius: @integer;
   a2: @real;
   h,s,v: @integer;
do    
   (* Draw a small rainbow *)
   (40,0) -> center;
   25 -> radius;
   180 -> a2;
   defaultmaxhue div 15 -> delta;
   
   (for h:15 repeat
        &Arc[] -> anArc[];
        anArc.init;
        center -> anArc.center;
        radius -> anArc.horizontalradius -> anArc.verticalradius;
        2 -> anArc.arcwidth; (* Actually 1 ought to be enough! *)
        a2 -> anArc.angle2;
        
        &SolidColor[] -> aSolidColor[] -> anArc.setPaint;
        (DefaultMaxHue+6-delta*h,DefaultMaxSat,DefaultMaxVal)
          -> aSolidColor.HSVvalues;
        anArc[] -> draw;
        radius+1 -> radius;
   for);
#)
-- InitializeColorCanvas: descriptor --
(# 
do (80,50) -> size;
   2 -> BorderWidth;
   
   theLine.init;
   mySolidColor.copy -> theLine.setPaint;
   ((10,40),(70,10)) -> theLine.coordinates;
   (if debugGraphic then 
       'colorcanvas initialized' -> putline; 
   if);
#) 
   
---- UpdateColorCanvas: descriptor ----
(* Draw a line between (10,40) and (70,10) with attributes as
 specified by mylinewidth,mySolidColor *)
(# GB: @theLine.GetBounds;
do
   GB -> damaged;
   mySolidColor.copy -> theLine.setPaint;
   myLineWidth -> theLine.width;
   mycapstyle  -> theLine.cap;
   GB -> damaged;
   repair;
   (if debugGraphic then 
       'colorcanvas updated' -> putline; 
   if);
#)

---- InitInfo:descriptor ----
(# blackpaint: @SolidColor;
do (745,18) -> Size;
   1 -> BorderWidth;
   label.init;
   ((2,5), Times, Plain, 14, false, 'Choose objects from the palette') 
     -> label.initText;
   blackpaint.init;
   black -> blackpaint.name;
   blackpaint[] -> label.setPaint;
   true -> bindright
#)

--InfoFrameChanged: descriptor--
(# mainpos, mainsize, palettepos, palettesize: @point;
   palettey, mainy: @integer;
do thePalette.position -> palettepos;
   thePalette.size -> palettesize;
   mainscroll.position -> mainpos;
   mainscroll.size -> mainsize;
   palettepos.y+palettesize.y+10 -> palettey;
   mainpos.y+mainsize.y+10 -> mainy;
   (if palettey<=mainy then
       (palettepos.x, (palettey,mainy)->max) -> Inform.position;
    else
       (mainpos.x, mainy) -> Inform.position;
   if)       
#)

-- OpenInfo: dopart --
do label[] -> draw 
   
-- ClearInfo: descriptor --
(# 
do label.getbounds -> damaged;
   '' -> label.thetext;
   repair;
#)
   
---- SetInfo:descriptor ---- 
(# GB: @label.GetBounds;
do GB -> damaged;
   t[]  -> label.thetext;
   GB -> damaged;
   repair;
#)

(* --ClipCanvasBody: MainPart--
 * (# eventhandler::
 *      (# onfatherframechanged::
 *           (# 
 *           do clipwin.size->size;
 *           #)
 *      #);
 * #)
 *)

--ClipWinPrivate: descriptor--
(# clip: ^Picture;
#)

--ClipWinUpdate: descriptor--
(# r: @rectangle;
   pos, siz, mainsiz: @point;
do (if private.clip[]<>NONE then
       private.clip[] -> clipwin.clipcanvas.erase;
   if);
   (if clipboard.isEmpty then
       'Bdraw: Empty Clipboard' -> clipwin.title;
       none -> private.clip[];
       (0,0,0,0) -> r;
    else
       'Bdraw: Clipboard' -> clipwin.title;
       clipboard.copy->private.clip[];
       private.clip.getbounds->r;
   if);
   clipwin.size -> siz;
   20+r.height -> r.height;
   20+r.width -> r.width;
   (if (r.width>siz.x) or (r.height>siz.y) then 
       (r.width,siz.x)->max->siz.x;
       (r.height,siz.y)->max->siz.y;
       siz -> clipwin.size;
   if);
   (if ((0,0), clipwin.position) -> EqualPoint then
       maincanvas.size -> mainsiz;
       maincanvas.position -> pos;
       (pos.x + mainsiz.x div 2, pos.y + mainsiz.y div 2) -> pos;
       (* Now pos is center of maincanvas *);
       (pos.x - siz.x div 2, pos.y - siz.y div 2) -> pos;
       (* Now clipwin is centered in Maincanvas *)
       pos -> clipwin.position;
       clipwin.bringtofront;
   if);
   (if private.clip[]<>NONE then
       (* Move it, so that its lower left corner is at (10,10) *)
       (-r.x+10, -r.y+r.height+10) -> private.clip.move;
       private.clip[] -> clipwin.clipcanvas.draw;
   if);
   clipwin.clipcanvas.refresh;
#)  
