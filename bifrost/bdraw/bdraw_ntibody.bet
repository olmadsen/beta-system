ORIGIN 'bdrawenv';
INCLUDE 'menus';
INCLUDE 'dialogs';
INCLUDE 'cursors';

INCLUDE '../private/WinNT/BifrostWinNTimpl';
INCLUDE '../private/WinNT/CanvasWinNTimpl';

INCLUDE '~beta/win32lib/v1.6/wingdi';
INCLUDE '~beta/win32lib/v1.6/wingdiconsts';
INCLUDE '~beta/win32lib/v1.6/dcmanagement';
INCLUDE '~beta/win32lib/v1.6/dialogcontrolmanagement';
INCLUDE '~beta/guienv/v1.6/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/v1.6/private/winnt/guienv_ntibody';
INCLUDE '~beta/sysutils/v1.6/cstring';

RESOURCE default 'printer.rc';

-- guienvLib: attributes --
load2:
  (# LoadCursorInt: external
       (#
          in0: @integer; (* HINSTANCE *)
          in1: @integer; (* LPCSTR *)
          out: @integer; (* HCURSOR *)
       enter (in0,in1)
       do 'LoadCursorA' -> callStd;
       exit out
       #);
     id: @integer; (* LPCSTR *)
     result: @integer;
  enter id
  do (uienvHInstance,id) 
       -> LoadCursorInt -> result; 
     (result,'cursorLib.load2') -> checkNullError;
  exit result
  #);

loadCursorFromResource:
  (# id: @integer;
     theCursor: ^cursor;
  enter id
  do &cursor[] -> theCursor[];
     id -> load2 -> theCursor.cursorHandle;
  exit theCursor[]
  #);

-- lib: attributes --
IsDialogMessage2: external
  (# hwnd: @integer; (* HWND *)
     msg: @integer; (* MSG FAR* *)
     result: @integer; (* BOOL *)
  enter (hwnd,msg)
  do 'IsDialogMessageA' -> callStd;
  exit result
  #);

DispatchMessage2: external
  (# theMsg: @integer; (* address of structure with message. const MSG FAR* *)
     out: @integer; (* LONG *)
  enter theMsg
  do 'DispatchMessageA' -> callStd;
  exit out
  #);

PD_RETURNDC: (# exit 16x00000100 #);
sizeOfPrintDlg: (# exit 66 #);
PRINTDLG: cstruct
  (# bytesize::< (# do sizeOfPrintDlg -> value; #);
     lStructSize: @long (# pos::< (# do 0 -> value; #); #);  
     hwndOwner: @long (# pos::< (# do 4 -> value; #); #);  
     hDevMode: @long (# pos::< (# do 8 -> value; #); #);   
     hDevNames: @long (# pos::< (# do 12 -> value; #); #);  
     hDC: @long (# pos::< (# do 16 -> value; #); #);  
     Flags: @long (# pos::< (# do 20 -> value; #); #);  
     nFromPage: @short (# pos::< (# do 22 -> value; #); #);  
     nToPage: @short (# pos::< (# do 24 -> value; #); #);   
     nMinPage: @short (# pos::< (# do 26 -> value; #); #);   
     nMaxPage: @short (# pos::< (# do 28 -> value; #); #);   
     nCopies: @short (# pos::< (# do 30 -> value; #); #);  
     hInstance: @long (# pos::< (# do 34 -> value; #); #);  
     lCustData: @long (# pos::< (# do 38 -> value; #); #);  
     lpfnPrintHook: @long (# pos::< (# do 42 -> value; #); #);  
     lpfnSetupHook: @long (# pos::< (# do 46 -> value; #); #);  
     lpPrintTemplateName: @long (# pos::< (# do 50 -> value; #); #);  
     lpSetupTemplateName: @long (# pos::< (# do 54 -> value; #); #);  
     hPrintTemplate: @long (# pos::< (# do 58 -> value; #); #);  
     hSetupTemplate: @long (# pos::< (# do 62 -> value; #); #);  
  #);

openPrintDlg: external
  (# thePRINTDLG: ^PRINTDLG;
     result: @integer;
  enter thePRINTDLG[]
  do 'PrintDlgA' -> callStd;
  exit result
  #);

SetAbortProc: external
  (#
     in0: @integer; (* HDC *)
     in1: @integer; (* ABORTPROC *)
     out: @integer; (* int *)
  enter (in0,in1)
  do callStd;
  exit out
  #);

StartDoc: external
  (# hdc: @integer; (* HDC *)
     ptr2DocInfo: ^DOCINFO; (* DOCINFO FAR* *)
     result: @integer; (* int *)
  enter (hdc,ptr2DocInfo[])
  do 'StartDocA' -> callStd;
  exit result
  #);

sizeOfDocInfo: (# exit 20 #);
DOCINFO: cstruct
  (# bytesize::< (# do sizeOfDocInfo -> value; #);
     cbSize: @long (# pos::< (# do 0 -> value; #); #); 
     lpszDocName: @long (# pos::< (# do 4 -> value; #); #); 
     lpszOutput: @long (# pos::< (# do 8 -> value; #); #); 
     
     (* Windows 95 only; ignored on Windows NT *)
     lpszDatatype: @long (# pos::< (# do 12 -> value; #); #);    
     
     (* Windows 95 only; ignored on Windows NT *)
     fwType: @long (# pos::< (# do 16 -> value; #); #);          
  #);

CreateDialogParam: external
  (#
     hInst: @integer; (* handle to application instance *)
     lpTemplate: [1] @char; (* identifies dialog box template name *)
     hWndParent: @integer; (* handle to owner window *)
     lpDialogFunc: @integer; (* pointer to dialog box procedure *)
     dwInitParam: @integer;
     theDlgHandle: @integer; (* if the function succeeds, the return value is 
                              * the handle to the dialog box.
                              * If the function fails, the return value is 0.
                              *)
  enter (hInst,lpTemplate,hWndParent,lpDialogFunc,dwInitParam)
  do 'CreateDialogParamA' -> callStd;
  exit theDlgHandle
  #);


GlobalFree: external
  (# ptr: @integer;
     result: @integer;
  enter ptr
  do callStd;
  exit result
  #);

freeCBF: External
  (# cbf: @integer;
  enter cbf
  #);                

DID_CANCEL: (# exit 503 #);

-- BdrawPrint: descriptor--
(# AbortDlgProc2Ptr: external
     (# func: ##AbortDlgProc;
        ptr: @integer;
     enter func##
     do 'copyinput'->callC
     exit ptr
     #);
   
   AbortProc2Ptr: external
     (# func: ##AbortProc;
        ptr: @integer;
     enter func##
     do 'copyinput'->callC
     exit ptr
     #);
   
   ghwndAbort, ghwndMain: @integer;
   AbortDlgProcAddress: @integer;
   AbortProcAddress: @integer;
   gbAbort: @boolean;
   ghdc: @integer;
   
   AbortProc: external
     (# hdc, error, result: @integer;
        m: @integer;
     enter (hdc, error)
     do StdExternalEntry;
        28 -> malloc -> m;
        L:
          (if (not gbAbort) 
              and 
              (((m,0,0,0,PM_REMOVE) -> PeekMessage)<>0)
              then
              
              (if (ghwndAbort<>0) 
                  or
                  (((m,ghwndAbort) -> IsDialogMessage2) <> 0)
                  then
                  m -> TranslateMessage;
                  m -> DispatchMessage2;
              if);
              restart L;
          if);
        m -> free;
        (if gbAbort then 0 -> result;
         else 1 -> result;
        if);
     exit result
     #);
   
   AbortDlgProc: external
     (# result: @integer;
        hwnd, msg, wParam, lParam: @integer;
        longInt: @CStruct
          (# ByteSize:: (# do 4 -> Value; #);
             loWord: signedShort (# Pos:: (# do 0 -> Value; #); #);
             hiWord: signedShort (# Pos:: (# do 2 -> Value; #); #);
          enter R[1]
          exit R[1]
          #);
     enter (hwnd, msg, wParam, lParam)
     do StdExternalEntry;
        
        (if msg
         //WM_INITDIALOG then
            
            hwnd -> ghwndAbort;
            ((hwnd, 0) -> GetSystemMenu, SC_CLOSE, MF_GRAYED)->EnableMenuItem;
            
         //WM_COMMAND then
            wParam -> longInt;
            (if longInt.loWord=DID_CANCEL then
                TRUE -> gbAbort;
                ghdc -> AbortDoc;
                (ghwndMain, 1) -> EnableWindow;
                hwnd -> DestroyWindow;
                0 -> ghwndAbort;
                1 -> result;
            if);
        if);
     exit result
     #);
   
   
   doPrint:
     (# pd: @PRINTDLG;
        di: @DOCINFO;
        owner: ^window;
        ownerId: @integer;
        doContinue: @boolean;
        docName: ^text; cstrDocName: @cString;
        tempText: @text; length: @integer;
     enter (owner[], docName[])
     do 
        (if owner[]<>NONE then
            owner.interfaceObjectId -> ownerId -> ghwndMain;
         else
            0 -> ownerId;
            GetActiveWindow -> ghwndMain;
            (if ghwndMain = 0 then
                L: this(guienv).private.windows.scan
                  (# 
                  do current.interfaceObjectID -> ghwndMain;
                     leave L;
                  #);
            if);
        if);
        (if docName[]=NONE then
            'Untitled' -> cstrDocName.set;
         else
            docName[] -> cstrDocName.set;
        if);

        (*
         * Initialize a PRINTDLG struct and call PrintDlg to allow user to
         * specify various printing options...
         *)
        
        sizeOfPrintDlg -> pd.lStructSize;
        ownerId -> pd.hwndOwner;
        PD_RETURNDC -> pd.Flags;
        0 -> pd.hInstance;
        
        (if (pd[] -> openPrintDlg)=0 then
            'openPrintDlg failed. Error code= ' -> screen.putText;
            GetLastError -> putint; newline;
         else
            pd.hDC -> ghdc;
            
            (if (pd.hDevMode<>0) then
                pd.hDevMode -> GlobalFree;
            if);
            
            (if (pd.hDevNames)<>0 then
                pd.hDevNames -> GlobalFree;
            if);
            
            (if (ghdc=0) then
                (owner[],'Cannot print. Creating printer DC failed.',NONE)->alertUser;
                'Creating printer DC failed. Error code= ' -> screen.putText; 
                GetLastError -> putint; newline;
                false -> doContinue;
             else
                true -> doContinue;
            if);
        
            (*
             * put up Abort & install the abort procedure
             *)
            
            AbortDlgProc## -> AbortDlgProc2Ptr -> AbortDlgProcAddress;
            FALSE -> gbAbort;
            (uienvHInstance, 'Abort', ghwndMain, AbortDlgProcAddress,0)
              -> CreateDialogParam
              -> ghwndAbort;
            (ghwndMain, 0) -> EnableWindow;
            AbortProc## -> AbortProc2Ptr -> AbortProcAddress;
            (ghdc, AbortProcAddress) -> SetAbortProc;
            
            sizeOfDocInfo -> di.cbSize;
            cstrDocName -> di.lpszDocName;
            0 -> di.lpszOutput;
            
            (if ((ghdc, di[]) -> StartDoc)<=0 then
                'StartDoc failed. Error code= ' -> screen.putText;
                GetLastError -> putInt; newline;
             else
                (if (ghdc -> StartPage)<=0 then
                    'StartPage failed. Error code= ' -> screen.putText;
                    GetLastError -> putInt; newline;
                 else
                    
                    (* TRUE -> debugGraphic; *)
                    
                    'PAINT BEGIN' -> screen.putLine;
                    
                    ghdc -> paint;
                    
                    'PAINT DONE' -> screen.putLine;
                    
                    (if (ghdc -> EndPage)<=0 then
                        'EndPage failed. Error code= ' -> screen.putText;
                        GetLastError -> putint; newline;
                    if);
                    (if (ghdc -> EndDoc)<=0 then
                        'EndDoc failed. Error code= ' -> screen.putText;
                        GetLastError -> putint; newline;
                    if);
                if);
            if);
            
            ghdc -> DeleteDC;        
            
            (if ( not gbAbort) then
                (ghwndMain, 1) -> EnableWindow;
                ghwndAbort -> DestroyWindow;            
                0 -> ghwndAbort;
            if);
            AbortDlgProcAddress -> freeCBF;
            AbortProcAddress -> freeCBF;
        if);
        cstrDocName.free;        
     #);
   
   paint:
     (# repaintCanvas:
          (# r: ^rectangle;
             theNtRectPtr: @integer; windowID: @integer;
          do &Rectangle[] -> r[];
             (0,0) -> (r.x, r.y);
             maincanvas.size -> (r.width,r.height);
             r[] -> mainCanvas.implpart.damagedList.append;
             mainCanvas.expose;  
          #);
        
        hdc: @integer;
        oldSelection: @picture;
        s: @ScaleMatrix;
        oldMatrix: @Matrix;
        theSize: @point; 
        page: @point;
        translate: @point;
        m: @point;
        margin: (# exit (20, 20) #);
        A4: (# exit (0, 0, 595, 822) #);
        pagesize: @rectangle;
        scale: @real;
     enter hdc
     do (* If the selection has been moved or otherwise transformed, this 
         * transformation is only registered by the selection TM matrix.
         * Temporarily remove the GOs in theSelection to make the GOs
         * incorporate the transformations.
         *)                        
        oldSelection.init;
        theSelection.scanGOs(# do go[] -> oldSelection.add #);
        theSelection.clear; 
        
        TRUE -> debugGraphic;
        
        A4 -> pagesize;
        maincanvas.size -> theSize;
        (pagesize.width-pagesize.x, pagesize.height-pagesize.y) -> page;
        margin -> m;
        (page.x-2*m.x, page.y-2*m.y) -> page;
        
        (* Calculate Scale to fit Canvas to page *)
        (if page.x-theSize.x < page.y-theSize.y then
            (* Scale to fit in x direction *)
            page.x -> scale;
            scale / theSize.x -> scale;
            0 -> translate.x;
            ((page.y-theSize.y) div 2) div scale-> translate.y;
         else
            (* scale to fit in y direction *)
            page.y -> scale;
            scale / theSize.y -> scale;
            0 -> translate.y;
            ((page.x-theSize.x) div 2) div scale -> translate.x;
        if);
        (margin, translate) -> addpoints -> translate;
        
        'scale= ' -> putText; scale->screen.putreal; newline;
        
        (6.2,8.2) -> s;
        maincanvas.TM -> oldMatrix.set;
        (* (maincanvas.TM[],s[]) -> MatrixMul -> maincanvas.TM[]; *)
        (* s[] -> maincanvas.thePicture.transform; *)
        
        maincanvas.implpart.hdc -> maincanvas.implpart.screenHdc;
        hdc -> maincanvas.implpart.hdc;
        
        repaintCanvas;
        oldMatrix[] -> maincanvas.TM[];
        maincanvas.implpart.screenHdc -> maincanvas.implpart.hdc;
        
        (* Restore selection *)
        oldSelection.scanGOs(# do go[] -> theSelection.add #); 
        
        
     #);
   
do (topwindow[],'myDocument') -> doPrint;
#)

-- BdrawExtensions: descriptor --
(# #)

--InitCursors: descriptor--
(# tempCursor: ^cursor;
do maincanvas.theCursor -> savedcursor.c[];
   (* true -> debugGraphic; *)
   1 -> loadCursorFromResource -> tempCursor[];  
   tempCursor.private.cursorHandle 
     -> ulcornercursor.ulc.private.cursorHandle;
   2 -> loadCursorFromResource -> tempCursor[];  
   tempCursor.private.cursorHandle 
     -> lrcornercursor.lrc.private.cursorHandle;
   3 -> loadCursorFromResource -> tempCursor[];  
   tempCursor.private.cursorHandle 
     -> lefthandcursor.lhc.private.cursorHandle;
#)
