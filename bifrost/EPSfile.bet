ORIGIN 'Bifrost';
BODY 'private/PS/EPSread'
     'private/PS/EPSmacros';
--- streamLib: attributes ---
skipEPSheaders:
  (* This functions should be called to skip over the PostScript
   * headers and check that it is a valid Bifrost PostScript file.
   *
   * PostScript headers are generated by canvas.writeEPS or if
   * startEPSfile is used directly.
   *)
  (# 
     formatException: exception
       (* called if THIS(stream) isn't a valid Bifrost PostScript
	* file.
	*)
       (# 
	  t: ^text
       enter t[]
       <<SLOT skipEPSheadersFormatException: doPart>>
       #);
     formatError:< formatException;
     inFile: ^stream;
  enter inFile[]
  <<SLOT skipEPSheaders: doPart>>
  #);

(* The following is indented to allow the user to write to
 * PostScript files, ie. writing several pictures (pages) to one
 * file.  Currently however, the user herself will have to generate
 * some PostScript code which separates the pages and makes it valid
 * postscript code.  This is likely to change in future releases.
 *)
startEPSfile:
  (* Writes PostScript headers to THIS(stream).  This function
   * should be called exactly once for each file before you do
   * anything else.
   *
   * This is called automatically by canvas.writeEPS file, but can
   * be used if the user don't want to use canvas.writeEPS.
   *)
  (# <<SLOT startEPSfile: doPart>> #);
endEPSfile:
  (* Write PostScript epilogue to out. This function should be
   * called exactly once, before you close this file.
   *
   * As startEPSfile, this is automatically called by
   * canvas.writeEPS, and should normally only be used if the user
   * also used startEPSfile.
   *)
  (# <<SLOT endEPSfile: doPart>> #);
eoe: booleanValue
  (* Tests for end of EPS file as marked by endEPSfile *)
  (# <<SLOT eoe: doPart>> #)

--- BifrostAttributes: attributes ---
loadPicture:
  (# 
     <<SLOT bifrostLoadPicture: attributes>>;
     parseException: exception
       (* A parse exception is generated if any parse errors occurs
	* while reading the EPS file.

	* Notice that if for instance the file is truncated, the
	* normal stream exception are generated.
	*)
       (# 
          t: ^text;
       enter t[]
       <<SLOT loadPictureParseException: doPart>>
       #);
     parseError:< parseException;
     createGO:<
       (* Should be specialized to create user defined patterns *)
       (#
          GO: ^AbstractGraphicalObject;
          patternName: ^text;
       enter patternName[]
       <<SLOT loadPicturecreateGO: doPart>>
       exit GO[]
       #);
     in: ^stream;
     out: ^Picture;
     private: @<<SLOT loadPicturePrivate: descriptor>>
  enter in[]
  <<SLOT loadPictureReadEPS: doPart >>
  exit out[]
  #)
