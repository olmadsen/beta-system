ORIGIN '../Predefined/TextImpl';
INCLUDE 'X11fonts';

-- TextShapeGetWidthHeight: descriptor --
(# xf: ^THIS(guienv).private.xfont;
do (* Find the xfont specified by nam, sty and siz *)
   (nam,sty,siz) -> XCheckFontLoaded -> (xf[],nam,sty,siz);
   
   (* Now obtain the width *)
   0 -> width;
   (if xf.fixedwidth then 
       theLines.scan
       (# w: @integer
       do current.length*xf.width -> w;
          (if w>width then w->width if);
       #);
    else
       theLines.scan
       (# w: @integer
       do (xf.fi, current.t, current.t.range) -> XTextWidth -> w;
          (if w>width then w->width if);
       #);
   if);
   
   (* now obtain the height *)
   theLines.size*xf.lineheight -> height;
   
#)

-- TextShapeMaxDescent: dopart --
do (nam,sty,siz) -> XCheckFontLoaded;
   
   THIS(guienv).private.fonts.xfonts[nam].style[sty].size[siz].maxdescent
     -> desc
   
   
-- TextShapeUnderlineDepth: descriptor --
(# t: @integer;
do (nam,sty,siz) -> XCheckFontLoaded;
   THIS(guienv).private.fonts.xfonts[nam].style[sty].size[siz].upos->depth;
   THIS(guienv).private.fonts.xfonts[nam].style[sty].size[siz].uthick -> t;
   (t+1) div 2 + depth -> depth;
#)

-- TextShapeInteractiveCreateBody: descriptor --
(# mousePoint: @Point;
   theCh, prevCh: @Char;
   ChWidth, prevChWidth: @Integer;
   chArray: [1] @Char;
   curx, cury, uppery, maxx: @Integer;
   theString: ^Text;
   xf: ^THIS(guienv).private.xfont;
   
   DrawInsertionMark:@
     (#
     do theCanvas.prepareInteraction;
        ((curx,cury + xf.maxdescent), (curx,uppery)) -> theCanvas.immediateline;
        theCanvas.endInteraction;
        theCanvas[] -> thecanvas.privatepart.interactionpaint.setcanvaspaint;
     #);
   
   LetterWidth: @
     (# ch: @Char;
     enter ch
     exit (ch -> xf.letterwidth)
     #);
   
   DrawCh: @
     (#
     do
        (* Cannot use XDrawImageString with TiledSolidColor,
         * so simulate it instead
         *)
        (xdisplay, 
        theCanvas.implpart.xdrawable,
        curx, uppery, ChWidth, xf.lineheight, 0) -> XClearArea;
        
        theCh -> chArray[1];
        (xdisplay, 
        theCanvas.implpart.xdrawable, 
        theCanvas.implpart.xgc,
        curx, cury,
        chArray, 1) -> XDrawString;
        
        (if textprivate.underline then	    
            (xdisplay,
            theCanvas.implpart.xdrawable, 
            theCanvas.implpart.xgc,
            curx,
            cury + THIS(guienv).private.fonts.
            xfonts[textprivate.theFontName].
            style[textprivate.theStyle].
            size[textprivate.theSize].upos,
            theCh -> letterwidth,
            THIS(guienv).private.fonts.
            xfonts[textprivate.theFontName].
            style[textprivate.theStyle].
            size[textprivate.theSize].uthick)
              -> XFillRectangle;
        if);
     #);
   
   ClearPrevCh: @
     (#
     do
        (xdisplay, 
        theCanvas.implpart.xdrawable,
        curx, uppery, prevChWidth, xf.lineheight, 0) -> XClearArea;
     #);
   
do (* TextShapeInteractiveCreateBody *)
   (if theCanvas.privatepart.interactionpaint[]=NONE then
       (if displayWarnings then
           'TextShape: No paint specified for interaction - using solid black' 
             ->PutLine;
       if);
       blackPaint -> theCanvas.privatepart.interactionpaint[];
   if);
   
   (* Set font *)
   (theCanvas[], textprivate.theFontName, textprivate.theStyle, textprivate.theSize)
     -> SetXFont
     -> (textprivate.theFontName,textprivate.theStyle,textprivate.theSize);
   THIS(guienv).private.fonts.
   xfonts[textprivate.theFontName].
   style[textprivate.theStyle].
   size[textprivate.theSize][] -> xf[];
   
   (* Determine where to start *)
   (* startpoint is in GO coords *)
   
   (startPoint.x, startpoint.y - 8) (* 8 is half height of xterm cursor *)
     -> position
     -> theCanvas.canvastodevice
     -> (curx, cury);
   
   (* Now we work in device coords *)
   (* cury is ypos of baseline *)
   curx -> maxx;
   cury - xf.maxascent (*size + xf.maxdescent*) -> uppery;
   
   (* Set linewidth (for drawInsertionMark) *)
   (xdisplay, 
   theCanvas.implpart.xgc,
   0, 0, 0, 0) -> XSetLineAttributes;
   
   (* Open the shap*)
   open;
   
   (* Start interaction *)
   DrawInsertionMark;
   &text[] -> theString[];
   (* Read letters *)
   theCanvas.interactionHandler
   (# stopinteraction: @boolean;
      
      buttonpress ::< (# do true -> stopinteraction #);
      
      terminateCondition ::<
        (# do stopinteraction -> value; #);
      
      keyPress ::<
        (#
        do (if ch->theCh
            // ascii.nl
            // ascii.cr then
               true -> stopinteraction;
            // ascii.bs
            // ascii.del then
               (if (theString.length>0) then
                   DrawInsertionMark;
                   theString.length -> theString.inxGet -> prevCh;
                   (theString.length,theString.length)
                     -> theString.delete;
                   curx - (prevCh->LetterWidth->prevChWidth) -> curx;
                   ClearPrevCh;
                   DrawInsertionMark;
               if);
            else
               (if debugGraphic then ch -> put if);
               ch -> theString.put;
               DrawInsertionMark; (* Clear previous mark *)
               ch -> letterwidth -> ChWidth;
               DrawCh;
               curx + ChWidth -> curx;
               (curx, maxx) -> Max -> maxx;
               DrawInsertionMark;
           if);
        #);
   #);
   DrawInsertionMark;
   (* Interaction done *)
   
   theCh -> lastCh;
   
   theString[] -> theText;
   
   (TextPrivate.position.x,
   TextPrivate.position.y+xf.maxascent,
   maxx-startpoint.x,
   xf.lineheight) -> theCanvas.damaged;
   theCanvas.repair;
   
#)	

-- TextShapeInteractiveReshapeBody: dopart --
do 'TextShape: InteractiveReshape not implemented !' -> putline;
   INNER;
   
-- TextShapeHiliteOutlineBody: descriptor --
(# pos: @point;
   itext: @theCanvas.immediateText;
   lineheight: @integer;
   xf: ^THIS(guienv).private.xfont;
   nam: @Fontname;
   sty: @Style;
   siz: @Integer;
do 
   (if TM[] // NONE then
       textprivate.position -> pos;
    else
       textprivate.position -> TM.transformpoint -> pos;
   if);
   pos -> Privatepart.Go2CanvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice -> pos;
   (textprivate.theFontName,
   textprivate.theStyle,
   textprivate.theSize) -> XCheckFontLoaded -> (xf[],nam,sty,siz);
   xf.lineheight -> lineheight;
   
   textprivate.thestrings.scan
   (# 
   do (pos, 
      textprivate.theFontName,
      textprivate.theStyle,
      textprivate.theSize,
      underline,
      current[]) -> itext;
      pos.y+lineheight -> pos.y (* device coords *);
   #);
#)
