ORIGIN '../Impl/RasterImpl';
LIB_ITEM 'bifrost';
INCLUDE 'BifrostX11impl';
INCLUDE '~beta/sysutils/endian';

(************* Rasters ****************)

-- RasterCalculate: dopart --
do INNER
   
   (* Bitmap *)
   
-- InitBitMapBody: descriptor --
(# x, more: @integer;
do (* Destroy old privatepart if needed *)
   
   (if bitmapprivatepart.xpixmap<>0 then 
       (THIS(guienv).private.display, bitmapprivatepart.xpixmap)
         -> XFreePixmap;
       0 -> bitmapprivatepart.xpixmap;
   if);
   
   ((width+7) div 8) * 8 -> bitmapprivatepart.realwidth;
   bitmapprivatepart.realwidth - width -> bitmapprivatepart.padright;
   
   (if debuggraphic then
       'Bitmap: realwidth: ' ->putwarntext;
       bitmapprivatepart.realwidth -> putwarnintline;
   if);
   
   (bitmapprivatepart.realwidth*height + 31) div 32
   - bitmapprivatepart.data.range
     -> more;
   (if more>0 then more -> bitmapprivatepart.data.extend;
   if);
   
   (if debugGraphic then
       'Bitmap.init: X data: range: ' -> putwarntext;
       BitMapPrivatePart.data.range -> putwarnintline;
   if);
#)

-- BitMapCalculate: dopart --
do (****
    (if debugGraphic then
    'Creating X Bitmap with the following data:'->putwarnline;
    (for i:BitMapPrivatePart.data.range
    repeat
    BitMapPrivatePart.data[i]
    -> putwarnint;
    ' ' -> putwarn;
    for);
    none->putwarnline;
    if);
    ****)
   
   (if rasterprivatepart.width=0 then
       'BitMap.calculate: Width of Bitmap is zero!' -> putwarnline;
       '(Maybe init has not been called)' -> putwarnline;
       1 -> rasterprivatepart.width;
   if);
   
   (if rasterprivatepart.height=0 then
       'BitMap.calculate: Height of Bitmap is zero!' -> putwarnline;
       '(Maybe init has not been called)' -> putwarnline;
       1 -> rasterprivatepart.height;
   if);
   
   (THIS(guienv).private.display,
   THIS(guienv).private.defaultdrawable,
   @@BitMapPrivatePart.data[1],
   rasterprivatepart.width,
   rasterprivatepart.height)
     -> XCreateBitMapFromData -> BitMapPrivatePart.xpixmap;
   
   (if BitMapPrivatePart.xpixmap=0 then 
       'BitMap.calculate: failed to create X Bitmap' -> putwarnline;
    else
       (if debuggraphic then
           (# rasthot: @point;
              filename: @text; status: @integer;
           do 'Writing bitmap file \'/tmp/Bifrost.bitmap\' ... '
                -> putwarntext;
              '/tmp/Bifrost.bitmap' -> filename;
              hotspot -> rasthot;
              (THIS(guienv).private.display,
              filename.t,
              BitMapPrivatePart.xpixmap,
              width,
              height,
              rasthot.x,
              rasthot.y) -> XWriteBitmapFile -> status;
              
              (if status=0 then 
                  'done.' -> putwarnline;
               else
                  'failed for reason: ' -> putwarntext;
                  status -> putwarnintline;
              if);
           #);
       if);
   if);
   INNER

-- BitMapPutPixel: descriptor --
(* FIXME: change private.data to byte-array *)
(# bitpos,  (* BIT-Position in BitMapPrivatePart.data from MSB *)
   longinx, (* BitMapPrivatePart.data[longinx] is the long to manipulate *)
   longpos, (* BIT-position in BitMapPrivatePart.data[longinx] *)
   byteno,  (* Byte index in BitMapPrivatePart.data[longinx] *)
   offset,  (* Bitposition in byte number byteno of 
             * BitMapPrivatePart.data[longinx]
             *)
   value: @integer;
   mybyte: @int8u;
do (if rasterprivatepart.indexOK then
       (if p.b then 1->value else 0->value if);
       (rasterprivatepart.height-j)*bitmapprivatepart.realwidth+(i-1)
         -> bitpos; 
       (bitpos) div 32 + 1 -> longinx; 
       (* +1 since we're using longinx for BitMapPrivatePart.data *)
       
       bitpos mod 32 -> longpos;
       longpos div 8 -> byteno;
       (byteno+1)*8-longpos-1 -> offset;
       
       byteno -> BitMapPrivatePart.data[longinx].%getByte -> mybyte;
       (if isLittleEndian then 7-offset->offset; (* FIXME! *) if);
       (value, offset, 1) -> mybyte.%PutBits -> value;
       (mybyte, byteno) -> BitMapPrivatePart.data[longinx].%putByte;
       
       (if false then
           '---putbit start---' -> putwarnline;
           'i,j: '->putwarntext; i->putwarnint; ','->put; j->putwarnintline;
           'bitpos: '->putwarntext; bitpos->putwarnintline;
           'byteno: '->putwarntext; byteno->putwarnintline;
           'longinx: '->putwarntext; longinx->putwarnintline;
           'longpos: '->putwarntext; longpos->putwarnintline;
           'value: '->putwarntext; value->putwarnintline;
           'mybyte after: '->putwarntext; mybyte->putwarnhexline;
           '---putbit end---' -> putwarnline;
       if);
   if);
#)

-- BitMapGetPixel: descriptor --
(* FIXME: change private.data to byte-array *)
(# bitpos,  (* BIT-Position in BitMapPrivatePart.data from MSB *)
   longinx, (* BitMapPrivatePart.data[longinx] is the long to manipulate *)
   longpos, (* BIT-position in BitMapPrivatePart.data[longinx] *)
   byteno,  (* Byte index in BitMapPrivatePart.data[longinx] *)
   offset,  (* Bitposition in byte number byteno of 
             * BitMapPrivatePart.data[longinx]
             *)
   value: @integer;
   mybyte: @int8u;
do &pixel[] -> p[];
   (if rasterprivatepart.indexOK then
       (rasterprivatepart.height-j)*bitmapprivatepart.realwidth+(i-1)
         -> bitpos; 
       (bitpos) div 32 + 1 -> longinx; 
       (* +1 since we're using longinx for BitMapPrivatePart.data *)
       
       bitpos mod 32 -> longpos;
       longpos div 8 -> byteno;
       (byteno+1)*8-longpos-1 -> offset;
       
       byteno -> BitMapPrivatePart.data[longinx].%getByte -> mybyte;
       (if isLittleEndian then 7-offset->offset; (* FIXME! *) if);
       (offset, 1) -> mybyte.%GetBits -> value;
       (if false then
           '---getbit start---' -> putwarnline;
           'i,j: '->putwarntext; i->putwarnint; ','->put; j->putwarnintline;
           'bitpos: '->putwarntext; bitpos->putwarnintline;
           'byteno: '->putwarntext; byteno->putwarnintline;
           'longinx: '->putwarntext; longinx->putwarnintline;
           'longpos: '->putwarntext; longpos->putwarnintline;
           'mybyte: '->putwarntext; mybyte->putwarnhexline;
           'value: '->putwarntext; value->putwarnintline;
           '---getbit end---' -> putwarnline;
       if)
   if);
   (value<>0) -> p.b;
#)


-- BitmapConvertPBMrow: descriptor --
(# (* Convert pbmrow to data for X bitmap *)
   (* Inspired from pbmtoxbm.c from pbmplus package by Jef Poskanzer *)
   
   index: @integer;       (* Index into bitmapprivatepart.data *)
   pbminx: @integer;      (* Index into pbmrow *)
   item: @integer;        (* Next byte for bitmapprivatepart.data *)
   bitsperitem: @integer; (* Bit pointer into item *)
   pbmitem: @integer;     (* pbmrow[pbminx] as integer *)
   pbmbit: @integer;      (* Bit pointer into pbmitem *)
   
   readrawpbmrow: @ (* Read and convert bits in pbmrow *)
     (# b: @integer;
     do 
        (for width repeat
             (if pbmbit=0 then
                 128 -> pbmbit;
                 pbminx+1 -> pbminx;
                 pbmrow[pbminx] -> pbmitem;
             if);
             (* Get next bit from pbmitem *)
             (if (pbmbit %Band pbmitem) = pbmbit then 1 -> b; else 0 -> b; if);    
             b -> putbit;
             pbmbit div 2 -> pbmbit;
        for);
        
        (* Skip remaining bits in last byte:
         * the next row begins in a new byte (NOT documented !)
         *)
        0 -> pbmbit; 
     #);
   
   readpbmrow: (* Read and convert integers in pbmrow *)
     (# 
     do (for width repeat
             pbminx+1 -> pbminx;
             pbmrow[pbminx] -> putbit; (* 0 or 1 *)
        for);
     #);
   
   putitem: @
     (# byteno: @integer;
     do (item, byteno) -> bitmapprivatepart.data[index+1].%PutByte;
        byteno+1 -> byteno;
        (if byteno=4 then index+1 -> index; 0 -> byteno if);
        0 -> bitsperitem;
        0 -> item;
     #);
   
   putbit: @
     (# b: @integer;
        theBit: @integer;
     enter b
     do (if bitsperitem=8 then putitem if);
        (if b=1 then
            1 %sll bitsperitem -> theBit;
            item %Bor theBit -> item;
        if);
        bitsperitem+1 -> bitsperitem;
     #);
   printf: external
     (# fmt: [0]@char;
        x: @integer
     enter (fmt,x)
     #);
do 
   0 -> pbminx -> item -> pbmbit -> bitsperitem;
   (if rawbits then
       readrawpbmrow;
    else
       readpbmrow
   if);
   
   (for bitmapprivatepart.padright repeat 0 -> putbit for);
   (if bitsperitem>0 then putitem if);
   
   (if false then
       'after BitmapConvertPBMrow:'->putwarnline;
       (for i: bitmapprivatepart.data.range repeat
            ('0x%08x',bitmapprivatepart.data[i]) -> printf;
            ' '->put;
       for); 
       NONE->putwarnline;
   if);
#)  
   
   (*** PixMap ***)
   
-- PixMapCalculate: dopart --
do INNER;
   
-- InitPixMapBody: descriptor --
(# pad,format: @integer;
do maxval -> pixmapPrivatepart.maxRGB;
   
   (if pixmapprivatepart.pixels=0 then 
    else (*Not needed; is handled by XDestroyImage *)
       (* pixmapprivatepart.pixels->free; *)
   if);
   (if pixmapprivatepart.ximage=0 then 
    else pixmapprivatepart.ximage->XDestroyImage
   if);
   
   4*width*height -> malloc -> pixmapprivatepart.pixels;
   
   (if THIS(guienv).private.defaultDepth=1 then
       XYPixmap->format;
       32->pad;
    else
       ZPixmap->format;
       (if (THIS(guienv).private.defaultDepth>8) then
           32 -> pad
        else
           8 -> pad
       if);
   if);
   (THIS(guienv).private.display,
   THIS(guienv).private.defaultVisual,
   THIS(guienv).private.defaultDepth,
   format,
   0,
   pixmapprivatepart.pixels,
   width,
   height,
   pad,
   0) -> XCreateImage -> pixmapprivatepart.ximage;
   (if pixmapprivatepart.ximage=0 then
       'Unable to allocate XImage' ->putwarnline;
   if);
   
#)

-- PixMapPutPixel: descriptor --
(# status: @integer;
   myxcolor: @XColor;
   
do (if rasterprivatepart.indexOK then
       p.r -> myxcolor.red; (* NB: skal scaleres !! *)
       p.g -> myxcolor.green;
       p.b -> myxcolor.blue;
       
       (THIS(guienv).private.display, 
       THIS(guienv).private.xcolormap,
       myxcolor[]) -> XAllocColor -> status;
       (if (status=0) then
           'Couldn\'t allocate color' -> putwarnline;
       if);
       
       (pixmapprivatepart.ximage, i-1, rasterprivatePart.height-j, myxcolor.pixel)
         -> XPutPixel -> status;
       
       
       (if (status=0) then
           'Failed to put pixel' -> putwarnline;
       if);
   if);
#)

-- PixMapGetPixel: dopart --
do 'PixMap.GetPixel' -> UnImplemented;
   INNER
   
-- PixMapCopy: descriptor --
(# p: ^PixMap;
do (if aCopy[]=NONE then (* Not done in inner *)
       &PixMap[] -> p[];
       (* ... *)
       p[] -> aCopy[];
   if);
#)

-- PixMapWritePPM: dopart --
do 'PixMap.WriteToPPMfile' -> UnImplemented;
   
-- PixMapReadPPM: dopart --
do 'PixMap.ReadFromPPMfile' -> UnImplemented;
   
-- PictureDrawOnPixmap: descriptor --
(* Since PictureDrawOnPixmap needs access to private attributes of rasters, it
 * is easiest to have it in here instead of in PictureX11Impl
 *)     
(# dummycanvas: @BifrostCanvas;
   xpixmap: @integer;
   b: @rectangle;
   format, pad: @integer;
do (if true then
       'Picture.DrawOnPixmap' -> UnImplemented;
    else
       dummycanvas.open; (* should not be mapped though!! *)
       (* Create an X Pixmap *)
       getbounds -> b;
       (THIS(guienv).private.display,
       THIS(guienv).private.defaultdrawable,
       b.x, b.y,
       THIS(guienv).private.defaultDepth) -> XCreatePixmap -> xpixmap;
       (* Specify this X Pixmap as drawable in dummycanvas *)
       xpixmap -> dummyCanvas.implpart.xdrawable;
       (* Draw all GOs on dummycanvas *)
       scanGOs(# do dummyCanvas[]->go.draw #);
       (* Now get the pixels from xpixmap into pm *)
       MaxRGB -> pm.pixmapprivatepart.maxRGB;
       (if THIS(guienv).private.defaultDepth=1 then
           XYPixmap->format;
           32->pad;
        else
           ZPixmap->format;
           (if (THIS(guienv).private.defaultDepth>8) then
               32 -> pad
            else
               8 -> pad
           if);
       if);
       (THIS(guienv).private.display,
       xpixmap,
       0, 0, b.x, b.y,
       -1, format) -> XGetImage -> pm.pixmapprivatepart.ximage;
   if);
#)
