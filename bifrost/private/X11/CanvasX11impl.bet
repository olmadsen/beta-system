ORIGIN '../Impl/CanvasImpl';
LIB_ITEM 'bifrost';
INCLUDE 'BifrostX11impl';
INCLUDE 'X11fonts';
BODY 'CanvasXtImpl';

(* CanvasX11impl.bet:
 *
 *   Fragments containing X11 dependent implementation-parts of BifrostCanvas
 *
 *)

-- canvasDamagedArea: descriptor --
RectangleList
(# intersect: @BooleanValue
     (# r: @Rectangle;
     enter r
     do
        False -> value;
        scanList: scan
          (# b1, b2, b3: @boolean;
          do (if true then
                 (* This has previously caused code generation errors
                  * on hppa, but it should work now!
                  *)
                 (if (((current.x <= r.x) and (r.x <= current.x+current.width)) or
                     ((r.x <= current.x) and (current.x <= r.x+r.width)))
                     and
                     (((current.y-current.height <= r.y) and (r.y <= current.y)) or
                     ((r.y-r.height <= current.y) and (current.y <= r.y))) then 
                     True -> value;
                     leave scanList;
                 if)
              else
                 (current.x <= r.x) -> b1;
                 (r.x <= current.x+current.width) and b1 -> b1;
                 (r.x <= current.x) -> b2;
                 (current.x <= r.x+r.width) and b2 -> b2;
                 b1 or b2 -> b3;
                 (current.y-current.height <= r.y) -> b1;
                 (r.y <= current.y) and b1 -> b1;
                 (r.y-r.height <= current.y) -> b2;
                 (current.y <= r.y) and b2 -> b2;
                 b3 and (b1 or b2) -> b1;
                 (if b1 then
                     True -> value;
                     leave scanList;
                 if);
             if)
          #);
     #)
#)

-- CanvasRefresh: descriptor --
(# r: ^rectangle;
do &Rectangle[] -> r[];
   THIS(guienv).private.damaged.topleft -> (r.x, r.y);
   THIS(guienv).private.damaged.size -> (r.width, r.height);
   r[] -> implpart.damagedList.append;
   expose;
   INNER onrefresh;
#)

-- canvasDamagedBody: descriptor --
(# rect: ^rectangle;
do (if (debugGraphic or privatepart.canvasdebug) then 
       'damaged ' -> putwarntext; r -> putrect;
   if);
   &rectangle[] -> rect[];
   r -> rect;
   rect[] -> privatepart.damagedArea.append;
#)

-- canvasRepairBody: descriptor --
(# mainShape, myShape: ^Shape;
do (if (debugGraphic or privatepart.canvasdebug) then 'repair BifrostCanvas.TM: ' -> putwarntext;
       TM[] -> putmatrix;
   if); 
   (if not privatepart.damagedArea.empty then
       (* Set clip region for next drawing operations *)
       &Shape[] -> mainShape[];
       (0,0) -> mainShape.open;
       (if debugGraphic then 'DAMAGED RECTANGLES:' -> putwarnline if);
       privatepart.damagedArea.scan 
       (#
       do (if debugGraphic then current -> putrect; if);
          &Shape[] -> myShape[];
          (current.x              ,current.y)                -> myShape.open;
          (current.x+current.width,current.y)                -> myShape.lineto;
          (current.x+current.width,current.y-current.height) -> myShape.lineto;
          (current.x              ,current.y-current.height) -> myShape.lineto;
          myShape.close;
          (idmatrix,myShape[]) -> mainShape.CombineShape;
          current -> clearRect;
       #);
       mainShape.close;
       mainShape[] -> SetClip;
       
       (* Check which GOs should be redrawn *)
       (if debugGraphic then 'BOUNDING BOXES:' -> putwarnline if);
       
       (if thepicture[]=none then
           'thepicture is none!!'->putwarnline;
       if);
       thePicture.scanGOs
       (# r: @rectangle;
       do
          (* only check first level of GOs !!!! *)
          go.getBounds -> r;
          (if debugGraphic then
              'GO with shape '->putwarntext;
              go.theshape[] -> getpatternname -> putwarntext; 
              ': '->putwarntext;
              r -> putrect;
          if);
          (if (r -> privatepart.damagedArea.intersect) then 
              (if (debugGraphic or privatepart.canvasdebug) then 
                  'redraw GO with shape ' -> putwarntext;
                  go.theshape[] -> getpatternname -> putwarnline;
              if);
              THIS(BifrostCanvas)[] -> go.draw;
          if);
       #);
       
       privatepart.damagedArea.clear;
       (if debuggraphic then
           'damagedArea after clearing >>>: '-> putwarnline;
           privatepart.damagedArea.scan(# do current -> putrect #);
           '^^^ damagedArea after clearing: ^^^'-> putwarnline;
       if);
       
       visualShape[] -> SetClip;
   if);
#)

-- CanvasUpdateCoordImpl: descriptor --
(# 
do (if TM[]=NONE then
       &Matrix[] -> TM[];
       1.0  -> TM.a;
       -1.0 -> TM.d;
       0.0  -> TM.c;
       0.0  -> TM.b;
       0.0  -> TM.tx;
   if);
   s.y -> TM.ty;
#)

-- CanvasInitPrivatePart: descriptor --
(# 
do (if not(THIS(guienv).private.fonts.initialized) then
       (if initBifrostFonts < 0 then
           this(BifrostCanvas).theEventhandler.onFatalError;
       if);
   if);
   
   implpart.xevent.init; (* Allocate implpart.xevent for XNextEvent *)
   THIS(guienv).private.xcolorMap -> implpart.xcolormap;
   
   (* Create and initialize a Graphic Context for THIS(BifrostCanvas) *)
   (THIS(guienv).private.display,
   THIS(guienv).private.defaultdrawable,
   0,
   0)
     -> XCreateGC -> implpart.xgc;
   
   (THIS(guienv).private.display, implpart.xgc,
   THIS(guienv).private.blackPixelvalue) -> XSetForeground;
   (THIS(guienv).private.display, implpart.xgc,
   THIS(guienv).private.whitePixelvalue) -> XSetBackground;
   
   (* Use Copy as the raster-rule *)
   (THIS(guienv).private.display, implpart.xgc, GXcopy)
     -> XSetFunction; 
   
   (* Don't allow drawing into child windows *)
   (*(THIS(guienv).private.display, implpart.xgc, ClipByChildren) 
    -> XSetSubwindowMode;*)
   
   <<SLOT InitCanvasWindow: descriptor>>;
#)   
   
-- canvasSetClipImplBody: descriptor --
(# myRegion: @Integer;
do
   (if implpart.xgc=0 then
       (* ignore *)
    else
       (* No transformation may be made when clipping is done *)
       (* clear the X region *)
       (if (implpart.clipRegion<>0) then
           implpart.clipregion -> XDestroyRegion;
           0 -> implpart.clipRegion;
       if);
       THIS(BifrostCanvas)[]
         ->clipShape.makeRegion -> implpart.clipRegion;(* clip region *)
       (if (clipShape[]<>visualShape[]) then
           THIS(BifrostCanvas)[]
             ->visualShape.makeRegion -> myRegion;  (* visible region *)
           (* make resulting clip region *)
           (myRegion,
           implpart.clipRegion,
           implpart.clipRegion) -> XIntersectRegion;
       if);
       (* set the clipRegion as clipmask in theCanvas GC *)
       (if debuggraphic then
           'BifrostCanvas.setclip: xgc: '->putwarntext;
           implpart.xgc->putwarnintline;
       if);
       (THIS(guienv).private.display, 
       implpart.xgc,
       implpart.clipRegion) -> XSetRegion;
   if);
#)

-- canvasprepareInteractionBody: descriptor --
(# planeMask: @Integer;
do
   (THIS(guienv).private.display,
   implpart.xgc,
   FillSolid) -> XSetFillStyle;
   
   THIS(guienv).private.blackpixelvalue %bxor
   THIS(guienv).private.whitepixelvalue -> planeMask;
   (*
    (THIS(guienv).private.display, 
    implpart.xgc,0xffffffff,0,GXxor,planeMask) -> XSetState;
    *)
   (THIS(guienv).private.display, 
   implpart.xgc,0,1,GXinvert,planeMask) -> XSetState;
#)

-- canvasEndInteractionBody: descriptor --
(# 
do 
   (THIS(guienv).private.display, implpart.xgc, GXcopy)
     -> XSetFunction;
   (THIS(guienv).private.display, implpart.xgc, 0xffffffff)
     -> XSetPlaneMask;
   
   (THIS(guienv).private.display, implpart.xgc,
   THIS(guienv).private.whitePixelvalue)
     -> xSetBackground;
#)
   
-- canvasSetImmediateLineWidthBody: dopart --
do 
   (THIS(guienv).private.display, 
   implpart.xgc,
   lineWidth,
   0,
   XCapNotLast,
   XJoinBevel) -> XSetLineAttributes;
   
   
-- CanvasImmediateSpot: dopart --
do
   (THIS(guienv).private.display,
   implpart.xdrawable,
   implpart.xgc,
   center.x-3, center.y-3, 6, 6) -> XFillRectangle;
   
   
-- canvasImmediateLineBody: dopart --
do 
   (if (implpart.xdrawable>0) then
       (THIS(guienv).private.display, 
       implpart.xdrawable, 
       implpart.xgc,
       p1.x,p1.y,
       p2.x,p2.y) -> XDrawLine;
   if)
   
   
-- canvasImmediateDot: dopart --
do
   (if (implpart.xdrawable>0) then
       p1 -> CanvasToDevice -> p1;
       (THIS(guienv).private.display, 
       implpart.xdrawable, 
       implpart.xgc,
       p1.x,p1.y) -> XDrawPoint;
   if);
   
   
-- canvasImmediateMultiLineBody: descriptor --
(# myP: @Point;
do 
   (if (implpart.xdrawable>0) then
       (if p.npoints = 0 then 
           'ImmediateMultiLine: no points' -> putwarnline;
        else
           idmatrix -> p.ToXPoints -> implpart.XPoints[];
           
           (if close then
               1 -> p.GetPoint -> myP;
               (* There IS room for ONE extra point in implpart.xpoints *)
               (myP.x,0) -> implpart.XPoints.p[p.npoints+1].%putShort;
               (myP.y,1) -> implpart.XPoints.p[p.npoints+1].%putShort;
               (THIS(guienv).private.display, 
               implpart.xdrawable, 
               implpart.xgc,
               @@implpart.XPoints.p[1],
               p.npoints+1,
               CoordModeOrigin) -> XDrawLines;
            else
               (THIS(guienv).private.display, 
               implpart.xdrawable, 
               implpart.xgc,
               @@implpart.XPoints.p[1],
               p.npoints,
               CoordModeOrigin) -> XDrawLines;
           if);
       if);
   if);
#)

-- CanvasImmediateArc: dopart --
do 
   (if (implpart.xdrawable>0) then
       a2-a1 -> a2;
       (THIS(guienv).private.display, 
       implpart.xdrawable, 
       implpart.xgc,
       cx-hr,
       cy-vr,
       2*hr,
       2*vr,
       64*a1,
       64*a2) -> XDrawArc;
   if)
   
   
-- canvasImmediaterectBody: dopart --
do
   (if (implpart.xdrawable>0) then
       (THIS(guienv).private.display, 
       implpart.xdrawable, 
       implpart.xgc,
       r.x,r.y,r.width,r.height) -> XDrawRectangle;
   if);
   
   
-- canvasClearRectBody: dopart --
do (if (implpart.xdrawable>0) then
       r -> TM.transformRectangle -> r;
       (THIS(guienv).private.display, 
       implpart.xdrawable, 
       r.x, r.y,
       r.width, r.height,0) -> XClearArea;
   if);
   
   
-- NoModifierBody: dopart --
do 0 -> m 
   
-- ShiftModifierBody: dopart --
do ShiftMask -> m 
   
-- ControlModifierBody: dopart --
do ControlMask -> m 
   
-- LockModifierBody: dopart --
do LockMask -> m 
   
-- MetaModifierBody: dopart --
do Mod1Mask -> m 
   
-- CommandModifierBody: dopart --
do 999 -> m (* Not for X11 *) 
   
-- CanvasAttributes: attributes --

Expose:
  (* Draw the GOs intersecting the damaged list reported in expose events *)
  (#
  do 
     <<SLOT GetDamagedRectangles: descriptor>>;
     repair;
  #);

grabPointer:
  (# status: @Integer;
     mask: @Integer;
  do 
     XButtonReleaseMask + XButtonPressMask + XPointerMotionMask -> mask;
     (if (implpart.xdrawable>0) then
         <<SLOT XGrabPointer: descriptor>>;
         (if status
          // 0 then 
          // 1 then
             'Failed to grab X Pointer: allready grabbed' -> putwarnline;
          // 2 then
             'Failed to grab X Pointer: invalid time' -> putwarnline;
          // 3 then
             'Failed to grab X Pointer: not viewable' -> putwarnline;
          // 4 then
             'Failed to grab X Pointer: frozen' -> putwarnline;
         if);
     if);
  #);

unGrabPointer: (# <<SLOT XUnGrabPointer: dopart>> #);

-- CanvasInteractionHandlerDoBody: descriptor --
(# buttonID : @Integer;
   ch: @char;
   display: @integer;
   allbuttons: @integer;
   translateKey: @implpart.xkey.translate
     (# do (if noOfChars=1 then kpCh -> ch -> theKeyPress if) #);
   
   theMotion: @Motion;
   theButtonPress: @ButtonPress;
   theButtonRelease: @ButtonRelease;
   theTerminateCondition: @TerminateCondition;
   theKeyPress: @KeyPress;
   theKeyRelease: @KeyRelease;
   getNextEvent: @<<SLOT GetNextEvent: descriptor>>;
   eventPending: @booleanValue(# <<SLOT eventPending: dopart>> #);
do
   <<SLOT StartInteractionHandler: descriptor>>;
   Grabpointer;
   0 -> implpart.xevent.type; (* xevent is not currently valid *)
   THIS(guienv).private.display->display;
   XLeftButton+XRightButton+XMiddleButton -> allbuttons;
   Initialize;
   loop:
     (#  
     do
	waitForEvent:
	  (if not eventPending then
	      6 -> guienvWait;
	      (if eventPending then leave waitForEvent if);
	      idle;
	      restart waitForEvent
	  if);
	getNextEvent;
        (if implpart.xevent.type 
         // XMotionNotify then
            (if (THIS(guienv).private.display -> XPending)
             // 0 then 
                implpart.xevent -> implpart.xbutton;
                theMotion;
            if);
         // XButtonPress then
            implpart.xevent -> implpart.xbutton;
            implpart.lastbut -> implpart.prevbut;
            implpart.xbutton.time -> implpart.lastbut;
            implpart.xbutton.button %band allbuttons
              -> buttonID -> theButtonPress;
            (if ((button3=buttonID) -> TerminateCondition) then leave loop
            if);
         // XButtonRelease then
            implpart.xevent -> implpart.xbutton;
            theButtonRelease;
            (if theTerminateCondition then leave loop if);
         // XKeyPress then
            implpart.xevent -> implpart.xkey -> implpart.xbutton;
            translateKey;
         // XKeyRelease then
            implpart.xevent -> implpart.xkey -> implpart.xbutton; 
            ch -> theKeyRelease;
         // XMappingNotify then
            implpart.xevent.ptr -> XRefreshKeyboardMapping;
        if);
        (if theTerminateCondition then leave loop
         else restart loop
        if);
     #); (* end loop *)
   UnGrabpointer;
   Terminated;
   <<SLOT EndInteractionHandler: descriptor>>;
#)

-- CanvasGetPointerBody: descriptor --
(#
do (if implpart.xevent.type = 0 then (* This must be a call from Initialize *)
       (# rw, cw, xr, yr, xw, yw, keybuttons: @IntegerRef;
          status: @integer;
       do (THIS(guienv).private.display,
          implpart.xdrawable,
          rw, cw, xr, yr, xw, yw, keybuttons) -> XQueryPointer -> status;
          xw.value ->  thePoint.x;
          yw.value ->  thePoint.y;
       #)	     
    else
       (* 'GetPointer: '->putwarnline;
        *        '----------------------'->putwarnline;
        *        (implpart.xbutton.x, implpart.xbutton.y) -> putpoint;
        *)
       implpart.xbutton.x -> thePoint.x;
       implpart.xbutton.y -> thePoint.y;
   if);
#)

-- CanvasGetGlobalPointerBody: descriptor --
(# rw, cw, xr, yr, xw, yw, keybuttons: @IntegerRef;
   status: @integer;
do (THIS(guienv).private.display,
      implpart.xdrawable,
      rw, cw, xr, yr, xw, yw, keybuttons) -> XQueryPointer -> status;
   xr.value ->  thePoint.x;
   yr.value ->  thePoint.y;
#)

-- CanvasIsModifierOnBody: descriptor --
(#
do (if themodifier=0 then (* NoModifier *)
       false -> value;
    else
       (if implpart.xevent.type=0 then (* This must be a call from Initialize *)
           (# rw, cw, xr, yr, xw, yw, keybuttons: @IntegerRef;
              status: @integer;
           do (THIS(guienv).private.display,
              implpart.xdrawable,
              rw, cw, xr, yr, xw, yw, keybuttons) 
                -> XQueryPointer -> status;
              ((keybuttons.value %Band themodifier) <> 0)  -> value;
              (* Perhaps XQueryKeyMap would be better *)
           #)
        else 
           ((implpart.xbutton.state %Band themodifier) <> 0)  -> value;
       if)
   if);
#)

-- CanvasTerminateCondition: dopart --
do INNER
   
-- CanvasDoubleClickBody: dopart --
do (implpart.lastbut - implpart.prevbut) > implpart.dbltime -> value 
   
-- CanvasMMtoPixel: descriptor --
(# s: @ScaleMatrix;
do (THIS(guienv).private.pixelsPerMillimeterHeight, 
   THIS(guienv).private.pixelsPerMillimeterWidth) -> s;
   p -> s.transformPoint -> p;
#)

-- CanvasPixelToMM: descriptor --
(# s: @ScaleMatrix;
do (THIS(guienv).private.pixelsPerMillimeterHeight, 
   THIS(guienv).private.pixelsPerMillimeterWidth) -> s;
   p -> s.inversetransformPoint -> p;
#)
