ORIGIN '../Impl/PaintImpl';
LIB_ITEM 'bifrost';
INCLUDE 'BifrostX11impl';

-- lib: attributes --

YAllocColor: external
   (# display: @integer;
      cmap: @integer;
      c: ^XColor;
      res: @integer
   enter (display, cmap, c[])
   exit res
   #);
-- PaintFillShapeBody: dopart --
do (if not theShape.isClosed then
       'Trying to fill non-closed Shape; ignoring request' -> putwarnline;
    else
       (THIS(guienv).private.display, 
       theCanvas.implpart.xgc,
       theShape.FillRule) -> XSetFillRule;
       INNER;
   if);

-- PaintFillLineBody: dopart --
do (* Set lineWidth *)
   (THIS(guienv).private.display, 
   theCanvas.implpart.xgc,
   theLine.width->theCanvas.ZoomDim,
   0,
   theline.cap,
   0) -> XSetLineAttributes;
   INNER;

-- PaintFillMultiLineBody: dopart --
do (* Set lineWidth *)
   (THIS(guienv).private.display, 
   theCanvas.implpart.xgc,
   theMultiLine.width->theCanvas.ZoomDim,
   0,
   theMultiLine.cap,
   themultiline.join) -> XSetLineAttributes;
   INNER;


-- PaintFillTextBody: dopart --
do (* Cannot call SetXfont here, since we need to get
    * the xf[] out of this call and use in the specializations.
    * Otherwise we would have to use a global variable somewhere
    * for the xf to propagate it to the specializations.
    *)
   INNER;

-- PaintFillPieBody: dopart --
do (THIS(guienv).private.display, 
   theCanvas.implpart.xgc,
   0,
   0,
   0,
   XJoinBevel) -> XSetLineAttributes;
   
   (THIS(guienv).private.display, 
   theCanvas.implpart.xgc,
   ArcPieSlice) -> XSetArcMode;
   INNER;   

-- PaintFillArcBody: dopart --
do (* Set lineWidth *)
   (THIS(guienv).private.display, 
   theCanvas.implpart.xgc,
   theArc.ArcWidth->theCanvas.ZoomDim,
   0,
   0,
   0) -> XSetLineAttributes;
   INNER;

-- PaintFillRectBody: dopart --
do (if theRect.stroked then
       (THIS(guienv).private.display, 
       theCanvas.implpart.xgc,
       theRect.StrokeWidth->theCanvas.ZoomDim,
       0,
       0,
       XJoinMiter) -> XSetLineAttributes;
   if);
   INNER;

-- PaintFillEllipseBody: dopart --
do (if theEllipse.stroked then
       (* Set lineWidth *)
       (THIS(guienv).private.display, 
       theCanvas.implpart.xgc,
       theEllipse.StrokeWidth->theCanvas.ZoomDim,
       0,
       0,
       0) -> XSetLineAttributes;
   if);
   INNER;

-- SolidColorImplPart: descriptor --
(# theXColor: @XColor;
   allocated: @integer;
#)

-- SolidColorInitBody: dopart --
do 0 -> implpart.allocated; 
   INNER

-- SolidColorChangedBody: descriptor --
(# 
do 0 -> implpart.allocated;
   
   privatepart.red -> implpart.theXcolor.red;
   privatepart.green -> implpart.theXcolor.green;
   privatepart.blue -> implpart.theXcolor.blue;
#)

-- MaxRGBBody: dopart --
do 65535 -> max 

-- SolidColorCopyImplPart: descriptor --
(# 
do	
   implpart.theXColor.red
     -> sc.implpart.theXColor.red;
   implpart.theXColor.green
     -> sc.implpart.theXColor.green;
   implpart.theXColor.blue
     -> sc.implpart.theXColor.blue;
   implpart.theXColor.pixel
     -> sc.implpart.theXColor.pixel;
   implpart.allocated
     -> sc.implpart.allocated;
#)

-- SolidColorSetCanvasPaintBody: dopart --
do (* Set color in GC of theCanvas *)
   INNER;
   (if not doneInInner then
       (THIS(guienv).private.display,
       theCanvas.implpart.xgc,
       FillSolid) -> XSetFillStyle;
   if);
   
   (* The rest must always be done *)
   (if  (implpart.allocated=0) then
       (* Allocate color *)
       (THIS(guienv).private.display, 
       theCanvas.implpart.xcolormap,
       implpart.theXcolor[] ) 
         -> YAllocColor -> implpart.allocated;
       
       (if implpart.allocated=0 then
           'Couldn\'t allocate color' -> putwarnline;
       if);
       
   if);
   
   (* Set foreground pixel value in theCanvas *)
   
   (THIS(guienv).private.display, 
   theCanvas.implpart.xgc,
   implpart.theXcolor.pixel) -> XSetForeGround;
   
   (if debuggraphic then
       'SolidColor: Foreground: '->putwarntext;
       (implpart.theXcolor.red, 6) -> putwarnintwidth;
       (implpart.theXcolor.green, 6) -> putwarnintwidth;
       (implpart.theXcolor.blue, 6) -> putwarnintwidthline;
   if);


-- SolidColorSetBorderPaintBody: dopart --
do INNER;
   (if (implpart.allocated=0) then
       (THIS(guienv).private.display, 
       THIS(guienv).private.xcolormap,
       implpart.theXcolor[] ) 
         -> YAllocColor -> implpart.allocated;
       
       (if (implpart.allocated=0) then
           'Couldn\'t allocate color' -> putwarnline;
       if);
       
   if);
   
   (if theCanvas.implpart.xdrawable=0 then
       (* setting of border paint is handled upon open *)
       implpart.theXcolor.pixel
         -> theCanvas.SetCanvasBorderPixel; 
    else 
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable,
       implpart.theXcolor.pixel) -> XSetWindowBorder;
   if);


-- SolidColorSetBackgroundPaintBody: dopart --
do INNER;
   (if not doneininner then
       (if (implpart.allocated=0) then
           (THIS(guienv).private.display, 
           THIS(guienv).private.xcolormap,
           implpart.theXcolor[] ) 
             -> YAllocColor -> implpart.allocated;
           
           (if (implpart.allocated=0)  then
               'Couldn\'t allocate color' -> putwarnline;
           if);
       if);
       
       (if theCanvas.implpart.xdrawable=0 then
           (* setting of background paint is handled upon open *)
           implpart.theXcolor.pixel
             -> theCanvas.SetCanvasBackgroundPixel;
        else
           (THIS(guienv).private.display, 
           theCanvas.implpart.xdrawable,
           implpart.theXcolor.pixel) -> XSetWindowBackGround;
           
           (THIS(guienv).private.display, 
           theCanvas.implpart.xdrawable,
           0, 0, 0, 0, 1) -> XClearArea;
       if);
   if);


-- SolidColorFillShapeBody: dopart --
do INNER;
   (if theShape.isclosed then
       
       theCanvas[]->setCanvasPaint;
       
       (if theShape.Invalid then
           theCanvas[] -> theShape.recalculatePrivatePart;
       if);
       
       (if (theShape.privatepart.implpart.NoOfPoints>0) and
           (theShape.privatepart.implpart.XPoints[]<>NONE) then
           (THIS(guienv).private.display,
           theCanvas.implpart.xdrawable,
           theCanvas.implpart.xgc,
           @@theShape.privatepart.implpart.XPoints.p[1],
           theShape.privatepart.implpart.NoOfPoints,
           Complex,
           Coordmodeorigin) -> XFillPolygon;
       if);
       (if debugGraphic then
           'SolidColor.FillShape done' -> putwarnline;
       if);
   if);


-- SolidColorFillLineBody: descriptor --
(# devBegin,devEnd: @Point;
do 
   theCanvas[]->setCanvasPaint;
   theLine.begin 
     -> theLine.privatepart.go2canvasTM.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> devBegin; 
   theLine.end 
     -> theLine.privatepart.go2canvasTM.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> devEnd;
   (THIS(guienv).private.display, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   devBegin.x, devBegin.y, devEnd.x, devEnd.y) -> XDrawLine;
#)

-- SolidColorFillMultiLineBody: dopart --
do theCanvas[]->setCanvasPaint;
   (if theMultiLine.privatepart.implpart[]=NONE then
       &theMultiLine.privatepart.implparttype[]
         -> theMultiLine.privatepart.implpart[]
   if);
   (if theMultiLine.Invalid then
       (theMultiLine.privatePart.go2canvastm,
       theCanvas.TM[]) 
         -> MatrixMul
         -> theMultiLine.points.p.ToXPoints
         -> theMultiLine.privatepart.implpart.xpoints[];
       theMultiLine.points.p.npoints 
         -> theMultiLine.privatepart.implpart.noofpoints;
   if);
   (if theMultiLine.dashes<>NONE then
       'MultiLine dashes' -> unimplemented;
   if);
   (if (theMultiline.privatepart.implpart.NoOfPoints>0) and
       (theMultiline.privatepart.implpart.XPoints[]<>NONE) then
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       @@theMultiLine.privatepart.implpart.xpoints.p[1],
       theMultiLine.privatepart.implpart.noofpoints,
       Coordmodeorigin) -> XDrawLines;
   if);

-- SolidColorFillTextBody: descriptor --
(# origin: @Point;
   strings: ^textlist;
   xf: ^THIS(guienv).private.xfont;
   nam: @FontName;
   sty: @Style;
   siz: @Integer;
   upos, uthick, width, lineheight: @integer;
do (if debug_fonts then
       'SolidColorFillTextBody: ' -> putline;
       '  '->puttext;
       (theText.theFontName, theText.theStyle, theText.Size) -> Font2Text -> putline;
   if);
   (theCanvas[],theText.theFontName, theText.theStyle, theText.Size) 
     -> SetXFont 
     -> (xf[], nam, sty, siz);
   (if debug_fonts then
       '  '->puttext;
       (nam,sty,siz) -> Font2Text -> puttext;
       ': ' -> puttext;
       xf.name[] -> putline;
   if);
   INNER FillText; 
   thetext.thelines -> strings[];
   theCanvas[]->setCanvasPaint;
   theText.Position 
     -> theText.privatePart.go2canvastm.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> origin;
   (if strings.size>1 then
       xf.lineheight -> lineheight;
   if);
   (if theText.underline then
       xf.upos -> upos;
       xf.uthick -> uthick;
   if);
   
   strings.scan
   (# 
   do (THIS(guienv).private.display, 
      theCanvas.implpart.xdrawable, 
      theCanvas.implpart.xgc,
      origin.x,
      origin.y, 
      current, 
      current.lgth) -> XDrawString;
      
      (if xf.fixedwidth then 
          current.length*xf.width -> width;
       else
          (xf.fi,current.t, current.t.range) -> XTextWidth -> width;
      if);

      (if theText.underline then
          (THIS(guienv).private.display,
          theCanvas.implpart.xdrawable, 
          theCanvas.implpart.xgc,
          origin.x,
          origin.y + upos,
          width,
          uthick) -> XFillRectangle;
      if);
      
      origin.y+lineheight -> origin.y (* device coords *);
   #);
#)

-- SolidColorFillPieBody: descriptor --
(# devUpperLeft,radius: @Point;
   a1, a2: @integer;
do theCanvas[]->setCanvasPaint;
   thePie.center -> thePie.privatePart.go2canvasTM.m.transformPoint
     -> devupperleft;
   
   (devupperleft.x,devupperleft.y,thePie.horizontalRadius,thePie.verticalRadius)
     -> theCanvas.CanvasToDeviceRectangle
     -> (devupperleft.x,devupperleft.y,radius.x,radius.y);
   
   (devupperleft.x-radius.x,
   devupperleft.y-radius.y) -> devupperleft;
   
   thePie.angle1 * 64 -> a1;
   thePie.angle2 * 64 -> a2;
   a2 - a1 -> a2;
   (* (if a1>360 then a1-360 -> a1 if); *)
   
   (THIS(guienv).private.display, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   devUpperLeft.x,devUpperLeft.y,
   2*radius.x, 2*radius.y,
   a1, a2) -> XFillArc;
#)

-- SolidColorFillArcBody: descriptor --
(# devUpperLeft,radius: @Point;
   a1, a2: @integer;
do theCanvas[]->setCanvasPaint;
   
   theArc.center -> theArc.privatePart.go2canvasTM.m.transformPoint
     -> devupperleft;
   
   (devupperleft.x,devupperleft.y,theArc.horizontalRadius,theArc.verticalRadius)
     -> theCanvas.CanvasToDeviceRectangle
     -> (devupperleft.x,devupperleft.y,radius.x,radius.y);
   
   (devupperleft.x-radius.x,
   devupperleft.y-radius.y) -> devupperleft;
   
   theArc.angle1 * 64 -> a1;
   theArc.angle2 * 64 -> a2;
   a2 - a1 -> a2;
  
   (THIS(guienv).private.display, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   devUpperLeft.x, devUpperleft.y,
   2*radius.x, 2*radius.y,
   a1, a2) -> XDrawArc;
#)

-- SolidColorFillRectBody: descriptor --
(# r: @rectangle;
do theCanvas[]->setCanvasPaint;
   theRect.upperleft 
     -> theRect.privatepart.go2canvasTM.m.transformPoint
     -> (r.x, r.y);
   (theRect.width, theRect.height) -> (r.width, r.height);
   r -> theCanvas.CanvasToDeviceRectangle -> r;

   (if theRect.stroked then
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       r.x, r.y, r.width, r.height) -> XDrawRectangle;
    else
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       r.x, r.y, r.width, r.height) -> XFillRectangle;
   if);
#)

-- SolidColorFillEllipseBody: descriptor --
(# devUpperLeft,radius: @Point;
do (if thecanvas[]=none then 
       'SolidColorFillEllipseBody: canvas is none'->putwarnline 
   if);
   theCanvas[]->setCanvasPaint;
   theEllipse.center -> theEllipse.privatepart.go2canvasTM.m.transformPoint
     -> devupperleft;
   
   (devupperleft.x,devupperleft.y,
   theEllipse.horizontalRadius,theEllipse.verticalRadius)
     -> theCanvas.CanvasToDeviceRectangle
     -> (devupperleft.x,devupperleft.y,radius.x,radius.y);
   
   (devupperleft.x-radius.x,
   devupperleft.y-radius.y) -> devupperleft;
   
   
   (if theEllipse.stroked then
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       devUpperleft.x, devUpperleft.y,
       2*radius.x,
       2*radius.y,
       0,360*64) -> XDrawArc;
    else
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       devUpperleft.x, devUpperleft.y,
       2*radius.x,
       2*radius.y,
       0,360*64) -> XFillArc;
   if);
#)


(*** TiledSolidColor ****)

-- TiledSolidFillShapeBody: dopart --
do INNER; 
   theShape[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillShape *) 


-- TiledSolidFillLineBody: dopart --
do INNER; 
   theLine[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillLine *) 


-- TiledSolidFillMultiLineBody: dopart --
do INNER; 
   theMultiLine[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillMultiline *) 


-- TiledSolidFillTextBody: dopart --
do INNER; 
   theText[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillText *) 


-- TiledSolidFillArcBody: dopart --
do INNER; 
   theArc[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillArc*) 


-- TiledSolidFillPieBody: dopart --
do INNER; 
   thePie[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillPie *) 


-- TiledSolidFillRectBody: dopart --
do INNER; 
   theRect[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillRect *) 


-- TiledSolidFillEllipseBody: dopart --
do INNER; 
   theEllipse[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillEllipse *) 


-- BifrostAttributes: attributes --

XCreatePixmapFromBitmap:
  (# pixel: @integer;
     bitmap: @integer;
     width, height: @integer;
     pixmap: @integer;
     theCanvas: ^BifrostCanvas;
  enter (theCanvas[], bitmap, width, height, pixel)
  do (* Set foreground pixel in 
      * theCanvas.implpart.xgc
      *)
     (THIS(guienv).private.display, 
     theCanvas.implpart.xgc,
     pixel) -> XSetForeGround;
     
     (* Create the Pixmap to exit *)
     (THIS(guienv).private.display,
     THIS(guienv).private.defaultdrawable,
     width,
     height,
     THIS(guienv).private.defaultdepth)
       -> XCreatePixmap -> pixmap;
     
     (* Copy bitmap to pixmap 
      * using theCanvas.implpart.xgc
      *)
     (THIS(guienv).private.display,
     theCanvas.implpart.xgc,
     0) -> XSetGraphicsExposures;
     
     (THIS(guienv).private.display,
     bitmap, 
     pixmap, 
     theCanvas.implpart.xgc,
     0,
     0,
     width,
     height,
     0,
     0,
     1) -> XCopyPlane;
  exit pixmap
  #);

-- TiledSolidSetBorderPaintBody: descriptor --
(# pixmap: @integer;
do (if not doneInInner then
       (* Check if color is allocated *)
       (if (implpart.allocated=0) then
           (* Allocate color *)
           (THIS(guienv).private.display, 
           THIS(guienv).private.xcolormap,
           implpart.theXcolor[] ) 
             -> YAllocColor -> implpart.allocated;
           
           (if implpart.allocated=0 then
               'Couldn\'t allocate color' -> putwarnline;
           if);
       if);
       
       (if tiledprivate.theBitmap.BitMapPrivatePart.xpixmap
        = 0 then (* Maybe the Bitmap hasn't been evaluated *)
           tiledprivate.theBitmap.calculate
       if);
       
       (theCanvas[],
       tiledprivate.theBitmap.BitMapPrivatePart.xpixmap,
       tiledprivate.theBitmap.width,
       tiledprivate.theBitmap.height,
       implpart.theXcolor.pixel)
         -> XCreatePixmapFromBitmap (* See above *)
         -> pixmap;
       
       (* Now set the background_pixmap of 
        * theCanvas.implpart.xdrawable
        *)
       (if theCanvas.implpart.xdrawable=0 then
           (* setting of background paint is handled upon open *)
           pixmap->theCanvas.SetCanvasBorderPixmap;
        else
           (THIS(guienv).private.display,
           theCanvas.implpart.xdrawable,
           pixmap) -> XSetWindowBorderPixmap;
       if);
       (*(THIS(guienv).private.display, pixmap) -> XFreePixmap;*)
       
       true -> doneInInner;
   if)
#)

-- TiledSolidSetBackgroundPaintBody: descriptor -- 
(# pixmap: @integer;
do (if not doneInInner then
       (* Check if color is allocated *)
       (if (implpart.allocated=0) then
           (* Allocate color *)
           (THIS(guienv).private.display, 
           THIS(guienv).private.xcolormap,
           implpart.theXcolor[] ) 
             -> YAllocColor -> implpart.allocated;
           
           (if (implpart.allocated=0) then
               'Couldn\'t allocate color' -> putwarnline;
           if);
       if);
       
       (if tiledprivate.theBitmap.BitMapPrivatePart.xpixmap
        = 0 then (* Maybe the Bitmap hasn't been evaluated *)
           tiledprivate.theBitmap.calculate
       if);
       
       (theCanvas[],
       tiledprivate.theBitmap.BitMapPrivatePart.xpixmap,
       tiledprivate.theBitmap.width,
       tiledprivate.theBitmap.height,
       implpart.theXcolor.pixel)
         -> XCreatePixmapFromBitmap (* See above *)
         -> pixmap;
       
       (* Now set the background_pixmap of 
        * theCanvas.implpart.xdrawable
        *)
       (if theCanvas.implpart.xdrawable=0 then
           (* setting of background paint is handled upon open *)
           pixmap
             -> theCanvas.SetCanvasBackgroundPixmap;
        else
           (THIS(guienv).private.display,
           theCanvas.implpart.xdrawable,
           pixmap) -> XSetWindowBackgroundPixmap;
           
           (THIS(guienv).private.display, 
           theCanvas.implpart.xdrawable,
           0, 0, 0, 0, 1) -> XClearArea;
       if);
       (*(THIS(guienv).private.display, pixmap) -> XFreePixmap;*)
       
       true -> doneInInner;
   if)
#)

-- TiledSolidSetCanvasPaintBody: descriptor --
(# pos: @Point;
   rasthot: @point;
do (if debuggraphic then 'TiledSolidSetCanvasPaint'->putwarnline; if);
   
   (if tiledprivate.theBitmap[]=NONE then
       'TiledSolidColor: the tile is NONE; ignoring tiling.'
         ->putwarnline;
    else
       (* Check the X Pixmap *)
       (if tiledprivate.theBitmap.BitMapPrivatePart.xpixmap
        = 0 then (* Maybe the Bitmap hasn't been evaluated *)
           'TiledSolidColor: The tile bitmap does not seem to have been evaluated!'
             -> putwarnline;
           'Evaluating it once.' -> putwarnline;
           tiledprivate.theBitmap;
       if);
       
       (THIS(guienv).private.display,
       theCanvas.implpart.xgc,
       FillStippled)
         -> XSetFillStyle;
       
       (THIS(guienv).private.display,
       theCanvas.implpart.xgc,
       tiledprivate.theBitmap.BitMapPrivatePart.xpixmap)
         -> XSetStipple;
       
       (if debuggraphic then
           'TiledSolidColor: Tiling prepared' -> putwarnline;
       if);
       
       (* Place hotspot of private.theBitmap on hotspot of 
        * tiledprivate.theshape (if any: TextShape.interactivecreate uses
        * setcanvaspaint without specifying tiledprivate.theshape).
        *)
       (if tiledprivate.theshape[]<>NONE then
           tiledprivate.theshape.hotspot 
             -> tiledprivate.theshape.privatePart.go2CanvasTM.m.transformPoint
             -> theCanvas.CanvasToDevice
             -> pos;
           tiledprivate.theBitmap.hotspot -> rasthot;
           pos.y - (tiledprivate.theBitmap.height - rasthot.y) -> pos.y;
           pos.x - rasthot.x -> pos.x;
       if);
       
       (THIS(guienv).private.display,
       theCanvas.implpart.xgc,
       pos.x, pos.y) -> XSetTSOrigin;
       
       true -> doneInInner;
   if);
   
#)

(*** RasterPaint ****)


-- RasterPaintFillMultiLineBody: dopart --
do INNER
-- RasterPaintFillArcBody: dopart --
do INNER
-- RasterPaintFillPieBody: dopart --
do INNER


-- RasterPaintFillShapeBody: descriptor --
(# pos: @point;
   rasthot: @point;
do 
   (if theShape.isclosed then
       
       theCanvas[]->setCanvasPaint;
       (if theShape.Invalid then
           theCanvas[] -> theShape.recalculatePrivatePart;
       if);
       theShape[] -> theCanvas.setclip;
       
       (if private.thePixmap[]=NONE then
           'RasterPaint: thePixmap is NONE; ignoring fill request'->putwarnline
        else 
           (* Place hotspot of private.thePixmap on hotspot of theshape *)
           theShape.hotspot -> theShape.privatePart.go2CanvasTM.m.transformPoint
             -> theCanvas.CanvasToDevice -> pos;
           private.thePixmap.hotspot -> rasthot;
           pos.y - (private.thePixmap.height - rasthot.y)
             -> pos.y;
           pos.x - rasthot.x 
             -> pos.x;
           
           (if paddingSolidColor[]=NONE then (* Tile with thePixMap *)
               (# b: @rectangle;
                  x, y, y1: @integer;
                  w, h: @integer;
                  (* Here we do it ourself. Alternatively one may write it in an
                   * X Pixmap and use this in an XSetTile with offset pos.
                   * This requires the FillTiled FillStyle.
                   *)
               do
                  theShape.getBounds 
                    -> theCanvas.TM.transformRectangle
                    -> b;
                  private.thePixmap.width -> w;
                  private.thePixmap.height -> h;
                  pos.x - w*((pos.x-b.x) div w + 1) -> x;
                  pos.y - h*((pos.y-b.y) div h + 1) -> y -> y1;
                  (for (b.width div w + 2) repeat
                       (for (b.height div h + 2) repeat
                            (THIS(guienv).private.display, 
                            theCanvas.implpart.xdrawable, 
                            theCanvas.implpart.xgc,
                            private.thePixmap.pixmapprivatepart.ximage,
                            0, 0, x, y, w, h) -> XPutImage;
                            y+h->y;
                       for);
                       y1 ->y;
                       x+w->x;
                  for);
               #);
	    else
               (theCanvas[],theShape[]) -> paddingSolidColor.fillShape;
               (THIS(guienv).private.display, 
               theCanvas.implpart.xdrawable, 
               theCanvas.implpart.xgc,
               private.thePixmap.pixmapprivatepart.ximage,
               0,0,
               pos.x, pos.y,
               private.thePixmap.width,
               private.thePixmap.height) -> XPutImage;
           if);
       if);
       theCanvas.visualShape[]
         -> theCanvas.SetClip;
   if);
   
#)

-- RasterPaintFillLineBody: dopart --
do INNER
-- RasterPaintFillRectBody: dopart --
do INNER
-- RasterPaintFillTextBody: dopart --
do INNER
-- RasterPaintFillEllipseBody: dopart --
do INNER

-- RasterPaintSetBorderPaintBody: descriptor --
(# pixmap: @integer;
do (* Create a pixmap and put private.thePixmap.pixmapprivatepart.ximage
    * into it
    *)
   
   (THIS(guienv).private.display,
   THIS(guienv).private.defaultdrawable,
   private.thePixmap.width,
   private.thePixmap.height,
   THIS(guienv).private.defaultdepth)
     -> XCreatePixmap -> pixmap;
   
   (THIS(guienv).private.display, 
   pixmap, 
   theCanvas.implpart.xgc,
   private.thePixmap.pixmapprivatepart.ximage,
   0,0,
   0,0,
   private.thePixmap.width,
   private.thePixmap.height) -> XPutImage;
   
   (* Now set the border_pixmap of 
    * theCanvas.implpart.xdrawable
    *)
   (if theCanvas.implpart.xdrawable=0 then
       (* setting of background paint is handled upon open *)
       pixmap->theCanvas.SetCanvasBorderPixmap;
    else
       (THIS(guienv).private.display,
       theCanvas.implpart.xdrawable,
       pixmap) -> XSetWindowBorderPixmap;
   if);
   (*(THIS(guienv).private.display, pixmap) -> XFreePixmap;*)
#)

-- RasterPaintSetBackgroundPaintBody: descriptor --
(# pixmap: @integer;
do (* Create a pixmap and put private.thePixmap.pixmapprivatepart.ximage
    * into it
    *)
   
   (THIS(guienv).private.display,
   THIS(guienv).private.defaultdrawable,
   private.thePixmap.width,
   private.thePixmap.height,
   THIS(guienv).private.defaultdepth)
     -> XCreatePixmap -> pixmap;
   
   (THIS(guienv).private.display, 
   pixmap, 
   theCanvas.implpart.xgc,
   private.thePixmap.pixmapprivatepart.ximage,
   0,0,
   0,0,
   private.thePixmap.width,
   private.thePixmap.height) -> XPutImage;
   
   (* Now set the background_pixmap of 
    * theCanvas.implpart.xdrawable
    *)
   (if theCanvas.implpart.xdrawable=0 then
       (* setting of background paint is handled upon open *)
       pixmap->theCanvas.SetCanvasBackgroundPixmap;
    else
       (THIS(guienv).private.display,
       theCanvas.implpart.xdrawable,
       pixmap) -> XSetWindowBackgroundPixmap;
       
       (THIS(guienv).private.display, 
       theCanvas.implpart.xdrawable,
       0, 0, 0, 0, 1) -> XClearArea;
   if);
   (* (THIS(guienv).private.display, pixmap) -> XFreePixmap; *)
#)

-- RasterPaintSetCanvasPaintBody: descriptor --
(# (* Nothing needed, GC isn't changed *) #)
