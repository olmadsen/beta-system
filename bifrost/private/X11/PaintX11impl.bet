ORIGIN '../Impl/PaintImpl';
INCLUDE 'BifrostX11impl';

-- PaintFillShapeBody: dopart --
do (if not theShape.isClosed then
       (if displayWarnings then
           'Trying to fill non-closed Shape; ignoring request' -> putline;
       if);
    else
       (xdisplay, 
       theCanvas.implpart.xgc,
       theShape.FillRule) -> XSetFillRule;
       INNER;
   if);

-- PaintFillLineBody: dopart --
do (* Set lineWidth *)
   (xdisplay, 
   theCanvas.implpart.xgc,
   theLine.width,
   0,
   theline.cap,
   0) -> XSetLineAttributes;
   INNER;

-- PaintFillMultiLineBody: dopart --
do (* Set lineWidth *)
   (xdisplay, 
   theCanvas.implpart.xgc,
   theMultiLine.width,
   0,
   theMultiLine.cap,
   themultiline.join) -> XSetLineAttributes;
   INNER;


-- PaintFillTextBody: dopart --
do (* Find the X font to use *)
   (theCanvas[],theText.theFontName, theText.theStyle, theText.Size) -> SetXFont;
   INNER;

-- PaintFillPieBody: dopart --
do (xdisplay, 
   theCanvas.implpart.xgc,
   0,
   0,
   0,
   XJoinBevel) -> XSetLineAttributes;
   
   (xdisplay, 
   theCanvas.implpart.xgc,
   ArcPieSlice) -> XSetArcMode;
   INNER;   

-- PaintFillArcBody: dopart --
do (* Set lineWidth *)
   (xdisplay, 
   theCanvas.implpart.xgc,
   theArc.ArcWidth,
   0,
   0,
   0) -> XSetLineAttributes;
   INNER;

-- PaintFillRectBody: dopart --
do (if theRect.stroked then
       (xdisplay, 
       theCanvas.implpart.xgc,
       theRect.StrokeWidth,
       0,
       0,
       XJoinMiter) -> XSetLineAttributes;
   if);
   INNER;

-- PaintFillEllipseBody: dopart --
do (if theEllipse.stroked then
       (* Set lineWidth *)
       (xdisplay, 
       theCanvas.implpart.xgc,
       theEllipse.StrokeWidth,
       0,
       0,
       0) -> XSetLineAttributes;
   if);
   INNER;

-- SolidColorImplPart: descriptor --
(# theXColor: @XColor;
   allocated: @Boolean;
#)

-- SolidColorInitBody: dopart --
do false -> implpart.allocated; 
   INNER

-- SolidColorChangedBody: descriptor --
(# 
do false -> implpart.allocated;
   
   privatepart.red -> implpart.theXcolor.red;
   privatepart.green -> implpart.theXcolor.green;
   privatepart.blue -> implpart.theXcolor.blue;
#)

-- MaxRGBBody: dopart --
do 65535 -> max 

-- SolidColorCopyImplPart: descriptor --
(# 
do	
   implpart.theXColor.red
     -> sc.implpart.theXColor.red;
   implpart.theXColor.green
     -> sc.implpart.theXColor.green;
   implpart.theXColor.blue
     -> sc.implpart.theXColor.blue;
   implpart.theXColor.pixel
     -> sc.implpart.theXColor.pixel;
   implpart.allocated
     -> sc.implpart.allocated;
#)

-- SolidColorSetCanvasPaintBody: dopart --
do (* Set color in GC of theCanvas *)
   INNER;
   (if not doneInInner then
       (xdisplay,
       theCanvas.implpart.xgc,
       FillSolid) -> XSetFillStyle;
   if);
   
   (* The rest must always be done *)
   (if not (implpart.allocated) then
       (* Allocate color *)
       (xdisplay, 
       theCanvas.implpart.xcolormap,
       implpart.theXcolor[] ) 
         -> XAllocColor -> implpart.allocated;
       
       (if not implpart.allocated then
           (if displayWarnings then
               'Couldn''t allocate color' -> putline;
           if);
       if);
       
   if);
   
   (* Set foreground pixel value in theCanvas *)
   
   (xdisplay, 
   theCanvas.implpart.xgc,
   implpart.theXcolor.pixel) -> XSetForeGround;
   
   (if debuggraphic then
       'SolidColor: Foreground: '->puttext;
       implpart.theXcolor.red
         -> screen.putint(# format::<(# do 6->width#)#);
       implpart.theXcolor.green
         -> screen.putint(# format::<(# do 6->width#)#);
       implpart.theXcolor.blue
         -> screen.putint(# format::<(# do 6->width#)#);
       newline;
   if);


-- SolidColorSetBorderPaintBody: dopart --
do INNER;
   (if not (implpart.allocated) then
       (xdisplay, 
       THIS(guienv).private.xcolormap,
       implpart.theXcolor[] ) 
         -> XAllocColor -> implpart.allocated;
       
       (if not implpart.allocated then
           (if displayWarnings then
               'Couldn''t allocate color' -> putline;
           if);
       if);
       
   if);
   
   (if theCanvas.implpart.xdrawable//0 then
       (* setting of border paint is handled upon open *)
       implpart.theXcolor.pixel
         -> theCanvas.SetCanvasBorderPixel; 
    else 
       (xdisplay, 
       theCanvas.implpart.xdrawable,
       implpart.theXcolor.pixel) -> XSetWindowBorder;
   if);


-- SolidColorSetBackgroundPaintBody: dopart --
do INNER;
   (if not doneininner then
       (if (not implpart.allocated) then
           (xdisplay, 
           THIS(guienv).private.xcolormap,
           implpart.theXcolor[] ) 
             -> XAllocColor -> implpart.allocated;
           
           (if not implpart.allocated then
               (if displayWarnings then
                   'Couldn''t allocate color' -> putline;
               if);
           if);
       if);
       
       (if theCanvas.implpart.xdrawable//0 then
           (* setting of background paint is handled upon open *)
           implpart.theXcolor.pixel
             -> theCanvas.SetCanvasBackgroundPixel;
        else
           (xdisplay, 
           theCanvas.implpart.xdrawable,
           implpart.theXcolor.pixel) -> XSetWindowBackGround;
           
           (xdisplay, 
           theCanvas.implpart.xdrawable,
           0, 0, 0, 0, 1) -> XClearArea;
       if);
   if);


-- SolidColorFillShapeBody: dopart --
do INNER;
   (if theShape.isclosed then
       
       theCanvas[]->setCanvasPaint;
       
       (if theShape.Invalid then
           theCanvas[] -> theShape.recalculatePrivatePart;
       if);
       
       (xdisplay,
       theCanvas.implpart.xdrawable,
       theCanvas.implpart.xgc,
       @@theShape.privatepart.implpart.XPoints.p[1],
       theShape.privatepart.implpart.NoOfPoints,
       Complex,
       Coordmodeorigin) -> XFillPolygon;
       (if debugGraphic then
           'SolidColor.FillShape done' -> putline;
       if);
   if);


-- SolidColorFillLineBody: descriptor --
(# devBegin,devEnd: @Point;
do 
   theCanvas[]->setCanvasPaint;
   theLine.begin 
     -> theLine.privatepart.go2canvasTM.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> devBegin; 
   theLine.end 
     -> theLine.privatepart.go2canvasTM.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> devEnd;
   (xdisplay, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   devBegin.x, devBegin.y, devEnd.x, devEnd.y) -> XDrawLine;
#)

-- SolidColorFillMultiLineBody: dopart --
do theCanvas[]->setCanvasPaint;
   (if theMultiLine.privatepart.implpart[]//NONE then
       &theMultiLine.privatepart.implparttype[]
         -> theMultiLine.privatepart.implpart[]
   if);
   (if theMultiLine.Invalid then
       (theMultiLine.privatePart.go2canvastm,
       theCanvas.TM[]) 
         -> MatrixMul
         -> theMultiLine.points.p.ToXPoints
         -> theMultiLine.privatepart.implpart.xpoints[];
       theMultiLine.points.p.npoints 
         -> theMultiLine.privatepart.implpart.noofpoints;
   if);
   (if theMultiLine.dashes<>NONE then
       'MultiLine dashes not yet implemented' -> putline;
   if);
   
   (xdisplay, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   @@theMultiLine.privatepart.implpart.xpoints.p[1],
   theMultiLine.privatepart.implpart.noofpoints,
   Coordmodeorigin) -> XDrawLines;


-- SolidColorFillTextBody: descriptor --
(# origin: @Point;
   string: @text;
   nam: @FontName;
   sty: @Style;
   siz: @integer;
   r: @rectangle;
   upos, uthick: @integer;
do thetext.thetext -> string;
   theCanvas[]->setCanvasPaint;
   theText.Position 
     -> theText.privatePart.go2canvastm.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> origin;
   
   (xdisplay, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   origin.x,
   origin.y, 
   string, 
   string.lgth) -> XDrawString;
   
   (if theText.underline then
       theText.theFontName -> nam;
       theText.theStyle    -> sty;
       theText.size        -> siz;
       thetext.getbounds   -> r;
       THIS(guienv).private.fonts.xfonts[nam].style[sty].size[siz].upos 
         -> upos;
       THIS(guienv).private.fonts.xfonts[nam].style[sty].size[siz].uthick
         -> uthick;
       
       (xdisplay,
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       origin.x,
       origin.y + upos,
       r.width,
       uthick) -> XFillRectangle;
   if);
#)

-- SolidColorFillPieBody: descriptor --
(# devUpperLeft: @Point;
   a1, a2: @integer;
do theCanvas[]->setCanvasPaint;
   thePie.center -> thePie.privatePart.go2canvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice 
     -> devupperleft;
   (devupperleft.x-thePie.horizontalRadius,
   devupperleft.y-thePie.verticalRadius) -> devupperleft;
   
   thePie.angle1 * 64 -> a1;
   thePie.angle2 * 64 -> a2;
   a2 - a1 -> a2;
   (* (if a1>360 then a1-360 -> a1 if); *)
   
   (xdisplay, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   devUpperLeft.x,devUpperLeft.y,
   2*thePie.horizontalradius,
   2*thePie.verticalradius,
   a1, a2) -> XFillArc;
#)

-- SolidColorFillArcBody: descriptor --
(# devUpperLeft: @Point;
   a1, a2: @integer;
do theCanvas[]->setCanvasPaint;
   
   theArc.center -> theArc.privatePart.go2canvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice
     -> devupperleft;
   (devupperleft.x-theArc.horizontalRadius,
   devupperleft.y-theArc.verticalRadius) -> devupperleft;
   
   
   theArc.angle1 * 64 -> a1;
   theArc.angle2 * 64 -> a2;
   a2 - a1 -> a2;
  
   (xdisplay, 
   theCanvas.implpart.xdrawable, 
   theCanvas.implpart.xgc,
   devUpperLeft.x, devUpperleft.y,
   2*theArc.horizontalradius,
   2*theArc.verticalradius,
   a1, a2) -> XDrawArc;
#)

-- SolidColorFillRectBody: descriptor --
(# devUpperLeft: @Point;
do theCanvas[]->setCanvasPaint;
   theRect.upperleft 
     -> theRect.privatepart.go2canvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice
     -> devUpperLeft;
   (if theRect.stroked then
       (xdisplay, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       devUpperleft.x, devUpperleft.y,
       theRect.width, theRect.height) -> XDrawRectangle;
    else
       (xdisplay, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       devUpperleft.x, devUpperleft.y,
       theRect.width, theRect.height) -> XFillRectangle;
   if);
#)

-- SolidColorFillEllipseBody: descriptor --
(# devUpperLeft: @Point;
do (if thecanvas[]//none then 'SolidColorFillEllipseBody: canvas is none'->putline if);
   theCanvas[]->setCanvasPaint;
   theEllipse.center -> theEllipse.privatepart.go2canvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice -> devupperleft;
   (devupperleft.x-theEllipse.horizontalRadius,
   devupperleft.y-theEllipse.verticalRadius) -> devupperleft;
   
   (if theEllipse.stroked then
       (xdisplay, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       devUpperleft.x, devUpperleft.y,
       2*theEllipse.horizontalradius,
       2*theEllipse.verticalradius,
       0,360*64) -> XDrawArc;
    else
       (xdisplay, 
       theCanvas.implpart.xdrawable, 
       theCanvas.implpart.xgc,
       devUpperleft.x, devUpperleft.y,
       2*theEllipse.horizontalradius,
       2*theEllipse.verticalradius,
       0,360*64) -> XFillArc;
   if);
#)


(*** TiledSolidColor ****)

-- TiledSolidFillShapeBody: dopart --
do INNER; 
   theShape[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillShape *) 


-- TiledSolidFillLineBody: dopart --
do INNER; 
   theLine[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillLine *) 


-- TiledSolidFillMultiLineBody: dopart --
do INNER; 
   theMultiLine[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillMultiline *) 


-- TiledSolidFillTextBody: dopart --
do INNER; 
   theText[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillText *) 


-- TiledSolidFillArcBody: dopart --
do INNER; 
   theArc[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillArc*) 


-- TiledSolidFillPieBody: dopart --
do INNER; 
   thePie[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillPie *) 


-- TiledSolidFillRectBody: dopart --
do INNER; 
   theRect[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillRect *) 


-- TiledSolidFillEllipseBody: dopart --
do INNER; 
   theEllipse[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillEllipse *) 


-- BifrostAttributes: attributes --

XCreatePixmapFromBitmap:
  (# pixel: @integer;
     bitmap: @integer;
     width, height: @integer;
     pixmap: @integer;
     theCanvas: ^BifrostCanvas;
  enter (theCanvas[], bitmap, width, height, pixel)
  do (* Set foreground pixel in 
      * theCanvas.implpart.xgc
      *)
     (xdisplay, 
     theCanvas.implpart.xgc,
     pixel) -> XSetForeGround;
     
     (* Create the Pixmap to exit *)
     (xdisplay,
     THIS(guienv).private.defaultdrawable,
     width,
     height,
     THIS(guienv).private.defaultdepth)
       -> XCreatePixmap -> pixmap;
     
     (* Copy bitmap to pixmap 
      * using theCanvas.implpart.xgc
      *)
     (xdisplay,
     theCanvas.implpart.xgc,
     0) -> XSetGraphicsExposures;
     
     (xdisplay,
     bitmap, 
     pixmap, 
     theCanvas.implpart.xgc,
     0,
     0,
     width,
     height,
     0,
     0,
     1) -> XCopyPlane;
  exit pixmap
  #);

-- TiledSolidSetBorderPaintBody: descriptor --
(# pixmap: @integer;
do (if not doneInInner then
       (* Check if color is allocated *)
       (if (not implpart.allocated) then
           (* Allocate color *)
           (xdisplay, 
           THIS(guienv).private.xcolormap,
           implpart.theXcolor[] ) 
             -> XAllocColor -> implpart.allocated;
           
           (if not implpart.allocated then
               (if displayWarnings then
                   'Couldn''t allocate color' -> putline;
               if);
           if);
       if);
       
       (if tiledprivate.theBitmap.BitMapPrivatePart.xpixmap
        // 0 then (* Maybe the Bitmap hasn't been evaluated *)
           tiledprivate.theBitmap.calculate
       if);
       
       (theCanvas[],
       tiledprivate.theBitmap.BitMapPrivatePart.xpixmap,
       tiledprivate.theBitmap.width,
       tiledprivate.theBitmap.height,
       implpart.theXcolor.pixel)
         -> XCreatePixmapFromBitmap (* See above *)
         -> pixmap;
       
       (* Now set the background_pixmap of 
        * theCanvas.implpart.xdrawable
        *)
       (if theCanvas.implpart.xdrawable//0 then
           (* setting of background paint is handled upon open *)
           pixmap->theCanvas.SetCanvasBorderPixmap;
        else
           (xdisplay,
           theCanvas.implpart.xdrawable,
           pixmap) -> XSetWindowBorderPixmap;
       if);
       (*(xdisplay, pixmap) -> XFreePixmap;*)
       
       true -> doneInInner;
   if)
#)

-- TiledSolidSetBackgroundPaintBody: descriptor -- 
(# pixmap: @integer;
do (if not doneInInner then
       (* Check if color is allocated *)
       (if (not implpart.allocated) then
           (* Allocate color *)
           (xdisplay, 
           THIS(guienv).private.xcolormap,
           implpart.theXcolor[] ) 
             -> XAllocColor -> implpart.allocated;
           
           (if not implpart.allocated then
               (if displayWarnings then
                   'Couldn''t allocate color' -> putline;
               if);
           if);
       if);
       
       (if tiledprivate.theBitmap.BitMapPrivatePart.xpixmap
        // 0 then (* Maybe the Bitmap hasn't been evaluated *)
           tiledprivate.theBitmap.calculate
       if);
       
       (theCanvas[],
       tiledprivate.theBitmap.BitMapPrivatePart.xpixmap,
       tiledprivate.theBitmap.width,
       tiledprivate.theBitmap.height,
       implpart.theXcolor.pixel)
         -> XCreatePixmapFromBitmap (* See above *)
         -> pixmap;
       
       (* Now set the background_pixmap of 
        * theCanvas.implpart.xdrawable
        *)
       (if theCanvas.implpart.xdrawable//0 then
           (* setting of background paint is handled upon open *)
           pixmap
             -> theCanvas.SetCanvasBackgroundPixmap;
        else
           (xdisplay,
           theCanvas.implpart.xdrawable,
           pixmap) -> XSetWindowBackgroundPixmap;
           
           (xdisplay, 
           theCanvas.implpart.xdrawable,
           0, 0, 0, 0, 1) -> XClearArea;
       if);
       (*(xdisplay, pixmap) -> XFreePixmap;*)
       
       true -> doneInInner;
   if)
#)

-- TiledSolidSetCanvasPaintBody: descriptor --
(# pos: @Point;
   rasthot: @point;
do (if debuggraphic then 'TiledSolidSetCanvasPaint'->putline; if);
   
   (if tiledprivate.theBitmap[]//NONE then
       (if displayWarnings then
           'TiledSolidColor: the tile is NONE; ignoring tiling.'
             ->putline;
       if);
    else
       (* Check the X Pixmap *)
       (if tiledprivate.theBitmap.BitMapPrivatePart.xpixmap
        // 0 then (* Maybe the Bitmap hasn't been evaluated *)
           (if displayWarnings then 
               'TiledSolidColor: The tile bitmap does not seem to have been evaluated!' -> putline;
               'Evaluating it once.' -> putline;
           if);
           tiledprivate.theBitmap;
       if);
       
       (xdisplay,
       theCanvas.implpart.xgc,
       FillStippled)
         -> XSetFillStyle;
       
       (xdisplay,
       theCanvas.implpart.xgc,
       tiledprivate.theBitmap.BitMapPrivatePart.xpixmap)
         -> XSetStipple;
       
       (if debuggraphic then
           'TiledSolidColor: Tiling prepared' -> putline;
       if);
       
       (* Place hotspot of private.theBitmap on hotspot of 
        * tiledprivate.theshape (if any: TextShape.interactivecreate uses
        * setcanvaspaint without specifying tiledprivate.theshape).
        *)
       (if tiledprivate.theshape[]<>NONE then
           tiledprivate.theshape.hotspot 
             -> tiledprivate.theshape.privatePart.go2CanvasTM.m.transformPoint
             -> theCanvas.CanvasToDevice
             -> pos;
           tiledprivate.theBitmap.hotspot -> rasthot;
           pos.y - (tiledprivate.theBitmap.height - rasthot.y) -> pos.y;
           pos.x - rasthot.x -> pos.x;
       if);
       
       (xdisplay,
       theCanvas.implpart.xgc,
       pos.x, pos.y) -> XSetTSOrigin;
       
       true -> doneInInner;
   if);
   
#)

(*** RasterPaint ****)


-- RasterPaintFillMultiLineBody: dopart --
do INNER
-- RasterPaintFillArcBody: dopart --
do INNER
-- RasterPaintFillPieBody: dopart --
do INNER


-- RasterPaintFillShapeBody: descriptor --
(# pos: @point;
   rasthot: @point;
do 
   (if theShape.isclosed then
       
       theCanvas[]->setCanvasPaint;
       (if theShape.Invalid then
           theCanvas[] -> theShape.recalculatePrivatePart;
       if);
       theShape[] -> theCanvas.setclip;
       
       (if private.thePixmap[]//NONE then
           (if displayWarnings then
               'RasterPaint: thePixmap is NONE; ignoring fill request'->putline;
           if);
        else 
           (* Place hotspot of private.thePixmap on hotspot of theshape *)
           theShape.hotspot -> theShape.privatePart.go2CanvasTM.m.transformPoint
             -> theCanvas.CanvasToDevice -> pos;
           private.thePixmap.hotspot -> rasthot;
           pos.y - (private.thePixmap.height - rasthot.y)
             -> pos.y;
           pos.x - rasthot.x 
             -> pos.x;
           
           (if paddingSolidColor[]//NONE then (* Tile with thePixMap *)
               (# b: @rectangle;
                  x, y, y1: @integer;
                  w, h: @integer;
                  (* Here we do it ourself. Alternatively one may write it in an
                   * X Pixmap and use this in an XSetTile with offset pos.
                   * This requires the FillTiled FillStyle.
                   *)
               do
                  theShape.getBounds 
                    -> theCanvas.TM.transformRectangle
                    -> b;
                  private.thePixmap.width -> w;
                  private.thePixmap.height -> h;
                  pos.x - w*((pos.x-b.x) div w + 1) -> x;
                  pos.y - h*((pos.y-b.y) div h + 1) -> y -> y1;
                  (for (b.width div w + 2) repeat
                       (for (b.height div h + 2) repeat
                            (xdisplay, 
                            theCanvas.implpart.xdrawable, 
                            theCanvas.implpart.xgc,
                            private.thePixmap.pixmapprivatepart.ximage,
                            0, 0, x, y, w, h) -> XPutImage;
                            y+h->y;
                       for);
                       y1 ->y;
                       x+w->x;
                  for);
               #);
	    else
               (theCanvas[],theShape[]) -> paddingSolidColor.fillShape;
               (xdisplay, 
               theCanvas.implpart.xdrawable, 
               theCanvas.implpart.xgc,
               private.thePixmap.pixmapprivatepart.ximage,
               0,0,
               pos.x, pos.y,
               private.thePixmap.width,
               private.thePixmap.height) -> XPutImage;
           if);
       if);
       theCanvas.visualShape[]
         -> theCanvas.SetClip;
   if);
   
#)

-- RasterPaintFillLineBody: dopart --
do INNER
-- RasterPaintFillRectBody: dopart --
do INNER
-- RasterPaintFillTextBody: dopart --
do INNER
-- RasterPaintFillEllipseBody: dopart --
do INNER

-- RasterPaintSetBorderPaintBody: descriptor --
(# pixmap: @integer;
do (* Create a pixmap and put private.thePixmap.pixmapprivatepart.ximage
    * into it
    *)
   
   (xdisplay,
   THIS(guienv).private.defaultdrawable,
   private.thePixmap.width,
   private.thePixmap.height,
   THIS(guienv).private.defaultdepth)
     -> XCreatePixmap -> pixmap;
   
   (xdisplay, 
   pixmap, 
   theCanvas.implpart.xgc,
   private.thePixmap.pixmapprivatepart.ximage,
   0,0,
   0,0,
   private.thePixmap.width,
   private.thePixmap.height) -> XPutImage;
   
   (* Now set the border_pixmap of 
    * theCanvas.implpart.xdrawable
    *)
   (if theCanvas.implpart.xdrawable//0 then
       (* setting of background paint is handled upon open *)
       pixmap->theCanvas.SetCanvasBorderPixmap;
    else
       (xdisplay,
       theCanvas.implpart.xdrawable,
       pixmap) -> XSetWindowBorderPixmap;
   if);
   (*(xdisplay, pixmap) -> XFreePixmap;*)
#)

-- RasterPaintSetBackgroundPaintBody: descriptor --
(# pixmap: @integer;
do (* Create a pixmap and put private.thePixmap.pixmapprivatepart.ximage
    * into it
    *)
   
   (xdisplay,
   THIS(guienv).private.defaultdrawable,
   private.thePixmap.width,
   private.thePixmap.height,
   THIS(guienv).private.defaultdepth)
     -> XCreatePixmap -> pixmap;
   
   (xdisplay, 
   pixmap, 
   theCanvas.implpart.xgc,
   private.thePixmap.pixmapprivatepart.ximage,
   0,0,
   0,0,
   private.thePixmap.width,
   private.thePixmap.height) -> XPutImage;
   
   (* Now set the background_pixmap of 
    * theCanvas.implpart.xdrawable
    *)
   (if theCanvas.implpart.xdrawable//0 then
       (* setting of background paint is handled upon open *)
       pixmap->theCanvas.SetCanvasBackgroundPixmap;
    else
       (xdisplay,
       theCanvas.implpart.xdrawable,
       pixmap) -> XSetWindowBackgroundPixmap;
       
       (xdisplay, 
       theCanvas.implpart.xdrawable,
       0, 0, 0, 0, 1) -> XClearArea;
   if);
   (* (xdisplay, pixmap) -> XFreePixmap; *)
#)

-- RasterPaintSetCanvasPaintBody: descriptor --
(# (* Nothing needed, GC isn't changed *) #)
