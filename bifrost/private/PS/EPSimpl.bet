ORIGIN '../Impl/BifrostImpl';
INCLUDE '~beta/basiclib/v1.5/file';
INCLUDE '~beta/sysutils/v1.5/time';
INCLUDE '../Impl/SegmentList';
BODY 'EPSmacros';

--StreamLib: attributes--
sep: (# do ' '->put #);
putpoint: 
  (# x,y: @integer;
     puti: @putint;
     s: @sep;
  enter (x,y) 
  do x->puti; s;
     y->puti; s
  #);
putrect:
  (# x,y,w,h: @integer;
     puti: @putint;
     s: @sep;
  enter ((x,y),w,h)
  do x -> puti; s;
     y -> puti; s;
     w -> puti; s;
     h -> puti; s;
  #);
putmatrix:
  (# a,b,c,d,tx,ty: @Real;
     putr: @putreal;
     s: @sep;
     putt: @puttext;
  enter (a,b,c,d,tx,ty)
  do '[ '->putt;
     a->putr; s;
     b->putr; s;
     c->putr; s;
     d->putr; s;
     tx->putr; s;
     ty->putr; s;
     '] '->putt;
  #);
debugps:
  (# comment: ^text;
  enter comment[]
  do '% '->puttext; comment[] -> putline;
  #);

--LineSegmentWritePS: descriptor--
(#
do 'LineSegment' -> out.debugps;
   (* begin->out.putpoint;
    * ' moveto'->out.putline;
    *)
   end->out.putpoint;
   ' lineto'->out.putline;
   INNER writePS;
#)
--SplineSegmentWritePS: descriptor--
(#
do 'SplineSegment' -> out.debugps;
   INNER writePS;
#)
--CircularSplineSegmentWritePS: descriptor--
(#
do 'CircularSplineSegment' -> out.debugps;
   (for i:controls.npoints repeat
        i->controls.getpoint->out.putpoint
   for);
   controls.npoints -> out.putint;
   ' CBSpl'->out.putline;
   INNER writePS;
#)
--NonCircularSplineSegmentWritePS: descriptor--
(#
do 'NonCircularSplineSegment' -> out.debugps;
   (for i:controls.npoints repeat
        i->controls.getpoint->out.putpoint
   for);
   controls.npoints -> out.putint;
   ' BSpl'->out.putline;
   INNER writePS;
#)

--ShapeWritePS: descriptor--
(# points: @PointArray;
   npoints: @integer;
   firstseg: ^Segment;
do 'Shape' -> out.debugps;
   privatepart.segmentlist.firstsegment -> firstseg[];
   (if firstseg##<=CircularSplineSegment##//false then
       firstpoint -> out.putpoint; 
       ' moveto' -> out.putline;
   if);
   privatepart.segmentlist.scan(# do out[] -> current.writePS #);
   INNER writePS;
#)

--PredefinedWritePS: descriptor--
(#
do 'PredefinedShape' -> out.debugps;
   INNER writePS;
#)

--LineShapeWritePS: descriptor--
(#
do 'LineShape' -> out.debugps;
   end -> out.putpoint;
   begin -> out.putpoint;
   (if cap
    // CapButt    then 0->out.putint; out.sep;
    // CapRounded then 1->out.putint; out.sep;
    // CapSquare  then 2->out.putint; out.sep;
   if);
   width -> out.putint;
   ' l' -> out.putline;
   INNER writePS;
#)

--MultilineShapeWritePS: descriptor--
(#
do 'MultiLineShape' -> out.debugps;
   (for i:points.p.npoints-1 repeat
        i -> points.p.GetPoint -> out.putpoint;
   for);
   points.p.nPoints-1 -> out.putint; out.sep;
   points.p.lastpoint -> out.putpoint;
   (if join
    // JoinMiter  then 0->out.putint; out.sep;
    // JoinRound  then 1->out.putint; out.sep;
    // Joinbevel  then 2->out.putint; out.sep;
   if);
   (if cap
    // CapButt    then 0->out.putint; out.sep;
    // CapRounded then 1->out.putint; out.sep;
    // CapSquare  then 2->out.putint; out.sep;
    if);
   width -> out.putint;
   ' m' -> out.putline;
   INNER writePS;
#)

--TextShapeWritePS: descriptor--
(# putt: @out.puttext;
   t: @text;
do 'TextShape' -> out.debugps;
   '(' -> out.put;
   theText -> t; t[] -> putt;
   ') '-> putt;
   (if underline then
       'true '->putt;
    else
       'false '->putt;
   if);
   position -> out.putpoint;
   size -> out.putint; out.newline;
   (if theFontName
    // Helvetica then '/Helvetica'->putt;
    // Times then '/Times'->putt;
    // Courier then '/Courier'->putt;
    else
       'TextShapeWritePS: Unsupported font number: '->screen.puttext;
       theFontName -> screen.putint; screen.newline;
   if);
   (if theStyle
    // Plain then
       (if theFontName//Times then
           '-Roman' -> putt;
       if)
    // Italic then 
       (if theFontName//Times then
           '-Italic'->putt;
        else
           '-Oblique'->putt;
       if);
    // Bold then '-Bold'->putt;
    else
       'TextShapeWritePS: Unsupported style number: '->screen.puttext;
       theStyle -> screen.putint; screen.newline;
   if);
   ' t' -> out.putline;
   INNER writePS;
#)

--PieShapeWritePS: descriptor--
(# r: @real;
do 'PieShape' -> out.debugps;
   center.p -> out.putpoint;
   angle1 -> out.putreal; out.sep;
   angle2 -> out.putreal; out.sep;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   'p'->out.putline;
   INNER writePS;
#)

--ArcShapeWritePS: descriptor--
(# r: @real;
do 'ArcShape' -> out.debugps;
   center.p -> out.putpoint;
   angle1 -> out.putreal; out.sep;
   angle2 -> out.putreal; out.sep;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   arcwidth -> out.putint; out.sep;
   'a'->out.putline;
   INNER writePS;
#)

--StrokeableShapeWritePS: descriptor--
(#
do 'StrokeableShape' -> out.debugps;
   (if stroked then
       strokewidth -> out.putint; ' setlinewidth' -> out.putline;
   if);
   INNER writePS;
   (if stroked then
       'stroke' -> out.putline;
    else
       'fill' -> out.putline;
   if);
#)

--RectShapeWritePS: descriptor--
(#
do 'RectShape' -> out.debugps;
   (upperleft, width, height) -> out.putrect;
   'r'->out.putline;
   INNER writePS;
#)

--EllipseShapeWritePS: descriptor--
(# r: @real
do 'EllipseShape' -> out.debugps;
   center.p -> out.putpoint;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   'e'->out.putline;
   INNER writePS;
#)

--SolidColorWritePS: descriptor--
(# writergb: @integerobject
     (# r: @real;
     do value -> r;
        r/MaxRGB  -> out.putreal; 
        out.sep;
     #)
do 'SolidColor' -> out.debugps;
   RGBvalues -> (writeRGB, writeRGB, writeRGB);
   'setrgbcolor' -> out.putline;
   INNER writePS;
#)

--RasterPaintWritePS: descriptor--
(#
do 'RasterPaint' -> out.debugps;
   'Not yet Implemented' -> out.debugps;
   INNER writePS;
#)

--TiledSolidColorWritePS: descriptor--
(#
do 'TiledSolidColor' -> out.debugps;
   'Not yet Implemented' -> out.debugps;
   INNER writePS;
#)

--GoWritePS: descriptor--
(#
do 'AbstractGraphicalObject' -> out.debugps;
   'gsave' -> out.putline;
   'newpath'->out.putline;
   (if TM.m[]<>NONE then 
       TM.m -> out.putmatrix; 'concat' -> out.putline;
   if);
   out[] -> thePaint.writePS;
   out[] -> theShape.writePS;
   INNER writePS;
   'grestore' -> out.putline;
#)
--UserDefGOWritePS: descriptor--
(# 
do (if theshape.fillRule
    // WindingRule then
       'fill' -> out.putline;
    // EvenOddRule then
       'eofill' -> out.putline;
   if);
   INNER writePS;
#)
--PictureShapeWritePS: descriptor--
(#
do 'PictureShape' -> out.debugps;
   INNER writePS;
#)

--PictureWritePS: descriptor--
(#
do 'Picture' -> out.debugps;
   scanGOs(# do out[] -> go.writePS #);
   INNER writePS;
#)

--CanvasWriteEPS: descriptor--
(# 
   WriteMacros: <<SLOT WriteEPSMacros: descriptor>>;
   size: @point; 
   f: @file;
   r: @rectangle; 
   scale: @real;
   translate: @point;
   page: @point;
   m: @point;
   margin: (# exit (20, 20) #);
do (if out[]//NONE then screen[]->out[] if);
   
   THIS(BifrostCanvas).size -> size;
   (pagesize.width-pagesize.x, pagesize.height-pagesize.y) -> page;
   margin -> m;
   (page.x-2*m.x, page.y-2*m.y) -> page;
   
   (* Write the header *)
   '%!PS-Adobe-3.0 EPSF-3.0' -> out.putline;
   '%%Creator: ' -> out.puttext;
   1 -> arguments -> f.name;
   f.entry.path.name -> out.puttext;
   out.newline;
   
   (* Calculate Scale to fit Canvas to page *)
   (if page.x-size.x < page.y-size.y then
       (* Scale to fit in x direction *)
       page.x -> scale;
       scale / size.x -> scale;
       0 -> translate.x;
       ((page.y-size.y) div 2) div scale-> translate.y;
    else
       (* scale to fit in y direction *)
       page.y -> scale;
       scale / size.y -> scale;
       0 -> translate.y;
       ((page.x-size.x) div 2) div scale -> translate.x;
   if);
   (margin, translate) -> addpoints -> translate;
   
   '%%BoundingBox: '->out.puttext; 
   thePicture.getbounds -> r;
   translate.x + scale * (r.x)          -> out.putint; out.sep;
   translate.y + scale * (r.y-r.height) -> out.putint; out.sep;
   translate.x + scale * (r.x+r.width)  -> out.putint; out.sep;
   translate.y + scale * (r.y)          -> out.putint; 
   out.newline;

   '%%Title: Bifrost EPS' -> out.puttext;
   out.newline;
   '%%CreationDate: ' -> out.puttext;
   systemtime -> formattime -> out.puttext;
   out.newline;
   
   (* '% canvas size:   '->out.puttext; size -> out.putpoint; out.newline;
    * '% margin:        '->out.puttext; margin -> out.putpoint; out.newline;
    * '% picture bound: '->out.puttext; 
    * (r.x, r.x)->out.putpoint; (r.width, r.height)->out.putpoint; out.newline;
    * '% page:          '->out.puttext; page -> out.putpoint; out.newline;
    *)
   
   WriteMacros;

   (* Handle vertical and noOfCopies *)
   (if vertical//false then
       'CanvasWriteEPS: horizontal print not yet handled' -> putline;
   if);
   (if noOfCopies>1 then
       '/#copies '->out.puttext; noOfCopies-> out.putint; ' def' -> out.putline;
   if);
   
   translate -> out.putpoint;
   'translate' -> out.putline;
   scale->out.putreal; out.sep; scale->out.putreal; 
   ' scale' -> out.putline;
    
   (if debugGraphic then
       '% Draw a thin frame around canvas' -> out.putline;
       'newpath' -> out.putline;
       '0.1 setlinewidth'-> out.putline;
       '0 setgray'-> out.putline;
       '0 0 moveto'-> out.putline;
       size.x -> out.putint; ' 0 rlineto'-> out.putline;
       '0 ' ->out.puttext; size.y -> out.putint; ' rlineto'-> out.putline;
       size.x-> out.putint; ' neg 0 rlineto'-> out.putline;
       'closepath'-> out.putline;
       'stroke'-> out.putline;
   if);
   
   (* Process the graphics *)
   'Begin' -> out.putline;
   out[] -> thePicture.writePS;
   
   (* Showpage & Epilogue *)
   'showpage' -> out.putline;
   'End' -> out.putline;
   
   '%%EOF' -> out.putline;
#)
