ORIGIN '../Impl/BifrostImpl';
INCLUDE '~beta/basiclib/file'
        '~beta/basiclib/numberio'
        '~beta/basiclib/regexp'
        '~beta/sysutils/time'
        '~beta/sysutils/objinterface'
        '../Impl/SegmentList'
        '../../EPSfile';
--- textlib: attributes ---
globalReplace: loop
  (* replaces all occurences of m with r in THIS(text) using
   * regexp_replace
   *)
  (#
     m,r: ^Text;
     while::
       (#
       do (m[],r[]) ->
          regexp_replace(# posToMatchEnd:: (# do true->value #) #)
            -> value;
       #)
  enter (m[],r[])
  #);

--StreamLib: attributes--
sep: (# do ' '->put #);
putpoint:
  (# x,y: @integer;
     puti: @putint;
     s: @sep;
  enter (x,y)
  do x->puti; s;
     y->puti; s
  #);
putrect:
  (# x,y,w,h: @integer;
     puti: @putint;
     s: @sep;
  enter ((x,y),w,h)
  do x -> puti; s;
     y -> puti; s;
     w -> puti; s;
     h -> puti; s;
  #);
putmatrix:
  (# a,b,c,d,tx,ty: @Real;
     putr: @putreal;
     s: @sep;
     putt: @puttext;
  enter (a,b,c,d,tx,ty)
  do '[ '->putt;
     a->putr; s;
     b->putr; s;
     c->putr; s;
     d->putr; s;
     tx->putr; s;
     ty->putr; s;
     '] '->putt;
  #);
debugps:
  (# comment: ^text;
  enter comment[]
  do '% '->puttext; comment[] -> putline;
  #);
--CanvasReadEPS: doPart--
do 'Not implemented yet' -> Screen.Putline;

--LineSegmentWritePS: descriptor--
(#
do 'LineSegment' -> out.debugps;
   (* begin->out.putpoint;
    * ' moveto'->out.putline;
    *)
   end->out.putpoint;
   ' lineto'->out.putline;
   INNER writePS;
#)
--SplineSegmentWritePS: descriptor--
(#
do 'SplineSegment' -> out.debugps;
   INNER writePS;
#)
--CircularSplineSegmentWritePS: descriptor--
(#
do 'CircularSplineSegment' -> out.debugps;
   (for i:controls.npoints repeat
        i->controls.getpoint->out.putpoint
   for);
   controls.npoints -> out.putint;
   ' CBSpl'->out.putline;
   INNER writePS;
#)
--NonCircularSplineSegmentWritePS: descriptor--
(#
do 'NonCircularSplineSegment' -> out.debugps;
   (for i:controls.npoints repeat
        i->controls.getpoint->out.putpoint
   for);
   controls.npoints -> out.putint;
   ' BSpl'->out.putline;
   INNER writePS;
#)

--ShapeWritePS: descriptor--
(# points: @PointArray;
   npoints: @integer;
   firstseg: ^Segment;
do 'Shape' -> out.debugps;
   privatepart.segmentlist.firstsegment -> firstseg[];
   (if firstseg##<=CircularSplineSegment##//false then
       firstpoint -> out.putpoint;
       ' moveto' -> out.putline;
   if);
   privatepart.segmentlist.scan(# do out[] -> current.writePS #);
   INNER writePS;
#)

--PredefinedWritePS: descriptor--
(#
do 'PredefinedShape' -> out.debugps;
   INNER writePS;
#)

--LineShapeWritePS: descriptor--
(#
do 'LineShape' -> out.debugps;
   (if invisible then '%' -> out.put if);
   end -> out.putpoint;
   begin -> out.putpoint;
   (if cap
    // CapButt    then 0->out.putint; out.sep;
    // CapRounded then 1->out.putint; out.sep;
    // CapSquare  then 2->out.putint; out.sep;
   if);
   width -> out.putint;
   ' l' -> out.putline;
   INNER writePS;
#)

--MultilineShapeWritePS: descriptor--
(#
do 'MultiLineShape' -> out.debugps;
   (for i:points.p.npoints-1 repeat
        i -> points.p.GetPoint -> out.putpoint;
   for);
   points.p.nPoints-1 -> out.putint; out.sep;
   points.p.lastpoint -> out.putpoint;
   (if join
    // JoinMiter  then 0->out.putint; out.sep;
    // JoinRound  then 1->out.putint; out.sep;
    // Joinbevel  then 2->out.putint; out.sep;
   if);
   (if cap
    // CapButt    then 0->out.putint; out.sep;
    // CapRounded then 1->out.putint; out.sep;
    // CapSquare  then 2->out.putint; out.sep;
   if);
   width -> out.putint;
   ' m' -> out.putline;
   (if not invisible then 'stroke'->out.putLine if);
   INNER writePS
#)

--TextShapeWritePS: descriptor--
(# putt: @out.puttext;
   t: @text;
   more: ^text;
do 'TextShape' -> out.debugps;
   '% Textvalue: ' -> more[];
   theText -> t;
   t[] -> more.putLine;
   '% TextAttributes: ' -> more.putText;
   position -> more.putpoint;
   ' ' -> more.put;
   size -> more.putint;
   ' ' -> more.put;
   theFontName -> more.putint;
   ' ' -> more.put;
   theStyle -> more.putint;
   '(' -> out.put;
   t.reset;
   (if t.length > 0 then
       ('\\\\','\\\\\\\\') -> t.globalReplace;
       t.reset;
       (')','\\\\)') -> t.globalReplace;
       t.reset;
       ('(','\\\\(') -> t.globalReplace;
   if);
   t[] -> putt;
   ') '-> putt;
   (if underline then
       'true '->putt;
       ' 1' -> more.putText;
    else
       'false '->putt;
       ' 0' -> more.putText;
   if);
   position -> out.putpoint;
   size -> out.putint; out.newline;
   (if theFontName
    // Helvetica then '/Helvetica'->putt;
    // Times then '/Times'->putt;
    // Courier then '/Courier'->putt;
    else
       'TextShapeWritePS: Unsupported font number: '->screen.puttext;
       theFontName -> screen.putint; screen.newline;
   if);
   (if theStyle
    // Plain then
       (if theFontName//Times then
           '-Roman' -> putt;
       if)
    // Italic then
       (if theFontName//Times then
           '-Italic'->putt;
        else
           '-Oblique'->putt;
       if);
    // Bold then '-Bold'->putt;
    else
       'TextShapeWritePS: Unsupported style number: '->screen.puttext;
       theStyle -> screen.putint; screen.newline;
   if);
   ' t' -> out.putline;
   more[]-> out.putline;
   INNER writePS;
#)

--PieShapeWritePS: descriptor--
(# r: @real;
do 'PieShape' -> out.debugps;
   center.p -> out.putpoint;
   angle1 -> out.putreal; out.sep;
   angle2 -> out.putreal; out.sep;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   'p'->out.putline;
   '% verticalradius: ' -> out.putText;
   verticalradius -> out.putInt;
   out.newLine;
   INNER writePS;
#)

--ArcShapeWritePS: descriptor--
(# r: @real;
do 'ArcShape' -> out.debugps;
   center.p -> out.putpoint;
   angle1 -> out.putreal; out.sep;
   angle2 -> out.putreal; out.sep;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   arcwidth -> out.putint; out.sep;
   'a'->out.putline;
   '% verticalradius: ' -> out.putText;
   verticalradius -> out.putInt;
   out.newLine;
   INNER writePS;
#)

--StrokeableShapeWritePS: descriptor--
(#
do 'StrokeableShape' -> out.debugps;
   (if stroked then
       strokewidth -> out.putint; ' setlinewidth' -> out.putline;
   if);
   INNER writePS;
   (if not invisible then
       (if stroked then
	   'stroke' -> out.putline;
	else
	   'fill' -> out.putline;
       if)
   if)
#)

--RectShapeWritePS: descriptor--
(#
do 'RectShape' -> out.debugps;
   (upperleft, width, height) -> out.putrect;
   'r'->out.putline;
   INNER writePS;
#)

--EllipseShapeWritePS: descriptor--
(# r: @real
do 'EllipseShape' -> out.debugps;
   center.p -> out.putpoint;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   'e'->out.putline;
   '% verticalradius: ' -> out.putText;
   verticalradius -> out.putInt;
   out.newLine;
   INNER writePS;
#)

--SolidColorWritePS: descriptor--
(# 
   putIntSep:
     (# i: @Integer;
     enter i
     do i -> t.putInt;
        ' ' -> t.put
     #);
   t: ^text;
   WriteRGB: @integerobject
     (# r: @real;
     do value -> r;
        r/MaxRGB  -> out.putreal;
        out.sep;
     #);
do &text[]->t[];
   'SolidColor ' -> t.putText;
   RGBvalues -> (putIntSep, putIntSep, putIntSep);
   t[] -> out.debugps;
   RGBvalues -> (writeRGB, writeRGB, writeRGB);
   'setrgbcolor' -> out.putline;
   INNER writePS;
#)

--RasterPaintWritePS: descriptor--
(#
do 'RasterPaint' -> out.debugps;
   'Not yet Implemented' -> out.debugps;
   INNER writePS;
#)

--TiledSolidColorWritePS: descriptor--
(# tile: ^BitMap;
   MakePaintProc:
     (# 
        p: ^BitMap.pixel;
        value: @int8u;
        numbit: @integer;
     do '{\n    pop\n    ' -> out.puttext;
        tile.width -> out.putint; out.sep;
        tile.height -> out.putint; out.sep;
        'true ' -> out.puttext;
        (* An image that is scanned left-to-right, top-to-bottom
         * is described by the following matrix, c.f. PostScript
         * Language Refererence Manual page 218, top:
         *    (tile.width, 0, 0, -tile.height, 0, tile.height) -> out.putmatrix;
         * However, this turn out wrong. It seems to work with
         * identity matrix.
         *)
        'matrix ' -> out.puttext;
        '{ <' -> out.puttext;
        (* Get the bits. FIXME: is wrong - it is like X with
         * each row starting on a byte boundary.
         *)
        (for j:tile.height repeat
             (for i:tile.width repeat
                  (i,j) -> tile.getPixel -> p[];
                  numbit+1 -> numbit;
                  value*2->value;
                  (if p.b then value+1 -> value if);
                  (if (numbit mod 4) = 0 then
                      value -> out.putHex(# do 1->width #);
                      0 -> value;
                  if);
             for);
        for);
        (if (numbit mod 4) <> 0 then
            value -> out.putHex(# do 1->width #);
        if);
        '> } imagemask' -> out.putline;
        '  }' -> out.putline;
     #);
   WriteRGB: @integerobject
     (# r: @real;
     do value -> r;
        r/MaxRGB  -> out.putreal;
        out.sep;
     #);
   SetPattern:
     (* Filling a shape with a pattern is amazingly complex
      * in PostScript. The following method is described in section 4.9
      * of PostScript Language Reference Manual, second edition, 
      * Adobe Systems Incorporated, 1990, ISBN 0-201-18127-4.
      * Some of this should probably be extracted into PostScript
      * macros (EPSmacros.bet).
      *)
     (# 
     do '[/Pattern /DeviceRGB] setcolorspace' ->out.putline;
        RGBvalues -> (writeRGB, writeRGB, writeRGB);
        '\n<<' -> out.putline;
        '  /PaintType 2' -> out.putline;
        '  /PatternType 1' -> out.putline;
        '  /TilingType 1' -> out.putline;
        (* FIXME: BBox is wrong - should take Tile.HotSpot into account *)
        '  /BBox [0 0 ' -> out.puttext;
        tile.width->out.putint; out.sep; tile.height->out.putint; 
        ']'->out.putline;
        '  /XStep ' -> out.puttext; tile.width->out.putint; out.newline;
        '  /YStep ' -> out.puttext; tile.height->out.putint; out.newline;
        '  /PaintProc ' -> out.puttext;
        MakePaintProc;
        '>>' -> out.putline;
        'matrix' -> out.putline;
        'makepattern' -> out.putline;
        'setcolor' -> out.putline;
     #);
do 'TiledSolidColor' -> out.debugps;
   theTile -> tile[];
   SetPattern;
   INNER writePS;
#)

--GoWritePS: descriptor--
(#
   pt: ^text
do 'AbstractGraphicalObject' -> out.debugps;
   'gsave' -> out.putline;
   'newpath'->out.putline;
   (if TM.m[]<>NONE then
       TM.m -> out.putmatrix; 'concat' -> out.putline;
   if);
   &text[] -> pt[];
   false -> invisible;
   pt[] -> thePaint.writePS;
   (if pt.length // 0 then true->invisible if);
   pt[] -> out.putText;
   'PatternName' -> out.debugps;
   this(abstractGraphicalObject)[] -> getPatternName -> out.debugps;
   (out[], invisible) -> theShape.writePS;
   INNER writePS;

   'grestore' -> out.putline;
   writeUserData -> out.putText;
   '% end GO' -> out.putline;
#)
--UserDefGOWritePS: descriptor--
(#
do
   (if not invisible then
       (if theshape.fillRule
	// WindingRule then
	   'fill' -> out.putline;
	// EvenOddRule then
	   'eofill' -> out.putline;
       if);
   if);
   INNER writePS;
#)
--PictureShapeWritePS: descriptor--
(#
do 'PictureShape' -> out.debugps;
   INNER writePS;
#)

--PictureWritePS: descriptor--
(#
do 'Picture' -> out.debugps;
   scanGOs(# do out[] -> go.writePS #);
   INNER writePS;
   'end picture' -> out.debugps;
#)

--CanvasWriteEPS: descriptor--
(#
   size: @point;
   f: @file;
   r: @rectangle;
   scale: @real;
   translate: @point;
   page: @point;
   m: @point;
   margin: (# exit (20, 20) #);
do (if out[]//NONE then screen[]->out[] if);

   THIS(BifrostCanvas).size -> size;
   (pagesize.width-pagesize.x, pagesize.height-pagesize.y) -> page;
   margin -> m;
   (page.x-2*m.x, page.y-2*m.y) -> page;

   (* Write the header *)
   '%!PS-Adobe-3.0 EPSF-3.0' -> out.putline;
   out.startEPSfile;

   (* Calculate Scale to fit Canvas to page *)
   (if page.x-size.x < page.y-size.y then
       (* Scale to fit in x direction *)
       page.x -> scale;
       scale / size.x -> scale;
       0 -> translate.x;
       ((page.y-size.y) div 2) div scale-> translate.y;
    else
       (* scale to fit in y direction *)
       page.y -> scale;
       scale / size.y -> scale;
       0 -> translate.y;
       ((page.x-size.x) div 2) div scale -> translate.x;
   if);
   (margin, translate) -> addpoints -> translate;

   '%%BoundingBox: '->out.puttext;
   thePicture.getbounds -> r;
   translate.x + scale * (r.x)          -> out.putint; out.sep;
   translate.y + scale * (r.y-r.height) -> out.putint; out.sep;
   translate.x + scale * (r.x+r.width)  -> out.putint; out.sep;
   translate.y + scale * (r.y)          -> out.putint;
   out.newline;

   (* '% canvas size:   '->out.puttext; size -> out.putpoint; out.newline;
    * '% margin:        '->out.puttext; margin -> out.putpoint; out.newline;
    * '% picture bound: '->out.puttext;
    * (r.x, r.x)->out.putpoint; (r.width, r.height)->out.putpoint; out.newline;
    * '% page:          '->out.puttext; page -> out.putpoint; out.newline;
    *)

   out.WriteMacros;

   (* Handle vertical and noOfCopies *)
   (if vertical//false then
       'CanvasWriteEPS: horizontal print not yet handled' -> putline;
   if);
   (if noOfCopies>1 then
       '/#copies '->out.puttext; noOfCopies-> out.putint; ' def' -> out.putline;
   if);

   translate -> out.putpoint;
   'translate' -> out.putline;
   scale->out.putreal; out.sep; scale->out.putreal;
   ' scale' -> out.putline;

   (if debugGraphic then
       '% Draw a thin frame around canvas' -> out.putline;
       'newpath' -> out.putline;
       '0.1 setlinewidth'-> out.putline;
       '0 setgray'-> out.putline;
       '0 0 moveto'-> out.putline;
       size.x -> out.putint; ' 0 rlineto'-> out.putline;
       '0 ' ->out.puttext; size.y -> out.putint; ' rlineto'-> out.putline;
       size.x-> out.putint; ' neg 0 rlineto'-> out.putline;
       'closepath'-> out.putline;
       'stroke'-> out.putline;
   if);

   (* Process the graphics *)
   'Begin' -> out.putline;
   out[] -> thePicture.writePS;

   (* Showpage & Epilogue *)
   'showpage' -> out.putline;
   'End' -> out.putline;
   out.endEPSfile;
#)
