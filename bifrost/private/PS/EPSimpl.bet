ORIGIN '../Impl/BifrostImpl';
INCLUDE '~beta/basiclib/v1.6/file';
INCLUDE '~beta/basiclib/v1.6/regexp';
INCLUDE '~beta/sysutils/v1.6/time';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '../Impl/SegmentList';
INCLUDE '../../EPSfile';
BODY 'EPSmacros';

--- textlib: attributes ---
globalReplace: loop
  (* replaces all occurences of m with r in THIS(text) using 
   * regexp_replace
   *)
  (# 
     m,r: ^Text;
     while::
       (# 
       do (m[],r[]) -> 
          regexp_replace(# posToMatchEnd:: (# do true->value #) #) 
            -> value;
       #)
  enter (m[],r[])
  #);

--StreamLib: attributes--
sep: (# do ' '->put #);
putpoint:
  (# x,y: @integer;
     puti: @putint;
     s: @sep;
  enter (x,y)
  do x->puti; s;
     y->puti; s
  #);
putrect:
  (# x,y,w,h: @integer;
     puti: @putint;
     s: @sep;
  enter ((x,y),w,h)
  do x -> puti; s;
     y -> puti; s;
     w -> puti; s;
     h -> puti; s;
  #);
putmatrix:
  (# a,b,c,d,tx,ty: @Real;
     putr: @putreal;
     s: @sep;
     putt: @puttext;
  enter (a,b,c,d,tx,ty)
  do '[ '->putt;
     a->putr; s;
     b->putr; s;
     c->putr; s;
     d->putr; s;
     tx->putr; s;
     ty->putr; s;
     '] '->putt;
  #);
debugps:
  (# comment: ^text;
  enter comment[]
  do '% '->puttext; comment[] -> putline;
  #);

--CanvasReadEPS: doPart--
do 'Not implemented yet' -> Screen.Putline;
   
--LineSegmentWritePS: descriptor--
(#
do 'LineSegment' -> out.debugps;
   (* begin->out.putpoint;
    * ' moveto'->out.putline;
    *)
   end->out.putpoint;
   ' lineto'->out.putline;
   INNER writePS;
#)
--SplineSegmentWritePS: descriptor--
(#
do 'SplineSegment' -> out.debugps;
   INNER writePS;
#)
--CircularSplineSegmentWritePS: descriptor--
(#
do 'CircularSplineSegment' -> out.debugps;
   (for i:controls.npoints repeat
        i->controls.getpoint->out.putpoint
   for);
   controls.npoints -> out.putint;
   ' CBSpl'->out.putline;
   INNER writePS;
#)
--NonCircularSplineSegmentWritePS: descriptor--
(#
do 'NonCircularSplineSegment' -> out.debugps;
   (for i:controls.npoints repeat
        i->controls.getpoint->out.putpoint
   for);
   controls.npoints -> out.putint;
   ' BSpl'->out.putline;
   INNER writePS;
#)

--ShapeWritePS: descriptor--
(# points: @PointArray;
   npoints: @integer;
   firstseg: ^Segment;
do 'Shape' -> out.debugps;
   privatepart.segmentlist.firstsegment -> firstseg[];
   (if firstseg##<=CircularSplineSegment##//false then
       firstpoint -> out.putpoint;
       ' moveto' -> out.putline;
   if);
   privatepart.segmentlist.scan(# do out[] -> current.writePS #);
   INNER writePS;
#)

--PredefinedWritePS: descriptor--
(#
do 'PredefinedShape' -> out.debugps;
   INNER writePS;
#)

--LineShapeWritePS: descriptor--
(#
do 'LineShape' -> out.debugps;
   end -> out.putpoint;
   begin -> out.putpoint;
   (if cap
    // CapButt    then 0->out.putint; out.sep;
    // CapRounded then 1->out.putint; out.sep;
    // CapSquare  then 2->out.putint; out.sep;
   if);
   width -> out.putint;
   ' l' -> out.putline;
   INNER writePS;
#)

--MultilineShapeWritePS: descriptor--
(#
do 'MultiLineShape' -> out.debugps;
   (for i:points.p.npoints-1 repeat
        i -> points.p.GetPoint -> out.putpoint;
   for);
   points.p.nPoints-1 -> out.putint; out.sep;
   points.p.lastpoint -> out.putpoint;
   (if join
    // JoinMiter  then 0->out.putint; out.sep;
    // JoinRound  then 1->out.putint; out.sep;
    // Joinbevel  then 2->out.putint; out.sep;
   if);
   (if cap
    // CapButt    then 0->out.putint; out.sep;
    // CapRounded then 1->out.putint; out.sep;
    // CapSquare  then 2->out.putint; out.sep;
   if);
   width -> out.putint;
   ' m' -> out.putline;
   INNER writePS;
#)

--TextShapeWritePS: descriptor--
(# putt: @out.puttext;
   t: @text;
   more: ^text;
do 'TextShape' -> out.debugps;
   '% Textvalue: ' -> more[];
   theText -> t; 
   t[] -> more.putLine;
   '% TextAttributes: ' -> more.putText;
   position -> more.putpoint;
   ' ' -> more.put;
   size -> more.putint;
   ' ' -> more.put;
   theFontName -> more.putint;
   ' ' -> more.put;
   theStyle -> more.putint;
   '(' -> out.put;
   t.reset;
   (if t.length > 0 then
       ('\\\\','\\\\\\\\') -> t.globalReplace;
       t.reset;
       (')','\\\\)') -> t.globalReplace;
       t.reset;
       ('(','\\\\(') -> t.globalReplace;
   if);
   t[] -> putt;
   ') '-> putt;
   (if underline then
       'true '->putt;
       ' 1' -> more.putText;
    else
       'false '->putt;
       ' 0' -> more.putText;
   if);
   position -> out.putpoint;
   size -> out.putint; out.newline;
   (if theFontName
    // Helvetica then '/Helvetica'->putt;
    // Times then '/Times'->putt;
    // Courier then '/Courier'->putt;
    else
       'TextShapeWritePS: Unsupported font number: '->screen.puttext;
       theFontName -> screen.putint; screen.newline;
   if);
   (if theStyle
    // Plain then
       (if theFontName//Times then
           '-Roman' -> putt;
       if)
    // Italic then
       (if theFontName//Times then
           '-Italic'->putt;
        else
           '-Oblique'->putt;
       if);
    // Bold then '-Bold'->putt;
    else
       'TextShapeWritePS: Unsupported style number: '->screen.puttext;
       theStyle -> screen.putint; screen.newline;
   if);
   ' t' -> out.putline;
   more[]-> out.putline;
   INNER writePS;
#)

--PieShapeWritePS: descriptor--
(# r: @real;
do 'PieShape' -> out.debugps;
   center.p -> out.putpoint;
   angle1 -> out.putreal; out.sep;
   angle2 -> out.putreal; out.sep;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   'p'->out.putline;
   '% verticalradius: ' -> out.putText;
   verticalradius -> out.putInt;
   out.newLine;
   INNER writePS;
#)

--ArcShapeWritePS: descriptor--
(# r: @real;
do 'ArcShape' -> out.debugps;
   center.p -> out.putpoint;
   angle1 -> out.putreal; out.sep;
   angle2 -> out.putreal; out.sep;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   arcwidth -> out.putint; out.sep;
   'a'->out.putline;
   '% verticalradius: ' -> out.putText;
   verticalradius -> out.putInt;
   out.newLine;
   INNER writePS;
#)

--StrokeableShapeWritePS: descriptor--
(#
do 'StrokeableShape' -> out.debugps;
   (if stroked then
       strokewidth -> out.putint; ' setlinewidth' -> out.putline;
   if);
   INNER writePS;
   (if stroked then
       'stroke' -> out.putline;
    else
       'fill' -> out.putline;
   if);
#)

--RectShapeWritePS: descriptor--
(#
do 'RectShape' -> out.debugps;
   (upperleft, width, height) -> out.putrect;
   'r'->out.putline;
   INNER writePS;
#)

--EllipseShapeWritePS: descriptor--
(# r: @real
do 'EllipseShape' -> out.debugps;
   center.p -> out.putpoint;
   horizontalradius -> out.putint; out.sep;
   verticalradius -> r;
   r / horizontalradius -> out.putreal; out.sep;
   'e'->out.putline;
   '% verticalradius: ' -> out.putText;
   verticalradius -> out.putInt;
   out.newLine;
   INNER writePS;
#)

--SolidColorWritePS: descriptor--
(# writergb: @integerobject
     (# r: @real;
     do value -> r;
        r/MaxRGB  -> out.putreal;
        out.sep;
     #);
   putIntSep:
     (# i: @Integer;
     enter i
     do i -> t.putInt;
        ' ' -> t.put
     #);
   t: ^text
do &text[]->t[];
   'SolidColor ' -> t.putText;
   RGBvalues -> (putIntSep, putIntSep, putIntSep);
   t[] -> out.debugps;
   RGBvalues -> (writeRGB, writeRGB, writeRGB);
   'setrgbcolor' -> out.putline;
   INNER writePS;
#)

--RasterPaintWritePS: descriptor--
(#
do 'RasterPaint' -> out.debugps;
   'Not yet Implemented' -> out.debugps;
   INNER writePS;
#)

--TiledSolidColorWritePS: descriptor--
(#
do 'TiledSolidColor' -> out.debugps;
   'Not yet Implemented' -> out.debugps;
   INNER writePS;
#)

--GoWritePS: descriptor--
(#
do 'AbstractGraphicalObject' -> out.debugps;
   'gsave' -> out.putline;
   'newpath'->out.putline;
   (if TM.m[]<>NONE then
       TM.m -> out.putmatrix; 'concat' -> out.putline;
   if);
   out[] -> thePaint.writePS;
   'PatternName' -> out.debugps;
   this(abstractGraphicalObject)[] -> getPatternName -> out.debugps;
   out[] -> theShape.writePS;
   INNER writePS;
   'grestore' -> out.putline;
   writeUserData -> out.putText;
   '% end GO' -> out.putline;
#)
--UserDefGOWritePS: descriptor--
(#
do (if theshape.fillRule
    // WindingRule then
       'fill' -> out.putline;
    // EvenOddRule then
       'eofill' -> out.putline;
   if);
   INNER writePS;
#)
--PictureShapeWritePS: descriptor--
(#
do 'PictureShape' -> out.debugps;
   INNER writePS;
#)

--PictureWritePS: descriptor--
(#
do 'Picture' -> out.debugps;
   scanGOs(# do out[] -> go.writePS #);
   INNER writePS;
   'end picture' -> out.debugps;
#)

--CanvasWriteEPS: descriptor--
(#
   WriteMacros: <<SLOT WriteEPSMacros: descriptor>>;
   size: @point;
   f: @file;
   r: @rectangle;
   scale: @real;
   translate: @point;
   page: @point;
   m: @point;
   margin: (# exit (20, 20) #);
do (if out[]//NONE then screen[]->out[] if);

   THIS(BifrostCanvas).size -> size;
   (pagesize.width-pagesize.x, pagesize.height-pagesize.y) -> page;
   margin -> m;
   (page.x-2*m.x, page.y-2*m.y) -> page;

   (* Write the header *)
   '%!PS-Adobe-3.0 EPSF-3.0' -> out.putline;
   out.startEPSfile;
   
   (* Calculate Scale to fit Canvas to page *)
   (if page.x-size.x < page.y-size.y then
       (* Scale to fit in x direction *)
       page.x -> scale;
       scale / size.x -> scale;
       0 -> translate.x;
       ((page.y-size.y) div 2) div scale-> translate.y;
    else
       (* scale to fit in y direction *)
       page.y -> scale;
       scale / size.y -> scale;
       0 -> translate.y;
       ((page.x-size.x) div 2) div scale -> translate.x;
   if);
   (margin, translate) -> addpoints -> translate;

   '%%BoundingBox: '->out.puttext;
   thePicture.getbounds -> r;
   translate.x + scale * (r.x)          -> out.putint; out.sep;
   translate.y + scale * (r.y-r.height) -> out.putint; out.sep;
   translate.x + scale * (r.x+r.width)  -> out.putint; out.sep;
   translate.y + scale * (r.y)          -> out.putint;
   out.newline;
   
   (* '% canvas size:   '->out.puttext; size -> out.putpoint; out.newline;
    * '% margin:        '->out.puttext; margin -> out.putpoint; out.newline;
    * '% picture bound: '->out.puttext;
    * (r.x, r.x)->out.putpoint; (r.width, r.height)->out.putpoint; out.newline;
    * '% page:          '->out.puttext; page -> out.putpoint; out.newline;
    *)

   WriteMacros;

   (* Handle vertical and noOfCopies *)
   (if vertical//false then
       'CanvasWriteEPS: horizontal print not yet handled' -> putline;
   if);
   (if noOfCopies>1 then
       '/#copies '->out.puttext; noOfCopies-> out.putint; ' def' -> out.putline;
   if);

   translate -> out.putpoint;
   'translate' -> out.putline;
   scale->out.putreal; out.sep; scale->out.putreal;
   ' scale' -> out.putline;

   (if debugGraphic then
       '% Draw a thin frame around canvas' -> out.putline;
       'newpath' -> out.putline;
       '0.1 setlinewidth'-> out.putline;
       '0 setgray'-> out.putline;
       '0 0 moveto'-> out.putline;
       size.x -> out.putint; ' 0 rlineto'-> out.putline;
       '0 ' ->out.puttext; size.y -> out.putint; ' rlineto'-> out.putline;
       size.x-> out.putint; ' neg 0 rlineto'-> out.putline;
       'closepath'-> out.putline;
       'stroke'-> out.putline;
   if);

   (* Process the graphics *)
   'Begin' -> out.putline;
   out[] -> thePicture.writePS;

   (* Showpage & Epilogue *)
   'showpage' -> out.putline;
   'End' -> out.putline;
   out.endEPSfile;
#)
