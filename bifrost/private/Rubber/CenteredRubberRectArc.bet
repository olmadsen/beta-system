ORIGIN 'CenteredRubberRect';

-- CanvasAttributes: attributes --

CenteredRubberRectWithArc: CenteredRubberRect
  (# p1, p2: @point;
     iarc:  @immediatearc;
     mymax: @max;
     angle1, angle2: @real;
     a1, a2: @integer;
     cos1, sin1, cos2, sin2: @real;
     w, h: @real;
     hw, hh: @integer;
     findnewpos: @boolean;
     tr: @Rectangle;
     initialize::<
       (#
       do (angle1 * pi) div 180 -> cos -> cos1;
          (angle1 * pi) div 180 -> sin -> sin1;
          (angle2 * pi) div 180 -> cos -> cos2;
          (angle2 * pi) div 180 -> sin -> sin2;
          angle1 -> a1;
          angle2 -> a2;
          
          (halfwidth -1, 0) -> mymax -> hw -> w;
          (halfheight-1, 0) -> mymax -> hh -> h;
          (w * cos1, h * sin1) -> p1;
          (w * cos2, h * sin2) -> p2;
          (p1, center) -> addpoints -> canvastodevice -> p1;
          (p2, center) -> addpoints -> canvastodevice -> p2;
          
          (center.x, center.y, hw, hh) 
            -> canvasToDeviceRectangle
            -> (tr.x, tr.y, tr.width, tr.height);
          
          (devicecenter.x, devicecenter.y, tr.width, tr.height, a1, a2) -> iarc;
          false -> findnewpos;
          INNER;
       #);
     motion::<
       (#
       do
          (if not findnewpos then
              (* First INNER *)
              true -> findnewpos; 
           else
              (* Second INNER *)
              (* Find new arcpoints *)
              (halfwidth -1, 0) -> mymax -> hw -> w;
              (halfheight-1, 0) -> mymax -> hh -> h;
              (w * cos1, h * sin1) -> p1;
              (w * cos2, h * sin2) -> p2;
              (p1, center) -> addpoints -> canvastodevice -> p1;
              (p2, center) -> addpoints -> canvastodevice -> p2;
              false -> findnewpos;
          if);
          
          (center.x, center.y, hw, hh) 
            -> canvasToDeviceRectangle
            -> (tr.x, tr.y, tr.width, tr.height);
          
          (* Erase / draw feedback *)
          (devicecenter.x, devicecenter.y, tr.width, tr.height, a1, a2) -> iarc;
          INNER;
       #);
     terminated::<
       (#
       do
          (center.x, center.y, hw, hh) 
            -> canvasToDeviceRectangle
            -> (tr.x, tr.y, tr.width, tr.height);
          
          (* Erase feedback *)
          (devicecenter.x, devicecenter.y, tr.width, tr.height, a1, a2) -> iarc;
          INNER;
       #);
  enter (angle1, angle2)
  #)

