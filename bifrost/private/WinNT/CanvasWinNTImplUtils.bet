ORIGIN 'CanvasWinNTimpl';

-- getNextMessageImpl: descriptor --
(# continue: @integer;
   theMessage: @integer;
   
   processMouseDown:
     (# btn: @integer;
     enter btn
     do win32ButtonPress -> implpart.message;
        false -> implpart.doubleClickPossible;
        btn -> implpart.theBtn;
     #);
   processMouseUp:
     (# btn: @integer;
     enter btn
     do win32ButtonRelease -> implpart.message;
        btn -> implpart.theBtn
     #);
   
   processMouseMotion:
     (# btn: @integer;
     do (* ((info.wParam,MK_SHIFT) -> tos'%and') = MK_CONTROL 
         * -> value; *)
        win32Motion -> implpart.message;
        lParam.loWord -> implpart.where.x;
        lParam.hiWord -> implpart.where.y;
        (* btn -> theBtn; *)
     #);
   
   processDoubleClick:
     (# btn: @integer;
     enter btn
     do true -> implpart.doubleClickPossible;
        btn -> implpart.theBtn
     #);
   
   processKeyDown:
     (# 
        handled: @boolean;
     do 
        wParam -> implpart.theKey;
        false -> handled;
        
        (if wParam
         //VK_LEFT   then ASCII.fs -> implpart.theKey; true -> handled;
         //VK_UP     then ASCII.rs -> implpart.theKey; true -> handled;
         //VK_RIGHT  then ASCII.gs -> implpart.theKey; true -> handled;
         //VK_DOWN   then ASCII.us -> implpart.theKey; true -> handled;
         //VK_DELETE then ASCII.del -> implpart.theKey; true -> handled; 
            
         //VK_HOME   then  true -> handled;
         //VK_PRIOR  then  true -> handled;
         //VK_NEXT   then  true -> handled;
         //VK_END    then  true -> handled;
         //VK_BACK   then  true -> handled;
        if);
        
        (if handled then
            win32KeyPress -> implpart.message;
         else
            0 -> implpart.theKey;
            0 -> implpart.message;
        if);
     #); 
   
   processWmChar:
     (# 
     do (if wParam<>VK_BACK then
            wParam -> implpart.theKey;
            win32KeyPress -> implpart.message;
         else
            0 -> implpart.theKey;
            0 -> implpart.message;
        if);
     #);
   
   processKeyUp:
     (#
     do win32KeyRelease -> implpart.message;
     #);
   
   param: integerObject
     (# hiWord,loWord: @integer; #);
   wParam,lParam: @param;
   x,y: @integer;
   longInt: @CStruct
     (#	ByteSize:: (# do 4 -> Value; #);
        loWord: signedShort (# Pos:: (# do 0 -> Value; #); #);
        hiWord: signedShort (# Pos:: (# do 2 -> Value; #); #);
     enter R[1]
     exit R[1]
     #);
   theCursorPosPtr: @integer;
do 0 -> implpart.message;
   (msg,windowId,0,0) -> GetMessage -> continue;
   (if continue
    //0 then
    //-1 then
    else
       msg -> TranslateMessage;
   if);
   
   msg + 4 -> TOS'%adrGetLong' -> theMessage;
   msg + 8 -> TOS'%adrGetLong' -> wParam;
   wParam -> longInt;
   longInt.hiWord -> wParam.hiWord;
   longInt.loWord -> wParam.loWord;
   
   msg + 12 -> TOS'%adrGetLong' -> lParam;
   lParam -> longInt;
   longInt.hiWord -> lParam.hiWord;
   longInt.loWord -> lParam.loWord;
   
   msg + 20 -> TOS'%adrGetLong' -> x;
   msg + 24 -> TOS'%adrGetLong' -> y;
   
   (x,y) -> makeNtPointPtr -> theCursorPosPtr;
   (implpart.windowID,theCursorPosPtr) -> ScreenToClient;
   theCursorPosPtr -> getPointFromNtPointPtr -> implpart.where;
   theCursorPosPtr -> free;
   
   (if theMessage
    //WM_LBUTTONDOWN then 1 -> processMouseDown;
    //WM_MBUTTONDOWN then 2 -> processMouseDown;
    //WM_RBUTTONDOWN then 3 -> processMouseDown;
            
    //WM_LBUTTONUP then 1 -> processMouseUp;
    //WM_MBUTTONUP then 2 -> processMouseUp;
    //WM_RBUTTONUP then 3 -> processMouseUp;
       
    //WM_MOUSEMOVE then processMouseMotion;
       
    //WM_LBUTTONDBLCLK then 1 -> processDoubleClick;
    //WM_MBUTTONDBLCLK then 2 -> processDoubleClick;
    //WM_RBUTTONDBLCLK then 3 -> processDoubleClick;
    //WM_KEYDOWN then processKeyDown;
    //WM_CHAR then	processWmChar;
    //WM_KEYUP then processKeyUp;
   if);
#)
