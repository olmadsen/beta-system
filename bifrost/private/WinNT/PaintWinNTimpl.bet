ORIGIN '../Impl/PaintImpl';
INCLUDE 'BifrostWinNTimpl';
INCLUDE 'utils';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/private/winnt/paletteFunctions';
INCLUDE '~beta/win32lib/wingdi';

-- PaintAttributes: attributes --
paintHandlePalette:
  (# hPal: @integer;
     hdc: @integer;
  enter hdc
  do (if this(guienv).private.curhPal<>0 then
         this(guienv).private.curhPal -> hPal;
      else
         this(guienv).private.ghPal -> hPal;
     if);
     (if (hPal<>0) then
         (hdc, hPal, 1) -> SelectPalette;
         hdc -> RealizePalette;
     if);
  #);

-- PaintFillShapeBody: dopart --
do (# polyFillMode: @integer; 
   do (if not theShape.isClosed then
          'Trying to fill non-closed Shape; ignoring request' -> putwarnline;
       else
          theCanvas.implpart.hdc -> paintHandlePalette;

          (if polyFillMode=EvenOddRule then
              ALTERNATE -> polyFillMode;
           else
              WINDING -> polyFillMode;
          if);
          (theCanvas.implpart.hdc, polyFillMode) -> SetPolyFillMode;
          INNER fillShape;
      if);
   #);
   
-- PaintFillLineBody: dopart --
do theCanvas.implpart.hdc -> paintHandlePalette;
   INNER;

-- PaintFillMultiLineBody: dopart --
do theCanvas.implpart.hdc -> paintHandlePalette;
   INNER;

-- PaintFillTextBody: dopart --
do (# prevBkMode: @integer;
   do theCanvas.implpart.hdc -> paintHandlePalette;
      
      (theCanvas.implpart.hdc,TRANSPARENT) -> SetBkMode -> prevBkMode;       
      (theCanvas[],theText.theFontName, theText.theStyle, theText.Size) 
        -> SetWin32Font;
      INNER fillText;
      (theCanvas.implpart.hdc,prevBkMode) -> SetBkMode;
   #);


-- PaintFillPieBody: dopart --
do theCanvas.implpart.hdc -> paintHandlePalette;
   INNER;   
   
-- PaintFillArcBody: dopart --
do theCanvas.implpart.hdc -> paintHandlePalette;
   INNER;

-- PaintFillRectBody: dopart --
do theCanvas.implpart.hdc -> paintHandlePalette;
   INNER;

-- PaintFillEllipseBody: dopart --
do theCanvas.implpart.hdc -> paintHandlePalette;
   INNER;

-- SolidColorImplPart: descriptor --
(# 
   theWin32Color: @win32Color;
   allocated: @integer;
#)

-- SolidColorInitBody: dopart --
do 0 -> implpart.allocated; 
   INNER;

-- SolidColorChangedBody: descriptor --
(# 
do 0 -> implpart.allocated;
   
   privatepart.red -> implpart.theWin32Color.red;
   privatepart.green -> implpart.theWin32Color.green;
   privatepart.blue -> implpart.theWin32Color.blue;
   
   0 -> implpart.theWin32Color.reserved;
#)

-- MaxRGBBody: dopart --
do 65535 -> max;

-- SolidColorCopyImplPart: descriptor --
(# 
do implpart.theWin32Color.red
     -> sc.implpart.theWin32Color.red;
   implpart.theWin32Color.green
     -> sc.implpart.theWin32Color.green;
   implpart.theWin32Color.blue
     -> sc.implpart.theWin32Color.blue;
   implpart.allocated
     -> sc.implpart.allocated;
#)

-- SolidColorSetCanvasPaintBody: dopart --
do (if debugGraphic then
       'SolidColorSetCanvasPaintBody begin.' -> putwarnline; 
   if);
   INNER;
   
   (if  (implpart.allocated=0) then
       (this(guienv).private.ghPal, implpart.theWin32Color) -> createColor -> implpart.allocated;
   if);
   
   (theCanvas.implpart.hdc,implpart.theWin32Color[] -> makeBifrostColorRef)
     ->SetTextColor; 
   
   (if debugGraphic then
       'SolidColorSetCanvasPaintBody done.' -> putwarnline; 
   if);
   
-- SolidColorSetBorderPaintBody: dopart --
do (if (implpart.allocated=0) then
       (this(guienv).private.ghPal, implpart.theWin32Color) -> createColor -> implpart.allocated;
   if);
   implpart.theWin32Color[] -> makeBifrostColorRef -> theCanvas.implpart.theBorderColor;

-- SolidColorSetBackgroundPaintBody: dopart --
do (if (implpart.allocated=0) then
       (this(guienv).private.ghPal, implpart.theWin32Color) -> createColor -> implpart.allocated;
   if);
   implpart.theWin32Color[]-> makeBifrostColorRef -> theCanvas.SetCanvasBackgroundColor; 
   (if theCanvas.implpart.hdc<>0 then
       (* setting of background paint is handled upon open *)
       (theCanvas.implpart.hdc,theCanvas.implpart.backGroundColor) -> SetBkColor;
   if);

-- SolidColorFillShapeBody: dopart --
do (# theBrush, theOldBrush: @integer; thePen, theOldPen: @integer; theColor: @integer;
   do (if debugGraphic then 
          'SolidColorFillShapeBody begin' -> putwarnline;
      if);
      (if theShape.isclosed then
          
          theCanvas[]->setCanvasPaint;
          
          (if theShape.Invalid then
              theCanvas[] -> theShape.recalculatePrivatePart;
          if);
          
          (* debug *)
          (if debugGraphic then
              (if theShape.privatepart.implpart.win32Points.p.range <> theShape.privatepart.implpart.NoOfPoints then
                  'WARNING: SolidColorFillShapeBody, ' -> putwarnText;
                  'theShape.privatepart.implpart.win32Points.p.range <> ' -> putwarnline;
                  'theShape.privatepart.implpart.NoOfPoints.' -> putwarnline;
              if);
          if);
          (* debug end *)
          
          (if false then
              'SolidColorFillShapeBody begin' -> putwarnline;
              (for i:theShape.privatepart.implpart.NoOfPoints repeat
                   theShape.privatepart.implpart.win32Points.p[(i*2)-1]-> putwarnint;
                   ', ' -> putwarntext;
                   theShape.privatepart.implpart.win32Points.p[i*2]-> putwarnint;
                   none->putwarnline;
              for);
              'SolidColorFillShapeBody end' -> putwarnline;
          if);
          
          implpart.theWin32Color[] -> makeBifrostColorRef -> theColor;
          implpart.theWin32Color[] 
            -> makeBifrostColorRef -> CreateSolidBrush -> theBrush; 
          (theCanvas.implpart.hdc, theBrush) -> SelectObject -> theOldBrush;
          
          NULL_PEN -> GetStockObject -> thePen;
          (theCanvas.implpart.hdc, thePen) -> SelectObject -> theOldPen;
          (if ((theCanvas.implpart.hdc,
              @@theShape.privatepart.implpart.win32Points.p[1],
              theShape.privatepart.implpart.NoOfPoints) 
                -> Polygon) = 0 then
              'Polygon failed in SolidColorFillShapeBody. ErrorCode= ' 
                -> putwarnText; GetLastError -> putwarnint; none->putwarnline;
          if);
          (theCanvas.implpart.hdc, theOldPen)->SelectObject;
          (theCanvas.implpart.hdc, theOldBrush)->SelectObject ->DeleteObject;
      if);
   #)
   
-- SolidColorFillLineBody: descriptor --
(# devBegin,devEnd,lBegin, lEnd: @Point;
   ntpPtr: @integer; pt: @point; result: @integer;
   theHPen, theOldHpen, penStyle, lineWidth: @integer;
   theLogbrush: @LOGBRUSH;
do (if debugGraphic then
       'SolidColorFillLineBody begin.' -> putwarnline;
   if);
   theCanvas[]->setCanvasPaint;
   theLine.begin 
     -> lBegin
     -> theLine.privatepart.go2canvasTM.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> devBegin; 
   theLine.end 
     -> lEnd
     -> theLine.privatepart.go2canvasTM.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> devEnd;
   
   8 -> malloc -> ntpPtr;
   (if ntpPtr<>0 then
       
       (if (lBegin.x - lEnd.x)<>0 then
           (devEnd.x - devBegin.x) div (lBegin.x - lEnd.x)
             -> lineWidth;
        else
           (if (lBegin.y - lEnd.y)<>0 then
               (devEnd.y - devBegin.y) div (lBegin.y - lEnd.y)
                 -> lineWidth;
            else
               0->lineWidth;
           if)
       if);
       theLine.Width * lineWidth -> lineWidth;
       (PS_GEOMETRIC %Bor PS_SOLID)-> penStyle;
       (penStyle %Bor PS_INSIDEFRAME)-> penStyle;
       (penStyle %Bor theline.cap)-> penStyle;
       
       BS_SOLID -> theLogBrush.lbStyle;
       
       implpart.theWin32Color[] 
         -> makeBifrostColorRef
         -> theLogBrush.lbColor; 
       (penStyle,lineWidth,theLogbrush[],0,0) -> ExtCreatePen -> theHPen;
       
       (theCanvas.implpart.hdc, theHPen) -> SelectObject -> theOldHPen;
       
       (theCanvas.implpart.hdc,devBegin.x,devBegin.y,ntpPtr) -> MoveToEx;
       (theCanvas.implpart.hdc,devEnd.x,devEnd.y) -> LineTo;
       (* restore the penposition *)
       ntpPtr -> getPointFromNtPointPtr -> (pt.x,pt.y);
       (theCanvas.implpart.hdc,pt.x,pt.y,0) -> MoveToEx;
       ntpPtr -> free;
       
       (theCanvas.implpart.hdc, theOldHPen) -> SelectObject -> DeleteObject;
    else
       'malloc failed in SolidColorFillLineBody.' -> putwarnline;
   if);
#)

-- SolidColorFillMultiLineBody: dopart --
do (# thePen, theOldPen, multiLineWidth, penStyle: @integer;
      theRect: @rectangle; 
      ul, devUpperLeft, devLowerRight: @Point;
      theLogBrush: @LOGBRUSH;
   do (if debugGraphic then
          'SolidColorFillMultiLineBody begin' -> putwarnline;
      if);
      
      theCanvas[]->setCanvasPaint;
      (if theMultiLine.privatepart.implpart[]=NONE then
          &theMultiLine.privatepart.implparttype[]
            -> theMultiLine.privatepart.implpart[]
      if);
      (if theMultiLine.Invalid then
          (theMultiLine.privatePart.go2canvasTM,
          theCanvas.TM[]) 
            -> MatrixMul
            -> theMultiLine.points.p.ToWin32Points
            -> theMultiLine.privatepart.implpart.win32Points[];
          theMultiLine.points.p.npoints 
            -> theMultiLine.privatepart.implpart.noofpoints;
      if);
      (if theMultiLine.dashes<>NONE then
          'MultiLine dashes' -> unimplemented;
      if);
      
      (if theMultiLine.privatepart.implpart.noofpoints > 0 then
          
          theMultiLine.getBounds -> theRect;
          (theRect.x,theRect.y)
            -> ul
            -> theMultiLine.privatepart.go2canvasTM.m.transformPoint
            -> theCanvas.CanvasToDevice
            -> devUpperLeft;
          (ul.x+theRect.width, ul.y-theRect.height)
            -> theMultiLine.privatepart.go2canvasTM.m.transformPoint
            -> theCanvas.CanvasToDevice
            -> devLowerRight;
          
          (if theRect.width>0 then
              (* Transform strokewidth by the factor theRect.width was 
               * increased by.
               *)
              theMultiLine.Width * ((devLowerRight.x - devUpperLeft.x) 
              div therect.width) -> multiLineWidth;
           else
              (if theRect.height>0 then
                  (* Transform strokewidth by the factor theRect.height was 
                   * increased by.
                   *)
                  theMultiLine.width * ((devLowerRight.y - devUpperLeft.y) 
                  div therect.height) -> multiLineWidth;
               else
                  (* Multiline with no width or height *)
                  0 -> multilinewidth;
              if)
          if);
          (PS_GEOMETRIC %Bor PS_SOLID)-> penStyle;
          (penStyle %Bor PS_INSIDEFRAME)-> penStyle;
          
          BS_SOLID -> theLogBrush.lbStyle;
          
          implpart.theWin32Color[] 
            -> makeBifrostColorRef
            -> theLogBrush.lbColor; 
          (penStyle,multiLineWidth,theLogbrush[],0,0)-> ExtCreatePen -> thePen;
          (theCanvas.implpart.hdc, thePen) -> SelectObject -> theOldPen;
          
          (if debugGraphic then
              (* debug *)
              (if theMultiLine.privatepart.implpart.win32Points.p.range <> theMultiLine.privatepart.implpart.NoOfPoints then
                  'WARNING: SolidColorFillMultiLineBody, ' -> putwarnText;
                  'theMultiLine.privatepart.implpart.win32Points.p.range <> ' -> putwarnline;
                  'theMultiLine.privatepart.implpart.NoOfPoints.' -> putwarnline;
              if);
          if);
          (* debug end *)
          
          
          (if ((theCanvas.implpart.hdc,
              @@theMultiLine.privatepart.implpart.win32Points.p[1],
              theMultiLine.privatepart.implpart.noofpoints)
                -> Polyline) = 0 then
              'Polyline failed in SolidColorFillMultiLineBody. Errorcode= ' 
                -> putwarnText; GetLastError -> putwarnint; none->putwarnline;
          if);
       else
          'SolidColorFillMultiLineBody. noofpoints=' -> putwarntext;
          theMultiLine.privatepart.implpart.noofpoints -> putwarnint; none->putwarnline;
      if);
      (theCanvas.implpart.hdc, theOldPen) -> SelectObject -> DeleteObject;
   #);
      
-- SolidColorFillTextBody: descriptor --
(# origin: @Point;
   length: @integer;
   x,y: @integer; 
   lineheight: @integer;
do (if debugGraphic then
       'SolidColorFillTextBody begin.' -> putwarnline;
   if);
   
   theCanvas[]->setCanvasPaint;
   theText.Position 
     -> theText.privatePart.go2canvastm.m.transformPoint 
     -> theCanvas.CanvasToDevice
     -> origin;
   
   origin.y -> y;
   origin.x -> x;
   
   (theCanvas.implpart.hdc, implpart.theWin32Color[]->makeBifrostColorRef)
     -> SetTextColor;
   
   (theText.theFontName, theText.theStyle, theText.Size)
     -> TextLineHeight
     -> lineheight;
   
   (theText.theLines).scan
   (# 
   do current.length -> length;
      (if length>0 then
          (if ((theCanvas.implpart.hdc, x, y,
              @@current.T[1],length) -> TextOut)=0 then
              'TextOut failed in SolidColorFillTextBody. ErrorCode= ' 
                -> putwarnText;
              GetLastError -> putwarnint; putwarnline;
          if);
      if);
      y+lineheight -> y (* device coords *);
   #);
#)

-- SolidColorFillPieBody: descriptor --
(# devUpperLeft,radius: @Point;
   ch,cv: @integer; (* center of rectangle *)
   xRadial1,yRadial1,xRadial2,yRadial2: @integer;
   angle1,angle2: @Real;
   theBrush, theOldBrush: @integer;
   left,right,top,bottom: @integer;
   center: @Point;
   thePen, theOldPen: @integer;
do (if debugGraphic then 'SolidColorFillPieBody begin.' -> putwarnline; if);
   
   theCanvas[]->setCanvasPaint;
   (* thePie.center -> thePie.privatePart.go2canvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice 
     -> devupperleft;
   devupperleft -> (ch,cv);
   (devupperleft.x-thePie.horizontalRadius,
   devupperleft.y-thePie.verticalRadius) -> devupperleft;
    *)
   thePie.center -> thePie.privatePart.go2canvasTM.m.transformPoint
     -> devupperleft;
   
   (devupperleft.x,devupperleft.y,thePie.horizontalRadius,thePie.verticalRadius)
     -> theCanvas.CanvasToDeviceRectangle
     -> (devupperleft.x,devupperleft.y,radius.x,radius.y);
   
   devupperleft -> (ch,cv);
   
   (devupperleft.x-radius.x,
   devupperleft.y-radius.y) -> devupperleft;

   devupperleft.x -> left; 
   devupperleft.x + 2*radius.x -> right;
   devupperleft.y -> top;
   devupperleft.y + 2*radius.y  -> bottom;
   
   (thePie.angle1/180) * pi -> angle1;
   (thePie.angle2/180) * pi -> angle2;

   ch + radius.x * (angle1 -> cos) -> xRadial1;
   cv + radius.y * (angle1 -> sin) -> yRadial1; 
   ch + radius.x * (angle2 -> cos) -> xRadial2;
   cv + radius.y * (angle2 -> sin) -> yRadial2;
   (2 * cv) - yRadial1 -> yRadial1;
   (2 * cv) - yRadial2 -> yRadial2;
   
   implpart.theWin32Color[] 
     -> makeBifrostColorRef -> CreateSolidBrush -> theBrush;
   (theCanvas.implpart.hdc, theBrush) -> SelectObject -> theOldBrush;
   NULL_PEN -> GetStockObject -> thePen;
   (theCanvas.implpart.hdc, thePen) -> SelectObject -> theOldPen;
   
   (if ( ((theCanvas.implpart.hdc,left,top,right,bottom,
       xRadial1,yRadial1,xRadial2,yRadial2)  -> Pie) = 0) then
       'Pie failed in SolidColorFillPieBody. ErrorCode= ' -> putwarnText;
       GetLastError -> putwarnint; none->putwarnline;
   if);
   (theCanvas.implpart.hdc, theOldBrush) -> SelectObject -> DeleteObject;
   (theCanvas.implpart.hdc, theOldPen) -> SelectObject;
   
   (if debugGraphic then 'SolidColorFillPieBody done.' -> putwarnline; if);
#)

-- SolidColorFillArcBody: descriptor --
(# ch,cv: @integer; (* center of rectangle *)
   xRadial1,yRadial1,xRadial2,yRadial2: @integer;
   angle1,angle2: @Real;
   result: @integer;
   left,right,top,bottom: @integer;
   devUpperLeft,radius: @Point;
   
   theHPen, theOldHpen, penStyle, arcWidth: @integer;
   theLogbrush: @LOGBRUSH;
   
do (if debugGraphic then 'SolidColorFillArcBody begin.' -> putwarnline; if);
   
   (if (theCanvas.implpart.windowID>0) then
              
       theCanvas[]->setCanvasPaint;
       
       theArc.center -> theArc.privatePart.go2canvasTM.m.transformPoint
         -> devupperleft;
       
       (devupperleft.x,devupperleft.y,theArc.horizontalRadius,theArc.verticalRadius)
         -> theCanvas.CanvasToDeviceRectangle
         -> (devupperleft.x,devupperleft.y,radius.x,radius.y);
   
       devupperleft -> (ch,cv);
       
       (devupperleft.x-radius.x,
       devupperleft.y-radius.y) -> devupperleft;
   
       devUpperLeft.x -> left; 
       devUpperLeft.x+2*radius.x -> right;
       devUpperleft.y -> top;
       devUpperleft.y+2*radius.y -> bottom;
       
       (theArc.angle1/180) * pi -> angle1;
       (theArc.angle2/180) * pi -> angle2;
       
       ch + radius.x * (angle1 -> cos) -> xRadial1;
       cv + radius.y * (angle1 -> sin) -> yRadial1; 
       ch + radius.x * (angle2 -> cos) -> xRadial2;
       cv + radius.y * (angle2 -> sin) -> yRadial2;
       (2 * cv) - yRadial1 -> yRadial1;
       (2 * cv) - yRadial2 -> yRadial2;
       
       theArc.arcWidth -> arcWidth;
       (PS_GEOMETRIC %Bor PS_SOLID)-> penStyle;
       (penStyle %Bor PS_INSIDEFRAME)-> penStyle;
       
       BS_SOLID -> theLogBrush.lbStyle;
       
       implpart.theWin32Color[] 
         -> makeBifrostColorRef
         -> theLogBrush.lbColor; 
       
       (penStyle,arcWidth,theLogbrush[],0,0) -> ExtCreatePen -> theHPen;
       
       (theCanvas.implpart.hdc, theHPen) -> SelectObject -> theOldHPen;
       
       (theCanvas.implpart.hdc,left,top,right,bottom,xRadial1,yRadial1,xRadial2,yRadial2)
         -> Arc -> result; 
       (theCanvas.implpart.hdc, theOldHPen) -> SelectObject -> DeleteObject;
   if);
   
   (if debugGraphic then 'SolidColorFillArcBody done.' -> putwarnline; if);
#)

-- SolidColorFillRectBody: descriptor --
(# ul, devUpperLeft, devLowerRight, transformedUl, transformedLr: @Point;
   result: @integer; hbr: @integer; hRgn: @integer; 
   hbrushOld: @integer;
   
   ntFillRect2: external
     (# hdc: @integer; (* HDC *)
        theRect: ^ntRECT; (* const RECT FAR* *)
        hbr: @integer; (* HBRUSH *)
        result: @integer; (* int *)
     enter (hdc,theRect[],hbr)
     do 'FillRect' -> callStd;
     exit result
     #);
   theNTRect: @ntRECT;
   theBrush: @integer;
   thePen, theOldPen, strokeWidth, penStyle: @integer;
   theLogBrush: @LOGBRUSH;
   
do theCanvas[]->setCanvasPaint;
   
   theRect.upperleft 
     -> ul
     -> theRect.privatepart.go2canvasTM.m.transformPoint
     -> transformedUl
     -> theCanvas.CanvasToDevice
     -> devUpperLeft;
   (ul.x+theRect.width, ul.y-theRect.height)
     -> theRect.privatepart.go2canvasTM.m.transformPoint
     -> transformedLr
     -> theCanvas.CanvasToDevice
     -> devLowerRight (* devLowerright *);
   
   (* Transform strokewidth by the factor theRect.width was increased by *)
   (if therect.width<> 0 then
       theRect.strokewidth * ((devLowerRight.x - devUpperLeft.x) 
       div therect.width) -> strokeWidth;
    else
       (if therect.height<> 0 then
           theRect.strokewidth * ((devLowerRight.y - devUpperLeft.y) 
           div therect.height) -> strokeWidth;
        else
           0->strokeWidth;
       if)
   if);
   (PS_GEOMETRIC %Bor PS_SOLID)-> penStyle;
   (penStyle %Bor PS_INSIDEFRAME)-> penStyle;
   
   BS_SOLID -> theLogBrush.lbStyle;
   
   implpart.theWin32Color[] 
     -> makeBifrostColorRef
     -> theLogBrush.lbColor; 
   (penStyle,strokeWidth,theLogbrush[],0,0) -> ExtCreatePen -> thePen;
   (theCanvas.implpart.hdc, thePen) -> SelectObject -> theOldPen;
   
   (if theRect.stroked then
       NULL_BRUSH -> GetStockObject -> hbr;
       (theCanvas.implpart.hdc, hbr) -> SelectObject -> hbrushOld;
       (theCanvas.implpart.hdc,
       devUpperleft.x,devUpperleft.y,
       devLowerRight.x,devLowerRight.y) 
         -> ntRectangle -> result;
       (if result=0 then
           'Rectangle failed in SolidColorFillRectBody. Errorcode: ' 
             -> putwarntext;
           GetLastError -> putwarnint; none->putwarnline;
       if);
       (theCanvas.implpart.hdc, hbrushOld) -> SelectObject;
    else
       devUpperleft.x -> theNTRect.left;
       devUpperleft.y -> theNTRect.top;
       devLowerRight.x -> theNTRect.right;
       devLowerRight.y -> theNTRect.bottom;
       implpart.theWin32Color[] 
         -> makeBifrostColorRef -> CreateSolidBrush -> theBrush;
       
       (theCanvas.implpart.hdc,theNTRect[],theBrush) 
         -> ntFillRect2 -> result;
       (if result=0 then
           'graphicsDrawRect. Rectangle failed!! Errorcode: ' -> putwarntext;
           GetLastError -> putwarnint; none->putwarnline;
       if);
       theBrush -> DeleteObject;
   if);
   (theCanvas.implpart.hdc, theOldPen) -> SelectObject -> DeleteObject;
#)

-- SolidColorFillEllipseBody: descriptor --
(# ul,ll, devUpperLeft, devLowerRight, transformedUl, transformedLr: @Point;
   width, height, devWidth, devHeight: @integer;
   theOldBrush, theBrush: @integer;
   thePen, theOldPen, strokeWidth, penStyle: @integer;
   theLogBrush: @LOGBRUSH;
do (if thecanvas[]=none then 'SolidColorFillEllipseBody: canvas is none'->putwarnline if);
   
   theCanvas[]->setCanvasPaint;
   
   theEllipse.center -> ul;
   ul.x - theEllipse.horizontalRadius -> ul.x;
   ul.y + theEllipse.verticalRadius -> ul.y;
   ul
     -> theEllipse.privatepart.go2canvasTM.m.transformPoint
     -> transformedUl
     -> theCanvas.CanvasToDevice
     -> devUpperLeft;
   
   (ul.x+(2*theEllipse.horizontalRadius), ul.y-(2*theEllipse.verticalRadius))
     -> theEllipse.privatepart.go2canvasTM.m.transformPoint
     -> transformedLr
     -> theCanvas.CanvasToDevice
     -> devLowerRight;
   
   (if theEllipse.stroked then
       
       (* Transform strokewidth by the factor theRect.width was increased by *)
       devLowerRight.x - devUpperLeft.x -> devWidth;
       2*theEllipse.horizontalRadius -> width;
       (if width<>0 then 
           theEllipse.strokewidth * (devWidth div width)
             -> strokeWidth;
        else
           devLowerRight.y - devUpperLeft.y -> devHeight;
           2*theEllipse.verticalRadius -> height;
           (if height<>0 then 
               theEllipse.strokewidth * (devHeight div height)
                 -> strokeWidth;
            else
               0 -> strokeWidth;
           if);
       if);
       
       (PS_GEOMETRIC %Bor PS_SOLID)-> penStyle;
       (penStyle %Bor PS_INSIDEFRAME)-> penStyle;
       
       BS_SOLID -> theLogBrush.lbStyle;
       
       implpart.theWin32Color[] 
         -> makeBifrostColorRef
         -> theLogBrush.lbColor; 
       (penStyle,strokeWidth,theLogbrush[],0,0) -> ExtCreatePen -> thePen;
       (theCanvas.implpart.hdc, thePen) -> SelectObject -> theOldPen;
       
       (theCanvas.implpart.hdc, (NULL_BRUSH -> GetStockObject)) 
         -> SelectObject -> theOldBrush;
       (if ((theCanvas.implpart.hdc,
           devUpperleft.x, 
           devUpperleft.y,
           devLowerRight.x,
           devLowerRight.y) 
             -> Ellipse)=0 then
           'Ellipse failed in SolidColorFillEllipseBody. ErrorCode= ' 
             -> putwarnText; GetLastError -> putwarnint; none->putwarnline;
       if);
       (theCanvas.implpart.hdc, theOldBrush) -> SelectObject;
       (theCanvas.implpart.hdc, theOldPen) -> SelectObject -> DeleteObject;
    else
       implpart.theWin32Color[] 
         -> makeBifrostColorRef -> CreateSolidBrush -> theBrush;
       (theCanvas.implpart.hdc, theBrush) -> SelectObject -> theOldBrush;
       NULL_PEN -> GetStockObject -> thePen;
       (theCanvas.implpart.hdc, thePen) -> SelectObject -> theOldPen;
       (if ((theCanvas.implpart.hdc,
           devUpperleft.x, 
           devUpperleft.y,
           devLowerRight.x,
           devLowerRight.y) 
             -> Ellipse)=0 then
           'Ellipse failed in SolidColorFillEllipseBody. ErrorCode= ' 
             -> putwarnText; GetLastError -> putwarnint; none->putwarnline;
       if);
       (theCanvas.implpart.hdc, theOldBrush) -> SelectObject -> DeleteObject;
       (theCanvas.implpart.hdc, theOldPen) -> SelectObject;
   if);   
#)


-- TiledSolidFillShapeBody: dopart --
do INNER; 
   theShape[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillShape *) 
   
-- TiledSolidFillLineBody: dopart --
do INNER; 
   theLine[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillLine *) 

-- TiledSolidFillMultiLineBody: dopart --
do INNER; 
   theMultiLine[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillMultiline *) 

-- TiledSolidFillTextBody: dopart --
do INNER; 
   theText[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillText *) 

-- TiledSolidFillArcBody: dopart --
do INNER; 
   theArc[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillArc*) 

-- TiledSolidFillPieBody: dopart --
do INNER; 
   thePie[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillPie *) 

-- TiledSolidFillRectBody: dopart --
do INNER; 
   theRect[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillRect *) 

-- TiledSolidFillEllipseBody: dopart --
do INNER; 
   theEllipse[] -> tiledprivate.theShape[];
   (* The rest is handled by SetCanvasPaint and SolidColor.FillEllipse *) 
   
-- BifrostAttributes: attributes --

-- TiledSolidSetBorderPaintBody: descriptor --
(# 
do 'TiledSolidSetBorderPaintBody' ->unimplemented;
#)
-- TiledSolidSetCanvasPaintBody: descriptor --
(# 
do 'TiledSolidSetCanvasPaintBody'->unimplemented
#) 
-- TiledSolidSetBackgroundPaintBody: descriptor --
(# 
do 'TiledSolidSetBackgroundPaintBody'->unimplemented
#)




-- RasterPaintFillMultiLineBody: dopart --
do INNER;
   'RasterPaintFillMultiLineBody'->unimplemented
   
-- RasterPaintFillArcBody: dopart --
do INNER;
   'RasterPaintFillArcBody'->unimplemented
   
-- RasterPaintFillPieBody: dopart --
do INNER;
   'RasterPaintFillPieBody'->unimplemented

-- RasterPaintFillShapeBody: descriptor --
(# 
do 'RasterPaintFillShapeBody'->unimplemented
#)

-- RasterPaintFillLineBody: dopart --
do INNER;
   'RasterPaintFillLineBody'->unimplemented
   
-- RasterPaintFillRectBody: dopart --
do INNER;
   'RasterPaintFillRectBody'->unimplemented
   
-- RasterPaintFillTextBody: dopart --
do INNER;
   'RasterPaintFillTextBody'->unimplemented
   
-- RasterPaintFillEllipseBody: dopart --
do INNER;
   'RasterPaintFillEllipseBody'->unimplemented

-- RasterPaintSetBorderPaintBody: descriptor --
(# 
do 'RasterPaintSetBorderPaintBody'->unimplemented
#)

-- RasterPaintSetBackgroundPaintBody: descriptor --
(# 
do 'RasterPaintSetBackgroundPaintBody'->unimplemented
#)

-- RasterPaintSetCanvasPaintBody: descriptor --
(# 
do 'RasterPaintSetCanvasPaintBody'->unimplemented
#)
