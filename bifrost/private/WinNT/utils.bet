ORIGIN '~beta/basiclib/betaenv';
BODY 'drawborderbody';
INCLUDE '~beta/guienv/graphmath';
INCLUDE '~beta/win32lib/ntitypes';
INCLUDE '~beta/win32lib/windowmanagement';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/wingdi';
INCLUDE '~beta/win32lib/windowsmisc';

-- lib: attributes --
RGN_AND: (# exit 1 #);

win32Color: 
  (# reserved: @integer;
     blue: @integer;
     green: @integer;
     red: @integer;
  enter (red,green,blue)
  exit (red,green,blue)
  #);

makeBifrostColorRef:
  (# theWin32Color: ^win32Color;
     theColorRef: @integer;
     red,green,blue: @integer;
  enter theWin32Color[]
  do 
     theWin32Color.red div 256 -> red;
     theWin32Color.green div 256 -> green;
     theWin32Color.blue div 256 -> blue;
     (red,  0) -> theColorRef.%PutByte;
     (green,1) -> theColorRef.%PutByte;
     (blue, 2) -> theColorRef.%PutByte;
     (2,    3) -> theColorRef.%PutByte;
  exit theColorRef
  #);

rectLeftOffset:   (# exit 0 #);
rectTopOffset:    (# exit 4 #);
rectRightOffset:  (# exit 8 #);
rectBottomOffset: (# exit 12 #);

makeNtRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter r[]
  do 16 -> malloc -> ntRectPtr;
     (r.left)   %putLongAt (ntRectPtr + rectLeftOffset);
     (r.top)    %putLongAt (ntRectPtr + rectTopOffset);
     (r.right)  %putLongAt (ntRectPtr + rectRightOffset);
     (r.bottom) %putLongAt (ntRectPtr + rectBottomOffset);
  exit ntRectPtr
  #);

getRectFromNtRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter ntRectPtr
  do &rectangle[] -> r[];
     %getLongAt (ntRectPtr + rectLeftOffset   ) -> r.left;
     %getLongAt (ntRectPtr + rectTopOffset    ) -> r.top;
     %getLongAt (ntRectPtr + rectRightOffset  ) -> r.right;
     %getLongAt (ntRectPtr + rectBottomOffset ) -> r.bottom;
  exit r
  #); 

pointXoffset: (# exit 0 #);
pointYoffset: (# exit 4 #);

makeNtPointPtr:
  (# h,v: @integer;
     ntPointPtr: @integer;
  enter (h,v)
  do 8 -> malloc -> ntPointPtr;
     h %putLongAt (ntPointPtr + pointXoffset);
     v %putLongAt (ntPointPtr + pointYoffset);
  exit ntPointPtr
  #);

getPointFromNtPointPtr:
  (# h,v: @integer;
     ntPointPtr: @integer;
  enter ntPointPtr
  do %getLongAt (ntPointPtr + pointXoffset) -> h;
     %getLongAt (ntPointPtr + pointYoffset) -> v;
  exit (h,v)
  #);


translateUpdateRect:
  (# r: ^rectangle;
     x,y,width,height: @integer;
  enter r[]
  do (if r[]<>NONE then
         r.topleft -> (x, y);
         r.size -> (width, height);
     if);
  exit (x,y,width,height)
  #);


win32ClearArea:
  (# r: @rectangle;
     x,y,width,height: @integer; hdc: @integer;
     theNtRectPtr: @integer; 
     backgroundBrush: @integer;
  enter (x,y,width,height,hdc,backgroundBrush)
  do (x,y) -> r.topLeft;
     (width,height) -> r.size;
     
     r[] -> makeNtRectPtr -> theNtRectPtr;
     (if ((hdc, theNtRectPtr, backgroundBrush) -> ntFillRect)=0 then
         'ntFillRect failed.' -> putline;
     if);
     theNtRectPtr -> free;
  #);


drawBorderBifrost:
  (# theStyle: @integer;
     width,height: @integer;
     x,y: @integer;
     windowId: @integer;
     theHPen: @integer;
  enter (windowId, theHPen, theStyle,x,y,width,height)
  do <<SLOT drawborderbodyBifrost: descriptor>>
  #);
