ORIGIN '~beta/basiclib/v1.5/betaenv';
BODY 'drawborderbody';
INCLUDE '~beta/guienv/v1.4/graphmath';
INCLUDE '~beta/win32lib/v1.2/ntitypes';
INCLUDE '~beta/win32lib/v1.2/windowmanagement';
INCLUDE '~beta/win32lib/v1.2/winuserconsts';
INCLUDE '~beta/win32lib/v1.2/wingdi';
INCLUDE '~beta/win32lib/v1.2/windowsmisc';

-- lib: attributes --
RGN_AND: (# exit 1 #);

win32Color: 
  (# reserved: @integer;
     blue: @integer;
     green: @integer;
     red: @integer;
  enter (red,blue,green)
  exit (red,blue,green)
  #);

makeColorRef:
  (# theWin32Color: ^win32Color;
     theColorRef: @integer;
     red,green,blue: @integer;
  enter theWin32Color[]
  do 
     theWin32Color.red div 256 -> red;
     theWin32Color.green div 256 -> green;
     theWin32Color.blue div 256 -> blue;
     (@@theColorRef,red) -> TOS'%PutByte';
     (@@theColorRef + 1,green) -> TOS'%PutByte';
     (@@theColorRef + 2,blue) -> TOS'%PutByte';
     (@@theColorRef + 3,0) -> TOS'%PutByte';
  exit theColorRef
  #);

rectLeftOffset:   (# exit 0 #);
rectTopOffset:    (# exit 4 #);
rectRightOffset:  (# exit 8 #);
rectBottomOffset: (# exit 12 #);

makeNtRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter r[]
  do 16 -> malloc -> ntRectPtr;
     (ntRectPtr + rectLeftOffset,  r.left) -> TOS'%PutLong';
     (ntRectPtr + rectTopOffset,   r.top) -> TOS'%PutLong';
     (ntRectPtr + rectRightOffset, r.right) -> TOS'%PutLong';
     (ntRectPtr + rectBottomOffset,r.bottom) -> TOS'%PutLong';
  exit ntRectPtr
  #);

getRectFromNtRectPtr:
  (# r: ^rectangle;
     ntRectPtr: @integer;
  enter ntRectPtr
  do &rectangle[] -> r[];
     ntRectPtr + rectLeftOffset   -> TOS'%adrGetLong' -> r.left;
     ntRectPtr + rectTopOffset    -> TOS'%adrGetLong' -> r.top;
     ntRectPtr + rectRightOffset  -> TOS'%adrGetLong' -> r.right;
     ntRectPtr + rectBottomOffset -> TOS'%adrGetLong' -> r.bottom;
  exit r
  #); 

pointXoffset: (# exit 0 #);
pointYoffset: (# exit 4 #);

makeNtPointPtr:
  (# h,v: @integer;
     ntPointPtr: @integer;
  enter (h,v)
  do 8 -> malloc -> ntPointPtr;
     (ntPointPtr + pointXoffset, h) -> TOS'%PutLong';
     (ntPointPtr + pointYoffset, v) -> TOS'%PutLong';
  exit ntPointPtr
  #);

getPointFromNtPointPtr:
  (# h,v: @integer;
     ntPointPtr: @integer;
  enter ntPointPtr
  do ntPointPtr + pointXoffset -> TOS'%adrGetLong' -> h;
     ntPointPtr + pointYoffset -> TOS'%adrGetLong' -> v;
  exit (h,v)
  #);


translateUpdateRect:
  (# r: ^rectangle;
     x,y,width,height: @integer;
  enter r[]
  do (if r[]<>NONE then
         r.topleft -> (x, y);
         r.size -> (width, height);
     if);
  exit (x,y,width,height)
  #);


win32ClearArea:
  (# r: @rectangle;
     x,y,width,height: @integer; hdc: @integer;
     theNtRectPtr: @integer; 
     backgroundBrush: @integer;
  enter (x,y,width,height,hdc,backgroundBrush)
  do (x,y) -> r.topLeft;
     (width,height) -> r.size;
     
     r[] -> makeNtRectPtr -> theNtRectPtr;
     (if ((hdc, theNtRectPtr, backgroundBrush) -> ntFillRect)=0 then
         'ntFillRect failed.' -> putline;
     if);
     theNtRectPtr -> free;
  #);


drawBorderBifrost:
  (# theStyle: @integer;
     width,height: @integer;
     x,y: @integer;
     windowId: @integer;
     theHPen: @integer;
  enter (windowId, theHPen, theStyle,x,y,width,height)
  do <<SLOT drawborderbodyBifrost: descriptor>>
  #);
