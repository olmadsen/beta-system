ORIGIN '../Predefined/TextImpl';
INCLUDE 'BifrostWinNTimpl';
INCLUDE '~beta/sysutils/cstring';

-- lib: attributes --
CreateDC2: external
  (# driver: [1] @char; (* LPCSTR *)
     device: @integer; (* LPCSTR *)
     output: @integer; (* Must be NULL *)
     initData: @integer; (* const void FAR* *)
     hdc: @integer; (* HDC *)
  enter (driver,device,output,initData)
  do 'CreateDCA' -> callStd;
  exit hdc
  #);

GetOutlineTextMetrics2: external
  (#
     in0: @integer; (* HDC *)
     in1: @integer; (* UINT *)
     in2: @integer; (* OUTLINETEXTMETRIC FAR* *)
     out: @int16; (* WORD *)
  enter (in0,in1,in2)
  do 'GetOutlineTextMetricsA' -> callStd;
  exit out
  #);

getOsVersionId: external
  (# osId: @integer;
  do callC;
  exit osId
  #);

-- TextListGetWidthHeight: descriptor --
(# w: @integer;
do 0->width;
   theLines.scan
   (# 
   do (current[], nam, sty, siz) -> TextGetWidth -> w;
      (if w>width then w -> width if);
   #);
   theLines.size*((nam,sty,siz)->TextLineHeight) -> height;
#)

--TextGetWidth: descriptor--
(# theWin32Font: ^win32Font; 
   theWin32Fonts: ^win32Fonts;
   hdc: @integer;
   theSize: @point;
   theSizePtr: @integer;
   cstr: @cstring;
   
do ('DISPLAY',0,0,0) -> CreateDC2 -> hdc;
   (if hdc<>0 then
       objectPool.scan
       (# type:: win32Fonts;
       do current[] -> theWin32Fonts[];
       #);
       
       (if theWin32Fonts[]<>NONE then
           (nam, sty, siz) -> theWin32Fonts.theFontTable.find -> theWin32Font[];
           (if theWin32Font[]=NONE then
               (hdc, nam, sty, siz) 
                 -> theWin32Fonts.createWin32Font;
               (nam, sty, siz) 
                 -> theWin32Fonts.theFontTable.find 
                 -> theWin32Font[];
               
               (if theWin32Font[]=NONE then
                   (if displayWarnings then
                       'Could not find font in TextGetWidth. ' -> screen.putText;
                       'nam= ' -> screen.putText; nam-> putint; ', ' -> puttext;
                       'sty= ' -> screen.putText; sty-> putint; ', ' -> puttext;
                       'siz= ' -> screen.putText; siz-> putint; newline;
                   if);
                   &win32Font[] -> theWin32Font[];
                   ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
               if);
           if);
        else
           &win32Font[] -> theWin32Font[];
           ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
       if);
       
       (hdc, theWin32Font.hFont) -> SelectObject;
       (if T.length> 0 then
           8 -> malloc -> theSizePtr;
           T[] -> cstr.set;
           (hdc,cstr.charPtr,cstr.length,theSizePtr) -> GetTextExtentPoint32;
           theSizePtr -> getPointFromNtPointPtr -> (theSize.x,theSize.y);
           theSize.x -> value;
           cstr.free;
           theSizePtr -> free;
        else
           0 -> value;
       if);
       hdc -> DeleteDC;
    else
       (if displayWarnings then
           'CreateDC2 failed in TextGetWidth. Error code= ' -> screen.putText;
           GetLastError -> putInt; newline;
       if);
       0 -> value;
   if);
#)

--TextGetHeight: descriptor--
(# theWin32Font: ^win32Font; 
   theWin32Fonts: ^win32Fonts;
   hdc: @integer;
   theSize: @point;
   theSizePtr: @integer;
   cstr: @cstring;
   
do ('DISPLAY',0,0,0) -> CreateDC2 -> hdc;
   (if hdc<>0 then
       objectPool.scan
       (# type:: win32Fonts;
       do current[] -> theWin32Fonts[];
       #);
       
       (if theWin32Fonts[]<>NONE then
           (nam, sty, siz) -> theWin32Fonts.theFontTable.find -> theWin32Font[];
           (if theWin32Font[]=NONE then
               (hdc, nam, sty, siz) 
                 -> theWin32Fonts.createWin32Font;
               (nam, sty, siz) 
                 -> theWin32Fonts.theFontTable.find 
                 -> theWin32Font[];
               
               (if theWin32Font[]=NONE then
                   (if displayWarnings then
                       'Could not find font in TextGetHeight. ' -> screen.putText;
                       'nam= ' -> screen.putText; nam-> putint; ', ' -> puttext;
                       'sty= ' -> screen.putText; sty-> putint; ', ' -> puttext;
                       'siz= ' -> screen.putText; siz-> putint; newline;
                   if);
                   
                   &win32Font[] -> theWin32Font[];
                   ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
               if);
           if);
        else
           &win32Font[] -> theWin32Font[];
           ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
       if);
       
       (hdc, theWin32Font.hFont) -> SelectObject;
       (if T.length > 0 then
           8 -> malloc -> theSizePtr;
           T[] -> cstr.set;
           (hdc,cstr.charPtr,cstr.length,theSizePtr) -> GetTextExtentPoint32;
           theSizePtr -> getPointFromNtPointPtr -> (theSize.x,theSize.y);
           theSize.y -> value;
           cstr.free;
           theSizePtr -> free;
        else
           0 -> value;
       if);
       hdc -> DeleteDC;
    else
       (if displayWarnings then
           'CreateDC2 failed in TextGetHeight. Error code= ' -> screen.putText;
           GetLastError -> putInt; newline;
       if);
       0 -> value;
   if);
#)

--TextLineHeight: dopart--
do (# theWin32Font: ^win32Font; 
      theWin32Fonts: ^win32Fonts;
      hdc: @integer;
      saved: @integer;
      infoPtr: @integer;
      sizeOfOUTLINETEXTMETRIC: @integer;
   do ('DISPLAY',0,0,0) -> CreateDC2 -> hdc;
      (if hdc<>0 then
          objectPool.scan
          (# type:: win32Fonts;
          do current[] -> theWin32Fonts[];
          #);
          
          (if theWin32Fonts[]<>NONE then
              (nam, sty, siz) -> theWin32Fonts.theFontTable.find -> theWin32Font[];
              (if theWin32Font[]=NONE then
                  (hdc, nam, sty, siz) 
                    -> theWin32Fonts.createWin32Font;
                  (nam, sty, siz) 
                    -> theWin32Fonts.theFontTable.find 
                    -> theWin32Font[];
                  (if theWin32Font[]=NONE then
                      (if displayWarnings then
                          'Could not find font in TextLineHeight.' -> screen.putLine;
                      if);
                      &win32Font[] -> theWin32Font[];
                      ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
                  if);
              if);
           else
              (if displayWarnings then
                  'WARNING: Did NOT find theWin32Fonts in TextLineHeight.'->screen.putLine;
              if);
              &win32Font[] -> theWin32Font[];
              ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
          if);
          
          (hdc,theWin32Font.hFont) -> SelectObject -> saved;
          
          (if theWin32Font.fontType
           =TRUETYPE_FONTTYPE then
              (hdc,0,0) -> GetOutlineTextMetrics2
                -> sizeOfOUTLINETEXTMETRIC;
              sizeOfOUTLINETEXTMETRIC -> malloc -> infoPtr;
              (hdc,sizeOfOUTLINETEXTMETRIC,infoPtr) -> GetOutlineTextMetrics2 
                -> sizeOfOUTLINETEXTMETRIC;
              (%getLongAt (infoPtr + textmetricTmHeightOffset + 4)) -> value;
           else
              56 -> malloc -> infoPtr;
              (hdc,infoPtr) -> GetTextMetrics;
              (%getLongAt (infoPtr + textmetricTmHeightOffset)) -> value;
          if);
          
          (hdc,saved) -> SelectObject;
          hdc -> DeleteDC;
          infoPtr -> free;
       else
          (if displayWarnings then
              'WARNING: CreateDC failed in TextLineHeight. Error code= ' 
                -> screen.putText;
              GetLastError -> putInt; newline;
          if);
      if);
   #);

-- TextMaxDescent: dopart --
do (# theWin32Font: ^win32Font; 
      theWin32Fonts: ^win32Fonts;
      hdc: @integer;
      saved: @integer;
      infoPtr: @integer;
      sizeOfOUTLINETEXTMETRIC: @integer;
   do ('DISPLAY',0,0,0) -> CreateDC2 -> hdc;
      (if hdc<>0 then
          objectPool.scan
          (# type:: win32Fonts;
          do current[] -> theWin32Fonts[];
          #);
          
          (if theWin32Fonts[]<>NONE then
              (nam, sty, siz) -> theWin32Fonts.theFontTable.find -> theWin32Font[];
              (if theWin32Font[]=NONE then
                  (hdc, nam, sty, siz) 
                    -> theWin32Fonts.createWin32Font;
                  (nam, sty, siz) 
                    -> theWin32Fonts.theFontTable.find 
                    -> theWin32Font[];
                  (if theWin32Font[]=NONE then
                      (if displayWarnings then
                          'Could not find font in TextMaxDescent.' -> screen.putLine;
                      if);
                      &win32Font[] -> theWin32Font[];
                      ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
                  if);
              if);
           else
              (if displayWarnings then
                  'WARNING: Did NOT find theWin32Fonts in TextMaxDescent.'->screen.putLine;
              if);
              &win32Font[] -> theWin32Font[];
              ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
          if);
          
          (hdc,theWin32Font.hFont) -> SelectObject -> saved;
          
          (if theWin32Font.fontType
           =TRUETYPE_FONTTYPE then
              (hdc,0,0) -> GetOutlineTextMetrics2
                -> sizeOfOUTLINETEXTMETRIC;
              sizeOfOUTLINETEXTMETRIC -> malloc -> infoPtr;
              (hdc,sizeOfOUTLINETEXTMETRIC,infoPtr) -> GetOutlineTextMetrics2 
                -> sizeOfOUTLINETEXTMETRIC;
              (%getLongAt (infoPtr + textmetricTmDescentOffset + 4)) -> value;
           else
              56 -> malloc -> infoPtr;
              (hdc,infoPtr) -> GetTextMetrics;
              (%getLongAt (infoPtr + textmetricTmDescentOffset)) -> value;
          if);
          
          (hdc,saved) -> SelectObject;
          hdc -> DeleteDC;
          infoPtr -> free;
       else
          (if displayWarnings then
              'WARNING: CreateDC failed in TextMaxDescent. Error code= ' 
                -> screen.putText;
              GetLastError -> putInt; newline;
          if);
      if);
   #);
   
--TextMaxAscent: dopart--
do (# theWin32Font: ^win32Font; 
      theWin32Fonts: ^win32Fonts;
      hdc: @integer;
      saved: @integer;
      infoPtr: @integer;
      sizeOfOUTLINETEXTMETRIC: @integer;
   do ('DISPLAY',0,0,0) -> CreateDC2 -> hdc;
      (if hdc<>0 then
          objectPool.scan
          (# type:: win32Fonts;
          do current[] -> theWin32Fonts[];
          #);
          
          (if theWin32Fonts[]<>NONE then
              (nam, sty, siz) -> theWin32Fonts.theFontTable.find -> theWin32Font[];
              (if theWin32Font[]=NONE then
                  (hdc, nam, sty, siz) 
                    -> theWin32Fonts.createWin32Font;
                  (nam, sty, siz) 
                    -> theWin32Fonts.theFontTable.find 
                    -> theWin32Font[];
                  (if theWin32Font[]=NONE then
                      (if displayWarnings then
                          'Could not find font in TextMaxAscent.' -> screen.putLine;
                      if);
                      &win32Font[] -> theWin32Font[];
                      ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
                  if);
              if);
           else
              (if displayWarnings then
                  'WARNING: Did NOT find theWin32Fonts in TextMaxAscent.'->screen.putLine;
              if);
              &win32Font[] -> theWin32Font[];
              ANSI_VAR_FONT -> GetStockObject -> theWin32Font.hFont;
          if);
          
          (hdc,theWin32Font.hFont) -> SelectObject -> saved;
          
          (if theWin32Font.fontType
           =TRUETYPE_FONTTYPE then
              (hdc,0,0) -> GetOutlineTextMetrics2
                -> sizeOfOUTLINETEXTMETRIC;
              sizeOfOUTLINETEXTMETRIC -> malloc -> infoPtr;
              (hdc,sizeOfOUTLINETEXTMETRIC,infoPtr) -> GetOutlineTextMetrics2 
                -> sizeOfOUTLINETEXTMETRIC;
              (%getLongAt (infoPtr + textmetricTmAscentOffset + 4)) -> value;
           else
              56 -> malloc -> infoPtr;
              (hdc,infoPtr) -> GetTextMetrics;
              (%getLongAt (infoPtr + textmetricTmAscentOffset)) -> value;
          if);
          
          (hdc,saved) -> SelectObject;
          hdc -> DeleteDC;
          infoPtr -> free;
       else
          (if displayWarnings then
              'WARNING: CreateDC failed in TextMaxAscent. Error code= ' 
                -> screen.putText;
              GetLastError -> putInt; newline;
          if);
      if);
   #);
  
-- TextUnderlineDepth: descriptor --
(# do 'TextUnderlineDepth' -> unimplemented; #)

(* TextShapeInteractiveCreate *)
--TextShapeInteractiveCreateBodyPrivate: descriptor--
(# theWin32Font: ^win32Font;
   theWin32Fonts: ^win32Fonts;
   maxDescent: @integer;
   tempCharWidth: @integer;
   theBrush: @integer;
   infoPtr, tmAscent, oldFont: @integer;
   osVersionId: @integer;
#)
--TextShapeInteractiveCreateBodyDrawInsertionMark: descriptor--
(#
do theCanvas.prepareInteraction;
   ((base_x,uppery-1 + icprivate.maxDescent + icprivate.tmAscent), (base_x,uppery-1))
     -> theCanvas.immediateline;
   theCanvas.endInteraction;
   theCanvas[] -> thecanvas.privatepart.interactionpaint.setcanvaspaint;
#)
--TextShapeInteractiveCreateBodyLetterWidth: dopart--
do (if icprivate.osVersionId=VER_PLATFORM_WIN32_NT then
          (theCanvas.implpart.hdc,ch,ch,icprivate.tempCharWidth) -> GetCharWidth32;
          (%getLongAt (icprivate.tempCharWidth)) -> value;
       else
          (theCanvas.implpart.hdc,ch,ch,icprivate.tempCharWidth) -> GetCharWidth;
          (%getLongAt (icprivate.tempCharWidth)) -> value;
      if);
--TextShapeInteractiveCreateBodyDrawCh: descriptor--
(# 
do (base_x,uppery,
   ChWidth+1,
   icprivate.tmAscent + icprivate.maxDescent,
   theCanvas.implpart.hdc, 
   icprivate.theBrush)
     -> win32ClearArea;
   
   theCh -> chArray[1];
   (if ((theCanvas.implpart.hdc, base_X, base_Y,@@chArray[1],1) 
         -> TextOut)=0 then
       (if displayWarnings then
           'TextOut failed in TextShapeInteractiveCreateBody. ErrorCode= ' 
             -> screen.putText;
           GetLastError -> putInt; screen.newline;
       if);
   if);
#)
--TextShapeInteractiveCreateBodyClearPrevCh: descriptor--
(#
do (base_x-2,uppery,
   prevChWidth+3,
   icprivate.tmAscent + icprivate.maxDescent,
   theCanvas.implpart.hdc,
   icprivate.theBrush)
     -> win32ClearArea;
#)
--TextShapeInteractiveCreateBodySetFontAndLine: descriptor--
(#
do    theCanvas.implpart.theWin32Fonts[] -> icprivate.theWin32Fonts[];
   
   (if icprivate.theWin32Fonts[]<>NONE then
       (textprivate.theFontName, textprivate.theStyle, textprivate.theSize) 
         -> icprivate.theWin32Fonts.theFontTable.find -> icprivate.theWin32Font[];
       (if icprivate.theWin32Font[]=NONE then
           (theCanvas.implpart.hdc, 
           textprivate.theFontName,textprivate.theStyle,textprivate.theSize)
             -> icprivate.theWin32Fonts.createWin32Font;
           (textprivate.theFontName,textprivate.theStyle,textprivate.theSize) 
             -> icprivate.theWin32Fonts.theFontTable.find 
             -> icprivate.theWin32Font[];
           
           (if icprivate.theWin32Font[]=NONE then
               (if displayWarnings then
                   'Could not find font in TextShapeInteractiveCreateBody.' 
                     -> screen.putLine;
               if);
               &win32Font[] -> icprivate.theWin32Font[];
               ANSI_VAR_FONT -> GetStockObject -> icprivate.theWin32Font.hFont;
           if);
       if);
    else
       (if displayWarnings then
           'Could not find icprivate.theWin32Fonts in TextShapeInteractiveCreateBody.' 
             -> screen.putLine;
       if);
       &win32Font[] -> icprivate.theWin32Font[];
       ANSI_VAR_FONT -> GetStockObject -> icprivate.theWin32Font.hFont;
   if);
   
   56 -> malloc -> icprivate.infoPtr;
   (if icprivate.infoPtr = 0 then 
       (if displayWarnings then
           'WARNING: 56 -> malloc -> icprivate.infoPtr; failed in TextShapeInteractiveCreateBody.' 
             -> screen.putLine;
       if);
   if);
   4 -> malloc -> icprivate.tempCharWidth;
   (if icprivate.tempCharWidth = 0 then
       (if displayWarnings then
           'WARNING: 4 -> malloc-> icprivate.tempCharWidth; failed in TextShapeInteractiveCreateBody.' 
             -> screen.putLine;
       if)
   if);
   
   (theCanvas.implpart.hdc,icprivate.theWin32Font.hFont) -> SelectObject -> icprivate.oldFont;
   
   getOsVersionId -> icprivate.osVersionId;
   (theCanvas.implpart.hdc,icprivate.infoPtr) -> GetTextMetrics;  
   (if theCanvas.implpart.custumbackground then
       (if theCanvas.implpart.backGroundColorSet then
           theCanvas.implpart.backGroundColor -> CreateSolidBrush -> icprivate.theBrush;
        else
           (if theCanvas.implpart.backGroundBitmapSet then
               
           if);
       if);
    else
       COLOR_BTNFACE -> GetSysColor -> CreateSolidBrush -> icprivate.theBrush;
   if);
   
   (%getLongAt (icprivate.infoPtr + textmetricTmDescentOffset)) -> icprivate.maxDescent;
   (%getLongAt (icprivate.infoPtr + textmetricTmAscentOffset)) -> icprivate.tmAscent;
#)
--TextShapeInteractiveCreateBodyFontAscent: dopart--
do icprivate.tmAscent -> value
--TextShapeInteractiveCreateBodyCleanUp: descriptor--
(# 
do (theCanvas.implpart.hdc,icprivate.oldFont) -> SelectObject;
   icprivate.infoPtr -> free;
   icprivate.tempCharWidth -> free;
   icprivate.theBrush -> DeleteObject;
#)

-- TextShapeHiliteOutlineBody: descriptor --
(# pos: @point;
   length: @integer;
   
   BeginPath: external
     (# hdc: @integer;
        result: @integer;
     enter hdc
     do callStd
     exit result
     #);
   EndPath: external
     (# hdc: @integer;
        result: @integer;
     enter hdc
     do callStd
     exit result
     #);
   StrokePath: external
     (# hdc: @integer;
        result: @integer;
     enter hdc
     do callStd
     exit result
     #);
   StrokeAndFillPath: external
     (# hdc: @integer;
        result: @integer;
     enter hdc
     do callStd
     exit result
     #);
   lineheight: @integer;
do 
   (if TM[] = NONE then
       textprivate.position -> pos;
    else
       textprivate.position -> TM.transformpoint -> pos;
   if);
   pos -> Privatepart.Go2CanvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice -> pos;
   
   (theCanvas.implpart.hdc,TRANSPARENT) -> SetBkMode; 
   
   (* Need to select this(textShape)'s font !!!!!!*)
   (theCanvas[],
   textprivate.theFontName, textprivate.theStyle, textprivate.theSize) 
     -> SetWin32Font;
   (textprivate.theFontName, textprivate.theStyle, textprivate.theSize)
     -> TextLineHeight
     -> theCanvas.ZoomDim
     -> lineheight;
   
   textprivate.thestrings.scan
   (# 
   do (* Bracket begin a path *)
      theCanvas.implpart.hdc -> BeginPath; 
      current.length -> length;
      (if length > 0 then
          (if ((theCanvas.implpart.hdc, pos.x, pos.y,
              @@current.T[1],length) -> TextOut)=0 then
              (if displayWarnings then
                  'TextOut failed in TextShapeHiliteOutlineBody. ErrorCode= ' 
                    -> screen.putText;
                  GetLastError -> putInt; screen.newline;
              if);
          if)
      if);
      (* Bracket end a path *)
      theCanvas.implpart.hdc -> EndPath; 
      (* Draw the outline *)
      theCanvas.implpart.hdc -> StrokePath;
      pos.y+lineheight -> pos.y (* device coords *);
   #);
#)
