ORIGIN '../../Bifrost';
BODY 'MathImpl';
BODY 'DatatypesImpl';
BODY 'SegmentImpl';
BODY 'AbstractShapeImpl';
BODY 'ShapeImpl';
BODY 'PredefinedImpl';
BODY 'PaintImpl';
BODY 'GoImpl';
BODY 'PictureImpl';
BODY 'CanvasImpl';
BODY '../PS/EPSimpl';
INCLUDE 'debug';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '~beta/guienv/v1.4/private/guienvbody';
INCLUDE '~beta/guienv/v1.4/stddialogs';
MDBODY mac     '../Macintosh/BifrostMacImpl'
       ppc     '../Macintosh/BifrostMacImpl'
       ppcmac  '../Macintosh/BifrostMacImpl'
       nti     '../WinNT/BifrostWinNTimpl'
       default '../X11/BifrostX11impl';

-- BifrostAttributes: attributes --
blackpaint: 
  (# black: ^SolidColor;
  do &solidcolor[]->black[];
     black.init; (* default (0,0,0) rgb values *)
  exit black[]
  #);

-- SegmentAttributes: attributes --

(* calculates offsets used in strokeshape... *)
CalculateOffset:
  (# p1,p2,p3: @Point;
     offset: @Point;
  enter (p1,p2,p3)
  do <<SLOT SegmentCalculateOffset: descriptor>>;
  exit offset
  #);

-- AShapeAttributes: attributes --

recalculatePrivatePart:
  (# theCanvas: ^BifrostCanvas;
  enter theCanvas[]
  do <<SLOT AShapeRecalculatePrivatePartBody: descriptor>>
  #);

ListOfSegments: <<SLOT segmentList: descriptor>>;

-- AShapePrivatePartBody: descriptor --
(# 
   segmentList: ^ListOfSegments;
   
   startPoint: @Point;
   go2canvasTM: @ (* transformation from my GO to the BifrostCanvas *)
     (# m: ^matrix;
        set: @
          (# newm: ^matrix
          enter newm[]
          do (if debugGraphic then
                 THIS(AbstractShape)[] -> getpatternname -> puttext;
                 ' go2canvasTM changed FROM'->putline;
                 m[] -> putmatrix; 
                 'TO' -> putline;
                 newm[] -> putmatrix;
             if);
             newm[] -> m[];
          #);
     enter set
     exit m[]
     #);
   
   invalid: @boolean;
   boundinvalid: @boolean;
   
   bound: @rectangle;
   controls: @PointArray;
   
   closed: @Boolean;  (* true if the shape is closed *)
   makingSpline,containsSpline: @Boolean;
   containsOnlyCircularSplines: @Boolean;
   mySpline: ^SplineSegment;
   implPartType: << SLOT AShapeImplPrivatePart: descriptor >>;
   implPart: ^implPartType;
#)

-- AGOprivate: descriptor --
(# 
   parent: ^Picture;
   (* refers to the picture I am part of, e.g. the BifrostCanvas picture *)
   hilited, drawn: @Boolean;
   GetGOToCanvas: 
     (# theTM: ^matrix;
        targetGO: ^AbstractGraphicalObject;
     do 
        (if debugGraphic then 'GetGOToCanvas' -> putline; if);
        THIS(AbstractGraphicalObject)[] -> targetGO[];
        IDMAtrix -> theTM[];
        loop:
          (# do 
             (theTM[],targetGO.TM) -> MatrixMul -> theTM[];
             targetGO.private.parent[] -> targetGO[];
             (* get next in Picture hierarchy *)
             (if targetGO[]
              //NONE then leave loop;
              else restart loop;
             if);
          #);
        (if debugGraphic then 
            'GetGOToCanvas: matrix: ' -> putline;
            theTM[] -> putmatrix;
            'GetGOToCanvas DONE'->putline;
        if);
     exit theTM[]
     #);
#)

-- shapeattributes: attributes --
makeRegion:
  (# theCanvas: ^Bifrostcanvas;
     theRegion: @Integer;
  enter theCanvas[]
  <<SLOT shapeMakeRegion: dopart>>
  exit theRegion
  #);

-- CanvasPrivatePart: Descriptor --
(#
   damagedArea: @ <<SLOT canvasDamagedArea: descriptor>>;
   
   canvasdebug: @boolean;
   
   borderpaint, backgroundpaint: ^Paint;
   
   interactionPaint: ^Paint
     (* Used when interaction may be performed using a real paint;
      * this is e.g. the case for TextShape.interactivecreate.
      *);
#)


-- CanvasAttributes: attributes --

initPrivatePart:  << SLOT canvasInitPrivatePart : descriptor >>;

prepareInteraction: <<SLOT canvasPrepareInteractionBody: descriptor>>;

endInteraction: <<SLOT canvasEndInteractionBody: descriptor>>;

clearRect:
  (# r: @Rectangle;
  enter r
  <<SLOT canvasClearRectBody: dopart>> 
  #);


--BifrostUnImplemented: dopart--
do (if displayWarnings then
       'Sorry, '''->feature.prepend;
       ''' is not yet implemented' -> feature.append;
       (NONE, feature[], 'Unimplemented') -> AlertUser;
   if)
