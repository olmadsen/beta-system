ORIGIN '../../Bifrost';
BODY 'MathImpl';
BODY 'DatatypesImpl';
BODY 'SegmentImpl';
BODY 'AbstractShapeImpl';
BODY 'ShapeImpl';
BODY 'PredefinedImpl';
BODY 'PaintImpl';
BODY 'GoImpl';
BODY 'PictureImpl';
BODY 'CanvasImpl';
BODY '../PS/EPSimpl';
INCLUDE 'debug';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '~beta/guienv/private/guienvbody';
INCLUDE '~beta/guienv/stddialogs';
MDBODY mac     '../Macintosh/BifrostMacImpl'
       ppc     '../Macintosh/BifrostMacImpl'
       ppcmac  '../Macintosh/BifrostMacImpl'
       nti     '../WinNT/BifrostWinNTimpl'
       default '../X11/BifrostX11impl';

-- BifrostAttributes: attributes --
putWarnText: (# enter THIS(GUIenv).bifrostprivate.putWarnText #);
putWarnLine: (# enter THIS(GUIenv).bifrostprivate.putWarnLine #);
putWarnInt:  (# enter THIS(GUIenv).bifrostprivate.putWarnInt #);

blackpaint: 
  (# black: ^SolidColor;
  do &solidcolor[]->black[];
     black.init; (* default (0,0,0) rgb values *)
  exit black[]
  #);
TextListGetWidthHeight:
  (# theLines: ^TextList;
     nam: @Fontname;
     sty: @Style;
     siz: @Integer;
     width,height: @Integer;
  enter (theLines[], nam, sty, siz)
  do <<SLOT TextListGetWidthHeight: descriptor >>;
  exit (width,height)
  #);
TextGetWidth: IntegerValue
  (# T: ^Text;
     nam: @Fontname;
     sty: @Style;
     siz: @Integer;
  enter (T[], nam, sty, siz)
  do <<SLOT TextGetWidth: descriptor >>;
  #);
TextGetHeight: IntegerValue
  (# T: ^Text;
     nam: @Fontname;
     sty: @Style;
     siz: @Integer;
  enter (T[], nam, sty, siz)
  do <<SLOT TextGetHeight: descriptor >>;
  #);
TextLineHeight: IntegerValue
  (# nam: @Fontname;
     sty: @Style;
     siz: @Integer;
  enter (nam, sty, siz)
  <<SLOT TextLineHeight: dopart>>
  #);
TextMaxDescent: IntegerValue
  (# nam: @Fontname;
     sty: @Style;
     siz: @Integer;
  enter (nam, sty, siz)
  <<SLOT TextMaxDescent: dopart>>
  #);
TextMaxAscent: IntegerValue
  (# nam: @Fontname;
     sty: @Style;
     siz: @Integer;
  enter (nam, sty, siz)
  <<SLOT TextMaxAscent: dopart>>
  #);
TextUnderlineDepth: IntegerValue
  (# nam: @Fontname;
     sty: @Style;
     siz: @Integer;
  enter (nam, sty, siz)
  do <<SLOT TextUnderlineDepth: descriptor >>;
  #);


-- SegmentAttributes: attributes --

(* calculates offsets used in strokeshape... *)
CalculateOffset:
  (# p1,p2,p3: @Point;
     offset: @Point;
  enter (p1,p2,p3)
  do <<SLOT SegmentCalculateOffset: descriptor>>;
  exit offset
  #);

-- AShapeAttributes: attributes --

recalculatePrivatePart:
  (# theCanvas: ^BifrostCanvas;
  enter theCanvas[]
  do <<SLOT AShapeRecalculatePrivatePartBody: descriptor>>
  #);

ListOfSegments: <<SLOT segmentList: descriptor>>;

-- AShapePrivatePartBody: descriptor --
(# 
   segmentList: ^ListOfSegments;
   
   startPoint: @Point;
   go2canvasTM: @ (* transformation from my GO to the BifrostCanvas *)
     (# m: ^matrix;
        set: @
          (# newm: ^matrix
          enter newm[]
          do (if debugGraphic then
                 THIS(AbstractShape)[] -> getpatternname -> putwarntext;
                 ' go2canvasTM changed FROM'->putwarnline;
                 m[] -> putmatrix; 
                 'TO' -> putwarnline;
                 newm[] -> putmatrix;
             if);
             newm[] -> m[];
          #);
     enter set
     exit m[]
     #);
   
   invalid: @boolean;
   boundinvalid: @boolean;
   
   bound: @rectangle;
   controls: @PointArray;
   
   closed: @Boolean;  (* true if the shape is closed *)
   makingSpline,containsSpline: @Boolean;
   containsOnlyCircularSplines: @Boolean;
   mySpline: ^SplineSegment;
   implPartType: << SLOT AShapeImplPrivatePart: descriptor >>;
   implPart: ^implPartType;
#)

-- AGOprivate: descriptor --
(# 
   parent: ^Picture;
   (* refers to the picture I am part of, e.g. the BifrostCanvas picture *)
   hilited, drawn: @Boolean;
   GetGOToCanvas: 
     (# theTM: ^matrix;
        targetGO: ^AbstractGraphicalObject;
     do 
        (if debugGraphic then 'GetGOToCanvas' -> putwarnline; if);
        THIS(AbstractGraphicalObject)[] -> targetGO[];
        IDMAtrix -> theTM[];
        loop:
          (# do 
             (theTM[],targetGO.TM) -> MatrixMul -> theTM[];
             targetGO.private.parent[] -> targetGO[];
             (* get next in Picture hierarchy *)
             (if targetGO[]
              =NONE then leave loop;
              else restart loop;
             if);
          #);
        (if debugGraphic then 
            'GetGOToCanvas: matrix: ' -> putwarnline;
            theTM[] -> putmatrix;
            'GetGOToCanvas DONE'->putwarnline;
        if);
     exit theTM[]
     #);
#)

-- shapeattributes: attributes --
makeRegion:
  (# theCanvas: ^Bifrostcanvas;
     theRegion: @Integer;
  enter theCanvas[]
  <<SLOT shapeMakeRegion: dopart>>
  exit theRegion
  #);

-- CanvasPrivatePart: Descriptor --
(#
   damagedArea: @ <<SLOT canvasDamagedArea: descriptor>>;
   
   canvasdebug: @boolean;
   
   borderpaint, backgroundpaint: ^Paint;
   
   interactionPaint: ^Paint
     (* Used when interaction may be performed using a real paint;
      * this is e.g. the case for TextShape.interactivecreate.
      *);
   currentZoomFactor: @vector;
   unZoomedSize: @Point;
   (* END: Used for zooming purpose *)
#)


-- CanvasAttributes: attributes --

initPrivatePart:  << SLOT canvasInitPrivatePart : descriptor >>;

prepareInteraction: <<SLOT canvasPrepareInteractionBody: descriptor>>;

endInteraction: <<SLOT canvasEndInteractionBody: descriptor>>;

ZoomDim:
  (* Transform dim using THIS(BifrostCanvas).TM.
   * This only works because the X direction of the 
   * current platforms are identical to the X direction
   * of Bifrost coordinate systems.
   *)
  (# dim: @integer;
     o,z: @point;
  enter dim
  do (0,0)   -> CanvasToDevice -> o;
     (dim,0) -> CanvasToDevice -> z;
  exit (z.x-o.x)
  #);

clearRect:
  (# r: @Rectangle;
  enter r
  <<SLOT canvasClearRectBody: dopart>> 
  #);

--BifrostUnImplemented: dopart--
do (if displayWarnings then
       'Sorry, \''->feature.prepend;
       '\' is not yet implemented' -> feature.append;
       (NONE, feature[], 'Unimplemented') -> AlertUser;
       feature[] -> putwarnline;
   if)
