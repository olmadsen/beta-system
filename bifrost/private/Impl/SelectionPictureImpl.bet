ORIGIN '../../SelectionPicture';
INCLUDE 'BifrostImpl';

--SelectionPictureInit: dopart--
do (if theCanvas[]//NONE then
       (if displaywarnings then
           'SelectionPicture.init: theCanvas is NONE' -> putline;
       if)
   if);
   true -> private.hilited
   
--SelectionPictureCopy: descriptor--
(# p: ^SelectionPicture;
do INNER copy;
   (if aCopy[] // NONE then
       &SelectionPicture[] -> p[] -> aCopy[];
   if);
   aCopy[] -> p[];
   thecanvas[] -> p.thecanvas[];
#)

--SelectionPictureDraw: dopart--
do (if doneInInner // false then
       (if displayWarnings // true then
           'Error to draw a SelectionPicture!' -> putline;
           'The GOs should already be in a Canvas!' -> putline;
       if);
       true -> doneInInner;
   if);
   
--SelectionPictureErase: dopart--
do (if doneInInner // false then
       (if displayWarnings // true then
           'Error to erase a SelectionPicture!' -> putline;
       if);
       true -> doneInInner;
   if);
   
--SelectionPictureAdd: dopart--
do (if debugGraphic // true then
       'SelectionPicture.add: GOs: ' -> puttext;
       NoOfGOs -> putint; newline;
   if);
   (if NoOfGOs
    // 1 then (* only one selected; hilite controls of it *)
       go.theShape.hc[] -> go.theShape.drawHilite[];
       theCanvas[] -> go.hilite;
       onOneGO;
    // 2 then (* two selected; start to hilite outline *)
       theShape.ho[] -> theShape.drawhilite[];
       go.theShape.ho[] -> go.theShape.drawHilite[];
       theCanvas[] -> go.hilite;
       
       firstGO -> go[];
       theCanvas[] -> go.unhilite;
       go.theShape.ho[] -> go.theShape.drawHilite[];
       theCanvas[] -> go.hilite;
       onTwoGOs;
    else 
       (* more than two selected; hilite outline *)
       go.theShape.ho[] -> go.theShape.drawHilite[];
       theCanvas[] -> go.hilite;
   if);
   
--SelectionPictureDelete: dopart--
do (if debugGraphic // true then
       'SelectionPicure.delete: GOs: ' -> puttext; NoOfGOs -> putint; newline;
   if);
   theCanvas[] -> go.unhilite;
   go.theShape.hc[] -> go.theShape.drawHilite[];
   (if NoOfGOs
    // 0 then (* no more *)
       onEmpty;
    // 1 then (* only one remaining; hilite controls *)
       firstGO -> go[];
       theCanvas[] -> go.unhilite;
       go.theShape.hc[] -> go.theShape.drawHilite[];
       theCanvas[] -> go.hilite;
       theShape.hc[] -> theShape.drawhilite[];
       onOneGO;
   if);
   
--SelectionPictureClear: dopart--
do scanGOs(# do go[] -> delete #);
   idmatrix -> TM;
