ORIGIN '../../Bifrost';
-- PointArrayPrivate: descriptor --
(#
   points: [1] ^Point;  (* "dynamic" array; extended when needed *)
#)

-- PointArrayInitPoints: descriptor --
(# more: @integer;
do 
   0 -> npoints;
   (if initialsize//0 then
    else
       (0, initialsize-private.points.range) -> max -> more;
       (if more//0 then else more -> private.points.extend; if);
   if);
#)

-- PointArrayCopy: dopart --
do &PointArray[] -> p[];
   p.initPoints;
   (for i: npoints repeat
        i -> getpoint -> p.addpoint;
   for);
   
-- PointArrayAddPoint: descriptor --
(# pp: ^Point
do 
   (if (npoints<private.points.range)
    // True then
       &Point[] -> pp[];
       (p.x,p.y) -> (pp.x,pp.y);
       npoints+1 -> npoints;
       pp[] -> private.points[npoints][];
    // False then
       private.points.range  -> private.points.extend;
       (if debugGraphic//true then
           'PointArray extended' -> putline;
       if);
       &Point[] -> pp[];
       (p.x,p.y) -> (pp.x,pp.y);
       npoints+1 -> npoints;
       pp[] -> private.points[npoints][];
   if);
#)

-- PointArrayGetPoint: dopart --
do
   (-1,-1) -> p;
   (if (0<i) and (i<=npoints) //true then
       (if (private.points[i][] = NONE) //false then
           (private.points[i].x,private.points[i].y) -> p;
        else
           (if debugGraphic//true then
               'GetPoint: private.points[i] is NONE' -> putline;
           if);
       if);
    else
       'GetPoint: index ' -> puttext;
       i -> putint; ' out of range; npoints: ' -> puttext;
       npoints -> putint;
       newline;
   if);
   
-- PointArraySetPoint: descriptor --
(# pp: ^Point;
do
   (if (0<i) and (i<=npoints) //true then
       &Point[] -> pp[];
       (p.x,p.y) -> (pp.x,pp.y);
       pp[] -> private.points[i][];
    else
       'SetPoint: index ' -> puttext;
       i -> putint; ' out of range; npoints: ' -> puttext;
       npoints -> putint;
       newline;
   if);
#)

-- PointArrayFirstPoint: dopart --
do
   (if (npoints>0) // true then
       (private.points[1].x,private.points[1].y) -> exitPoint;
    else
       (0,0) -> exitPoint;
       (if debugGraphic//true then
           'FirstPoint: no points' -> putline;
       if);
   if);
   
-- PointArrayLastPoint: dopart --
do
   (if (npoints>0) // true then
       (private.points[npoints].x,private.points[npoints].y) -> exitPoint;
    else
       (0,0) -> exitPoint;
       (if debugGraphic//true then
           'LastPoint: no points' -> putline;
       if);
   if);
   
   (***** PointArrayList ****)
   
-- pointArrayListPrivate: descriptor --
(# pointarrays: @List(# element::< PointArray #) #)

-- pointArrayListAppend: dopart --
do p[] -> private.pointarrays.append;
   
-- pointArrayListScan: dopart --
do private.pointarrays.scan
   (# 
   do current[] -> p[];
      INNER scanPointArrays;
   #)
   
-- pointArrayListEmpty: dopart --
do private.pointarrays.empty -> value
   
   
-- IntegerListPrivate: descriptor --
(##)

-- IntegerListInit: dopart -- do
-- IntegerListLength: dopart -- do
-- IntegerListAppend: dopart -- do
-- IntegerListRemove: dopart -- do
-- IntegerListInsert: dopart -- do
-- IntegerListCopy: dopart -- do
