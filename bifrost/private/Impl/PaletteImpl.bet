ORIGIN '../../Palette';

-- PalettePrivate: descriptor --
(#
   GOs: @Picture;
   deltax,deltay: @integer;
   vertical: @boolean;
   x: @integer; (* current x insertion value of the palette *)
   y: @integer; (* current y insertion value of the palette *)
   noOfItems: @integer;
   defaulthilite: @Rect;
   paletteopen: @boolean;
   newselection: @integer;
   size: @point;
#)

-- PaletteGetSize: dopart --
do paletteprivate.size -> s
   
-- PaletteCanvasOnOpen: dopart --
do true -> Paletteprivate.paletteopen;
   THIS(Palette).selection -> hiliteitem;
   INNER;
   (if paletteprivate.vertical then
       (* Items have been added with negative y values *)
       (0,-paletteprivate.y) -> paletteprivate.GOs.move;
   if);

-- PaletteCanvasOnButtonPress: dopart --
do (* Determine what item the button has been pressed on *)
   (if paletteprivate.vertical then
       mousepos.y div Paletteprivate.deltay + 1 -> Paletteprivate.newselection;
    else
       mousepos.x div Paletteprivate.deltax + 1 -> Paletteprivate.newselection;
   if);
   (if Paletteprivate.newselection//THIS(Palette).selection then else
       Paletteprivate.newselection -> THIS(Palette).selection;
   if);
   INNER;

-- PaletteCheckNewSelection: dopart --
do (if ( (1<=ns) and (ns<=Paletteprivate.NoOfItems) ) then
       (if ns//value then else
           ns -> value;
           changed;
       if);
   if);

-- PaletteNoOfItems: dopart --
do paletteprivate.noofitems -> value 

-- PaletteNewFramePaint: descriptor --
(# b: @boolean
do 
   (* Change lines *)
   false -> b;
   paletteprivate.GOs.scanGOs
   (#
   do (if not b then
          f[] -> go.setpaint;
      if);
      not b -> b;
   #);
   f[] -> THIS(BifrostCanvas).borderpaint;
#)

-- PaletteNewGoPaint: descriptor --
(# b: @boolean
do
   false -> b;
   paletteprivate.GOs.scanGOs
   (#
   do (if b then
          g.copy -> go.setpaint;
      if);
      not b -> b;
   #);
#)

-- PaletteOpen: dopart --
do (if deltax//0 then 
       'Palette.open: must specify positive deltax' -> putline;
   if);
   (if deltay//0 then 
       'Palette.open: must specify positive deltay' -> putline;
   if);
   deltax -> paletteprivate.deltax;
   deltay -> paletteprivate.deltay;
   vertical -> paletteprivate.vertical;
   2 -> THIS(BifrostCanvas).Borderwidth;
   (if not vertical then
       (1,deltay) -> paletteprivate.size;
       deltay -> paletteprivate.y; 
    else
       (deltax,1) -> paletteprivate.size;
   if);
   blackpaint.init;
   (0,0,0) -> blackpaint.RGBvalues;
   paletteprivate.GOs.init;
   paletteprivate.GOs[]->THIS(BifrostCanvas).thePicture[];
   paletteprivate.defaulthilite.init;
   (0,deltay) -> paletteprivate.defaulthilite.upperleft
     -> paletteprivate.defaulthilite.theshape.hotspot;
   deltax-8 -> paletteprivate.defaulthilite.width;
   deltay-8 -> paletteprivate.defaulthilite.height;
   true -> paletteprivate.defaulthilite.theshape.stroked;
   3 -> paletteprivate.defaulthilite.theshape.strokeWidth;
   blackpaint[] -> paletteprivate.defaulthilite.setpaint;
   paletteprivate.defaulthilite[] -> paletteprivate.GOs.add;
   INNER;
   paletteprivate.size->THIS(BifrostCanvas).size;
   position -> THIS(BifrostCanvas).Position;

-- PaletteClose: dopart --
do false->paletteprivate.paletteopen;
   INNER;

-- PaletteAppend: descriptor --
(# r: @rectangle;
   L: ^Line;
do Paletteprivate.NoOfItems+1 -> Paletteprivate.NoOfItems;
   Paletteprivate.NoOfItems -> THIS(Palette).selection.value; 
   (* Default selection is number of last appended item *)
   
   (if GoPaint//NONE then else GoPaint.g.copy -> go.setpaint; if);
   
   (* center go in box *)
   go.getbounds -> r;
   (paletteprivate.x - r.x + (paletteprivate.deltax - r.width + 1)  div 2,
   paletteprivate.y - r.y + (r.height - paletteprivate.deltay + 1) div 2) -> go.move;
 
   (* grow *)
   (if not paletteprivate.vertical then
       (paletteprivate.size, (paletteprivate.deltax,0)) 
         -> AddPoints
         -> paletteprivate.size;
       paletteprivate.x+paletteprivate.deltax -> paletteprivate.x;
    else
       (paletteprivate.size, (0, paletteprivate.deltay))
         -> AddPoints
         -> paletteprivate.size;
       paletteprivate.y-paletteprivate.deltay -> paletteprivate.y;
   if);
   go[] -> paletteprivate.GOs.add;
   (if paletteprivate.paletteopen then 
       paletteprivate.size->THIS(BifrostCanvas).size
   if);
   (* Separator line *)
   &Line[] -> L[];
   L.init;
   (if framePaint // NONE then
       blackpaint[] -> L.setpaint;
    else
       framepaint.f[] -> L.setpaint; 
   if);
   (if paletteprivate.vertical then
       ((0,paletteprivate.y),(paletteprivate.deltax+1,paletteprivate.y))
         -> L.coordinates;
    else
       ((paletteprivate.x,0),(paletteprivate.x,paletteprivate.deltay+1))
         -> L.coordinates;
   if);
   L[] -> paletteprivate.GOs.add;
#)

-- PaletteHiliteDefault: descriptor --
(# pos: @integer;
   GB: @paletteprivate.defaulthilite.getbounds;
do (* default highlight of item no i *)
   
   (if not doneininner then
       GB -> THIS(BifrostCanvas).damaged;
       (if paletteprivate.vertical then
           (1-i)*paletteprivate.deltay -> pos;
           (4, pos-4) -> paletteprivate.defaulthilite.moveto;
        else
           (i-1)*paletteprivate.deltax -> pos;
           (pos+4, paletteprivate.deltay-4) -> paletteprivate.defaulthilite.moveto;
       if);
       GB -> THIS(BifrostCanvas).damaged;
       THIS(BifrostCanvas).repair;
   if)
#)

-- PaletteChanged: dopart --
do (if paletteprivate.paletteopen then
       THIS(Palette).selection -> hiliteitem;
       INNER changed;
   if);

