ORIGIN '../../Bifrost';
INCLUDE 'BifrostImpl';

(****************************** MATRICES ********************************)


-- InverseTransformPointMatrixBody: dopart --
do GetInverse; (* calculate matrix *)
   p1 -> inverse.transformPoint -> p2;

-- TransformRectangleMatrixBody: descriptor --
(# bottomRight: @Point;
do
   (* (if THIS(Matrix)[]//IDMatrix then r -> result;
    * else
    *)
   (r.x,r.y) -> transformPoint -> (result.x,result.y);
   (r.x+r.width,r.y-r.height) -> transformPoint -> bottomRight;
   (bottomRight.x-result.x) -> Abs -> result.width;
   (bottomRight.y-result.y) -> Abs -> result.height;
   (* if); *)
#)


-- InverseTransformRectangleMatrixBody: dopart --
do GetInverse;
   r -> inverse.transformRectangle -> result;


-- IDMatrixBody: dopart --
do (*graphicPrivatePart.IDM[] -> ID[]*)
   &Matrix[] -> ID[];
   1.0 -> ID.a;
   1.0 -> ID.d;

-- TransformPointMatrixBody: dopart --
do (* (if THIS(Matrix)[]//IDMatrix then p -> result
    *  else
    *)
   a*p.x + c*p.y + tx -> result.x;
   b*p.x + d*p.y + ty -> result.y;
   (* if); *)

-- MoveMatrixBody: dopart --
do itx -> tx;
   ity -> ty;
   1.0  -> a;
   1.0  -> d;
   0.0 -> b;
   0.0 -> c;

-- ScaleMatrixBody: dopart --
do 0.0 -> b;
   0.0 -> c;
   0.0 -> tx;
   0.0 -> ty;

-- RotateMatrixBody: dopart --
do theta -> cos ->  a;
   theta -> sin ->  b;
   -(theta -> sin) -> c;
   theta -> cos -> d;
   0.0 -> tx;
   0.0 -> ty;


-- MultiplyMatrixBody: dopart--
   (* res = A*B *)
do 
   (* (if A[]//IDMatrix then B[] -> res[]
    * else
    * (if B[]//IDMatrix then A[] -> res[]
    * else
    *)
   &Matrix[] -> res[];
   
   (* 
    * 	(if NONE
    * 	 // A[] then 'MatrixMul: A is NONE'->putline;
    * 	 // B[] then 'MatrixMul: B is NONE'->putline;
    * 	if);
    *) 
   
   A.a*B.a + A.b*B.c -> res.a;
   A.c*B.a + A.d*B.c -> res.c;
   A.tx*B.a + A.ty*B.c + B.tx -> res.tx;
   A.a*B.b + A.b*B.d -> res.b;
   A.c*B.b + A.d*B.d -> res.d;
   A.tx*B.b + A.ty*B.d + B.ty -> res.ty;
   (* if)
    * if);
    *)
   (if debuggraphic//true then
       'Matrix.multiply: '->putline;
       '----- A: -----' ->putline;
       A[] -> putmatrix;
       '----- B: -----' ->putline;
       B[] -> putmatrix;
       '----- Result of A*B: -----' ->putline;
       res[] -> putmatrix;
   if)

-- CalcInversematrixBody: descriptor --
(# det: @Real;
do 
   (if inverse[] // NONE then 
       (* (if THIS(Matrix)[]//IDMatrix then IDMatrix -> inverse[]
        * else
        *)
       &Matrix[] -> inverse[];
       a*d - b*c -> det;
       (if det=0.0 // true then
           (if debugGraphic//true then
               'InverseTransformPoint: NOT A TRANSFORMATION MATRIX' -> putline;
           if);
        else
           d div det -> inverse.a;
           -b div det -> inverse.b;
           -c div det -> inverse.c;
           a div det -> inverse.d;
           (c*ty - d*tx) div det -> inverse.tx;
           (b*tx - a*ty) div det -> inverse.ty;
       if);
   if);
#)

-- EllipseAngle: descriptor --
(# hrr, vrr: @real    (* horizontalradius, verticalradius as reals *)
do
   hr -> hrr;
   vr -> vrr;
   (if x//cx then
       (if y>=cy
        // true then
           pihalf -> a;
           1.0 -> sin_a;
        // false then
           pi+pihalf -> a;
           -1.0 -> sin_a;
       if);
       0.0 -> cos_a;
    else	      
       ((y-cy) div vrr) div ((x-cx) div hrr)-> atan -> a;
       (if true
        // x<cx then
           pi+a -> a;
        // x>cx then
           (if y<cy
            // true then
               2*pi+a -> a;
           if);
       if);
       a -> cos -> cos_a;
       a -> sin -> sin_a;
   if);
#)

-- CircleAngle: descriptor --
(# rx, ry: @real;
do
   (* No need to scale by r in both dimensions *)
   
   (if x//cx then
       (if y>=cy
        // true then
           pihalf -> a;
           1.0 -> sin_a;
        // false then
           pi+pihalf -> a;
           -1.0 -> sin_a;
       if);
       0.0 -> cos_a;
    else	      
       (y-cy) -> ry;
       (x-cx) -> rx;
       (ry div rx) -> atan -> a;
       (if true
        // x<cx then
           pi+a -> a;
        // x>cx then
           (if y<cy
            // true then
               2*pi+a -> a;
           if);
       if);
       a -> cos -> cos_a;
       a -> sin -> sin_a;
   if);
#)
 
