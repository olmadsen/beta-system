ORIGIN 'BifrostImpl';

(****************************** MATRICES ********************************)

-- MatrixInvalidate: descriptor --
(# do NONE-> private.inverse[] #)

-- MatrixPrivate: descriptor --
(# inverse: ^Matrix;#)

-- InverseTransformPointMatrixBody: dopart --
do p1 -> (GetInverse).transformPoint -> p2;

-- TransformRectangleMatrixBody: descriptor --
(# bottomRight: @Point;
   rr: ^Rectangle;
do
   (* (if THIS(Matrix)[]=IDMatrix then r -> result;
    * else
    *)
   (if debug then  
       r[]->rr[];
       'Transforming: (%i,%i,%i,%i)\n' ->
       putFormat(#
                do (rr.x, rr.y, rr.width, rr.height)->(i,i,i,i);
                #);
   if);
   (r.x,r.y) -> transformPoint -> (result.x,result.y);
   (r.x+r.width,r.y-r.height) -> transformPoint -> bottomRight;
   (* ikke ændret munus til plus. Før: (r.x+r.width,r.y-r.height) *)
   (bottomRight.x-result.x) -> Abs -> result.width;
   (bottomRight.y-result.y) -> Abs -> result.height;
   (* if); *)
   (if debug then  
       '  Transformedto: (%i,%i,%i,%i)\n' ->
       putFormat(#
                do (result.x, result.y, result.width, result.height)->(i,i,i,i);
                #);
   if);
#)


-- InverseTransformRectangleMatrixBody: dopart --
do r -> (GetInverse).transformRectangle -> result;


-- IDMatrixBody: dopart --
do (*graphicPrivatePart.IDM[] -> ID[]*)
   &Matrix[] -> ID[];
   1.0 -> ID.a;
   1.0 -> ID.d;

-- TransformPointMatrixBody: dopart --
do (* (if THIS(Matrix)[]=IDMatrix then p -> result
    *  else
    *)
   a*p.x + c*p.y + tx -> result.x;
   b*p.x + d*p.y + ty -> result.y;
   (* if); *)

-- MoveMatrixBody: dopart --
do itx -> tx;
   ity -> ty;
   1.0  -> a;
   1.0  -> d;
   0.0 -> b;
   0.0 -> c;

-- ScaleMatrixBody: dopart --
do 0.0 -> b;
   0.0 -> c;
   0.0 -> tx;
   0.0 -> ty;

-- RotateMatrixBody: dopart --
do theta -> cos ->  a;
   theta -> sin ->  b;
   -(theta -> sin) -> c;
   theta -> cos -> d;
   0.0 -> tx;
   0.0 -> ty;


-- MultiplyMatrixBody: dopart--
   (* res = A*B *)
do 
   (* (if A[]=IDMatrix then B[] -> res[]
    * else
    * (if B[]=IDMatrix then A[] -> res[]
    * else
    *)
   &Matrix[] -> res[];
   
   (* 
    * 	(if NONE
    * 	 = A[] then 'MatrixMul: A is NONE'->putwarnline;
    * 	 = B[] then 'MatrixMul: B is NONE'->putwarnline;
    * 	if);
    *) 
   
   A.a*B.a + A.b*B.c -> res.a;
   A.c*B.a + A.d*B.c -> res.c;
   A.tx*B.a + A.ty*B.c + B.tx -> res.tx;
   A.a*B.b + A.b*B.d -> res.b;
   A.c*B.b + A.d*B.d -> res.d;
   A.tx*B.b + A.ty*B.d + B.ty -> res.ty;
   (* if)
    * if);
    *)
   (if debuggraphic then
       'Matrix.multiply: '->putwarnline;
       '----- A: -----' ->putwarnline;
       A[] -> putmatrix;
       '----- B: -----' ->putwarnline;
       B[] -> putmatrix;
       '----- Result of A*B: -----' ->putwarnline;
       res[] -> putmatrix;
   if)

-- CalcInversematrixBody: descriptor --
(# det: @Real;
do 
   (if private.inverse[] = NONE then 
       &Matrix[] -> private.inverse[] -> inverse[];
       a*d - b*c -> det;
       (if det=0.0 then
           (if debugGraphic then
               'InverseTransformPoint: NOT A TRANSFORMATION MATRIX' -> putwarnline;
           if);
        else
           d div det -> inverse.a;
           -b div det -> inverse.b;
           -c div det -> inverse.c;
           a div det -> inverse.d;
           (c*ty - d*tx) / det -> inverse.tx;
           (b*tx - a*ty) / det -> inverse.ty;
       if);
   if);
#)

-- EllipseAngle: descriptor --
(# hrr, vrr: @real    (* horizontalradius, verticalradius as reals *)
do
   hr -> hrr;
   vr -> vrr;
   (if true
    //x=cx then
       (if y>=cy then
           pihalf -> a;
           1.0 -> sin_a;
        else
           pi+pihalf -> a;
           -1.0 -> sin_a;
       if);
       0.0 -> cos_a;
    // y=cy then
       (if x>=cx then
           0.0 -> a;
           1.0 -> cos_a;
        else
           pi -> a;
           -1.0 -> cos_a;
       if);
       0.0 -> sin_a; 
       
    // vr=0 then (* Ellipse has no height *)
       (y-cy/x-cx) -> atan -> a;
       0.0 -> cos_a; (* Actually undefined *)
       0.0 -> sin_a; (* Actually undefined *)
       
    // hr=0 then (* Ellipse has no width *)
       (x-cx/y-cy) -> atan -> a;
       0.0 -> cos_a; (* Actually undefined *)
       0.0 -> sin_a; (* Actually undefined *)
    else	
       ((y-cy) / vrr) / ((x-cx) / hrr)-> atan -> a;
       (if true
        // x<cx then
           pi+a -> a;
        // x>cx then
           (if y<cy then
               2*pi+a -> a;
           if);
       if);
       a -> cos -> cos_a;
               a -> sin -> sin_a;
   if);
#)

-- CircleAngle: descriptor --
(# rx, ry: @real;
do
   (* No need to scale by r in both dimensions *)
   
   (if true
    // x=cx then
       (if y>=cy then
           pihalf -> a;
           1.0 -> sin_a;
        else
           pi+pihalf -> a;
           -1.0 -> sin_a;
       if);
       0.0 -> cos_a;
    // y=cy then
       (if x>=cx then
           0.0 -> a;
           1.0 -> cos_a;
        else
           pi -> a;
           -1.0 -> cos_a;
       if);
       0.0 -> sin_a; 
    else	      
       (y-cy) -> ry;
       (x-cx) -> rx;
       (ry / rx) -> atan -> a;
       (if true
        // x<cx then
           pi+a -> a;
        // x>cx then
           (if y<cy then
               2*pi+a -> a;
           if);
       if);
       a -> cos -> cos_a;
       a -> sin -> sin_a;
   if);
#)
 
-- BifrostAttributes: attributes --
MiterLength:
  (* FIXME: The following is NOT yet complete!!!
   * Calculate the miter length given by the two lines with linewidth 
   * "width" from p1 to p2, and p2 to p3. 
   * The angle alpha is between the two vertora from p2 to p1 and p3, 
   * respectively.
   * Cuts of to bewel at angles below 10 degrees.
   * 
   *           p2_________p3
   *           /     P
   *        V / 
   *         /            
   *     p1 /      
   *)    
  (# p1, p2, p3: @point;
     width: @integer;
     VLen, PLen, alpha: @real;
     V,P: @Vector;
     miterlength, len: @Point;
  enter (p1, p2, p3, width)
  do (p1.x-p2.x) -> V.x;
     (p1.y-p2.y) -> V.y;
     (p3.x-p2.x) -> P.x;
     (p3.y-p2.y) -> P.y;
     (if true
      // (width=0)                   (* thinnest line *)
      // (width=1)                   (* thin line *)
      // (V.x=0)     and (V.y=0)     (* p1 and p2 coincide *)
      // (P.x=0)     and (P.y=0)     (* p2 and p3 coincide *)
      // (p1.x=p3.x) and (p1.y=p3.y) (* p1 and p3 coincide *)
         then (* No miter *)
         (0,0) -> len;
      else
         (* Calculate angle between lines *)
         (V.x * V.x + V.y * V.y) -> sqrt -> VLen;
         (P.x * P.x + P.y * P.y) -> sqrt -> PLen;
         (((V.x * P.x) + (V.y * P.y)) / (VLen * PLen)) -> acos -> alpha;
         (* 0 <= alpha <= pi according to acos(3M) *)
         
         (* calculate miter length *)
         (if (180*alpha)/pi < 10 then
             (* switch to bewel *)
             (0,0) -> len (* FIXME: should be calculated *)
          else
             (* See setmiterlimit in PostScript Reference Manual *)
             (* (width * ((alpha/2) -> sin) div 2) -> miterlength; *)
             (* FIXME: project miterlength into len - see SegmentCalculateOffset *)
         if)
     if)
  exit len
  #)
