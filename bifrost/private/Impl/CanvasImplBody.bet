ORIGIN 'CanvasImpl';
-- CanvasOpened: dopart --
do INNER;
   (if not thepicture.isEmpty then
       THIS(BifrostCanvas)[] -> thePicture.draw
   if);
   
-- CloseCanvas: dopart --
do INNER;

-- Canvasbuttonpressed: dopart --
do localposition -> mousepos;
   INNER;
   
-- Canvaskeypressed: dopart --
do (* Ch is found by uienv *)
   INNER;
   
-- CanvasFrameChanged: dopart --
do UpdateCoordinateSystem;
   INNER;
   
-- BifrostCanvasSetSize: doPart --
do (w,h) 
     -> privatepart.unZoomedSize
     -> THIS(Canvas).size (* Deliberately not THIS(BifrostCanvas).size *);
   
-- CanvasActivate: dopart --
do INNER
   
-- CanvasDeActivate: dopart --
do INNER
   

-- CreateCanvasBody: dopart --
do &Picture[] -> thePicture[]; thePicture.init;
   NONE -> visualShape[] -> clipShape[];
   (* visual and clipShape will be the size of 
    * the BifrostCanvas when it has been opened
    *)
   initprivatepart;
   INNER;

-- CanvasDeviceToCanvasBody: dopart --
do p1 -> TM.inverseTransformPoint -> p2;

-- CanvasToDeviceBody: dopart --
do p1 -> TM.transformPoint -> p2;

-- CanvasDrawDoBody: dopart --
do GO[]-> thePicture.add;
   THIS(BifrostCanvas)[] -> GO.draw; (* Tell GO to draw itself on me *)

-- CanvasEraseDoBody: dopart --
do aGO[] -> thePicture.delete;
   THIS(BifrostCanvas)[] -> aGO.erase; (* Tell GO to delete itself *)

-- CanvasScanGOs: dopart --
do thePicture.scanGOs
   (# 
   do go[] -> THIS(scanThePicture).go[];
      INNER scanThePicture 
   #);

-- CanvasScanGOsReverse: dopart --
do thePicture.scanGOsReverse
   (# 
   do go[] -> THIS(scanThePictureReverse).go[];
      INNER scanThePictureReverse
   #);

-- CanvasInteractiveCreateShape: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveCreateShape;

-- CanvasInteractiveCombineShape: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveCombineShape;

-- CanvasInteractiveMove: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveMove;

-- CanvasInteractiveRotate: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveRotate;
   
-- CanvasInteractiveScale: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveScale;

-- CanvasInteractiveReShape: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveReshape;

-- canvasBringForwardDoBody: dopart --
do aGO[] -> thePicture.bringForward;
   aGO.getBounds -> damaged;
   repair;

-- canvasSendBehindDoBody: dopart --
do aGO[] -> thePicture.sendBehind;
   aGO.getBounds -> damaged;
   repair;

-- CanvasHitControl: dopart --
do p -> aGO.hitControl -> res[]

-- CanvasHiliteDoBody: dopart --
do THIS(BifrostCanvas)[] -> GO.hilite;

-- CanvasUnHiliteDoBody: dopart --
do THIS(BifrostCanvas)[] -> GO.unhilite;

-- CanvasInteractionHandlerInit: dopart --
do prepareInteraction;
   TerminateCondition;
   SetImmediateLineWidth; (* Sets it to 0 *)
   INNER;

-- CanvasInteractionHandlerTerminate: dopart --
do INNER; endInteraction;

-- changecanvasborderpaint: dopart--
do p[] -> privatepart.borderpaint[];                       
   THIS(BifrostCanvas)[] -> p.setborderpaint;
   
-- canvasborderpaint: dopart--
do privatepart.borderpaint[] -> p[];
   
-- changecanvasbackgroundpaint: dopart--
do p[] -> privatepart.backgroundpaint[];
   THIS(BifrostCanvas)[] -> p.setbackgroundpaint;
   
-- canvasbackgroundpaint: dopart--
do privatepart.backgroundpaint[] -> p[];
   
-- ZoomFactorSetBody: descriptor --
(#
   s: @ScaleMatrix;
   newzoom: @real;
   t: @MoveMatrix;
   csize: @point;
   newTM: ^Matrix;
   zoomdebug: (# exit false #);
do
   (if THIS(BifrostCanvas).TM[] = NONE then
       UpdateCoordinateSystem;
   if);
   z -> privatePart.currentZoomFactor;
   (if zoomdebug then
       'Current TM of MainCanvas'->putwarnline;
       THIS(BifrostCanvas).TM[]->putMatrix;
   if);
   z->s;
   
   (s.a*privatePart.unZoomedSize.x,s.a*privatePart.unZoomedSize.y)
     -> csize
     -> THIS(Canvas).size (* Deliberately not THIS(BifrostCanvas).size *);
   (if zoomdebug then
       'Changing ZOOM to %i%% (real=%f, %f)\n\n' 
         -> putFormat (# do z.x->i; (z.x,z.y)->(f,f) #);
   if);
   IDMatrix -> newTM[]; 
   -1.0 -> newTM.d; 
   privatePart.unZoomedSize.y -> newTM.ty;
   (newTM[], s[]) -> MatrixMul -> THIS(BifrostCanvas).TM[];
   (* REFRESH all the CANVAS *)
   (0, privatePart.unZoomedSize.y, privatePart.unZoomedSize.x, 
   privatePart.unZoomedSize.y) -> THIS(BifrostCanvas).damaged;
   THIS(BifrostCanvas).repair;
#)

-- ZoomFactorGetBody: dopart --
do privatePart.currentZoomFactor -> z;

