ORIGIN 'BifrostImpl';

-- segmentList: descriptor --
List
(# element::< Segment;
      
   isFirst:
     (# cell: ^theCellType;
        s: ^Segment; b: @Boolean;
     enter s[]
     do (if (head->cell[])<>NONE then 
            cell.elm[]=s[] ->b;
        if);
     exit b
     #);
   
   isLast:
     (# cell: ^theCellType;
        s: ^Segment; b: @Boolean;
     enter s[]
     do (if (last->cell[])<>NONE then 
            cell.elm[]=s[] -> b
        if);
     exit b
     #);
   
   firstSegment: 
     (# cell: ^theCellType;
        s: ^Segment
     do (if (head->cell[])<>NONE then
            cell.elm[]->s[] 
        if)
     exit s[]
     #);
   
   lastSegment: 
     (# cell: ^theCellType;
        s: ^Segment
     do (if (last->cell[])<>NONE then
            cell.elm[]->s[]
        if)
     exit s[]
     #);

   lastSimpleSegment:
     (# s: ^Segment;
     do (if empty then 
            NONE -> s[];
         else 
            scanList: scanReverse
              (#
              do
                 (if (current##<>Shape##) then
                     current[] -> s[];
                     leave scanList;
                 if);
              #);
        if);
     exit s[]
     #);
   
   scan2Segments :
     (# seg1,seg2: ^Segment;
        next: ^theCellType;
     do iterate
        (#
        do current.elm[] -> seg1[];
           current.succ[] -> next[];
           loop:    (* don't return shape segments in seg2 *)
             (if (next[]<>NONE) then
                 (if next.elm## <= Shape## then
                     next.succ[] -> next[];
                     restart loop;
                 if);
             if);
           (if next[] // NONE then
               NONE -> seg2[];
            else 
               next.elm[] -> seg2[];
           if);
           INNER scan2segments;
        #)
     #);
#)
