ORIGIN 'BifrostImpl';
LIB_ITEM 'bifrost';
INCLUDE '~beta/basiclib/file';

(*** Raster ***)

-- RasterEnterHotspot: dopart --
do p -> rasterprivatepart.hotspot 

-- RasterExitHotspot: dopart --
do rasterprivatepart.hotspot -> p 

-- RasterCopy: dopart --
do INNER;
   (if aCopy[]=NONE then (* Not done in inner *)
       &Raster[] -> aCopy[];
   if);


-- RasterPrivatePart: descriptor --
(#
   width, height: @integer;
   hotspot: @point;
   changed: @boolean;
   indexOK: @boolean;
#)

-- RasterInitBody: dopart --
do width -> rasterprivatePart.width;
   height -> rasterprivatePart.height;
   true -> rasterprivatePart.changed;
   INNER;

-- RasterWidth: dopart --
do rasterprivatepart.width -> value; 

-- RasterHeight: dopart --
do rasterprivatepart.height -> value 

-- RasterPutPixel: dopart --
do (if not (((0<i) and (i<=rasterprivatepart.width))
       and ((0<j) and (j<=rasterprivatepart.height))
         -> rasterprivatepart.indexOK) then
       'Index error in PutPixel, ignoring request'->putwarnline;
   if);
   INNER;

-- RasterGetPixel: dopart --
do (if not (((0<i) and (i<=rasterprivatepart.width)) 
       and ((0<j) and (j<=rasterprivatepart.height)) 
         -> rasterprivatepart.indexOK) then
       'Index error in GetPixel, ignoring request'->putwarnline;
   if);
   INNER;

-- BitMapCopy: descriptor --
(# b: ^BitMap;
do (if aCopy[]=NONE then (* Not done in inner *)
       &BitMap[] -> b[];
       (* ... *)
       b[] -> aCopy[];
   if);
#)

-- BitMapWritePBM: dopart --
do 'Bitmap.WriteToPBMfile' -> UnImplemented;
   INNER;
   
-- BitMapReadPBM: descriptor --
(#
   pbm: @file(# myget: @get; myeos: @eos; mypeek: @peek; mygetint: @getint #);
   ch, type: @char;
   rawbits: @boolean;
   width, height: @integer;
   row: @integer;      (* Number of current row in pbm file *)
   pbmrow: [1]@char;
   pbmbytes: @integer; (* Each new row in a RAWBITS PBM file begins in a 
                        * new byte.
                        * pbmbytes is the number of bytes in a pbm row 
                        *)
   
   ConvertPBMrowToDevice: @<<SLOT BitmapConvertPBMrow: descriptor>>;
   
   toofew: 
     (#
     do 'Bitmap: ReadPBMfile: too few bits in "' ->putwarntext;
        pbmfilename[] -> putwarntext; '"' -> putwarnline;
     #);
   
   tooMany:
     (#
     do 'Bitmap: ReadPBMfile: too many bits in "' ->putwarntext;
        pbmfilename[] -> putwarntext; '"' -> putwarnline;
     #);
   
   readrawbits:
     (# inx, more: @integer;
     do (width+7) div 8  -> pbmbytes;
	pbmbytes - 1 -> more;
        (if more>0 then more -> pbmrow.extend; if);
        (if debugGraphic then
            'Pbmrow: range: ' ->putwarntext; pbmrow.range -> putwarnintline;
        if);
        1 -> inx;
	1 -> row;
        pbm.myget; (* skip one whitespace character *)
        loop:
          (if pbm.myeos then 
	      (if (inx>1) or (row<=height) then toofew if);
	      leave loop
           else
	      pbm.myget -> pbmrow[inx];
	      (if inx=pbmbytes then
	    	  ConvertPBMrowToDevice;
		  1 -> inx;
		  row+1 -> row;
		  (if row>height+1 then
		      skipblanks;
		      (if not pbm.myeos then toomany if);
		      leave loop;
		  if);
	       else
            	  inx+1 -> inx;
	      if);
              restart loop;
          if);
     #);
   
   readbits:
     (# inx, more: @integer;
     do width -> pbmbytes;
        pbmbytes - 1 -> more;
        (if more>0 then more -> pbmrow.extend; if);
        (if debugGraphic then
            'Pbmrow: range: ' ->putwarntext; pbmrow.range -> putwarnintline;
        if);
        1 -> inx;
	1 -> row;
        loop:
	  (#
	  do skipblanks;
             (if pbm.myeos then 
	         (if (inx>1) or (row<=height) then toofew if);
	         leave loop
              else
	         (if pbm.myget
		  // '1' then 1 -> pbmrow[inx]
 	          // '0' then 0 -> pbmrow[inx]
	          else 
                     'Bitmap: ReadPBMfile: unknown character in "' 
                       ->putwarntext;
                     pbmfilename[] -> putwarntext; 
                     '", row number ' -> putwarntext;
                     row -> putwarnintline;
                     'Substituting 0' -> putwarnline;
		     0->pbmrow[inx]
 	         if);
	         (if inx=pbmbytes then
	    	     ConvertPBMrowToDevice;
		     1 -> inx;
		     row+1 -> row;
		     (if row>height+1 then
		         skipblanks;
		         (if not pbm.myeos then toomany if);
		         leave loop;
		     if);
	          else
            	     inx+1 -> inx;
	         if);
                 restart loop;
             if);
	  #);
     #);
   
   skipblanks: @
     (# ch: @ char;
     do loop:
	  (#
	  do (if not pbm.myeos then
		 pbm.mypeek -> ch;
            	 (if ch -> ascii.isSpace then
                     pbm.myget; restart loop
                  else
                     (if ch='#' then pbm.getline; restart loop
                      else leave loop
                     if)
            	 if);
	     if);
	  #);
     #);
   
do (if ('nti_ms'->(&machine_type).equal)
       or ('nti_gnu'->(&machine_type).equal) then
       'Bitmap.BitMapReadPBMfile' -> UnImplemented;
    else
       (if pbmfilename[]<>NONE then
           (pbmfilename[], THIS(guienv).bifrostprivate.PH.currentDirectory)
             -> THIS(guienv).bifrostprivate.PH.convertFilePath
             -> pbm.name;
           pbm.openread;
           
           (* Find magical number *)
           skipblanks;
           pbm.myget -> ch;
           pbm.myget -> type;
           (if ch = 'P' then
               (if type
                // '1' then false -> rawbits
                // '4' then true -> rawbits;
                else
                   'Bitmap: ReadPBMfile: Wrong magical number in "' ->putwarntext;
                   pbmfilename[] -> putwarntext; '"' -> putwarnline;
               if)
            else
               'Bitmap: ReadPBMfile: Wrong magical number in "' ->putwarntext;
               pbmfilename[] -> putwarntext; '"' -> putwarnline;
           if);
           
           
           (* Find dimensions *)
           skipblanks;
           (if ('0' < pbm.mypeek) and (pbm.mypeek < '9') then
               pbm.myGetInt -> width;
            else
               'Bitmap: ReadPBMfile: Wrong width specification in "' ->putwarntext;
               pbmfilename[] -> putwarntext; '"' -> putwarnline;
           if);
           
           skipblanks;
           (if ('0' < pbm.mypeek) and (pbm.mypeek < '9') then
               pbm.myGetInt -> height;
            else
               'Bitmap: ReadPBMfile: Wrong height specification in "' 
                 ->putwarntext;
               pbmfilename[] -> putwarntext; '"' -> putwarnline;
           if);
           
           (width,height) -> init;
           
           (if rawbits then
               readrawbits
            else
               readbits;
           if);
           
           pbm.close;
       if)
   if)       
#)

(*** GrayMap ***)

-- GrayMapCalculate: dopart --
do INNER;
   'GrayMap.Calculate' -> UnImplemented;
   
-- InitGrayMapBody: dopart --
do INNER;
   'GrayMap.Init' -> UnImplemented;

-- GrayMapPutPixel: dopart --
do INNER;
   'GrayMap.PutPixel' -> UnImplemented;

-- GrayMapGetPixel: dopart --
do INNER;
   'GrayMap.GetPixel' -> UnImplemented;

-- GrayMapCopy: descriptor --
(# g: ^GrayMap;
do (if aCopy[]=NONE then (* Not done in inner *)
       &GrayMap[] -> g[];
       (* ... *)
       'GrayMap.Copy' -> UnImplemented;
       g[] -> aCopy[];
   if);
#)

-- GrayMapWritePGM: dopart --
do 'GrayMap.WriteToPGMfile' -> UnImplemented;
   
-- GrayMapReadPGM: dopart --
do 'GrayMap.ReadFromPGMfile' -> UnImplemented;
   
 
