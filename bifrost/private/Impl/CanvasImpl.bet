ORIGIN 'BifrostImpl';
-- CanvasOpened: dopart --
do INNER;
   (if thepicture.isEmpty//false then
       THIS(BifrostCanvas)[] -> thePicture.draw
   if);
   
-- CloseCanvas: dopart --
do INNER;

-- Canvasbuttonpressed: dopart --
do localposition -> mousepos;
   INNER;
   
-- Canvaskeypressed: dopart --
do (* Ch is found by uienv *)
   INNER;
   
-- CanvasFrameChanged: dopart --
do UpdateCoordinateSystem;
   INNER;

-- CanvasActivate: dopart --
do INNER
   
-- CanvasDeActivate: dopart --
do INNER
   
-- CanvasAttributes: attributes --

UpdateCoordinateSystem:
  (# s: @point;
  do size -> s;
     <<SLOT CanvasUpdateCoordImpl: descriptor>>;
     (if visualShape[] // NONE then
         &Shape[] -> visualShape[];
         visualShape[] -> clipShape[];
     if);
     
     (* clear the visible shape *)
     none -> visualShape.privatepart.SegmentList[];
     
     (* set visibleShape to size of the BifrostCanvas window *)
     (0,0) -> visualShape.open;
     (s.x,0) -> visualShape.lineto;
     (s.x,s.y) -> visualShape.lineto;
     (0,s.y) -> visualShape.lineto;
     visualShape.close;
     
     (* force recalculation of go's according to new coordinatesystem *)
     thepicture.scanGOs(# do go.theshape.invalidate #);
     
  #);

-- CreateCanvasBody: dopart --
do &Picture[] -> thePicture[]; thePicture.init;
   NONE -> visualShape[] -> clipShape[];
   (* visual and clipShape will be the size of 
    * the BifrostCanvas when it has been opened
    *)
   initprivatepart;
   INNER;

-- CanvasDeviceToCanvasBody: dopart --
do p1 -> TM.inverseTransformPoint -> p2;

-- CanvasToDeviceBody: dopart --
do p1 -> TM.transformPoint -> p2;

-- CanvasDrawDoBody: dopart --
do GO[]-> thePicture.add;
   THIS(BifrostCanvas)[] -> GO.draw; (* Tell GO to draw itself on me *)

-- CanvasEraseDoBody: dopart --
do aGO[] -> thePicture.delete;
   THIS(BifrostCanvas)[] -> aGO.erase; (* Tell GO to delete itself *)

-- CanvasScanGOs: dopart --
do thePicture.scanGOs(# do INNER scanThePicture  #);

-- CanvasScanGOsReverse: dopart --
do thePicture.scanGOsReverse(# do INNER scanThePictureReverse #);

-- CanvasInteractiveCreateShape: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveCreateShape;

-- CanvasInteractiveCombineShape: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveCombineShape;

-- CanvasInteractiveMove: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveMove;

-- CanvasInteractiveRotate: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveRotate;
   
-- CanvasInteractiveScale: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveScale;

-- CanvasInteractiveReShape: dopart --
do (THIS(BifrostCanvas)[],p,theModifier) -> GO.interactiveReshape;

-- canvasBringForwardDoBody: dopart --
do aGO[] -> thePicture.bringForward;
   aGO.getBounds -> damaged;
   repair;

-- canvasSendBehindDoBody: dopart --
do aGO[] -> thePicture.sendBehind;
   aGO.getBounds -> damaged;
   repair;

-- CanvasHitControl: dopart --
do p -> aGO.hitControl -> res[]

-- CanvasHiliteDoBody: dopart --
do THIS(BifrostCanvas)[] -> GO.hilite;

-- CanvasUnHiliteDoBody: dopart --
do THIS(BifrostCanvas)[] -> GO.unhilite;

-- CanvasInteractionHandlerInit: dopart --
do prepareInteraction;
   TerminateCondition;
   SetImmediateLineWidth; (* Sets it to 0 *)
   INNER;

-- CanvasInteractionHandlerTerminate: dopart --
do INNER; endInteraction;

-- changecanvasborderpaint: dopart--
do p[] -> privatepart.borderpaint[];                       
   THIS(BifrostCanvas)[] -> p.setborderpaint;
   
-- canvasborderpaint: dopart--
do privatepart.borderpaint[] -> p[];
   
-- changecanvasbackgroundpaint: dopart--
do p[] -> privatepart.backgroundpaint[];
   THIS(BifrostCanvas)[] -> p.setbackgroundpaint;
   
-- canvasbackgroundpaint: dopart--
do privatepart.backgroundpaint[] -> p[];


