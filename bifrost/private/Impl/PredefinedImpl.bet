ORIGIN 'BifrostImpl';
LIB_ITEM 'bifrost';
BODY '../Predefined/TextImpl'
'../Predefined/RectImpl'
'../Predefined/EllipseImpl'
'../Predefined/PieImpl'
'../Predefined/LineImpl'
'../Predefined/MultilineImpl'
'../Predefined/ArcImpl';

(*********************** PREDEFINED SHAPE ********************************)

-- BifrostAttributes: attributes --
distanceToLine: (* algorithm from Graphical Gems II, p. 10-13 *)
  (# A, B, P: @point;
     idist: (* algorithm from Graphical Gems, p. 427-431 *)
       (# X, Y: @point; res: @integer
       enter (X, Y)
       do Y.x-X.x->abs->Y.x;
          Y.y-X.y->abs->Y.y;
          Y.x+Y.y-(((Y.x,Y.y)->min) div 2)->res;
       exit res
       #);
     d1: (* algorithm from Graphical Gems II, p. 10-13 *)
       (# a2: @integer; res: @integer
       do (P.y-A.y)*(B.x-A.x)-(P.x-A.x)*(B.y-A.y)->abs->a2;
          (((B.x-A.x)->abs)+((B.y-A.y)->abs)
          -((((B.x-A.x)->abs,(B.y-A.y)->abs)->min) div 2))->res;
          (if res <> 0 then a2 div res->res if)
       exit res
       #);
     d2: @integer;
  enter (A, B, P)
  do (if (P.x-A.x)*(B.x-A.x) + (P.y-A.y)*(B.y-A.y)<0 then
         (A,P)->idist->d2
      else
         (if (B.x-P.x)*(B.x-A.x) + (B.y-P.y)*(B.y-A.y)<0 then
             (B,P)->idist->d2
          else
             d1->d2
         if)
     if)
  exit d2
  #);

-- PrePrivate: descriptor --
(#
   calculatedShape: ^Shape; (* Caching of calculated approximating Shape*)
#)

-- PreShapeInvalidate: dopart --
do INNER;
   
-- PreShapeExitShape: dopart --
do preprivate.calculatedshape.copy -> s[] 
   
-- PreShapeContainsPoint: dopart --
do INNER;
   
-- PreShapeTransform: descriptor --
(# b: @boolean;
do 
   (* (if m[]<>IDmatrix then *)
   (m.a = 1.0) -> b;
   (m.b = 0.0) and b -> b;
   (m.c = 0.0) and b -> b;
   (m.d = 1.0) and b -> b;
   (if not b then
       'Warning: Attempt to rotate/scale a PredefinedShape (' -> putwarntext;
       THIS(PredefinedShape)[] -> getpatternname -> putwarntext;
       ').' -> putwarnline;
       'PredefinedShapes are only guarantied to be moveable!' -> putwarnline;
   if);
#)


(*********************** STROKEABLE SHAPE ********************************)

-- StrokeableGetBounds: dopart --
do INNER;
   (if privatepart.boundinvalid then
       (if stroked then
           (privatepart.bound, (strokewidth+1) div 2) -> ExpandRectangle 
             -> privatepart.bound;
       if);
       false -> privatepart.boundinvalid;
   if);
   
   
-- StrokeableCopyBody: descriptor --
(# str: ^StrokeableShape;
do (if aCopy[]=NONE then (* Not done in inner *)
       'Copy: Attempt to instantiate StrokeableShape'
         -> putwarnline;
    else
       aCopy[] -> str[];
       stroked -> str.stroked;
       strokewidth -> str.strokewidth;
   if);
#)
