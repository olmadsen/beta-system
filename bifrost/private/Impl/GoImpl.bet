ORIGIN './BifrostImpl';
(*
 * GoImpl.bet:
 *
 * 
 *
 *)

(******************** AbstractGraphicalObject *****************************)

-- AGOInitBody: dopart --
do	
   &ShapeDesc[] -> theShape[];
   theShape.open;
   (* theShape.Invalidate; *)
   IDMatrix -> TM;
   INNER
   
-- AGOCalcCanvasTM: dopart --
do INNER;
   theTM[] -> theShape.privatePart.go2CanvasTM;

-- AGOEnterTM: dopart --
do Private.GetGOtoCanvas -> TheShape.PrivatePart.Go2CanvasTM;
   TheShape.Invalidate;
   INNER


-- AGOCopyBody: dopart --
do INNER;
   (if ACopy[]//NONE Then (* Not done In Inner *)
       (if DisplayWarnings//True Then
           'Copy: Attempt To Instantiate AbstractGraphicalObject'-> Putline;
       if);
    else (* aCopy was instantiated in subpattern *)
       (if ACopy.TheShape[]//NONE Then
           (* acopy.theShape was not created in subpattern *)
           ACopy.Init;
           (if TheShape[]=NONE
            // False Then TheShape.Copy -> ACopy.TheShape[];
            // true then 
               (if DebugGraphic//True Then
                   'GO Copy: Shape Is None' -> Putline;
               if);
               &ShapeDesc[] -> TheShape[];
               &ShapeDesc[] -> ACopy.TheShape[];
           if);
       if);
       (if ThePaint[]=NONE 
        // false Then ThePaint.Copy -> ACopy.ThePaint[]
        // true then
           (if DebugGraphic//True Then
               'GO Copy: Paint Is None' -> Putline;
           if);
       if);
       TM -> ACopy.TM;
       Private.Hilited -> ACopy.Private.Hilited;
       Private.Drawn -> ACopy.Private.Drawn;
   if);
   
-- AGOMoveBody: descriptor --
(# m: @MoveMatrix;
do offset -> m;
   m[] -> transform;
#)

-- AGOMoveToBody: descriptor --
(# p: @Point;
do
   (* Where is hotspot now ? *)
   theShape.hotspot -> TM.m.transformPoint -> p;
   (* Move it as much as required *)
   (pos,p) -> subpoints -> move;
#)

-- AGOScaleBody: descriptor --
(# s: @ScaleMatrix;
do factor -> s;
   s[] -> transform;
#)

-- AGORotateBody: descriptor --
(# r: @RotateMatrix;
do angle -> r;
   r[] -> transform;
#)

-- AGOHitControlBody: descriptor --
(# hotSpots: ^PointArray;
   p: @Point;
   r: @Rectangle;
do 
   (NONE,TM) -> theShape.GetControls -> hotSpots[];
   checkList:
     (# 
     do
        (for i:hotSpots.npoints repeat
             i -> hotSpots.getPoint -> p;
             (p.x-3, p.y+3, 6, 6)
               -> r;
             (if ((thePoint,r) -> PointInRect) // true then
                 p[] -> res[];
                 leave checkList;
             if); 
        for);
     #);
#)

-- AGODrawBody: dopart --
do (if DisplayWarnings then
       (if theCanvas[]//NONE then
           'No Canvas specified for graphical object (with shape '->puttext; 
           Theshape[] -> Getpatternname -> Puttext; ')' -> Putline;
       if);
   if);
   (if Thepaint[]//NONE Then
       (if DisplayWarnings//True Then
           Ascii.Bel -> Put;
           'No paint specified for graphical object (with shape '  -> Puttext;
           Theshape[] -> Getpatternname -> Puttext; ')' -> Putline;
           'Using Solid Black.' -> PutLine;
       if);
       blackpaint -> ThePaint[];
   if);
   INNER;
   true -> private.drawn;
   (if doneInInner//False Then
       (if Private.Hilited//True Then
           thecanvas.PrepareInteraction;
           (theCanvas[],True, NONE) -> TheShape.DrawHilite;
           thecanvas.EndInteraction;
       if);
   if);

-- AGOEraseBody: dopart --
do 	
   (if displayWarnings then
       (if theCanvas[]//NONE then
           'AbstractGraphicalObject.erase: no canvas specified'->putline;
       if)
   if);       
   (if doneInInner//False Then
       thecanvas[] -> Unhilite;
       GetBounds -> thecanvas.Damaged;
       thecanvas.Repair;
       True -> doneInInner;
   if);


-- AGOIntersectsBody: dopart --
do INNER;
   'AbstractGraphicalObject.Intersects' -> UnImplemented;

-- AGOWithinBody: dopart --
do INNER;
   'AbstractGraphicalObject.Within' -> UnImplemented;

-- AGOgetbounds: dopart --
do INNER;
   (if doneInInner//False Then
       TheShape.GetBounds -> R;
   if);


-- AGOcontainsPoint: dopart --
do INNER;
   (if doneInInner//False Then 
       (thecanvas[],ThePoint) -> TheShape.ContainsPoint -> Value;
   if);


-- AGOTransform: dopart --
do 
   (TM,M[]) -> MatrixMul -> TM;
   (if Debuggraphic//True Then
       'AGOTransform: TM After:' -> Putline;
       TM -> Putmatrix;
   if);
   inner

-- AGOInteractiveCreateShape: dopart --
do (* Startpoint Is In BifrostCanvas Coords *)
   StartPoint 
     -> Theshape.Privatepart.Go2canvastm.M.InversetransformPoint 
     -> StartPoint;
   (* Startpoint Is In GO Coords *)
   INNER;
   (if doneInInner//False Then
       (theCanvas[], StartPoint, TheModifier) -> TheShape.InteractiveCreate;
       True -> doneInInner;
   if)

-- AGOInteractiveCombineShape: dopart --
do (* Startpoint Is In BifrostCanvas Coords *)
   StartPoint 
     -> Theshape.Privatepart.Go2canvastm.M.InversetransformPoint 
     -> StartPoint;
   (* Startpoint Is In GO Coords *)
   INNER;
   (if doneInInner//False Then
       (theCanvas[], StartPoint,TheModifier) -> TheShape.InteractiveCombine;
       True -> doneInInner;
   if)


-- AGOInteractiveReshape: descriptor --
(# hotSpots: ^PointArray;
   p: @Point;
   control: @boolean;
do (* Check that startpoint is a control point *)
   (NONE,TM) -> theShape.GetControls -> hotSpots[];
   check:
     (for i:hotSpots.npoints repeat
          i -> hotSpots.getPoint -> p;
          (if ((startpoint,p) -> EqualPoint) // true then
              true -> control;
              leave check;
          if); 
     for);
   (if control//false then
       (if displaywarnings//true then
           'AbstractGraphicalObject.InteractiveReshape: startpoint is not a controlpoint'
             -> putline;
           true -> doneInInner; (* hack *)
       if)
   if);
   
   (* startpoint is in BifrostCanvas coords *)
   startPoint 
     -> theshape.privatepart.go2canvastm.m.inversetransformPoint 
     -> startPoint;
   (* startpoint is in GO coords *)
   
   INNER InteractiveReshape;
   
   (if doneInInner//False Then
       (theCanvas[], StartPoint,TheModifier) -> TheShape.InteractiveReshape;
       True -> doneInInner;
   if)
#)

-- AGOInteractiveMove: descriptor --
(#
do (if doneInInner//false then
       thecanvas.InteractionHandler
       (# mousePoint: @Point;
          stopinteraction: @boolean;
          mm: @MoveMatrix;
          offset: @Point;
          myabs: @abs;
          
          Initialize::<
            (# 
            do (* Erase original highlight *)
               (if private.hilited//true then
                   (theCanvas[],false, NONE) -> theshape.drawhilite;
               if);
               (* Highlight outline *)
               (theCanvas[], true, NONE) -> theshape.ho;
               startPoint -> mousePoint;
            #);
          
          Motion::<
            (#
            do (* erase outline at old position *)
               offset -> mm;
               (theCanvas[], false, mm[]) -> theshape.ho;
               
               (* Find new offset and draw outline *)
               GetPointerLocation
                 -> thecanvas.DeviceToCanvas
                 -> mousePoint;
               (mousePoint.x-startpoint.x, mousePoint.y-startpoint.y)
                 -> offset;
               (if themodifier->isModifierOn
                // true then (* Constrain to orthogonal movements *)
                   (if (offset.y -> myabs) > (offset.x -> myabs)
                    // true then (* 90 degrees *) 0 -> offset.x;
                    // false then (* 0 degrees *) 0 -> offset.y;
                   if)
               if);
               offset -> mm;
               (theCanvas[], true, mm[]) -> theshape.ho;
            #);
          ButtonRelease::<
            (# do true -> stopinteraction #);
          TerminateCondition::<
            (# 
            do stopinteraction -> value;
            #);
          Terminated::<
            (# GB: @GetBounds;
            do (* Erase outline highlight *)
               (theCanvas[], false, NONE) -> theshape.ho;
               (if (offset.x<>0) or (offset.y<>0) 
                // true then
                   GB->thecanvas.damaged;
                   offset -> move;
                   GB->thecanvas.damaged;
               if);
               (* Restore original highlight *)
               (if private.hilited//true then 
                   (theCanvas[],false, NONE) -> theshape.drawHilite 
               if);
            #)
       #);
       thecanvas.repair;
       true -> doneInInner;
   if)
#)

-- AGOInteractiveScale: dopart --
do INNER;
   'AbstractGraphicalObject.InteractiveScale' -> UnImplemented;

-- AGOInteractiveRotate: dopart --
do INNER;
   'AbstractGraphicalObject.InteractiveRotate' -> UnImplemented;

-- AGOhiliteBody: dopart --
do (if theCanvas[]//NONE then
       (if displayWarnings then
           'AbstractGraphicalObject.Hilite: no canvas specified'->putline;
       if)
   if);
   INNER;
   (if doneInInner//False Then
       (if Private.Hilited//False Then
           True -> Private.Hilited;
           (if private.drawn//true then
               thecanvas.PrepareInteraction;
               (theCanvas[], True, NONE) -> TheShape.DrawHilite;
               thecanvas.EndInteraction;
               (* will be highlighted first time it is drawn *)
           if);
       if);
       True -> doneInInner;
   if);

-- AGOunhiliteBody: dopart --
do (if theCanvas[]//NONE then
       (if displayWarnings then
           'AbstractGraphicalObject.Unhilite: no canvas specified'->putline;
       if)
   if);
   INNER;
   (if doneInInner//False Then
       (if Private.Hilited//True Then
           False -> Private.Hilited;
           (if private.drawn//true then
               thecanvas.PrepareInteraction;
               (theCanvas[], False, NONE) -> TheShape.DrawHilite;
               thecanvas.EndInteraction;
            else
               (* will be unhighlighted first time it is drawn *)
           if)
       if);
       True -> doneInInner;
   if);




(******************** GraphicalObject ******************************)

-- UserDefGODrawBody: dopart --
do (theCanvas[],TheShape[]) -> ThePaint.FillShape;


-- UserDefGOCopyBody: dopart --
do INNER;
   (if ACopy[]//NONE Then (* Not done In Inner *)
       &GraphicalObject[] -> ACopy[];
   if);

-- UserDefRecalculateShapeBody: dopart --
do theCanvas[]->TheShape.RecalculatePrivatePart; 

-- UserDefGOHiliteBody: dopart --
do 

-- UserDefGOUnHiliteBody: dopart --
do 

