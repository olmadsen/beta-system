ORIGIN './BifrostImpl';
(*
 * GoImpl.bet:
 *
 * 
 *
 *)

(******************** AbstractGraphicalObject *****************************)

-- AGOInitBody: dopart --
do	
   &ShapeDesc[] -> theShape[];
   theShape.open;
   (* theShape.Invalidate; *)
   IDMatrix -> TM;
   INNER
   
-- AGOCalcCanvasTM: dopart --
do INNER;
   theTM[] -> theShape.privatePart.go2CanvasTM;
   
-- AGOEnterTM: dopart --
do Private.GetGOtoCanvas -> TheShape.PrivatePart.Go2CanvasTM;
   TheShape.Invalidate;
   INNER


-- AGOCopyBody: dopart --
do INNER;
   (if ACopy[]=NONE Then (* Not done In Inner *)
       'Copy: Attempt To Instantiate AbstractGraphicalObject'-> Putwarnline;
    else (* aCopy was instantiated in subpattern *)
       (if ACopy.TheShape[]=NONE Then
           (* acopy.theShape was not created in subpattern *)
           ACopy.Init;
           (if TheShape[]<>NONE Then
               TheShape.Copy -> ACopy.TheShape[]
            else
               (if DebugGraphic Then
                   'GO Copy: Shape Is None' -> Putwarnline;
               if);
               &ShapeDesc[] -> TheShape[];
               &ShapeDesc[] -> ACopy.TheShape[];
           if);
       if);
       (if ThePaint[]<>NONE then
           ThePaint.Copy -> ACopy.ThePaint[] 
        else
           (if DebugGraphic Then
               'GO Copy: Paint Is None' -> Putwarnline;
           if);
       if);
       TM -> ACopy.TM;
       Private.Hilited -> ACopy.Private.Hilited;
       Private.Drawn -> ACopy.Private.Drawn;
   if);
   
-- AGOMoveBody: descriptor --
(# m: @MoveMatrix;
do offset -> m;
   m[] -> transform;
#)

-- AGOMoveToBody: descriptor --
(# p: @Point;
do
   (* Where is hotspot now ? *)
   theShape.hotspot -> TM.m.transformPoint -> p;
   (* Move it as much as required *)
   (pos,p) -> subpoints -> move;
#)

-- AGOScaleBody: descriptor --
(# s: @ScaleMatrix;
do factor -> s;
   s[] -> transform;
#)

-- AGORotateBody: descriptor --
(# r: @RotateMatrix;
do angle -> r;
   r[] -> transform;
#)

-- AGOHitControlBody: descriptor --
(# hotSpots: ^PointArray;
   p: @Point;
   r: @Rectangle;
do 
   (NONE,TM) -> theShape.GetControls -> hotSpots[];
   checkList:
     (# 
     do
        (for i:hotSpots.npoints repeat
             i -> hotSpots.getPoint -> p;
             (p.x-3, p.y+3, 6, 6)
               -> r;
             (if ((thePoint,r) -> PointInRect) then
                 p[] -> res[];
                 leave checkList;
             if); 
        for);
     #);
#)

-- AGODrawBody: dopart --
do (if theCanvas[]=NONE then
       'No Canvas specified for graphical object (with shape '->putwarntext; 
       Theshape[] -> Getpatternname -> Putwarntext; ')' -> Putwarnline;
   if);
   (if Thepaint[]=NONE Then
       'No paint specified for graphical object (with shape '  -> Putwarntext;
       Theshape[] -> Getpatternname -> Putwarntext; ')' -> Putwarnline;
       'Using Solid Black.' -> Putwarnline;
       blackpaint -> ThePaint[];
   if);
   INNER;
   true -> private.drawn;
   (if not doneInInner Then
       (if Private.Hilited Then
           thecanvas.PrepareInteraction;
           (theCanvas[],True, NONE) -> TheShape.DrawHilite;
           thecanvas.EndInteraction;
       if);
   if);

-- AGOEraseBody: dopart --
do 	
   (if theCanvas[]=NONE then
       'AbstractGraphicalObject.erase: no canvas specified'->putwarnline;
   if);
   (if not doneInInner Then
       thecanvas[] -> Unhilite;
       GetBounds -> thecanvas.Damaged;
       thecanvas.Repair;
       True -> doneInInner;
   if);

-- AGOgetbounds: dopart --
do INNER;
   (if not doneInInner Then
       TheShape.GetBounds -> R;
   if);
   (if private.hilited then
       (* Make sure region for control points are updated too *)
       R.x-4 -> R.x;
       R.y+4 -> R.y;
       R.width+8 -> R.width;
       R.height+8 -> R.height;
   if);


-- AGOcontainsPoint: dopart --
do INNER;
   (if not doneInInner Then 
       (thecanvas[],ThePoint) -> TheShape.ContainsPoint -> Value;
   if);


-- AGOTransform: dopart --
do 
   (TM,M[]) -> MatrixMul -> TM;
   (if Debuggraphic Then
       'AGOTransform: TM After:' -> Putwarnline;
       TM -> Putmatrix;
   if);
   inner

-- AGOInteractiveCreateShape: dopart --
do (* Startpoint Is In BifrostCanvas Coords *)
   StartPoint 
     -> Theshape.Privatepart.Go2canvastm.M.InversetransformPoint 
     -> StartPoint;
   (* Startpoint Is In GO Coords *)
   INNER;
   (if not doneInInner Then
       (theCanvas[], StartPoint, TheModifier) -> TheShape.InteractiveCreate;
       True -> doneInInner;
   if)

-- AGOInteractiveCombineShape: dopart --
do (* Startpoint Is In BifrostCanvas Coords *)
   StartPoint 
     -> Theshape.Privatepart.Go2canvastm.M.InversetransformPoint 
     -> StartPoint;
   (* Startpoint Is In GO Coords *)
   INNER;
   (if not doneInInner Then
       (theCanvas[], StartPoint,TheModifier) -> TheShape.InteractiveCombine;
       True -> doneInInner;
   if)


-- AGOInteractiveReshape: descriptor --
(# hotSpots: ^PointArray;
   p: @Point;
   control: @boolean;
do (* Check that startpoint is a control point *)
   (NONE,TM) -> theShape.GetControls -> hotSpots[];
   check:
     (for i:hotSpots.npoints repeat
          i -> hotSpots.getPoint -> p;
          (if ((startpoint,p) -> EqualPoint) then
              true -> control;
              leave check;
          if); 
     for);
   (if not control then
       'AbstractGraphicalObject.InteractiveReshape: '
       'startpoint is not a controlpoint'
         -> putwarnline;
       true -> doneInInner; (* hack *)
   if);
   
   (* startpoint is in BifrostCanvas coords *)
   startPoint 
     -> theshape.privatepart.go2canvastm.m.inversetransformPoint 
     -> startPoint;
   (* startpoint is in GO coords *)
   
   INNER InteractiveReshape;
   
   (if not doneInInner Then
       (theCanvas[], StartPoint,TheModifier) -> TheShape.InteractiveReshape;
       True -> doneInInner;
   if)
#)

-- AGOInteractiveMove: descriptor --
(#
do (if not doneInInner then
       thecanvas.InteractionHandler
       (# mousePoint: @Point;
          stopinteraction: @boolean;
          mm: @MoveMatrix;
          offset: @Point;
          myabs: @abs;
          
          Initialize::<
            (# 
            do (0,0) -> mm;
               (* Erase original highlight *)
               (if private.hilited then
                   (theCanvas[],false, NONE) -> theshape.drawhilite;
               if);
               (* Highlight outline *)
               (theCanvas[], true, NONE) -> theshape.ho;
               startPoint -> mousePoint;
            #);
          
          Motion::<
            (#
            do (* erase outline at old position *)
               offset -> mm;
               (theCanvas[], false, mm[]) -> theshape.ho;
               
               (* Find new offset and draw outline *)
               GetPointerLocation
                 -> thecanvas.DeviceToCanvas
                 -> mousePoint;
               (mousePoint.x-startpoint.x, mousePoint.y-startpoint.y)
                 -> offset;
               (if themodifier->isModifierOn then (* Constrain to orthogonal movements *)
                   (if (offset.y -> myabs) > (offset.x -> myabs) then 
                       (* 90 degrees *) 0 -> offset.x;
                    else
                       (* 0 degrees *) 0 -> offset.y;
                   if)
               if);
               offset -> mm;
               (theCanvas[], true, mm[]) -> theshape.ho;
            #);
          ButtonRelease::<
            (# do true -> stopinteraction #);
          TerminateCondition::<
            (# 
            do stopinteraction -> value;
            #);
          Terminated::<
            (# GB: @GetBounds;
            do (* Erase outline highlight *)
               (theCanvas[], false, mm[]) -> theshape.ho;
               (if (offset.x<>0) or (offset.y<>0) then
                   GB->thecanvas.damaged;
                   offset -> move;
                   GB->thecanvas.damaged;
               if);
               (* Restore original highlight at new position
                * Will also be done by Repair, though.
                *)
               (if private.hilited then 
                   (theCanvas[],false, NONE) -> theshape.drawHilite 
               if);
            #)
       #);
       thecanvas.repair;
       true -> doneInInner;
   if)
#)

-- AGOInteractiveScale: dopart --
do INNER;
   'AbstractGraphicalObject.InteractiveScale' -> UnImplemented;

-- AGOInteractiveRotate: dopart --
do INNER;
   'AbstractGraphicalObject.InteractiveRotate' -> UnImplemented;

-- AGOhiliteBody: dopart --
do (if theCanvas[]=NONE then
       'AbstractGraphicalObject.Hilite: no canvas specified'->putwarnline;
   if);
   INNER;
   (if not doneInInner Then
       (if not Private.Hilited Then
           True -> Private.Hilited;
           (if private.drawn then
               thecanvas.PrepareInteraction;
               (theCanvas[], True, NONE) -> TheShape.DrawHilite;
               thecanvas.EndInteraction;
               (* will be highlighted first time it is drawn *)
           if);
       if);
       True -> doneInInner;
   if);

-- AGOunhiliteBody: dopart --
do (if theCanvas[]=NONE then
       'AbstractGraphicalObject.Unhilite: no canvas specified'->putwarnline;
   if);
   INNER;
   (if not doneInInner Then
       (if Private.Hilited Then
           False -> Private.Hilited;
           (if private.drawn then
               thecanvas.PrepareInteraction;
               (theCanvas[], False, NONE) -> TheShape.DrawHilite;
               thecanvas.EndInteraction;
            else
               (* will be unhighlighted first time it is drawn *)
           if)
       if);
       True -> doneInInner;
   if);




(******************** GraphicalObject ******************************)

-- UserDefGODrawBody: dopart --
do (theCanvas[],TheShape[]) -> ThePaint.FillShape;


-- UserDefGOCopyBody: dopart --
do INNER;
   (if ACopy[]=NONE Then (* Not done In Inner *)
       &GraphicalObject[] -> ACopy[];
   if);

-- UserDefRecalculateShapeBody: dopart --
do theCanvas[]->TheShape.RecalculatePrivatePart; 

-- UserDefGOHiliteBody: dopart --
do 

-- UserDefGOUnHiliteBody: dopart --
do 

