ORIGIN '../Impl/MathImpl'

[[
-- INCLUDE 'MacBifrostEnv'

(****************************** MATRICES ********************************)

-- TransformPointMatrixBody: descriptor --
     (#
     do
(****
	a*p.x + c*p.y + tx -> result.x;
	b*p.x + d*p.y + ty -> result.y;
****)
        (if THIS(Matrix)[]//IDMatrix then p -> result
	 else
	    (((a,p.x->env.myint2real)->env.myrmul, (c,p.y->env.myint2real1)->env.myrmul1)-> env.myradd, tx) -> env.myradd1
					-> env.myReal2Int -> result.x;
	    (((b,p.x->env.myint2real)->env.myrmul, (d,p.y->env.myint2real1)->env.myrmul1)-> env.myradd, ty) -> env.myradd1
					-> env.myReal2Int -> result.y;
	if);
     #)


-- MoveMatrixBody: descriptor --
     (#
      do itx -> env.myInt2Real -> tx;
	 ity -> env.myInt2Real -> ty;
	 env.myrone  -> a;
	 env.myrone  -> d;
         env.myrzero -> b;
	 env.myrzero -> c;
     #)

-- ScaleMatrixBody: descriptor --
     (#
     do
        env.myrzero -> b;
	env.myrzero -> c;
	env.myrzero -> tx;
	env.myrzero -> ty;
     #)

-- RotateMatrixBody: descriptor --
     (#
     do 
	theta -> env.myrcos ->  a;
	theta -> env.myrsin ->   b;
	theta -> env.myrsin -> env.myrneg -> c;
	theta -> env.myrcos -> d;
	env.myrzero -> tx;
	env.myrzero -> ty;
     #)


-- MultiplyMatrixBody: descriptor--
     (# (* res = A*B *)
     do 
        (if A[]//IDMatrix then B[] -> res[]
	 else
         (if B[]//IDMatrix then A[] -> res[]
	 else
	    &Matrix[] -> res[];
(****
	A.a*B.a + A.b*B.c -> res.a;
	A.c*B.a + A.d*B.c -> res.c;
	A.tx*B.a + A.ty*B.c + B.tx -> res.tx;
	A.a*B.b + A.b*B.d -> res.b;
	A.c*B.b + A.d*B.d -> res.d;
	A.tx*B.b + A.ty*B.d + B.ty -> res.ty;

	(if NONE
	 // A[] then 'MatrixMul: A is NONE'->putline;
	 // B[] then 'MatrixMul: B is NONE'->putline;
	if);
*****)
 	     ((A.a,B.a )->env.myrmul, (A.b,B.c )->env.myrmul1) -> env.myradd  -> res.a;
	     ((A.c,B.a )->env.myrmul, (A.d,B.c )->env.myrmul1) -> env.myradd  -> res.c;
	    (((A.tx,B.a)->env.myrmul, (A.ty,B.c)->env.myrmul1) -> env.myradd, B.tx) -> env.myradd1  -> res.tx;
 	     ((A.a,B.b )->env.myrmul, (A.b,B.d )->env.myrmul1) -> env.myradd  -> res.b;
	     ((A.c,B.b )->env.myrmul, (A.d,B.d )->env.myrmul1) -> env.myradd  -> res.d;
	    (((A.tx,B.b)->env.myrmul, (A.ty,B.d)->env.myrmul1) -> env.myradd, B.ty) -> env.myradd1 -> res.ty;
	if)if);
    #)

-- CalcInversematrixBody: descriptor --
     (#  det: @Real;
     do 
	(if inverse[] // NONE then 
            (if THIS(Matrix)[]//IDMatrix then IDMatrix -> inverse[]
	    else
	    &Matrix[] -> inverse[];
            (* a*d - b*c -> det; *)
	    ((a,d)-> env.myrmul,(b,c)-> env.myrmul) -> env.myrsub -> det;
	    (if (det,env.myrzero) -> env.myrequal // true then
                (if debugGraphic//true then
 	        'InverseTransformPoint: NOT A TRANSFORMATION MATRIX' -> putline;
                if);
	    else
(*****
                  d div det -> inverse.a;
                 -b div det -> inverse.b;
                 -c div det -> inverse.c;
                  a div det -> inverse.d;
                 (c*ty - d*tx) div det -> inverse.tx;
                 (b*tx - a*ty) div det -> inverse.ty;
*****)
		 (d      ,det) -> env.myrdiv -> inverse.a;
		 (b->rneg,det) -> env.myrdiv -> inverse.b;
		 (c->rneg,det) -> env.myrdiv -> inverse.c;
		 (a      ,det) -> env.myrdiv -> inverse.d;
		 (((c,ty)->env.myrmul, (d,tx)->env.myrmul1)->env.myrsub, det) -> env.myrdiv -> inverse.tx;
		 (((b,tx)->env.myrmul, (a,ty)->env.myrmul1)->env.myrsub, det) -> env.myrdiv -> inverse.ty;
	     if);
	   if);
        if);
      #)

-- EllipseAngle: descriptor --
     (# hrr, vrr: @real    (* horizontalradius, verticalradius as reals *)
     do
	hr -> env.myint2real -> hrr;
	vr -> env.myint2real -> vrr;
	(if x//cx then
	    (if y>=cy
	     // true then
		pihalf -> a;
		env.myrone -> sin;
	     // false then
		(env.myrpi,pihalf) -> env.myradd -> a;
		env.myrone -> env.myrneg -> sin;
	    if);
	    0.0 -> cos;
	    
	else	      
	    ( ((y-cy)->env.myint2real,vrr) -> env.myrdiv,
	      ((x-cx)->env.myint2real1,hrr) -> env.myrdiv1  ) -> env.myrdiv2 -> env.myratan -> a;
	    
	    (if true
	     // x<cx then
		(env.myrpi, a) -> env.myradd -> a;
	     // x>cx then
		(if y<cy
		 // true then
		    (twopi, a) -> env.myradd -> a;
		if);
	    if);
	    a -> env.myrcos -> cos;
	    a -> env.myrsin -> sin;
	if);
     #)

-- CircleAngle: descriptor --
     (#
     do
	(* No need to scale by r in both dimensions *)
	
	(if x//cx then
	    (if y>=cy
	     // true then
		pihalf -> a;
		env.myrone -> sin;
	     // false then
		(env.myrpi,pihalf) -> env.myradd -> a;
		env.myrone -> env.myrneg -> sin;
	    if);
	    env.myrzero -> cos;
	    
	else	      
	    ( (y-cy)->env.myint2real,
	      (x-cx)->env.myint2real1  ) -> env.myrdiv -> env.myratan -> a;
	    
	    (if true
	     // x<cx then
		(env.myrpi, a) -> env.myradd -> a;
	     // x>cx then
		(if y<cy
		 // true then
		    (twopi, a) -> env.myradd -> a;
		if);
	    if);
	    a -> env.myrcos -> cos;
	    a -> env.myrsin -> sin;
	if);
     #)



--]]
