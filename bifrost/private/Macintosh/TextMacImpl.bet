ORIGIN '../Predefined/TextImpl';

INCLUDE 'BifrostMacImpl';
INCLUDE '~beta/maclib/maclib';
INCLUDE '~beta/guienv/graphics';
INCLUDE '~beta/guienv/private/macintosh/guienv_macprivate';
 
-- lib: attributes --

guienvRectangle: rectangle (# #);

-- TextShapeGetWidthHeight: descriptor --
(# st: @textStyle;
do (if nam
	  //times then 'times' -> st.name;
	  //courier then 'courier' -> st.name;
	  //helvetica then 'helvetica' -> st.name;
	if);
	siz -> st.size;
	st.lineHeight -> height;
	theText[] -> st.widthOfText -> width;
#)

-- TextShapeInteractiveCreateBody: descriptor --
(# mousePoint: @Point;
   theCh, prevCh: @Char;
   ChWidth, prevChWidth: @Integer;
   chArray: [1] @Char;
   curx, cury, uppery, maxx: @Integer;
   theString: ^Text;
   fontInfo: @
		(# theTextStyle: @textStyle;
			
			letterwidth: integerValue
				(# ch: @char;
				enter ch
				do ch -> theTextStyle.widthOfChar -> value;
				#);
			maxdescent: integerValue
				(#
				do theTextStyle.descent -> value;
				#);
			upos: integerValue
				(#
				do theTextStyle.ascent -> value;
				#);
			uthick: integerValue
				(#
				do 1 -> value;
				#);
		#);
	SetFontInfo:
		(# name, style, size: @integer;
			theCanvas: ^bifrostCanvas;
		enter (theCanvas[], name, style, size)
		do (if name
				//times then 'times' -> fontInfo.theTextStyle.name;
				//courier then 'courier' -> fontInfo.theTextStyle.name;
				//helvetica then 'helvetica' -> fontInfo.theTextStyle.name;
			if);
			size -> fontInfo.theTextStyle.size;
		exit (name, style, size)
		#); 
   excess: @integer;
   
   DrawInsertionMark:@
     (#
     do theCanvas.prepareInteraction;
        ((curx,cury-1 + fontInfo.maxdescent + excess), (curx,uppery-1))
          -> theCanvas.immediateline;
        theCanvas.endInteraction;
        theCanvas[] -> thecanvas.privatepart.interactionpaint.setcanvaspaint;
     #);
   
   LetterWidth: @
     (# ch: @Char;
     enter ch
     exit (ch -> fontInfo.letterwidth)
     #);
   
   DrawCh: @
     (#
     do theCanvas.graphics
	  			(# t: @text;
					r: @guienvRectangle;
				do ((curX, uppery - 1), (curX + ChWidth+1, uppery + size + excess + 1)) -> r;
					r[] -> makeMacRect -> EraseRect;
					(curX, curY) -> moveTo;
					fontinfo.theTextStyle[] -> style;
					t.clear;
					theCh -> t.put;
					t[] -> drawText;
				#);
        (*************
        (xdisplay, 
        theCanvas.implpart.xdrawable,
        curx, uppery, ChWidth+1, size+excess, 0) -> XClearArea;
        
        theCh -> chArray[1];
        (xdisplay, 
        theCanvas.implpart.xdrawable, 
        theCanvas.implpart.xgc,
        curx, cury,
        chArray, 1) -> XDrawString;
        
        (if textprivate.underline then	    
            (xdisplay,
            theCanvas.implpart.xdrawable, 
            theCanvas.implpart.xgc,
            curx,
            cury + THIS(guienv).private.fonts.
            xfonts[textprivate.theFontName].
            style[textprivate.theStyle].
            size[textprivate.theSize].upos,
            theCh -> letterwidth,
            THIS(guienv).private.fonts.
            xfonts[textprivate.theFontName].
            style[textprivate.theStyle].
            size[textprivate.theSize].uthick)
              -> XFillRectangle;
        if);
		  
		  *************)
     #);
   
   ClearPrevCh: @
     (#
     do theCanvas.graphics
	  			(# r: @guienvRectangle;
				do ((curX, uppery - 1), (curX + prevChWidth+1, uppery + size + excess + 1)) -> r;
					r[] -> makeMacRect -> EraseRect;
				#);
	  		(*********
        (xdisplay, 
        theCanvas.implpart.xdrawable,
        curx, uppery, prevChWidth+1, size+excess, 0) -> XClearArea;
		  *********)
     #);
   
do (* TextShapeInteractiveCreateBody *)
   (if theCanvas.privatepart.interactionpaint[]
    // NONE then
       (if displayWarnings then
           'TextShape: No paint specified for interaction - using solid black' 
             ->PutLine;
       if);
       blackPaint -> theCanvas.privatepart.interactionpaint[];
   if);
   
	
	
	
   (* Set font *)
		
   (theCanvas[], textprivate.theFontName, textprivate.theStyle, textprivate.theSize)
     -> SetFontInfo
     -> (textprivate.theFontName,textprivate.theStyle,textprivate.theSize);
   (*******
	THIS(guienv).private.fonts.
   xfonts[textprivate.theFontName].
   style[textprivate.theStyle].
   size[textprivate.theSize][] -> fontInfo[];
	*********)
   
   (* (0, fontInfo.upos + (fontInfo.uthick+1) div 2 - fontInfo.maxdescent) -> max -> excess; *)
	0 -> excess;
   
   (* Determine where to start *)
   (* startpoint is in GO coords *)
   
   (startPoint.x, startpoint.y - 8) (* 8 is half height of xterm cursor *)
     -> position
     -> theCanvas.canvastodevice
     -> (curx, cury);
   
   (* Now we work in device coords *)
   (* cury is ypos of baseline *)
   curx -> maxx;
   cury - size + fontInfo.maxdescent -> uppery;
   
   (* Set linewidth (for drawInsertionMark) *)
  (********
   (xdisplay, 
   theCanvas.implpart.xgc,
   0, 0, 0, 0) -> XSetLineAttributes;
	***********)
   
   DrawInsertionMark;
   textprivate.thestring[] -> theString[];
   
   open;
   
   (* Read letters *)
   theCanvas.interactionHandler
   (# stopinteraction: @boolean;
      
      buttonpress ::< (# do true -> stopinteraction #);
      
      terminateCondition ::<
        (# do stopinteraction -> value; #);
      
      keyPress ::<
        (#
        do (if ch->theCh
            // ascii.nl
            // ascii.cr then
               true -> stopinteraction;
            // ascii.bs
            // ascii.del then
               (if (theString.length>0) then
                   theString.length -> theString.inxGet -> prevCh;
                   (theString.length,theString.length)
                     -> theString.delete;
                   curx - (prevCh->LetterWidth->prevChWidth) -> curx;
                   ClearPrevCh;
                   DrawInsertionMark;
               if);
            else
               (if debugGraphic then ch -> put if);
               ch -> theString.put;
               DrawInsertionMark; (* Clear previous mark *)
               ch -> letterwidth -> ChWidth;
               DrawCh;
               curx + ChWidth -> curx;
               (curx, maxx) -> Max -> maxx;
               DrawInsertionMark;
           if);
        #);
   #);
   
   theCh -> lastCh;
   
   (TextPrivate.position.x,
   TextPrivate.position.y+size-fontInfo.maxdescent+1,
   maxx-startpoint.x+2,
   size+1+excess) -> theCanvas.damaged;
   theCanvas.repair;
   
#)

-- TextShapeInteractiveReshapeBody: doPart --
do 

-- TextShapeHiliteOutlineBody: descriptor --
(# pos: @point;
   itext: @theCanvas.immediateText;
do 
   (if TM[] // NONE then
       textprivate.position -> pos;
    else
       textprivate.position -> TM.transformpoint -> pos;
   if);
   pos -> Privatepart.Go2CanvasTM.m.transformPoint
     -> theCanvas.CanvasToDevice -> pos;
   
   (pos, 
   textprivate.theFontName,
   textprivate.theStyle,
   textprivate.theSize,
   underline,
   textprivate.thestring[]) -> itext;	
#)

-- TextShapeMaxDescent: doPart --
do (# st: @textStyle;
	do (if nam
	 	 	//times then 'times' -> st.name;
	  		//courier then 'courier' -> st.name;
	  		//helvetica then 'helvetica' -> st.name;
		if);
		siz -> st.size;
		st.descent -> desc;
	#)

-- TextShapeUnderlineDepth: descriptor --
(# do 'TextShapeUnderlineDepth: descriptor' -> putLine #)


