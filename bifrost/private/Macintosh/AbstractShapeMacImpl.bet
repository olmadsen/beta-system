ORIGIN '../Impl/AbstractShapeImpl';
INCLUDE 'BifrostMacImpl'

-- AShapeRecalculatePrivatePartBody: descriptor --
     (* recalculates the shape approximation, MacPolygon, and bound *)
     (# 
	   thePointList: ^PointArrayList;
	   aPoly: @Integer;
	   dummy: @Point;
	   firstPoint: @Boolean;
	   EndPoints: ^PointArray;
       firstFree, firstFreeEnds: @Integer;
	   (* minx,miny,maxx,maxy: @Integer; *)
	   aPolyPtr: @polygonPtr; mr: @macRect;
	   tmTODevice: ^Matrix;
	   left, top, right, bottom: @integer;
     do
        (* 2147483647  -> minx -> miny; (* MaxInt *)
	    (* -2147483647 -> maxx -> maxy; (* MinInt *)
	    &PointArrayList[] -> thePointList[];
	    (NONE, thePointList[]) -> calculatePoints;
		
	    (if thePointList.empty = false then
	        (if privatePart.implPart[] = NONE then
		       &privatePart.implPartType[] -> privatePart.implPart[];
	        if);
	      	1 -> firstFree -> firstFreeEnds;
			
			&PointArray[] -> endPoints[];
			32 -> endPoints.initPoints;
			(privatePart.go2canvasTM.m[],theCanvas.TM[])
	     		 -> MatrixMul -> tmToDevice[];
			(if privatePart.implPart.macPoly<>0  then 
				privatePart.implPart.macPoly -> KillPoly;
			if);
			(if privatePart.implPart.macRgn<>0  then 
				privatePart.implPart.macRgn -> DisposeRgn;
				0 -> privatePart.implPart.macRgn;
			if);
			OpenPoly -> aPoly;
			true -> firstPoint;
	        (* scan list of polygons in PointArray *)
			thePointList.scanPointArrays
	        (# lastPoint: @Point;
	      	do 
			   (if firstPoint then
			   	   false -> firstPoint;
				   1 -> p.GetPoint -> tmTODevice.transformPoint -> dummy -> moveto;
				   (for i:p.npoints-1 repeat
					  (if i=p.npoints-1 then
					      (* save the last point *)
					      i+1 -> p.GetPoint -> tmTODevice.transformPoint -> lastPoint -> lineto;
					   else
					      i+1 -> p.GetPoint -> tmTODevice.transformPoint -> dummy -> lineto;
					  if);
				   for);
			   else
				   (for i:p.npoints repeat
					  (if i=p.npoints then
					      (* save the last point *)
					      i -> p.GetPoint -> tmTODevice.transformPoint -> lastPoint -> lineto;
					   else
					  	  i -> p.GetPoint -> tmTODevice.transformPoint -> dummy -> lineto;
					  if);
				   for);
			   if);
	           firstFree + p.npoints -> firstFree;
	           lastPoint -> endPoints.addPoint;
	           firstFreeEnds + 1 -> firstFreeEnds;
	      	#);
	      	firstFreeEnds - 1 -> firstFreeEnds;  (* we don't want the last end point *)
	      	(for i:firstFreeEnds-1 repeat
	             firstFreeEnds-i -> endPoints.getpoint -> dummy -> lineto
	      	for);
			ClosePoly;
			aPoly -> privatePart.implPart.macPoly;
			
			(* update bound *) 
			aPoly -> aPolyPtr.initFromHandle;
			aPolyPtr.left -> left;
			aPolyPtr.top -> top ;
			aPolyPtr.right -> right;
			aPolyPtr.bottom -> bottom;
			(left,top,right - left,bottom - top)
			   -> theCanvas.TM.inverseTransformRectangle 
			   -> privatePart.bound;
			   
	      	firstFree + firstFreeEnds - 2 -> privatePart.implPart.NoOfPoints;
	    	false -> privatepart.boundinvalid;
	    	false -> privatepart.invalid;
	    else
	      	0 -> privatePart.implPart.NoOfPoints;
			0 -> privatePart.implPart.macPoly;
	      	(0,0,0,0) -> privatepart.bound;
                'ShapeRecalculatePrivatePart: empty shape' -> putwarnline;
	    if);
     #)

-- AShapeTransformRecalc: descriptor --
  (# xp: @Point;
  do
	(if (privatePart.implPart[]<>NONE) then
		(* map the poly instead !!!!!!!!! *)
		'MUST MAP MACPOLY, NYI' -> putwarnline;
		(*
		(for i:privatePart.implPart.noOfPoints-1 repeat
			1 -> privatePart.implPart.MacPoints.p[i].%getshort 
                           -> xp.y;
			0 -> privatePart.implPart.MacPoints.p[i].%getshort 
                           -> xp.x;
			xp -> m.transformPoint -> xp;
			(xp.y, 1)       
                           -> privatePart.implPart.MacPoints.p[i].%putshort;
			(xp.x, 0)       
                           -> privatePart.implPart.MacPoints.p[i].%putshort;
		for);
		*)
	if);
  #)

