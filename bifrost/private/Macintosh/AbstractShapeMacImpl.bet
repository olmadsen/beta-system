ORIGIN '../Impl/AbstractShapeImpl';
[[

-- INCLUDE 'GraphicsMacImpl'
-- INCLUDE 'MacBifrostEnv'

-- AShapeRecalculatePrivatePartBody: descriptor --
     (* recalculates the shape approximation, MacPolygon, and bound *)
     (# 
	   thePointList: ^PointArrayList;
	   aPoly: @Integer;
	   dummy: @Point;
	   firstPoint: @Boolean;
	   EndPoints: ^PointArray;
       firstFree, firstFreeEnds: @Integer;
	   (* minx,miny,maxx,maxy: @Integer; *)
	   aPolyPtr: @PolyPtr; macRect: @MacRectangle;
	   tmTODevice: ^Matrix;

     do
        (* 2147483647  -> minx -> miny; (* MaxInt *)
	    (* -2147483647 -> maxx -> maxy; (* MinInt *)
	    &PointArrayList[] -> thePointList[];
	    (NONE, thePointList[]) -> calculatePoints;
		
	    (if thePointList.empty // false then
	        (if privatePart.implPart[] // NONE then
		       &privatePart.implPartType[] -> privatePart.implPart[];
	        if);
	      	1 -> firstFree -> firstFreeEnds;
			
			&PointArray[] -> endPoints[];
			32 -> endPoints.initPoints;
			(privatePart.go2canvasTM.m[],graphicprivatepart.currentcanvas.TM[])
	     		 -> MatrixMul -> tmToDevice[];
			(if privatePart.implPart.macPoly<>0 // true then 
				privatePart.implPart.macPoly -> KillPoly;
			if);
			(if privatePart.implPart.macRgn<>0 // true then 
				privatePart.implPart.macRgn -> DisposeRgn;
				0 -> privatePart.implPart.macRgn;
			if);
			OpenPoly -> aPoly;
			true -> firstPoint;
	        (* scan list of polygons in PointArray *)
			thePointList.scanPointArrays
	        (# lastPoint: @Point;
			   devTransform: @tmTODevice.transformPoint;
	      	do 
			   (if firstPoint//true then
			   	   false -> firstPoint;
				   1 -> p.GetPoint -> devTransform -> dummy -> moveto;
				   (for i:p.npoints-1 repeat
					  (if i//p.npoints-1 then
					      (* save the last point *)
					      i+1 -> p.GetPoint -> devTransform -> lastPoint -> lineto;
					   else
					      i+1 -> p.GetPoint -> devTransform -> dummy -> lineto;
					  if);
				   for);
			   else
				   (for i:p.npoints repeat
					  (if i//p.npoints then
					      (* save the last point *)
					      i -> p.GetPoint -> devTransform -> lastPoint -> lineto;
					   else
					  	  i -> p.GetPoint -> devTransform -> dummy -> lineto;
					  if);
				   for);
			   if);
	           firstFree + p.npoints -> firstFree;
	           lastPoint -> endPoints.addPoint;
	           firstFreeEnds + 1 -> firstFreeEnds;
	      	#);
	      	firstFreeEnds - 1 -> firstFreeEnds;  (* we don't want the last end point *)
	      	(for i:firstFreeEnds-1 repeat
	             firstFreeEnds-i -> endPoints.getpoint -> dummy -> lineto
	      	for);
			ClosePoly;
			aPoly -> privatePart.implPart.macPoly;
			
			(* update bound *) 
			aPoly -> aPolyPtr.initFromHandle;
			aPolyPtr.polyBBox -> macRect;
			(macRect.left,macrect.top,macrect.width,macrect.height)
			   -> graphicPrivatePart.currentCanvas.TM.inverseTransformRectangle 
			   -> privatePart.bound;
			   
	      	firstFree + firstFreeEnds - 2 -> privatePart.implPart.NoOfPoints;
	    	false -> privatepart.boundinvalid;
	    	false -> privatepart.invalid;
	    else
	      	0 -> privatePart.implPart.NoOfPoints;
			0 -> privatePart.implPart.macPoly;
	      	(0,0,0,0) -> privatepart.bound;
	      	'ShapeRecalculatePrivatePart: empty shape' -> putline;
	    if);
     #)

-- AShapeTransformRecalc: descriptor --
  (# xp: @Point;
  do
  	(if env.macDebug//true then 'ShapeTransform ' -> puttext if);
	(if privatePart.implPart[]=NONE//false then
		(* map the poly instead !!!!!!!!! *)
		'MUST MAP MACPOLY, NYI' -> putline;
		(*
		(for i:privatePart.implPart.noOfPoints-1 repeat
			privatePart.implPart.MacPoints.p[i] -> TOS'%getshort[1]' -> xp.y;
			privatePart.implPart.MacPoints.p[i] -> TOS'%getshort[0]' -> xp.x;
			xp -> m.transformPoint -> xp;
			(@@privatePart.implPart.MacPoints.p[i],xp.y) 
		   		-> TOS'%putshort[1]';
			(@@privatePart.implPart.MacPoints.p[i],xp.x) 
		   		-> TOS'%putshort[0]';
		for);
		*)
	if);
  	(if env.macDebug//true then 'done' -> putline if);
  #)

--]]
