ORIGIN '../Impl/ShapeImpl';

INCLUDE 'BifrostMacImpl';
INCLUDE '~beta/guienv/graphics';

-- ShapeGetBounds: descriptor --
     (#
	 (* Separated from recalculateprivatepart to allow it to be called 
      *  when there is no graphicprivatepart.currentcanvas
      *)
		thePointList: ^PointArrayList;
		minx,miny,maxx,maxy: @Integer;

        updateBound:
        (# p: @Point;
	  	enter p
	 	do
	  	   (minx,p.x) -> Min -> minx;
	       (miny,p.y) -> Min -> miny;
	       (maxx,p.x) -> Max -> maxx;
	  	   (maxy,p.y) -> Max -> maxy
	  	#);

     do
        2147483647  -> minx -> miny; (* MaxInt *)
	    -2147483647 -> maxx -> maxy; (* MinInt *)

		&PointArrayList[] -> thePointList[];
		(NONE, thePointList[]) -> calculatePoints;
	
		(if not thePointList.empty then
	   	 	(* scan list of polygons in thePointlist *)
	   		thePointList.scanPointArrays
	    	(#
	    	do 
	       	   (for i:p.npoints repeat
		    		i->p.GetPoint -> privatePart.go2canvasTM.m.transformPoint 
				 		 -> updateBound;
	       	   for);	    
	    	#);
	    	    (minx,maxy,maxx-minx,maxy-miny) -> privatepart.bound;
	    	    false -> privatepart.boundinvalid;
		 else
                    'ShapeGetbounds: empty shape' -> putwarnline;
	    	    (0,0,0,0) -> privatepart.bound;
		if);
     #)

-- ShapeContainsPoint: descriptor --
(# r: @Integer; 
   m: @MacPoint;
   
do thePoint -> theCanvas.CanvasToDevice -> thePoint;
   theCanvas[] -> makeRegion -> r;
   (thePoint.x, thePoint.y) -> m.setpoint;
   
   (m,r) -> PtInRgn -> value;
#)


-- shapeMakeRegion: doPart --
do (if privatePart.implPart[] = NONE then 
		&privatePart.implPartType[] -> privatePart.implPart[];
	if);
	(if privatePart.implPart.macRgn = 0 then (* recalculate the region if the shape is changed *)
		(if privatePart.invalid then theCanvas[] -> recalculatePrivatePart if);
		NewRgn -> theRegion;
		OpenRgn;
		privatepart.implpart.macPoly -> FramePoly;
		theRegion -> CloseRgn;
		theRegion -> privatePart.implPart.macRgn;
	else
		privatePart.implPart.macRgn -> theRegion;
	if);

-- ShapeHiliteOutlineImplBody: descriptor --
theCanvas.graphics
	(# x, y: @Integer;
	do transferModes.xorBlend -> pen.mode;
		(if TM[]<> NONE then
			(firstpoint -> TM.transformpoint, firstpoint)
				-> subpoints -> (x,y);
		if);
		(privatepart.implpart.macPoly,x,-y) -> OffsetPoly;
		privatepart.implpart.macPoly -> FramePoly;
	
		(* move polygon back to original position *)
		(privatepart.implpart.macPoly,-x,y) -> OffsetPoly;
	
	#)

-- ShapeRubberCreateButtonBody: doPart --
do (if button = 1then (* LeftButton *)
       (if (startPoint,myShapeBegin) -> EqualPoint then
           (* erase the first line; it will be drawn in next pass *)
           (myShapeBegin, mousePoint) 
             -> theCanvas.immediateLine;   
       if);
       (if theModifier -> IsModifierOn then 
           mousePoint
             -> theCanvas.DeviceToCanvas 
             -> SplineTo;
        else 
           mousePoint -> theCanvas.DeviceToCanvas
             -> LineTo;
       if);
       mousePoint -> startPoint;
   if);










