ORIGIN '../Impl/ShapeImpl';
[[

-- INCLUDE 'GraphicsMacImpl'
-- INCLUDE 'MacBifrostEnv'

-- ShapeGetBounds: descriptor --
     (#
	 (* Separated from recalculateprivatepart to allow it to be called 
      *  when there is no graphicprivatepart.currentcanvas
      *)
		thePointList: ^PointArrayList;
		minx,miny,maxx,maxy: @Integer;

        updateBound:
        (# p: @Point;
	  	enter p
	 	do
	  	   (minx,p.x) -> Min -> minx;
	       (miny,p.y) -> Min -> miny;
	       (maxx,p.x) -> Max -> maxx;
	  	   (maxy,p.y) -> Max -> maxy
	  	#);

     do
        2147483647  -> minx -> miny; (* MaxInt *)
	    -2147483647 -> maxx -> maxy; (* MinInt *)

		&PointArrayList[] -> thePointList[];
		(NONE, thePointList[]) -> calculatePoints;
	
		(if thePointList.empty // false then
	   	 	(* scan list of polygons in thePointlist *)
	   		thePointList.scanPointArrays
	    	(#
	    	do 
	       	   (for i:p.npoints repeat
		    		i->p.GetPoint -> privatePart.go2canvasTM.m.transformPoint 
				 		 -> updateBound;
	       	   for);	    
	    	#);
	    	(minx,maxy,maxx-minx,maxy-miny) -> privatepart.bound;
	    	false -> privatepart.boundinvalid;
		else
            (if displayWarnings//true then
	        	'ShapeGetbounds: empty shape' -> putline;
            if);
	    	(0,0,0,0) -> privatepart.bound;
		if);
     #)

-- ShapeContainsPoint: descriptor --
  (# r: @Integer; m: @MacPoint;
  do 
	 thePoint -> graphicprivatepart.currentcanvas.CanvasToDevice -> thePoint;
	 makeRegion -> r;
     (m.R,2,thePoint.x) ->TOS'%inxPutShort';
	 (m.R,0,thePoint.y) ->TOS'%inxPutShort';
     (if (m,r) -> PtInRgn 
	  //macTrue then
	    true -> inside;
	  //macFalse then
	    false -> inside;
	 if);
  #)
  
-- ShapeIntersects: descriptor -- (# #)
-- ShapeWithin: descriptor -- (# #)

-- shapeMakeRegion: descriptor --
     (#
     do
		(if privatePart.implPart[]//NONE then 
		    &privatePart.implPartType[] -> privatePart.implPart[];
		if);
		(if privatePart.implPart.macRgn//0 then (* recalculate the region if the shape is changed *)
	    	(if privatePart.invalid//true then recalculatePrivatePart if);
			NewRgn -> theRegion;
			OpenRgn;
			privatepart.implpart.macPoly -> FramePoly;
			theRegion -> CloseRgn;
			theRegion -> privatePart.implPart.macRgn;
		else
			privatePart.implPart.macRgn -> theRegion;
		if);
	  #)

-- ShapeHiliteOutlineImplBody: descriptor --
  (# x,y: @Integer;
  do
	 (if TM[]//NONE then
	  else
  	     (firstpoint -> TM.transformpoint, firstpoint)
	        -> subpoints -> (x,y);
     if);
	 (privatepart.implpart.macPoly,x,-y) -> OffsetPoly;
	 privatepart.implpart.macPoly -> FramePoly;
	 
	 (* move polygon back to original position *)
	 (privatepart.implpart.macPoly,-x,y) -> OffsetPoly;

  #)

-- ShapeRubberCreateButtonBody: descriptor --
  (# x,y: @Integer;
  do
	 (if (startPoint,myShapeBegin) -> EqualPoint
	  // true then
	 (* erase the first line; it will be drawn in next pass *)
	     (myShapeBegin, mousePoint) -> graphicprivatepart.currentcanvas.immediateLine;   
	 if);
	 (if theModifier -> IsModifierOn
	  // True then 
	     mousePoint -> graphicprivatepart.currentcanvas.DeviceToCanvas -> (x,y);
		 (x,y) -> SplineTo;
	  else 
	  	 mousePoint -> graphicprivatepart.currentcanvas.DeviceToCanvas -> (x,y);
		 (x,y) -> LineTo;
	 if);
	 mousePoint -> startPoint;
  #)

--]]








