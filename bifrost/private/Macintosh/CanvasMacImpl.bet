ORIGIN '../Impl/CanvasImpl';


INCLUDE 'BifrostMacImpl';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '~beta/guienv/graphics';
INCLUDE '~beta/guienv/private/macintosh/guienv_macbody';

-- lib: attributes --

guienvPoint: point
	(#
	#);

-- CanvasAttributes: attributes --
immediateGraphics: graphics
	(#
	do transferModes.xorBlend -> pen.mode;
		INNER;
	#);
drawTheBorder:
	(#
	do graphics
			(#
			do implPart.bw -> pen.size;
				implPart.border -> pen.foreGroundColor;
				((0, 0), size) -> drawRect;
			#);
	#);
	 
-- canvasDamagedBody: descriptor --
(#
do (* deliberately empty *)
#)

-- canvasRepairBody: descriptor --
(#
do (* just update everything *)
	update;
#)

-- CanvasUpdateCoordImpl: descriptor --
(# 
do (if TM[]=NONE then
       &Matrix[] -> TM[];
       1.0  -> TM.a;
       -1.0 -> TM.d;
       0.0  -> TM.c;
       0.0  -> TM.b;
       0.0  -> TM.tx;
   if);
   s.y -> TM.ty;
#)
  
-- canvasInitPrivatePart: descriptor -- 
(# (* do nothing *) #)
	


-- canvasSetClipImplBody: descriptor --
(# do 'canvasSetClipImplBody: descriptor' -> unimplemented #)

-- canvasprepareInteractionBody: descriptor --
(# (* do nothing *)#)
  
-- canvasEndInteractionBody: descriptor --
(#  (* do nothing *) #)

-- canvasSetImmediateLineWidthBody: doPart  --
do (* not implemented *) 
  
  
-- CanvasImmediateSpot: doPart --
do immediateGraphics
		(#
		do ((center.x - 3, center.y - 3), (center.x + 3, center.y + 3)) -> fillRect;
		#);
-- canvasImmediateLineBody: doPart --
do immediateGraphics
		(#
		do (p1,p2) -> drawLine;
		#);
		
-- canvasImmediateDot: doPart --
do immediateGraphics
		(#
		do p1 -> drawSpot;
		#);
-- canvasImmediateMultiLineBody: descriptor --
immediateGraphics
	(# fiskx, fisky: @Integer;
	do (if p.npoints <> 0 then 
			1 -> p.GetPoint -> (fiskx, fisky);
			(fiskx,fisky) -> moveto;
			(for i:p.npoints-1 repeat
				i+1 -> p.GetPoint -> (fiskx, fisky);
				(fiskx,fisky) -> lineto;
			for);
			(if close then
				1 -> p.GetPoint -> (fiskx, fisky);
				(fiskx,fisky) -> lineto;
			if);
		if);
	#)

-- CanvasImmediateArc: doPart --
do immediateGraphics
		(#
		do (((cx - hr, cy - vr), (cx + hr, cy + vr)), 90 - a1, - (a2 - a1)) -> drawSlice;
		#);
-- canvasImmediaterectBody: doPart --
do immediateGraphics
		(#
		do ((r.x, r.y), (r.x + r.width, r.y + r.height)) -> drawRect;
		#);
  
-- canvasClearRectBody: doPart -- 
do 'canvasClearRectBody: doPart' -> unimplemented

-- NoModifierBody: doPart --
do 0 -> m;
  
-- ShiftModifierBody: doPart --
do 512 -> m;
  
-- ControlModifierBody: doPart --
do 4096 -> m;

-- LockModifierBody: doPart --
do (* 1024 -> m;*)

-- MetaModifierBody: doPart --
do 2048 -> m;

-- CommandModifierBody: doPart --
do 256 -> m;

-- CanvasGetPointerBody: descriptor --
(# do implPart.mousePoint -> thePoint;
#)

-- CanvasGetGlobalPointerBody: descriptor --
(#
do implPart.global_mouse -> thePoint;
#)

-- CanvasIsModifierOnBody: descriptor --
(#
 do (((THIS(guienv).private.event.modifiers,themodifier) -> BitAnd) <> 0) -> value;
 #)

-- CanvasInteractionHandlerDoBody: descriptor --
(# clickPosition,pt: @guienvPoint;
   global_mouse: @guienvpoint;

	mousePosition: @
		(# pt: @guienvPoint;
			macPt: @macPoint
		do	setupPort
				(#
				do macPt.p[] -> GetMouse;
				#);
			macPt.getPoint -> pt;
		exit pt
		#);
	localize:
		(# pt: @guienvPoint;
			macPt: @macPoint
		enter pt
		do pt -> macPt.setPoint;
			setupPort
				(#
				do macPt.p[] -> MACGlobalToLocal;
				#);
			macPt.getPoint -> pt
		exit pt
		#);
	dispatch: @
		(# doProcessMouseDown: @
				(# partCode: @integer;
					extern: @COM
						(# windowPointer: @int32u;
						#);
					
					theWindow: ^window;
					macPt: @macPoint;
					time,dlbClickTime: @integer;
					screenBounds: @macRect;
					doTerminate: @boolean;
				do false -> doubleClickPossible;
					true -> sendOnMouseUp;
					(THIS(guienv).private.event.where,@@extern.windowPointer) -> FindWindow -> partCode;
					(if partCode
						//inMenubar then
							false -> sendOnMouseUp;
						//inSysWindow then
							false -> sendOnMouseUp;
						//inDesk then
							false -> sendOnMouseUp;
					else
						(* first determine if this can possibly be a doubleclick *)
						THIS(guienv).private.event.where -> macPt;
						macPt.getPoint -> clickPosition -> implpart.global_mouse;
						clickPosition -> localize -> implpart.mousePoint;
						THIS(guienv).private.event.when -> time;
						lastClickPosition -> pt;
						clickPosition -> pt.subTract;
						(if (pt.h*pt.h + pt.v*pt.v) < 10 then
							GetDblTime -> dlbClickTime;
							((time - lastClickTime) < dlbClickTime) -> doubleClickPossible;
						if);
						clickPosition -> lastClickPosition;
						time -> lastClickTime;
						(* now find the window *)
						extern.windowPointer -> THIS(guienv).private.windows.findBywindowPointer -> theWindow[];
						(if theWindow[]<>none then
							(if theWindow[] = THIS(window)[] then
								(if partCode
									//inContent then
										1 -> buttonPress;
									//inDrag then
										false -> sendOnMouseUp;
										NONE -> lastClickedObject;
									//inGrow then
										false -> sendOnMouseUp;
										NONE -> lastClickedObject;
									//inGoAway then
										false -> sendOnMouseUp;
										NONE -> lastClickedObject;
									//inZoomIn//inZoomOut then
										false -> sendOnMouseUp;
										NONE -> lastClickedObject;
								if);
							if);
						else
							false -> sendOnMouseUp;
							NONE -> lastClickedObject;
						if);
					if);
					THIS(guienv).private.event.controlKey 
						-> theTerminateCondition 
						-> doTerminate
				exit doTerminate
				#);
			doProcessMouseUp: @
				(# doTerminate: @boolean;
				do buttonRelease;
					theTerminateCondition -> doTerminate;
				exit doTerminate
				#);
			doProcessKeyDown: @
				(#
				do THIS(guienv).private.event.charCode -> keyPress;
				#);
			doProcessActivate: @processActivate;
			doProcessUpdate: @processUpdate;
			doProcessDiskEvent: @processDiskEvent;
			doProcessOsEvent: @processOsEvent;
			doProcessHighLevelEvent: @processHighLevelEvent;
			doTerminate: @boolean;
		do (if THIS(guienv).private.event.what
				//mouseDown then 
					doProcessMouseDown -> doTerminate
				//mouseUp then 
					doProcessMouseUp -> doTerminate
				//keyDown//autoKey then doProcessKeyDown
				//activateEvt then doProcessActivate
				//updateEvt then doProcessUpdate
				//diskEvt then doProcessDiskEvent
				//osEvt then doProcessOsEvent
				//kHighLevelEvent then doProcessHighLevelEvent
			if);
		exit doTerminate
		#);
		
	processOne: @
		(# gotEvent: @boolean;
			
			currentTime: @integer;

			theMotion: @motion;
			x, y: @integer;
			doTerminate: @boolean;
		do	mousePosition -> (x, y);
		    THIS(GUIenv).mouse.GlobalPosition -> implpart.global_mouse;
		    
			(if (x <> implpart.mousePoint.x)  OR (y <> implpart.mousePoint.y) then
				(x, y) -> implpart.mousePoint;
				theMotion;
			if);
			(if updateMenubarFlag then
				updateMenubar;
			if);
			(if THIS(guienv).private.updateCursorFlag then
				doUpdateCursor;
			if);
			(if THIS(guienv).private.eventHook[] <> NONE then
				THIS(guienv).private.eventHook;
			if);
			TickCount -> currentTime;
			(if currentTime - THIS(guienv).private.timerQueue.lastVisit > THIS(guienv).private.timerQueue.minInterval then
				THIS(guienv).private.timerQueue.executeElapsed;
			if);
			(everyEvent,THIS(guienv).private.event.event[],0,THIS(guienv).private.cursorRegion) -> WaitNextEvent -> gotEvent;
			(if gotEvent then
				dispatch -> doTerminate;
			if);
			(if NOT doTerminate then
				theTerminateCondition -> doTerminate;
			if);
		exit doTerminate
		#);
	
	theTerminateCondition: @terminateCondition
do Initialize;
	this(bifrostCanvas)[] -> target;
	interactionLoop:
		(#	doTerminate: @boolean;
		do  idle;
		    processOne -> doTerminate;
			(if doTerminate then
				terminated;
				leave interactionLoop;
			else
				restart interactionLoop
			if);
		#);
#)

(****
(# 

do
	false -> implPart.duringTrack;
	initialize;
	trackMouse
		(# mousePress:: 
				(# 
				do curPt.h -> putwarnint;
					' ' -> put;
					curPt.v -> putwarnintline;
					curPt -> implPart.mousePoint;
					true -> implPart.duringTrack;
					1 -> buttonPress 
				#);
			mouseMove:: 
				(# 
				do curPt -> implPart.mousePoint;
					motion;
				#);
			mouseRelease:: (# do buttonRelease #);
		#);
	false -> implPart.duringTrack;
	terminated;
#)
***)

-- CanvasTerminateCondition: dopart -- 
do INNER;

-- CanvasDoubleClickBody: doPart --
do (* 'CanvasDoubleClickBody: doPart' -> unimplemented	  *)  
  	 
  

-- CanvasMMtoPixel: descriptor -- 
(# s: @scaleMatrix;
	factor: (# exit 2.0 #)
do (factor, factor) -> s;
	p -> s.transformPoint -> p;

#)
-- CanvasPixelToMM: descriptor -- 
(# s: @scaleMatrix;
	factor: (# exit 2.0 #)
do (factor, factor) -> s;
	p -> s.inverseTransformPoint -> p;

#)



-- changecanvasborderwidth: doPart--
do value -> implpart.bw;

-- canvasborderwidth: doPart--
do implpart.bw -> value;

-- OpenCanvas: doPart --
do (* Initialize zoom factor *)
   (1.0,1.0) -> privatePart.currentZoomFactor;
   true -> implPart.isOpen;
	updateCoordinateSystem;
   INNER;
	(if NOT defaultbackground then
		(if implPart.bg[] <> NONE then
			implPart.bg -> backgroundColor;
		else
			(* Set the background to white *)
			(0xFFFF, 0xFFFF, 0xFFFF) -> backgroundColor;
		if);
	if);
	
-- canvasDamagedArea: descriptor --
(# (* deliberately empty *) #)

-- CanvasImmediateTextBody: descriptor --
immediateGraphics
	(# st: @textStyle;
		macFace: @integer;
	do pos -> moveTo;
		(if theFontName
			//times then 'times' -> st.name;
			//courier then 'courier' -> st.name;
			//helvetica then 'helvetica' -> st.name;
		if);
		theSize -> st.size;
		(if theStyle
			//plain  then 0 -> macface;
			//italic then 2 -> macface;
			//bold   then 1 -> macface;
		if);
		(if underline then macface+4 -> macface if);
		st[] -> style;
		macFace -> TextFace;
		srcXor -> TextMode;
		theString[] -> drawText;
		srcOr -> TextMode;
	#)


-- CanvasRefresh: descriptor --
(#
do (if NOT implpart.onOpenDone then
		true -> implpart.onOpenDone;
		theEventHandler.onOpen;
	if);
	(if thePicture[] <> NONE then
		thePicture.scanGOs
			(#
			do THIS(bifrostCanvas)[] -> go.draw;
			#);
		(if implpart.bw > 0 then
			drawTheBorder;
		if);
	if);
	inner onRefresh;
#)


