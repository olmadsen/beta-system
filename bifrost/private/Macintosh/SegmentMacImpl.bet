ORIGIN '../Impl/SegmentImpl';


[[

-- INCLUDE 'MacBifrostEnv'


-- SegmentCalculateOffset: descriptor --
     (#
	alfa,tanTheta,cosPhi,sinPhi: @Real;
	VLen,PLen, len: @Real;
	V,P: @Vector;
     do
	(p2.x-p1.x) -> env.myint2real -> V.x;
	(p2.y-p1.y) -> env.myint2real -> V.y;
	(p3.x-p2.x) -> env.myint2real -> P.x;
	(p3.y-p2.y) -> env.myint2real -> P.y;
	((V.x,V.x) -> env.myrmul,(V.y,V.y) -> env.myrmul1) -> env.myradd -> env.myrsqrt -> VLen;
	((P.x,P.x) -> env.myrmul,(P.y,P.y) -> env.myrmul1) -> env.myradd -> env.myrsqrt -> PLen;
	(if true
	 // (Vlen, env.myrzero)->env.myrequal then
	    (if debugGraphic//true then
		'CalculateOffset: V zero vector ' -> putLine;
	    if);
	    (if (Plen,env.myrzero)->env.myrequal//true then
		'BUG: Segment: CalculateOffset: PLen is zero'->putline;
	    if);
	    (graphicPrivatePart.halfW,PLen) -> rdiv -> len;
	    (P.y -> env.myrneg,len) -> env.myrmul -> env.myReal2Int -> offset.x;
	    (P.x,        len) -> env.myrmul -> env.myReal2Int -> offset.y;
	    
	 // (Plen, env.myrzero)->env.myrequal then
	    (if debugGraphic//true then
		'CalculateOffset: P zero vector' -> putLine;
	    if);
	    (if (Vlen,env.myrzero)->env.myrequal//true then
		'BUG: Segment: CalculateOffset: VLen is zero'->putline;
	    if);
	    (graphicPrivatePart.halfW,VLen) -> env.myrdiv -> len;
	    (V.y -> env.myrneg,len) -> env.myrmul -> env.myReal2Int -> offset.x;
	    (V.x,        len) -> env.myrmul -> env.myReal2Int -> offset.y;
	    
	 else
	    (( (V.x,P.x) -> env.myrmul, (V.y,P.y) -> env.myrmul1) -> env.myradd, 
	    (VLen,PLen) -> env.myrmul) -> env.myrdiv -> env.myracos -> alfa;
     	    
	    (* correct alfa depending on whether p3 is left or right of s1 *)
      	    
	    (if ((p1.x - p2.x) * (p3.y - p2.y) > 
		(p1.y - p2.y) * (p3.x - p2.x)) //true then
		((2 -> env.myint2real,env.myrpi) -> env.myrmul,alfa) -> env.myrsub -> alfa;
	    if);
	    
	    (alfa,2 -> env.myint2real) -> env.myrdiv -> env.myrtan -> tanTheta;
	    
	    (* calculate angle from x-axis to s1 *)
	    (V.x,VLen) -> env.myrdiv -> cosPhi;
	    (V.y,VLen) -> env.myrdiv -> sinPhi;
	    
	    (* finale *)
      	    
	    (((cosPhi -> env.myrneg,graphicPrivatePart.halfW) -> env.myrmul,tanTheta)
	    -> env.myrmul1,
	    (sinPhi,graphicPrivatePart.halfW) -> env.myrmul2) -> env.myrsub -> env.myreal2int
	    -> offset.x;
	    (((sinPhi -> env.myrneg,graphicPrivatePart.halfW) -> env.myrmul,tanTheta)
	    -> env.myrmul1,
	    (cosPhi,graphicPrivatePart.halfW) -> env.myrmul2) -> env.myradd -> env.myreal2int
	    -> offset.y;
	if);
     #)


-- CalcSplineSection: descriptor --
(#
do
	 (2.0, x1 -> env.myint2real) -> env.myrmul -> twicex1;
	 (2.0, y1 -> env.myint2real) -> env.myrmul -> twicey1;
	 (2.0, x2 -> env.myint2real) -> env.myrmul -> twicex2;
	 (2.0, y2 -> env.myint2real) -> env.myrmul -> twicey2;
	 
	 ((twicex1,x2 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv -> p1x;
	 ((twicey1,y2 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv -> p1y;
	 ((twicex2,x1 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv -> p2x;
	 ((twicey2,y1 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv -> p2y;
	 ((twicex1,x0 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv ->tempx;
	 ((twicey1,y0 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv ->tempy;
	 ((tempx,p1x) -> env.myradd, 2.0) -> env.myrdiv -> p0x;
	 ((tempy,p1y) -> env.myradd, 2.0) -> env.myrdiv -> p0y;
	 ((twicex2,x3 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv ->tempx;
	 ((twicey2,y3 -> env.myint2real) -> env.myradd,3.0) -> env.myrdiv ->tempy;
	 ((tempx,p2x) -> env.myradd, 2.0) -> env.myrdiv -> p3x;
	 ((tempy,p2y) -> env.myradd, 2.0) -> env.myrdiv -> p3y;
	 
	 (p0x,p0y, p1x,p1y, p2x,p2y, p3x,p3y)
		-> calculateCurveSegment -> splinePoints[];
	 (for i: splinePoints.npoints repeat
		  i -> splinePoints.GetPoint -> allSplinePoints.addPoint;
	 for);
#)


--]]
