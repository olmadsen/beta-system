ORIGIN '../Impl/PaintImpl';


INCLUDE 'DatatypesMacImpl';
INCLUDE 'BifrostMacImpl';
INCLUDE 'RasterMacImpl';
INCLUDE '~beta/guienv/graphics';



-- AShapeAttributes: attributes --
transformPoint:
  (# p: @point;
  enter p
  do p -> privatePart.go2canvasTM.m.transformPoint -> p;
  exit p
  #);

-- PaintFillShapeBody: doPart --
do INNER;

-- PaintFillLineBody: doPart --
do INNER;

-- PaintFillMultiLineBody: doPart --
do INNER;
   
-- PaintFillTextBody: doPart --
do INNER;

-- PaintFillPieBody: doPart -- 
do INNER;

-- PaintFillArcBody: doPart --
do INNER;

-- PaintFillRectBody: doPart --
do INNER;

-- PaintFillEllipseBody: doPart --
do INNER;


-- SolidColorImplPart: descriptor --
(# #)

-- SolidColorInitBody: doPart -- 
do INNER;


-- SolidColorChangedBody: descriptor --
(#	 
do (* do nothing *)
#)

-- MaxRGBBody: doPart --
do 65535 -> max;

-- SolidColorCopyImplPart: descriptor --
(#
do (* do nothing *)
#)


-- SolidColorSetCanvasPaintBody: doPart -- 
do 
   
   

-- SolidColorSetBorderPaintBody: doPart -- 
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> theCanvas.implPart.border;

-- SolidColorSetBackgroundPaintBody: doPart --
do &color[] -> theCanvas.implPart.bg[];
   (privatePart.red, privatePart.green, privatePart.blue) 
     -> theCanvas.implPart.bg;
   (if theCanvas.implPart.isOpen then
       theCanvas.implPart.bg -> theCanvas.backgroundColor;
   if);

-- SolidColorFillShapeBody : doPart --
do theCanvas.graphics
   (# aPoly: @Integer;
   do (privatePart.red, privatePart.green, privatePart.blue) 
        -> pen.foreGroundColor;
      (* fix me: do only if invalid *)
      theCanvas[] -> theShape.recalculatePrivatePart;
      (if theShape.privatePart.implPart.macPoly <> nil then
          theShape.privatePart.implPart.macPoly -> PaintPoly;
       else
          (* Fix me: do something else! *)
          'recalculatePrivatePart failed to create a polygon' -> putwarnline;
      if);
   #)

   (*********** PREDEFINED ***************)
   
-- SolidColorFillLineBody: descriptor --
theCanvas.graphics
(# begin, end: @point;
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> pen.foreGroundColor;
   
   
   (theLine.width -> theCanvas.ZoomDim, 1) -> Max -> pen.size;
   
   theLine.begin
     -> theLine.transformPoint
     -> theCanvas.canvasToDevice
     -> begin;
   
   theLine.end
     -> theLine.transformPoint
     -> theCanvas.canvasToDevice
     -> end;
   
   (begin, end) -> drawLine;
#)

-- SolidColorFillMultiLineBody: doPart --
do theCanvas.graphics
   (# first: @boolean;
   do (privatePart.red, privatePart.green, privatePart.blue) 
        -> pen.foreGroundColor;
      (theMultiLine.width -> theCanvas.ZoomDim, 1) -> max -> pen.size;
      
      true -> first;
      
      theMultiLine.points.p.scanPoints
      (# pt: @point;
      do current 
           -> theMultiLine.transformPoint
           -> theCanvas.canvasToDevice
           -> pt;
         (if first then
             pt -> moveTo;
             false -> first;
          else
             pt -> lineTo;
         if);
      #);
   #)


-- SolidColorFillTextBody: descriptor --
theCanvas.graphics
(# st: @textStyle;
   t: @text;
   macface, lineheight: @integer;
   x, y: @integer;
   
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> pen.foreGroundColor;
   (if theText.theFontName
    //times then 'times' -> st.name;
    //courier then 'courier' -> st.name;
    //helvetica then 'helvetica' -> st.name;
   if);
   theText.size -> theCanvas.ZoomDim -> st.size;
   (if theText.theStyle
    //plain  then 0 -> macface;
    //italic then 2 -> macface;
    //bold   then 1 -> macface;
   if);
   (if theText.underline then macface+4 -> macface if);
   st[] -> style;
   macFace -> TextFace;
   theText.position 
     -> theText.transformPoint
     -> theCanvas.canvasToDevice
     -> (x, y)
     -> moveTo;
   
   (theText.theFontName, theText.theStyle, theText.Size)
     -> TextLineHeight
     -> theCanvas.ZoomDim 
     -> lineheight;
   
   (theText.theLines).scan
   (# 
   do (x, y) -> moveTo;
   	  current[] -> drawtext;
   	  y + lineHeight -> y;
   #);
   
#)


-- SolidColorFillPieBody: descriptor --
theCanvas.graphics
(# c: @point;
   startAngle, arcLength: @integer;
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> pen.foreGroundColor;
   
   thePie.center 
     -> thePie.transformPoint
     -> theCanvas.canvasToDevice
     -> c;
   
   
   90 - thePie.angle1 -> startAngle;
   thePie.angle2 - thePie.angle1 -> arcLength;
   
   (((c.x - thePie.horizontalRadius,
   c.y - thePie.verticalRadius),
   (c.x + thePie.horizontalRadius,
   c.y + thePie.verticalRadius)),
   startAngle, -arcLength) -> fillSlice;
#)


-- SolidColorFillArcBody: descriptor --
theCanvas.graphics
(# c: @point;
   startAngle, arcLength: @Integer;
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> pen.foreGroundColor;
   
   (theArc.arcWidth, 1) -> max -> pen.size;
   
   theArc.center 
     -> theArc.transformPoint
     -> theCanvas.canvasToDevice
     -> c;
   
   90 - theArc.angle1 -> startAngle;
   theArc.angle2 - theArc.angle1 -> arcLength;
   
   
   (((c.x - theArc.horizontalRadius,
   c.y - theArc.verticalRadius),
   (c.x + theArc.horizontalRadius,
   c.y + theArc.verticalRadius)),
   startAngle, -arcLength) -> drawSlice;
#)

-- SolidColorFillRectBody: descriptor --
theCanvas.graphics
(# upperLeft: @point;
   r: @rectangle;
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> pen.foreGroundColor;
	 
   theRect.upperleft 
     -> theRect.privatepart.go2canvasTM.m.transformPoint
     -> (r.x, r.y);
   (theRect.width, theRect.height) -> (r.width, r.height);
   r -> theCanvas.CanvasToDeviceRectangle -> r;
   
   (if theRect.stroked then
       (theRect.strokewidth -> theCanvas.ZoomDim, 1) -> max -> pen.size;
       ((r.x, r.y), (r.x + r.width, r.y + r.height))
         -> DrawRect;
    else
       ((r.x, r.y), (r.x + r.width, r.y + r.height))
         -> FillRect;
   if);
#)
-- SolidColorFillEllipseBody: descriptor --
theCanvas.graphics
(# c: @point;
do (privatePart.red, privatePart.green, privatePart.blue) 
     -> pen.foreGroundColor;
   
   theEllipse.center 
     -> theEllipse.transformPoint
     -> theCanvas.canvasToDevice
     -> c;
   
   (if theEllipse.stroked then
       (theEllipse.strokewidth -> theCanvas.ZoomDim, 1) -> max -> pen.size;
       ((c.x - theEllipse.horizontalRadius,
       c.y - theEllipse.verticalRadius),
       (c.x + theEllipse.horizontalRadius,
       c.y + theEllipse.verticalRadius)) -> drawOval;
    else
       ((c.x - theEllipse.horizontalRadius,
       c.y - theEllipse.verticalRadius),
       (c.x + theEllipse.horizontalRadius,
       c.y + theEllipse.verticalRadius)) -> fillOval;
   if);
#)

(******** TILED SOLID COLOR ************)

-- TiledSolidFillShapeBody: doPart -- 
do 'TiledSolidFillShapeBody : doPart' -> unimplemented;

-- TiledSolidFillLineBody: doPart -- 
do 'TiledSolidFillLineBody : doPart' -> unimplemented;

-- TiledSolidFillMultiLineBody: doPart -- 
do 'TiledSolidFillMultiLineBody : doPart' -> unimplemented;

-- TiledSolidFillTextBody: doPart -- 
do 'TiledSolidFillTextBody : doPart' -> unimplemented;

-- TiledSolidFillArcBody: doPart -- 
do 'TiledSolidFillArcBody : doPart' -> unimplemented;

-- TiledSolidFillPieBody: doPart -- 
do 'TiledSolidFillPieBody : doPart' -> unimplemented;


-- TiledSolidFillRectBody: doPart --
do 'TiledSolidFillRectBody : doPart' -> unimplemented;


-- TiledSolidSetBorderPaintBody: descriptor -- 
(# do 'TiledSolidSetBorderPaintBody: descriptor' -> unimplemented #) 

-- TiledSolidSetBackgroundPaintBody: descriptor -- 
(# do 'TiledSolidSetBackgroundPaintBody: descriptor' -> unimplemented #) 

-- TiledSolidSetCanvasPaintBody: descriptor -- 
(# do 'TiledSolidSetCanvasPaintBody: descriptor' -> unimplemented #) 

-- TiledSolidFillEllipseBody: doPart -- 
do 'TiledSolidFillEllipseBody : doPart' -> unimplemented;
   



   (**************** RASTER ******************)

   (* Raster is not implemented *)

-- RasterPaintFillMultiLineBody: doPart -- 
do 'RasterPaintFillMultiLineBody : doPart' -> unimplemented;

-- RasterPaintFillArcBody: doPart --  
do 'RasterPaintFillArcBody : doPart' -> unimplemented;
   
-- RasterPaintFillPieBody: doPart --  
do 'RasterPaintFillPieBody : doPart' -> unimplemented;
   
-- RasterPaintFillShapeBody: descriptor -- 
(# do 'RasterPaintFillShapeBody: descriptor' -> unimplemented #) 

-- RasterPaintFillLineBody: doPart --  
do 'RasterPaintFillLineBody : doPart' -> unimplemented;
   
-- RasterPaintFillRectBody: doPart --  
do 'RasterPaintFillRectBody : doPart' -> unimplemented;
   
-- RasterPaintFillTextBody: doPart --  
do 'RasterPaintFillTextBody : doPart' -> unimplemented;
   
-- RasterPaintFillEllipseBody: doPart --  
do 'RasterPaintFillEllipseBody : doPart' -> unimplemented;
   
-- RasterPaintSetBorderPaintBody: descriptor -- 
(# do 'RasterPaintSetBorderPaintBody: descriptor' -> unimplemented #) 

-- RasterPaintSetBackgroundPaintBody: descriptor -- 
(# do 'RasterPaintSetBackgroundPaintBody: descriptor' -> unimplemented #) 

-- RasterPaintSetCanvasPaintBody: descriptor -- 
(# do 'RasterPaintSetCanvasPaintBody: descriptor' -> unimplemented #) 




