ORIGIN '../Impl/PaintImpl'
[[

-- INCLUDE 'DatatypesMacImpl'
-- INCLUDE 'GraphicsMacImpl'
-- INCLUDE 'RasterMacImpl'
-- INCLUDE 'MacBifrostEnv'

-- LIB: attributes --

-- PaintFillShapeBody: descriptor --
  (#
  do (if theShape.isClosed//false then
        (if displayWarnings//true then
            'Trying to fill non-closed Shape; ignoring request' -> putline;
        if);
     if);
	 (if theShape.FillRule // EvenOddRule then
        (if displayWarnings//true then
            'Cannot use EvenOdd fill rule on Mac, yet' -> putline;
        if);
	 if);
     PenNormal;
  #)
-- PaintFillLineBody: descriptor --
  (#
  do
     (* Set lineWidth *)
     PenNormal;
	 (if theLine.width//0 then 
	     (1,1) -> PenSize;
	  else
         (theLine.width,theLine.width) -> PenSize;
	 if);
  #) 
-- PaintFillMultiLineBody: descriptor --
  (#
  do
     (* Set lineWidth *)
     PenNormal;
     (if theMultiLine.width//0 then 
	     (1,1) -> PenSize;
	  else
         (theMultiLine.width,theMultiLine.width) -> PenSize;
	 if);
  #)
  
-- PaintFillTextBody: descriptor --
  (#
  do
     (theText.theFontName,theText.theStyle,theText.size,theText.underline) 
         -> graphicprivatepart.Fonts.SetMacFont;
  #)
-- PaintFillPieBody: descriptor -- (# #)

-- PaintFillArcBody: descriptor --
  (#
  do
     PenNormal;
	 (theArc.ArcWidth,theArc.ArcWidth) -> PenSize;
  #)

-- PaintFillRectBody: descriptor --
  (#
  do
     PenNormal;
     (if theRect.stroked//true then
	     (theRect.StrokeWidth,theRect.StrokeWidth) -> PenSize;
	 if);
  #)
-- PaintFillEllipseBody: descriptor --
  (#
  do
     PenNormal;
     (if theEllipse.stroked//true then
	     (theEllipse.StrokeWidth,theEllipse.StrokeWidth) -> PenSize;
	 if);
  #)

-- SolidColorImplPart: descriptor --
     (#
	   theMacColor: @RGBColor;
	   doneInInner: @Boolean;
	 #)
	
-- SolidColorInitBody: descriptor -- (# #)

-- SolidColorChangedBody: descriptor --
     (#
	 do
	 	privatepart.red   -> implpart.theMacColor.red;
	    privatepart.green -> implpart.theMacColor.green;
	    privatepart.blue  -> implpart.theMacColor.blue;
	 #)

-- MaxRGBBody: descriptor --
	 (# do 65535 -> max #)

-- SolidColorCopyImplPart: descriptor --
  (#
  do
	 implpart.theMacColor.red -> sc.implpart.theMacColor.red;
	 implpart.theMacColor.green -> sc.implpart.theMacColor.green;
	 implpart.theMacColor.blue -> sc.implpart.theMacColor.blue;
  #)


-- SolidColorSetCanvasPaintBody: descriptor -- 
     (# 
     do implpart.theMacColor[] -> RGBForeColor;
     #)

-- SolidColorSetBorderPaintBody: descriptor -- (# #)

-- SolidColorSetBackgroundPaintBody: descriptor --
     (# 
     do (* implpart.theMacColor[] -> RGBBackColor; *)
      #)

-- SolidColorFillShapeBody : descriptor --
     (# aPoly: @Integer;
	 do 
		SetCanvasPaint;
	    (if theShape.Invalid//true then
	        theShape.recalculatePrivatePart;
	    if);
        theShape.privatePart.implPart.macPoly -> PaintPoly;
	 #)
	 
	 (*********** PREDEFINED ***************)
	 
-- SolidColorFillLineBody: descriptor --
  (# x,y: @Integer;
  do
  	setCanvasPaint;
	theLine.begin 
	  -> theLine.privatepart.go2canvasTM.transformPoint 
	  -> graphicprivatepart.currentcanvas.CanvasToDevice -> (x,y);
    (x,y) -> moveto; 
	theLine.end 
      -> theLine.privatepart.go2canvasTM.transformPoint 
	  -> graphicprivatepart.currentcanvas.CanvasToDevice -> (x,y);
    (x,y) -> lineto;
  #)
  
-- SolidColorFillMultiLineBody: descriptor --
  (#
  do
     setCanvasPaint;
  	 (if theMultiLine.privatepart.implpart[]//NONE then
    	    &theMultiLine.privatepart.implparttype[]
      	      -> theMultiLine.privatepart.implpart[]
    	if);
	 (if theMultiLine.Invalid//true then
	    (theMultiLine.privatePart.go2canvastm,
	     graphicprivatepart.currentcanvas.TM[]) 
	      -> MatrixMul
	      -> theMultiLine.points.p.ToMacPoints
	      -> theMultiLine.privatepart.implpart.MacPoints[];
	    theMultiLine.points.p.npoints 
	      -> theMultiLine.privatepart.implpart.noofpoints;
	if);
	(if theMultiLine.dashes=NONE
	 // false then 'MultiLine dashes not yet implemented' -> putline;
	if);
	(theMultiLine.privatePart.implPart.MacPoints.p[1] -> TOS'%getshort[0]',
	 theMultiLine.privatePart.implPart.MacPoints.p[1] -> TOS'%getshort[1]') -> moveto;
	(for i:theMultiLine.privatepart.implpart.noofpoints-1 repeat
	    (theMultiLine.privatePart.implPart.MacPoints.p[i+1] -> TOS'%getshort[0]',
	 	 theMultiLine.privatePart.implPart.MacPoints.p[i+1] -> TOS'%getshort[1]')  -> lineto;
	for);
  #)

-- SolidColorFillTextBody: descriptor --
  (# x,y: @Integer;
  do 
	 SetCanvasPaint;
     theText.position 
          -> theText.privatePart.go2canvastm.transformPoint 
          -> graphicprivatepart.currentcanvas.CanvasToDevice -> (x,y);
     (x,y) -> moveto;
	 theText.theText -> DrawString;
  #)

-- SolidColorFillPieBody: descriptor --
  (# devupperleft: @Point;
     macR: @MacRectangle;
	 a1,a2: @Integer;
  do
    setCanvasPaint;
	thePie.center
	  -> thePie.privatePart.go2canvasTM.transformPoint
	  -> graphicprivatepart.currentcanvas.CanvasToDevice 
	  -> devupperleft;
	((devupperleft.x-thePie.horizontalRadius,devupperleft.y-thePie.verticalRadius,
      2*thePie.horizontalradius,2*thePie.verticalradius),macR[]) -> MakeMacRect;
	90 - (thePie.angle1 -> env.myReal2Int) -> a1;
	(thePie.angle1,thePie.angle2)
	    -> env.myrsub 
	    -> env.myReal2Int -> a2;
	(macR[],a1,a2) -> PaintArc;
  #)

-- SolidColorFillArcBody: descriptor --
  (# devupperleft: @Point;
     macR: @MacRectangle;
	 a1,a2: @Integer;
  do
    setCanvasPaint;
	theArc.center
	  -> theArc.privatePart.go2canvasTM.transformPoint
	  -> graphicprivatepart.currentcanvas.CanvasToDevice 
	  -> devupperleft;
	((devupperleft.x-theArc.horizontalRadius,devupperleft.y-theArc.verticalRadius,
      2*theArc.horizontalradius,2*theArc.verticalradius),macR[]) -> MakeMacRect;
	90 - (theArc.angle1 -> env.myReal2Int) -> a1;
	(theArc.angle1,theArc.angle2)
	    -> env.myrsub
	    -> env.myReal2Int -> a2;
	(macR[],a1,a2) -> FrameArc;
  #)

-- SolidColorFillRectBody: descriptor --
  (# macR: @MacRectangle; x,y: @Integer;
  do
     (if implpart.doneInInner//false then
		 setCanvasPaint;
		 theRect.upperleft 
		  -> theRect.privatepart.go2canvasTM.transformPoint
		  -> graphicprivatepart.currentcanvas.CanvasToDevice -> (x,y);
		 ((x,y,theRect.width, theRect.height),macR[]) -> MakeMacRect;
		 (if theRect.stroked//true then
			macR[] -> FrameRect;
		 else
			macR[]-> PaintRect;
		 if);
	 if);
  #)
-- SolidColorFillEllipseBody: descriptor --
  (# devupperleft: @Point;
     macR: @MacRectangle;
  do
     setCanvasPaint;
  	 theEllipse.center 
	  -> theEllipse.privatepart.go2canvasTM.transformPoint
	  -> graphicprivatepart.currentcanvas.CanvasToDevice -> devupperleft;
	 ((devupperleft.x-theEllipse.horizontalRadius,devupperleft.y-theEllipse.verticalRadius,
       2*theEllipse.horizontalradius,2*theEllipse.verticalradius),macR[]) -> MakeMacRect;
	 (if theEllipse.stroked//true then
	     macR[] -> FrameOval;
	 else
	     macR[] -> PaintOval;
	 if);
  #)


(******** TILED SOLID COLOR ************)
 
-- TiledSolidFillShapeBody: descriptor -- 
  (# pos: @Point;
     srcRect,dstRect: @macRectangle;
	 macp: @macPoint;
  do 
     setCanvasPaint;
     theShape.hotspot 
	  -> theShape.privatePart.go2CanvasTM.transformPoint
	  -> graphicprivatepart.currentcanvas.CanvasToDevice
 	  -> pos;
     (pos.x,pos.y) -> (macp.h,macp.v);
	 macp[] -> LocalToGlobal;
	 ((0,0,tiledprivate.theBitmap.width,tiledprivate.theBitmap.height),srcRect[]) -> MakeMacRect;
	 ((macp.x,macp.y,tiledprivate.theBitmap.width,tiledprivate.theBitmap.height),dstRect[]) -> MakeMacRect;
	 (tiledprivate.theBitmap.bitmapprivatepart.MacBitMap,env.theMacEnv.globvar.thePort+2,srcRect[],dstRect[],0,0)
	    -> CopyBits;
	 true -> implpart.doneInInner;
  #)
  
-- TiledSolidFillLineBody: descriptor -- (# #) 
-- TiledSolidFillMultiLineBody: descriptor -- (# #) 
-- TiledSolidFillTextBody: descriptor -- (# #) 
-- TiledSolidFillArcBody: descriptor -- (# #) 
-- TiledSolidFillPieBody: descriptor -- (# #)

-- TiledSolidFillRectBody: descriptor --
  (# pos: @Point;
     srcRect,dstRect: @macRectangle;
	 macp: @macPoint;
  do 
	 setCanvasPaint;
     theRect.hotspot -> theRect.privatePart.go2CanvasTM.transformPoint
	                 -> graphicprivatepart.currentcanvas.CanvasToDevice
 	  				 -> pos;
	 tiledprivate.theBitmap.bitmapprivatepart.MacBitMap.bounds -> srcRect;
	 srcRect -> dstRect;
	 (dstRect[],pos.x,pos.y) -> OffsetRect;
	 (tiledprivate.theBitmap.bitmapprivatepart.MacBitMap,
	  env.theMacEnv.globvar.thePort+2,
	  srcRect[],dstRect[],0,0) -> CopyBits;
	 true -> implpart.doneInInner;	 
  #)

-- TiledSolidSetBorderPaintBody: descriptor -- (# #) 
-- TiledSolidSetBackgroundPaintBody: descriptor -- (# #) 
-- TiledSolidSetCanvasPaintBody: descriptor -- (# #) 
-- TiledSolidFillEllipseBody: descriptor -- (# #) 
 
 (******** FILTERED SOLID COLOR ************)

-- FilteredSolidFillShapeBody: descriptor -- (# #) 
-- FilteredSolidFillLineBody: descriptor -- (# #) 
-- FilteredSolidFillMultiLineBody: descriptor -- (# #) 
-- FilteredSolidFillTextBody: descriptor -- (# #) 
-- FilteredSolidFillArcBody: descriptor -- (# #) 
-- FilteredSolidFillPieBody: descriptor -- (# #) 
-- FilteredSolidFillRectBody: descriptor -- (# #) 
-- FilteredSolidSetBorderPaintBody: descriptor -- (# #) 
-- FilteredSolidSetBackgroundPaintBody: descriptor -- (# #) 
-- FilteredSolidSetCanvasPaintBody: descriptor -- (# #) 
-- FilteredSolidFillEllipseBody: descriptor -- (# #) 



(**************** RASTER ******************)


-- RasterPaintPixmapEnter: descriptor -- (# #)
-- RasterPaintPixmapExit: descriptor -- (# #)

-- RasterPaintFillMultiLineBody: descriptor -- (# #)
-- RasterPaintFillArcBody: descriptor -- (# #)
-- RasterPaintFillPieBody: descriptor -- (# #)
-- RasterPaintFillShapeBody: descriptor -- (# #)
-- RasterPaintFillLineBody: descriptor -- (# #)
-- RasterPaintFillRectBody: descriptor -- (# #)
-- RasterPaintFillTextBody: descriptor -- (# #)
-- RasterPaintPrivate: descriptor -- (# #)
-- RasterPaintFillEllipseBody: descriptor -- (# #)
-- RasterPaintSetBorderPaintBody: descriptor -- (# #)
-- RasterPaintSetBackgroundPaintBody: descriptor -- (# #)
-- RasterPaintSetCanvasPaintBody: descriptor -- (# #)
--]]

