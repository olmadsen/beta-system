ORIGIN '../Impl/PredefinedImpl';
INCLUDE '../Rubber/RubberRect';

(************************ RECT SHAPE ******************************)

-- RectShapeChangeCorners: dopart --
do
   lowerright.x-upperleft.p.x -> width;
   upperleft.p.y-lowerright.y -> height;
   
   
-- RectShapeOpenBody: dopart --
do INNER;
   
-- RectShapeGetBoundsBody: dopart --
do (if privatepart.boundInvalid // true then
       upperleft.p.x -> privatepart.bound.x;
       upperleft.p.y -> privatepart.bound.y;
       width+1 -> privatepart.bound.width;
       height+1 -> privatepart.bound.height;
       privatepart.bound -> privatepart.go2canvasTM.m.transformrectangle 
         -> privatepart.bound;
       (* privatepart.boundinvalid is set to false in strokeableShape *)
   if);
   INNER;
   
-- RectShapeContainsPoint: dopart --
do (thePoint, getbounds) -> PointInRect -> value; 
   INNER;
-- RectShapeIntersects: dopart --
do INNER;
   'RectShape.Intersects' -> UnImplemented;
   
-- RectShapeWithin: dopart --
do INNER;
   'RectShape.Within' -> UnImplemented;

-- RectShapeGetControlsBody: dopart --
do (* transform points into BifrostCanvas coord. *)
   upperleft -> privatepart.Go2CanvasTM.M.TransformPoint  -> spots.addpoint;
   (upperleft.p.x+width,upperleft.p.y) 
     -> privatepart.Go2CanvasTM.M.TransformPoint -> spots.addpoint;
   (upperleft.p.x+width,upperleft.p.y-height)
     -> privatepart.Go2CanvasTM.M.TransformPoint -> spots.addpoint;
   (upperleft.p.x,upperleft.p.y-height) 
     -> privatepart.Go2CanvasTM.M.TransformPoint -> spots.addpoint;
   INNER;
   
-- RectShapeCopyBody: descriptor --
(# r: ^RectShape;
do (if aCopy[]//NONE then (* Not done in inner *)
       &RectShape[] -> r[];
       r.open;
       upperleft -> r.upperleft;
       width -> r.width;
       height -> r.height;
       r[] -> aCopy[];
   if)
#)

-- RectShapeHiliteOutlineBody: descriptor --
(# r: @rectangle;
do (if TM[]//NONE then
       upperleft
         -> privatepart.Go2CanvasTM.M.TransformPoint
         -> theCanvas.CanvasToDevice
         -> (r.x, r.y);
    else
       upperleft
         -> privatepart.Go2CanvasTM.M.TransformPoint
         -> TM.transformpoint
         -> theCanvas.CanvasToDevice
         -> (r.x, r.y);
   if);	    
   width -> r.width;
   height -> r.height;
   hiliteWidth -> theCanvas.setImmediateLineWidth;
   r -> theCanvas.immediaterect;
#)

-- RectShapeInteractiveCreateBody: descriptor --
(# r: @rectangle;
do open;
   (* startpoint is in GO coords *)
   
   (startpoint, startpoint, themodifier) 
     -> &theCanvas.RubberRect
     -> r;
   (r.x, r.y) 
     -> upperLeft
     -> hotspot;
   (r.width, r.height) -> (width, height);
#)

-- RectShapeInteractiveReshapeBody: descriptor --
(# anchorpoint: @point;
   r: @rectangle;	
   GB: @GetBounds;
do (* Determine anchorpoint, assume that startpoint is a corner *)
   
   (* startpoint is in GO coords *)
   startPoint -> anchorPoint;
   (* anchorpoint is in GO coords *)
   
   (if anchorpoint.x//upperleft.p.x then 
       upperleft.p.x + width -> anchorpoint.x
    else
       upperleft.p.x -> anchorpoint.x;
   if);
   (if anchorpoint.y//upperleft.p.y then 
       upperleft.p.y - height -> anchorpoint.y
    else
       upperleft.p.y -> anchorpoint.y
   if);
   
   startpoint
     -> privatePart.Go2CanvasTM.M.TransformPoint 
     -> startPoint;
   
   anchorpoint
     -> privatePart.Go2CanvasTM.M.TransformPoint 
     -> anchorPoint;
   
   (* Anchorpoint and startpoint are in BifrostCanvas coords *)
   
   GB -> theCanvas.damaged;
   (anchorpoint, startpoint, themodifier) 
     -> &theCanvas.RubberRect
   (# buttonrelease::<(# do true -> stopinteraction #)#)
     -> r;
   
   (* r is in BifrostCanvas coords *)
   r -> privatePart.go2CanvasTM.m.inversetransformrectangle -> r;
   (* r is in GO coords *)
   
   (r.x, r.y) 
     -> upperLeft
     -> hotspot;
   (r.width, r.height) -> (width, height);
   GB -> theCanvas.damaged;
   theCanvas.repair;
#)

-- RectShapeTransformBody: dopart --
do (upperleft.p.x, upperleft.p.y, width, height) -> m.transformRectangle
     -> (upperleft.p.x, upperleft.p.y, width, height);
   INNER;
   
-- RectShapecalculate: dopart --
do	
   (if privatepart.invalid//true then
       &Shape[] -> prePrivate.calculatedShape[];
       upperleft -> prePrivate.calculatedShape.open;
       (upperleft.p.x+width, upperleft.p.y)
         -> prePrivate.calculatedShape.LineTo;
       (upperleft.p.x+width, upperleft.p.y-height)
         -> prePrivate.calculatedShape.LineTo;
       (upperleft.p.x, upperleft.p.y-height)
         -> prePrivate.calculatedShape.LineTo;
       prePrivate.calculatedShape.close;
       (if stroked//true then
           (strokewidth, CapButt, JoinMiter)
             -> prePrivate.calculatedShape.stroke;
       if);
       &Matrix[]
         -> prePrivate.calculatedShape.privatepart.go2canvasTM.m[];
       privatepart.go2canvasTM.m 
         -> prePrivate.calculatedShape.privatepart.go2canvasTM.m.set;
       (* if); *)
       false -> privatepart.invalid;
   if);
   INNER;
