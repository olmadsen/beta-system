ORIGIN '../Impl/PredefinedImpl';

(********* Fonts and styles ***********)

-- CourierBody: dopart --
do 1->value;
   
   
-- TimesBody: dopart --
do 2->value;
   
   
-- HelveticaBody: dopart --
do 3->value;
   
   
-- PlainBody: dopart --
do 1->value;
   
   
-- ItalicBody: dopart --
do 2->value;
   
   
-- BoldBody: dopart --
do 3->value;
   
   
   
   (************ TextShape **********************)
   
-- TextShapeChangePosBody: dopart --
do p -> TextPrivate.position;
   Invalidate;
   
   
-- TextShapePosBody: dopart --
do TextPrivate.position -> p;
   
   
-- TextShapeChangeNameBody: dopart --
do nam -> TextPrivate.theFontName;
   Invalidate;
   
   
-- TextShapeTheFontNameBody: dopart --
do TextPrivate.theFontName -> nam;
   
   
-- TextShapeChangeStyleBody: dopart --
do sty -> TextPrivate.theStyle;
   Invalidate;
   
   
-- TextShapeTheStyleBody: dopart --
do TextPrivate.theStyle -> sty;
   
   
-- TextShapeChangeSizeBody: dopart --
do siz -> TextPrivate.theSize;
   Invalidate;
   
   
-- TextShapeSizeBody: dopart --
do TextPrivate.theSize -> siz;
   
   
-- TextShapeChangeUnderlineBody: dopart --
do ul -> TextPrivate.underline;
   Invalidate;
   
   
-- TextShapeUnderlineBody: dopart --
do TextPrivate.underline -> ul;
   
   
-- TextShapeChangeTextBody: dopart --
do (if t[]<>NONE then
       TextPrivate.theStrings.clear;
       t.scanall
       (# x: @text;
          i: @integer;
       do i+1->i;
          (if ch
           // ascii.nl
           // ascii.cr then
              x.copy -> TextPrivate.theStrings.append;
              x.clear;
           else
              ch -> x.put;
              (if i=t.lgth then
                  (* end of text reached *)
                  x.copy -> TextPrivate.theStrings.append;
              if);
          if);
       #);
       Invalidate;
   if)
   
   
-- TextShapeTheTextBody: dopart --
do &text[]->t[]; 
   TextPrivate.theStrings.scan
   (# firstdone: @boolean
   do (if firstdone then
          t.newline;
       else
          true -> firstdone;
      if);          
      current.copy -> t.append;
   #)
   
--TextShapeTheLinesBody: dopart-- 
do TextPrivate.thestrings.copy -> l[];
   
--TextShapeChangeLinesBody: dopart--
do (if l[]<>NONE then
       TextPrivate.thestrings.clear;
       l.scan
       (# 
       do current[] -> TextPrivate.thestrings.append;
       #);
       Invalidate;
   if)
   
--TextShapeNumberOfLinesBody: dopart--
do TextPrivate.thestrings.size-> value;
   
-- TextShapePrivatePart: descriptor --
(# thestrings: @TextList;
   theFontName: @FontName;
   theStyle: @Style;
   theSize: @Integer;
   underline: @Boolean;
   position: @Point;
#)

-- TextShapeGetBoundsBody: descriptor --
(# asc: @integer;
do (if privatepart.boundInvalid then
       
       (* Find width and height *)
       ((theLines, theFontName, theStyle, size) -> TextlistGetWidthHeight)
         -> (privatepart.bound.width,privatepart.bound.height);
       
       (* Find x *)
       TextPrivate.position.x -> privatepart.bound.x;
       
       (* Find y *)
       (theFontName, theStyle, size) -> TextMaxAscent -> asc;
       TextPrivate.position.y + asc (* Sum is top of top line *)
         -> privatepart.bound.y;
       
       (* Small adjustment *)
       privatepart.bound.width+1 -> privatepart.bound.width;
       privatepart.bound.height+1 -> privatepart.bound.height;
       
       (* Transform to canvas coords *)
       (privatepart.bound.x,privatepart.bound.y)
         -> privatepart.go2canvasTM.m.transformPoint
         -> (privatepart.bound.x,privatepart.bound.y);
       
       false -> privatepart.boundinvalid;
   if);
#)

-- TextShapeContainsPoint: dopart --
do (thePoint, getbounds) -> PointInRect -> value;
   INNER
   
-- TextShapeCopyBody: descriptor --
(# ts: ^TextShape;
do (if aCopy[]=NONE then (* Not done in inner *)
       &TextShape[] -> ts[];
       position -> ts.position;
       theFontName -> ts.theFontName;
       theStyle -> ts.theStyle;
       size -> ts.size;
       underline -> ts.underline;
       TextPrivate.theStrings.scan
       (# 
       do current[] -> ts.TextPrivate.theStrings.append;
       #);
       ts[] -> aCopy[];
   if)
#)

-- TextShapeTransformBody: dopart --
do TextPrivate.position -> M.transformPoint -> TextPrivate.position;
   INNER;
   
-- TextShapeCalculate: dopart --
do 'TextShape: CalculateShape not implemented' -> putline;
   INNER;
   
-- TextShapeGetControlsBody: descriptor --
(# r: @Rectangle;
do
   getBounds -> r; (* bound in BifrostCanvas coordinates *)
   (r.x, r.y)  -> spots.addpoint;
   (r.x+r.width, r.y) -> spots.addpoint;
   (r.x+r.width, r.y-r.height) -> spots.addpoint;
   (r.x, r.y-r.height) -> spots.addpoint;
#)

-- TextShapeInteractiveCreateBody: descriptor --
(# mousePoint: @Point;
   theCh, prevCh: @Char;
   ChWidth, prevChWidth: @Integer;
   chArray: [1] @Char;
   base_x, base_y, uppery, minx, miny, maxx, maxy: @Integer;
   theString: ^Text;
   
   icprivate: @
     <<SLOT TextShapeInteractiveCreateBodyPrivate: descriptor>>;
   
   DrawInsertionMark:@
     <<SLOT TextShapeInteractiveCreateBodyDrawInsertionMark: descriptor>>;
   
   LetterWidth: @IntegerValue
     (# ch: @Char;
     enter ch
     <<SLOT TextShapeInteractiveCreateBodyLetterWidth: dopart>>
     #);
   
   DrawCh: @
     <<SLOT TextShapeInteractiveCreateBodyDrawCh: descriptor>>;
   
   ClearPrevCh: @
     <<SLOT TextShapeInteractiveCreateBodyClearPrevCh: descriptor>>;
   
   SetInteractionFontAndLine:
     <<SLOT TextShapeInteractiveCreateBodySetFontAndLine: descriptor>>;
   
   font_ascent: @integervalue
     (#
     <<SLOT TextShapeInteractiveCreateBodyFontAscent: dopart>>
     #);
   
   lineheight: @integer;
   
do (* TextShapeInteractiveCreateBody *)
   (if theCanvas.privatepart.interactionpaint[]=NONE then
       (if displayWarnings then
           'TextShape: No paint specified for interaction - using solid black' 
             ->PutLine;
       if);
       blackPaint -> theCanvas.privatepart.interactionpaint[];
   if);
   
   (textprivate.theFontName,textprivate.theStyle,textprivate.theSize)
     -> TextLineHeight
     -> lineheight;
   
   SetInteractionFontAndLine;
   
   (* Determine where to start *)
   (* startpoint is in GO coords *)
   
   (startPoint.x, startpoint.y - 8) (* 8 is half height of xterm cursor *)
     -> position
     -> theCanvas.canvastodevice
     -> (base_x, base_y);
   
   (* Now we work in device coords *)
   (* base_y is ypos of baseline *)
   base_x -> minx -> maxx;
   base_y - font_ascent -> miny -> maxy -> uppery;
   
   (* Open the shape *)
   open;
   
   (* Start interaction *)
   DrawInsertionMark;
   &text[] -> theString[];
   (* Read letters *)
   theCanvas.interactionHandler
   (# stopinteraction: @boolean;
      
      buttonpress ::< (# do true -> stopinteraction #);
      
      terminateCondition ::<
        (# do stopinteraction -> value; #);
      
      keyPress ::<
        (#
        do (if ch->theCh
            // ascii.fs
            // ascii.rs
            // ascii.gs
            // ascii.us then
               (* These are the arrow keys. Do nothing. *)
            // ascii.esc then
               true -> stopinteraction;
            // ascii.nl
            // ascii.cr then
               DrawInsertionMark;
               theString[] -> TextPrivate.theStrings.append;
               &text[] -> theString[];
               minx -> base_x;
               base_y + lineheight -> base_y;
               uppery + lineheight -> uppery;
               (if uppery>maxy then uppery->maxy if);
               DrawInsertionMark;
            // ascii.bs
            // ascii.del then
               (if (theString.length=0) then
                   (* No more characters to delete in current string.
                    * Look for a possible previous string (text line)
                    *)
                   (if TextPrivate.theStrings.size>0 then
                       (* Fetch string for previous text line *)
                       (TextPrivate.theStrings.last).elm[]
                         -> theString[];
                       (* Delete it - it will later be inserted below *)
                       TextPrivate.theStrings.last 
                         -> TextPrivate.theStrings.delete;
                       DrawInsertionMark;
                       minx+((theString[],TextPrivate.theFontName,TextPrivate.theStyle,TextPrivate.theSize)->TextGetWidth)
                         -> base_x;
                       base_y - lineheight -> base_y;
                       uppery - lineheight -> uppery;
                       DrawInsertionMark;
                   if);
                else
                   (* Delete last character of the current string *)
                   DrawInsertionMark;
                   theString.length -> theString.inxGet -> prevCh;
                   (theString.length,theString.length)
                     -> theString.delete;
                   base_x - (prevCh->LetterWidth->prevChWidth) -> base_x;
                   ClearPrevCh;
                   DrawInsertionMark;
               if);
            else
               (if debugGraphic then ch -> put if);
               ch -> theString.put;
               DrawInsertionMark; (* Clear previous mark *)
               ch -> letterwidth -> ChWidth;
               DrawCh;
               base_x + ChWidth -> base_x;
               (base_x, maxx) -> Max -> maxx;
               DrawInsertionMark;
           if);
        #);
   #);
   DrawInsertionMark;
   (* Interaction done *)
   
   theCh -> lastCh;
   
   theString[] -> TextPrivate.theStrings.append;
   
   (TextPrivate.position.x, TextPrivate.position.y+font_ascent,
   maxx-minx, maxy-miny+lineheight) -> theCanvas.damaged;
   theCanvas.repair;
   
   <<SLOT TextShapeInteractiveCreateBodyCleanUp: descriptor>>
   
#)	

-- TextShapeInteractiveReshapeBody: dopart --
do 'TextShape: InteractiveReshape not implemented !' -> putline;
   INNER;
