ORIGIN '../Impl/PredefinedImpl';
INCLUDE '../Rubber/CenteredRubberEllipse';

(************************ ELLIPSE SHAPE *******************************)


-- EllipseShapeOpenBody: dopart --
do (0,0) -> center;
   0 -> verticalradius -> horizontalradius;
   INNER

-- EllipseShapeGetBoundsBody: dopart --
do
   (if privatepart.boundinvalid//true then
       2*horizontalradius+1 ->          privatepart.bound.width;
       2*verticalradius+1 ->            privatepart.bound.height;
       center.p.x-horizontalradius -> privatepart.bound.x;
       center.p.y+verticalradius ->   privatepart.bound.y;
       privatepart.bound -> privatepart.go2canvasTM.m.TransformRectangle 
         -> privatepart.bound;
       (* privatepart.boundinvalid is set to false in strokeableShape *)
   if);
   INNER

-- EllipseShapeContainsPoint: dopart --
do calculateshape;
   (theCanvas[],thePoint) -> preprivate.calculatedshape.containspoint -> value;
   INNER   
   
-- EllipseShapeIntersects: dopart --
do INNER;
   'EllipseShape.Intersects' -> UnImplemented;
-- EllipseShapeWithin: dopart --
do INNER;
   'EllipseShape.Within' -> UnImplemented;

-- EllipseShapeGetControlsBody: descriptor --
(# r: @rectangle;
do getbounds -> r;
   (r.x        , r.y         ) -> spots.addpoint;
   (r.x+r.width, r.y         ) -> spots.addpoint;
   (r.x,         r.y-r.height) -> spots.addpoint;
   (r.x+r.width, r.y-r.height) -> spots.addpoint;
#)

-- EllipseShapeCopyBody: descriptor --
(# e: ^EllipseShape;
do (if aCopy[]//NONE then (* Not done in inner *)
       &EllipseShape[] -> e[];
       e.open;
       center -> e.center;
       horizontalradius -> e.horizontalradius;
       verticalradius -> e.verticalradius;
       e[] -> aCopy[];
   if)
#)

-- EllipseShapeHiliteOutlineBody: descriptor --
(# c: @point;
do (if TM[] //NONE then
       center -> privatepart.Go2CanvasTM.M.Transformpoint -> c;
    else
       center 
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> TM.transformpoint
         -> c;
   if);
   c -> theCanvas.CanvasToDevice -> c;
   hiliteWidth 
     -> theCanvas.setImmediateLineWidth;
   (c.x, c.y, horizontalradius.value, verticalradius.value, 0, 360) 
     -> theCanvas.immediatearc;
#)

-- EllipseShapeInteractiveCreateBody: dopart --
do open;
   (* startpoint is in GO coords *)
   startpoint -> center.p;
   (* center is in GO coords *)
   (startpoint, startpoint, themodifier) 
     -> &theCanvas.CenteredRubberEllipse
     -> (horizontalradius.value, verticalradius.value);
   INNER;
   
-- EllipseShapeInteractiveReshapeBody: descriptor --
(# GB: @GetBounds;
do (* startpoint is in GO coords *)
   
   GB -> theCanvas.damaged;
   (center.p -> privatepart.Go2CanvasTM.M.Transformpoint,
   startpoint,
   themodifier) 
     -> &theCanvas.CenteredRubberEllipse
   (# buttonrelease::<(# do true -> stopinteraction#)#)
     -> (horizontalradius, verticalradius);
   GB -> theCanvas.damaged;
   theCanvas.repair;
#)

-- EllipseShapeTransformBody: dopart --
do
   (center.p.x,center.p.y,verticalradius,horizontalradius)
     -> m.transformRectangle
     -> (center.p.x,center.p.y,verticalradius,horizontalradius);
   invalidate;
   INNER;

-- EllipseCalculateShapeBody: descriptor --
(# c: @Point;
   hr,vr: @Integer;
   px1,py1,px2,py2: @Real;
   mySpline: ^CircularSplineSegment; 
   x,y: [8] @Integer;
   
   axis: (# exit  0.42  #);
   seen: (# exit  1.025 #);
do	
   (if privatepart.invalid//true then
       center -> c;
       horizontalRadius -> hr;
       verticalRadius -> vr;
       
       hr * axis -> px1;
       hr * seen -> px2;
       vr * axis -> py1;
       vr * seen -> py2;
       
       c.x + px1 -> x[1];
       c.y + py2 -> y[1];
       c.x - px1 -> x[2];
       y[1] -> y[2];
       c.x - px2 -> x[3];
       c.y + py1 -> y[3];
       x[3] -> x[4];
       c.y - py1 -> y[4];
       x[2] -> x[5];
       c.y - py2 -> y[5];
       x[1] -> x[6];
       y[5] -> y[6];
       c.x + px2 -> x[7];
       y[4] -> y[7];
       x[7] -> x[8];
       y[3] -> y[8];
       
       &CircularSplineSegment[] -> mySpline[];
       (x[1],y[1]) -> mySpline.open;
       (for i:7 repeat
            (x[i+1],y[i+1]) -> mySpline.addControl;
       for);
       
       &Shape[] -> prePrivate.calculatedShape[];
       (c.x,c.y+verticalRadius) -> prePrivate.calculatedShape.open;
       mySpline[] -> prePrivate.calculatedShape.addspline;
       prePrivate.calculatedShape.close;
       &Matrix[]
         -> prePrivate.calculatedShape.privatepart.go2canvasTM.m[];
       privatepart.go2canvasTM.m 
         -> prePrivate.calculatedShape.privatepart.go2canvasTM.m.set;
       false -> privatepart.invalid;
   if);
#)
