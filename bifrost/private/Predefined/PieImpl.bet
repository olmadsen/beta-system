ORIGIN '../Impl/PredefinedImpl';
INCLUDE '../Rubber/CenteredRubberEllipse';
INCLUDE '../Rubber/CenteredRubberRectWithArc';
INCLUDE '../Rubber/DoubleRubberArc';
INCLUDE '../Rubber/RubberArc';

(*************************** PIE SHAPE ********************************)

(* A pieslice is a section of a filled ellipse described by
 *      (x,y) = (c.x + hr*cos(a), c.y + vr*sin(a))
 * where c is the center, hr/vr is horizontal/vertical radius,
 *)

-- PieShapeOpenBody: descriptor --
(# (* Nothing special *) #)

-- PieShapeContainsPoint: descriptor --
(# i: @integer;            (* Angle in degrees *)
   a, cos_a, sin_a: @real; (* Radians *)
   x, y: @integer;
   c: @point;              (* transformed center *)
do 
   center.p -> privatepart.Go2CanvasTM.M.Transformpoint -> c;
   (c.x, c.y, horizontalradius.value, verticalradius.value,
   thepoint.x, thepoint.y) -> ellipseangle -> (a, cos_a, sin_a);
   
   (a * 180) div pi -> i;
   
   (if ((angle2.r)>360) and (i<180) then i+360 -> i
   if);
   
   ((angle1.r) < i) and (i < (angle2.r)) -> value;
   
   (if value then
       horizontalradius.value * cos_a -> x;
       value and (((thepoint.x-c.x)->abs) <= (x->abs)) -> value;
   if);
   
   (if value then
       verticalradius.value * sin_a -> y;
       value and (((thepoint.y-c.y)->abs) <= (y->abs)) -> value;
   if);	
#)

-- PieShapeIntersects: dopart --
do INNER;
   'PieShape.Intersects' -> UnImplemented;
   
-- PieShapeWithin: dopart --
do INNER;
   'PieShape.Within' -> UnImplemented;
   
-- PieShapeGetControlsBody: descriptor --
(# x, y: @integer;
do (* Corners *)
   (center.p, (-horizontalradius.value, verticalradius.value)) -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> spots.addpoint;
   (center.p, (horizontalradius.value, verticalradius.value)) -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> spots.addpoint;
   (center.p, (horizontalradius.value, -verticalradius.value)) -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> spots.addpoint;
   (center.p, (-horizontalradius.value, -verticalradius.value)) -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> spots.addpoint;
   
   (* Arc delimiters *)
   
   
   horizontalradius.value * (((angle1.r div 180) * pi) -> cos) -> x;
   verticalradius.value   * (((angle1.r div 180) * pi) -> sin) -> y;
   (center.p, (x,y)) -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> spots.addpoint;
   
   horizontalradius.value * (((angle2.r div 180) * pi) -> cos) -> x;
   verticalradius.value   * (((angle2.r div 180) * pi) -> sin) -> y;
   (center.p, (x,y)) -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> spots.addpoint;
#)

-- PieShapeCopyBody: descriptor --
(# aPie: ^PieShape;
do (if aCopy[]//NONE then (* Not done in inner *)
       &PieShape[] -> aPie[];
       center -> aPie.center;
       horizontalRadius -> aPie.horizontalRadius;
       verticalRadius -> aPie.verticalRadius;
       angle1 -> aPie.angle1;
       angle2 -> aPie.angle2;
       aPie[] -> aCopy[];
   if);
#)

-- PieShapeHiliteOutlineBody: descriptor --
(# cd, co: @point;
   x,y: @integer;
do 
   (if TM[]//NONE then
       center.p
         -> co
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> theCanvas.canvastodevice
         -> cd;
    else
       center.p
         -> TM.transformpoint
         -> co
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> theCanvas.canvastodevice
         -> cd;
   if);
   
   horizontalradius.value * (((angle1.r div 180) * pi) -> cos) -> x;
   verticalradius.value   * (((angle1.r div 180) * pi) -> sin) -> y;
   
   (co, (x,y))
     -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> theCanvas.canvastodevice
     -> (x,y);
   
   (cd, (x,y))
     -> theCanvas.immediateline;
   
   horizontalradius.value * (((angle2.r div 180) * pi) -> cos) -> x;
   verticalradius.value   * (((angle2.r div 180) * pi) -> sin) -> y;
   
   (co, (x,y))
     -> addpoints
     -> privatepart.Go2CanvasTM.M.Transformpoint
     -> theCanvas.canvastodevice
     -> (x,y);
   
   (cd, (x,y))
     -> theCanvas.immediateline;
   
   (cd.x, cd.y,
   horizontalradius.value, verticalradius.value,
   angle1.r, angle2.r) 
     -> theCanvas.immediatearc;
#)

-- PieShapeInteractiveCreateBody: descriptor --
(# a1, a2: @integer;
   irect: @theCanvas.immediaterect;
   outline: @rectangle;
do open; (* invalidates too *)
   (* Startpoint is in GO cords *)
   
   (* Determine center *)
   startPoint -> center.p; 
   (* center is in GO coords *)
   
   (* Determine horizontalradius, verticalradius *)
   (startpoint, startpoint, themodifier)
     -> &theCanvas.CenteredRubberEllipse
   (# initialize::<
        (# 
        do (center.x-width-1, center.y-height-1, 
           2*width+2, 2*height+2) -> irect
        #);
      Motion::<
        (# 
        do (center.x-width-1, center.y-height-1,
           2*width+2, 2*height+2) -> irect
        #);
      terminated::<
        (# 
        do (center.x-width-1, center.y-height-1,
           2*width+2, 2*height+2) -> outline;
        #);
   #)
     -> (horizontalradius.value, verticalradius.value);
   
   (* Determine angles *)
   (startpoint, horizontalradius.value, verticalradius.value, themodifier)
     -> &theCanvas.DoubleRubberArc
   (# iline: @theCanvas.immediateline;
      firstpoint: @point;
      initialize::<  (# do (devicecenter, arcpoint) -> iline #);
      motion::<      (# do (devicecenter, arcpoint) -> iline #);
      buttonpress::< 
        (# do (devicecenter, arcpoint->firstpoint) -> iline #);
      terminated::< 
        (# 
        do (* Erase extra feedback for THIS(DoubleRubberArc) *)
           (devicecenter, firstpoint) -> iline;
           (devicecenter, arcpoint) -> iline;
           (* Erase immediaterect from CenteredRubberEllipse *)
           outline -> irect;
        #);
   #)
     -> (a1, a2);
   
   a1 -> angle1.r;
   a2 -> angle2.r;
#)

-- PieShapeInteractiveReshapeBody: descriptor --
(# dim: @boolean;
   r: @rectangle;
   c: @point; (* Center in BifrostCanvas coords *)
   x, y, a1, a2: @integer;
   getangle: @EllipseAngle;
   GB: @GetBounds;
do 
   (* startpoint is in GO coords *)
   
   (if (center.p.x-horizontalradius.value)=startpoint.x then
       (if (center.p.y-verticalradius.value)=startpoint.y then
           true -> dim;
       if);
       (if (center.p.y+verticalradius.value)=startpoint.y then
           true -> dim;
       if);
   if);
   (if (center.p.x+horizontalradius.value)=startpoint.x then
       (if (center.p.y-verticalradius.value)=startpoint.y then
           true -> dim;
       if);
       (if (center.p.y+verticalradius.value)=startpoint.y then
           true -> dim;
       if);
   if);
   
   center.p
     -> privatePart.Go2CanvasTM.M.TransformPoint 
     -> c;
   
   startpoint
     -> privatePart.Go2CanvasTM.M.TransformPoint 
     -> startPoint;
   
   (* c and startpoint is in BifrostCanvas coords *)
   
   GB -> theCanvas.damaged;
   
   (if dim then (* Change dimensions *)
       (c, startpoint, themodifier, angle1.r, angle2.r) 
         -> &theCanvas.CenteredRubberRectWithArc
       (# iline: @theCanvas.immediateline;
          buttonrelease::< (# do true -> stopinteraction #);
          initialize::<
            (#
            do (devicecenter, p1) -> iline;
               (devicecenter, p2) -> iline;
            #);
          motion::<
            (#
            do (devicecenter, p1) -> iline;
               (devicecenter, p2) -> iline;
            #);
          terminated::<
            (#
            do (devicecenter, p1) -> iline;
               (devicecenter, p2) -> iline;
            #);
       #)
         -> r;
       r.width  div 2 -> horizontalradius;
       r.height div 2 -> verticalradius;
       
    else (* Change one of the angles *)
       
       (* Determine which angle to change *)	
       horizontalradius.value * ((angle1.r div 180) * pi -> cos) -> x;
       verticalradius.value   * ((angle1.r div 180) * pi -> sin) -> y;
       (center.p, (x,y)) -> addpoints
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> (x,y);
       (if (startpoint, (x,y))->equalpoint then (* Change angle1 *)
           angle1.r -> a1;
           angle2.r -> a2;
        else (* Change angle2 *)
           angle2.r -> a1;
           angle1.r -> a2;
       if);
       
       (a1, a2, c, horizontalradius.value, verticalradius.value, themodifier) 
         -> &theCanvas.RubberArc
       (# iline:@theCanvas.immediateline;
          buttonrelease::<
            (# do true -> stopinteraction #);
          initialize::< 
            (# do (devicecenter, arcpoint) -> iline #);
          motion::<
            (# do (devicecenter, arcpoint) -> iline #);
          terminated::<
            (# do (devicecenter, arcpoint) -> iline #);
       #)
         -> (angle1, angle2);
   if);
   
   GB -> theCanvas.damaged;
   theCanvas.repair;
#)

-- PieShapeTransformBody: dopart --
do INNER;

-- PieShapeGetBoundsBody: descriptor --
(#	
   cx, cy, x1, x2, y1, y2: @integer;
   a1, a2, hr, vr: @real;
   maxx, maxy, minx, miny: @integer;
   i1, i2: @integer;
   min1, min2: @Min;
   max1, max2: @Max;
   
do (if privatepart.boundInvalid then
       center.p -> privatepart.Go2CanvasTM.M.Transformpoint -> (cx, cy);
       horizontalradius.value -> hr;
       verticalradius.value   -> vr;
       (angle1.r * pi) div 180 -> a1;
       (angle2.r * pi) div 180 -> a2;
       
       cx + hr * (a1->cos) -> x1;
       cx + hr * (a2->cos) -> x2;
       cy + vr * (a1->sin) -> y1;
       cy + vr * (a2->sin) -> y2;
       
       
       (* ( (x1, x2) -> max1, cx) -> max2 -> maxx;
        * ( (x1, x2) -> min1, cx) -> min2 -> minx;
        * ( (y1, y2) -> max1, cy) -> max2 -> maxy;
        * ( (y1, y2) -> min1, cy) -> min2 -> miny;
        * error!
        *)
       ( (x1, x2) -> max, cx) -> max -> maxx;
       ( (x1, x2) -> min, cx) -> min -> minx;
       ( (y1, y2) -> max, cy) -> max -> maxy;
       ( (y1, y2) -> min, cy) -> min -> miny;
       
       (* Take extreme arc parts into account.
        * Assume
        *    0 <= a1 <= 360
        *   a1 <= a2 <= 360+a1 
        *)
       
       angle1.r -> i1;
       angle2.r -> i2;
       
       (if ((i1<90) and (90<i2))   or (450<=i2) then
           cy + verticalradius.value   -> maxy;
       if);
       
       (if ((i1<180) and (180<i2)) or (540<=i2) then
           cx - horizontalradius.value -> minx;
       if);
       
       (if ((i1<270) and (270<i2)) or (630<=i2) then
           cy - verticalradius.value   -> miny;
       if);
       
       (if (360<=i2) then
           cx + horizontalradius.value -> maxx
       if);
       
       (minx-1, maxy+1, maxx-minx+2, maxy-miny+2) -> privatepart.bound;
       false -> privatepart.boundinvalid;
       
   if);
#)


-- PieShapeBody: dopart --
do INNER;
