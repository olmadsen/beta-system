ORIGIN '../Impl/PredefinedImpl';
INCLUDE '../Rubber/RubberLine';

(*************************** LINE SHAPE **********************************)

-- LineShapeOpenBody: dopart --
do (0,0) -> begin -> end;
   INNER;
   
   
-- LineShapeGetBoundsBody: descriptor --
(# w: @Integer;  (* half line width *)
   absi: @abs;
do (if privatepart.boundInvalid then
       (begin.p.x-end.p.x -> absi) + width +1 -> privatepart.bound.width;
       (begin.p.y-end.p.y -> absi) + width +1 -> privatepart.bound.height;
       (width div 2) -> w;
       (* upperLeft *)
       ((begin.p.x,end.p.x) -> Min) - w -> privatepart.bound.x;
       ((begin.p.y,end.p.y) -> Max) + w -> privatepart.bound.y;
       privatepart.bound -> privatepart.go2canvasTM.m.transformrectangle 
         -> privatepart.bound;
       false -> privatepart.boundinvalid;
   if);
#)

-- LineShapeGetControlsBody: dopart --
do (* transform points into BifrostCanvas coord. *)
   begin -> privatepart.Go2CanvasTM.M.TransformPoint -> spots.addpoint;
   end   -> privatepart.Go2CanvasTM.M.TransformPoint -> spots.addpoint;
   INNER;
   
   
-- LineShapeCopyBody: descriptor --
(# l: ^LineShape;
do (if aCopy[]//NONE then (* Not done in inner *)
       &LineShape[] -> l[];
       l.open;
       begin -> l.begin;
       end -> l.end;
       cap -> l.cap;
       width -> l.width;
       (if dashes.d[]//none then else dashes.d.copy -> l.dashes; if);
       l[] -> aCopy[];
   if);
#)

-- LineHiliteOutlineBody: descriptor --
(# b,e: @point;
do 
   (if TM[] // NONE then
       begin -> privatepart.Go2CanvasTM.M.Transformpoint -> b;
       end -> privatepart.Go2CanvasTM.M.Transformpoint -> e;
    else
       begin 
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> TM.transformpoint -> b;
       end 
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> TM.transformpoint -> e;
   if);
   
   (b -> theCanvas.canvastodevice, e -> theCanvas.canvastodevice)
     -> theCanvas.immediateline;
#)

-- LineInteractiveCreateBody: descriptor --
(# anchorpoint, mousepoint: @point;
   GB: @GetBounds;
do open;
   (* startpoint is in GO coords *)
   GB -> theCanvas.damaged;
   startpoint 
     -> theCanvas.CanvasToDevice
     -> anchorpoint 
     -> mousePoint;
   
   (anchorpoint, mousepoint, themodifier) 
     -> &theCanvas.RubberLine 
     -> mousepoint;
   
   anchorPoint
     -> theCanvas.DeviceToCanvas
     -> begin;
   mousePoint
     -> theCanvas.DeviceToCanvas
     -> end;
#)

-- LineShapeInteractiveReshapeBody: descriptor --
(# mousePoint,anchorPoint: @Point;
   changebegin: @boolean; (* Is it begin that is to be changed ? *)
   GB: @GetBounds;
do GB -> theCanvas.damaged;
   (* startpoint is in GO coords *)
   (if (startpoint, begin.p)->equalpoint then
       begin
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> theCanvas.CanvasToDevice
         -> mousepoint;
       end
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> theCanvas.CanvasToDevice
         -> anchorpoint;
       true -> changebegin;
    else
       end
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> theCanvas.CanvasToDevice
         -> mousepoint;
       begin
         -> privatepart.Go2CanvasTM.M.Transformpoint
         -> theCanvas.CanvasToDevice
         -> anchorpoint;
   if);
   
   (anchorpoint, mousepoint, themodifier) 
     -> &theCanvas.RubberLine
   (# ButtonRelease::< (# do true -> stopinteraction #) #)
     -> mousepoint;
   
   mousePoint
     -> theCanvas.DeviceToCanvas
     -> privatepart.go2canvasTM.m.inversetransformpoint
     -> mousepoint;
   (if changebegin then mousepoint -> begin
    else mousepoint -> end
   if);
   GB -> theCanvas.damaged;
   theCanvas.repair;
#)

-- LineShapeTransformBody: dopart --
do begin -> M.transformPoint -> begin;
   end   -> M.transformPoint -> end;
   INNER;
   
-- LineShapeContainsPoint: dopart --
do calculateshape;
   (theCanvas[],thePoint) -> preprivate.calculatedshape.containspoint -> value;
   INNER;

-- LineShapeCalculate: dopart --
do (if privatepart.invalid then
       &Shape[] -> prePrivate.calculatedShape[];
       begin -> prePrivate.calculatedShape.open;
       end -> prePrivate.calculatedShape.lineto;
       (width, cap, JoinBevel) -> prePrivate.calculatedShape.stroke;
       (* (if privatepart.go2canvasTM.m[]<>IDmatrix
        * then
        *)
       &Matrix[]
         -> prePrivate.calculatedShape.privatepart.go2canvasTM.m[];
       privatepart.go2canvasTM.m 
         -> prePrivate.calculatedShape.privatepart.go2canvasTM.m.set;
       (* if); *)
       false -> privatepart.invalid;
   if);
   INNER;
