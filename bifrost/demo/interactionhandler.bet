ORIGIN '~beta/bifrost/v2.1/Bifrost';
INCLUDE '~beta/bifrost/v2.1/PredefinedGO';

-- PROGRAM: descriptor --

bifrost
(# 
   (* This is a demonstration of the use of a user-defined Interaction
    * Handler for a BifrostCanvas.
    * In this application, Lines can be drawn in a BifrostCanvas. Instead of using 
    * interactiveCreateShape with the Line, a specialized InteractionHandler 
    * is used. This implements an interaction that is slightly different than
    * the one offered by interactiveCreate of Line: 
    * When Lines are drawn, they are by default constrained to angles, that
    * are multiples of 90 degrees. If a modifier, in this case SHIFT is held
    * down during the interaction, it will be unconstrained.
    *) 
   theWindow: @window
     (# 
        myCanvas: @BifrostCanvas
          (# 
             RubberLine: InteractionHandler
               (# mousePoint,anchorPoint: @Point; (* Device coords *)
                  themodifier: @modifier;
                  stopInteraction: @boolean;
                  x,y: @integer;
                  
                  (* Static instances of heavily used patterns to avoid 
                   * generating too much garbage. Only used for efficiency
                   *)
                  myabs: @abs;
                  iline: @immediateLine;
                  
                  Initialize:: 
                    (# 
                    do (* Draw initial feedback *)
                       (anchorpoint, mousePoint)->iline;
                    #);
                  
                  Motion:: 
                    (# 
                    do (* Erase old feedback *)
                       (anchorpoint, mousePoint)->iline;
                       
                       (* Find new position to draw to *)
                       GetPointerLocation->mousePoint;
                       (if not (themodifier->isModifierOn) then
                           (* Constrain angles *)
                           (mousepoint.x-anchorpoint.x)->myabs->x;
                           (mousepoint.y-anchorpoint.y)->myabs->y;
                           (if y > x then 
                               (* Constrain to 90 degrees *)
                               anchorpoint.x->mousepoint.x
                            else
                               (* Constrain to 0 degrees *)
                               anchorpoint.y->mousepoint.y
                           if);
                       if);
                       (* Draw new feedback *)
                       (anchorpoint, mousePoint)->iline;
                    #);
                  ButtonPress:: 
                    (# do true->stopInteraction; #);
                  TerminateCondition:: 
                    (# do stopInteraction->value; #);
                  Terminated:: 
                    (# (* erase feedback *)
                    do (anchorpoint, mousePoint)->iline;
                    #);
                  
               enter (anchorpoint, mousepoint, themodifier)
               exit mousepoint
               #);
             
             aLine: ^Line;
             blackpaint: @SolidColor;

             open:: 
               (# 
               do (300, 300)->Size;
                  blackpaint.init;
                  (0, 0, 0)->blackpaint.name;
               #);
             eventhandler:: 
               (# onMouseDown:: 
		    (# 
		    do &Line[]->aLine[];
		       aLine.init;
		       (* Instead of using 
		        *     (aLine[], ...)->interactiveCreateShape
		        * we  set the attributes of aLine.theShape using
		        * an instance of the RubberLine pattern above
		        *)
		       3->aLine.width;
		       mousepos->deviceToCanvas->aLine.begin;
		       (mousepos, mousepos, ShiftModifier)
		         -> &RubberLine
		         -> devicetocanvas
		         -> aLine.end;
		       blackpaint[]->aLine.setpaint;
		       aLine[]->draw;
                    #);
                  onKeyDown:: 
                    (# 
                    do (if ch//'q'//'Q' then Terminate if)
                    #);
               #) (* eventhandler *);
          #) (* myCanvas *);
        open:: 
          (# 
          do myCanvas.open;
          #);
     #) (* theWindow *)
do theWindow.open;
#)
