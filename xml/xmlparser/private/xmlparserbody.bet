ORIGIN '../xmlparser';
INCLUDE '~beta/basiclib/external';
INCLUDE '~beta/sysutils/cstring';

BUILD nti     '$$/xmlparse.obj' 'external/xmlparse.c' 'betacc -v $0 $1'
      ppcmac  ':$$:xmlparse.obj' ':external/xmlparse.c' 'mrc -proto strict -proto auto -shared_lib_export on -o $0 $1'
      default '$$/xmlparse.o' 'external/xmlparse.c' '$CC -D$$ -c -o $0 $1';

BUILD nti     '$$/hashtable.obj' 'external/hashtable.c' 'betacc -v $0 $1'
      ppcmac  ':$$:hashtable.obj' ':external/hashtable.c' 'mrc -proto strict -proto auto -shared_lib_export on -o $0 $1'
      default '$$/hashtable.o' 'external/hashtable.c' '$CC -D$$ -c -o $0 $1';

BUILD nti     '$$/xmltok.obj' 'external/xmltok.c' 'betacc -v $0 $1'
      ppcmac  ':$$:xmltok.obj' ':external/xmltok.c' 'mrc -proto strict -proto auto -shared_lib_export on -o $0 $1'
      default '$$/xmltok.o' 'external/xmltok.c' '$CC -D$$ -c -o $0 $1';

BUILD nti     '$$/xmlrole.obj' 'external/xmlrole.c' 'betacc -v $0 $1'
      ppcmac  ':$$:xmlrole.obj' ':external/xmlrole.c' 'mrc -proto strict -proto auto -shared_lib_export on -o $0 $1'
      default '$$/xmlrole.o' 'external/xmlrole.c' '$CC -D$$ -c -o $0 $1';

-- lib: attributes --

trace_xml: (# exit false #);
(* Various C functions *)
malloc: External
  (# size: @integer;
     ptr: @integer;
  enter size
  exit ptr
  #);
memcpy: external
  (# s1, s2, nbytes: @int32;
  enter (s1, s2, nbytes)
  exit s1
  #);

XML_ParserCreate: External
  (# encoding: @int32;
     retval: @int32;
  enter encoding
  exit retval
  #);

XML_ParserCreateNS: External
  (# encoding: @int32;
     namespaceSeparator: @char;
     retval: @int32;
  enter (encoding, namespaceSeparator)
  exit retval
  #);

XML_SetElementHandler: External
  (# parser: @int32;
     start: @int32;
     end: @int32;
  enter (parser, start, end)
  #);

XML_SetCharacterDataHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_SetProcessingInstructionHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_SetCommentHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_SetCdataSectionHandler: External
  (# parser: @int32;
     start: @int32;
     end: @int32;
  enter (parser, start, end)
  #);

XML_SetDefaultHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_SetUnparsedEntityDeclHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_SetNotationDeclHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_SetNamespaceDeclHandler: External
  (# parser: @int32;
     start: @int32;
     end: @int32;
  enter (parser, start, end)
  #);

XML_SetExternalEntityRefHandler: External
  (# parser: @int32;
     handler: @int32;
  enter (parser, handler)
  #);

XML_Parse: External
  (# parser: @int32;
     s: @int32;
     len: @int32;
     isFinal: @int32;
     retval: @int32;
  enter (parser, s, len, isFinal)
  exit retval   
  #);

XML_ParserFree: External
  (# parser: @int32;
  enter parser
  #);

XML_GetErrorCode: External
  (# parser: @int32;
     retval: @int32;
  enter parser
  exit retval
  #);

XML_GetCurrentLineNumber: External
  (# parser: @int32;
     retval: @int32;
  enter parser
  exit retval
  #);

XML_GetCurrentColumnNumber: External
  (# parser: @int32;
     retval: @int32;
  enter parser
  exit retval
  #);

XML_GetCurrentByteIndex: External
  (# parser: @int32;
     retval: @int32;
  enter parser
  exit retval
  #);

XML_GetCurrentByteCount: External
  (# parser: @int32;
     retval: @int32;
  enter parser
  exit retval
  #);

XML_ErrorString: External
  (# error: @int32;
     retval: @int32;
  enter error
  exit retval
  #);

--- XMLParserLib:Attributes ---
CBF_ElementStart: External
  (# userData: @int32;
     name: @int32;
     atts: @int32;
  enter (userData, name, atts)
  do cExternalEntry;
     (# i, j: @int32;
        cstr: @CString;
        attname: @CString;
        attvalue: @CString;
        attlist: @AttributeList;
        att: ^Attribute;
     do While:
          (#
          do %getLongAt (atts+i)->j;
             (if j = 0 then
                 leave While; 
             if);
             &Attribute[]->att[];
             %getLongAt (atts+i)->attname;
             %getLongAt (atts+i+4)->attvalue;
             (attname.get, attvalue.get)->att;
             att[]->attlist.append;
             i+8->i;
             restart While;
          #);
        name->cstr;
        (cstr.get, attlist[])->onElementStart;
     #);
  #);

CBF_ElementEnd: External
  (# userData: @int32;
     name: @int32;
  enter (userData, name)
  do cExternalEntry;
     (# cstr: @CString;
     do name->cstr;
        cstr.get->onElementEnd;
     #);
  #);

CBF_CharacterData: External
  (# userData: @int32;
     s: @int32;
     len: @int32;
  enter (userData, s, len)
  do cExternalEntry;
     (# t: ^Text;
     do &Text[]->t[];
        (if len>0 then
            len->t.T.new;
            (@@t.T[1], s, len)->memcpy;
            len->t.lgth;
            len->t.pos;
        if);
        t[]->onCharacterData;
     #);
  #);

CBF_ProcessingInstruction: External
  (# userData: @int32;
     target: @int32;
     data: @int32;
  enter (userData, target, data)   
  do cExternalEntry;
     (# ctarget: @CString;
        cdata: @CString;
     do target->ctarget;
        data->cdata;
        (ctarget.get, cdata.get)->onProcessingInstruction;
     #);
  #);

CBF_Comment: External
  (# userData: @int32;
     data: @int32;
  enter (userData, data)
  do cExternalEntry;
     (# cdata: @CString;
     do data->cdata;
        cdata.get->onComment;
     #);
  #);

CBF_CDataStart: External
  (# userData: @int32;
  enter userData
  do cExternalEntry;
     onCDataStart;
  #);

CBF_CDataEnd: External
  (# userData: @int32;
  do cExternalEntry;
     onCDataEnd;
  #);

CBF_Default: External
  (# userData: @int32;
     s: @int32;
     len: @int32;
  enter (userData, s, len)
  do cExternalEntry;
     (# t: ^Text;
     do &Text[]->t[];
        (if len > 0 then
            len->t.T.new;
            (@@t.T[1], s, len)->memcpy;
            len->t.lgth;
            len->t.pos;
        if);
        t[]->onDefault;
     #);
  #); 

CBF_UnparsedEntity: External
  (# userData: @int32;
     entityName: @int32;
     base: @int32;
     systemId: @int32;
     publicId: @int32;
     notationName: @int32;
  enter (userData, entityName, base, systemId, publicId, notationName)
  do cExternalEntry;
     (# cEntityName: @CString;
        cBase: @CString;
        cSystemId: @CString;
        cPublicId: @CString;
        cNotationName: @CString;
     do entityName->cEntityName;
        base->cBase;
        systemId->cSystemId;
        publicId->cPublicId;
        notationName->cNotationName;
        (cEntityName.get, cBase.get, cSystemId.get, cPublicId.get, cNotationName.get)->onUnparsedEntity;
     #);
  #);

CBF_Notation: External
  (# userData: @int32;
     notationName: @int32;
     base: @int32;
     systemId: @int32;
     publicId: @int32;
  enter (userData, notationName, base, systemId, publicId)
  do cExternalEntry;
     (# cNotationName: @CString;
        cBase: @CString;
        cSystemId: @CString;
        cPublicId: @CString;
     do notationName->cNotationName;
        base->cBase;
        systemId->cSystemId;
        publicId->cPublicId;
        (cNotationName.get, cBase.get, cSystemId.get, cPublicId.get)->onNotation;
     #);   
  #);

CBF_NamespaceStart: External
  (# userData: @int32;
     prefix: @int32;
     uri: @int32;
  enter (userData, prefix, uri)
  do cExternalEntry;
     (# cPrefix: @CString;
        cUri: @CString;
     do prefix->cPrefix;
        uri->cUri;
        (cPrefix.get, cUri.get)->onNamespaceStart;
     #);
  #);

CBF_NamespaceEnd: External
  (# userData: @int32;
     prefix: @int32;
  enter (userData, prefix)
  do cExternalEntry;
     (# cstr: @CString;
     do prefix->cstr;
        cstr.get->onNamespaceEnd;
     #);
  #);

CBF_ExternalEntity: External
  (# userData: @int32;
     context: @int32;
     base: @int32;
     systemId: @int32;
     publicId: @int32;
  enter (userData, context, base, systemId, publicId)
  do cExternalEntry;
     (# cContext: @CString;
        cBase: @CString;
        cSystemId: @CString;
        cPublicId: @CString;
     do context->cContext;
        base->cBase;
        systemId->cSystemId;
        publicId->cPublicId;
        (cContext.get, cBase.get, cSystemId.get, cPublicId.get)->onExternalEntity;
     #);
  #);


--- XMLParserInit:DoPart ---
do (* Initialize encoding. *)
   false->Private.useNamespaces;
   (if encoding[] <> NONE then
       encoding->Private.encoding;
    else
       Private.encoding.clear;
   if);
   
   (* Create callback functions. *)
   (if Private.elementStartAddr = 0 then
       CBF_ElementStart##->makeCBF->Private.elementStartAddr;
   if);
   (if Private.elementEndAddr = 0 then
       CBF_ElementEnd##->makeCBF->Private.elementEndAddr;
   if);
   (if Private.characterDataAddr = 0 then
       CBF_CharacterData##->makeCBF->Private.characterDataAddr;
   if);
   (if Private.processingInstructionAddr = 0 then
       CBF_ProcessingInstruction##->makeCBF->Private.processingInstructionAddr;
   if);
   (if Private.commentAddr = 0 then
       CBF_Comment##->makeCBF->Private.commentAddr;
   if);
   (if Private.cDataStartAddr = 0 then
       CBF_CDataStart##->makeCBF->Private.cDataStartAddr;
   if);
   (if Private.cDataEndAddr = 0 then
       CBF_CDataEnd##->makeCBF->Private.cDataEndAddr;
   if);
   (if Private.defaultAddr = 0 then
       CBF_Default##->makeCBF->Private.defaultAddr;
   if);
   (if Private.unparsedEntityAddr = 0 then
       CBF_UnparsedEntity##->makeCBF->Private.unparsedEntityAddr;
   if);
   (if Private.notationAddr = 0 then
       CBF_Notation##->makeCBF->Private.notationAddr;
   if);
   (if Private.namespaceStartAddr = 0 then
       CBF_NamespaceStart##->makeCBF->Private.namespaceStartAddr;
   if);
   (if Private.namespaceEndAddr = 0 then
       CBF_NamespaceEnd##->makeCBF->Private.namespaceEndAddr;
   if);
   (if Private.externalEntityAddr = 0 then
       CBF_ExternalEntity##->makeCBF->Private.externalEntityAddr;
   if);
   
   (* Mark the parser as ready. *)
   true->Private.ready;
   INNER;
   
--- XMLParserInitNS:DoPart ---
do true->Private.useNamespaces;
   namespaceSeparator->Private.namespaceSeparator;
   
--- XMLParserClose:DoPart ---
do (* Mark the parser as not ready. *)
   false->Private.ready;
   
   (* Destroy callback functions. *)
   (if Private.elementStartAddr <> 0 then
       Private.elementStartAddr->freeCBF;
       0->Private.elementStartAddr;
   if);
   (if Private.elementEndAddr <> 0 then
       Private.elementEndAddr->freeCBF;
       0->Private.elementEndAddr;
   if);
   (if Private.characterDataAddr <> 0 then
       Private.characterDataAddr->freeCBF;
       0->Private.characterDataAddr;
   if);
   (if Private.processingInstructionAddr <> 0 then
       Private.processingInstructionAddr->freeCBF;
       0->Private.processingInstructionAddr;
   if);
   (if Private.commentAddr <> 0 then
       Private.commentAddr->freeCBF;
       0->Private.commentAddr;
   if);
   (if Private.cDataStartAddr <> 0 then
       Private.cDataStartAddr->freeCBF;
       0->Private.cDataStartAddr;
   if);
   (if Private.cDataEndAddr <> 0 then
       Private.cDataEndAddr->freeCBF;
       0->Private.cDataEndAddr;
   if);
   (if Private.defaultAddr <> 0 then
       Private.defaultAddr->freeCBF;
       0->Private.defaultAddr;
   if);
   (if Private.unparsedEntityAddr <> 0 then
       Private.unparsedEntityAddr->freeCBF;
       0->Private.unparsedEntityAddr;
   if);
   (if Private.notationAddr <> 0 then
       Private.notationAddr->freeCBF;
       0->Private.notationAddr;
   if);
   (if Private.namespaceStartAddr <> 0 then
       Private.namespaceStartAddr->freeCBF;
       0->Private.namespaceStartAddr;
   if);
   (if Private.namespaceEndAddr <> 0 then
       Private.namespaceEndAddr->freeCBF;
       0->Private.namespaceEndAddr;
   if);
   (if Private.externalEntityAddr <> 0 then
       Private.externalEntityAddr->freeCBF;
       0->Private.externalEntityAddr;
   if);
   
--- XMLParserPrivate:Descriptor ---
(# (* Parser state. *)
   useNamespaces: @Boolean;
   ready: @Boolean;
   
   (* Parser encoding and namespaceSeparator. *)
   encoding: @Text;
   namespaceSeparator: @Char;
   
   (* Parser address. *)
   parserAddr: @int32;
   
   (* Callback function addresses. *)
   elementStartAddr: @int32;
   elementEndAddr: @int32;
   characterDataAddr: @int32;
   processingInstructionAddr: @int32;
   commentAddr: @int32;
   cDataStartAddr: @int32;
   cDataEndAddr: @int32;
   defaultAddr: @int32;
   unparsedEntityAddr: @int32;
   notationAddr: @int32;
   namespaceStartAddr: @int32;
   namespaceEndAddr: @int32;
   externalEntityAddr: @int32;
#)

--- XMLParserDoPart: DoPart ---
do Parse:
     (#
     do (* Make sure the parser is ready. *)
        (if not Private.ready then 
            ('parser not properly initialized', 0, 0, 0, 0)->onError;
            leave Parse;
        if);
        
        (* Create a new parser instance. *)
        (if Private.useNamespaces then
            (if not Private.encoding.empty then
                (@@Private.encoding.T[1], Private.namespaceSeparator)->XML_ParserCreateNS->Private.parserAddr;
             else
                (0, Private.namespaceSeparator)->XML_ParserCreateNS->Private.parserAddr;
            if);
         else
            (if not Private.encoding.empty then
                @@Private.encoding.T[1]->XML_ParserCreate->Private.parserAddr;
             else
                0->XML_ParserCreate->Private.parserAddr;
            if);
        if);
        
        (* Initialize the new parser instance. *)
        (if Private.parserAddr <> 0 then
            (* Register Expat handlers. *)
            (Private.parserAddr, Private.elementStartAddr, Private.elementEndAddr)->XML_SetElementHandler;
            (Private.parserAddr, Private.characterDataAddr)->XML_SetCharacterDataHandler;
            (Private.parserAddr, Private.processingInstructionAddr)->XML_SetProcessingInstructionHandler;
            (Private.parserAddr, Private.commentAddr)->XML_SetCommentHandler;
            (Private.parserAddr, Private.cDataStartAddr, Private.cDataEndAddr)->XML_SetCdataSectionHandler;
            (Private.parserAddr, Private.defaultAddr)->XML_SetDefaultHandler;
            (Private.parserAddr, Private.unparsedEntityAddr)->XML_SetUnparsedEntityDeclHandler;
            (Private.parserAddr, Private.notationAddr)->XML_SetNotationDeclHandler;
            (Private.parserAddr, Private.namespaceStartAddr, Private.namespaceEndAddr)->XML_SetNamespaceDeclHandler;
            (Private.parserAddr, Private.externalEntityAddr)->XML_SetExternalEntityRefHandler;
         else
            (* No new parser instance created. *)
            ('cannot create new parser instance', 0, 0, 0, 0)->onError;
            leave Parse;
        if);
        
        INNER XMLParser;
        
        While: 
          (# t: ^Text;
             errorCode: @Integer;
             cstr: @CString;
          do inputStream.getLine->t[];
             (* OBS!!!
              * Necessary to make sure that the text pointer given to XML_Parse
              * does NOT move during a callback from XML_Parse (it does NOT copy
              * the string!). Thus the need for cstr.set.
              *)
             (if inputStream.eos then
                 (if trace_xml then
                     'xmlparsebody.bet: XMLParser.Parse.While: Sending final string to Expat' -> putLine;
                 if);
                 t[]->cstr.set;
                 (Private.parserAddr, cstr, t.lgth, 1)->XML_Parse->errorCode;
              else
                 '\n'->t.append;
                 t[]->cstr.set;
                 (Private.parserAddr, cstr, t.lgth, 0)->XML_Parse->errorCode;
             if);
             cstr.free;
             (if errorCode = 0 then
                 (* A fatal error has occured! *)
                 Private.parserAddr->XML_GetErrorCode->errorCode;
                 errorCode->XML_ErrorString->cstr;
                 (cstr.get, 
                 Private.parserAddr->XML_GetCurrentLineNumber,
                 Private.parserAddr->XML_GetCurrentColumnNumber, 
                 Private.parserAddr->XML_GetCurrentByteIndex,
                 Private.parserAddr->XML_GetCurrentByteCount)->onError;
              else
                 (if not inputStream.eos then
                     restart While;
                 if);
             if);
          #);
        
        (* Free the parser instance. *)
        Private.parserAddr->XML_ParserFree;
     #);
   
