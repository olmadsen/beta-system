ORIGIN '../xmlparser';
INCLUDE '~beta/basiclib/external';
INCLUDE '~beta/sysutils/cstring';

(*BUILD nti '$$/parser.obj' 'external/parser.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/parserInternals.obj' 'external/parserInternals.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/error.obj' 'external/error.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/chvalid.obj' 'external/chvalid.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/xmlIO.obj' 'external/xmlIO.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/uri.obj' 'external/uri.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/nanohttp.obj' 'external/nanohttp.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/nanoftp.obj' 'external/nanoftp.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/encoding.obj' 'external/encoding.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/HTMLparser.obj' 'external/HTMLparser.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/tree.obj' 'external/tree.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/entities.obj' 'external/entities.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/hash.obj' 'external/hash.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/valid.obj' 'external/valid.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/xmlregexp.obj' 'external/xmlregexp.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/xmlunicode.obj' 'external/xmlunicode.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/dict.obj' 'external/dict.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/list.obj' 'external/list.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/HTMLtree.obj' 'external/HTMLtree.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/SAX2.obj' 'external/SAX2.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/catalog.obj' 'external/catalog.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/threads.obj' 'external/threads.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/xpath.obj' 'external/xpath.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/debugXML.obj' 'external/debugXML.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/xpointer.obj' 'external/xpointer.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/xmlmemory.obj' 'external/xmlmemory.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/globals.obj' 'external/globals.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
BUILD nti '$$/SAX.obj' 'external/SAX.c' 'betacc -D "NDEBUG" -D "WIN32" -D "_WINDOWS" -D "_MBCS" -D "LIBXML_STATIC"-v $0 $1';
*)

LIBFILE nti_ms 'external/win32/iconv.lib';
LIBFILE nti_ms 'external/win32/libxml2_a.lib';
LINKOPT linux '-lxml2'
	default '';

(*LINKOPT nti_ms 'external/win32/libxslt_a.lib';
LINKOPT nti_ms 'external/win32/libexslt_a.lib';*)

-- lib: attributes --

trace_xml: (# exit false #);
(* Various C functions *)
malloc: External
  (# size: @integer;
     ptr: @integer;
  enter size
  exit ptr
  #);
memcpy: external
  (# s1, s2, nbytes: @int32;
  enter (s1, s2, nbytes)
  exit s1
  #);

xmlSAXHandler: cstruct
  (# byteSize ::< (# do 128 -> value #);

     internalSubset: long (# pos::< (# do 0 -> value; #); #);
     isStandalone: long (# pos::< (# do 4 -> value; #); #);
     hasInternalSubset: long (# pos::< (# do 8 -> value; #); #);
     hasExternalSubset: long (# pos::< (# do 12 -> value; #); #);
     resolveEntity: long (# pos::< (# do 16 -> value; #); #);
     getEntity: long (# pos::< (# do 20 -> value; #); #);
     entityDecl: long (# pos::< (# do 24 -> value; #); #);
     notationDecl: long (# pos::< (# do 28 -> value; #); #);
     attributeDecl: long (# pos::< (# do 32 -> value; #); #);
     elementDecl: long (# pos::< (# do 36 -> value; #); #);
     unparsedEntityDecl: long (# pos::< (# do 40 -> value; #); #);
     setDocumentLocator: long (# pos::< (# do 44 -> value; #); #);
     startDocument: long (# pos::< (# do 48 -> value; #); #);
     endDocument: long (# pos::< (# do 52 -> value; #); #);
     startElement: long (# pos::< (# do 56 -> value; #); #);
     endElement: long (# pos::< (# do 60 -> value; #); #);
     reference: long (# pos::< (# do 64 -> value; #); #);
     characters: long (# pos::< (# do 68 -> value; #); #);
     ignorableWhitespace: long (# pos::< (# do 72 -> value; #); #);
      processingInstruction: long (# pos::< (# do 76 -> value; #); #);
     comment: long (# pos::< (# do 80 -> value; #); #);
     warning: long (# pos::< (# do 84 -> value; #); #);
     error: long (# pos::< (# do 88 -> value; #); #);
     fatalError: long (# pos::< (# do 92 -> value; #); #); (* unused *)
     getParameterEntity: long (# pos::< (# do 96 -> value; #); #);
     cdataBlock: long (# pos::< (# do 100 -> value; #); #);
     externalSubset: long (# pos::< (# do 104 -> value; #); #);
     initialized: long (# pos::< (# do 108 -> value; #); #);

     (* The following fields are extensions ava *)
     _private: long (# pos::< (# do 112 -> value; #); #);
     startElementNs: long (# pos::< (# do 116 -> value; #); #);
     endElementNs: long (# pos::< (# do 120 -> value; #); #);
     serror: long (# pos::< (# do 124 -> value; #); #);
  #);

xmlCreatePushParserCtxt: External
  (# sax: ^xmlSAXHandler;
     user_data: @int32;
     chunk: @int32;
     size: @int32;
     filename: @int32;
     parserContext: @int32;
     enter (sax[], user_data, chunk, size, filename)
     exit parserContext
  #);

xmlFreeParserCtxt: External
  (# ctxt: @int32;
  enter ctxt
  #);

xmlParseChunk: External
  (# ctxt: @int32;
     chunk: @int32;
     size: @int32;
     terminate: @int32;
     error: @int32;
     enter (ctxt, chunk, size, terminate)
     exit error
  #);

--- XMLParserLib:Attributes ---
CBF_ElementStart: External
  (# userData: @int32;
     name: @int32;
     atts: @int32;
  enter (userData, name, atts)
  do cExternalEntry;
     (# i, j: @int32;
        cstr: @CString;
        attname: @CString;
        attvalue: @CString;
        attlist: @AttributeList;
        att: ^Attribute;
     do (if atts <> 0 then
            While:
              (#
              do %getLongAt (atts+i)->j;
                 (if j = 0 then
                     leave While; 
                 if);
                 &Attribute[]->att[];
                 %getLongAt (atts+i)->attname;
                 %getLongAt (atts+i+4)->attvalue;
                 (attname.get, attvalue.get)->att;
                 att[]->attlist.append;
                 i+8->i;
                 restart While;
              #);
        if);
        name->cstr;
        (cstr.get, attlist[])->onElementStart;
     #);
  #);

CBF_ElementEnd: External
  (# userData: @int32;
     name: @int32;
  enter (userData, name)
  do cExternalEntry;
     (# cstr: @CString;
     do name->cstr;
        cstr.get->onElementEnd;
     #);
  #);

CBF_CharacterData: External
  (# userData: @int32;
     s: @int32;
     len: @int32;
  enter (userData, s, len)
  do cExternalEntry;
     (# t: ^Text;
     do &Text[]->t[];
        (if len>0 then
            len->t.T.new;
            (@@t.T[1], s, len)->memcpy;
            len->t.lgth;
            len->t.pos;
        if);
        onCDataStart;
        t[]->onCharacterData;
        onCDataEnd;
     #);
  #);

CBF_ProcessingInstruction: External
  (# userData: @int32;
     target: @int32;
     data: @int32;
  enter (userData, target, data)   
  do cExternalEntry;
     (# ctarget: @CString;
        cdata: @CString;
     do target->ctarget;
        data->cdata;
        (ctarget.get, cdata.get)->onProcessingInstruction;
     #);
  #);

CBF_Comment: External
  (# userData: @int32;
     data: @int32;
  enter (userData, data)
  do cExternalEntry;
     (# cdata: @CString;
     do data->cdata;
        cdata.get->onComment;
     #);
  #);

CBF_CDataStart: External
  (# userData: @int32;
  enter userData
  do cExternalEntry;
     onCDataStart;
  #);

CBF_CDataEnd: External
  (# userData: @int32;
  do cExternalEntry;
     onCDataEnd;
  #);

CBF_Default: External
  (# userData: @int32;
     s: @int32;
     len: @int32;
  enter (userData, s, len)
  do cExternalEntry;
     (# t: ^Text;
     do &Text[]->t[];
        (if len > 0 then
            len->t.T.new;
            (@@t.T[1], s, len)->memcpy;
            len->t.lgth;
            len->t.pos;
        if);
        t[]->onDefault;
     #);
  #); 

CBF_UnparsedEntity: External
  (# userData: @int32;
     entityName: @int32;
     systemId: @int32;
     publicId: @int32;
     notationName: @int32;
  enter (userData, entityName, systemId, publicId, notationName)
  do cExternalEntry;
     (# cEntityName: @CString;
        cSystemId: @CString;
        cPublicId: @CString;
        cNotationName: @CString;
     do entityName->cEntityName;
        systemId->cSystemId;
        publicId->cPublicId;
        notationName->cNotationName;
        (cEntityName.get, '', cSystemId.get, cPublicId.get, cNotationName.get)->onUnparsedEntity;
     #);
  #);

CBF_Notation: External
  (# userData: @int32;
     notationName: @int32;
     systemId: @int32;
     publicId: @int32;
  enter (userData, notationName, systemId, publicId)
  do cExternalEntry;
     (# cNotationName: @CString;
        cSystemId: @CString;
        cPublicId: @CString;
     do notationName->cNotationName;
        systemId->cSystemId;
        publicId->cPublicId;
        (cNotationName.get, '', cSystemId.get, cPublicId.get)->onNotation;
     #);   
  #);

CBF_NamespaceStart: External
  (# userData: @int32;
     prefix: @int32;
     uri: @int32;
  enter (userData, prefix, uri)
  do cExternalEntry;
     (# cPrefix: @CString;
        cUri: @CString;
     do prefix->cPrefix;
        uri->cUri;
        (cPrefix.get, cUri.get)->onNamespaceStart;
     #);
  #);

CBF_NamespaceEnd: External
  (# userData: @int32;
     prefix: @int32;
  enter (userData, prefix)
  do cExternalEntry;
     (# cstr: @CString;
     do prefix->cstr;
        cstr.get->onNamespaceEnd;
     #);
  #);

CBF_ExternalEntity: External
  (# userData: @int32;
     context: @int32;
     systemId: @int32;
     publicId: @int32;
  enter (userData, context, systemId, publicId)
  do cExternalEntry;
     (# cContext: @CString;
        cSystemId: @CString;
        cPublicId: @CString;
     do context->cContext;
        systemId->cSystemId;
        publicId->cPublicId;
        (cContext.get, '', cSystemId.get, cPublicId.get)->onExternalEntity;
     #);
  #);


--- XMLParserInit:DoPart ---
do (* Initialize encoding. *)
   false->Private.useNamespaces;
   
   (* Create callback functions. *)
   (if Private.theSAXHandler.startElement = 0 then
       CBF_ElementStart##->makeCBF->Private.theSAXHandler.startElement;
   if);
   (if Private.theSAXHandler.endElement = 0 then
       CBF_ElementEnd##->makeCBF->Private.theSAXHandler.endElement;
   if);
   (if Private.theSAXHandler.cdataBlock = 0 then
(*       CBF_CharacterData##->makeCBF->Private.theSAXHandler.cdataBlock;*)
       CBF_CharacterData##->makeCBF->Private.theSAXHandler.characters;
   if);
   (if Private.theSAXHandler.processingInstruction = 0 then
       CBF_ProcessingInstruction##->makeCBF->Private.theSAXHandler.processingInstruction;
   if);
   (if Private.theSAXHandler.comment = 0 then
       CBF_Comment##->makeCBF->Private.theSAXHandler.comment;
   if);
(*   (if Private.cDataStartAddr = 0 then
       CBF_CDataStart##->makeCBF->Private.cDataStartAddr;
   if);
   (if Private.cDataEndAddr = 0 then
       CBF_CDataEnd##->makeCBF->Private.cDataEndAddr;
   if);*)
(*   (if Private.defaultAddr = 0 then
       CBF_Default##->makeCBF->Private.defaultAddr;
   if);*)
   (if Private.theSAXHandler.unparsedEntityDecl = 0 then
       CBF_UnparsedEntity##->makeCBF->Private.theSAXHandler.unparsedEntityDecl;
   if);
   (if Private.theSAXHandler.notationDecl = 0 then
       CBF_Notation##->makeCBF->Private.theSAXHandler.notationDecl;
   if);
   (if Private.theSAXHandler.externalSubset = 0 then
       CBF_ExternalEntity##->makeCBF->Private.theSAXHandler.externalSubset;
   if);
   
   (* Mark the parser as ready. *)
   INNER;
   1 -> Private.theSAXHandler.initialized;
   
--- XMLParserInitNS:DoPart ---
do true->Private.useNamespaces;
   ('do not turn on namespaces', 0, 0, 0, 0)->onError;
   
(*
   (if Private.theSAXHandler.startElementNs = 0 then
       CBF_NamespaceStart##->makeCBF->Private.theSAXHandler.startElementNs;
   if);
   (if Private.theSAXHandler.endElementNs = 0 then
       CBF_NamespaceEnd##->makeCBF->Private.endElementNs;
   if);*)
   namespaceSeparator->Private.namespaceSeparator;
   
--- XMLParserClose:DoPart ---
do (* Mark the parser as not ready. *)
   0 -> Private.theSAXHandler.initialized;
   
   (* Destroy callback functions. *)
   (if Private.theSAXHandler.startElement <> 0 then
       Private.theSAXHandler.startElement->freeCBF;
       0->Private.theSAXHandler.startElement;
   if);
   (if Private.theSAXHandler.endElement <> 0 then
       Private.theSAXHandler.endElement->freeCBF;
       0->Private.theSAXHandler.endElement;
   if);
   (if Private.theSAXHandler.cdataBlock <> 0 then
       Private.theSAXHandler.cdataBlock->freeCBF;
       0->Private.theSAXHandler.cdataBlock;
   if);
   (if Private.theSAXHandler.characters <> 0 then
       Private.theSAXHandler.characters->freeCBF;
       0->Private.theSAXHandler.characters;
   if);
   (if Private.theSAXHandler.processingInstruction <> 0 then
       Private.theSAXHandler.processingInstruction->freeCBF;
       0->Private.theSAXHandler.processingInstruction;
   if);
   (if Private.theSAXHandler.comment <> 0 then
       Private.theSAXHandler.comment->freeCBF;
       0->Private.theSAXHandler.comment;
   if);
(*   (if Private.cDataStartAddr <> 0 then
       Private.cDataStartAddr->freeCBF;
       0->Private.cDataStartAddr;
   if);
   (if Private.cDataEndAddr <> 0 then
       Private.cDataEndAddr->freeCBF;
       0->Private.cDataEndAddr;
   if);*)
(*   (if Private.defaultAddr <> 0 then
       Private.defaultAddr->freeCBF;
       0->Private.defaultAddr;
   if);*)
   (if Private.theSAXHandler.unparsedEntityDecl <> 0 then
       Private.theSAXHandler.unparsedEntityDecl->freeCBF;
       0->Private.theSAXHandler.unparsedEntityDecl;
   if);
   (if Private.theSAXHandler.notationDecl <> 0 then
       Private.theSAXHandler.notationDecl->freeCBF;
       0->Private.theSAXHandler.notationDecl;
   if);
   (if Private.theSAXHandler.externalSubset <> 0 then
       Private.theSAXHandler.externalSubset->freeCBF;
       0->Private.theSAXHandler.externalSubset;
   if);
   (if Private.theSAXHandler.startElementNs <> 0 then
       Private.theSAXHandler.startElementNs->freeCBF;
       0->Private.theSAXHandler.startElementNs;
   if);
   (if Private.theSAXHandler.endElementNs <> 0 then
       Private.theSAXHandler.endElementNs->freeCBF;
       0->Private.theSAXHandler.endElementNs;
   if);
   
--- XMLParserPrivate:Descriptor ---
(# (* Parser state. *)
   useNamespaces: @Boolean;
   
   (* Parser encoding and namespaceSeparator. *)
   namespaceSeparator: @Char;
   
   (* Parser address. *)
   parserAddr: @int32;
   
   (* Callback function addresses. *)
   theSAXHandler: @xmlSAXHandler;
#)

--- XMLParserDoPart: DoPart ---
do Parse:
     (#
     do (* Make sure the parser is ready. *)
        (if Private.theSAXHandler.initialized = 0 then 
            ('parser not properly initialized', 0, 0, 0, 0)->onError;
            leave Parse;
        if);
        
        (* Create a new parser instance. *)
(*        (Private.theSAXHandler[], 0, chars, ret, 0) -> xmlCreatePushParserCtxt -> Private.parserAddr;*)
        (Private.theSAXHandler[], 0, 0, 0, 0) -> xmlCreatePushParserCtxt -> Private.parserAddr;
        
        (* Initialize the new parser instance. *)
        (if Private.parserAddr = 0 then
            (* No new parser instance created. *)
            ('cannot create new parser instance', 0, 0, 0, 0)->onError;
            leave Parse;
        if);

        INNER XMLParser;
        
        While: 
          (# t: ^Text;
             errorCode: @Integer;
             cstr: @CString;
          do inputStream.getLine->t[];
             (* OBS!!!
              * Necessary to make sure that the text pointer given to XML_Parse
              * does NOT move during a callback from XML_Parse (it does NOT copy
              * the string!). Thus the need for cstr.set.
              *)
             (if inputStream.eos then
                 (if trace_xml then
                     'xmlparsebody.bet: XMLParser.Parse.While: Sending final string to Expat' -> putLine;
                 if);
                 t[]->cstr.set;
                 (Private.parserAddr, cstr, t.lgth, 1)->xmlParseChunk->errorCode;
              else
                 '\n'->t.append;
                 t[]->cstr.set;
                 (Private.parserAddr, cstr, t.lgth, 0)->xmlParseChunk->errorCode;
             if);
             cstr.free;
             (if errorCode <> 0 then
                 (* A fatal error has occured! *)
(*                 Private.parserAddr->XML_GetErrorCode->errorCode;
                 errorCode->XML_ErrorString->cstr;
                 (cstr.get, 
                 Private.parserAddr->XML_GetCurrentLineNumber,
                 Private.parserAddr->XML_GetCurrentColumnNumber, 
                 Private.parserAddr->XML_GetCurrentByteIndex,
                 Private.parserAddr->XML_GetCurrentByteCount)->onError;*)
                 ('Parsing failed, unknown error.', 0, 0, 0, 0)->onError;
              else
                 (if not inputStream.eos then
                     restart While;
                 if);
             if);
          #);
        
        (* Free the parser instance. *)
        Private.parserAddr -> xmlFreeParserCtxt;
     #);
