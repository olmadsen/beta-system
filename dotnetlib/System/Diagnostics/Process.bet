ORIGIN '_Process';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/ComponentModel/_Component';
INCLUDE '~beta/dotnetlib/System/_String';
INCLUDE '~beta/dotnetlib/System/_DateTime';
INCLUDE '~beta/dotnetlib/System/_IntPtr';
INCLUDE '~beta/dotnetlib/System/Diagnostics/_ProcessModule';
INCLUDE '~beta/dotnetlib/System/Diagnostics/_ProcessModuleCollection';
INCLUDE '~beta/dotnetlib/System/Diagnostics/_ProcessPriorityClass';
INCLUDE '~beta/dotnetlib/System/_TimeSpan';
INCLUDE '~beta/dotnetlib/System/Diagnostics/_ProcessStartInfo';
INCLUDE '~beta/dotnetlib/System/ComponentModel/_ISynchronizeInvoke';
INCLUDE '~beta/dotnetlib/System/Diagnostics/_ProcessThreadCollection';
INCLUDE '~beta/dotnetlib/System/IO/_StreamWriter';
INCLUDE '~beta/dotnetlib/System/IO/_StreamReader';
INCLUDE '~beta/dotnetlib/System/_EventHandler';
--LIB: attributes--

(* .NET Process class. *)
DotnetProcess: _Process
  (#
     (* Public/family CLS compliant constructors *)

     _init: cons
       (# result: ^DotnetProcess;
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     ToString: proc
       (# result: ^_String;
       exit result[]
       #);
     get_BasePriority: proc
       (# result: @int32;
       exit result
       #);
     get_ExitCode: proc
       (# result: @int32;
       exit result
       #);
     get_HasExited: proc
       (# result: @boolean;
       exit result
       #);
     get_ExitTime: proc
       (# result: ^_DateTime;
       exit result[]
       #);
     get_Handle: proc
       (# result: ^_IntPtr;
       exit result[]
       #);
     get_HandleCount: proc
       (# result: @int32;
       exit result
       #);
     get_Id: proc
       (# result: @int32;
       exit result
       #);
     get_MachineName: proc
       (# result: ^_String;
       exit result[]
       #);
     get_MainWindowHandle: proc
       (# result: ^_IntPtr;
       exit result[]
       #);
     get_MainWindowTitle: proc
       (# result: ^_String;
       exit result[]
       #);
     get_MainModule: proc
       (# result: ^_ProcessModule;
       exit result[]
       #);
     get_MaxWorkingSet: proc
       (# result: ^_IntPtr;
       exit result[]
       #);
     set_MaxWorkingSet: proc
       (# 
          arg1: ^_IntPtr;
       enter (arg1[])
       #);
     get_MinWorkingSet: proc
       (# result: ^_IntPtr;
       exit result[]
       #);
     set_MinWorkingSet: proc
       (# 
          arg1: ^_IntPtr;
       enter (arg1[])
       #);
     get_Modules: proc
       (# result: ^_ProcessModuleCollection;
       exit result[]
       #);
     get_NonpagedSystemMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_PagedMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_PagedSystemMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_PeakPagedMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_PeakWorkingSet: proc
       (# result: @int32;
       exit result
       #);
     get_PeakVirtualMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_PriorityBoostEnabled: proc
       (# result: @boolean;
       exit result
       #);
     set_PriorityBoostEnabled: proc
       (# 
          arg1: @boolean;
       enter (arg1)
       #);
     get_PriorityClass: proc
       (# result: ^_ProcessPriorityClass;
       exit result[]
       #);
     set_PriorityClass: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     get_PrivateMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_PrivilegedProcessorTime: proc
       (# result: ^_TimeSpan;
       exit result[]
       #);
     get_ProcessName: proc
       (# result: ^_String;
       exit result[]
       #);
     get_ProcessorAffinity: proc
       (# result: ^_IntPtr;
       exit result[]
       #);
     set_ProcessorAffinity: proc
       (# 
          arg1: ^_IntPtr;
       enter (arg1[])
       #);
     get_Responding: proc
       (# result: @boolean;
       exit result
       #);
     get_StartInfo: proc
       (# result: ^_ProcessStartInfo;
       exit result[]
       #);
     set_StartInfo: proc
       (# 
          arg1: ^_ProcessStartInfo;
       enter (arg1[])
       #);
     get_StartTime: proc
       (# result: ^_DateTime;
       exit result[]
       #);
     get_SynchronizingObject: proc
       (# result: ^_ISynchronizeInvoke;
       exit result[]
       #);
     set_SynchronizingObject: proc
       (# 
          arg1: ^_ISynchronizeInvoke;
       enter (arg1[])
       #);
     get_Threads: proc
       (# result: ^_ProcessThreadCollection;
       exit result[]
       #);
     get_TotalProcessorTime: proc
       (# result: ^_TimeSpan;
       exit result[]
       #);
     get_UserProcessorTime: proc
       (# result: ^_TimeSpan;
       exit result[]
       #);
     get_VirtualMemorySize: proc
       (# result: @int32;
       exit result
       #);
     get_EnableRaisingEvents: proc
       (# result: @boolean;
       exit result
       #);
     set_EnableRaisingEvents: proc
       (# 
          arg1: @boolean;
       enter (arg1)
       #);
     get_StandardInput: proc
       (# result: ^_StreamWriter;
       exit result[]
       #);
     get_StandardOutput: proc
       (# result: ^_StreamReader;
       exit result[]
       #);
     get_StandardError: proc
       (# result: ^_StreamReader;
       exit result[]
       #);
     get_WorkingSet: proc
       (# result: @int32;
       exit result
       #);
     add_Exited: proc
       (# 
          arg1: ^_EventHandler;
       enter (arg1[])
       #);
     remove_Exited: proc
       (# 
          arg1: ^_EventHandler;
       enter (arg1[])
       #);
     CloseMainWindow: proc
       (# result: @boolean;
       exit result
       #);
     Close: proc
       (# 
       #);
     EnterDebugMode: static_proc
       (# 
       #);
     LeaveDebugMode: static_proc
       (# 
       #);
     GetProcessById_int32_String: static_proc (* GetProcessById *)
       (# result: ^DotnetProcess;
          arg1: @int32;
          arg2: ^_String;
       enter (arg1, arg2[])
       do 'GetProcessById' -> procname;
       exit result[]
       #);
     GetProcessById_int32: static_proc (* GetProcessById *)
       (# result: ^DotnetProcess;
          arg1: @int32;
       enter (arg1)
       do 'GetProcessById' -> procname;
       exit result[]
       #);
     GetProcessesByName_String: static_proc (* GetProcessesByName *)
       (# result: [0]^DotnetProcess;
          arg1: ^_String;
       enter (arg1[])
       do 'GetProcessesByName' -> procname;
       exit result[]
       #);
     GetProcessesByName_String_String: static_proc (* GetProcessesByName *)
       (# result: [0]^DotnetProcess;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'GetProcessesByName' -> procname;
       exit result[]
       #);
     GetProcesses: static_proc (* GetProcesses *)
       (# result: [0]^DotnetProcess;
       do 'GetProcesses' -> procname;
       exit result[]
       #);
     GetProcesses_String: static_proc (* GetProcesses *)
       (# result: [0]^DotnetProcess;
          arg1: ^_String;
       enter (arg1[])
       do 'GetProcesses' -> procname;
       exit result[]
       #);
     GetCurrentProcess: static_proc
       (# result: ^DotnetProcess;
       exit result[]
       #);
     Refresh: proc
       (# 
       #);
     Start: proc (* Start *)
       (# result: @boolean;
       do 'Start' -> procname;
       exit result
       #);
     Start_String: static_proc (* Start *)
       (# result: ^DotnetProcess;
          arg1: ^_String;
       enter (arg1[])
       do 'Start' -> procname;
       exit result[]
       #);
     Start_String_String: static_proc (* Start *)
       (# result: ^DotnetProcess;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'Start' -> procname;
       exit result[]
       #);
     Start_ProcessStartInfo: static_proc (* Start *)
       (# result: ^DotnetProcess;
          arg1: ^_ProcessStartInfo;
       enter (arg1[])
       do 'Start' -> procname;
       exit result[]
       #);
     Kill: proc
       (# 
       #);
     WaitForExit_int32: proc (* WaitForExit *)
       (# result: @boolean;
          arg1: @int32;
       enter (arg1)
       do 'WaitForExit' -> procname;
       exit result
       #);
     WaitForExit: proc (* WaitForExit *)
       (# 
       do 'WaitForExit' -> procname;
       #);
     WaitForInputIdle_int32: proc (* WaitForInputIdle *)
       (# result: @boolean;
          arg1: @int32;
       enter (arg1)
       do 'WaitForInputIdle' -> procname;
       exit result
       #);
     WaitForInputIdle: proc (* WaitForInputIdle *)
       (# result: @boolean;
       do 'WaitForInputIdle' -> procname;
       exit result
       #);
  do '[System]System.Diagnostics.Process' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asProcess:
  (# _P: ^_Process;
     P: ^DotnetProcess;
  enter _P[]
  do _P[]->P[];
  exit P[]
  #);
