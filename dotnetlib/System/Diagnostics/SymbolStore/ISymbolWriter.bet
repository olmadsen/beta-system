ORIGIN '_ISymbolWriter';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/_IntPtr';
INCLUDE '~beta/dotnetlib/System/Diagnostics/SymbolStore/_ISymbolDocumentWriter';
INCLUDE '~beta/dotnetlib/System/_String';
INCLUDE '~beta/dotnetlib/System/Diagnostics/SymbolStore/_SymbolToken';
INCLUDE '~beta/dotnetlib/System/Reflection/_FieldAttributes';
INCLUDE '~beta/dotnetlib/System/Diagnostics/SymbolStore/_SymAddressKind';
INCLUDE '~beta/dotnetlib/System/Reflection/_ParameterAttributes';
INCLUDE '~beta/dotnetlib/System/_Guid';
--LIB: attributes--

(* .NET ISymbolWriter class. *)
ISymbolWriter: _ISymbolWriter
  (#
     (* Public/family CLS compliant methods *)

     SetUnderlyingWriter: proc
       (# 
          arg1: ^_IntPtr;
       enter (arg1[])
       #);
     SetMethodSourceRange: proc
       (# 
          arg1: ^_ISymbolDocumentWriter;
          arg2: @int32;
          arg3: @int32;
          arg4: ^_ISymbolDocumentWriter;
          arg5: @int32;
          arg6: @int32;
       enter (arg1[], arg2, arg3, arg4[], arg5, arg6)
       #);
     UsingNamespace: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     CloseNamespace: proc
       (# 
       #);
     OpenNamespace: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     SetSymAttribute: proc
       (# 
          arg1: ^_SymbolToken;
          arg2: ^_String;
          arg3: [0]@int8u;
       enter (arg1[], arg2[], arg3[])
       #);
     Close: proc
       (# 
       #);
     DefineGlobalVariable: proc
       (# 
          arg1: ^_String;
          arg2: ^_FieldAttributes;
          arg3: [0]@int8u;
          arg4: ^_SymAddressKind;
          arg5: @int32;
          arg6: @int32;
          arg7: @int32;
       enter (arg1[], arg2[], arg3[], arg4[], arg5, arg6, arg7)
       #);
     DefineField: proc
       (# 
          arg1: ^_SymbolToken;
          arg2: ^_String;
          arg3: ^_FieldAttributes;
          arg4: [0]@int8u;
          arg5: ^_SymAddressKind;
          arg6: @int32;
          arg7: @int32;
          arg8: @int32;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[], arg6, arg7, arg8)
       #);
     DefineParameter: proc
       (# 
          arg1: ^_String;
          arg2: ^_ParameterAttributes;
          arg3: @int32;
          arg4: ^_SymAddressKind;
          arg5: @int32;
          arg6: @int32;
          arg7: @int32;
       enter (arg1[], arg2[], arg3, arg4[], arg5, arg6, arg7)
       #);
     DefineLocalVariable: proc
       (# 
          arg1: ^_String;
          arg2: ^_FieldAttributes;
          arg3: [0]@int8u;
          arg4: ^_SymAddressKind;
          arg5: @int32;
          arg6: @int32;
          arg7: @int32;
          arg8: @int32;
          arg9: @int32;
       enter (arg1[], arg2[], arg3[], arg4[], arg5, arg6, arg7, arg8, arg9)
       #);
     SetScopeRange: proc
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       #);
     CloseScope: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     OpenScope: proc
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     DefineSequencePoints: proc
       (# 
          arg1: ^_ISymbolDocumentWriter;
          arg2: [0]@int32;
          arg3: [0]@int32;
          arg4: [0]@int32;
          arg5: [0]@int32;
          arg6: [0]@int32;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[], arg6[])
       #);
     CloseMethod: proc
       (# 
       #);
     OpenMethod: proc
       (# 
          arg1: ^_SymbolToken;
       enter (arg1[])
       #);
     SetUserEntryPoint: proc
       (# 
          arg1: ^_SymbolToken;
       enter (arg1[])
       #);
     DefineDocument: proc
       (# result: ^_ISymbolDocumentWriter;
          arg1: ^_String;
          arg2: ^_Guid;
          arg3: ^_Guid;
          arg4: ^_Guid;
       enter (arg1[], arg2[], arg3[], arg4[])
       exit result[]
       #);
     Initialize: proc
       (# 
          arg1: ^_IntPtr;
          arg2: ^_String;
          arg3: @boolean;
       enter (arg1[], arg2[], arg3)
       #);
  do '[mscorlib]System.Diagnostics.SymbolStore.ISymbolWriter' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asISymbolWriter:
  (# _I: ^_ISymbolWriter;
     I: ^ISymbolWriter;
  enter _I[]
  do _I[]->I[];
  exit I[]
  #);
