ORIGIN '_Math';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/_Decimal';
--LIB: attributes--

(* .NET Math class. *)
Math: _Math
  (#
     (* Public/family CLS compliant fields *)

     (* STATIC: *)
     PI: @real;
     (* STATIC: *)
     E: @real;

     (* Public/family CLS compliant methods *)

     Acos: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Asin: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Atan: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Atan2: static_proc
       (# result: @real;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       exit result
       #);
     Cos: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Sin: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Tan: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Cosh: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Sinh: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Tanh: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Round_real: static_proc (* Round *)
       (# result: @real;
          arg1: @real;
       enter (arg1)
       do 'Round' -> procname;
       exit result
       #);
     Round_real_int32: static_proc (* Round *)
       (# result: @real;
          arg1: @real;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Round' -> procname;
       exit result
       #);
     Round_Decimal: static_proc (* Round *)
       (# result: ^_Decimal;
          arg1: ^_Decimal;
       enter (arg1[])
       do 'Round' -> procname;
       exit result[]
       #);
     Round_Decimal_int32: static_proc (* Round *)
       (# result: ^_Decimal;
          arg1: ^_Decimal;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'Round' -> procname;
       exit result[]
       #);
     Ceiling: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Floor: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Sqrt: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Log_real: static_proc (* Log *)
       (# result: @real;
          arg1: @real;
       enter (arg1)
       do 'Log' -> procname;
       exit result
       #);
     Log10: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Exp: static_proc
       (# result: @real;
          arg1: @real;
       enter (arg1)
       exit result
       #);
     Pow: static_proc
       (# result: @real;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       exit result
       #);
     IEEERemainder: static_proc
       (# result: @real;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       exit result
       #);
     Abs_int16: static_proc (* Abs *)
       (# result: @int16;
          arg1: @int16;
       enter (arg1)
       do 'Abs' -> procname;
       exit result
       #);
     Abs_int32: static_proc (* Abs *)
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       do 'Abs' -> procname;
       exit result
       #);
     Abs_int64: static_proc (* Abs *)
       (# result: @int64;
          arg1: @int64;
       enter (arg1)
       do 'Abs' -> procname;
       exit result
       #);
     Abs_real32: static_proc (* Abs *)
       (# result: @real32;
          arg1: @real32;
       enter (arg1)
       do 'Abs' -> procname;
       exit result
       #);
     Abs_real: static_proc (* Abs *)
       (# result: @real;
          arg1: @real;
       enter (arg1)
       do 'Abs' -> procname;
       exit result
       #);
     Abs_Decimal: static_proc (* Abs *)
       (# result: ^_Decimal;
          arg1: ^_Decimal;
       enter (arg1[])
       do 'Abs' -> procname;
       exit result[]
       #);
     Max_int8u_int8u: static_proc (* Max *)
       (# result: @int8u;
          arg1: @int8u;
          arg2: @int8u;
       enter (arg1, arg2)
       do 'Max' -> procname;
       exit result
       #);
     Max_int16_int16: static_proc (* Max *)
       (# result: @int16;
          arg1: @int16;
          arg2: @int16;
       enter (arg1, arg2)
       do 'Max' -> procname;
       exit result
       #);
     Max_int32_int32: static_proc (* Max *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Max' -> procname;
       exit result
       #);
     Max_int64_int64: static_proc (* Max *)
       (# result: @int64;
          arg1: @int64;
          arg2: @int64;
       enter (arg1, arg2)
       do 'Max' -> procname;
       exit result
       #);
     Max_real32_real32: static_proc (* Max *)
       (# result: @real32;
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'Max' -> procname;
       exit result
       #);
     Max_real_real: static_proc (* Max *)
       (# result: @real;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       do 'Max' -> procname;
       exit result
       #);
     Max_Decimal_Decimal: static_proc (* Max *)
       (# result: ^_Decimal;
          arg1: ^_Decimal;
          arg2: ^_Decimal;
       enter (arg1[], arg2[])
       do 'Max' -> procname;
       exit result[]
       #);
     Min_int8u_int8u: static_proc (* Min *)
       (# result: @int8u;
          arg1: @int8u;
          arg2: @int8u;
       enter (arg1, arg2)
       do 'Min' -> procname;
       exit result
       #);
     Min_int16_int16: static_proc (* Min *)
       (# result: @int16;
          arg1: @int16;
          arg2: @int16;
       enter (arg1, arg2)
       do 'Min' -> procname;
       exit result
       #);
     Min_int32_int32: static_proc (* Min *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Min' -> procname;
       exit result
       #);
     Min_int64_int64: static_proc (* Min *)
       (# result: @int64;
          arg1: @int64;
          arg2: @int64;
       enter (arg1, arg2)
       do 'Min' -> procname;
       exit result
       #);
     Min_real32_real32: static_proc (* Min *)
       (# result: @real32;
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'Min' -> procname;
       exit result
       #);
     Min_real_real: static_proc (* Min *)
       (# result: @real;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       do 'Min' -> procname;
       exit result
       #);
     Min_Decimal_Decimal: static_proc (* Min *)
       (# result: ^_Decimal;
          arg1: ^_Decimal;
          arg2: ^_Decimal;
       enter (arg1[], arg2[])
       do 'Min' -> procname;
       exit result[]
       #);
     Log_real_real: static_proc (* Log *)
       (# result: @real;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       do 'Log' -> procname;
       exit result
       #);
     Sign_int16: static_proc (* Sign *)
       (# result: @int32;
          arg1: @int16;
       enter (arg1)
       do 'Sign' -> procname;
       exit result
       #);
     Sign_int32: static_proc (* Sign *)
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       do 'Sign' -> procname;
       exit result
       #);
     Sign_int64: static_proc (* Sign *)
       (# result: @int32;
          arg1: @int64;
       enter (arg1)
       do 'Sign' -> procname;
       exit result
       #);
     Sign_real32: static_proc (* Sign *)
       (# result: @int32;
          arg1: @real32;
       enter (arg1)
       do 'Sign' -> procname;
       exit result
       #);
     Sign_real: static_proc (* Sign *)
       (# result: @int32;
          arg1: @real;
       enter (arg1)
       do 'Sign' -> procname;
       exit result
       #);
     Sign_Decimal: static_proc (* Sign *)
       (# result: @int32;
          arg1: ^_Decimal;
       enter (arg1[])
       do 'Sign' -> procname;
       exit result
       #);
     BigMul: static_proc
       (# result: @int64;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result
       #);
     DivRem_int32_int32_int32: static_proc (* DivRem *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'DivRem' -> procname;
       exit result
       #);
     DivRem_int64_int64_int64: static_proc (* DivRem *)
       (# result: @int64;
          arg1: @int64;
          arg2: @int64;
          arg3: @int64;
       enter (arg1, arg2, arg3)
       do 'DivRem' -> procname;
       exit result
       #);
  do '[mscorlib]System.Math' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asMath:
  (# _M: ^_Math;
     M: ^Math;
  enter _M[]
  do _M[]->M[];
  exit M[]
  #);
