ORIGIN '_Region';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/_MarshalByRefObject';
INCLUDE '~beta/dotnetlib/System/Drawing/_RectangleF';
INCLUDE '~beta/dotnetlib/System/Drawing/_Rectangle';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_GraphicsPath';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_RegionData';
INCLUDE '~beta/dotnetlib/System/_IntPtr';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_Matrix';
INCLUDE '~beta/dotnetlib/System/Drawing/_Graphics';
INCLUDE '~beta/dotnetlib/System/Drawing/_PointF';
INCLUDE '~beta/dotnetlib/System/Drawing/_Point';
--LIB: attributes--

(* .NET Region class. *)
Region: _Region
  (#
     (* Public/family CLS compliant constructors *)

     _init: cons (* constructor *)
       (# result: ^Region;
       exit result[]
       #);
     _init_RectangleF: cons (* constructor *)
       (# result: ^Region;
          arg1: ^_RectangleF;
       enter (arg1[])
       exit result[]
       #);
     _init_Rectangle: cons (* constructor *)
       (# result: ^Region;
          arg1: ^_Rectangle;
       enter (arg1[])
       exit result[]
       #);
     _init_GraphicsPath: cons (* constructor *)
       (# result: ^Region;
          arg1: ^_GraphicsPath;
       enter (arg1[])
       exit result[]
       #);
     _init_RegionData: cons (* constructor *)
       (# result: ^Region;
          arg1: ^_RegionData;
       enter (arg1[])
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     Dispose: proc
       (# 
       #);
     FromHrgn: static_proc
       (# result: ^Region;
          arg1: ^_IntPtr;
       enter (arg1[])
       exit result[]
       #);
     Clone: proc
       (# result: ^Region;
       exit result[]
       #);
     MakeInfinite: proc
       (# 
       #);
     MakeEmpty: proc
       (# 
       #);
     Intersect_RectangleF: proc (* Intersect *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'Intersect' -> procname;
       #);
     Intersect_Rectangle: proc (* Intersect *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'Intersect' -> procname;
       #);
     Intersect_GraphicsPath: proc (* Intersect *)
       (# 
          arg1: ^_GraphicsPath;
       enter (arg1[])
       do 'Intersect' -> procname;
       #);
     Intersect_Region: proc (* Intersect *)
       (# 
          arg1: ^Region;
       enter (arg1[])
       do 'Intersect' -> procname;
       #);
     Union_RectangleF: proc (* Union *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'Union' -> procname;
       #);
     Union_Rectangle: proc (* Union *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'Union' -> procname;
       #);
     Union_GraphicsPath: proc (* Union *)
       (# 
          arg1: ^_GraphicsPath;
       enter (arg1[])
       do 'Union' -> procname;
       #);
     Union_Region: proc (* Union *)
       (# 
          arg1: ^Region;
       enter (arg1[])
       do 'Union' -> procname;
       #);
     Xor_RectangleF: proc (* Xor *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'Xor' -> procname;
       #);
     Xor_Rectangle: proc (* Xor *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'Xor' -> procname;
       #);
     Xor_GraphicsPath: proc (* Xor *)
       (# 
          arg1: ^_GraphicsPath;
       enter (arg1[])
       do 'Xor' -> procname;
       #);
     Xor_Region: proc (* Xor *)
       (# 
          arg1: ^Region;
       enter (arg1[])
       do 'Xor' -> procname;
       #);
     Exclude_RectangleF: proc (* Exclude *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'Exclude' -> procname;
       #);
     Exclude_Rectangle: proc (* Exclude *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'Exclude' -> procname;
       #);
     Exclude_GraphicsPath: proc (* Exclude *)
       (# 
          arg1: ^_GraphicsPath;
       enter (arg1[])
       do 'Exclude' -> procname;
       #);
     Exclude_Region: proc (* Exclude *)
       (# 
          arg1: ^Region;
       enter (arg1[])
       do 'Exclude' -> procname;
       #);
     Complement_RectangleF: proc (* Complement *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'Complement' -> procname;
       #);
     Complement_Rectangle: proc (* Complement *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'Complement' -> procname;
       #);
     Complement_GraphicsPath: proc (* Complement *)
       (# 
          arg1: ^_GraphicsPath;
       enter (arg1[])
       do 'Complement' -> procname;
       #);
     Complement_Region: proc (* Complement *)
       (# 
          arg1: ^Region;
       enter (arg1[])
       do 'Complement' -> procname;
       #);
     Translate_real32_real32: proc (* Translate *)
       (# 
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'Translate' -> procname;
       #);
     Translate_int32_int32: proc (* Translate *)
       (# 
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Translate' -> procname;
       #);
     Transform: proc
       (# 
          arg1: ^_Matrix;
       enter (arg1[])
       #);
     GetBounds: proc
       (# result: ^_RectangleF;
          arg1: ^_Graphics;
       enter (arg1[])
       exit result[]
       #);
     GetHrgn: proc
       (# result: ^_IntPtr;
          arg1: ^_Graphics;
       enter (arg1[])
       exit result[]
       #);
     IsEmpty: proc
       (# result: @boolean;
          arg1: ^_Graphics;
       enter (arg1[])
       exit result
       #);
     IsInfinite: proc
       (# result: @boolean;
          arg1: ^_Graphics;
       enter (arg1[])
       exit result
       #);
     Equals: proc
       (# result: @boolean;
          arg1: ^Region;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       exit result
       #);
     GetRegionData: proc
       (# result: ^_RegionData;
       exit result[]
       #);
     IsVisible_real32_real32: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_PointF: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_PointF;
       enter (arg1[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_real32_real32_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
          arg3: ^_Graphics;
       enter (arg1, arg2, arg3[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_PointF_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_PointF;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_real32_real32_real32_real32: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
       enter (arg1, arg2, arg3, arg4)
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_RectangleF: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_real32_real32_real32_real32_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
          arg5: ^_Graphics;
       enter (arg1, arg2, arg3, arg4, arg5[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_RectangleF_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_RectangleF;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_int32_int32_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
          arg3: ^_Graphics;
       enter (arg1, arg2, arg3[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_Point: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_Point;
       enter (arg1[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_Point_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_Point;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_int32_int32_int32_int32: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2, arg3, arg4)
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_Rectangle: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_int32_int32_int32_int32_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: ^_Graphics;
       enter (arg1, arg2, arg3, arg4, arg5[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_Rectangle_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_Rectangle;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       do 'IsVisible' -> procname;
       exit result
       #);
     GetRegionScans: proc
       (# result: [0]^_RectangleF;
          arg1: ^_Matrix;
       enter (arg1[])
       exit result
       #);
  do '[System.Drawing]System.Drawing.Region' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asRegion:
  (# _R: ^_Region;
     R: ^Region;
  enter _R[]
  do _R[]->R[];
  exit R[]
  #);
