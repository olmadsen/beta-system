ORIGIN '_GraphicsPath';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/_MarshalByRefObject';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_FillMode';
INCLUDE '~beta/dotnetlib/System/Drawing/_PointF';
INCLUDE '~beta/dotnetlib/System/Drawing/_Point';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_PathData';
INCLUDE '~beta/dotnetlib/System/Drawing/_Graphics';
INCLUDE '~beta/dotnetlib/System/Drawing/_Pen';
INCLUDE '~beta/dotnetlib/System/Drawing/_RectangleF';
INCLUDE '~beta/dotnetlib/System/Drawing/_Rectangle';
INCLUDE '~beta/dotnetlib/System/_String';
INCLUDE '~beta/dotnetlib/System/Drawing/_FontFamily';
INCLUDE '~beta/dotnetlib/System/Drawing/_StringFormat';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_Matrix';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_WarpMode';
--LIB: attributes--

(* .NET GraphicsPath class. *)
GraphicsPath: _GraphicsPath
  (#
     (* Public/family CLS compliant constructors *)

     _init: cons (* constructor *)
       (# result: ^GraphicsPath;
       exit result[]
       #);
     _init_FillMode: cons (* constructor *)
       (# result: ^GraphicsPath;
          arg1: @int32;
       enter (arg1)
       exit result[]
       #);
     _init_ArrayOf_PointF_ArrayOfInt8u: cons (* constructor *)
       (# result: ^GraphicsPath;
          arg1: [0]^_PointF;
          arg2: [0]@int8u;
       enter (arg1[], arg2[])
       exit result[]
       #);
     _init_ArrayOf_PointF_ArrayOfInt8u_FillMode: cons (* constructor *)
       (# result: ^GraphicsPath;
          arg1: [0]^_PointF;
          arg2: [0]@int8u;
          arg3: @int32;
       enter (arg1[], arg2[], arg3)
       exit result[]
       #);
     _init_ArrayOf_Point_ArrayOfInt8u: cons (* constructor *)
       (# result: ^GraphicsPath;
          arg1: [0]^_Point;
          arg2: [0]@int8u;
       enter (arg1[], arg2[])
       exit result[]
       #);
     _init_ArrayOf_Point_ArrayOfInt8u_FillMode: cons (* constructor *)
       (# result: ^GraphicsPath;
          arg1: [0]^_Point;
          arg2: [0]@int8u;
          arg3: @int32;
       enter (arg1[], arg2[], arg3)
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     Dispose: proc
       (# 
       #);
     Clone: proc
       (# result: ^Object;
       exit result[]
       #);
     Reset: proc
       (# 
       #);
     get_FillMode: proc
       (# result: ^_FillMode;
       exit result[]
       #);
     set_FillMode: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     get_PathData: proc
       (# result: ^_PathData;
       exit result[]
       #);
     StartFigure: proc
       (# 
       #);
     CloseFigure: proc
       (# 
       #);
     CloseAllFigures: proc
       (# 
       #);
     SetMarkers: proc
       (# 
       #);
     ClearMarkers: proc
       (# 
       #);
     Reverse: proc
       (# 
       #);
     GetLastPoint: proc
       (# result: ^_PointF;
       exit result[]
       #);
     IsVisible_real32_real32: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_PointF: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_PointF;
       enter (arg1[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_real32_real32_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
          arg3: ^_Graphics;
       enter (arg1, arg2, arg3[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_PointF_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_PointF;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_int32_int32: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_Point: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_Point;
       enter (arg1[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_int32_int32_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
          arg3: ^_Graphics;
       enter (arg1, arg2, arg3[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsVisible_Point_Graphics: proc (* IsVisible *)
       (# result: @boolean;
          arg1: ^_Point;
          arg2: ^_Graphics;
       enter (arg1[], arg2[])
       do 'IsVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_real32_real32_Pen: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
          arg3: ^_Pen;
       enter (arg1, arg2, arg3[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_PointF_Pen: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: ^_PointF;
          arg2: ^_Pen;
       enter (arg1[], arg2[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_real32_real32_Pen_Graphics: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: @real32;
          arg2: @real32;
          arg3: ^_Pen;
          arg4: ^_Graphics;
       enter (arg1, arg2, arg3[], arg4[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_PointF_Pen_Graphics: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: ^_PointF;
          arg2: ^_Pen;
          arg3: ^_Graphics;
       enter (arg1[], arg2[], arg3[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_int32_int32_Pen: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
          arg3: ^_Pen;
       enter (arg1, arg2, arg3[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_Point_Pen: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: ^_Point;
          arg2: ^_Pen;
       enter (arg1[], arg2[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_int32_int32_Pen_Graphics: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
          arg3: ^_Pen;
          arg4: ^_Graphics;
       enter (arg1, arg2, arg3[], arg4[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     IsOutlineVisible_Point_Pen_Graphics: proc (* IsOutlineVisible *)
       (# result: @boolean;
          arg1: ^_Point;
          arg2: ^_Pen;
          arg3: ^_Graphics;
       enter (arg1[], arg2[], arg3[])
       do 'IsOutlineVisible' -> procname;
       exit result
       #);
     AddLine_PointF_PointF: proc (* AddLine *)
       (# 
          arg1: ^_PointF;
          arg2: ^_PointF;
       enter (arg1[], arg2[])
       do 'AddLine' -> procname;
       #);
     AddLine_real32_real32_real32_real32: proc (* AddLine *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
       enter (arg1, arg2, arg3, arg4)
       do 'AddLine' -> procname;
       #);
     AddLines_ArrayOf_PointF: proc (* AddLines *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'AddLines' -> procname;
       #);
     AddLine_Point_Point: proc (* AddLine *)
       (# 
          arg1: ^_Point;
          arg2: ^_Point;
       enter (arg1[], arg2[])
       do 'AddLine' -> procname;
       #);
     AddLine_int32_int32_int32_int32: proc (* AddLine *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2, arg3, arg4)
       do 'AddLine' -> procname;
       #);
     AddLines_ArrayOf_Point: proc (* AddLines *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'AddLines' -> procname;
       #);
     AddArc_RectangleF_real32_real32: proc (* AddArc *)
       (# 
          arg1: ^_RectangleF;
          arg2: @real32;
          arg3: @real32;
       enter (arg1[], arg2, arg3)
       do 'AddArc' -> procname;
       #);
     AddArc_real32_real32_real32_real32_real32_real32: proc (* AddArc *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
          arg5: @real32;
          arg6: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       do 'AddArc' -> procname;
       #);
     AddArc_Rectangle_real32_real32: proc (* AddArc *)
       (# 
          arg1: ^_Rectangle;
          arg2: @real32;
          arg3: @real32;
       enter (arg1[], arg2, arg3)
       do 'AddArc' -> procname;
       #);
     AddArc_int32_int32_int32_int32_real32_real32: proc (* AddArc *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: @real32;
          arg6: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       do 'AddArc' -> procname;
       #);
     AddBezier_PointF_PointF_PointF_PointF: proc (* AddBezier *)
       (# 
          arg1: ^_PointF;
          arg2: ^_PointF;
          arg3: ^_PointF;
          arg4: ^_PointF;
       enter (arg1[], arg2[], arg3[], arg4[])
       do 'AddBezier' -> procname;
       #);
     AddBezier_real32_real32_real32_real32_real32_real32_real32_real32: proc (* AddBezier *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
          arg5: @real32;
          arg6: @real32;
          arg7: @real32;
          arg8: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
       do 'AddBezier' -> procname;
       #);
     AddBeziers_ArrayOf_PointF: proc (* AddBeziers *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'AddBeziers' -> procname;
       #);
     AddBezier_Point_Point_Point_Point: proc (* AddBezier *)
       (# 
          arg1: ^_Point;
          arg2: ^_Point;
          arg3: ^_Point;
          arg4: ^_Point;
       enter (arg1[], arg2[], arg3[], arg4[])
       do 'AddBezier' -> procname;
       #);
     AddBezier_int32_int32_int32_int32_int32_int32_int32_int32: proc (* AddBezier *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: @int32;
          arg6: @int32;
          arg7: @int32;
          arg8: @int32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
       do 'AddBezier' -> procname;
       #);
     AddBeziers_ArrayOf_Point: proc (* AddBeziers *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'AddBeziers' -> procname;
       #);
     AddCurve_ArrayOf_PointF: proc (* AddCurve *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'AddCurve' -> procname;
       #);
     AddCurve_ArrayOf_PointF_real32: proc (* AddCurve *)
       (# 
          arg1: [0]^_PointF;
          arg2: @real32;
       enter (arg1[], arg2)
       do 'AddCurve' -> procname;
       #);
     AddCurve_ArrayOf_PointF_int32_int32_real32: proc (* AddCurve *)
       (# 
          arg1: [0]^_PointF;
          arg2: @int32;
          arg3: @int32;
          arg4: @real32;
       enter (arg1[], arg2, arg3, arg4)
       do 'AddCurve' -> procname;
       #);
     AddCurve_ArrayOf_Point: proc (* AddCurve *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'AddCurve' -> procname;
       #);
     AddCurve_ArrayOf_Point_real32: proc (* AddCurve *)
       (# 
          arg1: [0]^_Point;
          arg2: @real32;
       enter (arg1[], arg2)
       do 'AddCurve' -> procname;
       #);
     AddCurve_ArrayOf_Point_int32_int32_real32: proc (* AddCurve *)
       (# 
          arg1: [0]^_Point;
          arg2: @int32;
          arg3: @int32;
          arg4: @real32;
       enter (arg1[], arg2, arg3, arg4)
       do 'AddCurve' -> procname;
       #);
     AddClosedCurve_ArrayOf_PointF: proc (* AddClosedCurve *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'AddClosedCurve' -> procname;
       #);
     AddClosedCurve_ArrayOf_PointF_real32: proc (* AddClosedCurve *)
       (# 
          arg1: [0]^_PointF;
          arg2: @real32;
       enter (arg1[], arg2)
       do 'AddClosedCurve' -> procname;
       #);
     AddClosedCurve_ArrayOf_Point: proc (* AddClosedCurve *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'AddClosedCurve' -> procname;
       #);
     AddClosedCurve_ArrayOf_Point_real32: proc (* AddClosedCurve *)
       (# 
          arg1: [0]^_Point;
          arg2: @real32;
       enter (arg1[], arg2)
       do 'AddClosedCurve' -> procname;
       #);
     AddRectangle_RectangleF: proc (* AddRectangle *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'AddRectangle' -> procname;
       #);
     AddRectangles_ArrayOf_RectangleF: proc (* AddRectangles *)
       (# 
          arg1: [0]^_RectangleF;
       enter (arg1[])
       do 'AddRectangles' -> procname;
       #);
     AddRectangle_Rectangle: proc (* AddRectangle *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'AddRectangle' -> procname;
       #);
     AddRectangles_ArrayOf_Rectangle: proc (* AddRectangles *)
       (# 
          arg1: [0]^_Rectangle;
       enter (arg1[])
       do 'AddRectangles' -> procname;
       #);
     AddEllipse_RectangleF: proc (* AddEllipse *)
       (# 
          arg1: ^_RectangleF;
       enter (arg1[])
       do 'AddEllipse' -> procname;
       #);
     AddEllipse_real32_real32_real32_real32: proc (* AddEllipse *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
       enter (arg1, arg2, arg3, arg4)
       do 'AddEllipse' -> procname;
       #);
     AddEllipse_Rectangle: proc (* AddEllipse *)
       (# 
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'AddEllipse' -> procname;
       #);
     AddEllipse_int32_int32_int32_int32: proc (* AddEllipse *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2, arg3, arg4)
       do 'AddEllipse' -> procname;
       #);
     AddPie_Rectangle_real32_real32: proc (* AddPie *)
       (# 
          arg1: ^_Rectangle;
          arg2: @real32;
          arg3: @real32;
       enter (arg1[], arg2, arg3)
       do 'AddPie' -> procname;
       #);
     AddPie_real32_real32_real32_real32_real32_real32: proc (* AddPie *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
          arg5: @real32;
          arg6: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       do 'AddPie' -> procname;
       #);
     AddPie_int32_int32_int32_int32_real32_real32: proc (* AddPie *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: @real32;
          arg6: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       do 'AddPie' -> procname;
       #);
     AddPolygon_ArrayOf_PointF: proc (* AddPolygon *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'AddPolygon' -> procname;
       #);
     AddPolygon_ArrayOf_Point: proc (* AddPolygon *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'AddPolygon' -> procname;
       #);
     AddPath: proc
       (# 
          arg1: ^GraphicsPath;
          arg2: @boolean;
       enter (arg1[], arg2)
       #);
     AddString_String_FontFamily_int32_real32_PointF_StringFormat: proc (* AddString *)
       (# 
          arg1: ^_String;
          arg2: ^_FontFamily;
          arg3: @int32;
          arg4: @real32;
          arg5: ^_PointF;
          arg6: ^_StringFormat;
       enter (arg1[], arg2[], arg3, arg4, arg5[], arg6[])
       do 'AddString' -> procname;
       #);
     AddString_String_FontFamily_int32_real32_Point_StringFormat: proc (* AddString *)
       (# 
          arg1: ^_String;
          arg2: ^_FontFamily;
          arg3: @int32;
          arg4: @real32;
          arg5: ^_Point;
          arg6: ^_StringFormat;
       enter (arg1[], arg2[], arg3, arg4, arg5[], arg6[])
       do 'AddString' -> procname;
       #);
     AddString_String_FontFamily_int32_real32_RectangleF_StringFormat: proc (* AddString *)
       (# 
          arg1: ^_String;
          arg2: ^_FontFamily;
          arg3: @int32;
          arg4: @real32;
          arg5: ^_RectangleF;
          arg6: ^_StringFormat;
       enter (arg1[], arg2[], arg3, arg4, arg5[], arg6[])
       do 'AddString' -> procname;
       #);
     AddString_String_FontFamily_int32_real32_Rectangle_StringFormat: proc (* AddString *)
       (# 
          arg1: ^_String;
          arg2: ^_FontFamily;
          arg3: @int32;
          arg4: @real32;
          arg5: ^_Rectangle;
          arg6: ^_StringFormat;
       enter (arg1[], arg2[], arg3, arg4, arg5[], arg6[])
       do 'AddString' -> procname;
       #);
     Transform: proc
       (# 
          arg1: ^_Matrix;
       enter (arg1[])
       #);
     GetBounds: proc (* GetBounds *)
       (# result: ^_RectangleF;
       do 'GetBounds' -> procname;
       exit result[]
       #);
     GetBounds_Matrix: proc (* GetBounds *)
       (# result: ^_RectangleF;
          arg1: ^_Matrix;
       enter (arg1[])
       do 'GetBounds' -> procname;
       exit result[]
       #);
     GetBounds_Matrix_Pen: proc (* GetBounds *)
       (# result: ^_RectangleF;
          arg1: ^_Matrix;
          arg2: ^_Pen;
       enter (arg1[], arg2[])
       do 'GetBounds' -> procname;
       exit result[]
       #);
     Flatten: proc (* Flatten *)
       (# 
       do 'Flatten' -> procname;
       #);
     Flatten_Matrix: proc (* Flatten *)
       (# 
          arg1: ^_Matrix;
       enter (arg1[])
       do 'Flatten' -> procname;
       #);
     Flatten_Matrix_real32: proc (* Flatten *)
       (# 
          arg1: ^_Matrix;
          arg2: @real32;
       enter (arg1[], arg2)
       do 'Flatten' -> procname;
       #);
     Widen_Pen: proc (* Widen *)
       (# 
          arg1: ^_Pen;
       enter (arg1[])
       do 'Widen' -> procname;
       #);
     Widen_Pen_Matrix: proc (* Widen *)
       (# 
          arg1: ^_Pen;
          arg2: ^_Matrix;
       enter (arg1[], arg2[])
       do 'Widen' -> procname;
       #);
     Widen_Pen_Matrix_real32: proc (* Widen *)
       (# 
          arg1: ^_Pen;
          arg2: ^_Matrix;
          arg3: @real32;
       enter (arg1[], arg2[], arg3)
       do 'Widen' -> procname;
       #);
     Warp_ArrayOf_PointF_RectangleF: proc (* Warp *)
       (# 
          arg1: [0]^_PointF;
          arg2: ^_RectangleF;
       enter (arg1[], arg2[])
       do 'Warp' -> procname;
       #);
     Warp_ArrayOf_PointF_RectangleF_Matrix: proc (* Warp *)
       (# 
          arg1: [0]^_PointF;
          arg2: ^_RectangleF;
          arg3: ^_Matrix;
       enter (arg1[], arg2[], arg3[])
       do 'Warp' -> procname;
       #);
     Warp_ArrayOf_PointF_RectangleF_Matrix_WarpMode: proc (* Warp *)
       (# 
          arg1: [0]^_PointF;
          arg2: ^_RectangleF;
          arg3: ^_Matrix;
          arg4: @int32;
       enter (arg1[], arg2[], arg3[], arg4)
       do 'Warp' -> procname;
       #);
     Warp_ArrayOf_PointF_RectangleF_Matrix_WarpMode_real32: proc (* Warp *)
       (# 
          arg1: [0]^_PointF;
          arg2: ^_RectangleF;
          arg3: ^_Matrix;
          arg4: @int32;
          arg5: @real32;
       enter (arg1[], arg2[], arg3[], arg4, arg5)
       do 'Warp' -> procname;
       #);
     get_PointCount: proc
       (# result: @int32;
       exit result
       #);
     get_PathTypes: proc
       (# result: [0]@int8u;
       exit result
       #);
     get_PathPoints: proc
       (# result: [0]^_PointF;
       exit result
       #);
  do '[System.Drawing]System.Drawing.Drawing2D.GraphicsPath' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asGraphicsPath:
  (# _G: ^_GraphicsPath;
     G: ^GraphicsPath;
  enter _G[]
  do _G[]->G[];
  exit G[]
  #);
