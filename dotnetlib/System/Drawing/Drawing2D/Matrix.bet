ORIGIN '_Matrix';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/_MarshalByRefObject';
INCLUDE '~beta/dotnetlib/System/Drawing/_RectangleF';
INCLUDE '~beta/dotnetlib/System/Drawing/_PointF';
INCLUDE '~beta/dotnetlib/System/Drawing/_Rectangle';
INCLUDE '~beta/dotnetlib/System/Drawing/_Point';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_MatrixOrder';
--LIB: attributes--

(* .NET Matrix class. *)
Matrix: _Matrix
  (#
     (* Public/family CLS compliant constructors *)

     _init: cons (* constructor *)
       (# result: ^Matrix;
       exit result[]
       #);
     _init_real32_real32_real32_real32_real32_real32: cons (* constructor *)
       (# result: ^Matrix;
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
          arg5: @real32;
          arg6: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       exit result[]
       #);
     _init_RectangleF_ArrayOf_PointF: cons (* constructor *)
       (# result: ^Matrix;
          arg1: ^_RectangleF;
          arg2: [0]^_PointF;
       enter (arg1[], arg2[])
       exit result[]
       #);
     _init_Rectangle_ArrayOf_Point: cons (* constructor *)
       (# result: ^Matrix;
          arg1: ^_Rectangle;
          arg2: [0]^_Point;
       enter (arg1[], arg2[])
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     Dispose: proc
       (# 
       #);
     GetHashCode: proc
       (# result: @int32;
       exit result
       #);
     Equals: proc
       (# result: @boolean;
          arg1: ^Object;
       enter (arg1[])
       exit result
       #);
     Clone: proc
       (# result: ^Matrix;
       exit result[]
       #);
     get_Elements: proc
       (# result: [0]@real32;
       exit result
       #);
     get_OffsetX: proc
       (# result: @real32;
       exit result
       #);
     get_OffsetY: proc
       (# result: @real32;
       exit result
       #);
     Reset: proc
       (# 
       #);
     Multiply_Matrix: proc (* Multiply *)
       (# 
          arg1: ^Matrix;
       enter (arg1[])
       do 'Multiply' -> procname;
       #);
     Multiply_Matrix_MatrixOrder: proc (* Multiply *)
       (# 
          arg1: ^Matrix;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'Multiply' -> procname;
       #);
     Translate_real32_real32: proc (* Translate *)
       (# 
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'Translate' -> procname;
       #);
     Translate_real32_real32_MatrixOrder: proc (* Translate *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'Translate' -> procname;
       #);
     Scale_real32_real32: proc (* Scale *)
       (# 
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'Scale' -> procname;
       #);
     Scale_real32_real32_MatrixOrder: proc (* Scale *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'Scale' -> procname;
       #);
     Rotate_real32: proc (* Rotate *)
       (# 
          arg1: @real32;
       enter (arg1)
       do 'Rotate' -> procname;
       #);
     Rotate_real32_MatrixOrder: proc (* Rotate *)
       (# 
          arg1: @real32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Rotate' -> procname;
       #);
     RotateAt_real32_PointF: proc (* RotateAt *)
       (# 
          arg1: @real32;
          arg2: ^_PointF;
       enter (arg1, arg2[])
       do 'RotateAt' -> procname;
       #);
     RotateAt_real32_PointF_MatrixOrder: proc (* RotateAt *)
       (# 
          arg1: @real32;
          arg2: ^_PointF;
          arg3: @int32;
       enter (arg1, arg2[], arg3)
       do 'RotateAt' -> procname;
       #);
     Shear_real32_real32: proc (* Shear *)
       (# 
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'Shear' -> procname;
       #);
     Shear_real32_real32_MatrixOrder: proc (* Shear *)
       (# 
          arg1: @real32;
          arg2: @real32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'Shear' -> procname;
       #);
     Invert: proc
       (# 
       #);
     TransformPoints_ArrayOf_PointF: proc (* TransformPoints *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'TransformPoints' -> procname;
       #);
     TransformPoints_ArrayOf_Point: proc (* TransformPoints *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'TransformPoints' -> procname;
       #);
     TransformVectors_ArrayOf_PointF: proc (* TransformVectors *)
       (# 
          arg1: [0]^_PointF;
       enter (arg1[])
       do 'TransformVectors' -> procname;
       #);
     VectorTransformPoints: proc
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       #);
     TransformVectors_ArrayOf_Point: proc (* TransformVectors *)
       (# 
          arg1: [0]^_Point;
       enter (arg1[])
       do 'TransformVectors' -> procname;
       #);
     get_IsInvertible: proc
       (# result: @boolean;
       exit result
       #);
     get_IsIdentity: proc
       (# result: @boolean;
       exit result
       #);
  do '[System.Drawing]System.Drawing.Drawing2D.Matrix' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asMatrix:
  (# _M: ^_Matrix;
     M: ^Matrix;
  enter _M[]
  do _M[]->M[];
  exit M[]
  #);
