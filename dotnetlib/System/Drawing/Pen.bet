ORIGIN '_Pen';
INCLUDE '~beta/dotnetlib/System/_MarshalByRefObject';
INCLUDE '~beta/dotnetlib/System/Drawing/_Color';
INCLUDE '~beta/dotnetlib/System/Drawing/_Brush';
INCLUDE '~beta/dotnetlib/System/_Void';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_LineCap';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_DashCap';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_LineJoin';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_CustomLineCap';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_PenAlignment';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_Matrix';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_MatrixOrder';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_PenType';
INCLUDE '~beta/dotnetlib/System/Drawing/Drawing2D/_DashStyle';
--LIB: attributes--

(* .NET Pen class. *)
Pen: _Pen
  (#
     (* Public/family CLS compliant constructors *)

     _init_Color: cons (* constructor *)
       (# result: ^Pen;
          arg1: ^_Color;
       enter (arg1[])
       exit result[]
       #);
     _init_Color_real32: cons (* constructor *)
       (# result: ^Pen;
          arg1: ^_Color;
          arg2: @real32;
       enter (arg1[], arg2)
       exit result[]
       #);
     _init_Brush: cons (* constructor *)
       (# result: ^Pen;
          arg1: ^_Brush;
       enter (arg1[])
       exit result[]
       #);
     _init_Brush_real32: cons (* constructor *)
       (# result: ^Pen;
          arg1: ^_Brush;
          arg2: @real32;
       enter (arg1[], arg2)
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     Dispose: proc
       (# result: ^_Void;
       exit result[]
       #);
     Clone: proc
       (# result: ^Object;
       exit result[]
       #);
     get_Width: proc
       (# result: @real32;
       exit result
       #);
     set_Width: proc
       (# result: ^_Void;
          arg1: @real32;
       enter (arg1)
       exit result[]
       #);
     SetLineCap: proc
       (# result: ^_Void;
          arg1: ^_LineCap;
          arg2: ^_LineCap;
          arg3: ^_DashCap;
       enter (arg1[], arg2[], arg3[])
       exit result[]
       #);
     get_StartCap: proc
       (# result: ^_LineCap;
       exit result[]
       #);
     set_StartCap: proc
       (# result: ^_Void;
          arg1: ^_LineCap;
       enter (arg1[])
       exit result[]
       #);
     get_EndCap: proc
       (# result: ^_LineCap;
       exit result[]
       #);
     set_EndCap: proc
       (# result: ^_Void;
          arg1: ^_LineCap;
       enter (arg1[])
       exit result[]
       #);
     get_DashCap: proc
       (# result: ^_DashCap;
       exit result[]
       #);
     set_DashCap: proc
       (# result: ^_Void;
          arg1: ^_DashCap;
       enter (arg1[])
       exit result[]
       #);
     get_LineJoin: proc
       (# result: ^_LineJoin;
       exit result[]
       #);
     set_LineJoin: proc
       (# result: ^_Void;
          arg1: ^_LineJoin;
       enter (arg1[])
       exit result[]
       #);
     get_CustomStartCap: proc
       (# result: ^_CustomLineCap;
       exit result[]
       #);
     set_CustomStartCap: proc
       (# result: ^_Void;
          arg1: ^_CustomLineCap;
       enter (arg1[])
       exit result[]
       #);
     get_CustomEndCap: proc
       (# result: ^_CustomLineCap;
       exit result[]
       #);
     set_CustomEndCap: proc
       (# result: ^_Void;
          arg1: ^_CustomLineCap;
       enter (arg1[])
       exit result[]
       #);
     get_MiterLimit: proc
       (# result: @real32;
       exit result
       #);
     set_MiterLimit: proc
       (# result: ^_Void;
          arg1: @real32;
       enter (arg1)
       exit result[]
       #);
     get_Alignment: proc
       (# result: ^_PenAlignment;
       exit result[]
       #);
     set_Alignment: proc
       (# result: ^_Void;
          arg1: ^_PenAlignment;
       enter (arg1[])
       exit result[]
       #);
     get_Transform: proc
       (# result: ^_Matrix;
       exit result[]
       #);
     set_Transform: proc
       (# result: ^_Void;
          arg1: ^_Matrix;
       enter (arg1[])
       exit result[]
       #);
     ResetTransform: proc
       (# result: ^_Void;
       exit result[]
       #);
     MultiplyTransform_Matrix: proc (* MultiplyTransform *)
       (# result: ^_Void;
          arg1: ^_Matrix;
       enter (arg1[])
       do 'MultiplyTransform' -> procname;
       exit result[]
       #);
     MultiplyTransform_Matrix_MatrixOrder: proc (* MultiplyTransform *)
       (# result: ^_Void;
          arg1: ^_Matrix;
          arg2: ^_MatrixOrder;
       enter (arg1[], arg2[])
       do 'MultiplyTransform' -> procname;
       exit result[]
       #);
     TranslateTransform_real32_real32: proc (* TranslateTransform *)
       (# result: ^_Void;
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'TranslateTransform' -> procname;
       exit result[]
       #);
     TranslateTransform_real32_real32_MatrixOrder: proc (* TranslateTransform *)
       (# result: ^_Void;
          arg1: @real32;
          arg2: @real32;
          arg3: ^_MatrixOrder;
       enter (arg1, arg2, arg3[])
       do 'TranslateTransform' -> procname;
       exit result[]
       #);
     ScaleTransform_real32_real32: proc (* ScaleTransform *)
       (# result: ^_Void;
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'ScaleTransform' -> procname;
       exit result[]
       #);
     ScaleTransform_real32_real32_MatrixOrder: proc (* ScaleTransform *)
       (# result: ^_Void;
          arg1: @real32;
          arg2: @real32;
          arg3: ^_MatrixOrder;
       enter (arg1, arg2, arg3[])
       do 'ScaleTransform' -> procname;
       exit result[]
       #);
     RotateTransform_real32: proc (* RotateTransform *)
       (# result: ^_Void;
          arg1: @real32;
       enter (arg1)
       do 'RotateTransform' -> procname;
       exit result[]
       #);
     RotateTransform_real32_MatrixOrder: proc (* RotateTransform *)
       (# result: ^_Void;
          arg1: @real32;
          arg2: ^_MatrixOrder;
       enter (arg1, arg2[])
       do 'RotateTransform' -> procname;
       exit result[]
       #);
     get_PenType: proc
       (# result: ^_PenType;
       exit result[]
       #);
     get_Color: proc
       (# result: ^_Color;
       exit result[]
       #);
     set_Color: proc
       (# result: ^_Void;
          arg1: ^_Color;
       enter (arg1[])
       exit result[]
       #);
     get_Brush: proc
       (# result: ^_Brush;
       exit result[]
       #);
     set_Brush: proc
       (# result: ^_Void;
          arg1: ^_Brush;
       enter (arg1[])
       exit result[]
       #);
     get_DashStyle: proc
       (# result: ^_DashStyle;
       exit result[]
       #);
     set_DashStyle: proc
       (# result: ^_Void;
          arg1: ^_DashStyle;
       enter (arg1[])
       exit result[]
       #);
     get_DashOffset: proc
       (# result: @real32;
       exit result
       #);
     set_DashOffset: proc
       (# result: ^_Void;
          arg1: @real32;
       enter (arg1)
       exit result[]
       #);
     get_DashPattern: proc
       (# result: [0]@real32;
       exit result
       #);
     set_DashPattern: proc
       (# result: ^_Void;
          arg1: [0]@real32;
       enter (arg1)
       exit result[]
       #);
     get_CompoundArray: proc
       (# result: [0]@real32;
       exit result
       #);
     set_CompoundArray: proc
       (# result: ^_Void;
          arg1: [0]@real32;
       enter (arg1)
       exit result[]
       #);
  do '[system.drawing]System.Drawing.Pen' -> className;
  INNER;
  #);

