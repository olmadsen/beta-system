ORIGIN '_PermissionSet';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/Security/Permissions/_PermissionState';
INCLUDE '~beta/dotnetlib/System/Collections/_IEnumerator';
INCLUDE '~beta/dotnetlib/System/_Array';
INCLUDE '~beta/dotnetlib/System/Security/_SecurityElement';
INCLUDE '~beta/dotnetlib/System/Security/_IPermission';
INCLUDE '~beta/dotnetlib/System/_Type';
INCLUDE '~beta/dotnetlib/System/_String';
--LIB: attributes--

(* .NET PermissionSet class. *)
PermissionSet: _PermissionSet
  (#
     (* Public/family CLS compliant constructors *)

     _init_PermissionState: cons (* constructor *)
       (# result: ^PermissionSet;
          arg1: @int32;
       enter (arg1)
       exit result[]
       #);
     _init_PermissionSet: cons (* constructor *)
       (# result: ^PermissionSet;
          arg1: ^PermissionSet;
       enter (arg1[])
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     PermitOnly: proc
       (# 
       #);
     Deny: proc
       (# 
       #);
     Demand: proc
       (# 
       #);
     Assert: proc
       (# 
       #);
     GetEnumerator: proc
       (# result: ^_IEnumerator;
       exit result[]
       #);
     get_IsSynchronized: proc
       (# result: @boolean;
       exit result
       #);
     get_SyncRoot: proc
       (# result: ^Object;
       exit result[]
       #);
     get_Count: proc
       (# result: @int32;
       exit result
       #);
     CopyTo: proc
       (# 
          arg1: ^_Array;
          arg2: @int32;
       enter (arg1[], arg2)
       #);
     FromXml: proc
       (# 
          arg1: ^_SecurityElement;
       enter (arg1[])
       #);
     ToXml: proc
       (# result: ^_SecurityElement;
       exit result[]
       #);
     Copy: proc
       (# result: ^PermissionSet;
       exit result[]
       #);
     Union: proc
       (# result: ^PermissionSet;
          arg1: ^PermissionSet;
       enter (arg1[])
       exit result[]
       #);
     Intersect: proc
       (# result: ^PermissionSet;
          arg1: ^PermissionSet;
       enter (arg1[])
       exit result[]
       #);
     IsSubsetOf: proc
       (# result: @boolean;
          arg1: ^PermissionSet;
       enter (arg1[])
       exit result
       #);
     IsUnrestricted: proc
       (# result: @boolean;
       exit result
       #);
     RemovePermission: proc
       (# result: ^_IPermission;
          arg1: ^_Type;
       enter (arg1[])
       exit result[]
       #);
     AddPermission: proc
       (# result: ^_IPermission;
          arg1: ^_IPermission;
       enter (arg1[])
       exit result[]
       #);
     SetPermission: proc
       (# result: ^_IPermission;
          arg1: ^_IPermission;
       enter (arg1[])
       exit result[]
       #);
     GetPermission: proc
       (# result: ^_IPermission;
          arg1: ^_Type;
       enter (arg1[])
       exit result[]
       #);
     IsEmpty: proc
       (# result: @boolean;
       exit result
       #);
     get_IsReadOnly: proc
       (# result: @boolean;
       exit result
       #);
     ToString: proc
       (# result: ^_String;
       exit result[]
       #);
     ConvertPermissionSet: static_proc
       (# result: [0]@int8u;
          arg1: ^_String;
          arg2: [0]@int8u;
          arg3: ^_String;
       enter (arg1[], arg2[], arg3[])
       exit result
       #);
     ContainsNonCodeAccessPermissions: proc
       (# result: @boolean;
       exit result
       #);
  do '[mscorlib]System.Security.PermissionSet' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asPermissionSet:
  (# _P: ^_PermissionSet;
     P: ^PermissionSet;
  enter _P[]
  do _P[]->P[];
  exit P[]
  #);
