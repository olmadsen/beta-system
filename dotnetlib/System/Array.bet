ORIGIN '_Array';
INCLUDE '~beta/dotnetlib/System/Collections/_IEnumerator';
INCLUDE '~beta/dotnetlib/System/_Type';
INCLUDE '~beta/dotnetlib/System/Collections/_IComparer';
--LIB: attributes--

(* .NET Array class. *)
Array: _Array
  (#
     (* Public/family CLS compliant methods *)

     GetEnumerator: proc
       (# result: ^_IEnumerator;
       exit result[]
       #);
     get_IsSynchronized: proc
       (# result: @boolean;
       exit result
       #);
     get_SyncRoot: proc
       (# result: ^Object;
       exit result[]
       #);
     CopyTo_Array_int32: proc (* CopyTo *)
       (# 
          arg1: ^Array;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'CopyTo' -> procname;
       #);
     get_IsFixedSize: proc
       (# result: @boolean;
       exit result
       #);
     get_IsReadOnly: proc
       (# result: @boolean;
       exit result
       #);
     Clone: proc
       (# result: ^Object;
       exit result[]
       #);
     CopyTo_Array_int64: proc (* CopyTo *)
       (# 
          arg1: ^Array;
          arg2: @int64;
       enter (arg1[], arg2)
       do 'CopyTo' -> procname;
       #);
     CreateInstance_Type_int32: static_proc (* CreateInstance *)
       (# result: ^Array;
          arg1: ^_Type;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstance_Type_int32_int32: static_proc (* CreateInstance *)
       (# result: ^Array;
          arg1: ^_Type;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstance_Type_int32_int32_int32: static_proc (* CreateInstance *)
       (# result: ^Array;
          arg1: ^_Type;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1[], arg2, arg3, arg4)
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstance_Type_ArrayOfInt32: static_proc (* CreateInstance *)
       (# result: ^Array;
          arg1: ^_Type;
          arg2: [0]@int32;
       enter (arg1[], arg2)
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstance_Type_ArrayOfInt64: static_proc (* CreateInstance *)
       (# result: ^Array;
          arg1: ^_Type;
          arg2: [0]@int64;
       enter (arg1[], arg2)
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstance_Type_ArrayOfInt32_ArrayOfInt32: static_proc (* CreateInstance *)
       (# result: ^Array;
          arg1: ^_Type;
          arg2: [0]@int32;
          arg3: [0]@int32;
       enter (arg1[], arg2, arg3)
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     Copy_Array_Array_int32: static_proc (* Copy *)
       (# 
          arg1: ^Array;
          arg2: ^Array;
          arg3: @int32;
       enter (arg1[], arg2[], arg3)
       do 'Copy' -> procname;
       #);
     Copy_Array_int32_Array_int32_int32: static_proc (* Copy *)
       (# 
          arg1: ^Array;
          arg2: @int32;
          arg3: ^Array;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'Copy' -> procname;
       #);
     Copy_Array_Array_int64: static_proc (* Copy *)
       (# 
          arg1: ^Array;
          arg2: ^Array;
          arg3: @int64;
       enter (arg1[], arg2[], arg3)
       do 'Copy' -> procname;
       #);
     Copy_Array_int64_Array_int64_int64: static_proc (* Copy *)
       (# 
          arg1: ^Array;
          arg2: @int64;
          arg3: ^Array;
          arg4: @int64;
          arg5: @int64;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'Copy' -> procname;
       #);
     Clear: static_proc
       (# 
          arg1: ^Array;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       #);
     GetValue_ArrayOfInt32: proc (* GetValue *)
       (# result: ^Object;
          arg1: [0]@int32;
       enter (arg1)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_int32: proc (* GetValue *)
       (# result: ^Object;
          arg1: @int32;
       enter (arg1)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_int32_int32: proc (* GetValue *)
       (# result: ^Object;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_int32_int32_int32: proc (* GetValue *)
       (# result: ^Object;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_int64: proc (* GetValue *)
       (# result: ^Object;
          arg1: @int64;
       enter (arg1)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_int64_int64: proc (* GetValue *)
       (# result: ^Object;
          arg1: @int64;
          arg2: @int64;
       enter (arg1, arg2)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_int64_int64_int64: proc (* GetValue *)
       (# result: ^Object;
          arg1: @int64;
          arg2: @int64;
          arg3: @int64;
       enter (arg1, arg2, arg3)
       do 'GetValue' -> procname;
       exit result[]
       #);
     GetValue_ArrayOfInt64: proc (* GetValue *)
       (# result: ^Object;
          arg1: [0]@int64;
       enter (arg1)
       do 'GetValue' -> procname;
       exit result[]
       #);
     SetValue_Object_int32: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_int32_int32: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_int32_int32_int32: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1[], arg2, arg3, arg4)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_ArrayOfInt32: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: [0]@int32;
       enter (arg1[], arg2)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_int64: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: @int64;
       enter (arg1[], arg2)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_int64_int64: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: @int64;
          arg3: @int64;
       enter (arg1[], arg2, arg3)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_int64_int64_int64: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: @int64;
          arg3: @int64;
          arg4: @int64;
       enter (arg1[], arg2, arg3, arg4)
       do 'SetValue' -> procname;
       #);
     SetValue_Object_ArrayOfInt64: proc (* SetValue *)
       (# 
          arg1: ^Object;
          arg2: [0]@int64;
       enter (arg1[], arg2)
       do 'SetValue' -> procname;
       #);
     get_Length: proc
       (# result: @int32;
       exit result
       #);
     get_LongLength: proc
       (# result: @int64;
       exit result
       #);
     GetLength: proc
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     GetLongLength: proc
       (# result: @int64;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     get_Rank: proc
       (# result: @int32;
       exit result
       #);
     GetUpperBound: proc
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     GetLowerBound: proc
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     BinarySearch_Array_Object: static_proc (* BinarySearch *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
       enter (arg1[], arg2[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     BinarySearch_Array_int32_int32_Object: static_proc (* BinarySearch *)
       (# result: @int32;
          arg1: ^Array;
          arg2: @int32;
          arg3: @int32;
          arg4: ^Object;
       enter (arg1[], arg2, arg3, arg4[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     BinarySearch_Array_Object_IComparer: static_proc (* BinarySearch *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
          arg3: ^_IComparer;
       enter (arg1[], arg2[], arg3[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     BinarySearch_Array_int32_int32_Object_IComparer: static_proc (* BinarySearch *)
       (# result: @int32;
          arg1: ^Array;
          arg2: @int32;
          arg3: @int32;
          arg4: ^Object;
          arg5: ^_IComparer;
       enter (arg1[], arg2, arg3, arg4[], arg5[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     IndexOf_Array_Object: static_proc (* IndexOf *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
       enter (arg1[], arg2[])
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_Array_Object_int32: static_proc (* IndexOf *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
          arg3: @int32;
       enter (arg1[], arg2[], arg3)
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_Array_Object_int32_int32: static_proc (* IndexOf *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
          arg3: @int32;
          arg4: @int32;
       enter (arg1[], arg2[], arg3, arg4)
       do 'IndexOf' -> procname;
       exit result
       #);
     LastIndexOf_Array_Object: static_proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
       enter (arg1[], arg2[])
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_Array_Object_int32: static_proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
          arg3: @int32;
       enter (arg1[], arg2[], arg3)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_Array_Object_int32_int32: static_proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^Array;
          arg2: ^Object;
          arg3: @int32;
          arg4: @int32;
       enter (arg1[], arg2[], arg3, arg4)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     Reverse_Array: static_proc (* Reverse *)
       (# 
          arg1: ^Array;
       enter (arg1[])
       do 'Reverse' -> procname;
       #);
     Reverse_Array_int32_int32: static_proc (* Reverse *)
       (# 
          arg1: ^Array;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'Reverse' -> procname;
       #);
     Sort_Array: static_proc (* Sort *)
       (# 
          arg1: ^Array;
       enter (arg1[])
       do 'Sort' -> procname;
       #);
     Sort_Array_Array: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: ^Array;
       enter (arg1[], arg2[])
       do 'Sort' -> procname;
       #);
     Sort_Array_int32_int32: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'Sort' -> procname;
       #);
     Sort_Array_Array_int32_int32: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: ^Array;
          arg3: @int32;
          arg4: @int32;
       enter (arg1[], arg2[], arg3, arg4)
       do 'Sort' -> procname;
       #);
     Sort_Array_IComparer: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: ^_IComparer;
       enter (arg1[], arg2[])
       do 'Sort' -> procname;
       #);
     Sort_Array_Array_IComparer: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: ^Array;
          arg3: ^_IComparer;
       enter (arg1[], arg2[], arg3[])
       do 'Sort' -> procname;
       #);
     Sort_Array_int32_int32_IComparer: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: @int32;
          arg3: @int32;
          arg4: ^_IComparer;
       enter (arg1[], arg2, arg3, arg4[])
       do 'Sort' -> procname;
       #);
     Sort_Array_Array_int32_int32_IComparer: static_proc (* Sort *)
       (# 
          arg1: ^Array;
          arg2: ^Array;
          arg3: @int32;
          arg4: @int32;
          arg5: ^_IComparer;
       enter (arg1[], arg2[], arg3, arg4, arg5[])
       do 'Sort' -> procname;
       #);
     Initialize: proc
       (# 
       #);
  do '[mscorlib]System.Array' -> className;
  INNER;
  #);

