ORIGIN '_String';
INCLUDE '~beta/dotnetlib/System/_IFormatProvider';
INCLUDE '~beta/dotnetlib/System/_TypeCode';
INCLUDE '~beta/dotnetlib/System/_Void';
INCLUDE '~beta/dotnetlib/System/Globalization/_CultureInfo';
INCLUDE '~beta/dotnetlib/System/_CharEnumerator';
--LIB: attributes--

(* .NET String class. *)
String: _String
  (#
     (* Public/protected CLS compliant constructors *)

     _init_ArrayOfChar_int32_int32: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       exit result[]
       #);
     _init_ArrayOfChar: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1)
       exit result[]
       #);
     _init_char_int32: cons (* constructor *)
       (# result: ^String;
          arg1: @char;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);

     (* Public/protected CLS compliant methods *)

     ToString_IFormatProvider: proc (* ToString *)
       (# result: ^String;
          arg1: ^_IFormatProvider;
       enter (arg1[])
       do 'ToString' -> procname;
       exit result[]
       #);
     GetTypeCode: proc
       (# result: ^_TypeCode;
       exit result[]
       #);
     Clone: proc
       (# result: ^_Object;
       exit result[]
       #);
     CompareTo_Object: proc (* CompareTo *)
       (# result: @int32;
          arg1: ^_Object;
       enter (arg1[])
       do 'CompareTo' -> procname;
       exit result
       #);
     GetHashCode: proc
       (# result: @int32;
       exit result
       #);
     Equals_Object: proc (* Equals *)
       (# result: @boolean;
          arg1: ^_Object;
       enter (arg1[])
       do 'Equals' -> procname;
       exit result
       #);
     ToString: proc (* ToString *)
       (# result: ^String;
       do 'ToString' -> procname;
       exit result[]
       #);
     Equals_String: proc (* Equals *)
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       do 'Equals' -> procname;
       exit result
       #);
     get_Chars: proc
       (# result: @char;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     CopyTo: proc
       (# result: ^_Void;
          arg1: @int32;
          arg2: [0]@char;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2, arg3, arg4)
       exit result[]
       #);
     ToCharArray: proc (* ToCharArray *)
       (# result: [0]@char;
       do 'ToCharArray' -> procname;
       exit result
       #);
     ToCharArray_int32_int32: proc (* ToCharArray *)
       (# result: [0]@char;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'ToCharArray' -> procname;
       exit result
       #);
     get_Length: proc
       (# result: @int32;
       exit result
       #);
     Split_ArrayOfChar: proc (* Split *)
       (# result: [0]^String;
          arg1: [0]@char;
       enter (arg1)
       do 'Split' -> procname;
       exit result
       #);
     Split_ArrayOfChar_int32: proc (* Split *)
       (# result: [0]^String;
          arg1: [0]@char;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Split' -> procname;
       exit result
       #);
     Substring_int32: proc (* Substring *)
       (# result: ^String;
          arg1: @int32;
       enter (arg1)
       do 'Substring' -> procname;
       exit result[]
       #);
     Substring_int32_int32: proc (* Substring *)
       (# result: ^String;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Substring' -> procname;
       exit result[]
       #);
     Trim_ArrayOfChar: proc (* Trim *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1)
       do 'Trim' -> procname;
       exit result[]
       #);
     TrimStart: proc
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1)
       exit result[]
       #);
     TrimEnd: proc
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1)
       exit result[]
       #);
     CompareTo_String: proc (* CompareTo *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'CompareTo' -> procname;
       exit result
       #);
     EndsWith: proc
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       exit result
       #);
     IndexOf_char: proc (* IndexOf *)
       (# result: @int32;
          arg1: @char;
       enter (arg1)
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_char_int32: proc (* IndexOf *)
       (# result: @int32;
          arg1: @char;
          arg2: @int32;
       enter (arg1, arg2)
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_char_int32_int32: proc (* IndexOf *)
       (# result: @int32;
          arg1: @char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOfAny_ArrayOfChar: proc (* IndexOfAny *)
       (# result: @int32;
          arg1: [0]@char;
       enter (arg1)
       do 'IndexOfAny' -> procname;
       exit result
       #);
     IndexOfAny_ArrayOfChar_int32: proc (* IndexOfAny *)
       (# result: @int32;
          arg1: [0]@char;
          arg2: @int32;
       enter (arg1, arg2)
       do 'IndexOfAny' -> procname;
       exit result
       #);
     IndexOfAny_ArrayOfChar_int32_int32: proc (* IndexOfAny *)
       (# result: @int32;
          arg1: [0]@char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'IndexOfAny' -> procname;
       exit result
       #);
     IndexOf_String: proc (* IndexOf *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_String_int32: proc (* IndexOf *)
       (# result: @int32;
          arg1: ^String;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_String_int32_int32: proc (* IndexOf *)
       (# result: @int32;
          arg1: ^String;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'IndexOf' -> procname;
       exit result
       #);
     LastIndexOf_char: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: @char;
       enter (arg1)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_char_int32: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: @char;
          arg2: @int32;
       enter (arg1, arg2)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_char_int32_int32: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: @char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOfAny_ArrayOfChar: proc (* LastIndexOfAny *)
       (# result: @int32;
          arg1: [0]@char;
       enter (arg1)
       do 'LastIndexOfAny' -> procname;
       exit result
       #);
     LastIndexOfAny_ArrayOfChar_int32: proc (* LastIndexOfAny *)
       (# result: @int32;
          arg1: [0]@char;
          arg2: @int32;
       enter (arg1, arg2)
       do 'LastIndexOfAny' -> procname;
       exit result
       #);
     LastIndexOfAny_ArrayOfChar_int32_int32: proc (* LastIndexOfAny *)
       (# result: @int32;
          arg1: [0]@char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'LastIndexOfAny' -> procname;
       exit result
       #);
     LastIndexOf_String: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_String_int32: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^String;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_String_int32_int32: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^String;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     PadLeft_int32: proc (* PadLeft *)
       (# result: ^String;
          arg1: @int32;
       enter (arg1)
       do 'PadLeft' -> procname;
       exit result[]
       #);
     PadLeft_int32_char: proc (* PadLeft *)
       (# result: ^String;
          arg1: @int32;
          arg2: @char;
       enter (arg1, arg2)
       do 'PadLeft' -> procname;
       exit result[]
       #);
     PadRight_int32: proc (* PadRight *)
       (# result: ^String;
          arg1: @int32;
       enter (arg1)
       do 'PadRight' -> procname;
       exit result[]
       #);
     PadRight_int32_char: proc (* PadRight *)
       (# result: ^String;
          arg1: @int32;
          arg2: @char;
       enter (arg1, arg2)
       do 'PadRight' -> procname;
       exit result[]
       #);
     StartsWith: proc
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       exit result
       #);
     ToLower: proc (* ToLower *)
       (# result: ^String;
       do 'ToLower' -> procname;
       exit result[]
       #);
     ToLower_CultureInfo: proc (* ToLower *)
       (# result: ^String;
          arg1: ^_CultureInfo;
       enter (arg1[])
       do 'ToLower' -> procname;
       exit result[]
       #);
     ToUpper: proc (* ToUpper *)
       (# result: ^String;
       do 'ToUpper' -> procname;
       exit result[]
       #);
     ToUpper_CultureInfo: proc (* ToUpper *)
       (# result: ^String;
          arg1: ^_CultureInfo;
       enter (arg1[])
       do 'ToUpper' -> procname;
       exit result[]
       #);
     Trim: proc (* Trim *)
       (# result: ^String;
       do 'Trim' -> procname;
       exit result[]
       #);
     Insert: proc
       (# result: ^String;
          arg1: @int32;
          arg2: ^String;
       enter (arg1, arg2[])
       exit result[]
       #);
     Replace_char_char: proc (* Replace *)
       (# result: ^String;
          arg1: @char;
          arg2: @char;
       enter (arg1, arg2)
       do 'Replace' -> procname;
       exit result[]
       #);
     Replace_String_String: proc (* Replace *)
       (# result: ^String;
          arg1: ^String;
          arg2: ^String;
       enter (arg1[], arg2[])
       do 'Replace' -> procname;
       exit result[]
       #);
     Remove: proc
       (# result: ^String;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);
     GetEnumerator: proc
       (# result: ^_CharEnumerator;
       exit result[]
       #);
  do '[mscorlib]System.String' -> className;
  INNER;
  #);

