ORIGIN '_ILGenerator';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/Diagnostics/SymbolStore/_ISymbolDocumentWriter';
INCLUDE '~beta/dotnetlib/System/Reflection/_FieldInfo';
INCLUDE '~beta/dotnetlib/System/Reflection/Emit/_LocalBuilder';
INCLUDE '~beta/dotnetlib/System/_String';
INCLUDE '~beta/dotnetlib/System/_Type';
INCLUDE '~beta/dotnetlib/System/Reflection/Emit/_Label';
INCLUDE '~beta/dotnetlib/System/Reflection/Emit/_OpCode';
INCLUDE '~beta/dotnetlib/System/Reflection/_ConstructorInfo';
INCLUDE '~beta/dotnetlib/System/Reflection/Emit/_SignatureHelper';
INCLUDE '~beta/dotnetlib/System/Reflection/_MethodInfo';
INCLUDE '~beta/dotnetlib/System/Reflection/_CallingConventions';
INCLUDE '~beta/dotnetlib/System/Runtime/InteropServices/_CallingConvention';
--LIB: attributes--

(* .NET ILGenerator class. *)
ILGenerator: _ILGenerator
  (#
     (* Public/family CLS compliant methods *)

     EndScope: proc
       (# 
       #);
     BeginScope: proc
       (# 
       #);
     MarkSequencePoint: proc
       (# 
          arg1: ^_ISymbolDocumentWriter;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3, arg4, arg5)
       #);
     EmitWriteLine_FieldInfo: proc (* EmitWriteLine *)
       (# 
          arg1: ^_FieldInfo;
       enter (arg1[])
       do 'EmitWriteLine' -> procname;
       #);
     EmitWriteLine_LocalBuilder: proc (* EmitWriteLine *)
       (# 
          arg1: ^_LocalBuilder;
       enter (arg1[])
       do 'EmitWriteLine' -> procname;
       #);
     EmitWriteLine_String: proc (* EmitWriteLine *)
       (# 
          arg1: ^_String;
       enter (arg1[])
       do 'EmitWriteLine' -> procname;
       #);
     ThrowException: proc
       (# 
          arg1: ^_Type;
       enter (arg1[])
       #);
     MarkLabel: proc
       (# 
          arg1: ^_Label;
       enter (arg1[])
       #);
     DefineLabel: proc
       (# result: ^_Label;
       exit result[]
       #);
     BeginFinallyBlock: proc
       (# 
       #);
     BeginFaultBlock: proc
       (# 
       #);
     BeginCatchBlock: proc
       (# 
          arg1: ^_Type;
       enter (arg1[])
       #);
     BeginExceptFilterBlock: proc
       (# 
       #);
     EndExceptionBlock: proc
       (# 
       #);
     BeginExceptionBlock: proc
       (# result: ^_Label;
       exit result[]
       #);
     Emit_OpCode_LocalBuilder: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_LocalBuilder;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_String: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_FieldInfo: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_FieldInfo;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_ArrayOf_Label: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: [0]^_Label;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_Label: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_Label;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_real: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: @real;
       enter (arg1[], arg2)
       do 'Emit' -> procname;
       #);
     Emit_OpCode_real32: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: @real32;
       enter (arg1[], arg2)
       do 'Emit' -> procname;
       #);
     Emit_OpCode_int64: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: @int64;
       enter (arg1[], arg2)
       do 'Emit' -> procname;
       #);
     Emit_OpCode_Type: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_Type;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_ConstructorInfo: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_ConstructorInfo;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_SignatureHelper: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_SignatureHelper;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_MethodInfo: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: ^_MethodInfo;
       enter (arg1[], arg2[])
       do 'Emit' -> procname;
       #);
     Emit_OpCode_int32: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'Emit' -> procname;
       #);
     Emit_OpCode_int16: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: @int16;
       enter (arg1[], arg2)
       do 'Emit' -> procname;
       #);
     Emit_OpCode_int8u: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
          arg2: @int8u;
       enter (arg1[], arg2)
       do 'Emit' -> procname;
       #);
     Emit_OpCode: proc (* Emit *)
       (# 
          arg1: ^_OpCode;
       enter (arg1[])
       do 'Emit' -> procname;
       #);
     EmitCalli_OpCode_CallingConventions_Type_ArrayOf_Type_ArrayOf_Type: proc (* EmitCalli *)
       (# 
          arg1: ^_OpCode;
          arg2: @int32;
          arg3: ^_Type;
          arg4: [0]^_Type;
          arg5: [0]^_Type;
       enter (arg1[], arg2, arg3[], arg4[], arg5[])
       do 'EmitCalli' -> procname;
       #);
     EmitCalli_OpCode_CallingConvention_Type_ArrayOf_Type: proc (* EmitCalli *)
       (# 
          arg1: ^_OpCode;
          arg2: @int32;
          arg3: ^_Type;
          arg4: [0]^_Type;
       enter (arg1[], arg2, arg3[], arg4[])
       do 'EmitCalli' -> procname;
       #);
     EmitCall: proc
       (# 
          arg1: ^_OpCode;
          arg2: ^_MethodInfo;
          arg3: [0]^_Type;
       enter (arg1[], arg2[], arg3[])
       #);
     DeclareLocal: proc
       (# result: ^_LocalBuilder;
          arg1: ^_Type;
       enter (arg1[])
       exit result[]
       #);
     UsingNamespace: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
  do '[mscorlib]System.Reflection.Emit.ILGenerator' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asILGenerator:
  (# _I: ^_ILGenerator;
     I: ^ILGenerator;
  enter _I[]
  do _I[]->I[];
  exit I[]
  #);
