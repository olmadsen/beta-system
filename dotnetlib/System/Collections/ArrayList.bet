ORIGIN '_ArrayList';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/Collections/_ICollection';
INCLUDE '~beta/dotnetlib/System/Collections/_IEnumerator';
INCLUDE '~beta/dotnetlib/System/_Array';
INCLUDE '~beta/dotnetlib/System/_Type';
INCLUDE '~beta/dotnetlib/System/Collections/_IComparer';
INCLUDE '~beta/dotnetlib/System/Collections/_IList';
--LIB: attributes--

(* .NET ArrayList class. *)
ArrayList: _ArrayList
  (#
     (* Public/family CLS compliant constructors *)

     _init: cons (* constructor *)
       (# result: ^ArrayList;
       exit result[]
       #);
     _init_int32: cons (* constructor *)
       (# result: ^ArrayList;
          arg1: @int32;
       enter (arg1)
       exit result[]
       #);
     _init_ICollection: cons (* constructor *)
       (# result: ^ArrayList;
          arg1: ^_ICollection;
       enter (arg1[])
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     Clone: proc
       (# result: ^Object;
       exit result[]
       #);
     GetEnumerator: proc (* GetEnumerator *)
       (# result: ^_IEnumerator;
       do 'GetEnumerator' -> procname;
       exit result[]
       #);
     get_IsSynchronized: proc
       (# result: @boolean;
       exit result
       #);
     get_SyncRoot: proc
       (# result: ^Object;
       exit result[]
       #);
     get_Count: proc
       (# result: @int32;
       exit result
       #);
     CopyTo_Array_int32: proc (* CopyTo *)
       (# 
          arg1: ^_Array;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'CopyTo' -> procname;
       #);
     RemoveAt: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     Remove: proc
       (# 
          arg1: ^Object;
       enter (arg1[])
       #);
     Insert: proc
       (# 
          arg1: @int32;
          arg2: ^Object;
       enter (arg1, arg2[])
       #);
     IndexOf_Object: proc (* IndexOf *)
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       do 'IndexOf' -> procname;
       exit result
       #);
     get_IsFixedSize: proc
       (# result: @boolean;
       exit result
       #);
     get_IsReadOnly: proc
       (# result: @boolean;
       exit result
       #);
     Clear: proc
       (# 
       #);
     Contains: proc
       (# result: @boolean;
          arg1: ^Object;
       enter (arg1[])
       exit result
       #);
     Add: proc
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       exit result
       #);
     set_Item: proc
       (# 
          arg1: @int32;
          arg2: ^Object;
       enter (arg1, arg2[])
       #);
     get_Item: proc
       (# result: ^Object;
          arg1: @int32;
       enter (arg1)
       exit result[]
       #);
     TrimToSize: proc
       (# 
       #);
     ToArray_Type: proc (* ToArray *)
       (# result: ^_Array;
          arg1: ^_Type;
       enter (arg1[])
       do 'ToArray' -> procname;
       exit result[]
       #);
     ToArray: proc (* ToArray *)
       (# result: [0]^Object;
       do 'ToArray' -> procname;
       exit result[]
       #);
     Sort_int32_int32_IComparer: proc (* Sort *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: ^_IComparer;
       enter (arg1, arg2, arg3[])
       do 'Sort' -> procname;
       #);
     Sort_IComparer: proc (* Sort *)
       (# 
          arg1: ^_IComparer;
       enter (arg1[])
       do 'Sort' -> procname;
       #);
     Sort: proc (* Sort *)
       (# 
       do 'Sort' -> procname;
       #);
     GetRange: proc
       (# result: ^ArrayList;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);
     SetRange: proc
       (# 
          arg1: @int32;
          arg2: ^_ICollection;
       enter (arg1, arg2[])
       #);
     Reverse_int32_int32: proc (* Reverse *)
       (# 
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'Reverse' -> procname;
       #);
     Reverse: proc (* Reverse *)
       (# 
       do 'Reverse' -> procname;
       #);
     RemoveRange: proc
       (# 
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       #);
     LastIndexOf_Object_int32_int32: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^Object;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_Object_int32: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^Object;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'LastIndexOf' -> procname;
       exit result
       #);
     LastIndexOf_Object: proc (* LastIndexOf *)
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       do 'LastIndexOf' -> procname;
       exit result
       #);
     InsertRange: proc
       (# 
          arg1: @int32;
          arg2: ^_ICollection;
       enter (arg1, arg2[])
       #);
     IndexOf_Object_int32_int32: proc (* IndexOf *)
       (# result: @int32;
          arg1: ^Object;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'IndexOf' -> procname;
       exit result
       #);
     IndexOf_Object_int32: proc (* IndexOf *)
       (# result: @int32;
          arg1: ^Object;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'IndexOf' -> procname;
       exit result
       #);
     GetEnumerator_int32_int32: proc (* GetEnumerator *)
       (# result: ^_IEnumerator;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'GetEnumerator' -> procname;
       exit result[]
       #);
     CopyTo_int32_Array_int32_int32: proc (* CopyTo *)
       (# 
          arg1: @int32;
          arg2: ^_Array;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2[], arg3, arg4)
       do 'CopyTo' -> procname;
       #);
     CopyTo_Array: proc (* CopyTo *)
       (# 
          arg1: ^_Array;
       enter (arg1[])
       do 'CopyTo' -> procname;
       #);
     BinarySearch_Object_IComparer: proc (* BinarySearch *)
       (# result: @int32;
          arg1: ^Object;
          arg2: ^_IComparer;
       enter (arg1[], arg2[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     BinarySearch_Object: proc (* BinarySearch *)
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     BinarySearch_int32_int32_Object_IComparer: proc (* BinarySearch *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
          arg3: ^Object;
          arg4: ^_IComparer;
       enter (arg1, arg2, arg3[], arg4[])
       do 'BinarySearch' -> procname;
       exit result
       #);
     AddRange: proc
       (# 
          arg1: ^_ICollection;
       enter (arg1[])
       #);
     set_Capacity: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     get_Capacity: proc
       (# result: @int32;
       exit result
       #);
     Adapter: static_proc
       (# result: ^ArrayList;
          arg1: ^_IList;
       enter (arg1[])
       exit result[]
       #);
     FixedSize_IList: static_proc (* FixedSize *)
       (# result: ^_IList;
          arg1: ^_IList;
       enter (arg1[])
       do 'FixedSize' -> procname;
       exit result[]
       #);
     FixedSize_ArrayList: static_proc (* FixedSize *)
       (# result: ^ArrayList;
          arg1: ^ArrayList;
       enter (arg1[])
       do 'FixedSize' -> procname;
       exit result[]
       #);
     ReadOnly_IList: static_proc (* ReadOnly *)
       (# result: ^_IList;
          arg1: ^_IList;
       enter (arg1[])
       do 'ReadOnly' -> procname;
       exit result[]
       #);
     ReadOnly_ArrayList: static_proc (* ReadOnly *)
       (# result: ^ArrayList;
          arg1: ^ArrayList;
       enter (arg1[])
       do 'ReadOnly' -> procname;
       exit result[]
       #);
     DotnetRepeat: static_proc
       (# result: ^ArrayList;
          arg1: ^Object;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'Repeat' -> procname;
       exit result[]
       #);
     Synchronized_IList: static_proc (* Synchronized *)
       (# result: ^_IList;
          arg1: ^_IList;
       enter (arg1[])
       do 'Synchronized' -> procname;
       exit result[]
       #);
     Synchronized_ArrayList: static_proc (* Synchronized *)
       (# result: ^ArrayList;
          arg1: ^ArrayList;
       enter (arg1[])
       do 'Synchronized' -> procname;
       exit result[]
       #);
  do '[mscorlib]System.Collections.ArrayList' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asArrayList:
  (# _A: ^_ArrayList;
     A: ^ArrayList;
  enter _A[]
  do _A[]->A[];
  exit A[]
  #);
