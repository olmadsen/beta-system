ORIGIN '_AppDomain';
INCLUDE '~beta/dotnetlib/System/_MarshalByRefObject';
INCLUDE '~beta/dotnetlib/System/_String';
INCLUDE '~beta/dotnetlib/System/_CrossAppDomainDelegate';
INCLUDE '~beta/dotnetlib/System/Security/Principal/_PrincipalPolicy';
INCLUDE '~beta/dotnetlib/System/Security/Principal/_IPrincipal';
INCLUDE '~beta/dotnetlib/System/Security/Policy/_PolicyLevel';
INCLUDE '~beta/dotnetlib/System/Reflection/_Assembly';
INCLUDE '~beta/dotnetlib/System/Security/Policy/_Evidence';
INCLUDE '~beta/dotnetlib/System/Reflection/_AssemblyName';
INCLUDE '~beta/dotnetlib/System/Runtime/Remoting/_ObjectHandle';
INCLUDE '~beta/dotnetlib/System/Reflection/_BindingFlags';
INCLUDE '~beta/dotnetlib/System/Reflection/_Binder';
INCLUDE '~beta/dotnetlib/System/Globalization/_CultureInfo';
INCLUDE '~beta/dotnetlib/System/Reflection/Emit/_AssemblyBuilder';
INCLUDE '~beta/dotnetlib/System/Reflection/Emit/_AssemblyBuilderAccess';
INCLUDE '~beta/dotnetlib/System/Security/_PermissionSet';
INCLUDE '~beta/dotnetlib/System/_UnhandledExceptionEventHandler';
INCLUDE '~beta/dotnetlib/System/_ResolveEventHandler';
INCLUDE '~beta/dotnetlib/System/_EventHandler';
INCLUDE '~beta/dotnetlib/System/_AssemblyLoadEventHandler';
INCLUDE '~beta/dotnetlib/System/_Type';
INCLUDE '~beta/dotnetlib/System/Configuration/Assemblies/_AssemblyHashAlgorithm';
INCLUDE '~beta/dotnetlib/System/_AppDomainSetup';
--LIB: attributes--

(* .NET AppDomain class. *)
AppDomain: _AppDomain
  (#
     (* Public/family CLS compliant methods *)

     get_DynamicDirectory: proc
       (# result: ^_String;
       exit result[]
       #);
     DoCallBack: proc
       (# 
          arg1: ^_CrossAppDomainDelegate;
       enter (arg1[])
       #);
     SetPrincipalPolicy: proc
       (# 
          arg1: ^_PrincipalPolicy;
       enter (arg1[])
       #);
     SetThreadPrincipal: proc
       (# 
          arg1: ^_IPrincipal;
       enter (arg1[])
       #);
     SetAppDomainPolicy: proc
       (# 
          arg1: ^_PolicyLevel;
       enter (arg1[])
       #);
     GetData: proc
       (# result: ^Object;
          arg1: ^_String;
       enter (arg1[])
       exit result[]
       #);
     SetData: proc
       (# 
          arg1: ^_String;
          arg2: ^Object;
       enter (arg1[], arg2[])
       #);
     SetCachePath: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     ClearShadowCopyPath: proc
       (# 
       #);
     SetShadowCopyPath: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     ClearPrivatePath: proc
       (# 
       #);
     AppendPrivatePath: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     GetAssemblies: proc
       (# result: [0]^_Assembly;
       exit result
       #);
     get_ShadowCopyFiles: proc
       (# result: @boolean;
       exit result
       #);
     get_RelativeSearchPath: proc
       (# result: ^_String;
       exit result[]
       #);
     get_BaseDirectory: proc
       (# result: ^_String;
       exit result[]
       #);
     get_FriendlyName: proc
       (# result: ^_String;
       exit result[]
       #);
     ExecuteAssembly_String_Evidence_ArrayOf_String: proc (* ExecuteAssembly *)
       (# result: @int32;
          arg1: ^_String;
          arg2: ^_Evidence;
          arg3: [0]^_String;
       enter (arg1[], arg2[], arg3[])
       do 'ExecuteAssembly' -> procname;
       exit result
       #);
     ExecuteAssembly_String: proc (* ExecuteAssembly *)
       (# result: @int32;
          arg1: ^_String;
       enter (arg1[])
       do 'ExecuteAssembly' -> procname;
       exit result
       #);
     ExecuteAssembly_String_Evidence: proc (* ExecuteAssembly *)
       (# result: @int32;
          arg1: ^_String;
          arg2: ^_Evidence;
       enter (arg1[], arg2[])
       do 'ExecuteAssembly' -> procname;
       exit result
       #);
     Load_String_Evidence: proc (* Load *)
       (# result: ^_Assembly;
          arg1: ^_String;
          arg2: ^_Evidence;
       enter (arg1[], arg2[])
       do 'Load' -> procname;
       exit result[]
       #);
     Load_AssemblyName_Evidence: proc (* Load *)
       (# result: ^_Assembly;
          arg1: ^_AssemblyName;
          arg2: ^_Evidence;
       enter (arg1[], arg2[])
       do 'Load' -> procname;
       exit result[]
       #);
     Load_ArrayOfInt8u_ArrayOfInt8u_Evidence: proc (* Load *)
       (# result: ^_Assembly;
          arg1: [0]@int8u;
          arg2: [0]@int8u;
          arg3: ^_Evidence;
       enter (arg1[], arg2[], arg3[])
       do 'Load' -> procname;
       exit result[]
       #);
     Load_ArrayOfInt8u_ArrayOfInt8u: proc (* Load *)
       (# result: ^_Assembly;
          arg1: [0]@int8u;
          arg2: [0]@int8u;
       enter (arg1[], arg2[])
       do 'Load' -> procname;
       exit result[]
       #);
     Load_ArrayOfInt8u: proc (* Load *)
       (# result: ^_Assembly;
          arg1: [0]@int8u;
       enter (arg1[])
       do 'Load' -> procname;
       exit result[]
       #);
     Load_String: proc (* Load *)
       (# result: ^_Assembly;
          arg1: ^_String;
       enter (arg1[])
       do 'Load' -> procname;
       exit result[]
       #);
     Load_AssemblyName: proc (* Load *)
       (# result: ^_Assembly;
          arg1: ^_AssemblyName;
       enter (arg1[])
       do 'Load' -> procname;
       exit result[]
       #);
     CreateInstanceFrom_String_String_boolean_BindingFlags_Binder_ArrayOfObject_CultureInfo_ArrayOfObject_Evidence: proc (* CreateInstanceFrom *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
          arg3: @boolean;
          arg4: ^_BindingFlags;
          arg5: ^_Binder;
          arg6: [0]^Object;
          arg7: ^_CultureInfo;
          arg8: [0]^Object;
          arg9: ^_Evidence;
       enter (arg1[], arg2[], arg3, arg4[], arg5[], arg6[], arg7[], arg8[], arg9[])
       do 'CreateInstanceFrom' -> procname;
       exit result[]
       #);
     CreateInstance_String_String_boolean_BindingFlags_Binder_ArrayOfObject_CultureInfo_ArrayOfObject_Evidence: proc (* CreateInstance *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
          arg3: @boolean;
          arg4: ^_BindingFlags;
          arg5: ^_Binder;
          arg6: [0]^Object;
          arg7: ^_CultureInfo;
          arg8: [0]^Object;
          arg9: ^_Evidence;
       enter (arg1[], arg2[], arg3, arg4[], arg5[], arg6[], arg7[], arg8[], arg9[])
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstanceFrom_String_String_ArrayOfObject: proc (* CreateInstanceFrom *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
          arg3: [0]^Object;
       enter (arg1[], arg2[], arg3[])
       do 'CreateInstanceFrom' -> procname;
       exit result[]
       #);
     CreateInstance_String_String_ArrayOfObject: proc (* CreateInstance *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
          arg3: [0]^Object;
       enter (arg1[], arg2[], arg3[])
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     CreateInstanceFrom_String_String: proc (* CreateInstanceFrom *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'CreateInstanceFrom' -> procname;
       exit result[]
       #);
     CreateInstance_String_String: proc (* CreateInstance *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'CreateInstance' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_String_Evidence_PermissionSet_PermissionSet_PermissionSet_boolean: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_String;
          arg4: ^_Evidence;
          arg5: ^_PermissionSet;
          arg6: ^_PermissionSet;
          arg7: ^_PermissionSet;
          arg8: @boolean;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[], arg6[], arg7[], arg8)
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_String_Evidence_PermissionSet_PermissionSet_PermissionSet: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_String;
          arg4: ^_Evidence;
          arg5: ^_PermissionSet;
          arg6: ^_PermissionSet;
          arg7: ^_PermissionSet;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[], arg6[], arg7[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_Evidence_PermissionSet_PermissionSet_PermissionSet: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_Evidence;
          arg4: ^_PermissionSet;
          arg5: ^_PermissionSet;
          arg6: ^_PermissionSet;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[], arg6[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_String_PermissionSet_PermissionSet_PermissionSet: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_String;
          arg4: ^_PermissionSet;
          arg5: ^_PermissionSet;
          arg6: ^_PermissionSet;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[], arg6[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_String_Evidence: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_String;
          arg4: ^_Evidence;
       enter (arg1[], arg2[], arg3[], arg4[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_PermissionSet_PermissionSet_PermissionSet: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_PermissionSet;
          arg4: ^_PermissionSet;
          arg5: ^_PermissionSet;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_Evidence: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_Evidence;
       enter (arg1[], arg2[], arg3[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess_String: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
          arg3: ^_String;
       enter (arg1[], arg2[], arg3[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     DefineDynamicAssembly_AssemblyName_AssemblyBuilderAccess: proc (* DefineDynamicAssembly *)
       (# result: ^_AssemblyBuilder;
          arg1: ^_AssemblyName;
          arg2: ^_AssemblyBuilderAccess;
       enter (arg1[], arg2[])
       do 'DefineDynamicAssembly' -> procname;
       exit result[]
       #);
     remove_UnhandledException: proc
       (# 
          arg1: ^_UnhandledExceptionEventHandler;
       enter (arg1[])
       #);
     add_UnhandledException: proc
       (# 
          arg1: ^_UnhandledExceptionEventHandler;
       enter (arg1[])
       #);
     remove_AssemblyResolve: proc
       (# 
          arg1: ^_ResolveEventHandler;
       enter (arg1[])
       #);
     add_AssemblyResolve: proc
       (# 
          arg1: ^_ResolveEventHandler;
       enter (arg1[])
       #);
     remove_ResourceResolve: proc
       (# 
          arg1: ^_ResolveEventHandler;
       enter (arg1[])
       #);
     add_ResourceResolve: proc
       (# 
          arg1: ^_ResolveEventHandler;
       enter (arg1[])
       #);
     remove_TypeResolve: proc
       (# 
          arg1: ^_ResolveEventHandler;
       enter (arg1[])
       #);
     add_TypeResolve: proc
       (# 
          arg1: ^_ResolveEventHandler;
       enter (arg1[])
       #);
     remove_ProcessExit: proc
       (# 
          arg1: ^_EventHandler;
       enter (arg1[])
       #);
     add_ProcessExit: proc
       (# 
          arg1: ^_EventHandler;
       enter (arg1[])
       #);
     remove_AssemblyLoad: proc
       (# 
          arg1: ^_AssemblyLoadEventHandler;
       enter (arg1[])
       #);
     add_AssemblyLoad: proc
       (# 
          arg1: ^_AssemblyLoadEventHandler;
       enter (arg1[])
       #);
     remove_DomainUnload: proc
       (# 
          arg1: ^_EventHandler;
       enter (arg1[])
       #);
     add_DomainUnload: proc
       (# 
          arg1: ^_EventHandler;
       enter (arg1[])
       #);
     get_Evidence: proc
       (# result: ^_Evidence;
       exit result[]
       #);
     GetType: proc
       (# result: ^_Type;
       exit result[]
       #);
     InitializeLifetimeService: proc
       (# result: ^Object;
       exit result[]
       #);
     ToString: proc
       (# result: ^_String;
       exit result[]
       #);
     CreateComInstanceFrom_String_String: proc (* CreateComInstanceFrom *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'CreateComInstanceFrom' -> procname;
       exit result[]
       #);
     CreateComInstanceFrom_String_String_ArrayOfInt8u_AssemblyHashAlgorithm: proc (* CreateComInstanceFrom *)
       (# result: ^_ObjectHandle;
          arg1: ^_String;
          arg2: ^_String;
          arg3: [0]@int8u;
          arg4: ^_AssemblyHashAlgorithm;
       enter (arg1[], arg2[], arg3[], arg4[])
       do 'CreateComInstanceFrom' -> procname;
       exit result[]
       #);
     ExecuteAssembly_String_Evidence_ArrayOf_String_ArrayOfInt8u_AssemblyHashAlgorithm: proc (* ExecuteAssembly *)
       (# result: @int32;
          arg1: ^_String;
          arg2: ^_Evidence;
          arg3: [0]^_String;
          arg4: [0]@int8u;
          arg5: ^_AssemblyHashAlgorithm;
       enter (arg1[], arg2[], arg3[], arg4[], arg5[])
       do 'ExecuteAssembly' -> procname;
       exit result
       #);
     get_CurrentDomain: static_proc
       (# result: ^AppDomain;
       exit result[]
       #);
     IsFinalizingForUnload: proc
       (# result: @boolean;
       exit result
       #);
     GetCurrentThreadId: static_proc
       (# result: @int32;
       exit result
       #);
     Unload: static_proc
       (# 
          arg1: ^AppDomain;
       enter (arg1[])
       #);
     CreateDomain_String_Evidence: static_proc (* CreateDomain *)
       (# result: ^AppDomain;
          arg1: ^_String;
          arg2: ^_Evidence;
       enter (arg1[], arg2[])
       do 'CreateDomain' -> procname;
       exit result[]
       #);
     CreateDomain_String_Evidence_String_String_boolean: static_proc (* CreateDomain *)
       (# result: ^AppDomain;
          arg1: ^_String;
          arg2: ^_Evidence;
          arg3: ^_String;
          arg4: ^_String;
          arg5: @boolean;
       enter (arg1[], arg2[], arg3[], arg4[], arg5)
       do 'CreateDomain' -> procname;
       exit result[]
       #);
     CreateDomain_String: static_proc (* CreateDomain *)
       (# result: ^AppDomain;
          arg1: ^_String;
       enter (arg1[])
       do 'CreateDomain' -> procname;
       exit result[]
       #);
     CreateDomain_String_Evidence_AppDomainSetup: static_proc (* CreateDomain *)
       (# result: ^AppDomain;
          arg1: ^_String;
          arg2: ^_Evidence;
          arg3: ^_AppDomainSetup;
       enter (arg1[], arg2[], arg3[])
       do 'CreateDomain' -> procname;
       exit result[]
       #);
     SetShadowCopyFiles: proc
       (# 
       #);
     SetDynamicBase: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     get_SetupInformation: proc
       (# result: ^_AppDomainSetup;
       exit result[]
       #);
     CreateInstanceAndUnwrap_String_String: proc (* CreateInstanceAndUnwrap *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'CreateInstanceAndUnwrap' -> procname;
       exit result[]
       #);
     CreateInstanceAndUnwrap_String_String_ArrayOfObject: proc (* CreateInstanceAndUnwrap *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_String;
          arg3: [0]^Object;
       enter (arg1[], arg2[], arg3[])
       do 'CreateInstanceAndUnwrap' -> procname;
       exit result[]
       #);
     CreateInstanceAndUnwrap_String_String_boolean_BindingFlags_Binder_ArrayOfObject_CultureInfo_ArrayOfObject_Evidence: proc (* CreateInstanceAndUnwrap *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_String;
          arg3: @boolean;
          arg4: ^_BindingFlags;
          arg5: ^_Binder;
          arg6: [0]^Object;
          arg7: ^_CultureInfo;
          arg8: [0]^Object;
          arg9: ^_Evidence;
       enter (arg1[], arg2[], arg3, arg4[], arg5[], arg6[], arg7[], arg8[], arg9[])
       do 'CreateInstanceAndUnwrap' -> procname;
       exit result[]
       #);
     CreateInstanceFromAndUnwrap_String_String: proc (* CreateInstanceFromAndUnwrap *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_String;
       enter (arg1[], arg2[])
       do 'CreateInstanceFromAndUnwrap' -> procname;
       exit result[]
       #);
     CreateInstanceFromAndUnwrap_String_String_ArrayOfObject: proc (* CreateInstanceFromAndUnwrap *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_String;
          arg3: [0]^Object;
       enter (arg1[], arg2[], arg3[])
       do 'CreateInstanceFromAndUnwrap' -> procname;
       exit result[]
       #);
     CreateInstanceFromAndUnwrap_String_String_boolean_BindingFlags_Binder_ArrayOfObject_CultureInfo_ArrayOfObject_Evidence: proc (* CreateInstanceFromAndUnwrap *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_String;
          arg3: @boolean;
          arg4: ^_BindingFlags;
          arg5: ^_Binder;
          arg6: [0]^Object;
          arg7: ^_CultureInfo;
          arg8: [0]^Object;
          arg9: ^_Evidence;
       enter (arg1[], arg2[], arg3, arg4[], arg5[], arg6[], arg7[], arg8[], arg9[])
       do 'CreateInstanceFromAndUnwrap' -> procname;
       exit result[]
       #);
  do '[mscorlib]System.AppDomain' -> className;
  INNER;
  #);

