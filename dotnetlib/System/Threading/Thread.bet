ORIGIN '_Thread';
ON 19 (* Disable warnings about runtime qualification tests *);
INCLUDE '~beta/dotnetlib/System/Threading/_ThreadStart';
INCLUDE '~beta/dotnetlib/System/Threading/_ThreadPriority';
INCLUDE '~beta/dotnetlib/System/_TimeSpan';
INCLUDE '~beta/dotnetlib/System/Threading/_ThreadState';
INCLUDE '~beta/dotnetlib/System/Threading/_ApartmentState';
INCLUDE '~beta/dotnetlib/System/_LocalDataStoreSlot';
INCLUDE '~beta/dotnetlib/System/_String';
INCLUDE '~beta/dotnetlib/System/Globalization/_CultureInfo';
INCLUDE '~beta/dotnetlib/System/Runtime/Remoting/Contexts/_Context';
INCLUDE '~beta/dotnetlib/System/Security/Principal/_IPrincipal';
INCLUDE '~beta/dotnetlib/System/_AppDomain';
INCLUDE '~beta/dotnetlib/System/_IntPtr';
--LIB: attributes--

(* .NET Thread class. *)
Thread: _Thread
  (#
     (* Public/family CLS compliant constructors *)

     _init: cons
       (# result: ^Thread;
          arg1: ^_ThreadStart;
       enter (arg1[])
       exit result[]
       #);

     (* Public/family CLS compliant methods *)

     Start: proc
       (# 
       #);
     Abort_Object: proc (* Abort *)
       (# 
          arg1: ^Object;
       enter (arg1[])
       do 'Abort' -> procname;
       #);
     Abort: proc (* Abort *)
       (# 
       do 'Abort' -> procname;
       #);
     ResetAbort: static_proc
       (# 
       #);
     DotnetSuspend: proc
       (# 
       do 'Suspend' -> procname;
       #);
     Resume: proc
       (# 
       #);
     Interrupt: proc
       (# 
       #);
     get_Priority: proc
       (# result: ^_ThreadPriority;
       exit result[]
       #);
     set_Priority: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     get_IsAlive: proc
       (# result: @boolean;
       exit result
       #);
     get_IsThreadPoolThread: proc
       (# result: @boolean;
       exit result
       #);
     Join: proc (* Join *)
       (# 
       do 'Join' -> procname;
       #);
     Join_int32: proc (* Join *)
       (# result: @boolean;
          arg1: @int32;
       enter (arg1)
       do 'Join' -> procname;
       exit result
       #);
     Join_TimeSpan: proc (* Join *)
       (# result: @boolean;
          arg1: ^_TimeSpan;
       enter (arg1[])
       do 'Join' -> procname;
       exit result
       #);
     Sleep_int32: static_proc (* Sleep *)
       (# 
          arg1: @int32;
       enter (arg1)
       do 'Sleep' -> procname;
       #);
     Sleep_TimeSpan: static_proc (* Sleep *)
       (# 
          arg1: ^_TimeSpan;
       enter (arg1[])
       do 'Sleep' -> procname;
       #);
     SpinWait: static_proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     get_CurrentThread: static_proc
       (# result: ^Thread;
       exit result[]
       #);
     get_IsBackground: proc
       (# result: @boolean;
       exit result
       #);
     set_IsBackground: proc
       (# 
          arg1: @boolean;
       enter (arg1)
       #);
     get_ThreadState: proc
       (# result: ^_ThreadState;
       exit result[]
       #);
     get_ApartmentState: proc
       (# result: ^_ApartmentState;
       exit result[]
       #);
     set_ApartmentState: proc
       (# 
          arg1: @int32;
       enter (arg1)
       #);
     AllocateDataSlot: static_proc
       (# result: ^_LocalDataStoreSlot;
       exit result[]
       #);
     AllocateNamedDataSlot: static_proc
       (# result: ^_LocalDataStoreSlot;
          arg1: ^_String;
       enter (arg1[])
       exit result[]
       #);
     GetNamedDataSlot: static_proc
       (# result: ^_LocalDataStoreSlot;
          arg1: ^_String;
       enter (arg1[])
       exit result[]
       #);
     FreeNamedDataSlot: static_proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     GetData: static_proc
       (# result: ^Object;
          arg1: ^_LocalDataStoreSlot;
       enter (arg1[])
       exit result[]
       #);
     SetData: static_proc
       (# 
          arg1: ^_LocalDataStoreSlot;
          arg2: ^Object;
       enter (arg1[], arg2[])
       #);
     get_CurrentUICulture: proc
       (# result: ^_CultureInfo;
       exit result[]
       #);
     set_CurrentUICulture: proc
       (# 
          arg1: ^_CultureInfo;
       enter (arg1[])
       #);
     get_CurrentCulture: proc
       (# result: ^_CultureInfo;
       exit result[]
       #);
     set_CurrentCulture: proc
       (# 
          arg1: ^_CultureInfo;
       enter (arg1[])
       #);
     get_CurrentContext: static_proc
       (# result: ^_Context;
       exit result[]
       #);
     get_CurrentPrincipal: static_proc
       (# result: ^_IPrincipal;
       exit result[]
       #);
     set_CurrentPrincipal: static_proc
       (# 
          arg1: ^_IPrincipal;
       enter (arg1[])
       #);
     GetDomain: static_proc
       (# result: ^_AppDomain;
       exit result[]
       #);
     GetDomainID: static_proc
       (# result: @int32;
       exit result
       #);
     get_Name: proc
       (# result: ^_String;
       exit result[]
       #);
     set_Name: proc
       (# 
          arg1: ^_String;
       enter (arg1[])
       #);
     VolatileRead_int8u: static_proc (* VolatileRead *)
       (# result: @int8u;
          arg1: @int8u;
       enter (arg1)
       do 'VolatileRead' -> procname;
       exit result
       #);
     VolatileRead_int16: static_proc (* VolatileRead *)
       (# result: @int16;
          arg1: @int16;
       enter (arg1)
       do 'VolatileRead' -> procname;
       exit result
       #);
     VolatileRead_int32: static_proc (* VolatileRead *)
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       do 'VolatileRead' -> procname;
       exit result
       #);
     VolatileRead_int64: static_proc (* VolatileRead *)
       (# result: @int64;
          arg1: @int64;
       enter (arg1)
       do 'VolatileRead' -> procname;
       exit result
       #);
     VolatileRead_IntPtr: static_proc (* VolatileRead *)
       (# result: ^_IntPtr;
          arg1: ^_IntPtr;
       enter (arg1[])
       do 'VolatileRead' -> procname;
       exit result[]
       #);
     VolatileRead_real32: static_proc (* VolatileRead *)
       (# result: @real32;
          arg1: @real32;
       enter (arg1)
       do 'VolatileRead' -> procname;
       exit result
       #);
     VolatileRead_real: static_proc (* VolatileRead *)
       (# result: @real;
          arg1: @real;
       enter (arg1)
       do 'VolatileRead' -> procname;
       exit result
       #);
     VolatileRead_Object: static_proc (* VolatileRead *)
       (# result: ^Object;
          arg1: ^Object;
       enter (arg1[])
       do 'VolatileRead' -> procname;
       exit result[]
       #);
     VolatileWrite_int8u_int8u: static_proc (* VolatileWrite *)
       (# 
          arg1: @int8u;
          arg2: @int8u;
       enter (arg1, arg2)
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_int16_int16: static_proc (* VolatileWrite *)
       (# 
          arg1: @int16;
          arg2: @int16;
       enter (arg1, arg2)
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_int32_int32: static_proc (* VolatileWrite *)
       (# 
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_int64_int64: static_proc (* VolatileWrite *)
       (# 
          arg1: @int64;
          arg2: @int64;
       enter (arg1, arg2)
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_IntPtr_IntPtr: static_proc (* VolatileWrite *)
       (# 
          arg1: ^_IntPtr;
          arg2: ^_IntPtr;
       enter (arg1[], arg2[])
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_real32_real32: static_proc (* VolatileWrite *)
       (# 
          arg1: @real32;
          arg2: @real32;
       enter (arg1, arg2)
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_real_real: static_proc (* VolatileWrite *)
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       do 'VolatileWrite' -> procname;
       #);
     VolatileWrite_Object_Object: static_proc (* VolatileWrite *)
       (# 
          arg1: ^Object;
          arg2: ^Object;
       enter (arg1[], arg2[])
       do 'VolatileWrite' -> procname;
       #);
     MemoryBarrier: static_proc
       (# 
       #);
  do '[mscorlib]System.Threading.Thread' -> className;
  INNER;
  #);

(* Utility function to ease casting to fully specified class. *)
asThread:
  (# _T: ^_Thread;
     T: ^Thread;
  enter _T[]
  do _T[]->T[];
  exit T[]
  #);
