ORIGIN '~beta/basiclib/v1.4/betaenv';
INCLUDE '~beta/mps/v4.9.1/astlevel'
        '~beta/betaast/v4.9.1/betacfl'
        '~beta/mps/v4.9.1/private/astparser'
        '~beta/guienv/v1.3/guienv'
        'codeviewer'
        'fragmentscanner';
-- program: Descriptor --
(#
   UI: ^guienv;
   myUI: guienv
     (#
        editorList: @list
          (#
             element:: 
               (# ff: ^mps.fragmentForm; fullName,formName: ^text; ed: ^sif
               #);
             findEditor:
               (# ff: ^mps.fragmentForm; theEditor: ^sif
               enter ff[]
               do
                  search: editorList.scan
                    (# 
                    do
                       (if
                       ((ff.father).name->mps.expandToFullPath
                          ->current.fullName.equalNCS) and
                       (ff.name->current.formName.equalNCS) then
                           current.ed[]->theEditor[]; leave search; 
                       if)
                    #)
               exit theEditor[]
               #)
          #);
        theSif: ^sif;
        sif: window
          (#
             editor: @sifTextEditor
               (#
                  initialContractionLevel::<  (#  do 1->value #);
                  codeViewerType::< 
                    (#
                       selectNode::< 
                         (# e: ^editorList.element; ed: ^sif
                         do
                            (if node[] <> none then
                                node.frag[]->editorList.findEditor->ed[];
                                (if ed[] <> none then
                                    (node[],1,0,0)->ed.editor.sifViewer.setFocus
                                 else
                                    &sif[]->theSif[];
                                    &editorList.element[]->e[];
                                    node.frag[]->e.ff[];
                                    (node.frag.father).name
                                      ->mps.expandToFullPath->e.fullName[];
                                    node.frag.name->e.formName[];
                                    &fragmentGroupScanner[]->fgs[];
                                    (mps[],node.frag.father)->fgs;
                                    '-----------------------------------------'
                                      ->putLine;
                                    (node.frag.father).name->putText;
                                    ': '->putLine;
                                    ;
                                    fgs.scanPropsAndFragsForText
                                      (#
                                         myAddText::< 
                                           (#  do t[]->putLine #)
                                      #);
                                    '-----------------------------------------'
                                      ->putLine;
                                    theSif[]->e.ed[];
                                    e[]->editorList.append;
                                    node[]->theSif.open
                                if)
                            if)
                         #)
                    #)
               #);
             open:: 
               (# ff: ^mps.fragmentForm; node: ^mps.ast; help: ^text; 
               enter node[]
               do
                  (if node[] <> none then
                      ((node.frag.father).name).copy->help[];
                      help.length->help.pos;
                      '-'->help.put;
                      node.frag.name->help.putText;
                      help[]->title;
                      help[]->putLine;
                      editor.open;
                      (mps[],betaGrammar[],node.frag[],node[])
                        ->editor.newfragment;
                      editor.size->size;
                      true->editor.bindBottom->editor.bindRight
                  if);
                  
               #);
             
          #);
        fg: ^mps.fragmentGroup;
        ff: ^mps.fragmentForm;
        e: ^editorList.element;
        fgs: ^fragmentGroupScanner;
        
     do
        (if noOfarguments > 1 then
            (for i: noOfArguments-1 repeat
              (i+1->Arguments,screen[])->mps.top.open->fg[];
              (if fg[] <> none then
                  l: fg.fragmentList.scan
                    (# 
                    do
                       (if current.type = mps.formType then
                           current.f[]->ff[];
                           &editorList.element[]->e[];
                           ff[]->e.ff[];
                           &fragmentGroupScanner[]->fgs[];
                           (mps[],ff.father)->fgs;
                           '-----------------------------------------'->putLine;
                           fg.name->putText;
                           ': '->putLine;
                           fgs.scanPropsAndFragsForText
                             (# myAddText::<  (#  do t[]->putLine #)
                             #);
                           '-----------------------------------------'->putLine;
                           (ff.father).name->mps.expandToFullPath->e.fullName[];
                           ff.name->e.formName[];
                           &sif[]->theSif[];
                           theSif[]->e.ed[];
                           e[]->editorList.append;
                           ff.root[]->theSif.open;
                           leave l
                       if)
                    #);
                  
              if)
            for)
         else
            'Usage: cv <betafile>'->putLine
        if)
     #);
   mps: @astInterface;
   betaGrammar: ^mps.treelevel;
   betaGrammarInit:
     (#
        theMetaGrammar: ^mps.treelevel;
        grammarWithPath,help: ^text;
        gg: ^mps.fragmentGroup;
        bobsfile: @file
     do
        &mps.metaGrammar[]->theMetaGrammar[]->mps.grammarTable.meta[];
        theMetaGrammar.init;
        '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('metagrammar',screen[])->gg.open->theMetaGrammar.grammarAst[];
            (if theMetaGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->theMetaGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        &mps.beta[]->betaGrammar[];
        betaGrammar.init;
        '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('beta',screen[])->gg.open->betaGrammar.grammarAst[];
            (if betaGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->betaGrammar.parser.initialize;
                    ('objectdescriptor','descriptor')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    ('attributedecl','attributes')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if);
                
            if);
            
        if);
        
     #);
   
do &myUI[]->UI[]; mps; betaGrammarInit; UI
#)  

