ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds'
        'codeTextField';
BODY '~beta/editor/private/betaTextFieldbody';
-- windowLib: Attributes --
betaTextField: codeTextField
  (#
     <<SLOT betaTextFieldLib: attributes>>;
     comment,starNeeded,commentJustEnded: @boolean;
     controlQPressed: @boolean;
     rigid,commentPos: @integer;
     init::  (#  <<SLOT Init:DoPart>> #);
     Handle_comment:
       (*  Handles comments, by setting values to 
        *  rigid, comment, starNeeded, commentJustEnded...
        *)
       (# t,previous: ^text
       enter t[]
       <<SLOT Handle_comment:DoPart>>
       exit previous[]
       #);
     indent_line:: 
       (#  <<SLOT betaTextField_indent_line:DoPart>> #);
     indent_current:
       (#
          current: ^text;
          done: @boolean;
          indent_value: @integer
       enter current[]
       <<SLOT indent_current:DoPart>>
       exit (indent_value,done)
       #);
     indent_previous:
     (* Mangler håndter:
      *
      *  trace:
      *    (# do asdf #)
      *)
       (# current: ^text; indent_value: @integer
       enter current[]
       <<SLOT indent_previous:DoPart>>
       exit indent_value
       #);
     blockHelper:
       (# t: ^text; block: @rowCol 
       enter t[]
       <<SLOT blockHelper:DoPart>>
       exit block
       #);
     patternCheck:
       (# block: @rowCol; done: @boolean
       <<SLOT patternCheck:DoPart>>
       exit (block,done)
       #);
     patternBlock: getBlockIndent
       (#
          getBlockNumber::<
            (#  do 1->blockNumber #);
          block: @rowCol
       <<SLOT patternBlock:DoPart>>
       exit block
       #);
     commentBlock: getBlockIndent
       (# getBlockNumber::<  (#  do 2->blockNumber #); 
          block: @rowCol
       <<SLOT commentBlock:DoPart>>
       exit block
       #);
     getRigid: getBlockIndent
       (#
          getBlockNumber::< 
            (#  do 2->blockNumber #);
          result: @integer
       <<SLOT getRigid:DoPart>>
       exit result
       #);
     commentBeginPos: getBlockIndent
       (#
          getBlockNumber::<  (#  do 2->blockNumber #)
       do
          block.col +1 -> block.col
       #);
     ifBlock: getBlockIndent
       (# getBlockNumber::< 
            (#  do 3->blockNumber #);
          begin: @rowCol
       <<SLOT ifBlock:DoPart>>
       exit begin
       #);
     forBlock: getBlockIndent
       (* checks if the next line should 
        * be indented two extra
        *)
       (# getBlockNumber::<  (#  do 4->blockNumber #);
          begin: @rowCol
       <<SLOT forBlock:DoPart>>
       exit begin
       #);
     check_pattern_def:
       (# t: ^text; b: @boolean
       enter t[]
       <<SLOT check_pattern_def:DoPart>>
       exit b
       #);
     remove_harmless:
       (# t: ^text
       enter t[]
       <<SLOT remove_harmless:DoPart>>
       #);
     eventhandler::< 
       (#
          onBeforeChange::< 
            (#  <<SLOT betaTextField_onBeforeChange:DoPart>> #)
       #);
     strip_comment:
       (* 
        * If the text is not a comment do nothing
        * else return the stomach of the comment
        *) 
       (# t: ^text enter t[] <<SLOT strip_comment:DoPart>> exit t[] #);
     close_construct:
       (* Returns the close-construct to the first 
        * seen unmatched open-construct when 
        * scanning backwards from the called
        * position
        *)
       (# endBlock: ^text
       <<SLOT close_construct:DoPart>>
       exit endBlock[]
       #);
     comment_out_block:
     (*  When called the selected block is commented.
      *  It handles nested comments so that when you 
      *  call remove_surrounding_block they are made
      *  into comments again.
      *) (#  <<SLOT comment_out_block:DoPart>> #);
     remove_surrounding_comment:
      (#  <<SLOT remove_surrounding_comment:DoPart>> #);
     find_rigid:
       (* Finds the rigid indentation 
        * of a given line. If the line 
        * has no sign of beeing a comment
        * then it scans backwards.
        *)
       (# t: ^text; i: @integer
       enter t[]
       <<SLOT find_rigid:DoPart>>
       exit i
       #);
     make_harmless_comment:
       (* Is called by comment_out_block, 
        * to remove comments from selected 
        * block, so that there will be no
        * nested comments.
        *)
       (# begin,end: @rowCol
       enter (begin,end)
       <<SLOT make_harmless_comment:DoPart>>
       #);
     make_real_comments:
       (* The inverse of make_harmless_comment.
        *)
       (# begin,end: @rowCol
       enter (begin,end)
       <<SLOT make_real_comments:DoPart>>
       #);
     indent_comment:
       (* indents a comment under the assumption 
        * that the line begins with a star.
        * If the beginning star is preceded by 
        * a ')' then the line is indented by the
        * first parameter.
        *)
       (# rigid,indent: @integer
       enter (rigid,indent)
       <<SLOT indent_comment:DoPart>>
       #);
     commentWhitespace:
       (# i,begin: @integer; t,tmp: ^text; 
       enter t[]
       <<SLOT commentWhitespace:DoPart>>
       #);
     next_line_in_comment:
       (* resturns true if the next line is in a comment
        * orelse false.
        *)
       (# t: ^text; result: @boolean
       enter t[]
       <<SLOT next_line_in_comment:DoPart>>
       exit result
       #);
     begins_with_star:       
       (# t: ^text; result: @boolean
       enter t[]
       <<SLOT begins_with_star:DoPart>>
       exit result
       #);
     shadow_string_constants:
       (* makes all text in a stringconstant 
        * to whitespace
        *)
       (# t: ^text
       enter t[]
       <<SLOT shadow_string_constants:DoPart>>
       exit t[]
       #);
     tmp_set_selection:
       (# t: ^text;
          beginrow,begincol,endrow,endcol,pos,endpos: @integer
       enter (beginrow,begincol,endrow,endcol)
       do
          (beginrow,begincol) -> rowColToPos -> pos;
          (endrow,endcol) -> rowColToPos -> endpos;
          (pos,endpos) -> selection
       #);
  #)  





