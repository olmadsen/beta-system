ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds'
        'codeTextField';
-- windowLib: Attributes --
betaTextField: codeTextField
  (#
     CheckDopart: regexp.reg_match (#  do 1->regNumber #);
     RemovePatternDef: regexp.reg_replace (#  do 2->regNumber #);
     CheckEndsWithSemicolon: regexp.reg_match (#  do 3->regNumber #);
     CheckBeginWithConstruct: regexp.reg_match (#  do 4->regNumber #);
     RemoveHarmless: regexp.reg_replace (#  do 5->regNumber #);
     CheckPatternNoDef: regexp.reg_match (#  do 6->regNumber #);
     CheckArrow: regexp.reg_match (#  do 7->regNumber #);
     CheckCommentBegin: regexp.reg_replace (#  do 8->regNumber #);
     CheckCommentEnd: regexp.reg_match (#  do 9->regNumber #);
     CheckWhite: regexp.reg_match (#  do 10->regNumber #);
     init:: 
       (# 
       do
          10->regexp.setNumberOfRegexps;
          4->regexp.setNumberOfBlocks;
          true->regexp.nonCaseSensitive;
          '(^do\\b|^enter\\b|^exit\\b|^else\\b|^//)'
            ->regexp.init_reg (#  do 1->regNumber #);
          '^[a-zA-Z0-9_, ]+:[:|<]?[:<]? *[@|^|\\|]?[\\|]? *[a-zA-Z0-9._<@ :>]* *'
            ->regexp.init_reg (#  do 2->regNumber #);
          '; *$'->regexp.init_reg (#  do 3->regNumber #);
          '^ *\\([#|if|for|\\*#].*'->regexp.init_reg (#  do 4->regNumber #);
          '(.*)(\\(' '#.*?#\\)|\\(' 'if\\b.*?\\bif\\)|\\(' 'for\\b.*?\\bfor\\)|\\(\\*.*?\\*\\))'
            ->regexp.init_reg
              (#
                 specialPcre::< 
                   (#
                      editorReplace:: 
                        (#
                           rep:: 
                             (# 
                             do
                                sub2->value[];
                                0->value.pos;
                                '{'->value.put;
                                value.length-1->value.pos;
                                '}'->value.put;
                                sub1->value.prepend;
                                
                             #)
                        #)
                   #)
              do 5->regNumber
              #);
          '^ *\\(' '#.*#\\)'->regexp.init_reg (#  do 6->regNumber #);
          '^ *->'->regexp.init_reg (#  do 7->regNumber #);
          '(.*)(\\(\\*)(.*)'
            ->regexp.init_reg
              (#
                 specialPcre::< 
                   (#
                      editorReplace:: 
                        (#
                           rep:: 
                             (# 
                             do
                                sub1->value[];
                                sub2->value.append;
                                value.length->commentPos;
                                sub3->value.append;
                                
                             #)
                        #)
                   #)
              do 8->regNumber
              #);
          '^ *\\*\\)'->regexp.init_reg (#  do 9->regNumber #);
          '^ *$'->regexp.init_reg (#  do 10->regNumber #);
          ('(#','#)',3)->regexp.init_block (#  do 1->blockNumber #);
          ('(*','*)',3)->regexp.init_block (#  do 2->blockNumber #);
          ('(if','if)',4)->regexp.init_block (#  do 3->blockNumber #);
          ('(for','for)',5)->regexp.init_block (#  do 4->blockNumber #)
       #);
     comment,starNeeded,commentJustEnded: @boolean;
     controlQPressed: @boolean;
     rigid,commentPos: @integer;
     Handle_comment:
     (*  Handles comments, by setting values to 
      *  rigid, comment, starNeeded, commentJustEnded...
      *)
       (#
          t,t2,dummy: ^text;
          int: @integer;
          b,beginComment,rigidFound: @boolean;
          
       do
          current_line->t[];
          t[]->eat_indent->(int,t[]);
          (if ((t.length > 0) and (t.T[1] = '*'))->comment then
              (if (not ((t.length > 1) and (t.T[2] = ')'))) then
                  ' '->t.T[1]; t[]->eat_indent->(int,t[]); false->starNeeded; 
               else
                  true->commentJustEnded
              if);
              
          if);
          (if t[]->CheckCommentBegin then
              commentPos->rigid; true->rigidFound; 
          if);
          (if not (first_line) then
              previous_line;
              current_line->eat_indent->(int,t2[]);
              (if t2.copy->next_line_in_comment then
                  (if not (comment) then true->starNeeded->comment if);
                  (if t2.copy->begins_with_star then
                      ' '->t2.T[1];
                      int->rigid;
                      true->rigidFound;
                      t2[]->eat_indent->(int,t2[]);
                      int-1->int;
                      
                  if);
                  t2[]->remove_harmless;
                  t.copy->dummy[];
                  (dummy[],2 (* comment *) )->regexp.removeBlock
                    ->(b,beginComment);
                  (if b and beginComment then
                      int+dummy.length+1->rigid;
                      true->rigidFound;
                      (rigid+2-int,t2.length)->t2.sub->t2[];
                      t2[]->eat_indent->(int,t2[]);
                      
                  if);
                  
              if);
              (if comment and not (rigidFound) then
                  current_line->find_rigid->rigid; 
              if);
              next_line;
              
          if);
          
       #);
     indent_line:: 
       (# done: @boolean; dummy: @integer; 
       do
          (if not (first_line) then
              (if (t.length > 0) and (t.T[1] = '*') then
                  ' '->t.T[1];
                  t[]->eat_indent->(dummy,t[]);
                  dummy+indent_value->indent_value;
                  0->offset;
                  (if (pos-begin) > indent_value then
                      pos-begin-indent_value->offset
                  if);
                  
              if);
              Handle_comment;
              indent_current->(indent_value,done);
              (if not (done or first_line) then
                  previous_line;
                  indent_previous+indent_value->indent_value;
                  next_line
              if);
              (if comment then
                  (if starNeeded and not (commentJustEnded) then
                      (beginning_of_line,beginning_of_line)->selection;
                      '*'->insert
                  if);
                  (rigid,indent_value)->indent_comment;
                  (if commentJustEnded then
                      rigid->indent_value
                   else
                      indent_value+rigid+1->indent_value
                  if)
               else
                  indent_value->indent_by_int; 
              if);
              false->comment->starNeeded->commentJustEnded
          if)
       #);
     indent_current:
       (#
          done,b,beginComment: @boolean;
          dummy,indent_value: @integer;
          t,special,tmp: ^text
       enter t[]
       do
          current_line->t[];
          t[]->remove_harmless;
          (if t[]->CheckCommentBegin then
          (* sets the indentation in the comment to two *)
              current_line->special[];
              special[]->remove_harmless;
              special[]->CheckCommentBegin;
              special[]->commentWhitespace;
              
          if);
          current_line->strip_comment->eat_indent->(dummy,t[]);
          (if t[]->CheckDopart then indent_value-3->indent_value if);
          (if t[]->CheckArrow then indent_value+2->indent_value if);
          l:
          (if t[]->regexp.lastBlockEnd
           // 1 then
              t[]->patternBlock->(indent_value,dummy); true->done; 
           // 2 then
              t[]->commentBlock->(indent_value,dummy);
              (if not (''->t.equal) then
                  0->indent_value; restart l; 
               else
                  true->done; 
              if)
           // 3 then
              t[]->ifBlock->(indent_value,dummy); true->done
           // 4 then
              t[]->forBlock->(indent_value,dummy); true->done; 
          if)
       exit (indent_value,done)
       #);
     indent_previous:
     (* Mangler håndter:
      *
      *  trace:
      *    (# do asdf #)
      *)
       (#
          first,second,prev,indent_value: @integer;
          b,match,beginComment: @boolean;
          t,dummy,copy: ^text
       do
          current_line->strip_comment->eat_indent->(indent_value,t[]);
          (if (not (first_line)) and (t[]->CheckPatternNoDef) then
              previous_line;
              (if current_line->strip_comment->check_pattern_def then
                  indent_value-2->indent_value
              if);
              next_line
          if);
          (if t[]->CheckArrow then indent_value-2->indent_value if);
          (if t[]->check_pattern_def->match then
              indent_value+2->indent_value; 
          if);
          t[]->remove_harmless;
          t.copy->copy[];
          (t[]->regexp.LastBlockBegin)->(match,first,dummy[]);
          (if match and ('#' ')'->dummy.equal) then
          (* Handle situations like:
           * (#    john::
           *         (# do #)
           * #)
           *)
              (t.length+3,copy.length)->copy.sub->copy[];
              (if copy[]->check_pattern_def then
                  indent_value+1->indent_value;
                  copy[]->strip_comment->eat_indent->(prev,copy[]);
                  prev+indent_value->indent_value
              if)
          if);
          first+indent_value->indent_value;
          (if not (match) and (t[]->CheckDopart) then
              indent_value+3->indent_value
          if);
          (if t[]->regexp.lastBlockEnd
           // 1 then
              t[]->patternBlock->(first,second); second->indent_value; 
           // 2 then
              t[]->commentBlock->(first,second); second->indent_value; 
           // 3 then
              t[]->ifBlock->(first,second); second->indent_value; 
           // 4 then
              t[]->forBlock->(first,second); second->indent_value; 
          if);
          
       exit indent_value
       #);
     blockHelper:
       (#
          b,beginComment,done: @boolean;
          blockStart,mem,tmp: @integer;
          dummy,t: ^text;
          
       enter t[]
       do
          (if not (first_line) then patternCheck->(blockStart,done) if);
          t[]->strip_comment->t[];
          t.copy->regexp.lastBlockBegin->(b,tmp,dummy[]);
          (if b then
              false->done;
              t[]->eat_indent->(mem,t[]);
              (dummy.length+1,t.length)->t.sub->t[];
              t[]->eat_indent->(tmp,t[]);
              dummy.length+tmp+mem->mem
          if);
          (if not (done) then
              mem->blockStart;
              (if (not (first_line)) and
              (current_line->strip_comment->CheckBeginWithConstruct) then
                  previous_line;
                  (if not (current_line->strip_comment->check_pattern_def) then
                      next_line
                  if)
              if);
              (if not (b) then
                  current_line->strip_comment->eat_indent->(blockStart,t[])
              if);
              (if t[]->CheckDopart then blockStart+3->blockStart if)
          if)
       exit blockStart
       #);
     patternCheck:
       (# blockStart: @integer; done,b: @boolean; t,copy,dummy: ^text; 
       do
          previous_line;
          current_line->strip_comment->t[];
          t.copy->copy[];
          t[]->regexp.lastBlockBegin->(b,blockStart,dummy[]);
          (if b and ('#' ')'->dummy.equal) then
              (t.length+3,copy.length)->copy.sub->copy[];
              (if copy[]->check_pattern_def then
                  copy[]->eat_indent->(blockStart,copy[]);
                  t.length+2+blockStart->blockStart;
                  true->done
              if)
          if);
          next_line;
          
       exit (blockStart,done)
       #);
     patternBlock: getBlockIndent
       (#
          getBlockNumber::<  (#  do 1->blockNumber #);
          blockStart: @integer;
          
       do
          t[]->blockHelper->blockStart;
          (if comment then blockIndent-rigid-1->blockIndent if)
       exit blockStart
       #);
     commentBlock: getBlockIndent
       (#
          getBlockNumber::<  (#  do 2->blockNumber #);
          blockStart: @integer;
          done: @boolean;
          dummy: ^text;
          
       do
          (if not (first_line) then patternCheck->(blockStart,done);  if);
          (if not (done) then
              t[]->strip_comment->regexp.lastBlockBegin->(b,blockStart,dummy[]);
              (if (not (first_line)) and
              (current_line->strip_comment->CheckBeginWithConstruct) then
                  previous_line;
                  (if not (current_line->strip_comment->check_pattern_def) then
                      next_line
                  if);
                  
              if);
              (if not (b) then
                  current_line->eat_indent->(blockStart,t[])
              if);
              
          if);
          
       exit blockStart
       #);
     getRigid: getBlockIndent
       (# getBlockNumber::<  (#  do 2->blockNumber #); result: @integer
       do t.length+2->result (* konstanten er muligvis forkert *)
       exit result
       #);
     commentBeginPos: getBlockIndent
       (#
          pos,row,col: @integer;
          getBlockNumber::<  (#  do 2->blockNumber #);
          
       do
          selection->(pos,pos);
          pos->posToRowCol->(row,col);
          (row,blockIndent+1)->rowColToPos->pos;
          
       exit pos
       #);
     ifBlock: getBlockIndent
       (#
          getBlockNumber::<  (#  do 3->blockNumber #);
          blockStart: @integer;
          
       do
          t[]->blockHelper->blockStart;
          (if comment then blockIndent-rigid-1->blockIndent if)
       exit blockStart
       #);
     forBlock: getBlockIndent
     (* checks if the next line should 
      * be indented two extra
      *)
       (#
          getBlockNumber::<  (#  do 4->blockNumber #);
          blockStart: @integer;
          
       do
          t[]->blockHelper->blockStart;
          (if comment then blockIndent-rigid-1->blockIndent if);
          
       exit blockStart
       #);
     check_pattern_def:
       (# t,dummy: ^text; b,open: @boolean; block: @integer; 
       enter t[]
       do
          t.copy->dummy[];
          false->b;
          (if dummy[]->RemovePatternDef then
              (if not (dummy[]->CheckEndsWithSemicolon) then
                  dummy[]->regexp.lastBlockBegin->(open,block,dummy[]);
                  not (open)->b
              if)
          if)
       exit b
       #);
     remove_harmless:
       (# t: ^text; 
       enter t[]
       do
          t[]->shadow_string_constants->t[];
          loop: cycle
            (#  do (if not (t[]->RemoveHarmless) then leave loop if) #);
          
       #);
     eventhandler::<
     (* removes all but one whitespace from 
      * the current cursor position.
      *) 
       (#
          altModified: @boolean;
          onKeyDown::<  (#  do altKey->altModified #);
          onBeforeChange::< 
            (# tmp,t: ^text; ch: @char; 
            do
               (if texteditmode then
                   theText->t[];
                   (if (t[] <> none ) and (t.length > 0) then
                       t.T[1]->ch;
                       (if ch
                        // '{' then
                           (if not (controlQPressed) then
                               regexp.blockreg[1].begin.copy->tmp[];
                               ' '->tmp.append;
                               tmp[]->insert;
                               false->allow;
                               
                           if);
                           false->controlQPressed
                        // '}' then
                           (if not (controlQPressed) then
                               close_construct->insert;
                               frozen_indent_line;
                               false->controlQPressed->allow;
                               
                           if);
                           false->controlQPressed
                        // ascii.sp then
                           (if altmodified then removeBlanks->allow;  if)
                       if)
                    else
                       false->controlQPressed; INNER ; 
                   if)
                else
                   INNER
               if)
            #)
       #);
     removeBlanks:
     (* 
      * If the text is not a comment do nothing
      * else return the stomach of the comment
      *)
       (# pos,endpos,i: @integer; t: ^text; ch: @char; allow: @boolean; 
       do
          selection->(pos,endpos);
          pos->i;
          loop: cycle
            (# 
            do
               (i,i+1)->myScan->ch;
               (if not (ch = ascii.sp) or (ch = ascii.nl) then
                   leave loop
               if);
               i+1->i;
               
            #);
          i->endpos;
          pos->i;
          loop: cycle
            (# 
            do
               (i-1,i)->myScan->ch;
               (if not (ch = ascii.sp) or (ch = ascii.nl) then
                   leave loop
               if);
               i-1->i;
               
            #);
          i->pos;
          (if (pos <> endpos) then
              (pos+1,endpos)->selection;
              delete;
              (pos+1,pos+1)->selection;
              false->allow;
              
           else
              true->allow; 
          if);
          
       exit allow
       #);
     strip_comment:
     (* Closes the first seen unmatched
      * open-construct when scanning backwards
      *)
       (# t,t2: ^text; indent: @integer; 
       enter t[]
       do
          t[]->remove_harmless;
          (if t[]->CheckCommentBegin then
              (commentPos+1,t.length)->t.sub->t[]; 
           else
              t.copy->eat_indent->(indent,t2[]);
              (if (t2.length > 0) and (t2.T[1] = '*') and not
              ((t2.length > 1) and (t2.T[2] = ')')) then
                  (2,t2.length)->t2.sub->t[]; 
              if);
              
          if);
          
       exit t[]
       #);
     close_construct:
     (* begin,end is the selection.
      * It is assumed that we are not within 
      * a comment.
      *)
       (#
          t,endBlock: ^text;
          b: @boolean;
          i,end,dummy,mem1,mem2: @integer;
          pat,com,if_,for_: @integer;
          ch: @char;
          
       do
          selection->(end,dummy)->(mem1,mem2);
          beginning_of_line->i;
          &text[]->t[];
          loop: cycle
            (# 
            do
               (i,i+1)->myScan->ch;
               (if (i >= end) or (ch = ascii.nl) then leave loop if);
               ch->t.put;
               i+1->i;
               
            #);
          t[]->remove_harmless;
          t[]->regexp.lastBlockBegin->(b,dummy,endBlock[]);
          (if not (b) then
              toploop: cycle
                (# 
                do
                   loop: cycle
                     (# 
                     do
                        (if t[]->regexp.lastBlockEnd
                         // 1 then
                            pat+1->pat; 
                         // 2 then
                            com+1->com; 
                         // 3 then
                            if_+1->if_; 
                         // 4 then
                            for_+1->for_; 
                         else
                            leave loop; 
                        if);
                        
                     #);
                   (if not (first_line) then
                       previous_line; 
                    else
                       ''->endBlock[]; leave toploop; 
                   if);
                   current_line->t[];
                   t[]->remove_harmless;
                   loop: cycle
                     (# 
                     do
                        t[]->regexp.lastBlockBegin->(b,i,endBlock[]);
                        (if b then
                            (if endblock[]->regexp.blockreg[1].end.equalNCS then
                                (if pat = 0 then
                                    leave toploop
                                 else
                                    pat-1->pat
                                if);
                                
                            if);
                            (if endblock[]->regexp.blockreg[2].end.equalNCS then
                                (if com = 0 then
                                    leave toploop
                                 else
                                    com-1->com
                                if);
                                
                            if);
                            (if endblock[]->regexp.blockreg[3].end.equalNCS then
                                (if if_ = 0 then
                                    leave toploop
                                 else
                                    if_-1->if_
                                if);
                                
                            if);
                            (if endblock[]->regexp.blockreg[4].end.equalNCS then
                                (if for_ = 0 then
                                    leave toploop
                                 else
                                    for_-1->for_
                                if);
                                
                            if);
                            
                         else
                            leave loop; 
                        if);
                        
                     #);
                   
                #);
              
          if);
          (mem1,mem2)->selection;
          
       exit endBlock[]
       #);
     comment_out_block:
     (*  When called the selected block is commented.
      *  It handles nested comments so that when you 
      *  call remove_surrounding_block they are made
      *  into comments again.
      *)
       (#
          begin,end,i: @integer; pos,endpos,addedLength: @integer; t: ^text; 
       do
          selection->(begin,end);
          (if (begin <> end) and (begin < end) then
              (begin,end)->make_harmless_comment;
              (begin,end)->depth_of_selection->i;
              (* check if it's ok to make a new line? *)
              (end,end)->selection;
              (if (i <> 1) and
              ((end,end_of_line)->get_selection->t[]->CheckWhite) then
                  (end_of_line,end_of_line)->selection;
                  '\n'->insert;
                  t.length+1+end->end
              if);
              (begin,begin)->selection;
              (if (i = 1) then
                  regexp.blockreg[2].begin.copy->t[];
                  ' '->t.append;
                  t[]->insert;
                  (end+3,end+3)->selection;
                  ' '->t[];
                  regexp.blockreg[2].end.copy->t.append;
                  t[]->insert;
                  
               else
                  regexp.blockreg[2].begin.copy->t[];
                  ' '->t.append;
                  t[]->insert;
                  3->addedLength;
                  (for i-2 repeat
                    beginning_of_line;
                    next_line;
                    '*'->insert;
                    addedLength+1->addedLength;
                    
                  for);
                  (end+addedLength,end+addedLength)->selection;
                  ' '->t[];
                  regexp.blockreg[2].end.copy->t.append;
                  t[]->insert;
                  
              if);
              (begin,end+addedLength)->indentHandler
          if)
       #);
     remove_surrounding_comment:
     (* Finds the rigid indentation 
      * of a given line. If the line 
      * has no sign of beeing a comment
      * then it scans backwards.
      *)
       (#
          i,begin,end,pos,max,min,row,col,deleted: @integer;
          InComment: @boolean;
          ch: @char;
          t: ^text;
          
       do
          true->InComment;
          all->(min,max);
          selection->(begin,begin);
          begin->i;
          loop: cycle
            (# 
            do
               (if i+1 >= max then false->InComment; leave loop if);
               (i,i+1)->myScan->ch;
               (if (ch = '*') and (((i+1,i+2)->myScan) = ')') then
                   leave loop
               if);
               i+1->i;
               
            #);
          (if InComment then
              i->end;
              end->posToRowCol->(row,col);
              (end,end)->selection;
              current_line->t[];
              (0,col)->t.sub->commentBeginPos->(i,begin);
              end+2->end;
              (* begin,end er commentaren *)
              (begin,end)->depth_of_selection->i;
              (begin,end)->make_real_comments;
              (if (i = 1) then
                  (end-2,end)->selection;
                  delete;
                  (end-3,end-2)->get_selection->t[];
                  (if (t.T[1] = ' ') then
                      (end-3,end-2)->selection; delete; 
                  if);
                  (begin,begin+2)->selection;
                  delete;
                  (begin,begin+1)->get_selection->t[];
                  (if (t.T[1] = ' ') then
                      (begin,begin+1)->selection; delete; 
                  if);
                  
               else
                  (begin,begin+2)->selection;
                  delete;
                  2->deleted;
                  next_line;
                  beginning_of_line;
                  (for i-1 repeat
                    current_line->t[];
                    t[]->eat_indent->(col,t[]);
                    (if (t.length > 0) and (t.T[1] = '*') then
                        selection->(pos,pos);
                        (pos+col,pos+col+1)->selection;
                        delete;
                        deleted+1->deleted;
                        (if (t.length > 1) and (t.T[2] = ')') then
                            (pos+col,pos+col+1)->selection;
                            delete;
                            deleted+1->deleted;
                            
                        if);
                        
                    if);
                    next_line;
                    beginning_of_line;
                    
                  for);
                  (end-deleted-2,end_of_line)->get_selection->t[];
                  (if (t.length > 1) and (t.T[1] = '*') and (t.T[2] = ')') then
                      (end-deleted-2,end-deleted)->selection;
                      delete;
                      deleted+2->deleted;
                      
                  if);
                  (end-deleted,end-deleted)->selection;
                  current_line->t[];
                  (if t[]->CheckWhite then
                      (beginning_of_line,end_of_line)->get_selection->t[];
                      (beginning_of_line,end_of_line+1)->selection;
                      delete;
                      deleted+t.length->deleted;
                      
                  if);
                  (begin,end-deleted)->indentHandler;
                  
              if);
              
          if);
          
       #);
     find_rigid:
     (* Is called by comment_out_block, 
      * to remove comments from selected 
      * block, so that there will be no
      * nested comments.
      *)
       (# t: ^text; i,dummy: @integer; b,firstblock: @boolean; 
       enter t[]
       do
          t[]->eat_indent->(i,t[]);
          (if not ((t.length > 1) and (t.T[1] = '*')) then
              t[]->remove_harmless;
              (t[],2 (* comment *) )->regexp.RemoveBlock->(b,firstblock);
              (if b and firstblock then
                  i+t.length+1->i; 
               else
                  t[]->getRigid->(i,dummy); 
              if);
              
          if);
          
       exit i
       #);
     make_harmless_comment:
     (* The inverse of make_harmless_comment.
      *)
       (# begin,end,i: @integer; ch: @char; first: @boolean; 
       enter (begin,end)
       do
          (begin,true)->(i,first);
          loop: cycle
            (# 
            do
               (i,i+1)->myScan->ch;
               (if i >= end-1 then leave loop if);
               (if ch
                // '(' then
                   (if ((i+1,i+2)->myScan) = '*' then
                       (i,i+1)->selection;
                       delete;
                       true->controlQPressed;
                       '{'->insert;
                       false->controlQPressed;
                       
                   if);
                   
                // ')' then
                   (if not (first) and (((i-1,i)->myScan) = '*') then
                       (i,i+1)->selection;
                       delete;
                       true->controlQPressed;
                       '}'->insert;
                       false->controlQPressed;
                       
                   if);
                   
               if);
               (if first then false->first if);
               i+1->i;
               
            #);
          
       #);
     make_real_comments:
     (* indents a comment under the assumption 
      * that the line begins with a star.
      * If the beginning star is preceded by 
      * a ')' then the line is indented by the
      * first parameter.
      *)
       (# begin,end,i: @integer; ch: @char; first: @boolean; 
       enter (begin,end)
       do
          (begin,true)->(i,first);
          loop: cycle
            (# 
            do
               (i,i+1)->myScan->ch;
               (if i >= end-1 then leave loop if);
               (if ch
                // '{' then
                   (if ((i+1,i+2)->myScan) = '*' then
                       (i,i+1)->selection;
                       delete;
                       true->controlQPressed;
                       '('->insert;
                       false->controlQPressed;
                       
                   if);
                   
                // '}' then
                   (if not (first) and (((i-1,i)->myScan) = '*') then
                       (i,i+1)->selection;
                       delete;
                       true->controlQPressed;
                       ')'->insert;
                       false->controlQPressed;
                       
                   if);
                   
               if);
               (if first then false->first if);
               i+1->i;
               
            #);
          
       #);
     indent_comment:
       (# rigid,indent,i,mem,len: @integer; white: ^text; ch: @char; 
       enter (rigid,indent)
       do
          beginning_of_line->i;
          (if not (current_line->CheckCommentEnd) then
              rigid->indent_by_int;
              i+rigid+1->i->mem;
              &text[]->white[];
              (i,i)->selection;
              0->len;
              loop: cycle
                (# 
                do
                   (i,i+1)->myScan->ch;
                   (if not (ch = ascii.sp) or
                   (ch = ascii.nl) (* or (ch=ascii.eos) *) then
                       leave loop
                   if);
                   i+1->i;
                   len+1->len;
                   
                #);
              (if (len > indent) and (indent >= 0) then
                  (mem,mem+len-indent)->selection; delete; 
              if);
              (if len < indent then
                  (mem,mem)->selection; indent-len->get_whitespace->insert; 
              if);
              
           else
              rigid->indent_by_int; 
          if);
          
       #);
     commentWhitespace:
     (* resturns true if the next line is in a comment
      * orelse false.
      *)
       (# i,begin: @integer; t,tmp: ^text; 
       enter t[]
       do
          commentPos->t.pos;
          loop: cycle
            (# 
            do
               (if not (t.pos = t.length) and (t.get = ascii.sp) then
                   i+1->i
                else
                   leave loop
               if);
               
            #);
          beginning_of_line+commentPos->begin;
          (if i < 2 then
              (begin,begin)->selection; 2-i->get_whitespace->insert; 
          if);
          (if i > 2 then (begin,begin+i-2)->selection; delete;  if);
          
       #);
     next_line_in_comment:
       (# t: ^text; result,b,firstBlock: @boolean; i: @integer; 
       enter t[]
       do
          t[]->remove_harmless;
          t[]->eat_indent->(i,t[]);
          (t.length > 0) and (t.T[1] = '*') and not
          ((t.length > 1) and (t.T[2] = ')'))->result;
          (t.copy,2)->regexp.RemoveBlock->(b,firstBlock);
          (if b then firstBlock->result if);
          
       exit result
       #);
     begins_with_star:
     (* makes all text in a stringconstant 
      * to whitespace
      *)
       (# t: ^text; result: @boolean; i: @integer; 
       enter t[]
       do t.copy->eat_indent->(i,t[]); 
       exit ((t.length > 0) and (t.T[1] = '*')) and not
       ((t.length > 1) and (t.T[2] = ')'))
       #);
     shadow_string_constants:
       (# t: ^text; lastBackslash,inText: @boolean; 
       enter t[]
       do
          false->lastBackslash->inText;
          (for i: t.length repeat
            (if t.T[i]
             // '\\' then
                true->lastBackslash; (if inText then ' '->t.T[i] if); 
             // '\'' then
                (if not (lastBackslash) then
                    not (inText)->inText; 
                 else
                    (if inText then ' '->t.T[i] if); false->lastBackslash; 
                if)
             else
                (if inText then ' '->t.T[i] if); false->lastBackslash; 
            if)
          for)
       exit t[]
       #)
  #)  

