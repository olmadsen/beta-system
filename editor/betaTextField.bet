ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds'
        '~beta/guienv/utils/codeTextField'
        '~beta/basiclib/formatio';
BODY '~beta/editor/private/betaTextFieldbody';
(**
 *   This file is currently used by MjolnerTool but
 *   it is obsolete. Instead use ~beta\guienv\utils\betaTextField, 
 *   where the indenter algorithm is separated from the textfield.
 *   
 *   15/04-03 MBE
 *)
-- windowLib: Attributes --
betaTextField: codeTextField
  (#
     <<SLOT betaTextFieldLib:Attributes>>;
     comment,starNeeded,commentJustEnded:
       @boolean;
     tuborgAllowed: @boolean;
     rigid,commentPos: @integer;
     init::  (#  <<SLOT Init:DoPart>> #);
     Handle_comment:
     (*  Handles comments, by setting values to 
      *  rigid, comment, starNeeded, commentJustEnded...
      *)
       (# t,previous: ^text
       enter t[]
       <<SLOT Handle_comment:DoPart>>
       exit previous[]
       #);
     indent_line:: 
       (# 
       <<SLOT betaTextField_indent_line:DoPart>>
       #);
     indent_current:
       (# current: ^text; done: @boolean; indent_value: @integer
       enter current[]
       <<SLOT indent_current:DoPart>>
       exit (indent_value,done)
       #);
     indent_previous:
       (# current: ^text; indent_value: @integer
       enter current[]
       <<SLOT indent_previous:DoPart>>
       exit indent_value
       #);
     check_doPart:
       (# indent_value: @integer;
          t: ^text
       enter t[]
       <<SLOT check_doPart: doPart>>
       exit indent_value
       #);
     blockHelper:
       (# t: ^text; block: @rowCol
       enter t[]
       <<SLOT blockHelper:DoPart>>
       exit block
       #);
     patternCheck:
       (#
          block:
            @rowCol;
          done: @boolean
       <<SLOT patternCheck:DoPart>>
       exit (block,done)
       #);
     patternBlock: getBlockIndent
       (#
          getBlockNumber::< 
            (#  do 1->blockNumber #);
          begin: @rowCol
       <<SLOT patternBlock:DoPart>>
       exit (begin,differentLines)
       #);
     commentBlock: getBlockIndent
       (# getBlockNumber::<  (#  do 2->blockNumber #); block: @rowCol
       <<SLOT commentBlock:DoPart>>
       exit (block,differentLines)
       #);
     getRigid: getBlockIndent
       (#
          getBlockNumber::< 
            (#  do 2->blockNumber #);
          result: @integer
       <<SLOT getRigid:DoPart>>
       exit result
       #);
     ifBlock:
      getBlockIndent
       (# getBlockNumber::<  (#  do 3->blockNumber #); begin: @rowCol
       <<SLOT ifBlock:DoPart>>
       exit (begin,differentLines)
       #);
     forBlock: getBlockIndent
     (* checks if the next line should 
      * be indented two extra
      *)
       (# getBlockNumber::<  (#  do 4->blockNumber #); begin: @rowCol
       <<SLOT forBlock:DoPart>>
       exit (begin,differentLines)
       #);
     check_pattern_def:
       (# t: ^text; b: @boolean
       enter t[]
       <<SLOT check_pattern_def:DoPart>>
       exit b
       #);
     remove_harmless:
       (# t: ^text
       enter t[]
       <<SLOT remove_harmless:DoPart>>
       #);
     eventhandler::< 
       (#
          onBeforeChange::< 
            (#  <<SLOT betaTextField_onBeforeChange:DoPart>> #)
       #);
     strip_comment:
     (* 
      * If the text is not a comment do nothing
      * else return the stomach of the comment
      *) (# t: ^text enter t[] <<SLOT strip_comment:DoPart>> exit t[] #);
     close_construct:
     (* Returns the close-construct to the first 
      * seen unmatched open-construct when 
      * scanning backwards from the called
      * position
      *)
       (# endBlock: ^text
       <<SLOT close_construct:DoPart>>
       exit endBlock[]
       #);
     comment_out_selection:
     (*  When called the selected block is commented.
      *  It handles nested comments so that when you 
      *  call remove_surrounding_block they are made
      *  into comments again.
      *) (#  <<SLOT comment_out_selection:DoPart>> #);
     remove_surrounding_comment:
       (# comBegin,comEnd: @rowCol
       enter (comBegin,comEnd)
       <<SLOT remove_surrounding_comment:DoPart>>
       #);
     surrounding_comment:
       (# beginPos,endPos: @rowCol
       <<SLOT surrounding_comment:DoPart>>
       exit (beginPos,endPos)
       #);
     inside_comment: 
       (# value: @boolean 
         <<SLOT inside_comment: doPart>>
       exit value
       #);     
     find_rigid:
     (* Finds the rigid indentation 
      * of a given line. If the line 
      * has no sign of beeing a comment
      * then it scans backwards.
      *)
       (# t: ^text; i: @integer
       enter t[]
       <<SLOT find_rigid:DoPart>>
       exit i
       #);
     make_harmless_comment:
     (* Is called by comment_out_block, 
      * to remove comments from selected 
      * block, so that there will be no
      * nested comments.
      *)
       (# begin,end: @rowCol
       enter (begin,end)
       <<SLOT make_harmless_comment:DoPart>>
       #);
     make_real_comments:
     (* The inverse of make_harmless_comment.
      *)
       (# begin,end: @rowCol
       enter (begin,end)
       <<SLOT make_real_comments:DoPart>>
       #);
     indent_comment:
     (* indents a comment under the assumption 
      * that the line begins with a star.
      * If the beginning star is preceded by 
      * a ')' then the line is indented by the
      * first parameter.
      *)
       (# rigid,indent: @integer
       enter (rigid,indent)
       <<SLOT indent_comment:DoPart>>
       #);
     commentWhitespace:
       (# i,begin: @integer; t,tmp: ^text; 
       enter t[]
       <<SLOT commentWhitespace:DoPart>>
       #);
     next_line_in_comment:
     (* resturns true if the next line is in a comment
      * orelse false.
      *)
       (# t: ^text; result: @boolean
       enter t[]
       <<SLOT next_line_in_comment:DoPart>>
       exit result
       #);
     begins_with_star:
       (# t: ^text; result: @boolean
       enter t[]
       <<SLOT begins_with_star:DoPart>>
       exit result
       #);
     shadow_string_constants:
     (* makes all text in a stringconstant 
      * to whitespace
      *)
       (# t: ^text
       enter t[]
       <<SLOT shadow_string_constants:DoPart>>
       exit t[]
       #);
     constructAllowed:
       (# value: @boolean
         <<SLOT constructAllowed: doPart>> 
       exit value
       #);     
     tmp_set_selection:
       (#
          t: ^text;
          beginrow,begincol,endrow,
            endcol,pos,endpos: @integer
       enter (beginrow,begincol,endrow,endcol)
       do
          (beginrow,begincol)->rowColToPos->pos;
          (endrow,endcol)->rowColToPos->endpos;
          (pos,endpos)->selection
       #);
     
  #)  

