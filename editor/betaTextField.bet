ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds';
INCLUDE 'codeTextField';

--windowLib: attributes--

betaTextField: codeTextField
  (#
     CheckDopart: aux.reg_match(# do 2->regNumber #);
     RemovePatternDef: aux.reg_replace(# do 3->regNumber #);
     CheckEndOfPatternDef : aux.reg_match(# do 4->regNumber #);
     CheckBeginWithPattern: aux.reg_match(# do 5->regNumber #);
     RemoveHarmless: aux.reg_replace(# do 6->regNumber #);
     CheckPatternNoDef: aux.reg_match(# do 7->regNumber #); 
     dummy: ^text;
     
     init:: 
       (# 
       do 
          7->aux.setNumberOfRegexps;
          4->aux.setNumberOfBlocks;          
          '(^do\\b|^enter\\b|^exit\\b|^else\\b|^//)'-> aux.init_reg(# do 2->regNumber #); 
          '^[a-zA-Z0-9_, ]+:[:|<]?[:<]? *[@|^|\\|]? *[a-zA-Z0-9_<@ :>]* *' 
            -> aux.init_reg(# do 3->regNumber #);
          '^;|^\\(' '#'->  aux.init_reg(# do 4->regNumber #);
          '^ *\\(' '#.*' -> aux.init_reg(# do 5->regNumber #); 
          '(.*)(\\(''#.*?#\\)|\\(''if\\b.*?\\bif\\)|\\(''for\\b.*?\\bfor\\)|\\(\\*.*?\\*\\))'
            -> aux.init_reg
          (# specialPcre::<(# editorReplace::(# rep::(# do sub2->value[]; 
                                                        0->value.pos; 
                                                        ';'->value.put; 
                                                        value.length-2->value.pos; 
                                                        '@'->value.put;  
                                                        sub1->value.prepend;
                           #) #) #) 
          do 6->regNumber 
          #);  
          '^ *\\(' '#.*#\\)'->aux.init_reg(# do 7->regNumber #);          
          
          ('(#','#)',3)->aux.init_block(# do 1->blockNumber #);
          ('(*','*)',3)->aux.init_block(# do 2->blockNumber #);
          ('(if','if)',4)->aux.init_block(# do 3->blockNumber #);
          ('(for','for)',5)->aux.init_block(# do 4->blockNumber #);
       #);    
     
     cycle: (# do INNER;
               restart cycle;
            #); 
     
     indent_line::
       (# done: @boolean;
       do
          (if not(first_line) then 
              t[]->indent_current->(indent_value,done);
              (if not(done) then 
                  previous_line;
                  indent_previous+indent_value->indent_value;
                  next_line;
              if);
              indent_value->indent_by_int;
          if);
       #); 
     
     indent_current:
       (# done,b: @boolean;
          dummy,indent_value: @integer;
          t: ^text;
       enter t[]
       do
          t[]->remove_harmless; 
          (if t[]->CheckDopart then indent_value-3->indent_value if); 
          (if t[]->aux.lastBlockEnd
           //1 then t[]->patternBlock->(indent_value,dummy); true->done;
           //2 then t[]->commentBlock->(indent_value,dummy); true->done;
           //3 then t[]->ifBlock->(indent_value,dummy); true->done;
           //4 then t[]->forBlock->(indent_value,dummy); true->done; 
          if); 
       exit (indent_value,done)
       #); 
     
     indent_previous:
       (# first,second,prev,indent_value: @integer;
          b, match: @boolean;
          t: ^text; 
       do 
          current_line->aux.eat_indent->(indent_value,t[]); 
          (if (not(first_line)) AND (t[]->CheckPatternNoDef) then 
              previous_line;
              (if current_line->check_pattern_def then indent_value-2->indent_value if);
              next_line;
          if); 
          t[]->remove_harmless;
          
          (if t[]->check_pattern_def->match then indent_value+2->indent_value; if);
          
          (t[]->aux.LastBlockBegin)->(b,first,dummy[]);
          first+indent_value->indent_value; 
          
          (if not(match) AND (t[]->CheckDopart) then indent_value+3->indent_value if); 
          (if t[]->aux.lastBlockEnd
           //1 then t[]->patternBlock->(first,second); second->indent_value;
           //2 then t[]->commentBlock->(first,second); second->indent_value;
           //3 then t[]->ifBlock->(first,second); second->indent_value;
           //4 then t[]->forBlock->(first,second); second->indent_value;
          if); 
       exit indent_value
       #);
     
     patternBlock: getBlockIndent
       (#
          getBlockNumber::<
            (# do 1->blockNumber #); 
          b: @boolean;
          blockStart: @integer;
       do 
          t[]->aux.lastBlockBegin->(b,blockStart,dummy[]);
          
          (if (not(first_line)) AND (current_line->CheckBeginWithPattern) then 
              previous_line;
              (if not(current_line->check_pattern_def) then next_line if); 
          if);
          current_line->aux.eat_indent->(blockStart,t[]); 
          
       exit blockStart
       #); 
     
     commentBlock: getBlockIndent
       (# 
          getBlockNumber::<
            (# do 2->blockNumber #);
          b: @boolean;
          blockStart: @integer;
       do 
          t[]->remove_harmless;
          t[]->aux.lastBlockBegin->(b,blockStart,dummy[]);
          (if not(b) then current_line->aux.eat_indent->(blockStart,t[]); if); 
       exit blockStart
       #);
     
     ifBlock: getBlockIndent
       (# 
          getBlockNumber::<
            (#  do 3->blockNumber #);
          b: @boolean;
          blockStart: @integer;
       do 
          t[]->remove_harmless;
          t[]->aux.lastBlockBegin->(b,blockStart,dummy[]);
          (if not(b) then current_line->aux.eat_indent->(blockStart,t[]); if); 
       exit blockStart 
       #);
     
     forBlock: getBlockIndent
       (# 
          getBlockNumber::<
            (# do 4->blockNumber #);
          b: @boolean;
          blockStart: @integer;
       do 
          t[]->remove_harmless;
          t[]->aux.lastBlockBegin->(b,blockStart,dummy[]);
          (if not(b) then current_line->aux.eat_indent->(blockStart,t[]); if); 
       exit blockStart 
       #);
     
     check_pattern_def:
       (# t,dummy: ^text;
       enter t[]
       do t.copy->dummy[];
       exit (dummy[]->RemovePatternDef) AND not(dummy[]->CheckEndOfPatternDef) 
       #); 
     
     
     remove_harmless:
       (# t: ^text;
       enter t[]
       do loop: cycle(# do (if not(t[]->RemoveHarmless) then leave loop if) #); 
       #);
     
     eventhandler::<
       (# 
          controlQPressed: @boolean;
          
          onBeforeChange::<
            (# t: ^text;
               ch : @char;
            do 
               theText -> T[];
               (if (t[]<>NONE) AND (T.lgth=1) then
                   T.T[1] -> ch;
               if);
               (if ch 
                // '{' then 
                   (if not(controlQPressed) then
                       aux.blockreg[1].begin[]->insert;
                       false->allow;
                   if);
                // '}' then
                   (if not(controlQPressed) then
                       close_construct->insert;
                       indent_line;
                       false->allow;    
                   if);
                // 'q'
                // 'Q' then 
                   (if controlmodified then true->controlQPressed;
                   if);
                   false->allow;
                else
                   false->controlQPressed;
                   INNER;
               if);
            #);          
          
       #);
     
     close_construct: 
       (# t,endBlock: ^text;
          b: @boolean;
          i,end,dummy,mem1,mem2: @integer;
          pat,com,if_,for_ : @integer;
          ch: @char;
       do 
          selection->(end,dummy)->(mem1,mem2);
          beginning_of_line->i; 
          &text[]->t[];
          loop: cycle
            (# do 
               (i,i+1)->myScan->ch;
               (if (i>=end) OR (ch=ascii.nl) then leave loop if);
               ch->t.put; 
               i+1->i;
            #);
          t[]->remove_harmless;
          t[]->aux.lastBlockBegin->(b,dummy,endBlock[]);
          (if not(b) then  
              toploop: cycle
                (# do                   
                   loop: cycle
                     (# do
                        (if t[]->aux.lastBlockEnd
                         //1 then pat+1->pat;
                         //2 then com+1->com; 
                         //3 then if_+1->if_;
                         //4 then for_+1->for_;
                         else leave loop;
                        if);
                     #);                   
                   (if not(first_line) then previous_line; 
                    else
                       ''->endBlock[];
                       leave toploop;
                   if);                   
                   current_line->t[];
                   t[]->remove_harmless;
                   loop: cycle
                     (# do                        
                        t[]->aux.lastBlockBegin->(b,i,endBlock[]);
                        (if b then 
                            (if endblock[]->aux.blockreg[1].end.equalNCS then
                                (if pat=0 then leave toploop else pat-1->pat if);
                            if);
                            (if endblock[]->aux.blockreg[2].end.equalNCS then
                                (if com=0 then leave toploop else com-1->com if);
                            if);
                            (if endblock[]->aux.blockreg[3].end.equalNCS then
                                (if if_=0 then leave toploop else if_-1->if_ if);
                            if);
                            (if endblock[]->aux.blockreg[4].end.equalNCS then
                                (if for_=0 then leave toploop else for_-1->for_ if);
                            if);
                         else leave loop;  
                        if);
                     #);
                #);
          if);
          (mem1,mem2)->selection;
       exit endBlock[]
       #); 
     
  #)
