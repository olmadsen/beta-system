ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds'
        '~beta/guienv/keys'
        'private/codeTextFieldRegexps'
        '~beta/guienv/fields';
BODY 'private/codeTextFieldbody';
-- windowLib: Attributes --
codeTextField: textField
  (#
     init:< (#  do &indentRegexps[]->regexp[]; regexp.init; INNER #);
     regexp: ^indentRegexps;
     controlmodified: @boolean;
     texteditingExtent:<
       (# start,end: @integer do INNER exit (start,end) #);
     texteditmode:< BooleanValue;
     (* globalRow and globalCol is used to internally navigate 
      * the textfield for performance reasons     
      *)
     rowCol: (# row,col: @integer
             enter (row,col)
             exit (row,col)
             #);
     (* globalText is the contents of the textfield *)
     globalText: ^text;
     (* globalFresh = true means that globalText contains 
      * the contents of the textfield, and false means
      * that the contents of the textfield has changed
      *)
     globalFresh: @boolean;
     trace: (#  exit false #);
     global: @rowCol;
     (* globalRow,globalCol: @integer; *)
     textfield_beginning_of_line:
       (* textfield_beginning_of_line moves the 
        * selection on the textfield to the beginning
        * of the line
        *)
       (# <<SLOT textfield_beginning_of_line:DoPart>> #);
     textfield_next_line:
       (* textfield_end_of_line moves the selection
        * on the textfield to the next line. If the 
        * current line is the last then the selection 
        * moves to the end of the line
        *)
       (# <<SLOT textfield_next_line:DoPart>> #);
     textfield_previous_line:
       (* textfield_previous_line moves the selection
        * on the textfield to the previous line. If 
        * the current line is the first line then the 
        * selection moves to the beginning of the line
        *)
       (# <<SLOT textfield_previous_line:DoPart>> #);
     textfield_end_of_line:
       (* textfield_end_of_line moves the selection
        * on the textfield to the end of the line
        * 
        *)
       (# <<SLOT textfield_end_of_line:DoPart>> #);
     beginning_of_line: 
       (* beginning_of_line moves the global position
        * (defined by globalRow and globalCol) to
        * the beginning of the line. It doesn't  
        * exceed the boundries defined by texteditingExtent 
        *)
       (#  <<SLOT beginning_of_line:DoPart>> #);
     end_of_line: 
       (* end_of_line moves the global position (defined
        * by globalRow and globalCol) to the end of the 
        * line. It doesn't exceed the boundries defined 
        * by texteditingExtent 
        *)
       (#  <<SLOT end_of_line:DoPart>> #);
     previous_line: 
       (* previous_line moves the global position (defined
        * by globalRow and globalCol) to the previous
        * line. It doesn't exceed the boundries defined 
        * by texteditingExtent
        *)
       (#  <<SLOT previous_line:DoPart>> #);
     next_line: 
       (* next_line moves the global position (defined
        * by globalRow and globalCol) to the next line.
        * It doesn't exceed the boundries defined by 
        * texteditingExtent
        *)
       (#  <<SLOT next_line:DoPart>> #);
     current_line:
       (* current_line returns the whole line 
        * which globalRow and globalCol points to.
        * It doesn't exceed the boundries defined by 
        * texteditingExtent
        *) 
       (# t: ^text; 
       <<SLOT current_line:DoPart>>
       exit t[]
       #);
     
     insertText:
       (* insertText inserts the text t 
        * in the textfield where globalRow
        * and globalCol points
        *)
       (# t: ^text
       enter t[]
       <<SLOT insertText: doPart>>
       #);
     deleteText:
       (* deleteText deletes the contents 
        * in the textfield starting from
        * (beginRow,beginCol) and ending in 
        * (endRow,endCol).
        *)
       (# begin,end: @rowCol
       enter (begin,end)
       <<SLOT deleteText: doPart>>
       #);
     getSelection:
       (* getSelection returns a text corresponding
        * to the contents of the textfield 
        * starting from begin
        * and ending in end
        *)
       (# begin,end : @rowCol;
          result: ^text
       enter (begin,end)
       <<SLOT getSelection: doPart>>   
       exit result[]
       #);
     last_line: 
       (* last_line returns a boolean
        * stating whether (globalRow,globalCol)
        * is positioned in the last line
        * according to the boundries defined 
        * by texteditingExtent
        *)
       (# result: @boolean;  
       <<SLOT last_line: doPart>> 
       exit result #);
     first_line:
       (* first_line returns a boolean
        * stating whether (globalRow,globalCol)
        * is positioned in the first line
        * according to the boundries defined 
        * by texteditingExtent
        *)
       (# result: @boolean;  
       <<SLOT first_line: doPart>> 
       exit result #);
     indent_by_int:
       (# indent: @integer; 
       enter indent
       <<SLOT indent_by_int:doPart>>
       #);
     eat_indent:
       (* eat_indent eats the starting 
        * whitespace in the input text. 
        * Returns an integer telling 
        * how much whitespace the input
        * text began with and a new text 
        * where the beginnning whitespace 
        * is removed.
        *)
       (# t,res: ^text;
          indent: @integer
       enter t[]
       <<SLOT eat_indent: doPart>>
       exit (indent,res[])
       #);
     get_whitespace:
       (* get_whitespace creates a string
        * of whitespace. The length of
        * the string is deternimed by 
        * the input integer.
        *)
       (# i: @integer; result: ^text; 
       enter i
       <<SLOT get_whitespace: doPart>>
       exit result[]
       #);
     indent_textField:
       (* indent_textField indents all
        * lines in the textField within
        * the boundries defined by 
        * texteditingExtent
        *)
       (# <<SLOT indent_textField: doPart>> #);
     frozen_indent_line:
       (* frozen_indent_line make a call to 
        * indent_line, but first it calls 
        * disableUpdate and after it calls 
        * enableUpdate. The input parameters
        * row and col are optional, but should
        * be used whenever possible to enhance 
        * perfomance. Row and col specifies 
        * the globalRow and globalCol.
        *)
       (# line: @rowCol
       enter line
       <<SLOT frozen_indent_line: doPart>>
       #);
     indent_line:<
       (* indent_line collects information
        * about where the position in the 
        * textfield was when indent_line was
        * called. Inner is then called and the 
        * further binding of indent_line is then
        * supposed to set an indent value to the 
        * variable indent_value. 
        * It exits the line number where the
        * indentation was performed
        *)
       (# lineNumber,indent_value,offset: @integer;
          entered: @rowCol;
          t, current: ^text
       enter entered
       <<SLOT indent_line: doPart>>
       exit lineNumber
       #);
     getBlockIndent:
       (* Finds the position of the beginnning block,
        * defined by the blocknumber.
        * Inner is called when the position is encountered.
        *)
       (# blockNumber: @integer;
          block: @rowCol;
          t: ^text;
          differentLines: @boolean;
          getBlockNumber:< (#  do INNER exit blockNumber #)
       enter t[]
       <<SLOT getBlockIndent: doPart>>   
       exit block
       #);
     indentHandler: (* enter a selection to be indented *)
       (# pos,endpos: @integer 
       enter (pos,endpos)
       <<SLOT indentHandler: doPart>>
       #);
     eventhandler::< 
       (#
          metaModified,controlModified: @boolean;
          theKey: @integer;
          enterPushed: @boolean;
          changingText: @boolean;
          keyDownTimer: @timer
            (# action:: (# <<SLOT keyDownTimer_action: doPart>> #) #);
          onKeyDown::< 
            (# t: ^text;
            <<SLOT codeTextField_onKeyDown: doPart>> #);
          onTextChanged::< 
            (# <<SLOT codeTextField_onTextChanged: doPart>> #);
          onBeforeChange::< 
            (# <<SLOT codeTextField_onBeforeChange: doPart>> #)
       #);
     removeBlanks:
       (* removes all but one whitespace from 
        * the current cursor position.
        *)
       (# allow: @boolean
         <<SLOT removeBlanks: doPart>>
       exit allow
       #);
     end_of_word:
       (* end_of_word searches from the current 
        * position and forward for a letter. 
        * When a letter is encountered (i.e. 
        * the beginning of a word) it positions
        * itself after the word
        *) 
       (# 
       <<SLOT end_of_word: doPart>>   
       #); 
     beginning_of_word:
       (* beginning_of_word searches backwards 
        * from the current position (not included) 
        * for a letter. When a letter is encountered
        * (i.e. the end of of a word) it positions
        * itself at the beginnning of the word 
        *) 
       (#  
       <<SLOT beginning_of_word: doPart>>
       #)
  #);
  

