ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds';
INCLUDE '~beta/guienv/keys';
INCLUDE 'private/codeRegexps';
BODY 'private/codePattern';

--windowLib: attributes--

codeTextField  : textField
  (# 
     
     init:<
       (# 
       do
          &indentRegexps[]->regexp[];
          regexp.init;
          INNER;
       #);     
     
     regexp: ^indentRegexps; 
     controlmodified: @boolean;          
     trace: (# exit false #);
     
     myScan: scantext (# exit ch #);     
     
     texteditingExtent:< (# start,end: @integer do INNER exit (start,end) #);
     
     beginning_of_line:
       (# pos: @integer;   
       <<SLOT beginning: doPart>>
       exit pos
       #);
     
     next_line:
       (# pos: @integer;
       <<SLOT next: doPart>>
       exit pos
       #);
     
     previous_line:
       (# pos: @integer;
       <<SLOT previous: doPart>>
       exit pos
       #);
     
     end_of_line:
       (# pos: @integer;
       <<SLOT end: doPart>>
       exit pos
       #);
     
     current_line:
       (# t : ^text;
       <<SLOT current: doPart>>
       exit t[]
       #);
     
     get_selection:
       (# begin,end: @integer;
          t: ^text;
       enter (begin,end)
       <<SLOT get_selection: doPart>>
       exit t[]
       #);
     
     last_line:
       (# result: @boolean;
       <<SLOT last: doPart>>
       exit result
       #); 
     
     first_line:  
       (# result: @boolean;
       <<SLOT first: doPart>>
       exit result
       #); 
     
     indent_by_int:
       (# indent: @integer;
       enter indent
       <<SLOT indent_by_int: doPart>> 
       #); 
     
     depth_of_selection:
       (# begin,end,depth: @integer;
       enter (begin,end)
       <<SLOT depth_of_selection: doPart>>
       exit depth
       #);
     
     get_whitespace:
       (# i: @integer;
          result: ^text;
       enter i
       do &text[]->result[];
          (for i repeat ' '->result.append for);
       exit result[]
       #);
     
     frozen_indent_line:
       (# do
          (* disableUpdate; *)
          indent_line;
          (* enableUpdate; *)
       #);
     
     indent_line:<
       (# t: ^text;
          indent_value,pos,pos2,offset,begin,position: @integer;
       do 
          selection->(pos,pos2);
          current_line->regexp.eat_indent->(indent_value,t[]);
          (* calculate the start position *)
          beginning_of_line->begin;
          (if (pos-begin)>indent_value then pos-begin-indent_value->offset if);
          INNER;
          (* VED IKKE OM DET SKAL VÆRE 
           begin+indent_value+offset -> position;
           (position,position)->selection;
           *)
          (if indent_value>0 then begin+indent_value+offset -> position
           else begin+offset -> position if);
          (position,position) -> selection;
       #);
     
     getBlockIndent:
       (# 
          blockNumber, blockIndent,count: @integer;
          mem1,mem2: @integer;
          t : ^text; 
          b,finished,firstBlock,sameLine: @boolean;
          
          getBlockNumber:<
            (# do INNER
            exit blockNumber
            #);
          
       enter t[] 
       do
          true -> sameLine;
          selection->(mem1,mem2);
          toploop: cycle
            (# do 
               loop: cycle
                 (# do
                    (t[],getBlockNumber)->regexp.RemoveBlock->(b,firstBlock);
                    (if not(b) then leave loop;
                     else (if firstBlock then 
                              (if count=0 then
                                  t.length->blockIndent;
                                  true->finished;
                                  leave loop;
                              if);
                              count-1->count;
                           else
                              count+1->count;                               
                          if);
                    if);
                 #); 
               (if finished then 
                   INNER getBlockIndent;
                   leave toploop;
                else 
                   (if first_line then
                       (* error: missing blockBegin *)
                       0->blockIndent;
                       leave toploop;
                   if);
                   previous_line;
                   false -> sameLine;
                   current_line->t[];
               if);
            #); (* toploop *) 
          (mem1,mem2)->selection;
       exit blockIndent
       #); 
     
     indentHandler:
       (* enter a selection to be indented *) 
       (# 
          begin,end,depth : @integer;
       enter (begin,end)
       do 
          (* disableUpdate; *)
          (begin,end)->depth_of_selection->depth;
          (begin,begin)->selection;
          indent_line;
          (for depth-1 repeat
               next_line;
               indent_line;
          for);
          (* enableupdate; *)
       #); 
     
     eventhandler::<
       (# 
          enterPushed: @boolean;
          changingText: @boolean;
          
          onKeyDown::<
            (# spk: @SpecialKeys;
            do 
               (if trace then 'onKeyDown'->putline if);
               (if ch=13 then true->enterPushed; if);
               (if key= (spk.HOME) then 
                   beginning_of_line;
               if);
               (if key=(spk.END) then 
                   end_of_line; 
               if);
               controlkey -> controlmodified; 
               INNER
            #);
          
          onTextChanged::<
            (# 
            do
               (if trace and enterPushed then 'enterPushed'->putline; if);
               (if enterPushed and NOT(changingText) then  
                   (* disableUpdate; *)
                   true->changingText;
                   previous_line;
                   'prev in enterpushed'->putline;
                   indent_line;
                   next_line;
                   beginning_of_line; 
                   indent_line;
                   false->enterPushed->changingText;
                   (* enableUpdate; *)
               if); 
               INNER
            #);
          
          onBeforeChange::<
            (# T,t1: ^text;
               ch1: @char;
               indent,begin,end: @integer;
            do 
               (if trace then 'onBeforeChange' -> putline; if); 
               (if (trace and controlmodified) then 
                   'Control' -> putline; 
               if);
               theText -> T[];
               (if (t[]<>NONE) AND (T.lgth=1) then
                   T.T[1] -> ch1;
                   (if trace then 
                       'ch1: '->screen.puttext; 
                       ch1->screen.putint; 
                       screen.newline;
                   if);
                   (if ch1
                    // ascii.ht then 
                       (if trace then 'Tab' -> screen.putline; if);
                       selection->(begin,end);
                       (if begin<>end then (begin,end)->indentHandler; 
                        else frozen_indent_line; 
                       if);
                       false -> allow;
                    // 'e'
                    // 'E' then
                       (if controlmodified then 
                           
                           end_of_line; 
                           false->allow; 
                       if);
                    else INNER
                   if);
                else INNER
               if); 
            #);
       #);
  #);
