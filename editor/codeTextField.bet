ORIGIN '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/textfieldadds'
        '~beta/guienv/keys'
        'private/codeRegexps';
BODY 'private/codePattern';
-- windowLib: Attributes --
codeTextField: textField
  (#
     init:< (#  do &indentRegexps[]->regexp[]; regexp.init; INNER #);
     regexp: ^indentRegexps;
     controlmodified: @boolean;
     trace: (#  exit false #);
     myScan: scantext (#  exit ch #);
     texteditingExtent:<
       (# start,end: @integer do INNER exit (start,end) #);
     texteditmode:< BooleanValue;
     beginning_of_line:
       (# pos: @integer;  <<SLOT beginning:DoPart>> exit pos #);
     next_line:
       (# pos: @integer; 
       <<SLOT next:DoPart>>
       exit pos
       #);
     previous_line:
       (# pos: @integer; 
       <<SLOT previous:DoPart>>
       exit
       pos
       #);
     end_of_line: (# pos: @integer;  <<SLOT end:DoPart>> exit pos #);
     current_line:
       (# t: ^text;  <<SLOT current:DoPart>> exit t[] #);
     get_selection:
       (# begin,end: @integer; t: ^text; 
       enter (begin,end)
       <<SLOT get_selection:DoPart>>
       exit t[]
       #);
     last_line:
       (# result: @boolean; 
       <<SLOT last:DoPart>>
       exit result
       #);
     first_line:
       (# result: @boolean; 
       <<SLOT first:DoPart>>
       exit result
       #);
     indent_by_int:
       (# indent: @integer;  enter indent <<SLOT indent_by_int:DoPart>> #);
     eat_indent:
       (#
          t,res: ^text;
          indent,row,col: @integer;
          
       enter t[]
       do
          t[]->regexp.eat_indent->(indent,res[]);
          (if (first_line) then
              beginning_of_line->posToRowCol
                ->(row,col);
              col-1+indent->indent
          if)
       exit (indent,res[])
       #);
     depth_of_selection:
       (# begin,end,depth: @integer; 
       enter (begin,end)
       <<SLOT depth_of_selection:DoPart>>
       exit depth
       #);
     get_whitespace:
       (# i: @integer; result: ^text; 
       enter i
       do &text[]->result[]; (for i repeat ' '->result.append for); 
       exit result[]
       #);
     frozen_indent_line:
       (#  do disableUpdate; indent_line; enableUpdate;  #);
     indent_line:<
       (# t: ^text; indent_value,pos,pos2,offset,begin,position: @integer; 
       do
          selection->(pos,pos2);
          current_line->regexp.eat_indent->(indent_value,t[]);
          (* calculate the start position *)
          beginning_of_line->begin;
          (if (pos-begin) > indent_value then
              pos-begin-indent_value->offset
          if);
          INNER ;
          (* VED IKKE OM DET SKAL VÆRE 
           begin+indent_value+offset -> position;
           (position,position)->selection;
           *)
          (if indent_value > 0 then
              begin+indent_value+offset->position
           else
              begin+offset->position
          if);
          (position,position)->selection
       #);
     getBlockIndent:
       (#
          blockNumber,blockIndent,count: @integer;
          mem1,mem2: @integer;
          t: ^text;
          b,finished,firstBlock,sameLine: @boolean;
          getBlockNumber:< (#  do INNER exit blockNumber #)
       enter t[]
       do
          true->sameLine;
          selection->(mem1,mem2);
          toploop: cycle
            (# 
            do
               loop: cycle
                 (# 
                 do
                    (t[],getBlockNumber)->regexp.RemoveBlock->(b,firstBlock);
                    (if not (b) then
                        leave loop; 
                     else
                        (if firstBlock then
                            (if count = 0 then (* t.length->blockIndent; *)
                                t[]->eat_indent->(blockIndent,t[]);
                                blockIndent+t.length->blockIndent;
                                true->finished;
                                leave loop
                            if);
                            count-1->count
                         else
                            count+1->count
                        if)
                    if)
                 #);
               (if finished then
                   INNER getBlockIndent; leave toploop; 
                else
                   (if first_line then (* error: missing blockBegin *)
                       0->blockIndent; leave toploop; 
                   if);
                   previous_line;
                   false->sameLine;
                   current_line->t[]
               if)
            #);
          (* toploop *)
          (mem1,mem2)->selection;
          
       exit blockIndent
       #);
     indentHandler: (* enter a selection to be indented *)
       (# begin,end,depth: @integer; 
       enter (begin,end)
       do
          disableUpdate;
          (begin,end)->depth_of_selection->depth;
          (begin,begin)->selection;
          indent_line;
          (for depth-1 repeat next_line; indent_line;  for);
          enableupdate
       #);
     eventhandler::< 
       (#
          metaModified: @boolean;
          enterPushed: @boolean;
          changingText: @boolean;
          onKeyDown::< 
            (# spk: @SpecialKeys; begin,end: @integer; 
            do
               (if texteditmode then
                   (if trace then 'onKeyDown'->putline if);
                   (if ch 
                    // 13 then true->enterPushed 
                    // 28 then 
                       (if controlkey then
                           
                       if)
                    // 29 then 
                       (if controlkey then
                           
                       if)
                   if);
                   (if key
                    // spk.HOME then
                       (if controlkey then
                           texteditingExtent->(begin,end); (begin,begin)->selection
                        else beginning_of_line
                       if)
                    // spk.END then
                       (if controlkey then
                           texteditingExtent->(begin,end); (end,end)->selection
                        else end_of_line 
                       if)
                   if);
                   controlkey->controlmodified;
                   metaKey->metaModified;
                   INNER
                else
                   INNER
               if)
            #);
          onTextChanged::< 
            (# 
            do
               (if texteditmode then
                   (if trace and enterPushed then
                       'enterPushed'->putline; 
                   if);
                   (if enterPushed and not (changingText) then
                       disableUpdate;
                       true->changingText;
                       previous_line;
                       indent_line;
                       next_line;
                       beginning_of_line;
                       indent_line;
                       false->enterPushed->changingText;
                       enableUpdate
                   if);
                   INNER
                else
                   INNER
               if)
            #);
          onBeforeChange::< 
            (# T,t1: ^text; ch1: @char; indent,begin,end: @integer; 
            do
               (if texteditmode then
                   (if trace then 'onBeforeChange'->putline;  if);
                   (if (trace and controlmodified) then
                       'Control'->putline; 
                   if);
                   theText->T[];
                   (if (t[] <> none ) and (T.lgth = 1) then
                       T.T[1]->ch1;
                       (if ch1
                        // ascii.ht then
                           (if trace then 'Tab'->screen.putline;  if);
                           selection->(begin,end);
                           (if begin <> end then
                               (begin,end)->indentHandler; 
                            else
                               frozen_indent_line; 
                           if);
                           false->allow
                        // ascii.sp then
                           (if metaModified then removeBlanks->allow if) 
                        else
                           INNER
                       if)                       
                    else
                       INNER
                   if)                   
                else
                   INNER
               if)               
            #)          
       #);     
     removeBlanks:
       (* removes all but one whitespace from 
        * the current cursor position.
        *) 
       (# pos,endpos,i: @integer; t: ^text; ch: @char; allow: @boolean; 
       do
          selection->(pos,endpos);
          pos->i;
          loop: cycle
            (# 
            do
               (i,i+1)->myScan->ch;
               (if not (ch = ascii.sp) or (ch = ascii.nl) then
                   leave loop
               if);
               i+1->i
            #);
          i->endpos;
          pos->i;
          loop: cycle
            (# 
            do
               (i-1,i)->myScan->ch;
               (if not (ch = ascii.sp) or (ch = ascii.nl) then
                   leave loop
               if);
               i-1->i
            #);
          i->pos;
          (if (pos <> endpos) then
              (pos+1,endpos)->selection;
              delete;
              (pos+1,pos+1)->selection;
              false->allow
           else
              true->allow; 
          if)
       exit allow
       #);
     end_of_word:
       (* end_of_word moves the cursor position to the 
        * end of the word
        *)
       (# 
          
       #);
     beginning_of_word:
       (* beginning_of_word moves the cursor position 
        * to the beginning of the word
        *)
       (# 
          
       #)
  #);
  

