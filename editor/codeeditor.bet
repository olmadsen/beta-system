ORIGIN 'codeviewer';
INCLUDE '~beta/guienv/v1.3.1/utils/simplemenu'
        '~beta/freja/v2.0/frejasifcomm'
        '~beta/containers/v1.4/sets'
        '~beta/containers/v1.4/seqContainers'
        '~beta/mps/v4.9.1/propertycfl'
        '~beta/prettygen/v4.9.1/prettyprintcfl'
        'ymercall';
BODY 'private/misc'
     'private/parsing'
     'private/derivation'
     'private/delete'
     'private/doundo'
     'private/optionals'
     'private/notification'
     'private/codeeditorbody'
     'private/updatemenus'
     'private/textediting'
     'private/editorenvbody'
     'private/groupeditorbody'
     'private/historybody'
     'private/frejacommbody'
     'private/slotbody'
     'private/propertyeditorbody'
     'private/subeditorbody';
-- lib: Attributes --
sifEditorenv: (#  #)  

-- windowlib: Attributes --
codeEditor: codeViewer
  (#
     edenv: ^editorEnv;
     thisGroupEditor: ^edenv.groupeditor;
     thePropertyEditor: ^propertyEditor;
     isAFrejaEditor,notifyFreja: @boolean;
     frejaStatusOn: @boolean;
     frejaEditTypeStatus: @text;
     frejaEditStatus: @text;
     frejaExpandStatus: @text;
     parsingPossible: @boolean;
     editingMode: @integer;
     structureMode: (#  exit 0 #);
     editLexemMode: (#  exit 1 #);
     editAndParseMode: (#  exit 2 #);
     TEexit: @
       (#
          escape: (#  exit 0 #);
          parseMode: (#  exit 1 #);
          exitMode: (#  exit 2 #);
          
       #);
     undoElem: ^undoElemType;
     undoElemType:
       (#
          fatherRef: ^mps.expanded;
          sonPos: @integer;
          fragments: @edenv.partlist;
          fragmentLength,undoLength: @integer
          (* fragmentLength is the length of the undoElem, 
           undoLength is the length of the fragment to be
           replaced by the undoElem.                     *) ;
          isDeleted: @boolean
          (* if true then undoElem is deleted from the program 
           else it is replaced by another fragment           *)
       exit (fatherRef[],sonPos,fragments.elm[1][],fragmentLength)
       #);
     updateHistory::<  (#  <<SLOT editorenvHistoryUpdateHistory:DoPart>> #);
     checkFormEditorExistence::< 
       (#  <<SLOT codeeditorCheckFormEditorExistence:DoPart>> #);
     setupFormEditor::< 
       (# 
       <<SLOT codeeditorSetupFormeditor:DoPart>>
       #);
     subject05: (* some useful editor specific operations: misc.bet *)
       (#  #);
     makeUndoElem:
       (#
          fatherNode: ^mps.expanded;
          sonPos,undoLength: @integer;
          undoFocus:
          (* undoLength is the number of nodes undoFocus should be replaced 
           with when undone .                                             *)
            @astFocus;
          isDeleted: @boolean;
          
       enter (fatherNode[],sonPos,undoFocus,undoLength,isDeleted)
       do <<SLOT makeUndoElemBody:Descriptor>>
       #);
     getSynCatNo:
       (#
          node: ^mps.ast;
          synCatNo: @mps.nonterminalSymbol;
          
       enter node[]
       do
          <<SLOT getSynCatNoBody:Descriptor>>
       exit synCatNo
       #);
     setSynCatNo:
       (# synCatNo: @mps.nonterminalSymbol; programNode: ^mps.expanded; 
       enter (synCatNo,programNode[])
       do <<SLOT setSynCatNoBody:Descriptor>>
       #);
     findSynNameAtt:
       (#
          production: ^mg.prod;
          synCatNo: @mps.nonterminalSymbol;
          
       enter production[]
       do
          <<SLOT findSynNameAttBody:Descriptor>>
       exit synCatNo
       #);
     subject1: (* parsing operations: parsing.bet *) (#  #);
     substitute:
       (# oldFragment,newFragment: ^mps.ast; 
       enter (oldFragment[],newFragment[])
       do <<SLOT substituteBody:Descriptor>>
       #);
     listSubstitute:
       (#
          f: @astFocus; theList: ^mps.list; 
       enter (f,theList[])
       do
          <<SLOT listSubstituteBody:Descriptor>>
       exit f
       #);
     parseText:
       (# f: @astFocus; t: ^text; parseOK: @boolean
       enter (f,t[])
       do <<SLOT parseTextBody:Descriptor>>
       exit (parseOK,f)
       #);
     subject2: (* undo operation: undo.bet *)
       (#  #);
     undo:
       (# 
       do <<SLOT undoBody:Descriptor>>
       #);
     subject3:
     (* derivation operations: derivation.bet *) (#  #);
     ins: @
       (#
          first: (#  exit 1 #);
          before: (#  exit 2 #);
          after: (#  exit 3 #)
       #);
     createList:
       (#
          synCatNo: @mps.nonterminalSymbol;
          prod: ^mg.prod;
          fatherNode: ^mps.expanded;
          isSon: @integer
       enter (synCatNo,prod[],fatherNode[],isSon)
       do <<SLOT createListBody:Descriptor>>
       #);
     new:
       (# 
       do <<SLOT newBody:Descriptor>>
       #);
     newPrivate:
       (# 
       do
          <<SLOT newPrivateBody:Descriptor>>
       #);
     expand:
       (#
          fatherNode: ^mps.expanded;
          isSon: @integer;
          synCatNo: @mps.nonterminalSymbol;
          
       enter (synCatNo,fatherNode[],isSon)
       do <<SLOT expandBody:Descriptor>>
       #);
     nodeExpand:
       (#
          synCatNo: @mps.nonterminalSymbol;
          newLexem: @boolean;
          
       enter (synCatNo,newLexem)
       do <<SLOT nodeExpandBody:Descriptor>>
       #);
     expandLexem:
       (# t: ^text;  enter t[] do <<SLOT expandLexemBody:Descriptor>> #);
     listInsert:
       (# command: @integer; 
       enter command
       do <<SLOT listInsertBody:Descriptor>>
       #);
     expandOptional: (#  do <<SLOT expandOptionalBody:Descriptor>> #);
     subject5:
     (* delete operations: delete.bet *) (#  #);
     deleted: @boolean;
     cut:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT cutFragmentBody:Descriptor>>
       #);
     makeEmptyListOrOpt:
       (# 
       do
          <<SLOT makeEmptyListOrOptBody:Descriptor>>
       #);
     paste:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT pasteFragmentBody:Descriptor>>
       #);
     copy:
       (# 
       do
          <<SLOT copyFragmentBody:Descriptor>>
       #);
     subject8: (* comment operations: comment.bet *) (#  #);
     removeOptionals:
       (# node: ^mps.ast; 
       enter node[]
       do <<SLOT removeOptionalsBody:Descriptor>>
       #);
     insertOptionals:
       (# node: ^mps.ast; 
       enter node[]
       do
          <<SLOT insertOptionalsBody:Descriptor>>
       #);
     removeEmptyElement:
       (# theList: ^mps.list; 
       enter theList[]
       do <<SLOT removeEmptyElementBody:Descriptor>>
       #);
     removeEmptyElements:
       (# node: ^mps.ast; 
       enter node[]
       do
          <<SLOT removeEmptyElementsBody:Descriptor>>
       #);
     onExternCommand:
       (# command,status: ^text; 
       enter command[]
       do <<SLOT onExternCommandBody:Descriptor>>
       exit status[]
       #);
     externCommand:
       (# command,status: ^text; 
       enter command[]
       do
          <<SLOT externCommandBody:Descriptor>>
       exit status[]
       #);
     closeGroup::<  (#  <<SLOT codeeditorCloseGroup:DoPart>> #);
     closeForm::< 
       (# 
       <<SLOT codeeditorCloseForm:DoPart>>
       #);
     subject9:
     (* The following virtual patterns (events) are called in the model
      every time certain changes are made.
      These patterns are specialized in the application.*) (#  #);
     editorEvent: (#  do INNER #);
     noOfAstChanges,ASLimit,touched: @integer;
     resetFragmentTouch: <<SLOT resetFragmentTouchBody:Descriptor>>;
     fragmentTouched:
      <<SLOT fragmentTouchedBody:Descriptor>>;
     fragmentDetouched: <<SLOT fragmentDetouchedBody:Descriptor>>;
     autoSaveLimit:<
       (# 
       do
          <<SLOT autoSaveLimitBody:Descriptor>>;
          INNER
       #);
     autoSave:< (#  <<SLOT autoSaveBody:DoPart>> #);
     onPopUpButton::< 
       (#  <<SLOT onPopUpButton:DoPart>> #);
     fragmentChangedEvent: editorEvent
       (#  do <<SLOT fragmentChangedEventBody:Descriptor>>; INNER #);
     newFragmentEvent:<
       (# 
       do
          <<SLOT frejaCommNewFragment:Descriptor>>;
          <<SLOT notificationNewFragment:Descriptor>>;
          
       #);
     aNewFragmentEvent: @NewFragmentEvent;
     astReplacedEvent:< fragmentChangedEvent
       (# oldAst,newAst: ^mps.ast; 
       enter (oldAst[],newAst[])
       do
          <<SLOT frejaCommAstReplaced:Descriptor>>;
          <<SLOT notificationAstReplaced:Descriptor>>
       #);
     anAstReplacedEvent: @astReplacedEvent;
     makeAstReplacedEvent:
       (# sequence: @boolean
       enter sequence
       <<SLOT MakeAstReplaced:DoPart>>
       #);
     astReplacedElement:
       (# oldAst,newAst: ^mps.ast #);
     astReplacedList: @list
       (#
          element:: astReplacedElement;
          appendElement:
            (#
               oldAst,newAst: ^mps.ast;
               e: ^astReplacedElement;
               
            enter (oldAst[],newAst[])
            do
               &astReplacedElement[]->e[];
               oldAst[]->e.oldAst[];
               newAst[]->e.newAst[];
               e[]->append
            #)
       #);
     astReplacedSequenceEvent:<
      fragmentChangedEvent
       (# rootOfSequence: ^mps.ast
       enter rootOfSequence[]
       do
          <<SLOT frejaCommAstReplacedSequence:Descriptor>>;
          <<SLOT notificationAstReplacedSequence:Descriptor>>
       #);
     listElementInsertedEvent:< fragmentChangedEvent
       (# position: @integer; fatherNode: ^mps.expanded; 
       enter (fatherNode[],position)
       do
          <<SLOT frejaCommListElementInserted:Descriptor>>;
          <<SLOT notificationListElementInserted:Descriptor>>
       #);
     aListElementInsertedEvent: @listElementInsertedEvent;
     listElementsDeletedEvent:< fragmentChangedEvent
       (#
          oldElements: ^edenv.partList;
          listNode: ^mps.expanded;
          position,length: @integer
       enter (listNode[],position,length,oldElements[])
       do
          <<SLOT frejaCommListElementsDeleted:Descriptor>>;
          <<SLOT notificationListElementsDeleted:Descriptor>>
       #);
     aListElementsDeletedEvent: @listElementsDeletedEvent;
     listElementsReplacedEvent:< fragmentChangedEvent
       (#
          oldElement: ^edenv.partList;
          listNode: ^mps.expanded;
          position,length,newLength: @integer
       enter (listNode[],position,length,oldElement[],newLength)
       do
          <<SLOT frejaCommListElementsReplaced:Descriptor>>;
          <<SLOT notificationListElementsReplaced:Descriptor>>
       #);
     aListElementsReplacedEvent: @listElementsreplacedEvent;
     focusChangedEvent::< 
       (# 
       do
          <<SLOT notificationFocusChanged:Descriptor>>;
          <<SLOT frejaCommFocusChanged:Descriptor>>
       #);
     visibleInFreja:
       (# node: ^mps.ast; value: @boolean; 
       enter node[]
       do <<SLOT visibleInFreja:Descriptor>>
       exit value
       #);
     expandMenuPrivate: ^expmenuprivate;
     expmenuprivate:
      <<SLOT expandMenuPrivate:Descriptor>>;
     updateExpandMenu: (#  do <<SLOT updateExpandMenuBody:Descriptor>> #);
     updateEditMenu: (#  do <<SLOT editMenuUpdateBody:Descriptor>> #);
     askUndoPermission::< 
       (#  do cs.undoPermit->value #);
     askPastePermission::< 
       (# 
       do cs.pastePermit->value
       #);
     askInsertPermission::< 
       (# 
       do cs.listInsertPermit->value
       #);
     texteditMode:
       (# 
       enter theSifTextEditor.textediting
       exit theSifTextEditor.textediting
       #);
     askTexteditMode::<  (#  do textEditMode->value #);
     doUndo::<  (#  do undo #);
     doCut::<  (#  do true->cs.undoPermit; cut #);
     doCopy::<  (#  do true->cs.undoPermit; copy; updateEditMenu #);
     doPaste::<  (#  do paste #);
     TE: ^texteditingPrivate;
     texteditingPrivate: <<SLOT texteditingPrivate:Descriptor>>;
     doTextedit::< 
       (# 
       <<SLOT doTextedit:DoPart>>
       #);
     checkTexteditingFinished::< 
       (#  do <<SLOT checkTexteditingFinished:Descriptor>>;  #);
     doParseText::< 
       (# 
       <<SLOT doParseText:DoPart>>
       #);
     doRevertTextedit::<  (#  <<SLOT doRevertTextediting:DoPart>> #);
     doShowTexteditCommands::< 
       (# 
       <<SLOT doShowTexteditingCommands:DoPart>>
       #);
     doInsertBefore::< 
       (#  do true->cs.undoPermit; ins.before->listInsert #);
     doInsertAfter::<  (#  do true->cs.undoPermit; ins.after->listInsert #);
     doRemoveOptionals::< 
       (#  do cs.perform (#  do current[]->removeOptionals #) #);
     doShowOptionals::< 
       (#  do cs.perform (#  do current[]->insertOptionals #) #);
     slotPrivate: ^slotPrivatePattern;
     slotPrivatePattern: <<SLOT slotPrivate:Descriptor>>;
     askMakeDopartSlot::< 
       (# 
       <<SLOT askMakeDopartSlot:DoPart>>
       #);
     askMakeDescriptorSlot::<  (#  <<SLOT askMakeDescriptorSlot:DoPart>> #);
     askMakeAttributesSlot::<  (#  <<SLOT askMakeAtributesSlot:DoPart>> #);
     askPasteFragmentForm::< 
       (# 
       <<SLOT askPasteFragmentForm:DoPart>>
       #);
     doMakeDopartSlot::<  (#  <<SLOT doMakeDopartSlot:DoPart>> #);
     doMakeDescriptorSlot::< 
       (# 
       <<SLOT doMakeDescriptorSlot:DoPart>>
       #);
     doMakeAttributesSlot::<  (#  <<SLOT doMakeAttributesSlot:DoPart>> #);
     doPasteFragmentForm::< 
       (# 
       <<SLOT doPasteFragmentForm:DoPart>>
       #);
     doFillSlot::<  (#  <<SLOT doFillSlot:DoPart>> #);
     doFillAllSlots::< 
       (#  <<SLOT doFillAllSlots:DoPart>> #);
     doHideImplementation::<  (#  <<SLOT doHideImplementation:DoPart>> #);
     openSubeditor::< 
       (# 
       <<SLOT subeditorOpenSubeditor:DoPart>>
       #);
     subeditors: @list (# element::< subeditor #);
     init::<  (#  <<SLOT codeeditorinit:DoPart>> #)
  #);
propertyEditor: codeeditor
  (#
     theGroupEditor: ^edenv.groupeditor;
     updateProperties:
       (# 
       <<SLOT propertyeditorUpdateProperties:DoPart>>
       #);
     astReplacedEvent::<  (#  <<SLOT propertyeditorAstReplaced:DoPart>> #);
     astReplacedSequenceEvent::< 
       (# 
       <<SLOT propertyeditorAstReplacedSequence:DoPart>>
       #);
     listElementInsertedEvent::< 
       (#  <<SLOT propertyeditorListElementInserted:DoPart>> #);
     listElementsDeletedEvent::< 
       (#  <<SLOT propertyeditorListElementsDeleted:DoPart>> #);
     listElementsReplacedEvent::< 
       (#  <<SLOT propertyeditorListElementsReplaced:DoPart>> #);
     
  #);
subeditor: codeeditor
  (#
     fatherEditor:
       ^codeeditor;
     astReplacedEvent::<  (#  <<SLOT subeditorAstReplaced:DoPart>> #);
     astReplacedSequenceEvent::< 
       (# 
       <<SLOT subeditorAstReplacedSequence:DoPart>>
       #);
     listElementInsertedEvent::< 
       (#  <<SLOT subeditorListElementInserted:DoPart>> #);
     listElementsDeletedEvent::< 
       (# 
       <<SLOT subeditorListElementsDeleted:DoPart>>
       #);
     listElementsReplacedEvent::< 
       (#  <<SLOT subeditorListElementsReplaced:DoPart>> #);
     
  #);
editorenv: sifEditorEnv
  (#
     mps: ^astInterface;
     betaGrammar:
     (*^mps.treelevel;*) ^mps.beta;
     betaGram: (* contains all the syntactic category numbers *) @grammar;
     propertyGrammar: ^mps.treeLevel;
     prettyprintGrammar: ^mps.treeLevel;
     UI: ^guienv;
     initiator: ^text;
     contractOnOpen,onlyNotifyFreja: @boolean;
     doQuit: @boolean;
     onGoingRecovery: @boolean;
     partList: (# elm: [50] ^mps.ast #);
     clip: ^clipBoard;
     clipBoard:
       (#
          synCatNo: @mps.nonterminalSymbol;
          fragments: @partList;
          length: @integer;
          
       #);
     clippedff: ^mps.fragmentForm;
     makeSLOTfrag: ^mps.fragmentForm;
     makeSLOTtype: @integer;
     fillSLOTfrag: ^mps.fragmentForm;
     fillSLOTtype: @integer;
     clippedfrag: ^mps.fragmentForm;
     clippedfragtype: @integer;
     formEditorNo: @integer;
     nextEditorId:
       (#  do formEditorNo+1->formEditorNo exit formEditorNo #);
     setWaitCursor: (#  do ui.cursors.watch[]->UI.mouse.busyCursor #);
     setStructureCursor: (#  do none ->UI.mouse.busyCursor #);
     doCommand:
       (#  do setWaitCursor; INNER doCommand; setStructureCursor #);
     history: @
       (#
          historyList: list (# element:: mps.ast;  #);
          h: ^historyList;
          init: (#  do &historyList[]->h[]; h.init #);
          currentCell: ^h.theCellType;
          private: @<<SLOT editorenvhistoryprivate:Descriptor>>;
          current:
            (# node: ^mps.ast
            <<SLOT editorenvHistoryCurrent:DoPart>>
            exit node[]
            #);
          add:
            (# node: ^mps.ast
            enter node[]
            <<SLOT editorenvHistoryAdd:DoPart>>
            #);
          remove:
            (# node: ^mps.ast
            enter node[]
            <<SLOT editorenvHistoryRemove:DoPart>>
            #);
          backPossible:
            (# node: ^mps.ast; value: @boolean
            enter node[]
            <<SLOT editorEnvHistoryBackPossible:DoPart>>
            exit value
            #);
          back:
            (#
               currentNode,newNode:
                 ^mps.ast
            enter currentNode[]
            <<SLOT editorEnvHistoryBack:DoPart>>
            exit newNode[]
            #);
          forwardPossible:
            (#
               node: ^mps.ast;
               value: @boolean
            enter node[]
            <<SLOT editorEnvHistoryForwardPossible:DoPart>>
            exit value
            #);
          forward:
            (# currentNode,newNode: ^mps.ast
            enter currentNode[]
            <<SLOT editorenvHistoryForward:DoPart>>
            exit newNode[]
            #)
       #);
     trace: [10] @boolean;
     editorenvPrivate:
       @<<SLOT editorenvPrivate:Descriptor>>;
     new:
       (# name: ^text; isAFrejaEditor: @boolean; ge: ^groupeditor
       enter (name[],isAfrejaEditor)
       <<SLOT editorenvNew:DoPart>>
       exit ge[]
       #);
     newBetaProgram: doCommand
       (#
          name: ^text;
          isAFrejaEditor: @boolean;
          ge: ^groupeditor
       enter (name[],isAfrejaEditor)
       <<SLOT editorEnvNewBetaProgram:DoPart>>
       exit ge[]
       #);
     newBetaLibrary: doCommand
       (# name: ^text; isAFrejaEditor: @boolean; ge: ^groupeditor
       enter (name[],isAfrejaEditor)
       <<SLOT editorenvNewBetaLibrary:DoPart>>
       exit ge[]
       #);
     openForm:
       (#
          name: ^text;
          index: @integer;
          ff: ^mps.fragmentForm;
          node: ^mps.ast
       enter (name[],index)
       do
          <<SLOT openFormBody:Descriptor>>
       exit (ff[],node[])
       #);
     saveAll: (#  <<SLOT editorenvSaveAll:DoPart>> #);
     groupEditor:
       (#
          fg: ^mps.fragmentGroup;
          writeAccess: @boolean;
          grammarName: ^text;
          touched: @integer;
          isAFrejaEditor: @boolean;
          needToUpdateTextFile: @boolean;
          autoSaveFileExists: @boolean;
          thePropertyEditor: ^codeeditor;
          formEditorList: @list
            (#
               element:: codeeditor;
               findOrCreateEditor:
                 (#
                    ff: ^mps.fragmentForm;
                    fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindOrCreateEditor:DoPart>>
                 exit fe[]
                 #);
               findEditor:
                 (# ff: ^mps.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindEditor:DoPart>>
                 exit fe[]
                 #);
               findEditorId:
                 (# id: @integer; fe: ^codeviewer
                 enter id
                 <<SLOT groupeditorFormeditorListFindEditorId:DoPart>>
                 exit fe[]
                 #)
            #);
          closeGroup: booleanValue
            (#  <<SLOT groupeditorCloseGroup:DoPart>> #);
          save: doCommand
            (#
               doUpdateTextFile,doGC:
                 @boolean
            enter (doUpdateTextFile,doGC)
            <<SLOT groupEditorSave:DoPart>>
            #);
          saveAs:
            (# newName: ^text
            <<SLOT groupeditorSaveAs:DoPart>>
            exit
            newName[]
            #);
          saveAbstract: (#  <<SLOT groupeditorSaveAbstract:DoPart>> #);
          recover: doCommand
            (# 
            <<SLOT groupeditorRecover:DoPart>>
            #);
          revert: doCommand (#  <<SLOT groupeditorRevert:DoPart>> #);
          resetGroupTouch:
            (# 
            <<SLOT groupeditorResetGroupTouch:DoPart>>
            #);
          groupTouched: (#  <<SLOT groupeeditorGroupTouched:DoPart>> #);
          groupDetouched:
            (# 
            <<SLOT groupeditorGroupDetouched:DoPart>>
            #);
          myAddFragment:
            (#
               g: ^mps.fragmentGroup;
               f: ^mps.fragment;
               beforeElement: ^g.fragmentListElement;
               status: @boolean;
               
            enter (g[],f[],beforeElement[])
            <<SLOT groupeditorMyAddFragment:DoPart>>
            exit status
            #);
          getFragmentListElement:
            (# ff: ^mps.fragmentForm; fle: ^fg.fragmentListElement
            enter ff[]
            <<SLOT groupeditorGetFragmentListElement:DoPart>>
            exit fle[]
            #);
          askUndoPermission:
            (#
               value: @boolean
            <<SLOT groupeditorAskUndoPermission:DoPart>>
            exit value
            #);
          askPastePermission:
            (# ff: ^mps.fragmentForm; value: @boolean
            enter ff[]
            <<SLOT groupeditorAskPastePermission:DoPart>>
            exit value
            #);
          askInsertPermission:
            (# value: @boolean
            <<SLOT groupeditorAskInsertPermission:DoPart>>
            exit value
            #);
          undo: (#  <<SLOT groupeditorUndo:DoPart>> #);
          cutForm: doCommand
            (# ff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorCutForm:DoPart>>
            #);
          copyForm: doCommand
            (# ff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorCopyForm:DoPart>>
            #);
          pasteForm: doCommand
            (# ff,newff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorPasteForm:DoPart>>
            exit newff[]
            #);
          insertForm: doCommand
            (#
               ff: ^mps.fragmentForm;
               synCatNo: @integer;
               newff: ^mps.fragmentForm
            enter (ff[],synCatNo)
            <<SLOT groupeditorInsertForm:DoPart>>
            exit newff[]
            #);
          editProperties:
            (# 
            <<SLOT groupeditorEditProperties:DoPart>>
            #);
          editFormName:
            (# ff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorEditFormName:DoPart>>
            #);
          searchSLOT:
            (#
               ff: ^mps.fragmentForm;
               theSLOTNode: ^mps.ast
            enter ff[]
            do
               <<SLOT groupeditorSearchSlot:Descriptor>>
            exit theSLOTnode[]
            #);
          onExternCommand:
            (# command,status: ^text; 
            enter command[]
            do <<SLOT onGroupExternCommandBody:Descriptor>>
            exit status[]
            #);
          compilerSavedGroup:
            (#
               fg:
                 ^mps.fragmentGroup
            enter fg[]
            do
               <<SLOT groupeditorCompilerSavedGroup:Descriptor>>;
               
            #)
       #);
     groupEditorList: @list
       (#
          element:: groupEditor;
          findOrCreateGroupEditor:
            (# fg: ^mps.fragmentGroup; ge: ^groupEditor
            enter fg[]
            <<SLOT editorenvFindOrCreateGroupEditor:DoPart>>
            exit ge[]
            #);
          findGroupEditor:
            (#
               fg:
                 ^mps.
                    fragmentGroup;
               ge: ^groupEditor
            enter fg[]
            <<SLOT editorenvFindGroupEditor:DoPart>>
            exit ge[]
            #)
       #);
     findEditorForForm:
     (* given a fragmentform and an AST node inside it (selectedNode), 
      * find an Editor on the fragmentform and select the AST node 
      * if not found create the editor
      * id is used in the communication with Freja
      *)
       (# ff: ^mps.fragmentForm; selectedNode: ^mps.ast; fe: ^codeeditor
       enter (ff[],selectedNode[])
       do <<SLOT findEditorForFormBody:Descriptor>>
       exit fe[]
       #);
     findFormEditorId:
       (# id: @integer; fe: ^codeeditor
       enter id
       <<SLOT findFormEditorId:DoPart>>
       exit fe[]
       #);
     commObject: ^communication;
     ymerCallback: ^ymerCall;
     nonterminalsExist:
       (#
          unexpandedExist: @boolean;
          unexp: ^mps.unexpanded
       do
          <<SLOT editorenvNonterminalsExist:Descriptor>>
       exit (unexpandedExist,unexp[])
       #);
     init:
       (#  enter (mps[],betaGrammar[],UI[]) <<SLOT editorEnvInit:DoPart>> #)
  #)  

