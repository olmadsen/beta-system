ORIGIN 'codeviewer';
INCLUDE '~beta/guienv/v1.3.1/utils/simplemenu'
        'frejasifcomm'
        '~beta/containers/v1.4/sets'
        '~beta/containers/v1.4/seqContainers'
        '~beta/mps/v5.0.1/propertycfl'
        '~beta/prettygen/v5.0.1/prettyprintcfl'
        'ymercall';
BODY 'private/misc'
     'private/parsing'
     'private/derivation'
     'private/delete'
     'private/doundo'
     'private/optionals'
     'private/notification'
     'private/codeeditorbody'
     'private/updatemenus'
     'private/textediting'
     'private/editorenvbody'
     'private/editorenvsearchbody'
     'private/groupeditorbody'
     'private/historybody'
     'private/frejacommbody'
     'private/slotbody'
     'private/externalinterfacebody'
     'private/propertyeditorbody'
     'private/subeditorbody'
     'private/fragmentgrouphandlerbody'
     'private/fragmentformhandlerbody'
     'private/codeeditormenus'
     'private/search';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- windowlib: Attributes --
codeEditor: codeViewer
  (#
     no: @integer;
     edenv: ^editorEnv;
     thisGroupEditor: ^editorEnv.groupeditor;
     thePropertyEditor: ^propertyEditor;
     ffh: ^editorEnv.fragmentFormHandler;
     isAFrejaEditor,notifyFreja: @boolean;
     frejaStatusOn: @boolean;
     frejaEditTypeStatus: @text;
     frejaEditStatus: @text;
     frejaExpandStatus: @text;
     parsingPossible: @boolean;
     editingMode: @integer;
     structureMode: (#  exit 0 #);
     editLexemMode: (#  exit 1 #);
     editAndParseMode: (#  exit 2 #);
     adaptivePrettyprinting:: 
       (#
          set::  (#  do v->edenv.adaptivePrettyprinting #);
          get::  (#  do edenv.adaptivePrettyprinting->v #)
       #);
     TEexit: @
       (#
          escape: (#  exit 0 #);
          parseMode: (#  exit 1 #);
          exitMode: (#  exit 2 #);
          
       #);
     currentUndoCell: ^undoList.theCellType;
     undoElem: ^undoElemType;
     undoList: ^undoListDesc;
     undoListDesc: list (# element:: undoElemType #);
     undoing: @boolean;
     undoElemType:
       (#
          fatherRef: ^astInterface.expanded;
          sonPos: @integer;
          fragments: @edenv.partlist;
          fragmentLength,undoLength: @integer
          (* fragmentLength is the length of the undoElem, 
           undoLength is the length of the fragment to be
           replaced by the undoElem.                     *) ;
          isDeleted: @boolean
          (* if true then undoElem is deleted from the program 
           else it is replaced by another fragment           *)
       exit (fatherRef[],sonPos,fragments.elm[1][],fragmentLength)
       #);
     followSemanticLink::< 
       (#  do <<SLOT codeeditorFollowSemanticLink:Descriptor>>;  #);
     setIsReadOnly::< 
       (# 
       <<SLOT codeeditorSetIsReadOnly:DoPart>>
       #);
     onReturnKey::<  (#  <<SLOT codeeditorOnReturnKey:DoPart>> #);
     updateHistory::< 
       (# 
       <<SLOT editorenvHistoryUpdateHistory:DoPart>>
       #);
     checkFormEditorExistence::< 
       (#  <<SLOT codeeditorCheckFormEditorExistence:DoPart>> #);
     setupFormEditor::< 
       (# 
       <<SLOT codeeditorSetupFormeditor:DoPart>>
       #);
     subject05: (* some useful editor specific operations: misc.bet *)
       (#  #);
     getSynCatNo:
       (# node: ^astInterface.ast; synCatNo: @mps.nonterminalSymbol; 
       enter node[]
       do <<SLOT getSynCatNoBody:Descriptor>>
       exit synCatNo
       #);
     setSynCatNo:
       (#
          synCatNo: @mps.nonterminalSymbol;
          programNode:
            ^astInterface.expanded;
          
       enter (synCatNo,programNode[])
       do
          <<SLOT setSynCatNoBody:Descriptor>>
       #);
     findSynNameAtt:
       (# production: ^mg.prod; synCatNo: @mps.nonterminalSymbol; 
       enter production[]
       do <<SLOT findSynNameAttBody:Descriptor>>
       exit synCatNo
       #);
     subject1:
     (* parsing operations: parsing.bet *) (#  #);
     substitute:
       (# oldFragment,newFragment: ^astInterface.ast; 
       enter (oldFragment[],newFragment[])
       do <<SLOT substituteBody:Descriptor>>
       #);
     listSubstitute:
       (#
          f: @astFocus;
          theList: ^astInterface.list;
          
       enter (f,theList[])
       do
          <<SLOT listSubstituteBody:Descriptor>>
       exit f
       #);
     parseText:
       (# f: @astFocus; t: ^text; parseOK: @boolean
       enter (f,t[])
       do <<SLOT parseTextBody:Descriptor>>
       exit (parseOK,f)
       #);
     subject2: (* undo operation: undo.bet *)
       (#  #);
     makeUndoElem:
       (#
          fatherNode: ^astInterface.expanded;
          sonPos,undoLength: @integer;
          undoFocus:
          (* undoLength is the number of nodes undoFocus should be replaced 
           with when undone .                                             *)
            @astFocus;
          isDeleted: @boolean;
          
       enter (fatherNode[],sonPos,undoFocus,undoLength,isDeleted)
       do <<SLOT makeUndoElemBody:Descriptor>>
       #);
     makeAstReplacedEvent:
       (# sequence: @boolean
       enter sequence
       <<SLOT MakeAstReplaced:DoPart>>
       #);
     undo: (#  do <<SLOT undoBody:Descriptor>> #);
     subject3:
     (* derivation operations: derivation.bet *) (#  #);
     ins: @
       (#
          first: (#  exit 1 #);
          before: (#  exit 2 #);
          after: (#  exit 3 #)
       #);
     createList:
       (#
          synCatNo: @mps.nonterminalSymbol;
          prod: ^mg.prod;
          fatherNode: ^astInterface.expanded;
          isSon: @integer
       enter (synCatNo,prod[],fatherNode[],isSon)
       do <<SLOT createListBody:Descriptor>>
       #);
     new:
       (# 
       do <<SLOT newBody:Descriptor>>
       #);
     newPrivate:
       (# 
       do
          <<SLOT newPrivateBody:Descriptor>>
       #);
     expand:
       (#
          fatherNode: ^astInterface.expanded;
          isSon: @integer;
          synCatNo: @mps.nonterminalSymbol;
          
       enter (synCatNo,fatherNode[],isSon)
       do <<SLOT expandBody:Descriptor>>
       #);
     nodeExpand:
       (#
          synCatNo: @mps.nonterminalSymbol;
          newLexem: @boolean;
          
       enter (synCatNo,newLexem)
       do <<SLOT nodeExpandBody:Descriptor>>
       #);
     expandLexem:
       (# t: ^text;  enter t[] do <<SLOT expandLexemBody:Descriptor>> #);
     listInsert:
       (# command: @integer; 
       enter command
       do <<SLOT listInsertBody:Descriptor>>
       #);
     expandOptional: (#  do <<SLOT expandOptionalBody:Descriptor>> #);
     subject5:
     (* delete operations: delete.bet *) (#  #);
     deleted: @boolean;
     cut:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          doNotCopyToClipBoard: @boolean
          (* if not specified, the deleted construct 
           * will not be copied to the clipboard
           *)
       enter (doNotNotify,doNotCopyToClipBoard)
       do <<SLOT cutFragmentBody:Descriptor>>
       #);
     makeEmptyListOrOpt:
       (# 
       do
          <<SLOT makeEmptyListOrOptBody:Descriptor>>
       #);
     paste:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT pasteFragmentBody:Descriptor>>
       #);
     copy:
       (# 
       do
          <<SLOT copyFragmentBody:Descriptor>>
       #);
     subject8: (* comment operations: comment.bet *) (#  #);
     removeOptionals:
       (# node: ^astInterface.ast; 
       enter node[]
       do <<SLOT removeOptionalsBody:Descriptor>>
       #);
     insertOptionals:
       (# node: ^astInterface.ast; 
       enter node[]
       do
          <<SLOT insertOptionalsBody:Descriptor>>
       #);
     removeEmptyElement:
       (# theList: ^astInterface.list; 
       enter theList[]
       do <<SLOT removeEmptyElementBody:Descriptor>>
       #);
     removeEmptyElements:
       (# node: ^astInterface.ast; 
       enter node[]
       do
          <<SLOT removeEmptyElementsBody:Descriptor>>
       #);
     searchPrivate: @<<SLOT searchPrivate:Descriptor>>;
     searchText:
       (# t: ^text; parseOK: @boolean
       enter t[]
       do <<SLOT searchTextBody:Descriptor>>
       exit
       parseOK
       #);
     searchStructure: (#  do <<SLOT searchStructureBody:Descriptor>> #);
     searchNext:
       (# found: @boolean
       do
          <<SLOT searchNextBody:Descriptor>>
       exit found
       #);
     searchPrev:
       (# found: @boolean
       do <<SLOT searchPrevBody:Descriptor>>
       exit found
       #);
     searchName:
       (# name: ^text; found: @boolean
       enter name[]
       do <<SLOT searchNameBody:Descriptor>>
       exit
       found
       #);
     externalInterface: (* Fragmentform specific commands *) @
       (#
          undo: (#  <<SLOT externalInterfaceUndo:DoPart>> #);
          cut:
            (# 
            <<SLOT externalInterfaceCut:DoPart>>
            #);
          copy: (#  <<SLOT externalInterfaceCopy:DoPart>> #);
          paste:
            (# 
            <<SLOT externalInterfacePaste:DoPart>>
            #);
          pasteBefore: (#  <<SLOT externalInterfacePasteBefore:DoPart>> #);
          pasteAfter: (#  <<SLOT externalInterfacePasteAfter:DoPart>> #);
          before:
            (# 
            <<SLOT externalInterfaceBefore:DoPart>>
            #);
          after: (#  <<SLOT externalInterfaceAfter:DoPart>> #);
          changeFocus:
            (#
               node: ^mps.ast;
               length: @integer;
               oldNotifyFreja: @boolean
            enter (node[],length)
            <<SLOT externalInterfaceChangeFocus:DoPart>>
            exit
            (frejaEditTypeStatus[],cs.undoPermit,cs.pastePermit,
             cs.listInsertPermit,frejaExpandStatus[])
            #);
          getStatus:
            (# oldNotifyFreja: @boolean
            <<SLOT externalInterfaceGetStatus:DoPart>>
            exit
            (cs.node[],cs.length,
             frejaEditTypeStatus[],cs.undoPermit,cs.pastePermit,
             cs.listInsertPermit,frejaExpandStatus[])
            #);
          expandNormal:
            (# synCatNo: @integer
            enter synCatNo
            <<SLOT externalInterfaceExpandNormal:DoPart>>
            #);
          expandOptional:
            (# synCatNo: @integer
            enter synCatNo
            <<SLOT externalInterfaceExpandOptional:DoPart>>
            #);
          expandLexem:
            (# theText: ^text
            enter theText[]
            <<SLOT externalInterfaceExpandLexem:DoPart>>
            #);
          insertOptionals:
            (# 
            <<SLOT externalInterfaceInsertOptionals:DoPart>>
            #);
          removeOptionals:
            (#  <<SLOT externalInterfaceRemoveOptionals:DoPart>> #);
          parse:
            (#
               node: ^mps.ast;
               ok: @boolean;
               errorPos:
                 @integer;
               parseText,parseErrorText: ^text;
               oldNotifyFreja: @boolean
            enter (node[],parseText[])
            <<SLOT externalInterfaceParse:DoPart>>
            exit
            (ok,errorPos,parseErrorText[])
            #);
          search: (#  <<SLOT externalInterfaceSearch:DoPart>> #)
       #);
     onExternCommand:
       (# command,status: ^text; 
       enter command[]
       do
          <<SLOT onExternCommandBody:Descriptor>>
       exit status[]
       #);
     externCommand:
       (# command,status: ^text; 
       enter command[]
       do <<SLOT externCommandBody:Descriptor>>
       exit status[]
       #);
     closeGroup::< 
       (# 
       <<SLOT codeeditorCloseGroup:DoPart>>
       #);
     closeForm::<  (#  <<SLOT codeeditorCloseForm:DoPart>> #);
     subject9:
     (* The following virtual patterns (events) are called in the model
      every time certain changes are made.
      These patterns are specialized in the application.*) (#  #);
     noOfAstChanges,ASLimit,touched: @integer;
     resetFragmentTouch: <<SLOT resetFragmentTouchBody:Descriptor>>;
     fragmentTouched:
      <<SLOT fragmentTouchedBody:Descriptor>>;
     fragmentDetouched: <<SLOT fragmentDetouchedBody:Descriptor>>;
     autoSaveLimit:<
       (# 
       do
          <<SLOT autoSaveLimitBody:Descriptor>>;
          INNER
       #);
     autoSave: (#  <<SLOT codeeditorAutoSave:DoPart>> #);
     onPopUpButton::< 
       (# 
       do
          <<SLOT usernotificationOnPopUpButton:Descriptor>>;
          <<SLOT onPopUpButton:Descriptor>>
       #);
     onDeleteKey:: 
       (# 
       do
          true->cs.undoPermit;
          (false (*doNotNotify*) ,true (*doNotCopyToClipBoard*) )->cut
       #);
     notificationPrivate: @<<SLOT notificationPrivate:Descriptor>>;
     userPrivate:
      <<SLOT userPrivate:Descriptor>>;
     up: ^userPrivate;
     userInit: <<SLOT userInit:Descriptor>>;
     fragmentChangedEvent:
       (#
          byMe: @boolean;
          (* if true the changes have been made in this editor
           * else by another editor on the same AST
           *)
          
       enter byMe
       do
          <<SLOT fragmentChangedEventBody:Descriptor>>;
          <<SLOT usernotificationFragmentChanged:Descriptor>>;
          INNER
       #);
     newFragmentEvent:<
       (# 
       do
          <<SLOT frejaCommNewFragment:Descriptor>>;
          <<SLOT notificationNewFragment:Descriptor>>;
          
       #);
     aNewFragmentEvent: @NewFragmentEvent;
     astReplacedEvent:< fragmentChangedEvent
       (# oldAst,newAst: ^astInterface.ast; 
       enter (oldAst[],newAst[])
       do
          <<SLOT frejaCommAstReplaced:Descriptor>>;
          <<SLOT notificationAstReplaced:Descriptor>>;
          <<SLOT usernotificationAstReplaced:Descriptor>>
       #);
     anAstReplacedEvent: @astReplacedEvent;
     astReplacedElement: (# oldAst,newAst: ^astInterface.ast #);
     astReplacedList: @list
       (#
          element:: astReplacedElement;
          appendElement:
            (# oldAst,newAst: ^astInterface.ast; e: ^astReplacedElement; 
            enter (oldAst[],newAst[])
            do
               &astReplacedElement[]->e[];
               oldAst[]->e.oldAst[];
               newAst[]->e.newAst[];
               e[]->append
            #)
       #);
     astReplacedSequenceEvent:< fragmentChangedEvent
       (# rootOfSequence: ^astInterface.ast
       enter rootOfSequence[]
       do
          <<SLOT frejaCommAstReplacedSequence:Descriptor>>;
          <<SLOT notificationAstReplacedSequence:Descriptor>>;
          <<SLOT usernotificationAstReplacedSequence:Descriptor>>
       #);
     listElementInsertedEvent:< fragmentChangedEvent
       (# position: @integer; listNode: ^astInterface.expanded; 
       enter (listNode[],position)
       do
          <<SLOT frejaCommListElementInserted:Descriptor>>;
          <<SLOT notificationListElementInserted:Descriptor>>;
          <<SLOT usernotificationListElementInserted:Descriptor>>
       #);
     aListElementInsertedEvent: @listElementInsertedEvent;
     listElementsDeletedEvent:< fragmentChangedEvent
       (#
          oldElements: ^editorEnv.partList;
          listNode: ^astInterface.expanded;
          position,length: @integer
       enter (listNode[],position,length,oldElements[])
       do
          <<SLOT frejaCommListElementsDeleted:Descriptor>>;
          <<SLOT notificationListElementsDeleted:Descriptor>>;
          <<SLOT usernotificationListElementsDeleted:Descriptor>>
       #);
     aListElementsDeletedEvent: @listElementsDeletedEvent;
     listElementsReplacedEvent:< fragmentChangedEvent
       (#
          oldElements: ^editorEnv.partList;
          listNode: ^astInterface.expanded;
          position,length,newLength: @integer
       enter (listNode[],position,length,oldElements[],newLength)
       do
          <<SLOT frejaCommListElementsReplaced:Descriptor>>;
          <<SLOT notificationListElementsReplaced:Descriptor>>;
          <<SLOT usernotificationListElementsReplaced:Descriptor>>
       #);
     aListElementsReplacedEvent: @listElementsreplacedEvent;
     refreshEvent::< 
       (# 
       do
          <<SLOT notificationRefresh:Descriptor>>;
          <<SLOT usernotificationRefresh:Descriptor>>
       #);
     focusChangedEvent::< 
       (# 
       do
          <<SLOT notificationFocusChanged:Descriptor>>;
          <<SLOT frejaCommFocusChanged:Descriptor>>;
          <<SLOT usernotificationFocusChanged:Descriptor>>
       #);
     handleDoubleClick::< 
       (#  do <<SLOT usernotificationOnDoubleClick:Descriptor>> #);
     visibleInFreja:
       (#
          node:
            ^astInterface.ast;
          value: @boolean;
          
       enter node[]
       do
          <<SLOT visibleInFreja:Descriptor>>
       exit value
       #);
     expandMenuPrivate: ^expmenuprivate;
     expmenuprivate: <<SLOT expandMenuPrivate:Descriptor>>;
     updateExpandMenu:
       (# 
       do
          <<SLOT updateExpandMenuBody:Descriptor>>
       #);
     updateEditMenu: (#  do <<SLOT editMenuUpdateBody:Descriptor>> #);
     askUndoPermission::< 
       (# 
       <<SLOT codeeditorAskUndoPermission:DoPart>>
       #);
     askPastePermission::< 
       (#  <<SLOT codeeditorAskPastePermission:DoPart>> #);
     askInsertPermission::< 
       (# 
       do
          not
          (cs.node[]
             ->editorRoot.equal) and
          cs.listInsertPermit->value
       #);
     askOpenSubeditorPermission::< 
       (#  <<SLOT askOpenSubeditorPermission:DoPart>> #);
     texteditMode:
       (#
          set:
            (# 
            enter
            theSifTextEditor.
              textediting
            do
               (if theSifTextEditor.textediting then
                   edenv.setTextCursor
                else
                   edenv.setStructureCursor
               if)
            #)
       enter set
       exit theSifTextEditor.textediting
       #);
     askTexteditMode::<  (#  do textEditMode->value #);
     doUndo::<  (#  <<SLOT codeeditorDoUndo:DoPart>> #);
     doCut::< 
       (# 
       <<SLOT codeeditorDoCut:DoPart>>
       #);
     doCopy::< 
       (# 
       <<SLOT codeeditorDoCopy:DoPart>>
       #);
     doPaste::<  (#  <<SLOT codeeditorDoPaste:DoPart>> #);
     doClear::< 
       (# 
       <<SLOT codeeditorDoClear:DoPart>>
       #);
     TE:
       ^texteditingPrivate;
     texteditingPrivate: <<SLOT texteditingPrivate:Descriptor>>;
     doTextedit::< 
       (# 
       <<SLOT doTextedit:DoPart>>
       #);
     doExternalTextEdit: (#  <<SLOT doExternalTextEdit:DoPart>> #);
     checkTexteditingFinished::< 
       (# 
       do
          <<SLOT checkTexteditingFinished:Descriptor>>;
          
       #);
     doParseText::<  (#  <<SLOT doParseText:DoPart>> #);
     externalTextEdit:
       (# textBefore,textAfter: ^text
       enter textBefore[]
       <<SLOT codeeditorExternalTextEdit:DoPart>>
       exit textAfter[]
       #);
     doRevertTextedit::<  (#  <<SLOT doRevertTextediting:DoPart>> #);
     doShowTexteditCommands::< 
       (# 
       <<SLOT doShowTexteditingCommands:DoPart>>
       #);
     doInsertBefore::< 
       (#  do true->cs.undoPermit; ins.before->listInsert #);
     doInsertAfter::<  (#  do true->cs.undoPermit; ins.after->listInsert #);
     doRemoveOptionals::< 
       (#  do cs.perform (#  do current[]->removeOptionals #) #);
     doShowOptionals::< 
       (#  do cs.perform (#  do current[]->insertOptionals #) #);
     doSearch: (#  <<SLOT doSearch:DoPart>> #);
     doReplace: (#  <<SLOT doReplace:DoPart>> #);
     getFragmentgroup:: 
       (# 
       <<SLOT codeeditorGetFragmentgroup:DoPart>>
       #);
     machineType::<  (#  <<SLOT codeeditorMachineType:DoPart>> #);
     slotPrivate: ^slotPrivatePattern;
     slotPrivatePattern:
      <<SLOT slotPrivate:Descriptor>>;
     askMakeDopartSlot::<  (#  <<SLOT askMakeDopartSlot:DoPart>> #);
     askMakeDescriptorSlot::< 
       (# 
       <<SLOT askMakeDescriptorSlot:DoPart>>
       #);
     askMakeAttributesSlot::<  (#  <<SLOT askMakeAtributesSlot:DoPart>> #);
     askPasteFragmentForm::< 
       (# 
       <<SLOT askPasteFragmentForm:DoPart>>
       #);
     doMakeDopartSlot::<  (#  <<SLOT doMakeDopartSlot:DoPart>> #);
     doMakeDescriptorSlot::< 
       (# 
       <<SLOT doMakeDescriptorSlot:DoPart>>
       #);
     doMakeAttributesSlot::<  (#  <<SLOT doMakeAttributesSlot:DoPart>> #);
     doPasteFragmentForm::< 
       (# 
       <<SLOT doPasteFragmentForm:DoPart>>
       #);
     doFillSlot::<  (#  <<SLOT doFillSlot:DoPart>> #);
     doFillAllSlots::< 
       (#  <<SLOT doFillAllSlots:DoPart>> #);
     doSetImplementationFragment::< 
       (#  <<SLOT doSetImplementationFragment:DoPart>> #);
     doUnsetImplementationFragment::<
       (#  <<SLOT doUnsetImplementationFragment:DoPart>> #);
     doSetSLOTNamePrefix::< 
       (# 
       <<SLOT doSetSLOTNameprefix:DoPart>>
       #);
     doUnsetSLOTNamePrefix::<  (#  <<SLOT doUnsetSLOTNameprefix:DoPart>> #);
     doHideImplementation::<  (#  <<SLOT doHideImplementation:DoPart>> #);
     openSubeditor::< 
       (# 
       <<SLOT subeditorOpenSubeditor:DoPart>>
       #);
     createSubeditor::<  (#  <<SLOT subeditorCreateSubeditor:DoPart>> #);
     subeditors: @list
       (# element::< codeeditor #);
     close::< 
       (# 
       <<SLOT codeeditorclose:DoPart>>
       #);
     init::<  (#  <<SLOT codeeditorinit:DoPart>> #)
  #);
mysimplemenu: menu
(* Special menu type with interdependant check marks, some other 
 * extra features, and a few code saving patterns, that allow
 * for simple specification of a menu.
 *
 * Example:
 * 
 *  FileMenu: @simplemenu
 *    (# inew:    @item(# onSelect:: (# do NewFile    #)#);
 *       iopen:   @item(# onSelect:: (# do OpenFile   #)#);
 *       iclose:  @item(# onSelect:: (# do Iconify    #)#);
 *       isave:   @item(# onSelect:: (# do SaveFile   #)#);
 *       isaveas: @item(# onSelect:: (# do SaveFileAs #)#);
 *       iexport: @item(# onSelect:: (# do Export     #)#);
 *       iprint:  @item(# onSelect:: (# do Print      #)#);
 *       iquit:   @item(# onSelect:: (# do Quit       #)#);
 *            
 *       open:: 
 *         (# 
 *         do ('New...',    'n') -> inew.newkey;  false -> inew.enabled;
 *            ('Open...',   'o') -> iopen.newkey; false -> iopen.enabled;
 *            ('Close',     'w') -> iclose.newkey;
 *            newseparator;
 *            ('Save',      's') -> isave.newkey; false -> isave.enabled;
 *            ('Save As...')     -> isaveas.new;  false -> isaveas.enabled;
 *            newseparator;
 *            ('Print...',  'p') -> iprint.newkey; 
 *            ('Export...', 'e') -> iexport.newkey; 
 *            newseparator;
 *            ('Quit',      'q') -> iquit.newkey;
 *         #)
 *     #);
 * 
 *  ShapeMenu: @simplemenu              	    
 *    (# ievenodd: @radioitem
 *         (# onSelect:: (# do EvenOddRule->SetFillRule #)#);
 *       iwinding: @radioitem
 *         (# onSelect:: (# do WindingRule->SetFillRule #)#);
 *       open:: 
 *         (# 
 *         do 'Even-Odd Fillrule'->ievenodd.new; 
 *            'Winding Fillrule'->iwinding.new;
 *         #);
 *    #);
 *)
  (#
     item: menuitem
       (#
          enabled: @boolean
          (* Set to true or false to enable or disable THIS(item) *) ;
          onSelect:< object (* Shortcut for eventhandler.onSelect *) ;
          onStatus:< booleanValue (* Shortcut for eventhandler.onStatus *)
            (#  do enabled->value; INNER #);
          new: (* Open and append THIS(Item) with label itemtext *)
            (# itemtext: ^text; 
            enter itemtext[]
            do
               true->enabled;
               open;
               (if itemtext[] <> none then itemtext[]->name if);
               THIS(item)[]->append;
               INNER ;
               
            #);
          newkey: new (* Also add key quivalent *)
            (# equiv: @char enter equiv do equiv->key #);
          eventhandler::< 
            (#
               onSelect::<  (#  do THIS(item).onSelect; INNER #);
               onStatus::<  (#  do THIS(item).onStatus->value; INNER #);
               
            #);
          
       #);
     noOfRadioGroups:< integervalue
     (* The number of independant groups of radioitems.
      * Default 1.
      *) (#  do 1->value; INNER #);
     radioitem: item
     (* Special item, that is un-checked when another radioitem
      * in the radiogroup indicated by "checkgroup" is selected. 
      *)
       (#
          checkgroup: @integer
          (* The group of items THIS(item) is dependant on. default 1. *) ;
          open::<  (#  do 1->checkgroup; INNER ;  #);
          onSelect::< 
            (#  do THIS(radioitem)[]->changechecked; INNER ;  #);
          
       #);
     toggleitem: item
     (* Special item that is checked evey second time it is selected *)
       (# onSelect::<  (#  do not checked->checked; INNER ;  #) #);
     newseparator: (* Open and append a separator to THIS(simplemenu) *)
       (# 
       do &separator[]->private.s[]; private.s.open; private.s[]->append; 
       #);
     new:
     (* Open THIS(simplemenu) and append it to THIS(MenuBar) 
      * with label menutext.
      *)
       (# menutext: ^text; 
       enter menutext[]
       do
          open;
          (if menutext[] <> none then menutext[]->name if);
          (* THIS(mysimplemenu)[]->THIS(menubar).append *)
          
       #);
     changechecked: (* Explicitly change the checked item to be newitem *)
       (# newitem: ^radioitem
       enter newitem[]
       do
          (if private.oldChecked[newitem.checkgroup][] <> newitem[] then
              (if private.oldChecked[newitem.checkgroup][] <> none then
                  false->private.oldChecked[newitem.checkgroup].checked; 
              if);
              newitem[]->private.oldChecked[newitem.checkgroup][];
              true->newitem.checked;
              
          if)
       #);
     <<SLOT SimpleMenuLib:Attributes>>;
     private: @
       (#
          oldChecked: [noOfRadioGroups]
          ^radioitem;
          s: ^separator;
          
       #);
     
  #);
codeeditorEditMenu: mysimplemenu
  (#
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if formEditorExists then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     useExternalTextEditor: @boolean;
     attach: (#  enter cfe[] #);
     writeStatus:< (# t: ^text enter t[] do INNER #);
     formEditorExists:<
       (# value: @boolean
       do INNER ; (if cfe[] <> none then true->value if)
       exit value
       #);
     allowCommand:
       (# value: @boolean
       do
          (if formEditorExists then
              not cfe.texteditMode and not cfe.isReadOnly->value
          if)
       exit value
       #);
     iUndo: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askUndoPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doUndo #)
       #);
     iCut: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doCut;  #)
       #);
     iCopy: @item
       (#
          onStatus:: 
            (#  do formEditorExists and not cfe.textEditMode->value #);
          onSelect::  (#  do cfe.doCopy #)
       #);
     iPaste: @item
       (#
          onStatus:: 
            (# 
            do
               (if formeditorExists and not cfe.texteditMode then
                   cfe.askPastePermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doPaste #)
       #);
     iClear: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doClear;  #)
       #);
     iTextedit: @item
       (#
          onStatus:: 
            (# 
            do
               (if formEditorExists then
                   (if cfe.isReadOnly then
                       'Write protected'->writeStatus
                    else
                       ''->writeStatus
                   if)
               if);
               (if formEditorExists and not cfe.isReadOnly then
                   (if cfe.askTextEditMode then
                       'Parse Text'->THIS(item).name
                    else
                       'Edit Text'->THIS(item).name
                   if);
                   true->value
                else
                   false->value
               if)
            #);
          onSelect:: 
            (# 
            do
               (if cfe.askTextEditMode then
                   cfe.doParseText; ''->writestatus
                else
                   cfe.doTextEdit; 'Textediting Mode'->writestatus
               if);
               
            #)
       #);
     iExternalTextEdit: @item
       (#
          onStatus:: 
            (#  <<SLOT editMenuiExternalTextEditOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuiExternalTextEditOnSelect:DoPart>>
            #)
       #);
     iRevertTextEdit: @item
       (#
          onStatus:: 
            (# 
            do
               (if formEditorExists and not cfe.isReadOnly then
                   cfe.askTextEditMode->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doRevertTextEdit; ''->writestatus #)
       #);
     iShowTexteditCommands: @item
       (#
          onStatus:: 
            (# 
            do
               (if formEditorExists and not cfe.isReadOnly then
                   cfe.askTexteditMode->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doShowTexteditCommands;  #)
       #);
     iInsertBefore: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askInsertPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doInsertBefore #)
       #);
     iInsertAfter: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askInsertPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doInsertAfter #)
       #);
     iRemoveOptionals: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doRemoveOptionals #)
       #);
     iShowOptionals: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doShowOptionals #)
       #);
     iSubeditor: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askOpenSubeditorPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.openSubeditor #)
       #);
     iSetIsReadOnly: @item
       (#
          onStatus:: 
            (# 
            do
               formeditorExists and not cfe.texteditMode->value;
               (if formEditorExists then
                   cfe.isReadOnly->checked;
                   (if cfe.isReadOnly then
                       'Write protected'->writeStatus
                    else
                       ''->writeStatus
                   if)
               if)
            #);
          onSelect:: 
            (# 
            do
               (if cfe.isReadOnly then
                   (if cfe.thisGroupEditor[] <> none then
                       (if cfe.thisGroupEditor.groupFileWriteable then
                           false->cfe.setIsReadOnly; ''->writeStatus
                       if)
                   if)
                else
                   true->cfe.setIsReadOnly; 'Write protected'->writeStatus
               if)
            #)
       #);
     open::<  (#  <<SLOT editMenuOpen:DoPart>> #);
     
  #);
codeeditorViewMenu: mysimplemenu
  (#
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if allowCommand then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     betaSif: @boolean;
     attach: (#  enter cfe[] #);
     formEditorExists:<
       (# value: @boolean
       do INNER ; (if cfe[] <> none then true->value if)
       exit value
       #);
     allowCommand:
       (# value: @boolean
       do (if formEditorExists then not cfe.texteditMode->value if)
       exit value
       #);
     iAbstract: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doAbstract #)
       #);
     iAbstractRecursively: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doAbstractRecursively;  #)
       #);
     iOverview: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doOverview;  #)
       #);
     iDetail: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doDetail #)
       #);
     iDetailRecursively: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doDetailRecursively;  #)
       #);
     iSearch: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doSearch #)
       #);
     iReplace: @item
       (#
          onStatus:: 
            (# 
            do
               (if formEditorExists then
                   not cfe.texteditMode and not cfe.isReadOnly->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doReplace #)
       #);
     iFollowSemanticLink: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.cs.hasSemanticLink->value
                else
                   false->value
               if)
            #);
          onSelect:: 
            (#  do (cfe.cs.node[],false)->cfe.followSemanticLink #)
       #);
     iFollowSLOTlink: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.cs.isSlot->value
                else
                   false->value
               if)
            #);
          onSelect:: 
            (#  do cfe.doCommand (#  do cfe.makeSearchSlotBinding #) #)
       #);
     iFollowFragmentLink: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect:: 
            (# node: ^astInterface.ast
            <<SLOT viewMenuFollowSLOTLinkonSelect:DoPart>>
            #)
       #);
     iZoomIn: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand
                then
                   (if cfe.thisGroupEditor[] <> none then
                       not cfe.thisGroupEditor.isAfrejaEditor and cfe.askZoomIn
                         ->value
                    else
                       cfe.askZoomIn->value
                   if)
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doZoomIn #)
       #);
     iZoomOut: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   (if cfe.thisGroupEditor[] <> none then
                       not cfe.thisGroupEditor.isAfrejaEditor and cfe.askZoomOut
                         ->value
                    else
                       cfe.askZoomOut->value
                   if)
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doZoomOut #)
       #);
     iZoomFullEditor: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   (if cfe.thisGroupEditor[] <> none then
                       not cfe.thisGroupEditor.isAfrejaEditor and
                       cfe.askZoomFullEditor->value
                    else
                       cfe.askZoomFullEditor->value
                   if)
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doZoomFullEditor #)
       #);
     iReprettyprint: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doReprettyprint;  #)
       #);
     iAdaptivePrettyprinting: @item
       (#
          onStatus:: 
            (# 
            do
               allowCommand->value;
               (if formEditorExists then
                   cfe.edenv.adaptivePrettyPrinting->checked
               if)
            #);
          onSelect:: 
            (# 
            do
               not cfe.edenv.adaptivePrettyprinting
                 ->cfe.edenv.adaptivePrettyPrinting;
               
            #)
       #);
     iShowAstCS: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.cs.node[]->cfe.doShowAst;  #)
       #);
     open::<  (#  <<SLOT viewMenuOpen:DoPart>> #);
     
  #);
codeeditorSLOTsMenu: mysimplemenu
  (#
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if allowCommand then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     attach: (#  enter cfe[] #);
     formeditorExists:<
       (# value: @boolean
       do INNER ; (if cfe[] <> none then not cfe.texteditMode->value if)
       exit value
       #);
     allowCommand:
       (# value: @boolean
       do
          (if formEditorExists and not cfe.texteditMode and not cfe.isReadOnly
           then
              (if cfe.thisGroupEditor[] <> none then
                  not cfe.thisGroupEditor.isAfrejaEditor->value
               else
                  true->value
              if)
          if)
       exit value
       #);
     iMakeDoPartSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askMakeDoPartSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doMakeDoPartSlot;  #)
       #);
     iMakeDescriptorSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askMakeDescriptorSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doMakeDescriptorSlot;  #)
       #);
     iMakeAttributesSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askMakeAttributesSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doMakeAttributesSlot;  #)
       #);
     iPasteFragmentForm: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askPasteFragmentForm->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doPasteFragmentForm;  #)
       #);
     iSetImplementationFragment: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuSetImplFragOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cfe.
                 doSetImplementationFragment;
               
            #)
       #);
     iUnsetImplementationFragment: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuUnsetImplFragOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cfe.
                 doUnsetImplementationFragment;
               
            #)
       #);
     iSetSLOTnamePrefix: @item
       (#
          onStatus:: 
            (#  <<SLOT SLOTsMenuSetSLOTnamePrefixOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cfe.
                 doSetSLOTNamePrefix;
               
            #)
       #);
     iUnsetSLOTnamePrefix: @item
       (#
          onStatus:: 
            (#  <<SLOT SLOTsMenuUnsetSLOTnamePrefixOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cfe.
                 doUnsetSLOTNamePrefix;
               
            #)
       #);
     iHideImpl: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuHideImplOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cfe.
                 doHideImplementation;
               
            #)
       #);
     iFillSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.cs.isSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doFillSlot;  #)
       #);
     iFillAllSlots: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doFillAllSlots #)
       #);
     open::<  (#  <<SLOT SLOTsMenuOpen:DoPart>> #);
     
  #);
propertyEditor: codeeditor
  (#
     theGroupEditor: ^editorEnv.groupeditor;
     updateProperties: doCommand
       (# byMe: @boolean
       enter byMe
       <<SLOT propertyeditorUpdateProperties:DoPart>>
       #);
     astReplacedEvent::<  (#  <<SLOT propertyeditorAstReplaced:DoPart>> #);
     astReplacedSequenceEvent::< 
       (# 
       <<SLOT propertyeditorAstReplacedSequence:DoPart>>
       #);
     listElementInsertedEvent::< 
       (#  <<SLOT propertyeditorListElementInserted:DoPart>> #);
     listElementsDeletedEvent::< 
       (#  <<SLOT propertyeditorListElementsDeleted:DoPart>> #);
     listElementsReplacedEvent::< 
       (#  <<SLOT propertyeditorListElementsReplaced:DoPart>> #);
     
  #);
editorenv: sifEditorEnv
  (#
     mps: ^astInterface;
     betaGrammar:
     (*^astInterface.treelevel;*) ^astInterface.beta;
     betaGram: (* contains all the syntactic category numbers *) @grammar;
     propertyGrammar: ^astInterface.treeLevel;
     prettyprintGrammar: ^astInterface.treeLevel;
     mg: ^astInterface.metagrammar;
     mpsErrorReporter: ^mps.errorReporter;
     UI: ^guienv;
     setWaitCursor: (#  <<SLOT editorenvSetWaitCursor:DoPart>> #);
     setStructureCursor:
       (# 
       <<SLOT editorenvSetStructureCursor:DoPart>>
       #);
     rightButtonCursor: ^guienv.cursor;
     setRightButtonCursor:
       (#  <<SLOT editorenvSetRightButtonCursor:DoPart>> #);
     textCursor: ^guienv.cursor;
     setTextCursor:
       (# 
       <<SLOT editorenvSetTextCursor:DoPart>>
       #);
     initiator: ^text;
     globalWriteProtection: @boolean;
     setGlobalWriteProtection:
       (# value: @boolean
       enter value
       <<SLOT editorenvSetGlobalWriteProtection:DoPart>>
       #);
     contractOnOpen,
       onlyNotifyFreja: @boolean;
     adaptivePrettyprinting: @boolean;
     useExternalTextEditor: @boolean;
     doQuit: @boolean;
     onGoingRecovery: @boolean;
     BETAsif: @boolean;
     openingFrejaEditor: @boolean;
     partList: (# elm: [50] ^astInterface.ast #);
     clip: ^clipBoard;
     clipBoard:
       (#
          synCatNo: @mps.nonterminalSymbol;
          fragments: @partList;
          length: @integer;
          
       #);
     clippedff: ^astInterface.fragmentForm;
     makeSLOTfrag: ^astInterface.fragmentForm;
     makeSLOTtype: @integer;
     fillSLOTfrag: ^astInterface.fragmentForm;
     fillSLOTtype: @integer;
     clippedfrag: ^astInterface.fragmentForm;
     clippedfragtype: @integer;
     implementationGroupEditor: ^groupEditor;
     slotNamePrefix: @text;
     formEditorNo: @integer;
     nextEditorId:
       (#  do formEditorNo+1->formEditorNo exit formEditorNo #);
     doCommand:
       (#  do setWaitCursor; INNER doCommand; setStructureCursor #);
     metaGrammarInit:
       (#  do <<SLOT editorenvMetaGrammarInit:Descriptor>> #);
     history: @
       (#
          historyList: list
            (# element:: mps.ast; 
            #);
          h: ^historyList;
          init:
            (# 
            do
               &historyList[]->h[];
               h.init;
               true->doUpdate
            #);
          currentCell:
            ^h.theCellType;
          private:
            @<<SLOT editorenvhistoryprivate:Descriptor>>;
          current:
            (# node: ^astInterface.ast
            <<SLOT editorenvHistoryCurrent:DoPart>>
            exit node[]
            #);
          add:
            (# node: ^astInterface.ast
            enter node[]
            <<SLOT editorenvHistoryAdd:DoPart>>
            #);
          remove:
            (# node: ^astInterface.ast
            enter node[]
            <<SLOT editorenvHistoryRemove:DoPart>>
            #);
          backPossible:
            (#
               node: ^astInterface.ast;
               value: @boolean
            enter node[]
            <<SLOT editorEnvHistoryBackPossible:DoPart>>
            exit value
            #);
          back: doCommand
            (# currentNode,newNode: ^astInterface.ast
            enter currentNode[]
            <<SLOT editorEnvHistoryBack:DoPart>>
            exit newNode[]
            #);
          forwardPossible:
            (#
               node: ^astInterface.ast;
               value: @boolean
            enter node[]
            <<SLOT editorEnvHistoryForwardPossible:DoPart>>
            exit value
            #);
          forward: doCommand
            (# currentNode,newNode: ^astInterface.ast
            enter currentNode[]
            <<SLOT editorenvHistoryForward:DoPart>>
            exit newNode[]
            #);
          doUpdate: @boolean;
          protect:
            (# 
            do
               <<SLOT editorenvHistoryProtect:Descriptor>>
            #)
       #);
     trace: [20] @boolean;
     switch: [20] @boolean;
     editorenvPrivate: @<<SLOT editorenvPrivate:Descriptor>>;
     uep:
       @<<SLOT userEditorenvPrivate:Descriptor>>;
     new: doCommand
       (#
          theBrowser: ^object;
          grammarName,groupName,formName: ^text;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],grammarName[],groupName[],formName[])
       <<SLOT editorenvNew:DoPart>>
       exit fg[]
       #);
     newBetaProgram: doCommand
       (#
          theBrowser: ^object;
          name: ^text;
          isAFrejaEditor: @boolean;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],name[],isAFrejaEditor)
       <<SLOT editorEnvNewBetaProgram:DoPart>>
       exit fg[]
       #);
     newBetaLibrary: doCommand
       (#
          theBrowser: ^object;
          name: ^text;
          isAFrejaEditor: @boolean;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],name[],isAFrejaEditor)
       <<SLOT editorenvNewBetaLibrary:DoPart>>
       exit fg[]
       #);
     openForm:
       (#
          name: ^text;
          index: @integer;
          ff: ^astInterface.fragmentForm;
          node: ^astInterface.ast
       enter (name[],index)
       do <<SLOT openFormBody:Descriptor>>
       exit (ff[],node[])
       #);
     saveAll:
       (# 
       <<SLOT editorenvSaveAll:DoPart>>
       #);
     makeNewTextFile:
       (# fg: ^astInterface.fragmentGroup
       enter fg[]
       do <<SLOT editorenvMakeNewTextFile:Descriptor>>; 
       #);
     searchTextDialog:
       (#
          fg:
            ^astInterface.
               fragmentGroup;
          ff: ^astInterface.fragmentForm;
          startNode: ^astInterface.ast;
          found:<
            (# foundNode: ^astInterface.ast
            enter foundNode[]
            do INNER
            #);
          notFound:< (# searchText: ^text enter searchText[] do INNER #)
       enter (fg[],ff[],startNode[])
       do <<SLOT editorenvSearchTextDialog:Descriptor>>
       #);
     searchPrivate:
       @<<SLOT editorenvSearchPrivate:Descriptor>>;
     searchText:
       (#
          t: ^text;
          direction: @integer;
          fg: ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          startNode,node: ^astInterface.ast;
          found:<
            (# foundNode: ^astInterface enter foundNode[] do INNER #);
          notFound:< object;
          
       enter (t[],direction,fg[],ff[],startNode[])
       do <<SLOT editorenvSearchText:Descriptor>>
       exit node[]
       #);
     scanGroupForText:
       (#
          t: ^text;
          direction: @integer;
          fg:
            ^astInterface.fragmentGroup;
          ff:
            ^astInterface.fragmentForm;
          current: ^astInterface.ast;
          
       enter (t[],fg[],ff[])
       do
          <<SLOT editorenvScanGroupForText:Descriptor>>
       #);
     groupEditor:
       (#
          fg: ^astInterface.fragmentGroup;
          no: @integer;
          theBrowser: ^object;
          groupFileWriteable: @boolean;
          isReadOnly: @boolean;
          setIsReadOnly:
            (# value: @boolean
            enter value
            <<SLOT groupeditorSetIsReadOnly:DoPart>>
            #);
          grammarName: ^text;
          touched: @integer;
          isAFrejaEditor: @boolean;
          needToUpdateTextFile:
            @boolean;
          autoSaveFileExists: @boolean;
          thePropertyEditor: ^codeeditor;
          fgh: ^fragmentGroupHandler;
          formEditorList: @list
            (#
               element:: codeeditor;
               findOrCreateEditor:
                 (# ff: ^astInterface.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindOrCreateEditor:DoPart>>
                 exit fe[]
                 #);
               findEditor:
                 (# ff: ^astInterface.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindEditor:DoPart>>
                 exit fe[]
                 #);
               findEditorId:
                 (# id: @integer; fe: ^codeviewer
                 enter id
                 <<SLOT groupeditorFormeditorListFindEditorId:DoPart>>
                 exit fe[]
                 #)
            #);
          closeGroup: booleanValue
            (#  <<SLOT groupeditorCloseGroup:DoPart>> #);
          save: doCommand
            (#
               doUpdateTextFile,doGC,OK:
                 @boolean
            enter (doUpdateTextFile,doGC)
            <<SLOT groupEditorSave:DoPart>>
            exit OK
            #);
          saveAs: doCommand
            (# newName: ^text
            <<SLOT groupeditorSaveAs:DoPart>>
            exit
            newName[]
            #);
          saveAbstract: doCommand
            (#  <<SLOT groupeditorSaveAbstract:DoPart>> #);
          recover: doCommand
            (# 
            <<SLOT groupeditorRecover:DoPart>>
            #);
          revert: doCommand (#  <<SLOT groupeditorRevert:DoPart>> #);
          autoSave:
            (# 
            <<SLOT groupeditorAutoSave:DoPart>>
            #);
          resetGroupTouch:
            (#  <<SLOT groupeditorResetGroupTouch:DoPart>> #);
          groupTouched:
            (# 
            <<SLOT groupeeditorGroupTouched:DoPart>>
            #);
          groupDetouched: (#  <<SLOT groupeditorGroupDetouched:DoPart>> #);
          myAddFragment:
            (#
               g: ^astInterface.fragmentGroup;
               f: ^astInterface.fragment;
               beforeElement: ^g.fragmentListElement;
               status: @boolean;
               
            enter (g[],f[],beforeElement[])
            <<SLOT groupeditorMyAddFragment:DoPart>>
            exit status
            #);
          getFragmentListElement:
            (# ff: ^astInterface.fragmentForm; fle: ^fg.fragmentListElement
            enter ff[]
            <<SLOT groupeditorGetFragmentListElement:DoPart>>
            exit fle[]
            #);
          askUndoPermission:
            (#
               value: @boolean
            <<SLOT groupeditorAskUndoPermission:DoPart>>
            exit value
            #);
          askPastePermission:
            (# ff: ^astInterface.fragmentForm; value: @boolean
            enter ff[]
            <<SLOT groupeditorAskPastePermission:DoPart>>
            exit value
            #);
          askInsertPermission:
            (# value: @boolean
            <<SLOT groupeditorAskInsertPermission:DoPart>>
            exit value
            #);
          undo: (#  <<SLOT groupeditorUndo:DoPart>> #);
          cutForm: doCommand
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorCutForm:DoPart>>
            #);
          copyForm: doCommand
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorCopyForm:DoPart>>
            #);
          pasteForm: doCommand
            (#
               ff,newff:
                 ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorPasteForm:DoPart>>
            exit newff[]
            #);
          insertForm: doCommand
            (#
               ff: ^astInterface.fragmentForm;
               synCatNo: @integer;
               newff: ^astInterface.fragmentForm
            enter (ff[],synCatNo)
            <<SLOT groupeditorInsertForm:DoPart>>
            exit newff[]
            #);
          editProperties:
            (# 
            <<SLOT groupeditorEditProperties:DoPart>>
            #);
          createPropertyEditor:
            (# theSifTextEditor: ^sifTexteditor
            enter theSifTexteditor[]
            <<SLOT groupeditorCreatePropertyEditor:DoPart>>
            #);
          editFormName:
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorEditFormName:DoPart>>
            #);
          searchSLOT:
            (#
               ff:
                 ^astInterface.
                    fragmentForm;
               theSLOTNode: ^astInterface.ast
            enter ff[]
            do <<SLOT groupeditorSearchSlot:Descriptor>>
            exit theSLOTnode[]
            #);
          onExternCommand:
            (#
               command,status: ^text; 
            enter command[]
            do
               <<SLOT onGroupExternCommandBody:Descriptor>>
            exit status[]
            #);
          compilerSavedGroup:
            (# fg: ^astInterface.fragmentGroup
            enter fg[]
            do <<SLOT groupeditorCompilerSavedGroup:Descriptor>>; 
            #);
          groupeditorNotificationPrivate:
            @<<SLOT groupeditorNotificationPrivate:Descriptor>>;
          groupChangedEvent:
            (# byMe: @boolean
            enter byMe
            <<SLOT groupeditorGroupChanged:DoPart>>
            #);
          propertiesChanged:
           groupChangedEvent
            (# 
            do
               <<SLOT frejacommPropertiesChanged:Descriptor>>;
               <<SLOT groupeditorPropertiesChanged:Descriptor>>
            #);
          fragmentChanged: groupChangedEvent
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            do
               <<SLOT frejacommFragmentChanged:Descriptor>>;
               <<SLOT groupeditorFragmentChanged:Descriptor>>
            #);
          fragmentInserted: groupChangedEvent
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            do
               <<SLOT frejacommFragmentInserted:Descriptor>>;
               <<SLOT groupeditorFragmentInserted:Descriptor>>
            #);
          fragmentDeleted: groupChangedEvent
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            do
               <<SLOT frejacommFragmentDeleted:Descriptor>>;
               <<SLOT groupeditorFragmentDeleted:Descriptor>>
            #);
          groupSaved:
            (# byMe: @boolean
            enter byMe
            <<SLOT groupeditorGroupSaved:DoPart>>
            #);
          
       #);
     groupEditorList: @list
       (#
          element:: groupEditor;
          CreateGroupEditor:
            (#
               theBrowser: ^object;
               fg:
                 ^astInterface.
                    fragmentGroup;
               readOnly: @boolean;
               ge: ^groupEditor
            enter (theBrowser[],fg[],readOnly)
            <<SLOT editorenvCreateGroupEditor:DoPart>>
            exit ge[]
            #);
          findOrCreateGroupEditor:
            (#
               theBrowser: ^object;
               fg: ^astInterface.fragmentGroup;
               readOnly: @boolean;
               ge: ^groupEditor
            enter (theBrowser[],fg[],readOnly)
            <<SLOT editorenvFindOrCreateGroupEditor:DoPart>>
            exit ge[]
            #);
          findGroupEditor:
            (#
               theBrowser: ^object;
               fg: ^astInterface.fragmentGroup;
               ge: ^groupEditor
            enter (theBrowser[],fg[])
            <<SLOT editorenvFindGroupEditor:DoPart>>
            exit ge[]
            #)
       #);
     fragmentDefaultName:
       (# f: @file
       enter f.name
       exit f.entry.path.name.prefix
       #);
     showEditors:
       (# 
       <<SLOT editorenvShowEditors:DoPart>>
       #);
     findOrCreateGroupEditor: groupEditorList.findOrCreateGroupEditor
       (#  #);
     createGroupEditor: groupEditorList.CreateGroupEditor (#  #);
     createFormEditor:
       (#
          ff: ^astInterface.fragmentForm;
          theEditorRoot,initialSelection: ^astInterface.ast;
          theSifTextEditor: ^sifTexteditor;
          ge: ^groupEditor;
          fe: ^codeeditor
       enter (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
       do <<SLOT editorEnvCreateFormEditor:Descriptor>>
       exit fe[]
       #);
     findOrCreateFormEditor:
       (#
          ff:
            ^astInterface.
               fragmentForm;
          theEditorRoot,initialSelection: ^astInterface.ast;
          theSifTextEditor: ^sifTexteditor;
          ge: ^groupEditor;
          fe: ^codeeditor
       enter (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
       do <<SLOT editorEnvFindOrCreateFormEditor:Descriptor>>
       exit fe[]
       #);
     findEditorForForm:
     (* given a fragmentform and an AST node inside it (selectedNode), 
      * find an Editor on the fragmentform and select the AST node 
      * if not found create the editor
      * id is used in the communication with Freja
      *)
       (#
          ff: ^astInterface.fragmentForm;
          selectedNode: ^astInterface.ast;
          fe: ^codeeditor
       enter (ff[],selectedNode[])
       do <<SLOT findEditorForFormBody:Descriptor>>
       exit fe[]
       #);
     findFormEditorId:
       (# id: @integer; fe: ^codeeditor
       enter id
       <<SLOT findFormEditorId:DoPart>>
       exit fe[]
       #);
     frejaInterface: ^frejaExternalInterface;
     ymerCallback: ^ymerCall;
     nonterminalsExist:
       (#
          unexpandedExist: @boolean;
          unexp: ^astInterface.unexpanded
       do
          <<SLOT editorenvNonterminalsExist:Descriptor>>
       exit (unexpandedExist,unexp[])
       #);
     fgHandler: @list
       (#
          element:: fragmentGroupHandler;
          subscribe:
            (# ge: ^groupEditor
            enter ge[]
            <<SLOT fragmentGroupHandlerSubscribe:DoPart>>
            #);
          unsubscribe:
            (# ge: ^groupEditor
            enter ge[]
            <<SLOT fragmentGroupHandlerUnsubscribe:DoPart>>
            #)
       #);
     fragmentGroupHandler:
       (#
          fg: ^astInterface.fragmentGroup;
          no: @integer;
          groupEditors: @list (# element:: groupEditor #);
          groupChangedEvent:
            (# byEditor: ^groupEditor
            enter byEditor[]
            <<SLOT fragmentGroupHandlerGroupChanged:DoPart>>
            #);
          propertiesChanged:
           groupChangedEvent
            (#  <<SLOT fragmentGroupHandlerPropertiesChanged:DoPart>> #);
          fragmentChanged:
           groupChangedEvent
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT fragmentGroupHandlerFragmentChanged:DoPart>>
            #);
          fragmentInserted:
           groupChangedEvent
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT fragmentGroupHandlerFragmentInserted:DoPart>>
            #);
          fragmentDeleted:
           groupChangedEvent
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT fragmentGroupHandlerFragmentDeleted:DoPart>>
            #);
          groupSaved:
            (#
               byEditor:
                 ^groupEditor
            enter byEditor[]
            <<SLOT fragmentGroupHandlerGroupSaved:DoPart>>
            #)
       #);
     ffHandler: @list
       (#
          element::
           fragmentFormHandler;
          subscribe:
            (# fe: ^codeeditor
            enter fe[]
            <<SLOT fragmentFormHandlerSubscribe:DoPart>>
            #);
          unsubscribe:
            (# fe: ^codeeditor
            enter fe[]
            <<SLOT fragmentFormHandlerUnsubscribe:DoPart>>
            #);
          externalSubscribe:
            (# remoteffh,localffh: ^externalFragmentFormHandler
            enter remoteffh[]
            <<SLOT externalfragmentFormHandlerSubscribe:DoPart>>
            exit localffh[]
            #);
          externalUnsubscribe:
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT externalfragmentFormHandlerUnsubscribe:DoPart>>
            #)
       #);
     fragmentFormHandler:
       (#
          ff: ^astInterface.fragmentForm;
          no: @integer;
          effh: ^externalFragmentFormHandler;
          formEditors: @list (# element:: codeEditor #);
          fragmentChangedEvent:
            (# byEditor: ^codeEditor
            enter byEditor[]
            <<SLOT fragmentFormHandlerfragmentChanged:DoPart>>
            #);
          astFocus:
            (#
               node:
                 ^astInterface
                  .ast;
               length,subCommentInx1,subCommentInx2: @integer;
               
            enter (node[],length,subCommentInx1,subCommentInx2)
            exit (node[],length,subCommentInx1,subCommentInx2)
            #);
          refreshEvent:
            (# byEditor: ^codeEditor; node: ^astInterface.ast
            enter (byEditor[],node[])
            <<SLOT fragmentFormHandlerRefresh:DoPart>>
            #);
          focusChangedEvent:
            (# byEditor: ^codeEditor; newCS: @astFocus; 
            enter (byEditor[],newCS)
            <<SLOT fragmentFormHandlerFocusChanged:DoPart>>
            #);
          astReplacedEvent: fragmentChangedEvent
            (# oldAst,newAst: ^astInterface.ast; 
            enter (oldAst[],newAst[])
            <<SLOT fragmentFormHandlerAstReplaced:DoPart>>
            #);
          anAstReplacedEvent: @astReplacedEvent;
          astReplacedSequenceEvent: fragmentChangedEvent
            (# rootOfSequence: ^astInterface.ast
            enter rootOfSequence[]
            <<SLOT fragmentFormHandlerAstReplacedSequence:DoPart>>
            #);
          listElementInsertedEvent: fragmentChangedEvent
            (# position: @integer; listNode: ^astInterface.expanded; 
            enter (listNode[],position)
            <<SLOT fragmentFormHandlerListElementInserted:DoPart>>
            #);
          aListElementInsertedEvent: @listElementInsertedEvent;
          listElementsDeletedEvent: fragmentChangedEvent
            (#
               oldElements: ^editorEnv.partList;
               listNode: ^astInterface.expanded;
               position,length: @integer
            enter (listNode[],position,length,oldElements[])
            <<SLOT fragmentFormHandlerListElementsDeleted:DoPart>>
            #);
          aListElementsDeletedEvent: @listElementsDeletedEvent;
          listElementsReplacedEvent: fragmentChangedEvent
            (#
               oldElements: ^editorEnv.partList;
               listNode: ^astInterface.expanded;
               position,length,newLength: @integer
            enter (listNode[],position,length,oldElements[],newLength)
            <<SLOT fragmentFormHandlerListElementsReplaced:DoPart>>
            #);
          aListElementsReplacedEvent: @listElementsreplacedEvent;
          
       #);
     externalFragmentFormHandler:
       (#
          ff: ^astInterface.fragmentForm;
          ffh: ^fragmentFormHandler;
          astFocus:
            (#
               node: ^astInterface.ast;
               length,subCommentInx1,subCommentInx2: @integer;
               
            enter (node[],length,subCommentInx1,subCommentInx2)
            exit (node[],length,subCommentInx1,subCommentInx2)
            #);
          refreshEvent:<
            (# node: ^astInterface.ast enter node[] do INNER #);
          focusChangedEvent:<
            (# newCS: @astFocus;  enter newCS do INNER #);
          astReplacedEvent:<
            (# oldAst,newAst: ^astInterface.ast; 
            enter (oldAst[],newAst[])
            do INNER
            #);
          astReplacedSequenceEvent:<
            (# rootOfSequence: ^astInterface.ast
            enter rootOfSequence[]
            do INNER
            #);
          listElementInsertedEvent:<
            (# position: @integer; listNode: ^astInterface.expanded; 
            enter (listNode[],position)
            do INNER
            #);
          listElementsDeletedEvent:<
            (#
               oldElements: ^editorEnv.partList;
               listNode: ^astInterface.expanded;
               position,length: @integer
            enter (listNode[],position,length,oldElements[])
            do INNER
            #);
          listElementsReplacedEvent:<
            (#
               oldElements: ^editorEnv.partList;
               listNode: ^astInterface.expanded;
               position,length,newLength: @integer
            enter (listNode[],position,length,oldElements[],newLength)
            do INNER
            #);
          
       #);
     init:
       (#  enter (mps[],betaGrammar[],UI[]) <<SLOT editorEnvInit:DoPart>> #)
  #)  

-- lib: Attributes --
sifEditorenv: (#  #)  

