ORIGIN 'codeviewer';
INCLUDE '~beta/guienv/v1.3/utils/simplemenu'
        'editorenv';
BODY 'private/parsing'
     'private/misc'
     'private/selection'
     'private/derivation'
     'private/delete'
     'private/doundo'
     'private/search'
     'private/optionals'
     'private/notification'
     'private/codeeditorbody'
     'private/updatemenus';
-- windowlib: Attributes --
codeEditor: codeViewer
  (#
     frejaStatusOn: @boolean;
     frejaEditTypeStatus: @text;
     frejaEditStatus: @text;
     frejaExpandStatus: @text;
     dir: @
       (#
          up: (#  exit 0 #);
          down: (#  exit 1 #);
          pred: (#  exit 2 #);
          next: (#  exit 3 #);
          root: (#  exit 4 #);
          extend: (#  exit 5 #);
          nextNonterminal: (#  exit 6 #);
          prevNonterminal: (#  exit 7 #);
          
       #);
     undoElem: ^undoElemType;
     undoElemType:
       (#
          fatherRef: ^mps.expanded;
          sonPos: @integer;
          fragments: @edenv.partlist;
          fragmentLength,undoLength: @integer
          (* fragmentLength is the length of the undoElem, 
           undoLength is the length of the fragment to be
           replaced by the undoElem.                     *) ;
          isDeleted: @boolean
          (* if true then undoElem is deleted from the program 
           else it is replaced by another fragment           *)
       exit (fatherRef[],sonPos,fragments.elm[1][],fragmentLength)
       #);
     subject05: (* some useful editor specific operations: misc.bet *)
       (#  #);
     makeUndoElem:
       (#
          fatherNode: ^mps.expanded;
          sonPos,undoLength: @integer;
          undoFocus:
          (* undoLength is the number of nodes undoFocus should be replaced 
           with when undone .                                             *)
            @astFocus;
          isDeleted: @boolean;
          
       enter (fatherNode[],sonPos,undoFocus,undoLength,isDeleted)
       do <<SLOT makeUndoElemBody:Descriptor>>
       #);
     getSynCatNo:
       (#
          node: ^mps.ast;
          synCatNo: @mps.nonterminalSymbol;
          
       enter node[]
       do
          <<SLOT getSynCatNoBody:Descriptor>>
       exit synCatNo
       #);
     setSynCatNo:
       (# synCatNo: @mps.nonterminalSymbol; programNode: ^mps.expanded; 
       enter (synCatNo,programNode[])
       do <<SLOT setSynCatNoBody:Descriptor>>
       #);
     findSynNameAtt:
       (#
          production: ^mg.prod;
          synCatNo: @mps.nonterminalSymbol;
          
       enter production[]
       do
          <<SLOT findSynNameAttBody:Descriptor>>
       exit synCatNo
       #);
     showAst: (#  do <<SLOT showAstBody:Descriptor>> #);
     subject1:
     (* parsing operations: parsing.bet *) (#  #);
     substitute:
       (# oldFragment,newFragment: ^mps.ast; 
       enter (oldFragment[],newFragment[])
       do <<SLOT substituteBody:Descriptor>>
       #);
     listSubstitute:
       (#
          f: @astFocus; theList: ^mps.list; 
       enter (f,theList[])
       do
          <<SLOT listSubstituteBody:Descriptor>>
       exit f
       #);
     findSuper:
       (# synCatNo: @mps.nonterminalSymbol; 
       enter synCatNo
       do <<SLOT findSuperBody:Descriptor>>
       exit synCatNo
       #);
     parsingSynCatNo:
       (#
          node: ^mps.ast;
          synCatNo: @mps.nonterminalSymbol;
          isList: @boolean;
          theListElement: ^mps.ast;
          
       enter node[]
       do
          <<SLOT parsingSynCatNoBody:Descriptor>>
       exit (synCatNo,isList,theListElement[])
       #);
     parseText:
       (# f: @astFocus; t: ^text; parseOK: @boolean
       enter (f,t[])
       do <<SLOT parseTextBody:Descriptor>>
       exit (parseOK,f)
       #);
     subject2: (* undo operation: undo.bet *)
       (#  #);
     undo:
       (# 
       do <<SLOT undoBody:Descriptor>>
       #);
     subject3:
     (* derivation operations: derivation.bet *) (#  #);
     ins: @
       (#
          first: (#  exit 1 #);
          before: (#  exit 2 #);
          after: (#  exit 3 #)
       #);
     createList:
       (#
          synCatNo: @mps.nonterminalSymbol;
          prod: ^mg.prod;
          fatherNode: ^mps.expanded;
          isSon: @integer
       enter (synCatNo,prod[],fatherNode[],isSon)
       do <<SLOT createListBody:Descriptor>>
       #);
     new:
       (# 
       do <<SLOT newBody:Descriptor>>
       #);
     newPrivate:
       (# 
       do
          <<SLOT newPrivateBody:Descriptor>>
       #);
     expand:
       (#
          fatherNode: ^mps.expanded;
          isSon: @integer;
          synCatNo: @mps.nonterminalSymbol;
          
       enter (synCatNo,fatherNode[],isSon)
       do <<SLOT expandBody:Descriptor>>
       #);
     nodeExpand:
       (#
          synCatNo: @mps.nonterminalSymbol;
          newLexem: @boolean;
          
       enter (synCatNo,newLexem)
       do <<SLOT nodeExpandBody:Descriptor>>
       #);
     expandLexem:
       (# t: ^text;  enter t[] do <<SLOT expandLexemBody:Descriptor>> #);
     listInsert:
       (# command: @integer; 
       enter command
       do <<SLOT listInsertBody:Descriptor>>
       #);
     expandOptional: (#  do <<SLOT expandOptionalBody:Descriptor>> #);
     subject4:
     (* navigation operations: selection.bet *) (#  #);
     selectNewCs: (#  do <<SLOT selectNewCsBody:Descriptor>> #);
     checkSon:
       (# 
       do <<SLOT checkSonBody:Descriptor>>
       #);
     checkSonNode:
       (# node: ^mps.ast
       enter node[]
       do <<SLOT checkSonNodeBody:Descriptor>>
       exit node[]
       #);
     checkFather:
       (# 
       do
          cs.node[]->checkFatherNode
            ->cs.node[]
       #);
     checkFatherNode:
       (# node: ^mps.ast
       enter node[]
       do
          <<SLOT checkFatherNodeBody:Descriptor>>
       exit node[]
       #);
     extend: (#  do <<SLOT extendBody:Descriptor>> #);
     down:
       (#  do <<SLOT downBody:Descriptor>> #);
     navigate:
       (# direction: @integer; 
       enter direction
       do <<SLOT navigateBody:Descriptor>>
       #);
     select:
       (# direction: @integer; 
       enter direction
       do <<SLOT selectBody:Descriptor>>
       #);
     gotoNonterminal: (#  do <<SLOT gotoNonterminalBody:Descriptor>> #);
     gotoNonEmpty:
       (# 
       do
          <<SLOT gotoNonEmptyBody:Descriptor>>
       #);
     nextNonterminal: (#  do <<SLOT nextNonterminalBody:Descriptor>> #);
     prevNonterminal:
       (# 
       do
          <<SLOT prevNonterminalBody:Descriptor>>
       #);
     subject5: (* delete operations: delete.bet *) (#  #);
     deleted: @boolean;
     cut:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT cutFragmentBody:Descriptor>>
       #);
     makeEmptyListOrOpt:
       (# 
       do
          <<SLOT makeEmptyListOrOptBody:Descriptor>>
       #);
     paste:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT pasteFragmentBody:Descriptor>>
       #);
     copy:
       (# 
       do
          <<SLOT copyFragmentBody:Descriptor>>
       #);
     subject7: (* search operations: search.bet *) (#  #);
     searchPrivate: @<<SLOT searchPrivate:Descriptor>>;
     searchText:
       (# t: ^text; parseOK: @boolean
       enter t[]
       do <<SLOT searchTextBody:Descriptor>>
       exit
       parseOK
       #);
     searchStructure: (#  do <<SLOT searchStructureBody:Descriptor>> #);
     searchNext:
       (# found: @boolean
       do
          <<SLOT searchNextBody:Descriptor>>
       exit found
       #);
     searchPrev:
       (# found: @boolean
       do <<SLOT searchPrevBody:Descriptor>>
       exit found
       #);
     searchName:
       (# name: ^text; found: @boolean
       enter name[]
       do <<SLOT searchNameBody:Descriptor>>
       exit
       found
       #);
     subject8: (* comment operations: comment.bet *) (#  #);
     removeOptionals:
       (# node: ^mps.ast; 
       enter node[]
       do <<SLOT removeOptionalsBody:Descriptor>>
       #);
     insertOptionals:
       (# node: ^mps.ast; 
       enter node[]
       do
          <<SLOT insertOptionalsBody:Descriptor>>
       #);
     removeEmptyElement:
       (# theList: ^mps.list; 
       enter theList[]
       do <<SLOT removeEmptyElementBody:Descriptor>>
       #);
     removeEmptyElements:
       (# node: ^mps.ast; 
       enter node[]
       do
          <<SLOT removeEmptyElementsBody:Descriptor>>
       #);
     subject9:
     (* The following virtual patterns (events) are called in the model
      every time certain changes are made.
      These patterns are specialized in the application.*) (#  #);
     editorEvent: (#  do INNER #);
     noOfAstChanges,ASLimit,touched: @integer;
     resetFragmentTouch: <<SLOT resetFragmentTouchBody:Descriptor>>;
     fragmentTouched:
      <<SLOT fragmentTouchedBody:Descriptor>>;
     fragmentDetouched: <<SLOT fragmentDetouchedBody:Descriptor>>;
     autoSaveLimit:<
       (# 
       do
          <<SLOT autoSaveLimitBody:Descriptor>>;
          INNER
       #);
     autoSave:< (#  <<SLOT autoSaveBody:DoPart>> #);
     fragmentChangedEvent: editorEvent
       (# 
       do
          <<SLOT fragmentChangedEventBody:Descriptor>>;
          INNER
       #);
     newFragmentEvent:<
       (#  do INNER ; <<SLOT newFragmentBody:Descriptor>>;  #);
     aNewFragmentEvent: @NewFragmentEvent;
     astReplacedEvent:< fragmentChangedEvent
       (# oldAst,newAst: ^mps.ast; 
       enter (oldAst[],newAst[])
       do
          INNER ;
          <<SLOT astReplacedBody:Descriptor>>;
          
       #);
     anAstReplacedEvent: @astReplacedEvent;
     makeAstReplacedEvent:
       (# sequence: @boolean
       enter sequence
       do <<SLOT makeAstReplacedEventBody:Descriptor>>
       #);
     astReplacedElement:
       (# oldAst,newAst: ^mps.ast
       #);
     astReplacedList: @list
       (#
          element::
           astReplacedElement;
          appendElement:
            (# oldAst,newAst: ^mps.ast; e: ^astReplacedElement; 
            enter (oldAst[],newAst[])
            do
               &astReplacedElement[]->e[];
               oldAst[]->e.oldAst[];
               newAst[]->e.newAst[];
               e[]->append
            #)
       #);
     astReplacedSequenceEvent:< fragmentChangedEvent
       (# rootOfSequence: ^mps.ast
       enter rootOfSequence[]
       do INNER ; <<SLOT astReplacedSequenceBody:Descriptor>>; 
       #);
     listElementInsertedEvent:<
      fragmentChangedEvent
       (# position: @integer; fatherNode: ^mps.expanded; 
       enter (fatherNode[],position)
       do INNER ; <<SLOT listElementInsertedBody:Descriptor>>; 
       #);
     aListElementInsertedEvent:
       @listElementInsertedEvent;
     listElementsDeletedEvent:< fragmentChangedEvent
       (#
          oldElements: ^edenv.partList;
          listNode: ^mps.expanded;
          position,length: @integer
       enter (listNode[],position,length,oldElements[])
       do INNER ; <<SLOT listElementsDeletedBody:Descriptor>>; 
       #);
     aListElementsDeletedEvent:
       @listElementsDeletedEvent;
     listElementsReplacedEvent:< fragmentChangedEvent
       (#
          oldElement: ^edenv.partList;
          listNode: ^mps.expanded;
          position,length,newLength: @integer
       enter (listNode[],position,length,oldElement[],newLength)
       do INNER ; <<SLOT listElementsReplacedBody:Descriptor>>; 
       #);
     aListElementsReplacedEvent:
       @listElementsreplacedEvent;
     focusChangedEvent::< 
       (#  do INNER ; <<SLOT focusChangedBody:Descriptor>>;  #);
     aFocusChangedEvent:
       @focusChangedEvent;
     onMiddleButton::< 
       (# 
       <<SLOT onMiddleButton:DoPart>>
       #);
     expandMenuPrivate: ^expmenuprivate;
     expmenuprivate: <<SLOT expandMenuPrivate:Descriptor>>;
     updateExpandMenu:
       (# 
       do
          <<SLOT updateExpandMenuBody:Descriptor>>
       #);
     updateEditMenu: (#  do <<SLOT editMenuUpdateBody:Descriptor>> #);
     askUndoPermission::< 
       (#  do cs.undoPermit->value #);
     askPastePermission::< 
       (# 
       do cs.pastePermit->value
       #);
     askInsertPermission::< 
       (# 
       do cs.listInsertPermit->value
       #);
     texteditMode: @boolean;
     askTexteditMode::< 
       (# 
       do not textEditMode->textEditMode
       #);
     doUndo::<  (#  do undo #);
     doCut::< 
       (# 
       do true->cs.undoPermit; cut
       #);
     doCopy::< 
       (# 
       do true->cs.undoPermit; copy
       #);
     doPaste::<  (#  do paste #);
     doTextedit::< 
       (# 
       do 'doTextEdit'->putLine
       #);
     doParseText::< 
       (# 
       do 'doParseText'->putLine
       #);
     doRevertTextedit::< 
       (# 
       do 'doRevertTextedit'->putLine
       #);
     doShowTexteditCommands::< 
       (# 
       do
          'doShowTexteditCommands'
            ->putLine
       #);
     doInsertBefore::< 
       (# 
       do
          true->cs.undoPermit;
          ins.before->listInsert
       #);
     doInsertAfter::< 
       (# 
       do
          true->cs.undoPermit;
          ins.after->listInsert
       #);
     doRemoveOptionals::< 
       (# 
       do cs.node[]->removeOptionals
       #);
     doShowOptionals::< 
       (# 
       do cs.node[]->insertOptionals
       #);
     init::< 
       (# 
       do
          &undoElemType[]->undoElem[];
          &expmenuprivate[]
            ->expandmenuprivate[]
       #)
  #)  

