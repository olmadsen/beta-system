ORIGIN 'codeviewer';
INCLUDE '~beta/guienv/utils/simplemenu'
        '~beta/containers/sets'
        '~beta/containers/seqContainers'
        '~beta/mps/propertycfl'
        '~beta/prettygen/prettyprintcfl'
        '~beta/freja/frejainterface'
        'ymercall'
        '~beta/guienv/keys';
LIB_DEF 'editorcodeeditor' '../lib';
BODY 'private/misc'
     'private/parsing'
     'private/derivation'
     'private/delete'
     'private/doundo'
     'private/optionals'
     'private/codeeditorbody'
     'private/updatemenus'
     'private/textediting'
     'private/editorenvbody'
     'private/editorenvsearchbody'
     'private/groupeditorbody'
     'private/historybody'
     'private/slotbody'
     'private/externalinterfacebody'
     'private/propertyeditorbody'
     'private/subeditorbody'
     'private/ffobserverbody'
     'private/fgobserverbody'
     'private/codeeditormenus'
     'private/search';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
-- windowlib: Attributes --
codeEditor: codeViewer
  (#
     spk: @specialKeys;
     edenv: ^editorEnv;
     thisGroupEditor: ^editorEnv.groupeditor;
     thePropertyEditor: ^propertyEditor;
     ffObserverType::< 
       (#
          private: @<<SLOT ffObserverPrivate:Descriptor>>;
          onRefresh::< 
            (# 
            <<SLOT ffObserverOnRefresh:DoPart>>
            #);
          onFocusChanged::<  (#  <<SLOT ffObserverOnFocusChanged:DoPart>> #);
          onAstReplaced::<  (#  <<SLOT ffObserverOnAstReplaced:DoPart>> #);
          onAstReplacedSequence::< 
            (# 
            <<SLOT ffObserverOnAstReplacedSequence:DoPart>>
            #);
          onListElementInserted::< 
            (#  <<SLOT ffObserverOnListElementInserted:DoPart>> #);
          onListElementsDeleted::< 
            (#  <<SLOT ffObserverOnListElementsDeleted:DoPart>> #);
          onListElementsReplaced::< 
            (#  <<SLOT ffObserverOnListElementsReplaced:DoPart>> #);
          onTouched::< 
            (# 
            <<SLOT ffObserverOnTouched:DoPart>>
            #);
          onDetouched::<  (#  <<SLOT ffObserverOnDetouched:DoPart>> #);
          onEnterTextediting::< 
            (# 
            <<SLOT ffObserverOnEnterTextediting:DoPart>>
            #);
          onExitTextediting::< 
            (#  <<SLOT ffObserverOnExitTextediting:DoPart>> #)
       #);
     theEditMenu:
       ^codeEditorEditMenu;
     theViewMenu: ^codeEditorViewMenu;
     theSLOTsMenu: ^codeEditorSLOTsMenu;
     thePopupMenu: ^codeEditorPopUpMenu;
     frejaStatusOn: @boolean;
     frejaEditTypeStatus: @text;
     frejaEditStatus: @text;
     frejaExpandStatus: @text;
     parsingPossible: @boolean;
     editingMode: @integer;
     structureMode: (#  exit 0 #);
     editLexemMode: (#  exit 1 #);
     editAndParseMode: (#  exit 2 #);
     askBeforeTextediting::< 
       (#  <<SLOT codeeditorAskBeforeTextediting:DoPart>> #);
     askBeforeTexteditingMessage::< 
       (#  <<SLOT codeeditorAskBeforeTexteditingMessage:DoPart>> #);
     adaptivePrettyprinting::< 
       (#
          set::  (#  do v->edenv.adaptivePrettyprinting #);
          get::<  (#  do edenv.adaptivePrettyprinting->v; INNER #)
       #);
     TEexit: @
       (#
          escape: (#  exit 0 #);
          parseMode: (#  exit 1 #);
          exitMode: (#  exit 2 #);
          
       #);
     currentUndoCell: ^undoList.theCellType;
     undoElem: ^undoElemType;
     undoList: ^undoListDesc;
     undoListDesc: list (# element:: undoElemType #);
     undoing,redoing: @boolean;
     undoElemType:
       (#
          fatherRef: ^astInterface.expanded;
          sonPos: @integer;
          fragments: @mps.astList;
          fragmentLength,undoLength: @integer
          (* fragmentLength is the length of the undoElem, 
           undoLength is the length of the fragment to be
           replaced by the undoElem.                     *) ;
          isDeleted: @boolean
          (* if true then undoElem is deleted from the program 
           else it is replaced by another fragment           *)
       exit (fatherRef[],sonPos,fragments.elm[1][],fragmentLength)
       #);
     localOnRefresh::<  (#  <<SLOT codeeditorLocalOnRefresh:DoPart>> #);
     localOnFocusChanged::< 
       (# 
       <<SLOT codeeditorLocalOnFocusChanged:DoPart>>
       #);
     followSemanticLink::< 
       (#  do <<SLOT codeeditorFollowSemanticLink:Descriptor>>;  #);
     setIsReadOnly::< 
       (# 
       <<SLOT codeeditorSetIsReadOnly:DoPart>>
       #);
     onReturnKey::<  (#  <<SLOT codeeditorOnReturnKey:DoPart>> #);
     onDeleteKey::< 
       (# 
       <<SLOT codeeditorOnDeleteKey:DoPart>>
       #);
     onControlChar::< 
       (#  do (if ch // 'A' then doCopy; doPasteAfter if) #);
     keyAllowed::<  (#  <<SLOT codeeditorKeyAllowed:DoPart>> #);
     updateHistory::< 
       (# 
       <<SLOT editorenvHistoryUpdateHistory:DoPart>>
       #);
     checkFormEditorExistence::< 
       (#  <<SLOT codeeditorCheckFormEditorExistence:DoPart>> #);
     setupFormEditor::< 
       (# 
       <<SLOT codeeditorSetupFormeditor:DoPart>>
       #);
     subject05: (* some useful editor specific operations: misc.bet *)
       (#  #);
     getSynCatNo:
       (# node: ^astInterface.ast; synCatNo: @mps.nonterminalSymbol; 
       enter node[]
       do <<SLOT getSynCatNoBody:Descriptor>>
       exit synCatNo
       #);
     setSynCatNo:
       (#
          synCatNo: @mps.nonterminalSymbol;
          programNode:
            ^astInterface.expanded;
          
       enter (synCatNo,programNode[])
       do
          <<SLOT setSynCatNoBody:Descriptor>>
       #);
     findSynNameAtt:
       (# production: ^mg.prod; synCatNo: @mps.nonterminalSymbol; 
       enter production[]
       do <<SLOT findSynNameAttBody:Descriptor>>
       exit synCatNo
       #);
     subject1:
     (* parsing operations: parsing.bet *) (#  #);
     substitute:
       (# oldFragment,newFragment: ^astInterface.ast; 
       enter (oldFragment[],newFragment[])
       do <<SLOT substituteBody:Descriptor>>
       #);
     listSubstitute:
       (#
          f: @mps.astFocus;
          theList: ^astInterface.list;
          
       enter (f,theList[])
       do
          <<SLOT listSubstituteBody:Descriptor>>
       exit f
       #);
     parseText:
       (#
          f: @mps.astFocus;
          t: ^text;
          parseOK: @boolean;
          astOverflow:< object
       enter (f,t[])
       do <<SLOT parseTextBody:Descriptor>>
       exit (parseOK,f)
       #);
     subject2: (* undo operation: undo.bet *)
       (#  #);
     makeUndoElem:
       (#
          fatherNode: ^astInterface.expanded;
          sonPos,undoLength: @integer;
          undoFocus:
          (* undoLength is the number of nodes undoFocus should be replaced 
           with when undone .                                             *)
            @mps.astFocus;
          isDeleted: @boolean;
          
       enter (fatherNode[],sonPos,undoFocus,undoLength,isDeleted)
       do <<SLOT makeUndoElemBody:Descriptor>>
       #);
     makeRedoElem:
       (#
          fatherNode:
            ^astInterface.expanded;
          sonPos,undoLength: @integer;
          undoFocus:
          (* undoLength is the number of nodes undoFocus should be replaced 
           with when undone .                                             *)
            @mps.astFocus;
          isDeleted: @boolean;
          
       enter (fatherNode[],sonPos,undoFocus,undoLength,isDeleted)
       do <<SLOT makeRedoElemBody:Descriptor>>
       #);
     makeAstReplacedEvent:
       (# sequence: @boolean
       enter sequence
       <<SLOT MakeAstReplaced:DoPart>>
       #);
     undo: (#  do <<SLOT undoBody:Descriptor>> #);
     redo:
       (#  do <<SLOT redoBody:Descriptor>> #);
     undoPrivate:
       @<<SLOT undoPrivate:Descriptor>>;
     subject3: (* derivation operations: derivation.bet *) (#  #);
     ins: @
       (#
          first: (#  exit 1 #);
          before: (#  exit 2 #);
          after: (#  exit 3 #)
       #);
     createList:
       (#
          synCatNo: @mps.nonterminalSymbol;
          prod: ^mg.prod;
          fatherNode: ^astInterface.expanded;
          isSon: @integer
       enter (synCatNo,prod[],fatherNode[],isSon)
       do <<SLOT createListBody:Descriptor>>
       #);
     newAst:
       (# 
       do <<SLOT newAstBody:Descriptor>>
       #);
     expand:
       (#
          fatherNode: ^astInterface.expanded;
          isSon: @integer;
          synCatNo: @mps.nonterminalSymbol;
          
       enter (synCatNo,fatherNode[],isSon)
       do <<SLOT expandBody:Descriptor>>
       #);
     nodeExpand:
       (#
          synCatNo: @mps.nonterminalSymbol;
          newLexem: @boolean;
          
       enter (synCatNo,newLexem)
       do <<SLOT nodeExpandBody:Descriptor>>
       #);
     expandLexem:
       (# t: ^text;  enter t[] do <<SLOT expandLexemBody:Descriptor>> #);
     listInsert:
       (# command: @integer; 
       enter command
       do <<SLOT listInsertBody:Descriptor>>
       #);
     expandOptional: (#  do <<SLOT expandOptionalBody:Descriptor>> #);
     subject5:
     (* delete operations: delete.bet *) (#  #);
     deleted: @boolean;
     cut:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          doNotCopyToClipBoard: @boolean
          (* if not specified, the deleted construct 
           * will not be copied to the clipboard
           *)
       enter (doNotNotify,doNotCopyToClipBoard)
       do <<SLOT cutFragmentBody:Descriptor>>
       #);
     makeEmptyListOrOpt:
       (# 
       do
          <<SLOT makeEmptyListOrOptBody:Descriptor>>
       #);
     paste:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT pasteFragmentBody:Descriptor>>
       #);
     copy:
       (# 
       do
          <<SLOT copyFragmentBody:Descriptor>>
       #);
     subject8: (* comment operations: comment.bet *) (#  #);
     removeOptionals:
       (# node: ^astInterface.ast; 
       enter node[]
       do <<SLOT removeOptionalsBody:Descriptor>>
       #);
     insertOptionals:
       (# node: ^astInterface.ast; 
       enter node[]
       do
          <<SLOT insertOptionalsBody:Descriptor>>
       #);
     removeEmptyElement:
       (# theList: ^astInterface.list; 
       enter theList[]
       do <<SLOT removeEmptyElementBody:Descriptor>>
       #);
     removeEmptyElements:
       (# node: ^astInterface.ast; 
       enter node[]
       do
          <<SLOT removeEmptyElementsBody:Descriptor>>
       #);
     searchPrivate: @<<SLOT searchPrivate:Descriptor>>;
     searchText:
       (# t: ^text; parseOK: @boolean
       enter t[]
       do <<SLOT searchTextBody:Descriptor>>
       exit
       parseOK
       #);
     searchStructure: (#  do <<SLOT searchStructureBody:Descriptor>> #);
     searchNext:
       (# found: @boolean
       do
          <<SLOT searchNextBody:Descriptor>>
       exit found
       #);
     searchPrev:
       (# found: @boolean
       do <<SLOT searchPrevBody:Descriptor>>
       exit found
       #);
     searchName:
       (# name: ^text; found: @boolean
       enter name[]
       do <<SLOT searchNameBody:Descriptor>>
       exit
       found
       #);
     editLexem:
       (# node: ^astInterface.ast; oldText,newText: ^text
       enter (node[],oldText[],newText[])
       <<SLOT codeeditorEditLexem:DoPart>>
       #);
     externalInterface:
     (* Fragmentform specific commands *) @
       (#
          undo: (#  <<SLOT externalInterfaceUndo:DoPart>> #);
          redo:
            (# 
            <<SLOT externalInterfaceRedo:DoPart>>
            #);
          cut: (#  <<SLOT externalInterfaceCut:DoPart>> #);
          clear:
            (# 
            <<SLOT externalInterfaceClear:DoPart>>
            #);
          copy: (#  <<SLOT externalInterfaceCopy:DoPart>> #);
          paste:
            (# 
            <<SLOT externalInterfacePaste:DoPart>>
            #);
          pasteBefore: (#  <<SLOT externalInterfacePasteBefore:DoPart>> #);
          pasteAfter: (#  <<SLOT externalInterfacePasteAfter:DoPart>> #);
          before:
            (# 
            <<SLOT externalInterfaceBefore:DoPart>>
            #);
          after: (#  <<SLOT externalInterfaceAfter:DoPart>> #);
          changeFocus:
            (#
               node: ^mps.ast;
               length: @integer
            enter (node[],length)
            <<SLOT externalInterfaceChangeFocus:DoPart>>
            exit
            (frejaEditTypeStatus[],cs.undoPermit,cs.pastePermit,
             cs.listInsertPermit,frejaExpandStatus[])
            #);
          getStatus:
            (# 
            <<SLOT externalInterfaceGetStatus:DoPart>>
            exit
            (cs.node[],cs.length,
             frejaEditTypeStatus[],cs.undoPermit,cs.pastePermit,
             cs.listInsertPermit,frejaExpandStatus[])
            #);
          expandNormal:
            (# synCatNo: @integer
            enter synCatNo
            <<SLOT externalInterfaceExpandNormal:DoPart>>
            #);
          expandOptional:
            (# synCatNo: @integer
            enter synCatNo
            <<SLOT externalInterfaceExpandOptional:DoPart>>
            #);
          expandLexem:
            (# theText: ^text
            enter theText[]
            <<SLOT externalInterfaceExpandLexem:DoPart>>
            #);
          insertOptionals:
            (# 
            <<SLOT externalInterfaceInsertOptionals:DoPart>>
            #);
          removeOptionals:
            (#  <<SLOT externalInterfaceRemoveOptionals:DoPart>> #);
          parse:
            (#
               node: ^mps.ast;
               ok: @boolean;
               errorPos:
                 @integer;
               parseText,parseErrorText: ^text
            enter (node[],parseText[])
            <<SLOT externalInterfaceParse:DoPart>>
            exit
            (ok,errorPos,parseErrorText[])
            #);
          search: (#  <<SLOT externalInterfaceSearch:DoPart>> #);
          replace:
            (# 
            <<SLOT externalInterfaceReplace:DoPart>>
            #);
          fragmentTouched:
            (#  <<SLOT externalInterfaceFragmentTouched:DoPart>> #)
       #);
     closeGroup::< 
       (# 
       <<SLOT codeeditorCloseGroup:DoPart>>
       #);
     closeForm::<  (#  <<SLOT codeeditorCloseForm:DoPart>> #);
     subject9:
     (* The following virtual patterns (events) are called in the model
      every time certain changes are made.
      These patterns are specialized in the application.*) (#  #);
     noOfAstChanges,ASLimit,touched,oldTouched: @integer;
     resetFragmentTouch: <<SLOT resetFragmentTouchBody:Descriptor>>;
     fragmentTouched:
      <<SLOT fragmentTouchedBody:Descriptor>>;
     fragmentDetouched: <<SLOT fragmentDetouchedBody:Descriptor>>;
     autoSaveLimit:<
       (# 
       <<SLOT codeeditorAutoSaveLimit:DoPart>>
       #);
     checkAutoSave: (#  <<SLOT codeeditorCheckAutoSave:DoPart>> #);
     autoSave:
       (# 
       <<SLOT codeeditorAutoSave:DoPart>>
       #);
     handleDoubleClick::< 
       (#  do <<SLOT usernotificationOnDoubleClick:Descriptor>> #);
     onPopUpButton::< 
       (# 
       do
          <<SLOT usernotificationOnPopUpButton:Descriptor>>;
          <<SLOT onPopUpButton:Descriptor>>
       #);
     callQuit::<  (#  <<SLOT codeeditorCallQuit:DoPart>> #);
     userPrivate:
      <<SLOT userPrivate:Descriptor>>;
     up: ^userPrivate;
     userOnOpenCodeeditor: <<SLOT userOnOpenCodeeditor:Descriptor>>;
     isUndoing:
     (* is used in fragmentChangedEvent in order to decide whether
      to increase or decrease touched *) @boolean;
     theAstReplacedList: ^astInterface.astReplacedList;
     expandMenuPrivate: ^expmenuprivate;
     expmenuprivate: <<SLOT expandMenuPrivate:Descriptor>>;
     updateExpandMenu:
       (# 
       do
          <<SLOT updateExpandMenuBody:Descriptor>>
       #);
     updateEditMenu: (#  do <<SLOT editMenuUpdateBody:Descriptor>> #);
     askUndoPermission::< 
       (# 
       <<SLOT codeeditorAskUndoPermission:DoPart>>
       #);
     askRedoPermission::< 
       (#  <<SLOT codeeditorAskRedoPermission:DoPart>> #);
     askPastePermission::< 
       (# 
       <<SLOT codeeditorAskPastePermission:DoPart>>
       #);
     askInsertPermission::< 
       (# 
       do not (cs.node[]->editorRoot.equal) and cs.listInsertPermit->value
       #);
     askOpenSubeditorPermission::< 
       (#  <<SLOT askOpenSubeditorPermission:DoPart>> #);
     texteditMode:
       (#
          set:
            (# 
            enter
            theSifTextEditor.
              textediting
            <<SLOT codeeditorSetTexteditmode:DoPart>>
            #)
       enter set
       exit
       theSifTextEditor.textediting
       #);
     askTexteditMode::< 
       (# 
       <<SLOT codeeditorAskTexteditMode:DoPart>>
       #);
     doUndo::<  (#  <<SLOT codeeditorDoUndo:DoPart>> #);
     doRedo::< 
       (# 
       <<SLOT codeeditorDoRedo:DoPart>>
       #);
     doCut::< 
       (# 
       <<SLOT codeeditorDoCut:DoPart>>
       #);
     doCopy::<  (#  <<SLOT codeeditorDoCopy:DoPart>> #);
     doPaste::< 
       (# 
       <<SLOT codeeditorDoPaste:DoPart>>
       #);
     doPasteBefore::< 
       (# 
       do
          true->cs.undoPermit;
          ins.before->listInsert;
          true->cs.undoPermit;
          paste
       #);
     doPasteAfter::< 
       (# 
       do
          true->cs.undoPermit; ins.after->listInsert; true->cs.undoPermit; paste
       #);
     doClear::<  (#  <<SLOT codeeditorDoClear:DoPart>> #);
     TE: ^texteditingPrivate;
     texteditingPrivate:
      <<SLOT texteditingPrivate:Descriptor>>;
     askValhallaBeforeTextEditing:< TrueObject;
     doTextedit::<  (#  <<SLOT doTextedit:DoPart>> #);
     doExternalTextEdit:
       (#  <<SLOT doExternalTextEdit:DoPart>> #);
     checkTexteditingFinished::< 
       (#  do <<SLOT checkTexteditingFinished:Descriptor>>;  #);
     keepInsideTexteditingArea::< 
       (# 
       do
          <<SLOT keepInsideTexteditingArea:Descriptor>>;
          
       #);
     texteditingExtent::<  (#  <<SLOT texteditingExtent:DoPart>> #);
     doParseText::< 
       (#  <<SLOT doParseText:DoPart>> #);
     externalTextEdit:
       (# textBefore,textAfter: ^text
       enter textBefore[]
       <<SLOT codeeditorExternalTextEdit:DoPart>>
       exit textAfter[]
       #);
     doRevertTextedit::< 
       (# 
       <<SLOT doRevertTextediting:DoPart>>
       #);
     doShowTexteditCommands::< 
       (#  <<SLOT doShowTexteditingCommands:DoPart>> #);
     doInsertBefore::< 
       (# 
       do
          true->cs.undoPermit;
          ins.before->listInsert
       #);
     doInsertAfter::< 
       (# 
       do
          true->cs.undoPermit;
          ins.after->listInsert
       #);
     doComment::< 
       (# 
       do
          theSifTextEditor.contents.
            comment_out_block
       #);
     doRemoveComment::< 
       (#  do theSifTextEditor.contents.remove_surrounding_comment #);
     doRemoveOptionals::< 
       (# 
       do
          cs.perform
            (# 
            do
               (if cs.node.kind <> mps.kinds.unexpanded then
                   current[]->removeOptionals
               if)
            #)
       #);
     doShowOptionals::< 
       (# 
       do
          cs.perform
            (# 
            do
               (if cs.node.kind <> mps.kinds.unexpanded then
                   current[]->insertOptionals
               if)
            #)
       #);
     doSearch: (#  <<SLOT doSearch:DoPart>> #);
     doReplace: (#  <<SLOT doReplace:DoPart>> #);
     getFragmentgroup:: 
       (# 
       <<SLOT codeeditorGetFragmentgroup:DoPart>>
       #);
     machineType::<  (#  <<SLOT codeeditorMachineType:DoPart>> #);
     slotPrivate: ^slotPrivatePattern;
     slotPrivatePattern:
      <<SLOT slotPrivate:Descriptor>>;
     askMakeDopartSlot::<  (#  <<SLOT askMakeDopartSlot:DoPart>> #);
     askMakeDescriptorSlot::< 
       (# 
       <<SLOT askMakeDescriptorSlot:DoPart>>
       #);
     askMakeAttributesSlot::<  (#  <<SLOT askMakeAtributesSlot:DoPart>> #);
     askPasteFragmentForm::< 
       (# 
       <<SLOT askPasteFragmentForm:DoPart>>
       #);
     doMakeDopartSlot::<  (#  <<SLOT doMakeDopartSlot:DoPart>> #);
     doMakeDescriptorSlot::< 
       (# 
       <<SLOT doMakeDescriptorSlot:DoPart>>
       #);
     doMakeAttributesSlot::<  (#  <<SLOT doMakeAttributesSlot:DoPart>> #);
     doPasteFragmentForm::< 
       (# 
       <<SLOT doPasteFragmentForm:DoPart>>
       #);
     doFillSlot::<  (#  <<SLOT doFillSlot:DoPart>> #);
     doFillAllSlots::< 
       (#  <<SLOT doFillAllSlots:DoPart>> #);
     doCreateImplementationFragment::< 
       (#  <<SLOT doCreateImplementationFragment:DoPart>> #);
     doSelectImplementationFragment::< 
       (#  <<SLOT doSelectImplementationFragment:DoPart>> #);
     doHideImplementation::< 
       (# 
       <<SLOT doHideImplementation:DoPart>>
       #);
     openSubeditor::<  (#  <<SLOT subeditorOpenSubeditor:DoPart>> #);
     createSubeditorObsoleteCode::< 
       (# 
       <<SLOT subeditorCreateSubeditor:DoPart>>
       #);
     subeditors: @list (# element::< codeeditor #);
     askShowDiagram::<  (#  <<SLOT askShowDiagramPermission:DoPart>> #);
     askEditUserInterface::< 
       (# 
       <<SLOT askEditUserInterfacePermission:DoPart>>
       #);
     showDiagram::<  (#  <<SLOT codeeditorShowDiagram:DoPart>> #);
     editUserinterface::< 
       (# 
       <<SLOT codeeditorEditUserinterface:DoPart>>
       #);
     close::<  (#  <<SLOT codeeditorclose:DoPart>> #);
     init::< 
       (#  <<SLOT codeeditorinit:DoPart>> #)
  #);
mysimplemenu: menu
(* Special menu type with interdependant check marks, some other 
 * extra features, and a few code saving patterns, that allow
 * for simple specification of a menu.
 *
 * Example:
 * 
 *  FileMenu: @simplemenu
 *    (# inew:    @item(# onSelect:: (# do NewFile    #)#);
 *       iopen:   @item(# onSelect:: (# do OpenFile   #)#);
 *       iclose:  @item(# onSelect:: (# do Iconify    #)#);
 *       isave:   @item(# onSelect:: (# do SaveFile   #)#);
 *       isaveas: @item(# onSelect:: (# do SaveFileAs #)#);
 *       iexport: @item(# onSelect:: (# do Export     #)#);
 *       iprint:  @item(# onSelect:: (# do Print      #)#);
 *       iquit:   @item(# onSelect:: (# do Quit       #)#);
 *            
 *       open:: 
 *         (# 
 *         do ('New...',    'n') -> inew.newkey;  false -> inew.enabled;
 *            ('Open...',   'o') -> iopen.newkey; false -> iopen.enabled;
 *            ('Close',     'w') -> iclose.newkey;
 *            newseparator;
 *            ('Save',      's') -> isave.newkey; false -> isave.enabled;
 *            ('Save As...')     -> isaveas.new;  false -> isaveas.enabled;
 *            newseparator;
 *            ('Print...',  'p') -> iprint.newkey; 
 *            ('Export...', 'e') -> iexport.newkey; 
 *            newseparator;
 *            ('Quit',      'q') -> iquit.newkey;
 *         #)
 *     #);
 * 
 *  ShapeMenu: @simplemenu              	    
 *    (# ievenodd: @radioitem
 *         (# onSelect:: (# do EvenOddRule->SetFillRule #)#);
 *       iwinding: @radioitem
 *         (# onSelect:: (# do WindingRule->SetFillRule #)#);
 *       open:: 
 *         (# 
 *         do 'Even-Odd Fillrule'->ievenodd.new; 
 *            'Winding Fillrule'->iwinding.new;
 *         #);
 *    #);
 *)
  (#
     item: menuitem
       (#
          enabled: @boolean
          (* Set to true or false to enable or disable THIS(item) *) ;
          onSelect:< object (* Shortcut for eventhandler.onSelect *) ;
          onStatus:< booleanValue (* Shortcut for eventhandler.onStatus *)
            (#  do enabled->value; INNER #);
          new: (* Open and append THIS(Item) with label itemtext *)
            (# itemtext: ^text; 
            enter itemtext[]
            do
               true->enabled;
               open;
               (if itemtext[] <> none then itemtext[]->name if);
               THIS(item)[]->append;
               INNER ;
               
            #);
          newkey: new (* Also add key quivalent *)
            (# equiv: @char enter equiv do equiv->key #);
          newSpecKey: new (* Also add key quivalent *)
            (# (* from special keys in keys.bet *)
               key: @integer; ctrl,shift,alt: @boolean
            enter (key,shift,ctrl,alt)
            do (key,shift,ctrl,alt)->specialKey
            #);
          eventhandler::< 
            (#
               onSelect::<  (#  do THIS(item).onSelect; INNER #);
               onStatus::<  (#  do THIS(item).onStatus->value; INNER #);
               
            #);
          
       #);
     noOfRadioGroups:< integervalue
     (* The number of independant groups of radioitems.
      * Default 1.
      *) (#  do 1->value; INNER #);
     radioitem: item
     (* Special item, that is un-checked when another radioitem
      * in the radiogroup indicated by "checkgroup" is selected. 
      *)
       (#
          checkgroup: @integer
          (* The group of items THIS(item) is dependant on. default 1. *) ;
          open::<  (#  do 1->checkgroup; INNER ;  #);
          onSelect::< 
            (#  do THIS(radioitem)[]->changechecked; INNER ;  #);
          
       #);
     toggleitem: item
     (* Special item that is checked evey second time it is selected *)
       (# onSelect::<  (#  do not checked->checked; INNER ;  #) #);
     newseparator: (* Open and append a separator to THIS(simplemenu) *)
       (# 
       do &separator[]->private.s[]; private.s.open; private.s[]->append; 
       #);
     new:
     (* Open THIS(simplemenu) and append it to THIS(MenuBar) 
      * with label menutext.
      *)
       (# menutext: ^text; 
       enter menutext[]
       do
          open;
          (if menutext[] <> none then menutext[]->name if);
          (* THIS(mysimplemenu)[]->THIS(menubar).append *)
          
       #);
     changechecked: (* Explicitly change the checked item to be newitem *)
       (# newitem: ^radioitem
       enter newitem[]
       do
          (if private.oldChecked[newitem.checkgroup][] <> newitem[] then
              (if private.oldChecked[newitem.checkgroup][] <> none then
                  false->private.oldChecked[newitem.checkgroup].checked; 
              if);
              newitem[]->private.oldChecked[newitem.checkgroup][];
              true->newitem.checked;
              
          if)
       #);
     <<SLOT SimpleMenuLib:Attributes>>;
     private: @
       (#
          oldChecked: [noOfRadioGroups]
          ^radioitem;
          s: ^separator;
          
       #);
     
  #);
codeeditorEditMenu: mysimplemenu
  (#
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if formEditorExists then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     useExternalTextEditor: @boolean;
     attach:
       (#  enter cfe[] do THIS(codeEditorEditMenu)[]->cfe.theEditMenu[] #);
     writeStatus:< (# t: ^text enter t[] do INNER #);
     formEditorExists:<
       (# value: @boolean
       do INNER ; (if cfe[] <> none then true->value if)
       exit value
       #);
     allowCommand:
       (# value: @boolean
       <<SLOT editMenuAllowCommand:DoPart>>
       exit value
       #);
     allowCommandTextedit:
       (# value: @boolean; 
       do
          (if formEditorExists and not
          cfe.isReadOnly then
              cfe.askTextEditMode->value
           else
              false->value
          if)
       exit value
       #);
     allowTextAndStructure:
       (# value: @boolean
       do (if formEditorExists then not cfe.isReadOnly->value if)
       exit value
       #);
     iUndo: @item
       (#
          onStatus::  (#  <<SLOT editMenuUndoOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuUndoOnSelect:DoPart>>
            #)
       #);
     iRedo: @item
       (#
          onStatus::  (#  <<SLOT editMenuRedoOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuRedoOnSelect:DoPart>>
            #)
       #);
     iCut: @item
       (#
          onStatus::  (#  <<SLOT editMenuCutOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuCutOnSelect:DoPart>>
            #)
       #);
     iCopy: @item
       (#
          onStatus::  (#  <<SLOT editMenuCopyOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuCopyOnSelect:DoPart>>
            #)
       #);
     iPaste: @item
       (#
          onStatus::  (#  <<SLOT editMenuPasteOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuPasteOnSelect:DoPart>>
            #)
       #);
     iPasteBefore: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askInsertPermission and cfe.askPastePermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doPasteBefore #)
       #);
     iPasteAfter: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askInsertPermission and cfe.askPastePermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doPasteAfter #)
       #);
     iClear: @item
       (#
          onStatus::  (#  <<SLOT editMenuClearOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuClearOnSelect:DoPart>>
            #)
       #);
     iTextedit: @item
       (#
          onStatus::  (#  <<SLOT editMenuTextEditOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuTexteditOnSelect:DoPart>>
            #)
       #);
     iExternalTextEdit: @item
       (#
          onStatus:: 
            (#  <<SLOT editMenuiExternalTextEditOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuiExternalTextEditOnSelect:DoPart>>
            #)
       #);
     iRevertTextEdit: @item
       (#
          onStatus::  (#  <<SLOT editMenuRevertTexteditOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuRevertTexteditOnSelect:DoPart>>
            #)
       #);
     iShowTexteditCommands: @item
       (#
          onStatus:: 
            (#  <<SLOT editMenuShowTexteditCommandsOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuShowTexteditCommandsOnSelect:DoPart>>
            #)
       #);
     iInsertBefore: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askInsertPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doInsertBefore #)
       #);
     iInsertAfter: @item
       (#
          onStatus::  (#  <<SLOT editMenuiInsertAfterOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuiInsertAfterOnSelect:DoPart>>
            #)
       #);
     iRemoveOptionals: @item
       (#
          onStatus:: 
            (#  <<SLOT editMenuiRemoveOptionalsOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuiRemoveOptionalsOnSelect:DoPart>>
            #)
       #);
     iShowOptionals: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doShowOptionals #)
       #);
     iSearch: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doSearch #)
       #);
     iReplace: @item
       (#
          onStatus::  (#  <<SLOT editMenuReplaceOnStatus:DoPart>> #);
          onSelect:: 
            (#  do cfe.doReplace #)
       #);
     iSubeditor: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.
                     askOpenSubeditorPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.openSubeditor #)
       #);
     iSetIsReadOnly: @item
       (#
          onStatus::  (#  <<SLOT editMenuiSetIsReadOnlyOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT editMenuiSetIsReadOnlyOnSelect:DoPart>>
            #)
       #);
     iComment: @item
       (#
          onStatus::  (#  do allowCommandTextEdit->value #);
          onSelect::  (#  do cfe.doComment #)
       #);
     iRemoveComment: @item
       (#
          onStatus::  (#  do allowCommandTextEdit->value #);
          onSelect::  (#  do cfe.doRemoveComment #)
       #);
     open::<  (#  <<SLOT editMenuOpen:DoPart>> #)
  #);
codeeditorViewMenu: mysimplemenu
  (#
     spk: @specialKeys;
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if allowCommand then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     betaSif: @boolean;
     attach:
       (#  enter cfe[] do THIS(codeEditorViewMenu)[]->cfe.theViewMenu[] #);
     formEditorExists:<
       (# value: @boolean
       do INNER ; (if cfe[] <> none then true->value if)
       exit value
       #);
     allowCommand:
       (# value: @boolean
       <<SLOT viewMenuAllowCommand:DoPart>>
       exit value
       #);
     iAbstract: @item
       (#
          onStatus:: 
            (# 
            do allowCommand->value
            #);
          onSelect:: 
            (#  do cfe.doAbstract #)
       #);
     iAbstractRecursively: @item
       (#
          onStatus:: 
            (# 
            do allowCommand->value
            #);
          onSelect:: 
            (# 
            do cfe.doAbstractRecursively; 
            #)
       #);
     iOverview: @item
       (#
          onStatus:: 
            (# 
            do allowCommand->value
            #);
          onSelect:: 
            (#  do cfe.doOverview;  #)
       #);
     iDetail: @item
       (#
          onStatus:: 
            (# 
            do allowCommand->value
            #);
          onSelect:: 
            (#  do cfe.doDetail #)
       #);
     iDetailRecursively: @item
       (#
          onStatus:: 
            (# 
            do allowCommand->value
            #);
          onSelect:: 
            (# 
            do cfe.doDetailRecursively; 
            #)
       #);
     iFollowSemanticLink: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.cs.hasSemanticLink
                     ->value
                else
                   false->value
               if)
            #);
          onSelect:: 
            (# 
            do
               (cfe.cs.node[],false)
                 ->cfe.followSemanticLink
            #)
       #);
     iFollowLinkToFragment: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.cs.isSlot->value
                else
                   false->value
               if)
            #);
          onSelect:: 
            (# 
            do
               cfe.doCommand
                 (# 
                 do
                    cfe.
                      makeSearchSlotBinding
                 #)
            #)
       #);
     iFollowLinkToSLOT: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect:: 
            (# node: ^astInterface.ast
            <<SLOT viewMenuFollowLinkToSLOTOnSelect:DoPart>>
            #)
       #);
     iZoomIn: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand
                then
                   (if cfe.thisGroupEditor[] <> none then
                       not cfe.thisGroupEditor.isAfrejaEditor and cfe.askZoomIn
                         ->value
                    else
                       cfe.askZoomIn->value
                   if)
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doZoomIn #)
       #);
     iZoomOut: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   (if cfe.thisGroupEditor[] <> none then
                       not cfe.thisGroupEditor.isAfrejaEditor and cfe.askZoomOut
                         ->value
                    else
                       cfe.askZoomOut->value
                   if)
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doZoomOut #)
       #);
     iZoomFullEditor: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   (if cfe.thisGroupEditor[] <> none then
                       not cfe.thisGroupEditor.isAfrejaEditor and
                       cfe.askZoomFullEditor->value
                    else
                       cfe.askZoomFullEditor->value
                   if)
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doZoomFullEditor #)
       #);
     iReprettyprint: @item
       (#
          onStatus::  (#  <<SLOT viewMenuiReprettyprintOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT viewMenuiReprettyprintOnSelect:DoPart>>
            #)
       #);
     iAdaptivePrettyprinting: @item
       (#
          onStatus:: 
            (# 
            do
               allowCommand->value;
               (if formEditorExists then
                   cfe.edenv.adaptivePrettyPrinting->checked
               if)
            #);
          onSelect:: 
            (# 
            do
               not cfe.edenv.adaptivePrettyprinting
                 ->cfe.edenv.adaptivePrettyPrinting;
               
            #)
       #);
     iFormat: @item
       (#
          onStatus::  (#  <<SLOT codeeditorFormatOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            <<SLOT codeeditorFormatOnSelect:DoPart>>
            #)
       #);
     iShowAstCS: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.cs.node[]->cfe.doShowAst;  #)
       #);
     open::<  (#  <<SLOT viewMenuOpen:DoPart>> #);
     
  #);
codeeditorSLOTsMenu: mysimplemenu
  (#
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if allowCommand then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     cge: ^editorEnv.groupeditor;
     formeditorExists:<
       (# value: @boolean
       <<SLOT SLOTsMenuFormeditorExists:DoPart>>
       exit value
       #);
     groupEditorExists:<
       (# value: @boolean
       <<SLOT SLOTsMenuGroupEditorExists:DoPart>>
       exit value
       #);
     allowCommand:
       (# value: @boolean
       <<SLOT SLOTsMenuAllowCommand:DoPart>>
       exit value
       #);
     iMakeDoPartSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askMakeDoPartSlot
                     ->value
                else
                   false->value
               if)
            #);
          onSelect:: 
            (# 
            do cfe.doMakeDoPartSlot; 
            #)
       #);
     iMakeDescriptorSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.
                     askMakeDescriptorSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doMakeDescriptorSlot;  #)
       #);
     iMakeAttributesSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askMakeAttributesSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doMakeAttributesSlot;  #)
       #);
     iPasteFragmentForm: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askPasteFragmentForm->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doPasteFragmentForm;  #)
       #);
     iCreateImplementationFragment: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuCreateImplFragOnStatus:DoPart>> #);
          onSelect::  (#  do cfe.doCreateImplementationFragment;  #)
       #);
     iSelectImplementationFragment: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuSelectImplFragOnStatus:DoPart>> #);
          onSelect::  (#  do cfe.doSelectImplementationFragment;  #)
       #);
     iSetImplementationFragment: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuSetImplFragOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cge.
                 doSetImplementationFragment;
               
            #)
       #);
     iUnsetImplementationFragment: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuUnsetImplFragOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cge.
                 doUnsetImplementationFragment;
               
            #)
       #);
     iSetSLOTnamePrefix: @item
       (#
          onStatus:: 
            (#  <<SLOT SLOTsMenuSetSLOTnamePrefixOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cge.
                 doSetSLOTNamePrefix;
               
            #)
       #);
     iUnsetSLOTnamePrefix: @item
       (#
          onStatus:: 
            (#  <<SLOT SLOTsMenuUnsetSLOTnamePrefixOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cge.
                 doUnsetSLOTNamePrefix;
               
            #)
       #);
     iHideImpl: @item
       (#
          onStatus::  (#  <<SLOT SLOTsMenuHideImplOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do
               cfe.
                 doHideImplementation;
               
            #)
       #);
     iFillSlot: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.cs.isSlot->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.doFillSlot;  #)
       #);
     iFillAllSlots: @item
       (#
          onStatus::  (#  do allowCommand->value #);
          onSelect::  (#  do cfe.doFillAllSlots #)
       #);
     open::<  (#  <<SLOT SLOTsMenuOpen:DoPart>> #);
     
  #);
codeEditorPopUpMenu: mysimplemenu
  (#
     eventHandler::< 
       (#
          onSelect::< 
            (# 
            do
            (* (if allowCommand then
             'menu enable does not work!!'->putLine; enable
             else
             'menu disable does not work!!'->putLine; disable
             if)*) 
            #)
       #);
     cfe: ^codeeditor;
     betaSif: @boolean;
     attach:
       (# 
       enter cfe[]
       do THIS(codeEditorPopUpMenu)[]->cfe.thePopUpMenu[]
       #);
     formEditorExists:<
       (# value: @boolean
       do INNER ; (if cfe[] <> none then true->value if)
       exit value
       #);
     allowCommand:
       (# value: @boolean
       <<SLOT popUpMenuAllowCommand:DoPart>>
       exit value
       #);
     allowCommandTextedit:
       (# value: @boolean; 
       do
          (if formEditorExists and not
          cfe.isReadOnly then
              cfe.askTextEditMode->value
           else
              false->value
          if)
       exit value
       #);
     allowTextAndStructure:
       (# value: @boolean
       do (if formEditorExists then not cfe.isReadOnly->value if)
       exit value
       #);
     iBack: @item
       (#
          onStatus::  (#  <<SLOT codeeditorPopUpMenuBackOnStatus:DoPart>> #);
          onSelect::  (#  <<SLOT codeeditorPopUpMenuBackOnSelect:DoPart>> #)
       #);
     iForward: @item
       (#
          onStatus:: 
            (# 
            <<SLOT codeeditorPopUpMenuForwardOnStatus:DoPart>>
            #);
          onSelect:: 
            (#  <<SLOT codeeditorPopUpMenuForwardOnSelect:DoPart>> #)
       #);
     iFollow: @item
       (#
          followSubMenu:
            @mysimplemenu
            (#
               iFollowSemanticLink: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.cs.hasSemanticLink->value
                          else
                             false->value
                         if)
                      #);
                    onSelect:: 
                      (# 
                      do (cfe.cs.node[],false)->cfe.followSemanticLink
                      #)
                 #);
               iFollowSemanticLinkSeparate: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.cs.hasSemanticLink->value
                          else
                             false->value
                         if)
                      #);
                    onSelect:: 
                      (#  do (cfe.cs.node[],true)->cfe.followSemanticLink #)
                 #);
               iFollowLinkToFragment: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.cs.isSlot->value
                          else
                             false->value
                         if)
                      #);
                    onSelect:: 
                      (# 
                      do cfe.doCommand (#  do cfe.makeSearchSlotBinding #)
                      #)
                 #);
               iFollowLinkToFragmentSeparate: @item
                 (#
                    onStatus:: 
                      (# 
                      <<SLOT popupMenuFollowLinkToFragmentSeparateOnStatus:DoPart>>
                      #);
                    onSelect:: 
                      (# 
                      <<SLOT popupMenuFollowLinkToFragmentSeparateOnSelect:DoPart>>
                      #)
                 #);
               iFollowLinkToSLOT: @item
                 (#
                    onStatus::  (#  do allowCommand->value #);
                    onSelect:: 
                      (# node: ^astInterface.ast
                      <<SLOT popupMenuFollowLinkToSLOTonSelect:DoPart>>
                      #)
                 #);
               iFollowLinkToSLOTSeparate: @item
                 (#
                    onStatus:: 
                      (# 
                      <<SLOT popupMenuFollowLinkToSLOTSeparateOnStatus:DoPart>>
                      #);
                    onSelect:: 
                      (# node: ^astInterface.ast
                      <<SLOT popupMenuFollowLinkToSLOTSeparateOnSelect:DoPart>>
                      #)
                 #);
               open::<  (#  <<SLOT popupMenuFollowOpen:DoPart>> #)
            #);
          open::< 
            (# 
            do
               followSubMenu.open;
               followSubMenu[]->subMenu
            #)
       #);
     iOpenSeparate: @item
       (#
          onStatus:: 
            (# 
            do allowCommand->value
            #);
          onSelect:: 
            (# 
            <<SLOT popupMenuOpenSeparateOnSelect:DoPart>>
            #)
       #);
     iSubeditor: @item
       (#
          onStatus:: 
            (# 
            do
               (if allowCommand then
                   cfe.askOpenSubeditorPermission->value
                else
                   false->value
               if)
            #);
          onSelect::  (#  do cfe.openSubeditor #)
       #);
     iShowDiagram: @item
       (#
          onStatus::  (#  <<SLOT popupMenuShowDiagramOnStatus:DoPart>> #);
          onSelect:: 
            (# 
            do cfe.showDiagram
            #)
       #);
     iEditUserInterface: @item
       (#
          onStatus:: 
            (# 
            <<SLOT popupMenuGUIOnStatus:DoPart>>
            #);
          onSelect::  (#  <<SLOT popupMenuGUIOnSelect:DoPart>> #)
       #);
     iEdit: @item
       (#
          editSubMenu: @mysimplemenu
            (#
               iCut: @item
                 (#
                    onStatus:: 
                      (# 
                      <<SLOT popupMenuCutOnStatus:DoPart>>
                      #);
                    onSelect::  (#  <<SLOT popupMenuCutOnSelect:DoPart>> #)
                 #);
               iCopy: @item
                 (#
                    onStatus:: 
                      (# 
                      <<SLOT popupMenuCopyOnStatus:DoPart>>
                      #);
                    onSelect::  (#  <<SLOT popupMenuCopyOnSelect:DoPart>> #)
                 #);
               iPaste: @item
                 (#
                    onStatus:: 
                      (# 
                      <<SLOT popupMenuPasteOnStatus:DoPart>>
                      #);
                    onSelect::  (#  <<SLOT popupMenuPasteOnSelect:DoPart>> #)
                 #);
               iPasteBefore: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.askInsertPermission and cfe.askPastePermission
                               ->value
                          else
                             false->value
                         if)
                      #);
                    onSelect::  (#  do cfe.doPasteBefore #)
                 #);
               iPasteAfter: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.askInsertPermission and cfe.askPastePermission
                               ->value
                          else
                             false->value
                         if)
                      #);
                    onSelect::  (#  do cfe.doPasteAfter #)
                 #);
               iInsertBefore: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.askInsertPermission->value
                          else
                             false->value
                         if)
                      #);
                    onSelect::  (#  do cfe.doInsertBefore #)
                 #);
               iInsertAfter: @item
                 (#
                    onStatus:: 
                      (# 
                      do
                         (if allowCommand then
                             cfe.askInsertPermission->value
                          else
                             false->value
                         if)
                      #);
                    onSelect::  (#  do cfe.doInsertAfter #)
                 #);
               iComment: @item
                 (#
                    onStatus::  (#  do allowCommandTextedit->value #);
                    onSelect::  (#  do cfe.doComment #)
                 #);
               iRemoveComment: @item
                 (#
                    onStatus::  (#  do allowCommandTextedit->value #);
                    onSelect::  (#  do cfe.doRemoveComment #)
                 #);
               open::<  (#  <<SLOT popupMenuEditOpen:DoPart>> #)
            #);
          open::< 
            (# 
            do
               editSubMenu.open;
               editSubMenu[]->subMenu
            #)
       #);
     iDebug: @item
       (#
          onStatus:: 
            (# 
            <<SLOT codeeditorPopupMenuDebugOnStatus:DoPart>>
            #);
          onSelect:: 
            (#  <<SLOT codeeditorPopupMenuDebugOnSelect:DoPart>> #);
          
       #);
     iReprettyprint: @item
       (#
          onStatus:: 
            (# 
            do
               allowCommand
                 ->value
            #);
          onSelect:: 
            (# 
            do
               cfe.
                 doReprettyprint;
               
            #)
       #);
     open::<  (#  <<SLOT popupMenuOpen:DoPart>> #);
     
  #);
propertyEditor: codeeditor
  (#
     theGroupEditor: ^editorEnv.groupeditor;
     ffObserverType::< 
       (#
          private:
            @<<SLOT propertyEditorPrivate:Descriptor>>;
          onAstReplaced::< 
            (#  <<SLOT propertyeditorOnAstReplaced:DoPart>> #);
          onAstReplacedSequence::< 
            (# 
            <<SLOT propertyeditorOnAstReplacedSequence:DoPart>>
            #);
          onListElementInserted::< 
            (#  <<SLOT propertyeditorOnListElementInserted:DoPart>> #);
          onListElementsDeleted::< 
            (#  <<SLOT propertyeditorOnListElementsDeleted:DoPart>> #);
          onListElementsReplaced::< 
            (#  <<SLOT propertyeditorOnListElementsReplaced:DoPart>> #)
       #);
     
  #);
editorenv: sifEditorEnv
  (#
     mps: ^astInterface;
     betaGrammar:
     (*^astInterface.treelevel;*) ^astInterface.beta;
     betaGram: (* contains all the syntactic category numbers *) @grammar;
     propertyGrammar: ^astInterface.treeLevel;
     prettyprintGrammar: ^astInterface.treeLevel;
     mg: ^astInterface.metagrammar;
     mpsErrorReporter: ^mps.errorReporter;
     UI: ^guienv;
     setWaitCursor: (#  <<SLOT editorenvSetWaitCursor:DoPart>> #);
     setStructureCursor:
       (# 
       <<SLOT editorenvSetStructureCursor:DoPart>>
       #);
     rightButtonCursor: ^guienv.cursor;
     setRightButtonCursor:
       (#  <<SLOT editorenvSetRightButtonCursor:DoPart>> #);
     textCursor: ^guienv.cursor;
     setTextCursor:
       (# 
       <<SLOT editorenvSetTextCursor:DoPart>>
       #);
     initiator: ^text;
     globalWriteProtection: @boolean;
     setGlobalWriteProtection:
       (# value: @boolean
       enter value
       <<SLOT editorenvSetGlobalWriteProtection:DoPart>>
       #);
     textediting: @boolean;
     contractOnOpen: @boolean;
     adaptivePrettyprinting:
       @boolean;
     useExternalTextEditor: @boolean;
     doQuit: @boolean;
     onGoingRecovery: @boolean;
     BETAsif: @boolean;
     openingFrejaEditor: @boolean;
     clip: ^clipBoard;
     clipBoard:
       (#
          synCatNo: @mps.nonterminalSymbol;
          fragments: @mps.astList;
          length: @integer;
          
       #);
     clippedff: ^astInterface.fragmentForm;
     makeSLOTfrag: ^astInterface.fragmentForm;
     makeSLOTtype: @integer;
     fillSLOTfrag: ^astInterface.fragmentForm;
     fillSLOTtype: @integer;
     clippedfrag: ^astInterface.fragmentForm;
     clippedfragtype: @integer;
     implementationGroupEditor: ^groupEditor;
     slotNamePrefix: @text;
     formEditorNo: @integer;
     nextEditorId:
       (#  do formEditorNo+1->formEditorNo exit formEditorNo #);
     doCommand:
       (#  do setWaitCursor; INNER doCommand; setStructureCursor #);
     history: @
       (#
          historyList: list (# element:: mps.ast;  #);
          h: ^historyList;
          init: (#  do &historyList[]->h[]; h.init; true->doUpdate #);
          currentCell: ^h.theCellType;
          private: @<<SLOT editorenvhistoryprivate:Descriptor>>;
          current:
            (#
               node:
                 ^astInterface.ast
            <<SLOT editorenvHistoryCurrent:DoPart>>
            exit node[]
            #);
          add:
            (# node: ^astInterface.ast
            enter node[]
            <<SLOT editorenvHistoryAdd:DoPart>>
            #);
          remove:
            (# node: ^astInterface.ast
            enter node[]
            <<SLOT editorenvHistoryRemove:DoPart>>
            #);
          backPossible:
            (# node: ^astInterface.ast; value: @boolean
            enter node[]
            <<SLOT editorEnvHistoryBackPossible:DoPart>>
            exit value
            #);
          back: doCommand
            (#
               currentNode,newNode:
                 ^astInterface.ast
            enter currentNode[]
            <<SLOT editorEnvHistoryBack:DoPart>>
            exit newNode[]
            #);
          forwardPossible:
            (#
               node: ^astInterface.ast;
               value: @boolean
            enter node[]
            <<SLOT editorEnvHistoryForwardPossible:DoPart>>
            exit value
            #);
          forward: doCommand
            (# currentNode,newNode: ^astInterface.ast
            enter currentNode[]
            <<SLOT editorenvHistoryForward:DoPart>>
            exit newNode[]
            #);
          doUpdate: @boolean;
          protect:
            (# 
            do
               <<SLOT editorenvHistoryProtect:Descriptor>>
            #)
       #);
     trace: [20] @boolean;
     switch: [20] @boolean;
     editorenvPrivate: @<<SLOT editorenvPrivate:Descriptor>>;
     uep:
       @<<SLOT userEditorenvPrivate:Descriptor>>;
     new: doCommand
       (#
          theBrowser: ^object;
          grammarName,groupName,formName: ^text;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],grammarName[],groupName[],formName[])
       <<SLOT editorenvNew:DoPart>>
       exit fg[]
       #);
     newBetaProgram: doCommand
       (#
          theBrowser: ^object;
          name: ^text;
          isAFrejaEditor: @boolean;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],name[],isAFrejaEditor)
       <<SLOT editorEnvNewBetaProgram:DoPart>>
       exit fg[]
       #);
     newBetaLibrary: doCommand
       (#
          theBrowser: ^object;
          name: ^text;
          isAFrejaEditor: @boolean;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],name[],isAFrejaEditor)
       <<SLOT editorenvNewBetaLibrary:DoPart>>
       exit fg[]
       #);
     newBetaBody: doCommand
       (#
          theBrowser: ^object;
          name: ^text;
          isAFrejaEditor: @boolean;
          fg: ^astInterface.fragmentGroup
       enter (theBrowser[],name[],isAFrejaEditor)
       <<SLOT editorenvNewBetaBody:DoPart>>
       exit fg[]
       #);
     openForm:
       (#
          name: ^text;
          index: @integer;
          ff: ^astInterface.fragmentForm;
          node: ^astInterface.ast
       enter (name[],index)
       do <<SLOT openFormBody:Descriptor>>
       exit (ff[],node[])
       #);
     saveAll:
       (# 
       <<SLOT editorenvSaveAll:DoPart>>
       #);
     makeNewTextFile:
       (# fg: ^astInterface.fragmentGroup
       enter fg[]
       do <<SLOT editorenvMakeNewTextFile:Descriptor>>; 
       #);
     fragmentGroupList: list
       (# element:: text #);
     searchTextDialog:
       (#
          ge: ^groupEditor;
          ce: ^codeeditor;
          fg:
            ^astInterface.
               fragmentGroup;
          ff: ^astInterface.fragmentForm;
          fgList: ^fragmentGroupList;
          keepSearchCriteria: @boolean;
          found:<
            (# foundNode: ^astInterface.ast
            enter foundNode[]
            do INNER
            #);
          notFound:< (# searchText: ^text enter searchText[] do INNER #)
       enter (ge[],ce[],fg[],ff[],fgList[],keepSearchCriteria)
       do <<SLOT editorenvSearchTextDialog:Descriptor>>
       #);
     replaceTextDialog:
       (#
          ge: ^groupEditor;
          ce: ^codeeditor;
          fg:
            ^astInterface.
               fragmentGroup;
          ff: ^astInterface.fragmentForm;
          fgList: ^fragmentGroupList;
          keepSearchCriteria: @boolean;
          found:<
            (# foundNode: ^astInterface.ast
            enter foundNode[]
            do INNER
            #);
          notFound:< (# searchText: ^text enter searchText[] do INNER #)
       enter (ge[],ce[],fg[],ff[],fgList[],keepSearchCriteria)
       do <<SLOT editorenvReplaceTextDialog:Descriptor>>
       #);
     searchDialogOpened:
       @boolean;
     replaceDialogOpened:
       @boolean;
     searchPrivate: @<<SLOT editorenvSearchPrivate:Descriptor>>;
     inLexem:
     (* true if t is in the text of node and node is a lexem *)
       (#
          t: ^text;
          node: ^astInterface.ast;
          found,caseSensitive,wholeWord: @boolean
       enter (t[],node[],caseSensitive,wholeWord)
       <<SLOT editorenvInLexem:DoPart>>
       exit found
       #);
     hasSemanticLink:
       (#
          node: ^astInterface.ast;
          value: @boolean;
          theDecl: ^astInterface.ast;
          semanticErrorsOrNotChecked: @boolean
       enter node[]
       do <<SLOT codeeditorHasSemanticLink:Descriptor>>
       exit
       (value,theDecl[],
        semanticErrorsOrNotChecked)
       #);
     isApplicationOf:
     (* value is true if node is an application of theNameDcl *)
       (#
          node: ^astInterface.ast;
          theNameDcl: ^betaGrammar.nameDcl;
          value,semanticErrorsOrNotChecked: @boolean
       enter (node[],theNameDcl[])
       <<SLOT editorenvIsApplicationOf:DoPart>>
       exit
       (value,
        semanticErrorsOrNotChecked)
       #);
     searchText:
       (#
          t: ^text;
          direction: @integer;
          ge: ^groupEditor;
          ce: ^codeeditor;
          fg:
            ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          fgList: ^fragmentGroupList;
          findDeclaration: @boolean;
          node: ^astInterface.ast;
          found:<
            (# foundNode: ^astInterface enter foundNode[] do INNER #);
          notFound:< object;
          
       enter (t[],direction,ge[],ce[],fg[],ff[],fgList[],findDeclaration)
       do <<SLOT editorenvSearchText:Descriptor>>
       exit node[]
       #);
     replaceText:
       (#
          theSearchText,theReplaceText:
            ^text;
          direction: @integer;
          ge: ^groupEditor;
          ce: ^codeeditor;
          fg: ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          fgList: ^fragmentGroupList;
          node: ^astInterface.ast;
          found:<
            (# foundNode: ^astInterface enter foundNode[] do INNER #);
          notFound:< object;
          
       enter
       (theSearchText[],theReplaceText[],direction,ge[],ce[],fg[],ff[],fgList[])
       do <<SLOT editorenvReplaceText:Descriptor>>
       exit node[]
       #);
     scanGroupForText:
       (#
          t: ^text;
          direction: @integer;
          fg:
            ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          current: ^astInterface.ast;
          
       enter (t[],fg[],ff[])
       do <<SLOT editorenvScanGroupForText:Descriptor>>
       #);
     groupEditor:
       (#
          fg:
            ^astInterface.
               fragmentGroup;
          no: @integer;
          theBrowserId: @integer;
          groupFileWriteable: @boolean;
          isReadOnly: @boolean;
          setIsReadOnly:
            (# value: @boolean
            enter value
            <<SLOT groupeditorSetIsReadOnly:DoPart>>
            #);
          grammarName: ^text;
          touched,oldTouched: @integer;
          isAFrejaEditor: @boolean;
          needToUpdateTextFile:
            @boolean;
          autoSaveFileExists: @boolean;
          thePropertyEditor: ^codeeditor;
          fgTitle:
            (# fgName: ^text
            <<SLOT groupeditorFGtitle:DoPart>>
            exit fgName[]
            #);
          fgObserverType:<
           fg.sifFragmentGroupObserver
            (#
               private:
                 @<<SLOT fgObserverPrivate:Descriptor>>;
               onNameChanged::< 
                 (#  <<SLOT fgObserverOnNameChanged:DoPart>> #);
               onFragmentInserted::< 
                 (# 
                 <<SLOT fgObserverOnFragInserted:DoPart>>
                 #);
               onFragmentDeleted::< 
                 (#  <<SLOT fgObserverOnFragDeleted:DoPart>> #);
               onPropertiesChanged::< 
                 (# 
                 <<SLOT fgObserverOnPropertyChanged:DoPart>>
                 #);
               onGroupSaved::< 
                 (#  <<SLOT fgObserverOnGroupSaved:DoPart>> #);
               onGroupNotSaved::< 
                 (# 
                 <<SLOT fgObserverOnGroupNotSaved:DoPart>>
                 #);
               onGroupAutoSaved::< 
                 (#  <<SLOT fgObserverOnGroupAutoSaved:DoPart>> #);
               onGroupChecked::< 
                 (# 
                 <<SLOT fgObserverOnGroupChecked:DoPart>>
                 #);
               onGroupLocked::< 
                 (#  <<SLOT fgObserverOnGroupLocked:DoPart>> #);
               onGroupUnlocked::< 
                 (# 
                 <<SLOT fgObserverOnGroupUnlocked:DoPart>>
                 #);
               onBeforeGroupClose::< 
                 (#  <<SLOT fgObserverOnBeforeGroupClose:DoPart>> #);
               onGroupClosed::< 
                 (# 
                 <<SLOT fgObserverOnGroupClosed:DoPart>>
                 #);
               onRefresh::<  (#  <<SLOT fgObserverOnRefresh:DoPart>> #);
               onTouched::< 
                 (# 
                 <<SLOT fgObserverOnTouched:DoPart>>
                 #);
               onDetouched::<  (#  <<SLOT fgObserverOnDetouched:DoPart>> #);
               onCloseUntouchedGroup::< 
                 (#  <<SLOT fgObserverOnCloseUntouchedGroup:DoPart>> #)
            #);
          fgObserver:
            ^fgObserverType;
          formEditorList: @list
            (#
               element:: codeeditor;
               findOrCreateEditor:
                 (# ff: ^astInterface.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindOrCreateEditor:DoPart>>
                 exit fe[]
                 #);
               findEditor:
                 (# ff: ^astInterface.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindEditor:DoPart>>
                 exit fe[]
                 #);
               findEditorId:
                 (# id: @integer; fe: ^codeviewer
                 enter id
                 <<SLOT groupeditorFormeditorListFindEditorId:DoPart>>
                 exit fe[]
                 #)
            #);
          ugp: @<<SLOT userGroupEditorPrivate:Descriptor>>;
          userOnOpenGroupeditor:
           <<SLOT userOnOpenGroupeditor:Descriptor>>;
          closeGroup: booleanValue
            (#  <<SLOT groupeditorCloseGroup:DoPart>> #);
          save: doCommand
            (#
               doUpdateTextFile,doGC,
                 doDeleteAutosaveFile,OK: @boolean
            enter (doUpdateTextFile,doGC,doDeleteAutosaveFile)
            <<SLOT groupEditorSave:DoPart>>
            exit OK
            #);
          saveAs: doCommand
            (# newName: ^text
            <<SLOT groupeditorSaveAs:DoPart>>
            exit newName[]
            #);
          saveAbstract: doCommand
            (# 
            <<SLOT groupeditorSaveAbstract:DoPart>>
            #);
          recover: doCommand (#  <<SLOT groupeditorRecover:DoPart>> #);
          revert: doCommand
            (# 
            <<SLOT groupeditorRevert:DoPart>>
            #);
          checkAutoSave: (#  <<SLOT groupEditorCheckAutoSave:DoPart>> #);
          autoSave:
            (# 
            <<SLOT groupeditorAutoSave:DoPart>>
            #);
          nonterminalsExist:
            (# unexpandedExist: @boolean; unexp: ^astInterface.unexpanded
            do <<SLOT groupeditorNonterminalsExist:Descriptor>>
            exit
            (unexpandedExist,
             unexp[])
            #);
          addProp:
            (#
               propName,propString: ^text;
               propExists:<
                 (# delete: @boolean
                 do true->delete; INNER
                 exit delete
                 #)
            enter (propName[],propString[])
            <<SLOT groupeditorAddProp:DoPart>>
            #);
          deleteProp:
            (#
               propName,propString: ^text;
               propNotFound:< object
            enter (propName[],propString[])
            <<SLOT groupeditorDeleteProp:DoPart>>
            #);
          resetGroupTouch:
            (#  <<SLOT groupeditorResetGroupTouch:DoPart>> #);
          groupTouched:
            (# 
            <<SLOT groupeeditorGroupTouched:DoPart>>
            #);
          groupDetouched: (#  <<SLOT groupeditorGroupDetouched:DoPart>> #);
          myAddFragment:
            (#
               g: ^astInterface.fragmentGroup;
               f: ^astInterface.fragment;
               beforeElement: ^g.fragmentListElement;
               status: @boolean;
               
            enter (g[],f[],beforeElement[])
            <<SLOT groupeditorMyAddFragment:DoPart>>
            exit status
            #);
          getFragmentListElement:
            (# ff: ^astInterface.fragmentForm; fle: ^fg.fragmentListElement
            enter ff[]
            <<SLOT groupeditorGetFragmentListElement:DoPart>>
            exit fle[]
            #);
          getBrotherff:
            (#
               ff,brotherff:
                 ^astInterface.
                    fragmentForm
            enter ff[]
            <<SLOT groupeditorGetBrotherff:DoPart>>
            exit brotherff[]
            #);
          askUndoPermission:
            (# value: @boolean
            <<SLOT groupeditorAskUndoPermission:DoPart>>
            exit value
            #);
          askPastePermission:
            (# ff: ^astInterface.fragmentForm; value: @boolean
            enter ff[]
            <<SLOT groupeditorAskPastePermission:DoPart>>
            exit value
            #);
          askInsertPermission:
            (# value: @boolean
            <<SLOT groupeditorAskInsertPermission:DoPart>>
            exit value
            #);
          undo: (#  <<SLOT groupeditorUndo:DoPart>> #);
          cutForm: doCommand
            (#
               ff,brotherff:
                 ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorCutForm:DoPart>>
            exit brotherff[]
            #);
          copyForm: doCommand
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorCopyForm:DoPart>>
            #);
          pasteForm: doCommand
            (#
               ff,newff:
                 ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorPasteForm:DoPart>>
            exit newff[]
            #);
          insertForm:
            (#
               ff: ^astInterface.fragmentForm;
               synCatNo: @integer;
               newff: ^astInterface.fragmentForm
            enter (ff[],synCatNo)
            <<SLOT groupeditorInsertForm:DoPart>>
            exit newff[]
            #);
          editProperties:
            (# 
            <<SLOT groupeditorEditProperties:DoPart>>
            #);
          editPropertiesCanvas:
            (# fatherCanvas: ^canvas; editor: ^codeEditor; 
            enter fatherCanvas[]
            <<SLOT groupeditorEditPropertiescanvas:DoPart>>
            exit editor[]
            #);
          createPropertyEditor:
            (# theSifTextEditor: ^sifTexteditor
            enter theSifTexteditor[]
            <<SLOT groupeditorCreatePropertyEditor:DoPart>>
            #);
          editFormName:
            (# ff: ^astInterface.fragmentForm
            enter ff[]
            <<SLOT groupeditorEditFormName:DoPart>>
            #);
          searchSLOT:
            (#
               ff:
                 ^astInterface.
                    fragmentForm;
               theSLOTNode: ^astInterface.ast
            enter ff[]
            do <<SLOT groupeditorSearchSlot:Descriptor>>
            exit theSLOTnode[]
            #);
          doSetImplementationFragment:
           (#  <<SLOT doSetImplementationFragment:DoPart>> #);
          doUnsetImplementationFragment:
            (#  <<SLOT doUnsetImplementationFragment:DoPart>> #);
          doSetSLOTNamePrefix:
            (# 
            <<SLOT doSetSLOTNameprefix:DoPart>>
            #);
          doUnsetSLOTNamePrefix:
            (#  <<SLOT doUnsetSLOTNameprefix:DoPart>> #)
       #);
     groupEditorList: @list
       (#
          element:: groupEditor;
          CreateGroupEditor:
            (#
               theBrowserId: @integer;
               fg:
                 ^astInterface.
                    fragmentGroup;
               readOnly: @boolean;
               ge: ^groupEditor
            enter (theBrowserId,fg[],readOnly)
            <<SLOT editorenvCreateGroupEditor:DoPart>>
            exit ge[]
            #);
          findOrCreateGroupEditor:
            (#
               theBrowserId: @integer;
               fg: ^astInterface.fragmentGroup;
               readOnly: @boolean;
               ge: ^groupEditor
            enter (theBrowserId,fg[],readOnly)
            <<SLOT editorenvFindOrCreateGroupEditor:DoPart>>
            exit ge[]
            #);
          findGroupEditor:
            (#
               theBrowserId: @integer;
               fg: ^astInterface.fragmentGroup;
               ge: ^groupEditor
            enter (theBrowserId,fg[])
            <<SLOT editorenvFindGroupEditor:DoPart>>
            exit ge[]
            #)
       #);
     fragmentDefaultName:
       (# f: @file
       enter f.name
       exit f.entry.path.name.prefix
       #);
     showEditors:
       (# 
       <<SLOT editorenvShowEditors:DoPart>>
       #);
     findOrCreateGroupEditor: groupEditorList.findOrCreateGroupEditor
       (#  #);
     createGroupEditor: groupEditorList.CreateGroupEditor (#  #);
     createFormEditor:
       (#
          ff: ^astInterface.fragmentForm;
          theEditorRoot,initialSelection: ^astInterface.ast;
          theSifTextEditor: ^sifTexteditor;
          ge: ^groupEditor;
          fe: ^codeeditor
       enter (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
       do <<SLOT editorEnvCreateFormEditor:Descriptor>>
       exit fe[]
       #);
     findOrCreateFormEditor:
       (#
          ff:
            ^astInterface.
               fragmentForm;
          theEditorRoot,initialSelection: ^astInterface.ast;
          theSifTextEditor: ^sifTexteditor;
          ge: ^groupEditor;
          fe: ^codeeditor
       enter (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
       do <<SLOT editorEnvFindOrCreateFormEditor:Descriptor>>
       exit fe[]
       #);
     findEditorForForm:
     (* given a fragmentform and an AST node inside it (selectedNode), 
      * find an Editor on the fragmentform and select the AST node 
      * if not found create the editor
      * id is used in the communication with Freja
      *)
       (#
          ff: ^astInterface.fragmentForm;
          selectedNode: ^astInterface.ast;
          fe: ^codeeditor
       enter (ff[],selectedNode[])
       do <<SLOT findEditorForFormBody:Descriptor>>
       exit fe[]
       #);
     findFormEditorId:
       (# id: @integer; fe: ^codeeditor
       enter id
       <<SLOT findFormEditorId:DoPart>>
       exit fe[]
       #);
     frejaExternalInterface: ^frejaInterface;
     ymerCallback: ^ymerCall;
     nonterminalsExist:
       (#
          unexpandedExist: @boolean;
          unexp: ^astInterface.unexpanded
       do
          <<SLOT editorenvNonterminalsExist:Descriptor>>
       exit (unexpandedExist,unexp[])
       #);
     wriggleWindows: @boolean;
     init:
       (#  enter (mps[],betaGrammar[],UI[]) <<SLOT editorEnvInit:DoPart>> #)
  #)  

-- lib: Attributes --
sifEditorenv: (#  #)  

