ORIGIN 'codeviewer';
INCLUDE '~beta/guienv/v1.3.1/utils/simplemenu'
        '~beta/freja/v2.0/frejasifcomm';
BODY 'private/parsing'
     'private/misc'
     'private/selection'
     'private/derivation'
     'private/delete'
     'private/doundo'
     'private/search'
     'private/optionals'
     'private/notification'
     'private/codeeditorbody'
     'private/updatemenus'
     'private/textediting'
     'private/editorenvbody'
     'private/groupeditorbody'
     'private/frejacommbody';
-- windowlib: Attributes --
codeEditor: codeViewer
  (#
     edenv: ^editorEnv;
     thisGroupEditor: ^edenv.groupeditor;
     isAFrejaEditor,notifyFreja: @boolean;
     frejaStatusOn: @boolean;
     frejaEditTypeStatus: @text;
     frejaEditStatus: @text;
     frejaExpandStatus: @text;
     dir: @
       (#
          up: (#  exit 0 #);
          down: (#  exit 1 #);
          pred: (#  exit 2 #);
          next: (#  exit 3 #);
          root: (#  exit 4 #);
          extend: (#  exit 5 #);
          nextNonterminal: (#  exit 6 #);
          prevNonterminal: (#  exit 7 #);
          
       #);
     parsingPossible: @boolean;
     editingMode: @integer;
     structureMode: (#  exit 0 #);
     editLexemMode: (#  exit 1 #);
     editAndParseMode: (#  exit 2 #);
     TEexit: @
       (#
          escape: (#  exit 0 #);
          parseMode: (#  exit 1 #);
          exitMode: (#  exit 2 #);
          
       #);
     undoElem: ^undoElemType;
     undoElemType:
       (#
          fatherRef: ^mps.expanded;
          sonPos: @integer;
          fragments: @edenv.partlist;
          fragmentLength,undoLength: @integer
          (* fragmentLength is the length of the undoElem, 
           undoLength is the length of the fragment to be
           replaced by the undoElem.                     *) ;
          isDeleted: @boolean
          (* if true then undoElem is deleted from the program 
           else it is replaced by another fragment           *)
       exit (fatherRef[],sonPos,fragments.elm[1][],fragmentLength)
       #);
     updateHistory::<  (#  do node[]->edenv.history.add #);
     checkFormEditorExistence::< 
       (#  <<SLOT codeeditorCheckFormEditorExistence:DoPart>> #);
     setupFormEditor::< 
       (# 
       <<SLOT codeeditorSetupFormeditor:DoPart>>
       #);
     subject05: (* some useful editor specific operations: misc.bet *)
       (#  #);
     makeUndoElem:
       (#
          fatherNode: ^mps.expanded;
          sonPos,undoLength: @integer;
          undoFocus:
          (* undoLength is the number of nodes undoFocus should be replaced 
           with when undone .                                             *)
            @astFocus;
          isDeleted: @boolean;
          
       enter (fatherNode[],sonPos,undoFocus,undoLength,isDeleted)
       do <<SLOT makeUndoElemBody:Descriptor>>
       #);
     getSynCatNo:
       (#
          node: ^mps.ast;
          synCatNo: @mps.nonterminalSymbol;
          
       enter node[]
       do
          <<SLOT getSynCatNoBody:Descriptor>>
       exit synCatNo
       #);
     setSynCatNo:
       (# synCatNo: @mps.nonterminalSymbol; programNode: ^mps.expanded; 
       enter (synCatNo,programNode[])
       do <<SLOT setSynCatNoBody:Descriptor>>
       #);
     findSynNameAtt:
       (#
          production: ^mg.prod;
          synCatNo: @mps.nonterminalSymbol;
          
       enter production[]
       do
          <<SLOT findSynNameAttBody:Descriptor>>
       exit synCatNo
       #);
     showAst: (#  do <<SLOT showAstBody:Descriptor>> #);
     subject1:
     (* parsing operations: parsing.bet *) (#  #);
     substitute:
       (# oldFragment,newFragment: ^mps.ast; 
       enter (oldFragment[],newFragment[])
       do <<SLOT substituteBody:Descriptor>>
       #);
     listSubstitute:
       (#
          f: @astFocus; theList: ^mps.list; 
       enter (f,theList[])
       do
          <<SLOT listSubstituteBody:Descriptor>>
       exit f
       #);
     findSuper:
       (# synCatNo: @mps.nonterminalSymbol; 
       enter synCatNo
       do <<SLOT findSuperBody:Descriptor>>
       exit synCatNo
       #);
     parsingSynCatNo:
       (#
          node: ^mps.ast;
          synCatNo: @mps.nonterminalSymbol;
          isList: @boolean;
          theListElement: ^mps.ast;
          
       enter node[]
       do
          <<SLOT parsingSynCatNoBody:Descriptor>>
       exit (synCatNo,isList,theListElement[])
       #);
     parseText:
       (# f: @astFocus; t: ^text; parseOK: @boolean
       enter (f,t[])
       do <<SLOT parseTextBody:Descriptor>>
       exit (parseOK,f)
       #);
     subject2: (* undo operation: undo.bet *)
       (#  #);
     undo:
       (# 
       do <<SLOT undoBody:Descriptor>>
       #);
     subject3:
     (* derivation operations: derivation.bet *) (#  #);
     ins: @
       (#
          first: (#  exit 1 #);
          before: (#  exit 2 #);
          after: (#  exit 3 #)
       #);
     createList:
       (#
          synCatNo: @mps.nonterminalSymbol;
          prod: ^mg.prod;
          fatherNode: ^mps.expanded;
          isSon: @integer
       enter (synCatNo,prod[],fatherNode[],isSon)
       do <<SLOT createListBody:Descriptor>>
       #);
     new:
       (# 
       do <<SLOT newBody:Descriptor>>
       #);
     newPrivate:
       (# 
       do
          <<SLOT newPrivateBody:Descriptor>>
       #);
     expand:
       (#
          fatherNode: ^mps.expanded;
          isSon: @integer;
          synCatNo: @mps.nonterminalSymbol;
          
       enter (synCatNo,fatherNode[],isSon)
       do <<SLOT expandBody:Descriptor>>
       #);
     nodeExpand:
       (#
          synCatNo: @mps.nonterminalSymbol;
          newLexem: @boolean;
          
       enter (synCatNo,newLexem)
       do <<SLOT nodeExpandBody:Descriptor>>
       #);
     expandLexem:
       (# t: ^text;  enter t[] do <<SLOT expandLexemBody:Descriptor>> #);
     listInsert:
       (# command: @integer; 
       enter command
       do <<SLOT listInsertBody:Descriptor>>
       #);
     expandOptional: (#  do <<SLOT expandOptionalBody:Descriptor>> #);
     subject4:
     (* navigation operations: selection.bet *) (#  #);
     selectNewCs: (#  do <<SLOT selectNewCsBody:Descriptor>> #);
     checkSon:
       (# 
       do <<SLOT checkSonBody:Descriptor>>
       #);
     checkSonNode:
       (# node: ^mps.ast
       enter node[]
       do <<SLOT checkSonNodeBody:Descriptor>>
       exit node[]
       #);
     checkFather:
       (# 
       do
          cs.node[]->checkFatherNode
            ->cs.node[]
       #);
     checkFatherNode:
       (# node: ^mps.ast
       enter node[]
       do
          <<SLOT checkFatherNodeBody:Descriptor>>
       exit node[]
       #);
     extend: (#  do <<SLOT extendBody:Descriptor>> #);
     down:
       (#  do <<SLOT downBody:Descriptor>> #);
     navigate:
       (# direction: @integer; 
       enter direction
       do <<SLOT navigateBody:Descriptor>>
       #);
     select:
       (# direction: @integer; 
       enter direction
       do <<SLOT selectBody:Descriptor>>
       #);
     gotoNonterminal: (#  do <<SLOT gotoNonterminalBody:Descriptor>> #);
     gotoNonEmpty:
       (# 
       do
          <<SLOT gotoNonEmptyBody:Descriptor>>
       #);
     nextNonterminal: (#  do <<SLOT nextNonterminalBody:Descriptor>> #);
     prevNonterminal:
       (# 
       do
          <<SLOT prevNonterminalBody:Descriptor>>
       #);
     subject5: (* delete operations: delete.bet *) (#  #);
     deleted: @boolean;
     cut:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT cutFragmentBody:Descriptor>>
       #);
     makeEmptyListOrOpt:
       (# 
       do
          <<SLOT makeEmptyListOrOptBody:Descriptor>>
       #);
     paste:
       (#
          doNotNotify: @boolean;
          (* if not specified the default is that notification
           * events will be generated
           *)
          
       enter doNotNotify
       do <<SLOT pasteFragmentBody:Descriptor>>
       #);
     copy:
       (# 
       do
          <<SLOT copyFragmentBody:Descriptor>>
       #);
     subject7: (* search operations: search.bet *) (#  #);
     searchPrivate: @<<SLOT searchPrivate:Descriptor>>;
     searchText:
       (# t: ^text; parseOK: @boolean
       enter t[]
       do <<SLOT searchTextBody:Descriptor>>
       exit
       parseOK
       #);
     searchStructure: (#  do <<SLOT searchStructureBody:Descriptor>> #);
     searchNext:
       (# found: @boolean
       do
          <<SLOT searchNextBody:Descriptor>>
       exit found
       #);
     searchPrev:
       (# found: @boolean
       do <<SLOT searchPrevBody:Descriptor>>
       exit found
       #);
     searchName:
       (# name: ^text; found: @boolean
       enter name[]
       do <<SLOT searchNameBody:Descriptor>>
       exit
       found
       #);
     subject8: (* comment operations: comment.bet *) (#  #);
     removeOptionals:
       (# node: ^mps.ast; 
       enter node[]
       do <<SLOT removeOptionalsBody:Descriptor>>
       #);
     insertOptionals:
       (# node: ^mps.ast; 
       enter node[]
       do
          <<SLOT insertOptionalsBody:Descriptor>>
       #);
     removeEmptyElement:
       (# theList: ^mps.list; 
       enter theList[]
       do <<SLOT removeEmptyElementBody:Descriptor>>
       #);
     removeEmptyElements:
       (# node: ^mps.ast; 
       enter node[]
       do
          <<SLOT removeEmptyElementsBody:Descriptor>>
       #);
     onExternCommand:
       (# command,status: ^text; 
       enter command[]
       do <<SLOT onExternCommandBody:Descriptor>>
       exit status[]
       #);
     externCommand:
       (# command,status: ^text; 
       enter command[]
       do
          <<SLOT externCommandBody:Descriptor>>
       exit status[]
       #);
     subject9:
     (* The following virtual patterns (events) are called in the model
      every time certain changes are made.
      These patterns are specialized in the application.*) (#  #);
     editorEvent: (#  do INNER #);
     noOfAstChanges,ASLimit,touched: @integer;
     resetFragmentTouch: <<SLOT resetFragmentTouchBody:Descriptor>>;
     fragmentTouched:
      <<SLOT fragmentTouchedBody:Descriptor>>;
     fragmentDetouched: <<SLOT fragmentDetouchedBody:Descriptor>>;
     autoSaveLimit:<
       (# 
       do
          <<SLOT autoSaveLimitBody:Descriptor>>;
          INNER
       #);
     autoSave:< (#  <<SLOT autoSaveBody:DoPart>> #);
     onPopUpButton::< 
       (#  <<SLOT onPopUpButton:DoPart>> #);
     fragmentChangedEvent: editorEvent
       (#  do <<SLOT fragmentChangedEventBody:Descriptor>>; INNER #);
     newFragmentEvent:<
       (# 
       do
          <<SLOT frejaCommNewFragment:Descriptor>>;
          <<SLOT notificationNewFragment:Descriptor>>;
          
       #);
     aNewFragmentEvent: @NewFragmentEvent;
     astReplacedEvent:< fragmentChangedEvent
       (# oldAst,newAst: ^mps.ast; 
       enter (oldAst[],newAst[])
       do
          <<SLOT frejaCommAstReplaced:Descriptor>>;
          <<SLOT notificationAstReplaced:Descriptor>>
       #);
     anAstReplacedEvent: @astReplacedEvent;
     makeAstReplacedEvent:
       (# sequence: @boolean
       enter sequence
       <<SLOT MakeAstReplaced:DoPart>>
       #);
     astReplacedElement:
       (# oldAst,newAst: ^mps.ast #);
     astReplacedList: @list
       (#
          element:: astReplacedElement;
          appendElement:
            (#
               oldAst,newAst: ^mps.ast;
               e: ^astReplacedElement;
               
            enter (oldAst[],newAst[])
            do
               &astReplacedElement[]->e[];
               oldAst[]->e.oldAst[];
               newAst[]->e.newAst[];
               e[]->append
            #)
       #);
     astReplacedSequenceEvent:<
      fragmentChangedEvent
       (# rootOfSequence: ^mps.ast
       enter rootOfSequence[]
       do
          <<SLOT frejaCommAstReplacedSequence:Descriptor>>;
          <<SLOT notificationAstReplacedSequence:Descriptor>>
       #);
     listElementInsertedEvent:< fragmentChangedEvent
       (# position: @integer; fatherNode: ^mps.expanded; 
       enter (fatherNode[],position)
       do
          <<SLOT frejaCommListElementInserted:Descriptor>>;
          <<SLOT notificationListElementInserted:Descriptor>>
       #);
     aListElementInsertedEvent: @listElementInsertedEvent;
     listElementsDeletedEvent:< fragmentChangedEvent
       (#
          oldElements: ^edenv.partList;
          listNode: ^mps.expanded;
          position,length: @integer
       enter (listNode[],position,length,oldElements[])
       do
          <<SLOT frejaCommListElementsDeleted:Descriptor>>;
          <<SLOT notificationListElementsDeleted:Descriptor>>
       #);
     aListElementsDeletedEvent: @listElementsDeletedEvent;
     listElementsReplacedEvent:< fragmentChangedEvent
       (#
          oldElement: ^edenv.partList;
          listNode: ^mps.expanded;
          position,length,newLength: @integer
       enter (listNode[],position,length,oldElement[],newLength)
       do
          <<SLOT frejaCommListElementsReplaced:Descriptor>>;
          <<SLOT notificationListElementsReplaced:Descriptor>>
       #);
     aListElementsReplacedEvent: @listElementsreplacedEvent;
     focusChangedEvent::< 
       (# 
       do
          <<SLOT notificationFocusChanged:Descriptor>>;
          <<SLOT frejaCommFocusChanged:Descriptor>>
       #);
     visibleInFreja:
       (# node: ^mps.ast; value: @boolean; 
       enter node[]
       do <<SLOT visibleInFreja:Descriptor>>
       exit value
       #);
     expandMenuPrivate: ^expmenuprivate;
     expmenuprivate:
      <<SLOT expandMenuPrivate:Descriptor>>;
     updateExpandMenu: (#  do <<SLOT updateExpandMenuBody:Descriptor>> #);
     updateEditMenu: (#  do <<SLOT editMenuUpdateBody:Descriptor>> #);
     askUndoPermission::< 
       (#  do cs.undoPermit->value #);
     askPastePermission::< 
       (# 
       do cs.pastePermit->value
       #);
     askInsertPermission::< 
       (# 
       do cs.listInsertPermit->value
       #);
     texteditMode:
       (# 
       enter theSifTextEditor.textediting
       exit theSifTextEditor.textediting
       #);
     askTexteditMode::<  (#  do textEditMode->value #);
     doUndo::<  (#  do undo #);
     doCut::<  (#  do true->cs.undoPermit; cut #);
     doCopy::<  (#  do true->cs.undoPermit; copy; updateEditMenu #);
     doPaste::<  (#  do paste #);
     TE: ^texteditingPrivate;
     texteditingPrivate: <<SLOT texteditingPrivate:Descriptor>>;
     doTextedit::< 
       (# 
       <<SLOT doTextedit:DoPart>>
       #);
     checkTexteditingFinished::< 
       (#  do <<SLOT checkTexteditingFinished:Descriptor>>;  #);
     doParseText::< 
       (# 
       <<SLOT doParseText:DoPart>>
       #);
     doRevertTextedit::<  (#  <<SLOT doRevertTextediting:DoPart>> #);
     doShowTexteditCommands::< 
       (# 
       <<SLOT doShowTexteditingCommands:DoPart>>
       #);
     doInsertBefore::< 
       (#  do true->cs.undoPermit; ins.before->listInsert #);
     doInsertAfter::<  (#  do true->cs.undoPermit; ins.after->listInsert #);
     doRemoveOptionals::< 
       (#  do cs.perform (#  do current[]->removeOptionals #) #);
     doShowOptionals::< 
       (#  do cs.perform (#  do current[]->insertOptionals #) #);
     init::<  (#  <<SLOT codeeditorinit:DoPart>> #)
  #);
editorenv:
  (#
     mps: ^astInterface;
     betaGrammar: (*^mps.treelevel;*) ^mps.beta;
     betaGram:
     (* contains all the syntactic category numbers *) @grammar;
     UI: ^guienv;
     contractOnOpen,onlyNotifyFreja: @boolean;
     doQuit: @boolean;
     partList: (# elm: [50] ^mps.ast #);
     clip: ^clipBoard;
     clipBoard:
       (#
          synCatNo: @mps.nonterminalSymbol;
          fragments: @partList;
          length: @integer;
          
       #);
     clippedff: ^mps.fragmentForm;
     makeSLOTfrag: ^mps.fragmentForm;
     makeSLOTtype: @integer;
     fillSLOTfrag: ^mps.fragmentForm;
     fillSLOTtype: @integer;
     clippedfrag: ^mps.fragmentForm;
     clippedfragtype: @integer;
     lastCompiledFragment: ^mps.fragmentGroup;
     formsWithSemanticErrors: @list (# element::< mps.fragmentForm #);
     formEditorNo: @integer;
     nextEditorId:
       (#  do formEditorNo+1->formEditorNo exit formEditorNo #);
     history: @list
       (#
          element:: mps.ast;
          currentCell: ^theCellType;
          private: @<<SLOT editorenvhistoryprivate:Descriptor>>;
          current:
            (# node: ^mps.ast
            <<SLOT editorenvHistoryCurrent:DoPart>>
            exit node[]
            #);
          add:
            (# node: ^mps.ast
            enter node[]
            <<SLOT editorenvHistoryAdd:DoPart>>
            #);
          remove:
            (# node: ^mps.ast
            enter node[]
            <<SLOT editorenvHistoryRemove:DoPart>>
            #);
          backPossible:
            (# value: @boolean
            <<SLOT editorEnvHistoryBackPossible:DoPart>>
            exit value
            #);
          back:
            (# node: ^mps.ast
            <<SLOT editorEnvHistoryBack:DoPart>>
            exit node[]
            #);
          forwardPossible:
            (# value: @boolean
            <<SLOT editorEnvHistoryForwardPossible:DoPart>>
            exit value
            #);
          forward:
            (# node: ^mps.ast
            <<SLOT editorenvHistoryForward:DoPart>>
            exit node[]
            #)
       #);
     trace: [10] @boolean;
     editorenvPrivate: @<<SLOT editorenvPrivate:Descriptor>>;
     mypromptForText:
       (#
          message,defaultText: ^text;
          confirm:<
            (# theText: ^text
            enter theText[]
            do INNER
            #);
          cancel:< object;
          
       enter (message[],defaultText[])
       <<SLOT editorEnvMypromptForText:DoPart>>
       #);
     new:
       (# name: ^text; isAFrejaEditor: @boolean; ge: ^groupeditor
       enter (name[],isAfrejaEditor)
       <<SLOT editorenvNew:DoPart>>
       exit ge[]
       #);
     newBetaProgram:
       (#
          name: ^text;
          isAFrejaEditor: @boolean;
          ge: ^groupeditor
       enter (name[],isAfrejaEditor)
       <<SLOT editorEnvNewBetaProgram:DoPart>>
       exit ge[]
       #);
     newBetaLibrary:
       (# name: ^text; isAFrejaEditor: @boolean; ge: ^groupeditor
       enter (name[],isAfrejaEditor)
       <<SLOT editorenvNewBetaLibrary:DoPart>>
       exit ge[]
       #);
     openForm:
       (#
          name: ^text;
          index: @integer;
          ff: ^mps.fragmentForm;
          node: ^mps.ast
       enter (name[],index)
       do
          <<SLOT openFormBody:Descriptor>>
       exit (ff[],node[])
       #);
     groupEditor:
       (#
          fg: ^mps.fragmentGroup;
          writeAccess: @boolean;
          touched: @integer;
          isAFrejaEditor: @boolean;
          needToUpdateBetFile: @boolean;
          formEditorList: @list
            (#
               element:: codeviewer;
               findOrCreateEditor:
                 (# ff: ^mps.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindOrCreateEditor:DoPart>>
                 exit fe[]
                 #);
               findEditor:
                 (# ff: ^mps.fragmentForm; fe: ^codeviewer
                 enter ff[]
                 <<SLOT groupeditorFormeditorListFindEditor:DoPart>>
                 exit fe[]
                 #);
               findEditorId:
                 (# id: @integer; fe: ^codeviewer
                 enter id
                 <<SLOT groupeditorFormeditorListFindEditorId:DoPart>>
                 exit fe[]
                 #)
            #);
          closeGroup: (#  <<SLOT groupeditorCloseGroup:DoPart>> #);
          save:
            (# 
            <<SLOT groupEditorSave:DoPart>>
            #);
          saveAs: (#  <<SLOT groupeditorSaveAs:DoPart>> #);
          saveAbstract:
            (# 
            <<SLOT groupeditorSaveAbstract:DoPart>>
            #);
          recover: (#  <<SLOT groupeditorRecover:DoPart>> #);
          revert:
            (# 
            <<SLOT groupeditorRevert:DoPart>>
            #);
          resetGroupTouch:
            (#  <<SLOT groupeditorResetGroupTouch:DoPart>> #);
          groupTouched:
            (# 
            <<SLOT groupeeditorGroupTouched:DoPart>>
            #);
          groupDetouched: (#  <<SLOT groupeditorGroupDetouched:DoPart>> #);
          myAddFragment:
            (#
               g: ^mps.fragmentGroup;
               f: ^mps.fragment;
               beforeElement: ^g.fragmentListElement;
               status: @boolean;
               
            enter (g[],f[],beforeElement[])
            <<SLOT groupeditorMyAddFragment:DoPart>>
            exit status
            #);
          getFragmentListElement:
            (# ff: ^mps.fragmentForm; fle: ^fg.fragmentListElement
            enter ff[]
            <<SLOT groupeditorGetFragmentListElement:DoPart>>
            exit fle[]
            #);
          askUndoPermission:
            (#
               value: @boolean
            <<SLOT groupeditorAskUndoPermission:DoPart>>
            exit value
            #);
          askPastePermission:
            (# ff: ^mps.fragmentForm; value: @boolean
            enter ff[]
            <<SLOT groupeditorAskPastePermission:DoPart>>
            exit value
            #);
          askInsertPermission:
            (# value: @boolean
            <<SLOT groupeditorAskInsertPermission:DoPart>>
            exit value
            #);
          undo: (#  <<SLOT groupeditorUndo:DoPart>> #);
          cutForm:
            (# ff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorCutForm:DoPart>>
            #);
          copyForm:
            (# ff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorCopyForm:DoPart>>
            #);
          pasteForm:
            (# ff,newff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorPasteForm:DoPart>>
            exit newff[]
            #);
          insertForm:
            (#
               ff: ^mps.fragmentForm;
               synCatNo: @integer;
               newff: ^mps.fragmentForm
            enter (ff[],synCatNo)
            <<SLOT groupeditorInsertForm:DoPart>>
            exit newff[]
            #);
          editProperties:
            (# 
            <<SLOT groupeditorEditProperties:DoPart>>
            #);
          editFormName:
            (# ff: ^mps.fragmentForm
            enter ff[]
            <<SLOT groupeditorEditFormName:DoPart>>
            #);
          onExternCommand:
            (# command,status: ^text; 
            enter command[]
            do
               <<SLOT onGroupExternCommandBody:Descriptor>>
            exit status[]
            #)
       #);
     groupEditorList: @list
       (#
          element:: groupEditor;
          findOrCreateGroupEditor:
            (# fg: ^mps.fragmentGroup; ge: ^groupEditor
            enter fg[]
            <<SLOT editorenvFindOrCreateGroupEditor:DoPart>>
            exit ge[]
            #);
          findGroupEditor:
            (#
               fg:
                 ^mps.
                    fragmentGroup;
               ge: ^groupEditor
            enter fg[]
            <<SLOT editorenvFindGroupEditor:DoPart>>
            exit ge[]
            #)
       #);
     findEditorForForm:
     (* given a fragmentform and an AST node inside it (selectedNode), 
      * find an Editor on the fragmentform and select the AST node 
      * if not found create the editor
      * id is used in the communication with Freja
      *)
       (# ff: ^mps.fragmentForm; selectedNode: ^mps.ast; fe: ^codeeditor
       enter (ff[],selectedNode[])
       do <<SLOT findEditorForFormBody:Descriptor>>
       exit fe[]
       #);
     findFormEditorId:
       (# id: @integer; fe: ^codeeditor
       enter id
       <<SLOT findFormEditorId:DoPart>>
       exit fe[]
       #);
     commObject: ^communication;
     init:
       (# 
       enter (mps[],betaGrammar[],UI[])
       do &clipBoard[]->clip[]
       #)
  #)  

