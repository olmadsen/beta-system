ORIGIN '~beta/guienv/v1.3.1/guienv';
BODY 'private/siftexteditorbody'
     'private/codeviewerbody'
     'private/selection'
     'private/search';
INCLUDE '~beta/guienv/v1.3.1/guienv'
        '~beta/guienv/v1.3.1/fields'
        '~beta/guienv/v1.3.1/guienvactions'
        '~beta/guienv/v1.3.1/stddialogs'
        '~beta/guienv/v1.3.1/utils/textfieldadds'
        '~beta/guienv/v1.3.1/utils/prompts'
        '~beta/guienv/v1.3.1/utils/timer'
        '~beta/pretty/v4.9.1/pplib'
        '~beta/betaast/v4.9.1/betasematt'
        '~beta/mps/v4.9.1/private/astparser'
        '~beta/betaast/v4.9.1/donecheck'
        '~beta/betaast/v4.9.1/gram'
        '~beta/sysutils/v1.4/envstring';
-- windowlib: Attributes --
sifTextEditor: textEditor
  (#
     charWidthType:< IntegerValue
       (#
          ts: ^textStyle;
          sz: @Point;
          count,sum: @Integer;
          ch: @Char;
          viewsize: @Point;
          
       enter viewsize
       do
          (if ts[]
           // none then
              contents.defaultStyle->ts[];
              (if ts[]
               // none then
                  INNER ;
                  (if ts[]
                   // none then system.systemTextStyle[]->ts[]; 
                  if);
                  
              if);
              
          if);
          'a'->ch;
          loop:
          (if ch <= 'z' then
              (ch->ts.widthOfChar)+sum->sum;
              (ch->ascii.upcase->ts.widthOfChar)+sum->sum;
              count+2->count;
              ch+1->ch;
              restart loop;
              
          if);
          '0'->ch;
          loop:
          (if ch <= '9' then
              (ch->ts.widthOfChar)+sum->sum;
              count+1->count;
              ch+1->ch;
              restart loop;
              
          if);
          viewsize.h div (sum div count)->value;
          
       #);
     charWidth: @charWidthType;
     codeViewerType:< codeViewer;
     initialContractionLevel:<
       (# value: @integer
       <<SLOT siftexteditorInitialContractionLevel:DoPart>>
       exit value
       #);
     readOnly:<
      booleanObject (#  do INNER ; value->isReadOnly;  exit value #);
     isReadOnly: @boolean;
     SifViewer: ^codeviewerType;
     mps: ^astInterface;
     betaGrammar: (*^astInterface.treelevel;*) ^astInterface.beta;
     theGrammar: ^astInterface.treeLevel;
     isApropertyEditor: @boolean;
     isAsubeditor: @boolean;
     UI: ^guienv;
     frag: ^astInterface.fragmentForm;
     editorRoot:
     (* root of this editor normally the same as frag.root, except in subeditors *)
     ^astInterface.ast;
     start,end: @integer;
     fragDotRoot: @
       (#
          setRoot: @
            (# node: ^astInterface.ast
            enter node[]
            do node[]->frag.root[]->editorRoot[]
            #)
       enter setRoot
       exit frag.root[]
       #);
     initialSelection: (* inititial selection *) ^astInterface.ast;
     theWindow: (#  exit THIS(window)[] #);
     textEditing: @boolean;
     onOpen:< (#  <<SLOT codeviewerOnOpen:DoPart>> #);
     onDoubleClick:<
       (#
          start,end: @integer;
          modifier: @boolean
       enter (start,end,modifier)
       <<SLOT codeviewerOnDoubleClick:DoPart>>
       #);
     onClick:<
       (# start,end,line1,char1,line2,char2: @integer
       enter (start,end)
       <<SLOT codeviewerOnClick:DoPart>>
       #);
     enterTextEditing:
       (# ch: @char
       enter ch
       <<SLOT codeviewerEnterTextEditing:DoPart>>
       #);
     exitTextEditing: (#  <<SLOT codeviewerExitTextEditing:DoPart>> #);
     prettyprinting: @boolean;
     showContents:
       (# 
       do
          (if SifViewer.switch[2] then
              (if SifViewer.switch[3]
               then
                  'contents: '->screen.putLine;
                  '['->screen.put;
                  contents.contents->screen.putText;
                  ']'->screen.put;
                  screen.newLine;
                  'contents: (scan) '->screen.putLine;
                  '['->screen.put;
                  contents.all
                    ->contents.scanText
                      (# 
                      do
                         (if ch
                          // ascii.sp then
                             ','->screen.put
                          // ascii.newline then
                             '<cr>'->screen.putText
                          else
                             ch->screen.put
                         if)
                      #);
                  ']'->screen.put;
                  screen.newLine
              if);
              'selection: '->screen.putText;
              contents.selection.start->screen.putint;
              ' '->screen.put;
              contents.selection.end->screen.putint;
              screen.newLine;
              'selection.contents: '->screen.putLine;
              '['->screen.put;
              contents.selection.contents->screen.putText;
              ']'->screen.put;
              'selection.contents: (scan)'->screen.putLine;
              '['->screen.put;
              (contents.selection.start,contents.selection.end)
                ->contents.scanText
                  (# 
                  do
                     (if ch
                      // ascii.sp then
                         ','->screen.put
                      // ascii.newline then
                         '<cr>'->screen.putText
                      else
                         ch->screen.put
                     if)
                  #);
              ']'->screen.put;
              screen.newLine;
              'length: '->screen.putText;
              contents.length->screen.putInt;
              screen.newLine
          if)
       #);
     contentstype::< 
       (#
          <<SLOT codeviewercontentsLib:Attributes>>;
          draggingSelection: @boolean;
          skipMouseUp: @Boolean;
          eventHandler::< 
            (#
               oldSelection: @point;
               theTimer: @timer
                 (#
                    action:: 
                      (# 
                      do
                         pause;
                         (if
                         sifViewer[] <> none then
                             (if SifViewer.switch[1] then
                                 'onIdle'->putLine; 
                             if);
                             (if draggingSelection then
                                 oldSelection->onClick; false->draggingSelection
                             if)
                         if);
                         
                      #);
                    
                 #);
               onKeyDown::<  (#  <<SLOT codeViewerOnKeyDown:DoPart>> #);
               onMouseDown::< 
                 (# 
                 <<SLOT codeViewerOnMouseDown:DoPart>>
                 #);
               onMouseUp::<  (#  <<SLOT codeviewerOnMouseUp:DoPart>> #);
               onBeforeChange::< 
                 (# 
                 <<SLOT codeViewerOnBeforeChange:DoPart>>
                 #);
               onTextChanged::< 
                 (# 
                 do
                    (if sifViewer[] <> none then
                        (if SifViewer.switch[1] then
                            'onTextChanged'->putLine; 
                        if);
                        INNER
                    if);
                    
                 #);
               onFrameChanged::< 
                 (#  do <<SLOT siftexteditorOnFrameChanged:Descriptor>> #);
               
            #);
          
       #);
     selectArea:
       (#
          line1,pos1,line2,pos2:
            @integer
       enter (line1,pos1,line2,pos2)
       <<SLOT siftexteditorSelectArea:DoPart>>
       #);
     deleteline:
       (# lineno: @integer; 
       enter lineno
       do
          <<SLOT sdeWtexteditordeleteline:Descriptor>>
       #);
     deletelines:
       (# lineno,number: @integer; 
       enter (lineno,number)
       do <<SLOT sdeWtexteditordeletelines:Descriptor>>
       #);
     deleteArea:
       (#
          line1,pos1,line2,pos2:
            @integer
       enter (line1,pos1,line2,pos2)
       <<SLOT siftexteditorDeleteArea:DoPart>>
       #);
     insertline:
       (#
          lineno: @integer; tt: ^text; 
       enter (tt[],lineno)
       do
          <<SLOT sdeWtexteditorinsertline:Descriptor>>
       #);
     getline:
       (# lineno: @integer; tt: ^text; 
       enter lineno
       do <<SLOT sdeWtexteditorgetline:Descriptor>>
       exit tt[]
       #);
     insertText:
       (# tt: ^text; 
       enter tt[]
       do
          <<SLOT sdeWtexteditorinsertText:Descriptor>>
       #);
     replaceText: (#  #);
     setText:
       (# tt: ^text; 
       enter tt[]
       do <<SLOT sdeWtexteditorsetText:Descriptor>>
       #);
     getText:
       (#
          lineno: @integer;
          tt: ^text;
          
       enter lineno
       do
          <<SLOT sdeWtexteditorgetText:Descriptor>>
       exit tt[]
       #);
     delete:
       (# lineno: @integer; tt: ^text; 
       enter lineno
       do <<SLOT sdeWtexteditordelete:Descriptor>>
       exit tt[]
       #);
     before:
       (# 
       do
          <<SLOT sdeWtexteditorbefore:Descriptor>>
       #);
     after: (#  do <<SLOT sdeWtexteditorafter:Descriptor>> #);
     refresh:
       (#
          lineno: @integer; tt: ^text; 
       enter lineno
       do
          <<SLOT sdeWtexteditorrefresh:Descriptor>>
       exit tt[]
       #);
     lastPosition:
       (# pos: @integer
       <<SLOT sdeWtexteditorLastposition:DoPart>>
       exit pos
       #);
     posToLineChar:
       (#
          pos: @integer;
          line,char: @integer;
          
       enter pos
       <<SLOT sdeWtexteditorposToLineChar:DoPart>>
       exit (line,char)
       #);
     lineCharToPos:
       (# line,char: @integer; pos: @integer; 
       enter (line,char)
       <<SLOT sdeWtexteditorlineCharToPos:DoPart>>
       exit pos
       #);
     closeGroup:
     (* if value then close is OK *) booleanValue
       (#  <<SLOT siftexteditorCloseGroup:DoPart>> #);
     saveGroup:
       (# 
       <<SLOT siftexteditorSaveGroup:DoPart>>
       #);
     saveGroupAs:
       (# name: ^text
       enter name[]
       <<SLOT siftexteditorSaveGroupAs:DoPart>>
       #);
     newGroup:
       (# 
       <<SLOT siftexteditorNewGroup:DoPart>>
       #);
     newfragment:<
       (#
          theEditorRoot,initialSelection: ^astInterface.ast;
          ed: ^codeviewerType
       enter (mps[],theGrammar[],theEditorRoot[],initialSelection[])
       <<SLOT siftexteditorNewfragment:DoPart>>
       exit ed[]
       #);
     open::< 
       (#
          defaultSize:<
            (# value: @Point; 
            <<SLOT siftexteditorDefaultSize:DoPart>>
            exit value
            #);
          
       <<SLOT siftexteditorOpen:DoPart>>
       #);
     close::<  (#  <<SLOT siftexteditorClose:DoPart>> #)
  #);
codeviewer:
  (#
     mps: ^astInterface;
     betaGrammar: (*^astInterface.treelevel;*)
       ^astInterface.beta;
     betaGram: @grammar;
     mg: ^astInterface.metagrammar;
     prodList: ^mg.productionList;
     gram:< mps.treelevel;
     ag (* applicationGrammar *) : ^gram;
     theGrammar: ^astInterface.treeLevel;
     isApropertyEditor: @boolean;
     isAsubeditor: @boolean;
     fg: ^astInterface.fragmentGroup;
     frag: ^astInterface.fragmentForm;
     editorRoot:
     (* root of this editor normally the same as frag.root, except in subeditors *)
     ^astInterface.ast;
     start,end: @integer;
     fragDotRoot: @
       (#
          setRoot: @
            (# node: ^astInterface.ast
            enter node[]
            do node[]->frag.root[]->editorRoot[]
            #)
       enter setRoot
       exit frag.root[]
       #);
     initialSelection: (* inititial selection *) ^astInterface.ast;
     UI: ^guienv;
     readOnly:< booleanObject
       (#  do INNER ; value->isReadOnly;  exit value #);
     isReadOnly: @boolean;
     theSifTextEditor: ^sifTextEditor;
     id: @integer;
     doObserveAST,traceSLOTsearch: @boolean;
     setWaitCursor: (#  do ui.cursors.watch[]->UI.mouse.busyCursor #);
     setStructureCursor: (#  do none ->UI.mouse.busyCursor #);
     onUpArrowKey:< (#  <<SLOT codeviewerOnUpArrowKey:DoPart>> #);
     onDownArrowKey:<
       (# 
       <<SLOT codeviewerOnDownArrowKey:DoPart>>
       #);
     onLeftArrowKey:< (#  <<SLOT codeviewerOnLeftArrowKey:DoPart>> #);
     onRightArrowKey:<
       (# 
       <<SLOT codeviewerOnRightArrowKey:DoPart>>
       #);
     onReturnKey:< (#  <<SLOT codeviewerOnReturnKey:DoPart>> #);
     fragmentDefaultName:
       (# f: @file
       enter f.name
       exit f.entry.path.name.prefix
       #);
     generalOutput: astView.output
       (#
          printSpecialComment::< 
            (#
               skipLeadingBlanks:
                 @boolean;
               
            do
               0->noOfLines;
               astView.pp.comBegin.lgth
                 ->lengthOfLastLine;
               astView.pp.comBegin[]
                 ->putText;
               false->skipLeadingBlanks;
               com.scanAll
                 (# 
                 do
                    (if ch
                     // ascii.newLine then
                        noOfLines+1->noOfLines;
                        1->lengthOfLastLine;
                        lineNo+1->lineNo;
                        lineNo->newLine;
                        (for margin+1 repeat ' '->put for);
                        true->skipLeadingBlanks;
                        
                     else
                        (if skipLeadingBlanks then
                            (if not (ch->ascii.isSpace) then
                                ch->put;
                                lengthOfLastLine+1->lengthOfLastLine;
                                false->skipLeadingBlanks
                            if)
                         else
                        (* skipping tabs *)
                            (if (ch->ascii.isSpace) then
                                (if ch
                                 // ascii.sp then
                                    ch->put;
                                    lengthOfLastLine+1->lengthOfLastLine;
                                    
                                 else
                                    'eating tabs in comment: '->screen.putText;
                                    ch->screen.putInt;
                                    screen.newLine;
                                    ' '->put;
                                    
                                if)
                             else
                                ch->put; lengthOfLastLine+1->lengthOfLastLine; 
                            if);
                            
                        if);
                        
                    if);
                    
                 #);
               lengthOfLastLine+astView.pp.comEnd.lgth->lengthOfLastLine;
               astView.pp.comEnd[]->putText;
               
            #);
          measureSpecialComment::< 
            (# 
            do
               (if (com.lgth > 40) then
                   100
                     ->length
                     (* only used to provoke a break
                      * the length 
                      *)
               if);
               
            #);
          (*putT: @screen.putText;
           putL: @screen.putLine;
           putC: @screen.put;
           *)
          
       #);
     checkFormEditorExistence:<
       (#
          ff: ^astInterface.fragmentForm;
          createIfNotExists: @boolean;
          theSifViewer: ^codeViewer
       enter (ff[],createIfNotExists)
       <<SLOT codeviewerCheckFormEditorExistence:DoPart>>
       exit theSifViewer[]
       #);
     setupFormEditor:<
       (# theSifViewer: ^codeViewer
       enter theSifViewer[]
       <<SLOT codeviewerSetupFormEditor:DoPart>>
       #);
     closeGroup:<
     (* if value then close is OK *) booleanValue;
     closeForm:< object;
     windowOutput: generalOutput
       (#
          windowLine,theWholeText: ^text;
          beforePresent::< 
            (# 
            do
               (if switch[1] then 'out. beforePresent'->screen.putLine;  if);
               theWholeText.clear;
               theSifTexteditor.before;
               ;
               
            #);
          afterPresent::< 
            (# 
            do
               (if switch[1] then 'out.afterPresent'->screen.putLine;  if);
               theWholeText[]->theSifTexteditor.insertText;
               theSifTexteditor.after;
               
            #);
          beforeUpdate::< 
            (# 
            do
               (if switch[1] then 'out.beforeUpdate'->screen.putLine;  if);
               theWholeText.clear;
               theSifTexteditor.before;
               
            #);
          afterUpdate::< 
            (# 
            do
               (if switch[1] then 'out.afterUpdate'->screen.putLine;  if);
               theWholeText[]->theSifTexteditor.insertText;
               theSifTexteditor.after;
               
            #);
          put::<  (#  do ch->windowLine.put;  #);
          putText::<  (#  do s[]->windowLine.putText;  #);
          putInt::<  (#  do n->windowLine.putInt #);
          selectArea::< 
            (# 
            do
               (if switch[1] then 'out.selectArea'->screen.putLine;  if);
               ((row1,col1,row2,col2))->theSifTexteditor.selectArea;
               
            #);
          clear::< 
            (# 
            do
               (if switch[1] then 'out.clear'->screen.putLine;  if);
               theSifTexteditor.contents.all
                 ->theSifTexteditor.contents.selection;
               theSifTexteditor.contents.clear
            #);
          newLine::< 
            (# 
            do
               (if switch[1] then 'out.newLine'->screen.putLine;  if);
               (if windowLine.length > 0 then
                   windowLine[]->theWholeText.putLine; windowLine.clear; 
                else
               (*'eating emtyline!'->screen.putLine;*)
                   
               if);
               
            #);
          insertLine::< 
            (# 
            do
               (if switch[1] then 'out.insertLine'->screen.putLine;  if);
               ('  ',lineNo)->theSifTexteditor.insertLine;
               
            #);
          deleteLine::< 
            (# 
            do
               (if switch[1] then 'out.deleteLine'->screen.putLine;  if);
               lineNo->theSifTexteditor.deleteLine;
               
            #);
          deleteLines::< 
            (# 
            do
            (*(for i:number repeat
             lineNo -> theSifTexteditor.contents.deleteLine;
             for) *)
               (if switch[1] then 'out.deleteLines'->screen.putLine;  if);
               (lineNo,number)->theSifTexteditor.deleteLines;
               
            #);
          deleteArea::< 
            (# 
            do
               (if switch[1] then 'out.deleteArea'->screen.putLine;  if);
               ((line1,pos1,line2,pos2))->theSifTexteditor.deleteArea
            #);
          getLine::< 
            (# 
            do
               (if switch[1] then 'out.getLine'->screen.putLine;  if);
               lineNo->theSifTexteditor.getLine->s[];
               
            #);
          init::< 
            (# 
            do
               (if switch[1] then 'out.init'->screen.putLine;  if);
               &text[]->windowLine[];
               &text[]->theWholeText[];
               
            #);
          
       #);
     astFocus: (* end earlier in pretty *)
       (#
          node: ^astInterface.ast;
          length,subCommentInx1,subCommentInx2: @integer;
          isComment,isContraction,isSlot,hasSemanticLink,isUnexpanded:
            @boolean;
          pastePermit,listInsertPermit,undoPermit: @boolean;
          perform:
            (#
               current: ^astInterface.ast;
               fatherNode: ^astInterface.ast;
               exp: ^astInterface.expanded
            do
               (if length = 1 then
                   node[]->current[];
                   INNER perform;
                   (current[],current[])->astView.pp.update
                else
                   node.father->fatherNode[];
                   (if fatherNode[] <> none then
                       (if fatherNode.kind = mps.kinds.interior then
                           fatherNode[]->exp[];
                           (for i: length repeat
                             node.sonNo+i-1->exp.get->current[];
                             INNER perform;
                             (current[],current[])->astView.pp.update
                           for);
                           (* (exp[],node.sonNo,length,length)
                            ->astView.pp.updateList*)
                           
                       if)
                   if);
                   
               if);
               (node[],length,subCommentInx1,subCommentInx2)->astToSelection;
               
            #);
          
       enter (node[],length,subCommentInx1,subCommentInx2)
       exit (node[],length,subCommentInx1,subCommentInx2)
       #);
     cs: @astFocus;
     astView: ^astInterface.astViewer;
     switch: [100] @boolean;
     doTrace,edDebug: @boolean;
     trace:
       (# str: ^text
       do
          (if doTrace then
              INNER ; '/'->screen.put; str[]->screen.putText; 
          if)
       #);
     test:
       (# str: ^text; 
       do (if edDebug then INNER ; str[]->screen.putText;  if)
       #);
     dir: @
       (#
          up: (#  exit 0 #);
          down: (#  exit 1 #);
          pred: (#  exit 2 #);
          next: (#  exit 3 #);
          root: (#  exit 4 #);
          extend: (#  exit 5 #);
          nextNonterminal: (#  exit 6 #);
          prevNonterminal: (#  exit 7 #);
          
       #);
     selectionToAST:
       (# start,end: @integer; newCS: @astFocus
       enter (start,end)
       do <<SLOT codeviewerSelectionToAst:Descriptor>>
       exit newCS
       #);
     selectionToFocus:
       (# start,end: @integer
       enter (start,end)
       <<SLOT codeviewerSelectionToFocus:DoPart>>
       #);
     aFocusChangedEvent: @focusChangedEvent;
     focusChangedEvent:<
       (# newCS: @astFocus; 
       enter newCS
       do <<SLOT codeviewerFocusChangedEvent:Descriptor>>
       #);
     topDotOpen:
       (#
          input: ^text;
          f:
            ^astInterface.
               fragment;
          feedBackOnNotExisting:< booleanValue
            (#  do true->value; INNER #);
          myStartingParsing:< object;
          myParseErrors:< object;
          myFatalParseError:<
            (# errNo: @integer enter errNo do INNER #);
          noChangesOnDisk:< (* used by checkDisk *) object;
          checkDisk:< trueObject;
          
       enter input[]
       do '<<SLOT topDotOpenBody:Descriptor>>'->putLine; 
       exit f[]
       #);
     groupEditorList: @list
       (#
          findEditorForForm:
          (* given a fragmentform and an AST node inside it (selectedNode),
           *            * find an Editor on the fragmentform and select the AST node
           *            * if not found create the editor
           *            * id is used in the communication with Freja
           *            *)
            (#
               ff: ^astInterface.fragmentForm;
               selectedNode: ^astInterface.ast;
               newEditor: ^fragmentEditor;
               id: @integer
            enter (ff[],selectedNode[])
            do '<<SLOT findEditorForFormBody:Descriptor>>'->putLine; 
            exit (newEditor[],id)
            #);
          findAndSelect:
            (# a: ^astInterface.ast; ed: ^fragmentEditor
            enter a[]
            do '<<SLOT findAndSelectBody:Descriptor>>'->putLine
            exit ed[]
            #);
          
       #);
     fragmentEditor: (#  #);
     getSynCatNo:
       (#
          node: ^astInterface.ast;
          synCatNo: @mps.nonterminalSymbol;
          nontNode: ^astInterface.unExpanded
       enter node[]
       do
          (if
          ((node.kind = mps.kinds.unexpanded) or
           (node.kind = mps.kinds.optional)) then
              node[]->nontNode[]; nontNode.nonterminalSymbol->synCatNo
           else
              node.symbol->synCatNo
          if)
       exit synCatNo
       #);
     nodeExists:
       (#
          node: ^astInterface.ast;
          subtree: ^astInterface.expanded;
          value: @boolean
       enter (node[],subtree[])
       do <<SLOT codeviewerNodeExists:Descriptor>>
       exit value
       #);
     isNodeInTree:
       (#
          node,tree: ^astInterface.ast;
          value: @boolean
       enter (node[],tree[])
       do
          <<SLOT codeviewerIsNodeInTree:Descriptor>>
       exit value
       #);
     setFocus:
       (#
          newCS: @astFocus;
          checkExistence:< booleanObject;
          nodeNotFound:<
            (# msg: ^text; 
            do 'SetFocus: node not found'->msg[]; INNER ; msg[]->putLine
            #)
       enter newCS
       do <<SLOT codeviewerSetFocus:Descriptor>>
       #);
     setNode:
       (# node: ^astInterface.ast
       enter node[]
       <<SLOT codeviewerSetNode:DoPart>>
       #);
     astToSelection:
       (# 
       enter cs
       do
          cs->selectArea
            ->
              astView.out.selectArea
              (* burde istedet kalde en cursor i winduet, maaske bare selection *)
       #);
     ASTObserver:
       (# node: ^astInterface.ast; 
       enter node[]
       do
            (#
               synCatNo,fatherSynCatNo,superSynCatNo: @mps.nonterminalSymbol;
               prod,fatherProd,nextProd: ^mg.prod;
               fatherNode: ^astInterface.ast;
               str,str2: @text;
               constructor: ^mg.constructor;
               alternation: ^mg.alternation;
               opt: ^mg.opt;
               listOne: ^mg.listOne;
               listZero: ^mg.listZero;
               dummy: ^mg.dummy;
               leftSide: ^mg.leftSide;
               
            do
               '['->screen.put;
               node[]->getSynCatNo->synCatNo;
               (if node.kind
                // mps.kinds.comment then 'comment'->str; 
                else
                   (if synCatNo.isLexem then
                       (if node.kind
                        // mps.kinds.nameAppl then
                           'nameAppl'->str; 
                        // mps.kinds.nameDecl then
                           'nameDecl'->str; 
                        // mps.kinds.string then
                           'string'->str; 
                        // mps.kinds.const then
                           'const'->str; 
                        else
                           'lexem'->str; 
                       if);
                       
                    else
                       synCatNo->Prodlist.get->prod[];
                       (if prod.symbol
                        // mg.alternation then
                           'alternation'->str; 
                        // mg.constructor then
                           'constructor'->str; 
                        // mg.listOne then
                           'listOne'->str; 
                        // mg.listZero then
                           'listZero'->str; 
                        // mg.opt then
                           'optional'->str; 
                        // mg.dummy then
                           'dummy'->str; 
                       if);
                       
                   if);
                   
               if);
               str[]->screen.putText;
               synCatNo->screen.putInt;
               ' '->screen.put;
               node.father
                 -> (* now look at the father or super categories *)
                   fatherNode[];
               (if fatherNode[]
                // none then 'root'->screen.putText; 
                else
                   fatherNode[]->getSynCatNo->fatherSynCatNo;
                   (if fatherSynCatNo.isLexem (* should not be necessary? *)
                    then
                       'fatherLexem'->screen.putText; 
                    else
                       fatherSynCatNo->Prodlist.get->fatherProd[];
                       (if fatherProd.symbol
                        // mg.listOne // mg.listZero then
                           'list'->screen.putText;
                           fatherSynCatNo->screen.putInt;
                           
                        else
                           (if not synCatNo.isLexem then
                               loop:
                                 (# 
                                 do
                                    (if prod.symbol
                                     // mg.constructor then
                                        'C'->screen.put;
                                        prod[]->constructor[];
                                        constructor.getLeftside->leftSide[];
                                        
                                     // mg.alternation then
                                        'A'->screen.put;
                                        prod[]->alternation[];
                                        alternation.getLeftside->leftSide[];
                                        
                                     // mg.opt then
                                        'O'->screen.put;
                                        prod[]->opt[];
                                        opt.getLeftside->leftSide[];
                                        
                                     // mg.listOne then
                                        'LO'->screen.putText;
                                        prod[]->listOne[];
                                        listOne.getLeftside->leftSide[];
                                        
                                     // mg.listZero then
                                        'LZ'->screen.putText;
                                        prod[]->listZero[];
                                        listZero.getLeftside->leftSide[];
                                        
                                     // mg.dummy then
                                        'D'->screen.put;
                                        prod[]->dummy[];
                                        dummy.getLeftside->leftSide[];
                                        
                                    if);
                                    1->leftSide.getAttribute->superSynCatNo;
                                    (if superSynCatNo
                                     // mps.super.cons then
                                        'cons'->screen.putText; 
                                     // mps.super.list then
                                        'list'->screen.putText; 
                                     // mps.super.undefined then
                                        'undefined'->screen.putText; 
                                     else
                                        'super'->screen.putText;
                                        superSynCatNo->screen.putInt;
                                        ' '->screen.put;
                                        superSynCatNo->Prodlist.get->prod[];
                                        restart loop;
                                        
                                    if);
                                    
                                 #);
                               
                           if);
                           
                       if);
                       
                   if);
                   
               if);
               ']'->screen.put;
               ' '->put;
                 (#
                    index: @integer; node: ^astInterface.ast; pptext: @text; 
                 do
                    (if syncatNo.islexem then
                        'cs.node is a lexem, prettyprint father instead'
                          ->putLine;
                        cs.node.father->cs.node[]
                    if);
                    (mps[],frag[],cs.node[],ppText[],none ,80,0,false,false,
                     false,false,false,false,false,'',false,false)->ppFragment;
                    'Prettyprint of node: '->screen.putText;
                    cs.node.index->screen.putInt;
                    screen.newLine;
                    ppText[]->screen.putLine;
                    checkson;
                    
                 #);
               
            #)
       #);
     editComment:
       (#
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2: @integer;
          t: ^text;
          reprettyprint: @boolean;
          
       enter (node[],subCommentInx1,subCommentInx2,t[])
       do '<<SLOT editCommentBody:Descriptor>>'->putLine; 
       exit reprettyprint
       #);
     ShowCommentPermit,MakeCommentPermit,HideCommentPermit,PasteCommentPermit:
       @boolean;
     commentEditor: sifTextEditor
       (#
          commentEditorPrivate: @
            (#
               reprettyprint,commentTouched: @boolean;
               commentWindow: ^commentEditor;
               node: ^astInterface.ast;
               subCommentInx1,subCommentInx2: @integer;
               line1,char1,line2,char2: @integer;
               initEditor:
                 (# title: @text; x,y,w,h: @integer
                 enter
                 (commentWindow[],title,x,y,w,h,node[],subCommentInx1,
                  subCommentInx2)
                 do 'initEditor: (title[],x,y,w,h)->init; '->putLine; 
                 #);
               hereIAm:
                 (# 
                 do 'hereIam: (char1,line1,char2,line2)->cursor;'->putLine
                 #);
               writeComment:
                 (#
                    node: ^astInterface.ast;
                    subCommentInx1,subCommentInx2: @integer;
                    t,t1,theWholeText: ^text;
                    lineno,firstRealLine: @integer;
                    skipLeadingBlanks: @boolean;
                    
                 enter (node[],subCommentInx1,subCommentInx2)
                 do
                    1->firstRealLine;
                    'writeComment: clear;'->putLine;
                    &text[]->theWholeText[];
                    1->char1->char2;
                    1->line1->line2;
                    (if not node.hasComment then (* ('  ',1)->insertLine;*)
                        ''->setText
                     else
                        hasCommentLabel:
                          (# 
                          do (*node.getComment->aComment[];*)
                             &text[]->t1[];
                             (subCommentInx1,subCommentInx2)->node.getSubcomment
                               ->t[];
                             (if t.length
                              // 0 then
                                 'Empty comment'->screen.putLine;
                                 leave hasCommentLabel
                             if);
                             1->lineno;
                             'UI.setWaitCursor;'->putLine;
                             t.scanAll
                               (# 
                               do
                                  (if ch
                                   // ascii.newLine then
                                      (if lineno
                                       // firstRealLine then
                                       (*(t1,line2) -> insertLine; *)
                                          t1[]->theWholeText.putLine;
                                          &text[]->t1[];
                                          line2+1->line2;
                                          1->char2;
                                          ' '->t1.put;
                                          char2+1->char2;
                                          true->skipLeadingBlanks;
                                          
                                       else
                                          lineno+1->lineno
                                      if);
                                      
                                   else
                                      (if lineno
                                       // firstRealLine then
                                          (if skipLeadingBlanks then
                                              (if (ch <> ' ') then
                                                  ch->t1.put;
                                                  char2+1->char2;
                                                  false->skipLeadingBlanks;
                                                  
                                              if)
                                           else
                                              ch->t1.put; char2+1->char2; 
                                          if)
                                      if)
                                  if);
                                  
                               #);
                             t1[]
                               -> (*(t1,line2) -> insertLine;*)
                                 theWholeText.putText;
                             theWholeText[]->setText;
                             
                          #);
                        
                    if);
                    ' UI.setTextCursor;'->putLine;
                    
                 #);
               undoCommentEditing: (* Reinsert the text in the comment node *)
                 (# 
                 do
                    (node[],subCommentInx1,subCommentInx2)->writeComment;
                    false->reprettyPrint;
                    (CS.node[],CS.subCommentInx1,CS.subCommentInx2,
                     reprettyprint,false)->printComment;
                    
                 #);
               exitCommentEditing:
               (* Insert the edited text in the comment node *)
                 (# firstRealLine: @integer; commentText: ^text; 
                 do
                    &text[]->commentText[];
                    commentText.clear;
                    'exitCommentEditing: lastPosition->pToXY->(char2,line2);'
                      ->putLine;
                    (char2+1,line2+1)->(char2,line2);
                    'exitCommentEditing: (char1,line1,char2,line2)
                      ->scanChar (#  do ch->commentText.put #);'
                      ->putLine;
                    1->firstRealLine;
                    (if commentText.length
                     // 0 then 'Empty comment'->screen.putLine
                    if);
                    (CS.node[],subCommentInx1,subCommentInx2,commentText[])
                      -> (*sde.*) editComment->reprettyprint;
                    false->commentEditorPrivate.commentTouched;
                    (if astView.pp.includeComments then
                        true->rePrettyprint; 
                    if);
                    (if commentText.length
                     // 0 then 'Empty comment'->screen.putLine
                     else
                        (CS.node[],subCommentInx1,subCommentInx2,reprettyprint,
                         false)->printComment;
                        
                    if);
                    'exitCommentEditing: sde.fragmentChangedEvent;'->putLine;
                    
                 #);
               
            #);
          
       #);
     printComment:
       (#
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2: @integer;
          reprettyprint: @boolean;
          updateWindow: @boolean
       enter (node[],subCommentInx1,subCommentInx2,reprettyprint,updateWindow)
       do
          (if reprettyprint then
              (node[],node[])->astView.pp.update; (node[],1,0,0)->astToSelection
           else
              (node[],subCommentInx1,subCommentInx2,updateWindow)
                ->comCprivate.checkWindow
          if);
          
       #);
     createCommentWindow:
       (#
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2: @integer;
          theWindow: ^commentEditor;
          
       enter (node[],subCommentInx1,subCommentInx2)
       do
            (# title: ^text; 
            do
               (if
               ((node[],subcommentInx1,subcommentInx2)
                  ->commentWindows.findWindow->theWindow[])
                // none then
                   'Comment on '->title[];
                   'sdeC.editorTitle[]->title.append;'->putLine;
                   &commentEditor[]->theWindow[];
                   (theWindow[],title,2 (*comCprivate.nextEditorX*) ,2
                    (* comCprivate.nextEditorY*) ,0,0,node[],subCommentInx1,
                    subCommentInx2)->theWindow.commentEditorPrivate.initEditor;
                   theWindow[]->commentWindows.insertWindow;
                   true->HideCommentPermit
                else
                   theWindow.commentEditorPrivate.hereIam; 
               if)
            #);
          
       exit theWindow[]
       #);
     commentWindows: @list
       (#
          element::< commentEditor;
          insertWindow:
            (# ce: ^commentEditor; 
            enter ce[]
            do ce[]->append; comcPrivate.commentWindowsTest; 
            #);
          deleteWindow:
            (#
               node: ^astInterface.ast;
               subcommentInx1,subcommentInx2: @integer
            enter (node[],subcommentInx1,subcommentInx2)
            do
                 (# ce2: ^commentEditor; 
                 do
                    search: scan
                      (# 
                      do
                         (if (Current.commentEditorPrivate.node[]->node.equal)
                         and
                         (Current.commentEditorPrivate.subcommentInx1 =
                          subcommentInx1) and
                         (Current.commentEditorPrivate.subcommentInx2 =
                          subcommentInx2) then
                             Current[]->ce2[];
                             Current[]->at->delete;
                             ce2.close;
                             leave search
                         if)
                      #);
                    comcPrivate.commentWindowsTest;
                    
                 #);
               
            #);
          findWindow:
            (#
               node: ^astInterface.ast;
               ce: ^commentEditor;
               subcommentInx1,subcommentInx2: @integer
            enter (node[],subcommentInx1,subcommentInx2)
            do 
            exit ce[]
            #);
          deleteAllWindows:
            (# 
            do
                 (# ce2: ^commentEditor; 
                 do
                    scan
                      (# 
                      do Current[]->ce2[]; Current[]->at->delete; ce2.close; 
                      #);
                    comcPrivate.commentWindowsTest;
                    
                 #);
               
            #);
          enablePaste: (#  do  #);
          
       #);
     comcPrivate: @
       (#
          nextX,nextY: @integer;
          nextEditorX: (#  enter nextX exit nextX #);
          nextEditorY: (#  enter nextY do nextY+50->nextY exit nextY #);
          commentWindowsTest:
            (# 
            do
               (if false then
                   '######################## commentWindows'->putLine;
                   commentWindows.scan
                     (# 
                     do
                        'node: '->putText;
                        current.commentEditorPrivate.node.index->putInt;
                        '   '->putText;
                        'inx1: '->putText;
                        current.commentEditorPrivate.subcommentinx1->putInt;
                        '   '->putText;
                        'inx2: '->putText;
                        current.commentEditorPrivate.subcommentinx2->putInt;
                        newLine
                     #)
               if)
            #);
          checkWindow:
            (#
               node: ^astInterface.ast;
               subCommentInx1,subCommentInx2: @integer;
               updateWindow: @boolean;
               theWindow: ^commentEditor;
               
            enter (node[],subCommentInx1,subCommentInx2,updateWindow)
            do
               (if
               (((node[],subcommentInx1,subcommentInx2)
                   ->commentWindows.findWindow->theWindow[]) <> none ) then
                   (if updateWindow then
                       (node[],subCommentInx1,subCommentInx2)
                         ->theWindow.commentEditorPrivate.writeComment
                    else
                   (*theWindow.commentEditorPrivate.hereIam;*)
                       
                   if);
                   
               if);
               
            #);
          
       #);
     makeDetail:<
       (# 
       do (*'makeDetail'->putLine;*)
          CS.node[]->openContraction;
          (CS.node[],CS.node[])->astView.pp.update;
          cs->astToSelection
       #);
     makeAbstract:<
       (# 
       do
          CS.node[]->setContraction;
          (if cs.node.father = none then
              (editorRoot[],- 1)->astView.pp.present
           else
              (CS.node[],CS.node[])->astView.pp.update
          if);
          cs->astToSelection
       #);
     makeShowComment:<
       (# doneInInner: @boolean
       do
          INNER makeShowComment;
          (if not doneInInner then
              not astView.pp.includeComments->astView.pp.includeComments;
              (CS.node[],CS.node[])->astView.pp.update;
              cs->astToSelection;
              
          if)
       #);
     makeFollowSemanticLink:<
       (# separate,doneInInner: @boolean
       enter separate
       do
          INNER makeFollowSemanticLink;
          (if not doneInInner then
              (if cs.node.kind
               // mps.kinds.nameDecl // mps.kinds.nameAppl then
                  (cs.node[],separate)->followSemanticLink
              if)
          if)
       #);
     makeSearchSlotBinding:<
       (# separate: @boolean; a: ^astInterface.ast; doneInInner: @boolean
       enter separate
       do
          INNER makeSearchSlotBinding;
          (if doneInInner then
              (if a[] <> none then
                  (a[],a[],separate)->selectNodeInFormEditor; 
              if)
           else
              cs.node[]
                ->searchSlotBinding
                  (#
                     bindingFound::< 
                       (# 
                       do
                          (if ff[] = none then
                              'bindingFound: ff is none!! '->putLine
                           else
                              (ff.root[],ff.root[],separate)
                                ->selectNodeInFormEditor
                          if)
                       #);
                     bindingNotFound:: 
                       (# help: ^text
                       do
                          slotName[]->help[];
                          ' not found'->help.append;
                          (none ,help[],'Search SLOT')->UI.alertUser
                       #)
                  #)
          if)
       #);
     searchSlotBinding:
       (#
          searchedUnexp: ^astInterface.unexpanded;
          theSlot: ^astInterface.slotDesc;
          slotName: ^text;
          found: @boolean;
          bindingFound:<
            (# ff: ^astInterface.fragmentform enter ff[] do INNER #);
          bindingNotFound:<
            (# slotName: ^text enter slotName[] do INNER #);
          searchBinding:
            (#
               searchFrag,fg: ^astInterface.fragmentGroup;
               found: @boolean;
               ff: ^astInterface.fragmentForm;
               help: ^text;
               de: @diskentry
            enter searchFrag[]
            do
               search: searchFrag.prop.scanProp
                 (#
                    doProp::< 
                      (# 
                      do
                         (if true
                          // ('BODY'->prop.equalNCS) then
                             scanParameters
                               (#
                                  doString::< 
                                    (# 
                                    do
                                       searchFrag.fullName->de.path;
                                       (if traceSLOTsearch then
                                           s[]->screen.putText; ' '->screen.put
                                       if);
                                       (s[],de.path.head)
                                         ->mps.thePathHandler.convertFilePath
                                         ->help[];
                                       (help[],screen[])->mps.top.open->fg[];
                                       (if not fg.isRealOpen then
                                           'fg was not realopen'->putLine;
                                           fg.realOpen
                                       if);
                                       (if (* should test if open already *)
                                       fg[]
                                        // none then
                                           s.copy->help[];
                                           ' not found'->help.putText;
                                           help[]-> (*UI.alertUser;*) putLine
                                        else
                                           fg.fragmentList.scan
                                             (# 
                                             do
                                                (if
                                                (current.name[]
                                                   ->slotName.equalNCS) then
                                                    (if current.type
                                                     // mps.formType then
                                                        true->found;
                                                        (if traceSLOTsearch then
                                                            newLine
                                                        if);
                                                        current.f[]->ff[]
                                                          ->bindingFound;
                                                        leave search
                                                     else
                                                        'Not a fragment form! '
                                                          ->putLine
                                                    if)
                                                if)
                                             #);
                                           fg[]->&searchBinding->found
                                       if)
                                    #)
                               #)
                          // ('MDBODY'->prop.equalNCS) then
                             searchMDbody: scanParameters
                               (#
                                  t,name: ^text;
                                  foundMachineType,isDefaultMachine,
                                    noMachineType: @boolean;
                                  doName::< 
                                    (# 
                                    do
                                       '$(objdir)'->expandEnvVar->t[];
                                       'Reading environment variable ''objdir'': '
                                         ->putText;
                                       t[]->putLine;
                                       n[]->name[];
                                       (if t[] <> none then
                                           (if t[]->n.equal then
                                               true->foundMachineType; 
                                            else
                                               (if 'default'->n.equal then
                                                   true->isDefaultMachine
                                               if)
                                           if)
                                        else
                                           true->noMachineType;
                                           'No objdir set in script'->putLine
                                       if)
                                    #);
                                  doString::< 
                                    (# 
                                    do
                                       searchFrag.fullName->de.path;
                                       (if traceSLOTsearch then
                                           s[]->screen.putText; ' '->screen.put
                                       if);
                                       (if foundMachineType or isDefaultMachine
                                       or noMachineType then
                                           'Choosing MDBODY '->putText;
                                           (if foundMachineType then
                                               t[]->putLine
                                            else
                                               name[]->putLine
                                           if);
                                           (s[],de.path.head)
                                             ->
                                               mps.thePathHandler.
                                                 convertFilePath->help[];
                                           ;
                                           (help[],screen[])->mps.top.open
                                             ->fg[];
                                           (if (* should test if open already *)
                                           fg[]
                                            // none then
                                               s.copy->help[];
                                               ' not found'->help.putText;
                                               help[]
                                                 -> (*UI.alertUser;*) putLine
                                            else
                                               (if not fg.isRealOpen then
                                                   'fg was not realopen'
                                                     ->putLine;
                                                   fg.realOpen
                                               if);
                                               fg.fragmentList.scan
                                                 (# 
                                                 do
                                                    (if
                                                    (current.name[]
                                                       ->slotName.equalNCS) then
                                                        (if current.type
                                                         // mps.formType then
                                                            true->found;
                                                            (if traceSLOTsearch
                                                             then
                                                                newLine
                                                            if);
                                                            current.f[]->ff[]
                                                              ->bindingFound;
                                                            leave search
                                                         else
                                                            'Not a fragment form! '
                                                              ->putLine
                                                        if)
                                                    if)
                                                 #);
                                               fg[]->&searchBinding->found
                                           if);
                                           leave searchMDbody
                                       if)
                                    #)
                               #)
                         if)
                      #)
                 #)
            exit found
            #)
       enter searchedUnexp[]
       do
          searchedUnexp.theSlot->theSlot[];
          theSlot.name->slotName[];
          (if traceSLOTsearch then
              newLine;
              'Searching for a SLOT binding of '''->putText;
              slotName[]->putText;
              ''''->put;
              ' in:'->putLine
          if);
          frag.father->&searchBinding->found;
          (if not found then slotName[]->bindingNotFound if)
       #);
     selectNodeInFormEditor:<
       (# theEditorRoot,node: ^astInterface.ast; separate: @boolean; 
       enter (theEditorRoot[],node[],separate)
       <<SLOT codeviewerSelectNode:DoPart>>
       #);
     updateHistory:<
       (# node: ^astInterface.ast enter node[] do INNER updateHistory #);
     followSemanticLink:
       (#
          separate: @boolean;
          node,theNode: ^astInterface.ast;
          ff: ^astInterface.fragmentForm;
          fg: ^astInterface.fragmentGroup;
          help: ^text;
          
       enter (node[],separate)
       do
          (if node.kind
           // mps.kinds.nameAppl // mps.kinds.nameDecl then
              node.father->theNode[]
           else
              node[]->theNode[]
          if);
          node.frag[]->ff[];
          ff.father->fg[];
          (if not ((mps[],fg[])->getDoneCheckProperty) (* isChecked *) then
          (* itemselected is 1 *)
              'This fragment group must be (re)checked'->help[];
              help.newLine;
              'in order to (re)build the semantic links '->help.putText;
              (none ,help[],'Alert')->UI.alertUser;
              
           else
              (if theNode.symbol
               // betaGrammar.nameApl then
                    (# theNameApl: ^betaGrammar.nameApl
                    do
                       theNode[]->theNameApl[];
                       ((theNameApl.dclRef).frag.root[],theNameApl.dclRef,
                        separate)->selectNodeInFormEditor
                    #)
               // betaGrammar.nameDcl then
                    (# theNameDcl: ^betaGrammar.nameDcl; f: ^astInterface.ast
                    do
                       theNode.father->f[];
                       (if f.symbol
                        // betaGrammar.names then
                           f.father->f[];
                           (if f.symbol
                            // betaGrammar.bindingDecl // betaGrammar.finalDecl
                            then
                               theNode[]->theNameDcl[];
                               ((theNameDcl.virtDcl).frag.root[],
                                theNameDcl.virtDcl,separate)
                                 ->selectNodeInFormEditor;
                               (* use findDescriptor instead? 
                                (if itemSelected
                                // 1 then
                                theNameApl.dclRef->selectNode
                                // 2 then
                                theNameApl.descRef->selectNode
                                // 3 then
                                theNameApl.findDescriptor->selectNode
                                if)*)
                               
                           if)
                       if);
                       (* use findDescriptor instead? 
                        (if itemSelected
                        // 2 then
                        theNode[]->theNameDcl[];
                        theNameDcl.findDescriptor->selectNode
                        if);
                        *)
                       
                    #)
              if)
          if)
       #);
     handleDoubleClick:
       (# modifier: @boolean
       enter modifier
       do <<SLOT codeviewerHandleDoubleClick:Descriptor>>; 
       #);
     onPopUpButton:<
       (# pos: @point
       enter pos
       do INNER
       #);
     selectArea:
       (#
          f: @astFocus;
          l1,l2,l,c1,c2:
            @integer;
          c: @integer;
          fatherNode: ^astInterface.expanded;
          node,keepNode: ^astInterface.ast
       enter f
       do
          (if astView.pp.ppDebug then
              ' selectarea: '->putText;
              f.node.index->putInt;
              ' '->put;
              f.length->putInt;
              newLine;
              
          if);
          (f.node[],f.subcommentInx1,f.subcommentInx2)->astView.pp.select
            ->(l1,c1,l2,c2);
          (if (1 < f.length) then
              (if (1 < f.length) then
                  f.node[]->checkFatherNode->node[];
                  (if astView.pp.ppDebug then
                      'node.index: '->putText; node.index->putInt; newLine; 
                  if);
                  node.father->fatherNode[];
                  (if astView.pp.ppDebug then
                      'fathernode.index: '->putText;
                      fathernode.index->putInt;
                      newLine;
                      
                  if);
                  (node.sonNo+f.length-1)->fatherNode.get->node[];
                  (node[],0,0)->astView.pp.select->(l,c,l2,c2);
                  
              if);
              
          if);
          
       exit (l1,c1,l2,c2)
       #);
     hasComment:
       (#
          node: ^astInterface.ast;
          hasOne: @boolean;
          expNode: ^astInterface.expanded;
          
       enter node[]
       do
          false->hasOne;
          (if (node.struc <= mps.expanded##)
           // true then
              node[]->expNode[];
              loop: expNode.suffixWalk
                (# 
                do
                   (if current.hasComment
                    // true then true->hasOne; leave loop
                   if);
                   
                #);
              
          if);
          
       exit hasOne
       #);
     contractionCategories: [1] @integer;
     getPropertiesFromGrammar:
       (# fg: ^astInterface.fragmentGroup; 
       do
          frag.grammar.kindArray.range-contractionCategories.range
            ->contractionCategories.extend;
          frag.grammar.grammarAst.father->fg[];
          (if fg.prop[]
           // none then 
           else
              'contractioncategoriesvalues'
                ->fg.prop.getProp
                  (#
                     doprop::< 
                       (# 
                       do
                          scanParameters
                            (#
                               doConst::< 
                                 (# 
                                 do
                                    (if
                                    ((c > 0) and
                                     (c <= contractionCategories.range)) then
                                        1->contractionCategories[c]
                                    if)
                                 #)
                            #)
                       #)
                  #);
              'longLexems'
                ->fg.prop.getProp
                  (#
                     doProp::< 
                       (#  do true->astView.pp.specialLexemTreatment;  #)
                  #);
              'longLexemsWithQuote'
                ->fg.prop.getProp
                  (#
                     doProp::< 
                       (# 
                       do
                          true
                            ->
                              astView.pp.specialLexemTreatment
                              (*->longLexemsWithquote*) ;
                          
                       #)
                  #);
              
          if);
          
       #);
     setContractions:
       (#
          node: ^astInterface.ast;
          symbol: @mps.nonterminalSymbol;
          expNode: ^astInterface.expanded
       enter node[]
       do
          (if node[] = none then cs.node[]->node[] if);
          (if (node.struc <= mps.expanded##) then
              node[]->expNode[];
              expNode.suffixWalk
                (#
                   unexp: ^astInterface.unexpanded;
                   aList: ^astInterface.list;
                   doContract: @boolean;
                   prod: ^mg.prod
                do
                   true->doContract;
                   Current.symbol->symbol;
                   (if symbol.predefined then
                       false->doContract; 
                    else
                       (if Current.kind
                        // mps.kinds.unexpanded then
                           Current[]->unexp[]; false->doContract; 
                        // mps.kinds.list then
                           Current[]->aList[];
                           (aList.noOfSons > 3 (* should be user-changable *) )
                             ->doContract;
                           
                        // mps.kinds.optional then
                           false->doContract
                        // mps.kinds.interior then
                           symbol->Prodlist.get->prod[];
                           (if prod.symbol
                            // mg.listOne // mg.listZero then
                               Current[]->aList[];
                               (aList.noOfSons > 3
                                (* should be user-changable *) )->doContract;
                               
                           if);
                           
                        else
                           
                       if);
                       (if doContract then
                           (if contractionCategories[symbol]
                            // 1 then Current[]->setContraction
                           if);
                           
                       if)
                   if)
                #)
          if)
       #);
     setContraction:
       (# node: ^astInterface.ast
       enter node[]
       <<SLOT codeviewerSetContraction:DoPart>>
       #);
     inContraction:
       (#
          node,contractionNode:
            ^astInterface.ast;
          inContr: @boolean;
          fatherNode:
            ^astInterface.ast;
          
       enter node[]
       do
          false->inContr;
          loop:
            (# 
            do
               node.father
                 ->fatherNode[];
               (if
               (fatherNode[] <> none )
                then
                   (if fatherNode.hasComment then
                       (if (fatherNode.typeOfComment = astView.pp.holocomment)
                        then
                           fatherNode[]->contractionNode[];
                           true->inContr;
                           leave loop
                       if);
                       
                   if);
                   fatherNode[]->node[];
                   restart loop;
                   
               if);
               
            #);
          
       exit (inContr,contractionNode[])
       #);
     openContractionsUntilRoot:
       (# node,holoNode,fatherNode: ^astInterface.ast; inHolo: @boolean; 
       enter node[]
       do
          false->inHolo;
          loop:
            (# 
            do
               node.father->fatherNode[];
               (if (fatherNode[] <> none ) then
                   (if fatherNode.hasComment then
                       (if (fatherNode.typeOfComment = astView.pp.holocomment)
                        then
                           fatherNode[]->holoNode[]->openContraction;
                           true->inHolo;
                           
                       if);
                       
                   if);
                   fatherNode[]->node[];
                   restart loop;
                   
               if);
               
            #);
          
       #);
     openContraction:
       (# node: ^astInterface.ast; aComment: ^astInterface.comment; 
       enter node[]
       do
          (if node[] = none then cs.node[]->node[] if);
          (if node.hasComment then
              (if node.typeOfComment
               // astView.pp.holocomment then
                  node.getComment->aComment[];
                  (if (aComment.curLength > 0) then
                      astView.pp.normalComment->node.typeOfComment; 
                   else
                      none ->node.addComment; 
                  if);
                  
              if);
              
          if);
          
       #);
     openAllContractions:
       (# node: ^astInterface.ast
       enter node[]
       do
          (if node[] = none then cs.node[]->node[] if);
          (node[],1000)->openContractionLevel
       #);
     openContractionLevel:
       (#
          node: ^astInterface.ast;
          level: @integer;
          aComment: ^astInterface.comment;
          anExp: ^astInterface.expanded;
          openedOne: @boolean;
          
       enter (node[],level)
       do
          (if node.hasComment then
              (if node.typeOfComment
               // astView.pp.holocomment then
                  node.getComment->aComment[];
                  (if (aComment.curLength > 0) then
                      astView.pp.normalComment->node.typeOfComment; 
                   else
                      none ->node.addComment; 
                  if);
                  
              if);
              
          if);
          (if node.kind
           // mps.kinds.interior then
              node[]->anExp[];
              anExp.scan
                (# 
                do
                   (if current.hasComment then
                       (if current.typeOfComment
                        // astView.pp.holocomment then
                           current[]->openContraction; true->openedOne; 
                       if)
                   if);
                   
                #);
              (if openedOne then level-1->level if);
              (if (level > 0) then
                  anExp.scan
                    (#  do (current[],level)->&openContractionLevel #)
              if)
          if)
       #);
     showAst: (#  do <<SLOT showAstBody:Descriptor>> #);
     doAbstract:
       (# 
       do
          cs.perform
            (# 
            do current[]->setContraction
            #)
       #);
     doAbstractRecursively:
       (# 
       do
          cs.perform
            (# 
            do current[]->setContractions
            #)
       #);
     doOverview:
       (# 
       do
          ui.cursors.watch[]
            ->UI.mouse.busyCursor;
          editorRoot[]->setContractions;
          (editorRoot[],- 1)->astView.pp.present;
          cs->setFocus;
          none ->UI.mouse.busyCursor
       #);
     doDetail:
       (# 
       do cs.perform (#  do (current[],1)->openContractionLevel #)
       #);
     doDetailRecursively:
       (#  do cs.perform (#  do current[]->openAllContractions #) #);
     doReprettyprint: (#  <<SLOT codeviewerDoReprettyprint:DoPart>> #);
     doShowAst:
       (# node: ^astInterface.ast
       enter node[]
       <<SLOT doShowAst:DoPart>>
       #);
     automaticHolocomments:
       (# abstracted: @boolean; 
       do
          editorRoot[]
            ->setContractions
            (*false->abstracted;
             loop: frag.prop.scanProp (# doProp::<  <<@32602:MainPart>>; #);
             (if not abstracted
             then
             ff.root[]->setContractions; 'ABSTRACTED'->frag.prop.addProp;
             if)*)
       #);
     setBreakPointBefore:
       (#
          node: ^astInterface.ast;
          theText: ^text;
          update: @boolean;
          pos: @integer;
          commentAST: ^astInterface.comment;
          theComment: ^text
       enter (node[],theText[],update)
       do
          (if not node.hasComment then
              node[]->astView.pp.CreateEmptyComment->theComment[];
              (mps.comment,0,frag[])->frag.grammar.newlexemText->commentAST[];
              theComment[]->commentAST.putText;
              commentAST[]->node.addComment
          if);
          (theText[],1,1)->node.setSubcomment;
          astView.pp.breakPointComment->node.typeOfComment;
          (if update then
              (node[],node[])->astView.pp.update; (node[],1,0,0)->setFocus
          if)
       exit 1
       #);
     setBreakPointAfter:
       (#
          node: ^astInterface.ast;
          pos: @integer;
          theText: ^text;
          update: @boolean;
          commentAST: ^astInterface.comment;
          theComment: ^text;
          noOfSons: @integer
       enter (node[],theText[],update)
       do
          (if not node.hasComment then
              node[]->astView.pp.CreateEmptyComment->theComment[];
              (mps.comment,0,frag[])->frag.grammar.newlexemText->commentAST[];
              theComment[]->commentAST.putText;
              commentAST[]->node.addComment
           else
              node.getComment->commentAst[]; commentAST.getText->theComment[]
          if);
          mps.commentSeparator1->theComment.findCh (#  do inx->noOfSons #);
          (theText[],noOfSons+2,1)->node.setSubcomment;
          astView.pp.breakPointComment->node.typeOfComment;
          (if update then
              (node[],node[])->astView.pp.update; (node[],1,0,0)->setFocus
          if)
       exit noOfSons+2
       #);
     clearBreakPoint:
       (# node: ^astInterface.ast; pos: @integer; update: @boolean
       enter (node[],pos,update)
       do
          (if node.hasComment then ('',pos,1)->node.setSubcomment if);
          astView.pp.normalComment->node.typeOfComment;
          (if update then
              (node[],node[])->astView.pp.update; (node[],1,0,0)->setFocus
          if)
       #);
     subject4: (* navigation operations: selection.bet *) (#  #);
     findSuper:
       (# synCatNo: @mps.nonterminalSymbol; 
       enter synCatNo
       do
            (#
               superSynCatNo,lastSuper: @mps.nonterminalSymbol;
               prod: ^mg.prod;
               constructor: ^mg.constructor;
               alternation: ^mg.alternation;
               opt: ^mg.opt;
               listOne: ^mg.listOne;
               listZero: ^mg.listZero;
               dummy: ^mg.dummy;
               leftSide: ^mg.leftSide;
               foundSuper: @boolean;
               
            do
               (if not synCatNo.isLexem then
                   false->foundSuper;
                   synCatNo->Prodlist.get->prod[];
                   loop:
                     (# 
                     do
                        (if prod.symbol
                         // mg.constructor then
                            prod[]->constructor[];
                            constructor.getLeftside->leftSide[];
                            
                         // mg.alternation then
                            prod[]->alternation[];
                            alternation.getLeftside->leftSide[];
                            
                         // mg.opt then
                            prod[]->opt[]; opt.getLeftside->leftSide[]; 
                         // mg.listOne then
                            prod[]->listOne[]; listOne.getLeftside->leftSide[]; 
                         // mg.listZero then
                            prod[]->listZero[];
                            listZero.getLeftside->leftSide[];
                            
                         // mg.dummy then
                            prod[]->dummy[]; dummy.getLeftside->leftSide[]; 
                        if);
                        1->leftSide.getAttribute->superSynCatNo;
                        (if superSynCatNo
                         // mps.super.cons then
                            
                         // mps.super.list then
                            
                         // mps.super.undefined then
                            
                         else
                            true->foundSuper;
                            superSynCatNo->Prodlist.get->prod[];
                            superSynCatNo->lastSuper;
                            restart loop;
                            
                        if);
                        
                     #);
                   (if foundSuper then lastSuper->synCatNo if);
                   
               if);
               
            #)
       exit synCatNo
       #);
     parsingSynCatNo:
       (#
          node: ^astInterface.ast;
          synCatNo: @mps.nonterminalSymbol;
          isList: @boolean;
          theListElement: ^astInterface.ast;
          
       enter node[]
       do
            (#
               node2: ^astInterface.ast;
               fatherSynCatNo: @mps.nonterminalSymbol;
               prod,fatherProd: ^mg.prod;
               fatherNode,expNode: ^astInterface.expanded;
               trySuper: @boolean;
               
            do
               trace
                 (#  do 'parsingSynCatNo'->str[] #);
               false->isList;
               true->trySuper;
               node[]->getSynCatNo->synCatNo;
               (if not synCatNo.isLexem then
                   synCatNo->Prodlist.get->prod[];
                   (if prod.symbol
                    // mg.listOne // mg.listZero then
                       true->isList;
                       false->trySuper;
                       (if node.kind
                        // mps.kinds.unexpanded then
                        (* in the case of attributes slot!*)
                           node[]->theListElement[]; 
                        else
                           node[]->expNode[];
                           expNode.getSon1->theListElement[];
                           
                       if);
                       
                   if);
                   
               if);
               (if not isList then
                   node[]->checkFatherNode->node2[]->getSynCatNo->synCatNo;
                   node2.father->fatherNode[];
                   (if fatherNode[]
                    // none then (* root *) ; 
                    else
                       fatherNode[]->getSynCatNo->fatherSynCatNo->Prodlist.get
                         ->fatherProd[];
                       (if fatherProd.symbol
                        // mg.listOne // mg.listZero then
                           fatherSynCatNo->synCatNo;
                           true->isList;
                           false->trySuper;
                           node2[]->theListElement[];
                           
                       if);
                       
                   if);
                   
               if);
               (if trySuper then synCatNo->findSuper->synCatNo;  if);
               (if edDebug then
                   'SynCatNo, isList: '->screen.putText;
                   synCatNo->screen.putInt;
                   isList->screen.putInt;
                   screen.newLine;
                   
               if);
               
            #)
       exit (synCatNo,isList,theListElement[])
       #);
     selectNewCs: (#  do <<SLOT selectNewCsBody:Descriptor>> #);
     checkSon:
       (# 
       do <<SLOT checkSonBody:Descriptor>>
       #);
     checkSonNode:
       (# node: ^astInterface.ast
       enter node[]
       do <<SLOT checkSonNodeBody:Descriptor>>
       exit node[]
       #);
     checkFather:
       (# 
       do
          cs.node[]->checkFatherNode
            ->cs.node[]
       #);
     checkFatherNode:
       (# node: ^astInterface.ast
       enter node[]
       do
          <<SLOT checkFatherNodeBody:Descriptor>>
       exit node[]
       #);
     extend: (#  do <<SLOT extendBody:Descriptor>> #);
     down:
       (#  do <<SLOT downBody:Descriptor>> #);
     navigate:
       (# direction: @integer; 
       enter direction
       do <<SLOT navigateBody:Descriptor>>
       #);
     select:
       (# direction: @integer; 
       enter direction
       do <<SLOT selectBody:Descriptor>>
       #);
     gotoNonterminal: (#  do <<SLOT gotoNonterminalBody:Descriptor>> #);
     gotoNonEmpty:
       (# 
       do
          <<SLOT gotoNonEmptyBody:Descriptor>>
       #);
     nextNonterminal: (#  do <<SLOT nextNonterminalBody:Descriptor>> #);
     prevNonterminal:
       (# 
       do
          <<SLOT prevNonterminalBody:Descriptor>>
       #);
     searchPrivate: @<<SLOT searchPrivate:Descriptor>>;
     searchText:
       (# t: ^text; parseOK: @boolean
       enter t[]
       do <<SLOT searchTextBody:Descriptor>>
       exit
       parseOK
       #);
     searchStructure: (#  do <<SLOT searchStructureBody:Descriptor>> #);
     searchNext:
       (# found: @boolean
       do
          <<SLOT searchNextBody:Descriptor>>
       exit found
       #);
     searchPrev:
       (# found: @boolean
       do <<SLOT searchPrevBody:Descriptor>>
       exit found
       #);
     searchName:
       (# name: ^text; found: @boolean
       enter name[]
       do <<SLOT searchNameBody:Descriptor>>
       exit
       found
       #);
     askUndoPermission:< booleanValue;
     askPastePermission:< booleanValue;
     askInsertPermission:< booleanValue;
     askTexteditMode:< booleanValue;
     askOpenSubeditorPermission:< booleanValue;
     doCommand:
       (#  do setWaitCursor; INNER doCommand; setStructureCursor #);
     doUndo:< doCommand;
     doCut:< doCommand;
     doCopy:< doCommand;
     doPaste:< doCommand;
     doTextedit:< (# ch: @char enter ch do INNER #);
     checkTexteditingFinished:<
       (# start,end: @integer enter (start,end) do INNER #);
     doParseText:< doCommand;
     doRevertTextedit:< doCommand;
     doShowTexteditCommands:< object;
     doInsertBefore:< doCommand;
     doInsertAfter:< doCommand;
     doRemoveOptionals:< doCommand;
     doShowOptionals:< doCommand;
     doSearch: (#  <<SLOT doSearch:DoPart>> #);
     askMakeDoPartSlot:< booleanValue;
     askMakeDescriptorSlot:< booleanValue;
     askMakeAttributesSlot:< booleanValue;
     askPasteFragmentForm:< booleanValue;
     doMakeDoPartSlot:< object;
     doMakeDescriptorSlot:< object;
     doMakeAttributesSlot:< object;
     doPasteFragmentForm:< doCommand;
     doFillSlot:< doCommand;
     doFillAllSlots:< object;
     doHideImplementation:< object;
     openSubeditor:<
       (# theEditorRoot,node: ^astInterface.ast
       enter (theEditorRoot[],node[])
       do INNER
       #);
     close:< object;
     init:<
       (# 
       enter
       (mps[],theGrammar[],UI[],theSifTextEditor[],editorRoot[],
        initialSelection[])
       do <<SLOT codeviewerinit:Descriptor>>; 
       #)
  #)  

