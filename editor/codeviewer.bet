ORIGIN '~beta/guienv/v1.6/guienv';
BODY 'private/siftexteditorbody'
     'private/codeviewerbody'
     'private/selection'
     'private/commentbody';
INCLUDE '~beta/guienv/v1.6/guienv';
INCLUDE '~beta/guienv/v1.6/fields';
INCLUDE '~beta/guienv/v1.6/guienvactions';
INCLUDE '~beta/guienv/v1.6/stddialogs';
INCLUDE '~beta/guienv/v1.6/utils/textfieldadds';
INCLUDE '~beta/guienv/v1.6/utils/prompts';
INCLUDE '~beta/guienv/v1.6/utils/timer';
INCLUDE '~beta/pretty/v5.2/pplib';
INCLUDE '~beta/betaast/v5.2/betasematt';
INCLUDE '~beta/mps/v5.2/private/astparser';
INCLUDE '~beta/betaast/v5.2/donecheck';
INCLUDE '~beta/betaast/v5.2/gram';
INCLUDE '~beta/sysutils/v1.6/envstring';
INCLUDE '~beta/basiclib/v1.6/textUtils';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- windowlib: Attributes --
sifTextEditor: textEditor
  (#
     charWidthType:< IntegerValue
       (# viewsize: @Point; ts: ^textStyle; 
       enter viewsize
       do
          <<SLOT siftexteditorCharWidthType:Descriptor>>;
          (* correction made by ess: *)
          
       #);
     charWidth: @charWidthType;
     codeViewerType:< codeViewer;
     initialContractionLevel:<
       (# value: @integer
       <<SLOT siftexteditorInitialContractionLevel:DoPart>>
       exit value
       #);
     readOnly:<
      booleanObject (#  do INNER ; value->isReadOnly;  exit value #);
     isReadOnly:
     (* is set to true if the file is readOnly or may be set
      * by the user
      *) @boolean;
     SifViewer: ^codeviewerType;
     mps: ^astInterface;
     betaGrammar: (*^astInterface.treelevel;*) ^astInterface.beta;
     theGrammar: ^astInterface.treeLevel;
     isApropertyEditor: @boolean;
     isAsubeditor: @boolean;
     UI: ^guienv;
     frag: ^astInterface.fragmentForm;
     editorRoot:
     (* root of this editor normally the same as frag.root, except in subeditors *)
     ^astInterface.ast;
     start,end: @integer;
     fragDotRoot: @
       (#
          setRoot: @
            (# node: ^astInterface.ast
            enter node[]
            do node[]->frag.root[]->editorRoot[]
            #)
       enter setRoot
       exit frag.root[]
       #);
     initialSelection: (* inititial selection *) ^astInterface.ast;
     theWindow: (#  exit THIS(window)[] #);
     textEditing,allowedTextediting: @boolean;
     undoPermit,redoPermit: @boolean;
     siftexteditorPrivate: @<<SLOT siftexteditorPrivate:Descriptor>>;
     onOpen:<
       (# 
       <<SLOT sifTexteditorOnOpen:DoPart>>
       #);
     onDoubleClick:<
       (# start,end: @integer; modifier: @boolean
       enter (start,end,modifier)
       <<SLOT sifTexteditorOnDoubleClick:DoPart>>
       #);
     onClick:<
       (#
          start,end,line1,char1,line2,
            char2: @integer
       enter (start,end)
       <<SLOT sifTexteditorOnClick:DoPart>>
       #);
     enterTextEditing:
       (# ch: @char
       enter ch
       <<SLOT sifTexteditorEnterTextEditing:DoPart>>
       #);
     exitTextEditing: (#  <<SLOT sifTexteditorExitTextEditing:DoPart>> #);
     prettyprinting: @boolean;
     showContents:
       (# 
       do
          (if SifViewer.switch[2]
           then
              (if SifViewer.switch[3] then
                  'contents: '->screen.putLine;
                  '['->screen.put;
                  contents.contents->screen.putText;
                  ']'->screen.put;
                  screen.newLine;
                  'contents: (scan) '->screen.putLine;
                  '['->screen.put;
                  contents.all
                    ->contents.scanText
                      (# 
                      do
                         (if ch
                          // ascii.sp then
                             ','->screen.put
                          // ascii.newline then
                             '<cr>'->screen.putText
                          else
                             ch->screen.put
                         if)
                      #);
                  ']'->screen.put;
                  screen.newLine
              if);
              'selection: '->screen.putText;
              contents.selection.start->screen.putint;
              ' '->screen.put;
              contents.selection.end->screen.putint;
              screen.newLine;
              'selection.contents: '->screen.putLine;
              '['->screen.put;
              contents.selection.contents->screen.putText;
              ']'->screen.put;
              'selection.contents: (scan)'->screen.putLine;
              '['->screen.put;
              (contents.selection.start,contents.selection.end)
                ->contents.scanText
                  (# 
                  do
                     (if ch
                      // ascii.sp then
                         ','->screen.put
                      // ascii.newline then
                         '<cr>'->screen.putText
                      else
                         ch->screen.put
                     if)
                  #);
              ']'->screen.put;
              screen.newLine;
              'length: '->screen.putText;
              contents.length->screen.putInt;
              screen.newLine
          if)
       #);
     contentstype::< 
       (#
          <<SLOT sifTexteditorContentsLib:Attributes>>;
          draggingSelection:
            @boolean;
          skipMouseUp: @Boolean;
          keyAllowed: @Boolean;
          eventHandler::< 
            (#
               oldSelection: @point;
               theShiftKey,theControlKey,theMetaKey: @boolean;
               theKey: @char;
               keyDownTimer: @timer
                 (#
                    action:: 
                      (#  <<SLOT siftexteditorKeyDownTimerAction:DoPart>> #);
                    
                 #);
               onKeyDown::<  (#  <<SLOT sifTexteditorOnKeyDown:DoPart>> #);
               mouseDownTimer: @timer
                 (#
                    action:: 
                      (# 
                      <<SLOT siftexteditorMouseDownTimerAction:DoPart>>
                      #);
                    
                 #);
               onMouseDown::< 
                 (#  <<SLOT sifTexteditorOnMouseDown:DoPart>> #);
               mouseUpTimer: @timer
                 (#
                    action:: 
                      (# 
                      <<SLOT siftexteditorMouseUpTimerAction:DoPart>>
                      #);
                    
                 #);
               onMouseUp::<  (#  <<SLOT sifTexteditorOnMouseUp:DoPart>> #);
               onBeforeChange::< 
                 (# 
                 <<SLOT sifTexteditorOnBeforeChange:DoPart>>
                 #);
               onTextChanged::< 
                 (# 
                 do
                    (if sifViewer[] <> none then
                        (if SifViewer.switch[1] then
                            'onTextChanged'->putLine; 
                        if);
                        INNER
                    if);
                    
                 #);
               onFrameChanged::< 
                 (#  do <<SLOT siftexteditorOnFrameChanged:Descriptor>> #);
               onEnableTarget::<
                 (#  <<SLOT siftexteditorOnEnableTarget:DoPart>> #);
               onDisableTarget::< 
                 (# 
                 <<SLOT siftexteditorOnDisableTarget:DoPart>>
                 #);
               
            #);
          
       #);
     selectArea:
       (# line1,pos1,line2,pos2: @integer
       enter (line1,pos1,line2,pos2)
       <<SLOT siftexteditorSelectArea:DoPart>>
       #);
     deleteline:
       (# lineno: @integer; 
       enter lineno
       do
          <<SLOT sdeWtexteditordeleteline:Descriptor>>
       #);
     deletelines:
       (# lineno,number: @integer; 
       enter (lineno,number)
       do <<SLOT sdeWtexteditordeletelines:Descriptor>>
       #);
     deleteArea:
       (#
          line1,pos1,line2,pos2:
            @integer
       enter (line1,pos1,line2,pos2)
       <<SLOT siftexteditorDeleteArea:DoPart>>
       #);
     insertline:
       (#
          lineno: @integer; tt: ^text; 
       enter (tt[],lineno)
       do
          <<SLOT sdeWtexteditorinsertline:Descriptor>>
       #);
     getline:
       (# lineno: @integer; tt: ^text; 
       enter lineno
       do <<SLOT sdeWtexteditorgetline:Descriptor>>
       exit tt[]
       #);
     insertText:
       (# tt: ^text; 
       enter tt[]
       do
          <<SLOT sdeWtexteditorinsertText:Descriptor>>
       #);
     replaceText: (#  #);
     setText:
       (# tt: ^text; 
       enter tt[]
       do <<SLOT sdeWtexteditorsetText:Descriptor>>
       #);
     getText:
       (#
          lineno: @integer;
          tt: ^text;
          
       enter lineno
       do
          <<SLOT sdeWtexteditorgetText:Descriptor>>
       exit tt[]
       #);
     delete:
       (# lineno: @integer; tt: ^text; 
       enter lineno
       do <<SLOT sdeWtexteditordelete:Descriptor>>
       exit tt[]
       #);
     before:
       (# 
       do
          <<SLOT sdeWtexteditorbefore:Descriptor>>
       #);
     after: (#  do <<SLOT sdeWtexteditorafter:Descriptor>> #);
     refresh:
       (#
          lineno: @integer; tt: ^text; 
       enter lineno
       do
          <<SLOT sdeWtexteditorrefresh:Descriptor>>
       exit tt[]
       #);
     lastPosition:
       (# pos: @integer
       <<SLOT sdeWtexteditorLastposition:DoPart>>
       exit pos
       #);
     posToLineChar:
       (#
          pos: @integer;
          line,char: @integer;
          
       enter pos
       <<SLOT sdeWtexteditorposToLineChar:DoPart>>
       exit (line,char)
       #);
     lineCharToPos:
       (# line,char: @integer; pos: @integer; 
       enter (line,char)
       <<SLOT sdeWtexteditorlineCharToPos:DoPart>>
       exit pos
       #);
     scrollIntoView:
       (# 
       <<SLOT siftexteditorScrollIntoView:DoPart>>
       #);
     centerSelection: (#  <<SLOT siftexteditorCenterSelection:DoPart>> #);
     selectionLength:
       (# length: @integer
       <<SLOT siftexteditorSelectionLength:DoPart>>
       exit length
       #);
     newfragment:<
       (#
          theEditorRoot,initialSelection: ^astInterface.ast;
          ed: ^codeviewerType
       enter (mps[],theGrammar[],theEditorRoot[],initialSelection[])
       <<SLOT siftexteditorNewfragment:DoPart>>
       exit ed[]
       #);
     open::< 
       (#
          defaultSize:<
            (# value: @Point; 
            <<SLOT siftexteditorDefaultSize:DoPart>>
            exit value
            #);
          
       <<SLOT siftexteditorOpen:DoPart>>
       #);
     close::<  (#  <<SLOT siftexteditorClose:DoPart>> #)
  #);
codeviewer:
  (#
     no: @integer;
     mps: ^astInterface;
     betaGrammar: (*^astInterface.treelevel;*)
       ^astInterface.beta;
     betaGram: @grammar;
     mg: ^astInterface.metagrammar;
     prodList: ^mg.productionList;
     gram:< mps.treelevel;
     ag (* applicationGrammar *) : ^gram;
     theGrammar: ^astInterface.treeLevel;
     isApropertyEditor: @boolean;
     isAsubeditor: @boolean;
     isAFrejaEditor: @boolean;
     fatherEditor: ^codeviewer;
     fg: ^astInterface.fragmentGroup;
     frag: ^astInterface.fragmentForm;
     editorRoot:
     (* root of this editor normally the same as frag.root, except in subeditors *)
     ^astInterface.ast;
     start,end: @integer;
     fragDotRoot: @
       (#
          setRoot: @
            (# node: ^astInterface.ast
            enter node[]
            do node[]->frag.root[]->editorRoot[]
            #)
       enter setRoot
       exit frag.root[]
       #);
     initialSelection: (* inititial selection *) ^astInterface.ast;
     UI: ^guienv;
     readOnly:< booleanObject
       (#  do INNER ; value->isReadOnly;  exit value #);
     isReadOnly:
     (* is set to true if the file is readOnly or may be set
      * by the user
      *) @boolean;
     setIsReadOnly:<
       (# value: @boolean
       enter value
       <<SLOT codeviewerSetIsReadOnly:DoPart>>
       #);
     adaptivePrettyprinting:<
       (#
          set:< (# v: @boolean enter v do INNER #);
          get:< (# v: @boolean do INNER exit v #)
       enter set
       do INNER
       exit get
       #);
     theSifTextEditor: ^sifTextEditor;
     id: @integer;
     doObserveAST,traceSLOTsearch: @boolean;
     setWaitCursor: (#  <<SLOT codeviewerSetWaitCursor:DoPart>> #);
     setStructureCursor:
       (# 
       <<SLOT codeviewerSetStructureCursor:DoPart>>
       #);
     onOpen:< (#  <<SLOT codeviewerOnOpen:DoPart>> #);
     askBeforeTextediting:< booleanValue;
     askBeforeTexteditingMessage:<
       (# msg: ^text
       do INNER
       exit msg[]
       #);
     onUpArrowKey:<
       (# 
       <<SLOT codeviewerOnUpArrowKey:DoPart>>
       #);
     onDownArrowKey:< (#  <<SLOT codeviewerOnDownArrowKey:DoPart>> #);
     onLeftArrowKey:<
       (# 
       <<SLOT codeviewerOnLeftArrowKey:DoPart>>
       #);
     onRightArrowKey:< (#  <<SLOT codeviewerOnRightArrowKey:DoPart>> #);
     onReturnKey:<
       (# 
       <<SLOT codeviewerOnReturnKey:DoPart>>
       #);
     onDeleteKey:< object;
     keyAllowed:< booleanValue
       (# ch: @char enter ch <<SLOT codeviewerKeyAllowed:DoPart>> #);
     fragmentDefaultName:
       (# f: @file
       enter f.name
       exit f.entry.path.name.prefix
       #);
     generalOutput: astView.output
       (#
          printSpecialComment::< 
            (#
               skipLeadingBlanks: @boolean;
               
            do
               0->noOfLines;
               astView.pp.comBegin.lgth
                 ->lengthOfLastLine;
               astView.pp.comBegin[]
                 ->putText;
               false->skipLeadingBlanks;
               com.scanAll
                 (# 
                 do
                    (if ch
                     // ascii.newLine then
                        noOfLines+1
                          ->noOfLines;
                        1->lengthOfLastLine;
                        lineNo+1->lineNo;
                        lineNo->newLine;
                        (for margin+1 repeat ' '->put for);
                        true->skipLeadingBlanks;
                        
                     else
                        (if skipLeadingBlanks then
                            (if not (ch->ascii.isSpace) then
                                ch->put;
                                lengthOfLastLine+1->lengthOfLastLine;
                                false->skipLeadingBlanks
                            if)
                         else
                        (* skipping tabs *)
                            (if (ch->ascii.isSpace) then
                                (if ch
                                 // ascii.sp then
                                    ch->put;
                                    lengthOfLastLine+1->lengthOfLastLine;
                                    
                                 else
                                    'eating tabs in comment: '->screen.putText;
                                    ch->screen.putInt;
                                    screen.newLine;
                                    ' '->put;
                                    
                                if)
                             else
                                ch->put; lengthOfLastLine+1->lengthOfLastLine; 
                            if);
                            
                        if);
                        
                    if);
                    
                 #);
               lengthOfLastLine+astView.pp.comEnd.lgth->lengthOfLastLine;
               astView.pp.comEnd[]->putText;
               
            #);
          measureSpecialComment::< 
            (# 
            do
               (if (com.lgth > 40) then
                   100
                     ->length
                     (* only used to provoke a break
                      * the length 
                      *)
               if);
               
            #);
          (*putT: @screen.putText;
           putL: @screen.putLine;
           putC: @screen.put;
           *)
          
       #);
     checkFormEditorExistence:<
       (#
          ff: ^astInterface.fragmentForm;
          createIfNotExists: @boolean;
          theSifViewer: ^codeViewer
       enter (ff[],createIfNotExists)
       <<SLOT codeviewerCheckFormEditorExistence:DoPart>>
       exit theSifViewer[]
       #);
     setupFormEditor:<
       (# theSifViewer: ^codeViewer
       enter theSifViewer[]
       <<SLOT codeviewerSetupFormEditor:DoPart>>
       #);
     closeGroup:<
     (* if value then close is OK *) booleanValue;
     closeForm:< object;
     windowOutput: generalOutput
       (#
          windowLine,theWholeText: ^text;
          beforePresent::< 
            (# 
            do
               (if switch[1] then 'out. beforePresent'->screen.putLine;  if);
               theWholeText.clear;
               theSifTexteditor.before;
               ;
               
            #);
          afterPresent::< 
            (# 
            do
               (if switch[1] then 'out.afterPresent'->screen.putLine;  if);
               theWholeText[]->theSifTexteditor.insertText;
               theSifTexteditor.after;
               
            #);
          beforeUpdate::< 
            (# 
            do
               (if switch[1] then 'out.beforeUpdate'->screen.putLine;  if);
               theWholeText.clear;
               theSifTexteditor.before;
               
            #);
          afterUpdate::< 
            (# 
            do
               (if switch[1] then 'out.afterUpdate'->screen.putLine;  if);
               theWholeText[]->theSifTexteditor.insertText;
               theSifTexteditor.after;
               
            #);
          put::<  (#  do ch->windowLine.put;  #);
          putText::<  (#  do s[]->windowLine.putText;  #);
          putInt::<  (#  do n->windowLine.putInt #);
          selectArea::< 
            (# 
            do
               (if switch[1] then 'out.selectArea'->screen.putLine;  if);
               ((row1,col1,row2,col2))->theSifTexteditor.selectArea;
               
            #);
          clear::< 
            (# 
            do
               (if switch[1] then 'out.clear'->screen.putLine;  if);
               theSifTexteditor.contents.all
                 ->theSifTexteditor.contents.selection;
               theSifTexteditor.contents.clear
            #);
          newLine::< 
            (# 
            do
               (if switch[1] then 'out.newLine'->screen.putLine;  if);
               (if windowLine.length > 0 then
                   windowLine[]->theWholeText.putLine; windowLine.clear; 
                else
               (*'eating emtyline!'->screen.putLine;*)
                   
               if);
               
            #);
          insertLine::< 
            (# 
            do
               (if switch[1] then 'out.insertLine'->screen.putLine;  if);
               ('  ',lineNo)->theSifTexteditor.insertLine;
               
            #);
          deleteLine::< 
            (# 
            do
               (if switch[1] then 'out.deleteLine'->screen.putLine;  if);
               lineNo->theSifTexteditor.deleteLine;
               
            #);
          deleteLines::< 
            (# 
            do
            (*(for i:number repeat
             lineNo -> theSifTexteditor.contents.deleteLine;
             for) *)
               (if switch[1] then 'out.deleteLines'->screen.putLine;  if);
               (lineNo,number)->theSifTexteditor.deleteLines;
               
            #);
          deleteArea::< 
            (# 
            do
               (if switch[1] then 'out.deleteArea'->screen.putLine;  if);
               ((line1,pos1,line2,pos2))->theSifTexteditor.deleteArea
            #);
          getLine::< 
            (# 
            do
               (if switch[1] then 'out.getLine'->screen.putLine;  if);
               lineNo->theSifTexteditor.getLine->s[];
               
            #);
          init::< 
            (# 
            do
               (if switch[1] then 'out.init'->screen.putLine;  if);
               &text[]->windowLine[];
               &text[]->theWholeText[];
               
            #);
          
       #);
     astFocus: (* end earlier in pretty *)
       (#
          node: ^astInterface.ast;
          length,subCommentInx1,subCommentInx2: @integer;
          isComment,isContraction,isSlot,hasSemanticLink,isUnexpanded:
            @boolean;
          pastePermit,listInsertPermit,undoPermit,redoPermit: @boolean;
          perform:
            (#
               current: ^astInterface.ast;
               fatherNode: ^astInterface.ast;
               exp: ^astInterface.expanded
            do
               (if length = 1 then
                   node[]->current[];
                   INNER perform;
                   (true,current[])->refreshEvent;
                   
                else
                   node.father->fatherNode[];
                   (if fatherNode[] <> none then
                       (if fatherNode.kind = mps.kinds.interior then
                           fatherNode[]->exp[];
                           (for i: length repeat
                             node.sonNo+i-1->exp.get->current[];
                             INNER perform;
                             (true,current[])->refreshEvent;
                             
                           for);
                           (* (exp[],node.sonNo,length,length)
                            ->astView.pp.updateList*)
                           
                       if)
                   if);
                   
               if);
               (node[],length,subCommentInx1,subCommentInx2)->astToSelection;
               
            #);
          
       enter (node[],length,subCommentInx1,subCommentInx2)
       exit (node[],length,subCommentInx1,subCommentInx2)
       #);
     cs: @astFocus;
     astView: ^astInterface.astViewer;
     switch: [100] @boolean;
     doTrace,edDebug: @boolean;
     trace:
       (# str: ^text
       do
          (if doTrace then
              INNER ; '/'->screen.put; str[]->screen.putText; 
          if)
       #);
     test:
       (# str: ^text; 
       do (if edDebug then INNER ; str[]->screen.putText;  if)
       #);
     dir: @
       (#
          up: (#  exit 0 #);
          down: (#  exit 1 #);
          pred: (#  exit 2 #);
          next: (#  exit 3 #);
          root: (#  exit 4 #);
          extend: (#  exit 5 #);
          nextNonterminal: (#  exit 6 #);
          prevNonterminal: (#  exit 7 #);
          
       #);
     selectionToAST:
       (# start,end: @integer; newCS: @astFocus
       enter (start,end)
       do <<SLOT codeviewerSelectionToAst:Descriptor>>
       exit newCS
       #);
     selectionToFocus:
       (#
          start,end: @integer;
          doScrollIntoView:
            @boolean
       enter (start,end,doScrollIntoView)
       <<SLOT codeviewerSelectionToFocus:DoPart>>
       #);
     refreshEvent:<
       (# byME: @boolean; node: ^astInterface.ast
       enter (byMe,node[])
       <<SLOT codeviewerRefreshEvent:DoPart>>
       #);
     aFocusChangedEvent:
       @focusChangedEvent;
     focusChangedEvent:<
       (#
          byMe: @boolean;
          newCS: @astFocus;
          inContr: @boolean;
          contractionNode: ^astInterface.ast
       enter (byMe,newCS)
       do <<SLOT codeviewerFocusChangedEvent:Descriptor>>
       #);
     topDotOpen:
       (#
          input: ^text;
          f:
            ^astInterface.
               fragment;
          feedBackOnNotExisting:< booleanValue
            (#  do true->value; INNER #);
          myStartingParsing:< object;
          myParseErrors:< object;
          myFatalParseError:<
            (# errNo: @integer enter errNo do INNER #);
          noChangesOnDisk:< (* used by checkDisk *) object;
          checkDisk:< trueObject;
          
       enter input[]
       do '<<SLOT topDotOpenBody:Descriptor>>'->putLine; 
       exit f[]
       #);
     groupEditorList: @list
       (#
          findEditorForForm:
          (* given a fragmentform and an AST node inside it (selectedNode),
           *            * find an Editor on the fragmentform and select the AST node
           *            * if not found create the editor
           *            * id is used in the communication with Freja
           *            *)
            (#
               ff: ^astInterface.fragmentForm;
               selectedNode: ^astInterface.ast;
               newEditor: ^fragmentEditor;
               id: @integer
            enter (ff[],selectedNode[])
            do '<<SLOT findEditorForFormBody:Descriptor>>'->putLine; 
            exit (newEditor[],id)
            #);
          findAndSelect:
            (# a: ^astInterface.ast; ed: ^fragmentEditor
            enter a[]
            do '<<SLOT findAndSelectBody:Descriptor>>'->putLine
            exit ed[]
            #);
          
       #);
     fragmentEditor: (#  #);
     getSynCatNo:
       (#
          node: ^astInterface.ast;
          synCatNo: @mps.nonterminalSymbol;
          nontNode: ^astInterface.unExpanded
       enter node[]
       do
          (if
          ((node.kind = mps.kinds.unexpanded) or
           (node.kind = mps.kinds.optional)) then
              node[]->nontNode[]; nontNode.nonterminalSymbol->synCatNo
           else
              node.symbol->synCatNo
          if)
       exit synCatNo
       #);
     nodeExists:
       (#
          node: ^astInterface.ast;
          subtree: ^astInterface.expanded;
          value: @boolean
       enter (node[],subtree[])
       do <<SLOT codeviewerNodeExists:Descriptor>>
       exit value
       #);
     isNodeInTree:
       (#
          node,tree: ^astInterface.ast;
          value: @boolean
       enter (node[],tree[])
       do
          <<SLOT codeviewerIsNodeInTree:Descriptor>>
       exit value
       #);
     setFocus:
       (#
          newCS: @astFocus;
          checkExistence:< booleanObject;
          nodeNotFound:<
            (# msg: ^text; 
            do 'SetFocus: node not found'->msg[]; INNER ; msg[]->putLine
            #);
          scrollIntoView:< booleanValue (#  do true->value; INNER #)
       enter newCS
       do <<SLOT codeviewerSetFocus:Descriptor>>
       #);
     setNode:
       (# node: ^astInterface.ast
       enter node[]
       <<SLOT codeviewerSetNode:DoPart>>
       #);
     astToSelection:
       (# 
       enter cs
       do
          cs->selectArea
            ->
              astView.out.selectArea
              (* burde istedet kalde en cursor i winduet, maaske bare selection *)
       #);
     ASTObserver:
       (# node: ^astInterface.ast; 
       enter node[]
       do
            (#
               synCatNo,fatherSynCatNo,superSynCatNo: @mps.nonterminalSymbol;
               prod,fatherProd,nextProd: ^mg.prod;
               fatherNode: ^astInterface.ast;
               str,str2: @text;
               constructor: ^mg.constructor;
               alternation: ^mg.alternation;
               opt: ^mg.opt;
               listOne: ^mg.listOne;
               listZero: ^mg.listZero;
               dummy: ^mg.dummy;
               leftSide: ^mg.leftSide;
               
            do
               '['->screen.put;
               node[]->getSynCatNo->synCatNo;
               (if node.kind
                // mps.kinds.comment then 'comment'->str; 
                else
                   (if synCatNo.isLexem then
                       (if node.kind
                        // mps.kinds.nameAppl then
                           'nameAppl'->str; 
                        // mps.kinds.nameDecl then
                           'nameDecl'->str; 
                        // mps.kinds.string then
                           'string'->str; 
                        // mps.kinds.const then
                           'const'->str; 
                        else
                           'lexem'->str; 
                       if);
                       
                    else
                       synCatNo->Prodlist.get->prod[];
                       (if prod.symbol
                        // mg.alternation then
                           'alternation'->str; 
                        // mg.constructor then
                           'constructor'->str; 
                        // mg.listOne then
                           'listOne'->str; 
                        // mg.listZero then
                           'listZero'->str; 
                        // mg.opt then
                           'optional'->str; 
                        // mg.dummy then
                           'dummy'->str; 
                       if);
                       
                   if);
                   
               if);
               str[]->screen.putText;
               synCatNo->screen.putInt;
               ' '->screen.put;
               node.father
                 -> (* now look at the father or super categories *)
                   fatherNode[];
               (if fatherNode[]
                // none then 'root'->screen.putText; 
                else
                   fatherNode[]->getSynCatNo->fatherSynCatNo;
                   (if fatherSynCatNo.isLexem (* should not be necessary? *)
                    then
                       'fatherLexem'->screen.putText; 
                    else
                       fatherSynCatNo->Prodlist.get->fatherProd[];
                       (if fatherProd.symbol
                        // mg.listOne // mg.listZero then
                           'list'->screen.putText;
                           fatherSynCatNo->screen.putInt;
                           
                        else
                           (if not synCatNo.isLexem then
                               loop:
                                 (# 
                                 do
                                    (if prod.symbol
                                     // mg.constructor then
                                        'C'->screen.put;
                                        prod[]->constructor[];
                                        constructor.getLeftside->leftSide[];
                                        
                                     // mg.alternation then
                                        'A'->screen.put;
                                        prod[]->alternation[];
                                        alternation.getLeftside->leftSide[];
                                        
                                     // mg.opt then
                                        'O'->screen.put;
                                        prod[]->opt[];
                                        opt.getLeftside->leftSide[];
                                        
                                     // mg.listOne then
                                        'LO'->screen.putText;
                                        prod[]->listOne[];
                                        listOne.getLeftside->leftSide[];
                                        
                                     // mg.listZero then
                                        'LZ'->screen.putText;
                                        prod[]->listZero[];
                                        listZero.getLeftside->leftSide[];
                                        
                                     // mg.dummy then
                                        'D'->screen.put;
                                        prod[]->dummy[];
                                        dummy.getLeftside->leftSide[];
                                        
                                    if);
                                    1->leftSide.getAttribute->superSynCatNo;
                                    (if superSynCatNo
                                     // mps.super.cons then
                                        'cons'->screen.putText; 
                                     // mps.super.list then
                                        'list'->screen.putText; 
                                     // mps.super.undefined then
                                        'undefined'->screen.putText; 
                                     else
                                        'super'->screen.putText;
                                        superSynCatNo->screen.putInt;
                                        ' '->screen.put;
                                        superSynCatNo->Prodlist.get->prod[];
                                        restart loop;
                                        
                                    if);
                                    
                                 #);
                               
                           if);
                           
                       if);
                       
                   if);
                   
               if);
               ']'->screen.put;
               ' '->put;
                 (#
                    index: @integer; node: ^astInterface.ast; pptext: @text; 
                 do
                    (if syncatNo.islexem then
                        'cs.node is a lexem, prettyprint father instead'
                          ->putLine;
                        cs.node.father->cs.node[]
                    if);
                    (mps[],frag[],cs.node[],ppText[],none ,80,0,false,false,
                     false,false,false,false,false,'',false,false,false)
                      ->ppFragment;
                    'Prettyprint of node: '->screen.putText;
                    cs.node.index->screen.putInt;
                    screen.newLine;
                    ppText[]->screen.putLine;
                    checkson;
                    
                 #);
               
            #)
       #);
     editComment:
       (#
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2: @integer;
          t: ^text;
          reprettyprint: @boolean;
          
       enter (node[],subCommentInx1,subCommentInx2,t[])
       do <<SLOT editComment:Descriptor>>
       exit reprettyprint
       #);
     ShowCommentPermit,MakeCommentPermit,
       HideCommentPermit,PasteCommentPermit: @boolean;
     commentEditor: window
       (#
          setTitle:<
            (# t: ^text <<SLOT commentEditorSetTitle:DoPart>> exit t[] #);
          isReadOnly: @boolean;
          menubarType:: 
            (#
               fileMenu: @menu
                 (#
                    revertItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onSelect:: 
                                (# 
                                <<SLOT commentWindowFileMenuRevertOnSelect:DoPart>>
                                #)
                           #);
                         open:: 
                           (#  <<SLOT commentEditorFileMenuOpen:DoPart>> #)
                      #);
                    closeItem:
                      @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onSelect:: 
                                (# 
                                <<SLOT commentWindowFileMenuCloseOnSelect:DoPart>>
                                #)
                           #);
                         open:: 
                           (# 
                           <<SLOT commentEditorFileMenuCloseOpen:DoPart>>
                           #)
                      #);
                    open:: 
                      (# 
                      <<SLOT commentWindowFileMenuOpen:DoPart>>
                      #)
                 #);
               editMenu: @menu
                 (#
                    cutItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT commentEditorCutOnStatus:DoPart>>
                                #);
                              onSelect::
                               
                                (# 
                                <<SLOT commentEditorCutOnSelect:DoPart>>
                                #)
                           #);
                         open:: 
                           (# 
                           <<SLOT commentEditorCutOpen:DoPart>>
                           #)
                      #);
                    copyItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT commentEditorCopyOnStatus:DoPart>>
                                #);
                              onSelect:: 
                                (# 
                                <<SLOT commentEditorCopyOnSelect:DoPart>>
                                #)
                           #);
                         open:: 
                           (# 
                           <<SLOT commentEditorCopyOpen:DoPart>>
                           #)
                      #);
                    pasteItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT commentEditorPasteOnStatus:DoPart>>
                                #);
                              onSelect:: 
                                (# 
                                <<SLOT commentEditorPasteOnSelect:DoPart>>
                                #)
                           #);
                         open:: 
                           (#  <<SLOT commentEditorPasteOpen:DoPart>> #)
                      #);
                    open:: 
                      (# 
                      <<SLOT commentWindowEditMenuOpen:DoPart>>
                      #)
                 #);
               open::  (#  <<SLOT commentEditorEditMenuOpen:DoPart>> #)
            #);
          contents: @textEditor
            (#
               contentsType:: 
                 (#
                    eventhandler:: 
                      (#
                         onBeforeChange::< 
                           (# 
                           <<SLOT commentTexteditorOnBeforeChange:DoPart>>
                           #);
                         onFrameChanged::< 
                           (# 
                           <<SLOT commentTexteditorOnFrameChanged:DoPart>>
                           #);
                         onEnableTarget::< 
                           (# 
                           <<SLOT commentTexteditorOnEnableTarget:DoPart>>
                           #);
                         onDisableTarget::< 
                           (# 
                           <<SLOT commentTexteditorOnDisableTarget:DoPart>>
                           #)
                      #)
                 #);
               dobind:
                 (# 
                 do
                    TRUE
                      ->bindTop
                      ->bindLeft
                      ->
                        bindRight->bindBottom;
                    
                 #);
               open::  (#  <<SLOT commentTextEditorOpen:DoPart>> #);
               
            #);
          open::< 
            (# 
            <<SLOT commentEditorWindowOpen:DoPart>>
            #);
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2: @integer;
          commentEditorPrivate: @<<SLOT commentEditorPrivate:Descriptor>>;
          
       #);
     printComment:
       (#
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2:
            @integer;
          reprettyprint: @boolean;
          updateWindow: @boolean
       enter (node[],subCommentInx1,subCommentInx2,reprettyprint,updateWindow)
       do
          (if reprettyprint then
              (true,node[])->refreshEvent; (node[],1,0,0)->astToSelection
           else
              (node[],subCommentInx1,subCommentInx2,updateWindow)
                ->comCprivate.checkWindow
          if);
          
       #);
     createCommentWindow:
       (#
          node: ^astInterface.ast;
          subCommentInx1,subCommentInx2: @integer;
          theWindow: ^commentEditor;
          
       enter (node[],subCommentInx1,subCommentInx2)
       <<SLOT createCommentWindow:DoPart>>
       exit theWindow[]
       #);
     commentWindows: @list
       (#
          element::< commentEditor;
          insertWindow:
            (# ce: ^commentEditor; 
            enter ce[]
            <<SLOT commentWindowsInsertWindow:DoPart>>
            #);
          deleteWindow:
            (#
               node:
                 ^astInterface.ast;
               subcommentInx1,
                 subcommentInx2: @integer
            enter (node[],subcommentInx1,subcommentInx2)
            <<SLOT commentWindowsDeleteWindow:DoPart>>
            #);
          findWindow:
            (#
               node: ^astInterface.ast;
               ce: ^commentEditor;
               subcommentInx1,subcommentInx2: @integer
            enter (node[],subcommentInx1,subcommentInx2)
            <<SLOT commentWindowsFindWindow:DoPart>>
            exit ce[]
            #);
          deleteAllWindows:
            (#  <<SLOT commentWindowsDeleteAllWindows:DoPart>> #);
          
       #);
     comcPrivate: @
       (#
          commentWindowsTest:
            (# 
            do
               (if switch[12] then
                   '######################## commentWindows'->putLine;
                   commentWindows.scan
                     (# 
                     do
                        'node: '->putText;
                        current.node.index->putInt;
                        '   '->putText;
                        'inx1: '->putText;
                        current.subcommentinx1->putInt;
                        '   '->putText;
                        'inx2: '->putText;
                        current.subcommentinx2->putInt;
                        newLine
                     #)
               if)
            #);
          checkWindow:
            (#
               node: ^astInterface.ast;
               subCommentInx1,subCommentInx2: @integer;
               updateWindow: @boolean;
               theWindow: ^commentEditor;
               
            enter (node[],subCommentInx1,subCommentInx2,updateWindow)
            <<SLOT checkCommentWindow:DoPart>>
            #);
          
       #);
     makeDetail:< (#  <<SLOT codeviewerMakeDetail:DoPart>> #);
     makeAbstract:<
       (# 
       <<SLOT codeviewerMakeAbstract:DoPart>>
       #);
     makeShowComment:<
       (# modifier,doneInInner: @boolean
       enter modifier
       <<SLOT codeviewerMakeShowComment:DoPart>>
       #);
     makeFollowSemanticLink:<
       (#
          separate,doneInInner:
            @boolean
       enter separate
       <<SLOT codeviewerMakeFollowSemanticLink:DoPart>>
       #);
     makeSearchSlotBinding:<
       (#
          separate: @boolean;
          a: ^astInterface.ast;
          doneInInner: @boolean
       enter separate
       <<SLOT codeviewerMakeSearchSlotBinding:DoPart>>
       #);
     searchSlotBinding:
       (#
          searchedUnexp: ^astInterface.unexpanded;
          searchSLOTbindingPrivate: @<<SLOT searchSLOTPrivate:Descriptor>>;
          bindingFound:<
            (#
               ff:
                 ^astInterface.fragmentform
            enter ff[]
            do INNER
            #);
          bindingNotFound:<
            (# slotName: ^text enter slotName[] do INNER #)
       enter searchedUnexp[]
       <<SLOT searchSlotBinding:DoPart>>
       #);
     getFragmentGroup:<
       (#
          name: ^text;
          fg: ^astInterface.fragmentGroup
       enter name[]
       do INNER
       exit fg[]
       #);
     machineType:<
       (# t: ^text do INNER exit t[] #);
     selectNodeInFormEditor:<
       (#
          theEditorRoot,node:
            ^astInterface.ast;
          separate,doneInInner: @boolean;
          
       enter (theEditorRoot[],node[],separate)
       <<SLOT codeviewerSelectNodeInFormEditor:DoPart>>
       #);
     updateHistory:<
       (# node: ^astInterface.ast enter node[] do INNER updateHistory #);
     followSemanticLink:<
       (# separate: @boolean; node: ^astInterface.ast; 
       enter (node[],separate)
       do INNER ; 
       #);
     handleDoubleClick:<
       (# modifier,doneInInner: @boolean
       enter modifier
       do <<SLOT codeviewerHandleDoubleClick:Descriptor>>
       #);
     onPopUpButton:<
       (#
          pos: @point;
          doneInInner: @boolean
       enter pos
       do INNER
       #);
     selectArea:
       (#
          f: @astFocus;
          l1,l2,l,c1,c2:
            @integer;
          c: @integer;
          fatherNode: ^astInterface.expanded;
          node,keepNode: ^astInterface.ast
       enter f
       <<SLOT codeviewerSelectArea:DoPart>>
       exit (l1,c1,l2,c2)
       #);
     hasComment:
       (#
          node: ^astInterface.ast;
          hasOne: @boolean;
          expNode: ^astInterface.expanded;
          
       enter node[]
       do
          false->hasOne;
          (if (node## <= mps.expanded##)
           // true then
              node[]->expNode[];
              loop: expNode.suffixWalk
                (# 
                do
                   (if current.hasComment
                    // true then
                       true->hasOne;
                       leave loop
                   if);
                   
                #);
              
          if);
          
       exit hasOne
       #);
     contractionCategories: [1] @integer;
     getPropertiesFromGrammar:
       (#
          fg: ^astInterface.fragmentGroup; 
       <<SLOT codeviewerGetPropertiesFromGrammar:DoPart>>
       #);
     setContractions:
       (#
          node: ^astInterface.ast;
          symbol: @mps.nonterminalSymbol;
          expNode: ^astInterface.expanded
       enter node[]
       <<SLOT codeviewerSetContractions:DoPart>>
       #);
     setContraction:
       (# node: ^astInterface.ast
       enter node[]
       <<SLOT codeviewerSetContraction:DoPart>>
       #);
     inContraction:
       (#
          node,contractionNode: ^astInterface.ast;
          inContr: @boolean;
          fatherNode: ^astInterface.ast;
          
       enter node[]
       <<SLOT codeviewerInContraction:DoPart>>
       exit (inContr,contractionNode[])
       #);
     openContractionsUntilRoot:
       (# node,holoNode,fatherNode: ^astInterface.ast; inHolo: @boolean; 
       enter node[]
       <<SLOT codeviewerOpenContractionsUntilRoot:DoPart>>
       #);
     openContraction:
       (#
          node:
            ^astInterface.
               ast;
          aComment:
            ^astInterface.
               comment;
          
       enter node[]
       <<SLOT codeviewerOpenContraction:DoPart>>
       #);
     openAllContractions:
       (# node: ^astInterface.ast
       enter node[]
       <<SLOT codeviewerOpenAllContractions:DoPart>>
       #);
     openContractionLevel:
       (#
          node: ^astInterface.ast;
          level: @integer;
          aComment:
            ^astInterface.comment;
          anExp:
            ^astInterface.expanded;
          openedOne: @boolean;
          
       enter (node[],level)
       <<SLOT codeviewerOpenContractionLevel:DoPart>>
       #);
     showAst:
       (# 
       do
          <<SLOT showAstBody:Descriptor>>
       #);
     doAbstract: doCommand
       (#  do cs.perform (#  do current[]->setContraction #) #);
     doAbstractRecursively: doCommand
       (#  do cs.perform (#  do current[]->setContractions #) #);
     doOverview: doCommand
       (# 
       do
          editorRoot[]->setContractions;
          (editorRoot[],- 1)->astView.pp.present;
          cs->setFocus
       #);
     doDetail: doCommand (#  <<SLOT codeviewerDoDetail:DoPart>> #);
     doDetailRecursively: doCommand
       (# 
       do
          cs.perform
            (# 
            do current[]->openAllContractions
            #)
       #);
     askZoomIn: booleanValue
       (# 
       <<SLOT codeviewerAskZoomIn:DoPart>>
       #);
     askZoomOut: booleanValue (#  <<SLOT codeviewerAskZoomOut:DoPart>> #);
     askZoomFullEditor: booleanValue
       (# 
       <<SLOT codeviewerAskZoomFullEditor:DoPart>>
       #);
     doZoomIn: doCommand (#  <<SLOT codeviewerDoZoomIn:DoPart>> #);
     doZoomOut: doCommand
       (# 
       <<SLOT codeviewerDoZoomOut:DoPart>>
       #);
     doZoomFullEditor: doCommand
       (#  <<SLOT codeviewerDoZoomFullEditor:DoPart>> #);
     doReprettyprint: doCommand
       (# 
       <<SLOT codeviewerDoReprettyprint:DoPart>>
       #);
     doShowAst: doCommand
       (# node: ^astInterface.ast enter node[] <<SLOT doShowAst:DoPart>> #);
     automaticHolocomments:
       (# abstracted: @boolean; 
       do
          false->abstracted;
          loop: frag.prop.scanProp
            (#
               doProp::< 
                 (# 
                 do
                    (if ('ABSTRACTED'->prop.equal->abstracted)
                     // true then leave loop
                    if)
                 #);
               
            #);
          (if not abstracted then
              editorRoot[]->setContractions; 'ABSTRACTED'->frag.prop.addProp; 
          if)
       #);
     setBreakPointBefore:
       (#
          node: ^astInterface.ast;
          theText: ^text;
          update: @boolean;
          pos: @integer;
          commentAST: ^astInterface.comment;
          theComment: ^text
       enter (node[],theText[],update)
       do
          (if not node.hasComment then
              node[]->astView.pp.CreateEmptyComment->theComment[];
              (mps.comment,0,frag[])->frag.grammar.newlexemText->commentAST[];
              theComment[]->commentAST.putText;
              commentAST[]->node.addComment
          if);
          (theText[],1,1)->node.setSubcomment;
          astView.pp.breakPointComment->node.typeOfComment;
          (if update then
              (true,node[])->refreshEvent; (node[],1,0,0)->setFocus
          if)
       exit 1
       #);
     setBreakPointAfter:
       (#
          node: ^astInterface.ast;
          pos: @integer;
          theText: ^text;
          update: @boolean;
          commentAST: ^astInterface.comment;
          theComment: ^text;
          noOfSons: @integer
       enter (node[],theText[],update)
       do
          (if not node.hasComment then
              node[]->astView.pp.CreateEmptyComment->theComment[];
              (mps.comment,0,frag[])->frag.grammar.newlexemText->commentAST[];
              theComment[]->commentAST.putText;
              commentAST[]->node.addComment
           else
              node.getComment->commentAst[]; commentAST.getText->theComment[]
          if);
          mps.commentSeparator1->theComment.findAll (#  do inx->noOfSons #);
          (theText[],noOfSons+2,1)->node.setSubcomment;
          astView.pp.breakPointComment->node.typeOfComment;
          (if update then
              (true,node[])->refreshEvent; (node[],1,0,0)->setFocus
          if)
       exit noOfSons+2
       #);
     clearBreakPoint:
       (# node: ^astInterface.ast; pos: @integer; update: @boolean
       enter (node[],pos,update)
       do
          (if node.hasComment then ('',pos,1)->node.setSubcomment if);
          astView.pp.normalComment->node.typeOfComment;
          (if update then
              (true,node[])->refreshEvent; (node[],1,0,0)->setFocus
          if)
       #);
     subject4: (* navigation operations: selection.bet *) (#  #);
     findSuper:
       (# synCatNo: @mps.nonterminalSymbol; 
       enter synCatNo
       <<SLOT codeviewerFindSuper:DoPart>>
       exit synCatNo
       #);
     checkSuper:
       (#
          node,enclosingNode:
            ^astInterface.ast;
          synCatNo: @mps.nonterminalSymbol;
          
       enter node[]
       <<SLOT codeviewerCheckSuper:DoPart>>
       exit (synCatNo,enclosingNode[])
       #);
     parsingSynCatNo:
       (#
          node,enclosingNode: ^astInterface.ast;
          synCatNo: @mps.nonterminalSymbol;
          isList: @boolean;
          theListElement: ^astInterface.ast;
          
       enter node[]
       <<SLOT codeviewerParsingSynCatNo:DoPart>>
       exit
       (synCatNo,isList,
        theListElement[],enclosingNode[])
       #);
     selectNewCs: (#  do <<SLOT selectNewCsBody:Descriptor>> #);
     checkSon:
       (# 
       do <<SLOT checkSonBody:Descriptor>>
       #);
     checkSonNode:
       (# node: ^astInterface.ast
       enter node[]
       do <<SLOT checkSonNodeBody:Descriptor>>
       exit node[]
       #);
     checkFather:
       (# 
       do
          cs.node[]->checkFatherNode
            ->cs.node[]
       #);
     checkFatherNode:
       (# node: ^astInterface.ast
       enter node[]
       do
          <<SLOT checkFatherNodeBody:Descriptor>>
       exit node[]
       #);
     extend: (#  do <<SLOT extendBody:Descriptor>> #);
     down:
       (#  do <<SLOT downBody:Descriptor>> #);
     navigate:
       (# direction: @integer; 
       enter direction
       do <<SLOT navigateBody:Descriptor>>
       #);
     select:
       (# direction: @integer; 
       enter direction
       do <<SLOT selectBody:Descriptor>>
       #);
     selectPrivate: @<<SLOT selectPrivate:Descriptor>>;
     gotoNonterminal:
       (# 
       do
          <<SLOT gotoNonterminalBody:Descriptor>>
       #);
     gotoNonEmpty: (#  do <<SLOT gotoNonEmptyBody:Descriptor>> #);
     nextNonterminal:
       (# 
       do
          <<SLOT nextNonterminalBody:Descriptor>>
       #);
     prevNonterminal: (#  do <<SLOT prevNonterminalBody:Descriptor>> #);
     askUndoPermission:< booleanValue;
     askRedoPermission:< booleanValue;
     askPastePermission:< booleanValue;
     askInsertPermission:< booleanValue;
     askTexteditMode:< booleanValue;
     askOpenSubeditorPermission:<
      booleanValue;
     doCommand:
       (#  do setWaitCursor; INNER doCommand; setStructureCursor #);
     doUndo:< doCommand;
     doRedo:< doCommand;
     doCut:< doCommand;
     doCopy:< doCommand;
     doPaste:< doCommand;
     doClear:< doCommand;
     doTextedit:< (# ch: @char enter ch do INNER #);
     checkTexteditingFinished:<
       (# start,end: @integer enter (start,end) do INNER #);
     doParseText:< doCommand;
     doRevertTextedit:< doCommand;
     doShowTexteditCommands:< object;
     doInsertBefore:< doCommand;
     doInsertAfter:< doCommand;
     doRemoveOptionals:< doCommand;
     doShowOptionals:< doCommand;
     askMakeDoPartSlot:< booleanValue;
     askMakeDescriptorSlot:< booleanValue;
     askMakeAttributesSlot:< booleanValue;
     askPasteFragmentForm:< booleanValue;
     doMakeDoPartSlot:< object;
     doMakeDescriptorSlot:< object;
     doMakeAttributesSlot:< object;
     doPasteFragmentForm:< doCommand;
     doFillSlot:< doCommand;
     doFillAllSlots:< object;
     doSetImplementationFragment:< object;
     doUnsetImplementationFragment:< object;
     doSetSLOTNamePrefix:< object;
     doUnsetSLOTNamePrefix:< object;
     doHideImplementation:< object;
     openSubeditor:< doCommand
       (# theEditorRoot,node: ^astInterface.ast
       enter (theEditorRoot[],node[])
       do INNER
       #);
     createSubeditor:< doCommand
       (#
          theEditorRoot,node: ^astInterface.ast;
          theSifTextEditor: ^sifTexteditor;
          sed: ^codeviewer
       enter (theEditorRoot[],node[],theSifTexteditor[])
       do INNER
       exit sed[]
       #);
     close:< object;
     init:<
       (# 
       enter
       (mps[],theGrammar[],UI[],theSifTextEditor[],frag[],editorRoot[],
        initialSelection[])
       do <<SLOT codeviewerinit:Descriptor>>; 
       #)
  #)  

