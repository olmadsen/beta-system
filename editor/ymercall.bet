ORIGIN '~beta/mps/astlevel';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
-- lib: Attributes --
ymerCall:
  (#
     theBrowser: ^object;
     theBrowserId: @integer;
     refreshGroup:<
       (# cb: ^object; fg: ^astInterface.fragmentGroup
       enter (cb[],fg[])
       do INNER
       #);
     getFragmentGroup:<
       (# name: ^text; fg: ^astInterface.fragmentGroup
       enter name[]
       do INNER
       exit fg[]
       #);
     fragmentGroupList: list (# element:: text #);
     getCurrentProject:<
       (# name: ^text; fgList: ^fragmentGroupList
       do INNER
       exit (name[],fgList[])
       #);
     getCurrentGroupProject:<
       (# searchArea: @integer; name: ^text; fgList: ^fragmentGroupList
       enter searchArea
       do INNER
       exit (name[],fgList[])
       #);
     getCurrentProjectStatus:< (# name: ^text do INNER exit name[] #);
     getCurrentFragmentGroup:<
       (# fg: ^astInterface.fragmentGroup do INNER exit fg[] #);
     getCurrentFragmentForm:<
       (# ff: ^astinterface.fragmentform do INNER exit ff[] #);
     getCurrentNode:<
       (# node: ^astinterface.ast do INNER exit node[] #);
     findAndSelect:<
       (# node: ^astInterface.ast enter node[] do INNER #);
     selectFragmentForm:<
       (# ff: ^astInterface.fragmentForm enter ff[] do INNER #);
     selectFragmentGroup:< (# fgName: ^text enter fgName[] do INNER #);
     check:<
       (# fg: ^astInterface.fragmentGroup; status: @boolean
       enter fg[]
       do INNER
       exit status
       #);
     saveAsAndCheck:<
       (# fg: ^astInterface.fragmentGroup; status: @boolean
       enter fg[]
       do INNER
       exit status
       #);
     betaenvVersion:< (# t: ^text do INNER exit t[] #);
     machineType:< (# t: ^text do INNER exit t[] #);
     infoView:< (# t: ^text enter t[] do INNER #);
     infoViewClear:< object;
     infoViewDone:< object;
     onAboutToCloseGroup:<
       (#
          fg: ^astInterface.fragmentGroup;
          OKtoClose,askSave: @boolean
          (* if OKtoClose the groupEditor is closed.
           * if askSave the user is prompted whether to save the group
           * else it is just saved (if necessary)
           *)
       enter fg[]
       do true->OKtoClose->askSave; INNER
       exit (OKtoClose,askSave)
       #);
     onGroupSaved:<
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER #);
     onGroupTouched:<
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER #);
     onGroupDetouched:<
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER #);
     externalTextEdit:<
       (# textBefore,textAfter: ^text
       enter textBefore[]
       do INNER
       exit textAfter[]
       #);
     frejaInclude:< (# t: ^text do INNER exit t[] #);
     setFrejaMark:<
       (# frejamark: @boolean; FG: ^astInterface.fragmentGroup
       enter (frejamark,FG[])
       do INNER
       #);
     getFrejaMark:<
       (# frejamark: @boolean; FG: ^astInterface.fragmentGroup
       enter FG[]
       do INNER
       exit frejamark
       #);
     isEditor:< booleanValue;
     callSearch:< object;
     callReplace:< object;
     showSearchHits:<
       (#
          fg: ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          node: ^astInterface.ast;
          t: ^text;
          caseSensitive,wholeWord,showAllHits,onlyApplications: @boolean;
          searchArea: @integer;
          theNameDcl: ^astInterface.ast
       enter
       (fg[],ff[],node[],t[],caseSensitive,wholeWord,searchArea,showAllHits,
        onlyApplications,theNameDcl[])
       do INNER
       #);
     replaceAll:<
       (#
          fg: ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          node: ^astInterface.ast;
          t,newt: ^text;
          caseSensitive,wholeWord,replaceDeclaration,onlyApplications:
            @boolean;
          searchArea: @integer;
          theNameDcl: ^astInterface.ast
       enter
       (fg[],ff[],node[],t[],newt[],caseSensitive,wholeWord,replaceDeclaration,
        searchArea,onlyApplications,theNameDcl[])
       do INNER
       #);
     isActive:< (# value: @boolean enter value do INNER #);
     openSubeditor:<
       (# editorRoot,node: ^astInterface.ast
       enter (editorRoot[],node[])
       do INNER
       #);
     askShowDiagram:< booleanValue
       (# node: ^astInterface.ast enter node[] do INNER #);
     showDiagram:< (# node: ^astInterface.ast enter node[] do INNER #);
     askEditUserinterface:< booleanValue
       (# node: ^astInterface.ast enter node[] do INNER #);
     editUserinterface:<
       (# frag: ^astInterface.fragmentForm; node: ^astInterface.ast
       enter (frag[],node[])
       do INNER
       #);
     OKtoTextedit:< (* ask userinterfacebuilder *) booleanValue
       (# node: ^astInterface.ast enter node[] do INNER #);
     createImplementationFragment:<
       (# fg: ^astInterface.fragmentGroup enter fg[] do INNER #);
     selectImplementationFragment:<
       (# fg: ^astInterface.fragmentGroup enter fg[] do INNER #);
     quit:< object;
     allowDebug:< booleanValue
       (# fg: ^astInterface.fragmentGroup; name: ^text
       enter fg[]
       do INNER
       exit name[]
       #);
     doDebug:<
       (# fg: ^astInterface.fragmentGroup enter fg[] do INNER #);
     stopDebugging:< object;
     newCodeViewWindow:<
       (# action1: ^object; callback: ^object; 
       enter callback[]
       do INNER
       exit action1[]
       #);
     showSemanticErrors:<
       (# fg: ^astInterface.fragmentGroup enter fg[] do INNER #)
  #)  

