ORIGIN '../codeeditor';
INCLUDE 'editorenvbody';
-- externCommandBody: Descriptor --
(# help,status: ^text; 
do
   '#'->help[];
   id->help.putInt;
   help[]->command.prepend;
   (if edenv.trace[1] then
       'Sif ******** <<sending: '->screen.putText;
       command[]->screen.putText;
       '>>'->screen.putLine;
       
   if);
   command[]->edenv.frejaInterface.onInput;
   
#)  

-- onGroupExternCommandBody: Descriptor --
(#  do  #)  

-- onExternCommandBody: Descriptor --
(#
   op,argument: ^text;
   synCatNo: @integer;
   normalFeedback: @boolean;
   OK: @integer;
   intTrue,intFalse: @integer;
   anExp: ^astInterface.expanded;
   OKfeedback:
     (# help: ^text
     do ' '->status.put; OK->status.putInt; false->normalFeedback; 
     #);
   myParseText:
     (#
        textToParse,parseErrorText: ^text;
        parseOK: @boolean;
        myErrorPos: @integer
     enter textToParse[]
     do
        parsing:
          (#
             myerrorReporter: mps.errorReporter
               (#
                  beforeFirstError::<  (#  do  #);
                  afterLastError::<  (#  do  #);
                  forEachError::< 
                    (# 
                    do
                    (*'streamPos,startLineNo,errorLines,errorPos{Inx},legalSymbols[]'->screen.putLine;
                     streamPos->screen.putInt;' '->screen.put;*)
                       streamPos-1->myErrorPos;
                       'Parse error'->parseErrorText[];
                       parseErrorText.newLine;
                       parseErrorText.newLine;
                       'Expected symbol'->parseErrorText.putText;
                       (if legalSymbols.terminals.range
                        // 1 then ': '->parseErrorText.putLine; 
                        else
                           's: '->parseErrorText.putLine
                       if);
                       (for i: legalSymbols.terminals.range repeat
                         legalSymbols.terminals[i][]->parseErrorText.putText;
                         ' '->parseErrorText.put
                       for);
                       leave parsing;
                       
                    #);
                  
               #);
             
          do (*exitTextEditing; *)
             0->textToParse.setPos;
             &myErrorReporter[]->mps.theErrorReporter[];
             (cs,textToParse[])->parseText->(parseOK,cs);
             (if (* now cs is updated *) parseOk then
                 selectNewCS; 
              else
             (* parse error *)
                   (# 
                   do
                      textToParse.reset;
                      (textToParse[],none )->ag.parser.errorReport;
                      
                   #);
                 
             if)
          #)
     exit (parseOK,parseErrorText[],myErrorPos)
     #);
   listPaste:
     (#
        beforeAfter: @integer;
        theElement: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        t: ^text;
        synCatNo2,position: @integer;
        command2: ^text;
        fg: ^astInterface.fragmentGroup
     enter beforeAfter
     do
        true->cs.undoPermit;
        false->notifyFreja;
        cs.node.father->fatherNode[];
        cs.node.sonNo+1->position;
        beforeAfter->listInsert;
        paste;
        true->notifyFreja;
        'listElementInserted '->command2[];
        fatherNode.index->command2.putInt;
        ' '->command2.put;
        position->command2.putInt;
        ' '->command2.put;
        position->fatherNode.get->theElement[];
        theElement[]->getSynCatNo->synCatNo2->frag.grammar.symbolToName->t[];
        synCatNo2->command2.putInt;
        ' '->command2.put;
        t[]->command2.putText;
        frag.father->fg[];
        (fg[],true)->edenv.editorenvPrivate.extendedMarkAsChanged;
        command2[]->externCommand;
        
     #);
   listExpand:
     (#
        beforeAfter: @integer;
        theElement: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        t: ^text;
        synCatNo2,position: @integer;
        command2: ^text;
        fg: ^astInterface.fragmentGroup
     enter beforeAfter
     do
        true->cs.undoPermit;
        false->notifyFreja;
        cs.node.father->fatherNode[];
        cs.node.sonNo+1->position;
        beforeAfter->listInsert;
        command.getInt->synCatNo;
        (if synCatNo
         // 0 then
            intFalse->OK; 'no syntactic category'->screen.putLine; 
         // 1 then
            OKfeedback; true->cs.undoPermit; makeEmptyListOrOpt; 
         else
            (if (synCatNo > 0) then
                OKfeedback;
                true->cs.undoPermit;
                (if synCatNo
                 // betagram.staticItem // betagram.dynamicItem then
                 (* select the referenceSpecification which is the second son of the granfather of
                  nameDecl, and expand it *)
                    (betaGram.simpleDecl,true)->nodeExpand;
                    (if edenv.trace[1] then
                        'frag.root:'->putLine;
                        frag.root.dump;
                        screen.newLine;
                        'cs.node:'->putLine;
                        cs.node.dump;
                        screen.newLine
                    if);
                    ((cs.node.father).father).father->anExp[];
                    (anExp.getSon2,1,0,0)->setFocus;
                    (if edenv.trace[1] then
                        'cs.node:'->putLine; cs.node.dump; screen.newLine
                    if);
                    ;
                    (synCatNo,true)->&nodeExpand;
                    (if edenv.trace[1] then
                        'frag.root:'->putLine;
                        frag.root.dump;
                        screen.newLine;
                        'cs.node:'->putLine;
                        cs.node.dump;
                        screen.newLine
                    if);
                    
                 else
                    (synCatNo,true)->&nodeExpand;
                    (if edenv.trace[1] then
                        'frag.root:'->putLine;
                        frag.root.dump;
                        screen.newLine;
                        'cs.node:'->putLine;
                        cs.node.dump;
                        screen.newLine
                    if)
                if);
                true->notifyFreja;
                'listElementInserted '->command2[];
                fatherNode.index->command2.putInt;
                ' '->command2.put;
                position->command2.putInt;
                ' '->command2.put;
                position->fatherNode.get->theElement[];
                theElement[]->getSynCatNo->synCatNo2->frag.grammar.symbolToName
                  ->t[];
                synCatNo2->command2.putInt;
                ' '->command2.put;
                t[]->command2.putText;
                frag.father->fg[];
                (fg[],true)->edenv.editorenvPrivate.extendedMarkAsChanged;
                command2[]->externCommand;
                (if synCatNo
                 // betaGram.PatternDecl then
                 (* set the focus to attributeDeclOpt, 
                  * to automatically detail in freja 
                  *)
                    ((cs.node.father).father).father->anExp[];
                    (if edenv.trace[1] then
                        'anExp:'->putLine; anExp.dump; screen.newLine
                    if);
                    anExp.suffixWalk
                      (# 
                      do
                         (if (current[]->getSynCatNo) =
                         betaGram.AttributeDeclOpt then
                             (current[],1,0,0)->setFocus; 
                         if)
                      #);
                    
                 // betagram.virtualDecl // betagram.bindingDecl
                 // betagram.finalDecl then
                 (* set the focus to objectSpecification which is the 2. son*)
                    ((cs.node.father).father).father->anExp[];
                    (anExp.getSon2,1,0,0)->setFocus
                if)
             else
            (* lexem *)
                intFalse->OK
            if);
            
        if);
        
     #);
   
do
   1->intTrue;
   0->intFalse;
   (if edenv.trace[1] then 'Sif ******** <<op: '->screen.putText;  if);
   command.reset;
   command.getAtom->op[];
   (if edenv.trace[1] then op[]->screen.putText; '>>'->screen.putLine;  if);
   intTrue->OK;
   true->normalFeedback->notifyFreja;
   op[]->status[];
   (if true
    // ('save'->op.equal) then
       intFalse->OK; 'man maasta spare paa sekundaer minnen!'->screen.putLine; 
    // ('undo'->op.equal) then
       OKfeedback; undo; 
    // ('cut'->op.equal) then
       OKfeedback; true->cs.undoPermit; cut; 
    // ('copy'->op.equal) then
       OKfeedback; copy; 
    // ('paste'->op.equal) then
       OKfeedback; true->cs.undoPermit; paste; 
    // ('pasteBefore'->op.equal) then
       ins.before->listPaste; 
    // ('pasteAfter'->op.equal) then
       ins.after->listPaste; 
    // ('before'->op.equal) then
       OKfeedback; true->cs.undoPermit; ins.before->listInsert; 
    // ('after'->op.equal) then
       OKfeedback; true->cs.undoPermit; ins.after->listInsert; 
    // ('changeFocus'->op.equal) then
         (#
            index,length: @integer;
            node: ^astInterface.ast;
            oldNotifyFreja: @boolean;
            
         do
            command.getInt->index;
            command.getInt->length;
            index
              ->frag.indexToNode
                (#
                   indexOutOfRange::< 
                     (#  do 'indexOutOfRange'->putLine; true->continue;  #);
                   noSuchSymbol::< 
                     (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                   grammarGenRefArrayError::< 
                     (# 
                     do 'grammarGenRefArrayError'->putLine; true->continue; 
                     #)
                #)->node[];
            (if node[]
             // none then
                intFalse->OK;
                'Sif changedFocus: error index not found'->screen.putLine;
                
             else
                false->normalFeedback;
                frejaEditTypeStatus.clear;
                frejaEditStatus.clear;
                frejaExpandStatus.clear;
                true->frejaStatusOn;
                notifyFreja->oldNotifyFreja;
                false->notifyFreja;
                'false->notifyfreja setFocus'->putLine;
                (node[],length,0,0)->setFocus;
                oldNotifyFreja->notifyFreja;
                ' '->status.put;
                intTrue->status.putInt;
                frejaEditTypeStatus[]->status.putText;
                frejaEditStatus[]->status.putText;
                frejaExpandStatus[]->status.putText;
                
            if);
            
         #);
       
    // ('getStatus'->op.equal) then
         (# oldNotifyFreja: @boolean
         do
            false->normalFeedback;
            ' '->status.put;
            intTrue->status.putInt;
            ' '->status.put;
            CS.node.index->status.putInt;
            ' '->status.put;
            CS.length->status.putInt;
            ' '->status.put;
            frejaEditTypeStatus.clear;
            frejaEditStatus.clear;
            frejaExpandStatus.clear;
            true->frejaStatusOn;
            notifyFreja->oldNotifyFreja;
            false->notifyFreja;
            updateExpandMenu;
            updateEditMenu;
            oldNotifyFreja->notifyFreja;
            frejaEditTypeStatus[]->status.putText;
            frejaEditStatus[]->status.putText;
            frejaExpandStatus[]->status.putText;
            
         #);
       
    // ('expandNormal'->op.equal) then
       command.getInt->synCatNo;
       OKfeedback;
       true->cs.undoPermit;
       (synCatNo,true)->&nodeExpand;
       
    // ('expandOptional'->op.equal) then
       command.getInt->synCatNo;
       (if synCatNo
        // 0 then
           intFalse->OK; 'no syntactic category'->screen.putLine; 
        // 1 then
           OKfeedback; true->cs.undoPermit; &makeEmptyListOrOpt; 
        else
           (if (synCatNo > 0) then
               OKfeedback; true->cs.undoPermit; (synCatNo,true)->&nodeExpand; 
            else
           (* lexem *)
               intFalse->OK
           if);
           
       if);
       
    // ('expandLexem'->op.equal) then
       command.getAtom->argument[];
       OKfeedback;
       true->cs.undoPermit;
       argument[]->expandLexem;
       
    // ('expandAfter'->op.equal) then
       ins.after->listExpand
    // ('insertOptionals'->op.equal) then
       cs.node[]->insertOptionals; OKfeedback; 
    // ('removeOptionals'->op.equal) then
       cs.node[]->removeOptionals; OKfeedback; 
    // ('startLink'->op.equal) then
       'startLink'->putLine
    // ('endLink'->op.equal) then
       'endLink'->putLine
    // ('getAnchors'->op.equal) then
       (#  #)
    // ('followLink'->op.equal) then
       'followLink'->putLine
    // ('check'->op.equal) then
       'check->OK'->putLine; OKfeedback; 
    // ('parse'->op.equal) then
         (#
            index,errorpos: @integer;
            theParseText,parseErrorText,help: ^text;
            node: ^astInterface.ast;
            oldNotifyFreja: @boolean;
            
         do
            command.getInt->index;
            (command.pos+1,command.length)->command.sub->help[];
            ''->theParseText[];
            help.scanAll
              (# 
              do
                 (if (ch > ' ') and (ch <= '~') then
                     (if edenv.trace[1] then
                         'ch<'->screen.puttext;
                         ch->screen.putInt;
                         ':'->screen.put;
                         ch->screen.put;
                         '>'->screen.putLine;
                         
                     if);
                     ch->theParseText.put;
                     
                  else
                     ;
                     (if (ch = ascii.sp) then
                         (if edenv.trace[1] then
                             'sp<'->screen.puttext;
                             ch->screen.putInt;
                             ':'->screen.put;
                             ch->screen.put;
                             '>'->screen.putLine;
                             
                         if);
                         ch->theParseText.put;
                         
                     if);
                     (if (ch = ascii.newLine) then
                         (if edenv.trace[1] then
                             'nl.<'->screen.putText;
                             ch->screen.putInt;
                             ':'->screen.put;
                             ch->screen.put;
                             '>'->screen.putLine;
                             
                         if);
                         ch->theParseText.put;
                         
                     if)
                 if)
              #);
            (if edenv.trace[1] then
                index->screen.putInt;
                '  ['->screen.putText;
                theparseText[]->screen.putText;
                '] '->screen.putLine
            if);
            index
              ->frag.indexToNode
                (#
                   indexOutOfRange::< 
                     (#  do 'indexOutOfRange'->putLine; true->continue;  #);
                   noSuchSymbol::< 
                     (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                   grammarGenRefArrayError::< 
                     (# 
                     do 'grammarGenRefArrayError'->putLine; true->continue; 
                     #)
                #)->node[];
            (if node[]
             // none then
                intFalse->OK;
                'Sif Parse: error index not found'->screen.putLine;
                
             else
                false->normalFeedback;
                (node[],1,0,0)->setFocus;
                (if theParseText.lgth = 0 then
                    true->cs.undoPermit; cut; intTrue->OK
                 else
                    theParseText[]->myParseText->(OK,parseErrorText[],errorPos)
                if);
                ' '->status.put;
                OK->status.putInt;
                (if OK = intFalse then
                    ' '->status.put;
                    errorPos->status.putInt;
                    ' '->status.put;
                    parseErrorText[]->status.putText;
                    (if edenv.trace[1] then
                        'Parse error!!!'->screen.putLine;
                        errorPos->screen.putInt;
                        '  <'->screen.putText;
                        parseErrorText[]->screen.putText;
                        '> '->screen.putLine
                    if)
                 else
                    true->cs.undoPermit
                if);
                
            if);
            
         #)
    // ('parseAfter'->op.equal) then
         (#
            node,theElement: ^astInterface.ast;
            fatherNode: ^astInterface.expanded;
            t: ^text;
            synCatNo,index,errorPos,synCatNo2,position: @integer;
            theParseText,parseErrorText,command2: ^text;
            fg: ^astInterface.fragmentGroup
         do
            true->cs.undoPermit;
            command.getInt->index;
            command.getInt->synCatNo;
            (command.pos+1,command.length)->command.sub->theParseText[];
            (if edenv.trace[1] then
                index->screen.putInt;
                ' '->screen.put;
                synCatNo->screen.putInt;
                '  ['->screen.putText;
                theparseText[]->screen.putText;
                '] '->screen.putLine
            if);
            index
              ->frag.indexToNode
                (#
                   indexOutOfRange::< 
                     (#  do 'indexOutOfRange'->putLine; true->continue;  #);
                   noSuchSymbol::< 
                     (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                   grammarGenRefArrayError::< 
                     (# 
                     do 'grammarGenRefArrayError'->putLine; true->continue; 
                     #)
                #)->node[];
            (if node[]
             // none then
                intFalse->OK;
                'Sif Parse: error index not found'->screen.putLine;
                
             else
                false->notifyFreja;
                node.father->fatherNode[];
                node.sonNo+1->position;
                (node[],1,0,0)->setFocus;
                ins.after->listInsert;
                (if theParseText.lgth = 0 then
                    true->cs.undoPermit;
                    cut;
                    intTrue->OK;
                    'Why call parseAfter with an empty text?!'->screen.putLine;
                    
                 else
                    theParseText[]->myParseText->(OK,parseErrorText[],errorPos)
                if);
                true->notifyFreja;
                'listElementInserted '->command2[];
                fatherNode.index->command2.putInt;
                ' '->command2.put;
                position->command2.putInt;
                ' '->command2.put;
                position->fatherNode.get->theElement[];
                theElement[]->getSynCatNo->synCatNo2->frag.grammar.symbolToName
                  ->t[];
                synCatNo2->command2.putInt;
                ' '->command2.put;
                t[]->command2.putText;
                frag.father->fg[];
                (fg[],true)->edenv.editorenvPrivate.extendedMarkAsChanged;
                command2[]->externCommand;
                false->normalFeedback;
                ' '->status.put;
                OK->status.putInt;
                ' '->status.put;
                theElement.index->status.putInt;
                ' '->status.put;
                
            if)
         #)
    // ('prettyprint'->op.equal) then
         (# index: @integer; node: ^astInterface.ast; pptext: @text; 
         do
            command.getInt->index;
            index
              ->frag.indexToNode
                (#
                   indexOutOfRange::< 
                     (#  do 'indexOutOfRange'->putLine; true->continue;  #);
                   noSuchSymbol::< 
                     (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                   grammarGenRefArrayError::< 
                     (# 
                     do 'grammarGenRefArrayError'->putLine; true->continue; 
                     #)
                #)->node[];
            (if node[]
             // none then
                intFalse->OK;
                'Sif Prettyprint: error index not found'->screen.putLine;
                
             else
                OKfeedback;
                ' '->status.put;
                intTrue->status.putInt;
                (mps[],frag[],node[],ppText[],none (*streamName[]*) ,80,0,false
                 (*abstractPresentation*) ,false (*showSemanticErrors*) ,false
                 (*includeComments*) ,false,false,false,false,'',false
                 (*onlyProperties*) ,false
                 (*
                  test*) )->ppFragment;
                ppText[]->status.putText;
                (if edenv.trace[1] then
                    'Prettyprint of node: '->screen.putText;
                    index->screen.putInt;
                    screen.newLine;
                    ppText[]->screen.putLine
                if);
                
            if);
            
         #);
       
    else
       intFalse->OK; 'Unknown command: '->screen.putText; op[]->screen.putLine; 
   if);
   (if normalFeedback then ' '->status.put; OK->status.putInt;  if);
   
#)  

-- frejaCommNewFragment: Descriptor --
(# 
do
   (if notifyFreja then
       (frag[],editorRoot[])->edenv.frejaInterface.newFragment
   if);
   
#)  

-- frejaCommAstReplaced: Descriptor --
(# (* oldAst,newAst: ^astInterface.ast;
    * enter (oldAst[],newAst[])
    *) command: ^text
do
   (if notifyFreja then
       (if oldAst[]->visibleInFreja then
           (oldAst[],newAst[])->edenv.frejaInterface.astReplaced
       if)
   if);
   
#)  

-- frejaCommAstReplacedSequence: Descriptor --
(# 
do
   (if notifyFreja then
       (if astReplacedList.size > 0 then
           astReplacedList.scan
             (# 
             do
                (if current.oldAst[]->visibleInFreja then
                    (current.oldAst[],current.newAst[])
                      ->edenv.frejaInterface.astReplaced
                if)
             #)
        else
           'no events in astReplacedList'->screen.putLine
       if)
   if);
   astReplacedList.clear
#)  

-- frejaCommListElementInserted: Descriptor --
(# 
do
   (if notifyFreja then
       (if position->listNode.get->visibleInFreja then
           (listNode[],position)->edenv.frejaInterface.listElementInserted
       if)
   if)
#)  

-- frejaCommListElementsDeleted: Descriptor --
(#
(* oldElements: ^partList;
 * listNode: ^astInterface.expanded;
 * position,length: @integer
 * enter (listNode[],position,length,oldElements[])
 *) command: ^text
do
   (if notifyFreja then
       (if oldElements.elm[length][]->visibleInFreja then
           (listNode[],position,length,oldElements.elm)
             ->edenv.frejaInterface.listElementsDeleted
       if)
   if);
   
#)  

-- frejaCommListElementsReplaced: Descriptor --
(# 
do
   (if notifyFreja then
       (if (length = 0) and (newLength = 1) then
           'converting listElementsReplacedEvent to listElemenInsertedEvent'
             ->screen.putline;
           (listNode[],position)->edenv.frejaInterface.listElementInserted
        else
           (if oldElements.elm[length][]->visibleInFreja then
               (listNode[],position,length,oldElements.elm,newLength)
                 ->edenv.frejaInterface.listElementsReplaced
           if)
       if)
   if)
#)  

-- frejaCommFocusChanged: Descriptor --
(# 
do
   (if notifyFreja then
       (if edenv.trace[1] then
           '*********************************************************************'
             ->screen.putLine;
           'Show Freja selection: '->putText;
           newCS.node.index->putInt;
           newline;
           
       if);
       (newCS.node[],newCS.length)->edenv.frejaInterface.focusChanged
   if)
#)  

-- visibleInFreja: Descriptor --
(# synCatNo: @integer; (*bg: ^astInterface.beta*) 
do (* betagrammar[]->bg[];*)
   true->value;
   loop:
     (# 
     do
        node[]->getSyncatNo->syncatNo;
        (if synCatNo
         // betaGram.imperatives // betaGram.enterPart // betaGram.enterPartOpt
         // betaGram.exitPart // betaGram.exitPartOpt // betaGram.doPart
         // betaGram.doPartOpt then
            false->value; 
         else
            (if node.father = none then
            (* imperatives, enterpart or exitpart was not found *)
                
             else
                node.father->node[]; restart loop
            if)
        if)
     #)
#)  

