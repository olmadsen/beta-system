ORIGIN '../ymersiflib';
INCLUDE '~beta/compiler/compiler'
        '~beta/compiler/GENERATOR/runJobFile'
'~beta/process/processmanager';
BODY  '~beta/compiler/GENERATOR/oldbackend';
MDBODY hpux9pa 'compiler_unixbody'
       sun4s 'compiler_unixbody'
       linux 'compiler_unixbody'
       x86sol'compiler_unixbody'
       sgi 'compiler_sgibody'
       nti 'compiler_ntibody'
       mac 'compiler_macbody'
       ppc 'compiler_macbody'
       ppcmac 'compiler_macbody';
LIB_DEF 'sif_compiler' '../../lib';
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1995-2000
 *	 All rights reserved.
 *)
-- sifCompilerVersion: Descriptor --
(# 
do
   'notfound'->version[];
   (* ymerBrowser.compilerPrivate.comp.compilerVersion->version[]; *)
   
#)  

-- compilerPrivate: Descriptor --
(#
   comp: ^mps.ast.compiler;
   sifInfoStream: @stream
     (#
        infoLine: @text;
        put:: 
          (# 
          do
             ch->screen.put;
             (if false (* to test speed *) then
                 ch->infoLine.put;
                 (if ch = ascii.newLine then
                     infoLine.clear
                  else
                     infoLine.copy->writeInfoView
                 if)
             if)
          #);
        putText:: 
          (# 
          do
             txt[]->screen.putText;
             (if false (* to test speed *) then
                 txt[]->infoLine.putText; infoLine.copy->writeInfoView
             if);
             
          #);
        putLine:
          (# t: ^text
          enter t[]
          do
             t[]->screen.putLine;
             (if false (* to test speed *) then
                 t[]->infoLine.putText;
                 infoLine.copy->writeInfoView;
                 infoLine.clear
             if)
          #);
        newLine:
          (# 
          do
             screen.newLine;
             (if false (* to test speed *) then infoLine.clear if)
          #);
        init: (#  do infoLine.clear #)
     #);
   jobfileProcess: ^theSystemenv.process;
   activateCompiler:
     (# fragmentFile: ^text; generateCode,generateDebugInfo,OK: @boolean
     enter (fragmentFile[],generateCode,generateDebugInfo)
     do <<SLOT activateCompilerBody:Descriptor>>
     exit OK
     #)
#)  

-- setCompilerOptions: Descriptor --
(#  do compilerprivate.comp[]->compiler[];  #)  

-- activateCompilerBody: Descriptor --
(#
   help: ^text;
   f,g: @file;
   parseErrors,someError: @boolean;
   fileWithParseErrors: @text;
   jobFilePermission:
     (# fgname: ^text; 
     enter fgname[]
     <<SLOT compilerJobFilePermission:DoPart>>
     #);
   jobFileDelete:
     (# fgname: ^text; 
     enter fgname[]
     <<SLOT compilerJobFileDelete:DoPart>>
     #);
   StartGiveTime: External (#  #);
   StopGiveTime: External (#  #);
   
do
   StartGiveTime;
   fragmentFile[]->jobFileDelete;
   <<SLOT machineDependentSwitches:Descriptor>>;
   (if not generatecode then
       (true,33)
         ->
         (* prevent activation of code generator*)
           compilerPrivate.comp.setswitch;
       (true,5)
         -> (*prevent execution of job file*) compilerPrivate.comp.setswitch
    else
       (false,33)
         -> (*prevent activation of code generator*)
           compilerPrivate.comp.setswitch;
       (false,5)
         -> (*prevent execution of job file*) compilerPrivate.comp.setswitch
   if);
   (generateDebugInfo,41)->compilerPrivate.comp.setswitch;
   (generateDebugInfo,55)->compilerPrivate.comp.setswitch;
   (true,19)->compilerPrivate.comp.setswitch;
   (true,90)->compilerPrivate.comp.setswitch;
   (true,32)->compilerPrivate.comp.setswitch;
   setcompilerOptions;
   compilerprivate.sifInfoStream.init;
   L:
   fragmentFile[]
     ->compilerPrivate.comp.translate
       (#
          Report:
            (# msg: ^text
            enter msg[]
            do (* msg[]->compilerPrivate.comp.messagestream.putline;*)
               (none ,msg[],'Compiler message')->gui.alertUser;
               true->someError;
               leave L
            #);
          jobFileRunner:: 
            (# 
            do
               (AFF[],common[],infoStream[],messageStream[],hostMachineType[],
                targetmachine[],jobfilemachine[],interactiveCompiler)
                 ->theSystemEnv.runJobFile
                   (# error::  (#  do msg[]->jobFileException #)
                   #)->jobFileProcess[]
            #);
          groupSavedNotification::< 
            (# ge: ^edEnv.groupEditor; currentName: ^text
            do
            (* obsolete  (browser[],fg[])
             ->edenv.groupEditorList.findGroupEditor->ge[];
             (if ge[] <> none then
             fg[]->ge.compilerSavedGroup;
             fg[]->savedGroups.insert;
             'ge.checkAutoSave in compiler-activateCompilerBody'->putLine;
             fg.notifyGroupSaved
             if) *) 
            #);
          semanticErrorsNotification::< 
            (#  do ff[]->formsWithSemanticErrors.append #);
          MsgException::< 
            (# semErrors: @boolean; keepMsg: ^text
            do
               msg.copy->keepMsg[];
               msg.clear;
               (if no
                // 1 then (* eliminate*)
                   'System error!!!'->msg.putline
                // 2 then
                   'The fragment group is empty!'->msg.putLine; 
                // 11 then
                   'Error(s) in fragment structure'->msg.putline; 
                // 12 then
                   'The fragment group is reached twice during dependency analysis'
                     ->msg.putline;
                   'Circularity in fragment structure (origin and/or include)'
                     ->msg.putLine;
                   
                // 14 then
                (*'Stopped because of semantic errors'->msg.putLine; *)
                   true->semErrors->someError
                // 16 then
                   'Stopped because of file access problem'->msg.putline
                else
                   'Should not happen(msg):'->msg.putline;
                   no->msg.putInt;
                   msg.newline
               if);
               (if not semErrors then
                   (if fg[] <> none then
                       fg[]->findGroup; msg[]->Report
                    else
                       newLine;
                       'msgException: '->putText;
                       no->putInt;
                       ': '->putLine;
                       keepMsg[]->putLine;
                       keepMsg[]->report
                   if)
                else
                   leave L
               if)
            #);
          TransAccessException::<  (#  do msg[]->Report #);
          TransCreateDirException::<  (#  do msg[]->Report #);
          NoSpaceException::<  (#  do msg[]->Report #);
          MPSException::<  (#  do msg[]->Report #);
          notExistingException::<  (#  do msg[]->Report #);
          parseException::< 
            (# 
            do (*msg[]->Report*)
               true->parseErrors->someError;
               fullFN->fileWithParseErrors;
               leave L
            #);
          jobFileException::<  (#  do msg[]->Report #);
          rereadFragment:: 
            (#  do fullFN[]->putText; ' has been reread!'->putLine #);
          checkedFragment::  (#  do  #);
          closedFragment:: 
            (# 
            do
            (* scanningGroupEditorList: edenv.groupEditorList.scan
             (# 
             do
             newLine;
             current.fg.name->putLine;
             fullFN[]->putLine;
             (if current.fg.name->fullFN.equal then
             false->proceed;
             'do not close'->putLine;
             leave scanningGroupEditorList
             if)
             #)*)
            (*fullFN[]->putText; ' TryToGC not allowed by Sif!'->putLine*) 
            #);
          doubleFormException::<  (#  do msg[]->Report #);
          fragmentException::
          (* Note that the group is closed here.
           * Sif and other tools may NOT want to do this!
           *) 
            (# keepMsg: ^text
            do (*CloseGroup;*)
               msg.copy->keepMsg[];
               msg.clear;
               (if errNo
                // 1 then
                   'Two or more slots have the name: '->msg.puttext;
                   slot.name->msg.puttext;
                   
                // 2 then
                   'No free slot found for: '->msg.Puttext;
                   FF.name->msg.puttext;
                   
                // 3 then
                   'Category of fragment: '->msg.puttext;
                   FF.name->msg.puttext;
                   ' does not correspond to category of slot'->msg.puttext;
                   
                // 4 then
                   'The slot: '->msg.Puttext;
                   FF.name->msg.puttext;
                   ' Is already bound'->msg.Puttext
                // 5 then
                   'Category of: '->msg.Puttext;
                   FF.name->msg.Puttext;
                   ' must be either: '->msg.Putline;
                   'Descriptor (ObjectDescriptor, DescriptorForm) or '
                     ->msg.puttext;
                   'Attributes (AttributeDecl, AttributesForm)'->msg.putline;
                   
                // 6 then
                   'Category of the following slot is not supported!\n\n\t'
                     ->msg.putText;
                   slot.name->msg.putLine;
                   '\nCategory must be: descriptor, attributes or doPart'
                     ->msg.putLine
                // 7 then
                   'Warning: mainPart-slots are NOT fully supported!'
                     ->msg.putLine
               if);
               'Error in fragment structure'->writeInfoView;
               '*** Error in fragment structure'->putLine;
               (if slot[] <> none then
                   slot.father->findAndSelect; msg[]->Report
                else
                   (if ff[] <> none then
                       ff[]->findForm; msg[]->Report
                    else
                       (if fg[] <> none then
                           fg[]->findGroup; msg[]->Report
                        else
                           'fragmentException: '->putText;
                           errNo->putInt;
                           ': '->putLine;
                           keepMsg[]->putLine;
                           keepMsg[]->report
                       if)
                   if)
               if)
            #);
          propertyException:: 
            (# keepMsg: ^text
            do
               msg.copy->keepMsg[];
               msg.clear;
               true->continue;
               (if n
                // 1 then
                   'Two or more origins are specified:\n\t'->msg.puttext;
                     (# g: ^astInterface.fragment; 
                     do FG.origin->g[]; g.name->msg.puttext; 
                     #);
                   '\n\t'->msg.puttext;
                   t[]->msg.putline
                // 2 then
                   'The reserved property name "'->msg.puttext;
                   t.makeUC;
                   t[]->msg.puttext;
                   '"\n\tappears in the property list for '->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   
                // 3 then
                   'Illegal "'->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   '" property: "'->msg.puttext;
                   t.makeUC;
                   t[]->msg.puttext;
                   '"\n'->msg.puttext
                // 4 then
                   'Empty filename in property "'->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   '"'->msg.put;
                   msg.newline;
                   
                // 5 then
                   'Unrecognised property: '->Msg.Puttext;
                   p[]->Msg.Putline;
                   true->warning;
                   true->continue
                // 6 then
                (*'Property "'->msg.puttext;
                 p[]->msg.puttext;
                 '" has no value for "'->msg.putText;
                 t[]->msg.putText;
                 '"\n'->msg.putLine;*)
                   true->warning
               if);
               (if not warning then
                   '\n\n\tA ";" may be missing before '->msg.puttext;
                   t[]->msg.putline;
                   'Property error'->writeInfoView;
                   '*** Property error'->putLine;
                   (if fg[] <> none then
                       fg[]->findGroup;
                       'in '->msg.append;
                       fg.name->msg.append;
                       msg[]->putLine;
                       msg[]->Report
                    else
                       'propertyException: '->putText;
                       n->putInt;
                       ': '->putLine;
                       keepMsg[]->putLine;
                       keepMsg[]->report
                   if)
                else
                   keepMsg[]->putLine
               if)
            #);
          SystemException::  (#  do msg[]->Report #)
       do 
       #);
   StopGiveTime;
   (if parseErrors then
       false->parseErrors;
       'Parse Error(s)'->writeInfoview;
       fileWithParseErrors[]->openParseEditor
   if);
   (if not someError then
       (if not generatecode then 'Checking finished'->writeInfoView if);
       fragmentFile[]->jobFilePermission
   if);
   not someError->OK;
   
#)  

-- initCompilerBody: Descriptor --
(#
(* Here it is possibleto initialize the compiler/checker 
 * to use specific instances
 * of ASTinterface and OSinterface. 
 * If comp.AST[]/ensemble[] are none, then
 * comp.init will generate new instances of ASTinterface and OSinterface.
 * 
 * myASTinterface[] -> comp.AST[]
 * myOsinterface[]-> comp.ensemble[]
 *) 
do
   (if compiler[] <> none then
       compiler[]->compilerPrivate.comp[]; 
    else
       &mps.ast.compiler[]->compilerPrivate.comp[]; 
   if);
   (* mps.ast[]->compilerPrivate.comp.AST[]; *)
   (true,401) -> compilerPrivate.comp.setSwitch;
   (true,403) -> compilerPrivate.comp.setSwitch;
   compilerPrivate.sifInfoStream.init;
   compilerPrivate.sifInfoStream[]->compilerPrivate.comp.infostream[];
   screen[]->compilerPrivate.comp.tracestream[];
   screen[]->compilerPrivate.comp.messagestream[];
   screen[]->compilerPrivate.comp.bugstream[];
   compilerPrivate.comp.verboseLevel.actions->compilerPrivate.comp.verboseLevel;
   compilerPrivate.comp.init;
   compilerPrivate.comp.compilerVersion->version[];
   <<SLOT MDinitCompiler:Descriptor>>
#)  

-- compilerCheck: Descriptor --
(# changedOutSide,otherError: @boolean
do
   'Calling checker...'->writeInfoView;
   thisOp: doCommand
     (# 
     do
        fg[]->DGchangedOutSide->(changedOutSide,otherError);
        (if not changedOutSide and not otherError then
            callCompiler
              (# 
              do
                 'Checking...'->writeInfoView;
                 (fg.name,false,false)->compilerPrivate.activateCompiler->status
              #);
            not status->fg.notifyGroupChecked
        if)
     #)
#)  

-- compilerCompile: Descriptor --
(# changedOutSide,otherError: @boolean
do
   (if editorprefs.PopupLogWindow then ymer.showlogwindowPushState if);
   'Calling compiler...'->writeInfoView;
   thisOp: doCommand
     (# 
     do
        fg[]->DGchangedOutSide->(changedOutSide,otherError);
        (if not changedOutSide and not otherError then
            callCompiler
              (# 
              do
                 'Compiling...'->writeInfoView;
                 ((fg.name).copy,true,true)->compilerPrivate.activateCompiler
                   ->status
              #);
            (*(fg[],status)->onGroupCompiled;*)
            not status->fg.notifyGroupChecked
        if)
     #);
   (if editorprefs.PopupLogWindow then ymer.logwindowPopState if)
#)  

-- compilerJobFileRunning: DoPart --
do
   (if compilerPrivate.jobFileProcess[] <> none then
       compilerPrivate.jobFileProcess.stillRunning->value
   if)  

-- compilerWaitOnJobfile: DoPart --
do
   (if compilerPrivate.jobFileProcess[] <> none then
       compilerPrivate.jobFileProcess.awaitStopped; '!'->putLine
   if)  

