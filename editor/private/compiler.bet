ORIGIN '../ymersiflib';
(*if only the checker: BODY '../mycompiler/dummysynthesizer';*)
BODY '../../system/v5.1/synthesizer';
MDBODY hpux8 '~beta/editor/system/v5.1/HPasmlink'
       hpux8 '~beta/editor/system/v5.1/HPasmlink'
       hpux9pa '~beta/editor/system/v5.1/SNAKEasmlink'
       snake '~beta/editor/system/v5.1/SNAKEasmlink'
       sun4 '~beta/editor/system/v5.1/SUN4asmlink'
       sun4s '~beta/editor/system/v5.1/SUN4SBasmlink'
       linux '~beta/editor/system/v5.1/LINUXasmlink'
       mac '~beta/editor/system/v5.1/MACasmlink'
       hpux8 '~beta/editor/system/v5.1/HPmachine'
       hpux9pa '~beta/editor/system/v5.1/SNAKEmachine'
       snake '~beta/editor/system/v5.1/SNAKEmachine'
       sun4 '~beta/editor/system/v5.1/SUN4machine'
       sun4s '~beta/editor/system/v5.1/SUN4Bmachine'
       linux '~beta/editor/system/v5.1/LINUXmachine'
       mac '~beta/editor/system/v5.1/MACmachine'
       hpux8 '~beta/editor/system/v5.1/MC68machine';
INCLUDE '~beta/editor/system/v5.1/system';
(*
 COPYRIGHT
 Copyright Mjolner Informatics, 1986-94
 All rights reserved.
 *)
-- compilerPrivate: Descriptor --
(#
   comp: @compiler
     (#
        groupSaved::< 
          (# ge: ^edenv.groupEditor; currentName: ^text
          do
             fg[]->edenv.groupEditorList.findGroupEditor->ge[];
             (if ge[] <> none then
                 fg[]->ge.compilerSavedGroup; fg[]->savedGroups.insert
             if)
          #);
        semanticErrors::<  (#  do ff[]->formsWithSemanticErrors.append #);
        sifInfoStream: @stream
          (#
             infoLine: @text;
             put:: 
               (# 
               do (* '[put:'->screen.putText;*)
                  ch->screen.put;
                  (* ']'->screen.putLine; *)
                  ch->infoLine.put;
                  (if ch = ascii.newLine then
                      infoLine.clear
                   else
                      infoLine.copy->writeInfoView
                  if)
               #);
             putText:: 
               (# 
               do (*  '[putText:'->screen.putText;*)
                  t[]->screen.putText;
                  (*']'->screen.putLine;*)
                  t[]->infoLine.putText;
                  infoLine.copy->writeInfoView;
                  true->doneInInner
               #);
             putLine:
               (# t: ^text
               enter t[]
               do (*'[putLine:'->screen.putText;*)
                  t[]->screen.putLine;
                  (* ']'->screen.putLine;*)
                  t[]->infoLine.putText;
                  infoLine.copy->writeInfoView;
                  infoLine.clear
               #);
             newLine:
               (# 
               do (*'[newLine]'->screen.putLine;*)
                  screen.newLine; infoLine.clear
               #);
             init: (#  do infoLine.clear #)
          #);
        
     #);
   
#)  

-- activateCompilerBody: Descriptor --
(#
   help: ^text;
   f: @file;
   parseErrors,someError: @boolean;
   fileWithParseErrors: @text;
   
do
   (if true
    // false then 'activateCompiler: '->putText; fragmentFile[]->putLine; 
   if);
   (if not generatecode then
       true->compilerPrivate.comp.switch[5];
       (* prevent activation of code generator*)
       true->compilerPrivate.comp.switch[33];
       (*prevent execution of job file*)
       
    else
       false->compilerPrivate.comp.switch[5];
       (*prevent activation of code generator*)
       false->compilerPrivate.comp.switch[33];
       (*prevent execution of job file*)
       
   if);
   (generateDebugInfo,41)->compilerPrivate.comp.setswitch;
   (generateDebugInfo,55)->compilerPrivate.comp.setswitch;
   (*do not print qua-check warnings*)
   true->compilerPrivate.comp.switch[19];
   (* do not print 
    * In  "X: ^R.P" or "Y: @R.P", "R" should NOT be a dynamic reference 
    * warnings
    *)
   true->compilerPrivate.comp.switch[90];
   (*true->compilerPrivate.comp.switch[18];*)
   (*do not make lst file*)
   true->compilerPrivate.comp.switch[32];
   'No qua-check warnings and .lst file'->screen.putLine;
   compilerprivate.comp.sifInfoStream.init;
   L:
   fragmentFile[]
     ->compilerPrivate.comp.translate
       (#
          Report:
            (# msg: ^text
            enter msg[]
            do (* msg[]->compilerPrivate.comp.messagestream.putline;*)
               (none ,msg[],'Compiler message')->alertUser;
               true->someError;
               leave L
            #);
          MsgException::< 
            (# semErrors: @boolean; keepMsg: ^text
            do
               msg.copy->keepMsg[];
               msg.clear;
               (if no
                // 1 then (* eliminate*)
                   'System error!!!'->msg.putline
                // 2 then
                   'The fragment group is empty!'->msg.putLine; 
                // 11 then
                   'Error(s) in fragment structure'->msg.putline; 
                // 12 then
                   'The fragment group is reached twice during dependency analysis'
                     ->msg.putline;
                   'Circularity in fragment structure (origin and/or include)'
                     ->msg.putLine;
                   
                // 14 then
                (*'Stopped because of semantic errors'->msg.putLine; *)
                   true->semErrors->someError
                // 16 then
                   'Stopped because of file access problem'->msg.putline
                else
                   'Should not happen(msg):'->msg.putline;
                   no->msg.putInt;
                   msg.newline
               if);
               (if not semErrors then
                   (if fg[] <> none then
                       fg[]->findGroup; msg[]->Report
                    else
                       newLine;
                       'msgException: '->putText;
                       no->putInt;
                       ': '->putLine;
                       keepMsg[]->putLine;
                       keepMsg[]->report
                   if)
                else
                   leave L
               if)
            #);
          TransAccessException::<  (#  do msg[]->Report #);
          TransCreateDirException::<  (#  do msg[]->Report #);
          NoSpaceException::<  (#  do msg[]->Report #);
          MPSException::<  (#  do msg[]->Report #);
          notExistingException::<  (#  do msg[]->Report #);
          parseException::< 
            (# 
            do (*msg[]->Report*)
               true->parseErrors->someError;
               fullFN->fileWithParseErrors;
               leave L
            #);
          betaRunException::<  (#  do msg[]->Report #);
          RshException::<  (#  do msg[]->Report #);
          jobFileException::<  (#  do msg[]->Report #);
          multipleMachException::<  (#  do msg[]->Report #);
          unknownMachException::<  (#  do msg[]->Report #);
          rereadFragment:: 
            (#  do fullFN[]->putText; ' has been reread!'->putLine #);
          checkedFragment::  (#  do  #);
          closedFragment:: 
            (# 
            do
               false->proceed;
               (*fullFN[]->putText; ' TryToGC not allowed by Sif!'->putLine*)
               
            #);
          doubleFormException::<  (#  do msg[]->Report #);
          fragmentException::
          (* Note that the group is closed here.
           * Sif and other tools may NOT want to do this!
           *) 
            (# keepMsg: ^text
            do (*CloseGroup;*)
               msg.copy->keepMsg[];
               msg.clear;
               (if errNo
                // 1 then
                   'Two or more slots have the name: '->msg.puttext;
                   slot.name->msg.puttext;
                   
                // 2 then
                   'No free slot found for: '->msg.Puttext;
                   FF.name->msg.puttext;
                   
                // 3 then
                   'Category of fragment: '->msg.puttext;
                   FF.name->msg.puttext;
                   ' does not correspond to category of slot'->msg.puttext;
                   
                // 4 then
                   'The slot: '->msg.Puttext;
                   FF.name->msg.puttext;
                   ' Is already bound'->msg.Puttext
                // 5 then
                   'Category of: '->msg.Puttext;
                   FF.name->msg.Puttext;
                   ' must be either: '->msg.Putline;
                   'Descriptor (ObjectDescriptor, DescriptorForm) or '
                     ->msg.puttext;
                   'Attributes (AttributeDecl, AttributesForm)'->msg.putline;
                   
                // 6 then
                   'Category of the following slot is not supported!\n\n\t'
                     ->msg.putText;
                   slot.name->msg.putLine;
                   '\nCategory must be: descriptor, attributes or doPart'
                     ->msg.putLine
                // 7 then
                   'Warning: mainPart-slots are NOT fully supported!'
                     ->msg.putLine
               if);
               'Error in fragment structure'->writeInfoView;
               (if slot[] <> none then
                   slot.father->findAndSelect; msg[]->Report
                else
                   (if ff[] <> none then
                       ff[]->findForm; msg[]->Report
                    else
                       (if fg[] <> none then
                           fg[]->findGroup; msg[]->Report
                        else
                           'fragmentException: '->putText;
                           errNo->putInt;
                           ': '->putLine;
                           keepMsg[]->putLine;
                           keepMsg[]->report
                       if)
                   if)
               if)
            #);
          propertyException:: 
            (# keepMsg: ^text
            do
               msg.copy->keepMsg[];
               msg.clear;
               (if n
                // 1 then
                   'Two or more origins are specified:\n\t'->msg.puttext;
                     (# g: ^mps.ast.fragment; 
                     do FG.origin->g[]; g.name->msg.puttext; 
                     #);
                   '\n\t'->msg.puttext;
                   t[]->msg.putline
                // 2 then
                   'The reserved property name "'->msg.puttext;
                   t.makeUC;
                   t[]->msg.puttext;
                   '"\n\tappears in the property list for '->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   
                // 3 then
                   'Illegal "'->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   '" property: "'->msg.puttext;
                   t.makeUC;
                   t[]->msg.puttext;
                   '"\n'->msg.puttext
                // 4 then
                   'Empty filename in property "'->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   '"'->msg.put;
                   msg.newline;
                   
                // 5 then
                   'Unrecognised property: '->Msg.Puttext;
                   p[]->Msg.Putline;
                   true->warning
                // 6 then
                   'Property "'->msg.puttext;
                   p[]->msg.puttext;
                   '" has no value for "'->msg.putText;
                   t[]->msg.putText;
                   '"\n'->msg.putLine;
                   true->warning
               if);
               (if not warning then
                   '\n\n\tA ";" may be missing before '->msg.puttext;
                   t[]->msg.putline;
                   
               if);
               'Property error'->writeInfoView;
              (if fg[] <> none then
                   fg[]->findGroup;
                   msg[]->Report
                else
                   'propertyException: '->putText;
                   n->putInt;
                   ': '->putLine;
                   keepMsg[]->putLine;
                   keepMsg[]->report
               if)
            #)
       do 
       #);
   (if parseErrors then
       false->parseErrors;
       'Parse Error(s)'->writeInfoview;
       fileWithParseErrors[]->openParseEditor
   if);
   (* trace dependendy analysis:
    * true->compilerPrivate.comp.switch[381];
    * 
    * trace checking
    * true->compilerPrivate.comp.switch[191];
    * true->compilerPrivate.comp.switch[192];
    * true->compilerPrivate.comp.switch[193];
    * 
    * for general switches see systembody.bet
    *)
   (if not someError then
       (if generatecode
        // false then
        (* (none ,'Checking finished',
         'Compiler message')->alertUser;*)
           'Checking finished'->writeInfoView
        else
       (* (none ,'Checking and code generation finished','Compiler message')
        ->alertUser;*)
           'Checking and code generation finished, wait for linking, see the console'->writeInfoView
       if)
   if);
   
#)  

-- initCompilerBody: Descriptor --
(#
(* Here it is possibleto initialize the compiler/checker 
 * to use specific instances
 * of ASTinterface and OSinterface. 
 * If comp.AST[]/ensemble[] are none, then
 * comp.init will generate new instances of ASTinterface and OSinterface.
 * 
 * myASTinterface[] -> comp.AST[]
 * myOsinterface[]-> comp.ensemble[]
 *) 
do
   mps.ast[]->compilerPrivate.comp.AST[];
   true->compilerPrivate.comp.switch[401];
   true->compilerPrivate.comp.switch[403];
   compilerPrivate.comp.sifInfoStream.init;
   compilerPrivate.comp.sifInfoStream[]->compilerPrivate.comp.infostream[];
   screen[]->compilerPrivate.comp.tracestream[];
   screen[]->compilerPrivate.comp.messagestream[];
   screen[]->compilerPrivate.comp.bugstream[];
   compilerPrivate.comp.verboseLevel.actions->compilerPrivate.comp.verboseLevel;
   compilerPrivate.comp.init;
   
#)  

