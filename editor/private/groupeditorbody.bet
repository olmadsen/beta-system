ORIGIN '../codeeditor';
INCLUDE 'editorenvbody'
        '~beta/betaast/v4.9.1/donecheck';
-- groupeditorFormeditorListFindOrCreateEditor: DoPart --
do
   ff[]->findEditor->fe[];
   (if trace[2] then
       (if fe[] = none then 'creating formeditor'->putLine;  if)
   if)  

-- groupeditorFormeditorListFindEditor: DoPart --
do
   search: scan
     (# 
     do (if current.frag[] // ff[] then current[]->fe[]; leave search if)
     #)  

-- groupeditorFormeditorListFindEditorId: DoPart --
do
   search: scan
     (# 
     do (if current.id // id then current[]->fe[]; leave search if)
     #)  

-- groupeditorCloseGroup: DoPart --
do
     (#
        position: ^groupEditorList.theCellType;
        help: ^text;
        cleanUp:
          (# 
          do
             formEditorList.scan
               (#  do current.closeForm #);
             position[]->groupEditorList.delete
          #)
     do
        (if (THIS(groupEditor)[]->groupEditorList.at->position[]) <> none then
            (if trace[2] then
                'GroupEditor.CloseGroup: '->putText; fg.name->putLine; 
            if);
            ;
            (if (touched > 0) and not isAfrejaEditor then
                'Save changes to '->help[];
                fg.name->help.putText;
                '?'->help.put;
                (none ,'Close group',help[])
                  ->UI.promptForBoolean
                    (#
                       ok::< 
                         (#  do (true,true)->save; true->value; cleanup #);
                       notOK::<  (#  do true->value; cleanUp #);
                       cancel::<  (#  do false->value #);
                       
                    #)
             else
                (if needToUpdateTextFile then
                    fg[]->editorenvPrivate.makeNewTextfile
                if);
                cleanUp;
                true->value
            if);
            
         else
            (if trace[2] then
                'GroupEditor.CloseGroup: already closed!!!'->putText;
                fg.name->putLine;
                
            if);
            true->value
        if)
     #)  

-- groupeditorSave: DoPart --
do
     (#
        f: @file;
        ff: ^mps.fragmentForm;
        textFile,tildeTextFile,gname: ^text;
        OKtoSave: @boolean;
        doSave:
          (# 
          do
             thisOperation:
               (# help: ^text; 
               do
                  (if doGC then fg[]->editorenvprivate.ASTGC;  if);
                  (if not ((fg[],true)->editorenvPrivate.extendedMarkAsChanged)
                   then
                      leave thisOperation
                  if);
                  resetGroupTouch;
                  fg[]->editorenvPrivate.deleteAutoSaveFile;
                  ('~',fg[])->editorenvPrivate.extendedSaveBackup;
                  fg[]->editorenvPrivate.getGrammarName->gname[];
                  (if ('beta'->gname.equal) then
                      fg.fragmentlist.scan
                        (#
                           help: ^text;
                           unexpandedExists: @boolean;
                           unExp: ^mps.unexpanded;
                           
                        do
                           (if current.type
                            // mps.formType then
                               current.f[]->editorenvPrivate.nonterminalExists
                                 ->(unexpandedExists,unExp[]);
                               (if unexpandedExists
                                // true then
                                   'Is saved, but notice that nonterminals still exist in the '
                                     ->help[];
                                   current.name[]->help.putText;
                                   ' fragment form.'->help.putLine;
                                   'This fragment group cannot be compiled before all nonterminals are removed'
                                     ->help.putText;
                                   help[]->putLine (* UI.statusmessage*) ;
                                   leave thisOperation
                               if)
                           if);
                           
                        #);
                      
                  if);
                  
               #);
             
          #);
        
     do
        (if writeAccess then
            (if (touched > 0) then
                true->OKtoSave
             else
                'Save: not touched, nothing done'->putLine;
                (* (none ,'Save',
                 'File not touched, do you really want to save?')
                 ->UI.promptForBoolean
                 (#
                 ok::<  (#  do true->OKtoSave #);
                 notOK::<  (#  do false->OKtoSave #)
                 #);*)
                
            if);
            (if OKtoSave then
                'Saving...'->putText;
                doSave;
                newLine;
                (if doUpdateTextFile then
                    fg[]->editorenvPrivate.makeNewTextFile
                if)
            if);
            
         else
            (none ,'This file is read-only','Alert')->UI.alertUser; 
        if);
        
     #)  

-- groupeditorSaveAs: DoPart --
do loop:
     (#
     do
        UI.fileCreationDialog->newName[]->putLine;
        newName[]->editorenvPrivate.stripExtension->newName[];
        (if newName[]->editorenvPrivate.fileWriteable then
            'Saving group as '->putText;
            newName[]->putText;
            '...'->putText;
            fg[]->editorenvPrivate.ASTGC;
            newName[]->mps.expandToFullPath->fg.saveAs;
            newLine;
            (* to avoid save prompt! :*)
            resetGroupTouch;
            formEditorList.scan
            (#  do current.resetFragmentTouch;  #);
            false->needToUpdateTextFile;
            closeGroup;
         else
            (none,'No write permission','Save As')->UI.alertUser; 
            restart loop
        if)
     #)

-- groupeditorSaveAbstract: DoPart --
do
   loop:   (# fileName: ^text
   do
      (*(none ,'Save Abstract',
       'Save fragment group at current abstraction level on which text file?','')
       ->promptForText
       (#
       ok::< 
       (# 
       do
       (mps[],fg[],none ,userText[])
       ->prettyprintFragment
       (# abstractPresentation::< trueObject #);
       
       #)
       #)
       *)
      
      UI.fileCreationDialog->fileName[]->putLine;
      (if fileName[]->editorenvPrivate.fileWriteable then
          (mps[],fg[],none ,fileName[])
            ->prettyprintFragment
          (# abstractPresentation::< trueObject #);
       else
          (none,'No write permission','Save Abstract')->UI.alertUser;
          restart loop
      if)
   #)
               
-- groupeditorRecover: DoPart --
do   

-- groupeditorRevert: DoPart --
do   

-- groupeditorResetGroupTouch: DoPart --
do 0->touched; formEditorList.scan (#  do current.resetFragmentTouch #);   

-- groupeeditorGroupTouched: DoPart --
do
   (if writeAccess // true then touched+1->touched;  if);
   (if touched
    // 1 (* only first time *) then
       (if (grammarName[] <> none )
        // true then
           (if ('beta'->grammarName.equal)
            // true then (0,mps[],fg[])->setDoneCheckProperty; 
           if);
           
       if);
       
   if);
   (if trace[7] then
       'group touched '->putText; touched->putint; ' times'->putLine; 
   if);
     

-- groupeditorGroupDetouched: DoPart --
do
   touched-1->touched;
   (if trace[7] then
       'group touched '->putText; touched->putint; ' times'->putLine; 
   if)  

-- groupeditorMyAddFragment: DoPart --
do
   loop:
     (# before: ^g.fragmentList.theCellType; newname,mess: ^text
     do
        true->status;
        loop2: g.fragmentlist.scan
          (# 
          do
             (if f.name->current.name.equalNCS then
                 false->status; leave loop2
             if)
          #);
        (if not status then
            (f.name).copy->mess[];
            ' already exists'->mess.append;
            (f.name).copy->newname[];
            'Copy'->newName.append;
            newName[]->f.name;
            mess[]->putline;
            restart loop;
            
        if);
        (if beforeElement[] = none then
            (f[])->g.fragmentList.addFragment; 
         else
            beforeElement[]->g.fragmentList.at->before[];
            (f[],before[])->g.fragmentList.insertFragmentBefore;
            
        if)
     #);
     

-- groupeditorGetFragmentListElement: DoPart --
do
   (if ff[] <> none then
       search: fg.fragmentlist.scan
         (# 
         do
            (if current.type = mps.formtype then
                (if current.f[] = ff[] then current[]->fle[]; leave search if)
            if)
         #);
       ff.name->putText;
       ' fragmentForm not found'->putLine
   if)  

-- groupeditorAskUndoPermission: DoPart --
do false->value  

-- groupeditorAskPastePermission: DoPart --
do (clippedFrag[] <> none )->value  

-- groupeditorAskInsertPermission: DoPart --
do true->value  

-- groupeditorUndo: DoPart --
do   

-- groupeditorCutForm: DoPart --
do
     (#
        fle: ^fg.fragmentListElement;
        theGrammar: ^mps.treelevel;
        (* fe: ^formEditor*)
        
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            ff.grammar[]->mps.newFragmentForm->clippedFrag[];
            clippedFrag[]->ff.root.copy->clippedFrag.root[];
            ff.name->clippedFrag.name;
            (* ff[]->groupEditorList.findFormEditor->fe[];
             (if (fe[] <> none ) // true then fe.sdeC.editorWindow.close if);*)
            'CutForm: the corresponding formEditor should be closed (if open)'
              ->putLine;
            ff.name->fg.fragmentList.deleteLocalName;
            groupTouched
        if)
     #)  

-- groupeditorCopyForm: DoPart --
do
   ff.grammar[]->mps.newFragmentForm->clippedFrag[];
   clippedFrag[]->ff.root.copy->clippedFrag.root[];
   (ff.name).copy->clippedFrag.name  

-- groupeditorPasteForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; pasteFrag: ^mps.fragmentForm
     do
        clippedFrag.grammar[]->mps.newFragmentForm->pasteFrag[]->newff[];
        pasteFrag[]->clippedFrag.root.copy->pasteFrag.root[];
        (clippedFrag.name).copy->pasteFrag.name;
        ff[]->getFragmentListElement->fle[];
        (if ((fg[],pasteFrag[],fle[])->myAddFragment) then groupTouched;  if)
     #)  

-- groupeditorInsertForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; t: ^text; doParse: @boolean
     do
        (none ,'Insert New Fragment Form','Enter fragment form name','')
          ->promptForText
            (#
               ok::< 
                 (# 
                 do
                    ('beta',screen[])->mps.grammarTable.find
                      ->mps.newFragmentForm->newff[];
                    userText[]->newff.name;
                    'syncatno: '->putText;
                    synCatNo->putInt;
                    newline;
                    (if synCatNo
                     // 2 (*descriptorForm*) then
                        '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 3 (*attributesForm*) then
                        '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 31 (*doPart*) then
                        'do <<ImpOpt>>'->t[]; true->doParse; 
                    if);
                    (if doParse
                     // true then
                        t.reset;
                        (synCatNo,t[],screen[],newff[])
                          ->betaGrammar.parser.doParse;
                        
                    if);
                    ff[]->getFragmentListElement->fle[];
                    (if ((fg[],newff[],fle[])->myAddFragment) then
                        groupTouched; 
                    if)
                 #)
            #);
        
     #)  

-- groupeditorEditProperties: DoPart --
do
     (#
        propGroup: ^mps.fragmentGroup;
        ff: ^mps.fragmentForm;
        thePropertyWindow: ^propertyWindow;
        propertyWindow: window
          (#
             editor: @sifTextEditor (# codeViewerType::< propertyEditor #);
             open:: 
               (#
                  ff: ^mps.fragmentForm;
                  node: ^mps.ast;
                  help: ^text;
                  ped: ^propertyeditor
               enter node[]
               do
                  (if node[] <> none then
                      ((node.frag.father).name).copy->help[];
                      help.length->help.pos;
                      '-'->help.put;
                      node.frag.name->help.putText;
                      help[]->title;
                      help[]->putLine;
                      editor.open;
                      (mps[],propertyGrammar[],node.frag.root[],node[])
                        ->editor.newfragment->ped[];
                      (if ped[] <> none then
                          THIS(GroupEditor)[]->ped.theGroupEditor[]; 
                       else
                          'no propertyeditor created!'->putLine
                      if);
                      editor.size->size;
                      true->editor.bindBottom->editor.bindRight
                  if);
                  
               #);
             
          #);
        
     do
        (if thePropertyEditor[] <> none then
            'thePropertyWindow.editor.wriggle'->putLine
         else
            fg[]->editorenvPrivate.propsToAst->propGroup[];
            l: propGroup.fragmentList.scan
              (# 
              do
                 (if current.type = mps.formType then
                     current.f[]->ff[]; leave l
                 if)
              #);
            (* prettyprint property list
             * and parse corresponding to the 
             * property grammar
             *)
            (if ff[] <> none then
                &propertyWindow[]->thePropertyWindow[];
                ff.root[]->thePropertyWindow.open
             else
                'editProperties: ff is none'->putLine
            if)
        if)
     #)  

-- groupeditorEditFormName: DoPart --
do
     (# fle: ^fg.fragmentListElement
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            (none ,'Edit Fragment Form Name','Enter New Name',fle.name[])
              ->promptForText
                (#
                   ok::< 
                     (# 
                     do userText[]->fle.name[]->fle.f.name; groupTouched; 
                     #)
                #)
        if)
     #)  

-- groupeditorSearchSlot: Descriptor --
(#
   slotName: ^text;
   searchFrag: ^mps.fragmentGroup;
   originName,help,path,name2: ^text;
   fg2: ^mps.fragmentGroup;
   found: @boolean;
   
do
   ff.name->slotName[];
   'Searching for the SLOT definition of '''->putText;
   slotName[]->putText;
   ''' in:'->putLine;
   fg[]->searchFrag[];
   searchSlot: searchFrag.prop.scanProp
     (#
        doProp::< 
          (# 
          do
             (if true
              // ('ORIGIN'->prop.equalNCS) then
                 getString->originName[];
                 (if (originName.length > 0)
                  // true then
                     originName[]->putLine;
                     searchFrag.fullName->editorenvPrivate.splitPath
                       ->(path[],name2[]);
                     ((originName[],path[] (*g.fullName*) )
                        ->mps.thePathHandler.convertFilePath->help[],screen[])
                       ->mps.top.open->fg2[];
                     (if fg2[]
                      // none then
                         ' not found'->help.putText;
                         (none ,help[],'Search SLOT')->UI.alertUser;
                         
                      else
                         l: fg2.scanSlots
                           (# 
                           do
                              (if (current.Name->slotName.equalNCS)
                               // true then
                                  true->found;
                                  current.father->theSlotNode[];
                                  leave l
                              if)
                           #);
                         (if found
                          // false then
                             fg2[]->searchFrag[];
                             ''->originName[];
                             restart searchSlot
                         if);
                         
                     if);
                     
                  else
                     'Could not find the SLOT '''->help[];
                     slotName[]->help.putText;
                     ''' on the ORIGIN chain'->help.putText;
                     (none ,help[],'Search SLOT')->UI.alertUser;
                     
                 if)
             if);
             
          #)
     #);
   
#)  

-- groupeditorCompilerSavedGroup: Descriptor --
(# 
do
   (if touched > 0 then
       true->needToUpdateTextFile;
       fg[]->editorenvPrivate.deleteAutoSaveFile;
       fg[]->editorenvPrivate.backupTextFile;
       resetGroupTouch
   if)
#)  

