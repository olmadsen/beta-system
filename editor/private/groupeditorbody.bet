ORIGIN '../codeeditor';
INCLUDE 'editorenvbody';
-- groupeditorFormeditorListFindOrCreateEditor: DoPart --
do
   'findOrCreateEditor'->putLine;
   ff[]->findEditor->fe[];
   (if fe[] = none then 'creating formeditor'->putLine;  if)  

-- groupeditorFormeditorListFindEditor: DoPart --
do
   search: scan
     (# 
     do (if current.frag[] // ff[] then current[]->fe[]; leave search if)
     #)  

-- groupeditorFormeditorListFindEditorId: DoPart --
do
   search: scan
     (# 
     do (if current.id // id then current[]->fe[]; leave search if)
     #)  

-- groupeditorCloseGroup: DoPart --
do 'CloseGroup'->putLine  

-- groupeditorSave: DoPart --
do
     (#
        f: @file;
        ff: ^mps.fragmentForm;
        textFile,tildeTextFile,gname: ^text;
        OKtoSave: @boolean;
        doSave:
          (# 
          do
             thisOperation:
               (# help: ^text; 
               do
                  fg[]->editorenvprivate.ASTGC;
                  (if not ((fg[],true)->editorenvPrivate.extendedMarkAsChanged)
                   then
                      leave thisOperation
                  if);
                  resetGroupTouch;
                  fg[]->editorenvPrivate.deleteAutoSaveFile;
                  ('~',fg[])->editorenvPrivate.extendedSaveBackup;
                  (* g.fullName->help[];
                   '#'->help.put;
                   mps.astFileExtension->help.putText;
                   help[]->f.name;
                   (if f.entry.exists
                   // true then 
                   f.delete
                   if);
                   * *)
                  fg[]->editorenvPrivate.getGrammarName->gname[];
                  (if ('beta'->gname.equal)
                   // true then
                      fg.fragmentlist.scan
                        (#
                           help: ^text;
                           unexpandedExists: @boolean;
                           unExp: ^mps.unexpanded;
                           
                        do
                           (if current.type
                            // mps.formType then
                               current.f[]->editorenvPrivate.nonterminalExists
                                 ->(unexpandedExists,unExp[]);
                               (if unexpandedExists
                                // true then
                                   'Is saved, but notice that nonterminals still exist in the '
                                     ->help[];
                                   current.name[]->help.putText;
                                   ' fragment form.'->help.putLine;
                                   'This fragment group cannot be compiled before all nonterminals are removed'
                                     ->help.putText;
                                   help[]->putLine (* UI.statusmessage*) ;
                                   leave
                                   (*unExp[]->groupEditorList.findAndSelect;*)
                                   thisOperation
                               if)
                           if);
                           
                        #);
                      
                  if);
                  
               #);
             
          #);
        
     do
        (if writeAccess then
            (if (touched > 0) then
                true->OKtoSave
             else
                (none ,'Save','File not touched, do you really want to save?')
                  ->UI.promptForBoolean
                    (#
                       ok::<  (#  do true->OKtoSave #);
                       cancel::<  (#  do false->OKtoSave #)
                    #);
                
            if);
            (if OKtoSave then
                'Saving...'->putText;
                doSave;
                newLine;
                fg[]->editorenvPrivate.makeNewTextFile
            if);
            
         else
            (none ,'This file is read-only','Alert')->UI.alertUser; 
        if);
        
     #)  

-- groupeditorSaveAs: DoPart --
do   

-- groupeditorSaveAbstract: DoPart --
do   

-- groupeditorRecover: DoPart --
do   

-- groupeditorRevert: DoPart --
do   

-- groupeditorResetGroupTouch: DoPart --
do
   0->touched;
   'formEditorList.scan(#  do current.sde.resetFragmentTouch #);'->putLine  

-- groupeeditorGroupTouched: DoPart --
do 'grouptouched'->putLine  

-- groupeditorGroupDetouched: DoPart --
do
   touched-1->touched;
   (if true then
       'group touched '->putText; touched->putint; ' times'->putLine; 
   if)  

-- groupeditorMyAddFragment: DoPart --
do
   loop:
     (# before: ^g.fragmentList.theCellType; newname,mess: ^text
     do
        true->status;
        loop2: g.fragmentlist.scan
          (# 
          do
             (if f.name->current.name.equalNCS then
                 false->status; leave loop2
             if)
          #);
        (if not status then
            (f.name).copy->mess[];
            ' already exists'->mess.append;
            (f.name).copy->newname[];
            'Copy'->newName.append;
            newName[]->f.name;
            restart loop;
            mess[]->putline;
            newName[]->putLine;
            (* (none ,'Sif',mess[],newName[])
             ->UI.promptForText
             (# ok::<  (#  do usertext[]->putLine #) #);*)
            (* (mess[],newname[])
             ->mypromptfortext
             (#
             confirm::<  (#  do thetext.copy->f.name; restart loop #);
             cancel::<  (#  do leave loop #)
             #)
             when this is OK the same test should be in editFormName*)
            
        if);
        (if beforeElement[] = none then
            (f[])->g.fragmentList.addFragment; 
         else
            beforeElement[]->g.fragmentList.at->before[];
            (f[],before[])->g.fragmentList.insertFragmentBefore;
            
        if)
     #);
     

-- groupeditorGetFragmentListElement: DoPart --
do
   (if ff[] <> none then
       search: fg.fragmentlist.scan
         (# 
         do
            (if current.type = mps.formtype then
                (if current.f[] = ff[] then current[]->fle[]; leave search if)
            if)
         #);
       ff.name->putText;
       ' fragmentForm not found'->putLine
   if)  

-- groupeditorAskUndoPermission: DoPart --
do false->value  

-- groupeditorAskPastePermission: DoPart --
do (clippedFrag[] <> none )->value  

-- groupeditorAskInsertPermission: DoPart --
do true->value  

-- groupeditorUndo: DoPart --
do   

-- groupeditorCutForm: DoPart --
do
     (#
        fle: ^fg.fragmentListElement;
        theGrammar: ^mps.treelevel;
        (* fe: ^formEditor*)
        
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            ff.grammar[]->mps.newFragmentForm->clippedFrag[];
            clippedFrag[]->ff.root.copy->clippedFrag.root[];
            ff.name->clippedFrag.name;
            (* ff[]->groupEditorList.findFormEditor->fe[];
             (if (fe[] <> none ) // true then fe.sdeC.editorWindow.close if);*)
            'CutForm: the corresponding formEditor should be closed (if open)'
              ->putLine;
            ff.name->fg.fragmentList.deleteLocalName;
            groupTouched
        if)
     #)  

-- groupeditorCopyForm: DoPart --
do
   ff.grammar[]->mps.newFragmentForm->clippedFrag[];
   clippedFrag[]->ff.root.copy->clippedFrag.root[];
   (ff.name).copy->clippedFrag.name  

-- groupeditorPasteForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; pasteFrag: ^mps.fragmentForm
     do
        clippedFrag.grammar[]->mps.newFragmentForm->pasteFrag[]->newff[];
        pasteFrag[]->clippedFrag.root.copy->pasteFrag.root[];
        (clippedFrag.name).copy->pasteFrag.name;
        ff[]->getFragmentListElement->fle[];
        (if ((fg[],pasteFrag[],fle[])->myAddFragment) then groupTouched;  if)
     #)  

-- groupeditorInsertForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; t: ^text; doParse: @boolean
     do
        ('Enter fragment form name','')
          ->myPromptForText
            (#
               confirm::< 
                 (# 
                 do
                    ('beta',screen[])->mps.grammarTable.find
                      ->mps.newFragmentForm->newff[];
                    theText[]->newff.name;
                    'syncatno: '->putText;
                    synCatNo->putInt;
                    newline;
                    (if synCatNo
                     // 2 (*descriptorForm*) then
                        '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 3 (*attributesForm*) then
                        '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 31 (*doPart*) then
                        'do <<ImpOpt>>'->t[]; true->doParse; 
                    if);
                    (if doParse
                     // true then
                        t.reset;
                        (synCatNo,t[],screen[],newff[])
                          ->betaGrammar.parser.doParse;
                        
                    if);
                    ff[]->getFragmentListElement->fle[];
                    (if ((fg[],newff[],fle[])->myAddFragment) then
                        groupTouched; 
                    if)
                 #)
            #);
        
     #)  

-- groupeditorEditProperties: DoPart --
do   

-- groupeditorEditFormName: DoPart --
do
     (# fle: ^fg.fragmentListElement
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            ('Edit Fragment Form Name',fle.name[])
              ->myPromptForText
                (#
                   confirm::< 
                     (# 
                     do theText[]->fle.name[]->fle.f.name; groupTouched; 
                     #)
                #)
        if)
     #)  

