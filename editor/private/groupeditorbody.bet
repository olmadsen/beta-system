ORIGIN '../codeeditor';
INCLUDE 'editorenvbody'
        '~beta/betaast/v5.0.1/donecheck';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- groupeditorSetIsReadOnly: DoPart --
do
   (if value then
       true->isReadOnly;
       formEditorList.scan
         (#  do true->current.setIsReadOnly #)
    else
       (if groupfileWriteable then (* only allow editing if file is writeable *)
           false->isReadOnly;
           formEditorList.scan
             (#  do false->current.setIsReadOnly #)
       if)
   if)  

-- groupeditorFormeditorListFindOrCreateEditor: DoPart --
do
   ff[]->findEditor->fe[];
   (if trace[2] then
       (if fe[] = none then 'creating formeditor'->putLine;  if)
   if)  

-- groupeditorFormeditorListFindEditor: DoPart --
do
   search: scan
     (# 
     do (if current.frag[] // ff[] then current[]->fe[]; leave search if)
     #)  

-- groupeditorFormeditorListFindEditorId: DoPart --
do
   search: scan
     (# 
     do (if current.id // id then current[]->fe[]; leave search if)
     #)  

-- groupeditorCloseGroup: DoPart --
do
     (#
        position: ^groupEditorList.theCellType;
        help: ^text;
        cleanUp:
          (# 
          do
             THIS(groupEditor)[]->fgHandler.unsubscribe;
             formEditorList.scan
               (#  do current.closeForm #);
             (* (if THIS(GroupEditor).fgh.groupEditors.size = 0 then fg.close if);*)
             position[]->groupEditorList.delete
          #);
        test:
          (# 
          do
             'groupEditorList: '->putText;
             groupEditorList.size->putInt;
             newLine;
             groupEditorList.scan
               (#  do current.fg.name->putLine;  #)
          #)
     do (*'before '->putText;
         test;*)
        (if (THIS(groupEditor)[]->groupEditorList.at->position[]) <> none then
            (if trace[2] then
                'GroupEditor.CloseGroup before: '->putText;
                fg.name->putLine;
                showEditors;
                
            if);
            ;
            (if (touched > 0) and not isAfrejaEditor then
                'Save changes to '->help[];
                fg.name->help.putText;
                '?'->help.put;
                help[]->putline;
                (none ,'Close group',help[])
                  ->UI.promptForBoolean
                    (#
                       ok::< 
                         (#  do (true,true)->save; true->value; cleanup #);
                       notOK::< 
                         (# 
                         do
                            true->value;
                            fg[]->editorenvPrivate.deleteAutoSaveFile;
                            cleanUp
                         #);
                       cancel::<  (#  do false->value #);
                       
                    #)
             else
                (if needToUpdateTextFile then fg[]->makeNewTextfile if);
                cleanUp;
                true->value
            if);
            
         else
            (if trace[2] then
                'GroupEditor.CloseGroup: already closed!!!'->putText;
                fg.name->putLine;
                
            if);
            true->value
        if);
        (if trace[2] then
            'GroupEditor.CloseGroup after: '->putText;
            fg.name->putLine;
            showEditors;
            
        if);
        (*'after '->putText;
         test;*)
        
     #)  

-- groupeditorSave: DoPart --
do
     (#
        f: @file;
        ff: ^astInterface.fragmentForm;
        textFile,tildeTextFile,gname: ^text;
        OKtoSave: @boolean;
        doSave:
          (# 
          do
             thisOperation:
               (# help: ^text; 
               do
                  (if doGC then
                      fg[]->editorenvprivate.ASTGC
                   else
                  (* only necessary if not AST GC is performed *)
                      fg[]->editorenvprivate.recomputeSLOTchain
                  if);
                  (if not ((fg[],true)->editorenvPrivate.extendedMarkAsChanged)
                   then
                      leave thisOperation
                  if);
                  resetGroupTouch;
                  fg[]->editorenvPrivate.deleteAutoSaveFile;
                  ('~',fg[])->editorenvPrivate.extendedSaveBackup;
                  fg[]->editorenvPrivate.getGrammarName->gname[];
                  (if gname[] <> none then
                      (if ('beta'->gname.equal) then
                          (if fg.fragmentList[] <> none then
                              fg.fragmentlist.scan
                                (#
                                   help: ^text;
                                   unexpandedExists: @boolean;
                                   unExp: ^astInterface.unexpanded;
                                   
                                do
                                   (if current.type
                                    // mps.formType then
                                       current.f[]
                                         ->editorenvPrivate.nonterminalExists
                                         ->(unexpandedExists,unExp[]);
                                       (if unexpandedExists then
                                           newLine;
                                           'Notice that nonterminals still exist in the '
                                             ->help[];
                                           current.name[]->help.putText;
                                           ' fragment form.'->help.putLine;
                                           'This fragment group cannot be compiled before all nonterminals are removed'
                                             ->help.putText;
                                           help[]
                                             ->putLine (* UI.statusmessage*) ;
                                           leave thisOperation
                                       if)
                                   if);
                                   
                                #);
                              
                          if)
                      if);
                      
                  if)
               #);
             
          #);
        
     do
        (if isReadOnly then
            (none ,'This file is read-only','Alert')->UI.alertUser; 
         else
            (if (touched > 0) then
                true->OKtoSave
             else
                'Save: not touched, nothing done'->putLine;
                (* (none ,'Save',
                 'File not touched, do you really want to save?')
                 ->UI.promptForBoolean
                 (#
                 ok::<  (#  do true->OKtoSave #);
                 notOK::<  (#  do false->OKtoSave #)
                 #);*)
                
            if);
            (if OKtoSave then
                'Saving...'->putText; doSave; true->groupSaved; newLine
            if);
            (if doUpdateTextFile then fg[]->makeNewTextFile if);
            
        if);
        
     #)  

-- groupeditorSaveAs: DoPart --
do
   loop:
     (# f: @file; t: ^text
     do
        UI.fileCreationDialog->t[];
        (if t[] <> none then
            t[]->f.name;
            f.name->editorenvPrivate.stripExtension->f.name->putLine;
            (if f.name->editorenvPrivate.fileWriteable then
                'Saving group as '->putText;
                f.name->newName[]->putText;
                '...'->putText;
                fg[]->editorenvPrivate.ASTGC;
                (*fg[]->editorenvprivate.recomputeSLOTchain; not necessary after AST GC *)
                newName[]->mps.expandToFullPath->fg.saveAs;
                newLine;
                (* to avoid save prompt! :*)
                resetGroupTouch;
                (*formEditorList.scan
                 (#  do current.resetFragmentTouch;  #);
                 false->needToUpdateTextFile;
                 closeGroup;*)
                
             else
                (none ,'No write permission','Save As')->UI.alertUser;
                restart loop
            if)
        if)
     #)  

-- groupeditorSaveAbstract: DoPart --
do
   loop:
     (# t: ^text; 
     do
        UI.fileCreationDialog->t[];
        (if (t[] <> none ) and (t.length > 0) then
            (if t[]->editorenvPrivate.fileWriteable then
                (mps[],fg[],none ,t[])
                  ->prettyprintFragment
                (# (*width:: (# do 100->value #) ;*)
                   abstractPresentation::< trueObject #);
                
             else
                (none ,'No write permission','Save Abstract')->UI.alertUser;
                restart loop
            if)
        if)
     #)  

-- groupeditorAutoSave: DoPart --
do ('#',fg[])->editorenvPrivate.extendedSaveBackup  

-- groupeditorRecover: DoPart --
do (* is done in ymersiflib *)   

-- groupeditorRevert: DoPart --
do (* is done in ymersiflib *)   

-- groupeditorResetGroupTouch: DoPart --
do 0->touched; formEditorList.scan (#  do current.resetFragmentTouch #);   

-- groupeeditorGroupTouched: DoPart --
do
   (if not isReadOnly then touched+1->touched;  if);
   (if touched = 1 (* only first time *) then
       (if (grammarName[] <> none ) then
           (if ('beta'->grammarName.equal) then
               (0,mps[],fg[])->setDoneCheckProperty; 
           if);
           
       if);
       
   if);
   (if trace[7] then
       'group touched '->putText; touched->putint; ' times'->putLine; 
   if);
     

-- groupeditorGroupDetouched: DoPart --
do
   touched-1->touched;
   (if trace[7] then
       'group touched '->putText; touched->putint; ' times'->putLine; 
   if)  

-- groupeditorMyAddFragment: DoPart --
do
   loop:
     (# before: ^g.fragmentList.theCellType; newname,mess: ^text
     do
        true->status;
        loop2: g.fragmentlist.scan
          (# 
          do
             (if f.name->current.name.equalNCS then
                 false->status; leave loop2
             if)
          #);
        (if not status then
            (f.name).copy->mess[];
            ' already exists'->mess.append;
            (f.name).copy->newname[];
            'Copy'->newName.append;
            newName[]->f.name;
            mess[]->putline;
            restart loop;
            
        if);
        (if beforeElement[] = none then
            (f[])->g.fragmentList.addFragment; 
         else
            beforeElement[]->g.fragmentList.at->before[];
            (f[],before[])->g.fragmentList.insertFragmentBefore;
            
        if)
     #);
     

-- groupeditorGetFragmentListElement: DoPart --
do
   (if ff[] <> none then
       search: fg.fragmentlist.scan
         (# 
         do
            (if current.type = mps.formtype then
                (if current.f[] = ff[] then current[]->fle[]; leave search if)
            if)
         #);
       ff.name->putText;
       ' fragmentForm not found'->putLine
   if)  

-- groupeditorAskUndoPermission: DoPart --
do false->value  

-- groupeditorAskPastePermission: DoPart --
do (clippedFrag[] <> none )->value  

-- groupeditorAskInsertPermission: DoPart --
do true->value  

-- groupeditorUndo: DoPart --
do   

-- groupeditorCutForm: DoPart --
do
     (#
        fle: ^fg.fragmentListElement;
        theGrammar: ^astInterface.treelevel;
        (* fe: ^formEditor*)
        
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            ff.grammar[]->mps.newFragmentForm->clippedFrag[];
            clippedFrag[]->ff.root.copy->clippedFrag.root[];
            ff.name->clippedFrag.name;
            (* ff[]->groupEditorList.findFormEditor->fe[];
             (if (fe[] <> none ) // true then fe.sdeC.editorWindow.close if);*)
            'CutForm: the corresponding formEditor should be closed (if open)'
              ->putLine;
            ff.name->fg.fragmentList.deleteLocalName;
            (true,ff[])->fragmentDeleted
        if)
     #)  

-- groupeditorCopyForm: DoPart --
do
   ff.grammar[]->mps.newFragmentForm->clippedFrag[];
   clippedFrag[]->ff.root.copy->clippedFrag.root[];
   (ff.name).copy->clippedFrag.name  

-- groupeditorPasteForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; pasteFrag: ^astInterface.fragmentForm
     do
        clippedFrag.grammar[]->mps.newFragmentForm->pasteFrag[]->newff[];
        pasteFrag[]->clippedFrag.root.copy->pasteFrag.root[];
        (clippedFrag.name).copy->pasteFrag.name;
        ff[]->getFragmentListElement->fle[];
        (if ((fg[],pasteFrag[],fle[])->myAddFragment) then
            (true,pasteFrag[])->fragmentInserted
        if)
     #)  

-- groupeditorInsertForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; t: ^text; doParse: @boolean
     do
        (none ,'Insert New Fragment Form','Enter fragment form name','')
          ->promptForText
            (#
               ok::< 
                 (# 
                 do
                    ('beta',screen[])->mps.grammarTable.find
                      ->mps.newFragmentForm->newff[];
                    userText[]->newff.name;
                    'syncatno: '->putText;
                    synCatNo->putInt;
                    newline;
                    (if synCatNo
                     // 2 (*descriptorForm*) then
                        '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 3 (*attributesForm*) then
                        '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 31 (*doPart*) then
                        'do <<ImpOpt>>'->t[]; true->doParse; 
                    if);
                    (if doParse
                     // true then
                        t.reset;
                        (synCatNo,t[],screen[],newff[])
                          ->betaGrammar.parser.doParse;
                        
                    if);
                    ff[]->getFragmentListElement->fle[];
                    (if ((fg[],newff[],fle[])->myAddFragment) then
                        (true,newff[])->fragmentInserted; 
                    if)
                 #)
            #);
        
     #)  

-- groupeditorEditProperties: DoPart --
do
     (#
        propGroup: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        thePropertyWindow: ^propertyWindow;
        propertyWindow: window
          (#
             editor: @sifTextEditor (# codeViewerType::< propertyEditor #);
             File: @mySimpleMenu
               (#
                  iClose: @item
                    (#
                       onSelect:: 
                         (# 
                         do thePropertyWindow.close; none ->thePropertyEditor[]
                         #)
                    #);
                  open::  (#  do ('Close','w')->iClose.newKey #)
               #);
             Edit: @codeEditorEditMenu;
             menubarType:: 
               (#
                  open:: 
                    (# 
                    do File.new; File[]->append; Edit.new; Edit[]->append; 
                    #)
               #);
             open:: 
               (#
                  ff: ^astInterface.fragmentForm;
                  node: ^astInterface.ast;
                  help: ^text;
                  ped: ^propertyeditor
               enter node[]
               do
                  (if node[] <> none then
                      ((node.frag.father).name).copy->help[];
                      help.length->help.pos;
                      '-'->help.put;
                      node.frag.name->help.putText;
                      help[]->title;
                      editor.open;
                      (mps[],propertyGrammar[],node.frag.root[],node[])
                        ->editor.newfragment->ped[]->thePropertyEditor[];
                      (if ped[] <> none then
                          THIS(GroupEditor)[]->ped.theGroupEditor[];
                          ped[]->Edit.attach
                       else
                          'no propertyeditor created!'->putLine
                      if);
                      editor.size->size;
                      true->editor.bindBottom->editor.bindRight
                   else
                      'propertyWindow: node is none! '->putLine
                  if);
                  
               #);
             
          #);
        
     do
        (if thePropertyEditor[] <> none then
            (thePropertyEditor.theSifTextEditor.theWindow).bringToFront
         else
            fg[]->editorenvPrivate.propsToAst->propGroup[];
            l: propGroup.fragmentList.scan
              (# 
              do
                 (if current.type = mps.formType then
                     current.f[]->ff[]; leave l
                 if)
              #);
            (* prettyprint property list
             * and parse corresponding to the 
             * property grammar
             *)
            (if ff[] <> none then
                &propertyWindow[]->thePropertyWindow[];
                ff.root[]->thePropertyWindow.open
             else
                'editProperties: ff is none'->putLine
            if)
        if)
     #)  

-- groupeditorCreatePropertyEditor: DoPart --
do   

-- groupeditorEditFormName: DoPart --
do
     (# fle: ^fg.fragmentListElement
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            (none ,'Edit Fragment Form Name','Enter New Name               ',
             fle.name[])
              ->promptForText
                (#
                   ok::< 
                     (# 
                     do
                        userText[]->fle.name[]->fle.f.name;
                        (true,fle.f[])->fragmentChanged
                     #)
                #)
        if)
     #)  

-- groupeditorSearchSlot: Descriptor --
(#
   slotName: ^text;
   searchFrag: ^astInterface.fragmentGroup;
   originName,help,path,name2: ^text;
   fg2: ^astInterface.fragmentGroup;
   found: @boolean;
   
do
   ff.name->slotName[];
   'Searching for the SLOT definition of '''->putText;
   slotName[]->putText;
   ''' in:'->putLine;
   fg[]->searchFrag[];
   searchSlot: searchFrag.prop.scanProp
     (#
        doProp::< 
          (# 
          do
             (if true
              // ('ORIGIN'->prop.equalNCS) then
                 getString->originName[];
                 (if (originName.length > 0)
                  // true then
                     originName[]->putLine;
                     searchFrag.fullName->editorenvPrivate.splitPath
                       ->(path[],name2[]);
                     ((originName[],path[] (*g.fullName*) )
                        ->mps.thePathHandler.convertFilePath->help[],screen[])
                       ->mps.top.open->fg2[];
                     (if fg2[]
                      // none then
                         ' not found'->help.putText;
                         (none ,help[],'Search SLOT')->UI.alertUser;
                         
                      else
                         l: fg2.scanSlots
                           (# 
                           do
                              (if (current.Name->slotName.equalNCS)
                               // true then
                                  true->found;
                                  current.father->theSlotNode[];
                                  leave l
                              if)
                           #);
                         (if found
                          // false then
                             fg2[]->searchFrag[];
                             ''->originName[];
                             restart searchSlot
                         if);
                         
                     if);
                     
                  else
                     'Could not find the SLOT '''->help[];
                     slotName[]->help.putText;
                     ''' on the ORIGIN chain'->help.putText;
                     (none ,help[],'Search SLOT')->UI.alertUser;
                     
                 if)
             if);
             
          #)
     #);
   
#)  

-- groupeditorCompilerSavedGroup: Descriptor --
(# 
do
   (if touched > 0 then
       true->needToUpdateTextFile;
       fg[]->editorenvPrivate.deleteAutoSaveFile;
       fg[]->editorenvPrivate.backupTextFile;
       resetGroupTouch
   if)
#)  

-- groupeditorNotificationPrivate: Descriptor --
(#
   refresh:
     (# 
     do
        (if ymerCallBack[] <> none then
            (theBrowser[],fg[])->ymerCallback.refreshGroup; 
         else
            'ymercallback is none!!'->putLine
        if)
     #)
#)  

-- groupeditorGroupChanged: DoPart --
do
   groupTouched;
   (if byMe and (frejaInterface[] = none ) then autoSave if);
   INNER GroupChangedEvent  

-- groupeditorPropertiesChanged: Descriptor --
(# 
do
   (if trace[7] then
       'groupeditorPropertiesChanged '->putText;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       THIS(groupeditor)[]->fgh.propertiesChanged
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorFragmentChanged: Descriptor --
(# 
do
   (if trace[7] then
       'groupeditorFragmentChanged '->putText;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       (THIS(groupeditor)[],ff[])->fgh.fragmentChanged
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorFragmentInserted: Descriptor --
(# 
do
   (if trace[7] then
       'groupeditorFragmentInserted '->putText;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       (THIS(groupeditor)[],ff[])->fgh.fragmentInserted
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorFragmentDeleted: Descriptor --
(# 
do
   (if trace[7] then
       'groupeditorFragmentDeleted '->putText;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       (THIS(groupeditor)[],ff[])->fgh.fragmentDeleted
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorGroupSaved: DoPart --
do (if byMe then THIS(groupEditor)[]->fgh.groupSaved else resetGroupTouch if)  

