ORIGIN '../codeeditor';
INCLUDE 'editorenvbody'
        '~beta/betaast/v5.1/donecheck';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- groupeditorSetIsReadOnly: DoPart --
do
   (if value then
       true->isReadOnly;
       formEditorList.scan
         (#  do true->current.setIsReadOnly #)
    else
       (if groupfileWriteable then (* only allow editing if file is writeable *)
           false->isReadOnly;
           formEditorList.scan
             (#  do false->current.setIsReadOnly #)
       if)
   if)  

-- groupeditorFormeditorListFindOrCreateEditor: DoPart --
do
   ff[]->findEditor->fe[];
   (if trace[2] then
       (if fe[] = none then 'creating formeditor'->putLine;  if)
   if)  

-- groupeditorFormeditorListFindEditor: DoPart --
do
   search: scan
     (# 
     do (if current.frag[] // ff[] then current[]->fe[]; leave search if)
     #)  

-- groupeditorFormeditorListFindEditorId: DoPart --
do
   search: scan
     (# 
     do (if current.id // id then current[]->fe[]; leave search if)
     #)  

-- groupeditorCloseGroup: DoPart --
do
     (#
        position: ^groupEditorList.theCellType;
        OKtoClose,askSave: @boolean;
        help: ^text;
        cleanUp:
          (# 
          do
             THIS(groupEditor)[]->fgHandler.unsubscribe;
             formEditorList.scan
               (#  do current.closeForm #);
             position[]->groupEditorList.delete;
             fg[]->ymerCallBack.onGroupClosed
          #);
        test:
          (# 
          do
             'groupEditorList: '->putText;
             groupEditorList.size->putInt;
             newLine;
             groupEditorList.scan
               (#  do current.fg.name->putLine;  #)
          #)
     do (*'before '->putText;
         test;*)
        (if (THIS(groupEditor)[]->groupEditorList.at->position[]) <> none then
            (if trace[2] then
                'GroupEditor.CloseGroup before: '->putText;
                fg.name->putLine;
                showEditors;
                
            if);
            fg[]->ymerCallBack.onAboutToCloseGroup->(OKtoClose,askSave);
            (if OKtoClose then
                (if (touched > 0) and not isAfrejaEditor then
                    (if askSave then
                        'Save changes to '->help[];
                        fg.name->help.putText;
                        '?'->help.put;
                        (none ,'Close group',help[])
                          ->UI.promptForBoolean
                            (#
                               ok::< 
                                 (# 
                                 do
                                    (if (true,true)->save then
                                        true->value; cleanup
                                    if)
                                 #);
                               notOK::< 
                                 (# 
                                 do
                                    true->value;
                                    fg[]->editorenvPrivate.deleteAutoSaveFile;
                                    fg[]->ymerCallBack.onGroupNotSaved;
                                    cleanUp
                                 #);
                               cancel::<  (#  do false->value #);
                               
                            #)
                     else
                        (true,true)->save; true->value; cleanup
                    if)
                 else
                    doCommand
                      (# 
                      do
                         (if needToUpdateTextFile then
                             fg[]->makeNewTextfile
                         if);
                         cleanUp;
                         true->value
                      #)
                if);
                
             else
                false->value
            if)
         else
            (if trace[2] then
                'GroupEditor.CloseGroup: already closed!!!'->putText;
                fg.name->putLine;
                
            if);
            true->value
        if);
        (if trace[2] then
            'GroupEditor.CloseGroup after: '->putText;
            fg.name->putLine;
            showEditors;
            
        if);
        (*'after '->putText;
         test;*)
        
     #)  

-- groupeditorSave: DoPart --
do
     (#
        f: @file;
        ff: ^astInterface.fragmentForm;
        textFile,tildeTextFile,gname,msg: ^text;
        OKtoSave: @boolean;
        doSave:
          (# 
          do
             thisOperation:
               (# help: ^text; 
               do
                  (if doGC then
                      fg[]->editorenvprivate.ASTGC
                   else
                  (* only necessary if not AST GC is performed *)
                      fg[]->editorenvprivate.recomputeSLOTchain
                  if);
                  fg[]->editorenvPrivate.backupGroupFile;
                  (fg[],true)->editorenvPrivate.extendedMarkAsChanged->OK;
                  (if not OK then
                      fg[]->editorenvPrivate.restoreGroupFile;
                      leave thisOperation
                  if);
                  fg[]->ymerCallBack.onGroupSaved;
                  resetGroupTouch;
                  fg[]->editorenvPrivate.deleteAutoSaveFile;
                  fg[]->editorenvPrivate.getGrammarName->gname[];
                  (if gname[] <> none then
                      (if ('beta'->gname.equal) then
                          (if fg.fragmentList[] <> none then
                              fg.fragmentlist.scan
                                (#
                                   help: ^text;
                                   unexpandedExists: @boolean;
                                   unExp: ^astInterface.unexpanded;
                                   
                                do
                                   (if current.type
                                    // mps.formType then
                                       current.f[]
                                         ->editorenvPrivate.nonterminalExists
                                         ->(unexpandedExists,unExp[]);
                                       (if unexpandedExists then
                                       (* newLine;
                                        'Notice that nonterminals still exist in the '
                                        ->help[];
                                        current.name[]->help.putText;
                                        ' fragment form.'->help.putLine;
                                        'This fragment group cannot be compiled before all nonterminals are removed'
                                        ->help.putText;
                                        help[]
                                        ->putLine*) (* UI.statusmessage*)
                                           ; leave thisOperation
                                       if)
                                   if);
                                   
                                #);
                              
                          if)
                      if);
                      
                  if)
               #);
             
          #);
        
     do
        (if (touched > 0) then
            (if isReadOnly then
                (none ,'This file is read-only','Save')->UI.alertUser
             else
                true->OKtoSave;
                fg.textFileName->textFile[]->f.name;
                (if f.entry.exists then
                (* this check should be in prettyprint fragment?? *)
                    (if f.entry.modtime > fg.modtime then
                        'The file '->msg[];
                        textFile[]->msg.putLine;
                        'has been changed by another tool!\n\n'->msg.append;
                        'Overwrite?'->msg.append;
                        (none ,'Save',msg[])
                          ->UI.promptForBoolean
                            (#
                               ok::<  (#  do true->OKtoSave #);
                               notOK::< 
                                 (# 
                                 do
                                    false->OKtoSave;
                                    resetGroupTouch;
                                    fg[]->editorenvPrivate.deleteAutoSaveFile;
                                    fg[]->ymerCallBack.onGroupNotSaved;
                                    (none ,
                                     'Please leave the editor immediately!\nand then start it again',
                                     'Save')->UI.alertUser
                                 #);
                               cancel::<  (#  do false->OKtoSave #);
                               
                            #)
                     else
                        true->OKtoSave
                    if)
                 else
                    true->OKtoSave
                if);
                (if OKtoSave then
                    doCommand
                      (# 
                      do
                         'Saving...'->ymerCallBack.infoView;
                         doSave;
                         true->groupSaved;
                         (if OK and doUpdateTextFile then
                             fg[]->makeNewTextFile
                         if);
                         ymerCallBack.infoViewDone
                      #)
                if)
            if)
        if);
        
     #)  

-- groupeditorSaveAs: DoPart --
do
   loop:
     (# f: @file; t,msg: ^text
     do
        UI.fileCreationDialog->t[];
        (if t[] <> none then
            t[]->f.name;
            f.name->editorenvPrivate.stripExtension->f.name;
            (if f.name->editorenvPrivate.fileWriteable then
                doCommand
                  (# 
                  do
                     'Saving group as '->msg[];
                     f.name->newName[]->msg.append;
                     '...'->msg.append;
                     msg[]->ymerCallBack.infoView;
                     (*  fg[]->editorenvPrivate.ASTGC;
                      no do not do this until it is possible to close a fg in ymer *)
                     (*fg[]->editorenvprivate.recomputeSLOTchain; not necessary after AST GC *)
                     newName[]->mps.expandToFullPath->fg.saveAs;
                     (* to avoid save prompt! :*)
                     resetGroupTouch;
                     fg[]->editorenvPrivate.deleteAutoSaveFile;
                     fg[]->ymerCallBack.onGroupNotSaved;
                     ymerCallBack.infoViewDone;
                     
                  #)
             else
                (none ,'No write permission','Save As')->UI.alertUser;
                restart loop
            if)
        if)
     #)  

-- groupeditorSaveAbstract: DoPart --
do
   loop:
     (# t: ^text; 
     do
        UI.fileCreationDialog->t[];
        (if (t[] <> none ) and (t.length > 0) then
            (if t[]->editorenvPrivate.fileWriteable then
                doCommand
                  (# 
                  do
                     'Save Abstract...'->ymerCallBack.infoView;
                     (mps[],fg[],none ,t[])
                       ->prettyprintFragment
                         (# (*width:: (# do 100->value #) ;*)
                            abstractPresentation::< trueObject
                         #);
                     ymerCallBack.infoViewDone
                  #)
             else
                (none ,'No write permission','Save Abstract')->UI.alertUser;
                restart loop
            if)
        if)
     #)  

-- groupeditorAutoSave: DoPart --
do ('#',fg[])->editorenvPrivate.extendedSaveBackup  

-- groupeditorRecover: DoPart --
do (* is done in ymersiflib *)   

-- groupeditorRevert: DoPart --
do (* is done in ymersiflib *)   

-- groupeditorResetGroupTouch: DoPart --
do 0->touched; formEditorList.scan (#  do current.resetFragmentTouch #);   

-- groupeeditorGroupTouched: DoPart --
do
   (if not isReadOnly then touched+1->touched;  if);
   (if touched = 1 (* only first time *) then
       (if (grammarName[] <> none ) then
           (if ('beta'->grammarName.equal) then
               (false,mps[],fg[])->setDoneCheckProperty;
               fg[]->ymerCallBack.onGroupTouched;
               
           if);
           
       if);
       
   if);
   (if trace[7] then
       fg.name->putText;
       ' group touched '->putText;
       touched->putint;
       ' times'->putLine;
       
   if);
     

-- groupeditorGroupDetouched: DoPart --
do
   touched-1->touched;
   (if trace[7] then
       fg.name->putText; ' group touched '->putText; ' times'->putLine; 
   if)  

-- groupeditorMyAddFragment: DoPart --
do
   loop:
     (# before: ^g.fragmentList.theCellType; newname,mess: ^text
     do
        true->status;
        loop2: g.fragmentlist.scan
          (# 
          do
             (if f.name->current.name.equalNCS then
                 false->status; leave loop2
             if)
          #);
        (if not status then
            (f.name).copy->mess[];
            ' already exists'->mess.append;
            (f.name).copy->newname[];
            'Copy'->newName.append;
            newName[]->f.name;
            mess[]->putline;
            restart loop;
            
        if);
        (if beforeElement[] = none then
            (f[])->g.fragmentList.addFragment; 
         else
            beforeElement[]->g.fragmentList.at->before[];
            (f[],before[])->g.fragmentList.insertFragmentBefore;
            
        if)
     #);
     

-- groupeditorGetFragmentListElement: DoPart --
do
     (# found: @boolean
     do
        (if ff[] <> none then
            search: fg.fragmentlist.scan
              (# 
              do
                 (if current.type = mps.formtype then
                     (if current.f[] = ff[] then
                         current[]->fle[]; true->found; leave search
                     if)
                 if)
              #);
            (if not found then
                'getFragmentList: '->putText;
                ff.name->putText;
                ' fragmentForm not found'->putLine
            if)
        if)
     #)  

-- groupeditorAskUndoPermission: DoPart --
do false->value  

-- groupeditorAskPastePermission: DoPart --
do (clippedFrag[] <> none )->value  

-- groupeditorAskInsertPermission: DoPart --
do true->value  

-- groupeditorUndo: DoPart --
do   

-- groupeditorCutForm: DoPart --
do
     (#
        fle: ^fg.fragmentListElement;
        theGrammar: ^astInterface.treelevel;
        (* fe: ^formEditor*)
        
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            ff.grammar[]->mps.newFragmentForm->clippedFrag[];
            clippedFrag[]->ff.root.copy->clippedFrag.root[];
            ff.name->clippedFrag.name;
            (* ff[]->groupEditorList.findFormEditor->fe[];
             (if (fe[] <> none ) // true then fe.sdeC.editorWindow.close if);*)
            ff.name->fg.fragmentList.deleteLocalName;
            (true,ff[])->fragmentDeleted
        if)
     #)  

-- groupeditorCopyForm: DoPart --
do
   ff.grammar[]->mps.newFragmentForm->clippedFrag[];
   clippedFrag[]->ff.root.copy->clippedFrag.root[];
   (ff.name).copy->clippedFrag.name  

-- groupeditorPasteForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; pasteFrag: ^astInterface.fragmentForm
     do
        clippedFrag.grammar[]->mps.newFragmentForm->pasteFrag[]->newff[];
        pasteFrag[]->clippedFrag.root.copy->pasteFrag.root[];
        (clippedFrag.name).copy->pasteFrag.name;
        ff[]->getFragmentListElement->fle[];
        (if ((fg[],pasteFrag[],fle[])->myAddFragment) then
            (true,pasteFrag[])->fragmentInserted
        if)
     #)  

-- groupeditorInsertForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; t: ^text; doParse: @boolean
     do
        (none ,'Insert New Fragment Form','Enter fragment form name','')
          ->promptForText
            (#
               ok::< 
                 (# 
                 do
                    ('beta',screen[])->mps.grammarTable.find
                      ->mps.newFragmentForm->newff[];
                    userText[]->newff.name;
                    (if synCatNo
                     // 2 (*descriptorForm*) then
                        '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 3 (*attributesForm*) then
                        '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                          ->t[];
                        true->doParse;
                        
                     // 31 (*doPart*) then
                        'do <<ImpOpt>>'->t[]; true->doParse; 
                    if);
                    (if doParse
                     // true then
                        t.reset;
                        (synCatNo,t[],screen[],newff[])
                          ->betaGrammar.parser.doParse;
                        
                    if);
                    ff[]->getFragmentListElement->fle[];
                    (if ((fg[],newff[],fle[])->myAddFragment) then
                        (true,newff[])->fragmentInserted; 
                    if)
                 #)
            #);
        
     #)  

-- groupeditorEditProperties: DoPart --
do
     (#
        propGroup: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        thePropertyWindow: ^propertyWindow;
        propertyWindow: window
          (#
             editor: @sifTextEditor (# codeViewerType::< propertyEditor #);
             File: @mySimpleMenu
               (#
                  iClose: @item
                    (#
                       onSelect:: 
                         (# 
                         do thePropertyWindow.close; none ->thePropertyEditor[]
                         #)
                    #);
                  open::  (#  do ('Close','w')->iClose.newKey #)
               #);
             Edit: @codeEditorEditMenu
               (#
                  iSearch: @item
                    (#
                       onStatus::  (#  do allowCommand->value #);
                       onSelect::  (#  do cfe.doSearch #)
                    #);
                  iReplace: @item
                    (#
                       onStatus:: 
                         (# 
                         do
                            (if formEditorExists then
                                not cfe.texteditMode and not cfe.isReadOnly
                                  ->value
                             else
                                false->value
                            if)
                         #);
                       onSelect::  (#  do cfe.doReplace #)
                    #);
                  iReprettyprint: @item
                    (#
                       onStatus::  (#  do allowCommand->value #);
                       onSelect::  (#  do cfe.doReprettyprint;  #)
                    #);
                  open:: 
                    (# 
                    do
                       newSeparator;
                       ('Search...','s')->iSearch.newKey;
                       ('Replace...','r')->iReplace.newKey;
                       newSeparator;
                       ('Reprettyprint','p')->iReprettyprint.newKey;
                       
                    #)
               #);
             menubarType:: 
               (#
                  open:: 
                    (# 
                    do File.new; File[]->append; Edit.new; Edit[]->append; 
                    #)
               #);
             open:: 
               (#
                  ff: ^astInterface.fragmentForm;
                  node: ^astInterface.ast;
                  help: ^text;
                  ped: ^propertyeditor
               enter node[]
               do
                  (if node[] <> none then
                      ((node.frag.father).name).copy->help[];
                      help.length->help.pos;
                      '-'->help.put;
                      node.frag.name->help.putText;
                      help[]->title;
                      editor.open;
                      (mps[],propertyGrammar[],node.frag.root[],node[])
                        ->editor.newfragment->ped[]->thePropertyEditor[];
                      (if ped[] <> none then
                          THIS(GroupEditor)[]->ped.theGroupEditor[];
                          ped[]->Edit.attach
                       else
                          'no propertyeditor created!'->putLine
                      if);
                      editor.size->size;
                      true->editor.bindBottom->editor.bindRight
                   else
                      'propertyWindow: node is none! '->putLine
                  if);
                  
               #);
             close::  (#  do none ->thePropertyEditor[] #);
             
          #);
        
     do
        (if thePropertyEditor[] <> none then
            (thePropertyEditor.theSifTextEditor.theWindow).bringToFront
         else
            fg[]->editorenvPrivate.propsToAst->propGroup[];
            l: propGroup.fragmentList.scan
              (# 
              do
                 (if current.type = mps.formType then
                     current.f[]->ff[]; leave l
                 if)
              #);
            (* prettyprint property list
             * and parse corresponding to the 
             * property grammar
             *)
            (if ff[] <> none then
                &propertyWindow[]->thePropertyWindow[];
                ff.root[]->thePropertyWindow.open
             else
                'editProperties: ff is none'->putLine
            if)
        if)
     #)  

-- groupeditorCreatePropertyEditor: DoPart --
do   

-- groupeditorEditFormName: DoPart --
do
     (# fle: ^fg.fragmentListElement
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            (none ,'Edit Fragment Form Name','Enter New Name               ',
             fle.name[])
              ->promptForText
                (#
                   ok::< 
                     (# 
                     do
                        userText[]->fle.name[]->fle.f.name;
                        (true,fle.f[])->fragmentChanged
                     #)
                #)
        if)
     #)  

-- groupeditorSearchSlot: Descriptor --
(#
   slotName: ^text;
   searchFrag: ^astInterface.fragmentGroup;
   originName,help,path,name2: ^text;
   fg2: ^astInterface.fragmentGroup;
   found: @boolean;
   
do
   ff.name->slotName[];
   'Searching for the SLOT definition of '''->putText;
   slotName[]->putText;
   ''' in:'->putLine;
   fg[]->searchFrag[];
   searchSlot: searchFrag.prop.scanProp
     (#
        doProp::< 
          (# 
          do
             (if true
              // ('ORIGIN'->prop.equalNCS) then
                 getString->originName[];
                 (if (originName.length > 0) then
                     originName[]->putLine;
                     searchFrag.fullName->editorenvPrivate.splitPath
                       ->(path[],name2[]);
                     (originName[],path[])
                       ->mps.thePathHandler.convertFilePath->help[];
                     (* (help[],screen[]) ->mps.top.open->fg2[];*)
                     help[]->ymerCallBack.getFragmentGroup->fg2[];
                     (if fg2[]=none then
                         ' could not be opened '->help.putText;
                         help[]->putLine;
                         (*(none ,help[],'Search SLOT')->UI.alertUser;*)
                         
                      else
                         l: fg2.scanSlots
                           (# 
                           do
                              (if (current.Name->slotName.equalNCS)
                               // true then
                                  true->found;
                                  current.father->theSlotNode[];
                                  leave l
                              if)
                           #);
                         (if found
                          // false then
                             fg2[]->searchFrag[];
                             ''->originName[];
                             restart searchSlot
                         if);
                         
                     if);
                     
                  else
                     'Could not find the SLOT '''->help[];
                     slotName[]->help.putText;
                     ''' in the ORIGIN chain'->help.putText;
                     (none ,help[],'Follow Link To SLOT')->UI.alertUser;
                     
                 if)
             if);
             
          #)
     #);
   
#)  

-- groupeditorCompilerSavedGroup: Descriptor --
(# 
do
   (if touched > 0 then
       true->needToUpdateTextFile;
       fg[]->editorenvPrivate.deleteAutoSaveFile;
       fg[]->editorenvPrivate.backupTextFile;
       resetGroupTouch
   if)
#)  

-- groupeditorNotificationPrivate: Descriptor --
(#
   refresh:
     (# 
     do
        (if ymerCallBack[] <> none then
            (theBrowser[],fg[])->ymerCallback.refreshGroup; 
         else
            'ymercallback is none!!'->putLine
        if)
     #)
#)  

-- groupeditorGroupChanged: DoPart --
do
   groupTouched;
   (if byMe and (frejaInterface[] = none ) then autoSave if);
   INNER GroupChangedEvent  

-- groupeditorPropertiesChanged: Descriptor --
(# 
do
   (if trace[7] then
       '----- groupeditorPropertiesChanged '->putText;
       fg.name->putText;
       ' '->put;
       no->putInt;
       (if byMe then ' byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       THIS(groupeditor)[]->fgh.propertiesChanged
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorFragmentChanged: Descriptor --
(# 
do
   (if trace[7] then
       '----- groupeditorFragmentChanged '->putText;
       fg.name->putText;
       ' '->put;
       no->putInt;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       (THIS(groupeditor)[],ff[])->fgh.fragmentChanged
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorFragmentInserted: Descriptor --
(# 
do
   (if trace[7] then
       '----- groupeditorFragmentInserted '->putText;
       fg.name->putText;
       ' '->put;
       no->putInt;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       (THIS(groupeditor)[],ff[])->fgh.fragmentInserted
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorFragmentDeleted: Descriptor --
(# 
do
   (if trace[7] then
       '----- groupeditorFragmentDeleted '->putText;
       fg.name->putText;
       ' '->put;
       no->putInt;
       (if byMe then 'byMe'->putText if);
       newLine;
       
   if);
   (if byMe then
       groupeditorNotificationPrivate.refresh;
       (THIS(groupeditor)[],ff[])->fgh.fragmentDeleted
    else
       groupeditorNotificationPrivate.refresh
   if)
#)  

-- groupeditorGroupSaved: DoPart --
do (if byMe then THIS(groupEditor)[]->fgh.groupSaved else resetGroupTouch if)  

