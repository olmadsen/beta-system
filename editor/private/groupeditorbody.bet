ORIGIN '../codeeditor';
INCLUDE 'editorenvbody'
        '~beta/betaast/donecheck'
        '~beta/mps/property'
        '~beta/sysutils/objinterface';
LIB_ITEM 'editorcodeeditor';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
-- canvasLib: Attributes --
getWindow: (#  exit THIS(Window)[] #);   

-- groupeditorSetIsReadOnly: DoPart --
do
   (if value then
       true->isReadOnly;
       formEditorList.scan
         (#  do true->current.setIsReadOnly #)
    else
       (if groupfileWriteable then (* only allow editing if file is writeable *)
           false->isReadOnly;
           formEditorList.scan
             (#  do false->current.setIsReadOnly #)
       if)
   if)  

-- groupeditorFGtitle: DoPart --
do
     (# pos: @integer
     do
        (fg.name).copy->fgName[];
        directoryChar->fgName.findAll (#  do inx->pos #);
        (if pos > 0 then (pos+1,fgName.length)->(fg.name).sub->fgName[] if)
     #)  

-- groupeditorFormeditorListFindOrCreateEditor: DoPart --
do
   ff[]->findEditor->fe[];
   (if trace[2] then
       (if fe[] = none then 'creating formeditor'->putLine;  if)
   if)  

-- groupeditorFormeditorListFindEditor: DoPart --
do
   search: scan
     (# 
     do
     (*  testing (if current.frag.name->(ff.name).equal then
      current[]->fe[]; 'found equal by name'->putline
      if);*)
        (if current.frag[] // ff[] then current[]->fe[]; leave search if)
     #)  

-- groupeditorFormeditorListFindEditorId: DoPart --
do
   search: scan
     (# 
     do (if current.id // id then current[]->fe[]; leave search if)
     #)  

-- groupeditorCloseGroup: DoPart --
do
     (#
        position: ^groupEditorList.theCellType;
        OKtoClose,askSave: @boolean;
        help: ^text;
        pos: @integer;
        f: @file;
        cleanUp:
          (# 
          do
             fgObserver[]->fg.detachObserver;
             formEditorList.scan
               (#  do current.closeForm #);
             position[]->groupEditorList.delete;
             fg.notifyGroupClosed
          #);
        test:
          (# 
          do
             'groupEditorList: '->putText;
             groupEditorList.size->putInt;
             newLine;
             groupEditorList.scan
               (#  do current.fg.name->putLine;  #)
          #)
     do (*'before '->putText;
         test;*)
        (if (THIS(groupEditor)[]->groupEditorList.at->position[]) <> none then
            (if trace[2] then
                'GroupEditor.CloseGroup before: '->putText;
                fg.name->putLine;
                'touched: '->putText;
                touched->putInt;
                newLine;
                showEditors;
                
            if);
            (* obsolete fg[]->ymerCallBack.onAboutToCloseGroup->(OKtoClose,askSave);
             (if OKtoClose then  else false->value if);
             (if askSave then
             <<ImpOpt>>
             else
             (true,true,true)->save; true->value; cleanup
             if);
             *)
            (if touched > 0 then
                'Save changes to '->help[];
                fg.name->help.putText;
                '?'->help.put;
                (none ,'Close group',help[])
                  ->UI.promptForBoolean
                    (#
                       ok::< 
                         (# 
                         do
                            (if (true,true,true)->save then
                                true->value; cleanup
                            if)
                         #);
                       notOK::< 
                         (# 
                         do
                            true->value;
                            fg[]->editorenvPrivate.deleteAutoSaveFile;
                            fg.notifyGroupNotSaved;
                            0->touched;
                            cleanUp
                         #);
                       cancel::<  (#  do false->value #);
                       
                    #)
             else
                doCommand
                  (# 
                  do (* in the case all changes have been undone: *)
                     (if needToUpdateTextFile then fg[]->makeNewTextfile if);
                     fg[]->editorenvPrivate.deleteAutoSaveFile;
                     fg.notifyCloseUntouchedGroup;
                     true->value;
                     (* in the case all changes have been undone: *)
                     cleanUp
                  #)
            if)
         else
            (if trace[2] then
                'GroupEditor.CloseGroup: already closed!!!'->putText;
                fg.name->putLine;
                
            if);
            true->value
        if);
        (if trace[2] then
            'GroupEditor.CloseGroup after: '->putText;
            fg.name->putLine;
            showEditors;
            
        if);
        (*'after '->putText;
         test;*)
        
     #)  

-- groupeditorSave: DoPart --
do
     (#
        f,autosaveFile: @file;
        ff: ^astInterface.fragmentForm;
        textFile,tildeTextFile,gname,msg,help: ^text;
        pos: @integer;
        OKtoSave: @boolean;
        doSave:
          (# 
          do
             thisOperation:
               (# help: ^text; 
               do
                  (if doGC then
                      fg[]->editorenvprivate.ASTGC
                   else
                  (* only necessary if not AST GC is performed *)
                      fg[]->editorenvprivate.recomputeSLOTchain
                  if);
                  fg[]->editorenvPrivate.backupGroupFile;
                  (fg[],true)->editorenvPrivate.extendedMarkAsChanged->OK;
                  (if not OK then
                      fg[]->editorenvPrivate.restoreGroupFile;
                      leave thisOperation
                  if);
                  (if doDeleteAutoSaveFile then
                      fg[]->editorenvPrivate.deleteAutoSaveFile
                   else
                      fg.diskFileName->help[];
                      '#'->help.put;
                      help[]->autoSaveFile.Name;
                      (if autoSaveFile.entry.exists then
                          fg.modtime+120
                            ->
                              autosaveFile.entry.modtime
                              (* because then the user will be prompted for recovery if the crash should happen again
                               and the editor is entered again on the same file *)
                      if)
                  if)
               #);
             
          #);
        
     do
        (if (touched > 0) then
            (if isReadOnly then
                (none ,'This file is read-only','Save')->UI.alertUser
             else
                true->OKtoSave;
                fg.textFileName->textFile[]->f.name;
                (if f.entry.exists then
                (* this check should be in prettyprint fragment?? *)
                    (if f.entry.modtime > fg.modtime then
                        'The file '->msg[];
                        textFile[]->msg.putLine;
                        'has been changed by another tool!\n\n'->msg.append;
                        'Overwrite?'->msg.append;
                        (none ,'Save',msg[])
                          ->UI.promptForBoolean
                            (#
                               ok::<  (#  do true->OKtoSave #);
                               notOK::< 
                                 (# 
                                 do
                                    false->OKtoSave;
                                    resetGroupTouch;
                                    fg[]->editorenvPrivate.deleteAutoSaveFile;
                                    fg.notifyGroupNotSaved;
                                    (none ,
                                     'Please leave the editor immediately!\nand then start it again',
                                     'Save')->UI.alertUser
                                 #);
                               cancel::<  (#  do false->OKtoSave #);
                               
                            #)
                     else
                        true->OKtoSave
                    if)
                 else
                    true->OKtoSave
                if);
                (if OKtoSave then
                    doCommand
                      (# t: ^text
                      do
                         'Saving '->t[];
                         fg.name->t.append;
                         '...'->t.append;
                         t[]->ymerCallBack.infoView;
                         t[]->putLine;
                         doSave;
                         (*'checkAutoSave in groupeditorbody-groupeditorSave'
                          ->putLine;*)
                         fg.notifyGroupSaved;
                         (if OK and doUpdateTextFile then
                             fg[]->makeNewTextFile
                         if);
                         ymerCallBack.infoViewDone
                      #)
                if)
            if)
         else
            (if needToUpdateTextFile then fg[]->makeNewTextFile if)
        if)
     #)  

-- groupeditorSaveAs: DoPart --
do
   loop:
     (#
        f: @file;
        t,msg: ^text;
        theDefaultGrammar: ^mps.treeLevel;
        nameOK,OK: @boolean
     do
        none ->t[];
        UI.fileCreationDialog
          (# 
          do 'Save \''->title[]; fgTitle->title.append; '\' as'->title.append
          #)->t[];
        (if (t[] <> none ) and (t.length > 0) then
            true->nameOK;
            checkName: t.scanAll
              (# 
              do
                 (if (ch->ascii.isWhiteSpace) or (ch->ascii.isSpace) then
                     false->nameOK; leave checkName
                 if)
              #);
            (if nameOK then
                t[]->editorenvPrivate.stripExtension->newName[]->f.name;
                mps.astFileExtension->(f.name).append->f.name;
                (if f.name->editorenvPrivate.fileWriteable then
                    doCommand
                      (# 
                      do
                         'Saving group as '->msg[];
                         newName[]->msg.append;
                         '...'->msg.append;
                         msg[]->ymerCallBack.infoView;
                         fg.defaultGrammar[]->theDefaultGrammar[];
                         true->OK;
                         (*  fg[]->editorenvPrivate.ASTGC;
                          no do not do this until it is possible to close a fg in ymer *)
                         (*fg[]->editorenvprivate.recomputeSLOTchain; not necessary after AST GC *)
                         newName[]->mps.expandToFullPath
                           ->fg.saveAs
                             (#
                                writeAccessError::< 
                                  (# 
                                  do
                                       (# msg: ^text
                                       do
                                          (if true (*feedback then*) then
                                              'Write access error: '->msg;
                                              fg.fullName->msg.append;
                                              (none ,msg[],'Save As')
                                                ->UI.alertUser
                                          if);
                                          true->continue;
                                          false->OK
                                       #)
                                  #);
                                noSpaceLeftError::< 
                                  (# 
                                  do
                                     (if true (*feedback*) then
                                         (none ,'Disk is full','Save As')
                                           ->UI.alertUser
                                     if);
                                     true->continue;
                                     false->OK
                                  #);
                                otherFileError::< 
                                  (# 
                                  do
                                     (if true (*feedback*) then
                                         (none ,
                                          'Other error, probably disk full, please check',
                                          'Save As')->UI.alertUser
                                     if);
                                     true->continue;
                                     false->OK
                                  #)
                             #);
                         (if OK then
                             resetGroupTouch;
                             theDefaultGrammar[]->fg.defaultGrammar[];
                             fg[]->editorenvPrivate.deleteAutoSaveFile;
                             fg[]->makeNewTextFile;
                             ymerCallBack.infoViewDone
                          else
                             restart loop
                         if);
                         (* to avoid save prompt! :*)
                         (*fg.notifyCloseUntouchedGroup;*)
                         
                      #)
                 else
                    none ->newName[];
                    (none ,'No write permission','Save As')->UI.alertUser;
                    restart loop
                if)
             else
                none ->newName[];
                (none ,'Invalid file name','Save As')->UI.alertUser;
                restart loop
            if)
        if)
     #)  

-- groupeditorSaveAbstract: DoPart --
do
   loop:
     (# t: ^text; 
     do
        UI.fileCreationDialog
          (#  do 'Save abstraction level on text file'->title[] #)->t[];
        (if (t[] <> none ) and (t.length > 0) then
            (if t[]->editorenvPrivate.fileWriteable then
                doCommand
                  (# 
                  do
                     'Save Abstract...'->ymerCallBack.infoView;
                     (mps[],fg[],none ,t[])
                       ->prettyprintFragment
                         (# (*width:: (# do 100->value #) ;*)
                            abstractPresentation::< trueObject
                         #);
                     ymerCallBack.infoViewDone
                  #)
             else
                (none ,'No write permission','Save Abstract')->UI.alertUser;
                restart loop
            if)
        if)
     #)  

-- groupeditorCheckAutoSave: DoPart --
do
   fg.notifyTouched;
   (* ess 990707: No not anymore after the integration (if frejaExternalInterface[] = none then*)
   autoSave
   (*if)*)  

-- groupeditorAutoSave: DoPart --
do ('#',fg[])->editorenvPrivate.extendedSaveBackup; fg.notifyGroupAutosaved  

-- groupeditorRecover: DoPart --
do (* is done in ymersiflib *)   

-- groupeditorRevert: DoPart --
do (* is done in ymersiflib *)   

-- groupeditorNonterminalsExist: Descriptor --
(#
   nonterminalsExistInForm:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExist: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExist;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExist; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExist; ff.root[]->unExp[]
        if);
        
     exit (unexpandedExist,unExp[])
     #);
   
do
   thisOperation:
   (if fg[] = none then
       'groupeditor.nonterminalsExists: fg is none'->putLine; 
    else
       fg.fragmentlist.scan
         (# help: ^text; 
         do
            (if current.type = mps.formType then
                (if current.f[] = none then screen[]->current.open if);
                (*current.f[]->ff[];
                 ff.recomputeSlotChain;*)
                current.f[]->nonterminalsExistInForm->(unexpandedExist,unExp[]);
                (if unexpandedExist then leave thisOperation if)
            if);
            
         #);
       fg[]->editorenvPrivate.recomputeSLOTchain
   if);
   
#)  

-- groupeditorAddProp: DoPart --
do
     (#
        doUpdate: @boolean;
        l: ^astInterface.fragmentGroup.prop.proplist.element;
        par: ^parElement;
        val: ^stringElement;
        propfg: ^astInterface.fragmentGroup;
        propff: ^astInterface.fragmentForm;
        OK,done,alreadyExists: @boolean
     do
        (if fg.prop[] <> none then
            propName[]->fg.prop.findProp->l[];
            (if l[] <> none then
                l.par.scan
                  (# 
                  do
                     current[]->par[];
                     (if par.type = stringType then
                         par.val[]->val[];
                         (if val.s[]->propString.equal then
                             true->alreadyExists; true->done
                         if)
                     if)
                  #);
                (if not alreadyExists then
                    &parElement[]->par[];
                    &stringElement[]->par.val[]->val[];
                    stringType->par.type;
                    propString->val.s;
                    par[]->l.par.append;
                    true->done;
                    true->doUpdate
                if)
            if);
            (if not done then
                propName[]
                  ->fg.prop.addProp
                    (# ifPropExist::  (#  do propExists->delete #)
                    do propString[]->addString; true->doUpdate
                    #)
            if);
            (if doupdate then
                (if 'include'->propName.equalNCS then
                    none ->fg.linkList[]
                if);
                checkAutoSave;
                fg.notifyPropertiesChanged
            if)
         else
            'groupEditor.addProp: '->putText;
            fg.name->putText;
            ' fg.prop is none!!'->putLine
        if)
     #)  

-- groupeditorDeleteProp: DoPart --
do
     (#
        p: ^propertyList.propList.element;
        tc: ^propertyList.propList.theCellType;
        doupdate,OK: @boolean;
        propfg: ^astInterface.fragmentGroup;
        propff: ^astInterface.fragmentForm;
        par: ^parElement;
        val: ^stringElement
     do
        (if fg.prop[] <> none then
            propName[]->fg.prop.findProp->p[];
            (if p[] <> none then (* check also the property list! *)
                parscan: p.par.scan
                  (# 
                  do
                     current[]->par[];
                     (if par.type = stringType then
                         par.val[]->val[];
                         (if val.s[]->propString.equal then
                             current[]->p.par.at->p.par.delete;
                             true->doupdate;
                             leave parscan
                         if)
                     if)
                  #)
            if);
            (if doupdate then
                (if 'include'->propName.equalNCS then
                    none ->fg.linkList[]
                if);
                checkAutoSave;
                fg.notifyPropertiesChanged
             else
                propNotFound
            if)
         else
            'groupEditor.deleteProp: '->putText;
            fg.name->putText;
            ' fg.prop is none!!'->putLine
        if)
     #)  

-- groupeditorResetGroupTouch: DoPart --
do
   (if trace[7] then
       fg.name->putText;
       '  touched reset, was touched '->putText;
       touched->putInt;
       ' times'->putLine;
       
   if);
   touched->oldTouched;
   0->touched;
   formEditorList.scan
     (#  do current.resetFragmentTouch #);
     

-- groupeeditorGroupTouched: DoPart --
do
   (if not isReadOnly then touched+1->touched;  if);
   (if touched = 1 (* only first time *) then
       (if (grammarName[] <> none ) then
           (if ('beta'->grammarName.equal) then
               (false,mps[],fg[])->setDoneCheckProperty;
               fg[]->ymerCallBack.onGroupTouched;
               
           if);
           
       if);
       
   if);
   (if trace[7] then
       fg.name->putText;
       ' group touched '->putText;
       touched->putint;
       ' times'->putLine;
       
   if);
     

-- groupeditorGroupDetouched: DoPart --
do
   touched-1->touched;
   fg[]->ymerCallBack.onGroupDetouched;
   (if trace[7] then
       fg.name->putText;
       ' group touched '->putText;
       touched->putInt;
       ' times'->putLine;
       
   if)  

-- groupeditorMyAddFragment: DoPart --
do
     (# namecollision: @boolean; 
     do
        loop:
          (# before: ^g.fragmentList.theCellType; newname,mess: ^text
          do
             true->status;
             loop2: g.fragmentlist.scan
               (# 
               do
                  (if f.name->current.name.equalNCS then
                      false->status; leave loop2
                  if)
               #);
             (if not status then
                 (f.name).copy->mess[];
                 ' already exists'->mess.append;
                 (f.name).copy->newname[];
                 'Copy'->newName.append;
                 newName[]->f.name;
                 mess[]->putline;
                 true->nameCollision;
                 restart loop
             if);
             (if beforeElement[] = none then
                 (f[])->g.fragmentList.addFragment
              else
                 beforeElement[]->g.fragmentList.at->before[];
                 (f[],before[])->g.fragmentList.insertFragmentBefore
             if)
          #);
        (if namecollision then f[]->editFormName if)
     #)  

-- groupeditorGetFragmentListElement: DoPart --
do
     (# found: @boolean
     do
        (if ff[] <> none then
            search: fg.fragmentlist.scan
              (# 
              do
                 (if current.type = mps.formtype then
                     (if current.f[] = ff[] then
                         current[]->fle[]; true->found; leave search
                     if)
                 if)
              #);
            (if not found then
                'getFragmentList: '->putText;
                ff.name->putText;
                ' fragmentForm not found'->putLine
            if)
        if)
     #)  

-- groupeditorGetBrotherff: DoPart --
do
     (#
        found: @boolean;
        ffPos,nextPos:
          ^astInterface.fragmentGroup.fragmentListDescription.theCellType
     do
        (if ff[] <> none then
            search: fg.fragmentlist.scan
              (# 
              do
                 (if current.type = mps.formtype then
                     (if current.f[] = ff[] then
                         current[]->fg.fragmentlist.at->ffPos[];
                         true->found;
                         leave search
                     if)
                 if)
              #);
            (if not found then
                'getBrotherff: '->putText;
                ff.name->putText;
                ' fragmentForm not found'->putLine
            if);
            ffPos[]->nextPos[];
            loop: (* try right brother *)
            (if nextPos[] <> none then
                (if nextPos.succ[] <> none then
                    nextPos.succ[]->nextPos[];
                    (if nextPos.elm.type = mps.formtype then
                        nextPos.elm.f[]->brotherff[]
                     else
                        restart loop
                    if)
                 else
                    
                if)
            if);
            (if brotherff[] = none then
                ffPos[]->nextPos[];
                loop: (* try left brother *)
                (if nextPos[] <> none then
                    (if nextPos.pred[] <> none then
                        nextPos.pred[]->nextPos[];
                        (if nextPos.elm.type = mps.formtype then
                            nextPos.elm.f[]->brotherff[]
                         else
                            restart loop
                        if)
                     else
                        
                    if)
                if)
            if)
        if)
     #)  

-- groupeditorAskUndoPermission: DoPart --
do false->value  

-- groupeditorAskPastePermission: DoPart --
do (clippedFrag[] <> none )->value  

-- groupeditorAskInsertPermission: DoPart --
do true->value  

-- groupeditorUndo: DoPart --
do   

-- groupeditorCutForm: DoPart --
do
     (#
        fle: ^fg.fragmentListElement;
        theGrammar: ^astInterface.treelevel;
        (* fe: ^formEditor*)
        
     do
        ff[]->getFragmentListElement->fle[];
        ff[]->getBrotherff->brotherff[];
        (if fle[] <> none then
            ff.grammar[]->mps.newFragmentForm->clippedFrag[];
            clippedFrag[]->ff.root.copy->clippedFrag.root[];
            ff.name->clippedFrag.name;
            ff.name->fg.fragmentList.deleteLocalName;
            checkAutoSave;
            ff[]->fg.notifyFragmentDeleted
        if)
     #)  

-- groupeditorCopyForm: DoPart --
do
   ff.grammar[]->mps.newFragmentForm->clippedFrag[];
   clippedFrag[]->ff.root.copy->clippedFrag.root[];
   (ff.name).copy->clippedFrag.name  

-- groupeditorPasteForm: DoPart --
do
     (# fle: ^fg.fragmentListElement; pasteFrag: ^astInterface.fragmentForm
     do
        clippedFrag.grammar[]->mps.newFragmentForm->pasteFrag[]->newff[];
        pasteFrag[]->clippedFrag.root.copy->pasteFrag.root[];
        (clippedFrag.name).copy->pasteFrag.name;
        ff[]->getFragmentListElement->fle[];
        (if ((fg[],pasteFrag[],fle[])->myAddFragment) then
            checkAutoSave; pasteFrag[]->fg.notifyFragmentInserted
        if)
     #)  

-- groupeditorInsertForm: DoPart --
do
     (#
        fle: ^fg.fragmentListElement;
        theTitle,aText: ^text;
        doParse: @boolean
     do
        'Insert new fragment form in \''->theTitle[];
        fgTitle->theTitle.append;
        '\''->theTitle.append;
        (none ,theTitle[],
         'Enter fragment form name                                             ',
         '')
          ->promptForText
            (#
               ok::< 
                 (# 
                 do
                    ('beta',screen[])->mps.grammarTable.find
                      ->mps.newFragmentForm->newfragmentForm[];
                    userText[]->newfragmentForm.name;
                    (if synCatNo
                     // 2 (*descriptorForm*) then
                        '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                          ->aText[];
                        true->doParse;
                        
                     // 3 (*attributesForm*) then
                        '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                          ->aText[];
                        true->doParse;
                        
                     // 31 (*doPart*) then
                        'do <<ImpOpt>>'->aText[]; true->doParse; 
                    if);
                    (if doParse
                     // true then
                        t.reset;
                        (synCatNo,aText[],screen[],newfragmentForm[])
                          ->betaGrammar.parser.doParse;
                        
                    if);
                    afragmentForm[]->getFragmentListElement->fle[];
                    (if ((fg[],newfragmentForm[],fle[])->myAddFragment) then
                        checkAutoSave;
                        newfragmentForm[]->fg.notifyFragmentInserted;
                        
                    if)
                 #)
            #);
        
     #)  

-- groupeditorEditPropertiesCanvas: DoPart --
do
     (#
        property: @mps.property;
        propGroup: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        thePropertyCanvas: ^propertyCanvas;
        RealLocation:
          (# (* converts linknames relative to the group *)
             groupName: ^Text; s,t: ^Text; fg: ^astInterface.fragmentGroup
          enter (s[],fg[])
          do
             ff.father->fg[];
             (if fg[] <> none then
                 fg.fullName->mps.stripPathName->t[];
                 (if t[] <> none then
                     (s.copy,t[])->mps.thePathHandler.convertFilePath->s[]
                 if)
             if);
             
          exit s[]
          #);
        theWindow: ^window;
        propertyCanvas: theWindow.canvas
          (#
             eventhandler::< 
               (#
                  onActivate::< 
                    (#  do true->ymerCallBack.isActive; INNER #);
                  onDeactivate::< 
                    (#  do false->ymerCallBack.isActive; INNER #)
               #);
             editor: @theWindow.sifTextEditor
               (#
                  codeViewerType::< propertyEditor
                    (#
                       stringlist: ^property.stringlist;
                       handleDoubleClick:: 
                         (#
                            lex: ^astInterface.lexemtext;
                            exp: ^astInterface.expanded;
                            textcst: ^property.TextConst
                         do
                            (if cs.node.symbol
                             // mps.prodNo.string then
                                cs.node[]->lex[];
                                (lex.getText,fg[])->RealLocation
                                  ->ymerCallBack.selectFragmentGroup
                             // property.ORIGIN then
                                cs.node[]->exp[];
                                exp.getson1->textcst[];
                                textcst.getson1->lex[];
                                lex.getText->ymerCallBack.selectFragmentGroup
                             // property.INCLUDE // property.BODY then
                                cs.node[]->exp[];
                                exp.getson1->stringlist[];
                                stringlist.getson1->textcst[];
                                textcst.getson1->lex[];
                                (lex.getText,fg[])->RealLocation
                                  ->ymerCallBack.selectFragmentGroup
                            if)
                         #)
                    #)
               #);
             open:: 
               (#
                  ff: ^astInterface.fragmentForm;
                  node: ^astInterface.ast;
                  help: ^text;
                  ped: ^propertyeditor
               enter node[]
               do
                  father.size->size;
                  (if node[] <> none then
                      ((node.frag.father).name).copy->help[];
                      help.length->help.pos;
                      '-'->help.put;
                      node.frag.name->help.putText;
                      THIS(propertyCanvas)[]->editor.open;
                      (mps[],propertyGrammar[],node.frag.root[],node[])
                        ->editor.newfragment->ped[];
                      (if ped[] <> none then
                          THIS(GroupEditor)[]->ped.theGroupEditor[]
                       else
                          'no propertyeditor created!'->putLine
                      if);
                      size->editor.size;
                      true->editor.bindBottom->editor.bindRight;
                      editor.sifViewer[]->THIS(editPropertiesCanvas).editor[]
                   else
                      'propertyWindow: node is none! '->putLine
                  if)
               #);
             close::  (#  do none ->thePropertyEditor[] #)
          #)
     do
        fg[]->editorenvPrivate.propsToAst->propGroup[];
        l: propGroup.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[]; leave l
             if)
          #);
        (* prettyprint property list
         * and parse corresponding to the 
         * property grammar
         *)
        (if ff[] <> none then
            fatherCanvas.getWindow->theWindow[];
            &propertyCanvas[]->thePropertyCanvas[];
            (fatherCanvas[],ff.root[])->thePropertyCanvas.open;
            
         else
            'editProperties: ff is none'->putLine
        if)
     #)  

-- groupeditorEditProperties: DoPart --
do
     (#
        property: @mps.property;
        propGroup: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        thePropertyWindow: ^propertyWindow;
        RealLocation:
          (# (* converts linknames relative to the group *)
             groupName: ^Text; s,t: ^Text; fg: ^astInterface.fragmentGroup
          enter (s[],fg[])
          do
             ff.father->fg[];
             (if fg[] <> none then
                 fg.fullName->mps.stripPathName->t[];
                 (if t[] <> none then
                     (s.copy,t[])->mps.thePathHandler.convertFilePath->s[]
                 if)
             if);
             
          exit s[]
          #);
        propertyWindow: window
          (#
             eventhandler::< 
               (#
                  onActivate::< 
                    (#  do true->ymerCallBack.isActive; INNER #);
                  onDeactivate::< 
                    (#  do false->ymerCallBack.isActive; INNER #)
               #);
             editor: @sifTextEditor
               (#
                  codeViewerType::< propertyEditor
                    (#
                       stringlist: ^property.stringlist;
                       handleDoubleClick:: 
                         (#
                            lex: ^astInterface.lexemtext;
                            exp: ^astInterface.expanded;
                            textcst: ^property.TextConst
                         do
                            (if cs.node.symbol
                             // mps.prodNo.string then
                                cs.node[]->lex[];
                                (lex.getText,fg[])->RealLocation
                                  ->ymerCallBack.selectFragmentGroup
                             // property.ORIGIN then
                                cs.node[]->exp[];
                                exp.getson1->textcst[];
                                textcst.getson1->lex[];
                                lex.getText->ymerCallBack.selectFragmentGroup
                             // property.INCLUDE // property.BODY then
                                cs.node[]->exp[];
                                exp.getson1->stringlist[];
                                stringlist.getson1->textcst[];
                                textcst.getson1->lex[];
                                (lex.getText,fg[])->RealLocation
                                  ->ymerCallBack.selectFragmentGroup
                            if)
                         #)
                    #)
               #);
             File: @mySimpleMenu
               (#
                  iClose: @item
                    (#
                       onSelect:: 
                         (# 
                         do thePropertyWindow.close; none ->thePropertyEditor[]
                         #)
                    #);
                  open::  (#  do ('Close','w')->iClose.newKey #)
               #);
             Edit: @codeEditorEditMenu
               (#
                  iSearch: @item
                    (#
                       onStatus::  (#  do allowCommand->value #);
                       onSelect::  (#  do cfe.doSearch #)
                    #);
                  iReplace: @item
                    (#
                       onStatus:: 
                         (# 
                         do
                            (if formEditorExists then
                                not cfe.frag.locked (*texteditMode*) and not
                                cfe.isReadOnly->value
                             else
                                false->value
                            if)
                         #);
                       onSelect::  (#  do cfe.doReplace #)
                    #);
                  iReprettyprint: @item
                    (#
                       onStatus::  (#  do allowCommand->value #);
                       onSelect::  (#  do cfe.doReprettyprint;  #)
                    #);
                  open:: 
                    (# 
                    do
                       newSeparator;
                       ('Search...','s')->iSearch.newKey;
                       ('Replace...','r')->iReplace.newKey;
                       newSeparator;
                       ('Reprettyprint','p')->iReprettyprint.newKey;
                       
                    #)
               #);
             menubarType:: 
               (#
                  open:: 
                    (# 
                    do File.new; File[]->append; Edit.new; Edit[]->append; 
                    #)
               #);
             open:: 
               (#
                  ff: ^astInterface.fragmentForm;
                  node: ^astInterface.ast;
                  help: ^text;
                  ped: ^propertyeditor
               enter node[]
               do
                  (if node[] <> none then
                      ((node.frag.father).name).copy->help[];
                      help.length->help.pos;
                      '-'->help.put;
                      node.frag.name->help.putText;
                      help[]->title;
                      editor.open;
                      (mps[],propertyGrammar[],node.frag.root[],node[])
                        ->editor.newfragment->ped[]->thePropertyEditor[];
                      (if ped[] <> none then
                          THIS(GroupEditor)[]->ped.theGroupEditor[];
                          ped[]->Edit.attach
                       else
                          'no propertyeditor created!'->putLine
                      if);
                      editor.size->size;
                      true->editor.bindBottom->editor.bindRight
                   else
                      'propertyWindow: node is none! '->putLine
                  if);
                  
               #);
             close::  (#  do none ->thePropertyEditor[] #);
             
          #);
        
     do
        (if thePropertyEditor[] <> none then
            (thePropertyEditor.theSifTextEditor.theWindow).bringToFront
         else
            fg[]->editorenvPrivate.propsToAst->propGroup[];
            l: propGroup.fragmentList.scan
              (# 
              do
                 (if current.type = mps.formType then
                     current.f[]->ff[]; leave l
                 if)
              #);
            (* prettyprint property list
             * and parse corresponding to the 
             * property grammar
             *)
            (if ff[] <> none then
                &propertyWindow[]->thePropertyWindow[];
                ff.root[]->thePropertyWindow.open
             else
                'editProperties: ff is none'->putLine
            if)
        if)
     #)  

-- groupeditorCreatePropertyEditor: DoPart --
do   

-- groupeditorEditFormName: DoPart --
do
     (# fle: ^fg.fragmentListElement; oldName: ^text
     do
        ff[]->getFragmentListElement->fle[];
        (if fle[] <> none then
            fle.name.copy->oldName[];
            (none ,'Edit Fragment Form Name',
             'Enter New Name of Fragment Form                                          ',
             fle.name[])
              ->promptForText
                (#
                   ok::< 
                     (# 
                     do
                        userText[]->fle.name[]->fle.f.name;
                        checkAutoSave;
                        (fle.f[],oldName[],userText[])->fg.notifyNameChanged
                     #)
                #)
        if)
     #)  

-- groupeditorSearchSlot: Descriptor --
(#
   slotName: ^text;
   searchFrag: ^astInterface.fragmentGroup;
   originName,help,path,name2: ^text;
   fg2: ^astInterface.fragmentGroup;
   found: @boolean;
   
do
   thisOperation:
     (# 
     do
        ff.name->slotName[];
        'Searching for the SLOT definition of \''->putText;
        slotName[]->putText;
        '\' in:'->putLine;
        fg[]->searchFrag[];
        searchFrag.scanSlots
          (# 
          do
             (if (current.Name->slotName.equalNCS) then
                 true->found; current.father->theSlotNode[]; leave thisOperation
             if)
          #);
        searchSlot: searchFrag.prop.scanProp
          (#
             doProp::< 
               (# 
               do
                  (if true
                   // ('ORIGIN'->prop.equalNCS) then
                      getString->originName[];
                      (if (originName.length > 0) then
                          originName[]->putLine;
                          searchFrag.fullName->editorenvPrivate.splitPath
                            ->(path[],name2[]);
                          (originName[],path[])
                            ->mps.thePathHandler.convertFilePath->help[];
                          (* (help[],screen[]) ->mps.top.open->fg2[];*)
                          help[]->ymerCallBack.getFragmentGroup->fg2[];
                          (if fg2[] = none then
                              ' could not be opened '->help.putText;
                              help[]->putLine;
                              (*(none ,help[],'Search SLOT')->UI.alertUser;*)
                              
                           else
                              l: fg2.scanSlots
                                (# 
                                do
                                   (if (current.Name->slotName.equalNCS) then
                                       true->found;
                                       current.father->theSlotNode[];
                                       leave l
                                   if)
                                #);
                              (if not found then
                                  fg2[]->searchFrag[];
                                  ''->originName[];
                                  restart searchSlot
                              if);
                              
                          if);
                          
                       else
                          'Could not find the SLOT \''->help[];
                          slotName[]->help.putText;
                          '\' in the ORIGIN chain'->help.putText;
                          (none ,help[],'Follow Link To SLOT')->UI.alertUser;
                          
                      if)
                  if);
                  
               #)
          #);
        
     #)
#)  

-- doSetImplementationFragment: DoPart --
do
     (# msg: ^text; currentfg: ^astInterface.fragmentGroup
     do
        'Implementation fragment file: '->msg[];
        THIS(GroupEditor)[]->implementationGroupEditor[];
        implementationGroupEditor.fg.fullName->msg.append;
        msg[]->ymerCallBack.infoView;
        
     #)  

-- doUnsetImplementationFragment: DoPart --
do
   none ->implementationGroupEditor[];
   'Implementation file is unset'->ymerCallBack.infoView  

-- doSetSLOTNameprefix: DoPart --
do
     (# msg: ^text
     do
        (none ,'Set SLOT name prefix',
         'Enter SLOT name prefix                        ',SLOTnamePrefix[])
          ->UI.promptForText
            (#
               ok::< 
                 (# 
                 do
                    usertext->SLOTnamePrefix;
                    'SLOT name prefix: '->msg[];
                    SLOTnamePrefix[]->msg.append;
                    msg[]->ymerCallBack.infoView;
                    
                 #)
            #)
     #)  

-- doUnsetSLOTNameprefix: DoPart --
do 'SLOT name prefix is unset'->ymerCallBack.infoView; ''->SLOTnamePrefix  

