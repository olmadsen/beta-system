ORIGIN '../codeeditor';
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1986-96
 *	 All rights reserved.
 *)
-- makeUndoElemBody: Descriptor --
(# garbage: ^undoListDesc; elmNo: @integer; 
do
   (if edenv.trace[13] then
       '***************************'->putLine;
       'before makeUndoElem'->undoPrivate.showUndoList
   if);
   (if undoprivate.everythingUndone then
       undoList.clear;
       (if edenv.trace[13] then 'undoList cleared'->putline if);
       false->undoPrivate.everyThingUndone
    else
       (if undoList.size > 1 then
           currentUndoCell[]->undoList.splitAfter->(undoList[],garbage[]);
           (if edenv.trace[13] then
               'undoList reduced'->undoPrivate.showUndoList
           if)
       if)
   if);
   false->cs.redoPermit;
   &undoElemType[]->undoElem[];
   undoElem[]->undoList.append;
   undoList.last->currentUndoCell[];
   (* from here same code as in makeRedoElem: *)
   fatherNode[]->undoElem.fatherRef[];
   undoFocus.node[]->undoElem.fragments.elm[1][];
   undoFocus.length->undoElem.FragmentLength;
   undoLength->undoElem.undoLength;
   isDeleted->undoElem.isDeleted;
   (if (fatherNode[] = none ) then
       0->undoElem.sonPos
    else
       sonPos->undoElem.sonPos;
       (if (1 < undoFocus.length) then
           (for i: (undoFocus.length-1) repeat
             (if i+1 > undoElem.fragments.elm.range then
                 undoElem.fragments.elm.range->undoElem.fragments.elm.extend
             if);
             sonPos+i->fatherNode.get->undoElem.fragments.elm[i+1][];
             
           for);
           none ->undoElem.fragments.elm[undoFocus.length+1][]
       if)
   if);
   (if edenv.trace[13] then 'after makeUndoElem'->undoPrivate.showUndoList if)
#)  

-- makeRedoElemBody: Descriptor --
(# 
do
   (if edenv.trace[13] then
       '***************************'->putLine;
       'before makeRedoElem'->undoPrivate.showUndoList
   if);
   fatherNode[]->undoElem.fatherRef[];
   undoFocus.node[]->undoElem.fragments.elm[1][];
   undoFocus.length->undoElem.FragmentLength;
   undoLength->undoElem.undoLength;
   isDeleted->undoElem.isDeleted;
   (if (fatherNode[] = none ) then
       0->undoElem.sonPos
    else
       sonPos->undoElem.sonPos;
       (if (1 < undoFocus.length) then
           (for i: (undoFocus.length-1) repeat
             (if i+1 > undoElem.fragments.elm.range then
                 undoElem.fragments.elm.range->undoElem.fragments.elm.extend
             if);
             sonPos+i->fatherNode.get->undoElem.fragments.elm[i+1][]
           for);
           none ->undoElem.fragments.elm[undoFocus.length+1][]
       if)
   if);
   (if edenv.trace[13] then 'after makeRedoElem'->undoPrivate.showUndoList if)
#)  

-- makeAstReplaced: DoPart --
do
   (if (undoElem.fatherRef[] = none ) then
       (if sequence then
           (undoElem.fragments.elm[1][],fragDotRoot)
             ->astReplacedList.appendElement
        else
           (true,undoElem.fragments.elm[1][],fragDotRoot)->anAstReplacedEvent
       if)
    else
       (if sequence then
           (undoElem.fragments.elm[1][],undoElem.sonPos->undoElem.fatherRef.get)
             ->astReplacedList.appendElement
        else
           (true,undoElem.fragments.elm[1][],
            undoElem.sonPos->undoElem.fatherRef.get)->anAstReplacedEvent
       if)
   if);
     

-- undoBody: Descriptor --
(# 
do
   (if edenv.trace[13] then
       '***************************'->putLine;
       'before undo'->undoPrivate.showUndoList
   if);
   (if undoPrivate.readyForRedo then
       currentUndoCell.pred[]->currentUndoCell[];
       currentUndoCell.elm[]->undoElem[];
       false->undoPrivate.readyForRedo
   if);
   true->isUndoing;
   undoprivate.doundo;
   false->isUndoing;
   true->cs.redoPermit;
   (*(if undoing then
    (if currentUndoCell.pred[] <> none then
    currentUndoCell.pred[]->currentUndoCell[];
    currentUndoCell.elm[]->undoElem[]
    else
    false->undoing
    if)
    else
    <* redoing *>
    (if currentUndoCell.succ[] <> none then
    currentUndoCell.succ[]->currentUndoCell[];
    currentUndoCell.elm[]->undoElem[]
    else
    true->undoing
    if)
    if);*)
   (if currentUndoCell.pred[] <> none then
       currentUndoCell.pred[]->currentUndoCell[];
       currentUndoCell.elm[]->undoElem[];
       false->undoprivate.everythingUndone;
       true->undoPrivate.readyForUndo
    else
       false->cs.undoPermit;
       true->undoprivate.everythingUndone;
       false->undoPrivate.readyForUndo
   if);
   (if edenv.trace[13] then 'after undo'->undoPrivate.showUndoList if)
#)  

-- redoBody: Descriptor --
(# 
do
   (if edenv.trace[13] then
       '***************************'->putLine;
       'before redo'->undoPrivate.showUndoList
   if);
   (if undoPrivate.readyForUndo then
       currentUndoCell.succ[]->currentUndoCell[];
       currentUndoCell.elm[]->undoElem[];
       false->undoPrivate.readyForUndo
   if);
   undoprivate.doundo;
   true->cs.undoPermit;
   false->undoPrivate.everyThingUndone;
   (if currentUndoCell.succ[] <> none then
       currentUndoCell.succ[]->currentUndoCell[];
       currentUndoCell.elm[]->undoElem[];
       true->undoPrivate.readyForRedo
    else
       false->cs.redoPermit; false->undoPrivate.readyForRedo
   if);
   (*(if redoing then
    (if currentUndoCell.succ[] <> none then
    currentUndoCell.succ[]->currentUndoCell[];
    currentUndoCell.elm[]->undoElem[]
    else
    false->redoing
    if)
    else
    <* undoing *>
    (if currentUndoCell.pred[] <> none then
    currentUndoCell.pred[]->currentUndoCell[];
    currentUndoCell.elm[]->undoElem[]
    else
    true->redoing
    if)
    if);*)
   (if edenv.trace[13] then 'after redo'->undoPrivate.showUndoList if)
#)  

-- undoPrivate: Descriptor --
(#
   showUndoList:
     (# t: ^text
     enter t[]
     do
        true->switch[7]->edenv.trace[7];
        t[]->putLine;
        'undoList.size: '->putText;
        undoList.size->putInt;
        newLine;
        undoList.scan
          (# ue: ^undoElemType
          do
             current[]->ue[];
             (if ue.fragments.elm[1][] <> none then
                 ue.fragments.elm[1].index->putInt; ' '->put
              else
                 'none '->putText
             if)
          #);
        newLine;
        (if undoElem[] <> none then
            'currentUndoElem: '->putText;
            (if undoElem.fragments.elm[1][] <> none then
                undoElem.fragments.elm[1].index->putInt; ' '->put
             else
                'none '->putText
            if);
            newLine
        if)
     #);
   everythingUndone,readyForUndo,readyForRedo: @boolean;
   doundo:
     (# (* undo's the latest performed editing operation, i.e. *)
     (* cut, paste, expand, insert before/after             *)
        oldFragment: @edenv.partList;
        fragmentLength,isSon: @integer;
        undoFragment,newElements: @astFocus;
        fatherNode: ^astInterface.expanded;
        found: @boolean;
        aList: ^astInterface.list;
        csInFragment:
        (* Tests whether current selection is in the fragment which shall   *)
        (* be replaced by 'undo'.                                           *)
          (#
             nodes,csFragments: @edenv.partList;
             fragment: @astFocus;
             fragmentFather,csFather,expfragment: ^astInterface.expanded;
             found: @boolean
          enter fragment
          do
             trace
               (#  do 'csInFragment '->str[] #);
             true->found;
             (if not ((cs.node[]->fragment.node.equal)->found) then
                 cs.node[]->csFragments.elm[1][];
                 cs.node.Father->csFather[];
                 (for i: (cs.length-1) repeat
                   cs.node.sonNo+i->csFather.get->csFragments.elm[i+1][]
                 for);
                 fragment.node[]->nodes.elm[1][];
                 fragment.node.Father->fragmentFather[];
                 (for i: (fragment.length-1) repeat
                   fragment.node.sonNo+i->fragmentFather.get->nodes.elm[i+1][]
                 for);
                 Loop:
                   (# 
                   do
                      (for i: fragment.length repeat
                        (if (nodes.elm[i].kind <> mps.kinds.interior) then
                            (for j: cs.length repeat
                              (if
                              ((csFragments.elm[j][]->nodes.elm[i].equal)
                                 ->found) then
                                  leave Loop
                              if)
                            for)
                         else
                            nodes.elm[i][]->expFragment[];
                            expFragment.suffixWalk
                              (# 
                              do
                                 (for j: cs.length repeat
                                   (if
                                   ((csFragments.elm[j][]->current.equal)
                                      ->found) then
                                       leave Loop
                                   if)
                                 for)
                              #)
                        if)
                      for)
                   #)
             if)
          exit found
          #)
     do
        undoElem->(fatherNode[],isSon,oldFragment.elm[1][],fragmentLength);
        false->found;
        (if undoElem.isDeleted then
        (* replacement or deletion of a number of list elements must be undone *)
            (if (1 < fragmentLength) then
            (* more than one list element is in the undo element *)
                (for i: (fragmentLength-1) repeat
                  undoElem.fragments.elm[i+1][]->oldFragment.elm[i+1][]
                for)
            if);
            (if (0 < undoElem.undoLength) then
            (* the undo element shall replace one or more list elements *)
                fatherNode[]->aList[];
                isSon->fatherNode.get->undoFragment.node[];
                undoElem.undoLength->undoFragment.length;
                
             else
            (* the undo element shall replace nothing *)
                none ->undoFragment.node[]; 0->undoFragment.length
            if);
            (fatherNode[],isSon,undoFragment,fragmentlength,true)->makeRedoElem;
            (for undoFragment.length repeat isSon->aList.delete for);
            (if (0 < fragmentLength) then
                (for i: fragmentLength repeat
                  (isSon+i-1,oldFragment.elm[i][])->fatherNode.Insert
                for);
                (true,fatherNode[],isSon,undoElem.fragmentLength,
                 undoElem.Fragments[],fragmentLength)
                  ->aListElementsReplacedEvent;
                (isSon->fatherNode.get,fragmentLength,0,0)->cs;
                
             else
                (true,fatherNode[],isSon,undoElem.fragmentLength,
                 undoElem.Fragments[])->aListElementsDeletedEvent;
                (if (1 <= fatherNode.noOfSons) then
                    (if (fatherNode.noOfSons < isSon) then
                        fatherNode.noOfSons->isSon
                    if);
                    isSon->fatherNode.get->cs.node[]
                 else
                    fatherNode[]->cs.node[]
                if);
                1->cs.length;
                
            if)
         else
            (if (fatherNode[] = none ) then
                fragDotRoot->undoFragment.node[];
                1->undoFragment.length;
                (fatherNode[],isSon,undoFragment,1,false)->makeRedoElem;
                oldFragment.elm[1][]->fragDotRoot->cs.node[];
                1->cs.length;
                makeASTReplacedEvent;
                
             else
                isSon->fatherNode.get->undoFragment.node[];
                1->undoFragment.length;
                (isSon,oldFragment.elm[1][])->fatherNode.put;
                (fatherNode[],isSon,undoFragment,1,false)->makeRedoElem;
                makeASTReplacedEvent;
                (isSon->fatherNode.get,1,0,0)->cs
            if);
            
        if);
        cs-> (* to generate event *) &setFocus
     #)
#)  

