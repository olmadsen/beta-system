ORIGIN '../codeeditor';
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1986-94
 *	 All rights reserved.
 *)

-- makeUndoElemBody: Descriptor --
(# garbage: ^undoListDesc;
   elmNo: @integer; 
do
   trace
   (#  do 'makeUndoElem'->str[] #);
(*   (if undoList.size > 1 then
       currentUndoCell[]->undoList.splitAfter->(undoList[],garbage[])
 if);
 *)
   &undoElemType[]->undoElem[];
(*   undoElem[]->undoList.append;
 undoList.last->currentUndoCell[];
 * *)
   
   fatherNode[]->undoElem.fatherRef[];
   undoFocus.node[]->undoElem.fragments.elm[1][];
   undoFocus.length->undoElem.FragmentLength;
   undoLength->undoElem.undoLength;
   isDeleted->undoElem.isDeleted;
   (if (fatherNode[] = none )
    then
       0->undoElem.sonPos; 
   else
       sonPos->undoElem.sonPos;
       (if (1 < undoFocus.length)
       then
           (for i: (undoFocus.length-1) repeat
             (if i+1 > undoElem.fragments.elm.range then
                 undoElem.fragments.elm.range->undoElem.fragments.elm.extend
             if);
             sonPos+i->fatherNode.get->undoElem.fragments.elm[i+1][];
             
           for);
           none ->undoElem.fragments.elm[undoFocus.length+1][];
           
       if);
       
   if);
   
#)  

-- makeAstReplaced: Dopart --
do    
   (if (undoElem.fatherRef[] = none )
    then
       (if sequence then
           (undoElem.fragments.elm[1][],fragDotRoot)
             ->astReplacedList.appendElement
        else
           (true,undoElem.fragments.elm[1][],fragDotRoot)->anAstReplacedEvent
       if)
   else
       (if sequence then
           (undoElem.fragments.elm[1][],undoElem.sonPos->undoElem.fatherRef.get)
             ->astReplacedList.appendElement
        else
           (true,undoElem.fragments.elm[1][],undoElem.sonPos->undoElem.fatherRef.get)
             ->anAstReplacedEvent
       if)
   if);
   
-- undoBody: Descriptor --
(# (* undo's the latest performed editing operation, i.e. *)
(* cut, paste, expand, insert before/after             *)
   oldFragment: @edenv.partList;
   fragmentLength,isSon: @integer;
   undoFragment,newElements: @astFocus;
   fatherNode: ^astInterface.expanded;
   found: @boolean;
   aList: ^astInterface.list;
   csInFragment:
   (* Tests whether current selection is in the fragment which shall   *)
   (* be replaced by 'undo'.                                           *)
     (#
        nodes,csFragments: @edenv.partList;
        fragment: @astFocus;
        fragmentFather,csFather,expfragment: ^astInterface.expanded;
        found: @boolean
     enter fragment
     do
        trace
          (#  do 'csInFragment '->str[] #);
        true->found;
        (if not ((cs.node[]->fragment.node.equal)->found)
        then
            cs.node[]->csFragments.elm[1][];
            cs.node.Father->csFather[];
            (for i: (cs.length-1) repeat
              cs.node.sonNo+i->csFather.get->csFragments.elm[i+1][]
            for);
            fragment.node[]->nodes.elm[1][];
            fragment.node.Father->fragmentFather[];
            (for i: (fragment.length-1) repeat
              fragment.node.sonNo+i->fragmentFather.get->nodes.elm[i+1][]
            for);
            Loop:
              (# 
              do
                 (for i: fragment.length repeat
                   (if (nodes.elm[i].kind <> mps.kinds.interior)
                   then
                       (for j: cs.length repeat
                         (if
                         ((csFragments.elm[j][]->nodes.elm[i].equal)->found)
                          then leave Loop
                         if)
                       for)
                  else
                       nodes.elm[i][]->expFragment[];
                       expFragment.suffixWalk
                         (# 
                         do
                            (for j: cs.length repeat
                              (if
                              ((csFragments.elm[j][]->current.equal)->found)
                             then leave Loop
                              if)
                            for)
                         #)
                   if)
                 for)
              #)
        if)
     exit found
     #)
do
   trace
   (#  do 'undo '->str[] #);
   undoElem->(fatherNode[],isSon,oldFragment.elm[1][],fragmentLength);
   false->found;
   (if undoElem.isDeleted
  then
    (* replacement or deletion of a number of list elements must be undone *)
       (if (1 < fragmentLength)
        then (* more than one list element is in the undo element *)
           (for i: (fragmentLength-1) repeat
             undoElem.fragments.elm[i+1][]->oldFragment.elm[i+1][]
           for)
       if);
       (if (0 < undoElem.undoLength)
       then
        (* the undo element shall replace one or more list elements *)
           fatherNode[]->aList[];
           isSon->fatherNode.get->undoFragment.node[];
           undoElem.undoLength->undoFragment.length;
           
      else (* the undo element shall replace nothing *)
           none ->undoFragment.node[]; 0->undoFragment.length
       if);
       (fatherNode[],isSon,undoFragment,fragmentlength,true)->&makeUndoElem;
       (for undoFragment.length repeat isSon->aList.delete for);
       (if (0 < fragmentLength)
       then
           (for i: fragmentLength repeat
             (isSon+i-1,oldFragment.elm[i][])->fatherNode.Insert
           for);
           (true,fatherNode[],isSon,undoElem.fragmentLength,undoElem.Fragments[],
            fragmentLength)->aListElementsReplacedEvent;
           (isSon->fatherNode.get,fragmentLength,0,0)->cs;
           
       else
           (true,fatherNode[],isSon,undoElem.fragmentLength,undoElem.Fragments[])
             ->aListElementsDeletedEvent;
           (if (1 <= fatherNode.noOfSons)
            then
               (if (fatherNode.noOfSons < isSon)
               then fatherNode.noOfSons->isSon
               if);
               isSon->fatherNode.get->cs.node[]
          else
               fatherNode[]->cs.node[]
           if);
           1->cs.length;
           
       if)
   else
       (if (fatherNode[] = none )
        then
           fragDotRoot->undoFragment.node[];
           1->undoFragment.length;
           (fatherNode[],isSon,undoFragment,1,false)->&makeUndoElem;
           oldFragment.elm[1][]->fragDotRoot->cs.node[];
           1->cs.length;
           (*&newFragmentEvent;*)
           makeASTReplacedEvent;
           
       else
           isSon->fatherNode.get->undoFragment.node[];
           1->undoFragment.length;
           (isSon,oldFragment.elm[1][])->fatherNode.put;
           (fatherNode[],isSon,undoFragment,1,false)->&makeUndoElem;
           makeAstReplacedEvent;
           (isSon->fatherNode.get,1,0,0)->cs
       if);
       
   if);
   cs-> (* to generate event *) &setFocus;
   
   (if false then 
     (if undoing then
       (if currentUndoCell.pred[]<>none then
           currentUndoCell.pred[]->currentUndoCell[];
           currentUndoCell.elm[]->undoElem[];
        else
           (if currentUndoCell.succ[]<>none then
               false->undoing; (* redoing *)
               currentUndoCell.succ[]->currentUndoCell[];
               currentUndoCell.elm[]->undoElem[];
           if)
       if)
    else (* redoing *)
        (if currentUndoCell.succ[]<>none then
           currentUndoCell.succ[]->currentUndoCell[];
           currentUndoCell.elm[]->undoElem[];
        else
           (if currentUndoCell.pred[]<>none then
               true->undoing; (* undoing *)
               currentUndoCell.pred[]->currentUndoCell[];
               currentUndoCell.elm[]->undoElem[];
           if)
        if)
     if)
   if)
#)  

