ORIGIN '../codeeditor';
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1986-94
 *	 All rights reserved.
 *)
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1986-94
 *	 All rights reserved.
 *)
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1986-94
 *	 All rights reserved.
 *)
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1986-94
 *	 All rights reserved.
 *)
-- undoBody: Descriptor --
(# (* undo's the latest performed editing operation, i.e. *)
(* cut, paste, expand, insert before/after             *)
   oldFragment: @edenv.partList;
   fragmentLength,isSon: @integer;
   undoFragment,newElements: @astFocus;
   fatherNode: ^mps.expanded;
   found: @boolean;
   aList: ^mps.list;
   csInFragment:
   (* Tests whether current selection is in the fragment which shall   *)
   (* be replaced by 'undo'.                                           *)
     (#
        nodes,csFragments: @edenv.partList;
        fragment: @astFocus;
        fragmentFather,csFather,expfragment: ^mps.expanded;
        found: @boolean
     enter fragment
     do
        trace
          (#  do 'csInFragment '->str[] #);
        true->found;
        (if ((cs.node[]->fragment.node.equal)->found)
         // false then
            cs.node[]->csFragments.elm[1][];
            cs.node.Father->csFather[];
            (for i: (cs.length-1) repeat
              cs.node.sonNo+i->csFather.get->csFragments.elm[i+1][]
            for);
            fragment.node[]->nodes.elm[1][];
            fragment.node.Father->fragmentFather[];
            (for i: (fragment.length-1) repeat
              fragment.node.sonNo+i->fragmentFather.get->nodes.elm[i+1][]
            for);
            Loop:
              (# 
              do
                 (for i: fragment.length repeat
                   (if (nodes.elm[i].kind = mps.kinds.interior)
                    // false then
                       (for j: cs.length repeat
                         (if
                         ((csFragments.elm[j][]->nodes.elm[i].equal)->found)
                          // true then leave Loop
                         if)
                       for)
                    // true then
                       nodes.elm[i][]->expFragment[];
                       expFragment.suffixWalk
                         (# 
                         do
                            (for j: cs.length repeat
                              (if
                              ((csFragments.elm[j][]->current.equal)->found)
                               // true then leave Loop
                              if)
                            for)
                         #)
                   if)
                 for)
              #)
        if)
     exit found
     #)
do
   trace
     (#  do 'undo '->str[] #);
   undoElem->(fatherNode[],isSon,oldFragment.elm[1][],fragmentLength);
   false->found;
   (if undoElem.isDeleted
    // true then
    (* replacement or deletion of a number of list elements must be undone *)
       (if (1 < fragmentLength)
        // true then (* more than one list element is in the undo element *)
           (for i: (fragmentLength-1) repeat
             undoElem.fragments.elm[i+1][]->oldFragment.elm[i+1][]
           for)
       if);
       (if (0 < undoElem.undoLength)
        // true then
        (* the undo element shall replace one or more list elements *)
           fatherNode[]->aList[];
           isSon->fatherNode.get->undoFragment.node[];
           undoElem.undoLength->undoFragment.length;
           
        // false then (* the undo element shall replace nothing *)
           none ->undoFragment.node[]; 0->undoFragment.length
       if);
       (fatherNode[],isSon,undoFragment,fragmentlength,true)->&makeUndoElem;
       (for undoFragment.length repeat isSon->aList.delete for);
       (if (0 < fragmentLength)
        // true then
           (for i: fragmentLength repeat
             (isSon+i-1,oldFragment.elm[i][])->fatherNode.Insert
           for);
           (fatherNode[],isSon,undoElem.fragmentLength,undoElem.Fragments[],
            fragmentLength)->aListElementsReplacedEvent;
           (isSon->fatherNode.get,fragmentLength,0,0)->cs;
           
        // false then
           (fatherNode[],isSon,undoElem.fragmentLength,undoElem.Fragments[])
             ->aListElementsDeletedEvent;
           (if (1 <= fatherNode.noOfSons)
            // true then
               (if (fatherNode.noOfSons < isSon)
                // true then fatherNode.noOfSons->isSon
               if);
               isSon->fatherNode.get->cs.node[]
            // false then
               fatherNode[]->cs.node[]
           if);
           1->cs.length;
           
       if)
    // false then
       (if (fatherNode[] = none )
        // true then
           frag.root[]->undoFragment.node[];
           1->undoFragment.length;
           (fatherNode[],isSon,undoFragment,1,false)->&makeUndoElem;
           oldFragment.elm[1][]->frag.root[]->cs.node[];
           1->cs.length;
           (*&newFragmentEvent;*)
           makeASTReplacedEvent;
           
        // false then
           isSon->fatherNode.get->undoFragment.node[];
           1->undoFragment.length;
           (isSon,oldFragment.elm[1][])->fatherNode.put;
           (fatherNode[],isSon,undoFragment,1,false)->&makeUndoElem;
           makeAstReplacedEvent;
           (isSon->fatherNode.get,1,0,0)->cs
       if);
       
   if);
   cs-> (* to generate event *) &setFocus
#)  

