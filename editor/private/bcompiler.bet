ORIGIN '../ymersiflib';

(* Used for NTI when SDK<>bor: links with binary compiler *)
BODY '~beta/system/v5.2/synthesizer';
MDBODY nti '~beta/system/v5.2/NTIBasmlink'
       nti '~beta/system/v5.2/INTELBmachine'
       nti '~beta/system/v5.2/INTELnotrace'
       nti '~beta/system/v5.2/COFF/WIN32coff'
       nti 'bcompiler_ntibody';
INCLUDE '~beta/system/v5.2/system';
-- sifCompilerVersion: DoPart --
do ymerBrowser.compilerPrivate.comp.compilerVersion->version[]  

-- compilerPrivate: Descriptor --
(#
   comp: @compiler
     (#
        groupSaved::< 
          (# ge: ^editorEnv.groupEditor; currentName: ^text
          do
             (browser[],fg[])->edenv.groupEditorList.findGroupEditor->ge[];
             (if ge[] <> none then
                 fg[]->ge.compilerSavedGroup; fg[]->savedGroups.insert
             if);
             fg[]->onGroupSaved
          #);
        semanticErrors::<  (#  do ff[]->formsWithSemanticErrors.append #);
        sifInfoStream: @stream
          (#
             infoLine: @text;
             put:: 
               (# 
               do (* '[put:'->screen.putText;*)
                  ch->screen.put;
                  (* ']'->screen.putLine; *)
                  ch->infoLine.put;
                  (if ch = ascii.newLine then
                      infoLine.clear
                   else
                      infoLine.copy->writeInfoView
                  if)
               #);
             putText:: 
               (# 
               do (*  '[putText:'->screen.putText;*)
                  txt[]->screen.putText;
                  txt[]->infoLine.putText;
                  infoLine.copy->writeInfoView;
                  (*true->doneInInner*)
                  
               #);
             putLine:
               (# t: ^text
               enter t[]
               do (*'[putLine:'->screen.putText;*)
                  t[]->screen.putLine;
                  t[]->infoLine.putText;
                  infoLine.copy->writeInfoView;
                  infoLine.clear
               #);
             newLine:
               (# 
               do (*'[newLine]'->screen.putLine;*)
                  screen.newLine; infoLine.clear
               #);
             init: (#  do infoLine.clear #)
          #);
        
     #);
   
#)  

-- activateCompilerBody: Descriptor --
(#
   help: ^text;
   f,g: @file;
   parseErrors,someError: @boolean;
   fileWithParseErrors: @text;
   jobFilePermission:
     (# fgname: ^text; 
     enter fgname[]
     <<SLOT compilerJobFilePermission:DoPart>>
     #);
   jobFileDelete:
     (# fgname: ^text; 
     enter fgname[]
     <<SLOT compilerJobFileDelete:DoPart>>
     #);
   
do
   fragmentFile[]->jobFileDelete;
   (if true
    // false then 'activateCompiler: '->putText; fragmentFile[]->putLine; 
   if);
   <<SLOT machineDependentSwitches:Descriptor>>;
   (if not generatecode then
       (true,33)
         ->
           compilerPrivate.comp.
             setswitch;
       (true,5)->compilerPrivate.comp.setswitch;
       (* prevent activation of code generator*)
       (*prevent execution of job file*)
       
    else
       (false,33)->compilerPrivate.comp.setswitch;
       (false,5)->compilerPrivate.comp.setswitch;
       (*prevent activation of code generator*)
       (*prevent execution of job file*)
       
   if);
   (generateDebugInfo,41)->compilerPrivate.comp.setswitch;
   (generateDebugInfo,55)->compilerPrivate.comp.setswitch;
   (true,19)->compilerPrivate.comp.setswitch;
   (true,90)->compilerPrivate.comp.setswitch;
   (true,32)->compilerPrivate.comp.setswitch;
   'No qua-check warnings and .lst file'->screen.putLine;
   compilerprivate.comp.sifInfoStream.init;
   L:
   fragmentFile[]
     ->compilerPrivate.comp.translate
       (#
          Report:
            (# msg: ^text
            enter msg[]
            do (* msg[]->compilerPrivate.comp.messagestream.putline;*)
               (none ,msg[],'Compiler message')->alertUser;
               true->someError;
               leave L
            #);
          MsgException::< 
            (# semErrors: @boolean; keepMsg: ^text
            do
               msg.copy->keepMsg[];
               msg.clear;
               (if no
                // 1 then (* eliminate*)
                   'System error!!!'->msg.putline
                // 2 then
                   'The fragment group is empty!'->msg.putLine; 
                // 11 then
                   'Error(s) in fragment structure'->msg.putline; 
                // 12 then
                   'The fragment group is reached twice during dependency analysis'
                     ->msg.putline;
                   'Circularity in fragment structure (origin and/or include)'
                     ->msg.putLine;
                   
                // 14 then
                (*'Stopped because of semantic errors'->msg.putLine; *)
                   true->semErrors->someError
                // 16 then
                   'Stopped because of file access problem'->msg.putline
                else
                   'Should not happen(msg):'->msg.putline;
                   no->msg.putInt;
                   msg.newline
               if);
               (if not semErrors then
                   (if fg[] <> none then
                       fg[]->findGroup; msg[]->Report
                    else
                       newLine;
                       'msgException: '->putText;
                       no->putInt;
                       ': '->putLine;
                       keepMsg[]->putLine;
                       keepMsg[]->report
                   if)
                else
                   leave L
               if)
            #);
          TransAccessException::<  (#  do msg[]->Report #);
          TransCreateDirException::<  (#  do msg[]->Report #);
          NoSpaceException::<  (#  do msg[]->Report #);
          MPSException::<  (#  do msg[]->Report #);
          notExistingException::<  (#  do msg[]->Report #);
          parseException::< 
            (# 
            do (*msg[]->Report*)
               true->parseErrors->someError;
               fullFN->fileWithParseErrors;
               leave L
            #);
          betaRunException::<  (#  do msg[]->Report #);
          RshException::<  (#  do msg[]->Report #);
          jobFileException::<  (#  do msg[]->Report #);
          multipleMachException::<  (#  do msg[]->Report #);
          unknownMachException::<  (#  do msg[]->Report #);
          rereadFragment:: 
            (#  do fullFN[]->putText; ' has been reread!'->putLine #);
          checkedFragment::  (#  do  #);
          closedFragment:: 
            (# 
            do
            (* scanningGroupEditorList: edenv.groupEditorList.scan
             (# 
             do
             newLine;
             current.fg.name->putLine;
             fullFN[]->putLine;
             (if current.fg.name->fullFN.equal then
             false->proceed;
             'do not close'->putLine;
             leave scanningGroupEditorList
             if)
             #)*)
            (*fullFN[]->putText; ' TryToGC not allowed by Sif!'->putLine*) 
            #);
          doubleFormException::<  (#  do msg[]->Report #);
          fragmentException::
          (* Note that the group is closed here.
           * Sif and other tools may NOT want to do this!
           *) 
            (# keepMsg: ^text
            do (*CloseGroup;*)
               msg.copy->keepMsg[];
               msg.clear;
               (if errNo
                // 1 then
                   'Two or more slots have the name: '->msg.puttext;
                   slot.name->msg.puttext;
                   
                // 2 then
                   'No free slot found for: '->msg.Puttext;
                   FF.name->msg.puttext;
                   
                // 3 then
                   'Category of fragment: '->msg.puttext;
                   FF.name->msg.puttext;
                   ' does not correspond to category of slot'->msg.puttext;
                   
                // 4 then
                   'The slot: '->msg.Puttext;
                   FF.name->msg.puttext;
                   ' Is already bound'->msg.Puttext
                // 5 then
                   'Category of: '->msg.Puttext;
                   FF.name->msg.Puttext;
                   ' must be either: '->msg.Putline;
                   'Descriptor (ObjectDescriptor, DescriptorForm) or '
                     ->msg.puttext;
                   'Attributes (AttributeDecl, AttributesForm)'->msg.putline;
                   
                // 6 then
                   'Category of the following slot is not supported!\n\n\t'
                     ->msg.putText;
                   slot.name->msg.putLine;
                   '\nCategory must be: descriptor, attributes or doPart'
                     ->msg.putLine
                // 7 then
                   'Warning: mainPart-slots are NOT fully supported!'
                     ->msg.putLine
               if);
               'Error in fragment structure'->writeInfoView;
               '*** Error in fragment structure'->putLine;
               (if slot[] <> none then
                   slot.father->findAndSelect; msg[]->Report
                else
                   (if ff[] <> none then
                       ff[]->findForm; msg[]->Report
                    else
                       (if fg[] <> none then
                           fg[]->findGroup; msg[]->Report
                        else
                           'fragmentException: '->putText;
                           errNo->putInt;
                           ': '->putLine;
                           keepMsg[]->putLine;
                           keepMsg[]->report
                       if)
                   if)
               if)
            #);
          propertyException:: 
            (# keepMsg: ^text
            do
               msg.copy->keepMsg[];
               msg.clear;
               (if n
                // 1 then
                   'Two or more origins are specified:\n\t'->msg.puttext;
                     (# g: ^astInterface.fragment; 
                     do FG.origin->g[]; g.name->msg.puttext; 
                     #);
                   '\n\t'->msg.puttext;
                   t[]->msg.putline
                // 2 then
                   'The reserved property name "'->msg.puttext;
                   t.makeUC;
                   t[]->msg.puttext;
                   '"\n\tappears in the property list for '->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   
                // 3 then
                   'Illegal "'->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   '" property: "'->msg.puttext;
                   t.makeUC;
                   t[]->msg.puttext;
                   '"\n'->msg.puttext
                // 4 then
                   'Empty filename in property "'->msg.puttext;
                   p.makeUC;
                   p[]->msg.puttext;
                   '"'->msg.put;
                   msg.newline;
                   
                // 5 then
                   'Unrecognised property: '->Msg.Puttext;
                   p[]->Msg.Putline;
                   true->warning;
                   true->continue
                // 6 then
                   'Property "'->msg.puttext;
                   p[]->msg.puttext;
                   '" has no value for "'->msg.putText;
                   t[]->msg.putText;
                   '"\n'->msg.putLine;
                   true->warning
               if);
               (if not warning then
                   '\n\n\tA ";" may be missing before '->msg.puttext;
                   t[]->msg.putline;
                   'Property error'->writeInfoView;
                   '*** Property error'->putLine;
                   (if fg[] <> none then
                       fg[]->findGroup;
                       'in '->msg.append;
                       fg.name->msg.append;
                       msg[]->putLine;
                       msg[]->Report
                    else
                       'propertyException: '->putText;
                       n->putInt;
                       ': '->putLine;
                       keepMsg[]->putLine;
                       keepMsg[]->report
                   if);
                   
               if)
            #);
          SystemException::  (#  do msg[]->Report #)
       do 
       #);
   (if parseErrors then
       false->parseErrors;
       'Parse Error(s)'->writeInfoview;
       fileWithParseErrors[]->openParseEditor
   if);
   (if not someError then
       (if generatecode
        // false then
        (* (none ,'Checking finished',
         'Compiler message')->alertUser;*)
           'Checking finished'->writeInfoView
        else
       (* (none ,'Checking and code generation finished','Compiler message')
        ->alertUser;*)
           'Checking and code generation finished, wait for linking, see the console'
             ->writeInfoView
       if);
       fragmentFile[]->jobFilePermission
   if);
   not someError->OK;
   
#)  

-- initCompilerBody: Descriptor --
(#
(* Here it is possibleto initialize the compiler/checker 
 * to use specific instances
 * of ASTinterface and OSinterface. 
 * If comp.AST[]/ensemble[] are none, then
 * comp.init will generate new instances of ASTinterface and OSinterface.
 * 
 * myASTinterface[] -> comp.AST[]
 * myOsinterface[]-> comp.ensemble[]
 *) 
do
   mps.ast[]->compilerPrivate.comp.AST[];
   true->compilerPrivate.comp.switch[401];
   true->compilerPrivate.comp.switch[403];
   compilerPrivate.comp.sifInfoStream.init;
   compilerPrivate.comp.sifInfoStream[]->compilerPrivate.comp.infostream[];
   screen[]->compilerPrivate.comp.tracestream[];
   screen[]->compilerPrivate.comp.messagestream[];
   screen[]->compilerPrivate.comp.bugstream[];
   compilerPrivate.comp.verboseLevel.actions->compilerPrivate.comp.verboseLevel;
   compilerPrivate.comp.init;
   compilerPrivate.comp.compilerVersion->version[];
   <<SLOT MDinitCompiler:Descriptor>>
#)  

