ORIGIN 'editorenvbody';
INCLUDE '~beta/win32lib/v1.6/ntitypes';
INCLUDE '~beta/sysutils/v1.6/cstring';
INCLUDE '~beta/win32lib/v1.6/errorhandling';
BUILD default '$$/filedirmisc.obj' 'external/filedirmisc.c' 'betacc $0 $1';
-- setupCursors: Descriptor --
(#  do  #)  

-- myRename: DoPart --
do
   thisOp:
     (# bug: @boolean; t: ^text; newf: @file
     do
        (f.name,newName[])
          ->renameWin32File_Dir
            (#
               error::
                 (# 
                 do
                    true->continue;
                    true->bug;
                    msg.copy->t[];
                    (* (none ,msg[],none )->noteUser; 
                     msg[]->putLine*)
                    
                 #);
               
            #);
        (if bug then
            newName[]->newf.name;
            (if newf.entry.exists then
                newf.delete;
                (f.name,newName[])
                  ->renameWin32File_Dir
                    (#
                       error::
                         (# 
                         do
                            true->continue;
                            newName[]->msg.append;
                            msg.newLine;
                            '2. rename'->msg.append;
                            (none ,msg[],none )->noteUser
                         #)
                    #)
             else
                t.newLine; newName[]->t.append; (none ,t[],none )->noteUser
            if)
        if)
     #)  

-- lib: Attributes --
FORMAT_MESSAGE_ALLOCATE_BUFFER: (#  exit 16x00000100 #);
FORMAT_MESSAGE_FROM_SYSTEM: (#  exit 16x00001000 #);
FormatMessage: external
  (#
     dwFlags: @integer;
     (* source and processing options *)
     lpSource: @integer;
     (* pointer to  message source *)
     dwMessageId: @integer;
     (* requested message identifier *)
     dwLanguageId: @integer;
     (* language identifier for requested message *)
     lpBuffer: @integer;
     (* pointer to message buffer *)
     nSize: @integer;
     (* maximum size of message buffer *)
     Arguments: @integer;
     (* address of array of message inserts *)
     result: @integer;
     
  enter (dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,nSize,Arguments)
  do 'FormatMessageA'->callStd; 
  exit result
  #);
MOVEFILE_REPLACE_EXISTING: (#  exit 16x00000001 #);
MOVEFILE_COPY_ALLOWED: (#  exit 16x00000002 #);
MOVEFILE_DELAY_UNTIL_REBOOT: (#  exit 16x00000004 #);
myMAKELANGID: external
  (# a,b,c: @integer;  enter (a,b) do 'myMAKELANGID'->callC;  exit c #);
LANG_NEUTRAL: (#  exit 16x00 #);
SUBLANG_NEUTRAL: (#  exit 16x00 #);
SUBLANG_DEFAULT: (#  exit 16x01 #);
(* WINBASEAPI BOOL WINAPI MoveFileExA
 * (LPCSTR lpExistingFileName,
 * LPCSTR lpNewFileName,
 * DWORD dwFlags)
 *)
MoveFileEx: external
  (#
     lpExistingFileName: [1] @char;
     lpNewFileName: [1] @char;
     dwFlags: @integer;
     result: @integer;
     
  enter (lpExistingFileName,lpNewFileName,dwFlags)
  do 'MoveFileExA'->callStd; 
  exit result
  #);
MoveFile: external
  (#
     lpExistingFileName: [1] @char;
     lpNewFileName: [1] @char;
     result: @integer;
     
  enter (lpExistingFileName,lpNewFileName)
  do 'MoveFileA'->callStd; 
  exit result
  #);
renameWin32File_Dir:
  (#
     oldName: ^text;
     newName: ^text;
     result: @integer;
     flag: @integer;
     errorMsg: ^text;
     errorMsgCstr: ^cString;
     error:< exception (#  do errorMsg[]->msg.append; INNER ;  #);
     dwFlags: @integer;
     formatRes: @integer;
     errorNo: @integer;
     ERROR_CALL_NOT_IMPLEMENTED: (#  exit 120 #);
     
  enter (oldName[],newName[])
  do
     (oldName,newName,MOVEFILE_COPY_ALLOWED)->MoveFileEx->result;
     errorCheckL:
     (if result = 0 then (* Rename failed. *)
     (* Check if we are on Win95. MoveFileEx is not implemented on
      * Win95 yet. *)
         GetLastError->errorNo;
         (if errorNo = ERROR_CALL_NOT_IMPLEMENTED then
         (* We try using MoveFile instead. *)
             (oldName,newName)->MoveFile->result;
             (if result = 0 then
                 GetLastError->errorNo; 
              else
                 leave errorCheckL; 
             if);
             
         if);
         FORMAT_MESSAGE_FROM_SYSTEM->dwFlags;
         &cString[]->errorMsgCstr[];
         256->errorMsgCstr.init;
         (dwFlags,0,errorNo,(LANG_NEUTRAL,SUBLANG_DEFAULT)->myMAKELANGID,
          errorMsgCstr,256,0)->FormatMessage->formatRes;
         (if formatRes = 0 then
             'FormatMessage failed. Error= '->screen.putText;
             GetLastError->screen.putInt;
             screen.newline;
             
         if);
         errorMsgCstr.get->errorMsg[];
         errorMsg.reset;
         errorMsgCstr.free;
         error;
         
     if);
     
  #)  

