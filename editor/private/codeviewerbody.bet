ORIGIN '../codeviewer' (*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
;
INCLUDE '~beta/mps/propertycfl'
        '~beta/sysutils/objinterface'
        '~beta/betaast/semanticerrortext';
LIB_ITEM 'editorcodeviewer';
-- codeviewerinit: Descriptor --
(# grammar: ^mg.Agrammar; exp: ^astInterface.expanded; help: ^text
do
   &mps.astViewer[]->astView[];
   &windowOutput[]->astView.out[];
   &csType[]->cs[];
   (if editorRoot[] <> none then (*  editorRoot.frag[]->frag[];*)
       (if editorRoot.father <> none then true->isAsubeditor if); 
   if);
   (if mps.grammarTable.meta[] <> none then
       mps.grammarTable.meta[]->mg[]; 
    else
       'No metagrammar installed!!'->putLine; 
   if);
   (if 'beta'->(frag.grammar.grammarIdentification).equal then
       theGrammar[]->betaGrammar[];
       (if betagrammar[] = none then 'betagrammar is none!!'->putLine if);
       (if betagrammar.grammarAst[] = none then
           'betagrammar.grammarAst is none!!'->putLine
       if);
       betaGrammar.grammarAst.root[]->grammar[];
       betaGrammar[]->ag[]
    else
       (if 'property'->(frag.grammar.grammarIdentification).equal then
           true->isApropertyEditor;
           theGrammar.grammarAst.root[]->grammar[];
           theGrammar[]->ag[]
        else
           theGrammar.grammarAst.root[]->grammar[]; theGrammar[]->ag[]
       if)
   if);
   grammar.getProductionList->prodList[];
   astView.out.init;
   frag.grammar.grammarAst.father->fg[];
   (fg.fullName).copy->help[];
   (help.length-4,help.length)->help.delete;
   help[] (*fg.fullName*) ->astView.pp.init;
   true->astView.pp.abstractPresentation;
   true->astView.pp.editorMode;
   getPropertiesFromGrammar;
   INNER init;
   theSifTexteditor.onOpen
#)  

-- codeviewerSetIsReadOnly: DoPart --
do INNER  

-- codeviewerOnOpen: DoPart --
do
   (if editorRoot[] <> none then
       (if (editorRoot[] = fragDotRoot) and (no = 1) then
       (* only if not a subeditor and if it is the first editor on this ff *)
           automaticHolocomments
       if);
       (if initialSelection[] <> none then
       (* Open contractions before prettyprinting to prevent prettyprinting
        * twice: *)
           initialSelection[]->openContractionsUntilRoot; 
        else
           (if (editorRoot[] = fragDotRoot) and (no = 1) then
           (* only if not a subeditor and if it is the first editor on this ff *)
               (if (theSifTexteditor.initialContractionLevel <> 0) and not
               isApropertyEditor and not isASubEditor then
                   (editorRoot[],theSifTexteditor.initialContractionLevel)
                     ->openContractionLevel;
                   
               if)
           if);
           
       if);
       (if adaptivePrettyprinting then
           theSifTexteditor.contents.size->theSifTexteditor.charWidth
             ->astView.pp.width
        else
           80->astView.pp.width
       if);
       (if switch[13] then
           'onOpen: pp width '->putText; astView.pp.width->putInt; newLine
       if);
       (editorRoot[],- 1)->astView.pp.present;
       (if initialSelection[] <> none then
           (if switch[8] then
               'initial selection: '->putText;
               initialSelection.index->putInt;
               newLine
           if);
           (initialSelection[],1,0,0)->setFocus;
           (if switch[8] then
               'cs.node index after setfocus: '->putText;
               cs.node.index->putInt;
               newLine
           if);
           
        else
           (if switch[8] then 'initial selection is none!'->putLine if);
           (1,1,true)->selectionToFocus;
           (if switch[8] then
               'initial selection was set to: '->putText;
               cs.node.index->putInt;
               newLine
           if);
           
       if);
       (if not isApropertyEditor then
           (if switch[8] then
               'history onOpen: adding end  point; '->putText;
               cs.node.index->putInt;
               newLine
           if);
           cs.node[]->updateHistory
       if)
   if)  

-- codeviewerOnUpArrowKey: DoPart --
do
     (# s,e: @integer; 
     do
        dir.pred->navigate;
        (*cs->setFocus;*)
        (* 'onUpArrow: '->putText;
         theSifTexteditor.contents.selection.start->putInt;
         ' '->put;
         theSifTexteditor.contents.selection.end->putInt;
         newLine;
         theSifTexteditor.contents.selection->(s,e);
         (s,e,true)->selectionToFocus*)
        
     #)  

-- codeviewerOnDownArrowKey: DoPart --
do
     (# s,e: @integer; 
     do
        dir.next->navigate;
        (*cs
         ->setFocus*)
        (*'onDownArrow: '->putText;
         theSifTexteditor.contents.selection.start->putInt;
         ' '->put;
         theSifTexteditor.contents.selection.end->putInt;
         newLine;
         theSifTexteditor.contents.selection->(s,e);
         (s,e,true)->selectionToFocus*)
        
     #)  

-- codeviewerOnLeftArrowKey: DoPart --
do
     (# s,e: @integer; 
     do
        dir.up->navigate;
        (*cs->setFocus;*)
        (*'onLeftArrow: '->putText;
         theSifTexteditor.contents.selection.start->putInt;
         ' '->put;
         theSifTexteditor.contents.selection.end->putInt;
         newLine;
         theSifTexteditor.contents.selection->(s,e);
         (s,e,true)->selectionToFocus*)
        
     #)  

-- codeviewerOnRightArrowKey: DoPart --
do
     (# s,e: @integer; 
     do
        dir.down->navigate;
        (*cs->setFocus;*)
        (*'onRightArrow: '->putText;
         theSifTexteditor.contents.selection.start->putInt;
         ' '->put;
         theSifTexteditor.contents.selection.end->putInt;
         newLine;
         theSifTexteditor.contents.selection->(s,e);
         (s,e,true)->selectionToFocus*)
        
     #)  

-- codeviewerOnReturnKey: DoPart --
do INNER onReturnKey;   

-- codeviewerKeyAllowed: DoPart --
do true->value; INNER  

-- codeviewerCheckFormEditorExistence: DoPart --
do INNER checkFormEditorExistence  

-- codeviewerSetupFormEditor: DoPart --
do INNER setupFormEditor  

-- codeviewerNodeExists: Descriptor --
(# 
do
   false->value;
   (if node[] = none then
       'NodeExists: node is none!!'->putLine; 
    else
       (if subtree[] = none then
           'NodeExists: subtree is none!!'->putLine; 
        else
           (if node.frag[] <> subtree.frag[] then
               'NodeExists: node and subtree are not in same fragment!!'
                 ->putLine;
               (if node.frag.father = none then
                   'the fragmentform has no father!'->putLine;
                   'node: '->putText;
                   
                else
                   'node: '->putText; (node.frag.father).name->putText; '-'->put
               if);
               node.frag.name->putText;
               '-'->put;
               node.index->putInt;
               newline;
               'subtree: '->putText;
               (if subtree.frag.father = none then
                   'the fragmentform has no father!'->putLine;
                   'node: '->putText;
                   
                else
                   'subtree: '->putText;
                   (subtree.frag.father).name->putText;
                   '-'->put
               if);
               subtree.frag.name->putText;
               '-'->put;
               subtree.index->putInt;
               newline
            else
               loop: subtree.suffixwalk
                 (# 
                 do
                    (if node[]->current.equal then true->value; leave loop if)
                 #);
               
           if)
       if)
   if)
#)  

-- codeviewerIsNodeInTree: Descriptor --
(# 
do
   false->value;
   (if tree.kind = mps.kinds.interior then
       (node[],tree[])->nodeExists->value
    else
       (node[]->tree.equal)->value
   if)
#)  

-- codeviewerCSperform: DoPart --
do
   (if length = 1 then
       node[]->current[]; INNER perform; current[]->localOnRefresh; 
    else
       node.father->fatherNode[];
       (if fatherNode[] <> none then
           (if fatherNode.kind = mps.kinds.interior then
               fatherNode[]->exp[];
               (for i: length repeat
                 node.sonNo+i-1->exp.get->current[];
                 INNER perform;
                 current[]->localOnRefresh;
                 
               for);
               (* (exp[],node.sonNo,length,length)
                ->astView.pp.updateList*)
               
           if)
       if);
       
   if);
   (node[],length,subCommentInx1,subCommentInx2)->astToSelection;
     

-- codeviewerSetFocus: Descriptor --
(# found: @boolean; nextCS: @mps.astFocus
do
   newCS->nextCS;
   (if nextCS.node[] <> none then
       (nextCS.node[],editorRoot[])->isNodeInTree->found;
       (if not found then
           (if not (editorRoot[]->frag.root.equal) (* is a subeditor *) then
               (nextCS.node[],frag.root[])->isNodeInTree->found;
               (if found then
                   frag.root[]->editorRoot[]->theSifTexteditor.editorRoot[];
                   (editorRoot[],- 1)->astView.pp.present
                else
                   nodeNotFound;
                   'Selecting root instead (1)'->putLine;
                   (editorRoot[],1,0,0)->nextCS;
                   true->found
               if)
            else
               nodeNotFound;
               'Selecting root instead (2)'->putLine;
               (editorRoot[],1,0,0)->nextCS;
               true->found
           if)
       if)
    else
       nodeNotFound;
       'Selecting root instead (3)'->putLine;
       (editorRoot[],1,0,0)->nextCS;
       true->found
   if);
   (if found then
       nextCS->cs;
       checkSon;
       cs->frag.notifyFocusChanged;
       cs->localOnFocusChanged;
       (if scrollIntoView then theSifTexteditor.scrollIntoView if)
    else
       'setFocus: node not found'->putLine
   if)
#)  

-- codeviewerLocalOnRefresh: DoPart --
do INNER localOnRefresh  

-- codeviewerLocalOnFocusChanged: DoPart --
do (newCS,true)->updatePresentation; INNER localOnFocusChanged  

-- codeviewerSetNode: DoPart --
do
   (if node[] <> none then
       (node[],1,0,0)->setFocus;
       (* !!! (if theSifTextEditor[] <> none then theSifTextEditor[]->target if); *)
       (if switch[8] then
           'history setNode: adding end  point; '->putText;
           (cs.node.frag.father).name->putText;
           '-'->put;
           cs.node.frag.name->putText;
           '-'->put;
           cs.node.index->putInt;
           newLine;
           
       if);
       cs.node[]->updateHistory;
       (* tempory hack to avoid wrong selection when following semantic links and slot link to betaenv! *)
       (node[],1,0,0)->setFocus
   if)  

-- codeviewerSelectionToAst: Descriptor --
(#
   line1,char1,line2,char2: @integer;
   startNode,endNode,nca,firstListElement,lastListElement: ^astInterface.ast;
   prod: ^mg.prod;
   expNode: ^astInterface.expanded;
   startSonNo,endSonNo: @integer;
   synCatNo: @mps.nonterminalSymbol;
   startInx,startSubinx,endInx,endSubInx: @integer
do
   (if start = end then
       start->theSifTexteditor.posToLineChar->(line1,char1);
       (if switch[2] then
           'onClick after posToLineChar: '->putText;
           line1->screen.putint;
           ' '->screen.put;
           char1->screen.putint;
           ' '->screen.put;
           
       if);
       (line1,char1)->astView.pp.hit->(startNode[],startInx,startSubinx);
       startNode[]->nca[];
       0->startSonNo;
       (if switch[2] then
           'onClick: startSonNo, index: '->putText;
           startSonNo->putInt;
           ' '->put;
           startNode.index->putInt;
           newLine;
           'startSon: inx, subinx: '->putText;
           startInx->putInt;
           ' '->put;
           startSubInx->putInt;
           newLine;
           
       if)
    else
       start->theSifTexteditor.posToLineChar->(line1,char1);
       end->theSifTexteditor.posToLineChar->(line2,char2);
       (if switch[2] then
           'onClick after posToLineChar: '->putText;
           line1->screen.putint;
           ' '->screen.put;
           char1->screen.putint;
           ' '->screen.put;
           line2->screen.putint;
           ' '->screen.put;
           char2->screen.putint;
           ' '->screen.put;
           newLine;
           
       if);
       (line1,char1)->astView.pp.hit->(startNode[],startInx,startSubinx);
       (line2,char2)->astView.pp.hit->(endNode[],endInx,endSubInx);
       startNode[]->endNode.nearestCommonAncestor->(nca[],startSonNo,endSonNo);
       (if (startNode[]->endNode.equal) and (startInx = endInx) and
       (startSubinx = endSubinx) then
           
        else
           0->startInx->startSubInx
       if);
       (if switch[2] then
           'onClick: startSonNo, index: '->putText;
           startSonNo->putInt;
           ' '->put;
           startNode.index->putInt;
           newLine;
           'startSon: inx, subinx: '->putText;
           startInx->putInt;
           ' '->put;
           startSubInx->putInt;
           newLine;
           'onClick endSonNo, index: '->putText;
           endSonNo->putInt;
           ' '->put;
           endNode.index->putInt;
           newLine;
           'emdSon: inx, subinx: '->putText;
           endInx->putInt;
           ' '->put;
           endSubInx->putInt;
           newLine;
           'noClick: nca index: '->putText;
           nca.index->putInt;
           newLine;
           
       if);
       
   if);
   (if ((startSonNo = 0) or (endSonNo = 0)) then
       (nca[],1,startInx,startSubInx)->newCS
    else
       nca[]->getSynCatNo->synCatNo;
       (if synCatNo.isLexem then
           (nca[],1,startInx,startSubInx)->newCS; 
        else
           synCatNo->prodList.get->prod[];
           (if prod.symbol
            // mg.listZero // mg.listOne then
               nca[]->expNode[];
               startSonNo->expNode.get->firstListElement[];
               endSonNo->expNode.get->lastListElement[];
               (if switch[2] then
                   'onClick: first: '->putText;
                   firstListElement.index->putInt;
                   newLine;
                   'onClick: last: '->putText;
                   lastListElement.index->putInt;
                   newLine;
                   
               if);
               (firstListElement[],endSonNo-startSonNo+1,0,0)->newCS;
               
            else
               (nca[],1,startInx,startSubInx)->newCS; 
           if);
           
       if);
       
   if)
#)  

-- codeviewerSelectionToFocus: DoPart --
do
   (start,end)->selectionToAST
     ->setFocus
       (# scrollIntoView::  (#  do doScrollIntoView->value #) #)  

-- codeviewerSelectNodeInFormEditor: DoPart --
do
     (#
        historyBefore:
          (# 
          do
             (if switch[8] then
                 'history selectNodeInFormEditor: adding start point:  '
                   ->putText;
                 (cs.node.frag.father).name->putText;
                 '-'->put;
                 cs.node.frag.name->putText;
                 ':'->put;
                 cs.node.index->putInt;
                 newLine
             if);
             cs.node[]->updateHistory
          #);
        historyAfter:
          (# 
          do
             (if switch[8] then
                 'history selectNodeInFormEditor: adding end point:  '->putText;
                 (cs.node.frag.father).name->putText;
                 '-'->put;
                 cs.node.frag.name->putText;
                 ':'->put;
                 cs.node.index->putInt;
                 newLine
             if);
             cs.node[]->updateHistory
          #)
     do
        (if node[] = none then
            'selectNodeInFormEditor: node[] is none!!'->putLine
         else
            historyBefore;
            (if isASubeditor then
                (if node.frag[] <> frag[] then
                    (node.frag.root[],node[])->openSubEditor
                 else
                    (if (node[],editorRoot[])->isNodeInTree then
                        (node[],1,0,0)->setfocus; historyAfter
                     else
                    (* was in r4.0.1: (node.frag.root[],node[])->openSubEditor;*)
                        (if (node[],frag.root[])->isNodeInTree then
                            frag.root[]->editorRoot[]
                              ->theSifTexteditor.editorRoot[];
                            (editorRoot[],- 1)->astView.pp.present;
                            (node[],1,0,0)->setfocus;
                            historyAfter
                        if)
                    if)
                if)
             else
                (if separate or (node.frag[] <> frag[]) then
                    INNER selectNodeInFormEditor
                 else
                    (node[],1,0,0)->setfocus; historyAfter
                if)
            if)
        if)
     #)  

-- codeviewerHandleDoubleClick: Descriptor --
(# unexp: ^astInterface.unexpanded
do
   INNER handleDoubleClick;
   (if not doneInInner then
       (if cs.isComment then
           modifier->makeShowComment
        else
           (if cs.isContraction then
               makeDetail
            else
               (if cs.isSlot then
                   modifier->makeSearchSlotBinding
                else
                   (if cs.hasSemanticLink then
                       modifier->makeFollowSemanticLink
                    else
                       (if modifier and (cs.length = 1) then
                       (*(cs.node[],cs.node[]->openSubEditor*)
                           (cs.node[],cs.node[],true)->selectNodeInFormEditor
                        else
                           (if false
                           (* disable this feature, due to 'nervous' users like jlk :-) *)
                           then
                               cs->astToSelection;
                               (if cs.node.kind <> mps.kinds.unexpanded then
                                   makeAbstract
                               if)
                           if);
                           (if cs.isInPatternDecl then
                               (if cs.thePatternDecl[] <> none then
                                   (cs.thePatternDecl[],1,0,0)->setFocus
                               if)
                           if);
                           cs.perform
                             (#  do (current[],1)->openContractionLevel #)
                       if)
                   if)
               if)
           if)
       if)
   if)
#)  

-- codeviewerSetContraction: DoPart --
do
   thisOperation:
     (# newComment: ^astInterface.comment; t: ^text
     do
        (if node[] = none then cs.node[]->node[] if);
        (if not node.hasComment then
            mps.protect
              (#
                 ASToverflow:: 
                   (# msg: ^text
                   do
                      'SetContraction: AST overflow in '->msg[];
                      (frag.father).name->msg.append;
                      '-'->msg.append;
                      frag.name->msg.append;
                      '\nMjolner is quitting, but the AST will be automatically garbage-collected'
                        ->msg.append;
                      (none ,msg[],'SetContraction: AST overflow')
                        ->UI.alertUser;
                      msg[]->putLine;
                      none ->mps.theCatcher[];
                      callQuit;
                      leave thisOperation
                   #)
              do
                 (mps.comment,0,frag[])->theGrammar.newlexemText (#  #)
                   ->newComment[]
              #);
            &text[]->t[];
            t[]->newcomment.putText;
            newComment[]->node.addComment
        if);
        astView.pp.holocomment->node.typeOfComment
     #)  

-- codeviewerAskZoomIn: DoPart --
do true->value  

-- codeviewerAskZoomOut: DoPart --
do (editorRoot[] <> frag.root[])->value  

-- codeviewerAskZoomFullEditor: DoPart --
do (editorRoot[] <> frag.root[])->value  

-- codeviewerDoZoomIn: DoPart --
do
   ui.cursors.watch[]->UI.mouse.busyCursor;
   cs.node[]->editorRoot[]->theSifTexteditor.editorRoot[];
   (editorRoot[],- 1)->astView.pp.present;
   cs->setFocus;
   none ->UI.mouse.busyCursor  

-- codeviewerDoZoomOut: DoPart --
do
   (if editorRoot.father <> none then
       ui.cursors.watch[]->UI.mouse.busyCursor;
       editorRoot.father->editorRoot[]->theSifTexteditor.editorRoot[];
       (editorRoot[],- 1)->astView.pp.present;
       cs->setFocus;
       none ->UI.mouse.busyCursor
   if)  

-- codeviewerDoZoomFullEditor: DoPart --
do
   ui.cursors.watch[]->UI.mouse.busyCursor;
   frag.root[]->editorRoot[]->theSifTexteditor.editorRoot[];
   (editorRoot[],- 1)->astView.pp.present;
   cs->setFocus;
   none ->UI.mouse.busyCursor  

-- codeviewerDoReprettyprint: DoPart --
do
   ui.cursors.watch[]->UI.mouse.busyCursor;
   (editorRoot[],- 1)->astView.pp.present;
   cs->setFocus;
   none ->UI.mouse.busyCursor  

-- showAstBody: Descriptor --
(# 
do
   trace
     (#  do 'showAst'->str[] #);
   (if edDebug then
       (1,screen[])->editorRoot.dump;
       newLine;
       'cs.node.index/isSon: '->screen.putText;
       cs.node.index->putInt;
       ' '->put;
       (if (cs.node.father <> none ) then cs.node.sonNo->putInt if);
       newLine;
       
   if);
   
#)  

-- doShowAst: DoPart --
do (*node[]->*) newLine; (1,screen[])->node.dump; newLine  

-- searchSLOTPrivate: Descriptor --
(#
   theSlot: ^astInterface.slotDesc;
   fgtable: @hashtable
     (#
        element:: mps.fragmentGroup;
        hashFunction::  (#  do e.modtime->value #)
     #);
   init: (#  do fgtable.init #);
   slotName: ^text;
   searchBinding:
     (#
        searchFrag,fg: ^astInterface.fragmentGroup;
        found: @boolean;
        ff: ^astInterface.fragmentForm;
        help: ^text;
        de: @diskentry;
        has_nti_prefix: booleanValue
          (# t: ^text
          enter t[]
          do
             (if t.length >= 3 then
                 (if 'nti'->((1,3)->t.sub).equal then true->value if)
             if)
          #)
     enter searchFrag[]
     do
        (if searchFrag[]->fgtable.has then leave searchBinding if);
        searchFrag[]->fgtable.insert;
        thisOperation:
          (# 
          do
             searchFrag.fragmentList.scan
               (# 
               do
                  (if (current.name[]->slotName.equalNCS) then
                      (if current.type = mps.formType then
                          true->found;
                          (if traceSLOTsearch then newLine if);
                          current.f[]->ff[]->bindingFound;
                          leave thisOperation
                       else
                          'Not a fragment form! '->putLine
                      if)
                  if)
               #);
             search: searchFrag.prop.scanProp
               (#
                  doProp::< 
                    (# 
                    do
                       (if true
                        // ('BODY'->prop.equalNCS) // ('ORIGIN'->prop.equalNCS)
                        then
                           scanParameters
                             (#
                                doString::< 
                                  (# 
                                  do
                                     searchFrag.fullName->de.path;
                                     (if traceSLOTsearch then
                                         s[]->screen.putText; ' '->screen.put
                                     if);
                                     (s[],de.path.head)
                                       ->mps.thePathHandler.convertFilePath
                                       ->help[];
                                     help[]->getFragmentGroup->fg[];
                                     (if (* should test if open already *) fg[]
                                     = none then (*s.copy*)
                                         help.copy->help[];
                                         ' could not be opened(1)'
                                           ->help.putText;
                                         help[]
                                           ->putLine
                                           (* (none ,help[],
                                            'Follow Link To Fragment')->UI.alertUser*)
                                      else
                                         (if not fg.isRealOpen then
                                         (*'searchBinding: '->putText;
                                          fg.name->putText;
                                          'fg was not realopen'->putLine;*)
                                             fg.realOpen
                                         if);
                                         fg.fragmentList.scan
                                           (# 
                                           do
                                              (if
                                              (current.name[]
                                                 ->slotName.equalNCS) then
                                                  (if current.type =
                                                  mps.formType then
                                                      true->found;
                                                      (if traceSLOTsearch then
                                                          newLine
                                                      if);
                                                      current.f[]->ff[]
                                                        ->bindingFound;
                                                      leave search
                                                   else
                                                      'Not a fragment form! '
                                                        ->putLine
                                                  if)
                                              if)
                                           #);
                                         fg[]->&searchBinding->found;
                                         (if found then leave search if)
                                     if)
                                  #)
                             #)
                        // ('MDBODY'->prop.equalNCS) then
                           searchMDbody: scanParameters
                             (#
                                t,name: ^text;
                                foundMachineType,isDefaultMachine,noMachineType:
                                  @boolean;
                                doName::< 
                                  (# 
                                  do
                                     machineType->t[];
                                     n[]->name[];
                                     (if traceSLOTsearch then
                                         n[]->screen.putText; ' '->screen.put
                                     if);
                                     (if t[] <> none then
                                         (if t[]->n.equal then
                                             true->foundMachineType; 
                                          else
                                             (if (machineType->has_nti_prefix)
                                             and (n[]->has_nti_prefix) then
                                                 true->foundMachineType
                                              else
                                                 (if 'default'->n.equal then
                                                     true->isDefaultMachine
                                                 if)
                                             if)
                                         if)
                                      else
                                         true->noMachineType;
                                         'Unknown machine type'->putLine
                                     if)
                                  #);
                                doString::< 
                                  (# msg: ^text
                                  do
                                     searchFrag.fullName->de.path;
                                     (if traceSLOTsearch then
                                         s[]->screen.putText; ' '->screen.put
                                     if);
                                     (if foundMachineType or isDefaultMachine or
                                     noMachineType then
                                         'Choosing MDBODY '->msg[];
                                         (if foundMachineType then
                                             t[]->msg.putLine
                                          else
                                             name[]->msg.putLine
                                         if);
                                         msg[]->putLine;
                                         (s[],de.path.head)
                                           ->mps.thePathHandler.convertFilePath
                                           ->help[];
                                         help[]->getFragmentGroup->fg[];
                                         (if (* should test if open already *)
                                         fg[] = none then (*s.copy*)
                                             help.copy->help[];
                                             ' could not be opened (2)'
                                               ->help.putText;
                                             help[]
                                               ->putLine
                                               (* (none ,help[],
                                                'Follow Link To Fragment')->UI.alertUser*)
                                          else
                                             (if not fg.isRealOpen then
                                             (*'searchBinding: '->putText;
                                              fg.name->putText;
                                              ' was not realopen'->putLine;*)
                                                 fg.realOpen
                                             if);
                                             fg.fragmentList.scan
                                               (# 
                                               do
                                                  (if
                                                  (current.name[]
                                                     ->slotName.equalNCS) then
                                                      (if current.type =
                                                      mps.formType then
                                                          true->found;
                                                          (if traceSLOTsearch
                                                           then
                                                              newLine
                                                          if);
                                                          current.f[]->ff[]
                                                            ->bindingFound;
                                                          leave search
                                                       else
                                                          'Not a fragment form! '
                                                            ->putLine
                                                      if)
                                                  if)
                                               #);
                                             fg[]->&searchBinding->found;
                                             (if found then leave search if)
                                         if);
                                         leave searchMDbody
                                     if)
                                  #)
                             #)
                       if)
                    #)
               #)
          #)
     exit found
     #)
#)  

-- searchSlotBinding: DoPart --
do
     (# found: @boolean
     do
        searchedUnexp.theSlot->searchSLOTbindingPrivate.theSlot[];
        searchSLOTbindingPrivate.theSlot.name
          ->searchSLOTbindingPrivate.slotName[];
        (if traceSLOTsearch then
            newLine;
            'Searching for a SLOT binding of \''->putText;
            searchSLOTbindingPrivate.slotName[]->putText;
            '\''->put;
            ' in:'->putLine
        if);
        searchSLOTbindingPrivate.init;
        frag.father->&searchSLOTbindingPrivate.searchBinding->found;
        (if not found then
            searchSLOTbindingPrivate.slotName[]->bindingNotFound
        if)
     #)  

-- codeviewerSetWaitCursor: DoPart --
do ui.cursors.watch[]->UI.mouse.busyCursor  

-- codeviewerSetStructureCursor: DoPart --
do UI.cursors.arrow[]->UI.mouse.busyCursor  

-- codeviewerMakeFollowSemanticLink: DoPart --
do
   INNER makeFollowSemanticLink;
   (if not doneInInner then
       (if cs.node.kind
        // mps.kinds.nameDecl // mps.kinds.nameAppl then
           (cs.node[],separate)->followSemanticLink
       if)
   if)  

-- codeviewerMakeSearchSlotBinding: DoPart --
do
   INNER makeSearchSlotBinding;
   (if doneInInner then
       (if a[] <> none then (a[],a[],separate)->selectNodeInFormEditor;  if)
    else
       cs.node[]
         ->searchSlotBinding
           (#
              bindingFound::< 
                (# 
                do
                   (if ff[] = none then
                       'bindingFound: ff is none!! '->putLine
                    else
                       (ff.root[],ff.root[],separate)->selectNodeInFormEditor
                   if)
                #);
              bindingNotFound:: 
                (# help: ^text
                do
                   slotName[]->help[];
                   ' not found'->help.append;
                   (none ,help[],'Search SLOT')->UI.alertUser
                #)
           #)
   if)  

-- codeviewerMakeDetail: DoPart --
do (*'makeDetail'->putLine;*)
   CS.node[]->openContraction;
   CS.node[]->localOnRefresh;
   cs->astToSelection;
   theSifTextEditor.contents.selection.scrollIntoView  

-- codeviewerDoDetail: DoPart --
do
   (if cs.isComment then
       makeShowComment
    else
       (if cs.hasSemanticLink then
           (cs.node[],false)->followSemanticLink
        else
           (if cs.isSlot then
               doCommand (#  do makeSearchSlotBinding #)
            else
               (if cs.isInPatternDecl then
                   (if cs.thePatternDecl[] <> none then
                       (cs.thePatternDecl[],1,0,0)->setFocus
                   if)
               if);
               cs.perform
                 (#  do (current[],1)->openContractionLevel #)
           if)
       if)
   if)  

-- codeviewerMakeAbstract: DoPart --
do
   CS.node[]->setContraction;
   (if cs.node.father = none then
       (editorRoot[],- 1)->astView.pp.present
    else
       CS.node[]->localOnRefresh; 
   if);
   cs->astToSelection  

-- codeviewerMakeShowComment: DoPart --
do
   INNER makeShowComment;
   (if not doneInInner then
       (if modifier then
           (cs.node[],cs.subcommentinx1,cs.subcommentinx2)->createCommentWindow
        else
           not astView.pp.includeComments->astView.pp.includeComments;
           CS.node[]->localOnRefresh;
           cs->astToSelection
       if);
       
   if)  

-- codeviewerSelectArea: DoPart --
do
   (if astView.pp.ppDebug then
       ' selectarea: '->putText;
       f.node.index->putInt;
       ' '->put;
       f.length->putInt;
       newLine;
       
   if);
   (f.node[],f.subcommentInx1,f.subcommentInx2)->astView.pp.select
     ->(l1,c1,l2,c2);
   (if (1 < f.length) then
       (if (1 < f.length) then
           f.node[]->checkFatherNode->node[];
           (if astView.pp.ppDebug then
               'node.index: '->putText; node.index->putInt; newLine; 
           if);
           node.father->fatherNode[];
           (if astView.pp.ppDebug then
               'fathernode.index: '->putText;
               fathernode.index->putInt;
               newLine;
               
           if);
           (node.sonNo+f.length-1)->fatherNode.get->node[];
           (node[],0,0)->astView.pp.select->(l,c,l2,c2);
           
       if);
       
   if);
     

-- codeviewerSetTextStyle: DoPart --
do style->theSifTexteditor.contents.setTextStyle  

-- codeviewerGetPropertiesFromGrammar: DoPart --
do
   frag.grammar.kindArray.range-contractionCategories.range
     ->contractionCategories.extend;
   frag.grammar.grammarAst.father->fg[];
   (if fg.prop[]
    // none then 
    else
       'contractioncategoriesvalues'
         ->fg.prop.getProp
           (#
              doprop::< 
                (# 
                do
                   scanParameters
                     (#
                        doConst::< 
                          (# 
                          do
                             (if
                             ((c > 0) and (c <= contractionCategories.range))
                              then
                                 1->contractionCategories[c]
                             if)
                          #)
                     #)
                #)
           #);
       'longLexems'
         ->fg.prop.getProp
           (#
              doProp::<  (#  do true->astView.pp.specialLexemTreatment;  #)
           #);
       'longLexemsWithQuote'
         ->fg.prop.getProp
           (#
              doProp::< 
                (# 
                do
                   true
                     ->
                       astView.pp.specialLexemTreatment
                       (*->longLexemsWithquote*) ;
                   
                #)
           #);
       
   if);
     

-- codeviewerSetContractions: DoPart --
do
   (if node[] = none then cs.node[]->node[] if);
   (if (node## <= mps.expanded##) then
       node[]->expNode[];
       expNode.suffixWalk
         (#
            unexp: ^astInterface.unexpanded;
            aList: ^astInterface.list;
            doContract: @boolean;
            prod: ^mg.prod
         do
            true->doContract;
            Current.symbol->symbol;
            (if symbol.predefined then
                false->doContract; 
             else
                (if Current.kind
                 // mps.kinds.unexpanded then
                    Current[]->unexp[]; false->doContract; 
                 // mps.kinds.list then
                    Current[]->aList[];
                    (aList.noOfSons > 3 (* should be user-changable *) )
                      ->doContract;
                    
                 // mps.kinds.optional then
                    false->doContract
                 // mps.kinds.interior then
                    symbol->Prodlist.get->prod[];
                    (if prod.symbol
                     // mg.listOne // mg.listZero then
                        Current[]->aList[];
                        (aList.noOfSons > 3 (* should be user-changable *) )
                          ->doContract;
                        
                    if);
                    
                 else
                    
                if);
                (if doContract then
                    (if contractionCategories[symbol]
                     // 1 then Current[]->setContraction
                    if);
                    
                if)
            if)
         #)
   if)  

-- codeviewerInContraction: DoPart --
do
   false->inContr;
   loop:
     (# 
     do
        node.father->fatherNode[];
        (if (fatherNode[] <> none ) then
            (if fatherNode.hasComment then
                (if (fatherNode.typeOfComment = astView.pp.holocomment) then
                    fatherNode[]->contractionNode[]; true->inContr; leave loop
                if);
                
            if);
            fatherNode[]->node[];
            restart loop;
            
        if);
        
     #);
     

-- codeviewerOpenContractionsUntilRoot: DoPart --
do
   false->inHolo;
   loop:
     (# 
     do
        node.father->fatherNode[];
        (if (fatherNode[] <> none ) then
            (if fatherNode.hasComment then
                (if (fatherNode.typeOfComment = astView.pp.holocomment) then
                    fatherNode[]->holoNode[]->openContraction; true->inHolo; 
                if);
                
            if);
            fatherNode[]->node[];
            restart loop;
            
        if);
        
     #);
     

-- codeviewerOpenContraction: DoPart --
do
   (if node[] = none then cs.node[]->node[] if);
   (if node.hasComment then
       (if node.typeOfComment
        // astView.pp.holocomment then
           node.getComment->aComment[];
           (if (aComment.curLength > 0) then
               astView.pp.normalComment->node.typeOfComment; 
            else
               none ->node.addComment; 
           if);
           
       if);
       
   if);
     

-- codeviewerOpenAllContractions: DoPart --
do
   (if node[] = none then cs.node[]->node[] if);
   (node[],1000)->openContractionLevel  

-- codeviewerOpenContractionLevel: DoPart --
do
   (if node.hasComment then
       (if node.typeOfComment
        // astView.pp.holocomment then
           node.getComment->aComment[];
           (if (aComment.curLength > 0) then
               astView.pp.normalComment->node.typeOfComment; 
            else
               none ->node.addComment; 
           if);
           
       if);
       
   if);
   (if node.kind
    // mps.kinds.interior then
       node[]->anExp[];
       anExp.scan
         (# 
         do
            (if current.hasComment then
                (if current.typeOfComment
                 // astView.pp.holocomment then
                    current[]->openContraction; true->openedOne; 
                if)
            if);
            
         #);
       (if openedOne then level-1->level if);
       (if (level > 0) then
           anExp.scan (#  do (current[],level)->&openContractionLevel #)
       if)
   if)  

-- codeviewerFindSuper: DoPart --
do
     (#
        superSynCatNo,lastSuper: @mps.nonterminalSymbol;
        prod: ^mg.prod;
        constructor: ^mg.constructor;
        alternation: ^mg.alternation;
        opt: ^mg.opt;
        listOne: ^mg.listOne;
        listZero: ^mg.listZero;
        dummy: ^mg.dummy;
        leftSide: ^mg.leftSide;
        consElemList: ^mg.consElemList;
        consElem: ^mg.consElem;
        foundSuper: @boolean;
        
     do
        (if not synCatNo.isLexem then
            false->foundSuper;
            synCatNo->Prodlist.get->prod[];
            loop:
              (# 
              do
                 (if prod.symbol
                  // mg.constructor then
                     prod[]->constructor[];
                     constructor.getLeftside->leftSide[];
                     (if switch[16] then
                         constructor.getConsElemList->consElemList[];
                         consElemList.newScan
                           (# 
                           do current[]->consElem[]; consElem.dump; newLine
                           #)
                     if);
                     
                  // mg.alternation then
                     prod[]->alternation[];
                     alternation.getLeftside->leftSide[];
                     
                  // mg.opt then
                     prod[]->opt[]; opt.getLeftside->leftSide[]; 
                  // mg.listOne then
                     prod[]->listOne[]; listOne.getLeftside->leftSide[]; 
                  // mg.listZero then
                     prod[]->listZero[]; listZero.getLeftside->leftSide[]; 
                  // mg.dummy then
                     prod[]->dummy[]; dummy.getLeftside->leftSide[]; 
                 if);
                 1->leftSide.getAttribute->superSynCatNo;
                 (if switch[16] then
                     'superSynCatNo: '->screen.putText;
                     superSynCatNo->screen.putInt;
                     ' '->put;
                     superSynCatNo->ag.symbolToName->putLine;
                     
                 if);
                 (if superSynCatNo
                  // mps.super.cons then
                     (if switch[16] then 'super is cons'->putLine if); 
                  // mps.super.list then
                     (if switch[16] then 'super is list'->putLine if); 
                  // mps.super.undefined then
                     (if switch[16] then 'super is  undefined'->putLine if)
                  else
                     true->foundSuper;
                     superSynCatNo->Prodlist.get->prod[];
                     superSynCatNo->lastSuper;
                     restart loop;
                     
                 if);
                 
              #);
            (if foundSuper then lastSuper->synCatNo if)
        if);
        (if switch[16] then
            'findSuper: SynCatNo: '->screen.putText;
            synCatNo->screen.putInt;
            ' '->put;
            synCatNo->ag.symbolToName->putLine;
            
        if)
     #)  

-- codeviewerCheckSuper: DoPart --
do
     (#
        upperNode: ^astInterface.ast;
        superSynCatNo,lastSuper: @mps.nonterminalSymbol;
        prod: ^mg.prod;
        constructor: ^mg.constructor;
        alternation: ^mg.alternation;
        opt: ^mg.opt;
        listOne: ^mg.listOne;
        listZero: ^mg.listZero;
        dummy: ^mg.dummy;
        leftSide: ^mg.leftSide;
        consElemList: ^mg.consElemList;
        consElem: ^mg.consElem;
        foundSuper,inCons: @boolean;
        checkWhetherInCons:
          (#
             node,enclosingNode: ^astInterface.ast;
             inCons: @boolean;
             fatherNode: ^astInterface.ast;
             fatherSynCatNo: @mps.nonterminalSymbol;
             prod: ^mg.prod;
             constructor: ^mg.constructor;
             leftSide: ^mg.leftSide;
             consElemList: ^mg.consElemList;
             consElem: ^mg.consElem
          enter node[]
          do
             node.father->fatherNode[]->getSynCatNo->fatherSynCatNo;
             (if not fatherSynCatNo.isLexem then
                 false->foundSuper;
                 synCatNo->Prodlist.get->prod[];
                 (if prod.symbol = mg.constructor then
                     true->inCons;
                     fatherNode[]->enclosingNode[];
                     prod[]->constructor[];
                     constructor.getLeftside->leftSide[];
                     (if switch[16] then
                         constructor.getConsElemList->consElemList[];
                         consElemList.newScan
                           (# 
                           do current[]->consElem[]; consElem.dump; newLine
                           #)
                     if);
                     
                 if);
                 (if switch[16] then
                     (if inCons then
                         'enclosingNode: '->screen.putText;
                         enclosingNode.dump;
                         newLine
                      else
                         'not in cons'->putLine
                     if)
                 if)
             if)
          exit (inCons,enclosingNode[])
          #);
        
     do
        node[]->upperNode[];
        upperNode[]->checkFatherNode->upperNode[];
        upperNode[]->getSynCatNo->synCatNo;
        (if upperNode.father <> none then
            upperNode[]->checkWhetherInCons->(inCons,enclosingNode[])
        if);
        (if not inCons then
            (if not synCatNo.isLexem then
                false->foundSuper;
                synCatNo->Prodlist.get->prod[];
                loop:
                  (# 
                  do
                     (if prod.symbol
                      // mg.constructor then
                         prod[]->constructor[];
                         constructor.getLeftside->leftSide[];
                         (if switch[16] then
                             constructor.getConsElemList->consElemList[];
                             consElemList.newScan
                               (# 
                               do current[]->consElem[]; consElem.dump; newLine
                               #)
                         if);
                         
                      // mg.alternation then
                         prod[]->alternation[];
                         alternation.getLeftside->leftSide[];
                         
                      // mg.opt then
                         prod[]->opt[]; opt.getLeftside->leftSide[]; 
                      // mg.listOne then
                         prod[]->listOne[]; listOne.getLeftside->leftSide[]; 
                      // mg.listZero then
                         prod[]->listZero[]; listZero.getLeftside->leftSide[]; 
                      // mg.dummy then
                         prod[]->dummy[]; dummy.getLeftside->leftSide[]; 
                     if);
                     1->leftSide.getAttribute->superSynCatNo;
                     (if switch[16] then
                         'superSynCatNo: '->screen.putText;
                         superSynCatNo->screen.putInt;
                         ' '->put;
                         superSynCatNo->ag.symbolToName->putLine;
                         
                     if);
                     (if superSynCatNo
                      // mps.super.cons then
                         (if switch[16] then 'super is cons'->putLine if); 
                      // mps.super.list then
                         (if switch[16] then 'super is list'->putLine if); 
                      // mps.super.undefined then
                         (if switch[16] then
                             'super is  undefined'->putLine
                         if)
                      else
                         true->foundSuper;
                         superSynCatNo->Prodlist.get->prod[];
                         superSynCatNo->lastSuper;
                         restart loop;
                         
                     if);
                     
                  #);
                (if foundSuper then lastSuper->synCatNo if)
            if)
        if);
        (if switch[16] then
            (if inCons then
                'checkSuper: enclosingNode: '->screen.putText;
                enclosingNode.dump;
                newLine
             else
                'checkSuper: SynCatNo: '->screen.putText;
                synCatNo->screen.putInt;
                ' '->put;
                synCatNo->ag.symbolToName->putLine;
                'not in cons'->putLine
            if);
            
        if)
     #)  

-- codeviewerParsingSynCatNo: DoPart --
do
     (#
        node2: ^astInterface.ast;
        fatherSynCatNo,fatherSuperSynCatNo: @mps.nonterminalSymbol;
        prod,fatherProd: ^mg.prod;
        expNode,fatherNode: ^astInterface.expanded;
        trySuper: @boolean;
        
     do
        (if switch[16] then 'parsingSyncatno'->putLine if);
        false->isList;
        true->trySuper;
        node[]->getSynCatNo->synCatNo;
        (if not synCatNo.isLexem then
            synCatNo->Prodlist.get->prod[];
            (if prod.symbol
             // mg.listOne // mg.listZero then
                true->isList;
                false->trySuper;
                (if node.kind
                 // mps.kinds.unexpanded then
                 (* in the case of attributes slot!*)
                    node[]->theListElement[]; 
                 else
                    node[]->expNode[];
                    (if expNode.noOfSons > 0 then
                        expNode.getSon1->theListElement[]
                     else
                        expNode[]->theListElement[]
                    if);
                    
                if);
                
            if);
            
        if);
        node[]->node2[];
        (if not isList then
            node2[]->checkFatherNode->node2[]->getSynCatNo->synCatNo;
            node2.father->fatherNode[];
            (if switch[16] then
                'after checkFatherNode synCatNo: '->putText;
                synCatNo->putInt;
                ' '->put;
                synCatNo->ag.symbolToName->putLine;
                'index: '->putText;
                node2.index->putInt;
                newLine;
                
            if);
            (if fatherNode[] = none then (* root *)
                ; 
             else
                fatherNode[]->getSynCatNo->fatherSynCatNo->Prodlist.get
                  ->fatherProd[];
                (if fatherProd.symbol
                 // mg.listOne // mg.listZero then
                    fatherSynCatNo->synCatNo;
                    true->isList;
                    false->trySuper;
                    node2[]->theListElement[]
                if);
                
            if);
            
        if);
        (if trySuper then
            node[]->checkSuper->(synCatNo,enclosingNode[]);
            (* was  synCatNo->findSuper->synCatNo *)
            
        if);
        (if switch[16] then
            (if enclosingNode[] <> none then
                'parsingSynCatNo: enclosingNode: '->screen.putText;
                enclosingNode.dump;
                newLine
             else
                'parsingSynCatNo: synCatNo, isList: '->screen.putText;
                synCatNo->screen.putInt;
                ' '->put;
                synCatNo->ag.symbolToName->putLine;
                isList->screen.putBoolean;
                screen.newLine
            if);
            
        if);
        (* (if trySuper then
         node.father->getSyncatNo->findSuper->fatherSynCatNo;
         (if synCatNo = fatherSynCatNo then true->recursive if);
         
         if);*)
        
     #)  

-- codeviewerUpdatePresentation: DoPart --
do
     (#
        inContr: @boolean;
        contractionNode: ^astInterface.ast;
        t: ^text;
        commentAst: ^astInterface.comment;
        fatherNode: ^astInterface.ast;
        unexp: ^astInterface.unexpanded;
        setCSattributes:
          (# 
          do
             false->cs.isComment->cs.isContraction->cs.isUnexpanded->cs.isSlot
               ->cs.hasSemanticLink->cs.hasSemanticError->cs.isInPatternDecl;
             0->cs.semanticError;
             none ->cs.thePatternDecl[];
             (if (cs.subcommentInx1 <> 0) and ((cs.subcommentInx2 <> 0)) then
                 (cs.subCommentInx1,cs.subCommentInx2)->cs.node.getSubcomment
                   ->t[];
                 (if t[] <> none then
                     (if t.length <> 0 then
                         true->cs.isComment;
                         true->ShowCommentPermit;
                         false->MakeCommentPermit
                      else
                         0->cs.subcommentInx1->cs.subcommentInx2
                     if)
                  else
                     0->cs.subcommentInx1->cs.subcommentInx2
                 if)
             if);
             (if not cs.isComment then
                 true->MakeCommentPermit;
                 false->ShowCommentPermit;
                 (if cs.node.hasComment then
                     (if cs.node.typeOfComment = astView.pp.holocomment then
                         true->cs.isContraction
                     if)
                 if);
                 (if cs.node.kind = mps.kinds.unexpanded then
                     cs.node[]->unexp[];
                     (if unexp.isSlot then
                         true->cs.isSlot; 
                      else
                         true->cs.isUnexpanded
                     if)
                 if);
                 (if
                 'beta'
                   ->
                     (frag.grammar.grammarIdentification).equal
                     (* (mps[],cs.node.frag.father)->getDoneCheckProperty  is Checked *)
                     then
                     (if cs.node.kind
                      // mps.kinds.nameDecl // mps.kinds.nameAppl then
                         cs.node.father->fatherNode[];
                         (if fatherNode.symbol
                          // betaGrammar.nameDcl then
                             fatherNode.hasSemanticError->cs.hasSemanticError;
                             fatherNode.semanticError->cs.semanticError;
                             fatherNode.father->fatherNode[];
                             (if fatherNode.symbol
                              // betaGrammar.names then
                                 fatherNode.father->fatherNode[];
                                 (if fatherNode.symbol
                                  // betaGrammar.bindingDecl
                                  // betaGrammar.finalDecl then
                                     true->cs.hasSemanticLink
                                  // betaGrammar.patternDecl
                                  // betaGrammar.virtualDecl then
                                     true->cs.isInPatternDecl;
                                     fatherNode[]->cs.thePatternDecl[]
                                 if)
                             if)
                          // betaGrammar.nameApl then
                             true->cs.hasSemanticLink;
                             fatherNode.hasSemanticError->cs.hasSemanticError;
                             fatherNode.semanticError->cs.semanticError
                         if)
                      else
                         cs.node.hasSemanticError->cs.hasSemanticError;
                         cs.node.semanticError->cs.semanticError
                     if)
                 if)
             if);
             (if false then
                 'cs.isComment      : '->putText;
                 (if cs.isComment then
                     'TRUE'->putLine
                  else
                     'false'->putLine; 
                 if);
                 '['->put;
                 t[]->putText;
                 ']'->put;
                 newLine;
                 'cs.isContraction  : '->putText;
                 (if cs.isContraction then
                     'TRUE'->putLine
                  else
                     'false'->putLine; 
                 if);
                 'cs.isUnexpanded   : '->putText;
                 (if cs.isUnexpanded then
                     'TRUE'->putLine
                  else
                     'false'->putLine; 
                 if);
                 'cs.isSlot         : '->putText;
                 (if cs.isSlot then
                     'TRUE'->putLine
                  else
                     'false'->putLine; 
                 if);
                 'cs.hasSemanticLink: '->putText;
                 (if cs.hasSemanticLink then
                     'TRUE'->putLine
                  else
                     'false'->putLine; 
                 if);
                 'cs.hasSemanticError: '->putText;
                 (if cs.hasSemanticError then
                     'TRUE'->putLine;
                     cs.semanticError->mps.semanticErrorText->putLine
                  else
                     'false'->putLine; 
                 if);
                 'cs.isInPatternDecl: '->putText;
                 (if cs.isInPatternDecl then
                     'TRUE'->putLine; 
                  else
                     'false'->putLine; 
                 if)
             if);
             (if doObserveAST then newCS.node[]->ASTObserver if)
          #)
     do
        (if false then
            'updatePresentation ('->putText;
            no->putInt;
            ') '->putText;
            (if local then 'local '->putText if);
            (if isAfrejaEditor then 'isAfrejaEditor '->putText if);
            
        if);
        newCS.node[]->inContraction->(inContr,contractionNode[]);
        (if false then (if inContr then 'inContr '->putLine if) if);
        (if inContr then newCS.node[]->openContractionsUntilRoot if);
        (if local or isAfrejaEditor then
            (if inContr then (editorRoot[],- 1)->astView.pp.present if);
            newCS->cs->astToSelection
         else
            newCS->cs
        if);
        setCSattributes
     #)  

