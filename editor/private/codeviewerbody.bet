ORIGIN '../codeviewer';
-- codeviewerinit: Descriptor --
(# grammar: ^mg.Agrammar; exp: ^mps.expanded
do
   metaGrammarInit;
   &mps.astViewer[]->astView[];
   &windowOutput[]->astView.out[];
   root.frag[]->frag[];
   (if root.father <> none then true->isAsubeditor if);
   (if 'beta'->(frag.grammar.grammarIdentification).equal then
       theGrammar[]->betaGrammar[];
       betaGrammar.grammarAst.root[]->grammar[];
       betaGrammar[]->ag[]
    else
       (if 'property'->(frag.grammar.grammarIdentification).equal then
           true->isApropertyEditor;
           theGrammar.grammarAst.root[]->grammar[];
           theGrammar[]->ag[]
       if)
   if);
   grammar.getProductionList->prodList[];
   astView.out.init;
   frag.grammar.grammarAst.father->fg[];
   fg.father->fg[];
   fg.fullName->astView.pp.init;
   true->astView.pp.abstractPresentation;
   true->astView.pp.editorMode;
   theSifTextEditor.contents.size->theSifTextEditor.charWidth->astView.pp.width;
   getPropertiesFromGrammar;
   INNER init;
   theSifTexteditor.onOpen
#)  

-- codeviewerCheckFormEditorExistence: DoPart --
do INNER checkFormEditorExistence  

-- codeviewerSetupFormEditor: DoPart --
do INNER setupFormEditor  

-- codeviewerNodeExists: Descriptor --
(# 
do
   false->value;
   (if node[] = none then
       'NodeExists: node is none!!'->putLine; 
    else
       (if subtree[] = none then
           'NodeExists: subtree is none!!'->putLine; 
        else
           (if node.frag[] <> subtree.frag[] then
               'NodeExists: node and subtree are not in same fragment!!'
                 ->putLine;
               
            else
               loop: subtree.suffixwalk
                 (# 
                 do
                    (if node[]->current.equal then true->value; leave loop if)
                 #);
               
           if)
       if)
   if)
#)  

-- codeviewerSetFocus: Descriptor --
(# found: @boolean
do
   (if newCS.node[] <> none then
       (if true (*checkExistence*) then
           (newCS.node[],newCS.node.frag.root[])->nodeExists->found;
           (if not found then nodeNotFound if)
        else
           true->found
       if);
       (if found then
           newCS->cs;
           checkSon;
           cs->aFocusChangedEvent;
           theSifTexteditor.contents.selection.scrollIntoView;
           (*cs->astToSelection; is done in focuschangedEvent*)
           (* must be deleted on mac? *)
           
       if)
    else
       'SetFocus: newCS.node is none!!'->putLine; nodeNotFound
   if)
#)  

-- codeviewerFocusChangedEvent: Descriptor --
(#
   t: ^text;
   commentAst: ^mps.comment;
   inContr: @boolean;
   contractionNode,fatherNode: ^mps.ast;
   unexp: ^mps.unexpanded
do (* from notification.focusChanged *)
   newCS.node[]->inContraction->(inContr,contractionNode[]);
   (if inContr then
       newCS.node[]->openContractionsUntilRoot;
       ( (* root *) frag.root[],- 1)
         ->
           astView.pp.present
           (* should be update, mut disabled due to an error *)
   if);
   newCS->cs->astToSelection;
   false->cs.isComment->cs.isContraction->cs.isSlot->cs.hasSemanticLink;
   (if (cs.subcommentInx1 <> 0) and ((cs.subcommentInx2 <> 0)) then
       (cs.subCommentInx1,cs.subCommentInx2)->cs.node.getSubcomment->t[];
       (if t[] <> none then
           (t.length <> 0)->cs.isComment;
           true->ShowCommentPermit;
           false->MakeCommentPermit
       if)
   if);
   (if not cs.isComment then
       true->MakeCommentPermit;
       false->ShowCommentPermit;
       (if cs.node.hasComment then
           (if cs.node.typeOfComment = astView.pp.holocomment then
               true->cs.isContraction
           if)
       if);
       (if cs.node.kind = mps.kinds.unexpanded then
           cs.node[]->unexp[]; (if unexp.isSlot then true->cs.isSlot;  if)
       if);
       (if (mps[],cs.node.frag.father)->getDoneCheckProperty (* isChecked *)
        then
           (if cs.node.kind
            // mps.kinds.nameDecl // mps.kinds.nameAppl then
               cs.node.father->fatherNode[];
               (if fatherNode.symbol
                // betaGrammar.nameDcl then
                   fatherNode.father->fatherNode[];
                   (if fatherNode.symbol
                    // betaGrammar.names then
                       fatherNode.father->fatherNode[];
                       (if fatherNode.symbol
                        // betaGrammar.bindingDecl // betaGrammar.finalDecl then
                           true->cs.hasSemanticLink
                       if)
                   if)
                // betaGrammar.nameApl then
                   true->cs.hasSemanticLink; 
               if)
           if)
       if)
   if);
   (if false then
       'cs.isComment      : '->putText;
       (if cs.isComment then 'TRUE'->putLine else 'false'->putLine;  if);
       'cs.isContraction  : '->putText;
       (if cs.isContraction then 'TRUE'->putLine else 'false'->putLine;  if);
       'cs.isSlot         : '->putText;
       (if cs.isSlot then 'TRUE'->putLine else 'false'->putLine;  if);
       'cs.hasSemanticLink: '->putText;
       (if cs.hasSemanticLink then 'TRUE'->putLine else 'false'->putLine;  if)
   if);
   (if doObserveAST then newCS.node[]->ASTObserver if);
   INNER focusChangedEvent;
   
#)  

-- codeviewerSelectionToAst: Descriptor --
(#
   line1,char1,line2,char2: @integer;
   newCS: @astFocus;
   startNode,endNode,nca,firstListElement,lastListElement: ^mps.ast;
   prod: ^mg.prod;
   expNode: ^mps.expanded;
   startSonNo,endSonNo: @integer;
   synCatNo: @mps.nonterminalSymbol;
   startInx,startSubinx,endInx,endSubInx: @integer
do
   (if start = end then
       start->theSifTexteditor.posToLineChar->(line1,char1);
       (if switch[2] then
           'onClick after posToLineChar: '->putText;
           line1->screen.putint;
           ' '->screen.put;
           char1->screen.putint;
           ' '->screen.put;
           
       if);
       (line1,char1)->astView.pp.hit->(startNode[],startInx,startSubinx);
       startNode[]->nca[];
       0->startSonNo;
       (if switch[2] then
           'onClick: startSonNo, index: '->putText;
           startSonNo->putInt;
           ' '->put;
           startNode.index->putInt;
           newLine;
           'startSon: inx, subinx: '->putText;
           startInx->putInt;
           ' '->put;
           startSubInx->putInt;
           newLine;
           
       if)
    else
       start->theSifTexteditor.posToLineChar->(line1,char1);
       end->theSifTexteditor.posToLineChar->(line2,char2);
       (if switch[2] then
           'onClick after posToLineChar: '->putText;
           line1->screen.putint;
           ' '->screen.put;
           char1->screen.putint;
           ' '->screen.put;
           line2->screen.putint;
           ' '->screen.put;
           char2->screen.putint;
           ' '->screen.put;
           newLine;
           
       if);
       (line1,char1)->astView.pp.hit->(startNode[],startInx,startSubinx);
       (line2,char2)->astView.pp.hit->(endNode[],endInx,endSubInx);
       startNode[]->endNode.nearestCommonAncestor->(nca[],startSonNo,endSonNo);
       (if (startNode[]->endNode.equal) and (startInx = endInx) and
       (startSubinx = endSubinx) then
           
        else
           0->startInx->startSubInx
       if);
       (if switch[2] then
           'onClick: startSonNo, index: '->putText;
           startSonNo->putInt;
           ' '->put;
           startNode.index->putInt;
           newLine;
           'startSon: inx, subinx: '->putText;
           startInx->putInt;
           ' '->put;
           startSubInx->putInt;
           newLine;
           'onClick endSonNo, index: '->putText;
           endSonNo->putInt;
           ' '->put;
           endNode.index->putInt;
           newLine;
           'emdSon: inx, subinx: '->putText;
           endInx->putInt;
           ' '->put;
           endSubInx->putInt;
           newLine;
           'noClick: nca index: '->putText;
           nca.index->putInt;
           newLine;
           
       if);
       
   if);
   (if ((startSonNo = 0) or (endSonNo = 0)) then
       (nca[],1,startInx,startSubInx)->newCS
    else
       nca[]->getSynCatNo->synCatNo;
       (if synCatNo.isLexem then
           (nca[],1,startInx,startSubInx)->newCS; 
        else
           synCatNo->prodList.get->prod[];
           (if prod.symbol
            // mg.listZero // mg.listOne then
               nca[]->expNode[];
               startSonNo->expNode.get->firstListElement[];
               endSonNo->expNode.get->lastListElement[];
               (if switch[2] then
                   'onClick: first: '->putText;
                   firstListElement.index->putInt;
                   newLine;
                   'onClick: last: '->putText;
                   lastListElement.index->putInt;
                   newLine;
                   
               if);
               (firstListElement[],endSonNo-startSonNo+1,0,0)->newCS;
               
            else
               (nca[],1,startInx,startSubInx)->newCS; 
           if);
           
       if);
       
   if);
   newCS->setFocus
#)  

-- codeviewerSelectNode: DoPart --
do
   (if node[] = none then
       'selectNode: node[] is none!!'->putLine
    else
       (if switch[8] then
           'history: adding start  point; '->putText;
           cs.node.index->putInt;
           newLine;
           
       if);
       cs.node[]->updateHistory;
       (if node.frag[] <> frag[] then
           INNER selectNode
        else
           (node[],1,0,0)->setfocus;
           (if switch[8] then
               'history: adding end  point; '->putText;
               cs.node.index->putInt;
               newLine;
               
           if);
           cs.node[]->updateHistory
       if);
       (*      (if node.father <> none then
        node[]->checkSonNode->node[]->updateHistory
        else
        node[]->updateHistory
        if)
        *)
       
   if)  

-- codeviewerSetContraction: DoPart --
do
     (# newComment: ^mps.comment; t: ^text
     do
        (if node[] = none then cs.node[]->node[] if);
        (if not node.hasComment then
            (mps.comment,0,frag[])->theGrammar.newlexemText->newComment[];
            &text[]->t[];
            t[]->newcomment.putText;
            newComment[]->node.addComment;
            
        if);
        astView.pp.holocomment->node.typeOfComment;
        
     #)  

-- showAstBody: Descriptor --
(# 
do
   trace
     (#  do 'showAst'->str[] #);
   (if edDebug then
       (1,screen[])-> (* root *) frag.root.dump;
       newLine;
       'cs.node.index/isSon: '->screen.putText;
       cs.node.index->putInt;
       ' '->put;
       (if (cs.node.father <> none ) then cs.node.sonNo->putInt if);
       newLine;
       
   if);
   
#)  

-- doShowAst: DoPart --
do (*node[]->*) newLine; (1,screen[])->node.dump; newLine  

