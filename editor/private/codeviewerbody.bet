ORIGIN '../codeviewer';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- codeviewerinit: Descriptor --
(#
   grammar: ^mg.Agrammar;
   exp: ^astInterface.expanded;
   metaGrammarInit:
     (#
        theMetaGrammar: ^astInterface.treelevel;
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file
     do
        (if mps.grammarTable.meta[] <> none then
            mps.grammarTable.meta[]->mg[]; 
         else
            &mps.metaGrammar[]->theMetaGrammar[]->mps.grammarTable.meta[]->mg[];
            theMetaGrammar.init;
            '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
            ('-meta'->grammarWithPath.copyAppend,screen[])->mps.top.open->gg[];
            (if gg[]
             // none then
                'Could not open: '->screen.putText;
                '-meta'->grammarWithPath.copyAppend->screen.putLine;
                (failure,'')->stop;
                
             else
                ('metagrammar',screen[])->gg.open->theMetagrammar.grammarAst[];
                (if theMetagrammar.grammarAst[]
                 // none then
                    'No grammarAst for '->screen.putText;
                    grammarWithPath[]->screen.putLine;
                    (failure,'')->stop;
                    
                 else
                    grammarWithPath[]->mps.expandToFullPath->help[];
                    '-parser'->help.append;
                    mps.parserFileExtension->help.append;
                    help[]->bobsFile.name;
                    (if bobsFile.entry.exists then
                        bobsFile.name->theMetagrammar.parser.initialize; 
                     else
                        'No parser available: '->screen.putText; bobsFile.name->screen.putLine; 
                    if)
                if);
                
            if);
            
        if);
        
     #);
   help: ^text
do
   metaGrammarInit;
   &mps.astViewer[]->astView[];
   &windowOutput[]->astView.out[];
   (if editorRoot[] <> none then (*  editorRoot.frag[]->frag[];*)
       (if editorRoot.father <> none then true->isAsubeditor if); 
   if);
   (if 'beta'->(frag.grammar.grammarIdentification).equal then
       theGrammar[]->betaGrammar[]; betaGrammar.grammarAst.root[]->grammar[]; betaGrammar[]->ag[]
    else
       (if 'property'->(frag.grammar.grammarIdentification).equal then
           true->isApropertyEditor; theGrammar.grammarAst.root[]->grammar[]; theGrammar[]->ag[]
        else
           'Grammar: '->putText;
           frag.grammar.grammarIdentification->putLine;
           theGrammar.grammarAst.root[]->grammar[];
           theGrammar[]->ag[]
       if)
   if);
   grammar.getProductionList->prodList[];
   astView.out.init;
   frag.grammar.grammarAst.father->fg[];
   (fg.fullName).copy->help[];
   (help.length-4,help.length)->help.delete;
   help[] (*fg.fullName*) ->astView.pp.init;
   true->astView.pp.abstractPresentation;
   true->astView.pp.editorMode;
   getPropertiesFromGrammar;
   INNER init;
   theSifTexteditor.onOpen
#)  

-- codeviewerSetIsReadOnly: DoPart --
do INNER  

-- codeviewerOnUpArrowKey: DoPart --
do dir.pred->select; cs->setFocus  

-- codeviewerOnDownArrowKey: DoPart --
do dir.next->select; cs->setFocus  

-- codeviewerOnLeftArrowKey: DoPart --
do dir.extend->select; cs->setFocus  

-- codeviewerOnRightArrowKey: DoPart --
do dir.down->select; cs->setFocus  

-- codeviewerOnReturnKey: DoPart --
do INNER onReturnKey;   

-- codeviewerCheckFormEditorExistence: DoPart --
do INNER checkFormEditorExistence  

-- codeviewerSetupFormEditor: DoPart --
do INNER setupFormEditor  

-- codeviewerNodeExists: Descriptor --
(# 
do
   false->value;
   (if node[] = none then
       'NodeExists: node is none!!'->putLine; 
    else
       (if subtree[] = none then
           'NodeExists: subtree is none!!'->putLine; 
        else
           (if node.frag[] <> subtree.frag[] then
               'NodeExists: node and subtree are not in same fragment!!'->putLine;
               (if node.frag.father = none then
                   'the fragmentform has no father!'->putLine; 'node: '->putText; 
                else
                   'node: '->putText; (node.frag.father).name->putText; '-'->put
               if);
               node.frag.name->putText;
               '-'->put;
               node.index->putInt;
               newline;
               'subtree: '->putText;
               (if subtree.frag.father = none then
                   'the fragmentform has no father!'->putLine; 'node: '->putText; 
                else
                   'subtree: '->putText; (subtree.frag.father).name->putText; '-'->put
               if);
               subtree.frag.name->putText;
               '-'->put;
               subtree.index->putInt;
               newline
            else
               loop: subtree.suffixwalk
                 (#  do (if node[]->current.equal then true->value; leave loop if) #);
               
           if)
       if)
   if)
#)  

-- codeviewerIsNodeInTree: Descriptor --
(# 
do
   false->value;
   (if tree.kind = mps.kinds.interior then
       (node[],tree[])->nodeExists->value
    else
       (node[]->tree.equal)->value
   if)
#)  

-- codeviewerSetFocus: Descriptor --
(# found: @boolean
do
   (if newCS.node[] <> none then
       (if true (*checkExistence*) then
           (newCS.node[],editorRoot[] (*newCS.node.frag.root[]*) )->isNodeInTree->found;
           (if not found then nodeNotFound if)
        else
           true->found
       if);
       (if found then
           newCS->cs;
           checkSon;
           (true,cs)->aFocusChangedEvent;
           theSifTexteditor.contents.selection.scrollIntoView;
           
       if)
    else
       'SetFocus: newCS.node is none!!'->putLine; nodeNotFound
   if)
#)  

-- codeviewerSetNode: DoPart --
do
   (if node[] <> none then
       (node[],1,0,0)->setFocus;
       (if switch[8] then
           'history setNode: adding end  point; '->putText;
           (cs.node.frag.father).name->putText;
           '-'->put;
           cs.node.frag.name->putText;
           '-'->put;
           cs.node.index->putInt;
           newLine;
           
       if);
       cs.node[]->updateHistory
   if)  

-- codeviewerRefreshEvent: DoPart --
do INNER  

-- codeviewerFocusChangedEvent: Descriptor --
(#
   t: ^text;
   commentAst: ^astInterface.comment;
   fatherNode: ^astInterface.ast;
   unexp: ^astInterface.unexpanded;
   OK: @boolean
do (* from notification.focusChanged *)
   (if byMe then true->OK else (newCS.node[],editorRoot[])->isNodeInTree->OK if);
   (if OK then
       newCS.node[]->inContraction->(inContr,contractionNode[]);
       (if inContr then
           newCS.node[]->openContractionsUntilRoot;
           (*(editorRoot[],- 1)
            ->
            astView.pp.present;*)
           (* should be update, must disabled due to an error *)
           (byMe,editorRoot[])->refreshEvent
       if);
       (if byMe then newCS->cs->astToSelection;  else newCS->cs if);
       false->cs.isComment->cs.isContraction->cs.isUnexpanded->cs.isSlot->cs.hasSemanticLink;
       (if (cs.subcommentInx1 <> 0) and ((cs.subcommentInx2 <> 0)) then
           (cs.subCommentInx1,cs.subCommentInx2)->cs.node.getSubcomment->t[];
           (if t[] <> none then
               (t.length <> 0)->cs.isComment; true->ShowCommentPermit; false->MakeCommentPermit
           if)
       if);
       (if not cs.isComment then
           true->MakeCommentPermit;
           false->ShowCommentPermit;
           (if cs.node.hasComment then
               (if cs.node.typeOfComment = astView.pp.holocomment then true->cs.isContraction if)
           if);
           (if cs.node.kind = mps.kinds.unexpanded then
               cs.node[]->unexp[];
               (if unexp.isSlot then true->cs.isSlot;  else true->cs.isUnexpanded if)
           if);
           (if
           'beta'
             ->
               (frag.grammar.grammarIdentification).equal
               (* (mps[],cs.node.frag.father)->getDoneCheckProperty  is Checked *) then
               (if cs.node.kind
                // mps.kinds.nameDecl // mps.kinds.nameAppl then
                   cs.node.father->fatherNode[];
                   (if fatherNode.symbol
                    // betaGrammar.nameDcl then
                       fatherNode.father->fatherNode[];
                       (if fatherNode.symbol
                        // betaGrammar.names then
                           fatherNode.father->fatherNode[];
                           (if fatherNode.symbol
                            // betaGrammar.bindingDecl // betaGrammar.finalDecl then
                               true->cs.hasSemanticLink
                           if)
                       if)
                    // betaGrammar.nameApl then
                       true->cs.hasSemanticLink; 
                   if)
               if)
           if)
       if);
       (if false then
           'cs.isComment      : '->putText;
           (if cs.isComment then 'TRUE'->putLine else 'false'->putLine;  if);
           'cs.isContraction  : '->putText;
           (if cs.isContraction then 'TRUE'->putLine else 'false'->putLine;  if);
           'cs.isUnexpanded   : '->putText;
           (if cs.isUnexpanded then 'TRUE'->putLine else 'false'->putLine;  if);
           'cs.isSlot         : '->putText;
           (if cs.isSlot then 'TRUE'->putLine else 'false'->putLine;  if);
           'cs.hasSemanticLink: '->putText;
           (if cs.hasSemanticLink then 'TRUE'->putLine else 'false'->putLine;  if)
       if);
       (if doObserveAST then newCS.node[]->ASTObserver if);
       INNER focusChangedEvent
   if)
#)  

-- codeviewerSelectionToAst: Descriptor --
(#
   line1,char1,line2,char2: @integer;
   startNode,endNode,nca,firstListElement,lastListElement: ^astInterface.ast;
   prod: ^mg.prod;
   expNode: ^astInterface.expanded;
   startSonNo,endSonNo: @integer;
   synCatNo: @mps.nonterminalSymbol;
   startInx,startSubinx,endInx,endSubInx: @integer
do
   (if start = end then
       start->theSifTexteditor.posToLineChar->(line1,char1);
       (if switch[2] then
           'onClick after posToLineChar: '->putText;
           line1->screen.putint;
           ' '->screen.put;
           char1->screen.putint;
           ' '->screen.put;
           
       if);
       (line1,char1)->astView.pp.hit->(startNode[],startInx,startSubinx);
       startNode[]->nca[];
       0->startSonNo;
       (if switch[2] then
           'onClick: startSonNo, index: '->putText;
           startSonNo->putInt;
           ' '->put;
           startNode.index->putInt;
           newLine;
           'startSon: inx, subinx: '->putText;
           startInx->putInt;
           ' '->put;
           startSubInx->putInt;
           newLine;
           
       if)
    else
       start->theSifTexteditor.posToLineChar->(line1,char1);
       end->theSifTexteditor.posToLineChar->(line2,char2);
       (if switch[2] then
           'onClick after posToLineChar: '->putText;
           line1->screen.putint;
           ' '->screen.put;
           char1->screen.putint;
           ' '->screen.put;
           line2->screen.putint;
           ' '->screen.put;
           char2->screen.putint;
           ' '->screen.put;
           newLine;
           
       if);
       (line1,char1)->astView.pp.hit->(startNode[],startInx,startSubinx);
       (line2,char2)->astView.pp.hit->(endNode[],endInx,endSubInx);
       startNode[]->endNode.nearestCommonAncestor->(nca[],startSonNo,endSonNo);
       (if (startNode[]->endNode.equal) and (startInx = endInx) and (startSubinx = endSubinx) then
           
        else
           0->startInx->startSubInx
       if);
       (if switch[2] then
           'onClick: startSonNo, index: '->putText;
           startSonNo->putInt;
           ' '->put;
           startNode.index->putInt;
           newLine;
           'startSon: inx, subinx: '->putText;
           startInx->putInt;
           ' '->put;
           startSubInx->putInt;
           newLine;
           'onClick endSonNo, index: '->putText;
           endSonNo->putInt;
           ' '->put;
           endNode.index->putInt;
           newLine;
           'emdSon: inx, subinx: '->putText;
           endInx->putInt;
           ' '->put;
           endSubInx->putInt;
           newLine;
           'noClick: nca index: '->putText;
           nca.index->putInt;
           newLine;
           
       if);
       
   if);
   (if ((startSonNo = 0) or (endSonNo = 0)) then
       (nca[],1,startInx,startSubInx)->newCS
    else
       nca[]->getSynCatNo->synCatNo;
       (if synCatNo.isLexem then
           (nca[],1,startInx,startSubInx)->newCS; 
        else
           synCatNo->prodList.get->prod[];
           (if prod.symbol
            // mg.listZero // mg.listOne then
               nca[]->expNode[];
               startSonNo->expNode.get->firstListElement[];
               endSonNo->expNode.get->lastListElement[];
               (if switch[2] then
                   'onClick: first: '->putText;
                   firstListElement.index->putInt;
                   newLine;
                   'onClick: last: '->putText;
                   lastListElement.index->putInt;
                   newLine;
                   
               if);
               (firstListElement[],endSonNo-startSonNo+1,0,0)->newCS;
               
            else
               (nca[],1,startInx,startSubInx)->newCS; 
           if);
           
       if);
       
   if)
#)  

-- codeviewerSelectionToFocus: DoPart --
do (start,end)->selectionToAST->setFocus  

-- codeviewerSelectNode: DoPart --
do
   (if node[] = none then
       'selectNode: node[] is none!!'->putLine
    else
       (if switch[8] then
           'history selectNode: adding start  point; '->putText; cs.node.index->putInt; newLine; 
       if);
       cs.node[]->updateHistory;
       (if separate or (node.frag[] <> frag[]) then
           INNER selectNodeInFormEditor
        else
           (node[],1,0,0)->setfocus;
           (if switch[8] then
               'history selectNode: adding end  point; '->putText; cs.node.index->putInt; newLine; 
           if);
           cs.node[]->updateHistory
       if)
   if)  

-- codeviewerHandleDoubleClick: Descriptor --
(# unexp: ^astInterface.unexpanded
do
   INNER handleDoubleClick;
   (if not doneInInner then
       (if cs.isComment then
           modifier->makeShowComment
        else
           (if cs.isContraction then
               makeDetail
            else
               (if cs.isSlot then
                   modifier->makeSearchSlotBinding
                else
                   (if cs.hasSemanticLink then
                       modifier->makeFollowSemanticLink
                    else
                       (if modifier and (cs.length = 1) then (*(cs.node[],cs.node[]->openSubEditor*)
                           (cs.node[],cs.node[],true)->selectNodeInFormEditor
                        else
                           cs->astToSelection; makeAbstract
                       if)
                   if)
               if)
           if)
       if)
   if)
#)  

-- codeviewerSetContraction: DoPart --
do
     (# newComment: ^astInterface.comment; t: ^text
     do
        (if node[] = none then cs.node[]->node[] if);
        (if not node.hasComment then
            (mps.comment,0,frag[])->theGrammar.newlexemText->newComment[];
            &text[]->t[];
            t[]->newcomment.putText;
            newComment[]->node.addComment;
            
        if);
        astView.pp.holocomment->node.typeOfComment;
        
     #)  

-- codeviewerAskZoomIn: DoPart --
do true->value  

-- codeviewerAskZoomOut: DoPart --
do (editorRoot[] <> frag.root[])->value  

-- codeviewerAskZoomFullEditor: DoPart --
do (editorRoot[] <> frag.root[])->value  

-- codeviewerDoZoomIn: DoPart --
do
   ui.cursors.watch[]->UI.mouse.busyCursor;
   cs.node[]->editorRoot[]->theSifTexteditor.editorRoot[];
   (editorRoot[],- 1)->astView.pp.present;
   cs->setFocus;
   none ->UI.mouse.busyCursor  

-- codeviewerDoZoomOut: DoPart --
do
   (if editorRoot.father <> none then
       ui.cursors.watch[]->UI.mouse.busyCursor;
       editorRoot.father->editorRoot[]->theSifTexteditor.editorRoot[];
       (editorRoot[],- 1)->astView.pp.present;
       cs->setFocus;
       none ->UI.mouse.busyCursor
   if)  

-- codeviewerDoZoomFullEditor: DoPart --
do
   ui.cursors.watch[]->UI.mouse.busyCursor;
   frag.root[]->editorRoot[]->theSifTexteditor.editorRoot[];
   (editorRoot[],- 1)->astView.pp.present;
   cs->setFocus;
   none ->UI.mouse.busyCursor  

-- codeviewerDoReprettyprint: DoPart --
do
   ui.cursors.watch[]->UI.mouse.busyCursor;
   (editorRoot[],- 1)->astView.pp.present;
   cs->setFocus;
   none ->UI.mouse.busyCursor  

-- showAstBody: Descriptor --
(# 
do
   trace
     (#  do 'showAst'->str[] #);
   (if edDebug then
       (1,screen[])->editorRoot.dump;
       newLine;
       'cs.node.index/isSon: '->screen.putText;
       cs.node.index->putInt;
       ' '->put;
       (if (cs.node.father <> none ) then cs.node.sonNo->putInt if);
       newLine;
       
   if);
   
#)  

-- doShowAst: DoPart --
do (*node[]->*) newLine; (1,screen[])->node.dump; newLine  

-- searchSLOTPrivate: Descriptor --
(#
   theSlot: ^astInterface.slotDesc;
   slotName: ^text;
   searchBinding:
     (#
        searchFrag,fg: ^astInterface.fragmentGroup;
        found: @boolean;
        ff: ^astInterface.fragmentForm;
        help: ^text;
        de: @diskentry
     enter searchFrag[]
     do
        search: searchFrag.prop.scanProp
          (#
             doProp::< 
               (# 
               do
                  (if true
                   // ('BODY'->prop.equalNCS) then
                      scanParameters
                        (#
                           doString::< 
                             (# 
                             do
                                searchFrag.fullName->de.path;
                                (if traceSLOTsearch then s[]->screen.putText; ' '->screen.put if);
                                (s[],de.path.head)->mps.thePathHandler.convertFilePath->help[];
                                (help[],screen[])->mps.top.open->fg[];
                                (if not fg.isRealOpen then
                                    'fg was not realopen'->putLine; fg.realOpen
                                if);
                                (if (* should test if open already *) fg[]
                                 // none then
                                    s.copy->help[];
                                    ' not found'->help.putText;
                                    help[]-> (*UI.alertUser;*) putLine
                                 else
                                    fg.fragmentList.scan
                                      (# 
                                      do
                                         (if (current.name[]->slotName.equalNCS) then
                                             (if current.type
                                              // mps.formType then
                                                 true->found;
                                                 (if traceSLOTsearch then newLine if);
                                                 current.f[]->ff[]->bindingFound;
                                                 leave search
                                              else
                                                 'Not a fragment form! '->putLine
                                             if)
                                         if)
                                      #);
                                    fg[]->&searchBinding->found
                                if)
                             #)
                        #)
                   // ('MDBODY'->prop.equalNCS) then
                      searchMDbody: scanParameters
                        (#
                           t,name: ^text;
                           foundMachineType,isDefaultMachine,noMachineType: @boolean;
                           doName::< 
                             (# 
                             do
                                machineType->t[];
                                n[]->name[];
                                (if t[] <> none then
                                    (if t[]->n.equal then
                                        true->foundMachineType; 
                                     else
                                        (if 'default'->n.equal then true->isDefaultMachine if)
                                    if)
                                 else
                                    true->noMachineType; 'Unknown machine type'->putLine
                                if)
                             #);
                           doString::< 
                             (# 
                             do
                                searchFrag.fullName->de.path;
                                (if traceSLOTsearch then s[]->screen.putText; ' '->screen.put if);
                                (if foundMachineType or isDefaultMachine or noMachineType then
                                    'Choosing MDBODY '->putText;
                                    (if foundMachineType then
                                        t[]->putLine
                                     else
                                        name[]->putLine
                                    if);
                                    (s[],de.path.head)->mps.thePathHandler.convertFilePath->help[];
                                    (help[],screen[])->mps.top.open->fg[];
                                    (if (* should test if open already *) fg[]
                                     // none then
                                        s.copy->help[];
                                        ' not found'->help.putText;
                                        help[]-> (*UI.alertUser;*) putLine
                                     else
                                        (if not fg.isRealOpen then
                                            'fg was not realopen'->putLine; fg.realOpen
                                        if);
                                        fg.fragmentList.scan
                                          (# 
                                          do
                                             (if (current.name[]->slotName.equalNCS) then
                                                 (if current.type
                                                  // mps.formType then
                                                     true->found;
                                                     (if traceSLOTsearch then newLine if);
                                                     current.f[]->ff[]->bindingFound;
                                                     leave search
                                                  else
                                                     'Not a fragment form! '->putLine
                                                 if)
                                             if)
                                          #);
                                        fg[]->&searchBinding->found
                                    if);
                                    leave searchMDbody
                                if)
                             #)
                        #)
                  if)
               #)
          #)
     exit found
     #)
#)  

-- searchSlotBinding: DoPart --
do
     (# found: @boolean
     do
        searchedUnexp.theSlot->searchSLOTbindingPrivate.theSlot[];
        searchSLOTbindingPrivate.theSlot.name->searchSLOTbindingPrivate.slotName[];
        (if traceSLOTsearch then
            newLine;
            'Searching for a SLOT binding of '''->putText;
            searchSLOTbindingPrivate.slotName[]->putText;
            ''''->put;
            ' in:'->putLine
        if);
        frag.father->&searchSLOTbindingPrivate.searchBinding->found;
        (if not found then searchSLOTbindingPrivate.slotName[]->bindingNotFound if)
     #)  

