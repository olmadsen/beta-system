ORIGIN '../codeeditor';
LIB_ITEM 'editorcodeeditor';
(*
 * COPYRIGHT
 *	 Copyright (C) Aarhus University
 *	 All rights reserved.
 *)
-- cutFragmentBody: Descriptor --
(#
   fatherNode: ^astInterface.expanded;
   prod,sonProd,fatherProd: ^mg.prod;
   synCatNo: @mps.nonterminalSymbol;
   isSon: @integer;
   doNotify,doCopyOnClipBoard: @boolean;
   makeClipBoardElement:
   (* saves a cut or copied fragmnet on the 'clipboard'    *)
   (* The syntactic category and the length of the clipped *)
   (* fragment and furthermore each og elements in the     *)
   (* fragment is saved.                                   *)
     (#
        elm: @mps.astFocus;
        synCatNo: @mps.nonterminalSymbol;
        isSon: @integer;
        fatherNode: ^astInterface.expanded
     enter (synCatNo,elm)
     do
        trace
          (#  do 'makeclip'->str[] #);
        synCatNo->edenv.clip.synCatNo;
        elm.length->edenv.clip.length;
        (if elm.length > edenv.clip.fragments.elm.range then
            elm.length->edenv.clip.fragments.elm.extend
        if);
        elm.node[]->edenv.clip.fragments.elm[1][];
        (if ((elm.node.Father->fatherNode[]) <> none ) then
            elm.node.sonNo->isSon;
            (for i: (elm.length-1) repeat
              isSon+i->fatherNode.get->edenv.clip.fragments.elm[i+1][]
            for)
        if);
        
     #);
   deleteListElements:
   (* cs is one or more listElements that should be deleted *)
     (# isSon: @integer; aList: ^astInterface.list
     do
        cs.node.father->aList[];
        cs.node.sonNo->isSon;
        (aList[],isSon,cs,0,deleted)->makeUndoElem;
        (for cs.length repeat isSon->aList.delete for);
        (if doNotify then
            checkAutosave;
            (aList[],isSon,undoElem.fragmentLength,undoElem.Fragments[])
              ->frag.notifyListElementsDeleted;
            
        if);
        (if (1 <= aList.noOfSons) then
            (if (aList.noOfSons < isSon) then aList.noOfSons->isSon if);
            isSon->aList.get->cs.node[]
         else
            aList[]->cs.node[]
        if);
        1->cs.length;
        (if doNotify then selectNewCs if);
        
     #);
   reduceOptional:
   (* cs is either derived over an optional or is a nonterminal which *)
   (* is an optional, e.g.<<impop>>. An optional-nonterminal must be  *)
   (* inserted instead of cs.                                         *)
     (#
        fatherNode: ^astInterface.expanded;
        aList: ^astInterface.list;
        synCatNo: @mps.nonterminalSymbol;
        isSon: @integer;
        newOpt: ^astInterface.optional
     enter synCatNo
     do
        cs.node.father->fatherNode[];
        cs.node.sonNo->isSon;
        (fatherNode[],isSon,cs,1,deleted)->makeUndoElem;
        (synCatNo,frag[])->ag.newOptional->newOpt[];
        synCatNo->newOpt.nonterminalSymbol;
        (if (1 < cs.length) then
        (* father is listOne and cs.length = noOfSons *)
            fatherNode[]->aList[];
            (for i: cs.length repeat 1->aList.delete for);
            (1,newOpt[])->aList.insert (* now all the sons are deleted *) ;
            newOpt[]->cs.node[];
            1->cs.length;
            (if doNotify then
                checkAutosave;
                (aList[],1,undoElem.fragmentLength,undoElem.fragments[],
                 cs.length)->frag.notifyListElementsReplaced
            if)
         else
        (* father is constructor or cs is an optional nonterminal *)
            (isSon,newOpt[])->fatherNode.put;
            newOpt[]->cs.node[];
            (if doNotify then makeAstReplacedEvent if);
            
        if);
        (if doNotify then goToNonEmpty; cs->setFocus;  if);
        
     #);
   reduceConstructor:
   (* The father of cs is a constructor and cs should be replaced  *)
   (* by a nonterminal with the syntactic category of the position *)
   (* isSon in the father production.                              *)
     (#
        synCatNo: @mps.nonterminalSymbol;
        isSon: @integer;
        fatherNode: ^astInterface.expanded;
        constructor: ^astInterface.cons;
        nontNode: ^astInterface.unexpanded
     enter synCatNo
     do
        trace
          (#  do 'reduceConstructor'->str[] #);
        checkFather;
        cs.node.father->fatherNode[]->constructor[];
        cs.node.sonNo->isSon;
        (fatherNode[],isSon,cs,1,deleted)->makeUndoElem;
        (syncatNo,frag[])->ag.newUnexpanded->nontNode[];
        (isSon,nontNode[])->fatherNode.put;
        (synCatNo,fatherNode[],isSon)->&expand;
        isSon->fatherNode.get->cs.node[];
        (if doNotify then makeAstReplacedEvent; selectNewCs if);
        
     #);
   reduceListOne:
   (* fatherNode is a listOne and cs.length = noOfSons, which means *)
   (* than cs should be replaced by a son-nonterminal               *)
     (#
        nontNode: ^astInterface.ast;
        aList: ^astInterface.list;
        isSon: @integer;
        synCatNo: @mps.nonterminalSymbol
     enter synCatNo
     do
        cs.node.father->aList[];
        cs.node.sonNo->isSon;
        (aList[],isSon,cs,1,deleted)->makeUndoElem;
        (syncatNo,frag[])->ag.newUnexpanded->nontNode[];
        (for i: cs.length repeat 1->aList.delete for);
        (isSon,nontNode[])->aList.insert;
        (synCatNo,aList[],isSon)->&expand;
        isSon->aList.get->cs.node[];
        1->cs.length;
        (if doNotify then
            checkAutosave;
            (aList[],isSon,undoElem.fragmentLength,undoElem.fragments[],
             cs.length)->frag.notifyListElementsReplaced;
            selectNewCs
        if);
        
     #);
   deleteListZero:
   (* cs is a listZero nonterminal or node with any number of sons *)
   (* and should be replaced by an empty listZero node.            *)
     (#
        fatherNode,newNode: ^astInterface.expanded;
        synCatNo: @mps.nonterminalSymbol;
        aList: ^astInterface.list;
        listElms: @mps.astFocus;
        noOfSons,isSon: @integer
     enter synCatNo
     do
        trace
          (#  do 'deleteListZero'->str[] #);
        cs.node.father->fatherNode[];
        cs.node.sonNo->isSon;
        (if (cs.node.kind = mps.kinds.interior) then
            cs.node[]->aList[];
            aList.noOfSons->noOfSons;
            aList.getSon1->listElms.node[];
            noOfsons->listElms.length;
            (aList[],1,listElms,0,true)->makeUndoElem;
            (for i: noOfsons repeat 1->aList.delete for);
            (if doNotify then
                checkAutosave;
                (aList[],1,undoElem.fragmentLength,undoElem.fragments[])
                  ->frag.notifyListElementsDeleted
            if)
         else
            (fatherNode[],isSon,cs,1,deleted)->makeUndoElem;
            (synCatNo,frag[])->ag.newAst (* newUnexpanded? *) ->newNode[];
            (isSon,newNode[])->fatherNode.put;
            newNode[]->cs.node[];
            (if doNotify then makeAstReplacedEvent if);
            
        if);
        (if doNotify then selectNewCs if)
     #);
   reduceRoot:
     (# 
     do
        trace
          (#  do 'reduceRoot'->str[] #);
        (if 'beta'->(frag.grammar.grammarIdentification).equal then
            cs.node[]->removeOptionals
         else
            (none ,0,cs,1,deleted)->makeUndoElem;
            newAst;
            (if doNotify then makeAstReplacedEvent; selectNewCs if)
        if)
     #);
   
do
   trace
     (#  do 'cutFragment'->str[] #);
   not doNotNotify->doNotify;
   not doNotCopyToClipboard->doCopyOnClipBoard;
   checkFather;
   cs.node.father->fatherNode[];
   cs.node[]->getSynCatNo->synCatNo;
   (if doCopyOnClipBoard then (synCatNo,cs)->makeClipboardElement if);
   L:
     (# 
     do
        (if (fatherNode[] = none ) then (* cs is root *)
            false->deleted; reduceRoot; leave L
         else
            cs.node.sonNo->isSon;
            fatherNode.symbol->ProdList.get->fatherProd[];
            (if not synCatNo.isLexem then
                synCatNo->ProdList.get->prod[];
                (if cs.length
                 // 1 then
                    (if prod.symbol
                     // mg.listZero then
                     (* cs is a listZero node or nonterminal and should *)
                     (* be replaced by an empty listZero node *)
                        false->deleted; synCatNo->deleteListZero; leave L
                     // mg.opt then
                     (* cs is a nonterminal which is optional and should *)
                     (* be replaced by an optional-nonterminal *)
                        (if
                        ((fatherProd.symbol = mg.listZero) or
                         ((fatherProd.symbol = mg.listOne) and
                          (cs.length+1 <= fatherNode.noOfSons))) then
                        (* cs is one or more list elements *)
                            true->deleted; deleteListElements
                         else
                            false->deleted; synCatNo->reduceOptional; 
                        if);
                        leave L
                    if)
                if)
            if);
            (if
            ((fatherProd.symbol = mg.listZero) or
             ((fatherProd.symbol = mg.listOne) and
              (cs.length+1 <= fatherNode.noOfSons))) then
            (* cs is one or more list elements *)
                true->deleted; deleteListElements
             else
                (if fatherProd.symbol
                 // mg.listOne then
                    fatherProd[]->findSynNameAtt->synCatNo->ProdList.get
                      ->sonProd[];
                    (if cs.length = fatherNode.noOfSons then (* whole list *)
                        true->deleted; synCatNo->reduceListOne
                     else
                        (if (sonProd.symbol = mg.opt) then
                            false->deleted; synCatNo->reduceOptional
                         else
                            true->deleted; synCatNo->reduceListOne
                        if)
                    if)
                 // mg.constructor then
                    (if (cs.node.kind <> mps.kinds.unexpanded) then
                          (#
                             cons: ^mg.constructor;
                             consElemList: ^mg.consElemList;
                             sonIndex: @integer
                          do
                             fatherProd[]->cons[];
                             cons.getConsElemList->consElemList[];
                             0->sonIndex;
                             loop:
                             mg.synName
                               ->consElemList.suffixWalkForProd
                                 (# 
                                 do
                                    sonIndex+1->sonIndex;
                                    (if sonIndex
                                     // isSon then
                                        1->current.getAttribute->synCatNo;
                                        leave loop
                                    if)
                                 #);
                             false->deleted;
                             (if not synCatNo.isLexem then
                                 synCatNo->ProdList.get->sonProd[];
                                 (if (sonProd.symbol = mg.opt) then
                                     synCatNo->reduceOptional
                                  else
                                     synCatNo->reduceConstructor
                                 if)
                              else
                                 synCatNo->reduceConstructor
                             if)
                          #)
                    if)
                if)
            if)
        if)
     #)
#)  

-- makeEmptyListOrOptBody: Descriptor --
(# (* cs is a listZero or an optional nonterminal *)
   fatherNode: ^astInterface.expanded;
   newFragment,unExp: ^astInterface.unexpanded;
   newOpt: ^astInterface.optional;
   synCatNo: @mps.nonterminalSymbol;
   prod: ^mg.prod;
   doDelete: @boolean
do
   trace
     (#  do 'makeEmptyListOrOpt'->str[] #);
   false->doDelete;
   cs.node.father->fatherNode[];
   (fatherNode[],cs.node.sonNo,cs,1,doDelete)->makeUndoElem;
   cs.node[]->unExp[];
   unExp.nonterminalSymbol->synCatNo->ProdList.get->prod[];
   (if prod.symbol
    // mg.opt // mg.listZero then
       (synCatNo,frag[])->ag.newOptional->newOpt[];
       synCatNo->newOpt.nonterminalSymbol;
       (cs.node.sonNo,newOpt[])->fatherNode.put;
       newOpt[]->cs.node[];
       
    else
       (synCatNo,frag[])->ag.newAst->newFragment[];
       (cs.node.sonNo,newFragment[])->fatherNode.put;
       newFragment[]->cs.node[];
       
   if);
   makeAstReplacedEvent;
   selectNewcs
#)  

-- copyFragmentBody: Descriptor --
(# (* copyFragment may be called for any node. The fragment to be *)
(* copied will be copied to the clipboard.                     *)
   fatherNode: ^astInterface.expanded;
   copyNode: ^astInterface.ast;
   synCatNo: @mps.nonterminalSymbol;
   prod: ^mg.prod;
   isSon: @integer
do
   trace
     (#  do 'copyFragment '->str[] #);
   checkFather;
   (if edenv[] = none then 'edenv[] is none!!'->putLine if);
   ag[]->mps.newFragmentForm->edenv.clippedff[];
   edenv.clippedff[]
     ->
       cs.node.copy
       (* not necessary to bind astoverflow exception because clippedff i new *)
       ->edenv.clip.fragments.elm[1][];
   (if ((cs.node.father->fatherNode[]) <> none ) then
       (if cs.length > edenv.clip.fragments.elm.range then
           cs.length->edenv.clip.fragments.elm.extend
       if);
       (for i: (cs.length-1) repeat
         cs.node.sonNo+i->fatherNode.get->copyNode[];
         edenv.clippedff[]->copyNode.copy->edenv.clip.fragments.elm[i+1][]
       for)
   if);
   cs.node[]->getSynCatNo->edenv.clip.synCatNo;
   cs.length->edenv.clip.length
#)  

-- pasteFragmentBody: Descriptor --
(# (* pasteFragment is called only if current selection is a node with *)
(* same or compatibel syntactic category as fragment on clipboard   *)
   fatherNode: ^astInterface.expanded;
   prod: ^mg.prod;
   pasteElement,node: ^astInterface.ast;
   doDelete: @boolean;
   aList: ^astInterface.list;
   isSon: @integer;
   newFocus,undoFocus: @mps.astFocus;
   length: @integer;
   doNotify: @boolean;
   tempFragments: @mps.astList;
   lex: ^astInterface.lexemText;
   lexemToLexem: @boolean
do
   thisOperation: mps.protect
     (#
        ASToverflow::
        (* due to an error in AST overflow handling in copy
         * the whole paste operation is surrounded by protect 
         *) 
          (# msg: ^text
          do
             'Paste: AST overflow in '->msg[];
             (frag.father).name->msg.append;
             '-'->msg.append;
             frag.name->msg.append;
             '\nMjolner is quitting, but the AST will be automatically garbage-collected'
               ->msg.append;
             (none ,msg[],'Paste: AST overflow')->UI.alertUser;
             msg[]->putLine;
             none ->mps.theCatcher[];
             (if touched = 0 then
                 fragmentTouched (* to provoke garbage collection*)
             if);
             edenv.ymerCallback.quit;
             leave thisOperation
          #)
     do
        trace
          (#  do 'pasteFragment'->str[] #);
        not doNotNotify->doNotify;
        frag[]
          ->edenv.clip.fragments.elm[1].copy
            (#
               ASToverflow:: 
                 (# msg: ^text
                 do
                    'Paste: AST overflow in '->msg[];
                    (frag.father).name->msg.append;
                    '-'->msg.append;
                    frag.name->msg.append;
                    '\nMjolner is quitting, but the AST will be automatically garbage-collected'
                      ->msg.append;
                    (none ,msg[],'Paste: AST overflow')->UI.alertUser;
                    msg[]->putLine;
                    none ->mps.theCatcher[];
                    (if touched = 0 then
                        fragmentTouched (* to provoke garbage collection*)
                    if);
                    edenv.ymerCallback.quit;
                    leave thisOperation
                 #)
            #)->pasteElement[];
        edenv.clip.length->length;
        (if (cs.node.father = none ) then (* current selection is root *)
            false->doDelete;
            (none ,0,cs,length,doDelete)->makeUndoElem;
            pasteElement[]->fragDotRoot;
            (if doNotify then
                &makeAstReplacedEvent; (fragDotRoot,1,0,0)->&setFocus
            if);
            
         else
            (if true (* testing kompatibility on lexems *) then
                  (#
                     node2: ^astInterface.ast;
                     csNodeKind,clipKind: @integer;
                     checkIfLexem:
                       (#
                          node: ^astinterface.ast;
                          theKind: @integer;
                          unExp: ^astInterface.unexpanded;
                          synCatNo: @mps.nonterminalSymbol;
                          
                       enter node[]
                       do
                          (if node.kind
                           // mps.kinds.unexpanded then
                              node[]->getSynCatNo->synCatNo;
                              (if syncatNo.isLexem then
                                  node[]->unExp[];
                                  (if unExp.nonterminalSymbol
                                   // mps.prodNo.nameDecl then
                                      mps.prodNo.nameDecl->theKind
                                   // mps.prodNo.nameAppl then
                                      mps.prodNo.nameAppl->theKind
                                  if)
                              if)
                           // mps.kinds.nameDecl then
                              mps.kinds.nameDecl->theKind
                           // mps.kinds.nameAppl then
                              mps.kinds.nameAppl->theKind
                          if)
                       exit theKind
                       #);
                     
                  do
                     cs.node[]->checkIfLexem->csNodeKind;
                     edenv.clip.fragments.elm[1][]->checkSonNode->node2[];
                     node2[]->checkIfLexem->clipKind;
                     (if clipKind
                      // mps.kinds.nameDecl // mps.kinds.nameAppl then
                         (if csNodeKind
                          // mps.kinds.nameDecl // mps.prodNo.nameDecl
                          // mps.kinds.nameAppl // mps.prodNo.nameAppl then
                             node2[]->lex[];
                             (cs.node[],none ,lex.getText)->editLexem;
                             true->lexemToLexem
                         if)
                     if)
                  #)
            if);
            (if not lexemToLexem then
                cs.node[]->checkFatherNode->node[];
                (if node.father = none then
                    cs.node[]->node[]; cs.node.father->fatherNode[]
                 else
                    node.father->fatherNode[]
                if);
                cs->undoFocus;
                node[]->undoFocus.node[];
                (if switch[10] then
                    ' ------------- paste'->putLine;
                    'cs.node.dump'->putLine;
                    cs.node.dump;
                    newLine;
                    'corrected cs.node.dump'->putLine;
                    node.dump;
                    newLine;
                    'pasteElement.dump'->putLine;
                    pasteElement.dump;
                    newLine;
                    newline;
                    
                if);
                fatherNode.symbol->ProdList.get->prod[];
                (if (prod.symbol = mg.listZero) or (prod.symbol = mg.listOne)
                 then
                    true->doDelete;
                    node.sonNo->isSon;
                    (if length > tempFragments.elm.range then
                        length->tempFragments.elm.extend
                    if);
                    (for i: length repeat
                      frag[]
                        ->edenv.clip.fragments.elm[i].copy
                          (#
                             ASToverflow:: 
                               (# msg: ^text
                               do
                                  'Paste: AST overflow in '->msg[];
                                  (frag.father).name->msg.append;
                                  '-'->msg.append;
                                  frag.name->msg.append;
                                  '\nMjolner is quitting, but the AST will be automatically garbage-collected'
                                    ->msg.append;
                                  (none ,msg[],'Paste: AST overflow')
                                    ->UI.alertUser;
                                  msg[]->putLine;
                                  none ->mps.theCatcher[];
                                  (if touched = 0 then
                                      fragmentTouched
                                      (* to provoke garbage collection*)
                                  if);
                                  edenv.ymerCallback.quit;
                                  leave thisOperation
                               #)
                          #)->tempFragments.elm[i][]
                    for);
                    fatherNode[]->aList[];
                    (fatherNode[],isSon,undoFocus,length,doDelete)
                      ->makeUndoElem;
                    (for cs.length repeat isSon->aList.delete for);
                    (for i: length repeat
                      (isSon+i-1,tempFragments.elm[i][])->fatherNode.insert
                    for);
                    (isSon->fatherNode.get,length,0,0)->newFocus;
                    (if doNotify then
                        checkAutosave;
                        (fatherNode[],isSon,undoElem.fragmentLength,
                         undoElem.fragments[],newFocus.length)
                          ->frag.notifyListElementsReplaced;
                        newFocus->&setFocus
                    if);
                    
                 else
                (* cs.length as well as length is equal to 1 ! *)
                    false->doDelete;
                    (fatherNode[],node.sonNo,undoFocus,length,doDelete)
                      ->makeUndoElem;
                    (node.sonNo,pasteElement[])->fatherNode.put;
                    (if doNotify then
                        &makeAstReplacedEvent; (pasteElement[],1,0,0)->setFocus
                    if);
                    
                if)
            if)
        if)
     #)
#)  

