ORIGIN '../codeeditor';
INCLUDE '../searchreplace';
LIB_ITEM 'editorcodeeditor';
(*
 * COPYRIGHT
 *	 Copyright (C) Aarhus University
 *	 All rights reserved.
 *)
-- editorenvSearchPrivate: Descriptor --
(#
   ge: ^groupEditor;
   ce: ^codeeditor;
   fg: ^astInterface.fragmentGroup;
   ff: ^astInterface.fragmentForm;
   fgList: ^fragmentGroupList;
   ;
   theSearchText,foundText: ^text;
   lastff: ^astInterface.fragmentform;
   lastfg: ^astInterface.fragmentgroup;
   caseSensitive,wholeWord,onlyApplications: @boolean;
   theNameDcl: ^betaGrammar.nameDcl;
   fgPos: ^ymerCallBack.fragmentGroupList.theCellType;
   wraparound,wrapcs,wrapform,wrapgroup,wrapproject: @boolean;
   searchArea: @integer;
   dir: @
     (#
        up: (#  exit 0 #);
        down: (#  exit 1 #);
        pred: (#  exit 2 #);
        next: (#  exit 3 #);
        root: (#  exit 4 #);
        extend: (#  exit 5 #);
        nextNonterminal: (#  exit 6 #);
        prevNonterminal: (#  exit 7 #);
        nonCyclicDown: (#  exit 8 #)
     #);
   navigate:
     (#
        node: ^astInterface.ast;
        direction: @integer;
        allowWrap,wrapped: @boolean;
        length: @integer;
        fatherNode: ^astInterface.expanded;
        exp: ^astInterface.expanded;
        current: ^astInterface.ast;
        goDownRight:
          (# 
          do
             loop:
               (# 
               do
                  (if (node.kind = mps.kinds.interior) then
                      node[]->exp[];
                      (if (exp.noOfSons <> 0) then (* go to rightmost son *)
                          exp.noOfSons->exp.get->node[]; restart loop; 
                      if);
                      
                  if);
                  
               #);
             1->length;
             
          #);
        sonExists:
          (# exists: @boolean; 
          do
             (if (node.kind <> mps.kinds.interior) then
                 false->exists; 
              else
                 node[]->exp[]; (exp.noOfSons <> 0)->exists; 
             if);
             
          exit exists
          #)
     enter (node[],direction,allowWrap)
     do
        (if node[] <> none then
            node[]->current[];
            node.father->fatherNode[];
            (if direction
             // dir.up then
                (if (node.father = none ) then
                    (if allowWrap then
                        &goDownRight (* to keeop symmetry *)
                     else
                        true->wrapped;
                        (if trace[12] then 'wrapped'->putLine if);
                        
                    if);
                    
                 else
                    (if (node.sonNo = 1) then (* no left brother *)
                        node.father->node[];
                        (* go up *)
                        (* node[]->checkFatherNode;*)
                        
                     else
                    (* go left and downto rightmost leaf *)
                        node.sonNo-1 (* go left *) ->fatherNode.get->node[];
                        &goDownRight;
                        
                    if);
                    
                if);
                1->length;
                
             // dir.down then
                (if (1 < length) then
                    1->length; 
                 else
                    (if not sonExists then
                        (if (node.father <> none ) then
                            (if (node.sonNo = fatherNode.noOfSons) then
                            (* no right brother *)
                                loop:
                                  (# 
                                  do
                                     node.father->node[];
                                     (* go up *)
                                     (if (node.father <> none ) then
                                         node.father->fatherNode[];
                                         (if (node.sonNo < fatherNode.noOfSons)
                                          then (* right brother exists *)
                                             node.sonNo+1
                                               -> (* go right *) fatherNode.get
                                               ->node[];
                                             
                                          else
                                         (* go up *)
                                             restart loop; 
                                         if);
                                         
                                      else
                                         (if not allowWrap then
                                             true->wrapped;
                                             (if trace[12] then
                                                 'wrapped'->putLine
                                             if)
                                         if)
                                     if);
                                     
                                  #);
                                
                             else
                            (* right brother exists *)
                                node.sonNo+1-> (* go right *) fatherNode.get
                                  ->node[];
                                
                            if);
                            (* right brother exists? *)
                            
                        if);
                        (* father exists *)
                        
                     else
                    (* son exists *)
                    (* go down *)
                        node[]->exp[]; exp.getSon1->node[]; 
                    if);
                    (* sons exists ? *)
                    1->length;
                    
                if);
                (*node[]->checkSonNode;*)
                
            if)
        if);
        
     exit (node[],wrapped)
     #);
   ;
   initSearchCriteria:
     (#
        ge: ^groupEditor;
        ce: ^codeeditor;
        fg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        fgList: ^fragmentGroupList;
        keepSearchCriteria,isSearchDialog: @boolean;
        cnode: ^astInterface.ast;
        lexText: ^astInterface.lexemText;
        hasLink,semanticErrors: @boolean;
        theDecl: ^astInterface.ast;
        checkNeeded:
          (#
             mess,help: ^text;
             theNode: ^astInterface.ast;
             status,doCheck: @boolean;
             theGroupEditor: ^groupEditor
          enter (theNode[],mess[])
          do
             (if not ((mps[],theNode.frag.father)->getDoneCheckProperty) then
                 mess.copy->help[];
                 help.newline;
                 help.newLine;
                 'Check?'->help.putText;
                 (if ymerCallback[] <> none then
                     (none ,'Check?',help[])
                       ->UI.promptForBoolean
                         (# ok::  (#  do true->doCheck #) #);
                     (if doCheck then
                         (ymerCallback.theBrowserId,theNode.frag.father)
                           ->groupEditorList.findGroupEditor->theGroupEditor[];
                         (if (theGroupEditor[] <> none ) then
                             (if not theGroupeditor.isReadOnly then
                                 theNode.frag.father->ymerCallback.check->status
                              else
                                 'Is readonly, make copy before checking'
                                   ->ymerCallback.infoView;
                                 (* theNode.frag.father->ymerCallback.saveAsAndCheck
                                  ->status;
                                  false->stillInSameGroup*)
                                 
                             if)
                         if)
                     if)
                 if)
              else
                 true->status
             if)
          exit status
          #);
        checked: @boolean;
        help: ^text
     enter (ge[],ce[],fg[],ff[],fgList[],keepSearchCriteria,isSearchDialog)
     do
        ge[]->searchPrivate.ge[];
        ce[]->searchPrivate.ce[];
        fg[]->searchPrivate.fg[];
        ff[]->searchPrivate.ff[];
        fgList[]->searchPrivate.fgList[];
        ;
        none ->searchPrivate.fgPos[];
        false->searchPrivate.wraparound;
        ''->searchPrivate.foundText[];
        (if not keepSearchCriteria then
            none ->searchPrivate.theNameDcl[];
            none ->searchPrivate.theSearchText[];
            false->searchPrivate.onlyApplications;
            ymerCallBack.getCurrentNode->cnode[];
            (if isSearchDialog then
                'Search in lexems for:'->searchPrivate.searchMessText[]
             else
                'Search in lexems for:'->searchPrivate.replaceMessText[]
            if);
            (if cnode[] <> none then
                (if cnode.kind
                 // mps.kinds.nameDecl // mps.kinds.nameAppl then
                    ((cnode.frag.father).name).copy->help[];
                    '\nmust be (re)checked in order to search semantically\n'
                      ->help.append;
                    (cnode[],help[])->checkNeeded->checked;
                    (if checked then
                        (if cnode.kind
                         // mps.kinds.nameDecl then
                            cnode.father->searchPrivate.theNameDcl[];
                            cnode[]->lexText[];
                            lexText.getText->searchPrivate.thesearchText[];
                            (if isSearchDialog then
                                'Search for applications of:'
                                  ->searchPrivate.searchMessText[]
                             else
                                'Search for applications of:'
                                  ->searchPrivate.replaceMessText[]
                            if);
                            true->searchPrivate.onlyApplications
                         // mps.kinds.nameAppl then
                            cnode[]->hasSemanticLink
                              ->(hasLink,theDecl[],semanticErrors);
                            (if hasLink then
                                theDecl[]->searchPrivate.theNameDcl[];
                                (if isSearchDialog then
                                    'Search for applications of:'
                                      ->searchPrivate.searchMessText[]
                                 else
                                    'Search for applications of:'
                                      ->searchPrivate.replaceMessText[]
                                if);
                                true->searchPrivate.onlyApplications
                            if);
                            cnode[]->lexText[];
                            lexText.getText->searchPrivate.thesearchText[]
                        if)
                    if)
                if)
            if)
        if)
     #);
   ;
   searchResult: ^searchResultCallback;
   searchResultCallback:
     (#
        found:<
          (# foundNode: ^astInterface.ast enter foundNode[] do INNER #);
        notFound:< (# searchText: ^text enter searchText[] do INNER #)
     #);
   searchMessText: ^text;
   searchdialog: UI.searchdialog
     (#
        node: ^astInterface.ast;
        next:: 
          (# 
          do
             thisOperation:
               (# 
               do
                  (if trace[12] then
                      'match case: '->putText;
                      matchCase->putBoolean;
                      newLine;
                      'match word: '->putText;
                      matchWord->putBoolean;
                      newLine;
                      showAllHits->putBoolean;
                      newLine;
                      onlyApplications->putBoolean;
                      newLine;
                      'search area: '->putText;
                      searchArea->putInt;
                      newLine
                  if);
                  matchCase->searchPrivate.caseSensitive;
                  matchWord->searchPrivate.wholeWord;
                  onlyApplications->searchPrivate.onlyApplications;
                  (if onlyApplications then
                      (if searchPrivate.theNameDcl[] = none then
                          'No name declaration selected'->putLine;
                          leave thisOperation
                      if)
                  if);
                  searchArea->searchPrivate.searchArea;
                  (if searchArea
                   // searchArea_cs then
                      false->searchPrivate.wrapCS;
                      true->searchPrivate.wrapForm;
                      false->searchPrivate.wrapGroup;
                      false->searchPrivate.wrapProject;
                      ascii.bel->put;
                      'Search in current selection not implemented - use Browse hits'
                        ->ymerCallback.infoView
                   // searchArea_ff then
                      false->searchPrivate.wrapCS;
                      true->searchPrivate.wrapForm;
                      false->searchPrivate.wrapGroup;
                      false->searchPrivate.wrapProject
                   // searchArea_fg then
                      false->searchPrivate.wrapCS;
                      false->searchPrivate.wrapForm;
                      true->searchPrivate.wrapGroup;
                      false->searchPrivate.wrapProject
                   // searchArea_project // searchArea_domain
                   // searchArea_extent then
                      false->searchPrivate.wrapCS;
                      false->searchPrivate.wrapForm;
                      false->searchPrivate.wrapGroup;
                      true->searchPrivate.wrapProject
                  if);
                  (if userText.length > 0 then
                      (if not (searchPrivate.theSearchText[]->userText.equal)
                       then
                          userText.copy->searchPrivate.theSearchText[];
                          ''->searchPrivate.foundText
                      if);
                      (searchPrivate.theSearchText[],searchPrivate.dir.down,
                       ge[],ce[],fg[],ff[],fgList[],false)->searchText->node[];
                      (if node[] <> none then
                          node[]->searchResult.found
                       else
                          searchPrivate.theSearchText[]->searchResult.notFound
                      if)
                  if)
               #)
          #);
        browseHits:: 
          (#
             cnode: ^astInterface.ast;
             cff: ^astInterface.fragmentForm;
             cfg: ^astInterface.fragmentGroup
          do
             thisOperation:
             (if userText.length > 0 then
                 (if onlyApplications then
                     (if searchPrivate.theNameDcl[] = none then
                         'No name declaration selected'->putLine;
                         leave thisOperation
                     if)
                 if);
                 userText.copy->searchPrivate.thesearchText[];
                 (if searchArea
                  // searchArea_cs then
                     ymerCallBack.getCurrentNode->cnode[];
                     (if cnode[] <> none then
                         (cnode.frag.father,cnode.frag[],cnode[],
                          searchPrivate.thesearchText[],matchCase,matchWord,
                          searchArea,showAllHits,onlyApplications,
                          searchPrivate.theNameDcl[])
                           ->ymerCallBack.showSearchHits
                     if)
                  // searchArea_ff then
                     ymerCallBack.getCurrentFragmentForm->cff[];
                     (if cff[] <> none then
                         (cff.father,cff[],none ,searchPrivate.thesearchText[],
                          matchCase,matchWord,searchArea,showAllHits,
                          onlyApplications,searchPrivate.theNameDcl[])
                           ->ymerCallBack.showSearchHits
                     if)
                  // searchArea_fg then
                     ymerCallBack.getCurrentFragmentGroup->cfg[];
                     (if cfg[] <> none then
                         (cfg[],none ,none ,searchPrivate.thesearchText[],
                          matchCase,matchWord,searchArea,showAllHits,
                          onlyApplications,searchPrivate.theNameDcl[])
                           ->ymerCallBack.showSearchHits
                     if)
                  // searchArea_project // searchArea_domain
                  // searchArea_extent then
                     (none ,none ,none ,searchPrivate.thesearchText[],matchCase,
                      matchWord,searchArea,showAllHits,onlyApplications,
                      searchPrivate.theNameDcl[])->ymerCallBack.showSearchHits
                 if)
             if)
          #);
        cancel::  (#  do onClose #);
        onUserTextChanged:: 
          (# 
          do
             (if searchPrivate.onlyApplications then
                 false->searchPrivate.onlyApplications;
                 none ->searchPrivate.theNameDcl[];
                 'Search in lexems for:'->searchMessText[]->resetDialog
             if)
          #);
        calculateSearchScopes:
          (#
             name: ^text;
             theFgList: ^ymerCallBack.fragmentGroupList;
             fg: ^astInterface.fragmentGroup;
             ff: ^astInterface.fragmentForm
          do
             ymerCallback.getCurrentProjectStatus->name[];
             (if name[] <> none then
                 true->enableProjectScope; name[]->projectName[]
              else
                 ''->projectName[]
             if);
             ymerCallback.getCurrentFragmentGroup->fg[];
             (fg[] <> none )->enableFileScope;
             (if fg[] <> none then fg.name->fgName[] else ''->fgName[] if);
             ymerCallback.getCurrentFragmentForm->ff[];
             (ff[] <> none )->enableFragmentFormScope;
             (if ff[] <> none then ff.name->ffName[] else ''->ffName[] if)
          #);
        onClose:: 
          (#  do false->searchDialogOpened; none ->theSearchDialog[] #)
     #);
   theSearchDialog: ^searchdialog;
   ;
   replaceResult: ^replaceResultCallback;
   replaceResultCallback:
     (#
        found:<
          (# foundNode: ^astInterface.ast enter foundNode[] do INNER #);
        notFound:< (# searchText: ^text enter searchText[] do INNER #)
     #);
   replaceMessText: ^text;
   replacedialog: UI.replacedialog
     (#
        node: ^astInterface.ast;
        replace:: 
          (#
             cfg: ^astInterface.fragmentGroup;
             applicationOf,semanticErrorsOrNotChecked: @boolean
          do
             thisOperation:
               (# 
               do
                  ymerCallBack.getCurrentNode->node[];
                  (if node[] <> none then
                      (if searchPrivate.onlyApplications then
                          (node[],searchPrivate.theNameDcl[])->isApplicationOf
                            ->(applicationOf,semanticErrorsOrNotChecked);
                          (if semanticErrorsOrNotChecked then
                              leave thisOperation
                          if);
                          (if not applicationOf then
                              (if replaceDeclaration then
                                  (if not
                                  (searchPrivate.theNameDcl.getSon1->node.equal)
                                   then
                                      next
                                  if)
                               else
                                  next
                              if)
                          if)
                       else
                          (if not
                          ((theUserSearchText[],node[],
                            searchPrivate.caseSensitive,searchPrivate.wholeWord)
                             ->inLexem) then
                              next
                          if)
                      if)
                   else
                      next
                  if);
                  (if node[] <> none then
                      ymerCallBack.getCurrentFragmentGroup->cfg[];
                      (if cfg[] <> none then
                          (ymerCallback.theBrowserId,cfg[])
                            ->groupEditorList.findGroupEditor->ge[];
                          (if ge[] <> none then
                              node.frag[]->ge.formEditorList.findEditor->ce[];
                              (if ce[] <> none then
                                  (node[],theUserSearchText[],
                                   theUserReplaceText[])->ce.editLexem;
                                  next
                               else
                                  'ce is none!'->putLine
                              if)
                           else
                              'ge is none!'->putLine
                          if)
                       else
                          'cfg is none!'->putLine
                      if)
                  if)
               #)
          #);
        next:: 
          (# 
          do
             thisOperation:
               (# 
               do
                  (if trace[12] then
                      'match case: '->putText;
                      matchCase->putBoolean;
                      newLine;
                      'match word: '->putText;
                      matchWord->putBoolean;
                      newLine;
                      'search area: '->putText;
                      searchArea->putInt;
                      newLine
                  if);
                  matchCase->searchPrivate.caseSensitive;
                  matchWord->searchPrivate.wholeWord;
                  onlyApplications->searchPrivate.onlyApplications;
                  (if onlyApplications then
                      (if searchPrivate.theNameDcl[] = none then
                          'No name declaration selected'->putLine;
                          leave thisOperation
                      if)
                  if);
                  searchArea->searchPrivate.searchArea;
                  (if searchArea
                   // searchArea_cs then
                      false->searchPrivate.wrapCS;
                      true->searchPrivate.wrapForm;
                      false->searchPrivate.wrapGroup;
                      false->searchPrivate.wrapProject;
                      ascii.bel->put;
                      'Search in current selection not implemented - use Browse hits'
                        ->ymerCallback.infoView
                   // searchArea_ff then
                      false->searchPrivate.wrapCS;
                      true->searchPrivate.wrapForm;
                      false->searchPrivate.wrapGroup;
                      false->searchPrivate.wrapProject
                   // searchArea_fg then
                      false->searchPrivate.wrapCS;
                      false->searchPrivate.wrapForm;
                      true->searchPrivate.wrapGroup;
                      false->searchPrivate.wrapProject
                   // searchArea_project // searchArea_domain
                   // searchArea_extent then
                      false->searchPrivate.wrapCS;
                      false->searchPrivate.wrapForm;
                      false->searchPrivate.wrapGroup;
                      true->searchPrivate.wrapProject
                  if);
                  (if theUserSearchText.length > 0 then
                      (if not
                      (searchPrivate.theSearchText[]->theUserSearchText.equal)
                       then
                          theUserSearchText.copy->searchPrivate.theSearchText[];
                          ''->searchPrivate.foundText
                      if);
                      (theUserSearchText[],searchPrivate.dir.down,ge[],ce[],
                       fg[],ff[],fgList[],replaceDeclaration)->searchText
                        ->node[];
                      (if node[] <> none then
                          node[]->replaceResult.found
                       else
                          theUserSearchText[]->replaceResult.notFound
                      if)
                  if)
               #)
          #);
        replaceAll:: 
          (#
             cnode: ^astInterface.ast;
             cff: ^astInterface.fragmentForm;
             cfg: ^astInterface.fragmentGroup
          do
             thisOperation:
             (if theUserSearchText.length > 0 then
                 (if onlyApplications then
                     (if searchPrivate.theNameDcl[] = none then
                         'No name declaration selected'->putLine;
                         leave thisOperation
                     if)
                 if);
                 theUserSearchText.copy->searchPrivate.theSearchText[];
                 (if searchArea
                  // searchArea_cs then
                     ymerCallBack.getCurrentNode->cnode[];
                     (if cnode[] <> none then
                         (cnode.frag.father,cnode.frag[],cnode[],
                          theUserSearchText[],theUserReplaceText[],matchCase,
                          matchWord,replaceDeclaration,searchArea,
                          onlyApplications,searchPrivate.theNameDcl[])
                           ->ymerCallBack.replaceAll
                     if)
                  // searchArea_ff then
                     ymerCallBack.getCurrentFragmentForm->cff[];
                     (if cff[] <> none then
                         (cff.father,cff[],none ,theUserSearchText[],
                          theUserReplaceText[],matchCase,matchWord,
                          replaceDeclaration,searchArea,onlyApplications,
                          searchPrivate.theNameDcl[])->ymerCallBack.replaceAll
                     if)
                  // searchArea_fg then
                     ymerCallBack.getCurrentFragmentGroup->cfg[];
                     (if cfg[] <> none then
                         (cfg[],none ,none ,theUserSearchText[],
                          theUserReplaceText[],matchCase,matchWord,
                          replaceDeclaration,searchArea,onlyApplications,
                          searchPrivate.theNameDcl[])->ymerCallBack.replaceAll
                     if)
                  // searchArea_project // searchArea_domain
                  // searchArea_extent then
                     (none ,none ,none ,theUserSearchText[],
                      theUserReplaceText[],matchCase,matchWord,
                      replaceDeclaration,searchArea,onlyApplications,
                      searchPrivate.theNameDcl[])->ymerCallBack.replaceAll
                 if)
             if)
          #);
        cancel::  (#  do onClose #);
        onUserTextChanged:: 
          (# 
          do
             (if searchPrivate.onlyApplications then
                 false->searchPrivate.onlyApplications;
                 none ->searchPrivate.theNameDcl[];
                 'Search in lexems for:'->replaceMessText[]->resetDialog
             if)
          #);
        calculateSearchScopes:
          (#
             name: ^text;
             theFgList: ^ymerCallBack.fragmentGroupList;
             fg: ^astInterface.fragmentGroup;
             ff: ^astInterface.fragmentForm
          do
             ymerCallback.getCurrentProjectStatus->name[];
             (if name[] <> none then
                 true->enableProjectScope; name[]->projectName[]
              else
                 ''->projectName[]
             if);
             ymerCallback.getCurrentFragmentGroup->fg[];
             (fg[] <> none )->enableFileScope;
             (if fg[] <> none then fg.name->fgName[] else ''->fgName[] if);
             ymerCallback.getCurrentFragmentForm->ff[];
             (ff[] <> none )->enableFragmentFormScope;
             (if ff[] <> none then ff.name->ffName[] else ''->ffName[] if)
          #);
        onClose:: 
          (#  do false->replaceDialogOpened; none ->theReplaceDialog[] #)
     #);
   theReplaceDialog: ^replaceDialog;
   (* fix me *)
   
#)  

-- editorenvSearchTextDialog: Descriptor --
(#
   searchResult: searchPrivate.searchResultCallBack
     (#
        found::  (#  do foundNode[]->THIS(searchTextDialog).found #);
        notFound::  (#  do searchText[]->THIS(searchTextDialog).notFound #)
     #);
   searchTextForDialog: ^text
do
   &searchResult[]->searchPrivate.searchResult[];
   (ge[],ce[],fg[],ff[],fgList[],keepSearchCriteria,true)
     ->searchPrivate.initSearchCriteria;
   (if not searchDialogOpened then
       true->searchDialogOpened;
       &searchPrivate.searchDialog[]->searchPrivate.theSearchDialog[]
   if);
   searchPrivate.onlyApplications
     ->searchPrivate.theSearchDialog.onlyApplications;
   searchPrivate.theSearchDialog.calculateSearchScopes;
   (if keepSearchCriteria then
       ''->searchTextForDialog[]
    else
       searchPrivate.theSearchText[]->searchTextForDialog[]
   if);
   (none ,'Search',searchPrivate.searchMessText[],searchTextForDialog[])
     ->searchPrivate.theSearchDialog.popup;
   searchPrivate.theSearchDialog.bringtofront
#)  

-- editorenvSearchText: Descriptor --
(#
   cff: ^astInterface.fragmentForm;
   ffPos: ^astInterface.fragmentGroup.fragmentListDescription.theCellType;
   cfg: ^astInterface.fragmentGroup;
   fgname,help: ^text;
   wrapped,foundff: @boolean;
   name: ^text;
   fglist: ^ymerCallback.fragmentGroupList;
   applicationOf,semanticErrorsOrNotChecked: @boolean
do
   (if searchPrivate.wrapAround then
       (if trace[12] then 'wrap around'->putline if);
       false->searchPrivate.wraparound;
       (if searchPrivate.wrapForm then
           (if trace[12] then 'wrap form'->putline if);
           (if searchPrivate.lastff[] <> none then
               searchPrivate.lastff.root[]->node[]
            else
               'lastff[] is none'->putLine
           if);
           searchPrivate.lastfg[]->fg[]
       if);
       (if searchPrivate.wrapGroup then
           (if trace[12] then 'wrap group'->putline if);
           searchPrivate.lastfg[]->fg[];
           (if fg[] <> none then
               findFirstff: fg.fragmentList.scan
                 (# 
                 do
                    (if current.type = mps.formtype then
                        current.f[]->ff[];
                        ff.root[]->node[];
                        current[]->fg.fragmentlist.at->ffPos[];
                        leave findFirstff
                    if)
                 #)
            else
               'lastfg[] is none'->putLine
           if)
       if);
       (if searchPrivate.wrapProject then
           searchPrivate.searchArea->&ymerCallBack.getCurrentGroupProject
             ->(name[],fgList[]);
           (if fgList[] <> none then
               (if trace[12] then 'get first element in fglist '->putText if);
               fgList.head->searchPrivate.fgPos[];
               findFFinFGlist:
               (if searchPrivate.fgPos[] <> none then
                   searchPrivate.fgPos.elm[]->ymerCallBack.getFragmentGroup
                     ->fg[];
                   (if fg[] <> none then
                       (if trace[12] then fg.name->putLine if);
                       findFirstff: fg.fragmentList.scan
                         (# 
                         do
                            (if current.type = mps.formtype then
                                current.f[]->ff[];
                                ff.root[]->node[];
                                current[]->fg.fragmentlist.at->ffPos[];
                                true->foundff;
                                leave findFirstff
                            if)
                         #);
                       (if not foundff then
                           (if searchPrivate.fgPos.succ[] <> none then
                               searchPrivate.fgPos.succ[]
                                 ->searchPrivate.fgpos[];
                               restart findFFinFGlist
                           if)
                       if)
                    else
                       'getFragmentGroup did not return any fg'->putLIne; 
                   if)
                else
                   'fgPos is none'->putLine
               if)
            else
               searchPrivate.lastfg[]->fg[];
               findFirstff: fg.fragmentList.scan
                 (# 
                 do
                    (if current.type = mps.formtype then
                        current.f[]->ff[];
                        ff.root[]->node[];
                        current[]->fg.fragmentlist.at->ffPos[];
                        leave findFirstff
                    if)
                 #)
           if)
       if)
    else
       ymerCallBack.getCurrentFragmentGroup->cfg[];
       ymerCallBack.getCurrentFragmentForm->cff[];
       (if trace[12] then 'searchtext: '->putText; t[]->putLine if);
       (if cfg[] <> none then
           'Search in: '->help[];
           cfg.name->help.putText;
           (if cff[] <> none then '-'->help.put; cff.name->help.putText if);
           (if trace[12] then help[]->putLine if);
           help[]->ymerCallBack.infoView
       if);
       (if searchPrivate.wrapProject then
           searchPrivate.searchArea->&ymerCallBack.getCurrentGroupProject
             ->(name[],fgList[]);
           (if fgList[] <> none then
               (if searchPrivate.fgPos[] <> none then
                   
                else
                   (if trace[12] then
                       'get first element in fglist '->putText
                   if);
                   fgList.head->searchPrivate.fgPos[];
                   findFFinFGlist:
                   (if searchPrivate.fgPos[] <> none then
                       searchPrivate.fgPos.elm[]->ymerCallBack.getFragmentGroup
                         ->fg[];
                       (if fg[] <> none then
                           (if trace[12] then fg.name->putLine if);
                           findFirstff: fg.fragmentList.scan
                             (# 
                             do
                                (if current.type = mps.formtype then
                                    current.f[]->ff[];
                                    ff.root[]->node[];
                                    current[]->fg.fragmentlist.at->ffPos[];
                                    true->foundff;
                                    leave findFirstff
                                if)
                             #);
                           (if not foundff then
                               (if searchPrivate.fgPos.succ[] <> none then
                                   searchPrivate.fgPos.succ[]
                                     ->searchPrivate.fgpos[];
                                   restart findFFinFGlist
                               if)
                           if)
                        else
                           'getFragmentGroup did not return andy fg'->putLIne; 
                       if)
                    else
                       'fgPos is none'->putLine
                   if)
               if)
            else
               (if trace[12] then 'fglist is none'->putLIne if)
           if)
       if);
       (if cfg[] <> none (* a groupeditor is open in this browser *) then
           (if ge[] <> none then
               (if ge.fg[] <> cfg[]
               (* check whether the user changed groupeditor *) then
                   (ymerCallback.theBrowserId,cfg[])
                     ->groupEditorList.findGroupEditor->ge[];
                   (if ge[] <> none then
                       (if trace[12] then 'found groupeeditor'->putLine if)
                    else
                       'groupeditor not found for: '->putText; cfg.name->putLine
                   if)
               if)
            else
               (if trace[12] then
                   'ge is none, find group editor'->putLine
               if);
               (ymerCallback.theBrowserId,cfg[])
                 ->groupEditorList.findGroupEditor->ge[];
               (if ge[] <> none then
                   (if trace[12] then 'found groupeeditor'->putLine if)
                else
                   'groupeditor not found for: '->putText; cfg.name->putLine
               if)
           if)
        else
           (if trace[12] then 'cfg is none'->putLIne if);
           none ->ge[];
           none ->fg[]
       if);
       (if cff[] <> none (* a codeeditor is open in this browser *) then
           (if ce[] <> none then
               (if ce.frag[] <> cff[]
               (* check whether the user changed codeeditor *) then
                   (if trace[12] then 'cff <> ce.frag'->putLine if);
                   cff[]->ge.formEditorList.findEditor->ce[]
               if);
               (if ce[] <> none then
                   loop: ge.fg.fragmentList.scan
                     (# 
                     do
                        (if current.type = mps.formtype then
                            current.f[]->ff[];
                            (if ff[] = cff[] then
                                current[]->ge.fg.fragmentlist.at->ffPos[];
                                leave loop
                            if)
                        if)
                     #)
                else
                   'new codeeditor not found for: '->putText;
                   cfg.name->putText;
                   '-'->put;
                   cff.name->putLine
               if)
            else
               (if trace[12] then 'ce is none, find code editor'->putLine if);
               cff[]->ge.formEditorList.findEditor->ce[];
               (if ce[] <> none then
                   (if trace[12] then 'found codeeditor'->putLine if);
                   loop: ge.fg.fragmentList.scan
                     (# 
                     do
                        (if current.type = mps.formtype then
                            current.f[]->ff[];
                            (if ff[] = cff[] then
                                current[]->ge.fg.fragmentlist.at->ffPos[];
                                leave loop
                            if)
                        if)
                     #)
                else
                   'codeeditor not found for: '->putText;
                   cfg.name->putText;
                   '-'->put;
                   cff.name->putLine
               if)
           if)
        else
           (if trace[12] then 'cff is none'->putLIne if);
           none ->ce[];
           none ->ff[]
       if);
       (if ge[] <> none then ge.fg[]->fg[] if);
       (if fg[] <> none then
           (if ce[] <> none then
               ce.frag[]->ff[];
               (if ce.cs.node[] <> none then
                   ce.cs.node[]->node[]
                else
                   (if trace[12] then 'no cs'->putLine if);
                   ce.frag.root[]->node[]
               if)
            else
               (if trace[12] then 'ce is none'->putLine if);
               findFirstff: fg.fragmentList.scan
                 (# 
                 do
                    (if current.type = mps.formtype then
                        current.f[]->ff[];
                        ff.root[]->node[];
                        current[]->fg.fragmentlist.at->ffPos[];
                        leave findFirstff
                    if)
                 #)
           if)
       if)
   if);
   (if (fg[] <> none ) and (fg.fragmentList.size > 0) then
       loop:
         (# help: ^text
         do
            (node[],direction,false)->searchPrivate.navigate->(node[],wrapped);
            (if wrapped then
                (if trace[12] then 'did wrap'->putLine if);
                (if searchPrivate.wrapForm then
                    none ->node[]
                 else
                    (if ffPos[] <> none then
                        (if trace[12] then 'ffpos <>none'->putLine if);
                        loop2:
                        (if ffPos.succ[] <> none then
                            ffPos.succ[]->ffPos[];
                            (if ffPos.elm.type = mps.formtype then
                                ffPos.elm.f[]->ff[];
                                ff.root[]->node[];
                                'Search in: '->help[];
                                (ff.father).name->help.putText;
                                '-'->help.put;
                                ff.name->help.putText;
                                help[]->ymerCallBack.infoView;
                                (if trace[12] then help[]->putLine if);
                                restart loop
                             else
                                restart loop2
                            if)
                         else
                            (if trace[12] then
                                'end of fragmentlist'->putLine
                            if);
                            (if fgList[] <> none then
                                (if searchPrivate.wrapGroup then
                                    none ->node[]
                                 else
                                    (if searchPrivate.fgPos[] <> none then
                                        (if searchPrivate.fgPos.succ[] <> none
                                         then
                                            (if trace[12] then
                                                'get next fg'->putLine
                                            if);
                                            searchPrivate.fgPos.succ[]
                                              ->searchPrivate.fgPos[];
                                            searchPrivate.fgPos.elm[]->fgname[];
                                            'Search in: '->help[];
                                            fgname[]->help.putText;
                                            help[]->ymerCallBack.infoView;
                                            (if trace[12] then
                                                help[]->putLine
                                            if);
                                            fgname[]
                                              ->ymerCallBack.getFragmentGroup
                                              ->fg[];
                                            findFirstff: fg.fragmentList.scan
                                              (# 
                                              do
                                                 (if current.type = mps.formtype
                                                  then
                                                     current.f[]->ff[];
                                                     ff.root[]->node[];
                                                     current[]
                                                       ->fg.fragmentlist.at
                                                       ->ffPos[];
                                                     leave findFirstff
                                                 if)
                                              #);
                                            restart loop
                                         else
                                            (if trace[12] then
                                                'end of fragmentgroup list'
                                                  ->putLine
                                            if);
                                            none ->searchPrivate.fgPos[];
                                            none ->node[]
                                        if)
                                     else
                                        none ->node[]
                                    if)
                                if)
                             else
                                none ->node[]
                            if)
                        if)
                     else
                        (if trace[12] then 'ffpos is none'->putLine if);
                        none ->node[]
                    if)
                if)
             else
                (if node[] <> none then
                    (if searchPrivate.onlyApplications then
                        (node[],searchPrivate.theNameDcl[])->isApplicationOf
                          ->(applicationOf,semanticErrorsOrNotChecked);
                        (if semanticErrorsOrNotChecked then leave loop if);
                        (if not ApplicationOf then
                            (if findDeclaration then
                                (if not
                                (searchPrivate.theNameDcl[]->node.equal) then
                                    restart loop
                                if)
                             else
                                restart loop
                            if)
                        if)
                     else
                        (if not
                        ((t[],node[],searchPrivate.caseSensitive,
                          searchPrivate.wholeWord)->inLexem) then
                            restart loop
                        if)
                    if);
                    t[]->searchPrivate.foundText[]
                 else
                    'node is none'->putLine
                if)
            if)
         #);
       (if node[] <> none then
           
        else
           (if true
           (* if started below the hit then this test does not work: searchPrivate.foundText[]->t.equalNCS*)
           then
               true->searchPrivate.wrapAround;
               ff[]->searchPrivate.lastff[];
               fg[]->searchPrivate.lastfg[]
            else
               (if trace[12] then 'nothing found at all'->putLine if);
               false->searchPrivate.wrapAround;
               none ->searchPrivate.lastff[];
               none ->searchPrivate.lastfg[]
           if)
       if)
   if)
#)  

-- editorenvScanGroupForText: Descriptor --
(#  #)  

-- editorenvInLexem: DoPart --
do
     (# lexText: ^astInterface.lexemText; help: ^text
     do
        (if t[] <> none then
            (if (t.length > 0) then
                (if node.kind
                 // mps.kinds.nameDecl // mps.kinds.nameAppl
                 // mps.kinds.string then
                    node[]->lexText[];
                    lexText.getText->help[];
                    (if wholeWord then
                        (if caseSensitive then
                            t[]->help.equal->found
                         else
                            t[]->help.equalNCS->found
                        if)
                     else
                        (if caseSensitive then
                            l:
                            t[]
                              ->help.findTextAll
                                (# NCS:: falseObject
                                do true->found; leave l
                                #)
                         else
                            l:
                            t[]
                              ->help.findTextAll
                                (# NCS:: trueObject
                                do true->found; leave l
                                #)
                        if)
                    if)
                if);
                
            if)
        if)
     #)  

-- editorenvIsApplicationOf: DoPart --
do
     (#
        hasLink: @boolean;
        theDecl,declNodeRoot,applNodeRoot: ^astInterface.ast
     do
        node[]->hasSemanticLink->(hasLink,theDecl[],semanticErrorsOrNotChecked);
        (if hasLink then
            (theNameDcl[]->theDecl.equal)->value;
            (if not value
            (* try to see whether node and theNameDecl have a common virtual decl root *)
            then
                theNameDcl[]->declNodeRoot[];
                theDecl[]->applNodeRoot[];
                declLoop:
                  (# 
                  do
                     declNodeRoot[]->hasSemanticLink
                       ->(hasLink,theDecl[],semanticErrorsOrNotChecked);
                     (if hasLink and (theDecl[] <> none ) then
                         theDecl[]->declNodeRoot[]; restart declLoop
                     if)
                  #);
                applLoop:
                  (# 
                  do
                     applNodeRoot[]->hasSemanticLink
                       ->(hasLink,theDecl[],semanticErrorsOrNotChecked);
                     (if hasLink and (theDecl[] <> none ) then
                         theDecl[]->applNodeRoot[]; restart applLoop
                     if)
                  #);
                (declNodeRoot[]->applNodeRoot.equal)->value
            if)
        if)
     #)  

-- editorenvReplaceText: Descriptor --
(#  do  #)  

-- editorenvReplaceTextDialog: Descriptor --
(#
   replaceResult: searchPrivate.replaceResultCallBack
     (#
        found::  (#  do foundNode[]->THIS(replaceTextDialog).found #);
        notFound::  (#  do searchText[]->THIS(replaceTextDialog).notFound #)
     #);
   searchTextForDialog: ^text
do
   &replaceResult[]->searchPrivate.replaceResult[];
   (ge[],ce[],fg[],ff[],fgList[],keepSearchCriteria,false)
     ->searchPrivate.initSearchCriteria;
   (if not replaceDialogOpened then
       true->replaceDialogOpened;
       &searchPrivate.replaceDialog[]->searchPrivate.theReplaceDialog[]
   if);
   searchPrivate.onlyApplications
     ->searchPrivate.theReplaceDialog.onlyApplications;
   searchPrivate.theReplaceDialog.calculateSearchScopes;
   (if keepSearchCriteria then
       ''->searchTextForDialog[]
    else
       searchPrivate.theSearchText[]->searchTextForDialog[]
   if);
   (none ,'Replace',searchPrivate.replaceMessText[],'Replace with:',
    searchTextForDialog[])->searchPrivate.theReplaceDialog.popup;
   searchPrivate.theReplaceDialog.bringtofront
#)  

