ORIGIN '../codeeditor';
INCLUDE '../searchreplace';
-- editorenvSearchPrivate: Descriptor --
(#
   theSearchText,foundText: ^text;
   lastff: ^astInterface.fragmentform;
   lastfg: ^astInterface.fragmentgroup;
   caseSensitive,wholeWord: @boolean;
   fgPos: ^ymerCallBack.fragmentGroupList.theCellType;
   wraparound,wrapform,wrapgroup,wrapproject: @boolean;
   dir: @
     (#
        up: (#  exit 0 #);
        down: (#  exit 1 #);
        pred: (#  exit 2 #);
        next: (#  exit 3 #);
        root: (#  exit 4 #);
        extend: (#  exit 5 #);
        nextNonterminal: (#  exit 6 #);
        prevNonterminal: (#  exit 7 #);
        nonCyclicDown: (#  exit 8 #)
     #);
   navigate:
     (#
        node: ^astInterface.ast;
        direction: @integer;
        allowWrap,wrapped: @boolean;
        length: @integer;
        fatherNode: ^astInterface.expanded;
        exp: ^astInterface.expanded;
        current: ^astInterface.ast;
        goDownRight:
          (# 
          do
             loop:
               (# 
               do
                  (if (node.kind = mps.kinds.interior) then
                      node[]->exp[];
                      (if (exp.noOfSons <> 0) then (* go to rightmost son *)
                          exp.noOfSons->exp.get->node[]; restart loop; 
                      if);
                      
                  if);
                  
               #);
             1->length;
             
          #);
        sonExists:
          (# exists: @boolean; 
          do
             (if (node.kind <> mps.kinds.interior) then
                 false->exists; 
              else
                 node[]->exp[]; (exp.noOfSons <> 0)->exists; 
             if);
             
          exit exists
          #)
     enter (node[],direction,allowWrap)
     do
        node[]->current[];
        node.father->fatherNode[];
        (if direction
         // dir.up then
            (if (node.father = none ) then
                (if allowWrap then
                    &goDownRight (* to keeop symmetry *)
                 else
                    true->wrapped; (if trace[12] then 'wrapped'->putLine if); 
                if);
                
             else
                (if (node.sonNo = 1) then (* no left brother *)
                    node.father->node[];
                    (* go up *)
                    (* node[]->checkFatherNode;*)
                    
                 else
                (* go left and downto rightmost leaf *)
                    node.sonNo-1 (* go left *) ->fatherNode.get->node[];
                    &goDownRight;
                    
                if);
                
            if);
            1->length;
            
         // dir.down then
            (if (1 < length) then
                1->length; 
             else
                (if not sonExists then
                    (if (node.father <> none ) then
                        (if (node.sonNo = fatherNode.noOfSons) then
                        (* no right brother *)
                            loop:
                              (# 
                              do
                                 node.father->node[];
                                 (* go up *)
                                 (if (node.father <> none ) then
                                     node.father->fatherNode[];
                                     (if (node.sonNo < fatherNode.noOfSons) then
                                     (* right brother exists *)
                                         node.sonNo+1
                                           -> (* go right *) fatherNode.get
                                           ->node[];
                                         
                                      else
                                     (* go up *)
                                         restart loop; 
                                     if);
                                     
                                  else
                                     (if not allowWrap then
                                         true->wrapped;
                                         (if trace[12] then
                                             'wrapped'->putLine
                                         if)
                                     if)
                                 if);
                                 
                              #);
                            
                         else
                        (* right brother exists *)
                            node.sonNo+1-> (* go right *) fatherNode.get
                              ->node[];
                            
                        if);
                        (* right brother exists? *)
                        
                    if);
                    (* father exists *)
                    
                 else
                (* son exists *)
                (* go down *)
                    node[]->exp[]; exp.getSon1->node[]; 
                if);
                (* sons exists ? *)
                1->length;
                
            if);
            (*node[]->checkSonNode;*)
            
        if);
        
     exit (node[],wrapped)
     #);
   
#)  

-- editorenvSearchTextDialog: Descriptor --
(#
   searchd: @UI.searchdialog
     (#
        node: ^astInterface.ast;
        next:: 
          (# 
          do
             (if trace[12] then
                 'match case: '->putText;
                 matchCase->putBoolean;
                 newLine;
                 'match word: '->putText;
                 matchWord->putBoolean;
                 newLine;
                 'search area: '->putText;
                 searchArea->putInt;
                 newLine
             if);
             matchCase->searchPrivate.caseSensitive;
             matchWord->searchPrivate.wholeWord;
             (if searchArea
              // 1 then
                 true->searchPrivate.wrapForm;
                 false->searchPrivate.wrapGroup;
                 false->searchPrivate.wrapProject
              // 2 then
                 false->searchPrivate.wrapForm;
                 true->searchPrivate.wrapGroup;
                 false->searchPrivate.wrapProject
              // 3 then
                 false->searchPrivate.wrapForm;
                 false->searchPrivate.wrapGroup;
                 true->searchPrivate.wrapProject
             if);
             (if userText.length > 0 then
                 (if not (searchPrivate.theSearchText[]->userText.equal) then
                     userText.copy->searchPrivate.theSearchText[];
                     ''->searchPrivate.foundText
                 if);
                 (userText[],searchPrivate.dir.down,ge[],ce[],fg[],ff[],
                  fgList[])->searchText->node[];
                 (if node[] <> none then
                     node[]->found
                  else
                     userText[]->notFound
                 if)
             if)
          #);
        previous::  (#  do  #);
        browseHits:: 
          (# cfg: ^astInterface.fragmentGroup
          do
             (if userText.length > 0 then
                 (if searchArea = 3 then
                     (none ,usertext[],matchCase,matchWord,searchArea)
                       ->ymerCallBack.showSearchHits
                  else
                     ymerCallBack.getCurrentFragmentGroup->cfg[];
                     (if cfg[] <> none then
                         (cfg[],usertext[],matchCase,matchWord,searchArea)
                           ->ymerCallBack.showSearchHits
                     if)
                 if)
             if)
          #);
        cancel::  (#  do  #);
        
     #)
do
   searchd.open;
   none ->searchPrivate.fgPos[];
   ''->searchPrivate.foundText[];
   (none ,'Search','Search in lexems for:',searchPrivate.thesearchText[])
     ->searchd.popup
#)  

-- editorenvSearchText: Descriptor --
(#
   cff: ^astInterface.fragmentForm;
   ffPos: ^astInterface.fragmentGroup.fragmentListDescription.theCellType;
   cfg: ^astInterface.fragmentGroup;
   fgname,help: ^text;
   wrapped,foundff: @boolean;
   fglist: ^ymerCallback.fragmentGroupList
do
   (if searchPrivate.wrapAround then
       (if trace[12] then 'wrap around'->putline if);
       false->searchPrivate.wraparound;
       (if searchPrivate.wrapForm then
           searchPrivate.lastff.root[]->node[]; searchPrivate.lastfg[]->fg[]
       if);
       (if searchPrivate.wrapGroup then
           searchPrivate.lastfg[]->fg[];
           findFirstff: fg.fragmentList.scan
             (# 
             do
                (if current.type = mps.formtype then
                    current.f[]->ff[];
                    ff.root[]->node[];
                    current[]->fg.fragmentlist.at->ffPos[];
                    leave findFirstff
                if)
             #)
       if);
       (if searchPrivate.wrapProject then
           &ymerCallBack.getCurrentProject->fgList[];
           (if fgList[] <> none then
               (if trace[12] then 'get first element in fglist '->putText if);
               fgList.head->searchPrivate.fgPos[];
               findFFinFGlist:
               (if searchPrivate.fgPos[] <> none then
                   searchPrivate.fgPos.elm[]->ymerCallBack.getFragmentGroup
                     ->fg[];
                   (if fg[] <> none then
                       (if trace[12] then fg.name->putLine if);
                       findFirstff: fg.fragmentList.scan
                         (# 
                         do
                            (if current.type = mps.formtype then
                                current.f[]->ff[];
                                ff.root[]->node[];
                                current[]->fg.fragmentlist.at->ffPos[];
                                true->foundff;
                                leave findFirstff
                            if)
                         #);
                       (if not foundff then
                           (if searchPrivate.fgPos.succ[] <> none then
                               searchPrivate.fgPos.succ[]
                                 ->searchPrivate.fgpos[];
                               restart findFFinFGlist
                           if)
                       if)
                    else
                       'getFragmentGroup did not return any fg'->putLIne; 
                   if)
                else
                   'fgPos is none'->putLine
               if)
            else
               searchPrivate.lastfg[]->fg[];
               findFirstff: fg.fragmentList.scan
                 (# 
                 do
                    (if current.type = mps.formtype then
                        current.f[]->ff[];
                        ff.root[]->node[];
                        current[]->fg.fragmentlist.at->ffPos[];
                        leave findFirstff
                    if)
                 #)
           if)
       if)
    else
       ymerCallBack.getCurrentFragmentGroup->cfg[];
       ymerCallBack.getCurrentFragmentForm->cff[];
       (if trace[12] then 'searchtext: '->putText; t[]->putLine if);
       (if cfg[] <> none then
           'Search in: '->help[];
           cfg.name->help.putText;
           (if cff[] <> none then '-'->help.put; cff.name->help.putText if);
           (if trace[12] then help[]->putLine if);
           help[]->ymerCallBack.infoView
       if);
       (if searchPrivate.wrapProject then
           &ymerCallBack.getCurrentProject->fgList[];
           (if fgList[] <> none then
               (if searchPrivate.fgPos[] <> none then
                   
                else
                   (if trace[12] then
                       'get first element in fglist '->putText
                   if);
                   fgList.head->searchPrivate.fgPos[];
                   findFFinFGlist:
                   (if searchPrivate.fgPos[] <> none then
                       searchPrivate.fgPos.elm[]->ymerCallBack.getFragmentGroup
                         ->fg[];
                       (if fg[] <> none then
                           (if trace[12] then fg.name->putLine if);
                           findFirstff: fg.fragmentList.scan
                             (# 
                             do
                                (if current.type = mps.formtype then
                                    current.f[]->ff[];
                                    ff.root[]->node[];
                                    current[]->fg.fragmentlist.at->ffPos[];
                                    true->foundff;
                                    leave findFirstff
                                if)
                             #);
                           (if not foundff then
                               (if searchPrivate.fgPos.succ[] <> none then
                                   searchPrivate.fgPos.succ[]
                                     ->searchPrivate.fgpos[];
                                   restart findFFinFGlist
                               if)
                           if)
                        else
                           'getFragmentGroup did not return andy fg'->putLIne; 
                       if)
                    else
                       'fgPos is none'->putLine
                   if)
               if)
            else
               (if trace[12] then 'fglist is none'->putLIne if)
           if)
       if);
       (if cfg[] <> none (* a groupeditor is open in this browser *) then
           (if ge[] <> none then
               (if ge.fg[] <> cfg[]
               (* check whether the user changed groupeditor *) then
                   (ymerCallback.theBrowser[],cfg[])
                     ->groupEditorList.findGroupEditor->ge[];
                   (if ge[] <> none then
                       (if trace[12] then 'found groupeeditor'->putLine if)
                    else
                       'groupeditor not found for: '->putText; cfg.name->putLine
                   if)
               if)
            else
               (if trace[12] then
                   'ge is none, find group editor'->putLine
               if);
               (ymerCallback.theBrowser[],cfg[])
                 ->groupEditorList.findGroupEditor->ge[];
               (if ge[] <> none then
                   (if trace[12] then 'found groupeeditor'->putLine if)
                else
                   'groupeditor not found for: '->putText; cfg.name->putLine
               if)
           if)
        else
           (if trace[12] then 'cfg is none'->putLIne if);
           none ->ge[];
           none ->fg[]
       if);
       (if cff[] <> none (* a codeeditor is open in this browser *) then
           (if ce[] <> none then
               (if ce.frag[] <> cff[]
               (* check whether the user changed codeeditor *) then
                   (if trace[12] then 'cff <> ce.frag'->putLine if);
                   cff[]->ge.formEditorList.findEditor->ce[]
               if);
               (if ce[] <> none then
                   loop: ge.fg.fragmentList.scan
                     (# 
                     do
                        (if current.type = mps.formtype then
                            current.f[]->ff[];
                            (if ff[] = cff[] then
                                current[]->ge.fg.fragmentlist.at->ffPos[];
                                leave loop
                            if)
                        if)
                     #)
                else
                   'new codeeditor not found for: '->putText;
                   cfg.name->putText;
                   '-'->put;
                   cff.name->putLine
               if)
            else
               (if trace[12] then 'ce is none, find code editor'->putLine if);
               cff[]->ge.formEditorList.findEditor->ce[];
               (if ce[] <> none then
                   (if trace[12] then 'found codeeditor'->putLine if);
                   loop: ge.fg.fragmentList.scan
                     (# 
                     do
                        (if current.type = mps.formtype then
                            current.f[]->ff[];
                            (if ff[] = cff[] then
                                current[]->ge.fg.fragmentlist.at->ffPos[];
                                leave loop
                            if)
                        if)
                     #)
                else
                   'codeeditor not found for: '->putText;
                   cfg.name->putText;
                   '-'->put;
                   cff.name->putLine
               if)
           if)
        else
           (if trace[12] then 'cff is none'->putLIne if);
           none ->ce[];
           none ->ff[]
       if);
       (if ge[] <> none then ge.fg[]->fg[] if);
       (if fg[] <> none then
           (if ce[] <> none then
               ce.frag[]->ff[];
               (if ce.cs.node[] <> none then
                   ce.cs.node[]->node[]
                else
                   (if trace[12] then 'no cs'->putLine if);
                   ce.frag.root[]->node[]
               if)
            else
               (if trace[12] then 'ce is none'->putLine if);
               findFirstff: fg.fragmentList.scan
                 (# 
                 do
                    (if current.type = mps.formtype then
                        current.f[]->ff[];
                        ff.root[]->node[];
                        current[]->fg.fragmentlist.at->ffPos[];
                        leave findFirstff
                    if)
                 #)
           if)
       if)
   if);
   (if fg[] <> none then
       loop:
         (# help: ^text
         do
            (node[],direction,false)->searchPrivate.navigate->(node[],wrapped);
            (if wrapped then
                (if trace[12] then 'did wrap'->putLine if);
                (if searchPrivate.wrapForm then
                    none ->node[]
                 else
                    (if ffPos[] <> none then
                        (if trace[12] then 'ffpos <>none'->putLine if);
                        loop2:
                        (if ffPos.succ[] <> none then
                            ffPos.succ[]->ffPos[];
                            (if ffPos.elm.type = mps.formtype then
                                ffPos.elm.f[]->ff[];
                                ff.root[]->node[];
                                'Search in: '->help[];
                                (ff.father).name->help.putText;
                                '-'->help.put;
                                ff.name->help.putText;
                                help[]->ymerCallBack.infoView;
                                (if trace[12] then help[]->putLine if);
                                restart loop
                             else
                                restart loop2
                            if)
                         else
                            (if trace[12] then
                                'end of fragmentlist'->putLine
                            if);
                            (if fgList[] <> none then
                                (if searchPrivate.wrapGroup then
                                    none ->node[]
                                 else
                                    (if searchPrivate.fgPos[] <> none then
                                        (if searchPrivate.fgPos.succ[] <> none
                                         then
                                            (if trace[12] then
                                                'get next fg'->putLine
                                            if);
                                            searchPrivate.fgPos.succ[]
                                              ->searchPrivate.fgPos[];
                                            searchPrivate.fgPos.elm[]->fgname[];
                                            'Search in: '->help[];
                                            fgname[]->help.putText;
                                            help[]->ymerCallBack.infoView;
                                            (if trace[12] then
                                                help[]->putLine
                                            if);
                                            fgname[]
                                              ->ymerCallBack.getFragmentGroup
                                              ->fg[];
                                            findFirstff: fg.fragmentList.scan
                                              (# 
                                              do
                                                 (if current.type = mps.formtype
                                                  then
                                                     current.f[]->ff[];
                                                     ff.root[]->node[];
                                                     current[]
                                                       ->fg.fragmentlist.at
                                                       ->ffPos[];
                                                     leave findFirstff
                                                 if)
                                              #);
                                            restart loop
                                         else
                                            (if trace[12] then
                                                'end of fragmentgroup list'
                                                  ->putLine
                                            if);
                                            none ->searchPrivate.fgPos[];
                                            none ->node[]
                                        if)
                                     else
                                        none ->node[]
                                    if)
                                if)
                             else
                                none ->node[]
                            if)
                        if)
                     else
                        (if trace[12] then 'ffpos is none'->putLine if);
                        none ->node[]
                    if)
                if)
             else
                (if node[] <> none then
                    (if not
                    ((t[],node[],searchPrivate.caseSensitive,
                      searchPrivate.wholeWord)->inLexem) then
                        restart loop
                    if);
                    t[]->searchPrivate.foundText[]
                 else
                    'node is none'->putLine
                if)
            if)
         #)
   if);
   (if node[] <> none then
       
    else
       (if true
       (* if started below the hit then this test does not work: searchPrivate.foundText[]->t.equalNCS*)
       then
           true->searchPrivate.wrapAround;
           ff[]->searchPrivate.lastff[];
           fg[]->searchPrivate.lastfg[]
        else
           (if trace[12] then 'nothing found at all'->putLine if);
           false->searchPrivate.wrapAround;
           none ->searchPrivate.lastff[];
           none ->searchPrivate.lastfg[]
       if)
   if)
#)  

-- editorenvScanGroupForText: Descriptor --
(#  #)  

-- editorenvInLexem: DoPart --
do
     (# lexText: ^astInterface.lexemText; help: ^text
     do
        (if t[] <> none then
            (if (t.length > 0) then
                (if node.kind
                 // mps.kinds.nameDecl // mps.kinds.nameAppl
                 // mps.kinds.string then
                    node[]->lexText[];
                    lexText.getText->help[];
                    (if wholeWord then
                        (if caseSensitive then
                            t[]->help.equal->found
                         else
                            t[]->help.equalNCS->found
                        if)
                     else
                        (if caseSensitive then
                            l:
                            t[]
                              ->help.findTextAll
                                (# NCS:: falseObject
                                do true->found; leave l
                                #)
                         else
                            l:
                            t[]
                              ->help.findTextAll
                                (# NCS:: trueObject
                                do true->found; leave l
                                #)
                        if)
                    if)
                if);
                
            if)
        if)
     #)  

-- editorenvReplaceText: Descriptor --
(#  do  #)  

-- editorenvReplaceTextDialog: Descriptor --
(#
   replaced: @UI.replacedialog
     (#
        node: ^astInterface.ast;
        replace:: 
          (# cfg: ^astInterface.fragmentGroup
          do
             (if node[] <> none then
                 ymerCallBack.getCurrentFragmentGroup->cfg[];
                 (if cfg[] <> none then
                     (ymerCallback.theBrowser[],cfg[])
                       ->groupEditorList.findGroupEditor->ge[];
                     (if ge[] <> none then
                         node.frag[]->ge.formEditorList.findEditor->ce[];
                         (if ce[] <> none then
                             (node[],theSearchText[],theReplaceText[])
                               ->ce.editLexem;
                             next
                          else
                             'ce is none!'->putLine
                         if)
                      else
                         'ge is none!'->putLine
                     if)
                  else
                     'cfg is none!'->putLine
                 if)
             if)
          #);
        next:: 
          (# 
          do
             (if trace[12] then
                 'match case: '->putText;
                 matchCase->putBoolean;
                 newLine;
                 'match word: '->putText;
                 matchWord->putBoolean;
                 newLine;
                 'search area: '->putText;
                 searchArea->putInt;
                 newLine
             if);
             matchCase->searchPrivate.caseSensitive;
             matchWord->searchPrivate.wholeWord;
             (if searchArea
              // 1 then
                 true->searchPrivate.wrapForm;
                 false->searchPrivate.wrapGroup;
                 false->searchPrivate.wrapProject
              // 2 then
                 false->searchPrivate.wrapForm;
                 true->searchPrivate.wrapGroup;
                 false->searchPrivate.wrapProject
              // 3 then
                 false->searchPrivate.wrapForm;
                 false->searchPrivate.wrapGroup;
                 true->searchPrivate.wrapProject
             if);
             (if theSearchText.length > 0 then
                 (if not (searchPrivate.theSearchText[]->theSearchText.equal)
                  then
                     theSearchText.copy->searchPrivate.theSearchText[];
                     ''->searchPrivate.foundText
                 if);
                 (theSearchText[],searchPrivate.dir.down,ge[],ce[],fg[],ff[],
                  fgList[])->searchText->node[];
                 (if node[] <> none then
                     node[]->found
                  else
                     theSearchText[]->notFound
                 if)
             if)
          #);
        previous::  (#  do  #);
        cancel::  (#  do  #);
        
     #)
do
   replaced.open;
   none ->searchPrivate.fgPos[];
   ''->searchPrivate.foundText[];
   (none ,'replace','Search in lexems for:','Replace with:',
    searchPrivate.thesearchText[])->replaced.popup
#)  

