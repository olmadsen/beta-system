ORIGIN '../codeeditor';
INCLUDE '~beta/mps/v5.0.1/findgrammar'
        '~beta/betaast/v5.0.1/donecheck'
        '~beta/sysutils/v1.4.2/objinterface'
        'editorenvbody';
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-96
 * All rights reserved.
 *)
-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then 'is equal to editorenv'->putline if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then 'is equal to sifeditorenv'->putline;  if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (*
         * cannot be used because of different origins
         * objectPool.get
         (#
         type:: editorEnv;
         init:: 
         (# 
         do
         'init editorEnv from codeeditor'->putLine;
         true->inithere;
         (mps[],betagrammar[],UI[])->obj.init
         #)
         #)->edenv[];*)
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then 'codeeditor'->edenv.initiator[]->putLine;  if);
            edenv.initiator[]->putLine
        if);
        (* &undoElemType[]->undoElem[];*)
        &undoListDesc[]->undoList[];
        undoList.init;
        true->undoing;
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        (if up[] = none then &userPrivate[]->up[] if);
        userInit;
        THIS(codeeditor)[]->edenv.ffHandler.subscribe;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser was initialized'->putline;
            (*'~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
             (if betaGrammar.grammarAst[]
             // none then
             'No grammarAst for '->screen.putText; grammarWithPath[]->screen.putLine; 
             else
             '-parser'->help[];
             mps.parserFileExtension->help.append;
             help[]->grammarWithPath.copyAppend->mps.expandToFullPath->bobsFile.name;
             (if bobsFile.entry.exists then
             bobsFile.name->betaGrammar.parser.initialize;
             ('objectdescriptor','descriptor')
             ->betaGrammar.parser.privatePart.b.defineNonTAlias;
             ('attributedecl','attributes')->betaGrammar.parser.privatePart.b.defineNonTAlias;
             
             else
             'No parser available: '->screen.putText; bobsFile.name->screen.putLine; 
             if);
             
             if);
             true->parsingPossible;
             'Parser initialized now'->putLine;*)
            
        if);
        (if edenv.trace[2] then 'Grammar: '->putText; ag.grammarIdentification->putLine if);
        (if editorRoot[] = none then
            newPrivate;
            editorRoot[]->theSifTexteditor.editorRoot[];
            (if edenv.trace[2] then 'calling newPrivate'->putLine if);
            
        if);
        edenv.nextEditorId->id;
        (* siftexteditor trace: *)
        false->switch[1];
        (*  siftexteditor debug:  *)
        false->switch[2];
        (* very detailed siftexteditor debug: *)
        false->switch[3];
        (* textediting: *)
        false->switch[4];
        (* debug slots: *)
        false->switch[5];
        (* debug slots (very detailed): *)
        false->switch[6];
        (* touched and event trace: *)
        false->switch[7];
        (* history trace: *)
        false->switch[8];
        (* updateeditmenu trace: *)
        false->switch[10];
        (* object pool trace: *)
        false->switch[11];
        (* comments: *)
        false->switch[12];
        (* pp trace: *)
        false->switch[13];
        (* charwidth beregning: *)
        false->switch[14];
        (* freja communication: *)
        false->edenv.trace[1];
        (* start trace: *)
        false->edenv.trace[2];
        (* group editing: *)
        false->edenv.trace[3];
        (* touched and event trace: *)
        false->edenv.trace[7];
        (* history trace: *)
        false->edenv.trace[8];
        (* propertyEditor: *)
        false->edenv.trace[9];
        (* external procedure interface trace: *)
        false->edenv.trace[11]
     #)  

-- codeeditorFollowSemanticLink: Descriptor --
(#
   theNode: ^astInterface.ast;
   ff: ^astInterface.fragmentForm;
   fg: ^astInterface.fragmentGroup;
   help,help2: ^text;
   checked,doCheck: @boolean
do
   (if node.kind
    // mps.kinds.nameAppl // mps.kinds.nameDecl then node.father->theNode[]
    else
       node[]->theNode[]
   if);
   node.frag[]->ff[];
   ff.father->fg[];
   ((mps[],fg[])->getDoneCheckProperty (* isChecked *) )->checked;
   (if not checked then
       'This fragment group must be (re)checked '->help[];
       help.newLine;
       'in order to (re)build the semantic links '->help.putText;
       help.copy->help2[];
       help2.newline;
       help2.newLine;
       'Check current?'->help2.putText;
       (if (edenv[] <> none ) and (edenv.ymerCallback[] <> none ) then
           (none ,'Check current?',help2[])
             ->UI.promptForBoolean (# ok::  (#  do true->doCheck #) #);
           
        else
           (none ,help[],'Alert')->UI.alertUser; 
       if);
       (if doCheck then fg[]->edenv.ymerCallback.check->checked if)
   if);
   (if checked then
       (if theNode.symbol
        // betaGrammar.nameApl then
             (# theNameApl: ^betaGrammar.nameApl
             do
                theNode[]->theNameApl[];
                ((theNameApl.dclRef).frag.root[],theNameApl.dclRef,separate)->selectNodeInFormEditor
             #)
        // betaGrammar.nameDcl then
             (# theNameDcl: ^betaGrammar.nameDcl; f: ^astInterface.ast
             do
                theNode.father->f[];
                (if f.symbol
                 // betaGrammar.names then
                    f.father->f[];
                    (if f.symbol
                     // betaGrammar.bindingDecl // betaGrammar.finalDecl then
                        theNode[]->theNameDcl[];
                        ((theNameDcl.virtDcl).frag.root[],theNameDcl.virtDcl,separate)
                          ->selectNodeInFormEditor;
                        (* use findDescriptor instead? 
                         (if itemSelected
                         // 1 then
                         theNameApl.dclRef->selectNode
                         // 2 then
                         theNameApl.descRef->selectNode
                         // 3 then
                         theNameApl.findDescriptor->selectNode
                         if)*)
                        
                    if)
                if);
                (* use findDescriptor instead? 
                 (if itemSelected
                 // 2 then
                 theNode[]->theNameDcl[];
                 theNameDcl.findDescriptor->selectNode
                 if);
                 *)
                
             #)
       if)
   if)
#)  

-- codeeditorSetIsReadOnly: DoPart --
do
(* if value is false this operation must only be called 
 * if the groupfile is writeable
 *)
   value->isReadOnly;
   (if theSifTextEditor[] <> none then value->theSifTextEditor.isReadOnly if);
   subeditors.scan
     (#  do value->current.setIsReadOnly;  #)  

-- codeeditorOnReturnKey: DoPart --
do (if askInsertPermission then doInsertAfter if)  

-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            (none ,ff.father,false)->edenv.groupEditorList.findOrCreateGroupEditor->ge[]
         else
            (none ,ff.father)->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then fe[]->theSifViewer[] else none ->theSifViewer[] if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (none ,thesifViewer.frag.father,false)->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        edenv.globalWriteProtection or not ge.isReadOnly->theSifViewer.theSifTextEditor.isReadOnly;
        (if false then
            'setupFormEditor isReadOnly: '->putText;
            (if theSifViewer.theSifTextEditor.isReadOnly then
                'true'->putLine
             else
                'false'->putLine
            if);
            
        if)
     #)  

-- codeeditorCloseGroup: DoPart --
do
(*  shutdown: edenv.groupEditorList.scan
 (# 
 do current.closeGroup->value; (if not value then leave shutdown if)
 #)  *)   

-- codeeditorAutoSave: DoPart --
do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (#  do (if current.frag[] = frag[] then current[]->edenv.history.remove if) #)  

-- askOpenSubeditorPermission: DoPart --
do (cs.length = 1)->value  

-- codeeditorclose: DoPart --
do THIS(codeeditor)[]->edenv.ffHandler.unsubscribe  

-- codeeditorDoUndo: DoPart --
do undo  

-- codeeditorDoCut: DoPart --
do (if textEditMode then 'cut'->putLine else true->cs.undoPermit; cut if)  

-- codeeditorDoCopy: DoPart --
do true->cs.undoPermit; copy; updateEditMenu  

-- codeeditorDoPaste: DoPart --
do paste  

-- codeeditorDoClear: DoPart --
do true->cs.undoPermit; (false,true)->cut  

-- codeeditorAskUndoPermission: DoPart --
do cs.undoPermit->value  

-- codeeditorAskPastePermission: DoPart --
do cs.pastePermit->value  

