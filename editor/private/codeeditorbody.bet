ORIGIN '../codeeditor';
INCLUDE '~beta/mps/utils/safesemanticlinks'
        '~beta/betaast/donecheck'
        '~beta/sysutils/objinterface'
        'editorenvbody';
LIB_ITEM 'editorcodeeditor';
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-2000
 * All rights reserved.
 *)
-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then
                     'is equal to editorenv'->putline
                 if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then
                     'is equal to sifeditorenv'->putline; 
                 if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then
                'codeeditor'->edenv.initiator[]->putLine; 
            if);
            edenv.initiator[]->putLine
        if);
        (if edenv.trace[2] then 'codeeditor.init'->putLine if);
        &undoListDesc[]->undoList[];
        undoList.init;
        true->undoing->redoing;
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        &mps.astReplacedList[]->theAstReplacedList[];
        (if up[] = none then &userPrivate[]->up[] if);
        &ffObserverType[]->ffObserver[]->frag.attachObserver;
        ffObserver.no->no;
        userOnOpenCodeeditor;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser for grammar: '->putText;
            ag.grammarIdentification->putLine
        if);
        (if edenv.trace[2] then
            'Grammar: '->putText; ag.grammarIdentification->putLine
        if);
        (* siftexteditor trace: *)
        (if editorRoot[] = none then
            newAst;
            editorRoot[]->theSifTexteditor.editorRoot[];
            (if edenv.trace[2] then 'calling newPrivate'->putLine if);
            
        if);
        (*  siftexteditor debug:  *)
        edenv.nextEditorId->id;
        (* very detailed siftexteditor debug: *)
        false->switch[1];
        (* textediting: *)
        false->switch[2];
        (* debug slots: *)
        false->switch[3];
        (* debug slots (very detailed): *)
        false->switch[4];
        (* touched and event trace: *)
        false->switch[5];
        (* history trace: *)
        false->switch[6];
        (* updateeditmenu trace: *)
        edenv.switch[7]->switch[7];
        (* object pool trace: *)
        false->switch[8];
        (* comments: *)
        false->switch[10];
        (* pp trace: *)
        false->switch[11];
        (* charwidth beregning: *)
        false->switch[12];
        (* freja communication: *)
        (* start trace: *)
        false->switch[13];
        (* navigate trace: *)
        false->switch[14];
        (* parsing syncatno etc: *)
        false->switch[15];
        false->switch[16];
        (* group editing: *)
        false->edenv.trace[1];
        (* touched and event trace: *)
        false->edenv.trace[2];
        (* history trace: *)
        false->edenv.trace[3];
        (* propertyEditor: *)
        false->edenv.trace[7];
        (* external procedure interface trace: *)
        false->edenv.trace[8];
        (* trace global search replace: *)
        false->edenv.trace[9];
        (* undo trace: *)
        false->edenv.trace[11];
        (* navigate  trace: *)
        false->edenv.trace[12];
        false->edenv.trace[13];
        
     #)  

-- codeeditorGetFragmentgroup: DoPart --
do name[]->edenv.ymerCallBack.getFragmentGroup->fg[]  

-- codeeditorMachineType: DoPart --
do
   (if edenv.ymerCallBack[] <> none then
       edenv.ymerCallBack.machineType->t[]
   if)  

-- codeeditorLocalOnRefresh: DoPart --
do (node[],node[])->astView.pp.update  

-- codeeditorLocalOnFocusChanged: DoPart --
do
     (# t: ^text
     do
        updateExpandMenu;
        updateEditMenu;
        (if true (* byMe*) then
            edenv.setStructureCursor;
            (if cs.hasSemanticError then
                (if (cs.semanticError->mps.isWarning) then
                    'Warning: '->t[];
                    cs.semanticError->mps.semanticErrorText->t.append;
                    t[]->edenv.ymerCallback.infoView
                 else
                    cs.semanticError->mps.semanticErrorText
                      ->edenv.ymerCallback.infoView
                if)
             else
                edenv.ymerCallback.infoViewClear
            if)
        if);
        INNER localOnFocusChanged
     #)  

-- codeeditorFollowSemanticLink: Descriptor --
(# hasLink,semanticErrors: @boolean; theDecl: ^astInterface.ast
do
   node[]->edenv.hasSemanticLink->(hasLink,theDecl[],semanticErrors);
   (if hasLink then
       (theDecl.frag.root[],theDecl[],separate)->selectNodeInFormEditor
   if)
#)  

-- codeeditorHasSemanticLink: Descriptor --
(#
   theNode,fatherNode: ^astInterface.ast;
   help,help2,msg: ^text;
   checked,doCheck,stillInSameGroup: @boolean;
   checkNeeded:
     (#
        mess,help: ^text;
        status,doCheck: @boolean;
        theGroupEditor: ^groupEditor
     enter mess[]
     do
        mess.copy->help[];
        help.newline;
        help.newLine;
        'Check?'->help.putText;
        (if ymerCallback[] <> none then
            (none ,'Check?',help[])
              ->UI.promptForBoolean (# ok::  (#  do true->doCheck #) #);
            (if doCheck then
                (ymerCallback.theBrowserId,theNode.frag.father)
                  ->groupEditorList.findGroupEditor->theGroupEditor[];
                (if (theGroupEditor[] <> none ) then
                    (if not theGroupeditor.isReadOnly then
                        theNode.frag.father->ymerCallback.check->status
                     else
                        'Is readonly, make copy before checking'
                          ->ymerCallback.infoView;
                        theNode.frag.father->ymerCallback.saveAsAndCheck
                          ->status;
                        false->stillInSameGroup
                    if)
                if)
            if)
        if)
     exit status
     #);
   nodeExists:
     (#
        node: ^astInterface.ast;
        subtree: ^astInterface.expanded;
        value: @boolean
     enter (node[],subtree[])
     do
        false->value;
        (if node[] = none then
            'NodeExists: node is none!!'->putLine; 
         else
            (if subtree[] = none then
                'NodeExists: subtree is none!!'->putLine; 
             else
                (if node.frag[] <> subtree.frag[] then
                    'NodeExists: node and subtree are not in same fragment!!'
                      ->putLine;
                    (if node.frag.father = none then
                        'the fragmentform has no father!'->putLine;
                        'node: '->putText;
                        
                     else
                        'node: '->putText;
                        (node.frag.father).name->putText;
                        '-'->put
                    if);
                    node.frag.name->putText;
                    '-'->put;
                    node.index->putInt;
                    newline;
                    'subtree: '->putText;
                    (if subtree.frag.father = none then
                        'the fragmentform has no father!'->putLine;
                        'node: '->putText;
                        
                     else
                        'subtree: '->putText;
                        (subtree.frag.father).name->putText;
                        '-'->put
                    if);
                    subtree.frag.name->putText;
                    '-'->put;
                    subtree.index->putInt;
                    newline
                 else
                    loop: subtree.suffixwalk
                      (# 
                      do
                         (if node[]->current.equal then
                             true->value; leave loop
                         if)
                      #);
                    
                if)
            if)
        if)
     exit value
     #);
   isNodeInTree:
     (# node,tree: ^astInterface.ast; value: @boolean
     enter (node[],tree[])
     do
        false->value;
        (if tree.kind = mps.kinds.interior then
            (node[],tree[])->nodeExists->value
         else
            (node[]->tree.equal)->value
        if)
     exit value
     #)
do
   true->stillInSameGroup;
   thisCommand:
     (# 
     do
        (if node.kind
         // mps.kinds.nameAppl // mps.kinds.nameDecl then
            node.father->theNode[]
         else
            node[]->theNode[]
        if);
        (if theNode[] = none then
            'followSemanticLink: theNode is none!!'->putLine
         else
            (if theNode.symbol
             // betaGrammar.nameApl then
                  (#
                     theNameApl: ^betaGrammar.nameApl;
                     node: ^mps.ast;
                     theNameAppl: ^astInterface.nameAppl
                  do
                     theNode[]->theNameApl[];
                     (if true then
                         theNameApl[]->mps.safeDclRef->node[]
                      else
                         'hasSemanticLinks: calling old semantic links code (dclRef)'
                           ->putLine;
                         theNameApl.dclRef->node[]
                     if);
                     (if node[] <> none then
                         (if (node[],node.frag.root[])->isNodeInTree then
                             true->value; node[]->theDecl[]
                          else
                             ((theNode.frag.father).name).copy->help[];
                             '\nmust be (re)checked in order to (re)build the semantic links (1)\n'
                               ->help.append;
                             help[]->checkNeeded->checked;
                             not checked->semanticErrorsOrNotChecked;
                             (if checked and stillInSameGroup then
                                 restart thisCommand
                             if)
                         if)
                      else
                         ((theNode.frag.father).name).copy->help[];
                         '\nmust be (re)checked in order to (re)build the semantic links (2)\n'
                           ->help.append;
                         help[]->checkNeeded->checked;
                         not checked->semanticErrorsOrNotChecked;
                         (if checked and stillInSameGroup then
                             restart thisCommand
                         if)
                     if)
                  #)
             // betaGrammar.nameDcl then
                  (#
                     theNameDcl: ^betaGrammar.nameDcl;
                     f,node: ^astInterface.ast
                  do
                     theNode.father->f[];
                     (if f.symbol
                      // betaGrammar.names then
                         f.father->f[];
                         (if f.symbol
                          // betaGrammar.bindingDecl // betaGrammar.finalDecl
                          then
                             theNode[]->theNameDcl[];
                             (if true then
                                 theNameDcl[]->mps.safeVirtDcl->node[]
                              else
                                 'hasSemanticLinks: calling old semantic links code (virtDecl)'
                                   ->putLine;
                                 theNameDcl.VirtDcl->node[]
                             if);
                             (if node[] <> none then
                                 (if (node[],node.frag.root[])->isNodeInTree
                                  then
                                     true->value; node[]->theDecl[]
                                  else
                                     ((theNode.frag.father).name).copy->help[];
                                     '\nmust be (re)checked in order to (re)build the semantic links (3)\n'
                                       ->help.append;
                                     help[]->checkNeeded->checked;
                                     not checked->semanticErrorsOrNotChecked;
                                     (if checked and stillInSameGroup then
                                         restart thisCommand
                                     if)
                                 if)
                              else
                                 ((theNode.frag.father).name).copy->help[];
                                 '\nmust be (re)checked in order to (re)build the semantic links (4)\n'
                                   ->help.append;
                                 help[]->checkNeeded->checked;
                                 not checked->semanticErrorsOrNotChecked;
                                 (if checked and stillInSameGroup then
                                     restart thisCommand
                                 if)
                             if)
                             (* use findDescriptor instead?
                              (if itemSelected
                              // 1 then
                              theNameApl.myDclRef->selectNode
                              // 2 then
                              theNameApl.descRef->selectNode
                              // 3 then
                              theNameApl.findDescriptor->selectNode
                              if)*)
                         if)
                     if);
                     (* use findDescriptor instead?
                      (if itemSelected
                      // 2 then
                      theNode[]->theNameDcl[];
                      theNameDcl.findDescriptor->selectNode
                      if);
                      *)
                     
                  #)
            if)
        if)
     #)
#)  

-- codeeditorSetIsReadOnly: DoPart --
do
(* if value is false this operation must only be called
 * if the groupfile is writeable
 *)
   value->isReadOnly;
   (if frag[] <> none then
       (if isReadOnly then frag.setReadOnly else frag.unsetReadOnly if)
   if);
   (if theSifTextEditor[] <> none then
       value->theSifTextEditor.isReadOnly
   if);
   subeditors.scan
     (#  do value->current.setIsReadOnly;  #)  

-- codeeditorOnReturnKey: DoPart --
do (if not frag.locked and askInsertPermission then doInsertAfter if)  

-- codeeditorOnDeleteKey: DoPart --
do
   (if not frag.locked then
       true->cs.undoPermit;
       (false (*doNotNotify*) ,true (*doNotCopyToClipBoard*) )->cut;
       cs->setFocus (* inorder to scroll into view *)
   if)  

-- codeeditorKeyAllowed: DoPart --
do
   (if false (*isAFrejaEditor or (edenv.frejaExternalInterface[] <> none )*)
    then
       (if isAsubeditor or isApropertyEditor then
           (if (ch = ascii.bs) or (ch = ascii.del) then
               false->value;
               (none ,
                'Backspace is currently disabled in subeditors and property editors in Freja',
                'Backspace')->UI.alertUser
           if)
       if)
   if)  

-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            (edenv.ymercallBack.theBrowserId,ff.father,false)
              ->edenv.groupEditorList.findOrCreateGroupEditor->ge[]
         else
            (edenv.ymerCallBack.theBrowserId,ff.father)
              ->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then
                fe[]->theSifViewer[]
             else
                none ->theSifViewer[]
            if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (edenv.ymerCallBack.theBrowserId,thesifViewer.frag.father,false)
          ->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        edenv.globalWriteProtection or ge.isReadOnly->theSifViewer.setIsReadOnly
     #)  

-- codeeditorCloseGroup: DoPart --
do
(*  shutdown: edenv.groupEditorList.scan
 (#
 do current.closeGroup->value; (if not value then leave shutdown if)
 #)  *)   

-- codeeditorAutoSaveLimit: DoPart --
do 1->ASlimit; INNER  

-- codeeditorCheckAutoSave: DoPart --
do
   noOfAstChanges+1->noOfAstChanges;
   (if isUndoing then
       (if oldTouched > 0 then
           oldTouched->touched;
           0->oldTouched;
           thisGroupEditor.oldTouched->thisGroupEditor.touched;
           0->thisGroupEditor.oldTouched;
           (if (thisGroupEditor.grammarName[] <> none ) then
               (if ('beta'->thisGroupEditor.grammarName.equal) then
                   (false,mps[],thisGroupEditor.fg[])->setDoneCheckProperty;
                   thisGroupEditor.fg[]->edenv.ymerCallBack.onGroupTouched
               if)
           if);
           frag.notifyTouched
        else
           frag.notifyDetouched
       if)
    else
       frag.notifyTouched
   if);
   (if (noOfAstChanges >= ASLimit) then
       (if not isApropertyEditor then
           (if thisGroupEditor[] <> none then
               (if not thisGroupEditor.isAfrejaEditor then
                   autoSave; 0->noOfAstChanges
               if)
            else
               autoSave; 0->noOfAstChanges
           if)
       if)
   if)  

-- codeeditorAutoSave: DoPart --
do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- askOpenSubeditorPermission: DoPart --
do (cs.length = 1)->value  

-- codeeditorSetTexteditmode: DoPart --
do
   (if theSifTextEditor.textediting then (*edenv.setTextCursor*)
       edenv.textCursor[]->theSifTexteditor.theCursor;
       frag.lock;
       frag.notifyEnterTextediting
    else
   (*edenv.setStructureCursor;*)
       UI.cursors.arrow[]->theSifTexteditor.theCursor;
       false->theSifTexteditor.allowedTextediting;
       frag.unLock;
       frag.notifyExitTextediting
   if);
   theSifTextEditor.textediting->edenv.textediting  

-- codeeditorAskTexteditMode: DoPart --
do textEditMode->value  

-- codeeditorclose: DoPart --
do THIS(codeeditor).ffObserver[]->frag.detachObserver  

-- codeeditorDoUndo: DoPart --
do undo; true->cs.redoPermit  

-- codeeditorDoRedo: DoPart --
do redo  

-- codeeditorDoCut: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.cut
    else
       (if (cs.subCommentInx1 = 0) and (cs.subCommentInx2 = 0) then
           true->cs.undoPermit;
           cut;
           cs->setFocus (* inorder to scroll into view *)
        else
           (none ,'To edit comments, textedit the enclosing structure','Cut')
             ->UI.alertUser
       if)
   if)  

-- codeeditorDoCopy: DoPart --
do
     (#
        hasContractions: booleanValue
          (# t: ^text
          enter t[]
          do l: '<<@'->t.findTextAll (#  do true->value; leave l #)
          #)
     do
        (if textEditMode then
            edenv.ymerCallback.infoViewClear;
            (if not
            (theSifTextEditor.contents.selection.contents->hasContractions) then
                theSifTextEditor.contents.copy
             else
                'It is not possible to copy the textual representation of contractions'
                  ->edenv.ymerCallback.infoView;
                ascii.bel->put;
                (theSifTextEditor.contents.selection.start,
                 theSifTextEditor.contents.selection.start)
                  ->theSifTextEditor.contents.selection;
                theSifTextEditor.contents.copy
            if)
         else
            copy; updateEditMenu
        if)
     #)  

-- codeeditorDoPaste: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.paste
    else
       true->cs.undoPermit; paste
   if)  

-- codeeditorDoClear: DoPart --
do
   true->cs.undoPermit;
   (false,true)->cut;
   cs->setFocus (* inorder to scroll into view *)  

-- codeeditorDoSelectAll: DoPart --
do (frag.root[],1,0,0)->setFocus;   

-- codeeditorAskUndoPermission: DoPart --
do cs.undoPermit and (undoElem[] <> none )->value  

-- codeeditorAskRedoPermission: DoPart --
do cs.redoPermit and (undoElem[] <> none )->value  

-- codeeditorAskPastePermission: DoPart --
do cs.pastePermit->value  

-- codeeditorExternalTextEdit: DoPart --
do textBefore[]->edenv.ymerCallBack.externalTextEdit->textAfter[]  

-- codeeditorAskBeforeTextediting: DoPart --
do
     (# exp: ^astInterface.expanded
     do
        (if isAFrejaEditor and (edenv.frejaExternalInterface[] <> none ) then
            (if cs.node[]->edenv.frejaExternalInterface.askBeforeTextediting
             then
                (if cs.node.kind = mps.kinds.interior then
                    cs.node[]->exp[];
                    betaGram.ObjectDescriptor
                      ->exp.suffixWalkForProd (#  do true->value #)
                if)
            if)
        if)
     #)  

-- codeeditorAskBeforeTexteditingMessage: DoPart --
do
   (if isAFrejaEditor and (edenv.frejaExternalInterface[] <> none ) then
       edenv.frejaExternalInterface.askBeforeTexteditingMessage->msg[];
       (if msg[] = none then
           'Textediting on this level may imply that parts of the diagrams have to be rebuilt, continue?'
             ->msg[]
       if)
   if)  

-- codeeditorEditLexem: DoPart --
do
     (#
        lexText: ^astInterface.lexemText;
        fatherNode: ^astInterface.expanded;
        currentText: ^text;
        found: @boolean;
        startInx: @integer
     do
        thisOp:
        (if (node[] <> none ) and (newText[] <> none ) then
            node[]
              ->checkSonNode (* in case node is pointing at the nameApl level *)
              ->node[];
            (if node.kind
             // mps.kinds.nameDecl // mps.kinds.nameAppl // mps.kinds.string
             // mps.kinds.unexpanded then
                (if node.kind <> mps.kinds.string then
                    newText.scanAll
                      (# 
                      do
                         (if not
                         (((ch >= 'a') and (ch <= 'z')) or
                          ((ch >= 'A') and (ch <= 'Z')) or
                          ((ch >= '0') and (ch <= '9')) or (ch = '_')) then
                             'Not valid lexem'->putLine; leave thisOp
                         if)
                      #)
                if);
                (if node.kind <> mps.kinds.unexpanded then
                    (if node## <= mps.lexemText## then
                        node[]->lexText[]; lexText.getText->currentText[]
                     else
                        'EditLexem: wrong qualifiation, not lexemText'->putLine;
                        leave thisOp
                    if)
                 else
                    ''->currentText[]
                if);
                (if (oldText[] = none ) or (oldText[]->currentText.equalNCS)
                 then
                    true->cs.undoPermit;
                    (node.father,node.sonNo,(node[],1,0,0),1,false)
                      ->makeUndoElem;
                    (node[]->getSynCatNo,frag[])->ag.newAst->lexText[];
                    newText[]->lexText.putText;
                    node.father->fatherNode[];
                    (node.sonno,lexText[])->fatherNode.put;
                    makeASTreplacedEvent;
                    lexText[]->cs.node[];
                    cs->setFocus
                 else
                    l:
                    oldText[]
                      ->currentText.findTextAll
                        (# NCS:: trueObject
                        do true->found; inx->startInx; leave l
                        #);
                    (if found then
                        true->cs.undoPermit;
                        (node.father,node.sonNo,(node[],1,0,0),1,false)
                          ->makeUndoElem;
                        (startInx,startInx+oldText.length-1)
                          ->currentText.delete;
                        (newText[],startInx)->currentText.insert;
                        (node[]->getSynCatNo,frag[])->ag.newAst->lexText[];
                        currentText[]->lexText.putText;
                        node.father->fatherNode[];
                        (node.sonno,lexText[])->fatherNode.put;
                        makeASTreplacedEvent;
                        lexText[]->cs.node[];
                        cs->setFocus
                     else
                        oldText[]->putText;
                        ' not found in: '->putText;
                        newText[]->putLine;
                        
                    if)
                if)
            if)
        if)
     #)  

-- resetFragmentTouchBody: Descriptor --
(# 
do
   (if switch[7] then
       (frag.father).name->putText;
       '-'->put;
       frag.name->putText;
       ' reset touched, was touched '->putText;
       touched->putint;
       ' times'->putLine;
       
   if);
   touched->oldTouched;
   0->touched;
   
#)  

-- fragmentTouchedBody: Descriptor --
(# 
do
   touched+1->touched;
   (if switch[7] then
       (frag.father).name->putText;
       '-'->put;
       frag.name->putText;
       ' fragment touched '->putText;
       touched->putint;
       ' times'->putLine;
       
   if);
   (if touched = 1 then 'TOUCHED'->frag.prop.addProp if);
   (if thisGroupEditor[] <> none then thisGroupEditor.groupTouched;  if)
#)  

-- fragmentDetouchedBody: Descriptor --
(# 
do
   touched-1->touched;
   (if switch[7] then
       (frag.father).name->putText;
       '-'->put;
       frag.name->putText;
       ' fragment touched '->putText;
       touched->putint;
       ' times'->putLine;
       
   if);
   (if thisGroupEditor[] <> none then
       thisGroupEditor.fg.notifyDetouched; 
   if);
   
#)  

-- askShowDiagramPermission: DoPart --
do cs.node[]->edenv.ymerCallback.askShowDiagram->value  

-- askEditUserinterfacePermission: DoPart --
do cs.node[]->edenv.ymerCallback.askEditUserinterface->value  

-- codeeditorShowdiagram: DoPart --
do cs.node[]->edenv.ymerCallBack.showDiagram  

-- codeeditorEditUserinterface: DoPart --
do (frag[],cs.node[])->edenv.ymerCallback.editUserinterface  

-- codeeditorCallQuit: DoPart --
do edenv.ymerCallback.quit  

