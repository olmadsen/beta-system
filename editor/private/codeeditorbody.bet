ORIGIN '../codeeditor';
INCLUDE '~beta/mps/v5.0.1/findgrammar'
        '~beta/betaast/v5.0.1/donecheck'
        '~beta/sysutils/v1.4.2/objinterface'
        'editorenvbody';
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-96
 * All rights reserved.
 *)
-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then
                     'is equal to editorenv'->putline
                 if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then
                     'is equal to sifeditorenv'->putline; 
                 if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then
                'codeeditor'->edenv.initiator[]->putLine; 
            if);
            edenv.initiator[]->putLine
        if);
        &undoListDesc[]->undoList[];
        undoList.init;
        true->undoing;
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        (if up[] = none then &userPrivate[]->up[] if);
        userInit;
        THIS(codeeditor)[]->edenv.ffHandler.subscribe;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser was initialized'->putline;
            (*'~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
             (if betaGrammar.grammarAst[]
             // none then
             'No grammarAst for '->screen.putText; grammarWithPath[]->screen.putLine; 
             else
             '-parser'->help[];
             mps.parserFileExtension->help.append;
             help[]->grammarWithPath.copyAppend->mps.expandToFullPath->bobsFile.name;
             (if bobsFile.entry.exists then
             bobsFile.name->betaGrammar.parser.initialize;
             ('objectdescriptor','descriptor')
             ->betaGrammar.parser.privatePart.b.defineNonTAlias;
             ('attributedecl','attributes')->betaGrammar.parser.privatePart.b.defineNonTAlias;
             
             else
             'No parser available: '->screen.putText; bobsFile.name->screen.putLine; 
             if);
             
             if);
             true->parsingPossible;
             'Parser initialized now'->putLine;*)
            
        if);
        (if edenv.trace[2] then
            'Grammar: '->putText; ag.grammarIdentification->putLine
        if);
        (if editorRoot[] = none then
            newPrivate;
            editorRoot[]->theSifTexteditor.editorRoot[];
            (if edenv.trace[2] then 'calling newPrivate'->putLine if);
            
        if);
        edenv.nextEditorId->id;
        false->switch[1];
        false->switch[2];
        false->switch[3];
        false->switch[4];
        false->switch[5];
        false->switch[6];
        false->switch[7];
        false->switch[8];
        false->switch[10];
        false->switch[11];
        false->switch[12];
        false->switch[13];
        false->switch[14];
        false->edenv.trace[1];
        false->edenv.trace[2];
        false->edenv.trace[3];
        false->edenv.trace[7];
        false->edenv.trace[8];
        false->edenv.trace[9];
        false->edenv.trace[11]
     #)  

-- codeeditorMachineType: DoPart --
do
   (if edenv.ymerCallBack[] <> none then
       edenv.ymerCallBack.machineType->t[]
   if)  

-- codeeditorFollowSemanticLink: Descriptor --
(#
   theNode: ^astInterface.ast;
   ff: ^astInterface.fragmentForm;
   fg: ^astInterface.fragmentGroup;
   help,help2: ^text;
   checked,doCheck: @boolean;
   myValueToAst: (* Private *)
     (#
        val: @integer; a: ^astInterface.Ast; ff,f: ^astInterface.fragmentForm
     enter (val,ff[])
     do
        (if val
         // 0 then none ->a[]
         else
            val->tos'%getShort[0]'->ff.import.getGroup->f[];
            val->tos'%getShort[1]'->tos'%ShiftLeft[1]'->val;
            (if val <> 0 then
                val
                  ->f.indextoNode
                    (#
                       indexOutOfRange::< 
                         (# 
                         do 'indexOutOfRange'->putLine; true->continue; 
                         #);
                       noSuchSymbol::< 
                         (# 
                         do 'noSuchSymbol'->putLine; true->continue; 
                         #);
                       grammarGenRefArrayError::< 
                         (# 
                         do
                            'grammarGenRefArrayError'->putLine; true->continue; 
                         #)
                    #)->a[]
            if)
        if)
     exit a[]
     #);
   myGetNodeAttribute:
     (# aplNode,val: ^astInterface.ast; attributNo: @integer
     enter (attributNo,aplNode[])
     do
        attributNo->aplNode.checkAttributNo;
        (aplNode.frag.a[aplNode.index+ (*offset.attribute*) 2+attributno-1],
         aplNode.frag[])->myValueToAst->val[]
     exit val[]
     #);
   myDclRef:
     (# aplNode,dclNode: ^astInterface.ast
     enter aplNode[]
     do ((1,aplNode[])->myGetNodeAttribute)->dclNode[]; 
     exit dclNode[]
     #);
   myVirtDcl:
     (# aplNode,dclNode: ^astInterface.ast; f: ^astInterface.ast
     enter aplNode[]
     do
        aplNode.father->f[];
        f.father->f[];
        ((1,f[])->myGetNodeAttribute)->dclNode[]
     exit dclNode[]
     #);
   checkNeeded:
     (# mess,help: ^text; status,doCheck: @boolean
     enter mess[]
     do
        mess.copy->help[];
        help.newline;
        help.newLine;
        'Check current?'->help.putText;
        (if (edenv[] <> none ) and (edenv.ymerCallback[] <> none ) then
            (none ,'Check current?',help[])
              ->UI.promptForBoolean (# ok::  (#  do true->doCheck #) #);
            
         else
            (none ,mess[],'Alert')->UI.alertUser; 
        if);
        (if doCheck then fg[]->edenv.ymerCallback.check->status if)
     exit status
     #);
   
do
   thisCommand:
     (# 
     do
        (if node.kind
         // mps.kinds.nameAppl // mps.kinds.nameDecl then
            node.father->theNode[]
         else
            node[]->theNode[]
        if);
        node.frag[]->ff[];
        ff.father->fg[];
        ((mps[],fg[])->getDoneCheckProperty (* isChecked *) )->checked;
        (if not checked then
            'This fragment group must be (re)checked \nin order to (re)build the semantic links\n'
              ->checkNeeded->checked
        if);
        doCommand
          (# 
          do
             (if checked then
                 (if theNode[] = none then
                     'followSemanticLink: theNode is none!!'->putLine
                  else
                     (if theNode.symbol
                      // betaGrammar.nameApl then
                           (#
                              theNameApl: ^betaGrammar.nameApl; node: ^mps.ast
                           do
                              theNode[]->theNameApl[];
                              theNameApl[]->myDclRef->node[];
                              (if node[] <> none then
                                  (node.frag.root[],node[],separate)
                                    ->selectNodeInFormEditor
                               else
                                  'The destination fragment group must be (re)checked \nin order to (re)build the semantic links\n'
                                    ->checkNeeded->checked;
                                  (if checked then restart thisCommand if)
                              if)
                           #)
                      // betaGrammar.nameDcl then
                           (#
                              theNameDcl: ^betaGrammar.nameDcl;
                              f,node: ^astInterface.ast
                           do
                              theNode.father->f[];
                              (if f.symbol
                               // betaGrammar.names then
                                  f.father->f[];
                                  (if f.symbol
                                   // betaGrammar.bindingDecl
                                   // betaGrammar.finalDecl then
                                      theNode[]->theNameDcl[];
                                      theNameDcl[]->myVirtDcl->node[];
                                      (if node[] <> none then
                                          (node.frag.root[],node[],separate)
                                            ->selectNodeInFormEditor
                                       else
                                          'The destination fragment group must be (re)checked \nin order to (re)build the semantic links\n'
                                            ->checkNeeded->checked;
                                          (if checked then
                                              restart thisCommand
                                          if)
                                      if)
                                      (* use findDescriptor instead? 
                                       (if itemSelected
                                       // 1 then
                                       theNameApl.myDclRef->selectNode
                                       // 2 then
                                       theNameApl.descRef->selectNode
                                       // 3 then
                                       theNameApl.findDescriptor->selectNode
                                       if)*)
                                  if)
                              if);
                              (* use findDescriptor instead? 
                               (if itemSelected
                               // 2 then
                               theNode[]->theNameDcl[];
                               theNameDcl.findDescriptor->selectNode
                               if);
                               *)
                              
                           #)
                     if)
                 if)
             if)
          #)
     #)
#)  

-- codeeditorSetIsReadOnly: DoPart --
do
(* if value is false this operation must only be called 
 * if the groupfile is writeable
 *)
   value->isReadOnly;
   (if theSifTextEditor[] <> none then
       value->theSifTextEditor.isReadOnly
   if);
   subeditors.scan
     (#  do value->current.setIsReadOnly;  #)  

-- codeeditorOnReturnKey: DoPart --
do (if askInsertPermission then doInsertAfter if)  

-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            (none ,ff.father,false)
              ->edenv.groupEditorList.findOrCreateGroupEditor->ge[]
         else
            (none ,ff.father)->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then
                fe[]->theSifViewer[]
             else
                none ->theSifViewer[]
            if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (none ,thesifViewer.frag.father,false)
          ->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        edenv.globalWriteProtection or not ge.isReadOnly
          ->theSifViewer.theSifTextEditor.isReadOnly;
        (if false then
            'setupFormEditor isReadOnly: '->putText;
            (if theSifViewer.theSifTextEditor.isReadOnly then
                'true'->putLine
             else
                'false'->putLine
            if);
            
        if)
     #)  

-- codeeditorCloseGroup: DoPart --
do
(*  shutdown: edenv.groupEditorList.scan
 (# 
 do current.closeGroup->value; (if not value then leave shutdown if)
 #)  *)   

-- codeeditorAutoSave: DoPart --
do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- askOpenSubeditorPermission: DoPart --
do (cs.length = 1)->value  

-- codeeditorclose: DoPart --
do THIS(codeeditor)[]->edenv.ffHandler.unsubscribe  

-- codeeditorDoUndo: DoPart --
do undo  

-- codeeditorDoCut: DoPart --
do (if textEditMode then 'cut'->putLine else true->cs.undoPermit; cut if)  

-- codeeditorDoCopy: DoPart --
do true->cs.undoPermit; copy; updateEditMenu  

-- codeeditorDoPaste: DoPart --
do paste  

-- codeeditorDoClear: DoPart --
do true->cs.undoPermit; (false,true)->cut  

-- codeeditorAskUndoPermission: DoPart --
do cs.undoPermit and (undoElem[] <> none )->value  

-- codeeditorAskPastePermission: DoPart --
do cs.pastePermit->value  

