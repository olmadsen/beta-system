(*
 COPYRIGHT
 Copyright Mjolner Informatics, 1986-94
 All rights reserved.
 *)
ORIGIN '../codeeditor';
INCLUDE '~beta/mps/v4.9.1/findgrammar'
        '~beta/betaast/v4.9.1/donecheck'
        '~beta/sysutils/v1.4/objinterface'
        'editorenvbody';
(*
 COPYRIGHT
 Copyright Mjolner Informatics, 1986-94
 All rights reserved.
 *)
-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            ff.father->edenv.groupEditorList.findOrCreateGroupEditor->ge[]
         else
            ff.father->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then
                fe[]->theSifViewer[]
             else
                none ->theSifViewer[]
            if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        thesifViewer.frag.father->edenv.groupEditorList.findOrCreateGroupEditor
          ->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        not ge.writeAccess->theSifViewer.theSifTextEditor.isReadOnly;
        (if false then
            'readOnly: '->putText;
            (if theSifViewer.theSifTextEditor.readOnly then
                'true'->putLine
             else
                'false'->putLine
            if);
            
        if)
     #)  

-- codeeditorCloseGroup: DoPart --
do (*thisGroupEditor.closeGroup->value*)
   shutdown: edenv.groupEditorList.scan
     (# 
     do current.closeGroup->value; (if not value then leave shutdown if)
     #)  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- autoSaveLimitBody: Descriptor --
(#  do 1->ASlimit;  #)  

-- autoSaveBody: DoPart --
do
   (if switch[7] then 'autosave'->putLine;  if);
   (if not isApropertyEditor and not isASubeditor then
       (if not thisGroupEditor.isAfrejaEditor then
       (*'Auto save...'->  screen.putText*) (*UI.setAutoSaveCursor;*)
           thisOperation:
             (# 
             do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup
             #);
           (*UI.setStructureCursor*)
           
       if)
   if)  

-- fragmentChangedEventBody: Descriptor --
(# 
do
   noOfAstChanges+1->noOfAstChanges;
   fragmentTouched;
   (if byMe then
       (if (noOfAstChanges >= ASLimit) then autoSave; 0->noOfAstChanges;  if);
       
   if);
   
#)  

-- resetFragmentTouchBody: Descriptor --
(#  do 0->touched;  #)  

-- fragmentTouchedBody: Descriptor --
(# 
do
   touched+1->touched;
   (if switch[7] then
       'fragment touched '->putText; touched->putint; ' times'->putLine; 
   if);
   'TOUCHED'->frag.prop.addProp;
   (if thisGroupEditor[] <> none then thisGroupEditor.groupTouched;  if)
#)  

-- fragmentDetouchedBody: Descriptor --
(# 
do
   touched-1->touched;
   (if switch[7] then
       'fragment touched '->putText; touched->putint; ' times'->putLine; 
   if);
   (if thisGroupEditor[] <> none then thisGroupEditor.groupDetouched;  if);
   
#)  

-- askOpenSubeditorPermission: DoPart --
do
   (if cs.length = 1 then
       ((cs.node.kind = mps.kinds.interior) or
        (cs.node.kind = mps.kinds.unexpanded))->value
   if)  

-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then
                     'is equal to editorenv'->putline
                 if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then
                     'is equal to sifeditorenv'->putline; 
                 if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (*
         * cannot be used because of different origins
         * objectPool.get
         (#
         type:: editorEnv;
         init:: 
         (# 
         do
         'init editorEnv from codeeditor'->putLine;
         true->inithere;
         (mps[],betagrammar[],UI[])->obj.init
         #)
         #)->edenv[];*)
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then
                'codeeditor'->edenv.initiator[]->putLine; 
            if);
            edenv.initiator[]->putLine
        if);
        &undoElemType[]->undoElem[];
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        THIS(codeeditor)[]->edenv.ffHandler.subscribe;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser was initialized'->putline;
            '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
            (if betaGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists then
                    bobsFile.name->betaGrammar.parser.initialize;
                    ('objectdescriptor','descriptor')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    ('attributedecl','attributes')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if);
                
            if);
            true->parsingPossible;
            'Parser initialized now'->putLine;
            
        if);
        edenv.nextEditorId->id;
        false->switch[1];
        (* siftexteditor trace *)
        false->switch[2];
        (*  siftexteditor debug  *)
        false->switch[3];
        (* detailed siftexteditor debug *)
        false->switch[4];
        (* textediting *)
        false->switch[5];
        (* debug slots *)
        false->switch[6];
        (* debug slots? *)
        false->switch[7];
        (* touched trace *)
        false->switch[8];
        (* history trace *)
        false->switch[10];
        (* updateeditmenu trace *)
        false->switch[11];
        (* object pool trace *)
        false->edenv.trace[1];
        (* freja communication *)
        true->edenv.trace[2];
        (* start trace *)
        false->edenv.trace[3];
        (* group editing *)
        false->edenv.trace[7];
        (* touched trace *)
        false->edenv.trace[8];
        (* history trace *)
        false->edenv.trace[9] (* propertyEditor *)
     #)  

