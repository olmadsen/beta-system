ORIGIN '../codeeditor';
INCLUDE '~beta/mps/v4.9.1/findgrammar'
        '~beta/betaast/v4.9.1/donecheck'
        'editorenvbody';
(*
 COPYRIGHT
 Copyright Mjolner Informatics, 1986-94
 All rights reserved.
 *)
-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        ff.father->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        ff[]->ge.formeditorList.findEditor->fe[];
        (if fe[] <> none then fe[]->theSifViewer[] if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        thesifViewer.frag.father->edenv.groupEditorList.findOrCreateGroupEditor
          ->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[]
     #)  

-- codeeditorCloseGroup: DoPart --
do (*thisGroupEditor.closeGroup->value*)
   shutdown: edenv.groupEditorList.scan
     (# 
     do
        current.closeGroup->value;
        'value is: '->putText;
        (if value then 1->putInt else 0->putInt if);
        newLine;
        (if not value then leave shutdown if)
     #)  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- autoSaveLimitBody: Descriptor --
(#  do 1->ASlimit;  #)  

-- autoSaveBody: DoPart --
do
   (if switch[7] then 'autosave'->putLine;  if);
   (if not thisGroupEditor.isAfrejaEditor then
   (*'Auto save...'->  screen.putText*) (*UI.setAutoSaveCursor;*)
       thisOperation:
         (# 
         do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup
         #);
       (*UI.setStructureCursor*)
       
   if)  

-- fragmentChangedEventBody: Descriptor --
(# 
do
   noOfAstChanges+1->noOfAstChanges;
   fragmentTouched;
   (if (noOfAstChanges >= ASLimit) then autoSave; 0->noOfAstChanges;  if);
   (* (if (thisGroupEditor[] <> none ) then
    (if thisGroupEditor.writeAccess then
    
    if);
    
    if);*)
   
#)  

-- resetFragmentTouchBody: Descriptor --
(#  do 0->touched;  #)  

-- fragmentTouchedBody: Descriptor --
(# 
do
   touched+1->touched;
   (if switch[7] then
       'fragment touched '->putText; touched->putint; ' times'->putLine; 
   if);
   'TOUCHED'->frag.prop.addProp;
   (if thisGroupEditor[] <> none then thisGroupEditor.groupTouched;  if)
#)  

-- fragmentDetouchedBody: Descriptor --
(# 
do
   touched-1->touched;
   (if switch[7] then
       'fragment touched '->putText; touched->putint; ' times'->putLine; 
   if);
   (if thisGroupEditor[] <> none then thisGroupEditor.groupDetouched;  if);
   
#)  

-- codeeditorinit: DoPart --
do
     (# grammarWithPath,help: ^text; gg: ^mps.fragmentGroup; bobsfile: @file
     do
     (*&editorEnv[]->edenv[]
      ->objectPool.put
      (# alreadyThere::<  (#  do true->continue #) #);
      (mps[],betagrammar[],UI[])->edenv.init;*)
        objectPool.get
          (#
             type:: editorEnv;
             init:: 
               (# 
               do
                  'init editorEnv from codeeditor'->putLine;
                  (mps[],betagrammar[],UI[])->obj.init
               #)
          #)->edenv[];
        &undoElemType[]->undoElem[];
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser was initialized'->putline;
            '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
            (if betaGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists then
                    bobsFile.name->betaGrammar.parser.initialize;
                    ('objectdescriptor','descriptor')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    ('attributedecl','attributes')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if);
                
            if);
            true->parsingPossible;
            'Parser initialized now'->putLine;
            
        if);
        edenv.nextEditorId->id;
        false->switch[1];
        (* siftexteditor trace *)
        false->switch[2];
        (*  siftexteditor debug  *)
        false->switch[3];
        (* detailed siftexteditor debug *)
        false->switch[4];
        (* textediting *)
        false->switch[5];
        (* debug slots *)
        false->switch[6];
        (* debug slots? *)
        false->switch[7];
        (* touched trace *)
        false->switch[8];
        (* history trace *)
        false->switch[10];
        (* updateeditmenu trace *)
        false->edenv.trace[1];
        (* freja communication *)
        false->edenv.trace[2];
        (* start trace *)
        false->edenv.trace[3];
        (* group editing *)
        false->edenv.trace[7];
        (* touched trace *)
        false->edenv.trace[8] (* history trace *)
     #)  

