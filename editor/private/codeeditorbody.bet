ORIGIN '../codeeditor';
INCLUDE '~beta/mps/v4.9.1/findgrammar'
        '~beta/betaast/v4.9.1/donecheck'
        '~beta/sysutils/v1.4/objinterface'
        'editorenvbody';
(*
 COPYRIGHT
 Copyright Mjolner Informatics, 1986-94
 All rights reserved.
 *)
-- codeeditorOnReturnKey: DoPart --
do (if askInsertPermission then doInsertAfter if)  

-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            (none ,ff.father)->edenv.groupEditorList.findOrCreateGroupEditor
              ->ge[]
         else
            (none ,ff.father)->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then
                fe[]->theSifViewer[]
             else
                none ->theSifViewer[]
            if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (none ,thesifViewer.frag.father)
          ->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        not ge.writeAccess->theSifViewer.theSifTextEditor.isReadOnly;
        (if false then
            'readOnly: '->putText;
            (if theSifViewer.theSifTextEditor.readOnly then
                'true'->putLine
             else
                'false'->putLine
            if);
            
        if)
     #)  

-- codeeditorCloseGroup: DoPart --
do
(*  shutdown: edenv.groupEditorList.scan
 (# 
 do current.closeGroup->value; (if not value then leave shutdown if)
 #)  *)   

-- codeeditorAutoSave: DoPart --
do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- askOpenSubeditorPermission: DoPart --
do (cs.length = 1)->value  

-- codeeditorclose: DoPart --
do THIS(codeeditor)[]->edenv.ffHandler.unsubscribe  

-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then
                     'is equal to editorenv'->putline
                 if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then
                     'is equal to sifeditorenv'->putline; 
                 if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (*
         * cannot be used because of different origins
         * objectPool.get
         (#
         type:: editorEnv;
         init:: 
         (# 
         do
         'init editorEnv from codeeditor'->putLine;
         true->inithere;
         (mps[],betagrammar[],UI[])->obj.init
         #)
         #)->edenv[];*)
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then
                'codeeditor'->edenv.initiator[]->putLine; 
            if);
            edenv.initiator[]->putLine
        if);
        (* &undoElemType[]->undoElem[];*)
        &undoListDesc[]->undoList[];
        undoList.init;
        true->undoing;
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        THIS(codeeditor)[]->edenv.ffHandler.subscribe;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser was initialized'->putline;
            '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
            (if betaGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists then
                    bobsFile.name->betaGrammar.parser.initialize;
                    ('objectdescriptor','descriptor')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    ('attributedecl','attributes')
                      ->betaGrammar.parser.privatePart.b.defineNonTAlias;
                    
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if);
                
            if);
            true->parsingPossible;
            'Parser initialized now'->putLine;
            
        if);
        edenv.nextEditorId->id;
        (* siftexteditor trace: *)
        false->switch[1];
        (*  siftexteditor debug:  *)
        false->switch[2];
        (* detailed siftexteditor debug: *)
        false->switch[3];
        (* textediting: *)
        false->switch[4];
        (* debug slots: *)
        false->switch[5];
        (* debug slots?: *)
        false->switch[6];
        (* touched and event trace: *)
        false->switch[7];
        (* history trace: *)
        false->switch[8];
        (* updateeditmenu trace: *)
        false->switch[10];
        (* object pool trace: *)
        false->switch[11];
        (* freja communication: *)
        false->edenv.trace[1];
        (* start trace: *)
        false->edenv.trace[2];
        (* group editing: *)
        false->edenv.trace[3];
        (* touched and event trace: *)
        false->edenv.trace[7];
        (* history trace: *)
        false->edenv.trace[8];
        (* propertyEditor: *)
        false->edenv.trace[9];
        (* external procedure interface trace: *)
        false->edenv.trace[11];
        
     #)  

