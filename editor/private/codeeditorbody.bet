ORIGIN '../codeeditor';
INCLUDE '~beta/betaast/v5.2/donecheck'
        '~beta/betaast/v5.2/semanticerrortext'
        '~beta/sysutils/v1.6/objinterface'
        'editorenvbody';
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-97
 * All rights reserved.
 *)
-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then
                     'is equal to editorenv'->putline
                 if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then
                     'is equal to sifeditorenv'->putline; 
                 if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then
                'codeeditor'->edenv.initiator[]->putLine; 
            if);
            edenv.initiator[]->putLine
        if);
        (if edenv.trace[2] then 'codeeditor.init'->putLine if);
        &undoListDesc[]->undoList[];
        undoList.init;
        true->undoing->redoing;
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        (if up[] = none then &userPrivate[]->up[] if);
        userInit;
        THIS(codeeditor)[]->edenv.ffHandler.subscribe;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if edenv.trace[2] then
            'Grammar: '->putText; ag.grammarIdentification->putLine
        if);
        (* siftexteditor trace: *)
        (if editorRoot[] = none then
            newPrivate;
            editorRoot[]->theSifTexteditor.editorRoot[];
            (if edenv.trace[2] then 'calling newPrivate'->putLine if);
            
        if);
        (*  siftexteditor debug:  *)
        edenv.nextEditorId->id;
        (* very detailed siftexteditor debug: *)
        false->switch[1];
        (* textediting: *)
        false->switch[2];
        (* debug slots: *)
        false->switch[3];
        (* debug slots (very detailed): *)
        false->switch[4];
        (* touched and event trace: *)
        false->switch[5];
        (* history trace: *)
        false->switch[6];
        (* updateeditmenu trace: *)
        edenv.switch[7]->switch[7];
        (* object pool trace: *)
        false->switch[8];
        (* comments: *)
        false->switch[10];
        (* pp trace: *)
        false->switch[11];
        (* charwidth beregning: *)
        false->switch[12];
        (* freja communication: *)
        (* start trace: *)
        false->switch[13];
        (* navigate trace: *)
        false->switch[14];
        (* parsing syncatno etc: *)
        false->switch[15];
        false->switch[16];
        (* group editing: *)
        false->edenv.trace[1];
        (* touched and event trace: *)
        false->edenv.trace[2];
        (* history trace: *)
        false->edenv.trace[3];
        (* propertyEditor: *)
        false->edenv.trace[7];
        (* external procedure interface trace: *)
        false->edenv.trace[8];
        (* trace global search replace: *)
        false->edenv.trace[9];
        (* undo trace: *)
        false->edenv.trace[11];
        (* navigate  trace: *)
        false->edenv.trace[12];
        false->edenv.trace[13];
        
     #)  

-- codeeditorGetFragmentgroup: DoPart --
do name[]->edenv.ymerCallBack.getFragmentGroup->fg[]  

-- codeeditorMachineType: DoPart --
do
   (if edenv.ymerCallBack[] <> none then
       edenv.ymerCallBack.machineType->t[]
   if)  

-- codeeditorFollowSemanticLink: Descriptor --
(#
   theNode,fatherNode,testNode: ^astInterface.ast;
   help,help2,msg: ^text;
   checked,doCheck: @boolean;
   myIndexToNode:
     (#
        inx: @integer;
        as: ^astInterface.ast;
        indexOutOfRange:< mps.astInterfaceException;
        noSuchSymbol:< mps.astInterfaceException;
        grammarGenRefArrayError:< mps.astInterfaceException;
        symbol,val: @integer;
        errorMsg:
          (# n: @integer; msg: ^text
          enter n
          do
             '*** Error in IndexToNode:'->msg[];
             '\nIndex='->msg.puttext;
             inx->msg.putint;
             '\nSymbol='->msg.puttext;
             symbol->msg.putint;
             '\nVal='->msg.puttext;
             val->msg.putint;
             msg.newline
          exit msg[]
          #);
        ff: ^astInterface.fragmentForm;
        
     enter (inx,ff[])
     do
        l:
        (if true
         // (0 < inx) and (inx <= ff.a.range) then
            ff.a[inx]->val->tos'%GetSignedBits[4,12]'->symbol;
            (if true
             // (0 < symbol) and (symbol <= ff.grammar.genRefArray.range) then
                (if ff.grammar.genRefArray[symbol]->as[]
                 // none then (* IndexToNode: genRefArray problem *)
                    errorMsg->grammarGenRefArrayError; leave l
                if)
             else
                (if symbol
                 // mps.prodNo.unExpanded then
                    &mps.UnExpanded[]->as[]
                 // mps.prodNo.optional then
                    &mps.Optional[]->as[]
                 // mps.prodNo.nameDecl then
                    &mps.NameDecl[]->as[]
                 // mps.prodNo.nameAppl then
                    &mps.NameAppl[]->as[]
                 // mps.prodNo.string then
                    &mps.String[]->as[]; 
                 // mps.prodNo.Const then
                    &mps.Const[]->as[]; 
                 // mps.prodNo.Comment then
                    &mps.Comment[]->as[]
                 // mps.prodNo.SlotDesc then
                    &mps.SlotDesc[]->as[]
                 else
                (* IndexToNode: no match for symbol! *)
                    none ->as[]; errorMsg->noSuchSymbol; leave l
                if)
            if);
            inx->as.index;
            ff[]->as.frag[]
         // (0 = inx) then (* Zero index is the same as a NONE ast *)
            none ->as[]
         else
        (* IndexToNode: index out of range *)
            none ->as[]; errorMsg->indexOutOfRange
        if)
     exit as[]
     #);
   myIsRealOpen:
     (# fg: ^astInterface.fragmentGroup; isOpen: @boolean
     enter fg[]
     do
        scanner: fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 (if (current.f[] <> none ) then
                     true->isOpen
                  else
                     false->isOpen; leave scanner
                 if)
             if)
          #)
     exit isOpen
     #);
   myGetGroup:
   (* Private: The inverse of GetIndex; If the group is not open then open it *)
     (#
        ff,f: ^astInterface.FragmentForm;
        Index: @integer;
        importException:< mps.AstInterfaceException;
        error: ^stream;
        openForm:
          (# fg: ^astInterface.fragmentGroup; name: ^Text; i: @Integer; 
          enter name[]
          do
             '-'->name.findAll (#  do inx->i #);
             thisOperation:
             ((1,i-1)->name.sub,screen[])
               ->mps.top.open
                 (#
                    myException:
                      (# msg,help: ^text
                      enter msg[]
                      do
                         ': '->help[];
                         (1,i-1)->name.sub->help.putText;
                         help[]->msg.append;
                         (none ,msg[],'Alert')->UI.alertUser;
                         none ->f[];
                         none ->mps.theCatcher[];
                         leave thisOperation
                      #);
                    readAccessError::< 
                      (#  do 'Read access error'->myException #);
                    fragmentNotExisting::< 
                      (#  do 'Non-existent fragment file'->myException #);
                    grammarNotFound::< 
                      (#  do 'Grammar not found for'->myException #);
                    badFormat::<  (#  do 'Bad AST format'->myException #);
                    WriteAccessOnLstFileError::< 
                      (# 
                      do
                         'Access error on .lst file'->myException;
                         true
                           ->continue
                           (*'Access error on .lst file'->myException*)
                      #);
                    writeAccessError::< 
                      (# 
                      do
                         'No write access'->myException;
                         true
                           ->continue
                           (*'Write access error'->myException
                            * *)
                      #);
                    startingParsing::< 
                      (# 
                      do
                         'Parsing '->putText;
                         (1,i-1)->name.sub->putText;
                         '...'->putLine;
                         'myStartingParsing'->putLine;
                         
                      #);
                    ParseErrors::< 
                      (# 
                      do (*none ->f[];*)
                         'myParseErrors'->putline; ; leave thisOperation
                      #);
                    DoubleFormDeclaration::< 
                      (# 
                      do
                         'Two forms are declared with the same name'
                           ->myException
                      #);
                    fatalParseError::< 
                      (# 
                      do (*none ->f[];*)
                         'errNo->myFatalParseError'->putLine;
                         leave thisOperation
                      #);
                    OtherFileError::< 
                      (# fil: @file
                      do
                         (1,i-1)->name.sub->fil.name;
                         (if fil.entry.exists
                          // true then
                             (if fil.entry.isDirectory
                              // true then 'Is a directory'->myException
                              else
                                 'Other file error'->myException
                             if)
                         if)
                      #);
                    
                 #)->fg[];
             (if fg[] <> none then
                 ((i+1,name.lgth)->name.sub,screen[])->fg.open->f[]
             if);
             
          #);
        
     enter (ff[],index)
     do
        thisOp:
          (# 
          do
             (if (ff[] = none ) then leave thisOp;  if);
             (if (ff.import.impL[] = none ) then leave thisOp;  if);
             (if (index > ff.import.impL.l.range) then leave thisOp;  if);
             (if (index = 0) then leave thisOp;  if);
             (if (ff.import.impL.l[index][] = none ) then leave thisOp;  if);
             (if (ff.import.impL.l[index].f[]->f[])
              // none then
                   (# t: ^text
                   do
                      (ff.father).fullName->mps.stripPathName->t[];
                      (if t[]
                       // none then
                          (ff.import.impL.l[index].n.copy,
                           mps.thePathHandler.currentDirectory)
                            ->mps.thePathHandler.convertFilePath->openForm;
                          (if f[] <> none then
                              f[]->ff.import.impL.l[index].f[]
                          if)
                       else
                          (ff.import.impL.l[index].n.copy,t[])
                            ->mps.thePathHandler.convertFilePath->openForm;
                          (if f[] <> none then
                              f[]->ff.import.impL.l[index].f[]
                          if)
                      if);
                      
                   #);
                 (if f[]
                  // none then
                       (# t: ^text
                       do
                          &text[]->t[];
                          'Import error!! '->t.putLine;
                          'There is something wrong with the file "'->t.putText;
                          (ff.father).diskFileName->t.putText;
                          '"\n. It refers to the fragment "'->t.putText;
                          ff.import.impL.l[index].n[]->t.putText;
                          '" which was not found \n\n.'->t.putText;
                          (*t[]->ImportException*)
                          
                       #)
                 if)
             if)
          #)
     exit f[]
     #);
   myValueToAst: (* Private *)
     (#
        val: @integer; a: ^astInterface.Ast; ff,f: ^astInterface.fragmentForm
     enter (val,ff[])
     do
        (if val
         // 0 then none ->a[]
         else
            (ff[],val->tos'%getShort[0]')->myGetGroup->f[];
            val->tos'%getShort[1]'->tos'%ShiftLeft[1]'->val;
            (if f[] <> none then
                (if not (f.father).isRealOpen then (f.father).realOpen if);
                (if val <> 0 then
                    (val,f[])
                      ->myindextoNode
                        (#
                           indexOutOfRange::< 
                             (# 
                             do 'indexOutOfRange'->putLine; true->continue; 
                             #);
                           noSuchSymbol::< 
                             (# 
                             do 'noSuchSymbol'->putLine; true->continue; 
                             #);
                           grammarGenRefArrayError::< 
                             (# 
                             do
                                'grammarGenRefArrayError'->putLine;
                                true->continue;
                                
                             #)
                        #)->a[]
                if)
            if)
        if)
     exit a[]
     #);
   myGetNodeAttribute:
     (# aplNode,val: ^astInterface.ast; attributNo: @integer
     enter (attributNo,aplNode[])
     do
        attributNo->aplNode.checkAttributNo;
        (aplNode.frag.a[aplNode.index+ (*offset.attribute*) 2+attributno-1],
         aplNode.frag[])->myValueToAst->val[]
     exit val[]
     #);
   myDclRef:
     (# aplNode,dclNode: ^astInterface.ast
     enter aplNode[]
     do ((1,aplNode[])->myGetNodeAttribute)->dclNode[]; 
     exit dclNode[]
     #);
   myVirtDcl:
     (# aplNode,dclNode: ^astInterface.ast; f: ^astInterface.ast
     enter aplNode[]
     do
        aplNode.father->f[];
        f.father->f[];
        ((1,f[])->myGetNodeAttribute)->dclNode[]
     exit dclNode[]
     #);
   checkNeeded:
     (# mess,help: ^text; status,doCheck: @boolean
     enter mess[]
     do
        mess.copy->help[];
        help.newline;
        help.newLine;
        'Check current?'->help.putText;
        (if (edenv[] <> none ) and (edenv.ymerCallback[] <> none ) then
            (none ,'Check current?',help[])
              ->UI.promptForBoolean (# ok::  (#  do true->doCheck #) #);
            
         else
            (none ,mess[],'Alert')->UI.alertUser; 
        if);
        (if doCheck then
            theNode.frag.father->edenv.ymerCallback.check->status
        if)
     exit status
     #);
   
do
   thisCommand:
     (# 
     do
        (if node.kind
         // mps.kinds.nameAppl // mps.kinds.nameDecl then
            node.father->theNode[]->testNode[]
         else
            node[]->theNode[]->testNode[]
        if);
        checkForSemanticErrors:
        (if testNode.hasSemanticError then
            (if testNode.semanticError <> 0 then
                testNode.semanticError->semanticErrorText->msg[];
                (testNode[],1,0,0)->setFocus;
                (none ,msg[],'Semantic error')->UI.alertUser;
                leave thisCommand
            if)
         else
            testNode.father->testNode[];
            (if testNode[] <> none then restart checkForSemanticErrors if)
        if);
        doCommand
          (# 
          do
             (if true (*checked*) then
                 (if theNode[] = none then
                     'followSemanticLink: theNode is none!!'->putLine
                  else
                     (if theNode.symbol
                      // betaGrammar.nameApl then
                           (#
                              theNameApl: ^betaGrammar.nameApl; node: ^mps.ast
                           do
                              theNode[]->theNameApl[];
                              theNameApl[]->myDclRef->node[];
                              (*theNameApl.dclRef->node[];*)
                              (if node[] <> none then
                                  (node.frag.root[],node[],separate)
                                    ->selectNodeInFormEditor
                               else
                                  'This fragment group must be (re)checked \nin order to (re)build the semantic links\n'
                                    ->checkNeeded->checked;
                                  (if checked then restart thisCommand if)
                              if)
                           #)
                      // betaGrammar.nameDcl then
                           (#
                              theNameDcl: ^betaGrammar.nameDcl;
                              f,node: ^astInterface.ast
                           do
                              theNode.father->f[];
                              (if f.symbol
                               // betaGrammar.names then
                                  f.father->f[];
                                  (if f.symbol
                                   // betaGrammar.bindingDecl
                                   // betaGrammar.finalDecl then
                                      theNode[]->theNameDcl[];
                                      theNameDcl[]->myVirtDcl->node[];
                                      (*theNameDcl.VirtDcl->node[];*)
                                      (if node[] <> none then
                                          (node.frag.root[],node[],separate)
                                            ->selectNodeInFormEditor
                                       else
                                          'This fragment group must be (re)checked \nin order to (re)build the semantic links\n'
                                            ->checkNeeded->checked;
                                          (if checked then
                                              restart thisCommand
                                          if)
                                      if)
                                      (* use findDescriptor instead?
                                       (if itemSelected
                                       // 1 then
                                       theNameApl.myDclRef->selectNode
                                       // 2 then
                                       theNameApl.descRef->selectNode
                                       // 3 then
                                       theNameApl.findDescriptor->selectNode
                                       if)*)
                                  if)
                              if);
                              (* use findDescriptor instead?
                               (if itemSelected
                               // 2 then
                               theNode[]->theNameDcl[];
                               theNameDcl.findDescriptor->selectNode
                               if);
                               *)
                              
                           #)
                     if)
                 if)
             if)
          #)
     #)
#)  

-- codeeditorSetIsReadOnly: DoPart --
do
(* if value is false this operation must only be called
 * if the groupfile is writeable
 *)
   value->isReadOnly;
   (if theSifTextEditor[] <> none then
       value->theSifTextEditor.isReadOnly
   if);
   subeditors.scan
     (#  do value->current.setIsReadOnly;  #)  

-- codeeditorOnReturnKey: DoPart --
do (if askInsertPermission then doInsertAfter if)  

-- codeeditorOnDeleteKey: DoPart --
do
   true->cs.undoPermit;
   (false (*doNotNotify*) ,true (*doNotCopyToClipBoard*) )->cut  

-- codeeditorKeyAllowed: DoPart --
do
   (if false (*isAFrejaEditor or (edenv.frejaInterface[] <> none )*) then
       (if isAsubeditor or isApropertyEditor then
           (if (ch = ascii.bs) or (ch = ascii.del) then
               false->value;
               (none ,
                'Backspace is currently disabled in subeditors and property editors in Freja',
                'Backspace')->UI.alertUser
           if)
       if)
   if)  

-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            (none ,ff.father,false)
              ->edenv.groupEditorList.findOrCreateGroupEditor->ge[]
         else
            (none ,ff.father)->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then
                fe[]->theSifViewer[]
             else
                none ->theSifViewer[]
            if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (none ,thesifViewer.frag.father,false)
          ->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        edenv.globalWriteProtection or not ge.isReadOnly
          ->theSifViewer.theSifTextEditor.isReadOnly;
        (if false then
            'setupFormEditor isReadOnly: '->putText;
            (if theSifViewer.theSifTextEditor.isReadOnly then
                'true'->putLine
             else
                'false'->putLine
            if);
            
        if)
     #)  

-- codeeditorCloseGroup: DoPart --
do
(*  shutdown: edenv.groupEditorList.scan
 (#
 do current.closeGroup->value; (if not value then leave shutdown if)
 #)  *)   

-- codeeditorAutoSave: DoPart --
do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- askOpenSubeditorPermission: DoPart --
do (cs.length = 1)->value  

-- codeeditorclose: DoPart --
do THIS(codeeditor)[]->edenv.ffHandler.unsubscribe  

-- codeeditorDoUndo: DoPart --
do undo; true->cs.redoPermit  

-- codeeditorDoRedo: DoPart --
do redo  

-- codeeditorDoCut: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.cut
    else
       (if (cs.subCommentInx1 = 0) and (cs.subCommentInx2 = 0) then
           true->cs.undoPermit;
           cut;
           cs->setFocus (* inorder to scroll into view *)
        else
           (none ,'To edit comments, textedit the enclosing structure','Cut')
             ->UI.alertUser
       if)
   if)  

-- codeeditorDoCopy: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.copy
    else
       copy; updateEditMenu
   if)  

-- codeeditorDoPaste: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.paste
    else
       true->cs.undoPermit; paste
   if)  

-- codeeditorDoClear: DoPart --
do true->cs.undoPermit; (false,true)->cut  

-- codeeditorAskUndoPermission: DoPart --
do cs.undoPermit and (undoElem[] <> none )->value  

-- codeeditorAskRedoPermission: DoPart --
do cs.redoPermit and (undoElem[] <> none )->value  

-- codeeditorAskPastePermission: DoPart --
do cs.pastePermit->value  

-- codeeditorExternalTextEdit: DoPart --
do textBefore[]->edenv.ymerCallBack.externalTextEdit->textAfter[]  

-- codeeditorAskBeforeTextediting: DoPart --
do
     (# exp: ^astInterface.expanded
     do
        (if isAFrejaEditor and (edenv.frejaInterface[] <> none ) then
            (if edenv.frejaInterface.askBeforeTextediting then
                (if cs.node[]->visibleInFreja then
                    (if cs.node.kind = mps.kinds.interior then
                        cs.node[]->exp[];
                        betaGram.ObjectDescriptor
                          ->exp.suffixWalkForProd (#  do true->value #)
                    if)
                if)
            if)
        if)
     #)  

-- codeeditorAskBeforeTexteditingMessage: DoPart --
do
   (if isAFrejaEditor and (edenv.frejaInterface[] <> none ) then
       edenv.frejaInterface.askBeforeTexteditingMessage->msg[];
       (if msg[] = none then
           'Textediting on this level may imply that parts of the diagrams have to be rebuilt, continue?'
             ->msg[]
       if)
   if)  

-- codeeditorEditLexem: DoPart --
do
     (#
        lexText: ^astInterface.lexemText;
        fatherNode: ^astInterface.expanded;
        help: ^text;
        found: @boolean;
        startInx: @integer
     do
        thisOp:
        (if (node[] <> none ) and (oldText[] <> none ) and (newText[] <> none )
         then
            (if node.kind
             // mps.kinds.nameDecl // mps.kinds.nameAppl // mps.kinds.string
             then
                (if node.kind
                 // mps.kinds.nameDecl // mps.kinds.nameAppl then
                    newText.scanAll
                      (# 
                      do
                         (if not
                         (((ch >= 'a') and (ch <= 'z')) or
                          ((ch >= 'A') and (ch <= 'Z')) or
                          ((ch >= '0') and (ch <= '9'))) then
                             'Not valid lexem'->putLine; leave thisOp
                         if)
                      #)
                if);
                node[]->lexText[];
                lexText.getText->help[];
                (if oldText[]->help.equalNCS then
                    true->cs.undoPermit;
                    (node.father,node.sonNo,cs,1,false)->makeUndoElem;
                    (cs.node[]->getSynCatNo,frag[])->ag.newAst->lexText[];
                    newText[]->lexText.putText;
                    node.father->fatherNode[];
                    (node.sonno,lexText[])->fatherNode.put;
                    makeASTreplacedEvent;
                    lexText[]->cs.node[];
                    cs->setFocus
                 else
                    l:
                    oldText[]
                      ->help.findTextAll
                        (# NCS:: trueObject
                        do true->found; inx->startInx; leave l
                        #);
                    (if found then
                        true->cs.undoPermit;
                        (node.father,node.sonNo,cs,1,false)->makeUndoElem;
                        (startInx,startInx+oldText.length-1)->help.delete;
                        (newText[],startInx)->help.insert;
                        (cs.node[]->getSynCatNo,frag[])->ag.newAst->lexText[];
                        help[]->lexText.putText;
                        node.father->fatherNode[];
                        (node.sonno,lexText[])->fatherNode.put;
                        makeASTreplacedEvent;
                        lexText[]->cs.node[];
                        cs->setFocus
                     else
                        oldText[]->putText;
                        ' not found in: '->putText;
                        newText[]->putLine;
                        
                    if)
                if)
            if)
        if)
     #)  

