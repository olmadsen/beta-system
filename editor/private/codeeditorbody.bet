ORIGIN '../codeeditor';
INCLUDE '~beta/mps/v5.1/findgrammar'
        '~beta/betaast/v5.1/donecheck'
        '~beta/betaast/v5.1/semanticerrortext'
        '~beta/sysutils/v1.5/objinterface'
        'editorenvbody';
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-96
 * All rights reserved.
 *)
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-96
 * All rights reserved.
 *)
-- codeeditorinit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file;
        inithere,foundEditorenv: @boolean;
        
     do
        (if switch[11] then '***** objectpool: '->putLine;  if);
        objectpool.scan
          (# ee: ##object; 
          do
             (if switch[11] then
                 'pattern : '->putText;
                 current[]->getPatternName->putLine;
                 current[]->getprototype->putInt;
                 newline;
                 'origin: '->putText;
                 current.origin[]->getPatternName->putLine;
                 current.origin[]->getprototype->putint;
                 newline;
                 'editorenv: '->putText;
                 'origin: '->putText;
                 editorenv##->ee##;
                 (@@ ee->tos'%AdrGetLong')+8->tos'%AdrGetLong'->putint;
                 newline;
                 ee##->getprototypeforStruc->putint;
                 newline;
                 (if current## = ee## then
                     'is equal to editorenv'->putline
                 if);
                 
             if);
             (if current## <= sifEditorenv## then
                 (if switch[11] then
                     'is equal to sifeditorenv'->putline; 
                 if);
                 current[]->edenv[];
                 true->foundEditorenv
             if)
          #);
        (if switch[11] then newline;  if);
        (if not foundEditorenv then
            &editorenv[]->edenv[];
            'init editorEnv from codeeditor'->putLine;
            true->inithere;
            (mps[],betagrammar[],UI[])->edenv.init;
            
        if);
        (if inithere then
            edenv.initiator[]->putLine;
            (if true (* switch[11] *) then
                'codeeditor'->edenv.initiator[]->putLine; 
            if);
            edenv.initiator[]->putLine
        if);
        &undoListDesc[]->undoList[];
        undoList.init;
        true->undoing;
        &expmenuprivate[]->expandmenuprivate[];
        &texteditingPrivate[]->TE[];
        &SlotPrivatePattern[]->slotPrivate[];
        (if up[] = none then &userPrivate[]->up[] if);
        userInit;
        THIS(codeeditor)[]->edenv.ffHandler.subscribe;
        frag.grammar.parser.haveBeenInitialized->parsingPossible;
        (if not parsingPossible then
            'No parser was initialized'->putline;
            (*'~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
             (if betaGrammar.grammarAst[]
             // none then
             'No grammarAst for '->screen.putText; grammarWithPath[]->screen.putLine; 
             else
             '-parser'->help[];
             mps.parserFileExtension->help.append;
             help[]->(grammarWithPath.copy).Append->mps.expandToFullPath->bobsFile.name;
             (if bobsFile.entry.exists then
             bobsFile.name->betaGrammar.parser.initialize;
             ('objectdescriptor','descriptor')
             ->betaGrammar.parser.privatePart.b.defineNonTAlias;
             ('attributedecl','attributes')->betaGrammar.parser.privatePart.b.defineNonTAlias;
             
             else
             'No parser available: '->screen.putText; bobsFile.name->screen.putLine; 
             if);
             
             if);
             true->parsingPossible;
             'Parser initialized now'->putLine;*)
            
        if);
        (if edenv.trace[2] then
            'Grammar: '->putText; ag.grammarIdentification->putLine
        if);
        (if editorRoot[] = none then
            newPrivate;
            editorRoot[]->theSifTexteditor.editorRoot[];
            (if edenv.trace[2] then 'calling newPrivate'->putLine if);
            
        if);
        edenv.nextEditorId->id;
        (* siftexteditor trace: *)
        false->switch[1];
        (*  siftexteditor debug:  *)
        false->switch[2];
        (* very detailed siftexteditor debug: *)
        false->switch[3];
        (* textediting: *)
        false->switch[4];
        (* debug slots: *)
        false->switch[5];
        (* debug slots (very detailed): *)
        false->switch[6];
        (* touched and event trace: *)
        edenv.switch[7]->switch[7];
        (* history trace: *)
        false->switch[8];
        (* updateeditmenu trace: *)
        false->switch[10];
        (* object pool trace: *)
        false->switch[11];
        (* comments: *)
        false->switch[12];
        (* pp trace: *)
        false->switch[13];
        (* charwidth beregning: *)
        false->switch[14];
        (* freja communication: *)
        false->edenv.trace[1];
        (* start trace: 
         false->edenv.trace[2];*)
        (* group editing: *)
        false->edenv.trace[3];
        (* touched and event trace:
         false->edenv.trace[7]; *)
        (* history trace: *)
        false->edenv.trace[8];
        (* propertyEditor: *)
        false->edenv.trace[9];
        (* external procedure interface trace: *)
        false->edenv.trace[11]
     #)  

-- codeeditorGetFragmentgroup: DoPart --
do name[]->edenv.ymerCallBack.getFragmentGroup->fg[]  

-- codeeditorMachineType: DoPart --
do
   (if edenv.ymerCallBack[] <> none then
       edenv.ymerCallBack.machineType->t[]
   if)  

-- codeeditorFollowSemanticLink: Descriptor --
(#
   theNode,fatherNode,testNode: ^astInterface.ast;
   help,help2,msg: ^text;
   checked,doCheck: @boolean;
   myIndexToNode:
     (#
        inx: @integer;
        as: ^astInterface.ast;
        indexOutOfRange:< mps.astInterfaceException;
        noSuchSymbol:< mps.astInterfaceException;
        grammarGenRefArrayError:< mps.astInterfaceException;
        symbol,val: @integer;
        errorMsg:
          (# n: @integer; msg: ^text
          enter n
          do
             '*** Error in IndexToNode:'->msg[];
             '\nIndex='->msg.puttext;
             inx->msg.putint;
             '\nSymbol='->msg.puttext;
             symbol->msg.putint;
             '\nVal='->msg.puttext;
             val->msg.putint;
             msg.newline
          exit msg[]
          #);
        ff: ^astInterface.fragmentForm;
        
     enter (inx,ff[])
     do
        l:
        (if true
         // (0 < inx) and (inx <= ff.a.range) then
            ff.a[inx]->val->tos'%GetSignedBits[4,12]'->symbol;
            (if true
             // (0 < symbol) and (symbol <= ff.grammar.genRefArray.range) then
                (if ff.grammar.genRefArray[symbol]->as[]
                 // none then (* IndexToNode: genRefArray problem *)
                    errorMsg->grammarGenRefArrayError; leave l
                if)
             else
                (if symbol
                 // mps.prodNo.unExpanded then
                    &mps.UnExpanded[]->as[]
                 // mps.prodNo.optional then
                    &mps.Optional[]->as[]
                 // mps.prodNo.nameDecl then
                    &mps.NameDecl[]->as[]
                 // mps.prodNo.nameAppl then
                    &mps.NameAppl[]->as[]
                 // mps.prodNo.string then
                    &mps.String[]->as[]; 
                 // mps.prodNo.Const then
                    &mps.Const[]->as[]; 
                 // mps.prodNo.Comment then
                    &mps.Comment[]->as[]
                 // mps.prodNo.SlotDesc then
                    &mps.SlotDesc[]->as[]
                 else
                (* IndexToNode: no match for symbol! *)
                    none ->as[]; errorMsg->noSuchSymbol; leave l
                if)
            if);
            inx->as.index;
            ff[]->as.frag[]
         // (0 = inx) then (* Zero index is the same as a NONE ast *)
            none ->as[]
         else
        (* IndexToNode: index out of range *)
            none ->as[]; errorMsg->indexOutOfRange
        if)
     exit as[]
     #);
   myIsRealOpen:
     (# fg: ^astInterface.fragmentGroup; isOpen: @boolean
     enter fg[]
     do
        scanner: fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 (if (current.f[] <> none ) then
                     true->isOpen
                  else
                     false->isOpen; leave scanner
                 if)
             if)
          #)
     exit isOpen
     #);
   myGetGroup:
   (* Private: The inverse of GetIndex; If the group is not open then open it *)
     (#
        ff,f: ^astInterface.FragmentForm;
        Index: @integer;
        importException:< mps.AstInterfaceException;
        error: ^stream;
        openForm:
          (# fg: ^astInterface.fragmentGroup; name: ^Text; i: @Integer; 
          enter name[]
          do
             '-'->name.findAll (#  do inx->i #);
             ((1,i-1)->name.sub,screen[])->mps.top.open->fg[];
             ((i+1,name.lgth)->name.sub,screen[])->fg.open->f[];
             
          #);
        
     enter (ff[],index)
     do
        thisOp:
          (# 
          do
             (if (ff[] = none ) then leave thisOp;  if);
             (if (ff.import.impL[] = none ) then leave thisOp;  if);
             (if (index > ff.import.impL.l.range) then leave thisOp;  if);
             (if (index = 0) then leave thisOp;  if);
             (if (ff.import.impL.l[index][] = none ) then leave thisOp;  if);
             (if (ff.import.impL.l[index].f[]->f[])
              // none then
                   (# t: ^text
                   do
                      (ff.father).fullName->mps.stripPathName->t[];
                      (if t[]
                       // none then
                          (ff.import.impL.l[index].n.copy,
                           mps.thePathHandler.currentDirectory)
                            ->mps.thePathHandler.convertFilePath->openForm;
                          f[]->ff.import.impL.l[index].f[]
                       else
                          (ff.import.impL.l[index].n.copy,t[])
                            ->mps.thePathHandler.convertFilePath->openForm;
                          f[]->ff.import.impL.l[index].f[]
                      if);
                      
                   #);
                 (if f[]
                  // none then
                       (# t: ^text
                       do
                          &text[]->t[];
                          'Import error!! '->t.putLine;
                          'There is something wrong with the file "'->t.putText;
                          (ff.father).diskFileName->t.putText;
                          '"\n. It refers to the fragment "'->t.putText;
                          ff.import.impL.l[index].n[]->t.putText;
                          '" which was not found \n\n.'->t.putText;
                          t[]->ImportException
                       #)
                 if)
             if)
          #)
     exit f[]
     #);
   myValueToAst: (* Private *)
     (#
        val: @integer; a: ^astInterface.Ast; ff,f: ^astInterface.fragmentForm
     enter (val,ff[])
     do
        (if val
         // 0 then none ->a[]
         else
            (ff[],val->tos'%getShort[0]')->myGetGroup->f[];
            val->tos'%getShort[1]'->tos'%ShiftLeft[1]'->val;
            (*  (f.father).fullName->putText;
             '-'->put;
             f.name->putText;
             ' '->put;
             val->putInt;
             newLine;
             * *)
            (if f[] <> none then
                (if not (f.father->myisRealOpen) then
                (* isRealOpen does not work!!! *)
                (* 'not real open'->putLine; *)
                    (f.father).realOpen
                 else
                (*'is real open'->putLine; *)
                    (f.father).realOpen
                if);
                (if val <> 0 then
                    (val,f[])
                      ->myindextoNode
                        (#
                           indexOutOfRange::< 
                             (# 
                             do 'indexOutOfRange'->putLine; true->continue; 
                             #);
                           noSuchSymbol::< 
                             (# 
                             do 'noSuchSymbol'->putLine; true->continue; 
                             #);
                           grammarGenRefArrayError::< 
                             (# 
                             do
                                'grammarGenRefArrayError'->putLine;
                                true->continue;
                                
                             #)
                        #)->a[]
                if)
            if)
        if)
     exit a[]
     #);
   myGetNodeAttribute:
     (# aplNode,val: ^astInterface.ast; attributNo: @integer
     enter (attributNo,aplNode[])
     do
        attributNo->aplNode.checkAttributNo;
        (aplNode.frag.a[aplNode.index+ (*offset.attribute*) 2+attributno-1],
         aplNode.frag[])->myValueToAst->val[]
     exit val[]
     #);
   myDclRef:
     (# aplNode,dclNode: ^astInterface.ast
     enter aplNode[]
     do ((1,aplNode[])->myGetNodeAttribute)->dclNode[]; 
     exit dclNode[]
     #);
   myVirtDcl:
     (# aplNode,dclNode: ^astInterface.ast; f: ^astInterface.ast
     enter aplNode[]
     do
        aplNode.father->f[];
        f.father->f[];
        ((1,f[])->myGetNodeAttribute)->dclNode[]
     exit dclNode[]
     #);
   checkNeeded:
     (# mess,help: ^text; status,doCheck: @boolean
     enter mess[]
     do
        mess.copy->help[];
        help.newline;
        help.newLine;
        'Check current?'->help.putText;
        (if (edenv[] <> none ) and (edenv.ymerCallback[] <> none ) then
            (none ,'Check current?',help[])
              ->UI.promptForBoolean (# ok::  (#  do true->doCheck #) #);
            
         else
            (none ,mess[],'Alert')->UI.alertUser; 
        if);
        (if doCheck then
            theNode.frag.father->edenv.ymerCallback.check->status
        if)
     exit status
     #);
   
do
   thisCommand:
     (# 
     do
        (if node.kind
         // mps.kinds.nameAppl // mps.kinds.nameDecl then
            node.father->theNode[]->testNode[]
         else
            node[]->theNode[]->testNode[]
        if);
        checkForSemanticErrors:
        (if testNode.hasSemanticError then
            (if testNode.semanticError <> 0 then
                testNode.semanticError->semanticErrorText->msg[];
                (testNode[],1,0,0)->setFocus;
                (none ,msg[],'Semantic error')->UI.alertUser;
                leave thisCommand
            if)
         else
            testNode.father->testNode[];
            (if testNode[] <> none then restart checkForSemanticErrors if)
        if);
        doCommand
          (# 
          do
             (if true (*checked*) then
                 (if theNode[] = none then
                     'followSemanticLink: theNode is none!!'->putLine
                  else
                     (if theNode.symbol
                      // betaGrammar.nameApl then
                           (#
                              theNameApl: ^betaGrammar.nameApl; node: ^mps.ast
                           do
                              theNode[]->theNameApl[];
                              theNameApl[]->myDclRef->node[];
                              (if node[] <> none then
                                  (node.frag.root[],node[],separate)
                                    ->selectNodeInFormEditor
                               else
                                  'This fragment group must be (re)checked \nin order to (re)build the semantic links\n'
                                    ->checkNeeded->checked;
                                  (if checked then restart thisCommand if)
                              if)
                           #)
                      // betaGrammar.nameDcl then
                           (#
                              theNameDcl: ^betaGrammar.nameDcl;
                              f,node: ^astInterface.ast
                           do
                              theNode.father->f[];
                              (if f.symbol
                               // betaGrammar.names then
                                  f.father->f[];
                                  (if f.symbol
                                   // betaGrammar.bindingDecl
                                   // betaGrammar.finalDecl then
                                      theNode[]->theNameDcl[];
                                      theNameDcl[]->myVirtDcl->node[];
                                      (if node[] <> none then
                                          (node.frag.root[],node[],separate)
                                            ->selectNodeInFormEditor
                                       else
                                          'This fragment group must be (re)checked \nin order to (re)build the semantic links\n'
                                            ->checkNeeded->checked;
                                          (if checked then
                                              restart thisCommand
                                          if)
                                      if)
                                      (* use findDescriptor instead? 
                                       (if itemSelected
                                       // 1 then
                                       theNameApl.myDclRef->selectNode
                                       // 2 then
                                       theNameApl.descRef->selectNode
                                       // 3 then
                                       theNameApl.findDescriptor->selectNode
                                       if)*)
                                  if)
                              if);
                              (* use findDescriptor instead? 
                               (if itemSelected
                               // 2 then
                               theNode[]->theNameDcl[];
                               theNameDcl.findDescriptor->selectNode
                               if);
                               *)
                              
                           #)
                     if)
                 if)
             if)
          #)
     #)
#)  

-- codeeditorSetIsReadOnly: DoPart --
do
(* if value is false this operation must only be called 
 * if the groupfile is writeable
 *)
   value->isReadOnly;
   (if theSifTextEditor[] <> none then
       value->theSifTextEditor.isReadOnly
   if);
   subeditors.scan
     (#  do value->current.setIsReadOnly;  #)  

-- codeeditorOnReturnKey: DoPart --
do (if askInsertPermission then doInsertAfter if)  

-- codeeditorCheckFormEditorExistence: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (if createIfNotExists then
            (none ,ff.father,false)
              ->edenv.groupEditorList.findOrCreateGroupEditor->ge[]
         else
            (none ,ff.father)->edenv.groupEditorList.findGroupEditor->ge[]
        if);
        (if ge[] <> none then
            ff[]->ge.formeditorList.findEditor->fe[];
            (if fe[] <> none then
                fe[]->theSifViewer[]
             else
                none ->theSifViewer[]
            if)
        if)
     #)  

-- codeeditorSetupFormEditor: DoPart --
do
     (# ge: ^editorenv.groupEditor; fe: ^codeEditor
     do
        (none ,thesifViewer.frag.father,false)
          ->edenv.groupEditorList.findOrCreateGroupEditor->ge[];
        theSifViewer[]->ge.formeditorList.append;
        theSifViewer[]->fe[];
        ge[]->fe.thisGroupEditor[];
        edenv.globalWriteProtection or not ge.isReadOnly
          ->theSifViewer.theSifTextEditor.isReadOnly;
        (if false then
            'setupFormEditor isReadOnly: '->putText;
            (if theSifViewer.theSifTextEditor.isReadOnly then
                'true'->putLine
             else
                'false'->putLine
            if);
            
        if)
     #)  

-- codeeditorCloseGroup: DoPart --
do
(*  shutdown: edenv.groupEditorList.scan
 (# 
 do current.closeGroup->value; (if not value then leave shutdown if)
 #)  *)   

-- codeeditorAutoSave: DoPart --
do ('#',frag.father)->edenv.editorenvPrivate.extendedSaveBackup  

-- codeeditorCloseForm: DoPart --
do
   edenv.history.h.scan
     (# 
     do (if current.frag[] = frag[] then current[]->edenv.history.remove if)
     #)  

-- askOpenSubeditorPermission: DoPart --
do (cs.length = 1)->value  

-- codeeditorclose: DoPart --
do THIS(codeeditor)[]->edenv.ffHandler.unsubscribe  

-- codeeditorDoUndo: DoPart --
do undo  

-- codeeditorDoCut: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.cut
    else
       true->cs.undoPermit; cut
   if)  

-- codeeditorDoCopy: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.copy
    else
       copy; updateEditMenu
   if)  

-- codeeditorDoPaste: DoPart --
do
   (if textEditMode then
       theSifTextEditor.contents.paste
    else
       true->cs.undoPermit; paste
   if)  

-- codeeditorDoClear: DoPart --
do true->cs.undoPermit; (false,true)->cut  

-- codeeditorAskUndoPermission: DoPart --
do cs.undoPermit and (undoElem[] <> none )->value  

-- codeeditorAskPastePermission: DoPart --
do cs.pastePermit->value  

-- codeeditorExternalTextEdit: DoPart --
do textBefore[]->edenv.ymerCallBack.externalTextEdit->textAfter[]  

