ORIGIN '~beta/editor/betaTextField';
-- betaTextFieldLib: Attributes --
CheckDopart: regexp.reg_match (#  do 1->regNumber #);
RemovePatternDef: regexp.reg_replace (#  do 2->regNumber #);
CheckEndsWithSemicolon: regexp.reg_match (#  do 3->regNumber #);
CheckBeginWithConstruct: regexp.reg_match (#  do 4->regNumber #);
RemoveHarmless: regexp.reg_replace (#  do 5->regNumber #);
CheckPatternNoDef: regexp.reg_match (#  do 6->regNumber #);
CheckArrow: regexp.reg_match (#  do 7->regNumber #);
CheckCommentBegin: regexp.reg_replace (#  do 8->regNumber #);
CheckCommentEnd: regexp.reg_match (#  do 9->regNumber #);
CheckWhite: regexp.reg_match (#  do 10->regNumber #);
RemoveOnelineComment: regexp.reg_replace (#  do 11->regNumber #);
  

-- Init: DoPart --
do
   11->regexp.setNumberOfRegexps;
   4->regexp.setNumberOfBlocks;
   true->regexp.nonCaseSensitive;
   '(^do\\b|^enter\\b|^exit\\b|^else\\b|^//)'
     ->regexp.init_reg (#  do 1->regNumber #);
   '^[a-zA-Z0-9_, ]+:[:|<]?[:<]? *[@|^|\\|]?[\\|]? *[a-zA-Z0-9._<@ :>]* *'
     ->regexp.init_reg (#  do 2->regNumber #);
   '; *$'->regexp.init_reg (#  do 3->regNumber #);
   '^ *\\([#|if|for|\\*#].*'->regexp.init_reg (#  do 4->regNumber #);
   '(.*)(\\(' '#.*?#\\)|\\(' 'if\\b.*?\\bif\\)|\\(' 'for\\b.*?\\bfor\\)|\\(\\*.*?\\*\\))'
     ->regexp.init_reg
       (#
          specialPcre::< 
            (#
               editorReplace:: 
                 (#
                    rep:: 
                      (# 
                      do
                         sub2->value[];
                         0->value.pos;
                         '{'->value.put;
                         value.length-1->value.pos;
                         '}'->value.put;
                         sub1->value.prepend
                      #)
                 #)
            #)
       do 5->regNumber
       #);
   '^ *\\(' '#.*#\\)'->regexp.init_reg (#  do 6->regNumber #);
   '^ *->'->regexp.init_reg (#  do 7->regNumber #);
   '(.*)(\\(\\*)(.*)'
     ->regexp.init_reg
       (#
          specialPcre::< 
            (#
               editorReplace:: 
                 (#
                    rep:: 
                      (# 
                      do
                         sub1->value[];
                         sub2->value.append;
                         value.length->commentPos;
                         sub3->value.append
                      #)
                 #)
            #)
       do 8->regNumber
       #);
   '^ *\\*\\)'->regexp.init_reg (#  do 9->regNumber #);
   '^ *$'->regexp.init_reg (#  do 10->regNumber #);
   '(.*)(\\(\\*.*?\\*\\))'
     ->regexp.init_reg
       (#
          specialPcre::< 
            (#
               editorReplace:: 
                 (#
                    rep:: 
                      (# 
                      do
                         sub2->value[];
                         0->value.pos;
                         '{'->value.put;
                         value.length-1->value.pos;
                         '}'->value.put;
                         sub1->value.prepend
                      #)
                 #)
            #)
       do 11->regNumber
       #);
   ('(#','#)',3)->regexp.init_block (#  do 1->blockNumber #);
   ('(*','*)',3)->regexp.init_block (#  do 2->blockNumber #);
   ('(if','if)',4)->regexp.init_block (#  do 3->blockNumber #);
   ('(for','for)',5)->regexp.init_block (#  do 4->blockNumber #)  

-- Handle_comment: DoPart --
do
   (# t2,dummy: ^text; int: @integer; b,beginComment,rigidFound: @boolean
   do
      t[]->eat_indent->(int,t[]);
      (if ((t.length > 0) and (t.T[1] = '*'))->comment then
          (if (not ((t.length > 1) and (t.T[2] = ')'))) then
              ' '->t.T[1]; t[]->eat_indent->(int,t[]); false->starNeeded
           else
              true->commentJustEnded
          if)
      if);
      (if t[]->CheckCommentBegin then
          commentPos->rigid; true->rigidFound; 
      if);
      (if not (first_line) then
          previous_line;
          current_line->previous[]->eat_indent->(int,t2[]);
          (if t2.copy->next_line_in_comment then
              (if not (comment) then true->starNeeded->comment if);
              (if t2.copy->begins_with_star then
                  ' '->t2.T[1];
                  int->rigid;
                  true->rigidFound;
                  t2[]->eat_indent->(int,t2[]);
                  int-1->int
              if);
              t2[]->remove_harmless;
              t.copy->dummy[];
              (dummy[],2 (* comment *) )->regexp.removeBlock
                ->(b,beginComment);
              (if b and beginComment then
                  int+dummy.length+1->rigid;
                  true->rigidFound;
                  (rigid+2-int,t2.length)->t2.sub->t2[];
                  t2[]->eat_indent->(int,t2[])
              if)
          if);
          (if comment and not (rigidFound) then
              previous[]->find_rigid->rigid; 
          if);
          next_line
      if)
   #)  
   
-- betaTextField_indent_line: DoPart --
do
     (# done: @boolean; dummy: @integer; previous: ^text
     do
        (if not (first_line) then
            (if (t.length > 0) and (t.T[1] = '*') then
                ' '->t.T[1];
                t[]->eat_indent->(dummy,t[]);
                dummy+indent_value->indent_value;
                1->offset;
                (if global.col > indent_value then
                    global.col-indent_value->offset
                if)
            if);
            current[]->Handle_comment->previous[];
            current[]->indent_current->(indent_value,done);
            (if not (done or first_line) then
                previous_line;
                (previous[]->indent_previous)+indent_value->indent_value;
                next_line
            if);
            (if comment then
                (if starNeeded and not (commentJustEnded) then
                    beginning_of_line; '*'->insertText
                if);
                (rigid,indent_value)->indent_comment;
                (if commentJustEnded then
                    rigid->indent_value
                 else
                    indent_value+rigid+1->indent_value
                if)
             else
                indent_value->indent_by_int; 
            if);
            false->comment->starNeeded->commentJustEnded
        if)
     #)  

-- indent_current: DoPart --
do
     (# first,second: @rowCol; dummy: @integer; t,t2: ^text
     do
        current[]->strip_comment->eat_indent->(dummy,t[]);
        (if t[]->CheckDopart then
            indent_value-3->indent_value;
            (if not (first_line) then
                previous_line;
                current_line->t2[];
                (if (t2[]->RemovePatternDef) and not
                (t2[]->CheckEndsWithSemicolon) then
                    indent_value-2->indent_value
                if);
                next_line
            if)
        if);
        (if t[]->CheckArrow then indent_value+2->indent_value if);
        l:
        (if t[]->regexp.lastBlockEnd
         // 1 then
            t[]->patternBlock->(first,second,done);
            (if done then first.col->indent_value if)
         // 2 then
            t[]->commentBlock->(first,second,done);
            (if done then first.col->indent_value if);
            (if not (''->t.equal) then
                (0,false)->(indent_value,done); restart l
            if)
         // 3 then
            t[]->ifBlock->(first,second,done);
            (if done then first.col->indent_value if)
         // 4 then
            t[]->forBlock->(first,second,done);
            (if done then first.col->indent_value if)
        if)
     #)  

-- indent_previous: DoPart --
do
     (# first,second: @rowCol; b,match: @boolean; t,dummy: ^text
     do
        current.copy->strip_comment->eat_indent->(indent_value,t[]);
        (if (not (first_line)) and (t[]->CheckPatternNoDef) then
            previous_line;
            (if current_line->strip_comment->check_pattern_def then
                indent_value-2->indent_value
            if);
            next_line
        if);
        (if t[]->CheckArrow then indent_value-2->indent_value if);
        (if t[]->check_pattern_def->match then
            indent_value+2->indent_value
        if);
        t[]->remove_harmless;
        (t[]->regexp.LastBlockBegin)->(match,first.col,dummy[]);
        global.row->first.row;
        first.col+indent_value->indent_value;
        (if not (match) and (t[]->CheckDopart) then
            indent_value+3->indent_value
        if);
        (if t[]->regexp.lastBlockEnd
         // 1 then
            t[]->patternBlock->(first,second,b); second.col->indent_value
         // 2 then
            t[]->commentBlock->(first,second,b); second.col->indent_value
         // 3 then
            t[]->ifBlock->(first,second,b); second.col->indent_value
         // 4 then
            t[]->forBlock->(first,second,b); second.col->indent_value
        if)
     #)  

-- blockHelper: DoPart --
do
     (# b,done: @boolean; mem,tmp: @integer; dummy: ^text
     do

        (if not (first_line) then patternCheck->(block,done) if);
        t[]->strip_comment->t[];
        t.copy->regexp.lastBlockBegin->(b,tmp,dummy[]);
        (if b then
            false->done;
            t[]->eat_indent->(mem,t[]);
            (dummy.length+1,t.length)->t.sub->t[];
            t[]->eat_indent->(tmp,t[]);
            dummy.length+tmp+mem->mem
        if);
        (if not (done) then
            mem->block.col;
            (if (not (first_line)) and
                (current_line->strip_comment->CheckBeginWithConstruct) then
                previous_line;
                (if not (current_line->strip_comment->check_pattern_def) then
                    next_line
                if)
            if);
            (if not (b) then
                current_line->strip_comment->eat_indent->(block.col,t[])
            if);
            (if t[]->CheckDopart then block.col+3->block.col if)
        if);
        global.row->block.row
     #)  

-- patternCheck: DoPart --
do
     (# b: @boolean; t,copy,dummy: ^text
     do
        previous_line;
        current_line->strip_comment->t[];
        t.copy->copy[];
        t[]->regexp.lastBlockBegin->(b,block.col,dummy[]);
        (if b and ('#' ')'->dummy.equal) then
            (t.length+3,copy.length)->copy.sub->copy[];
            (if copy[]->check_pattern_def then
                copy[]->eat_indent->(block.col,copy[]);
                t.length+2+block.col->block.col;
                true->done
            if)
        if);
        next_line;
        global.row->block.row
     #)  

-- patternBlock: DoPart --
do t[]->blockHelper->block; (if comment then block.col-rigid-1->block.col if)  

-- commentBlock: DoPart --
do
     (# done,b: @boolean; dummy: ^text
     do
        (if not (first_line) then patternCheck->(block,done) if);
        (if not (done) then
            t[]->strip_comment->regexp.lastBlockBegin->(b,block.col,dummy[]);
            global.row->block.row;
            (if (not (first_line)) and
            (current_line->strip_comment->CheckBeginWithConstruct) then
                previous_line;
                (if not (current_line->strip_comment->check_pattern_def) then
                    next_line
                if)
            if);
            (if not (b) then
                current_line->eat_indent->(block.col,t[]); global.row->block.row
            if)
        if)
     #)  

-- getRigid: DoPart --
do t.length+2->result   

-- ifBlock: DoPart --
do t[]->blockHelper->begin; (if comment then block.col-rigid-1->block.col if)  

-- forBlock: DoPart --
do t[]->blockHelper->begin; (if comment then block.col-rigid-1->block.col if)  

-- check_pattern_def: DoPart --
do
     (# dummy: ^text; open: @boolean; block: @integer
     do
        t.copy->dummy[];
        false->b;
        (if dummy[]->RemovePatternDef then
            (if not (dummy[]->CheckEndsWithSemicolon) then
                dummy[]->regexp.lastBlockBegin->(open,block,dummy[]);
                not (open)->b
            if)
        if)
     #)  

-- remove_harmless: DoPart --
do
   t[]->shadow_string_constants->t[];
   loop: cycle
     (#  do (if not (t[]->RemoveHarmless) then leave loop if) #)  

-- betaTextField_onBeforeChange: DoPart --
do
     (# tmp,t: ^text; ch: @char
     do
        (if texteditmode then
            theText->t[];
            (if (t[] <> none ) and (t.length > 0) then
                t.T[1]->ch;
                (if ch
                 // '{' then
                    (if not (controlQPressed) then
                        regexp.blockreg[1].begin.copy->tmp[];
                        ' '->tmp.append;
                        tmp[]->insert;
                        (* NOTE: it is important that it is 
                         * insert and not insertText that is being 
                         * called. GlobalRow and globalCol doesn't 
                         * have the right values
                         *)
                        false->allow
                    if);
                    false->controlQPressed
                 // '}' then
                    (if not (controlQPressed) then
                        close_construct->insertText;
                        frozen_indent_line;
                        false->allow
                    if);
                    false->controlQPressed
                if)
             else
                false->controlQPressed; INNER onBeforeChange
            if)
         else
            INNER onBeforeChange
        if)
     #)  

-- strip_comment: DoPart --
do
     (# t2: ^text; indent: @integer
     do
        l: (if t[]->RemoveOnelineComment then restart l if);
        (if t[]->CheckCommentBegin then
            (commentPos+1,t.length)->t.sub->t[]; 
         else
            t.copy->eat_indent->(indent,t2[]);
            (if (t2.length > 0) and (t2.T[1] = '*') and not
            ((t2.length > 1) and (t2.T[2] = ')')) then
                (2,t2.length)->t2.sub->t[]; 
            if)
        if)
     #)  

-- close_construct: DoPart --
do
     (# t: ^text; b: @boolean; i,pat,com,if_,for_: @integer; start: @rowCol
     do
        selection.start->posToRowCol->start->global;
        beginning_of_line;
        (global,start)->getSelection->t[];
        t[]->remove_harmless;
        t[]->regexp.lastBlockBegin->(b,i,endBlock[]);
        (if not (b) then
            toploop: cycle
              (# 
              do
                 loop: cycle
                   (# 
                   do
                      (if t[]->regexp.lastBlockEnd
                       // 1 then
                          pat+1->pat; 
                       // 2 then
                          com+1->com; 
                       // 3 then
                          if_+1->if_; 
                       // 4 then
                          for_+1->for_; 
                       else
                          leave loop; 
                      if)
                   #);
                 (if not (first_line) then
                     previous_line; 
                  else
                     ''->endBlock[]; leave toploop; 
                 if);
                 current_line->t[];
                 t[]->remove_harmless;
                 loop: cycle
                   (# 
                   do
                      t[]->regexp.lastBlockBegin->(b,i,endBlock[]);
                      (if b then
                          (if endblock[]->regexp.blockreg[1].end.equalNCS then
                              (if pat = 0 then
                                  leave toploop
                               else
                                  pat-1->pat
                              if)
                          if);
                          (if endblock[]->regexp.blockreg[2].end.equalNCS then
                              (if com = 0 then
                                  leave toploop
                               else
                                  com-1->com
                              if)
                          if);
                          (if endblock[]->regexp.blockreg[3].end.equalNCS then
                              (if if_ = 0 then
                                  leave toploop
                               else
                                  if_-1->if_
                              if)
                          if);
                          (if endblock[]->regexp.blockreg[4].end.equalNCS then
                              (if for_ = 0 then
                                  leave toploop
                               else
                                  for_-1->for_
                              if)
                          if);
                          
                       else
                          leave loop; 
                      if)
                   #)
              #)
        if);
        start->global
     #)  

-- comment_out_selection: DoPart --
do
     (#
        depth,pos,endpos: @integer;
        begin,end: @rowCol;
        insertNewline: @boolean;
        t: ^text
     do
        selection.start->pos->posToRowCol->begin;
        selection.end->endpos->posToRowCol->end;
        (if ((begin.row <> end.row) or (begin.col <> end.col)) then
            (begin,end)->make_harmless_comment;
            end.row-begin.row+1->depth;
            (if (depth <> 1) then
                end->global;
                end_of_line;
                (end,global)->getSelection->t[];
                (if t[]->checkWhite then
                    '\n'->insertText; (end.row+1,1)->end
                if)
            if);
            begin->global;
            (if (depth = 1) then
                regexp.blockreg[2].begin.copy->t[];
                ' '->t.append;
                t[]->insertText;
                (end.row,end.col+3)->global;
                ' '->t[];
                regexp.blockreg[2].end.copy->t.append;
                t[]->insertText
             else
                regexp.blockreg[2].begin.copy->t[];
                ' '->t.append;
                t[]->insertText;
                (for depth-2 repeat
                  next_line; beginning_of_line; '*'->insertText; 
                for);
                end->global;
                ' '->t[];
                regexp.blockreg[2].end.copy->t.append;
                t[]->insertText
            if);
            end->rowColToPos->endpos;
            (pos,endpos)->indentHandler
        if)
     #)  

-- remove_surrounding_comment: DoPart --
do
   (#
      depth,pos,endpos,indent: @integer;
      mem: @rowCol;
      t: ^text
   do
      comEnd.row-comBegin.row+1->depth;
      ((comEnd.row,comEnd.col-3),comEnd)->getSelection->t[];
      (if t.T[1] = ascii.sp then
          ((comEnd.row,comEnd.col-3),comEnd)->deleteText;
          comEnd.col-3->comEnd.col
       else
          ((comEnd.row,comEnd.col-2),comEnd)->deleteText;
          comEnd.col-2->comEnd.col
      if);
      (comBegin,(comBegin.row,comBegin.col+3))
        ->getSelection->t[];
      (if t.T[3] = ascii.sp then
          (comBegin,(comBegin.row,comBegin.col+3))
            ->deleteText;
          (if depth = 1 then comEnd.col-3->comEnd.col if)
       else
          (comBegin,(comBegin.row,comBegin.col+2))
            -> deleteText;
          (if depth = 1 then comEnd.col-2 -> comEnd.col if)
      if);
      (comBegin,comEnd)->make_real_comments;
      (if depth>1 then
          comBegin->global;
          next_line;
          beginning_of_line;
          (for depth-2 repeat
               current_line->t[];
               t[]->eat_indent->(mem.col,t[]);
               (if (t.length > 0) and (t.T[1] = '*') then
                   ((global.row,global.col+mem.col),
                   (global.row,global.col+mem.col+1))->deleteText
               if);
               next_line
          for);
          comEnd->global;
          current_line->eat_indent->(mem.col,t[]);
          (if (t.length > 0) and (t.T[1] = '*') then
              mem.col+1->global.col;
              (global,(global.row,global.col+1))->deleteText
          if);
          (if t[]->CheckWhite then
              beginning_of_line;
              global->mem;
              (if last_line then end_of_line else next_line if);
              (mem,global)->deleteText
          if);
          comBegin->rowColToPos->pos;
          global->rowColToPos->endpos;
          (pos,endpos)->indentHandler
      if);
      (pos,pos) -> selection
   #)
   
-- surrounding_comment: doPart --
do (# pos,mem,min,max: @integer;
      star,left,right,notFound: @boolean
   do
      selection.start -> pos -> mem;
      texteditingExtent -> (min,max);
      (if not(globalFresh) then contents->globalText[]; true -> globalFresh if);
      pos -> globalText.pos;
      scanForward: cycle
        (# 
        do
           (if globalText.T[pos]
            // '*' then 
               (if left then
                   true -> notFound;
                   leave ScanForward
               if);
               true -> star;
               false -> left
            // '(' then
               true -> left;
               false -> star;
            // ')' then
               (if star then 
                   pos -> posToRowCol -> endPos;
                   leave scanForward 
               if);
               false -> star -> left
            else 
               false -> star -> left;
           if);
           pos+1 -> pos;
           (if pos>max then true->notFound; leave scanForward if);
        #);
      (if notFound then
          (-1,-1) -> beginPos -> endPos
       else
          mem -> pos;
          scanBackward: cycle
            (# do          
               (if globalText.T[pos]
                // '*' then 
                   (if right then
                       (-1,-1) -> beginPos -> endPos;
                       leave scanBackward
                   if);
                   true -> star;
                   false -> right;
                // '(' then
                   (if star then
                       pos-1 -> posToRowCol -> beginPos;
                       leave scanBackward 
                   if);
                   false -> star -> right
                // ')' then
                   false -> star;
                   true -> right
                else
                   false -> star -> right
               if);
               pos-1 -> pos;
               (if pos<min then 
                   (-1,-1) -> beginPos -> endPos;
                   leave scanBackward
               if)
            #)
      if)
   #)
   
-- find_rigid: DoPart --
do
     (# dummy: @integer; firstblock,b: @boolean
     do
        t[]->eat_indent->(i,t[]);
        (if not ((t.length > 1) and (t.T[1] = '*')) then
            t[]->remove_harmless;
            (t[],2 (* comment *) )->regexp.RemoveBlock->(b,firstblock);
            (if b and firstblock then
                i+t.length+1->i; 
             else
                t[]->getRigid->((dummy,i),dummy); 
            if)
        if)
     #)  

-- make_harmless_comment: DoPart --
do
     (# depth,indent: @integer; t: ^text; left,star: @boolean
     do
        begin->global;
        end.row-begin.row+1->depth;
        (for i: depth repeat
          (if i
           // 1 then
              end_of_line;
              ((begin.row,begin.col+1),global)->getSelection->t[];
              begin.col->indent;
              
           // depth then
              beginning_of_line;
              (global,(end.row,end.col-1))->getSelection->t[];
              global.col->indent;
              
           else
              current_line->eat_indent->(indent,t[])
          if);
          (for j: t.length repeat
            (if t.T[j]
             // '(' then
                true->left; false->star
             // '*' then
                (if left then
                    indent+j-1->global.col;
                    (global,(global.row,global.col+1))->deleteText;
                    true->controlQPressed;
                    '{'->insertText
                if);
                true->star;
                false->left
             // ')' then
                (if star then
                    indent+j->global.col;
                    (global,(global.row,global.col+1))->deleteText;
                    true->controlQPressed;
                    '}'->insertText
                if);
                false->left->star
             else
                false->left->star
            if)
          for);
          next_line
        for)
     #)  

-- make_real_comments: DoPart --
do
     (# depth,indent: @integer; left,star: @boolean; t: ^text; 
     do
        begin->global;
        end.row-begin.row+1->depth;
        (for i: depth repeat
          (if i
           // 1 then
              end_of_line;
              ((begin.row,begin.col+1),global)->getSelection->t[];
              begin.col->indent
           // depth then
              beginning_of_line;
              (global,(end.row,end.col-1))->getSelection->t[];
              global.col->indent
           else
              current_line->eat_indent->(indent,t[])
          if);
          (for j: t.length repeat
            (if t.T[j]
             // '{' then
                true->left; false->star
             // '*' then
                (if left then
                    indent+j-1->global.col;
                    (global,(global.row,global.col+1))->deleteText;
                    '('->insertText
                if);
                true->star;
                false->left
             // '}' then
                (if star then
                    indent+j->global.col;
                    (global,(global.row,global.col+1))->deleteText;
                    ')'->insertText
                if);
                false->left->star
             else
                false->left->star
            if)
          for);
          next_line
        for)
     #)  

-- indent_comment: DoPart --
do
     (# i,mem,white: @integer; t: ^text; ch: @char
     do
        beginning_of_line;
        (if not (current_line->t[]->CheckCommentEnd) then
            rigid->indent_by_int;
            t[]->eat_indent->(white,t[]);
            ascii.sp->t.T[1];
            t[]->eat_indent->(white,t[]);
            white-1->white;
            (if (white > indent) and (indent >= 0) then
                global.col+rigid+1->global.col;
                (global,(global.row,global.col+white-indent))->deleteText
            if);
            (if white < indent then
                rigid+2->global.col; indent-white->get_whitespace->insertText
            if)
         else
            rigid->indent_by_int; 
        if)
     #)  

-- commentWhitespace: DoPart --
do
     (# white: @integer; tmp: ^text
     do (* commentPos er sat andetsteds *)
        beginning_of_line;
        ((global.row,global.col+commentPos),(global.row,global.col+t.length))
          ->getSelection->t[];
        t[]->eat_indent->(white,t[]);
        global.col+commentPos->global.col;
        (if white < 2 then 2-white->get_whitespace->insertText if);
        (if white > 2 then
            (global,(global.row,global.col+white-2))->deleteText
        if)
     #)  

-- next_line_in_comment: DoPart --
do
     (# b,firstBlock: @boolean; i: @integer; 
     do
        t[]->remove_harmless;
        t[]->eat_indent->(i,t[]);
        (t.length > 0) and (t.T[1] = '*') and not
        ((t.length > 1) and (t.T[2] = ')'))->result;
        (t.copy,2)->regexp.RemoveBlock->(b,firstBlock);
        (if b then firstBlock->result if)
     #)  

-- begins_with_star: DoPart --
do
     (# i: @integer
     do
        t.copy->eat_indent->(i,t[]);
        ((t.length > 0) and (t.T[1] = '*')) and not
        ((t.length > 1) and (t.T[2] = ')'))->result
     #)  

-- shadow_string_constants: DoPart --
do
     (# lastBackslash,inText: @boolean
     do
        false->lastBackslash->inText;
        (for i: t.length repeat
          (if t.T[i]
           // '\\' then
              true->lastBackslash; (if inText then ' '->t.T[i] if); 
           // '\'' then
              (if not (lastBackslash) then
                  not (inText)->inText; 
               else
                  (if inText then ' '->t.T[i] if); false->lastBackslash; 
              if)
           else
              (if inText then ' '->t.T[i] if); false->lastBackslash; 
          if)
        for)
     #)  

