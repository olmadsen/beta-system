ORIGIN '../codeeditor';
LIB_ITEM 'editorcodeeditor';
(*
 *  COPYRIGHT
 *      Copyright Mjolner Informatics, 1986-2000
 *      All rights reserved.
 *)
-- substituteBody: Descriptor --
(# fatherNode: ^astInterface.expanded; 
do
   trace
     (#  do 'substitute'->str[] #);
   (if (oldFragment.father = none ) then
       (none ,0,(oldFragment[],1,0,0),1,false)->makeUndoElem;
       newFragment[]->fragDotRoot;
       (*aNewFragmentEvent;*)
       makeAstReplacedEvent;
       (*removed 950524: fragmentTouched;
        thisGroupEditor.groupTouched;*)
       
    else
       oldFragment.father->fatherNode[];
       (fatherNode[],oldFragment.sonNo,(oldFragment[],1,0,0),1,false)
         ->makeUndoElem;
       (oldFragment.sonNo,newFragment[])->fatherNode.put;
       checkAutosave;
       (oldFragment[],newFragment[])->frag.notifyAstReplaced;
       
   if)
#)  

-- listSubstituteBody: Descriptor --
(#
   fatherNode: ^astInterface.list;
   startElement,noOfOldElements,noOfNewElements: @integer;
   elem: ^astInterface.ast;
   subComments: ^text;
   tempFragments: @mps.astList
do
   thisOperation:
     (# 
     do
        trace
          (#  do 'listSubstitute'->str[] #);
        f.node.father->fatherNode[];
        (if astView.pp.ppDebug then
            'dump of whole list before: '->putLine; fatherNode.dump; newline; 
        if);
        f.length->noOfOldElements;
        theList.noOfSons->noOfNewElements;
        f.node.sonNo->startElement;
        (if noOfNewElements > tempFragments.elm.range then
            (if false then
                'noOfSons: '->putText;
                noOfNewElements->putInt;
                newLine;
                'extending from: '->putText;
                tempFragments.elm.range->putInt;
                newLine
            if);
            noOfNewElements->tempFragments.elm.extend;
            (if false then
                'to: '->putText; tempFragments.elm.range->putInt; newLine
            if)
        if);
        (for i: noOfNewElements repeat
        (*i->theList.get->elem[];
         frag[]
         ->elem.copy
         (#
         ASToverflow:: 
         (# msg: ^text
         do
         'Paste: AST overflow, quit Mjolner and reparse '->msg[];
         (frag.father).name->msg.append;
         (none ,msg[],'ListSubstitute: AST overflow')
         ->UI.alertUser;
         msg[]->putLine;
         none ->mps.theCatcher[];
         leave thisOperation
         #)
         #)->tempFragments.elm[i][];*)
          i->theList.get->tempFragments.elm[i][]
        for);
        (if astView.pp.ppDebug then
            'StartElement: '->screen.putText;
            startElement->screen.putInt;
            screen.newline;
            'newElms: '->screen.putText;
            noOfNewElements->screen.putInt;
            screen.newline;
            'oldElms: '->screen.putText;
            noOfOldElements->screen.putInt;
            screen.newline;
            
        if);
        (fatherNode[],startElement,f,noOfNewElements,true)->makeUndoElem;
        (if astView.pp.ppDebug then
            '*** deleting old selection'->screen.putLine; 
        if);
        (for i: f.length repeat
          (if fatherNode.hasComment then
              (if (i <= f.length) then
                  ('',startElement)->fatherNode.setSubComments
              if);
              
          if);
          startElement->fatherNode.delete;
          
        for);
        (for i: noOfNewElements repeat
          (startElement+i-1,tempFragments.elm[i][])->fatherNode.insert; 
        for);
        (if astView.pp.ppDebug then
            'dump of parsed list: '->putLine;
            thelist.dump;
            newline;
            '*** inserting parsed list in old list'->screen.putLine;
            
        if);
        (for i: noOfNewElements repeat
          i->theList.getSubcomments->subcomments[];
          (if (subcomments.lgth <> 0) then
              (if astView.pp.ppDebug then
                  screen.newLine;
                  'listSub '->putText;
                  i->putint;
                  ' ('->Screen.putText;
                  (subcomments[],screen[])->mps.printComment;
                  ')'->Screen.put;
                  Screen.newLine;
                  
              if);
              (if (i = 1) and (startElement+i-1 > 1) then
                  (subcomments[],startElement+i-2)
                    ->fatherNode.insertSubComments;
                  
               else
                  (subcomments[],startElement+i-1)->fatherNode.setSubComments; 
              if);
              
          if);
          
        for);
        (if astView.pp.ppDebug then
            'dump of updated list: '->putLine; fatherNode.dump; newline; 
        if);
        checkAutosave;
        (fatherNode[],startElement,noOfOldElements,undoElem.fragments[],
         noOfNewElements)->frag.notifyListElementsReplaced;
        (startElement->fatherNode.get,noOfNewElements,0,0)->f;
        
     #)
#)  

-- parseTextBody: Descriptor --
(#
   synCatNo,syncatNo2: @mps.nonterminalSymbol;
   isList,badSynCatNos: @boolean;
   originalNode,topNode,node,keepRoot,parsingRoot: ^astInterface.ast;
   enclosingNode: ^astInterface.ast;
   rootNode,fatherNode: ^astInterface.expanded;
   prod: ^mg.prod;
   isListZero: @boolean
do
   trace
     (#  do 'parseText'->str[] #);
   f.node[]->originalNode[];
   f.node[]->parsingSynCatNo->(synCatNo,isList,node[],enclosingNode[]);
   (if isList then
       f.node[]->getSynCatNo->synCatNo2;
       (if not synCatNo2.isLexem then
           synCatNo2->Prodlist.get->prod[];
           (if prod.symbol // mg.listZero then true->isListZero if)
       if);
       (if (node.father <> none ) then
           node.father->fatherNode[];
           (if (f.node[]->fatherNode.equal) then
               fatherNode.noOfSons->f.length
           if)
       if);
       node[]->f.node[]
   if);
   fragDotRoot->keepRoot[];
   t.reset;
   doParse:
     (# 
     do
        (synCatNo,t[],screen[],frag[])
          ->ag.parser.doParse
            (#
               fatalParseError::< 
                 (# help: ^text
                 do
                    &text[]->help[];
                    (if errNo
                     // 0 then (* 'Parse error(s)' -> help.putLine;*) 
                     else
                        'Fatal parse error:'->help.putLine;
                        help.newLine;
                        (if errNo
                         // 1 then
                            'Parse stack overflow'->help.putLine
                         // 2 then
                            'End of file encountered during parsing'
                              ->help.putLine
                         // 9 then
                            'End of file encountered while reading a string'
                              ->help.putLine
                         // 10 then
                            'End of file encountered while reading a comment or a nonterminal'
                              ->help.putLine
                        if);
                        (none ,help[],'Parse error')->UI.alertUser
                    if);
                    none ->mps.theCatcher[];
                    false->parseOK;
                    leave doParse
                 #);
               ASToverflow:: 
                 (# msg: ^text
                 do
                    'Parsing: AST overflow in '->msg[];
                    (frag.father).name->msg.append;
                    '-'->msg.append;
                    frag.name->msg.append;
                    '\nMjolner is quitting, but the AST will be automatically garbage-collected'
                      ->msg.append;
                    (none ,msg[],'Parsing: AST overflow')->UI.alertUser;
                    msg[]->putLine;
                    none ->mps.theCatcher[];
                    false->parseOK;
                    THIS(ParseText).astOverflow;
                    leave doParse
                 #)
            #)->parseOk;
        
     #);
   (if parseOk then
       fragDotRoot->parsingRoot[];
       (*'parsingroot.syncatno: '->putText;
        parsingRoot[]->getSynCatNo->putInt;
        newLine;*)
       (if keepRoot[]->editorRoot.equal then (* is not a subeditor *)
           keepRoot[]->fragDotRoot
        else
           keepRoot[]->frag.root[]
       if);
       (if parsingRoot.kind = mps.kinds.unexpanded then
       (* just to avoid the prettyprinter do crash because of nonterminals with synCatNo=0 
        this is the case for listZero nonterminals that has been parsed *)
           ((parsingRoot[]->getSynCatNo) = 0)->badSynCatNos
        else
           (if parsingRoot.kind = mps.kinds.interior then
               parsingRoot[]->rootNode[];
               loop: rootNode.suffixWalk
                 (# 
                 do
                    (if (current[]->getSynCatNo) = 0 then
                        true->badSynCatNos; leave loop
                    if)
                 #)
           if)
       if);
       (if badSynCatNos then
           false->parseOK;
           (none ,'The text contains illegal nonterminals','Parse error')
             ->UI.alertUser
        else
           (if isList then
               (if isListZero then
                   (if (f.length = 1) (* selection length *) then
                       (if (parsingRoot.kind = mps.kinds.unexpanded) or
                       (f.node.kind = mps.kinds.unexpanded) then
                           (f.node[],parsingRoot[])->substitute;
                           parsingRoot[]->f.node[]
                        else
                           parsingRoot[]->rootNode[];
                           (if (rootNode.noOfSons = 1) then
                               1->rootNode.get->node[];
                               f.node[]->checkFatherNode->f.node[];
                               (f.node[],node[])->substitute;
                               node[]->f.node[]
                            else
                               (f,parsingRoot[])->listSubstitute->f
                           if)
                       if)
                    else
                       (if parsingRoot.kind = mps.kinds.unexpanded then
                           (f.node[],parsingRoot[])->substitute;
                           parsingRoot[]->f.node[]
                        else
                           (f,parsingRoot[])->listSubstitute->f
                       if)
                   if)
                else
                   (if (f.length = 1) (* selection length *) then
                       parsingRoot[]->rootNode[];
                       (if (rootNode.noOfSons = 1) then
                           1->rootNode.get->node[];
                           f.node[]->checkFatherNode->f.node[];
                           (f.node[],node[])->substitute;
                           node[]->f.node[]
                        else
                           (f,parsingRoot[])->listSubstitute->f
                       if)
                    else
                       (f,parsingRoot[])->listSubstitute->f
                   if)
               if)
            else
           (*(if recursive then
            f.node[]->checkFatherNode->f.node[];
            'not List recursive'->putLine;
            'f.node: '->putLine;
            f.node.dump;
            newLine;
            'parsingRoot: '->putLine;
            parsingRoot.dump;
            newLine;
            originalNode[]->checkFatherNode->topNode[];
            (if topNode.sonNo = 1 then
            (f.node[],parsingRoot[])->substitute
            else
            (f.node[],parsingRoot[])->recursiveSubstitute;
            'recursiveSubstitute done'->putLine
            if);
            parsingRoot[]->f.node[]
            else*)
               f.node[]->checkFatherNode->f.node[];
               (f.node[],parsingRoot[])->substitute;
               parsingRoot[]->f.node[] (*if)*)
           if)
       if)
    else
   (* was only  keepRoot[]->fragDotRoot; which caused problems in subeditors*)
       (if keepRoot[]->editorRoot.equal then (* is not a subeditor *)
           keepRoot[]->fragDotRoot
        else
           keepRoot[]->frag.root[]
       if)
   if);
   
#)  

