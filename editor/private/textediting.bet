ORIGIN '../codeeditor' (*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-2000
 *   All rights reserved.
 *)
;
INCLUDE '~beta/basiclib/numberio'
        '~beta/guienv/utils/navigationkeys';
LIB_ITEM 'editorcodeeditor';
(*~beta/guienv/styledtext'*)
-- texteditingPrivate: Descriptor --
(#
   markerlength: (# (* including the space *)  exit 3 #);
   markerBegin:
     (# (* must include a space as the "last" character *)  exit '[[ ' #);
   markerEnd:
     (# (* must include a space as the "first" character *)  exit ' ]]' #);
   selRow,selCol,endRow,endCol: @integer;
   editingLexems: @boolean;
   useExternalTextEditor: @boolean;
   updateList:
     (# listNode: ^astInterface.expanded; containsLastElement: @boolean
     enter (listNode[],containsLastElement)
     do (* (editorRoot[] ,- 1)->astView.pp.present;*)
        (if containsLastElement then
            (if listNode[]->editorRoot.equal then
                doReprettyprint
             else
                (if listNode.father <> none then
                    (listNode.father,listNode.father)->astView.pp.update
                 else
                    doReprettyprint
                if)
            if)
         else
            (listNode[],listNode[])->astView.pp.update
        if)
     #);
   teInfo: @
     (#
        lineS1,charS1,lineS2,charS2: @integer;
        posStartBefore,posEndBefore: @integer;
        oldnode: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        inList,isList: @boolean;
        listNode: ^astInterface.list;
        oldNoOfSons: @integer;
        sonNo: @integer;
        lastPosBefore: @integer;
        synCatNo: (* editAndParse: *) @mps.nonterminalSymbol;
        oldLength: @integer;
        textBefore: @text;
        textAfter: ^text;
        hadParseErrors: @boolean;
        parseError: @boolean;
        parseErrorText: @text
     #);
   IS: (* initial selection *) @
     (#
        cs: @mps.astFocus;
        lineS1,charS1,lineS2,charS2: @integer;
        start,end: @integer;
        ch: @char
     #);
   contractionSet: @set (# element:: mps.ast #);
   skipLeadingAndTrailingBlanks:
     (# t: ^text
     enter t[]
     do
        skipLeadingBlanks:
        (if (t.length > 0) and ((1->t.inxGet)->ascii.isSpace) then
            (1,1)->t.delete; restart skipLeadingBlanks
        if);
        skipTrailingBlanks:
        (if (t.length > 0) and ((t.length->t.inxGet)->ascii.isSpace) then
            (t.length,t.length)->t.delete; restart skipTrailingBlanks
        if)
     #);
   isComment: booleanValue
     (# t: ^text
     enter t[]
     do
        t[]->skipLeadingAndTrailingBlanks;
        (if t.length >= 4 then
            (((1->t.inxGet) = '(') and ((2->t.inxGet) = '*') and
             ((t.length-1->t.inxGet) = '*') and ((t.length->t.inxGet) = ')'))
              ->value
        if)
     #);
   enterEditLexemMode:
     (# pos1,pos2: @integer
     do
        (if (IS.ch = ' ') or (IS.ch = 0) then
            theSifTextEditor.contents.selection->(pos1,pos2);
            (pos1,pos1)->theSifTextEditor.contents.selection
        if);
        true->textEditMode;
        editLexemMode->editingMode;
        cs.node[]->teInfo.oldNode[];
        cs.node.father->teInfo.fatherNode[];
        (if (teInfo.fatherNode[] <> none ) then
        (* else a program with a lexem in the root!! *)
            cs.node.sonNo->teInfo.sonNo;
            theSifTextEditor.lastPosition->teInfo.lastPosBefore;
            cs->selectArea
              ->(teInfo.lineS1,teInfo.charS1,teInfo.lineS2,teInfo.charS2);
            (teInfo.lineS1,teInfo.charS1)->theSifTextEditor.LineChartoPos
              ->teInfo.posStartBefore;
            (teInfo.lineS2,teInfo.charS2)->theSifTextEditor.LineChartoPos
              ->teInfo.posEndBefore;
            teInfo.textBefore.clear;
            (teInfo.posStartBefore,teInfo.posEndBefore)
              ->theSifTextEditor.contents.scantext
                (#  do ch->teInfo.textBefore.put #);
            (if useExternalTextEditor then
                false->useExternalTextEditor;
                TEinfo.textBefore[]->externalTextEdit->TEinfo.TextAfter[];
                (if TEinfo.textBefore[]->TEinfo.textAfter.equal then
                    false->textEditMode; 'No changes'->putLine
                 else
                    (teInfo.posStartBefore,teInfo.posEndBefore)
                      ->theSifTextEditor.contents.selection;
                    theSifTextEditor.contents.delete;
                    (teInfo.posStartBefore,teInfo.posStartBefore)
                      ->theSifTextEditor.contents.selection;
                    TEinfo.textAfter[]->theSifTextEditor.contents.insert;
                    false->textEditMode;
                    (TEexit.exitMode,(none ,1,0,0))->TE.exitEditLexemMode
                if)
            if);
            
        if)
     #);
   exitEditLexemMode:
     (#
        exitKind: @integer;
        outLineS2,outCharS2: (* terrible names!!! *) @integer;
        posEndAfter: @integer;
        theLexemText,help: ^text;
        alexemText: ^astInterface.lexemText;
        newNode: ^astInterface.ast;
        synCatNo: @mps.nonterminalSymbol;
        unExp: ^astInterface.unexpanded;
        newCS: @mps.astFocus;
        OK,OKtoParse: @boolean;
        preceeding: @boolean;
        
     enter (exitKind,newCS)
     do
        parsingLexems:
          (#
             parseConst:
               (# theConst: ^astInterface.const; help: ^text; 
               enter theconst[]
               do
                  'no errors'->help[];
                  0->theLexemText.setPos;
                  theLexemText.getnumber
                    (#
                       syntaxError::< 
                         (# 
                         do
                            true->continue;
                            'getNumber: Syntax error - looking at: "'->help[];
                            peekCh->help.put;
                            '"'->help.put;
                            
                         #);
                       baseError::< 
                         (# 
                         do
                            true->continue;
                            'getNumber: Error in base - looking at: "'->help[];
                            base->help.put;
                            '"'->help.put
                         #);
                       valueError::< 
                         (# 
                         do
                            true->continue;
                            'getNumber: Illegal value type - looking at: "'
                              ->help[];
                            peekCh->help.put;
                            '"'->help.put
                         #);
                       integerValue::<  (#  do true->OK #);
                       basedValue::<  (#  do true->OK #);
                       realValue::<  (#  do true->OK #);
                       
                    #);
                  (if OK then
                      theLexemText[]->theConst.putText; 
                   else
                      true->textEditMode;
                      (none ,help[],'Alert')->UI.alertUser;
                      leave parsingLexems
                  if);
                  
               #);
             
          do
             teInfo.posEndBefore+theSifTexteditor.lastPosition-
             teInfo.lastPosBefore
               -> (* determine extent of edited text: *) posEndAfter;
             posEndAfter->theSifTextEditor.posToLineChar->(outLineS2,outCharS2);
             (if (outLineS2 <> 0) and (outCharS2 <> 0) then
                 (teInfo.oldNode[],outLineS2-teInfo.lineS2,outCharS2-
                  teInfo.charS2)
                   -> (* tell the pretty printer how to update the SAST *)
                     astView.pp.resized
              else
                 'exitEditLexemMode: posToLineChar returned (0,0)'->putLine
             if);
             (if exitKind
              // TEexit.escape then
                 (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update;
                 cs->astToSelection;
                 
              // TEexit.exitMode // TEexit.parseMode then
              (* normal exit 
               parse the edited text *)
                 &text[]->theLexemText[];
                 true->preceeding;
                 (teInfo.posStartBefore,posEndAfter)
                   ->theSifTextEditor.contents.scantext
                     (# 
                     do
                        (if ((ch->ascii.isSpace) and preceeding) then
                            
                         else
                            false->preceeding;
                            (if true
                             // (ch > ' ') // ch = ascii.sp
                             // ch = ascii.newLine then
                                ch->theLexemText.put
                            if);
                            
                        if);
                        
                     #);
                 (if theLexemText[]->teInfo.textBefore.equal then
                     'Textediting: No changes'->edenv.ymerCallback.infoView
                  else
                     (if theLexemText.length > 0 then
                         false->OKtoParse;
                         theLexemText.scanAll
                           (# (* avoid parsing nothing, just cut *) 
                           do
                              (if not (ch->ascii.isSpace) then
                                  true->OKtoParse
                              if)
                           #);
                         
                     if);
                     (if OKtoParse then
                         true->cs.undoPermit;
                         (teInfo.fatherNode[],teInfo.sonNo,cs,1,false)
                           ->makeUndoElem;
                         (if cs.node.kind
                          // mps.kinds.unexpanded then
                             (cs.node[]->getSynCatNo,frag[])->ag.newAst
                               ->newNode[];
                             (teInfo.sonNo,newNode[])->teInfo.fatherNode.put;
                             cs.node[]->getSynCatNo->synCatNo;
                             (if syncatNo.isLexem then
                                 cs.node[]->unExp[];
                                 (if unExp.nonterminalSymbol
                                  // mps.prodNo.nameDecl // mps.prodNo.nameAppl
                                  // mps.prodNo.string then
                                     newNode[]->alexemText[];
                                     theLexemText[]->alexemText.putText;
                                     
                                  // mps.prodNo.const then
                                     newNode[]->parseConst
                                  else
                                     'unexp.nonterminalSymbol: '->putText;
                                     unexp.nonterminalSymbol->putInt;
                                     newLine
                                 if);
                                 
                             if)
                          // mps.kinds.nameDecl // mps.kinds.nameAppl
                          // mps.kinds.string then
                             cs.node[]->alexemText[];
                             theLexemText[]->alexemText.putText;
                             
                          // mps.kinds.const then
                             cs.node[]->parseConst; 
                          else
                             'cs.node.kind: '->putText;
                             cs.node.kind->putInt;
                             newLine
                         if);
                         makeAstReplacedEvent;
                         newCS->setFocus;
                         
                      else
                         cut; 
                     if);
                     
                 if);
                 
             if);
             structureMode->editingMode;
             
          #);
        
     #);
   enterEditAndParseMode:
     (#
        oldParsingInformation,oldIncludeComments: @boolean;
        textToParse,help: ^text;
        node,tmpNode,theListElement: ^astInterface.ast;
        enclosingNode: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        startPos: @integer;
        prettyprintedComments,extendingArea: @boolean;
        pos1,pos2,pos1withoutMark,pos2withoutMark: @integer;
        dummyInt: @integer;
        temporaryhasComment:
          (#
             node: ^astInterface.ast;
             hasOne: @boolean;
             expNode: ^astInterface.expanded;
             
          enter node[]
          do
             false->hasOne;
             (if (node## <= mps.expanded##)
              // true then
                 node[]->expNode[];
                 loop: expNode.suffixWalk
                   (# 
                   do
                      (if current.hasComment then
                          true->hasOne;
                          (if current.typeOfComment = astView.pp.holoComment
                           then
                              current[]->contractionSet.insert;
                              (if
                              'beta'->(frag.grammar.grammarIdentification).equal
                               then
                                  (if current.symbol =
                                  edenv.betaGrammar.attributes then
                                  (*Attributes contraction opened due to an error in the parser *)
                                      current[]->openContraction
                                  if)
                              if)
                          if)
                      if);
                      
                   #);
                 
             if);
             
          exit hasOne
          #);
        isList: booleanValue
          (#
          (* if the list node is selected or a number of list elements are selected
           * especially in the end of the list there are (incremental) prettyprint problems
           * Therefore we reprettyprint the whole tree in this cases
           *)
             node: ^astInterface.ast;
             synCatNo: @mps.nonterminalSymbol;
             prod: ^mg.prod
          enter node[]
          do
             node[]->getSynCatNo->synCatNo;
             (if not synCatNo.isLexem then
                 synCatNo->Prodlist.get->prod[];
                 (if prod.symbol
                  // mg.listOne // mg.listZero then true->value
                 if)
             if);
             (if not value then (cs.length > 1)->value if)
          #);
        OKtoTextedit: @boolean
     do
        editAndParseMode->editingMode;
        showCommentsAndContractions:
          (# 
          do
             astView.pp.parsingInformation
               ->
               (* if the selection contains normal or holo comments,
                the the comments and ast node addresses are included
                in the text
                *) oldParsingInformation;
             astView.pp.includeComments->oldIncludeComments;
             true->astView.pp.parsingInformation->astView.pp.includeComments;
             contractionSet.clear;
             (if cs.length = 1 then
                 (if (cs.node[]->temporaryhasComment) then
                     cs->selectArea
                       ->
                         (teInfo.lineS1,teInfo.charS1,teInfo.lineS2,
                          teInfo.charS2);
                     (cs.node[],cs.node[])->astView.pp.update;
                     (teInfo.LineS1,teInfo.charS1)
                       ->theSifTexteditor.lineCharToPos->startPos;
                     true->prettyPrintedComments
                 if)
              else
                 cs.node.father->fatherNode[];
                 l:
                   (# 
                   do
                      (if (fatherNode[] <> none ) then
                          (if fatherNode## = mps.list## then
                              fatherNode.father->fatherNode[]; restart l
                          if)
                      if)
                   #);
                 (if fatherNode[]->temporaryhasComment then
                     cs->selectArea
                       ->
                         (teInfo.lineS1,teInfo.charS1,teInfo.lineS2,
                          teInfo.charS2);
                     (for i: cs.length repeat
                       cs.node.sonNo+i-1->fatherNode.get->tmpNode[];
                       (tmpNode[],tmpNode[])->astView.pp.update
                     for);
                     (teInfo.LineS1,teInfo.charS1)
                       ->theSifTexteditor.lineCharToPos->startPos;
                     (startPos,startPos)->theSifTextEditor.contents.selection;
                     true->prettyPrintedComments
                 if)
             if);
             oldParsingInformation->astView.pp.parsingInformation;
             oldIncludeComments->astView.pp.includeComments
          #);
        recordStatusBefore:
          (# 
          do
             cs.node[]->teInfo.oldNode[];
             cs.length->teInfo.oldLength;
             cs.node.father->teInfo.fatherNode[];
             cs.node[]->isList->teInfo.isList;
             false->teInfo.hadParseErrors
          #);
        cs.node[]->parsingSynCatNo
          ->(dummyInt,teInfo.inList,theListElement[],enclosingNode[]);
        (if enclosingNode[] <> none then
            (if
            (enclosingNode[],editorRoot[])
              ->isNodeInTree (* if inside editor in case of zoom or subeditor *)
              then
                (enclosingNode[],1,0,0)->cs;
                true->extendingArea;
                restart enterEditAndParseMode
            if)
        if);
        (if extendingArea then
            cs->astToSelection;
            theSifTexteditor.contents.setTexteditStyle;
            (* (if machineType <> none then
             (if not ('nti'->(machineType).equal) and not
             ('ppcmac'->(machineType).equal) then
             '***************************************************************'
             ->putLine;
             'Extending the textediting area to:'->putLine;
             theSifTextEditor.contents.selection.contents->putLine
             if)
             else
             '***************************************************************'
             ->putLine;
             'Extending the textediting area to:'->putLine;
             theSifTextEditor.contents.selection.contents->putLine
             if);*)
            IS.cs->selectArea->astView.out.selectArea
         else
            (if prettyPrintedComments then
                cs->astToSelection;
                theSifTexteditor.contents.setTexteditStyle;
                IS.cs->selectArea->astView.out.selectArea
            if)
        if);
        (if (IS.ch = ' ') or (IS.ch = 0) then
        (* this should be obsolete now after the markers are inserted later *)
            theSifTextEditor.contents.selection->(pos1,pos2);
            (pos1,pos1)->theSifTextEditor.contents.selection
        if);
        true->OKtoTextedit;
        ifFrejaEditor:
          (# 
          do
             (if askBeforeTextediting then
                 (if (askBeforeTexteditingMessage <> none ) and
                 ((askBeforeTexteditingMessage).length > 0) then
                     (none ,'Textedit',askBeforeTexteditingMessage)
                       ->promptForBoolean
                         (#
                            ok::<  (#  do (* OKtoTextedit *)  #);
                            notOk::< 
                              (# 
                              do
                              (* (cs.node[],cs.node[])
                               ->astView.pp.update;
                               cs->selectArea
                               ->astView.out.selectArea;
                               (if useExternalTextEditor then
                               false->useExternalTextEditor
                               if);
                               structureMode->editingMode;*)
                                 false->OKtoTextedit
                              #);
                            cancel::< 
                              (# 
                              do
                              (*(cs.node[],cs.node[])->astView.pp.update;
                               cs->selectArea->astView.out.selectArea;
                               (if useExternalTextEditor then
                               false->useExternalTextEditor
                               if);
                               structureMode->editingMode;*)
                                 false->OKtoTextedit
                              #)
                         #)
                 if)
             if)
          #);
        (if OKtoTextedit then
            askFrigg:
              (# 
              do (cs.node[]->edenv.ymercallback.OKtoTextedit)->OKtoTextedit
              #);
            (if OKtoTextedit then
                true->textEditMode;
                recordStatusBefore:
                  (# 
                  do
                     (if (teInfo.fatherNode[] <> none ) then
                         teInfo.fatherNode.noOfSons->teInfo.oldNoOfSons;
                         cs.node.sonNo->teInfo.sonNo
                     if);
                     theSifTextEditor.lastPosition->teInfo.lastPosBefore;
                     cs->selectArea
                       ->
                         (teInfo.lineS1,teInfo.charS1,teInfo.lineS2,
                          teInfo.charS2);
                     (teInfo.lineS1,teInfo.charS1)
                       ->theSifTextEditor.LineChartoPos->teInfo.posStartBefore;
                     (teInfo.lineS2,teInfo.charS2)
                       ->theSifTextEditor.LineChartoPos->teInfo.posEndBefore;
                     teInfo.textBefore.clear;
                     (teInfo.posStartBefore,teInfo.posEndBefore)
                       ->theSifTextEditor.contents.scantext
                         (#  do ch->teInfo.textBefore.put #)
                  #);
                insertMarkers:
                  (# 
                  do
                     theSifTextEditor.contents.selection
                       ->(pos1withoutMark,pos2withoutMark);
                     cs->astToSelection;
                     theSifTextEditor.contents.selection->(pos1,pos2);
                     markerBegin->theSifTextEditor.contents.insert;
                     (pos2+markerLength,pos2+markerLength)
                       ->theSifTextEditor.contents.selection;
                     markerEnd->theSifTextEditor.contents.insert;
                     (if (IS.ch = ' ') or (IS.ch = 0) then
                         (if extendingArea then
                             (pos1withoutMark+markerLength,pos1withoutMark+
                              markerLength)->theSifTextEditor.contents.selection
                          else
                             (pos1+markerLength,pos1+markerLength)
                               ->theSifTextEditor.contents.selection
                         if)
                      else
                         (if extendingArea then
                             (pos1withoutMark+markerLength,pos2withoutMark+
                              markerLength)->theSifTextEditor.contents.selection
                          else
                             (pos1+markerLength,pos2+markerLength)
                               ->theSifTextEditor.contents.selection
                         if)
                     if)
                  #);
                (if useExternalTextEditor then
                    startExternalEditor:
                      (# 
                      do
                         false->useExternalTextEditor;
                         'External textediting'->edenv.ymerCallback.infoView;
                         TEinfo.textBefore[]->externalTextEdit
                           ->TEinfo.TextAfter[];
                         (if TEinfo.textBefore[]->TEinfo.textAfter.equal then
                             'No changes'->putLine;
                             'External textediting: No changes'
                               ->edenv.ymerCallback.infoView;
                             removeMarkers:
                               (# 
                               do
                                  (teInfo.posStartBefore,teInfo.posStartBefore+
                                   markerLength)
                                    ->theSifTextEditor.contents.selection;
                                  theSifTextEditor.contents.delete;
                                  (teInfo.posEndBefore,teInfo.posEndBefore+
                                   markerLength)
                                    ->theSifTextEditor.contents.selection;
                                  theSifTextEditor.contents.delete;
                                  
                               #);
                             false->textEditMode
                          else
                             (teInfo.posStartBefore+markerLength,
                              teInfo.posEndBefore+markerLength)
                               ->theSifTextEditor.contents.selection;
                             theSifTextEditor.contents.delete;
                             (teInfo.posStartBefore+markerLength,
                              teInfo.posStartBefore+markerLength)
                               ->theSifTextEditor.contents.selection;
                             TEinfo.textAfter[]
                               ->theSifTextEditor.contents.insert;
                             false->textEditMode;
                             (TEexit.parseMode,(none ,1,0,0))
                               ->TE.exitEditAndParseMode;
                             (if TEinfo.parseError then
                                 TEinfo.parseErrorText[]
                                   ->edenv.ymerCallBack.infoView
                             if);
                             
                         if)
                      #)
                if)
            if)
        if);
        (if not OKtoTextedit then
            doReprettyprint;
            cs->selectArea->astView.out.selectArea;
            structureMode->editingMode;
            edenv.ymerCallback.infoViewClear
        if)
     #);
   exitEditAndParseMode:
     (#
        exitKind: @integer;
        outLineS2,outCharS2: @integer;
        posEndAfter: @integer;
        newCs: @mps.astFocus;
        textToParse,help,tt: ^text;
        parseOk,OKtoParse,noText: @boolean;
        instring: @boolean;
        parsingOK:< (#  do INNER #);
        parsingNotOK:< (#  do INNER #);
        
     enter (exitKind,newCS)
     do
        parsing:
          (#
             myerrorReporter: mps.errorReporter
               (#
                  beforeFirstError::<  (#  do parsingNotOK;  #);
                  afterLastError::<  (#  do  #);
                  forEachError::< 
                    (# alertText: ^text
                    do
                       (teInfo.posStartBefore+markerLength+streamPos-1,
                        teInfo.posStartBefore+markerLength+streamPos-1)
                         ->theSifTextEditor.contents.selection;
                       'Parse error, expected symbol'->alertText[];
                       (if legalSymbols.terminals.range
                        // 1 then ': '->alertText.putText; 
                        else
                           's: '->alertText.putText
                       if);
                       (for i: legalSymbols.terminals.range repeat
                         legalSymbols.terminals[i][]->alertText.putText;
                         ' '->alertText.put
                       for);
                       theSifTexteditor.contents[]->target;
                       ascii.bel->put;
                       alertText[]->edenv.ymerCallBack.infoView;
                       true->TEinfo.parseError;
                       alertText->TEinfo.parseErrorText;
                       leave parsing
                    #)
               #);
             
          do
             false->TEinfo.parseError;
             ''->TEinfo.parseErrorText;
             updatePPshadowAst:
               (# 
               do
                  teInfo.posEndBefore+theSifTextEditor.lastPosition-
                  teInfo.lastPosBefore
                    -> (* determine extent of edited text: *) posEndAfter;
                  posEndAfter->theSifTextEditor.posToLineChar
                    ->(outLineS2,outCharS2);
                  (if (outLineS2 <> 0) and (outCharS2 <> 0) then
                      (if (* tell the pretty printer how to update the SAST *)
                      (teInfo.oldLength = 1) then
                          (teInfo.oldNode[],outLineS2-teInfo.lineS2,outCharS2-
                           teInfo.charS2)->astView.pp.resized
                       else
                          (if (teInfo.sonNo = teInfo.fatherNode.noOfSons) then
                              (teInfo.fatherNode[],outLineS2-teInfo.lineS2,
                               outCharS2-teInfo.charS2)->astView.pp.resized
                           else
                              (teInfo.fatherNode[],outLineS2-teInfo.lineS2,0)
                                ->astView.pp.resized
                          if)
                      if)
                   else
                      'exitEditAndParseMode: posToLineChar returned (0,0)'
                        ->putLine
                  if)
               #);
             (if (* text editor exited by a key stroke or menu *) exitKind
              // TEexit.escape then
                 doReprettyprint; structureMode->editingMode; 
              // TEexit.exitMode // TEexit.parseMode then
              (* normal exit 
               parse the edited text *)
                 &text[]->textToParse[];
                 textToParse.reset;
                 ascii.newLine->textToParse.put;
                 (teInfo.posStartBefore,posEndAfter)
                   ->theSifTextEditor.contents.selection;
                 (teInfo.posStartBefore,posEndAfter)
                   ->theSifTextEditor.contents.scantext
                     (# 
                     do
                        (if true
                         // (ch > ' ') (*and (ch <= '~') *) // ch = ascii.sp
                         // ch = ascii.newLine then
                            ch->textToParse.put
                        if)
                     #);
                 ignoreMarkers:
                   (# 
                   do (* "eat" the markers excluding the spaces *)
                      (markerLength+1,textToParse.length-markerLength+1)
                        ->textToParse.sub->textToParse[];
                      textToParse[]->skipLeadingAndTrailingBlanks
                   #);
                 (if textToParse[]->teInfo.textBefore.equal then
                     (if (teInfo.oldLength = 1) then
                         (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update
                      else
                         (teInfo.fatherNode[],teInfo.fatherNode[])
                           ->astView.pp.update
                     if);
                     cs->astToSelection;
                     structureMode->editingMode;
                     'Textediting: No changes'->edenv.ymerCallback.infoView
                  else
                     (if textToParse.length = 0 then
                         true->noText
                      else
                         (if textToParse.length > 0 then
                             false->OKtoParse;
                             true->noText;
                             textToParse.scanAll
                               (# 
                               do
                                  (if not (ch->ascii.isSpace) then
                                      true->OKtoParse; false->noText
                                  if)
                               #)
                         if)
                     if);
                     (if OKtoParse then
                         checkContractions:
                           (#
                              index: @integer;
                              contractionFound,syntaxErrorInText: @boolean;
                              msg: ^text
                           do
                              (if contractionSet.size > 0 then  if);
                              '<<@'
                                ->textToParse.findTextAll
                                  (# 
                                  do
                                     (if contractionSet.size > 0 then
                                         inx+2->textToParse.pos;
                                         (if not textToParse.eos and
                                         (textToParse.peek->ascii.isDigit) then
                                             textToParse.getInt->index;
                                             false->contractionFound;
                                             l: contractionSet.scan
                                               (# 
                                               do
                                                  (if current.index = index then
                                                      true->contractionFound;
                                                      leave l
                                                  if)
                                               #);
                                             (if not contractionFound then
                                                 false->OKtoParse;
                                                 'The AST index: '->msg[];
                                                 index->msg.putInt;
                                                 ' not found, do not modify the textual representation of contractions'
                                                   ->msg.append;
                                                 msg[]
                                                   ->
                                                     edenv.ymerCallback.
                                                       infoView;
                                                 ascii.bel->put;
                                                 true->texteditMode;
                                                 true->teInfo.hadParseErrors;
                                                 (teInfo.posStartBefore+
                                                  markerLength+inx+2,
                                                  teInfo.posStartBefore+
                                                  markerLength+inx+2)
                                                   ->
                                                     theSifTextEditor.contents.
                                                       selection;
                                                 leave parsing
                                             if)
                                          else
                                             false->OKtoParse;
                                             'Do not modify the textual representation of contractions'
                                               ->edenv.ymerCallback.infoView;
                                             ascii.bel->put;
                                             true->texteditMode;
                                             true->teInfo.hadParseErrors;
                                             (teInfo.posStartBefore+markerLength
                                              +inx+2,teInfo.posStartBefore+
                                              markerLength+inx+2)
                                               ->
                                                 theSifTextEditor.contents.
                                                   selection;
                                             leave parsing
                                         if)
                                      else
                                         false->OKtoParse;
                                         'Unexpected textual representation of contraction'
                                           ->edenv.ymerCallback.infoView;
                                         ascii.bel->put;
                                         true->texteditMode;
                                         true->teInfo.hadParseErrors;
                                         (teInfo.posStartBefore+markerLength+inx
                                          +2,teInfo.posStartBefore+markerLength+
                                          inx+2)
                                           ->
                                             theSifTextEditor.contents.
                                               selection;
                                         leave parsing
                                     if)
                                  #);
                              textToParse.length->textToParse.pos
                           #)
                     if);
                     (if OKtoParse then
                         (if not (textToParse[]->isComment) then
                             textToParse.newLine;
                             textToParse.reset;
                             true->cs.undoPermit;
                             &myErrorReporter[]->mps.theErrorReporter[];
                             (cs,textToParse[])
                               ->parseText
                                 (#
                                    astOverflow:: 
                                      (# 
                                      do
                                         false->textEditMode;
                                         edenv.mpsErrorReporter[]
                                           ->mps.theErrorReporter[];
                                         (TEexit.escape,cs)
                                           ->TE.exitEditAndParseMode;
                                         (if touched = 0 then
                                             fragmentTouched
                                             (* to provoke garbage collection*)
                                         if);
                                         edenv.ymerCallback.quit;
                                         leave parsing
                                      #)
                                 #)->(parseOK,cs);
                             (if (* now cs is updated *) parseOk then
                                 theSifTexteditor.contents.resetTexteditStyle;
                                 structureMode->editingMode;
                                 (if newCS.node[] = none then
                                     cs->setFocus
                                  else
                                     newCS->setFocus
                                 if);
                                 parsingOK;
                                 edenv.ymerCallback.infoViewClear;
                                 (if teInfo.hadParseErrors or teInfo.isList then
                                     doReprettyprint
                                 if)
                              else
                             (* parse error *)
                                 true->texteditMode;
                                 true->teInfo.hadParseErrors;
                                 (* prepare for reentrance: this is not enough apparently: theSifTextEditor.lastPosition
                                  ->teInfo.lastPosBefore;
                                  posEndAfter->teInfo.posEndBefore;*)
                                 &text[]->tt[];
                                 textToParse.scanAll
                                   (#
                                   (* all this due to an error in the error reporter :-) *)
                                   
                                   do
                                      (if ch
                                       // '\'' then
                                          not inString->inString; ch->tt.put
                                       // ascii.sp then
                                          (if inString then
                                              ch->tt.put
                                           else
                                              tt.newLine
                                          if)
                                       else
                                          ch->tt.put
                                      if)
                                   #);
                                 '       '->tt.putLine;
                                 tt.reset;
                                 (tt[],screen[])->ag.parser.errorReport
                             if)
                          else
                             (none ,
                              'To comment out code, you currently have to textedit the enclosing block',
                              'It is a comment')->UI.alertUser;
                             (if (teInfo.oldLength = 1) then
                                 (teInfo.oldNode[],teInfo.oldNode[])
                                   ->astView.pp.update
                              else
                                 (teInfo.fatherNode[],teInfo.fatherNode[])
                                   ->astView.pp.update
                             if);
                             cs->astToSelection;
                             structureMode->editingMode
                         if)
                      else
                         (if noText then
                             cut;
                             structureMode->editingMode;
                             newCS->setFocus;
                             doReprettyprint;
                             parsingOK
                         if)
                     if)
                 if)
             if)
          #);
        edenv.mpsErrorReporter[]->mps.theErrorReporter[]
     #)
#)  

-- doTextedit: DoPart --
do
     (# OKtoTextedit: @boolean
     do
        (if not frag.locked then
            (if (cs.subCommentInx1 = 0) and (cs.subCommentInx2 = 0) then
            (*now moved to entereditandparse mdoe true->textEditMode;*)
                (if edenv.ymerCallback.isEditor then
                    true->OKtoTextedit
                 else
                    (if askValhallaBeforeTextEditing then
                        (none ,'Stop debugging?',
                         'If you edit the program debugging cannot continue\nStop debugging?')
                          ->promptForBoolean
                            (#
                               ok::< 
                                 (# 
                                 do
                                    edenv.ymerCallback.stopDebugging;
                                    true->OKtoTextedit
                                 #)
                            #)
                     else
                        true->OktoTextedit
                    if)
                if);
                (if OKtoTextedit then
                    'Textedit mode: Use \'Parse Text(Ctrl-space or Ctrl-t)\' or \'Cancel Textediting(Esc)\' to exit'
                      ->edenv.ymerCallback.infoView;
                    (if cs.isContraction then
                        CS.node[]->openContraction;
                        CS.node[]->localOnRefresh;
                        cs->astToSelection
                    if);
                    cs->TE.IS.cs;
                    ch->TE.IS.ch;
                    cs->selectArea
                      ->(TE.IS.lineS1,TE.IS.charS1,TE.IS.lineS2,TE.IS.charS2);
                    (TE.IS.lineS1,TE.IS.charS1)->theSifTextEditor.LineChartoPos
                      ->TE.IS.start;
                    (TE.IS.lineS2,TE.IS.charS2)->theSifTextEditor.LineChartoPos
                      ->TE.IS.end;
                    (if ch = 0 then
                          (# pos1,pos2: @integer
                          do
                             thesiftexteditor.contents.setTexteditStyle;
                             theSifTextEditor.contents.selection->(pos1,pos2);
                             (pos1,pos1)->theSifTextEditor.contents.selection
                          #)
                    if);
                      (#
                         unExp: ^astInterface.unexpanded;
                         synCatNo: @mps.nonterminalSymbol
                      do
                         (if (cs.length = 1) then
                             (if cs.node.kind
                              // mps.kinds.unexpanded then
                                 cs.node[]->getSynCatNo->synCatNo;
                                 (if syncatNo.isLexem then
                                     cs.node[]->unExp[];
                                     (if unExp.nonterminalSymbol
                                      // mps.prodNo.nameDecl
                                      // mps.prodNo.nameAppl
                                      // mps.prodNo.string // mps.prodNo.const
                                      then
                                         (if parsingPossible then
                                             TE.enterEditAndParseMode; 
                                          else
                                             TE.enterEditLexemMode
                                         if)
                                         (*// mps.prodNo.const then
                                          TE.enterEditLexemMode*)
                                      else
                                         (if parsingPossible then
                                             TE.enterEditAndParseMode
                                          else
                                             false->textEditMode;
                                             (none ,
                                              'No parser available\nText editing is only allowed on lexems',
                                              'Alert')->UI.alertUser
                                         if)
                                     if)
                                  else
                                     (if parsingPossible then
                                         TE.enterEditAndParseMode
                                      else
                                         false->textEditMode;
                                         (none ,
                                          'No parser available\nText editing is only allowed on lexems',
                                          'Alert')->UI.alertUser
                                     if)
                                 if)
                              // mps.kinds.nameDecl // mps.kinds.nameAppl
                              // mps.kinds.string // mps.prodNo.const then
                                 (if parsingPossible then
                                     TE.enterEditAndParseMode
                                  else
                                     TE.enterEditLexemMode
                                 if)
                                 (*// mps.kinds.const then
                                  TE.enterEditLexemMode*)
                              else
                                 (if parsingPossible then
                                     TE.enterEditAndParseMode
                                  else
                                     false->textEditMode;
                                     (none ,
                                      'No parser available\nText editing is only allowed on lexems',
                                      'Alert')->UI.alertUser
                                 if)
                             if);
                             
                          else
                             (if parsingPossible then
                                 TE.enterEditAndParseMode
                              else
                                 false->textEditMode;
                                 (none ,
                                  'No parser available\nText editing is only allowed on one lexem at a time',
                                  'Alert')->UI.alertUser
                             if)
                         if)
                      #)
                if)
             else
                (none ,'To edit comments, textedit the enclosing structure',
                 'Edit text')->UI.alertUser
            if)
         else
            ascii.bel->put;
            'This fragment form is read-only or textediting on this fragment form is ongoing in another window'
              ->edenv.ymerCallback.infoView
        if)
     #)  

-- doExternalTextEdit: DoPart --
do true->TE.useExternalTextEditor; doTextedit  

-- checkTexteditingFinished: Descriptor --
(#
   oldWay:
     (# posEndAfter: @integer; newCS: @mps.astFocus; outside: @boolean
     do
        TE.teInfo.posEndBefore+theSifTextEditor.lastPosition-
        TE.teInfo.lastPosBefore
          -> (* determine extent of edited text: *) posEndAfter;
        (if
        ((start < TE.teInfo.posStartBefore+TE.markerLength) or
         (end < TE.teInfo.posStartBefore+TE.markerLength)) then
            (start,end)->selectionToAST->newCS; true->outside
        if);
        (if
        ((start > posEndAfter-TE.markerLength) or
         (end > posEndAfter-TE.markerLength)) then
            (start-2*TE.markerLength,end-2*TE.markerLength)->selectionToAST
              ->newCS;
            (*(if newCS.node[] <> none then newCS.node[]->astObserver if);
             (start,end)->selectionToAST->newCS;
             (if newCS.node[] <> none then newCS.node[]->astObserver if);*)
            true->outside
        if);
        (if outside then
            (if editingMode
             // editAndParseMode then
                false->textEditMode;
                (TEexit.parseMode,newCS)->TE.exitEditAndParseMode
             // editLexemMode then
                false->textEditMode;
                (TEexit.exitMode,newCS)->TE.exitEditLexemMode
            if)
        if)
     #);
   newWay:
     (# posEndAfter,startSel,endSel,begin,end: @integer; outside: @boolean
     do
        TE.teInfo.posEndBefore+theSifTextEditor.lastPosition-
        TE.teInfo.lastPosBefore
          -> (* determine extent of edited text: *) posEndAfter;
        (if editingMode = editLexemMode then
            TE.teInfo.posStartBefore->begin; posEndAfter->end
         else
            TE.teInfo.posStartBefore+TE.markerLength->begin;
            posEndAfter-TE.markerLength->end
        if);
        (start,end)->min->startSel;
        (start,end)->max->endSel;
        (if startSel < begin then
            true->outSide; (begin,begin)->theSifTextEditor.contents.selection
         else
            (if endSel > end then
                true->outSide; (end,end)->theSifTextEditor.contents.selection
            if)
        if);
        (if outSide then
            ascii.bel->put;
            'Textedit mode: Use \'Parse Text(Ctrl-space or Ctrl-t)\' or \'Cancel Textediting(Esc)\' to exit'
              ->edenv.ymerCallback.infoView
        if)
     #)
do
   (if true (* do not allow to exit using the mouse anymore *) then
       newWay
    else
       oldWay
   if)
#)  

-- keepInsideTexteditingArea: Descriptor --
(# posEndAfter,pos,begin,end: @integer; outSide: @boolean
do
   TE.teInfo.posEndBefore+theSifTextEditor.lastPosition-TE.teInfo.lastPosBefore
     -> (* determine extent of edited text: *) posEndAfter;
   theSifTextEditor.contents.selection.start->pos;
   true->value;
   (if editingMode = editLexemMode then
       TE.teInfo.posStartBefore->begin; posEndAfter->end
    else
       TE.teInfo.posStartBefore+TE.markerLength->begin;
       posEndAfter-TE.markerLength->end
   if);
   (if arrowKey
    // leftArrow // rightArrow // upArrow // downArrow
    // - 1 (* ascii.bs or ascii.del *) then
       (if pos < begin then
           true->outSide;
           (begin,begin)->theSifTextEditor.contents.selection;
           false->value
        else
           (if pos > end then
               true->outSide;
               (end,end)->theSifTextEditor.contents.selection;
               false->value
           if)
       if);
       (if outSide then
           ascii.bel->put;
           'Textedit mode: Use \'Parse Text(Ctrl-space or Ctrl-t)\' or \'Cancel Textediting(Esc)\' to exit'
             ->edenv.ymerCallback.infoView
       if)
    // spk.HOME then
       (begin,begin)->theSifTextEditor.contents.selection
    // spk.END then
       (end,end)->theSifTextEditor.contents.selection
   if)
#)  

-- doParseText: DoPart --
do
   false->textEditMode;
   (if editingMode
    // editAndParseMode then
       (TEexit.parseMode,(none ,0,0,0))->TE.exitEditAndParseMode; 
    // editLexemMode then
       (TEexit.exitMode,(none ,0,0,0))->TE.exitEditLexemMode; 
   if)  

-- doRevertTextediting: DoPart --
do
   false->textEditMode;
   edenv.mpsErrorReporter[]->mps.theErrorReporter[];
   (if editingMode
    // editAndParseMode then
       (TEexit.escape,cs)->TE.exitEditAndParseMode; 
    // editLexemMode then
       (TEexit.escape,cs)->TE.exitEditLexemMode; 
   if)  

-- doShowTexteditingCommands: DoPart --
do   

-- texteditingExtent: DoPart --
do (* modification made by MBE *)
   TE.teInfo.posStartBefore+3->start;
   TE.teInfo.posEndBefore+theSifTextEditor.lastPosition-TE.teInfo.lastPosBefore-
   3->end  

