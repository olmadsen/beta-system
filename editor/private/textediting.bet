ORIGIN '../codeeditor';
INCLUDE '~beta/basiclib/v1.5/numberio'
        '~beta/guienv/v1.4/styledtext';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- texteditingPrivate: Descriptor --
(#
   selRow,selCol,endRow,endCol: @integer;
   editingLexems: @boolean;
   useExternalTextEditor: @boolean;
   updateList:
     (# listNode: ^astInterface.expanded; containsLastElement: @boolean
     enter (listNode[],containsLastElement)
     do (* (editorRoot[] ,- 1)->astView.pp.present;*)
        (if containsLastElement then
            (if listNode[]->editorRoot.equal then
                doReprettyprint
             else
                (if listNode.father <> none then
                    (listNode.father,listNode.father)->astView.pp.update
                 else
                    doReprettyprint
                if)
            if)
         else
            (listNode[],listNode[])->astView.pp.update
        if)
     #);
   teInfo: @
     (#
        lineS1,charS1,lineS2,charS2: @integer;
        posStartBefore,posEndBefore: @integer;
        oldnode: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        inList: @boolean;
        listNode: ^astInterface.list;
        oldNoOfSons: @integer;
        sonNo: @integer;
        lastPosBefore: @integer;
        synCatNo: (* editAndParse: *) @mps.nonterminalSymbol;
        oldLength: @integer;
        textBefore: @text;
        textAfter: ^text
     #);
   test4:
     (# xstart,ystart,xend,yend: @integer; com,t: ^text
     enter (com[],xstart,ystart,xend,yend)
     do
        &text[]->t[];
        com[]->t.putText;
        ': '->t.putText;
        xstart->t.putInt;
        ' '->t.put;
        ystart->t.putInt;
        ' '->t.put;
        xend->t.putInt;
        ' '->t.put;
        yend->t.putInt;
        t[]->putText;
        
     #);
   test2:
     (# x,y: @integer; com,t: ^text
     enter (com[],x,y)
     do
        &text[]->t[];
        com[]->t.putText;
        ': '->t.putText;
        x->t.putInt;
        ' '->t.put;
        y->t.putInt;
        t[]->putText;
        
     #);
   isComment: booleanValue
     (# t: ^text; start,end: @integer
     enter t[]
     do
        skipLeadingBlanks: t.scanAll
          (# 
          do
             (if not (ch->ascii.isSpace) then
                 start+1->start; leave skipLeadingBlanks
             if)
          #);
        (if start > 0 then (1,start)->t.delete if);
        skipTrailingBlanks:
        (if (t.length->t.inxGet)->ascii.isSpace then
            (t.length,t.length)->t.delete; restart skipTrailingBlanks
        if);
        (((1->t.inxGet) = '(') and ((2->t.inxGet) = '*') and
         ((t.length-1->t.inxGet) = '*') and ((t.length->t.inxGet) = ')'))->value
     #);
   enterEditLexemMode:
     (# 
     do
        (if switch[4] then 'enterEditLexemMode: '->putLine if);
        editLexemMode->editingMode;
        cs.node[]->teInfo.oldNode[];
        cs.node.father->teInfo.fatherNode[];
        (if (teInfo.fatherNode[] <> none ) then
        (* else a program with a lexem in the root!! *)
            cs.node.sonNo->teInfo.sonNo;
            theSifTextEditor.lastPosition->teInfo.lastPosBefore;
            cs->selectArea
              ->(teInfo.lineS1,teInfo.charS1,teInfo.lineS2,teInfo.charS2);
            (teInfo.lineS1,teInfo.charS1)->theSifTextEditor.LineChartoPos
              ->teInfo.posStartBefore;
            (teInfo.lineS2,teInfo.charS2)->theSifTextEditor.LineChartoPos
              ->teInfo.posEndBefore;
            teInfo.textBefore.clear;
            (teInfo.posStartBefore,teInfo.posEndBefore)
              ->theSifTextEditor.contents.scantext
                (#  do ch->teInfo.textBefore.put #);
            (if useExternalTextEditor then
                false->useExternalTextEditor;
                TEinfo.textBefore[]->externalTextEdit->TEinfo.TextAfter[];
                (teInfo.posStartBefore,teInfo.posEndBefore)
                  ->theSifTextEditor.contents.selection;
                theSifTextEditor.contents.delete;
                (teInfo.posStartBefore,teInfo.posStartBefore)
                  ->theSifTextEditor.contents.selection;
                TEinfo.textAfter[]->theSifTextEditor.contents.insert;
                false->textEditMode;
                (TEexit.exitMode,(none ,1,0,0))->TE.exitEditLexemMode
            if);
            
        if)
     #);
   exitEditLexemMode:
     (#
        exitKind: @integer;
        outLineS2,outCharS2: (* terrible names!!! *) @integer;
        posEndAfter: @integer;
        theLexemText,help: ^text;
        alexemText: ^astInterface.lexemText;
        newNode: ^astInterface.ast;
        synCatNo: @mps.nonterminalSymbol;
        unExp: ^astInterface.unexpanded;
        newCS: @astFocus;
        OK,OKtoParse: @boolean;
        preceeding: @boolean;
        
     enter (exitKind,newCS)
     do
        (if switch[4] then
            'exitEditLexemMode: '->putText;
            '<'->put;
            exitKind->putInt;
            '>'->put;
            newLine
        if);
        parsingLexems:
          (#
             parseConst:
               (# theConst: ^astInterface.const; help: ^text; 
               enter theconst[]
               do
                  'no errors'->help[];
                  0->theLexemText.setPos;
                  theLexemText.getnumber
                    (#
                       syntaxError::< 
                         (# 
                         do
                            true->continue;
                            'getNumber: Syntax error - looking at: "'->help[];
                            peekCh->help.put;
                            '"'->help.put;
                            
                         #);
                       baseError::< 
                         (# 
                         do
                            true->continue;
                            'getNumber: Error in base - looking at: "'->help[];
                            base->help.put;
                            '"'->help.put
                         #);
                       valueError::< 
                         (# 
                         do
                            true->continue;
                            'getNumber: Illegal value type - looking at: "'
                              ->help[];
                            peekCh->help.put;
                            '"'->help.put
                         #);
                       integerValue::<  (#  do true->OK #);
                       basedValue::<  (#  do true->OK #);
                       realValue::<  (#  do true->OK #);
                       
                    #);
                  (if OK then
                      theLexemText[]->theConst.putText; 
                   else
                      true->textEditMode;
                      'Trying to parse: <'->screen.putText;
                      theLexemText[]->screen.putText;
                      '>'->screen.putLine;
                      (none ,help[],'Alert')->UI.alertUser;
                      leave parsingLexems
                  if);
                  
               #);
             
          do
             (if switch[4] then
                 ('positions before',teInfo.posStartBefore,teInfo.posEndBefore)
                   ->test2;
                 ('last position before and after',teInfo.lastPosBefore,
                  theSifTexteditor.lastPosition)->test2;
                 
             if);
             teInfo.posEndBefore+theSifTexteditor.lastPosition-
             teInfo.lastPosBefore
               -> (* determine extent of edited text: *) posEndAfter;
             (if switch[4] then
                 ('positions after',teInfo.posStartBefore,posEndAfter)->test2; 
             if);
             posEndAfter->theSifTextEditor.posToLineChar->(outLineS2,outCharS2);
             (if (outLineS2 <> 0) and (outCharS2 <> 0) then
                 (if switch[4] then
                     ('outCharS2, outLineS2',outCharS2,outLineS2)->test2; 
                 if);
                 (teInfo.oldNode[],outLineS2-teInfo.lineS2,outCharS2-
                  teInfo.charS2)
                   -> (* tell the pretty printer how to update the SAST *)
                     astView.pp.resized
              else
                 'exitEditLexemMode: posToLineChar returned (0,0)'->putLine
             if);
             (if exitKind
              // TEexit.escape then
                 (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update;
                 cs->astToSelection;
                 
              // TEexit.exitMode // TEexit.parseMode then
              (* normal exit 
               parse the edited text *)
                 &text[]->theLexemText[];
                 true->preceeding;
                 (teInfo.posStartBefore,posEndAfter)
                   ->theSifTextEditor.contents.scantext
                     (# 
                     do
                        (if ((ch->ascii.isSpace) and preceeding) then
                            
                         else
                            false->preceeding;
                            (if true
                             // (ch > ' ') // ch = ascii.sp
                             // ch = ascii.newLine then
                                ch->theLexemText.put
                            if);
                            
                        if);
                        
                     #);
                 (if switch[4] then
                     ' ['->help[];
                     theLexemText[]->help.putText;
                     '] '->help.putText;
                     (help[],teInfo.charS1,teInfo.lineS1,outCharS2,outLineS2)
                       ->test4;
                     
                 if);
                 (if theLexemText[]->teInfo.textBefore.equal then
                     (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update;
                     cs->astToSelection;
                     
                  else
                     (theLexemText.length <> 0)
                       ->
                       (* avoid parsing of only space symbols, just cut the corresponding AST *)
                       OKtoParse;
                     (if OKtoParse then
                         false->OKtoParse;
                         theLexemText.scanAll
                           (# 
                           do
                              (if not (ch->ascii.isSpace) then
                                  true->OKtoParse
                              if)
                           #);
                         
                     if);
                     (if OKtoParse then
                         true->cs.undoPermit;
                         (teInfo.fatherNode[],teInfo.sonNo,cs,1,false)
                           ->makeUndoElem;
                         (if cs.node.kind
                          // mps.kinds.unexpanded then
                             (cs.node[]->getSynCatNo,frag[])->ag.newAst
                               ->newNode[];
                             (teInfo.sonNo,newNode[])->teInfo.fatherNode.put;
                             cs.node[]->getSynCatNo->synCatNo;
                             (if syncatNo.isLexem then
                                 cs.node[]->unExp[];
                                 (if unExp.nonterminalSymbol
                                  // mps.prodNo.nameDecl // mps.prodNo.nameAppl
                                  // mps.prodNo.string then
                                     newNode[]->alexemText[];
                                     theLexemText[]->alexemText.putText;
                                     
                                  // mps.prodNo.const then
                                     newNode[]->parseConst
                                  else
                                     'unexp.nonterminalSymbol: '->putText;
                                     unexp.nonterminalSymbol->putInt;
                                     newLine
                                 if);
                                 
                             if)
                          // mps.kinds.nameDecl // mps.kinds.nameAppl
                          // mps.kinds.string then
                             cs.node[]->alexemText[];
                             theLexemText[]->alexemText.putText;
                             
                          // mps.kinds.const then
                             cs.node[]->parseConst; 
                          else
                             'cs.node.kind: '->putText;
                             cs.node.kind->putInt;
                             newLine
                         if);
                         makeAstReplacedEvent;
                         newCS->setFocus;
                         
                      else
                         cut; 
                     if);
                     
                 if);
                 
             if);
             structureMode->editingMode;
             
          #);
        
     #);
   enterEditAndParseMode:
     (#
        oldParsingInformation,oldIncludeComments: @boolean;
        textToParse,help: ^text;
        node,tmpNode,theListElement: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        startPos,dummyInt: @integer;
        temporaryhasComment:
          (#
             node: ^astInterface.ast;
             hasOne: @boolean;
             expNode: ^astInterface.expanded;
             
          enter node[]
          do
             false->hasOne;
             (if (node## <= mps.expanded##)
              // true then
                 node[]->expNode[];
                 loop: expNode.suffixWalk
                   (# 
                   do
                      (if current.hasComment then
                          true->hasOne;
                          (if current.typeOfComment = astView.pp.holoComment
                           then
                              (if
                              'beta'->(frag.grammar.grammarIdentification).equal
                               then
                                  (if current.symbol =
                                  edenv.betaGrammar.attributes then
                                      'Attributes contraction opened'->putLine;
                                      current[]->openContraction
                                  if)
                              if)
                          if)
                      if);
                      
                   #);
                 
             if);
             
          exit hasOne
          #)
     do (*  ch->enterTextediting;*)
        (if switch[4] then 'enterEditAndParseMode: '->putLine if);
        editAndParseMode->editingMode;
        astView.pp.parsingInformation
          ->
          (* if the selection contains normal or holo comments,
           the the comments and ast node addresses are included
           in the text
           *) oldParsingInformation;
        astView.pp.includeComments->oldIncludeComments;
        true->astView.pp.parsingInformation->astView.pp.includeComments;
        (if cs.length
         // 1 then
            (if (cs.node[]->temporaryhasComment) then
                cs->selectArea
                  ->(teInfo.lineS1,teInfo.charS1,teInfo.lineS2,teInfo.charS2);
                (cs.node[],cs.node[])->astView.pp.update;
                (teInfo.LineS1,teInfo.charS1)->theSifTexteditor.lineCharToPos
                  ->startPos;
                (startPos,startPos)->theSifTextEditor.contents.selection;
                
            if);
            
         else
            cs.node.father->fatherNode[];
            l:
              (# 
              do
                 (if (fatherNode[] <> none ) then
                     (if fatherNode## = mps.list## then
                         fatherNode.father->fatherNode[]; restart l
                     if)
                 if)
              #);
            (if fatherNode[]->temporaryhasComment then
                cs->selectArea
                  ->(teInfo.lineS1,teInfo.charS1,teInfo.lineS2,teInfo.charS2);
                (for i: cs.length repeat
                  cs.node.sonNo+i-1->fatherNode.get->tmpNode[];
                  (tmpNode[],tmpNode[])->astView.pp.update
                for);
                (teInfo.LineS1,teInfo.charS1)->theSifTexteditor.lineCharToPos
                  ->startPos;
                (startPos,startPos)->theSifTextEditor.contents.selection;
                
            if);
            
        if);
        oldParsingInformation->astView.pp.parsingInformation;
        oldIncludeComments->astView.pp.includeComments;
        cs.node[]->teInfo.oldNode[];
        cs.length->teInfo.oldLength;
        cs.node.father->teInfo.fatherNode[];
        cs.node[]->parsingSynCatNo->(dummyInt,teInfo.inList,theListElement[]);
        (if teInfo.inList then theListElement.father->teInfo.listNode[] if);
        (if (teInfo.fatherNode[] <> none ) then
            teInfo.fatherNode.noOfSons->teInfo.oldNoOfSons;
            cs.node.sonNo->teInfo.sonNo
        if);
        theSifTextEditor.lastPosition->teInfo.lastPosBefore;
        cs->selectArea
          ->(teInfo.lineS1,teInfo.charS1,teInfo.lineS2,teInfo.charS2);
        (teInfo.lineS1,teInfo.charS1)->theSifTextEditor.LineChartoPos
          ->teInfo.posStartBefore;
        (teInfo.lineS2,teInfo.charS2)->theSifTextEditor.LineChartoPos
          ->teInfo.posEndBefore;
        teInfo.textBefore.clear;
        (teInfo.posStartBefore,teInfo.posEndBefore)
          ->theSifTextEditor.contents.scantext
            (#  do ch->teInfo.textBefore.put #);
        (if switch[4] then
            &text[]->textToParse[];
            (teInfo.posStartBefore,teInfo.posEndBefore)
              ->theSifTextEditor.contents.scantext
                (#  do ch->textToParse.put #);
            ascii.newLine->textToParse.put;
            ' ['->help[];
            textToParse[]->help.putText;
            '] '->help.putText;
            (help[],teInfo.charS1,teInfo.lineS1,teInfo.charS2,teInfo.lineS2)
              ->test4;
            (' positions before (1 dim)',
             (teInfo.lineS1,teInfo.charS1)->theSifTextEditor.LineChartoPos,
             (teInfo.lineS2,teInfo.charS2)->theSifTextEditor.LineChartoPos)
              ->test2;
            
        if);
        (if useExternalTextEditor then
            false->useExternalTextEditor;
            TEinfo.textBefore[]->externalTextEdit->TEinfo.TextAfter[];
            (teInfo.posStartBefore,teInfo.posEndBefore)
              ->theSifTextEditor.contents.selection;
            theSifTextEditor.contents.delete;
            (teInfo.posStartBefore,teInfo.posStartBefore)
              ->theSifTextEditor.contents.selection;
            TEinfo.textAfter[]->theSifTextEditor.contents.insert;
            false->textEditMode;
            (TEexit.parseMode,(none ,1,0,0))->TE.exitEditAndParseMode
        if);
        
     #);
   exitEditAndParseMode:
     (#
        exitKind: @integer;
        outLineS2,outCharS2: @integer;
        posEndAfter: @integer;
        newCs: @astFocus;
        textToParse,help,tt: ^text;
        parseOk,OKtoParse: @boolean;
        instring: @boolean;
        parsingOK:< (#  do (*'parsing OK'->putLine;*) INNER #);
        parsingNotOK:< (#  do (*'parsing not OK'->putLine;*) INNER #);
        
     enter (exitKind,newCS)
     do
        (if switch[4] then
            'exitEditAndParseMode: '->putText;
            '<'->put;
            exitKind->putInt;
            '>'->put;
            newLine
        if);
        parsing:
          (#
             myerrorReporter: mps.errorReporter
               (#
                  beforeFirstError::<  (#  do parsingNotOK;  #);
                  afterLastError::<  (#  do  #);
                  forEachError::< 
                    (# alertText: ^text
                    do
                    (*'streamPos,startLineNo,errorLines,errorPos{Inx},legalSymbols[]'->screen.putLine;
                     streamPos->screen.putInt;' '->screen.put;*)
                       (teInfo.posStartBefore+streamPos-1,teInfo.posStartBefore+
                        streamPos-1)->theSifTextEditor.contents.selection;
                       'Parse error'->alertText[];
                       alertText.newLine;
                       alertText.newLine;
                       'Expected symbol'->alertText.putText;
                       (if legalSymbols.terminals.range
                        // 1 then ': '->alertText.putLine; 
                        else
                           's: '->alertText.putLine
                       if);
                       (for i: legalSymbols.terminals.range repeat
                         legalSymbols.terminals[i][]->alertText.putText;
                         ' '->alertText.put
                       for);
                       (none ,alertText[],'Alert')->UI.alertUser;
                       theSifTexteditor.contents[]->target;
                       leave parsing;
                       
                    #);
                  
               #);
             
          do
             (if switch[4] then
                 ('positions before (2 dim)',teInfo.charS1-1,teInfo.lineS1-1,
                  teInfo.charS2-1,teInfo.lineS2-1)->test4;
                 ('positions before (2 dim)',teInfo.charS1-1,teInfo.lineS1-1,
                  teInfo.charS2-1,teInfo.lineS2-1)->test4;
                 ('positions before (1 dim)',teInfo.posStartBefore,
                  teInfo.posEndBefore)->test2;
                 ('last position before and after',teInfo.lastPosBefore,
                  theSifTextEditor.lastPosition)->test2;
                 
             if);
             teInfo.posEndBefore+theSifTextEditor.lastPosition-
             teInfo.lastPosBefore
               -> (* determine extent of edited text: *) posEndAfter;
             (if switch[4] then
                 ('positions after',teInfo.posStartBefore,posEndAfter)->test2; 
             if);
             posEndAfter->theSifTextEditor.posToLineChar->(outLineS2,outCharS2);
             (if switch[4] then
                 ('outCharS2, outLineS2',outCharS2,outLineS2)->test2; 
             if);
             (if (outLineS2 <> 0) and (outCharS2 <> 0) then
                 (if (* tell the pretty printer how to update the SAST *)
                 (teInfo.oldLength = 1) then
                     (teInfo.oldNode[],outLineS2-teInfo.lineS2,outCharS2-
                      teInfo.charS2)->astView.pp.resized;
                     
                  else
                     (if (teInfo.sonNo = teInfo.fatherNode.noOfSons) then
                         (teInfo.fatherNode[],outLineS2-teInfo.lineS2,outCharS2-
                          teInfo.charS2)->astView.pp.resized;
                         
                      else
                         (teInfo.fatherNode[],outLineS2-teInfo.lineS2,0)
                           ->astView.pp.resized;
                         
                     if);
                     
                 if)
              else
                 'exitEditAndParseMode: posToLineChar returned (0,0)'->putLine
             if);
             (if (* text editor exited by a key stroke or menu *) exitKind
              // TEexit.escape then
              (* (if teInfo.inList then
               'inList'->putLine;
               (teInfo.listNode[],
               (teInfo.sonNo+teInfo.oldLength = teInfo.oldNoOfSons))
               ->updateList
               else
               'not inList'->putLine;
               (if teInfo.fatherNode[] <> none then
               (teInfo.fatherNode[],teInfo.fatherNode[])
               ->astView.pp.update
               else
               (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update
               if);
               cs->astToSelection
               if);
               *)
                 doReprettyprint;
                 (*  (if (teInfo.oldLength = 1) then
                  (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update;
                  cs->astToSelection;
                  
                  else
                  (teInfo.fatherNode[],teInfo.fatherNode[])
                  ->astView.pp.update;
                  
                  if);*)
                 structureMode->editingMode;
                 
              // TEexit.exitMode // TEexit.parseMode then
              (* normal exit 
               parse the edited text *)
                 &text[]->textToParse[];
                 textToParse.reset;
                 ascii.newLine->textToParse.put;
                 (teInfo.posStartBefore,posEndAfter)
                   ->theSifTextEditor.contents.scantext
                     (# 
                     do
                        (if true
                         // (ch > ' ') (*and (ch <= '~') *) // ch = ascii.sp
                         // ch = ascii.newLine then
                            ch->textToParse.put
                        if)
                     #);
                 (if textToParse[]->teInfo.textBefore.equal then
                     (if (teInfo.oldLength = 1) then
                         (teInfo.oldNode[],teInfo.oldNode[])->astView.pp.update;
                         
                      else
                         (teInfo.fatherNode[],teInfo.fatherNode[])
                           ->astView.pp.update;
                         
                     if);
                     cs->astToSelection;
                     structureMode->editingMode;
                     
                  else
                     (if switch[4] then
                         ' ['->help[];
                         textToParse[]->help.putText;
                         '] '->help.putText;
                         help[]->screen.putLine;
                         (help[],teInfo.charS1,teInfo.lineS1,outCharS2,
                          outLineS2)->test4;
                         
                     if);
                     (if textToParse.length > 0 then
                         false->OKtoParse;
                         textToParse.scanAll
                           (# 
                           do
                              (if not (ch->ascii.isSpace) then
                                  true->OKtoParse
                              if)
                           #);
                         
                     if);
                     (if OKtoParse then
                         (if not (textToParse[]->isComment) then
                             textToParse.newLine;
                             textToParse.reset;
                             true->cs.undoPermit;
                             &myErrorReporter[]->mps.theErrorReporter[];
                             (cs,textToParse[])->parseText->(parseOK,cs);
                             (if (* now cs is updated *) parseOk then
                                 structureMode->editingMode;
                                 (if newCS.node[] = none then
                                     cs->setFocus
                                  else
                                     newCS->setFocus
                                 if);
                                 parsingOK;
                                 
                              else
                             (* parse error *)
                                 true->texteditMode;
                                 &text[]->tt[];
                                 textToParse.scanAll
                                   (# 
                                   do
                                      (if ch
                                       // '''' then
                                          not inString->inString; ch->tt.put
                                       // ascii.sp then
                                          (if inString then
                                              ch->tt.put
                                           else
                                              tt.newLine
                                          if)
                                       else
                                          ch->tt.put
                                      if)
                                   #);
                                 '       '->tt.putLine;
                                 tt.reset;
                                 (tt[],screen[])->ag.parser.errorReport
                             if)
                          else
                             (none ,
                              'To comment out code, you currently have to textedit the enclosing block',
                              'It is a comment')->UI.alertUser;
                             (if (teInfo.oldLength = 1) then
                                 (teInfo.oldNode[],teInfo.oldNode[])
                                   ->astView.pp.update;
                                 
                              else
                                 (teInfo.fatherNode[],teInfo.fatherNode[])
                                   ->astView.pp.update;
                                 
                             if);
                             cs->astToSelection;
                             structureMode->editingMode
                         if);
                         
                      else
                         cut;
                         structureMode->editingMode;
                         newCS->setFocus;
                         parsingOK;
                         
                     if);
                     
                 if)
             if)
          #);
        edenv.mpsErrorReporter[]->mps.theErrorReporter[];
        
     #)
#)  

-- doTextedit: DoPart --
do
   (if switch[4] then 'doTextEdit'->putLine if);
   true->textEditMode;
   (if ch = 0 then
         (# pos1,pos2: @integer
         do
            (if switch[4] then 'enter textediting, preliminary'->putLine if);
            theSifTextEditor.contents.selection->(pos1,pos2);
            (pos1,pos1)->theSifTextEditor.contents.selection
         #)
   if);
     (# unExp: ^astInterface.unexpanded; synCatNo: @mps.nonterminalSymbol; 
     do
        (if (cs.length = 1) then
            (if cs.node.kind
             // mps.kinds.unexpanded then
                cs.node[]->getSynCatNo->synCatNo;
                (if syncatNo.isLexem then
                    cs.node[]->unExp[];
                    (if unExp.nonterminalSymbol
                     // mps.prodNo.nameDecl // mps.prodNo.nameAppl
                     // mps.prodNo.string then
                        (if parsingPossible then
                            TE.enterEditAndParseMode; 
                         else
                            TE.enterEditLexemMode
                        if)
                     // mps.prodNo.const then
                        TE.enterEditLexemMode
                     else
                        (if parsingPossible then
                            TE.enterEditAndParseMode
                         else
                            (none ,
                             'No parser available\nText editing is only allowed on lexems',
                             'Alert')->UI.alertUser;
                            
                        if)
                    if)
                 else
                    (if parsingPossible then
                        TE.enterEditAndParseMode
                     else
                        (none ,
                         'No parser available\nText editing is only allowed on lexems',
                         'Alert')->UI.alertUser;
                        
                    if)
                if);
                
             // mps.kinds.nameDecl // mps.kinds.nameAppl // mps.kinds.string
             then
                (if parsingPossible then
                    TE.enterEditAndParseMode; 
                 else
                    TE.enterEditLexemMode
                if)
             // mps.kinds.const then
                TE.enterEditLexemMode
             else
                (if parsingPossible then
                    TE.enterEditAndParseMode
                 else
                    (none ,
                     'No parser available\nText editing is only allowed on lexems',
                     'Alert')->UI.alertUser;
                    
                if);
                
            if);
            
         else
            (if parsingPossible then
                TE.enterEditAndParseMode
             else
                (none ,
                 'No parser available\nText editing is only allowed on one lexem at a time',
                 'Alert')->UI.alertUser;
                
            if);
            
        if);
        ;
        
     #)  

-- doExternalTextEdit: DoPart --
do true->TE.useExternalTextEditor; doTextedit  

-- checkTexteditingFinished: Descriptor --
(#
   posEndAfter,outCharS2,outLineS2,startPos,endPos: @integer; newCS: @astFocus
do
   (if switch[4] then
       'checkTextEditingFinished'->putLine;
       'start,end: '->putLine;
       start->putInt;
       ' '->put;
       end->putInt;
       newLine
   if);
   TE.teInfo.posEndBefore+theSifTextEditor.lastPosition-TE.teInfo.lastPosBefore
     -> (* determine extent of edited text: *) posEndAfter;
   (if
   ((start < TE.teInfo.posStartBefore) or (end < TE.teInfo.posStartBefore) or
    (start > posEndAfter) or (end > posEndAfter)) then
       (start,end)->selectionToAST->newCS;
       (if editingMode
        // editAndParseMode then
           false->textEditMode;
           (TEexit.parseMode,newCS)->TE.exitEditAndParseMode
        // editLexemMode then
           false->textEditMode; (TEexit.exitMode,newCS)->TE.exitEditLexemMode; 
       if)
   if)
#)  

-- doParseText: DoPart --
do
   (if switch[4] then 'doParseText'->putLine;  if);
   false->textEditMode;
   (if editingMode
    // editAndParseMode then
       (TEexit.parseMode,(none ,0,0,0))->TE.exitEditAndParseMode; 
    // editLexemMode then
       (TEexit.exitMode,(none ,0,0,0))->TE.exitEditLexemMode; 
   if)  

-- doRevertTextediting: DoPart --
do
   (if switch[4] then 'doRevertTextedit'->putLine;  if);
   false->textEditMode;
   edenv.mpsErrorReporter[]->mps.theErrorReporter[];
   (if editingMode
    // editAndParseMode then
       (TEexit.escape,cs)->TE.exitEditAndParseMode; 
    // editLexemMode then
       (TEexit.escape,cs)->TE.exitEditLexemMode; 
   if)  

-- doShowTexteditingCommands: DoPart --
do   

