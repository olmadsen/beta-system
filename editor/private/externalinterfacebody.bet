ORIGIN '../codeeditor';
-- externalInterfaceUndo: DoPart --
do
   
   (if edenv.trace[11] then
       'Sif ******** External interface: undo'->screen.putline; 
   if);
   THIS(codeeditor).undo  

-- externalInterfaceCut: DoPart --
do
   (if edenv.trace[11] then
       'Sif ******** External interface: cut'->screen.putline; 
   if);
   true->cs.undoPermit;
   THIS(codeeditor).cut  

-- externalInterfaceCopy: DoPart --
do
   (if edenv.trace[11] then
       'Sif ******** External interface: copy'->screen.putline; 
   if);
   THIS(codeeditor).copy  

-- externalInterfacePaste: DoPart --
do
   (if edenv.trace[11] then
       'Sif ******** External interface: paste'->screen.putline; 
   if);
   true->cs.undoPermit;
   THIS(codeeditor).paste  

-- externalInterfacePasteBefore: DoPart --
do   

-- externalInterfacePasteAfter: DoPart --
do   

-- externalInterfaceBefore: DoPart --
do
   (if edenv.trace[11] then
       'Sif ******** External interface: before'->screen.putline; 
   if);
   true->cs.undoPermit;
   ins.before->listInsert  

-- externalInterfaceAfter: DoPart --
do
   (if edenv.trace[11] then
       'Sif ******** External interface: after'->screen.putline; 
   if);
   true->cs.undoPermit;
   ins.after->listInsert  

-- externalInterfaceChangeFocus: DoPart --
do
   frejaEditTypeStatus.clear;
   frejaExpandStatus.clear;
   true->frejaStatusOn;
   notifyFreja->oldNotifyFreja;
   false->notifyFreja;
   (node[],length,0,0)->setFocus;
   oldNotifyFreja->notifyFreja  

-- externalInterfaceGetStatus: DoPart --
do
   frejaEditTypeStatus.clear;
   frejaExpandStatus.clear;
   true->frejaStatusOn;
   notifyFreja->oldNotifyFreja;
   false->notifyFreja;
   updateExpandMenu;
   updateEditMenu;
   oldNotifyFreja->notifyFreja;
     

-- externalInterfaceExpandNormal: DoPart --
do true->cs.undoPermit; (synCatNo,true)->&nodeExpand  

-- externalInterfaceExpandOptional: DoPart --
do
   (if synCatNo
    // 0 then
       'no syntactic category'->screen.putLine; 
    // 1 then
       true->cs.undoPermit; &makeEmptyListOrOpt; 
    else
       (if (synCatNo > 0) then
           true->cs.undoPermit; (synCatNo,true)->&nodeExpand; 
        else
           'expandNormal: synCatNo<0 - nothing done'->screen.putline
       if);
       
   if)  

-- externalInterfaceExpandLexem: DoPart --
do true->cs.undoPermit; theText[]->THIS(codeeditor).expandLexem  

-- externalInterfaceInsertOptionals: DoPart --
do cs.node[]->THIS(codeeditor).insertOptionals  

-- externalInterfaceRemoveOptionals: DoPart --
do cs.node[]->THIS(codeeditor).removeOptionals  

-- externalInterfaceParse: DoPart --
do
     (#
        theParseText: ^Text;
        myParseText:
          (#
             textToParse,parseErrorText: ^text;
             parseOK: @boolean;
             myErrorPos: @integer
          enter textToParse[]
          do
             parsing:
               (#
                  myerrorReporter: mps.errorReporter
                    (#
                       beforeFirstError::<  (#  do  #);
                       afterLastError::<  (#  do  #);
                       forEachError::< 
                         (# 
                         do
                         (*'streamPos,startLineNo,errorLines,errorPos{Inx},legalSymbols[]'->screen.putLine;
                          streamPos->screen.putInt;' '->screen.put;*)
                            streamPos-1->myErrorPos;
                            'Parse error'->parseErrorText[];
                            parseErrorText.newLine;
                            parseErrorText.newLine;
                            'Expected symbol'->parseErrorText.putText;
                            (if legalSymbols.terminals.range
                             // 1 then ': '->parseErrorText.putLine; 
                             else
                                's: '->parseErrorText.putLine
                            if);
                            (for i: legalSymbols.terminals.range repeat
                              legalSymbols.terminals[i][]
                                ->parseErrorText.putText;
                              ' '->parseErrorText.put
                            for);
                            leave parsing;
                            
                         #);
                       
                    #);
                  
               do (*exitTextEditing; *)
                  0->textToParse.setPos;
                  &myErrorReporter[]->mps.theErrorReporter[];
                  (cs,textToParse[])->THIS(codeeditor).parseText->(parseOK,cs);
                  (if (* now cs is updated *) parseOk then
                      selectNewCS; 
                   else
                  (* parse error *)
                        (# 
                        do
                           textToParse.reset;
                           (textToParse[],none )->ag.parser.errorReport;
                           
                        #);
                      
                  if)
               #)
          exit (parseOK,parseErrorText[],myErrorPos)
          #)
     do
        ''->theParseText[];
        parseText.scanAll
          (# 
          do
             (if (ch > ' ') and (ch <= '~') then
                 (if edenv.trace[1] then
                     'ch<'->screen.puttext;
                     ch->screen.putInt;
                     ':'->screen.put;
                     ch->screen.put;
                     '>'->screen.putLine;
                     
                 if);
                 ch->theParseText.put;
                 
              else
                 ;
                 (if (ch = ascii.sp) then
                     (if edenv.trace[1] then
                         'sp<'->screen.puttext;
                         ch->screen.putInt;
                         ':'->screen.put;
                         ch->screen.put;
                         '>'->screen.putLine;
                         
                     if);
                     ch->theParseText.put;
                     
                 if);
                 (if (ch = ascii.newLine) then
                     (if edenv.trace[1] then
                         'nl.<'->screen.putText;
                         ch->screen.putInt;
                         ':'->screen.put;
                         ch->screen.put;
                         '>'->screen.putLine;
                         
                     if);
                     ch->theParseText.put;
                     
                 if)
             if)
          #);
        (if edenv.trace[1] then
            node.index->screen.putInt;
            '  ['->screen.putText;
            theparseText[]->screen.putText;
            '] '->screen.putLine
        if);
        (node[],1,0,0)->setFocus;
        (if theParseText.lgth = 0 then
            true->cs.undoPermit; cut; true->OK
         else
            theParseText[]->myParseText->(OK,parseErrorText[],errorPos)
        if);
        (if OK then true->cs.undoPermit if);
        
     #)  

-- externalInterfaceSearch: DoPart --
do doSearch  

