ORIGIN '../codeeditor';
INCLUDE '../searchdialog';
(*
 * COPYRIGHT
 * Copyright Mjolner Informatics, 1986-96
 * All rights reserved.
 *)
-- searchPrivate: Descriptor --
(#
   theSearchName: ^text;
   searchNode: ^astInterface.ast;
   textWithFindSub: text
     (#
        FindCh:
        (* Finds all occurences of ch:
         * For 'inx' where THIS(text).inx=ch do inner
         *)
          (# inx: @integer; ch: @char
          enter ch
          do
             (for i: lgth repeat
               (if T[i->inx]->ascii.upCase
                // ch->ascii.upCase then INNER
               if)
             for)
          #);
        findSubstring:
          (# texttofind: ^text; firstch: @char; startInx: @integer; 
          enter texttofind[]
          do
             1->texttofind.inxget->firstch
               ->findCh
                 (# foundtext: ^text; 
                 do
                    (inx,inx+texttofind.length-1)->sub->foundtext[];
                    (if (foundtext[]->texttofind.equalNCS) then
                        inx->startInx; INNER findSubstring; 
                    if)
                 #)
          #);
        isSubstring:
          (# string: ^text; found: @boolean; startInxOfString: @integer; 
          enter string[]
          do
             FALSE->found;
             l:
             string[]
               ->findSubstring
                 (#  do TRUE->found; startInx->startInxOfString; leave l #);
             
          exit (found,startInxOfString)
          #);
        
     #);
   search:
     (#
        direction: @integer;
        current: ^astInterface.ast;
        csIsMatching: @boolean;
        
     enter direction
     do
        cs.node[]->current[];
        true->csIsMatching;
        loop:
          (# 
          do
             (if (searchPrivate.searchNode[]->cs.node.match) then
                 (if csIsMatching then
                     direction->&select; restart loop; 
                  else
                     (cs.node[],1,0,0)->setFocus; 
                 if);
                 
              else
                 false->csIsMatching;
                 direction->&select;
                 (if (current[]->cs.node.equal) then
                     'Fragment not found'->screen.putText;
                     screen.newLine;
                     leave loop;
                     
                  else
                     restart loop; 
                 if);
                 
             if);
             
          #);
        
     #);
   searchName:
     (#
        direction: @integer;
        current: ^astInterface.ast;
        lexText: ^astInterface.lexemText;
        help: ^text;
        help2: @searchPrivate.textWithFindSub;
        found: @boolean;
        startInx: @integer;
        
     enter direction
     do
        (if theSearchName[] <> none then
            (if (theSearchName.length > 0) then
                cs.node[]->current[];
                loop:
                  (# 
                  do
                     direction->select;
                     (if (current[]->cs.node.equal) then
                         false->found; leave loop; 
                     if);
                     (if cs.node.kind
                      // mps.kinds.nameDecl // mps.kinds.nameAppl
                      // mps.kinds.string then
                         cs.node[]->lexText[];
                         lexText.getText->help[];
                         help->help2;
                         theSearchname[]->help2.isSubstring->(found,startInx);
                         (if found then
                             (cs.node[],1,0,0)->setFocus; 
                          else
                             restart loop; 
                         if);
                         
                      else
                         restart loop; 
                     if);
                     
                  #);
                
            if)
        if);
        
     exit found
     #);
   editLexem:
     (#
        node: ^astInterface.ast;
        oldText,newText: ^text;
        lexText: ^astInterface.lexemText;
        help: ^text;
        help2: @searchPrivate.textWithFindSub;
        found: @boolean;
        startInx: @integer
     enter (node[],oldText[],newText[])
     do
        thisOp:
        (if (node[] <> none ) and (oldText[] <> none ) and (newText[] <> none )
         then
            (if node.kind
             // mps.kinds.nameDecl // mps.kinds.nameAppl // mps.kinds.string
             then
                (if node.kind
                 // mps.kinds.nameDecl // mps.kinds.nameAppl then
                    newText.scanAll
                      (# 
                      do
                         (if not
                         (((ch >= 'a') and (ch <= 'z')) or
                          ((ch >= 'A') and (ch <= 'Z')) or
                          ((ch >= '0') and (ch <= '9'))) then
                             'Not valid lexem'->putLine; leave thisOp
                         if)
                      #)
                if);
                node[]->lexText[];
                lexText.getText->help[];
                help->help2;
                oldText[]->help2.isSubstring->(found,startInx);
                (if found then
                    (startInx,startInx+oldText.length-1)->help.delete;
                    (newText[],startInx)->help.insert;
                    help[]->lexText.putText;
                    true->cs.undoPermit;
                    (node.father,node.sonNo,cs,1,false)->makeUndoElem;
                    makeASTreplacedEvent;
                    cs->setFocus
                 else
                    oldText[]->putText;
                    ' not found in: '->putText;
                    newText[]->putLine;
                    
                if)
            if)
        if)
     #);
   
#)  

-- Searchtextbody: Descriptor --
(#
   synCatNo: @mps.nonterminalSymbol;
   isList: @boolean;
   current: ^astInterface.ast;
   rootNode: ^astInterface.expanded;
   theListElement: ^astInterface.ast;
   
do
   cs.node[]->parsingSynCatNo->(synCatNo,isList,theListElement[]);
   0->t.setPos;
   (synCatNo,screen[],t[],frag[])->ag.parser->parseOK;
   (if parseOK then dir.down->searchPrivate.search;  if);
   
#)  

-- searchStructureBody: Descriptor --
(# 
do cs.node[]->searchPrivate.searchNode[]; dir.down->searchPrivate.search; 
#)  

-- searchNextBody: Descriptor --
(#  do dir.down->searchPrivate.searchName->found #)  

-- searchPrevBody: Descriptor --
(#  do dir.up->searchPrivate.searchName->found #)  

-- searchNameBody: Descriptor --
(#
   exp: ^astInterface.expanded;
   lexText: ^astInterface.lexemText;
   help: ^text;
   help2: @searchPrivate.textWithFindSub;
   startInx: @integer;
   
do
   (if editorRoot.kind
    // mps.kinds.interior then
       editorRoot[]->exp[];
       search: exp.suffixWalk
         (# 
         do
            (if current.kind
             // mps.kinds.nameDecl // mps.kinds.nameAppl // mps.kinds.string
             then
                current[]->lexText[];
                lexText.getText->help[];
                help->help2;
                name[]->help2.isSubstring->(found,startInx);
                (if found then
                    name[]->searchPrivate.theSearchName[];
                    (current[],1,0,0)->setFocus;
                    leave search;
                    
                if);
                
            if);
            
         #);
       (if not found then &text[]->searchPrivate.theSearchName[];  if)
   if)
#)  

-- doSearch: DoPart --
do
     (#
        searchd: @UI.search
          (#
             next:: 
               (# 
               do
                  doCommand
                    (# 
                    do
                       (if theSifTextEditor[] <> none then
                           (if searchPrivate.theSearchName[] = none then
                               ''->searchPrivate.theSearchName[]
                           if);
                           (if searchPrivate.theSearchName[]->userText.equal
                            then
                               searchNext
                            else
                               (if not (userText[]->searchName) then
                                   (none ,' not found'->(usertext.copy).Append,
                                    'Search')->UI.alertUser
                               if)
                           if)
                        else
                           'not active'->putline
                       if)
                    #)
               #);
             previous:: 
               (# 
               do
                  doCommand
                    (# 
                    do
                       (if theSifTextEditor[] <> none then
                           searchPrev
                        else
                           'not active'->putline
                       if)
                    #)
               #);
             cancel::  (#  do  #);
             
          #);
        help: ^text
     do
        searchd.open;
        ((frag.father).name).copy->fragmentDefaultName->help[];
        '-'->help.append;
        frag.name->help.append;
        (none ,help[],'Search in lexems for:',searchPrivate.theSearchName[])
          ->searchd.popup
     #)  

-- doReplace: DoPart --
do
     (#
        replaced: @UI.replaceWindow
          (#
             next:: 
               (# 
               do
                  doCommand
                    (# 
                    do
                       (if theSifTextEditor[] <> none then
                           (if searchPrivate.theSearchName[] = none then
                               ''->searchPrivate.theSearchName[]
                           if);
                           (if searchPrivate.theSearchName[]->searchText.equal
                            then
                               searchNext
                            else
                               (if not (searchText[]->searchName) then
                                   (none ,' not found'->(searchtext.copy).Append,
                                    'Search')->UI.alertUser
                               if)
                           if)
                        else
                           'not active'->putline
                       if)
                    #)
               #);
             previous:: 
               (# 
               do
                  doCommand
                    (# 
                    do
                       (if theSifTextEditor[] <> none then
                           searchPrev
                        else
                           'not active'->putline
                       if)
                    #)
               #);
             replace:: 
               (# 
               do
                  doCommand
                    (# 
                    do
                       (if theSifTextEditor[] <> none then
                           (cs.node[],searchText[],replaceText[])
                             ->searchPrivate.editLexem;
                           searchNext
                        else
                           'not active'->putline
                       if)
                    #)
               #);
             cancel::  (#  do  #);
             
          #);
        help: ^text
     do
        replaced.open;
        ((frag.father).name).copy->fragmentDefaultName->help[];
        '-'->help.append;
        frag.name->help.append;
        (none ,help[],'Search in lexems for:','Replace with:',
         searchPrivate.theSearchName[])->replaced.popup
     #)  

