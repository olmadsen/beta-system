ORIGIN '../codeviewer';
INCLUDE '../searchdialog';
(*
 COPYRIGHT
 Copyright Mjolner Informatics, 1986-94
 All rights reserved.
 *)
-- searchPrivate: Descriptor --
(#
   searchNode: ^astInterface.ast;
   theSearchName: ^text;
   textWithFindSub: text
     (#
        FindCh:
        (* Finds all occurences of ch:
         * For 'inx' where THIS(text).inx=ch do inner
         *)
          (# inx: @integer; ch: @char
          enter ch
          do
             (for i: lgth repeat
               (if T[i->inx]->ascii.upCase
                // ch->ascii.upCase then INNER
               if)
             for)
          #);
        findSubstring:
          (# texttofind: ^text; firstch: @char; 
          enter texttofind[]
          do
             1->texttofind.inxget->firstch
               ->findCh
                 (# foundtext: ^text; 
                 do
                    (inx,inx+texttofind.length-1)->sub->foundtext[];
                    (if (foundtext[]->texttofind.equalNCS) then
                        INNER findSubstring; 
                    if)
                 #)
          #);
        isSubstring:
          (# string: ^text; found: @boolean; 
          enter string[]
          do
             FALSE->found;
             l: string[]->findSubstring (#  do TRUE->found; leave l #);
             
          exit found
          #);
        
     #);
   search:
     (#
        direction: @integer;
        current: ^astInterface.ast;
        csIsMatching: @boolean;
        
     enter direction
     do
        cs.node[]->current[];
        true->csIsMatching;
        loop:
          (# 
          do
             (if (searchPrivate.searchNode[]->cs.node.match) then
                 (if csIsMatching then
                     direction->&select; restart loop; 
                  else
                     (cs.node[],1,0,0)->setFocus; 
                 if);
                 
              else
                 false->csIsMatching;
                 direction->&select;
                 (if (current[]->cs.node.equal) then
                     'Fragment not found'->screen.putText;
                     screen.newLine;
                     leave loop;
                     
                  else
                     restart loop; 
                 if);
                 
             if);
             
          #);
        
     #);
   searchName:
     (#
        direction: @integer;
        current: ^astInterface.ast;
        lexText: ^astInterface.lexemText;
        help: ^text;
        help2: @searchPrivate.textWithFindSub;
        found: @boolean;
        
     enter direction
     do
        (if (searchNode[] <> none ) and (theSearchName[] <> none ) then
            (if (theSearchName.length > 0) then
                cs.node[]->current[];
                loop:
                  (# 
                  do
                     direction->select;
                     (if (current[]->cs.node.equal) then false->found;  if);
                     (if cs.node.kind
                      // mps.kinds.nameDecl // mps.kinds.nameAppl
                      // mps.kinds.string then
                         cs.node[]->lexText[];
                         lexText.getText->help[];
                         help->help2;
                         (if (theSearchName[]->help2.isSubString) then
                             true->found;
                             cs.node[]->searchPrivate.searchNode[];
                             (cs.node[],1,0,0)->setFocus;
                             
                          else
                             restart loop; 
                         if);
                         
                      else
                         restart loop; 
                     if);
                     
                  #);
                
            if)
        if);
        
     exit found
     #);
   
#)  

-- Searchtextbody: Descriptor --
(#
   synCatNo: @mps.nonterminalSymbol;
   isList: @boolean;
   current: ^astInterface.ast;
   rootNode: ^astInterface.expanded;
   theListElement: ^astInterface.ast;
   
do
   cs.node[]->parsingSynCatNo->(synCatNo,isList,theListElement[]);
   0->t.setPos;
   (synCatNo,screen[],t[],frag[])->ag.parser->parseOK;
   (if parseOK then
       (if isList then
           editorRoot[]->rootNode[];
           1->rootNode.get->searchPrivate.searchNode[];
           
        else
           editorRoot[]->searchPrivate.searchNode[]; 
       if);
       dir.down->searchPrivate.search;
       
   if);
   
#)  

-- searchStructureBody: Descriptor --
(# 
do cs.node[]->searchPrivate.searchNode[]; dir.down->searchPrivate.search; 
#)  

-- searchNextBody: Descriptor --
(#  do dir.down->searchPrivate.searchName->found #)  

-- searchPrevBody: Descriptor --
(#  do dir.up->searchPrivate.searchName->found #)  

-- searchNameBody: Descriptor --
(#
   exp: ^astInterface.expanded;
   lexText: ^astInterface.lexemText;
   help: ^text;
   help2: @searchPrivate.textWithFindSub;
   
do
   (if editorRoot.kind
    // mps.kinds.interior then
       editorRoot[]->exp[];
       search: exp.suffixWalk
         (# 
         do
            (if current.kind
             // mps.kinds.nameDecl // mps.kinds.nameAppl // mps.kinds.string
             then
                current[]->lexText[];
                lexText.getText->help[];
                help->help2;
                (if (name[]->help2.isSubString) then
                    true->found;
                    exp[]->searchPrivate.searchNode[];
                    name[]->searchPrivate.theSearchName[];
                    (current[],1,0,0)->setFocus;
                    leave search;
                    
                if);
                
            if);
            
         #);
       (if not found then
           none ->searchPrivate.searchNode[];
           &text[]->searchPrivate.theSearchName[];
           
       if)
   if)
#)  

-- doSearch: DoPart --
do
     (#
        searchd: @UI.search
          (#
             next:: 
               (# 
               do
                  (if searchPrivate.theSearchName[] = none then
                      ''->searchPrivate.theSearchName[]
                  if);
                  (if searchPrivate.theSearchName[]->userText.equal then
                      searchNext
                   else
                      (if not (userText[]->searchName) then
                          (none ,' not found'->usertext.copyAppend,'Search')
                            ->UI.alertUser
                      if)
                  if)
               #);
             previous::  (#  do searchPrev #);
             cancel::  (#  do  #);
             
          #);
        help: ^text
     do
        searchd.open;
        ((frag.father).name).copy->fragmentDefaultName->help[];
        '-'->help.append;
        frag.name->help.append;
        (theSifTexteditor.theWindow,help[],'Search for:',
         searchPrivate.theSearchName[])->searchd.popup
     #)  

