ORIGIN '../codeeditor';
(*
   COPYRIGHT
	 Copyright Mjolner Informatics, 1986-94
	 All rights reserved.
 *)
-- makeUndoElemBody: Descriptor --
(# elmNo: @integer; 
do
   trace
     (#  do 'makeUndoElem'->str[] #);
   fatherNode[]->undoElem.fatherRef[];
   undoFocus.node[]->undoElem.fragments.elm[1][];
   undoFocus.length->undoElem.FragmentLength;
   undoLength->undoElem.undoLength;
   isDeleted->undoElem.isDeleted;
   (if (fatherNode[] = none )
    then
       0->undoElem.sonPos; 
   else
       sonPos->undoElem.sonPos;
       (if (1 < undoFocus.length)
       then
           (for i: (undoFocus.length-1) repeat
             (if i+1 > undoElem.fragments.elm.range then
                 undoElem.fragments.elm.range->undoElem.fragments.elm.extend
             if);
             sonPos+i->fatherNode.get->undoElem.fragments.elm[i+1][];
             
           for);
           none ->undoElem.fragments.elm[undoFocus.length+1][];
           
       if);
       
   if);
   
#)  

-- makeAstReplacedEventBody: Descriptor --
(# 
do
   (if (undoElem.fatherRef[] = none )
    then
       (if sequence then
           (undoElem.fragments.elm[1][],frag.root[])
             ->astReplacedList.appendElement
        else
           (undoElem.fragments.elm[1][],frag.root[])->anAstReplacedEvent
       if)
   else
       (if sequence then
           (undoElem.fragments.elm[1][],undoElem.sonPos->undoElem.fatherRef.get)
             ->astReplacedList.appendElement
        else
           (undoElem.fragments.elm[1][],undoElem.sonPos->undoElem.fatherRef.get)
             ->anAstReplacedEvent
       if)
   if);
   
#)  

-- getSynCatNoBody: Descriptor --
(# nontNode: ^mps.unExpanded
do
   trace
     (#  do 'getSynCatNo'->str[] #);
   (if
   ((node.kind = mps.kinds.unexpanded) or (node.kind = mps.kinds.optional))
    then
       node[]->nontNode[]; nontNode.nonterminalSymbol->synCatNo
   else
       node.symbol->synCatNo
   if)
#)  

-- setSynCatNoBody: Descriptor --
(# cons: ^mg.constructor; consList: ^mg.consElemList; sonIndex: @integer; 
do
   trace
     (#  do 'setSynCatNo'->str[] #);
   synCatNo->Prodlist.get->cons[];
   cons.getConsElemList->consList[];
   0->sonIndex;
   mg.synName
     -> (* nonterminals *) consList.suffixWalkForProd
       (#
          nontNode: ^mps.unexpanded;
          theAttribute: @integer;
          (* due to the compiler *)
          
       do (* son is now right hand side nonterminal *)
          1+sonIndex->sonIndex->programNode.get->nontNode[];
          1->current.getAttribute->theAttribute;
          theAttribute->nontNode.nonterminalSymbol;
          
       #);
   
#)  

-- findSynNameAttBody: Descriptor --
(# 
do
   trace
     (#  do 'findSynNameAtt'->str[] #);
   loop:
   mg.synName
     ->production.suffixWalkForProd
       (#  do 1->current.getAttribute->synCatNo; leave loop;  #);
   
#)  

-- showAstBody: Descriptor --
(# 
do
   trace
     (#  do 'showAst'->str[] #);
   (if edDebug
   then
       (1,screen[])->frag.root.dump;
       newLine;
       'cs.node.index/isSon: '->screen.putText;
       cs.node.index->putInt;
       ' '->put;
       (if (cs.node.father <> none ) then cs.node.sonNo->putInt if);
       newLine;
       (*test (# do 'Type <any key> <cr> to continue ...'->str #);
        getNonBlank;*)
       
   if);
   
#)  

