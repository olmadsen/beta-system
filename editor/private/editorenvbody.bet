ORIGIN '../codeeditor';
INCLUDE '~beta/basiclib/v1.5/directory'
        '~beta/pretty/v5.1/pplib'
        '~beta/mps/v5.1/propertyparser';
MDBODY nti 'editorenv_ntibody'
       mac 'editorenv_macbody'
       ppc 'editorenv_macbody'
       ppcmac 'editorenv_macbody'
       default 'editorenv_X11body';
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1995-96
 *	 All rights reserved.
 *)
-- editorenvSetGlobalWriteProtection: DoPart --
do
   value->globalWriteProtection;
   groupEditorList.scan
     (#  do value->current.setIsReadOnly #)  

-- editorenvMetaGrammarInit: Descriptor --
(#
   theMetaGrammar: ^astInterface.treelevel;
   grammarWithPath,help: ^text;
   gg: ^astInterface.fragmentGroup;
   bobsfile: @file
do
   (if mg[] = none then
       (if mps.grammarTable.meta[] <> none then
           mps.grammarTable.meta[]->mg[]; 
        else
           &mps.metaGrammar[]->theMetaGrammar[]->mps.grammarTable.meta[]->mg[];
           theMetaGrammar.init;
           '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
           ('-meta'->(grammarWithPath.copy).Append,screen[])->mps.top.open
             ->gg[];
           (if gg[]
            // none then
               'Could not open: '->screen.putText;
               '-meta'->(grammarWithPath.copy).Append->screen.putLine;
               (failure,'')->stop;
               
            else
               ('metagrammar',screen[])->gg.open->theMetagrammar.grammarAst[];
               (if theMetagrammar.grammarAst[]
                // none then
                   'No grammarAst for '->screen.putText;
                   grammarWithPath[]->screen.putLine;
                   (failure,'')->stop;
                   
                else
                   grammarWithPath[]->mps.expandToFullPath->help[];
                   '-parser'->help.append;
                   mps.parserFileExtension->help.append;
                   help[]->bobsFile.name;
                   (if bobsFile.entry.exists then
                       bobsFile.name->theMetagrammar.parser.initialize; 
                    else
                       'No parser available: '->screen.putText;
                       bobsFile.name->screen.putLine;
                       
                   if)
               if);
               
           if);
           
       if);
       
   if)
#)  

-- editorenvPrivate: Descriptor --
(#
   untitledNo (* used by newGroup and newBETAgroup *) : @integer;
   nextUntitled:
     (# t: ^text; 
     do
        untitledNo+1->untitledNo;
        'untitled'->t[];
        (if (untitledNo > 1)
         // true then t.length->t.setPos; untitledNo->t.putInt; 
        if)
     exit t.copy
     #);
   splitPath:
     (# e: @diskEntry;  enter e.path exit (e.path.head,e.path.name) #);
   splitFileName:
     (# e: @diskEntry; 
     enter e.path
     exit (e.path.name.prefix,e.path.name.suffix)
     #);
   stripExtension:
     (# e: @diskEntry; noExt: ^text; 
     enter e.path
     do
        e.path.head->noExt[];
        (if noExt.length > 0 then '/'->noExt.append if);
        e.path.name.prefix->noExt.append;
        
     exit noExt[]
     #);
   fileWriteable:
   (* test whether the path is OK and the dir can be written into and whether the file can be written
    on if the path is OK and the file exists *)
     (# f: @file enter f.name exit f.entry.writeable #);
   myRename:
     (# f: @file; newName: ^text
     enter (f.name,newName[])
     <<SLOT myRename:DoPart>>
     #);
   showEditors:
     (# 
     do
        'groupEditorList: '->putText;
        groupEditorList.size->putInt;
        newLine;
        groupEditorList.scan
          (# 
          do
             current.fg.name->putLine;
             'formEditorList: '->putText;
             current.formEditorList.size->putInt;
             newLine;
             current.formEditorList.scan
               (#  do current.frag.name->putLine #);
             
          #)
     #);
   doNewGroup:
     (#
        theFile,fragmentName,language: ^text;
        synCatNo: @integer;
        theBrowser: ^object;
        isAFrejaEditor: @boolean;
        fg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        doParse: @boolean;
        help,t,keepName: ^text;
        propText: ^text;
        status: @boolean;
        
     enter
     (theFile[],fragmentName[],language[],synCatNo,theBrowser[],isAFrejaEditor)
     do
        thisOperation:
          (# 
          do
             (if trace[3] then
                 'doNewGroup:'->putLine;
                 theFile[]->putLine;
                 fragmentName[]->putLine;
                 language[]->putLine;
                 synCatNo->putInt;
                 newLine
             if);
             (if (theFile[] <> none ) and (theFile.length > 0) then
                 groupEditorlist.scan
                   (# theGroupEditor: ^groupEditor
                   do
                      current[]->theGroupEditor[];
                      theFile[]->mps.expandToFullPath->help[];
                      (if
                      (theGroupEditor.fg.name->mps.expandToFullPath->help.equal)
                       then
                          (none ,'A group editor already exists','doNewGroup')
                            ->UI.alertUser;
                          leave thisOperation
                      if)
                   #);
                 (if (fragmentName[] <> none ) then
                     (if (fragmentName.length > 0) then
                         (if ('beta'->language.equal) then
                             theFile[]->mps.expandToFullPath
                               ->mps.top.newGroup
                                 (#
                                    alreadyOpen::<  (#  do true->continue #)
                                 #)->fg[];
                             betagrammar[]->fg.defaultGrammar[];
                             betagrammar[]->mps.newFragmentForm->ff[];
                             (if ymerCallback[] <> none then
                                 'ORIGIN '''->propText[];
                                 ymerCallBack.betaenvVersion->propText.append;
                                 ''''->propText.append;
                                 (if isAFrejaEditor then
                                     '; '->propText.append;
                                     'INCLUDE '''->propText.append;
                                     ymerCallBack.frejaInclude->propText.append;
                                     ''''->propText.putline
                                 if)
                              else
                                 'ORIGIN ''~beta/basiclib/v1.5/betaenv'''
                                   ->propText[];
                                 (if isAFrejaEditor then
                                     '; '->propText.putLine;
                                     'INCLUDE ''~beta/freja/v2.2/associations'''
                                       ->propText.putLine
                                 if)
                             if);
                             propText.reset;
                             l:
                             (propText[],screen[])
                               ->fg.parseProperty
                                 (#
                                    parseErrors::<
                                    (* exception called if parse-errors *) 
                                      (# 
                                      do
                                         'parse errors in the property list'
                                           ->screen.putLine;
                                         leave l;
                                         
                                      #);
                                    doubleFormDeclaration::<
                                    (* exception called if two fragmentForms with the same name *)
                                    
                                      (# 
                                      do
                                         ' this one is never called!!! double form declaration'
                                           ->screen.putLine;
                                         leave l
                                      #);
                                    
                                 #)->status;
                             (if synCatNo
                              // betaGram.descriptorForm then
                                 '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                                   ->t[];
                                 true->doParse;
                                 
                              // betaGram.attributesForm then
                                 '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                                   ->t[];
                                 true->doParse;
                                 
                              else
                                 '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                                   ->t[];
                                 true->doParse;
                                 
                             if);
                             (if doParse
                              // true then
                                 t.reset;
                                 (synCatNo,t[],screen[],ff[])
                                   ->betaGrammar.parser.doParse;
                                 
                             if);
                             fragmentName[]->ff.name;
                             ff[]->fg.fragmentList.addFragment;
                             ;
                             
                          else
                             theFile[]->mps.expandToFullPath
                               ->mps.top.newGroup
                                 (#
                                    alreadyOpen::<  (#  do true->continue #)
                                 #)->fg[];
                             (language[],screen[])
                               ->mps.grammarTable.find
                                 (#
                                    ifNotFound::< 
                                      (# help: @text
                                      do
                                         'Grammar: '->help;
                                         language[]->help.putText;
                                         ' not found'->help.putText;
                                         help[]->putLine;
                                         (none ,help[],'doNewGroup')
                                           ->UI.alertUser;
                                         leave thisOperation
                                      #);
                                    
                                 #)->mps.newFragmentForm->ff[];
                             fragmentName[]->ff.name;
                             ff[]->fg.fragmentList.addFragment;
                             ff.grammar[]->fg.defaultGrammar[]
                         if);
                         
                     if);
                     
                 if)
             if);
             
          #);
        
     exit fg[]
     #);
   newBETAprogOrLib:
     (#
        theBrowser: ^object;
        name,noExt: ^text;
        isAFrejaEditor: @boolean;
        type: @integer;
        fg: ^astInterface.fragmentGroup;
        t,ffName: ^text;
        synCatNo: @integer;
        help,language,title,mess,mess2: ^text;
        astFileName,textFileName: ^text;
        f,astFile,textFile: @file
     enter (theBrowser[],name[],type,isAFrejaEditor)
     do
        (if type
         // 1 (* program *) then
            'Program'->t[];
            betaGram.descriptorForm->synCatNo;
            'program'->ffName[]
         // 2 (* lib *) then
            'Library'->t[]; betaGram.attributesForm->synCatNo; 'lib'->ffName[]
        if);
        'New BETA '->title[];
        t[]->title.append;
        newprog:
          (# 
          do
             (if name[] = none then
             (*editorenvPrivate.nextUntitled->help[]; help.copy->f.name*)
                 loop:
                   (# 
                   do
                      UI.fileCreationDialog->name[];
                      (if (name[] <> none ) and (name.length > 0) then
                          name[]->f.name->stripExtension->noExt[]->f.name;
                          (if not (f.name->fileWriteable) then
                              (none ,'No write permission',title[])
                                ->UI.alertUser;
                              restart loop
                          if)
                       else
                          leave newprog
                      if)
                   #)
              else
                 name.copy->f.name->stripExtension->f.name
             if);
             name[]->f.name;
             name.copy->astFileName[];
             mps.astFileExtension->astFileName.append;
             astFileName[]->astFile.name;
             name.copy->textFileName[];
             '.bet'->textFileName.append;
             textFileName[]->textFile.name;
             (if f.entry.exists or astFile.entry.exists or
             textFile.entry.exists then
                 (if f.entry.exists then
                     (if f.entry.isDirectory then
                         (none ,'Is a directory',title[])->UI.alertUser;
                         leave newProg
                      else
                         name.copy->mess2[]
                     if)
                  else
                     (if textFile.entry.exists then
                         textFileName.copy->mess2[]
                      else
                         astFileName.copy->mess2[]
                     if)
                 if);
                 ' does already exist\nOverwrite?'->mess2.append;
                 (none ,title[],mess2[])
                   ->UI.promptForBoolean
                     (#
                        ok::< 
                          (# 
                          do
                             (noExt[],ffName[],'beta',synCatNo,theBrowser[],
                              isAfrejaEditor)->doNewGroup->fg[];
                             (if fg[]
                              // none then
                                 name[]->putText;
                                 ' fragment group not created'->putLine;
                                 
                              else
                                 (fg[],true)
                                   ->extendedMarkAsChanged
                                   (* this is done in order to
                                    open the new group in ymer *)
                             if)
                          #)
                     #)
              else
                 (noExt[],ffName[],'beta',synCatNo,theBrowser[],isAFrejaEditor)
                   ->doNewGroup->fg[];
                 (if fg[] = none then
                     name[]->putText; ' fragment group not created'->putLine; 
                  else
                     (if fg.name->mps.expandToFullPath->fileWriteable then
                         (fg[],true)
                           ->extendedMarkAsChanged
                           (* this is done in order to
                            open the new group in ymer *)
                     if)
                 if)
             if)
          #)
     exit fg[]
     #);
   ASTGC:
     (#
        fg: ^astInterface.fragmentGroup;
        ff,newff: ^astInterface.fragmentform;
        
     enter fg[]
     do
        fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[];
                 loop: ff.prop.scanProp
                   (#
                      doProp::< 
                        (# 
                        do
                           prop.makeLC;
                           (if ('touched'->prop.equal) then
                               'AST GC in '->putText;
                               ff.name->putText;
                               ' ('->putText;
                               ff.a.range->putInt;
                               '->'->putText;
                               ff.grammar[]->mps.newFragmentForm->newff[];
                               newff[]->ff.root.copy->newff.root[];
                               ff.name->newff.name;
                               ff.grammar[]->newff.grammar[];
                               fg[]->newff.father;
                               newff[]->current.f[];
                               newff.a.range->putInt;
                               ') '->putLine;
                               leave loop
                           if)
                        #);
                      
                   #);
                 
             if)
          #);
        
     #);
   recomputeSLOTchain:
     (# fg: ^astInterface.fragmentGroup; ff: ^astInterface.fragmentform; 
     enter fg[]
     do
        fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[];
                 loop: ff.prop.scanProp
                   (#
                      doProp::< 
                        (# msg: ^text
                        do
                           prop.makeLC;
                           (if ('touched'->prop.equal) then
                           (*'Recomputing slot chain for: '->msg[];
                            ff.name->msg.append;
                            msg[]->ymercallBack.infoView;*)
                               ff.recomputeSlotChain;
                               (*''->ymerCallBack.infoView;*)
                               leave loop
                           if)
                        #);
                      
                   #);
                 
             if)
          #);
        
     #);
   getGrammarName:
     (# g: ^astInterface.fragmentGroup; name: ^text; 
     enter g[]
     do
          (# ff: ^astInterface.fragmentForm; 
          do
             (if g[] <> none then
                 loop:
                 (if (g.fragmentList[] <> none )
                  // true then
                     g.fragmentList.scan
                       (# 
                       do
                          (if current.type
                           // mps.formType then
                              current.f[]->ff[];
                              ff.grammar.grammarIdentification->name[];
                              leave loop
                          if);
                          
                       #);
                     
                  else
                     'getGrammarFileName: fragmentList is empty!!'->putLine; 
                 if)
              else
                 'getGrammarFileName: g[] is none!!'->putLine
             if)
          #)
     exit name[]
     #);
   extendedMarkAsChanged:
     (# g: ^astInterface.fragmentGroup; feedback,status: @boolean
     enter (g[],feedback)
     do
          (# help: @text; 
          do
             true->status;
             thisOperation:
               (# 
               do
                  g.markAsChanged
                    (#
                       writeAccessError::< 
                         (# 
                         do
                            (if feedback then
                                'Write access error: '->help;
                                g.fullName->help.append;
                                (none ,help[],'extendedMarkAsChanged')
                                  ->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       noSpaceLeftError::< 
                         (# 
                         do
                            (if feedback then
                                (none ,'Disk is full','extendedMarkAsChanged')
                                  ->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       otherFileError::< 
                         (# 
                         do
                            (if feedback then
                                (none ,
                                 'Other error, probably disk full, please check',
                                 'extendedMarkAsChanged')->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #)
                    #)
               #)
          #)
     exit status
     #);
   dirWriteable: (# f: @file enter f.name exit f.entry.writeable #);
   extendedSaveBackup:
     (#
        ext: ^text;
        g: ^astInterface.fragmentGroup;
        status: @boolean (* is now only used for autosaving *)
     enter (ext[],g[])
     do
          (# f: @file
          do
             true->status;
             ext[]->((g.diskfileName).copy).Append->f.name;
             (if (f.entry.path.head->dirWriteable)
              // true then
                 (if f.entry.writeable then
                     ext[]->g.saveBackup
                  else
                       (# msg: ^text
                       do
                          'No write access to the file:\n'->msg[];
                          f.name->msg.append;
                          (none ,msg[],'Auto-save')->UI.alertUser;
                          false->status
                       #)
                 if)
              else
                   (# msg: ^text
                   do
                      'No write access to the directory:\n'->msg[];
                      f.entry.path.head->msg.append;
                      (none ,msg[],'Auto-save')->UI.alertUser;
                      false->status
                   #)
             if)
          #)
     exit status
     #);
   backupTextFile:
     (#
        fg: ^astInterface.fragmentGroup;
        textFile,tildeTextFile,msg: ^text;
        f,ftilde: @file;
        OK: @boolean
     enter fg[]
     do
        fg.textFileName->textFile[]->f.name;
        textFile.copy->tildeTextFile[];
        '~'->tildeTextFile.append;
        (if f.entry.exists then
            tildeTextFile[]->ftilde.name;
            (if ftilde.entry.exists then
                (if ftilde.entry.writeable then
                    true->OK
                 else
                    false->OK;
                    'No write access to the file:\n'->msg[];
                    tildeTextFile[]->msg.append;
                    (none ,msg[],'Backup text file')->UI.alertUser
                if)
             else
                (if f.entry.path.head->dirWriteable then
                    true->OK
                 else
                    false->OK;
                    'No write access to the directory:\n'->msg[];
                    f.entry.path.head->msg.append;
                    (none ,msg[],'Backup text file')->UI.alertUser
                if)
            if);
            (if OK then
                doCommand
                  (# 
                  do
                  (*'Renaming text file to: '->msg[];
                   tildeTextFile[]->msg.append;
                   msg[]->ymerCallBack.infoView;*)
                     (f.name,tildeTextFile[])->myRename;
                     (* tildeTextFile[]->f.entry.rename;*)
                     (*ymerCallBack.infoViewDone*)
                     
                  #)
            if)
        if);
        
     #);
   backupGroupFile:
     (#
        fg: ^astInterface.fragmentGroup;
        groupFile,tildegroupFile,msg: ^text;
        f,ftilde: @file;
        OK: @boolean
     enter fg[]
     do
        fg.diskFileName->groupFile[]->f.name;
        groupFile.copy->tildegroupFile[];
        '~'->tildegroupFile.append;
        (if f.entry.exists then
            tildegroupFile[]->ftilde.name;
            (if ftilde.entry.exists then
                (if ftilde.entry.writeable then
                    true->OK
                 else
                    false->OK;
                    'No write access to the file:\n'->msg[];
                    tildegroupFile[]->msg.append;
                    (none ,msg[],'Backup group file')->UI.alertUser
                if)
             else
                (if f.entry.path.head->dirWriteable then
                    true->OK
                 else
                    false->OK;
                    'No write access to the directory:\n'->msg[];
                    f.entry.path.head->msg.append;
                    (none ,msg[],'Backup group file')->UI.alertUser
                if)
            if);
            (if OK then
                doCommand
                  (# 
                  do
                  (*'Renaming group file to: '->msg[];
                   tildegroupFile[]->msg.append;
                   msg[]->ymerCallBack.infoView;*)
                     (f.name,tildegroupFile[])->myRename;
                     (*tildegroupFile[]->f.entry.rename*)
                     (*ymerCallBack.infoViewDone*)
                     
                  #)
            if)
        if);
        
     #);
   restoreGroupFile:
     (#
        fg: ^astInterface.fragmentGroup;
        groupFile,tildegroupFile,msg: ^text;
        f,ftilde: @file;
        OK: @boolean
     enter fg[]
     do
        fg.diskFileName->groupFile[];
        groupFile.copy->tildegroupFile[];
        '~'->tildegroupFile.append;
        tildeGroupFile[]->ftilde.name;
        (if ftilde.entry.exists then
            groupFile[]->f.name;
            (if f.entry.exists then
                (if f.entry.writeable then
                    true->OK
                 else
                    false->OK;
                    'No write access to the file:\n'->msg[];
                    groupFile[]->msg.append;
                    (none ,msg[],'Restore group file')->UI.alertUser
                if)
             else
                (if ftilde.entry.path.head->dirWriteable then
                    true->OK
                 else
                    false->OK;
                    'No write access to the directory:\n'->msg[];
                    ftilde.entry.path.head->msg.append;
                    (none ,msg[],'Restore group file')->UI.alertUser
                if)
            if);
            (if OK then
                doCommand
                  (# 
                  do
                  (*'Renaming tilde group file to: '->msg[];
                   groupFile[]->msg.append;
                   msg[]->ymerCallBack.infoView;*)
                     (f.name,groupFile[])->myRename;
                     (*groupFile[]->f.entry.rename;*)
                     (*ymerCallBack.infoViewDone*)
                     
                  #)
            if)
        if);
        
     #);
   deleteAutoSaveFile:
     (# fg: ^astInterface.fragmentGroup; help,autosaveFile: ^text; f: @file
     enter fg[]
     do
        fg.fullName->help[];
        help.copy->autoSaveFile[];
        mps.astFileExtension->autoSaveFile.putText;
        '#'->autoSaveFile.put;
        autoSaveFile[]->f.name;
        (if f.entry.exists // true then f.delete if);
        
     #);
   checkAutoSaveFile:
     (#
        g: ^astInterface.fragmentGroup;
        didRecover: @boolean;
        help,grammarName: ^text;
        groupFile,autoSaveFile: @file;
        ge: ^groupEditor
     enter g[]
     do
        thisOperation:
          (# 
          do
             g.diskFileName->help[];
             '#'->help.put;
             help[]->autoSaveFile.Name;
             g.diskFileName->groupFile.Name;
             (if groupFile.entry.exists and autoSaveFile.entry.exists then
                 (if (autoSaveFile.entry.modTime > groupFile.entry.modTime) then
                 (* (ymerCallBack.theBrowser[],g[])->groupEditorList.findGroupEditor->ge[];
                  (if ge[] <> none then
                  true->ge.autoSaveFileExists
                  else
                  'checkAutoSaveFile: no group editor'->putLine
                  if);
                  *)
                     'Auto save file is newer: '->help[];
                     autoSaveFile.name->fragmentDefaultName->help.append;
                     help.newLine;
                     'Do you want to recover?'->help.append;
                     (none ,'Recover?',help[])
                       ->UI.promptForBoolean
                         (#
                            ok::< 
                              (# 
                              do
                                 '#'->g.restoreBackup;
                                 autoSaveFile.delete;
                                 (*g[]->ymerCallBack.recoverGroup;*)
                                 true->didRecover
                              #)
                         #)
                 if)
             if);
             
          #)
     exit didRecover
     #);
   nonterminalExists:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExists: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExists;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExists; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExists; ff.root[]->unExp[]; 
        if);
        
     exit (unexpandedExists,unExp[])
     #);
   checkWriteAccess:
     (#
        fg: ^astInterface.fragmentGroup;
        writeAccess: @boolean;
        f: @file;
        path,name,msg: ^text
     enter fg[]
     do
        fg.diskFileName->f.name;
        (f.entry.writeable)->writeAccess;
        (if writeAccess then
            fg.textFileName->f.name;
            (f.entry.writeable)->writeAccess;
            (if not writeAccess then
                'No write access to the file:\n'->msg[];
                f.name->msg.append;
                (*(none ,msg[],'Check write access')->UI.alertUser*)
                
            if)
        if)
     exit writeAccess
     #);
   astToProps:
     (#
        propText: @text;
        synCatNo: @integer;
        fg: ^astInterface.fragmentGroup;
        fl: ^astInterface.fragmentLink;
        propff: ^astInterface.fragmentForm;
        status: @boolean;
        S: @stack (# element:: text #)
     enter (propff[],fg[])
     do
        propText.clear;
        (mps[],propff[],propText[],'')->prettyprintFragment;
        (if trace[9] then
            'astToProps, prettyprinted ast: '->putLine;
            '<'->put;
            propText[]->putText;
            '>'->put;
            newLine;
            
        if);
        propText.reset;
        (if fg[] = none then
            'astToProps: fg is none!!'->putLine
         else
            (if fg.fragmentlist[] = none then
                'astToProps: fg.fragmentlist is none!!'->putLine
             else
                fg.fragmentlist.scan
                  (# 
                  do
                     (if (current.type = mps.linkType) then
                         current.name[]->S.push
                     if)
                  #);
                loop:
                (if not S.empty then
                    S.pop->fg.fragmentList.deleteLocalName; restart loop
                if);
                true->status;
                l:
                (propText[],screen[])
                  ->fg.parseProperty
                    (#
                       parseErrors::< (* exception called if parse-errors *) 
                         (# 
                         do
                            'Temporary parse errors in the property list, please ignore'
                              ->screen.putLine;
                            false->status;
                            leave l;
                            
                         #);
                       doubleFormDeclaration::<
                       (* exception called if two fragmentForms with the same name *)
                       
                         (# 
                         do
                            ' this one is never called!!! double form declaration'
                              ->screen.putLine;
                            false->status;
                            leave l
                         #);
                       
                    #)->status;
                (if trace[9] then
                    'parseProperty status: '->putText;
                    (if status then 'true'->putText else 'false'->putText if);
                    newLine;
                    (if fg.prop.propList.Size
                     // 0 then 'The property list is emty'->putLine; 
                     else
                        fg.prop.scanProp
                          (#
                             doProp::< 
                               (# 
                               do
                                  prop[]->putText;
                                  ' '->put;
                                  scanParameters
                                    (#
                                       doString::< 
                                         (# 
                                         do
                                            ''''->put;
                                            s[]->putText;
                                            ''''->put;
                                            ' '->put;
                                            
                                         #);
                                       doName::< 
                                         (#  do n[]->putText; ' '->put;  #);
                                       doConst::< 
                                         (#  do c->putInt; ' '->put;  #);
                                       
                                    #);
                                  newLine;
                                  
                               #);
                             
                          #);
                        
                    if);
                    ;
                    
                if)
            if)
        if)
     exit status
     #);
   propsToAst:
     (#
        propText: @text;
        synCatNo: @integer;
        fg,propfg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        pos: @integer
     enter fg[]
     do
        (mps[],fg[],propText[],'')
          ->prettyprintFragment (# onlyProperties::< trueObject #);
        (if trace[9] then
            'PropsToAst, prettyprint of properties:'->putLine;
            '<'->put;
            propText[]->putText;
            '>'->put;
            newLine;
            
        if);
        (if propText.length
         // 0 // 1 // 2 then '<<PropertyOpt>>'->propText
        if);
        mps.newFragmentGroup->propfg[];
        'Prop'->((fg.name).copy).Append->propfg.name;
        mps.top.topgroup[]->propfg.father;
        propertyGrammar[]->mps.newFragmentForm->ff[];
        propText.reset;
        mpsErrorReporter[]->mps.theErrorReporter[];
        (if
        (1 (*root*) ,propText[],screen[],ff[])->propertyGrammar.parser.doParse
         then
            'property'->ff.name; ff[]->propfg.fragmentList.addFragment
         else
            'Parse errors in property list'->putLine; proptext[]->putLine; 
        if)
     exit propfg[]
     #)
#)  

-- editorenvNew: DoPart --
do
   (if (groupName[] <> none ) and (groupName.length > 0) then
       (if groupName[]->editorenvPrivate.fileWriteable then
           (groupName[],formName[],grammarName[],1,theBrowser[],false)
             ->editorenvPrivate.doNewGroup->fg[];
           (if fg[]
            // none then
               grammarName[]->putLine;
               groupName[]->putLine;
               formName[]->putLine;
               ' fragmentgroup not created'->putLine;
               
            else
               (fg[],true)
                 ->
                   editorenvPrivate.extendedMarkAsChanged
                   (* this is done in order to
                    open the new group in ymer *)
           if)
        else
           (none ,'Error in path','New...')->UI.alertUser
       if)
   if)  

-- editorEnvNewBetaProgram: DoPart --
do
   (theBrowser[],name[],1 (* Program *) ,isAfrejaEditor)
     ->editorenvPrivate.newBETAProgOrLib->fg[]  

-- editorenvNewBetaLibrary: DoPart --
do
   (theBrowser[],name[],2 (* Library *) ,isAfrejaEditor)
     ->editorenvPrivate.newBETAProgOrLib->fg[]  

-- openFormBody: Descriptor --
(#
   f: ^astInterface.fragment;
   fg: ^astInterface.fragmentGroup;
   node: ^astInterface.ast;
   fe: ^codeviewer;
   ge: ^groupEditor;
   formName,thePath,help: ^text;
   dashPosition: @integer;
   doOpen:
     (#
        input: ^text;
        fg: ^astInterface.fragmentGroup;
        error: @stream;
        fil: @file;
        
     enter input[]
     do
        thisOperation:
        (input[],error[])
          ->mps.top.open
            (#
               myException:
                 (# msg,help: ^text
                 enter msg[]
                 do
                    ': '->help[];
                    input[]->help.putText;
                    help[]->msg.append;
                    (none ,msg[],'Alert')->UI.alertUser;
                    none ->f[];
                    none ->mps.theCatcher[];
                    leave thisOperation
                 #);
               readAccessError::< 
                 (#  do 'Read access error'->myException #);
               fragmentNotExisting::< 
                 (#  do 'Non-existent fragment file'->myException #);
               grammarNotFound::< 
                 (#  do 'Grammar not found for'->myException #);
               badFormat::<  (#  do 'Bad AST format'->myException #);
               WriteAccessOnLstFileError::< 
                 (# 
                 do
                    'Access error on .lst file'->myException;
                    true->continue (*'Access error on .lst file'->myException*)
                 #);
               writeAccessError::< 
                 (# 
                 do
                    'No write access'->myException;
                    true
                      ->continue
                      (*'Write access error'->myException
                       * *)
                 #);
               startingParsing::< 
                 (# 
                 do
                    'Parsing '->putText;
                    input[]->putText;
                    '...'->putLine;
                    'myStartingParsing'->putLine;
                    
                 #);
               ParseErrors::< 
                 (# 
                 do (*none ->f[];*)
                    'myParseErrors'->putline; ; leave thisOperation
                 #);
               DoubleFormDeclaration::< 
                 (# 
                 do 'Two forms are declared with the same name'->myException
                 #);
               fatalParseError::< 
                 (# 
                 do (*none ->f[];*)
                    'errNo->myFatalParseError'->putLine; leave thisOperation
                 #);
               OtherFileError::< 
                 (# 
                 do
                    input[]->fil.name;
                    (if fil.entry.exists
                     // true then
                        (if fil.entry.isDirectory
                         // true then 'Is a directory'->myException
                         else
                            'Other file error'->myException
                        if)
                    if)
                 #);
               
            #)->f[];
        (if (f[] <> none ) then
            (if f.type
             // mps.groupType then
                f[]->fg[];
                (*fg[]->gettextfilename->textfile.name;*)
                (*fg.textfilename->textfile.name;
                 (if textfile.entry.exists
                 // false then
                 'Text file does not exist'->UI.statusMessage;
                 fg[]->groupEditorList.findGE->ge[];
                 (if ge[]<>none then true->ge.needToPrettyPrint if);
                 if);
                 *)
                
            if);
            (if not fg.isRealOpen then fg.realOpen if)
        if)
     exit fg[]
     #);
   
do
   (if trace[2] then 'openForm: '->putText; name[]->putLine;  if);
   '-'->name.findAll (#  do inx->dashPosition #);
   (if dashPosition <> 0 then
       (dashPosition+1,name.length)->name.sub->formName[];
       (1,dashPosition-1)->name.sub->thePath[];
       thePath[]->doOpen->fg[];
       (if fg[] <> none then
           (formName[],screen[])->fg.open->ff[];
           (if ff[] <> none then
               (if index
                // 0 then none ->node[]
                else
                   index->ff.indexToNode->node[];
                   index
                     ->ff.indexToNode
                       (#
                          indexOutOfRange::< 
                            (# 
                            do 'indexOutOfRange'->putLine; true->continue; 
                            #);
                          noSuchSymbol::< 
                            (# 
                            do 'noSuchSymbol'->putLine; true->continue; 
                            #);
                          grammarGenRefArrayError::< 
                            (# 
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                               
                            #)
                       #)->node[]
               if);
               
            else
               'OpenForm: The fragment form: '->putText;
               formName[]->putText;
               ' not found'->putLine;
               
           if);
           
        else
           'openform: fg[] is none'->putLine
       if)
    else
       'OpenForm: Syntax is <fragmentGroupName>-<fragmentFormName>'->putline;
       name[]->putline;
       
   if);
   
#)  

-- editorenvSaveAll: DoPart --
do   

-- editorenvMakeNewTextFile: Descriptor --
(# textFile,msg: ^text; tf,f,fast: @file; OK: @boolean
do
   fg.textFileName->textFile[]->f.name;
   fg.diskFileName->fast.name;
   (if f.entry.exists then (* this check should be in prettyprint fragment?? *)
       (if f.entry.writeable then
           true->OK
        else
           false->OK;
           'No write access to the file:\n'->msg[];
           textFile[]->msg.append;
           (none ,msg[],'Make new text file')->UI.alertUser
       if)
    else
       (if f.entry.path.head->editorenvPrivate.dirWriteable then
           true->OK
        else
           false->OK;
           'No write access to the directory:\n'->msg[];
           f.entry.path.head->msg.append;
           (none ,msg[],'Make new text file')->UI.alertUser
       if)
   if);
   (if OK then
       fg[]->editorenvPrivate.backupTextFile;
       (*'Updating textfile: '->msg[];
        fg.textFileName->textFile[]->msg.append;
        '...'->msg.append;
        msg[]->ymerCallBack.infoView;*)
       (if fg.fragmentList[] <> none then
           (mps[],fg[],none ,textFile[])
             ->prettyprintFragment (# showSemanticErrors:: falseObject #);
           
        else
           (mps[],fg[],none ,textFile[])
             ->prettyprintFragment
               (#
                  onlyProperties::< trueObject;
                  showSemanticErrors::< falseObject
               #)
       if);
       (* changed by jlk for v1.5:(textfile,fg.modtime-120)->setEntryModtime;*)
       textfile[]->tf.name;
       fg.modtime-120->tf.entry.modtime;
       (*ymerCallBack.infoViewDone*)
       
   if)
#)  

-- editorenvCreateGroupEditor: DoPart --
do
     (# textfile: @file; didRecover,alreadyExists: @boolean; msg: ^text
     do
        (if not onGoingRecovery (* why this: ?groupeditorList.size = 0) *) and
        not openingFrejaEditor then
            search: scan
              (# 
              do
                 (if (fg[] = current.fg[]) then
                     true->alreadyExists; leave search
                 if)
              #);
            (if not alreadyExists then
                fg[]->editorenvPrivate.checkAutoSaveFile->didRecover
            if)
        if);
        (if trace[2] then
            'creating groupEditor: '->putText;
            fg.name->putLine;
            (if (mps[],fg[])->getDoneCheckProperty (* isChecked *) then
                'is checked'->putLine
             else
                'is not checked'->putLine
            if);
            
        if);
        &groupEditor[]->ge[];
        fg[]->ge.fg[];
        theBrowser[]->ge.theBrowser[];
        fg[]->editorenvPrivate.checkWriteAccess->ge.groupfileWriteable;
        globalWriteProtection or readOnly or not ge.groupfileWriteable
          ->ge.isReadOnly;
        (if didRecover then
            ge.grouptouched
         else
            true->ge.autoSaveFileExists
        if);
        (if trace[2] then
            'create groupeditor globalWriteProtection: '->putText;
            (if globalWriteProtection then
                'true'->putLine
             else
                'false'->putLine
            if);
            'create groupeditor readonly: '->putText;
            (if readOnly then 'true'->putLine else 'false'->putLine if);
            'create groupeditor ge.groupfileWriteable: '->putText;
            (if ge.groupfileWriteable then
                'true'->putLine
             else
                'false'->putLine
            if);
            'create groupeditor ge.isReadOnly: '->putText;
            (if ge.isReadOnly then 'true'->putLine else 'false'->putLine if)
        if);
        fg.textfilename->textfile.name;
        (if not textfile.entry.exists then
            'Text file does not exist'->msg[];
            msg[]->ymerCallBack.infoView;
            true->ge.needToUpdateTextFile;
            
        if);
        fg[]->editorenvPrivate.getGrammarName->ge.grammarName[];
        ge[]->fgHandler.subscribe;
        ge[]->append;
        (* (if not onGoingRecovery and (ge.fgh.groupEditors.size = 1) and not
         openingFrejaEditor then
         ge.fg[]->editorenvPrivate.checkAutoSaveFile
         if)*)
        
     #)  

-- editorenvFindOrCreateGroupEditor: DoPart --
do
     (# textfile: @file
     do
        (theBrowser[],fg[])->findGroupEditor->ge[];
        (if ge[] = none then
            (theBrowser[],fg[],readOnly)->createGroupEditor->ge[]
        if)
     #)  

-- editorenvCreateFormEditor: Descriptor --
(# help: ^text; 
do
   (if ge[] <> none then
   (* overfloedigt theEditorRoot.frag[]->ge.formeditorList.findEditor->fe[];*)
       (if trace[2] then
           'creating formeditor: '->putText;
           (if theEditorRoot[] <> none then
               (theEditorRoot.frag.father).name->putText;
               '-'->put;
               theEditorRoot.frag.name->putLine;
               
            else
               'theEditorRoot is none'->putLine
           if)
       if);
       (if theSifTextEditor[] <> none then
           &theSifTextEditor.codeviewerType[]->fe[];
           fe[]->theSifTexteditor.SifViewer[];
           theSifTextEditor[]->fe.theSifTextEditor[];
           (if theEditorRoot[] <> none then
               theEditorRoot.frag[]->theSifTexteditor.frag[];
               theEditorRoot[]->theSifTexteditor.editorRoot[];
               (mps[],theEditorRoot.frag.grammar[],UI[],theSifTextEditor[],
                theEditorRoot.Frag[],theEditorRoot[],initialSelection[])
                 ->fe.init;
               
            else
               (if ff[] <> none then
                   ff[]->theSifTexteditor.frag[];
                   none ->theSifTexteditor.editorRoot[];
                   (mps[],ff.grammar[],UI[],theSifTextEditor[],ff[],
                    theEditorRoot[],initialSelection[])->fe.init;
                   
                else
                   'createFormEditor: theEditorRoot and ff are none!!'->putLine
               if)
           if);
           fe[]->ge.formeditorList.append;
           ge[]->fe.thisGroupEditor[];
           (if ge.groupFileWriteable then
               globalWriteProtection or ge.isReadOnly->fe.isReadOnly
                 ->fe.theSifTextEditor.isReadOnly;
               
            else
               true->fe.isReadOnly->fe.theSifTextEditor.isReadOnly; 
           if);
           (if trace[2] then
               'createFormEditor isReadOnly: '->putText;
               (if fe.theSifTextEditor.isReadOnly then
                   'true'->putLine
                else
                   'false'->putLine
               if);
               
           if);
           
        else
           'CreateFormEditor: theSifTexteditor is none!'->putLine
       if)
    else
       'CreateFormEditor: ge is none!'->putLine
   if);
   
#)  

-- editorenvFindOrCreateFormEditor: Descriptor --
(# help: ^text; 
do
   (if ge[] <> none then
       (if theSifTextEditor[] <> none then
           (if trace[2] then
               'find or create formeditor: '->putText;
               (if theEditorRoot[] <> none then
                   (theEditorRoot.frag.father).name->putText;
                   '-'->put;
                   theEditorRoot.frag.name->putLine;
                   
                else
                   'theEditorRoot is none'->putLine
               if)
           if);
           (if theSifTextEditor.SifViewer[] <> none then
               (if trace[2] then
                   'theSifTexteditor.sifViewer[]<>none'->putLine
               if);
               (if theSifTexteditor.textediting then
                   false->theSifTextEditor.textediting;
                   'Textediting is abandoned in '->help[];
                   help.newLine;
                   (theSifTextEditor.frag.father).name->help.putText;
                   '-'->help.put;
                   theSifTextEditor.frag.name->help.putText;
                   (none ,help[],'Textediting abandoned')->UI.alertUser;
                   (*theSifTextEditor.sifViewer.doParseText*)
                   
                else
                   none ->theSifTextEditor.sifViewer.theSifTextEditor[];
                   (* the current editor is not visible anymore *)
                   
               if)
           if);
           (if theEditorRoot[] <> none then
               theEditorRoot.frag[]->ge.formeditorList.findEditor->fe[];
               (if fe[] <> none then
                   (if trace[2] then 'already exists'->putLine if);
                   fe[]->theSifTexteditor.SifViewer[];
                   theSifTextEditor[]
                     ->theSifTextEditor.sifViewer.theSifTextEditor[];
                   fe.editorRoot.frag[]->theSifTextEditor.frag[];
                   fe.editorRoot[]->theSifTexteditor.editorRoot[];
                   fe.isReadOnly->theSifTexteditor.isReadOnly;
                   (if trace[2] then
                       'findOrcreateFormEditor isReadOnly: '->putText;
                       (if fe.theSifTextEditor.isReadOnly then
                           'true'->putLine
                        else
                           'false'->putLine
                       if);
                       
                   if);
                   fe.doReprettyprint;
                   fe.cs->fe.setFocus
                else
                   (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],
                    ge[])->createFormEditor->fe[]
               if)
            else
               (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
                 ->createFormEditor->fe[]
           if)
        else
           'findOrCreateFormEditor: theSifTexteditor is none!'->putLine
       if)
    else
       'findOrCreateFormEditor: ge is none!'->putLine
   if);
   
#)  

-- editorenvFindGroupEditor: DoPart --
do
(*'grouplist Size: '->putText;
 size->putInt;
 newLine;
 scan
 (# 
 do
 current.fg.name->putText;
 ': '->putLine;
 'formList Size: '->putText;
 size->putInt;
 newLine;
 current.formeditorList.scan
 (# 
 do
 current.id->putInt;
 ' '->put;
 (current.frag.father).name->putText;
 '-'->put;
 current.frag.name->putText;
 putline
 #);
 putLine
 #);*)
   search: scan
     (# 
     do
        (if theBrowser[] <> none then
            (if (fg[] = current.fg[]) and (theBrowser[] = current.theBrowser[])
             then
                current[]->ge[]; leave search
            if)
        if)
     #)  

-- editorenvShowEditors: DoPart --
do
   'groupEditorList: '->putText;
   groupEditorList.size->putInt;
   newLine;
   groupEditorList.scan
     (# 
     do
        current.fg.name->putLine;
        'formEditorList: '->putText;
        current.formEditorList.size->putInt;
        newLine;
        current.formEditorList.scan
          (#  do current.frag.name->putLine #);
        
     #)  

-- findEditorForFormBody: Descriptor --
(# ge: ^groupEditor; help: ^text; 
do
   (ymerCallback.theBrowser[],ff.father,false)
     ->groupeditorList.findOrCreateGroupEditor->ge[];
   (if ge[] <> none then
       ff[]->ge.formeditorList.findEditor->fe[];
       (if fe[] <> none then
           (if (selectedNode[] <> none ) then
               (selectedNode[],1,0,0)->fe.setFocus
            else
               fe.cs->fe.setFocus
           if)
        else
           ' findEditorForFormBody: editor not found'->putLine
       if)
   if);
   
#)  

-- findFormEditorId: DoPart --
do
   (if trace[1] then 'findFormEditorId'->putLine;  if);
     (# ge: ^groupEditor; help: ^text
     do
        search: groupeditorList.scan
          (# 
          do
             id->current.formeditorList.findEditorId->fe[];
             (if fe[] <> none then leave search if);
             
          #)
     #)  

-- editorenvNonterminalsExist: Descriptor --
(#
   nonterminalsExistInForm:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExist: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExist;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExist; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExist; ff.root[]->unExp[]
        if);
        
     exit (unexpandedExist,unExp[])
     #);
   
do
   thisOperation: groupEditorList.scan
     (# ge: ^groupEditor; (*ff: ^astInterface.fragmentForm;*) 
     do
        current[]->ge[];
        (if ge.fg[] = none then
            'scanGEs: ge.g[] is none!'->putLine; 
         else
            ge.fg.fragmentlist.scan
              (# help: ^text; 
              do
                 (if current.type = mps.formType then
                     (if current.f[] = none then screen[]->current.open if);
                     (*current.f[]->ff[];
                      ff.recomputeSlotChain;*)
                     current.f[]->nonterminalsExistInForm
                       ->(unexpandedExist,unExp[]);
                     (if unexpandedExist then leave thisOperation if)
                 if);
                 
              #);
            ge.fg[]->editorenvPrivate.recomputeSLOTchain
        if);
        
     #);
   
#)  

-- editorEnvInit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file
     do
        &clipBoard[]->clip[];
        history.init;
        metaGrammarInit;
        (* is only done if necessary *)
        (if trace[9]
         // true then '*************** prettygrammar.init'->putLine
        if);
        &mps.prettyprint[]->prettyprintGrammar[];
        prettyprintGrammar.init;
        '~beta/grammars/pretty/v2.3/prettyprint'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->(grammarWithPath.copy).Append->screen.putLine;
            (failure,'')->stop;
            
         else
            ('prettyprint',screen[])->gg.open->prettyprintGrammar.grammarAst[];
            (if prettyprintGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->(grammarWithPath.copy).Append->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->prettyprintGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        (if trace[9]
         // true then '*************** propertygrammar.init'->putLine
        if);
        &mps.property[]->propertyGrammar[];
        propertyGrammar.init;
        '~beta/grammars/property/v1.2/property'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->(grammarWithPath.copy).Append->screen.putLine;
            (failure,'')->stop;
            
         else
            ('property',screen[])->gg.open->propertyGrammar.grammarAst[];
            (if propertyGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->(grammarWithPath.copy).Append->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->propertyGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        mps.theErrorReporter[]->mpsErrorReporter[];
        &UI.cursor[]->rightButtonCursor[];
        &UI.cursor[]->textCursor[];
        <<SLOT setupCursors:Descriptor>>
     #)  

-- editorenvSetWaitCursor: DoPart --
do ui.cursors.watch[]->UI.mouse.busyCursor  

-- editorenvSetStructureCursor: DoPart --
do UI.cursors.arrow[]->UI.mouse.busyCursor  

-- editorenvSetRightButtonCursor: DoPart --
do rightButtonCursor[]->UI.mouse.busyCursor  

-- editorenvSetTextCursor: DoPart --
do UI.cursors.iBeam[]->UI.mouse.busyCursor  

