ORIGIN '../codeeditor';
INCLUDE '~beta/basiclib/v1.4/directory'
        '~beta/pretty/v5.0.1/pplib'
        'modtime'
        '~beta/mps/v5.0.1/propertyparser';
MDBODY nti 'editorenv_ntibody'
       mac 'editorenv_macbody'
       default 'editorenv_X11body';
(*
 * COPYRIGHT
 *	 Copyright Mjolner Informatics, 1995-96
 *	 All rights reserved.
 *)
-- editorenvSetGlobalWriteProtection: DoPart --
do
   value->globalWriteProtection;
   groupEditorList.scan
     (#  do value->current.setIsReadOnly #)  

-- editorenvMetaGrammarInit: Descriptor --
(#
   theMetaGrammar: ^astInterface.treelevel;
   grammarWithPath,help: ^text;
   gg: ^astInterface.fragmentGroup;
   bobsfile: @file
do
   (if mg[] = none then
       (if mps.grammarTable.meta[] <> none then
           mps.grammarTable.meta[]->mg[]; 
        else
           &mps.metaGrammar[]->theMetaGrammar[]->mps.grammarTable.meta[]->mg[];
           theMetaGrammar.init;
           '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
           ('-meta'->grammarWithPath.copyAppend,screen[])->mps.top.open->gg[];
           (if gg[]
            // none then
               'Could not open: '->screen.putText;
               '-meta'->grammarWithPath.copyAppend->screen.putLine;
               (failure,'')->stop;
               
            else
               ('metagrammar',screen[])->gg.open->theMetagrammar.grammarAst[];
               (if theMetagrammar.grammarAst[]
                // none then
                   'No grammarAst for '->screen.putText;
                   grammarWithPath[]->screen.putLine;
                   (failure,'')->stop;
                   
                else
                   grammarWithPath[]->mps.expandToFullPath->help[];
                   '-parser'->help.append;
                   mps.parserFileExtension->help.append;
                   help[]->bobsFile.name;
                   (if bobsFile.entry.exists then
                       bobsFile.name->theMetagrammar.parser.initialize; 
                    else
                       'No parser available: '->screen.putText;
                       bobsFile.name->screen.putLine;
                       
                   if)
               if);
               
           if);
           
       if);
       
   if)
#)  

-- editorenvPrivate: Descriptor --
(#
   untitledNo (* used by newGroup and newBETAgroup *) : @integer;
   nextUntitled:
     (# t: ^text; 
     do
        untitledNo+1->untitledNo;
        'untitled'->t[];
        (if (untitledNo > 1)
         // true then t.length->t.setPos; untitledNo->t.putInt; 
        if)
     exit t.copy
     #);
   splitPath:
     (# e: @diskEntry;  enter e.path exit (e.path.head,e.path.name) #);
   splitFileName:
     (# e: @diskEntry; 
     enter e.path
     exit (e.path.name.prefix,e.path.name.suffix)
     #);
   stripExtension:
     (# e: @diskEntry; noExt: ^text; 
     enter e.path
     do
        e.path.head->noExt[];
        '/'->noExt.append;
        e.path.name.prefix->noExt.append;
        
     exit noExt[]
     #);
   fileWriteable:
   (* test whether the path is OK and the dir can be written into and whether the file can be written
    on if the path is OK and the file exists *)
     (# f: @file enter f.name exit f.entry.writeable #);
   showEditors:
     (# 
     do
        'groupEditorList: '->putText;
        groupEditorList.size->putInt;
        newLine;
        groupEditorList.scan
          (# 
          do
             current.fg.name->putLine;
             'formEditorList: '->putText;
             current.formEditorList.size->putInt;
             newLine;
             current.formEditorList.scan
               (#  do current.frag.name->putLine #);
             
          #)
     #);
   doNewGroup:
     (#
        theFile,fragmentName,language: ^text;
        synCatNo: @integer;
        theBrowser: ^object;
        isAFrejaEditor: @boolean;
        fg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        doParse: @boolean;
        help,t,keepName: ^text;
        propText: ^text;
        status: @boolean;
        
     enter
     (theFile[],fragmentName[],language[],synCatNo,theBrowser[],isAFrejaEditor)
     do
        thisOperation:
          (# 
          do
             (if trace[3] then
                 'doNewGroup:'->putLine;
                 theFile[]->putLine;
                 fragmentName[]->putLine;
                 language[]->putLine;
                 synCatNo->putInt;
                 newLine
             if);
             groupEditorlist.scan
               (# theGroupEditor: ^groupEditor
               do
                  current[]->theGroupEditor[];
                  theFile[]->mps.expandToFullPath->help[];
                  (if
                  (theGroupEditor.fg.name->mps.expandToFullPath->help.equal)
                   then
                      (none ,'A group editor already exists','Alert')
                        ->UI.alertUser;
                      leave thisOperation
                  if)
               #);
             (if (fragmentName[] <> none ) then
                 (if (fragmentName.length > 0) then
                     (if ('beta'->language.equal) then
                         theFile[]->mps.expandToFullPath
                           ->mps.top.newGroup
                             (# alreadyOpen::<  (#  do true->continue #)
                             #)->fg[];
                         betagrammar[]->fg.defaultGrammar[];
                         betagrammar[]->mps.newFragmentForm->ff[];
                         'ORIGIN ''~beta/basiclib/v1.4/betaenv'''->propText[];
                         (if isAFrejaEditor then
                             '; '->propText.putLine;
                             'INCLUDE ''~beta/freja/v2.1/associations'''
                               ->propText.putLine
                         if);
                         propText.reset;
                         l:
                         (propText[],screen[])
                           ->fg.parseProperty
                             (#
                                parseErrors::<
                                (* exception called if parse-errors *) 
                                  (# 
                                  do
                                     'parse errors in the property list'
                                       ->screen.putLine;
                                     leave l;
                                     
                                  #);
                                doubleFormDeclaration::<
                                (* exception called if two fragmentForms with the same name *)
                                
                                  (# 
                                  do
                                     ' this one is never called!!! double form declaration'
                                       ->screen.putLine;
                                     leave l
                                  #);
                                
                             #)->status;
                         (if synCatNo
                          // betaGram.descriptorForm then
                             '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                               ->t[];
                             true->doParse;
                             
                          // betaGram.attributesForm then
                             '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                               ->t[];
                             true->doParse;
                             
                          else
                             '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                               ->t[];
                             true->doParse;
                             
                         if);
                         (if doParse
                          // true then
                             t.reset;
                             (synCatNo,t[],screen[],ff[])
                               ->betaGrammar.parser.doParse;
                             
                         if);
                         fragmentName[]->ff.name;
                         ff[]->fg.fragmentList.addFragment;
                         ;
                         
                      else
                         theFile[]->mps.expandToFullPath
                           ->mps.top.newGroup
                             (# alreadyOpen::<  (#  do true->continue #)
                             #)->fg[];
                         (language[],screen[])
                           ->mps.grammarTable.find
                             (#
                                ifNotFound::< 
                                  (# help: @text
                                  do
                                     'Grammar: '->help;
                                     language[]->help.putText;
                                     ' not found'->help.putText;
                                     help[]->putLine;
                                     (none ,help[],'Alert')->UI.alertUser;
                                     leave thisOperation
                                  #);
                                
                             #)->mps.newFragmentForm->ff[];
                         fragmentName[]->ff.name;
                         ff[]->fg.fragmentList.addFragment;
                         ff.grammar[]->fg.defaultGrammar[]
                     if);
                     
                 if);
                 
             if);
             
          #);
        
     exit fg[]
     #);
   ASTGC:
     (#
        fg: ^astInterface.fragmentGroup;
        ff,newff: ^astInterface.fragmentform;
        
     enter fg[]
     do
        fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[];
                 loop: ff.prop.scanProp
                   (#
                      doProp::< 
                        (# 
                        do
                           prop.makeLC;
                           (if ('touched'->prop.equal) then
                               ' AST GC in '->putText;
                               ff.name->putText;
                               ' ('->putText;
                               ff.a.range->putInt;
                               '->'->putText;
                               ff.grammar[]->mps.newFragmentForm->newff[];
                               newff[]->ff.root.copy->newff.root[];
                               ff.name->newff.name;
                               ff.grammar[]->newff.grammar[];
                               fg[]->newff.father;
                               newff[]->current.f[];
                               newff.a.range->putInt;
                               ') '->putLine;
                               leave loop
                           if)
                        #);
                      
                   #);
                 
             if)
          #);
        
     #);
   recomputeSLOTchain:
     (# fg: ^astInterface.fragmentGroup; ff: ^astInterface.fragmentform; 
     enter fg[]
     do
        fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[];
                 loop: ff.prop.scanProp
                   (#
                      doProp::< 
                        (# 
                        do
                           prop.makeLC;
                           (if ('touched'->prop.equal) then
                               'Recomputing slot chain for: '->putText;
                               ff.name->putLine;
                               ff.recomputeSlotChain;
                               leave loop
                           if)
                        #);
                      
                   #);
                 
             if)
          #);
        
     #);
   getGrammarName:
     (# g: ^astInterface.fragmentGroup; name: ^text; 
     enter g[]
     do
          (# ff: ^astInterface.fragmentForm; 
          do
             (if g[] <> none then
                 loop:
                 (if (g.fragmentList[] <> none )
                  // true then
                     g.fragmentList.scan
                       (# 
                       do
                          (if current.type
                           // mps.formType then
                              current.f[]->ff[];
                              ff.grammar.grammarIdentification->name[];
                              leave loop
                          if);
                          
                       #);
                     
                  else
                     'getGrammarFileName: fragmentList is empty!!'->putLine; 
                 if)
              else
                 'getGrammarFileName: g[] is none!!'->putLine
             if)
          #)
     exit name[]
     #);
   extendedMarkAsChanged:
     (# g: ^astInterface.fragmentGroup; feedback,status: @boolean
     enter (g[],feedback)
     do
          (# help: @text; 
          do
             true->status;
             thisOperation:
               (# 
               do
                  g.markAsChanged
                    (#
                       writeAccessError::< 
                         (# 
                         do
                            (if feedback then
                                'Write access error: '->help;
                                g.fullName->help.append;
                                (none ,help[],'Alert')->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       noSpaceLeftError::< 
                         (# 
                         do
                            (if feedback then
                                (none ,'Disk is full','Alert')->UI.alertUser; 
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       otherFileError::< 
                         (# 
                         do
                            (if feedback then
                                (none ,
                                 'Other error, probably disk full, please check',
                                 'Alert')->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       
                    #);
                  (* 'extendedMarkAsChanged: g.modtime: '->putText;
                   g.modtime->putInt;
                   newLine;
                   *)
                  
               #)
          #)
     exit status
     #);
   extendedSaveBackup:
     (# ext: ^text; g: ^astInterface.fragmentGroup; status: @boolean
     enter (ext[],g[])
     do
          (#
             f: @file;
             dirWriteable:
               (# f: @file enter f.name exit f.entry.writeable #)
          do
             true->status;
             g.diskfileName->f.name;
             (if (f.entry.path.head->dirWriteable)
              // true then
                 (if f.entry.writeable
                  // true then ext[]->g.saveBackup
                  else
                       (# t: @text
                       do
                          'No write access to the file: "'->t;
                          f.name->t.append;
                          '"'->t.putline;
                          false->status
                       #)
                 if)
              else
                   (# t: @text
                   do
                      'No write access to the directory: "'->t;
                      f.entry.path.head->t.append;
                      '"'->t.putline;
                      false->status
                   #)
             if)
          #)
     exit status
     #);
   backupTextFile:
     (#
        fg: ^astInterface.fragmentGroup;
        textFile,tildeTextFile: ^text;
        f: @file
     enter fg[]
     do
        fg.textFileName->textFile[]->f.name;
        textFile.copy->tildeTextFile[];
        '~'->tildeTextFile.append;
        (if f.entry.exists
         // true then
            newLine;
            'Renaming text file to: '->putText;
            tildeTextFile[]->putLine;
            tildeTextFile[]->f.entry.rename;
            
        if);
        
     #);
   deleteAutoSaveFile:
     (# fg: ^astInterface.fragmentGroup; help,autosaveFile: ^text; f: @file
     enter fg[]
     do
        fg.fullName->help[];
        help.copy->autoSaveFile[];
        mps.astFileExtension->autoSaveFile.putText;
        '#'->autoSaveFile.put;
        autoSaveFile[]->f.name;
        (if f.entry.exists // true then f.delete if);
        
     #);
   checkAutoSaveFile:
     (#
        g: ^astInterface.fragmentGroup;
        didRecover: @boolean;
        help,grammarName: ^text;
        groupFile,autoSaveFile: @file;
        ge: ^groupEditor
     enter g[]
     do
        (if ymerCallBack[] <> none then
            (if g[] = none then
                'This fragment group is none'->putLine; 
             else
                (if g.fragmentlist[] = none then
                    'CheckAutoSaveFile: This fragment group has no fragments'
                      ->putLine;
                    
                 else
                    g[]->getGrammarName->grammarName[];
                    (if grammarName[] = none then
                        
                     else
                    (* do not backup *)
                        (if ('property'->grammarName.equal) then
                        (* no backup needed *)
                            
                         else
                            thisOperation:
                              (# 
                              do
                                 g.diskFileName->help[];
                                 '#'->help.put;
                                 help[]->autoSaveFile.Name;
                                 g.diskFileName->groupFile.Name;
                                 (if groupFile.entry.exists and
                                 autoSaveFile.entry.exists then
                                     (if
                                     (autoSaveFile.entry.modTime >
                                      groupFile.entry.modTime) then
                                     (* (ymerCallBack.theBrowser[],g[])->groupEditorList.findGroupEditor->ge[];
                                      (if ge[] <> none then
                                      true->ge.autoSaveFileExists
                                      else
                                      'checkAutoSaveFile: no group editor'->putLine
                                      if);
                                      *)
                                         'Auto save file is newer: '->help[];
                                         autoSaveFile.name->fragmentDefaultName
                                           ->help.append;
                                         help.newLine;
                                         'Do you want to recover?'->help.append;
                                         (none ,'Recover?',help[])
                                           ->UI.promptForBoolean
                                             (#
                                                ok::< 
                                                  (# 
                                                  do
                                                     '#'->g.restoreBackup;
                                                     autoSaveFile.delete;
                                                     (*g[]->ymerCallBack.recoverGroup;*)
                                                     true->didRecover
                                                  #)
                                             #)
                                     if)
                                 if);
                                 
                              #)
                        if);
                        
                    if);
                    
                if)
            if)
        if)
     exit didRecover
     #);
   nonterminalExists:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExists: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExists;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExists; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExists; ff.root[]->unExp[]; 
        if);
        
     exit (unexpandedExists,unExp[])
     #);
   checkWriteAccess:
     (#
        fg: ^astInterface.fragmentGroup;
        writeAccess: @boolean;
        f: @file;
        path,name: ^text
     enter fg[]
     do fg.diskFileName->f.name; (f.entry.writeable)->writeAccess
     exit writeAccess
     #);
   astToProps:
     (#
        propText: @text;
        synCatNo: @integer;
        fg: ^astInterface.fragmentGroup;
        fl: ^astInterface.fragmentLink;
        propff: ^astInterface.fragmentForm;
        status: @boolean;
        S: @stack (# element:: text #)
     enter (propff[],fg[])
     do
        propText.clear;
        (mps[],propff[],propText[],'')
          ->prettyprintFragment;
        (if trace[9] then
            'astToProps, prettyprinted ast: '->putLine;
            '<'->put;
            propText[]->putText;
            '>'->put;
            newLine;
            
        if);
        propText.reset;
        (if fg[] = none then
            'astToProps: fg is none!!'->putLine
         else
            (if fg.fragmentlist[] = none then
                'astToProps: fg.fragmentlist is none!!'->putLine
             else
                fg.fragmentlist.scan
                  (# 
                  do
                     (if (current.type = mps.linkType) then
                         current.name[]->S.push
                     if)
                  #);
                loop:
                (if not S.empty then
                    S.pop->fg.fragmentList.deleteLocalName; restart loop
                if);
                true->status;
                l:
                (propText[],screen[])
                  ->fg.parseProperty
                    (#
                       parseErrors::< (* exception called if parse-errors *) 
                         (# 
                         do
                            'Temporary parse errors in the property list, please ignore'
                              ->screen.putLine;
                            false->status;
                            leave l;
                            
                         #);
                       doubleFormDeclaration::<
                       (* exception called if two fragmentForms with the same name *)
                       
                         (# 
                         do
                            ' this one is never called!!! double form declaration'
                              ->screen.putLine;
                            false->status;
                            leave l
                         #);
                       
                    #)->status;
                (if trace[9] then
                    'parseProperty status: '->putText;
                    (if status then 'true'->putText else 'false'->putText if);
                    newLine;
                    (if fg.prop.propList.Size
                     // 0 then 'The property list is emty'->putLine; 
                     else
                        fg.prop.scanProp
                          (#
                             doProp::< 
                               (# 
                               do
                                  prop[]->putText;
                                  ' '->put;
                                  scanParameters
                                    (#
                                       doString::< 
                                         (# 
                                         do
                                            ''''->put;
                                            s[]->putText;
                                            ''''->put;
                                            ' '->put;
                                            
                                         #);
                                       doName::< 
                                         (#  do n[]->putText; ' '->put;  #);
                                       doConst::< 
                                         (#  do c->putInt; ' '->put;  #);
                                       
                                    #);
                                  newLine;
                                  
                               #);
                             
                          #);
                        
                    if);
                    ;
                    
                if)
            if)
        if)
     exit status
     #);
   propsToAst:
     (#
        propText: @text;
        synCatNo: @integer;
        fg,propfg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        pos: @integer
     enter fg[]
     do
        (mps[],fg[],propText[],'')
          ->prettyprintFragment (# onlyProperties::< trueObject #);
        (if trace[9] then
            'PropsToAst, prettyprint of properties:'->putLine;
            '<'->put;
            propText[]->putText;
            '>'->put;
            newLine;
            
        if);
        mps.newFragmentGroup->propfg[];
        'Prop'->(fg.name).copyAppend->propfg.name;
        mps.top.topgroup[]->propfg.father;
        propertyGrammar[]->mps.newFragmentForm->ff[];
        propText.reset;
        (if
        (1 (*root*) ,propText[],screen[],ff[])->propertyGrammar.parser.doParse
         then
            'property'->ff.name; ff[]->propfg.fragmentList.addFragment
         else
            'Parse errors in property list'->putLine; proptext[]->putLine; 
        if)
     exit propfg[]
     #)
#)  

-- editorenvNew: DoPart --
do
   (if groupName[]->editorenvPrivate.fileWriteable then
       (groupName[],formName[],grammarName[],1,theBrowser[],false)
         ->editorenvPrivate.doNewGroup->fg[];
       (if fg[]
        // none then
           grammarName[]->putLine;
           groupName[]->putLine;
           formName[]->putLine;
           ' fragmentgroup not created'->putLine;
           
        else
           fg.markAsChanged
           (* this is done in order to
            open the new group in ymer *)
       if)
    else
       (none ,'Error in path','New...')->UI.alertUser
   if)  

-- editorEnvNewBetaProgram: DoPart --
do
   newprog:
     (# help,language: ^text; f,f2: @file
     do
        (if name[] = none then
        (*editorenvPrivate.nextUntitled->help[]; help.copy->f.name*)
            loop:
              (# 
              do
                 UI.fileCreationDialog->name[];
                 (if name[] <> none then
                     name[]->f.name->editorenvPrivate.stripExtension->f.name;
                     (if not (f.name->editorenvPrivate.fileWriteable) then
                         (none ,'No write permission','New BETA Program')
                           ->UI.alertUser;
                         restart loop
                     if)
                  else
                     leave newprog
                 if)
              #)
         else
            name.copy->help[]; help.copy->f.name
        if);
        name.copy->help[];
        mps.astFileExtension->help.append;
        help[]->f2.name;
        (if f2.entry.exists
         // true then
            ' does already exist\nOverwrite?'->help.putText;
            (none ,'New BETA Program',help[])
              ->UI.promptForBoolean
                (#
                   ok::< 
                     (# 
                     do
                        'program'->name[];
                        'beta'->language[];
                        (f.name,name[],language[],betaGram.descriptorForm,
                         theBrowser[],isAfrejaEditor)
                          ->editorenvPrivate.doNewGroup->fg[];
                        (if fg[]
                         // none then
                            name[]->putText;
                            ' fragmentgroup not created'->putLine;
                            
                         else
                            fg.markAsChanged
                            (* this is done in order to
                             open the new group in ymer *)
                        if)
                     #)
                #)
         else
            'program'->name[];
            'beta'->language[];
            (f.name,name[],language[],betaGram.descriptorForm,theBrowser[],
             isAFrejaEditor)->editorenvPrivate.doNewGroup->fg[];
            (if fg[]
             // none then
                name[]->putText; ' fragmentgroup not created'->putLine; 
             else
                (if
                fg.name->mps.expandToFullPath->editorenvPrivate.fileWriteable
                 then
                    fg.markAsChanged
                    (* this is done in order to
                     open the new group in ymer *)
                if)
            if)
        if)
     #)  

-- editorenvNewBetaLibrary: DoPart --
do
   newLib:
     (# help,language: ^text; f,f2: @file
     do
        (if name[] = none then
        (*editorenvPrivate.nextUntitled->help[]; help.copy->f.name*)
            loop:
              (# 
              do
                 UI.fileCreationDialog->name[];
                 (if name[] <> none then
                     name[]->f.name->editorenvPrivate.stripExtension->f.name;
                     (if not (f.name->editorenvPrivate.fileWriteable) then
                         (none ,'No write permission','New BETA Library')
                           ->UI.alertUser;
                         restart loop
                     if)
                  else
                     leave newLib
                 if)
              #)
         else
            name.copy->help[]; help.copy->f.name
        if);
        name.copy->help[];
        mps.astFileExtension->help.append;
        help[]->f2.name;
        (if f2.entry.exists
         // true then
            ' does already exist\nOverwrite?'->help.putText;
            (none ,'New BETA Library',help[])
              ->UI.promptForBoolean
                (#
                   ok::< 
                     (# 
                     do
                        'lib'->name[];
                        'beta'->language[];
                        (f.name,name[],language[],betaGram.descriptorForm,
                         theBrowser[],isAFrejaEditor)
                          ->editorenvPrivate.doNewGroup->fg[];
                        (if fg[]
                         // none then
                            name[]->putText;
                            ' fragmentgroup not created'->putLine;
                            
                         else
                            fg.markAsChanged
                            (* this is done in order to
                             open the new group in ymer *)
                        if)
                     #)
                #)
         else
            'lib'->name[];
            'beta'->language[];
            (f.name,name[],language[],betaGram.attributesForm,theBrowser[],
             isAFrejaEditor)->editorenvPrivate.doNewGroup->fg[];
            (if fg[]
             // none then
                name[]->putText; ' fragmentgroup not created'->putLine; 
             else
                (if
                fg.name->mps.expandToFullPath->editorenvPrivate.fileWriteable
                 then
                    fg.markAsChanged
                    (* this is done in order to
                     open the new group in ymer *)
                if)
            if)
        if)
     #)  

-- openFormBody: Descriptor --
(#
   f: ^astInterface.fragment;
   fg: ^astInterface.fragmentGroup;
   node: ^astInterface.ast;
   fe: ^codeviewer;
   ge: ^groupEditor;
   formName,thePath,help: ^text;
   dashPosition: @integer;
   doOpen:
     (#
        input: ^text;
        fg: ^astInterface.fragmentGroup;
        error: @stream;
        fil: @file;
        
     enter input[]
     do
        thisOperation:
        (input[],error[])
          ->mps.top.open
            (#
               myException:
                 (# msg,help: ^text
                 enter msg[]
                 do
                    ': '->help[];
                    input[]->help.putText;
                    help[]->msg.append;
                    (none ,msg[],'Alert')->UI.alertUser;
                    none ->f[];
                    none ->mps.theCatcher[];
                    leave thisOperation
                 #);
               readAccessError::< 
                 (#  do 'Read access error'->myException #);
               fragmentNotExisting::< 
                 (#  do 'Non-existent fragment file'->myException #);
               grammarNotFound::< 
                 (#  do 'Grammar not found for'->myException #);
               badFormat::<  (#  do 'Bad AST format'->myException #);
               WriteAccessOnLstFileError::< 
                 (# 
                 do
                    'Access error on .lst file'->myException;
                    true->continue (*'Access error on .lst file'->myException*)
                 #);
               writeAccessError::< 
                 (# 
                 do
                    'No write access'->myException;
                    true
                      ->continue
                      (*'Write access error'->myException
                       * *)
                 #);
               startingParsing::< 
                 (# 
                 do
                    'Parsing '->putText;
                    input[]->putText;
                    '...'->putLine;
                    'myStartingParsing'->putLine;
                    
                 #);
               ParseErrors::< 
                 (# 
                 do (*none ->f[];*)
                    'myParseErrors'->putline; ; leave thisOperation
                 #);
               DoubleFormDeclaration::< 
                 (# 
                 do 'Two forms are declared with the same name'->myException
                 #);
               fatalParseError::< 
                 (# 
                 do (*none ->f[];*)
                    'errNo->myFatalParseError'->putLine; leave thisOperation
                 #);
               OtherFileError::< 
                 (# 
                 do
                    input[]->fil.name;
                    (if fil.entry.exists
                     // true then
                        (if fil.entry.isDirectory
                         // true then 'Is a directory'->myException
                         else
                            'Other file error'->myException
                        if)
                    if)
                 #);
               
            #)->f[];
        (if (f[] <> none ) then
            (if f.type
             // mps.groupType then
                f[]->fg[];
                (*fg[]->gettextfilename->textfile.name;*)
                (*fg.textfilename->textfile.name;
                 (if textfile.entry.exists
                 // false then
                 'Text file does not exist'->UI.statusMessage;
                 fg[]->groupEditorList.findGE->ge[];
                 (if ge[]<>none then true->ge.needToPrettyPrint if);
                 if);
                 *)
                
            if);
            (if not fg.isRealOpen then fg.realOpen if)
        if)
     exit fg[]
     #);
   
do
   (if trace[2] then 'openForm: '->putText; name[]->putLine;  if);
   '-'->name.findCh (#  do inx->dashPosition #);
   (if dashPosition <> 0 then
       (dashPosition+1,name.length)->name.sub->formName[];
       (1,dashPosition-1)->name.sub->thePath[];
       thePath[]->doOpen->fg[];
       (if fg[] <> none then
           (formName[],screen[])->fg.open->ff[];
           (if ff[] <> none then
               (if index
                // 0 then none ->node[]
                else
                   index->ff.indexToNode->node[];
                   index
                     ->ff.indexToNode
                       (#
                          indexOutOfRange::< 
                            (# 
                            do 'indexOutOfRange'->putLine; true->continue; 
                            #);
                          noSuchSymbol::< 
                            (# 
                            do 'noSuchSymbol'->putLine; true->continue; 
                            #);
                          grammarGenRefArrayError::< 
                            (# 
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                               
                            #)
                       #)->node[]
               if);
               
            else
               'OpenForm: The fragment form: '->putText;
               formName[]->putText;
               ' not found'->putLine;
               
           if);
           
        else
           'openform: fg[] is none'->putLine
       if)
    else
       'OpenForm: Syntax is <fragmentGroupName>-<fragmentFormName>'->putline;
       name[]->putline;
       
   if);
   
#)  

-- editorenvSaveAll: DoPart --
do   

-- editorenvMakeNewTextFile: Descriptor --
(# textFile: ^text; f: @file
do
   fg[]->editorenvPrivate.backupTextFile;
   'Prettyprinting '->putText;
   fg.name->putText;
   fg.textFileName->textFile[];
   '...'->putText;
   (if fg.fragmentList[] <> none then
       (mps[],fg[],none ,textFile[])
         ->prettyprintFragment (# width:: (# do 100->value #) ;
                                  showSemanticErrors:: falseObject #);
       
    else
       (mps[],fg[],none ,textFile[])
         ->prettyprintFragment
       (# width:: (# do 100->value #) ;
          onlyProperties::< trueObject; showSemanticErrors::< falseObject
           #)
   if);
   ' Done'->putLine;
   textfile[]->f.name;
   (textfile,fg.modtime-120)->setEntryModtime;
   
#)  

-- editorenvCreateGroupEditor: DoPart --
do
     (# textfile: @file; didRecover: @boolean
     do
        (if not onGoingRecovery and (groupeditorList.size = 0) and not
        openingFrejaEditor then
            fg[]->editorenvPrivate.checkAutoSaveFile->didRecover
        if);
        (if trace[2] then
            'creating groupEditor: '->putText; fg.name->putLine; 
        if);
        &groupEditor[]->ge[];
        fg[]->ge.fg[];
        theBrowser[]->ge.theBrowser[];
        fg[]->editorenvPrivate.checkWriteAccess->ge.groupfileWriteable;
        globalWriteProtection or readOnly or not ge.groupfileWriteable
          ->ge.isReadOnly;
        (if didRecover then
            ge.grouptouched
         else
            true->ge.autoSaveFileExists
        if);
        (if trace[2] then
            'create groupeditor globalWriteProtection: '->putText;
            (if globalWriteProtection then
                'true'->putLine
             else
                'false'->putLine
            if);
            'create groupeditor readonly: '->putText;
            (if readOnly then 'true'->putLine else 'false'->putLine if);
            'create groupeditor ge.groupfileWriteable: '->putText;
            (if ge.groupfileWriteable then
                'true'->putLine
             else
                'false'->putLine
            if);
            'create groupeditor ge.isReadOnly: '->putText;
            (if ge.isReadOnly then 'true'->putLine else 'false'->putLine if)
        if);
        fg.textfilename->textfile.name;
        (if not textfile.entry.exists then
            '### Text file does not exist'->putLine;
            true->ge.needToUpdateTextFile;
            
        if);
        fg[]->editorenvPrivate.getGrammarName->ge.grammarName[];
        ge[]->fgHandler.subscribe;
        ge[]->append;
        (* (if not onGoingRecovery and (ge.fgh.groupEditors.size = 1) and not
         openingFrejaEditor then
         ge.fg[]->editorenvPrivate.checkAutoSaveFile
         if)*)
        
     #)  

-- editorenvFindOrCreateGroupEditor: DoPart --
do
     (# textfile: @file
     do
        (theBrowser[],fg[])->findGroupEditor->ge[];
        (if ge[] = none then
            (theBrowser[],fg[],readOnly)->createGroupEditor->ge[]
        if)
     #)  

-- editorenvCreateFormEditor: Descriptor --
(# help: ^text; 
do
   (if ge[] <> none then
   (* overfloedigt theEditorRoot.frag[]->ge.formeditorList.findEditor->fe[];*)
       (if trace[2] then
           'creating formeditor: '->putText;
           (if theEditorRoot[] <> none then
               (theEditorRoot.frag.father).name->putText;
               '-'->put;
               theEditorRoot.frag.name->putLine;
               
            else
               'theEditorRoot is none'->putLine
           if)
       if);
       (if theSifTextEditor[] <> none then
           &theSifTextEditor.codeviewerType[]->fe[];
           fe[]->theSifTexteditor.SifViewer[];
           theSifTextEditor[]->fe.theSifTextEditor[];
           (if theEditorRoot[] <> none then
               theEditorRoot.frag[]->theSifTexteditor.frag[];
               theEditorRoot[]->theSifTexteditor.editorRoot[];
               (mps[],theEditorRoot.frag.grammar[],UI[],theSifTextEditor[],
                theEditorRoot.Frag[],theEditorRoot[],initialSelection[])
                 ->fe.init;
               
            else
               (if ff[] <> none then
                   ff[]->theSifTexteditor.frag[];
                   none ->theSifTexteditor.editorRoot[];
                   (mps[],ff.grammar[],UI[],theSifTextEditor[],ff[],
                    theEditorRoot[],initialSelection[])->fe.init;
                   
                else
                   'createFormEditor: theEditorRoot and ff are none!!'->putLine
               if)
           if);
           fe[]->ge.formeditorList.append;
           ge[]->fe.thisGroupEditor[];
           (if ge.groupFileWriteable then
               globalWriteProtection or ge.isReadOnly->fe.isReadOnly
                 ->fe.theSifTextEditor.isReadOnly;
               
            else
               true->fe.isReadOnly->fe.theSifTextEditor.isReadOnly; 
           if);
           (if trace[2] then
               'createFormEditor isReadOnly: '->putText;
               (if fe.theSifTextEditor.isReadOnly then
                   'true'->putLine
                else
                   'false'->putLine
               if);
               
           if);
           
        else
           'CreateFormEditor: theSifTexteditor is none!'->putLine
       if)
    else
       'CreateFormEditor: ge is none!'->putLine
   if);
   
#)  

-- editorenvFindOrCreateFormEditor: Descriptor --
(# help: ^text; 
do
   (if ge[] <> none then
       (if theSifTextEditor[] <> none then
           (if theSifTextEditor.SifViewer[] <> none then
               (if theSifTexteditor.textediting then
                   false->theSifTextEditor.textediting;
                   'Textediting is abandoned in '->help[];
                   help.newLine;
                   (theSifTextEditor.frag.father).name->help.putText;
                   '-'->help.put;
                   theSifTextEditor.frag.name->help.putText;
                   (none ,help[],'Textediting abandoned')->UI.alertUser;
                   (*theSifTextEditor.sifViewer.doParseText*)
                   
                else
                   none ->theSifTextEditor.sifViewer.theSifTextEditor[];
                   (* the current editor is not visible anymore *)
                   
               if)
           if);
           (if theEditorRoot[] <> none then
               theEditorRoot.frag[]->ge.formeditorList.findEditor->fe[];
               (if fe[] <> none then
                   fe[]->theSifTexteditor.SifViewer[];
                   theSifTextEditor[]
                     ->theSifTextEditor.sifViewer.theSifTextEditor[];
                   fe.editorRoot.frag[]->theSifTextEditor.frag[];
                   fe.editorRoot[]->theSifTexteditor.editorRoot[];
                   fe.isReadOnly->theSifTexteditor.isReadOnly;
                   (if trace[2] then
                       'findOrcreateFormEditor isReadOnly: '->putText;
                       (if fe.theSifTextEditor.isReadOnly then
                           'true'->putLine
                        else
                           'false'->putLine
                       if);
                       
                   if);
                   fe.doReprettyprint;
                   fe.cs->fe.setFocus
                else
                   (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],
                    ge[])->createFormEditor->fe[]
               if)
            else
               (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
                 ->createFormEditor->fe[]
           if)
        else
           'findOrCreateFormEditor: theSifTexteditor is none!'->putLine
       if)
    else
       'findOrCreateFormEditor: ge is none!'->putLine
   if);
   
#)  

-- editorenvFindGroupEditor: DoPart --
do
(*'grouplist Size: '->putText;
 size->putInt;
 newLine;
 scan
 (# 
 do
 current.fg.name->putText;
 ': '->putLine;
 'formList Size: '->putText;
 size->putInt;
 newLine;
 current.formeditorList.scan
 (# 
 do
 current.id->putInt;
 ' '->put;
 (current.frag.father).name->putText;
 '-'->put;
 current.frag.name->putText;
 putline
 #);
 putLine
 #);*)
   search: scan
     (# 
     do
        (if theBrowser[] <> none then
            (if (fg[] = current.fg[]) and (theBrowser[] = current.theBrowser[])
             then
                current[]->ge[]; leave search
            if)
         else
            'FindGroupEditor: theBrowser is none'->putLine
        if)
     #)  

-- editorenvShowEditors: DoPart --
do
   'groupEditorList: '->putText;
   groupEditorList.size->putInt;
   newLine;
   groupEditorList.scan
     (# 
     do
        current.fg.name->putLine;
        'formEditorList: '->putText;
        current.formEditorList.size->putInt;
        newLine;
        current.formEditorList.scan
          (#  do current.frag.name->putLine #);
        
     #)  

-- findEditorForFormBody: Descriptor --
(# ge: ^groupEditor; help: ^text; 
do
   (ymerCallback.theBrowser[],ff.father,false)
     ->groupeditorList.findOrCreateGroupEditor->ge[];
   (if ge[] <> none then
       ff[]->ge.formeditorList.findEditor->fe[];
       (if fe[] <> none then
           (if (selectedNode[] <> none ) then
               (selectedNode[],1,0,0)->fe.setFocus
            else
               fe.cs->fe.setFocus
           if)
        else
           ' findEditorForFormBody: editor not found'->putLine
       if)
   if);
   
#)  

-- findFormEditorId: DoPart --
do
   (if trace[1] then 'findFormEditorId'->putLine;  if);
     (# ge: ^groupEditor; help: ^text
     do
        search: groupeditorList.scan
          (# 
          do
             id->current.formeditorList.findEditorId->fe[];
             (if fe[] <> none then leave search if);
             
          #)
     #)  

-- editorenvNonterminalsExist: Descriptor --
(#
   nonterminalsExistInForm:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExist: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExist;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExist; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExist; ff.root[]->unExp[]
        if);
        
     exit (unexpandedExist,unExp[])
     #);
   
do
   thisOperation: groupEditorList.scan
     (# ge: ^groupEditor; (*ff: ^astInterface.fragmentForm;*) 
     do
        current[]->ge[];
        (if ge.fg[] = none then
            'scanGEs: ge.g[] is none!'->putLine; 
         else
            ge.fg.fragmentlist.scan
              (# help: ^text; 
              do
                 (if current.type = mps.formType then
                     (if current.f[] = none then screen[]->current.open if);
                     (*current.f[]->ff[];
                      ff.recomputeSlotChain;*)
                     current.f[]->nonterminalsExistInForm
                       ->(unexpandedExist,unExp[]);
                     (if unexpandedExist then leave thisOperation if)
                 if);
                 
              #);
            ge.fg[]->editorenvPrivate.recomputeSLOTchain
        if);
        
     #);
   
#)  

-- editorEnvInit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file
     do
        &clipBoard[]->clip[];
        history.init;
        metaGrammarInit;
        (* is only done if necessary *)
        (if trace[9]
         // true then '*************** prettygrammar.init'->putLine
        if);
        &mps.prettyprint[]->prettyprintGrammar[];
        prettyprintGrammar.init;
        '~beta/grammars/pretty/v2.3/prettyprint'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('prettyprint',screen[])->gg.open->prettyprintGrammar.grammarAst[];
            (if prettyprintGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->prettyprintGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        (if trace[9]
         // true then '*************** propertygrammar.init'->putLine
        if);
        &mps.property[]->propertyGrammar[];
        propertyGrammar.init;
        '~beta/grammars/property/v1.1/property'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('property',screen[])->gg.open->propertyGrammar.grammarAst[];
            (if propertyGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->propertyGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        &UI.cursor[]->rightButtonCursor[];
        &UI.cursor[]->textCursor[];
        <<SLOT setupCursors:Descriptor>>
     #)  

