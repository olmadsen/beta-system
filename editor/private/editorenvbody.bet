ORIGIN '../codeeditor';
INCLUDE '~beta/basiclib/v1.4/directory'
        'mypropertyparser'
        '~beta/pretty/v4.9.1/pplib'
        'modtime'
        '../searchdialog';
(*'~beta/mps/v4.9.1/propertyparser'*)
(*'~beta/mps/v4.9.1/propertyparser'*)
(*'~beta/mps/v4.9.1/propertyparser'*)
(*'~beta/mps/v4.9.1/propertyparser'*)
-- editorenvMetaGrammarInit: Descriptor --
(#
   theMetaGrammar: ^astInterface.treelevel;
   grammarWithPath,help: ^text;
   gg: ^astInterface.fragmentGroup;
   bobsfile: @file
do
   (if mg[] = none then
       (if mps.grammarTable.meta[] <> none then
           mps.grammarTable.meta[]->mg[]; 
        else
           &mps.metaGrammar[]->theMetaGrammar[]->mps.grammarTable.meta[]->mg[];
           theMetaGrammar.init;
           '~beta/grammars/metagram/v4.4/metagrammar'->grammarWithPath[];
           ('-meta'->grammarWithPath.copyAppend,screen[])->mps.top.open->gg[];
           (if gg[]
            // none then
               'Could not open: '->screen.putText;
               '-meta'->grammarWithPath.copyAppend->screen.putLine;
               (failure,'')->stop;
               
            else
               ('metagrammar',screen[])->gg.open->theMetagrammar.grammarAst[];
               (if theMetagrammar.grammarAst[]
                // none then
                   'No grammarAst for '->screen.putText;
                   grammarWithPath[]->screen.putLine;
                   (failure,'')->stop;
                   
                else
                   grammarWithPath[]->mps.expandToFullPath->help[];
                   '-parser'->help.append;
                   mps.parserFileExtension->help.append;
                   help[]->bobsFile.name;
                   (if bobsFile.entry.exists then
                       bobsFile.name->theMetagrammar.parser.initialize; 
                    else
                       'No parser available: '->screen.putText;
                       bobsFile.name->screen.putLine;
                       
                   if)
               if);
               
           if);
           
       if);
       
   if)
#)  

-- editorenvPrivate: Descriptor --
(#
   untitledNo (* used by newGroup and newBETAgroup *) : @integer;
   nextUntitled:
     (# t: ^text; 
     do
        untitledNo+1->untitledNo;
        'untitled'->t[];
        (if (untitledNo > 1)
         // true then t.length->t.setPos; untitledNo->t.putInt; 
        if)
     exit t.copy
     #);
   splitPath:
     (# e: @diskEntry;  enter e.path exit (e.path.head,e.path.name) #);
   splitFileName:
     (# e: @diskEntry; 
     enter e.path
     exit (e.path.name.prefix,e.path.name.suffix)
     #);
   stripExtension:
     (# e: @diskEntry; noExt: ^text; 
     enter e.path
     do
        e.path.head->noExt[];
        '/'->noExt.append;
        e.path.name.prefix->noExt.append;
        
     exit noExt[]
     #);
   fileWriteable:
   (* test whether the path is OK and the dir can be written into and whether the file can be written
    on if the path is OK and the file exists *)
     (# f: @file enter f.name exit f.entry.writeable #);
   showEditors:
     (# 
     do
        'groupEditorList: '->putText;
        groupEditorList.size->putInt;
        newLine;
        groupEditorList.scan
          (# 
          do
             current.fg.name->putLine;
             'formEditorList: '->putText;
             current.formEditorList.size->putInt;
             newLine;
             current.formEditorList.scan
               (#  do current.frag.name->putLine #);
             
          #)
     #);
   doNewGroup:
     (#
        theFile,fragmentName,language: ^text;
        synCatNo: @integer;
        theBrowser: ^object;
        isAFrejaEditor: @boolean;
        fg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        doParse: @boolean;
        help,t,keepName: ^text;
        propText: ^text;
        status: @boolean;
        
     enter
     (theFile[],fragmentName[],language[],synCatNo,theBrowser[],isAFrejaEditor)
     do
        thisOperation:
          (# 
          do
             (if trace[3] then
                 'doNewGroup:'->putLine;
                 theFile[]->putLine;
                 fragmentName[]->putLine;
                 language[]->putLine;
                 synCatNo->putInt;
                 newLine
             if);
             groupEditorlist.scan
               (# theGroupEditor: ^groupEditor
               do
                  current[]->theGroupEditor[];
                  theFile[]->mps.expandToFullPath->help[];
                  (if
                  (theGroupEditor.fg.name->mps.expandToFullPath->help.equal)
                   then
                      (none ,'A group editor already exists','Alert')
                        ->UI.alertUser;
                      leave thisOperation
                  if)
               #);
             (if (fragmentName[] <> none ) then
                 (if (fragmentName.length > 0) then
                     (if ('beta'->language.equal) then
                         theFile[]->mps.expandToFullPath
                           ->mps.top.newGroup
                             (# alreadyOpen::<  (#  do true->continue #)
                             #)->fg[];
                         betagrammar[]->fg.defaultGrammar[];
                         betagrammar[]->mps.newFragmentForm->ff[];
                         'ORIGIN ''~beta/basiclib/v1.4/betaenv'''->propText[];
                         (if isAFrejaEditor then
                             '; '->propText.putLine;
                             'INCLUDE ''~beta/freja/v2.1/associations'''
                               ->propText.putLine
                         if);
                         propText.reset;
                         l:
                         (propText[],screen[])
                           ->fg.parseProperty
                             (#
                                parseErrors::<
                                (* exception called if parse-errors *) 
                                  (# 
                                  do
                                     'parse errors in the property list'
                                       ->screen.putLine;
                                     leave l;
                                     
                                  #);
                                doubleFormDeclaration::<
                                (* exception called if two fragmentForms with the same name *)
                                
                                  (# 
                                  do
                                     ' this one is never called!!! double form declaration'
                                       ->screen.putLine;
                                     leave l
                                  #);
                                
                             #)->status;
                         (if synCatNo
                          // betaGram.descriptorForm then
                             '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                               ->t[];
                             true->doParse;
                             
                          // betaGram.attributesForm then
                             '<<NameDecl>>: <<PrefixOpt>> (# <<AttributeDeclOpt>> <<EnterPartOpt>> <<DoPartOpt>> <<ExitPartOpt>> #)\n'
                               ->t[];
                             true->doParse;
                             
                          else
                             '<<PrefixOpt>> (# <<AttributeDeclOpt>> do <<ImpOpt>> #)\n'
                               ->t[];
                             true->doParse;
                             
                         if);
                         (if doParse
                          // true then
                             t.reset;
                             (synCatNo,t[],screen[],ff[])
                               ->betaGrammar.parser.doParse;
                             
                         if);
                         fragmentName[]->ff.name;
                         ff[]->fg.fragmentList.addFragment;
                         ;
                         
                      else
                         theFile[]->mps.expandToFullPath
                           ->mps.top.newGroup
                             (# alreadyOpen::<  (#  do true->continue #)
                             #)->fg[];
                         (language[],screen[])
                           ->mps.grammarTable.find
                             (#
                                ifNotFound::< 
                                  (# help: @text
                                  do
                                     'Grammar: '->help;
                                     language[]->help.putText;
                                     ' not found'->help.putText;
                                     help[]->putLine;
                                     (none ,help[],'Alert')->UI.alertUser;
                                     leave thisOperation
                                  #);
                                
                             #)->mps.newFragmentForm->ff[];
                         fragmentName[]->ff.name;
                         ff[]->fg.fragmentList.addFragment;
                         ff.grammar[]->fg.defaultGrammar[]
                     if);
                     
                 if);
                 
             if);
             
          #);
        
     exit fg[]
     #);
   ASTGC:
     (#
        fg: ^astInterface.fragmentGroup;
        ff,newff: ^astInterface.fragmentform;
        
     enter fg[]
     do
        fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[];
                 loop: ff.prop.scanProp
                   (#
                      doProp::< 
                        (# 
                        do
                           prop.makeLC;
                           (if ('touched'->prop.equal) then
                               ' AST GC in '->putText;
                               ff.name->putText;
                               ' ('->putText;
                               ff.a.range->putInt;
                               '->'->putText;
                               ff.grammar[]->mps.newFragmentForm->newff[];
                               newff[]->ff.root.copy->newff.root[];
                               ff.name->newff.name;
                               ff.grammar[]->newff.grammar[];
                               fg[]->newff.father;
                               newff[]->current.f[];
                               leave loop
                           if)
                        #);
                      
                   #);
                 
             if)
          #);
        
     #);
   recomputeSLOTchain:
     (# fg: ^astInterface.fragmentGroup; ff: ^astInterface.fragmentform; 
     enter fg[]
     do
        fg.fragmentList.scan
          (# 
          do
             (if current.type = mps.formType then
                 current.f[]->ff[];
                 loop: ff.prop.scanProp
                   (#
                      doProp::< 
                        (# 
                        do
                           prop.makeLC;
                           (if ('touched'->prop.equal) then
                               'Recomputing slot chain for: '->putText;
                               ff.name->putLine;
                               ff.recomputeSlotChain;
                               leave loop
                           if)
                        #);
                      
                   #);
                 
             if)
          #);
        
     #);
   getGrammarName:
     (# g: ^astInterface.fragmentGroup; name: ^text; 
     enter g[]
     do
          (# ff: ^astInterface.fragmentForm; 
          do
             (if g[] <> none then
                 loop:
                 (if (g.fragmentList[] <> none )
                  // true then
                     g.fragmentList.scan
                       (# 
                       do
                          (if current.type
                           // mps.formType then
                              current.f[]->ff[];
                              ff.grammar.grammarIdentification->name[];
                              leave loop
                          if);
                          
                       #);
                     
                  else
                     'getGrammarFileName: fragmentList is empty!!'->putLine; 
                 if)
              else
                 'getGrammarFileName: g[] is none!!'->putLine
             if)
          #)
     exit name[]
     #);
   extendedMarkAsChanged:
     (# g: ^astInterface.fragmentGroup; feedback,status: @boolean
     enter (g[],feedback)
     do
          (# help: @text; 
          do
             true->status;
             thisOperation:
               (# 
               do
                  g.markAsChanged
                    (#
                       writeAccessError::< 
                         (# 
                         do
                            (if feedback then
                                'Write access error: '->help;
                                g.fullName->help.append;
                                (none ,help[],'Alert')->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       noSpaceLeftError::< 
                         (# 
                         do
                            (if feedback then
                                (none ,'Disk is full','Alert')->UI.alertUser; 
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       otherFileError::< 
                         (# 
                         do
                            (if feedback then
                                (none ,
                                 'Other error, probably disk full, please check',
                                 'Alert')->UI.alertUser;
                                
                            if);
                            true->continue;
                            false->status;
                            
                         #);
                       
                    #);
                  (* 'extendedMarkAsChanged: g.modtime: '->putText;
                   g.modtime->putInt;
                   newLine;
                   *)
                  
               #)
          #)
     exit status
     #);
   extendedSaveBackup:
     (# ext: ^text; g: ^astInterface.fragmentGroup; status: @boolean
     enter (ext[],g[])
     do
          (#
             f: @file;
             dirWriteable:
               (# f: @file enter f.name exit f.entry.writeable #)
          do
             true->status;
             g.diskfileName->f.name;
             (if (f.entry.path.head->dirWriteable)
              // true then
                 (if f.entry.writeable
                  // true then ext[]->g.saveBackup
                  else
                       (# t: @text
                       do
                          'No write access to the file: "'->t;
                          f.name->t.append;
                          '"'->t.putline;
                          false->status
                       #)
                 if)
              else
                   (# t: @text
                   do
                      'No write access to the directory: "'->t;
                      f.entry.path.head->t.append;
                      '"'->t.putline;
                      false->status
                   #)
             if)
          #)
     exit status
     #);
   backupTextFile:
     (#
        fg: ^astInterface.fragmentGroup;
        textFile,tildeTextFile: ^text;
        f: @file
     enter fg[]
     do
        (if true (*writeAccess*)
         // true then
            fg.textFileName->textFile[]->f.name;
            textFile.copy->tildeTextFile[];
            '~'->tildeTextFile.append;
            (if f.entry.exists
             // true then
                newLine;
                'Renaming text file to: '->putText;
                tildeTextFile[]->putLine;
                tildeTextFile[]->f.entry.rename;
                
            if);
            
         else
            (none ,'This file is read-only','Alert')->UI.alertUser; 
        if);
        
     #);
   makeNewTextFile:
     (# fg: ^astInterface.fragmentGroup; textFile: ^text; f: @file
     enter fg[]
     do
        fg[]->backupTextFile;
        'Prettyprinting '->putText;
        fg.name->putText;
        fg.textFileName->textFile[];
        '...'->putText;
        (if fg.fragmentList[] <> none then
            (mps[],fg[],none ,textFile[])
              ->prettyprintFragment
                (# showSemanticErrors::< falseObject #);
            
         else
            (mps[],fg[],none ,textFile[])
              ->prettyprintFragment
                (#
                   onlyProperties::< trueObject;
                   showSemanticErrors::< falseObject
                #)
        if);
        ' Done'->putLine;
        textfile[]->f.name;
        (textfile,fg.modtime-120)->setEntryModtime;
        
     #);
   deleteAutoSaveFile:
     (# fg: ^astInterface.fragmentGroup; help,autosaveFile: ^text; f: @file
     enter fg[]
     do
        fg.fullName->help[];
        help.copy->autoSaveFile[];
        mps.astFileExtension->autoSaveFile.putText;
        '#'->autoSaveFile.put;
        autoSaveFile[]->f.name;
        (if f.entry.exists // true then f.delete if);
        
     #);
   checkAutoSaveFile:
     (#
        help,grammarName: ^text;
        groupFile,autoSaveFile: @file;
        g: ^astInterface.fragmentGroup;
        writeAccess: @boolean;
        ge: ^groupEditor
     enter g[]
     do
        (if ymerCallBack[] <> none then
            (if g[] = none then
                'This fragment group is none'->putLine; 
             else
                (if g.fragmentlist[] = none then
                    'CheckAutoSaveFile: This fragment group has no fragments'
                      ->putLine;
                    
                 else
                    g[]->getGrammarName->grammarName[];
                    (if grammarName[] = none then
                        
                     else
                    (* do not backup *)
                        true->writeAccess;
                        (if ('property'->grammarName.equal) then
                        (* no backup needed *)
                            
                         else
                            thisOperation:
                              (# 
                              do
                                 g.diskFileName->help[];
                                 '#'->help.put;
                                 help[]->autoSaveFile.Name;
                                 g.diskFileName->groupFile.Name;
                                 (if groupFile.entry.exists and
                                 autoSaveFile.entry.exists then
                                     (if
                                     (autoSaveFile.entry.modTime >
                                      groupFile.entry.modTime) then
                                         (ymerCallBack.theBrowser[],g[])
                                           ->groupEditorList.findGroupEditor
                                           ->ge[];
                                         (if ge[] <> none then
                                             true->ge.autoSaveFileExists
                                          else
                                             'checkAutoSaveFile: the group editor was not found'
                                               ->putLine
                                         if);
                                         'Auto save file is newer'->help[];
                                         help.newLine;
                                         'Consider using the Recover Command'
                                           ->help.putText;
                                         (none ,help[],'Recover?')
                                           ->UI.alertUser;
                                         
                                     if)
                                 if);
                                 
                              #)
                        if);
                        
                    if);
                    
                if)
            if)
        if)
     exit writeAccess
     #);
   nonterminalExists:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExists: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExists;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExists; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExists; ff.root[]->unExp[]; 
        if);
        
     exit (unexpandedExists,unExp[])
     #);
   checkWriteAccess:
     (#
        fg: ^astInterface.fragmentGroup;
        writeAccess: @boolean;
        f: @file;
        path,name: ^text
     enter fg[]
     do fg.diskFileName->f.name; (f.entry.writeable)->writeAccess
     exit writeAccess
     #);
   astToProps:
     (#
        propText: @text;
        synCatNo: @integer;
        fg: ^astInterface.fragmentGroup;
        fl: ^astInterface.fragmentLink;
        propff: ^astInterface.fragmentForm;
        status: @boolean;
        S: @stack (# element:: text #)
     enter (propff[],fg[])
     do
        propText.clear;
        (mps[],propff[],propText[],'')
          ->prettyprintFragment (*(# test::<trueObject #)*) ;
        (if trace[9] then
            'astToProps, prettyprinted ast: '->putLine;
            '<'->put;
            propText[]->putText;
            '>'->put;
            newLine;
            
        if);
        propText.reset;
        (if fg[] = none then
            'astToProps: fg is none!!'->putLine
         else
            (if fg.fragmentlist[] = none then
                'astToProps: fg.fragmentlist is none!!'->putLine
             else
                fg.fragmentlist.scan
                  (# 
                  do
                     (if (current.type = mps.linkType) then
                         current.name[]->S.push
                     if)
                  #);
                loop:
                (if not S.empty then
                    S.pop->fg.fragmentList.deleteLocalName; restart loop
                if);
                true->status;
                l:
                (propText[],screen[])
                  ->fg.parseProperty
                    (#
                       parseErrors::< (* exception called if parse-errors *) 
                         (# 
                         do
                            'Temporary parse errors in the property list, please ignore'
                              ->screen.putLine;
                            false->status;
                            leave l;
                            
                         #);
                       doubleFormDeclaration::<
                       (* exception called if two fragmentForms with the same name *)
                       
                         (# 
                         do
                            ' this one is never called!!! double form declaration'
                              ->screen.putLine;
                            false->status;
                            leave l
                         #);
                       
                    #)->status;
                (if trace[9] then
                    'parseProperty status: '->putText;
                    status->putInt;
                    newLine;
                    (if fg.prop.propList.Size
                     // 0 then 'The property list is emty'->putLine; 
                     else
                        fg.prop.scanProp
                          (#
                             doProp::< 
                               (# 
                               do
                                  prop[]->putText;
                                  ' '->put;
                                  scanParameters
                                    (#
                                       doString::< 
                                         (# 
                                         do
                                            ''''->put;
                                            s[]->putText;
                                            ''''->put;
                                            ' '->put;
                                            
                                         #);
                                       doName::< 
                                         (#  do n[]->putText; ' '->put;  #);
                                       doConst::< 
                                         (#  do c->putInt; ' '->put;  #);
                                       
                                    #);
                                  newLine;
                                  
                               #);
                             
                          #);
                        
                    if);
                    ;
                    
                if)
            if)
        if)
     exit status
     #);
   propsToAst:
     (#
        propText: @text;
        synCatNo: @integer;
        fg,propfg: ^astInterface.fragmentGroup;
        ff: ^astInterface.fragmentForm;
        pos: @integer
     enter fg[]
     do
        (mps[],fg[],propText[],'')
          ->prettyprintFragment (# onlyProperties::< trueObject #);
        (if trace[9] then
            'PropsToAst, prettyprint of properties:'->putLine;
            '<'->put;
            propText[]->putText;
            '>'->put;
            newLine;
            
        if);
        mps.newFragmentGroup->propfg[];
        'Prop'->(fg.name).copyAppend->propfg.name;
        mps.top.topgroup[]->propfg.father;
        propertyGrammar[]->mps.newFragmentForm->ff[];
        propText.reset;
        (if
        (1 (*root*) ,propText[],screen[],ff[])->propertyGrammar.parser.doParse
         then
            'property'->ff.name; ff[]->propfg.fragmentList.addFragment
         else
            'Parse errors in property list'->putLine; proptext[]->putLine; 
        if)
     exit propfg[]
     #)
#)  

-- editorenvNew: DoPart --
do
   (if groupName[]->editorenvPrivate.fileWriteable then
       (groupName[],formName[],grammarName[],1,theBrowser[],false)
         ->editorenvPrivate.doNewGroup->fg[];
       (if fg[]
        // none then
           grammarName[]->putLine;
           groupName[]->putLine;
           formName[]->putLine;
           ' fragmentgroup not created'->putLine;
           
        else
           fg.markAsChanged
           (* this is done in order to
            open the new group in ymer *)
       if)
    else
       (none ,'Error in path','New...')->UI.alertUser
   if)  

-- editorEnvNewBetaProgram: DoPart --
do
   newprog:
     (# help,language: ^text; f: @file
     do
        (if name[] = none then
        (*editorenvPrivate.nextUntitled->help[]; help.copy->f.name*)
            loop:
              (# 
              do
                 UI.fileCreationDialog->name[];
                 (if name[] <> none then
                     name[]->f.name->editorenvPrivate.stripExtension->f.name
                       ->putLine;
                     (if not (f.name->editorenvPrivate.fileWriteable) then
                         (none ,'No write permission','New BETA Program')
                           ->UI.alertUser;
                         restart loop
                     if)
                  else
                     leave newprog
                 if)
              #)
         else
            name.copy->help[]; help.copy->f.name
        if);
        name.copy->help[];
        mps.astFileExtension->help.append;
        (if f.entry.exists
         // true then
            ' does already exist\nOverwrite?'->help.putText;
            (none ,'New BETA Program',help[])
              ->UI.promptForBoolean
                (#
                   ok::< 
                     (# 
                     do
                        'program'->name[];
                        'beta'->language[];
                        (f.name,name[],language[],betaGram.descriptorForm,
                         theBrowser[],isAfrejaEditor)
                          ->editorenvPrivate.doNewGroup->fg[];
                        (if fg[]
                         // none then
                            name[]->putText;
                            ' fragmentgroup not created'->putLine;
                            
                         else
                            fg.markAsChanged
                            (* this is done in order to
                             open the new group in ymer *)
                        if)
                     #)
                #)
         else
            'program'->name[];
            'beta'->language[];
            (f.name,name[],language[],betaGram.descriptorForm,theBrowser[],
             isAFrejaEditor)->editorenvPrivate.doNewGroup->fg[];
            (if fg[]
             // none then
                name[]->putText; ' fragmentgroup not created'->putLine; 
             else
                (if
                fg.name->mps.expandToFullPath->editorenvPrivate.fileWriteable
                 then
                    fg.markAsChanged
                    (* this is done in order to
                     open the new group in ymer *)
                if)
            if)
        if)
     #)  

-- editorenvNewBetaLibrary: DoPart --
do
   newLib:
     (# help,language: ^text; f: @file
     do
        (if name[] = none then
        (*editorenvPrivate.nextUntitled->help[]; help.copy->f.name*)
            loop:
              (# 
              do
                 UI.fileCreationDialog->name[];
                 (if name[] <> none then
                     name[]->f.name->editorenvPrivate.stripExtension->f.name
                       ->putLine;
                     (if not (f.name->editorenvPrivate.fileWriteable) then
                         (none ,'No write permission','New BETA Library')
                           ->UI.alertUser;
                         restart loop
                     if)
                  else
                     leave newLib
                 if)
              #)
         else
            name.copy->help[]; help.copy->f.name
        if);
        name.copy->help[];
        mps.astFileExtension->help.append;
        (if f.entry.exists
         // true then
            ' does already exist\nOverwrite?'->help.putText;
            (none ,'New BETA Library',help[])
              ->UI.promptForBoolean
                (#
                   ok::< 
                     (# 
                     do
                        'lib'->name[];
                        'beta'->language[];
                        (f.name,name[],language[],betaGram.descriptorForm,
                         theBrowser[],isAFrejaEditor)
                          ->editorenvPrivate.doNewGroup->fg[];
                        (if fg[]
                         // none then
                            name[]->putText;
                            ' fragmentgroup not created'->putLine;
                            
                         else
                            fg.markAsChanged
                            (* this is done in order to
                             open the new group in ymer *)
                        if)
                     #)
                #)
         else
            'lib'->name[];
            'beta'->language[];
            (f.name,name[],language[],betaGram.attributesForm,theBrowser[],
             isAFrejaEditor)->editorenvPrivate.doNewGroup->fg[];
            (if fg[]
             // none then
                name[]->putText; ' fragmentgroup not created'->putLine; 
             else
                (if
                fg.name->mps.expandToFullPath->editorenvPrivate.fileWriteable
                 then
                    fg.markAsChanged
                    (* this is done in order to
                     open the new group in ymer *)
                if)
            if)
        if)
     #)  

-- openFormBody: Descriptor --
(#
   f: ^astInterface.fragment;
   fg: ^astInterface.fragmentGroup;
   node: ^astInterface.ast;
   fe: ^codeviewer;
   ge: ^groupEditor;
   formName,thePath,help: ^text;
   dashPosition: @integer;
   doOpen:
     (#
        input: ^text;
        fg: ^astInterface.fragmentGroup;
        error: @stream;
        fil: @file;
        
     enter input[]
     do
        thisOperation:
        (input[],error[])
          ->mps.top.open
            (#
               myException:
                 (# msg,help: ^text
                 enter msg[]
                 do
                    ': '->help[];
                    input[]->help.putText;
                    help[]->msg.append;
                    (none ,msg[],'Alert')->UI.alertUser;
                    none ->f[];
                    none ->mps.theCatcher[];
                    leave thisOperation
                 #);
               readAccessError::< 
                 (#  do 'Read access error'->myException #);
               fragmentNotExisting::< 
                 (#  do 'Non-existent fragment file'->myException #);
               grammarNotFound::< 
                 (#  do 'Grammar not found for'->myException #);
               badFormat::<  (#  do 'Bad AST format'->myException #);
               WriteAccessOnLstFileError::< 
                 (# 
                 do
                    'Access error on .lst file'->myException;
                    true->continue (*'Access error on .lst file'->myException*)
                 #);
               writeAccessError::< 
                 (# 
                 do
                    'No write access'->myException;
                    true
                      ->continue
                      (*'Write access error'->myException
                       * *)
                 #);
               startingParsing::< 
                 (# 
                 do
                    'Parsing '->putText;
                    input[]->putText;
                    '...'->putLine;
                    'myStartingParsing'->putLine;
                    
                 #);
               ParseErrors::< 
                 (# 
                 do (*none ->f[];*)
                    'myParseErrors'->putline; ; leave thisOperation
                 #);
               DoubleFormDeclaration::< 
                 (# 
                 do 'Two forms are declared with the same name'->myException
                 #);
               fatalParseError::< 
                 (# 
                 do (*none ->f[];*)
                    'errNo->myFatalParseError'->putLine; leave thisOperation
                 #);
               OtherFileError::< 
                 (# 
                 do
                    input[]->fil.name;
                    (if fil.entry.exists
                     // true then
                        (if fil.entry.isDirectory
                         // true then 'Is a directory'->myException
                         else
                            'Other file error'->myException
                        if)
                    if)
                 #);
               
            #)->f[];
        (if (f[] <> none ) then
            (if f.type
             // mps.groupType then
                f[]->fg[];
                (*fg[]->gettextfilename->textfile.name;*)
                (*fg.textfilename->textfile.name;
                 (if textfile.entry.exists
                 // false then
                 'Text file does not exist'->UI.statusMessage;
                 fg[]->groupEditorList.findGE->ge[];
                 (if ge[]<>none then true->ge.needToPrettyPrint if);
                 if);
                 *)
                
            if);
            (if not fg.isRealOpen then fg.realOpen if)
        if)
     exit fg[]
     #);
   
do
   (if trace[2] then 'openForm: '->putText; name[]->putLine;  if);
   '-'->name.findCh (#  do inx->dashPosition #);
   (if dashPosition <> 0 then
       (dashPosition+1,name.length)->name.sub->formName[];
       (1,dashPosition-1)->name.sub->thePath[];
       thePath[]->doOpen->fg[];
       (if fg[] <> none then
           (formName[],screen[])->fg.open->ff[];
           (if ff[] <> none then
               (if index
                // 0 then none ->node[]
                else
                   index->ff.indexToNode->node[];
                   index
                     ->ff.indexToNode
                       (#
                          indexOutOfRange::< 
                            (# 
                            do 'indexOutOfRange'->putLine; true->continue; 
                            #);
                          noSuchSymbol::< 
                            (# 
                            do 'noSuchSymbol'->putLine; true->continue; 
                            #);
                          grammarGenRefArrayError::< 
                            (# 
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                               
                            #)
                       #)->node[]
               if);
               
            else
               'OpenForm: The fragment form: '->putText;
               formName[]->putText;
               ' not found'->putLine;
               
           if);
           
        else
           'openform: fg[] is none'->putLine
       if)
    else
       'OpenForm: Syntax is <fragmentGroupName>-<fragmentFormName>'->putline;
       name[]->putline;
       
   if);
   
#)  

-- editorenvSaveAll: DoPart --
do
   l: groupEditorList.scan
     (# help: ^text
     do
        (if (current.touched > 0) and not current.isAfrejaEditor then
            'Save changes to '->help[];
            current.fg.name->help.append;
            '?'->help.append;
            help[]->putLine;
            (none ,'Save group',help[])
              ->UI.promptForBoolean
                (#
                   ok::<  (#  do (true,false)->current.save #);
                   notOK::<  (#  do  #);
                   cancel::<  (#  do leave l #);
                   
                #)
         else
            (if current.needToUpdateTextFile and not current.isAFrejaEditor then
                current.fg[]->editorenvPrivate.makeNewTextFile
            if)
        if)
     #)  

-- editorenvSearchTextDialog: Descriptor --
(#
   searchd: @UI.search
     (#
        node: ^astInterface.ast;
        next:: 
          (# 
          do
             (if searchTextPrivate.thesearchText[] = none then
                 ''->searchTextPrivate.thesearchText[]
             if);
             (if searchTextPrivate.thesearchText[]->userText.equal then
                 (if
                 (('',1 (*dir.down*) ,none ,none ,none )->searchText->node[]) <>
                 none then
                     node[]->found
                  else
                     userText[]->notFound
                 if)
              else
                 (if
                 ((userText[],1 (*dir.down*) ,fg[],ff[],startNode[])->searchText
                    ->node[]) <> none then
                     node[]->found
                  else
                     userText[]->notFound
                 if)
             if)
          #);
        previous:: 
          (# 
          do
             (if (('',0 (*dir.up*) ,none ,none ,none )->searchText->node[]) <>
             none then
                 node[]->found
              else
                 userText[]->notFound
             if)
          #);
        cancel::  (#  do  #);
        
     #);
   help: ^text;
   grammar: ^mg.aGrammar
do
   searchd.open;
   (if fg[] <> none then
       l: fg.fragmentList.scan
         (# 
         do
            (if current.type = mps.formType then
                current.f[]->ff[];
                ff.grammar.grammarASt.root[]->grammar[];
                grammar.getProductionList->searchTextPrivate.prodList[];
                leave l
            if)
         #);
       (fg.name).copy->fragmentDefaultName->help[];
       (none ,help[],'Search for:',searchTextPrivate.thesearchText[])
         ->searchd.popup
    else
       'searchTextDialog: fg[] is none!'->putLine
   if)
#)  

-- editorenvSearchTextPrivate: Descriptor --
(#
   startNode,currentNode: ^astInterface.ast;
   thesearchText: ^text;
   prodList: ^mg.productionList;
   dir: @
     (#
        up: (#  exit 0 #);
        down: (#  exit 1 #);
        pred: (#  exit 2 #);
        next: (#  exit 3 #);
        root: (#  exit 4 #);
        extend: (#  exit 5 #);
        nextNonterminal: (#  exit 6 #);
        prevNonterminal: (#  exit 7 #);
        nonCyclicDown: (#  exit 8 #)
     #);
   checkSonNode:
     (#
     (* The following two situations makes it necessary
      * to go further down:
      * 1) This selection is a list node with only one son.
      * 2) This selection is a constructor node with only one son
      *)
        node: ^astInterface.ast;
        expNode: ^astInterface.expanded;
        prod: ^mg.prod;
        constructor: ^mg.constructor;
        consElemList: ^mg.consElemList;
        
     enter node[]
     do
        loop:
        (if (node.kind = mps.kinds.interior) then
            node[]->expNode[];
            (if expNode.noOfSons
             // 1 then
                expNode.symbol->searchTextPrivate.prodList.get->prod[];
                (if prod.symbol
                 // mg.listZero // mg.listOne then
                    expNode.getson1->node[]; restart loop; 
                 // mg.constructor then
                    prod[]->constructor[];
                    constructor.getConsElemList->consElemList[];
                    (if consElemList.noOfSons
                     // 1 then expNode.getson1->node[]; restart loop; 
                    if);
                    
                if);
                
            if);
            
        if)
     #);
   checkFatherNode:
     (#
     (* The following two situations makes it necessary to
      *  go further up:
      *  1) If the old selection was the only son and this
      *  selection is a list node.
      *  2) If the old selection was the only son 
      *  and this selection is constructor node.
      *  
      *  cs.length = 1 when this routine is called.
      *)
        node: ^astInterface.ast;
        fatherNode: ^astInterface.expanded;
        prod: ^mg.prod;
        constructor: ^mg.constructor;
        consElemList: ^mg.consElemList;
        
     enter node[]
     do
        loop:
        (if (node.father <> none ) then
            node.father->fatherNode[];
            fatherNode.symbol->searchTextPrivate.prodList.get->prod[];
            (if fatherNode.noOfSons
             // 1 then
                (if prod.symbol
                 // mg.constructor then
                    prod[]->constructor[];
                    constructor.getConsElemList->consElemList[];
                    (if consElemList.noOfSons
                     // 1 then fatherNode[]->node[]; restart loop; 
                    if);
                    
                if);
                
            if);
            
        if);
        
     #);
   select:
     (#
        direction: @integer;
        node: ^astInterface.ast;
        length: @integer;
        fatherNode: ^astInterface.expanded;
        exp: ^astInterface.expanded;
        current: ^astInterface.ast;
        goDownRight:
          (# 
          do
             loop:
               (# 
               do
                  (if (node.kind = mps.kinds.interior) then
                      node[]->exp[];
                      (if (exp.noOfSons <> 0) then (* go to rightmost son *)
                          exp.noOfSons->exp.get->node[]; restart loop; 
                      if);
                      
                  if);
                  
               #);
             1->length;
             
          #);
        sonExists:
          (# exists: @boolean; 
          do
             (if (node.kind <> mps.kinds.interior) then
                 false->exists; 
              else
                 node[]->exp[]; (exp.noOfSons <> 0)->exists; 
             if);
             
          exit exists
          #)
     do
        node[]->current[];
        node.father->fatherNode[];
        (if direction
         // dir.up then
            (if (node.father = none ) then
                &goDownRight; (* to keep symmetry *) 
             else
                (if (node.sonNo = 1) then (* no left brother *)
                    node.father->node[];
                    (* go up *)
                    (* node[]->checkFatherNode;*)
                    
                 else
                (* go left and downto rightmost leaf *)
                    node.sonNo-1 (* go left *) ->fatherNode.get->node[];
                    &goDownRight;
                    
                if);
                
            if);
            1->length;
            
         // dir.down then
            (if (1 < length) then
                1->length; 
             else
                (if not sonExists then
                    (if (node.father <> none ) then
                        (if (node.sonNo = fatherNode.noOfSons) then
                        (* no right brother *)
                            loop:
                              (# 
                              do
                                 node.father->node[];
                                 (* go up *)
                                 (if (node.father <> none ) then
                                     node.father->fatherNode[];
                                     (if (node.sonNo < fatherNode.noOfSons) then
                                     (* right brother exists *)
                                         node.sonNo+1
                                           -> (* go right *) fatherNode.get
                                           ->node[];
                                         
                                      else
                                     (* go up *)
                                         restart loop; 
                                     if);
                                     
                                 if);
                                 
                              #);
                            
                         else
                        (* right brother exists *)
                            node.sonNo+1-> (* go right *) fatherNode.get
                              ->node[];
                            
                        if);
                        (* right brother exists? *)
                        
                    if);
                    (* father exists *)
                    
                 else
                (* son exists *)
                (* go down *)
                    node[]->exp[]; exp.getSon1->node[]; 
                if);
                (* sons exists ? *)
                1->length;
                
            if);
            (*node[]->checkSonNode;*)
            
         // dir.nonCyclicDown then
            thisOp:
              (# 
              do
              (* this is really awfull, but I have only 5 minutes,
               it is a copy of dir.down, except that only traversal 
               in the selected subtree is allowed  *)
                 (if (1 < length) then
                     1->length; 
                  else
                     (if not sonExists then
                         (if (node.father <> none ) then
                             (if (node.sonNo = fatherNode.noOfSons) then
                             (* no right brother *)
                                 loop:
                                   (# 
                                   do
                                      node.father->node[];
                                      (if (node[]->current.equal) then
                                          'back again from select '->putLine;
                                          leave thisOp;
                                          
                                      if);
                                      (if (node.father <> none ) then
                                          node.father->fatherNode[];
                                          (if
                                          (node.sonNo < fatherNode.noOfSons)
                                           then (* right brother exists *)
                                              node.sonNo+1
                                                -> (* go right *) fatherNode.get
                                                ->node[];
                                              
                                           else
                                          (* go up *)
                                              restart loop; 
                                          if);
                                          
                                      if);
                                      
                                   #);
                                 
                              else
                             (* right brother exists *)
                                 node.sonNo+1-> (* go right *) fatherNode.get
                                   ->node[];
                                 
                             if);
                             (* right brother exists? *)
                             
                         if);
                         (* father exists *)
                         
                      else
                     (* son exists *)
                     (* go down *)
                         node[]->exp[]; exp.getSon1->node[]; 
                     if);
                     (* sons exists ? *)
                     1->length;
                     
                 if);
                 
              #)
         // dir.pred then
            (if (node.father <> none ) then
                (if (node.sonNo = 1) then (* no left brother *)
                    
                 else
                (* go left *)
                    node.sonNo-1->fatherNode.get->node[] (*->checkSonNode*) ; 
                if);
                1->length;
                
             else
            (* no left brother *)
                
            if);
            
         // dir.next then
            (if (node.father <> none ) then
                (if (node.sonNo+length-1 < fatherNode.noOfSons) then
                    node.sonNo+length->fatherNode.get
                      ->node[] (*->checkSonNode*) ;
                    
                if);
                1->length;
                
             else
            (* no right brother *)
                
            if);
            
         // dir.root then (* editorRoot[]->node[];
                           1->length;*)
            
         // dir.extend then
              (# prod: ^mg.prod; 
              do
                 (if not ((node.father->fatherNode[]) = none ) then
                     fatherNode.symbol->searchTextPrivate.prodList.get->prod[];
                     (if
                     (((prod.symbol = mg.listZero) or
                       (prod.symbol = mg.listOne)) and
                      (node.sonNo+length <= fatherNode.noOfSons)) then
                         length+1->length; 
                      else
                         fatherNode[]->node[] (*->checkFatherNode*) ;
                         1->length;
                         
                     if);
                     
                 if);
                 
              #);
            
         // dir.nextNonterminal then (*&nextNonterminal *)
            
         // dir.prevNonterminal then (*prevNontermina*)
            
        if);
        
     #);
   textWithFindSub: text
     (#
        FindCh:
        (* Finds all occurences of ch:
         * For 'inx' where THIS(text).inx=ch do inner
         *)
          (# inx: @integer; ch: @char
          enter ch
          do
             (for i: lgth repeat
               (if T[i->inx]->ascii.upCase
                // ch->ascii.upCase then INNER
               if)
             for)
          #);
        findSubstring:
          (# texttofind: ^text; firstch: @char; 
          enter texttofind[]
          do
             1->texttofind.inxget->firstch
               ->findCh
                 (# foundtext: ^text; 
                 do
                    (inx,inx+texttofind.length-1)->sub->foundtext[];
                    (if (foundtext[]->texttofind.equalNCS) then
                        INNER findSubstring; 
                    if)
                 #)
          #);
        isSubstring:
          (# string: ^text; found: @boolean; 
          enter string[]
          do
             FALSE->found;
             l: string[]->findSubstring (#  do TRUE->found; leave l #);
             
          exit found
          #);
        
     #);
   
#)  

-- editorenvSearchText: Descriptor --
(#  #)  

-- editorenvScanGroupForText: Descriptor --
(#  #)  

-- editorenvCreateGroupEditor: DoPart --
do
     (# textfile: @file
     do
        (if trace[2] then
            'creating groupEditor: '->putText; fg.name->putLine; 
        if);
        &groupEditor[]->ge[];
        fg[]->ge.fg[];
        theBrowser[]->ge.theBrowser[];
        fg[]->editorenvPrivate.checkWriteAccess->ge.writeAccess;
        (if trace[2] then
            'create groupeditor writeAccess: '->putText;
            (if ge.writeAccess then 'true'->putLine else 'false'->putLine if)
        if);
        ;
        fg.textfilename->textfile.name;
        (if not textfile.entry.exists then
            '### Text file does not exist'->putLine;
            true->ge.needToUpdateTextFile;
            
        if);
        fg[]->editorenvPrivate.getGrammarName->ge.grammarName[];
        ge[]->fgHandler.subscribe;
        ge[]->append;
        (if not onGoingRecovery and (ge.fgh.groupEditors.size = 1) and not
        ge.isAfrejaEditor then
            ge.fg[]->editorenvPrivate.checkAutoSaveFile
        if)
     #)  

-- editorenvFindOrCreateGroupEditor: DoPart --
do
     (# textfile: @file
     do
        (theBrowser[],fg[])->findGroupEditor->ge[];
        (if ge[] = none then (theBrowser[],fg[])->createGroupEditor->ge[] if)
     #)  

-- editorenvCreateFormEditor: Descriptor --
(# help: ^text; 
do
   (if ge[] <> none then
   (* overfloedigt theEditorRoot.frag[]->ge.formeditorList.findEditor->fe[];*)
       (if trace[2] then
           'creating formeditor: '->putText;
           (if theEditorRoot[] <> none then
               (theEditorRoot.frag.father).name->putText;
               '-'->put;
               theEditorRoot.frag.name->putLine;
               
            else
               'theEditorRoot is none'->putLine
           if)
       if);
       (if theSifTextEditor[] <> none then
           &theSifTextEditor.codeviewerType[]->fe[];
           fe[]->theSifTexteditor.SifViewer[];
           theSifTextEditor[]->fe.theSifTextEditor[];
           (if theEditorRoot[] <> none then
               theEditorRoot.frag[]->theSifTexteditor.frag[];
               theEditorRoot[]->theSifTexteditor.editorRoot[];
               (mps[],theEditorRoot.frag.grammar[],UI[],theSifTextEditor[],
                theEditorRoot.Frag[],theEditorRoot[],initialSelection[])
                 ->fe.init;
               
            else
               (if ff[] <> none then
                   ff[]->theSifTexteditor.frag[];
                   none ->theSifTexteditor.editorRoot[];
                   (* the editorRoot is set up by codeeditor.init *)
                   (mps[],ff.grammar[],UI[],theSifTextEditor[],ff[],
                    theEditorRoot[],initialSelection[])->fe.init;
                   
                else
                   'createFormEditor: theEditorRoot and ff are none!!'->putLine
               if)
           if);
           fe[]->ge.formeditorList.append;
           ge[]->fe.thisGroupEditor[];
           not ge.writeAccess->fe.isReadOnly->fe.theSifTextEditor.isReadOnly;
           (if trace[2] then
               'createFormEditor readOnly: '->putText;
               (if fe.theSifTextEditor.isReadOnly then
                   'true'->putLine
                else
                   'false'->putLine
               if);
               
           if);
           
        else
           'CreateFormEditor: theSifTexteditor is none!'->putLine
       if)
    else
       'CreateFormEditor: ge is none!'->putLine
   if);
   
#)  

-- editorenvFindOrCreateFormEditor: Descriptor --
(# help: ^text; 
do
   (if ge[] <> none then
       (if theSifTextEditor[] <> none then
           (if theSifTextEditor.SifViewer[] <> none then
               (if theSifTexteditor.textediting then
                   false->theSifTextEditor.textediting;
                   'Textediting is abandoned in '->help[];
                   help.newLine;
                   (theSifTextEditor.frag.father).name->help.putText;
                   '-'->help.put;
                   theSifTextEditor.frag.name->help.putText;
                   (none ,help[],'Textediting abandoned')->UI.alertUser;
                   (*theSifTextEditor.sifViewer.doParseText*)
                   
                else
                   none ->theSifTextEditor.sifViewer.theSifTextEditor[];
                   (* the current editor is not visible anymore *)
                   
               if)
           if);
           (if theEditorRoot[] <> none then
               theEditorRoot.frag[]->ge.formeditorList.findEditor->fe[];
               (if fe[] <> none then
                   fe[]->theSifTexteditor.SifViewer[];
                   theSifTextEditor[]
                     ->theSifTextEditor.sifViewer.theSifTextEditor[];
                   fe.editorRoot.frag[]->theSifTextEditor.frag[];
                   fe.editorRoot[]->theSifTexteditor.editorRoot[];
                   fe.isReadOnly->theSifTexteditor.isReadOnly;
                   (if trace[2] then
                       'findOrcreateFormEditor readOnly: '->putText;
                       (if fe.theSifTextEditor.isReadOnly then
                           'true'->putLine
                        else
                           'false'->putLine
                       if);
                       
                   if);
                   fe.doReprettyprint;
                   fe.cs->fe.setFocus
                else
                   (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],
                    ge[])->createFormEditor->fe[]
               if)
            else
               (ff[],theEditorRoot[],initialSelection[],theSifTexteditor[],ge[])
                 ->createFormEditor->fe[]
           if)
        else
           'findOrCreateFormEditor: theSifTexteditor is none!'->putLine
       if)
    else
       'findOrCreateFormEditor: ge is none!'->putLine
   if);
   
#)  

-- editorenvFindGroupEditor: DoPart --
do
(*'grouplist Size: '->putText;
 size->putInt;
 newLine;
 scan
 (# 
 do
 current.fg.name->putText;
 ': '->putLine;
 'formList Size: '->putText;
 size->putInt;
 newLine;
 current.formeditorList.scan
 (# 
 do
 current.id->putInt;
 ' '->put;
 (current.frag.father).name->putText;
 '-'->put;
 current.frag.name->putText;
 putline
 #);
 putLine
 #);*)
   search: scan
     (# 
     do
        (if theBrowser[] <> none then
            (if (fg[] = current.fg[]) and (theBrowser[] = current.theBrowser[])
             then
                current[]->ge[]; leave search
            if)
         else
            'FindGroupEditor: theBrowser is none'->putLine
        if)
     #)  

-- editorenvShowEditors: DoPart --
do
   'groupEditorList: '->putText;
   groupEditorList.size->putInt;
   newLine;
   groupEditorList.scan
     (# 
     do
        current.fg.name->putLine;
        'formEditorList: '->putText;
        current.formEditorList.size->putInt;
        newLine;
        current.formEditorList.scan
          (#  do current.frag.name->putLine #);
        
     #)  

-- findEditorForFormBody: Descriptor --
(# ge: ^groupEditor; help: ^text; 
do
   (ymerCallback.theBrowser[],ff.father)
     ->groupeditorList.findOrCreateGroupEditor->ge[];
   (if ge[] <> none then
       ff[]->ge.formeditorList.findEditor->fe[];
       (if fe[] <> none then
           (if (selectedNode[] <> none ) then
               (selectedNode[],1,0,0)->fe.setFocus
            else
               fe.cs->fe.setFocus
           if)
        else
           ' findEditorForFormBody: editor not found'->putLine
       if)
   if);
   
#)  

-- findFormEditorId: DoPart --
do
   (if trace[1] then 'findFormEditorId'->putLine;  if);
     (# ge: ^groupEditor; help: ^text
     do
        search: groupeditorList.scan
          (# 
          do
             id->current.formeditorList.findEditorId->fe[];
             (if fe[] <> none then leave search if);
             
          #)
     #)  

-- editorenvNonterminalsExist: Descriptor --
(#
   nonterminalsExistInForm:
     (#
        ff: ^astInterface.fragmentForm;
        unexpandedExist: @boolean;
        unExp: ^astInterface.unexpanded;
        expNode: ^astInterface.expanded;
        
     enter ff[]
     do
        (if ff.root.kind
         // mps.kinds.interior then
            ff.root[]->expNode[];
            false->unexpandedExist;
            loop: expNode.suffixWalk
              (# 
              do
                 (if current.kind
                  // mps.kinds.unexpanded then
                     current[]->unExp[];
                     (if unExp.isSlot
                      // false then true->unexpandedExist; leave loop; 
                     if)
                 if);
                 
              #);
            
         else
            true->unexpandedExist; ff.root[]->unExp[]
        if);
        
     exit (unexpandedExist,unExp[])
     #);
   
do
   thisOperation: groupEditorList.scan
     (#
        ge: ^groupEditor;
        ff: ^astInterface.fragmentForm;
        didRecompute: @boolean
     do
        current[]->ge[];
        (if ge.fg[] = none then
            'scanGEs: ge.g[] is none!'->putLine; 
         else
            ge.fg.fragmentlist.scan
              (# help: ^text; 
              do
                 (if current.type = mps.formType then
                     (if current.f[] = none then screen[]->current.open if);
                     (* (if ge.touched > 0 then *)
                     (* this should not be the editors job!! *)
                     (* '.'->put; *)
                     current.f[]->ff[];
                     ff.recomputeSlotChain;
                     (* false->didRecompute;
                      if);*)
                     current.f[]->nonterminalsExistInForm
                       ->(unexpandedExist,unExp[]);
                     (if unexpandedExist then leave thisOperation if)
                 if);
                 
              #);
            (* (if didRecompute then
             ' Recomputed slot chain for: '->putText;
             ge.fg.name->putLine;
             false->didRecompute
             if);*)
            
        if);
        
     #);
   
#)  

-- editorEnvInit: DoPart --
do
     (#
        grammarWithPath,help: ^text;
        gg: ^astInterface.fragmentGroup;
        bobsfile: @file
     do
        &clipBoard[]->clip[];
        history.init;
        metaGrammarInit;
        (* is only done if necessary *)
        (if trace[9]
         // true then '*************** prettygrammar.init'->putLine
        if);
        &mps.prettyprint[]->prettyprintGrammar[];
        prettyprintGrammar.init;
        '~beta/grammars/pretty/v2.3/prettyprint'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('prettyprint',screen[])->gg.open->prettyprintGrammar.grammarAst[];
            (if prettyprintGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->prettyprintGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if);
        (if trace[9]
         // true then '*************** propertygrammar.init'->putLine
        if);
        &mps.property[]->propertyGrammar[];
        propertyGrammar.init;
        '~beta/grammars/property/v1.1/property'->grammarWithPath[];
        (grammarWithPath[],screen[])->mps.top.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            grammarWithPath[]->putLine;
            (failure,'')->stop;
            
        if);
        ('meta',screen[])->gg.open->gg[];
        (if gg[]
         // none then
            'Could not open: '->screen.putText;
            '-meta'->grammarWithPath.copyAppend->screen.putLine;
            (failure,'')->stop;
            
         else
            ('property',screen[])->gg.open->propertyGrammar.grammarAst[];
            (if propertyGrammar.grammarAst[]
             // none then
                'No grammarAst for '->screen.putText;
                grammarWithPath[]->screen.putLine;
                (failure,'')->stop;
                
             else
                '-parser'->help[];
                mps.parserFileExtension->help.append;
                help[]->grammarWithPath.copyAppend->mps.expandToFullPath
                  ->bobsFile.name;
                (if bobsFile.entry.exists
                 // true then
                    bobsFile.name->propertyGrammar.parser.initialize; 
                 else
                    'No parser available: '->screen.putText;
                    bobsFile.name->screen.putLine;
                    
                if)
            if);
            
        if)
     #)  

