ORIGIN 'objectcode'
---classDef:doPart---
do (if false then
       '**** classDef: ' -> puttext; N[] -> puttext;
       ' ' -> put; descNo  -> putint; 
       ' ' -> put; orgOfN[] -> putline
   if);
   (if descNo -> typeInfo.exists then
       leave classDef
   if);
   isValueObj -> isValueObject;
   N[] -> filter -> N[];
   
   '%' -> T[]; N[] -> T.puttext; 
   '$' -> T.put; descNo -> T.putint;
   (if orgOfN[] = none then
       (descNo,T[],none) -> typeInfo.addDsc;
    else
       (descNo,T[],(orgOfN[],orgDescNo) -> mkTypePtr) 
         -> typeInfo.addDsc;
   if);
   
   '%' -> T[]; N[] -> T.puttext; 
   '$' -> T.put; descNo -> T.putint;
   
   (* *** LLVMstructs as printed here are apparently not used?
    * T[] -> LLVMstructs.puttext; 
    * ' = type {' -> LLVMstructs.puttext;
    *)
   
   true -> first;  
   'vdt_type$' -> T[];
   N[] -> filter -> T.puttext; 
   '$' -> T.put; descNo -> T.putint;
   ' ' -> T.put;
   (0,T[]) -> AddR; 
   inner classDef;
   
   (* '}'-> LLVMstructs.puttext; LLVMstructs.newline;
    * ';;%vdt_type ' -> LLVMstructs.putline;
    *)
---class:descriptor---
(#
do  (*typeInfo.print;*)
   (N[],descNo,originOff,originDescNo,isValueObj,out[])
     -> descs.setCurrent;
   (topDescNo,descs.OD[topDescNo].bc[]) 
     -> descs.current.setSuperBC;
   
   N[] -> filter -> N[];
   
   descNo -> thisClassDescNo;
   N.copy -> thisClassId[]; 
   '$' -> thisClassId.put; descNo -> thisClassId.putint;
   '%' -> thisClassT[]; 
   thisClassId[] -> thisClassT.puttext; 
   '*' -> (thisClassT.copy -> thisClassP[]).put;
   orgId[] -> thisClassOrgId[];
   originDescNo -> thisClassOrgDescNo;
   originOff -> thisClassOriginOff;
   (if traceLLVMcalls then
       '\n@S.' -> out.puttext; N[] -> out.puttext; 
       '$' -> out.put; descNo -> out.putint;               
       ' = private unnamed_addr constant [' -> out.puttext;
       thisClassT.length + 2 -> out.putint;
       ' x i8] c"' -> out.puttext; thisClassT[] -> out.puttext;
       '\\0A\\00"\n' -> out.puttext;
   if);
   isValueObj -> isValueObject;
   (if true 
    // 'main' -> N.equal then
       '\ndefine void @main(i8* %args){\n' -> out.puttext;
    // isValueObj and false then 
       true -> isValueObject;
       '\ndefine %Object' -> out.puttext; 
       '* @' -> out.puttext; N[] -> out.puttext;      
       '$' -> out.put; descNo -> out.putint;
       '(%Object* %R0, i32 %off' -> out.puttext;
       '){\n' -> out.puttext;
    else
       '\ndefine ' -> out.puttext; thisClassT[] -> out.puttext; 
       '* @' -> out.puttext; N[] -> out.puttext;      
       '$' -> out.put; descNo -> out.putint;
       '(' -> out.put; 
       (if not isVstub then
           thisClassT[] -> out.puttext;
           '* %R0' -> out.puttext;
       if);
       (if true
        // isVstub then
           (*',' -> out.put;*)
           orgId[] -> mkLLVMtype -> out.puttext;
           allocReg; (* alloc R1 for origin *)
           '* %R1' -> out.puttext;
        //  isValueObject then
           ', i32 %off' -> out.puttext
        else
           (if newFeature then
               allocReg; (* allocate R1 for origin *)
               (if ((descNo -> typeInfo.get).orgSig[] -> S[]) <> none
                   then
                   ', ' -> out.puttext;
                   S[] -> out.puttext;
                   ' %R1' -> out.puttext;
               if)
           if)
       if);
       '){\n' -> out.puttext;
   if);
   
   (if traceLLVMcalls and not isVstubObject then
       thisClassT[] -> mkTextConst -> putString;
   if);
   (if dumpLLVMobjs and not ('main' -> N.equal) then
       (if isVstub then
           ('entry:Vstub:origin:',thisClassT[]
           ,1, orgId[] -> mkLLVMtype) 
             -> dumpObjX;
        else
           ('entry:',thisClassT[],0,thisClassT[]) -> dumpObjX;
       if)
   if);   
   (if isVstub->isVstubObject then lcom(#do'isVstubObject'->TT#) if);
   '   %V0 = add i32 0, 0' -> out.putline; (* just a dummy *)
#)
---pushConst:descriptor---
(#
do ind;
   allocReg -> rN -> emitVreg -> out.puttext;
   ' = add i32 0, ' -> out.puttext; cst -> out.putint; 
   out.newline;
   rn -> stack.vPush;
   cst -> stack.value -> stack.vVal[stack.vTop][];
#)
---rpushg:descriptor---
(#
do (if stack.rtop = 0 then
       '   ;; rpushg: stack.rtop = 0' -> out.putline;
       '!!!! rpushg: stack.rtop = 0' -> putline;
    else
       (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
           '*** rpushg:in value object: ' -> puttext;
           N[] -> putline;
       if);
       (stack.rType[stack.rtop][],off) -> typeInfo.lookup -> elmType[];
       
       lcom(#do 'Rtype.rtop:' -> TT; stack.Rtype[stack.rtop][] -> TQ;
              'typeInfo[rtop,off]=elmType:'-> TT; elmType[] -> TQ;
           #);
       lcom(#do stack.print -> TT #);
       off -> leag -> rN;
       ind;
       allocReg -> rN2 -> emitRreg -> out.puttext;
       ' = load ' -> out.puttext; 
       elmType[] -> out.puttext;
       ' , ' -> out.puttext; 
       elmType[] -> out.puttext; '* ' -> out.puttext;
       rN -> emitRreg -> out.puttext;
       out.newline;
       1 -> stack.rpop;
       (rN2,elmType[]) -> stack.rPushT;
   if)
#)
---invokev:descriptor---
(#
do (if 'Vstub$' -> ((1,6) -> N.sub).equal then
       true -> isCallVstub;
       (7,N.length) -> N.sub -> filter -> Nsig[]
    else
       N[] -> filter -> Nsig[]
   if);
   lcom(#do 'vdt:dinx: ' -> TT; dinx -> II;  #);
   stack.put;
   lcom(#do 'load pointer to VDT' -> TT #);
   0 -> leag -> rNx; 
   
   '%vdt_type$' -> T[];
   (2,stack.rtype[stack.rtop].length)
     -> stack.rtype[stack.rtop].sub -> T.append;
   lcom(#do 'type of vdt = ' -> TT; T[] -> TT #);
   ind;
   allocReg -> rNy -> emitRreg -> out.puttext;
   ' = load ' -> out.puttext; T[] -> out.puttext; 
   ', ' -> out.puttext; T[] -> out.puttext; '* ' -> out.puttext; 
   rNx -> emitRreg -> out.putline;
   
   lcom(#do rNy -> emitRreg -> TT; ' = ptr to VDT' -> TT #);
   
   T[] -> deRef -> T[];
   
   lcom(#do 'N: ' -> TT; N[] -> TT; 'Nsig:'->TT; Nsig[] -> TT #);
   
   (rNy,T[],dinx - 1) -> leaReg -> rNz;   
   
   lcom(#do rNZ->emitRreg->TT; ' = &VDT['->TT; dinx->II; ']'->TT#);
   
   '%vdt_ret$' -> T[]; Nsig[] -> T.append; '*' -> T.append;
   originOff; (* not used? *)
   
   lcom(#do 'T:'->TT; T[] -> TT #);
   stack.put;
   
   ind;
   allocReg -> rNv -> emitRreg -> out.puttext;
   ' = load ' -> out.puttext; T[] -> out.puttext;
   '(' -> out.put;
   stack.rType[stack.rTop][] -> out.puttext;
   ')*' -> out.puttext;
   ', ' -> out.puttext; 
   T[] -> out.puttext; 
   '(' -> out.put;
   stack.rType[stack.rTop][] -> out.puttext;
   ')' -> out.puttext;
   '** ' -> out.puttext; 
   rNz -> emitRreg -> out.puttext; '\n' -> out.puttext;
   
   lcom(#do rNv -> emitRreg -> TT;
          ' = obj.VDT[dinx] = [' -> TT; dinx - 1 -> II;  ']'->TT #);
   
   (*(rNv,T[]->deRef) -> dumpObj;*)      
   
   lcom(#do 'Call:VDT:' -> TT; T[] -> TT; 
          ' useStub:' -> TT; useStb -> BB #);
   (if useStb then 
       '%vdt_ret$' -> T[]; Nsig[] -> T.append; '*' -> T.append;
       ind;
       allocReg -> rNx -> emitRreg -> out.puttext;
       ' = call ' -> out.puttext; T[] -> out.puttext; ' '-> out.put;
       rNv -> emitRreg -> out.puttext;
       
       (*'()\n' -> out.puttext;*)
       '(' -> out.put; 
       (if true then
           stack.rType[stack.rTop][] -> out.puttext; 
           ' ' -> out.put;
           stack.rTop -> rReg -> out.puttext;
       if);
       ')\n' -> out.puttext;
       stack.put;
       (rNx,T[]) -> stack.rPushT;      
       stack.put;
       (rNx,T[]->deRef,0,allocReg->rNy,N[]-> mkLLVMtype) 
         -> LLVMget -> out.putline;
       (rNy,N[]->mkTypePtrX,'*'->(topId[]-> mkLLVMtype).put)
         -> bitCast -> rNx;
       (topId[],topId[],rNx,allocReg) -> LLVMcall -> out.putline
    else
       '%vdt_ret$' -> T[]; N[] -> T.append; 
       ind;
       allocReg -> rNw -> emitRreg -> out.puttext;
       ' = call ' -> out.puttext; T[] -> out.puttext;
       '* ' -> out.puttext;
       rNv  -> emitRreg -> out.puttext;
       '(' -> out.puttext;
       (if true then
           stack.rType[stack.rTop][] -> out.puttext; 
           ' ' -> out.put;
           stack.rTop -> rReg -> out.puttext;
       if);
       ')\n' -> out.puttext;
       lcom(#do 'Load  new virtual object' -> TT #);
       (rNw,T[],0) -> leaReg -> rNq;
       ind;
       allocReg -> rNx -> emitRreg -> out.puttext;
       ' = load %' -> out.puttext;
       N[] -> out.puttext; '*, %' -> out.puttext;
       N[] -> out.puttext; '** ' -> out.puttext;
       rNq -> emitRreg -> out.puttext;
       '\n' -> out.puttext;
       lcom(#do rNx->emitRreg-> TT; ' = new virtual object' -> TT #);
       (if not newFeature then
           lcom(#do 'Store origin in virtual object - FIX'->TT #);
           lcom(#do 'store origin:off:' -> TT; orgOff -> II; 
                  ' orgType: ' -> TT; orgType[] -> TT #);
           stack.put;
           (if orgOff = 0 then
               '!!!! invokev:originOff = 0 :'  -> puttext;
               N[] -> putline;
               lcom(#do '!!!! originOff = 0 '  -> TT; N[] -> TT  #);
               1 -> orgOff (* a hack !? *)
           if);
           (if not useStb then
               (rNx,'%'->(N.copy).prepend,orgOff) -> leaReg -> rNy;
               '   store ' -> out.puttext; 
               stack.rType[stack.rTop][] -> out.puttext; 
               stack.rTop -> rReg -> out.puttext;
               ', ' -> out.puttext; 
               stack.rType[stack.rTop][] -> out.puttext; 
               '* ' -> out.puttext; rNy -> emitRreg -> out.putline;
           if)
       if);
       (if dumpLLVMobjs then
           ('Virtual:',N[],rNx,'%'->(N.copy).prepend)
             -> dumpObjX;
       if);
       (if true then
           lcom(#do 'FIX: mustr VDT entry' -> TT #);
           stack.put;           
           (if useStb then
               (rNx,('%'->(N.copy).prepend).put,2) -> leaReg -> rNy;
               allocReg -> rNx -> emitRreg -> out.puttext;
               ' = load %' -> out.puttext;
               topId[] -> out.puttext; '*, %' -> out.puttext;
               topId[] -> out.puttext; '** ' -> out.puttext;
               rNy -> emitRreg -> out.puttext;
               '\n' -> out.puttext;                      
           if);
           (if false then
               (# T: ^text
               do 'Virtual:'->(N.copy).prepend -> T[];
                  (if useStb then ' useStub' -> T.puttext if);
                  ('VirtualX:',N[],rNx,'%'-> (topId.copy).prepend) 
                    -> dumpObjX;
               #);
           if);
           (if false and  not (N[] -> topId.equal) then
               (rNx
               ,'*' -> ('%'->(N.copy).prepend).put
               ,'*' -> ('%'->(topId.copy).prePend).put)
                 -> bitcast -> rNx
           if);
           '   call %' -> out.puttext; 
           (if true then
               topId[] -> out.puttext;
            else
               N[] -> out.puttext;
           if);
           '* @' -> out.puttext;
           (if true then
               topId[] -> out.puttext;
            else
               N[] -> out.puttext;
           if);
           '(%' -> out.puttext;  
           (if true then
               topId[] -> out.puttext;
            else
               N[] -> out.puttext;
           if);
           '* ' -> out.puttext; rNx -> emitRreg -> out.puttext;
           (if newFeature then
               ',' -> out.put;
               (if stack.rTop > 0 then
                   stack.rtop -> typedRreg -> out.puttext
                else
                   'NULL' -> out.puttext;
           if)if);
           ')\n' -> out.puttext;
           '%' -> T[]; 
           (if true then
               topId[] ->  T.append
            else
               N.copy -> T.append; 
           if);
           '*' -> T.put;
           (rNx,T[]) -> stack.rPushT;
        else
           lcom (#do 'FIX:other: ' -> TT; topId[] -> TT#);
           (rNw,T[],1) -> leaReg -> rNy;
           ind;
           allocReg -> rNz -> emitRreg -> out.puttext;
           ' = load %' -> out.puttext; N[] -> out.puttext;
           '* (%' -> out.puttext;  N[] -> out.puttext;
           '*)*, %' -> out.puttext; N[] -> out.puttext;
           '* (%' -> out.puttext; N[] -> out.puttext;
           '*)**' -> out.puttext;
           rNy -> emitRreg -> out.putline;
           (if not (N[] -> topId.equal) then
               (rNz,N[]->mkFuncPtr,topId[]->mkFuncPtr) 
                 -> bitCast -> rNz;
               (rNx
               ,'*' -> ('%'->(N.copy).prepend).put
               ,'*' -> ('%'->(topId.copy).prePend).put)
                 -> bitcast -> rNx
           if);
           '   call %' -> out.puttext;
           (if true then 
               topId[] -> out.puttext
            else
               N[] -> out.puttext;
           if);
           '* ' -> out.puttext;
           rNz -> emitRreg  -> out.puttext;
           '(%' -> out.puttext;  
           (if true then 
               topId[] -> out.puttext; 
            else
               N[] -> out.puttext; 
           if);
           '* ' -> out.puttext; rNx -> emitRreg -> out.puttext;
           ')\n' -> out.puttext
   if)if)
#)
---jmp:doPart---
do '   br label %L' -> out.puttext; lab ->  out.putint; out.newline 
---jmpFalse:descriptor---
(#
do stack.put;
   (if stack.vTop = 0 then
       '   ;; jmpFalse: stack.vTop = 0' -> out.putline;
       '\n!!!! jmpFalse: stack.vTop = 0' -> putline;
    else
       (if stack.Vtype[stack.vTop] = 1 then
           stack.vRegNo[stack.vTop] -> Vn
        else
           allocReg -> Vn -> emitVreg -> out.puttext;
           ' = trunc  i32 ' -> out.puttext;
           stack.vtop -> vRegInStack -> out.puttext; 
           ' to i1\n' -> out.puttext;
       if);
       
       '   br i1 ' -> out.puttext; 
       Vn -> emitVreg -> out.puttext;
       ', label %L' -> out.puttext; Tlab ->  out.putint;
       ', label %L' -> out.puttext; Flab ->  out.putint; 
       out.newline;
       1-> stack.vpop
   if)
#)
---callPrim:descriptor---
(#
do (if op 
    // prim.put then
       '   call i32 @putCh(i32 ' -> out.puttext; 
       stack.vtop -> vRegInStack -> out.puttext;
       ')\n' ->out.puttext;
       1 -> stack.vpop
    // prim.asString then
       ';; call asString' -> out.putline;
       '!!!! LLVM:callPrim:notImplemented:asString'->putline;
    else
       '!!!! LLVM:callPrim:notImplemented:'->puttext; op -> putint; newline
   if)
#)
---callPrim2:descriptor---
(#
do '!!!! LLVM:callPrim2:notImplemented:'->puttext; op -> putint; newline
#)

