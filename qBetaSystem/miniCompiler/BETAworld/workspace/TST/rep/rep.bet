rep: @
  (# R: [10] @integer;
     testGlobalRep:
       (#
          S: [3] @integer;
          globalRep:
            (#
            do (for k: 3 repeat 107 + k -> S[k] for); 
               (for k: 3 repeat S[k] -> put for); (* 'lmn' *)
            #);
       do globalRep
       #)
     forTst2: @
       (# q,w: @integer
       do 'n' -> q;
          (for i: 8 repeat (* 'o-v' *)
               q + i -> put;
               0 -> w;
               (for j: 3 repeat w+j -> w for)
          for);
          'w' -> put;
          (if w = 6 then 'x' -> put else 66 -> put if);
       #);
     dynamite: 
       (# V: @integer;
          run: 
            (# X: [4] @integer; ; k: @integer
            do V + 1 -> V; 3 -> k;
               17 -> X[k];
            #);
       #);
     dynRep: @
       (# ds: [3] ^dynamite; q: ^dynamite;
          inside:
            (# 
            do &dynamite[] -> q[];
               (for i: 3 repeat &dynamite[] -> ds[i][] for);
               (for i: 3 repeat 
                    q.run;
                    ds[i].run;
               for);
               (if (ds[2].V = 1) and (q.V = 3) then 
                   'z' -> put 
                else '?' -> put 
               if)
            #)
       do &dynamite[] -> q[];
          (for i: 3 repeat &dynamite[] -> ds[i][] for);
          (for i: 3 repeat 
               q.run;
               ds[i].run;
          for);
          (if (ds[2].V = 1) and (q.V = 3) then 'y' -> put else '?' -> put if);
          inside
       #);
     
  do 97 -> R[3];
     R[3] -> put; (* 'a' *)
     (for i: 10 repeat 97 + i -> R[i] for); 
     (for i: 10 repeat R[i] -> put for); (* 'b-k' *)
     testGlobalRep; (* 'lmn' *) 
     forTst2;
     dynRep;
     'z' -> last;      
  #);
