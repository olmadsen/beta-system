ImplicitSuper: @
  (# implicitSuper_x:
       (# Foo: (# a: @char do ch -> a; a -> put; inner; a -> put #);     
          Fisk:
            (# Bar: Foo (* on = 1 *) (# do 'b' -> a; #);
               snorf:< Foo
            #);
          hest: Fisk (# snorf:: (* on = 1 *) (# do 'd' -> a #) #);
          ch: @char;
          R: @Fisk;
          S: ^Fisk;
       enter ch
       do R.bar;
          &hest[] -> S[];
          'c' -> ch;
          (if true then 
              '?' -> put
           else
              S.snorf; (* problem with ON in implicit super of snorf in hest *)
          if)

       #);
     implicitSuper_y:
       (# Foo1: (# a: @char do ch -> a; a -> put; inner; a -> put #);     
          Fisk1:
            (# Bar1: Foo1 (* on = 1 *) (# do ch + 1 -> a; #);
               snorf1:< Foo1
            #);
          AAA1:
            (# hest1: Fisk1 (# snorf1:: (* on = 2 *) (# do ch + 1 -> a #) #);
               R: @Fisk1;
               S: ^Fisk1;
            do R.bar1;
               &hest1[] -> S[];
               ch + 2 -> ch;
               S.snorf1
            #);
          ch: @char;
       enter ch
       do AAA1
       #);
     implicitSuper_z:
       (# Q:
            (# Foo2: (# a: @char do ch -> a; a -> put; inner; a -> put #);     
               Fisk2:
                 (# Bar2: Foo2 (* on = 1 *) (#do  ch + 1 -> a #);
                    snorf2:< Foo2 (* on = 1 *) 
                 #);
            #);
          P: @Q;   
          hest2: P.Fisk2 (# snorf2:: (* on = ? *) (# do ch + 1 -> a #) #);      
          ch: @char;
          R: @P.Fisk2;
          S: ^P.Fisk2;
       enter ch
       do R.bar2;
          &hest2[] -> S[];
          ch + 2 -> ch;
          (if true then
              '?' -> put; (* same as for snorf in hest *)
           else
              S.snorf2
          if)
       #);
     implicitSuper_v:
       (# Koks3: @ (# Foo3: (# a: @char do ch -> a; a -> put; inner; a -> put #) #);     
          Fisk3:
            (# Bar3: koks3.Foo3(# do ch + 1-> a; #);
               snorf3:< koks3.Foo3 (* origin = koks *)
            #);
          AAA3:
            (# hest3: Fisk3 (# snorf3::  (# do ch + 1 -> a #) #);
               R: @Fisk3;
               S: ^Fisk3;
            do R.bar3;
               &hest3[] -> S[];
               ch + 2 -> ch;
               S.snorf3
            #);
          ch: @char;
       enter ch
       do AAA3
       #)
  do 'ImplicitSuper has errors:'.print;
     newline;
     'P' -> mark;
     'a' -> implicitSuper_x;
     'e' -> implicitSuper_y;
     'i' -> implicitSuper_z;
     'm' -> implicitSuper_v;
     'p' -> last
  #)
