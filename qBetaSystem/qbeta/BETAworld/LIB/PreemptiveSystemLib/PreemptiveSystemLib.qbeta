PreemptiveSystemLib: obj
   %visible Collections, LIB.StringLib,LIB.Collections.QueueLib
   PreemptiveSystem:
      P_status: obj 
         %globals
         %Public	 
         ACTIVE: val 1
         WAITING: val 2
         TERMINATED: val 3
      PSYSprocess: GeneralProcess
          -- origin.off:4
          %id "PSYSprocess"
          doRepeat: 
             until:<
                out BB: var Boolean
                put('(')
                "bummelum2".print
                inner(until)
                put('!')
             doing:< PSYSProcess
                %id "doing_process"
                untilCond:
                   out BB: var Boolean 
                   put('?')
                   BB := until
                put('@')
                put('A')
                caller := this(PSYSProcess)
                this(PSYSprocess).newRepeat := theRepeat
                rep := this(doing)
                put('@')
                put('B')
                this(doing).suspend   -- we must run the PSYSprocess until here
                -- make sure that the PSYSprocess does not resume here
                put('@')
                put('C')
                inner(doing)
                -- status := p_status.terminated
             theRepeat:
                out R: ref doRepeat
                R := this(doRepeat)
             --this(doRepeat).rep := doing --- probably no ref/doing) returned
             put('*')
             doing("doing") -- seems that compiler thinks here is a ref arg 
             put('+')  
             this(PSYSprocess).suspend
             put('=')
             rep: ref doing -- off:2
          newRepeat: ref doRepeat -- off: 5
          caller: ref PreemptiveProcess
          put('%')
          put('a')
          inner(PSYSprocess)
      PreemptiveProcess: PSYSprocess
          activateX:
             status := p_status.ACTIVE
             activate(this(PreemptiveProcess))
          console.display
             ("<ACT=" + id + ">").print
          this(PreemptiveProcess).suspend -- for doRepeat we suspend here,
          -- but we never start doRepeat
          put('%')
          put('b')
          inner(PreemptiveProcess)
          status := p_status.TERMINATED
      %private
      SQS: obj LIB.Collections.QueueLib.Queue
      activate:
         in P: ref PSYSprocess
         disable
         P.status := P_status.ACTIVE
         SQS.insert(P)
         enable
      scheduler:
         "SC:1:\n".print
         loop: do
            active: ref PSYSprocess
            SQS.scan
               active := current
               ("\nSC:Q: " + active.id + " {I2S(active.status)}\n").print
            active := SQS.removeNext
            SQS.scan
               active := current
               ("\nSC:W: " + active.id + " {I2S(active.status)}\n").print
            if (active =/= none) :then
               ("\nSC:A: " + active.id + " {I2S(active.status)}\n").print
               active.attach(50)
               SQS.scan
                  active := current
                  ("\nSC:E: " + active.id + " {I2S(active.status)}\n").print
               --("\nSC:S:" + active.id + " {I2S(active.status)} !\n").print
               "\nSC:S:".print
               if (active.status = p_status.ACTIVE) :then
                  "\nSC:B".print
                  if (active.newRepeat =/= none) :then
                     "\nSC:R:\n".print
                     active.status := p_status.WAITING
                     active.newRepeat.rep.status := P_status.ACTIVE
                     SQS.scan
                        active := current
                        ("\nSC:R: " + active.id + " {I2S(active.status)}\n").print
                     SQS.insert(active.newRepeat.rep)
                     SQS.scan
                        act: ref PSYSProcess
                        act := current
                        ("\nSC:T: " + act.id + " {I2S(act.status)}\n").print
                     "\nSC:Rx:\n".print
                     if (active.newRepeat.rep == none) :then
                         "\n!!active.newRepeat.rep is none".print
                     if active.newRepeat.rep.untilCond :then
                        ("\nSC:R:U" + active.id + " S\n").print
                        active.caller.status := p_status.ACTIVE
                        active.status := p_status.TERMINATED
                        active.newRepeat := none
                     :else
                        "\nSC:C".print
                        restart(loop)
                  :else
                     SQS.scan
                        act: ref PSYSProcess
                        act := current
                        ("\nSC:X: " + act.id + " {I2S(act.status)}\n").print
                     SQS.insert(active)
                     SQS.scan
                        act: ref PSYSProcess
                        act := current
                        ("\nSC:Y: " + act.id + " {I2S(act.status)}\n").print
                  restart(loop)
               :else
                  "\nSC:D".print
               --restart(loop)
            :else
               put('F')
            --restart(loop)
            -- "Scheduler terminated".print
      console: obj
         L: obj LockLib.Lock("Console:lock")
         %public
         display: 
            L.get
            disable
            inner(display)
            enable
            L.free
         L.init
      "PreemptiveSystem:\n".print
      inner(PreemptiveSystem)
      scheduler
   aPsys: obj PreemptiveSystem
     P1: obj PreemptiveProcess ("P1")
        ch: var Char
        ch := 'a'
        put('/')
        put('Q')
        doRepeat
            %id "repeat_inv"
            until::
                  BB := ch > 'g'
                  put(')')
            doing::
               L: do
                  put('/')
                  put('W')
                  put(ch)
                  ch := ch + 1
                  restart(L)
        put('/')
        put('E')
     --P2: obj PreemptiveProcess("P2")
     --   ch: var Char
     --   ch := 'A'
     --   repeatX
     --       exe::
     --          until::
     --             BB := ch > 'J'
     --          put('%')
     --          put(ch)
     --          ch := ch + 1
     --          restart(exe)
        ...
     P1.activateX
     "aPsys\n".print
