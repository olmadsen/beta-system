PreemptiveSystemLib: obj
   %visible Collections, LIB.StringLib,LIB.Collections.QueueLib
   PreemptiveSystem:
      P_status: obj 
         %globals
         %Public	 
         ACTIVE: val 1
         WAITING: val 2
         TERMINATED: val 3
      PSYSprocess: GeneralProcess
          %id "PSYSprocess"
          ifStop:<
             out B: var Boolean
             inner(ifStop)
          repeat: 
             until:<
                out BB: var Boolean
                inner(until)
             doing:< PSYSProcess
                %id "doing_process"
                ifStop::
                   B := until
                disable
                caller := this(PSYSProcess)
                this(PSYSprocess).newRepeat := this(repeat)
                rep := this(doing)
                enable
                this(doing).suspend 
                inner(doing)
             rep: ref doing
             doing("doing") -- seems that compiler thinks here is a ref arg 
             this(PSYSprocess).suspend
          newRepeat: ref repeat
          caller: ref PreemptiveProcess
          inner(PSYSprocess)
      PreemptiveProcess: PSYSprocess
          activateX:
             status := p_status.ACTIVE
             activate(this(PreemptiveProcess))
          this(PreemptiveProcess).suspend 
          inner(PreemptiveProcess)
          status := p_status.TERMINATED
      console: obj
         L: obj LockLib.Lock("Console:lock")
         %public
         display: 
            L.get
            disable
            inner(display)
            enable
            L.free
         L.init
      %private
      SQS: obj LIB.Collections.QueueLib.Queue
      activate:
         in P: ref PSYSprocess
         disable
         P.status := P_status.ACTIVE
         SQS.insert(P)
         enable
      scheduler:
         loop: do
            active: ref PSYSprocess
            active := SQS.removeNext
            if (active =/= none) :then
               active.attach(30)
               if (active.status = p_status.ACTIVE) :then
                  if (active.newRepeat =/= none) :then
                     active.status := p_status.WAITING
                     active.newRepeat.rep.status := P_status.ACTIVE
                     SQS.insert(active.newRepeat.rep)
                     active.newRepeat := none
                  :else
                     if (active.ifStop) :then
                           active.caller.status := p_status.ACTIVE
                           active.status := p_status.TERMINATED
                           SQS.insert(active.caller)
                     :else
                        SQS.insert(active)
                  restart(loop)
      "PreemptiveSystem:\n".print
      inner(PreemptiveSystem)
      scheduler
   aPsys: obj PreemptiveSystem
     P1: obj PreemptiveProcess ("P1")
        ch: var Char
        ch := 'a'
        console.display
           "Start P1\n".print
        repeat
            %id "repeat_inv"
            until::
                  BB := ch > 'g'
            doing::
               L: do
                  put(ch)
                  ch := ch + 1
                  restart(L)
        console.display
           "\nEnd: P1\n".print
     P2: obj PreemptiveProcess("P2")
        ch: var Char
        console.display
           "Start P2\n".print
        ch := 'A'
        repeat
           until::
                 BB := ch > 'J'
           doing::
              L: do
                 put(ch)
                 ch := ch + 1
                 restart(L)
        console.display
           "\nEnd: P2\n".print
     P1.activateX
     P2.activateX
     --"aPsys\n".print
