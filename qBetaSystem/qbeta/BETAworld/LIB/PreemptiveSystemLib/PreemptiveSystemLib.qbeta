PreemptiveSystemLib: obj
   %visible Collections, LIB.StringLib,LIB.Collections.QueueLib
   PreemptiveSystem:
      P_status: obj 
         %globals
         %Public	 
         ACTIVE: val 1
         WAITING: val 2
         TERMINATED: val 3
      PSYSprocess: GeneralProcess
          -- origin.off:4
          %id "PSYSprocess"
          ifStop:<
             out B: var Boolean
             inner(ifStop)
          doRepeat: 
             until:<
                out BB: var Boolean
                --put('(')
                inner(until)
                --put('!')
             doing:< PSYSProcess
                %id "doing_process"
                ifStop::
                   B := until
                --put('@')
                --put('A')
                disable
                caller := this(PSYSProcess)
                this(PSYSprocess).newRepeat := theRepeat
                rep := this(doing)
                enable
                --put('@')
                --put('B')
                this(doing).suspend   -- we must run the PSYSprocess until here
                -- make sure that the PSYSprocess does not resume here
                --put('@')
                --put('C')
                inner(doing)
                -- status := p_status.terminated
             theRepeat:
                out R: ref doRepeat
                R := this(doRepeat)
             rep: ref doing -- off:2
             --this(doRepeat).rep := doing --- probably no ref/doing) returned
             --put('*')
             doing("doing") -- seems that compiler thinks here is a ref arg 
             --put('+')  
             this(PSYSprocess).suspend
             --put('=')
          newRepeat: ref doRepeat -- off: 5
          caller: ref PreemptiveProcess
          --put('%')
          --put('a')
          inner(PSYSprocess)
      PreemptiveProcess: PSYSprocess
          activateX:
             status := p_status.ACTIVE
             activate(this(PreemptiveProcess))
          --console.display
          --   ("<ACT=" + id + ">").print
          this(PreemptiveProcess).suspend -- for doRepeat we suspend here,
          -- but we never start doRepeat
          --put('%')
          --put('b')
          inner(PreemptiveProcess)
          status := p_status.TERMINATED
      console: obj
         L: obj LockLib.Lock("Console:lock")
         %public
         display: 
            L.get
            disable
            inner(display)
            enable
            L.free
         L.init
      %private
      SQS: obj LIB.Collections.QueueLib.Queue
      activate:
         in P: ref PSYSprocess
         disable
         P.status := P_status.ACTIVE
         SQS.insert(P)
         enable
      scheduler:
         --"SC:1:\n".print
         loop: do
            active: ref PSYSprocess
            active := SQS.removeNext
            if (active =/= none) :then
               --("\nSC:A: " + active.id + " {I2S(active.status)}\n").print
               active.attach(30)
               --"\nSC:S:".print
               if (active.status = p_status.ACTIVE) :then
                  --"\nSC:B".print
                  if (active.newRepeat =/= none) :then
                     --"\nSC:R:\n".print
                     --("\nSC:A: " + active.id + " {I2S(active.status)}\n").print
                     active.status := p_status.WAITING
                     active.newRepeat.rep.status := P_status.ACTIVE
                     SQS.insert(active.newRepeat.rep)
                     active.newRepeat := none
                     --put('Q')
                  :else
                     --"\nSC:Rx:\n".print
                     if (active.ifStop) :then
                           --("\nSC:R:U" + active.id + " S\n").print
                           active.caller.status := p_status.ACTIVE
                           active.status := p_status.TERMINATED
                           SQS.insert(active.caller)
                     :else
                        SQS.insert(active)
                  restart(loop)
               :else
                  -- "\nSC:D".print
                  restart(loop)
            :else
                -- put('F')
                ...
      "PreemptiveSystem:\n".print
      inner(PreemptiveSystem)
      scheduler
   aPsys: obj PreemptiveSystem
     P1: obj PreemptiveProcess ("P1")
        ch: var Char
        ch := 'a'
        console.display
           "Start P1\n".print
        doRepeat
            %id "repeat_inv"
            until::
                  BB := ch > 'g'
            doing::
               L: do
                  put(ch)
                  ch := ch + 1
                  restart(L)
        console.display
           "\nEnd: P1\n".print
     P2: obj PreemptiveProcess("P2")
        ch: var Char
        console.display
           "Start P2\n".print
        ch := 'A'
        doRepeat
           until::
                 BB := ch > 'J'
           doing::
              L: do
                 put(ch)
                 ch := ch + 1
                 restart(L)
        console.display
           "\nEnd: P2\n".print
     P1.activateX
     P2.activateX
     --"aPsys\n".print
