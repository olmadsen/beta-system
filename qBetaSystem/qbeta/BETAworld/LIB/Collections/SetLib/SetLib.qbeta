SetLib: obj
   Set: Collection
      %globals 
      has::
         B := false
         scan
            if (current == e) :then
                B:= true
                leave(has)
            :else
                B:= B
      isEmpty::<
          B := head == none
      insert::
          if has(e).not :then
             head:= link(e,head)
      remove::
         "\nObs! Set:remove:not implemented!\n".print      
      size::<
          scan
             N:= N + 1
      clear::<
         head := none      
      scan:
         %OSDvisibility skipInternal
         current: ref elm
         nxt: ref link
         nxt := head
         scanTail:
            current: ref elm
            nxtt: ref link
            nxtt := this(scan).nxt.next
            loop: do
               if (nxtt =/= none) :then
                  current := nxtt.e
                  inner(scanTail)
                  nxtt := nxtt.next
                  restart(loop)

         Loop: do
            if (nxt =/= none) :then
               current:= nxt.e
               inner(scan)
               nxt:= nxt.next
               restart(Loop)
            :else
              nxt:= nxt
      forAllX:
           current: ref elm
           scan
              (this(forAllX)).current := current
              inner(forAllX)
      -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
      forAll:
         in pred:<
            in x: ref Object
            out V: var Boolean
         out B: var Boolean
         B := true
         scan
            B := B && pred(current)
      exists:
         in pred:<
            in x: ref elm
            out V: var Boolean
         out B: var Boolean
         scan
             if (pred(current)) :then
                 B := true
                 leave(scan)
      reduce:
         in F:<
            in x: ref Object
            in b: var Boolean
            out z: var Boolean
         in IV: var Boolean    
         out V: var Boolean
         V := IV
         scan
            V := F(current,V)
      link:
         in e: ref elm
         in next: ref link
      head: ref link
      inner(Set)
   test:
       Record(ch: var char):
          print:
             put(ch)
       L: obj Set(#Record)
       R: ref Record
       L.insert(Record('d'))
       L.insert(Record('c'))
       R := Record('b')
       L.insert(R)
       L.insert(Record('a'))
       L.insert(R)
       --"Size: {putint(L.size)}\n".print
       "Size: ".print
       putint(L.size)
       newline
       L.scan
           current.print
           if (current.ch = 'b') :then
              put('[')
              scanTail
                  current.print
              put(']')
       newline
   --test