Xarray: obj
   -- has semantic errors
   %visible  StringLib
   Dimension: Value
      in low: var integer
      in upp: var integer
      Length:
         out V: var integer
         V := (upp - low) + 1
      print:
        "Dimension:(".print
        putint(low)
        put(',')
        putint(upp)
        put(')')
      --print
   Range:
      in dims: ref indexed(1,#Dimension)
      put('R')
      putint(dims.length)
      put(';')
      for (1) :to (dims.length) :repeat
          (dims.get[inx]).print
   Array:
      -- A[1:3][1:4] =
      -- A[i][j] = (i - 1) * D2.length + j
      -- A[1][1] = R[1]
      -- A[1][2] = R[2]
      -- A[1][3] = R[3]
      -- A[1][4] = R[4]
      -- A[2][1] = R[5] = (2 - 1) * 4 + 1 = 5
      
      in D1: var Dimension(0,0)
      in D2: var Dimension(0,0)
      put(V: var float):at[ix1: var integer,ix2: var integer]:
         inx: var integer
         inx := ((ix1 - 1) * D2.length) + ix2
         R.put(V):at[inx]

      get[ix1: var integer,ix2: var integer]:
          out V: var float
          V := R.get[((ix1 - 1) * D2.length) + ix2]
      add[row1: var integer, row2: var integer]:
         for (1) :to (D2.length) :repeat
              put(get[row1,inx] + get[row2,inx]):at[row1,inx]
      
      mult[row: var integer]:by(V: var integer):
         for (1) :to (D2.length) :repeat
              put(get[row,inx] * V):at[row,inx]
      sort:
         for (1) :to (D1.length) :repeat
              i: var integer
              i := inx
              for (i + 1) :to (D1.length) :repeat
                  j: var integer
                  j := inx
                  if (get[i,i] < get[j,i]) :then
                      for (1) :to (D2.length) :repeat
                           k: var integer
                           k := inx
                           put(get[i,k] + get[j,k]):at[i,k]
                           put(get[i,k] - get[j,k]):at[j,k]
                           put(get[i,k] - get[j,k]):at[i,k]
      Gauss:
         "Gauss:\n".print      
         for (1) :to ((D1.length - 1)) :repeat
              i: var integer
              i := inx
              for (i + 1) :to (D1.length) :repeat
                  j: var integer
                  j := inx
                  f: var Float
                  x: var Float
                  "i:{I2S(i)}, j: {I2S(j)}:\n".print	  
                  x := get[j,i]		  
                  "A: ".print
                  putFloat(x)
                  " B: ".print
                  putFloat(get[i,i])                  
                  f := get[j,i]
                  f := f / get [i,i]	
                  " F: ".print
                  putFloat(f)
                  newline		  
                  for (1) :to (D2.length) :repeat
                        k: var integer
                        k := inx
                        "\nInner: i:{I2S(i)}, j: {I2S(j)}, k: {I2S(k)}:\n".print
                        "X: ".print
                        x := get[j,k]      
                        putFloat(x)
                        " Y: ".print
                        x := get[i,k]      
                        putFloat(x)
                        " Z: ".print
                        x := f * get[j,k]      
                        putFloat(x)
                        "\nQ: ".print
                        x := (get[j,k] - (f * get[i,k]))
                        putFloat(x)
                        put(get[j,k] - (f * get[i,k])):at[j,k]
                        " W: ".print
                        x := get[j,k]      
                        putFloat(x)
                        newline			
      substitute:
         out res: obj Indexed(D1.length,#Float)
         for (1) :to (D1.length) :repeat
              i: var integer
              i := (D1.length - inx) + 1
              "\nsub, i={I2S(i)} = ".print
              putFloat(get[i,D2.length])
              newline
              res.put((get[i,D2.length])):at[i]
              for (i + 1) :to (D1.length) :repeat
                   j: var integer
                   j := inx
                   "\nsub:inner, i={I2S(i)}, j={I2S(j)}\n".print
                   if (i <> j):then		      
                      "res[{I2S(i)}] = ".print		   
                      putFloat(res.get[i])
                      "\nget[i,j] = ".print
                      putFloat(get[i,j])
                      "\nres[{I2S(j)}] = ".print		   
                      putFloat(res.get[j])
                      " exp: ".print
                      putFloat((res.get[i]) - (get[i,j] * (res.get[j])))
                      res.put((res.get[i]) - (get[i,j] * (res.get[j]))) :at[i]
                   :else
                      "nskip:\n".print
              "\nDiv: ".print
              putFloat((res.get[i]))
              " / ".print
              putfloat(get[i,i])
              " = ".print
              putfloat((res.get[i]) / get[i,i])
              newline
              res.put((((res.get[i])) / get[i,i])):at[i]
              "\nsub:final, i={I2S(i)} = ".print
              putfloat(res.get[i])
              newline
         "\nSolution:\n".print
         for (1) :to (D1.length) :repeat
              putFloat(res.get[inx])
              put(' ')
         newline	      
      printSeq:
         "print: ".print
         putint(R.length)
         newline
         for (1) :to (R.length) :repeat
              putint(R.get[inx])
              put(' ')
      print:
         "Matrix:\n".print
         for (D1.low) :to (D1.upp) :repeat
              ix: var integer
              ix := inx
              for (D2.low) :to (D2.upp) :repeat
                   F:  var Float
                   F := get[ix,inx]
                   --F :=R.get[((ix - 1) * D2.length) + inx]
                   putFloat(F)
                   put(' ' )
              newline
      
      R: obj Indexed(D1.length * D2.length,#Float)   
      range: var integer
      range := D1.length * D2.length
      --R := Indexed(range,#Float)     
   A: obj Array(Dimension(1,3),Dimension(1,4))

   simple:
      B: obj Array(Dimension(1,2),Dimension(1,3))
      "\nSimple:\n".print
      B.put(1):at[1,1]
      B.put(1):at[1,2]
      B.put(3):at[1,3]
      B.put(3):at[2,1]
      B.put(0 - 2):at[2,2]
      B.put(4):at[2,3]
      B.print
      newline
      B.sort
      B.print
      newline
      B.Gauss
      B.print
      newline
      B.substitute
      B.print
   for (1) :to (3) :repeat
      ix: var integer
      ix := inx
      for (1) :to (4) :repeat
           F: var Float
           F := inx * inx + (ix * 5)
           A.put(F):at[ix,inx]	   
   A.printSeq
   newline
   A.print
   newline
   --Range((1,10))
   A.mult[1]:by(2)
   A.print
   newline
   A.add[3,1]
   A.print
   A.sort
   A.print
   newline
   A.Gauss
   A.print
   newline
   A.substitute
   Simple
   newline