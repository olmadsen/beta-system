;;; Start of LLVM
target triple = "i686-pc-windows-cygnus"
%BETAworld$1 = type {%vdt_type$BETAworld$1 *,%Object$22*,%BETA$2*,%LIB$8*,%QBETA$16*,%workspace$17*}
%vdt_type$BETAworld$1 = type {%BETAworld$1*(%BETAworld$1*)*}
%vdt_ret$BETAworld$1 = type{%BETAworld$1*,%BETAworld$1*(%BETAworld$1*)*}

%BETA$2 = type {%vdt_type$BETA$2 *,%BETAworld$1*,%$S$3$3*}
%vdt_type$BETA$2 = type {%BETA$2*(%BETA$2*)*}
%vdt_ret$BETA$2 = type{%BETA$2*,%BETA$2*(%BETA$2*)*}

%$S$3$3 = type {%vdt_type$$S$3$3 *,%BETA$2*,i32,i32,i32}
%vdt_type$$S$3$3 = type {%$S$3$3*(%$S$3$3*)*}
%vdt_ret$$S$3$3 = type{%$S$3$3*,%$S$3$3*(%$S$3$3*)*}

%_assign$4 = type {%vdt_type$_assign$4 *,%Value$5*,i32,i32}
%vdt_type$_assign$4 = type {%_assign$4*(%_assign$4*)*}
%vdt_ret$_assign$4 = type{%_assign$4*,%_assign$4*(%_assign$4*)*}

%Value$5 = type {%vdt_type$Value$5 *}
%vdt_type$Value$5 = type {%Value$5*(%Value$5*, i32)*}
%vdt_ret$Value$5 = type{%Value$5*,%Value$5*(%Value$5*, i32)*}

%char$6 = type {%vdt_type$char$6 *,i32}
%vdt_type$char$6 = type {%char$6*(%char$6*, i32)*}
%vdt_ret$char$6 = type{%char$6*,%char$6*(%char$6*, i32)*}

%universal$7 = type {%vdt_type$universal$7 *}
%vdt_type$universal$7 = type {%universal$7*(%universal$7*, i32)*}
%vdt_ret$universal$7 = type{%universal$7*,%universal$7*(%universal$7*, i32)*}

%LIB$8 = type {%vdt_type$LIB$8 *,%BETAworld$1*,i32,%BasicIO$10*,%StringLib$14*}
%vdt_type$LIB$8 = type {%LIB$8*(%LIB$8*)*}
%vdt_ret$LIB$8 = type{%LIB$8*,%LIB$8*(%LIB$8*)*}

%integer$9 = type {%vdt_type$integer$9 *,i32}
%vdt_type$integer$9 = type {%integer$9*(%integer$9*, i32)*}
%vdt_ret$integer$9 = type{%integer$9*,%integer$9*(%integer$9*, i32)*}

%BasicIO$10 = type {%vdt_type$BasicIO$10 *,%LIB$8*,%$S$11$11*,%$S$12$12*}
%vdt_type$BasicIO$10 = type {%BasicIO$10*(%BasicIO$10*)*}
%vdt_ret$BasicIO$10 = type{%BasicIO$10*,%BasicIO$10*(%BasicIO$10*)*}

%$S$11$11 = type {%vdt_type$$S$11$11 *,%BasicIO$10*}
%vdt_type$$S$11$11 = type {%$S$11$11*(%$S$11$11*)*}
%vdt_ret$$S$11$11 = type{%$S$11$11*,%$S$11$11*(%$S$11$11*)*}

%$S$12$12 = type {%vdt_type$$S$12$12 *,%BasicIO$10*,%Lock$13*}
%vdt_type$$S$12$12 = type {%$S$12$12*(%$S$12$12*)*}
%vdt_ret$$S$12$12 = type{%$S$12$12*,%$S$12$12*(%$S$12$12*)*}

%Lock$13 = type {%vdt_type$Lock$13 *,%BasicIO$10*,i32,i32}
%vdt_type$Lock$13 = type {%Lock$13*(%Lock$13*)*}
%vdt_ret$Lock$13 = type{%Lock$13*,%Lock$13*(%Lock$13*)*}

%StringLib$14 = type {%vdt_type$StringLib$14 *,%LIB$8*}
%vdt_type$StringLib$14 = type {%StringLib$14*(%StringLib$14*)*}
%vdt_ret$StringLib$14 = type{%StringLib$14*,%StringLib$14*(%StringLib$14*)*}

%String$15 = type {%vdt_type$String$15 *,%StringLib$14*}
%vdt_type$String$15 = type {%String$15*(%String$15*)*}
%vdt_ret$String$15 = type{%String$15*,%String$15*(%String$15*)*}

%QBETA$16 = type {%vdt_type$QBETA$16 *,%BETAworld$1*}
%vdt_type$QBETA$16 = type {%QBETA$16*(%QBETA$16*)*}
%vdt_ret$QBETA$16 = type{%QBETA$16*,%QBETA$16*(%QBETA$16*)*}

%workspace$17 = type {%vdt_type$workspace$17 *,%BETAworld$1*,%LLVMex$18*}
%vdt_type$workspace$17 = type {%workspace$17*(%workspace$17*)*}
%vdt_ret$workspace$17 = type{%workspace$17*,%workspace$17*(%workspace$17*)*}

%LLVMex$18 = type {%vdt_type$LLVMex$18 *,%workspace$17*,%mini4$19*}
%vdt_type$LLVMex$18 = type {%LLVMex$18*(%LLVMex$18*)*}
%vdt_ret$LLVMex$18 = type{%LLVMex$18*,%LLVMex$18*(%LLVMex$18*)*}

%mini4$19 = type {%vdt_type$mini4$19 *,%LLVMex$18*}
%vdt_type$mini4$19 = type {%mini4$19*(%mini4$19*)*}
%vdt_ret$mini4$19 = type{%mini4$19*,%mini4$19*(%mini4$19*)*}

%put$20 = type {%vdt_type$put$20 *,i32}
%vdt_type$put$20 = type {%put$20*(%put$20*)*}
%vdt_ret$put$20 = type{%put$20*,%put$20*(%put$20*)*}

%$for$$to$repeat$21 = type {%vdt_type$$for$$to$repeat$21 *,i32,i32,i32}
%vdt_type$$for$$to$repeat$21 = type {%$for$$to$repeat$21*(%$for$$to$repeat$21*)*,%vdt_ret$repeat$24$44*(%$for$$to$repeat$21*)*
,i8*(i8*)*}
%vdt_ret$$for$$to$repeat$21 = type{%$for$$to$repeat$21*,%$for$$to$repeat$21*(%$for$$to$repeat$21*)*}

%Object$22 = type {%vdt_type$Object$22 *,%BETA$2*}
%vdt_type$Object$22 = type {i8*(i8*)*}
%vdt_ret$Object$22 = type{%Object$22*,%Object$22*(%Object$22*)*}

%$for$$to$repeat$S$25$25 = type {%vdt_type$$for$$to$repeat$S$25$25 *,i32,i32,i32,%mini4$19*}
%vdt_type$$for$$to$repeat$S$25$25 = type {%$for$$to$repeat$21*(%$for$$to$repeat$21*)*,%vdt_ret$repeat$S$32$32*(%$for$$to$repeat$S$25$25*)*
,%$for$$to$repeat$S$25$25*(%$for$$to$repeat$S$25$25*)*}
%vdt_ret$$for$$to$repeat$S$25$25 = type{%$for$$to$repeat$S$25$25*,%$for$$to$repeat$S$25$25*(%$for$$to$repeat$S$25$25*)*}

%$S$26$26 = type {%vdt_type$$S$26$26 *,%$for$$to$repeat$21*}
%vdt_type$$S$26$26 = type {%$S$26$26*(%$S$26$26*)*}
%vdt_ret$$S$26$26 = type{%$S$26$26*,%$S$26$26*(%$S$26$26*)*}

%$S$28$28 = type {%vdt_type$$S$28$28 *,%$S$26$26*}
%vdt_type$$S$28$28 = type {%$S$28$28*(%$S$28$28*)*}
%vdt_ret$$S$28$28 = type{%$S$28$28*,%$S$28$28*(%$S$28$28*)*}

%repeat$S$32$32 = type {%vdt_type$repeat$S$32$32 *,%$for$$to$repeat$S$25$25*}
%vdt_type$repeat$S$32$32 = type {%repeat$S$32$32*(%repeat$S$32$32*)*}
%vdt_ret$repeat$S$32$32 = type{%repeat$S$32$32*,%repeat$S$32$32*(%repeat$S$32$32*)*}

%_add$33 = type {%vdt_type$_add$33 *,%String$15*,%String$15*,%String$15*,i32}
%vdt_type$_add$33 = type {%_add$33*(%_add$33*)*}
%vdt_ret$_add$33 = type{%_add$33*,%_add$33*(%_add$33*)*}

%length$34 = type {%vdt_type$length$34 *,%String$15*,i32}
%vdt_type$length$34 = type {%length$34*(%length$34*)*}
%vdt_ret$length$34 = type{%length$34*,%length$34*(%length$34*)*}

%$S$35$35 = type {%vdt_type$$S$35$35 *,%_add$33*,i32,i32,%array$1*}
%vdt_type$$S$35$35 = type {%$S$35$35*(%$S$35$35*)*}
%vdt_ret$$S$35$35 = type{%$S$35$35*,%$S$35$35*(%$S$35$35*)*}

%Indexed$36 = type {%vdt_type$Indexed$36 *,i32}
%vdt_type$Indexed$36 = type {%Indexed$36*(%Indexed$36*)*,%vdt_ret$elm$37$45*(%Indexed$36*)*
}
%vdt_ret$Indexed$36 = type{%Indexed$36*,%Indexed$36*(%Indexed$36*)*}

%$for$$to$repeat$S$38$38 = type {%vdt_type$$for$$to$repeat$S$38$38 *,i32,i32,i32,%$S$35$35*}
%vdt_type$$for$$to$repeat$S$38$38 = type {%$for$$to$repeat$21*(%$for$$to$repeat$21*)*,%vdt_ret$repeat$S$41$41*(%$for$$to$repeat$S$38$38*)*
,%$for$$to$repeat$S$38$38*(%$for$$to$repeat$S$38$38*)*}
%vdt_ret$$for$$to$repeat$S$38$38 = type{%$for$$to$repeat$S$38$38*,%$for$$to$repeat$S$38$38*(%$for$$to$repeat$S$38$38*)*}

%$for$$to$repeat$S$39$39 = type {%vdt_type$$for$$to$repeat$S$39$39 *,i32,i32,i32,%$S$35$35*}
%vdt_type$$for$$to$repeat$S$39$39 = type {%$for$$to$repeat$21*(%$for$$to$repeat$21*)*,%vdt_ret$repeat$S$43$43*(%$for$$to$repeat$S$39$39*)*
,%$for$$to$repeat$S$39$39*(%$for$$to$repeat$S$39$39*)*}
%vdt_ret$$for$$to$repeat$S$39$39 = type{%$for$$to$repeat$S$39$39*,%$for$$to$repeat$S$39$39*(%$for$$to$repeat$S$39$39*)*}

%_assign$40 = type {%vdt_type$_assign$40 *,%Object$22*}
%vdt_type$_assign$40 = type {%_assign$40*(%_assign$40*)*}
%vdt_ret$_assign$40 = type{%_assign$40*,%_assign$40*(%_assign$40*)*}

%repeat$S$41$41 = type {%vdt_type$repeat$S$41$41 *,%$for$$to$repeat$S$38$38*}
%vdt_type$repeat$S$41$41 = type {%repeat$S$41$41*(%repeat$S$41$41*)*}
%vdt_ret$repeat$S$41$41 = type{%repeat$S$41$41*,%repeat$S$41$41*(%repeat$S$41$41*)*}

%repeat$S$43$43 = type {%vdt_type$repeat$S$43$43 *,%$for$$to$repeat$S$39$39*}
%vdt_type$repeat$S$43$43 = type {%repeat$S$43$43*(%repeat$S$43$43*)*}
%vdt_ret$repeat$S$43$43 = type{%repeat$S$43$43*,%repeat$S$43$43*(%repeat$S$43$43*)*}

%repeat$24$44 = type {%vdt_type$repeat$24$44 *,%$for$$to$repeat$21*,%Object$22*}
%vdt_type$repeat$24$44 = type {}
%vdt_ret$repeat$24$44 = type{%repeat$24$44*,%repeat$24$44*(%repeat$24$44*)*}

%elm$37$45 = type {%vdt_type$elm$37$45 *,%Indexed$36*,%Object$22*}
%vdt_type$elm$37$45 = type {}
%vdt_ret$elm$37$45 = type{%elm$37$45*,%elm$37$45*(%elm$37$45*)*}

%array$1 = type {i8*, i32, [0 x i32]}


declare noalias i8* @malloc(i64)
declare noalias i32* @allocIndexed(i32,i32)
declare noalias i32 @arrayLength(i32*)
declare noalias i32* @allocString(i8*, i32)
declare i32 @puts(i8* nocapture) nounwind
declare i32 @putCh(i32 nocapture) nounwind
declare i32 @putHex(i32 nocapture) nounwind
declare i32 @dumpHex(i32 nocapture, i32 nocapture) nounwind
declare void @notImpl(i32 nocapture) nounwind
   ;; QBETA
   ;; OG:markForCodeGen: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;--wor ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;--workspace;}" 
   ;; ComputeVariant:A: "BETAworld" 
   ;; %id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;--workspace;} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;--workspace;}" q ... 0 
   ;; OG:Qalloc:A:  "BETAworld"  super:  ""  marked:  true "BETAworld: obj {   %id "BETAworld";   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;     ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;--workspace;}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "BETAworld" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 1 IS.newDescNo: 1 objSize: 0 varNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integ ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM ...}" 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: error 
   ;; ModuleItem:Qalloc:  --BETA{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: BETA 
   ;; Module:alloc:off: 2 BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   universal: Value;      %ID universal;      %basic 1, 32; ...} 
   ;; ModuleItem:Qalloc:  --DK{} 
   ;; ModuleItem:Qalloc:  --LIB{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: LIB 
   ;; Module:alloc:off: 3 LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem; ...} 
   ;; ModuleItem:Qalloc:  --OOPM{} 
   ;; ModuleItem:Qalloc:  --QBETA{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: QBETA 
   ;; Module:alloc:off: 4 QBETA: obj {   %requires BETA;   %visible BETA;   NewSyntaxIndexed: ;      %globals;      %basic 114;      %public;      in range: var Integer;      in ...} 
   ;; ModuleItem:Qalloc:  --no{} 
   ;; ModuleItem:Qalloc:  --workspace{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: workspace 
   ;; Module:alloc:off: 5 workspace: obj {   %id "workspace";   %include BETA, LIB, LIB.BasicIO, qbeta;   %domain_boundary;   --AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;-- ...} 
   ;; Items:Qalloc:END:objSize: 5  newDescNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;-- ...}" 
   ;; IS.newDescNo: 1 IS.objSize: 5 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  1 
   ;; "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;--workspace;}" 
   ;; computeVariant:newDescNo: 1  size:  5  IS: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;- ...}" 
   ;; ComputeVariant:B:  "BETAworld" 
   ;; ObjTmpStack:add: :genDone: false   "BETAworld" : "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;- ...}" 
   ;; items:markForCodeGen: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;   x: var BETA.integer;--BETA;--DK;--LIB;--OOPM;--QBETA;--no;-- ...}" 
   ;; markItem: "%id "BETAworld"" Property 
   ;; markItem: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" Property 
   ;; OG:markForCodeGen: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basi ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;    ...}" 
   ;; ComputeVariant:A: "BETA" 
   ;; %ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;    ...}" q ... 0 
   ;; OG:Qalloc:A:  "BETA"  super:  ""  marked:  true "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   universal: Value;      %ID  ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: va ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "BETA" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 2 IS.newDescNo: 2 objSize: 0 varNo: 1 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;  ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: universal 
   ;; Pattern:Qalloc: integer 
   ;; Pattern:Qalloc: Boolean 
   ;; Pattern:Qalloc: False 
   ;; Pattern:Qalloc:B: False 
   ;; Pattern:Qalloc: True 
   ;; Pattern:Qalloc:B: True 
   ;; Pattern:Qalloc: char 
   ;; Pattern:Qalloc: universalFloat 
   ;; Pattern:Qalloc: float 
   ;; Pattern:Qalloc: put 
   ;; Pattern:Qalloc: _put 
   ;; Pattern:Qalloc: _get 
   ;; Pattern:Qalloc: _iget 
   ;; Pattern:Qalloc:B: _iget 
   ;; Pattern:Qalloc: _kbhit 
   ;; Pattern:Qalloc:B: _kbhit 
   ;; Pattern:Qalloc: Object 
   ;; Pattern:Qalloc: Value 
   ;; Pattern:Qalloc: Cvalue 
   ;; Pattern:Qalloc:B: Cvalue 
   ;; Pattern:Qalloc: none 
   ;; Pattern:Qalloc: immutable 
   ;; Pattern:Qalloc: unique 
   ;; Pattern:Qalloc:B: unique 
   ;; Pattern:Qalloc: @innerX::inner 
   ;; Pattern:Qalloc: inner 
   ;; Pattern:Qalloc: this 
   ;; Pattern:Qalloc: disable 
   ;; Pattern:Qalloc: enable 
   ;; Pattern:Qalloc: fork 
   ;; Pattern:Qalloc: sleep 
   ;; Pattern:Qalloc: core 
   ;; Pattern:Qalloc:B: core 
   ;; Pattern:Qalloc: thisCore 
   ;; Pattern:Qalloc: thisCoreId 
   ;; Pattern:Qalloc: inSub 
   ;; Pattern:Qalloc: method 
   ;; Pattern:Qalloc:B: method 
   ;; Pattern:Qalloc: disguised 
   ;; Pattern:Qalloc:B: disguised 
   ;; Pattern:Qalloc: SkipInternal 
   ;; Pattern:Qalloc:B: SkipInternal 
   ;; Pattern:Qalloc: Show 
   ;; Pattern:Qalloc:B: Show 
   ;; Pattern:Qalloc: Indexed 
   ;; Pattern:Qalloc: IndexedRef 
   ;; Pattern:Qalloc: @if::then 
   ;; Pattern:Qalloc: @ifX::thenX 
   ;; Pattern:Qalloc: @restart: 
   ;; Pattern:Qalloc: @leave: 
   ;; Pattern:Qalloc: @if::then:else 
   ;; Pattern:Qalloc:B: @if::then:else 
   ;; Pattern:Qalloc: cycle 
   ;; Pattern:Qalloc:B: cycle 
   ;; Pattern:Qalloc: @for::to:repeat 
   ;; Pattern:Qalloc:B: @for::to:repeat 
   ;; Pattern:Qalloc: switch 
   ;; Pattern:Qalloc:B: switch 
   ;; Pattern:Qalloc: rswitch 
   ;; Pattern:Qalloc:B: rswitch 
   ;; dataitem:qalloc: "ascii" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 2 "ascii: obj {   nl: val 10;   cr: val 13;   newline: var char;   isLetter: ;      in ch: var char;      out B: var Boolean;      B := ((('a' <= ch) && (ch ...}" 
   ;; OG:Qalloc: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z' ...}" q ... 0 
   ;; OG:Qalloc:A:  "$S$0"  super:  ""  marked:  false "ascii: obj {   nl: val 10;   cr: val 13;   newline: var char;   isLetter: ;      in ch: var char;      out B: var Boolean ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')));isDigit ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 3 IS.newDescNo: 3 objSize: 0 varNo: 1 "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 3 "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "nl" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; dataitem:qalloc: "cr" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 3 
   ;; dataitem:qalloc: "newline" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 4 
   ;; Pattern:Qalloc: isLetter 
   ;; Pattern:Qalloc:B: isLetter 
   ;; Pattern:Qalloc: isDigit 
   ;; Pattern:Qalloc:B: isDigit 
   ;; OG:Qalloc: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  marked:  false "nl: val 10{cr: val 13;newline: var char;isLetter ...}" s ... n ... 
   ;; Invocation:Qalloc: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; ObjectInvocation:Qalloc: "newline" 
   ;; name:   "newline" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; name:   ":=" 
   ;; Arguments   "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:Qalloc:SuperAlloc: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc: "%basic 8{in V: var Value;--inner(Value);}" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  ""  marked:  false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%basic 8{in V: var Value;--inner(Value);}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: ":=" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 4 IS.newDescNo: 4 objSize: 0 varNo: 1 "%basic 8{in V: var Value;--inner(Value);}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 4 "%basic 8{in V: var Value;--inner(Value);}" 
   ;; OriginIsValue: true 
   ;; Items:Qalloc:Super:C:objSize: 3 originOff: 1 
   ;; dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
   ;; diSize: 1 IT.qSize: 4 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 4 "%basic 8{in V: var Value;--inner(Value);}" 
   ;; IS.newDescNo: 4 IS.objSize: 4 "%basic 8{in V: var Value;--inner(Value);}" 
   ;; OG:Qalloc:end: IS.newDescNo:  4 
   ;; "%basic 8{in V: var Value;--inner(Value);}" 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; super:  "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; E:  ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 3 "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z') ...}" 
   ;; IS.newDescNo: 3 IS.objSize: 4 "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' < ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  3 
   ;; "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')));isDigit ...}" 
   ;; Pattern:Qalloc: newline 
   ;; Pattern:Qalloc:B: newline 
   ;; Pattern:Qalloc: int2chars 
   ;; Pattern:Qalloc:B: int2chars 
   ;; Pattern:Qalloc: putint 
   ;; Pattern:Qalloc:B: putint 
   ;; Pattern:Qalloc: exp 
   ;; Pattern:Qalloc:B: exp 
   ;; Pattern:Qalloc: sqrt 
   ;; Pattern:Qalloc: cbrt 
   ;; Pattern:Qalloc: log 
   ;; Pattern:Qalloc: putFloat 
   ;; Pattern:Qalloc: putFloatX 
   ;; Pattern:Qalloc:B: putFloatX 
   ;; ModuleItem:Qalloc:  --doTest{} 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globa ...}" 
   ;; IS.newDescNo: 2 IS.objSize: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ; ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  2 
   ;; "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: va ...}" 
   ;; computeVariant:newDescNo: 2  size:  2  IS: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %glob ...}" 
   ;; ComputeVariant:B:  "BETA" 
   ;; ObjTmpStack:add: :genDone: false   "BETA" : "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %glo ...}" 
   ;; items:markForCodeGen: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %b ...}" 
   ;; markItem: "%ID BETA" Property 
   ;; markItem: "%OSDvisibility disguised" Property 
   ;; markItem: "%module LIB, LIB.StringLib" Property 
   ;; markItem: "%public" Property 
   ;; DataItem:markForCodeGen: "ascii" :descNo: 3 :OG.primNo: 0 
   ;; OG:markForCodeGen: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (c ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z' ...}" 
   ;; ComputeVariant:A: "$S$3" 
   ;; nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')));isDigit: ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z' ...}" q ... 3 
   ;; computeVariant:newDescNo: 3  size:  4  IS: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z' ...}" 
   ;; ComputeVariant:B:  "$S$3" 
   ;; ObjTmpStack:add: :genDone: false   "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (( ...}" 
   ;; items:markForCodeGen: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && ...}" 
   ;; DataItem:markForCodeGen: "nl" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "10" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "10" 
   ;; "10" true 
   ;; 
   ;; OG:markSuper: "10" 
   ;; Invocation:markForCodeGen: "10" 
   ;; not ObjDesc:  "10"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "cr" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "13" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "13" 
   ;; "13" true 
   ;; 
   ;; OG:markSuper: "13" 
   ;; Invocation:markForCodeGen: "13" 
   ;; not ObjDesc:  "13"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "newline" :descNo: 0 :OG.primNo: 3 
   ;; OG:markForCodeGen: "char" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "char" 
   ;; "char" true 
   ;; 
   ;; OG:markSuper: "char" 
   ;; Invocation:markForCodeGen: "char" 
   ;; ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
   ;; Pattern:markForCodeGen: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;  ...}" 
   ;; OG:markForCodeGen: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "value" 
   ;; "value" true 
   ;; 
   ;; OG:markSuper: "value" 
   ;; Invocation:markForCodeGen: "value" 
   ;; ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value ...}" 
   ;; Pattern:markForCodeGen: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value);      }" 
   ;; OG:markForCodeGen: "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; ComputeVariant:A: "Value" 
   ;; %ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" qDescno:  0 
   ;; OG:Qalloc:A:  "Value"  super:  ""  marked:  true "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Val ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "Value" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 5 IS.newDescNo: 5 objSize: 0 varNo: 1 "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 5 "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; Items:Qalloc:Super:C:objSize: 0 originOff: 0 
   ;; Pattern:Qalloc: := 
   ;; Items:Qalloc:END:objSize: 0  newDescNo: 5 "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; IS.newDescNo: 5 IS.objSize: 0 "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:end: IS.newDescNo:  5 
   ;; "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; computeVariant:newDescNo: 5  size:  0  IS: "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; ComputeVariant:B:  "Value" 
   ;; ObjTmpStack:add: :genDone: false   "Value" : "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; items:markForCodeGen: "%ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; markItem: "%ID Value" Property 
   ;; markItem: "%globals" Property 
   ;; markItem: "%basic 21" Property 
   ;; markItem: "%public" Property 
   ;; OG:markIS: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var cha ...}" 
   ;; ComputeVariant:A: "char" 
   ;; value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var char;   -  : ;  ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: Value 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var cha ...}" q ... 0 
   ;; OG:Qalloc:A:  "char"  super:  "value"  marked:  true "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" s ... v ... 
   ;; Invocation:Qalloc: "value" 
   ;; ObjectInvocation:Qalloc: "value" 
   ;; name:   "value" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 0 %ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value);      }" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var char;   -  : ; ...}" 
   ;; super:  "value" 
   ;; E:  "value" 
   ;; OG:Qalloc:B: "char" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 6 IS.newDescNo: 6 objSize: 0 varNo: 1 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var c ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 6 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ...}" 
   ;; Items:Qalloc:super: "value" size: 0 "char" 
   ;; super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
   ;; Items:Qalloc:super:B:objSize: 0 originOff: 0 
   ;; dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 1 
   ;; Pattern:Qalloc: + 
   ;; Pattern:Qalloc: - 
   ;; Pattern:Qalloc: = 
   ;; Pattern:Qalloc: < 
   ;; Pattern:Qalloc: <= 
   ;; Pattern:Qalloc: > 
   ;; Pattern:Qalloc: >= 
   ;; Pattern:Qalloc: <> 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 6 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char; ...}" 
   ;; IS.newDescNo: 6 IS.objSize: 1 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %ba ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  6 
   ;; "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var char;   -  : ; ...}" 
   ;; computeVariant:newDescNo: 6  size:  1  IS: "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char ...}" 
   ;; ComputeVariant:B:  "char" 
   ;; ObjTmpStack:add: :genDone: false   "char" : "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in ...}" 
   ;; items:markForCodeGen: "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %basic 62;  ...}" 
   ;; markItem: "%id "char"" Property 
   ;; markItem: "%globals" Property 
   ;; markItem: "%basic 3, 16" Property 
   ;; markItem: "%public" Property 
   ;; DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "Universal" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Universal" 
   ;; "Universal" true 
   ;; 
   ;; OG:markSuper: "Universal" 
   ;; Invocation:markForCodeGen: "Universal" 
   ;; ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
   ;; Pattern:markForCodeGen: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;  ...}" 
   ;; OG:markForCodeGen: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;  ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Value" 
   ;; "Value" true 
   ;; 
   ;; OG:markSuper: "Value" 
   ;; Invocation:markForCodeGen: "Value" 
   ;; ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value ...}" 
   ;; OG:markIS: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in  ...}" 
   ;; ComputeVariant:A: "universal" 
   ;; Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in V: var integ ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: Value 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in  ...}" q ... 0 
   ;; OG:Qalloc:A:  "universal"  super:  "Value"  marked:  true "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;  ...}" s ... V ... 
   ;; Invocation:Qalloc: "Value" 
   ;; ObjectInvocation:Qalloc: "Value" 
   ;; name:   "Value" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 0 %ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value);      }" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in V: var inte ...}" 
   ;; super:  "Value" 
   ;; E:  "Value" 
   ;; OG:Qalloc:B: "universal" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 7 IS.newDescNo: 7 objSize: 0 varNo: 1 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;  ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 7 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var in ...}" 
   ;; Items:Qalloc:super: "Value" size: 0 "universal" 
   ;; super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
   ;; Items:Qalloc:super:B:objSize: 0 originOff: 0 
   ;; Pattern:Qalloc: + 
   ;; Pattern:Qalloc: - 
   ;; Items:Qalloc:END:objSize: 0  newDescNo: 7 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: va ...}" 
   ;; IS.newDescNo: 7 IS.objSize: 0 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  7 
   ;; "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in V: var inte ...}" 
   ;; computeVariant:newDescNo: 7  size:  0  IS: "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: v ...}" 
   ;; ComputeVariant:B:  "universal" 
   ;; ObjTmpStack:add: :genDone: false   "universal" : "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var inte ...}" 
   ;; items:markForCodeGen: "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   out R:  ...}" 
   ;; markItem: "%ID universal" Property 
   ;; markItem: "%basic 1, 32" Property 
   ;; markItem: "%globals" Property 
   ;; not ObjDesc:  "Universal"  IS.isEmpty:  true 
   ;; not ObjDesc:  "char"  IS.isEmpty:  true 
   ;; markItem: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" ObjectGenerator 
   ;; OG:markForCodeGen: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; "newline" true 
   ;; ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" true 
   ;; 
   ;; OG:markSuper: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; Invocation:markForCodeGen: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: var char" 
   ;; ObjectInvocation:markForCodeGen: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; Pattern:markForCodeGen: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:markForCodeGen: "%basic 8{in V: var Value;--inner(Value);}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%basic 8{in V: var Value;--inner(Value);}" 
   ;; ComputeVariant:A: ":=" 
   ;; %basic 8{in V: var Value;--inner(Value);} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%basic 8{in V: var Value;--inner(Value);}" qDescno:  4 
   ;; computeVariant:newDescNo: 4  size:  4  IS: "%basic 8{in V: var Value;--inner(Value);}" 
   ;; ComputeVariant:B:  ":=" 
   ;; ObjTmpStack:add: :genDone: false   ":=" : "%basic 8{in V: var Value;--inner(Value);}" 
   ;; items:markForCodeGen: "%basic 8{in V: var Value;--inner(Value);}" 
   ;; markItem: "%basic 8" Property 
   ;; DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 21 
   ;; OG:markForCodeGen: "Value{--inner(Value);}" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Value{--inner(Value);}" 
   ;; "Value{--inner(Value);}" true 
   ;; 
   ;; OG:markSuper: "Value{--inner(Value);}" 
   ;; Invocation:markForCodeGen: "Value{--inner(Value);}" 
   ;; ObjectInvocation:markForCodeGen: "Value{--inner(Value);}"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;   ...}" 
   ;; not ObjDesc:  "Value{--inner(Value);}"  IS.isEmpty:  true 
   ;; arg:   "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; OG:markForCodeGen: "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" true 
   ;; 
   ;; not ObjDesc:  "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  IS.isEmpty:  true 
   ;; OG:markForCodeGen: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Co ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Containers ...}" 
   ;; ComputeVariant:A: "LIB" 
   ;; %id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Containers;--Dimension ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Containers ...}" q ... 0 
   ;; OG:Qalloc:A:  "LIB"  super:  ""  marked:  true "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--Basic ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Containers;--Dimensio ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "LIB" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 8 IS.newDescNo: 8 objSize: 0 varNo: 1 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--Ba ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 8 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Comp ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "x_dummy_LIB" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; ModuleItem:Qalloc:  --AgentSystem{} 
   ;; ModuleItem:Qalloc:  --Associations{} 
   ;; ModuleItem:Qalloc:  --BasicIO{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: BasicIO 
   ;; Module:alloc:off: 3 BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;   ...} 
   ;; ModuleItem:Qalloc:  --BasicSystem{} 
   ;; ModuleItem:Qalloc:  --COsystem{} 
   ;; ModuleItem:Qalloc:  --Compiler{} 
   ;; ModuleItem:Qalloc:  --Complex{} 
   ;; ModuleItem:Qalloc:  --Containers{} 
   ;; ModuleItem:Qalloc:  --Dimensions{} 
   ;; ModuleItem:Qalloc:  --EMC2array{} 
   ;; ModuleItem:Qalloc:  --Embedded{} 
   ;; ModuleItem:Qalloc:  --FileSys{} 
   ;; ModuleItem:Qalloc:  --ForkJoinSystem{} 
   ;; ModuleItem:Qalloc:  --MetaSystem{} 
   ;; ModuleItem:Qalloc:  --MonitorSystem{} 
   ;; ModuleItem:Qalloc:  --NonBlockingIO{} 
   ;; ModuleItem:Qalloc:  --SimpleConcurrentProcesses{} 
   ;; ModuleItem:Qalloc:  --Socket{} 
   ;; ModuleItem:Qalloc:  --SocketSystem{} 
   ;; ModuleItem:Qalloc:  --StringLib{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: StringLib 
   ;; Module:alloc:off: 4 StringLib: obj {   %id "String module";   %module LIB;   %public;   String: ;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;  ...} 
   ;; ModuleItem:Qalloc:  --Units{} 
   ;; ModuleItem:Qalloc:  --Xarray{} 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 8 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;-- ...}" 
   ;; IS.newDescNo: 8 IS.objSize: 4 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  8 
   ;; "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Containers;--Dimensio ...}" 
   ;; computeVariant:newDescNo: 8  size:  4  IS: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;- ...}" 
   ;; ComputeVariant:B:  "LIB" 
   ;; ObjTmpStack:add: :genDone: false   "LIB" : "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;- ...}" 
   ;; items:markForCodeGen: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;- ...}" 
   ;; markItem: "%id "LIB"" Property 
   ;; markItem: "%module BETA" Property 
   ;; markItem: "%Include BETA" Property 
   ;; DataItem:markForCodeGen: "x_dummy_LIB" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; Pattern:markForCodeGen: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var in ...}" 
   ;; OG:markForCodeGen: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "value" 
   ;; "value" true 
   ;; 
   ;; OG:markSuper: "value" 
   ;; Invocation:markForCodeGen: "value" 
   ;; ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value ...}" 
   ;; OG:markIS: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" 
   ;; ComputeVariant:A: "integer" 
   ;; value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;    ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: Value 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" q ... 0 
   ;; OG:Qalloc:A:  "integer"  super:  "value"  marked:  true "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;   ...}" s ... v ... 
   ;; Invocation:Qalloc: "value" 
   ;; ObjectInvocation:Qalloc: "value" 
   ;; name:   "value" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 0 %ID Value{%globals;%basic 21;%public;:=  : ;   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value);      }" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   ...}" 
   ;; super:  "value" 
   ;; E:  "value" 
   ;; OG:Qalloc:B: "integer" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 9 IS.newDescNo: 9 objSize: 0 varNo: 1 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var  ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 9 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integ ...}" 
   ;; Items:Qalloc:super: "value" size: 0 "integer" 
   ;; super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
   ;; Items:Qalloc:super:B:objSize: 0 originOff: 0 
   ;; dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 1 
   ;; Pattern:Qalloc: + 
   ;; Pattern:Qalloc: - 
   ;; Pattern:Qalloc: * 
   ;; Pattern:Qalloc: / 
   ;; Pattern:Qalloc: // 
   ;; Pattern:Qalloc: /% 
   ;; Pattern:Qalloc: = 
   ;; Pattern:Qalloc: < 
   ;; Pattern:Qalloc: <= 
   ;; Pattern:Qalloc: > 
   ;; Pattern:Qalloc: >= 
   ;; Pattern:Qalloc: <> 
   ;; Pattern:Qalloc: cmpAndSwap 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 9 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var i ...}" 
   ;; IS.newDescNo: 9 IS.objSize: 1 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  :  ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  9 
   ;; "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   ...}" 
   ;; computeVariant:newDescNo: 9  size:  1  IS: "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var  ...}" 
   ;; ComputeVariant:B:  "integer" 
   ;; ObjTmpStack:add: :genDone: false   "integer" : "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;     ...}" 
   ;; items:markForCodeGen: "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %bas ...}" 
   ;; markItem: "%ID integer" Property 
   ;; markItem: "%basic 1, 32" Property 
   ;; markItem: "%globals" Property 
   ;; markItem: "%public" Property 
   ;; DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "Universal" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Universal" 
   ;; "Universal" true 
   ;; 
   ;; OG:markSuper: "Universal" 
   ;; Invocation:markForCodeGen: "Universal" 
   ;; ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
   ;; not ObjDesc:  "Universal"  IS.isEmpty:  true 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; OG:markForCodeGen: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      lo ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj  ...}" 
   ;; ComputeVariant:A: "BasicIO" 
   ;; %module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         di ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj  ...}" q ... 0 
   ;; OG:Qalloc:A:  "BasicIO"  super:  ""  marked:  true "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         d ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "BasicIO" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 10 IS.newDescNo: 10 objSize: 0 varNo: 1 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 10 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res:  ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: Lock 
   ;; Pattern:Qalloc:B: Lock 
   ;; dataitem:qalloc: "keyboard" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 2 "keyboard: obj {   %Public;   readLine: ;      out M: ref LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ; ...}" 
   ;; OG:Qalloc: "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGet;   ...}" q ... 0 
   ;; OG:Qalloc:A:  "$S$0"  super:  ""  marked:  false "keyboard: obj {   %Public;   readLine: ;      out M: ref LIB.StringLib.String;      inx: var integer;      msg: obj Index ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGet;      put(ch) ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 11 IS.newDescNo: 11 objSize: 0 varNo: 1 "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,intege ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 11 "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: v ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: readLine 
   ;; Pattern:Qalloc:B: readLine 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 11 "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      c ...}" 
   ;; IS.newDescNo: 11 IS.objSize: 1 "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char; ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  11 
   ;; "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGet;      put(ch) ...}" 
   ;; dataitem:qalloc: "screen" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 3 "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
   ;; OG:Qalloc: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" qDescno:  0 
   ;; OG:Qalloc:A:  "$S$0"  super:  ""  marked:  false "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inn ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 12 IS.newDescNo: 12 objSize: 0 varNo: 1 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 12 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "L" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 2 "L: obj Lock" 
   ;; OG:Qalloc: "Lock" qDescno:  0 
   ;; OG:Qalloc:A:  "Lock"  super:  "Lock"  marked:  false "L: obj Lock" super:  Lock 
   ;; Invocation:Qalloc: "Lock" 
   ;; ObjectInvocation:Qalloc: "Lock" 
   ;; name:   "Lock" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;  ...}" 
   ;; OG:Qalloc: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap(1);  ...}" q ... 0 
   ;; OG:Qalloc:A:  "Lock"  super:  ""  marked:  false "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      lo ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap(1);      @if re ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "Lock" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 13 IS.newDescNo: 13 objSize: 0 varNo: 1 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;     ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 13 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;   ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "dummy" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; dataitem:qalloc: "M" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 3 
   ;; Pattern:Qalloc: init 
   ;; Pattern:Qalloc:B: init 
   ;; Pattern:Qalloc: get 
   ;; Pattern:Qalloc:B: get 
   ;; Pattern:Qalloc: free 
   ;; Pattern:Qalloc:B: free 
   ;; Items:Qalloc:END:objSize: 3  newDescNo: 13 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 1 ...}" 
   ;; IS.newDescNo: 13 IS.objSize: 3 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res  ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  13 
   ;; "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap(1);      @if re ...}" 
   ;; OG:super:  "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res ...}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "Lock" 
   ;; super:  "Lock" 
   ;; E:  "Lock" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "Lock" 
   ;; Pattern:Qalloc: init 
   ;; Pattern:Qalloc:B: init 
   ;; Pattern:Qalloc: display 
   ;; Pattern:Qalloc:B: display 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 12 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; IS.newDescNo: 12 IS.objSize: 2 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; OG:Qalloc:end: IS.newDescNo:  12 
   ;; "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; Items:Qalloc:END:objSize: 3  newDescNo: 10 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      r ...}" 
   ;; IS.newDescNo: 10 IS.objSize: 3 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var inte ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  10 
   ;; "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         d ...}" 
   ;; computeVariant:newDescNo: 10  size:  3  IS: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;       ...}" 
   ;; ComputeVariant:B:  "BasicIO" 
   ;; ObjTmpStack:add: :genDone: false   "BasicIO" : "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;    ...}" 
   ;; items:markForCodeGen: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      ...}" 
   ;; markItem: "%module LIB.StringLib" Property 
   ;; markItem: "%Public" Property 
   ;; DataItem:markForCodeGen: "keyboard" :descNo: 11 :OG.primNo: 0 
   ;; OG:markForCodeGen: "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch :=  ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGet;   ...}" 
   ;; ComputeVariant:A: "$S$11" 
   ;; %Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGet;      put(ch); ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGet;   ...}" q ... 11 
   ;; computeVariant:newDescNo: 11  size:  1  IS: "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;       ...}" 
   ;; ComputeVariant:B:  "$S$11" 
   ;; ObjTmpStack:add: :genDone: false   "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var C ...}" 
   ;; items:markForCodeGen: "%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch  ...}" 
   ;; markItem: "%Public" Property 
   ;; DataItem:markForCodeGen: "screen" :descNo: 12 :OG.primNo: 0 
   ;; OG:markForCodeGen: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; ComputeVariant:A: "$S$12" 
   ;; L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" qDescno:  12 
   ;; computeVariant:newDescNo: 12  size:  2  IS: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; ComputeVariant:B:  "$S$12" 
   ;; ObjTmpStack:add: :genDone: false   "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; items:markForCodeGen: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
   ;; DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
   ;; OG:markForCodeGen: "Lock" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "Lock" 
   ;; "Lock" false 
   ;; 
   ;; OG:markSuper: "Lock" 
   ;; Invocation:markForCodeGen: "Lock" 
   ;; ObjectInvocation:markForCodeGen: "Lock"  ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: ...}" 
   ;; Pattern:markForCodeGen: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable ...}" 
   ;; OG:markForCodeGen: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndS ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap(1);  ...}" 
   ;; ComputeVariant:A: "Lock" 
   ;; dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap(1);      @if res ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap(1);  ...}" q ... 13 
   ;; computeVariant:newDescNo: 13  size:  3  IS: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res :=  ...}" 
   ;; ComputeVariant:B:  "Lock" 
   ;; ObjTmpStack:add: :genDone: false   "Lock" : "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res :=  ...}" 
   ;; items:markForCodeGen: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpA ...}" 
   ;; DataItem:markForCodeGen: "dummy" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; markItem: "%Public" Property 
   ;; DataItem:markForCodeGen: "M" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; not ObjDesc:  "Lock"  IS.isEmpty:  true 
   ;; markItem: "%Public" Property 
   ;; OG:markForCodeGen: "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;  ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out ...}" 
   ;; ComputeVariant:A: "StringLib" 
   ;; %id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var inte ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out ...}" q ... 0 
   ;; OG:Qalloc:A:  "StringLib"  super:  ""  marked:  true "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: ;      %id "String pattern";      %OSDvis ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var int ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "StringLib" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 14 IS.newDescNo: 14 objSize: 0 varNo: 1 "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 14 "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   % ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: String 
   ;; Pattern:Qalloc: C 
   ;; Pattern:Qalloc:B: C 
   ;; Pattern:Qalloc: I2S 
   ;; Pattern:Qalloc:B: I2S 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 14 "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable; ...}" 
   ;; IS.newDescNo: 14 IS.objSize: 1 "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;  ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  14 
   ;; "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var int ...}" 
   ;; computeVariant:newDescNo: 14  size:  1  IS: "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable ...}" 
   ;; ComputeVariant:B:  "StringLib" 
   ;; ObjTmpStack:add: :genDone: false   "StringLib" : "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immu ...}" 
   ;; items:markForCodeGen: "%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ...}" 
   ;; markItem: "%id "String module"" Property 
   ;; markItem: "%module LIB" Property 
   ;; markItem: "%public" Property 
   ;; Items:markString %id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;     ...} 
   ;; Pattern:markForCodeGen: "String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V :=  ...}" 
   ;; OG:markForCodeGen: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in get: ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in get: var int ...}" 
   ;; ComputeVariant:A: "String" 
   ;; %id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in get: var integer;   out  ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in get: var int ...}" q ... 0 
   ;; OG:Qalloc:A:  "String"  super:  ""  marked:  true "String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out  ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in get: var integer;   out ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "String" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 15 IS.newDescNo: 15 objSize: 0 varNo: 1 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var intege ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 15 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   % ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: length 
   ;; Pattern:Qalloc:B: length 
   ;; Pattern:Qalloc: @get: 
   ;; Pattern:Qalloc: + 
   ;; Pattern:Qalloc:B: + 
   ;; Pattern:Qalloc: asLowerCase 
   ;; Pattern:Qalloc:B: asLowerCase 
   ;; Pattern:Qalloc: scan 
   ;; Pattern:Qalloc:B: scan 
   ;; Pattern:Qalloc: print 
   ;; Pattern:Qalloc:B: print 
   ;; Pattern:Qalloc: = 
   ;; Pattern:Qalloc:B: = 
   ;; Pattern:Qalloc: <> 
   ;; Pattern:Qalloc:B: <> 
   ;; Pattern:Qalloc: <= 
   ;; Pattern:Qalloc:B: <= 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 15 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ; ...}" 
   ;; IS.newDescNo: 15 IS.objSize: 1 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 11 ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  15 
   ;; "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in get: var integer;   out ...}" 
   ;; computeVariant:newDescNo: 15  size:  1  IS: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get:  ...}" 
   ;; ComputeVariant:B:  "String" 
   ;;  String:  15 
   ;; ObjTmpStack:add: :genDone: false   "String" : "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get ...}" 
   ;; items:markForCodeGen: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @get 0;@get: ;   %basic 117;   in g ...}" 
   ;; markItem: "%id "String pattern"" Property 
   ;; markItem: "%OSDvisibility disguised" Property 
   ;; markItem: "%basic 5" Property 
   ;; markItem: "%immutable" Property 
   ;; markItem: "%public" Property 
   ;; OG:markForCodeGen: "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out  ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var ...}" 
   ;; ComputeVariant:A: "QBETA" 
   ;; %requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;    ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var ...}" q ... 0 
   ;; OG:Qalloc:A:  "QBETA"  super:  ""  marked:  true "QBETA: obj {   %requires BETA;   %visible BETA;   NewSyntaxIndexed: ;      %globals;      %basic 114;      %public;       ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;   ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "QBETA" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 16 IS.newDescNo: 16 objSize: 0 varNo: 1 "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var I ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 16 "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: NewSyntaxIndexed 
   ;; Pattern:Qalloc: if:then 
   ;; Pattern:Qalloc:B: if:then 
   ;; Pattern:Qalloc: if:then:else 
   ;; Pattern:Qalloc:B: if:then:else 
   ;; Pattern:Qalloc: restart 
   ;; Pattern:Qalloc: leave 
   ;; Pattern:Qalloc: for:to:repeat 
   ;; Pattern:Qalloc:B: for:to:repeat 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 16 "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Objec ...}" 
   ;; IS.newDescNo: 16 IS.objSize: 1 "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  16 
   ;; "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;   ...}" 
   ;; computeVariant:newDescNo: 16  size:  1  IS: "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Obje ...}" 
   ;; ComputeVariant:B:  "QBETA" 
   ;; ObjTmpStack:add: :genDone: false   "QBETA" : "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Obj ...}" 
   ;; items:markForCodeGen: "%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      o ...}" 
   ;; markItem: "%requires BETA" Property 
   ;; markItem: "%visible BETA" Property 
   ;; OG:markForCodeGen: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CASt ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CAStest;--CA ...}" 
   ;; ComputeVariant:A: "workspace" 
   ;; %id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CAStest;--CAStestCore;-- ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CAStest;--CA ...}" q ... 0 
   ;; OG:Qalloc:A:  "workspace"  super:  ""  marked:  true "workspace: obj {   %id "workspace";   %include BETA, LIB, LIB.BasicIO, qbeta;   %domain_boundary;   --AccessEx;--Appl ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CAStest;--CAStestCore;- ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "workspace" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 17 IS.newDescNo: 17 objSize: 0 varNo: 1 "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--Arduin ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 17 "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;- ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; ModuleItem:Qalloc:  --AccessEx{} 
   ;; ModuleItem:Qalloc:  --ApplyPred{} 
   ;; ModuleItem:Qalloc:  --ArduinoEx{} 
   ;; ModuleItem:Qalloc:  --ArmBasicSys{} 
   ;; ModuleItem:Qalloc:  --ArmLed{} 
   ;; ModuleItem:Qalloc:  --ArmMultiCore{} 
   ;; ModuleItem:Qalloc:  --CAStest{} 
   ;; ModuleItem:Qalloc:  --CAStestCore{} 
   ;; ModuleItem:Qalloc:  --CppEx{} 
   ;; ModuleItem:Qalloc:  --DumpObjEx{} 
   ;; ModuleItem:Qalloc:  --ESP32Ex{} 
   ;; ModuleItem:Qalloc:  --Errors{} 
   ;; ModuleItem:Qalloc:  --ForkGC{} 
   ;; ModuleItem:Qalloc:  --FuncVirtExVclass{} 
   ;; ModuleItem:Qalloc:  --FunctionalVirtEx{} 
   ;; ModuleItem:Qalloc:  --Generic{} 
   ;; ModuleItem:Qalloc:  --GenericArray{} 
   ;; ModuleItem:Qalloc:  --GenericList{} 
   ;; ModuleItem:Qalloc:  --IndexEx{} 
   ;; ModuleItem:Qalloc:  --Jurgen{} 
   ;; ModuleItem:Qalloc:  --LLVMex{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: LLVMex 
   ;; Module:alloc:off: 2 LLVMex: obj {   %id "LLVMex";   outint: ;      %globals;      S: obj Indexed ( 6 , integer );      in X: var integer;      V: var integer;      V := X  ...} 
   ;; ModuleItem:Qalloc:  --Line{} 
   ;; ModuleItem:Qalloc:  --ListLiteralEx{} 
   ;; ModuleItem:Qalloc:  --LockTest{} 
   ;; ModuleItem:Qalloc:  --LockTestCore{} 
   ;; ModuleItem:Qalloc:  --MVRsystem{} 
   ;; ModuleItem:Qalloc:  --MapEx{} 
   ;; ModuleItem:Qalloc:  --MiniVal{} 
   ;; ModuleItem:Qalloc:  --NewInner{} 
   ;; ModuleItem:Qalloc:  --NewKeyWord{} 
   ;; ModuleItem:Qalloc:  --NewStorage{} 
   ;; ModuleItem:Qalloc:  --NewSyntax{} 
   ;; ModuleItem:Qalloc:  --NoneEx{} 
   ;; ModuleItem:Qalloc:  --ObjectAndValues{} 
   ;; ModuleItem:Qalloc:  --PTX{} 
   ;; ModuleItem:Qalloc:  --PointReturn{} 
   ;; ModuleItem:Qalloc:  --PointSys{} 
   ;; ModuleItem:Qalloc:  --PtnName{} 
   ;; ModuleItem:Qalloc:  --Qtst{} 
   ;; ModuleItem:Qalloc:  --QuaValue{} 
   ;; ModuleItem:Qalloc:  --Qual{} 
   ;; ModuleItem:Qalloc:  --Recursive{} 
   ;; ModuleItem:Qalloc:  --RemoteSuperVC{} 
   ;; ModuleItem:Qalloc:  --Restrictions{} 
   ;; ModuleItem:Qalloc:  --Rtest{} 
   ;; ModuleItem:Qalloc:  --SlideEx{} 
   ;; ModuleItem:Qalloc:  --Small{} 
   ;; ModuleItem:Qalloc:  --SmallVirtEx{} 
   ;; ModuleItem:Qalloc:  --StringEx{} 
   ;; ModuleItem:Qalloc:  --Sub1{} 
   ;; ModuleItem:Qalloc:  --SubOfInt{} 
   ;; ModuleItem:Qalloc:  --TST{} 
   ;; ModuleItem:Qalloc:  --TstBreak{} 
   ;; ModuleItem:Qalloc:  --UnitLiterals{} 
   ;; ModuleItem:Qalloc:  --UnitTest{} 
   ;; ModuleItem:Qalloc:  --ValueArray{} 
   ;; ModuleItem:Qalloc:  --ValueConv{} 
   ;; ModuleItem:Qalloc:  --ValueEx{} 
   ;; ModuleItem:Qalloc:  --ValueItemEx{} 
   ;; ModuleItem:Qalloc:  --ValueTypes{} 
   ;; ModuleItem:Qalloc:  --VirtError{} 
   ;; ModuleItem:Qalloc:  --VirtualEx{} 
   ;; ModuleItem:Qalloc:  --Visibility{} 
   ;; ModuleItem:Qalloc:  --cbrtUnit{} 
   ;; ModuleItem:Qalloc:  --comment{} 
   ;; ModuleItem:Qalloc:  --demo{} 
   ;; ModuleItem:Qalloc:  --noglobtst{} 
   ;; ModuleItem:Qalloc:  --qbetaCmp{} 
   ;; ModuleItem:Qalloc:  --qenvTest{} 
   ;; ModuleItem:Qalloc:  --rangetst{} 
   ;; ModuleItem:Qalloc:  --test{} 
   ;; ModuleItem:Qalloc:  --testA{} 
   ;; ModuleItem:Qalloc:  --testB{} 
   ;; ModuleItem:Qalloc:  --testJ{} 
   ;; ModuleItem:Qalloc:  --testX{} 
   ;; ModuleItem:Qalloc:  --testY{} 
   ;; ModuleItem:Qalloc:  --testZ{} 
   ;; ModuleItem:Qalloc:  --tiny{} 
   ;; ModuleItem:Qalloc:  --tinyA{} 
   ;; ModuleItem:Qalloc:  --tinyB{} 
   ;; ModuleItem:Qalloc:  --tinyC{} 
   ;; ModuleItem:Qalloc:  --tinyD{} 
   ;; ModuleItem:Qalloc:  --tinyE{} 
   ;; ModuleItem:Qalloc:  --tinyF{} 
   ;; ModuleItem:Qalloc:  --tinyG{} 
   ;; ModuleItem:Qalloc:  --tinyH{} 
   ;; ModuleItem:Qalloc:  --tinyI{} 
   ;; ModuleItem:Qalloc:  --tinyP{} 
   ;; ModuleItem:Qalloc:  --tinyQ{} 
   ;; ModuleItem:Qalloc:  --tinyR{} 
   ;; ModuleItem:Qalloc:  --tinyS{} 
   ;; ModuleItem:Qalloc:  --tinyT{} 
   ;; ModuleItem:Qalloc:  --tinyW{} 
   ;; ModuleItem:Qalloc:  --tinyY{} 
   ;; ModuleItem:Qalloc:  --tinyZ{} 
   ;; ModuleItem:Qalloc:  --tinyx{} 
   ;; ModuleItem:Qalloc:  --xKinds{} 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 17 "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmL ...}" 
   ;; IS.newDescNo: 17 IS.objSize: 2 "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMult ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  17 
   ;; "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CAStest;--CAStestCore;- ...}" 
   ;; computeVariant:newDescNo: 17  size:  2  IS: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--Arm ...}" 
   ;; ComputeVariant:B:  "workspace" 
   ;; ObjTmpStack:add: :genDone: false   "workspace" : "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys; ...}" 
   ;; items:markForCodeGen: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--C ...}" 
   ;; markItem: "%id "workspace"" Property 
   ;; markItem: "%include BETA, LIB, LIB.BasicIO, qbeta" Property 
   ;; markItem: "%domain_boundary" Property 
   ;; OG:markForCodeGen: "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X  ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X // 10;   ...}" 
   ;; ComputeVariant:A: "LLVMex" 
   ;; %id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X // 10;   V := X /% 1 ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X // 10;   ...}" q ... 0 
   ;; OG:Qalloc:A:  "LLVMex"  super:  ""  marked:  true "LLVMex: obj {   %id "LLVMex";   outint: ;      %globals;      S: obj Indexed ( 6 , integer );      in X: var integer;    ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X // 10;   V := X /%  ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "LLVMex" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 18 IS.newDescNo: 18 objSize: 0 varNo: 1 "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var inte ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 18 "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@pu ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: outint 
   ;; Pattern:Qalloc:B: outint 
   ;; ModuleItem:Qalloc:  --RefRel{} 
   ;; ModuleItem:Qalloc:  --mini{} 
   ;; ModuleItem:Qalloc:  --mini1{} 
   ;; ModuleItem:Qalloc:  --mini2{} 
   ;; ModuleItem:Qalloc:  --mini3{} 
   ;; ModuleItem:Qalloc:  --mini4{} 
   ;; ModuleItem:Qalloc:B:
   ;; Qalloc:module: mini4 
   ;; Module:alloc:off: 2 mini4: obj {   put ( 'Q' );   @for 1 :to 1 :repeat ;      put ( 'Q' + inx )} 
   ;; ModuleItem:Qalloc:  --miniq{} 
   ;; ModuleItem:Qalloc:  --minix{} 
   ;; ModuleItem:Qalloc:  --miniy{} 
   ;; ModuleItem:Qalloc:  --miniz{} 
   ;; ModuleItem:Qalloc:  --mixed{} 
   ;; ModuleItem:Qalloc:  --valEx{} 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 18 "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S ...}" 
   ;; IS.newDescNo: 18 IS.objSize: 2 "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at  ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  18 
   ;; "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X // 10;   V := X /%  ...}" 
   ;; computeVariant:newDescNo: 18  size:  2  IS: "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;    ...}" 
   ;; ComputeVariant:B:  "LLVMex" 
   ;; ObjTmpStack:add: :genDone: false   "LLVMex" : "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;  ...}" 
   ;; items:markForCodeGen: "%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := ...}" 
   ;; markItem: "%id "LLVMex"" Property 
   ;; OG:markForCodeGen: "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; ComputeVariant:A: "mini4" 
   ;; put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" qDescno:  0 
   ;; OG:Qalloc:A:  "mini4"  super:  ""  marked:  true "mini4: obj {   put ( 'Q' );   @for 1 :to 1 :repeat ;      put ( 'Q' + inx )}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "mini4" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 19 IS.newDescNo: 19 objSize: 0 varNo: 1 "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 19 "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; OG:Qalloc: "put ( 'Q' )" qDescno:  0 
   ;; OG:Qalloc:A:  "put"  super:  "put ( 'Q' )"  marked:  false "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" super:  put ( 'Q' ) 
   ;; Invocation:Qalloc: "put ( 'Q' )" 
   ;; ObjectInvocation:Qalloc: "put ( 'Q' )" 
   ;; name:   "put" 
   ;; Arguments   "put ( 'Q' )" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%basic 2;in ch: val char} 
   ;; OG:Qalloc:SuperAlloc: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; OG:Qalloc: "%globals{%basic 2;in ch: val char}" qDescno:  0 
   ;; OG:Qalloc:A:  "put"  super:  "-- to be eliminated{}"  marked:  false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" super:  -- to be eliminated{} 
   ;; Invocation:Qalloc: "-- to be eliminated{}" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%globals{%basic 2;in ch: val char}" 
   ;; super:  "-- to be eliminated{}" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "put" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 20 IS.newDescNo: 20 objSize: 0 varNo: 1 "%globals{%basic 2;in ch: val char}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 20 "%globals{%basic 2;in ch: val char}" 
   ;; Items:Qalloc:Super:C:objSize: 0 originOff: 0 
   ;; dataitem:qalloc: "ch" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 1 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 20 "%globals{%basic 2;in ch: val char}" 
   ;; IS.newDescNo: 20 IS.objSize: 1 "%globals{%basic 2;in ch: val char}" 
   ;; OG:Qalloc:end: IS.newDescNo:  20 
   ;; "%globals{%basic 2;in ch: val char}" 
   ;; OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "put ( 'Q' )" 
   ;; super:  "put ( 'Q' )" 
   ;; E:  "put ( 'Q' )" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "put ( 'Q' )" 
   ;; OG:Qalloc: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" qDescno:  0 
   ;; OG:Qalloc:A:  "@for::to:repeat$S$0"  super:  "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  marked:  false "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" super: ... @ ... 
   ;; Invocation:Qalloc: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ObjectInvocation:Qalloc: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; name:   "@for::to:repeat" 
   ;; Arguments   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := f ...} 
   ;; OG:Qalloc:SuperAlloc: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for ...}" 
   ;; OG:Qalloc: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;       ...}" q ... 0 
   ;; OG:Qalloc:A:  "@for::to:repeat"  super:  ""  marked:  false "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   ...} 
   ;; OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;      repeat;     ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "@for::to:repeat" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 21 IS.newDescNo: 21 objSize: 0 varNo: 1 "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%priv ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 21 "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   ...}" 
   ;; Items:Qalloc:Super:C:objSize: 0 originOff: 0 
   ;; dataitem:qalloc: "for" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 1 
   ;; dataitem:qalloc: "to" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; Pattern:Qalloc: repeat 
   ;; Pattern:Qalloc:B: repeat 
   ;; (OG.super.desc).newDescNo = 0 
   ;; OG:Qalloc: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V:  ...}" q ... 0 
   ;; OG:Qalloc:A:  "Object"  super:  ""  marked:  false "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6; ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  false  IS.superDesc.newDescNo:  
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "Object" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 22 IS.newDescNo: 22 objSize: 0 varNo: 1 "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Obje ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 22 "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in ...}" 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; Pattern:Qalloc: := 
   ;; Pattern:Qalloc: :- 
   ;; Pattern:Qalloc: == 
   ;; Pattern:Qalloc: =/= 
   ;; Pattern:Qalloc: suspend 
   ;; Pattern:Qalloc: attach 
   ;; Pattern:Qalloc: call 
   ;; Pattern:Qalloc: onResume 
   ;; Pattern:Qalloc: onSuspend 
   ;; Pattern:Qalloc: dumpObj 
   ;; OG:Qalloc: "inner(Object)" qDescno:  0 
   ;; OG:Qalloc:A:  "inner"  super:  "inner(Object)"  marked:  false "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;= ...}" s ... i ... 
   ;; Invocation:Qalloc: "inner(Object)" 
   ;; ObjectInvocation:Qalloc: "inner(Object)" 
   ;; name:   "inner" 
   ;; Arguments   "(Object)" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 101{in inner: ref Object} 
   ;; OG:Qalloc:SuperAlloc: "inner: {   %basic 101;   in inner: ref Object}" 
   ;; OG:Qalloc: "%basic 101{in inner: ref Object}" qDescno:  0 
   ;; OG:Qalloc:A:  "inner"  super:  ""  marked:  false "inner: {   %basic 101;   in inner: ref Object}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%basic 101{in inner: ref Object}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "inner" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 23 IS.newDescNo: 23 objSize: 0 varNo: 1 "%basic 101{in inner: ref Object}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 23 "%basic 101{in inner: ref Object}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "inner" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 2 "in inner: ref Object" 
   ;; OG:Qalloc: "Object" qDescno:  0 
   ;; OG:Qalloc:A:  "Object"  super:  "Object"  marked:  false "in inner: ref Object" super:  Object 
   ;; Invocation:Qalloc: "Object" 
   ;; ObjectInvocation:Qalloc: "Object" 
   ;; name:   "Object" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:super:  "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      % ...}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "Object" 
   ;; super:  "Object" 
   ;; E:  "Object" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "Object" 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 23 "%basic 101{in inner: ref Object}" 
   ;; IS.newDescNo: 23 IS.objSize: 2 "%basic 101{in inner: ref Object}" 
   ;; OG:Qalloc:end: IS.newDescNo:  23 
   ;; "%basic 101{in inner: ref Object}" 
   ;; OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "inner(Object)" 
   ;; super:  "inner(Object)" 
   ;; E:  "inner(Object)" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "inner(Object)" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 22 "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;  ...}" 
   ;; IS.newDescNo: 22 IS.objSize: 1 "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: r ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  22 
   ;; "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean ...}" 
   ;; Pattern:qalloc:super:descNo: 22 in repeat:< Object 
   ;; Pattern:Qalloc: repeat$24 
   ;; Pattern:Qalloc:B: repeat$24 
   ;; dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 3 
   ;; OG:Qalloc: "inx := for" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "inx := for"  marked:  false "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := ...}" s ... i ... 
   ;; Invocation:Qalloc: "inx := for" 
   ;; ObjectInvocation:Qalloc: "inx" 
   ;; name:   "inx" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= for" 
   ;; name:   ":=" 
   ;; Arguments   "for" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "inx := for" 
   ;; super:  "inx := for" 
   ;; E:  ":= for" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "inx := for" 
   ;; OG:Qalloc: "inner(for)" qDescno:  0 
   ;; OG:Qalloc:A:  "inner"  super:  "inner(for)"  marked:  false "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx ...}" s ... i ... 
   ;; Invocation:Qalloc: "inner(for)" 
   ;; ObjectInvocation:Qalloc: "inner(for)" 
   ;; name:   "inner" 
   ;; Arguments   "(for)" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  23 2 %basic 101{in inner: ref Object} 
   ;; OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "inner(for)" 
   ;; super:  "inner(for)" 
   ;; E:  "inner(for)" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "inner(for)" 
   ;; Items:Qalloc:END:objSize: 3  newDescNo: 21 "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ...}" 
   ;; IS.newDescNo: 21 IS.objSize: 3 "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  21 
   ;; "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;      repeat;     ...}" 
   ;; OG:super:  "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop:  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  false 
   ;;  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
   ;; "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; super:  "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; E:  "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; OG:Qalloc:B: "@for::to:repeat$S$0" newDescNo: 0 objSize: 3 
   ;; OG:isObjectDesc:NewDescNo: 25 IS.newDescNo: 25 objSize: 3 varNo: 1 "" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 25 "" 
   ;; Items:Qalloc:super: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" size: 3 "@for::to:repeat$S$25" 
   ;; super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:super:B:objSize: 4 originOff: 4 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 25 "" 
   ;; IS.newDescNo: 25 IS.objSize: 3 "" 
   ;; OG:Qalloc:end: IS.newDescNo:  25 
   ;; "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 19 "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; IS.newDescNo: 19 IS.objSize: 1 "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; OG:Qalloc:end: IS.newDescNo:  19 
   ;; "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; computeVariant:newDescNo: 19  size:  1  IS: "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; ComputeVariant:B:  "mini4" 
   ;; ObjTmpStack:add: :genDone: false   "mini4" : "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; items:markForCodeGen: "put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )}" 
   ;; markItem: "put ( 'Q' )" ObjectGenerator 
   ;; OG:markForCodeGen: "put ( 'Q' )" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "put ( 'Q' )" 
   ;; "put ( 'Q' )" true 
   ;; 
   ;; OG:markSuper: "put ( 'Q' )" 
   ;; Invocation:markForCodeGen: "put ( 'Q' )" 
   ;; ObjectInvocation:markForCodeGen: "put ( 'Q' )"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; Pattern:markForCodeGen: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; OG:markForCodeGen: "%globals{%basic 2;in ch: val char}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "-- to be eliminated{}" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%globals{%basic 2;in ch: val char}" 
   ;; ComputeVariant:A: "put" 
   ;; %globals{%basic 2;in ch: val char} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%globals{%basic 2;in ch: val char}" qDescno:  20 
   ;; computeVariant:newDescNo: 20  size:  1  IS: "%globals{%basic 2;in ch: val char}" 
   ;; ComputeVariant:B:  "put" 
   ;; ObjTmpStack:add: :genDone: false   "put" : "%globals{%basic 2;in ch: val char}" 
   ;; items:markForCodeGen: "%globals{%basic 2;in ch: val char}" 
   ;; markItem: "%globals" Property 
   ;; markItem: "%basic 2" Property 
   ;; DataItem:markForCodeGen: "ch" :descNo: 0 :OG.primNo: 3 
   ;; OG:markForCodeGen: "char" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "char" 
   ;; "char" true 
   ;; 
   ;; OG:markSuper: "char" 
   ;; Invocation:markForCodeGen: "char" 
   ;; ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
   ;; not ObjDesc:  "char"  IS.isEmpty:  true 
   ;; arg:   "'Q'" 
   ;; OG:markForCodeGen: "'Q'" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "'Q'" 
   ;; "'Q'" true 
   ;; 
   ;; OG:markSuper: "'Q'" 
   ;; Invocation:markForCodeGen: "'Q'" 
   ;; not ObjDesc:  "'Q'"  IS.isEmpty:  true 
   ;; not ObjDesc:  "put ( 'Q' )"  IS.isEmpty:  true 
   ;; markItem: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" ObjectGenerator 
   ;; OG:markForCodeGen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: false 
   ;;  super.hasVirtualArgs: true 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" false 
   ;; 
   ;; OG:markSuper: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; Invocation:markForCodeGen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ObjectInvocation:markForCodeGen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:<  ...}" 
   ;; Pattern:markForCodeGen: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := f ...}" 
   ;; OG:markForCodeGen: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;       ...}" 
   ;; ComputeVariant:A: "@for::to:repeat" 
   ;; %globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;      repeat;      ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;       ...}" q ... 21 
   ;; computeVariant:newDescNo: 21  size:  3  IS: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: d ...}" 
   ;; ComputeVariant:B:  "@for::to:repeat" 
   ;; ObjTmpStack:add: :genDone: false   "@for" : "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: d ...}" 
   ;; items:markForCodeGen: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :t ...}" 
   ;; markItem: "%globals inSub" Property 
   ;; DataItem:markForCodeGen: "for" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "to" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; Pattern:markForCodeGen: "in repeat:< Object" 
   ;; OG:markForCodeGen: "Object" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Object" 
   ;; "Object" true 
   ;; 
   ;; not ObjDesc:  "Object"  IS.isEmpty:  true 
   ;; markItem: "%public" Property 
   ;; DataItem:markForCodeGen: "inx" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; markItem: "%private" Property 
   ;; markItem: "inx := for" ObjectGenerator 
   ;; OG:markForCodeGen: "inx := for" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "inx := for" 
   ;; "inx" true 
   ;; ":= for" true 
   ;; 
   ;; OG:markSuper: "inx := for" 
   ;; Invocation:markForCodeGen: "inx := for" 
   ;; ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= for"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "for" 
   ;; OG:markForCodeGen: "for" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "for" 
   ;; "for" true 
   ;; 
   ;; not ObjDesc:  "inx := for"  IS.isEmpty:  true 
   ;; OG:markForCodeGen: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; ComputeVariant:A: "$S$0" 
   ;; @if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" qDescno:  0 
   ;; OG:Qalloc:A:  "$S$0"  super:  ""  marked:  true "_loop: do {   @if inx <= to :then ;      repeat;      inx := inx + 1;      @restart _loop}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 26 IS.newDescNo: 26 objSize: 0 varNo: 1 "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 26 "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; OG:Qalloc: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" qDescno:  0 
   ;; OG:Qalloc:A:  "@ifX::thenX$S$0"  super:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}"  marked:  false "@if inx <= to :then {   repeat;   inx := in ...}" s ... @ ... 
   ;; Invocation:Qalloc: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; OG:Qalloc: "inx <= to" qDescno:  0 
   ;; OG:Qalloc:A:  "<="  super:  "inx <= to"  marked:  false "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" super:  inx <= to 
   ;; Invocation:Qalloc: "inx <= to" 
   ;; ObjectInvocation:Qalloc: "inx" 
   ;; name:   "inx" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: "<= to" 
   ;; name:   "<=" 
   ;; Arguments   "to" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 52{in V: var integer;out B: var boolean} 
   ;; OG:Qalloc:SuperAlloc: "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" 
   ;; OG:Qalloc: "%basic 52{in V: var integer;out B: var boolean}" qDescno:  0 
   ;; OG:Qalloc:A:  "<="  super:  ""  marked:  false "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%basic 52{in V: var integer;out B: var boolean}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "<=" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 27 IS.newDescNo: 27 objSize: 0 varNo: 1 "%basic 52{in V: var integer;out B: var boolean}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 27 "%basic 52{in V: var integer;out B: var boolean}" 
   ;; OriginIsValue: true 
   ;; Items:Qalloc:Super:C:objSize: 3 originOff: 1 
   ;; dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 4 
   ;; dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 5 
   ;; Items:Qalloc:END:objSize: 5  newDescNo: 27 "%basic 52{in V: var integer;out B: var boolean}" 
   ;; IS.newDescNo: 27 IS.objSize: 5 "%basic 52{in V: var integer;out B: var boolean}" 
   ;; OG:Qalloc:end: IS.newDescNo:  27 
   ;; "%basic 52{in V: var integer;out B: var boolean}" 
   ;; OG:super:  "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "inx <= to" 
   ;; super:  "inx <= to" 
   ;; E:  "<= to" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "inx <= to" 
   ;; OG:Qalloc: "repeat{inx := inx + 1;@restart _loop}" qDescno:  0 
   ;; OG:Qalloc:A:  "$S$0"  super:  ""  marked:  false "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "repeat{inx := inx + 1;@restart _loop}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 28 IS.newDescNo: 28 objSize: 0 varNo: 1 "repeat{inx := inx + 1;@restart _loop}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 28 "repeat{inx := inx + 1;@restart _loop}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; OG:Qalloc: "repeat" qDescno:  0 
   ;; OG:Qalloc:A:  "Object"  super:  "repeat"  marked:  false "repeat{inx := inx + 1;@restart _loop}" super:  repeat 
   ;; Invocation:Qalloc: "repeat" 
   ;; ObjectInvocation:Qalloc: "repeat" 
   ;; name:   "repeat" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:super:  "in repeat:< Object" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "repeat" 
   ;; super:  "repeat" 
   ;; E:  "repeat" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "repeat" 
   ;; OG:Qalloc: "inx := inx + 1" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "inx := inx + 1"  marked:  false "repeat{inx := inx + 1;@restart _loop}" super:  inx := inx + 1 
   ;; Invocation:Qalloc: "inx := inx + 1" 
   ;; ObjectInvocation:Qalloc: "inx" 
   ;; name:   "inx" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= inx + 1" 
   ;; name:   ":=" 
   ;; Arguments   "inx + 1" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "inx := inx + 1" 
   ;; super:  "inx := inx + 1" 
   ;; E:  ":= inx + 1" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "inx := inx + 1" 
   ;; OG:Qalloc: "@restart _loop" qDescno:  0 
   ;; OG:Qalloc:A:  "@restart:"  super:  "@restart _loop"  marked:  false "repeat{inx := inx + 1;@restart _loop}" super:  @restart _loop 
   ;; Invocation:Qalloc: "@restart _loop" 
   ;; ObjectInvocation:Qalloc: "@restart _loop" 
   ;; name:   "@restart" 
   ;; Arguments   "@restart _loop" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 102{in restart: var integer} 
   ;; OG:Qalloc:SuperAlloc: "@restart: {   %basic 102;   in restart: var integer}" 
   ;; OG:Qalloc: "%basic 102{in restart: var integer}" qDescno:  0 
   ;; OG:Qalloc:A:  "@restart:"  super:  ""  marked:  false "@restart: {   %basic 102;   in restart: var integer}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%basic 102{in restart: var integer}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "@restart:" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 29 IS.newDescNo: 29 objSize: 0 varNo: 1 "%basic 102{in restart: var integer}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 29 "%basic 102{in restart: var integer}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "restart" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 29 "%basic 102{in restart: var integer}" 
   ;; IS.newDescNo: 29 IS.objSize: 2 "%basic 102{in restart: var integer}" 
   ;; OG:Qalloc:end: IS.newDescNo:  29 
   ;; "%basic 102{in restart: var integer}" 
   ;; OG:super:  "@restart: {   %basic 102;   in restart: var integer}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "@restart _loop" 
   ;; super:  "@restart _loop" 
   ;; E:  "@restart _loop" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "@restart _loop" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 28 "repeat{inx := inx + 1;@restart _loop}" 
   ;; IS.newDescNo: 28 IS.objSize: 1 "repeat{inx := inx + 1;@restart _loop}" 
   ;; OG:Qalloc:end: IS.newDescNo:  28 
   ;; "repeat{inx := inx + 1;@restart _loop}" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object} 
   ;; OG:Qalloc:SuperAlloc: "@ifX: {   %globals inSub;   %basic 100;   in ifX: var boolean;   in thenX:< Object}" 
   ;; OG:Qalloc: "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" qDescno:  0 
   ;; OG:Qalloc:A:  "@ifX::thenX"  super:  ""  marked:  false "@ifX: {   %globals inSub;   %basic 100;   in ifX: var boolean;   in thenX:< Object}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "@ifX::thenX" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 30 IS.newDescNo: 30 objSize: 0 varNo: 1 "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 30 "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; Items:Qalloc:Super:C:objSize: 0 originOff: 0 
   ;; dataitem:qalloc: "ifX" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 1 
   ;; Pattern:Qalloc: thenX 
   ;; Pattern:Qalloc:B: thenX 
   ;; Pattern:Qalloc: thenX$31 
   ;; Pattern:Qalloc:B: thenX$31 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 30 "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; IS.newDescNo: 30 IS.objSize: 1 "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; OG:Qalloc:end: IS.newDescNo:  30 
   ;; "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; OG:super:  "@ifX: {   %globals inSub;   %basic 100;   in ifX: var boolean;   in thenX:< Object}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  true  hasItems:  false 
   ;;  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
   ;; "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; super:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; E:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 26 "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; IS.newDescNo: 26 IS.objSize: 1 "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; OG:Qalloc:end: IS.newDescNo:  26 
   ;; "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; computeVariant:newDescNo: 26  size:  1  IS: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; ComputeVariant:B:  "$S$26" 
   ;; ObjTmpStack:add: :genDone: false   "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; items:markForCodeGen: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; markItem: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" ObjectGenerator 
   ;; OG:markForCodeGen: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; isObjectDesc: false  isObjectDescX: true  hasItems: false 
   ;;  super.hasVirtualArgs: true 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" true 
   ;; 
   ;; OG:markSuper: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; Invocation:markForCodeGen: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; OG:markForCodeGen: "inx <= to" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "inx <= to" 
   ;; "inx" true 
   ;; "<= to" true 
   ;; 
   ;; OG:markSuper: "inx <= to" 
   ;; Invocation:markForCodeGen: "inx <= to" 
   ;; ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
   ;; ObjectInvocation:markForCodeGen: "<= to"  ATd: "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" 
   ;; Pattern:markForCodeGen: "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" 
   ;; arg:   "to" 
   ;; OG:markForCodeGen: "to" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "to" 
   ;; "to" true 
   ;; 
   ;; not ObjDesc:  "inx <= to"  IS.isEmpty:  true 
   ;; OG:markForCodeGen: "repeat{inx := inx + 1;@restart _loop}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "repeat{inx := inx + 1;@restart _loop}" 
   ;; ComputeVariant:A: "$S$28" 
   ;; repeat{inx := inx + 1;@restart _loop} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "repeat{inx := inx + 1;@restart _loop}" qDescno:  28 
   ;; computeVariant:newDescNo: 28  size:  1  IS: "repeat{inx := inx + 1;@restart _loop}" 
   ;; ComputeVariant:B:  "$S$28" 
   ;; ObjTmpStack:add: :genDone: false   "repeat{inx := inx + 1;@restart _loop}" 
   ;; items:markForCodeGen: "repeat{inx := inx + 1;@restart _loop}" 
   ;; markItem: "repeat" ObjectGenerator 
   ;; OG:markForCodeGen: "repeat" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "repeat" 
   ;; "repeat" false 
   ;; 
   ;; OG:markSuper: "repeat" 
   ;; Invocation:markForCodeGen: "repeat" 
   ;; ObjectInvocation:markForCodeGen: "repeat"  ATd: "in repeat:< Object" 
   ;; not ObjDesc:  "repeat"  IS.isEmpty:  true 
   ;; markItem: "inx := inx + 1" ObjectGenerator 
   ;; OG:markForCodeGen: "inx := inx + 1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "inx := inx + 1" 
   ;; "inx" true 
   ;; ":= inx + 1" true 
   ;; 
   ;; OG:markSuper: "inx := inx + 1" 
   ;; Invocation:markForCodeGen: "inx := inx + 1" 
   ;; ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= inx + 1"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "inx + 1" 
   ;; OG:markForCodeGen: "inx + 1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "inx + 1" 
   ;; "inx" true 
   ;; "+ 1" true 
   ;; 
   ;; OG:markSuper: "inx + 1" 
   ;; Invocation:markForCodeGen: "inx + 1" 
   ;; ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
   ;; ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; Pattern:markForCodeGen: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; arg:   "1" 
   ;; OG:markForCodeGen: "1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "1" 
   ;; "1" true 
   ;; 
   ;; OG:markSuper: "1" 
   ;; Invocation:markForCodeGen: "1" 
   ;; not ObjDesc:  "1"  IS.isEmpty:  true 
   ;; not ObjDesc:  "inx + 1"  IS.isEmpty:  true 
   ;; not ObjDesc:  "inx := inx + 1"  IS.isEmpty:  true 
   ;; markItem: "@restart _loop" ObjectGenerator 
   ;; not ObjDesc:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}"  IS.isEmpty:  true 
   ;; markItem: "inner(for)" ObjectGenerator 
   ;; arg:   "1" 
   ;; OG:markForCodeGen: "1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "1" 
   ;; "1" true 
   ;; 
   ;; OG:markSuper: "1" 
   ;; Invocation:markForCodeGen: "1" 
   ;; not ObjDesc:  "1"  IS.isEmpty:  true 
   ;; arg:   "1" 
   ;; OG:markForCodeGen: "1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "1" 
   ;; "1" true 
   ;; 
   ;; OG:markSuper: "1" 
   ;; Invocation:markForCodeGen: "1" 
   ;; not ObjDesc:  "1"  IS.isEmpty:  true 
   ;; arg:   "put ( 'Q' + inx )" 
   ;; OG:markForCodeGen: "put ( 'Q' + inx )" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "put ( 'Q' + inx )" 
   ;; ComputeVariant:A: "repeat$S$0" 
   ;; put ( 'Q' + inx ) 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: repeat 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; OG:Qalloc: "Object" qDescno:  0 
   ;; OG:Qalloc:A:  "Object"  super:  "Object"  marked:  true "in repeat:< Object" super:  Object 
   ;; Invocation:Qalloc: "Object" 
   ;; ObjectInvocation:Qalloc: "Object" 
   ;; name:   "Object" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:super:  "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      % ...}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "Object" 
   ;; super:  "Object" 
   ;; E:  "Object" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "Object" 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "put ( 'Q' + inx )" qDescno:  0 
   ;; OG:Qalloc:A:  "repeat$S$0"  super:  ""  marked:  true "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "put ( 'Q' + inx )" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "repeat$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 32 IS.newDescNo: 32 objSize: 0 varNo: 1 "put ( 'Q' + inx )" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 32 "put ( 'Q' + inx )" 
   ;; Items:Qalloc:super: "" size: 1 "repeat$S$32" 
   ;; super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
   ;; Items:Qalloc:super:B:objSize: 1 originOff: 1 
   ;; OG:Qalloc: "put ( 'Q' + inx )" qDescno:  0 
   ;; OG:Qalloc:A:  "put"  super:  "put ( 'Q' + inx )"  marked:  false "put ( 'Q' + inx )" super:  put ( 'Q' + inx ) 
   ;; Invocation:Qalloc: "put ( 'Q' + inx )" 
   ;; ObjectInvocation:Qalloc: "put ( 'Q' + inx )" 
   ;; name:   "put" 
   ;; Arguments   "put ( 'Q' + inx )" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %globals{%basic 2;in ch: val char} 
   ;; OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "put ( 'Q' + inx )" 
   ;; super:  "put ( 'Q' + inx )" 
   ;; E:  "put ( 'Q' + inx )" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "put ( 'Q' + inx )" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 32 "put ( 'Q' + inx )" 
   ;; IS.newDescNo: 32 IS.objSize: 1 "put ( 'Q' + inx )" 
   ;; OG:Qalloc:end: IS.newDescNo:  32 
   ;; "put ( 'Q' + inx )" 
   ;; computeVariant:newDescNo: 32  size:  1  IS: "put ( 'Q' + inx )" 
   ;; ComputeVariant:B:  "repeat$S$32" 
   ;; ObjTmpStack:add: :genDone: false   "put ( 'Q' + inx )" 
   ;; items:markForCodeGen: "put ( 'Q' + inx )" 
   ;; markItem: "put ( 'Q' + inx )" ObjectGenerator 
   ;; OG:markForCodeGen: "put ( 'Q' + inx )" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "put ( 'Q' + inx )" 
   ;; "put ( 'Q' + inx )" true 
   ;; 
   ;; OG:markSuper: "put ( 'Q' + inx )" 
   ;; Invocation:markForCodeGen: "put ( 'Q' + inx )" 
   ;; ObjectInvocation:markForCodeGen: "put ( 'Q' + inx )"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; arg:   "'Q' + inx" 
   ;; OG:markForCodeGen: "'Q' + inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "'Q' + inx" 
   ;; "'Q'" true 
   ;; "+ inx" true 
   ;; 
   ;; OG:markSuper: "'Q' + inx" 
   ;; Invocation:markForCodeGen: "'Q' + inx" 
   ;; ObjectInvocation:markForCodeGen: "+ inx"  ATd: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
   ;; Pattern:markForCodeGen: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
   ;; arg:   "inx" 
   ;; OG:markForCodeGen: "inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "inx" 
   ;; "inx" true 
   ;; 
   ;; not ObjDesc:  "'Q' + inx"  IS.isEmpty:  true 
   ;; not ObjDesc:  "put ( 'Q' + inx )"  IS.isEmpty:  true 
   ;; OG:markIS: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ComputeVariant:A: "@for::to:repeat$S$25" 
   ;; @for 1 :to 1 :repeat {   put ( 'Q' + inx )} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: @for::to:repeat 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" qDescno:  25 
   ;; computeVariant:newDescNo: 25  size:  3  IS: "" 
   ;; ComputeVariant:B:  "@for::to:repeat$S$25" 
   ;; ObjTmpStack:add: :genDone: false   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; items:markForCodeGen: "" 
   ;; Pattern:markForCodeGen: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   = ...}" 
   ;; OG:markForCodeGen: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V:  ...}" 
   ;; ComputeVariant:A: "Object" 
   ;; %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean; ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V:  ...}" q ... 22 
   ;; computeVariant:newDescNo: 22  size:  1  IS: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56; ...}" 
   ;; ComputeVariant:B:  "Object" 
   ;; ObjTmpStack:add: :genDone: false   "Object" : "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 5 ...}" 
   ;; items:markForCodeGen: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object ...}" 
   ;; markItem: "%ID Object" Property 
   ;; markItem: "%basic 64" Property 
   ;; markItem: "%public" Property 
   ;; markItem: "inner(Object)" ObjectGenerator 
   ;; Pattern:markForCodeGen: "+  : {   in S: ref String;   out V: ref String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T:  ...}" 
   ;; OG:markForCodeGen: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);  ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 ...}" 
   ;; ComputeVariant:A: "+" 
   ;; in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 :to L :repe ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 ...}" q ... 0 
   ;; OG:Qalloc:A:  "+"  super:  ""  marked:  true "+  : {   in S: ref String;   out V: ref String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i:  ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 :to L :rep ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 33 IS.newDescNo: 33 objSize: 0 varNo: 1 "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var i ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 33 "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "S" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 2 "in S: ref String" 
   ;; OG:Qalloc: "String" qDescno:  0 
   ;; OG:Qalloc:A:  "String"  super:  "String"  marked:  false "in S: ref String" super:  String 
   ;; Invocation:Qalloc: "String" 
   ;; ObjectInvocation:Qalloc: "String" 
   ;; name:   "String" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 1 %id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @ ...} 
   ;; OG:super:  "String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @ge ...}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "String" 
   ;; super:  "String" 
   ;; E:  "String" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "String" 
   ;; dataitem:qalloc: "V" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 3 "out V: ref String" 
   ;; OG:Qalloc: "String" qDescno:  0 
   ;; OG:Qalloc:A:  "String"  super:  "String"  marked:  false "out V: ref String" super:  String 
   ;; Invocation:Qalloc: "String" 
   ;; ObjectInvocation:Qalloc: "String" 
   ;; name:   "String" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 1 %id "String pattern"{%OSDvisibility disguised;%basic 5;%immutable;%public;length: ;   out V: var integer;   V := @ ...} 
   ;; OG:super:  "String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @ge ...}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "String" 
   ;; super:  "String" 
   ;; E:  "String" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "String" 
   ;; dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 4 
   ;; OG:Qalloc: "L := Length" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "L := Length"  marked:  false "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   ...}" s ... L ... 
   ;; Invocation:Qalloc: "L := Length" 
   ;; ObjectInvocation:Qalloc: "L" 
   ;; name:   "L" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= Length" 
   ;; name:   ":=" 
   ;; Arguments   "Length" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "L := Length" 
   ;; super:  "L := Length" 
   ;; E:  ":= Length" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "L := Length" 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 33 "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed ...}" 
   ;; IS.newDescNo: 33 IS.objSize: 4 "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.lengt ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  33 
   ;; "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 :to L :rep ...}" 
   ;; computeVariant:newDescNo: 33  size:  4  IS: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexe ...}" 
   ;; ComputeVariant:B:  "+" 
   ;; ObjTmpStack:add: :genDone: false   "+" : "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L ...}" 
   ;; items:markForCodeGen: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer ...}" 
   ;; DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
   ;; OG:markForCodeGen: "String" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "String" 
   ;; "String" true 
   ;; 
   ;; OG:markSuper: "String" 
   ;; Invocation:markForCodeGen: "String" 
   ;; ObjectInvocation:markForCodeGen: "String"  ATd: "String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: ...}" 
   ;; not ObjDesc:  "String"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 5 
   ;; OG:markForCodeGen: "String" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "String" 
   ;; "String" true 
   ;; 
   ;; OG:markSuper: "String" 
   ;; Invocation:markForCodeGen: "String" 
   ;; ObjectInvocation:markForCodeGen: "String"  ATd: "String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: ...}" 
   ;; not ObjDesc:  "String"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; markItem: "L := Length" ObjectGenerator 
   ;; OG:markForCodeGen: "L := Length" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "L := Length" 
   ;; "L" true 
   ;; ":= Length" true 
   ;; 
   ;; OG:markSuper: "L := Length" 
   ;; Invocation:markForCodeGen: "L := Length" 
   ;; ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= Length"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "Length" 
   ;; OG:markForCodeGen: "Length" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "Length" 
   ;; "Length" false 
   ;; 
   ;; OG:markSuper: "Length" 
   ;; Invocation:markForCodeGen: "Length" 
   ;; ObjectInvocation:markForCodeGen: "Length"  ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; Pattern:markForCodeGen: "length: {   out V: var integer;   V := @get 0}" 
   ;; OG:markForCodeGen: "out V: var integer{V := @get 0}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "out V: var integer{V := @get 0}" 
   ;; ComputeVariant:A: "length" 
   ;; out V: var integer{V := @get 0} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "out V: var integer{V := @get 0}" qDescno:  0 
   ;; OG:Qalloc:A:  "length"  super:  ""  marked:  true "length: {   out V: var integer;   V := @get 0}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "out V: var integer{V := @get 0}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "length" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 34 IS.newDescNo: 34 objSize: 0 varNo: 1 "out V: var integer{V := @get 0}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 34 "out V: var integer{V := @get 0}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; OG:Qalloc: "V := @get 0" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "V := @get 0"  marked:  false "out V: var integer{V := @get 0}" super:  V := @get 0 
   ;; Invocation:Qalloc: "V := @get 0" 
   ;; ObjectInvocation:Qalloc: "V" 
   ;; name:   "V" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= @get 0" 
   ;; name:   ":=" 
   ;; Arguments   "@get 0" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "V := @get 0" 
   ;; super:  "V := @get 0" 
   ;; E:  ":= @get 0" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "V := @get 0" 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 34 "out V: var integer{V := @get 0}" 
   ;; IS.newDescNo: 34 IS.objSize: 2 "out V: var integer{V := @get 0}" 
   ;; OG:Qalloc:end: IS.newDescNo:  34 
   ;; "out V: var integer{V := @get 0}" 
   ;; computeVariant:newDescNo: 34  size:  2  IS: "out V: var integer{V := @get 0}" 
   ;; ComputeVariant:B:  "length" 
   ;; ObjTmpStack:add: :genDone: false   "length" : "out V: var integer{V := @get 0}" 
   ;; items:markForCodeGen: "out V: var integer{V := @get 0}" 
   ;; DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; markItem: "V := @get 0" ObjectGenerator 
   ;; OG:markForCodeGen: "V := @get 0" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "V := @get 0" 
   ;; "V" true 
   ;; ":= @get 0" true 
   ;; 
   ;; OG:markSuper: "V := @get 0" 
   ;; Invocation:markForCodeGen: "V := @get 0" 
   ;; ObjectInvocation:markForCodeGen: "V"  ATd: "out V: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= @get 0"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "@get 0" 
   ;; not ObjDesc:  "V := @get 0"  IS.isEmpty:  true 
   ;; not ObjDesc:  "Length"  IS.isEmpty:  true 
   ;; not ObjDesc:  "L := Length"  IS.isEmpty:  true 
   ;; OG:markForCodeGen: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repe ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   e ...}" 
   ;; ComputeVariant:A: "$S$0" 
   ;; e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   e := S.@get i ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   e ...}" q ... 0 
   ;; OG:Qalloc:A:  "$S$0"  super:  ""  marked:  true "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 :to L :repeat ;      e : ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   e := S.@get  ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 35 IS.newDescNo: 35 objSize: 0 varNo: 1 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get i ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 35 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for  ...}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "e" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 2 
   ;; dataitem:qalloc: "i" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 3 
   ;; dataitem:qalloc: "T" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 4 "T: obj Indexed(L + S.length,Integer)" 
   ;; OG:Qalloc: "Indexed(L + S.length,Integer)" qDescno:  0 
   ;; OG:Qalloc:A:  "Indexed$S$0"  super:  "Indexed(L + S.length,Integer)"  marked:  false "T: obj Indexed(L + S.length,Integer)" super:  Indexed(L + S.length,Integer) 
   ;; Invocation:Qalloc: "Indexed(L + S.length,Integer)" 
   ;; ObjectInvocation:Qalloc: "Indexed(L + S.length,Integer)" 
   ;; name:   "Indexed" 
   ;; Arguments   "(L + S.length,Integer)" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0 ...} 
   ;; OG:Qalloc:SuperAlloc: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get  ...}" 
   ;; OG:Qalloc: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;    ...}" q ... 0 
   ;; OG:Qalloc:A:  "Indexed"  super:  ""  marked:  false "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res:  ...}" s ...  
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;   in at: var  ...}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "Indexed" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 36 IS.newDescNo: 36 objSize: 0 varNo: 1 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   r ...}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 36 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basi ...}" 
   ;; Items:Qalloc:Super:C:objSize: 0 originOff: 0 
   ;; dataitem:qalloc: "range" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 1 
   ;; Pattern:Qalloc: elm 
   ;; Pattern:Qalloc:B: elm 
   ;; Pattern:Qalloc: elm$37 
   ;; Pattern:Qalloc:B: elm$37 
   ;; Pattern:Qalloc: length 
   ;; Pattern:Qalloc:B: length 
   ;; Pattern:Qalloc: @put::at 
   ;; Pattern:Qalloc: @get: 
   ;; Pattern:Qalloc: @getV: 
   ;; Pattern:Qalloc: asString 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 36 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   % ...}" 
   ;; IS.newDescNo: 36 IS.objSize: 1 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  36 
   ;; "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;   in at: var  ...}" 
   ;; OG:super:  "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get 0;   @put:  ...}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  true  hasItems:  false 
   ;;  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
   ;; "Indexed(L + S.length,Integer)" 
   ;; super:  "Indexed(L + S.length,Integer)" 
   ;; E:  "Indexed(L + S.length,Integer)" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "Indexed(L + S.length,Integer)" 
   ;; OG:Qalloc: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" qDescno:  0 
   ;; OG:Qalloc:A:  "@for::to:repeat$S$0"  super:  "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  marked:  false "e: var integer{i: var integer;T: obj Indexed(L  ...}" s ... @ ... 
   ;; Invocation:Qalloc: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ObjectInvocation:Qalloc: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; name:   "@for::to:repeat" 
   ;; Arguments   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 3 %globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx :=  ...} 
   ;; OG:super:  "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop:  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  false 
   ;;  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
   ;; "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; super:  "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; E:  "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; OG:Qalloc:B: "@for::to:repeat$S$0" newDescNo: 0 objSize: 3 
   ;; OG:isObjectDesc:NewDescNo: 38 IS.newDescNo: 38 objSize: 3 varNo: 1 "" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 38 "" 
   ;; Items:Qalloc:super: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" size: 3 "@for::to:repeat$S$38" 
   ;; super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:super:B:objSize: 4 originOff: 4 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 38 "" 
   ;; IS.newDescNo: 38 IS.objSize: 3 "" 
   ;; OG:Qalloc:end: IS.newDescNo:  38 
   ;; "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; OG:Qalloc: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" qDescno:  0 
   ;; OG:Qalloc:A:  "@for::to:repeat$S$0"  super:  "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  marked:  false "e: var integer{i: var in ...}" s ... @ ... 
   ;; Invocation:Qalloc: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ObjectInvocation:Qalloc: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; name:   "@for::to:repeat" 
   ;; Arguments   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 3 %globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx :=  ...} 
   ;; OG:super:  "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop:  ...}" 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  false 
   ;;  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
   ;; "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; super:  "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; E:  "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; OG:Qalloc:B: "@for::to:repeat$S$0" newDescNo: 0 objSize: 3 
   ;; OG:isObjectDesc:NewDescNo: 39 IS.newDescNo: 39 objSize: 3 varNo: 1 "" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 39 "" 
   ;; Items:Qalloc:super: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" size: 3 "@for::to:repeat$S$39" 
   ;; super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:super:B:objSize: 4 originOff: 4 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 39 "" 
   ;; IS.newDescNo: 39 IS.objSize: 3 "" 
   ;; OG:Qalloc:end: IS.newDescNo:  39 
   ;; "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; OG:Qalloc: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  marked:  false "e: var integer{i: var integer;T ...}" s ... V ... 
   ;; Invocation:Qalloc: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; ObjectInvocation:Qalloc: "V" 
   ;; name:   "V" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; name:   ":=" 
   ;; Arguments   "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 8{in V: var Value} 
   ;; OG:Qalloc:SuperAlloc: ":=  : {   %basic 8;   in V: var Value}" 
   ;; OG:Qalloc: "%basic 8{in V: var Value}" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  ""  marked:  false ":=  : {   %basic 8;   in V: var Value}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%basic 8{in V: var Value}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: ":=" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 40 IS.newDescNo: 40 objSize: 0 varNo: 1 "%basic 8{in V: var Value}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 40 "%basic 8{in V: var Value}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
   ;; diSize: 1 IT.qSize: 2 
   ;; Items:Qalloc:END:objSize: 2  newDescNo: 40 "%basic 8{in V: var Value}" 
   ;; IS.newDescNo: 40 IS.objSize: 2 "%basic 8{in V: var Value}" 
   ;; OG:Qalloc:end: IS.newDescNo:  40 
   ;; "%basic 8{in V: var Value}" 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; super:  "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; E:  ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; Items:Qalloc:END:objSize: 4  newDescNo: 35 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@ ...}" 
   ;; IS.newDescNo: 35 IS.objSize: 4 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S. ...}" 
   ;; OG:Qalloc:end: IS.newDescNo:  35 
   ;; "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   e := S.@get  ...}" 
   ;; computeVariant:newDescNo: 35  size:  4  IS: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx; ...}" 
   ;; ComputeVariant:B:  "$S$35" 
   ;; ObjTmpStack:add: :genDone: false   "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :t ...}" 
   ;; items:markForCodeGen: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :r ...}" 
   ;; DataItem:markForCodeGen: "e" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "i" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "integer" 
   ;; "integer" true 
   ;; 
   ;; OG:markSuper: "integer" 
   ;; Invocation:markForCodeGen: "integer" 
   ;; ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "integer"  IS.isEmpty:  true 
   ;; DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 114 
   ;; OG:markForCodeGen: "Indexed(L + S.length,Integer)" 
   ;; isObjectDesc: false  isObjectDescX: true  hasItems: false 
   ;;  super.hasVirtualArgs: true 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Indexed(L + S.length,Integer)" 
   ;; "Indexed(L + S.length,Integer)" true 
   ;; 
   ;; OG:markSuper: "Indexed(L + S.length,Integer)" 
   ;; Invocation:markForCodeGen: "Indexed(L + S.length,Integer)" 
   ;; ObjectInvocation:markForCodeGen: "Indexed(L + S.length,Integer)"  ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   lengt ...}" 
   ;; Pattern:markForCodeGen: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @ge ...}" 
   ;; OG:markForCodeGen: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref ...}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;    ...}" 
   ;; ComputeVariant:A: "Indexed" 
   ;; %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;   in at: var i ...} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;    ...}" q ... 36 
   ;; computeVariant:newDescNo: 36  size:  1  IS: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;    ...}" 
   ;; ComputeVariant:B:  "Indexed" 
   ;; ObjTmpStack:add: :genDone: false   "Indexed" : "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ; ...}" 
   ;; items:markForCodeGen: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put:  ...}" 
   ;; markItem: "%globals" Property 
   ;; markItem: "%basic 114" Property 
   ;; markItem: "%public" Property 
   ;; DataItem:markForCodeGen: "range" :descNo: 0 :OG.primNo: 1 
   ;; OG:markForCodeGen: "Integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Integer" 
   ;; "Integer" true 
   ;; 
   ;; OG:markSuper: "Integer" 
   ;; Invocation:markForCodeGen: "Integer" 
   ;; ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "Integer"  IS.isEmpty:  true 
   ;; Pattern:markForCodeGen: "in elm:< Object" 
   ;; OG:markForCodeGen: "Object" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Object" 
   ;; "Object" true 
   ;; 
   ;; not ObjDesc:  "Object"  IS.isEmpty:  true 
   ;; arg:   "L + S.length" 
   ;; OG:markForCodeGen: "L + S.length" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "L + S.length" 
   ;; "L" true 
   ;; "+ S.length" true 
   ;; 
   ;; OG:markSuper: "L + S.length" 
   ;; Invocation:markForCodeGen: "L + S.length" 
   ;; ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
   ;; ObjectInvocation:markForCodeGen: "+ S.length"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; arg:   "S.length" 
   ;; OG:markForCodeGen: "S.length" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "S.length" 
   ;; "S" true 
   ;; "length" false 
   ;; 
   ;; OG:markSuper: "S.length" 
   ;; Invocation:markForCodeGen: "S.length" 
   ;; ObjectInvocation:markForCodeGen: "S"  ATd: "in S: ref String" 
   ;; ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; not ObjDesc:  "S.length"  IS.isEmpty:  true 
   ;; not ObjDesc:  "L + S.length"  IS.isEmpty:  true 
   ;; arg:   "Integer" 
   ;; OG:markForCodeGen: "Integer" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Integer" 
   ;; "Integer" true 
   ;; 
   ;; OG:markSuper: "Integer" 
   ;; Invocation:markForCodeGen: "Integer" 
   ;; ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
   ;; not ObjDesc:  "Integer"  IS.isEmpty:  true 
   ;; not ObjDesc:  "Indexed(L + S.length,Integer)"  IS.isEmpty:  true 
   ;; markItem: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" ObjectGenerator 
   ;; OG:markForCodeGen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: false 
   ;;  super.hasVirtualArgs: true 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" false 
   ;; 
   ;; OG:markSuper: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; Invocation:markForCodeGen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ObjectInvocation:markForCodeGen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer ...}" 
   ;; arg:   "1" 
   ;; OG:markForCodeGen: "1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "1" 
   ;; "1" true 
   ;; 
   ;; OG:markSuper: "1" 
   ;; Invocation:markForCodeGen: "1" 
   ;; not ObjDesc:  "1"  IS.isEmpty:  true 
   ;; arg:   "L" 
   ;; OG:markForCodeGen: "L" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "L" 
   ;; "L" true 
   ;; 
   ;; arg:   "e := @get inx{T.@put e :at inx}" 
   ;; OG:markForCodeGen: "e := @get inx{T.@put e :at inx}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "e := @get inx{T.@put e :at inx}" 
   ;; ComputeVariant:A: "repeat$S$0" 
   ;; e := @get inx{T.@put e :at inx} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: repeat 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "e := @get inx{T.@put e :at inx}" qDescno:  0 
   ;; OG:Qalloc:A:  "repeat$S$0"  super:  ""  marked:  true "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "e := @get inx{T.@put e :at inx}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "repeat$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 41 IS.newDescNo: 41 objSize: 0 varNo: 1 "e := @get inx{T.@put e :at inx}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 41 "e := @get inx{T.@put e :at inx}" 
   ;; Items:Qalloc:super: "" size: 1 "repeat$S$41" 
   ;; super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
   ;; Items:Qalloc:super:B:objSize: 1 originOff: 1 
   ;; OG:Qalloc: "e := @get inx" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "e := @get inx"  marked:  false "e := @get inx{T.@put e :at inx}" super:  e := @get inx 
   ;; Invocation:Qalloc: "e := @get inx" 
   ;; ObjectInvocation:Qalloc: "e" 
   ;; name:   "e" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= @get inx" 
   ;; name:   ":=" 
   ;; Arguments   "@get inx" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "e := @get inx" 
   ;; super:  "e := @get inx" 
   ;; E:  ":= @get inx" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "e := @get inx" 
   ;; OG:Qalloc: "T.@put e :at inx" qDescno:  0 
   ;; OG:Qalloc:A:  "@put::at"  super:  "T.@put e :at inx"  marked:  false "e := @get inx{T.@put e :at inx}" super:  T.@put e :at inx 
   ;; Invocation:Qalloc: "T.@put e :at inx" 
   ;; ObjectInvocation:Qalloc: "T" 
   ;; name:   "T" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: "@put e :at inx" 
   ;; name:   "@put::at" 
   ;; Arguments   "@put e :at inx" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 115{in put: ref elm;in at: var integer} 
   ;; OG:Qalloc:SuperAlloc: "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; OG:Qalloc: "%basic 115{in put: ref elm;in at: var integer}" qDescno:  0 
   ;; OG:Qalloc:A:  "@put::at"  super:  ""  marked:  false "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "%basic 115{in put: ref elm;in at: var integer}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "@put::at" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 42 IS.newDescNo: 42 objSize: 0 varNo: 1 "%basic 115{in put: ref elm;in at: var integer}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 42 "%basic 115{in put: ref elm;in at: var integer}" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; Items:Qalloc:Super:C:objSize: 1 originOff: 1 
   ;; dataitem:qalloc: "put" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
   ;; DI:Qalloc:off: 2 "in put: ref elm" 
   ;; OG:Qalloc: "elm" qDescno:  0 
   ;; OG:Qalloc:A:  "Object"  super:  "elm"  marked:  false "in put: ref elm" super:  elm 
   ;; Invocation:Qalloc: "elm" 
   ;; ObjectInvocation:Qalloc: "elm" 
   ;; name:   "elm" 
   ;; Arguments   "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:super:  "in elm:< Object" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "elm" 
   ;; super:  "elm" 
   ;; E:  "elm" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "elm" 
   ;; dataitem:qalloc: "at" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
   ;; diSize: 1 IT.qSize: 3 
   ;; Items:Qalloc:END:objSize: 3  newDescNo: 42 "%basic 115{in put: ref elm;in at: var integer}" 
   ;; IS.newDescNo: 42 IS.objSize: 3 "%basic 115{in put: ref elm;in at: var integer}" 
   ;; OG:Qalloc:end: IS.newDescNo:  42 
   ;; "%basic 115{in put: ref elm;in at: var integer}" 
   ;; OG:super:  "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "T.@put e :at inx" 
   ;; super:  "T.@put e :at inx" 
   ;; E:  "@put e :at inx" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "T.@put e :at inx" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 41 "e := @get inx{T.@put e :at inx}" 
   ;; IS.newDescNo: 41 IS.objSize: 1 "e := @get inx{T.@put e :at inx}" 
   ;; OG:Qalloc:end: IS.newDescNo:  41 
   ;; "e := @get inx{T.@put e :at inx}" 
   ;; computeVariant:newDescNo: 41  size:  1  IS: "e := @get inx{T.@put e :at inx}" 
   ;; ComputeVariant:B:  "repeat$S$41" 
   ;; ObjTmpStack:add: :genDone: false   "e := @get inx{T.@put e :at inx}" 
   ;; items:markForCodeGen: "e := @get inx{T.@put e :at inx}" 
   ;; markItem: "e := @get inx" ObjectGenerator 
   ;; OG:markForCodeGen: "e := @get inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "e := @get inx" 
   ;; "e" true 
   ;; ":= @get inx" true 
   ;; 
   ;; OG:markSuper: "e := @get inx" 
   ;; Invocation:markForCodeGen: "e := @get inx" 
   ;; ObjectInvocation:markForCodeGen: "e"  ATd: "e: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= @get inx"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "@get inx" 
   ;; not ObjDesc:  "e := @get inx"  IS.isEmpty:  true 
   ;; markItem: "T.@put e :at inx" ObjectGenerator 
   ;; OG:markIS: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ComputeVariant:A: "@for::to:repeat$S$38" 
   ;; @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: @for::to:repeat 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" qDescno:  38 
   ;; computeVariant:newDescNo: 38  size:  3  IS: "" 
   ;; ComputeVariant:B:  "@for::to:repeat$S$38" 
   ;; ObjTmpStack:add: :genDone: false   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; items:markForCodeGen: "" 
   ;; markItem: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" ObjectGenerator 
   ;; OG:markForCodeGen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: false 
   ;;  super.hasVirtualArgs: true 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" false 
   ;; 
   ;; OG:markSuper: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; Invocation:markForCodeGen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ObjectInvocation:markForCodeGen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  ATd: "@for: {   %globals inSub;   in for: var intege ...}" 
   ;; arg:   "1" 
   ;; OG:markForCodeGen: "1" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "1" 
   ;; "1" true 
   ;; 
   ;; OG:markSuper: "1" 
   ;; Invocation:markForCodeGen: "1" 
   ;; not ObjDesc:  "1"  IS.isEmpty:  true 
   ;; arg:   "S.length" 
   ;; OG:markForCodeGen: "S.length" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "S.length" 
   ;; "S" true 
   ;; "length" false 
   ;; 
   ;; OG:markSuper: "S.length" 
   ;; Invocation:markForCodeGen: "S.length" 
   ;; ObjectInvocation:markForCodeGen: "S"  ATd: "in S: ref String" 
   ;; ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; not ObjDesc:  "S.length"  IS.isEmpty:  true 
   ;; arg:   "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; OG:markForCodeGen: "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; ComputeVariant:A: "repeat$S$0" 
   ;; e := S.@get inx{i := L + inx;T.@put e :at i} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: repeat 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "e := S.@get inx{i := L + inx;T.@put e :at i}" qDescno:  0 
   ;; OG:Qalloc:A:  "repeat$S$0"  super:  ""  marked:  true "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" super:   
   ;; Invocation:Qalloc: "" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  22 1 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;  ...} 
   ;; OG:Qalloc:isObjectDesc:  true  isObjectDescX:  true  hasItems:  true 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; super:  "" 
   ;; E:  "" 
   ;; OG:Qalloc:B: "repeat$S$0" newDescNo: 0 objSize: 0 
   ;; OG:isObjectDesc:NewDescNo: 43 IS.newDescNo: 43 objSize: 0 varNo: 1 "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; Items:Qalloc:objSize: 0  newDescNo: 43 "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; Items:Qalloc:super: "" size: 1 "repeat$S$43" 
   ;; super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
   ;; Items:Qalloc:super:B:objSize: 1 originOff: 1 
   ;; OG:Qalloc: "e := S.@get inx" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "e := S.@get inx"  marked:  false "e := S.@get inx{i := L + inx;T.@put e :at i}" super:  e := S.@get inx 
   ;; Invocation:Qalloc: "e := S.@get inx" 
   ;; ObjectInvocation:Qalloc: "e" 
   ;; name:   "e" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= S.@get inx" 
   ;; name:   ":=" 
   ;; Arguments   "S.@get inx" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "e := S.@get inx" 
   ;; super:  "e := S.@get inx" 
   ;; E:  ":= S.@get inx" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "e := S.@get inx" 
   ;; OG:Qalloc: "i := L + inx" qDescno:  0 
   ;; OG:Qalloc:A:  ":="  super:  "i := L + inx"  marked:  false "e := S.@get inx{i := L + inx;T.@put e :at i}" super:  i := L + inx 
   ;; Invocation:Qalloc: "i := L + inx" 
   ;; ObjectInvocation:Qalloc: "i" 
   ;; name:   "i" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: ":= L + inx" 
   ;; name:   ":=" 
   ;; Arguments   "L + inx" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 4 %basic 8{in V: var Value;--inner(Value);} 
   ;; OG:super:  ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "i := L + inx" 
   ;; super:  "i := L + inx" 
   ;; E:  ":= L + inx" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "i := L + inx" 
   ;; OG:Qalloc: "T.@put e :at i" qDescno:  0 
   ;; OG:Qalloc:A:  "@put::at"  super:  "T.@put e :at i"  marked:  false "e := S.@get inx{i := L + inx;T.@put e :at i}" super:  T.@put e :at i 
   ;; Invocation:Qalloc: "T.@put e :at i" 
   ;; ObjectInvocation:Qalloc: "T" 
   ;; name:   "T" 
   ;; Arguments   "" 
   ;; ObjectInvocation:Qalloc: "@put e :at i" 
   ;; name:   "@put::at" 
   ;; Arguments   "@put e :at i" 
   ;; IS.superDesc<>none:  true  IS.superDesc.newDescNo:  42 3 %basic 115{in put: ref elm;in at: var integer} 
   ;; OG:super:  "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; OG:Qalloc:isObjectDesc:  false  isObjectDescX:  false  hasItems:  false 
   ;;  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
   ;; "T.@put e :at i" 
   ;; super:  "T.@put e :at i" 
   ;; E:  "@put e :at i" 
   ;; OG:Qalloc:end: IS.newDescNo:  0 
   ;; "T.@put e :at i" 
   ;; Items:Qalloc:END:objSize: 1  newDescNo: 43 "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; IS.newDescNo: 43 IS.objSize: 1 "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; OG:Qalloc:end: IS.newDescNo:  43 
   ;; "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; computeVariant:newDescNo: 43  size:  1  IS: "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; ComputeVariant:B:  "repeat$S$43" 
   ;; ObjTmpStack:add: :genDone: false   "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; items:markForCodeGen: "e := S.@get inx{i := L + inx;T.@put e :at i}" 
   ;; markItem: "e := S.@get inx" ObjectGenerator 
   ;; OG:markForCodeGen: "e := S.@get inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "e := S.@get inx" 
   ;; "e" true 
   ;; ":= S.@get inx" true 
   ;; 
   ;; OG:markSuper: "e := S.@get inx" 
   ;; Invocation:markForCodeGen: "e := S.@get inx" 
   ;; ObjectInvocation:markForCodeGen: "e"  ATd: "e: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= S.@get inx"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "S.@get inx" 
   ;; not ObjDesc:  "e := S.@get inx"  IS.isEmpty:  true 
   ;; markItem: "i := L + inx" ObjectGenerator 
   ;; OG:markForCodeGen: "i := L + inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "i := L + inx" 
   ;; "i" true 
   ;; ":= L + inx" true 
   ;; 
   ;; OG:markSuper: "i := L + inx" 
   ;; Invocation:markForCodeGen: "i := L + inx" 
   ;; ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer" 
   ;; ObjectInvocation:markForCodeGen: ":= L + inx"  ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; arg:   "L + inx" 
   ;; OG:markForCodeGen: "L + inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "L + inx" 
   ;; "L" true 
   ;; "+ inx" true 
   ;; 
   ;; OG:markSuper: "L + inx" 
   ;; Invocation:markForCodeGen: "L + inx" 
   ;; ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
   ;; ObjectInvocation:markForCodeGen: "+ inx"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; arg:   "inx" 
   ;; OG:markForCodeGen: "inx" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "inx" 
   ;; "inx" true 
   ;; 
   ;; not ObjDesc:  "L + inx"  IS.isEmpty:  true 
   ;; not ObjDesc:  "i := L + inx"  IS.isEmpty:  true 
   ;; markItem: "T.@put e :at i" ObjectGenerator 
   ;; OG:markIS: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ComputeVariant:A: "@for::to:repeat$S$39" 
   ;; @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; PropagateToSuper: @for::to:repeat 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" qDescno:  39 
   ;; computeVariant:newDescNo: 39  size:  3  IS: "" 
   ;; ComputeVariant:B:  "@for::to:repeat$S$39" 
   ;; ObjTmpStack:add: :genDone: false   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; items:markForCodeGen: "" 
   ;; markItem: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" ObjectGenerator 
   ;; OG:markForCodeGen: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; "V" true 
   ;; ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" true 
   ;; 
   ;; OG:markSuper: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; Invocation:markForCodeGen: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; ObjectInvocation:markForCodeGen: "V"  ATd: "out V: ref String" 
   ;; ObjectInvocation:markForCodeGen: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  ATd: ":=  : {   %basic 8;   in V: var Value}" 
   ;; Pattern:markForCodeGen: ":=  : {   %basic 8;   in V: var Value}" 
   ;; OG:markForCodeGen: "%basic 8{in V: var Value}" 
   ;; isObjectDesc: true  isObjectDescX: true  hasItems: true 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: false 
   ;;  (super.last).isPrimitive: false 
   ;; "" 
   ;; "" false 
   ;; 
   ;; OG:markIS: "%basic 8{in V: var Value}" 
   ;; ComputeVariant:A: ":=" 
   ;; %basic 8{in V: var Value} 
   ;; topVarExists:top: 1 
   ;; checkIfTopIsNew:A:topVarExists: false  isEmpty:  false 
   ;; checkIfTopIsNew:ISNEW 
   ;; PropagateToSuper:A:
   ;; PropagateToSuper:B:
   ;; super.ATd is none 
   ;; var is new: top:  1 var.thisVarNo: 1 
   ;; OG:Qalloc: "%basic 8{in V: var Value}" qDescno:  40 
   ;; computeVariant:newDescNo: 40  size:  2  IS: "%basic 8{in V: var Value}" 
   ;; ComputeVariant:B:  ":=" 
   ;; ObjTmpStack:add: :genDone: false   ":=" : "%basic 8{in V: var Value}" 
   ;; items:markForCodeGen: "%basic 8{in V: var Value}" 
   ;; markItem: "%basic 8" Property 
   ;; DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 21 
   ;; OG:markForCodeGen: "Value" 
   ;; isObjectDesc: false  isObjectDescX: false  hasItems: false 
   ;;  super.hasVirtualArgs: false 
   ;;  super.isPrimitive: true 
   ;;  (super.last).isPrimitive: true 
   ;; "Value" 
   ;; "Value" true 
   ;; 
   ;; OG:markSuper: "Value" 
   ;; Invocation:markForCodeGen: "Value" 
   ;; ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   :=  : ;      %basic 8;      in V: var Value;      --inner(Value ...}" 
   ;; not ObjDesc:  "Value"  IS.isEmpty:  true 
   ;; arg:   "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; not ObjDesc:  "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  IS.isEmpty:  true 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; ascii  basic:  false  val:  false  valObj:  false  Inx: false 
   ;; _thisBasicValue  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; _thisBasicValue  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; ch  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; V  basic:  false  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: true 
   ;; V  basic:  false  val:  true  valObj:  true  Inx: false 
   ;; range  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; for  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; to  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; inx  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; nl  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; cr  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; newline  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; x_dummy_LIB  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; keyboard  basic:  false  val:  false  valObj:  false  Inx: false 
   ;; screen  basic:  false  val:  false  valObj:  false  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; dummy  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; M  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; L  basic:  false  val:  false  valObj:  false  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; V  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; S  basic:  false  val:  false  valObj:  false  Inx: true 
   ;; V  basic:  false  val:  false  valObj:  false  Inx: true 
   ;; L  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; e  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; i  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; T  basic:  false  val:  false  valObj:  false  Inx: true 
   ;; for  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; to  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; inx  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; for  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; to  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; inx  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; for  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; to  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; inx  basic:  true  val:  true  valObj:  true  Inx: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 1 :top: 1 
   ;; Items:GenClass: BETAworld descNo: 1 
   ;; genClass:super: BETAworld 
   ;; "" 
   ;; Items:GenClass: Object descNo: 22 
;; class  Object 22 1 BETA 2

define %Object$22* @Object$22(%Object$22* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; $Property:"%ID Object" 
   ;; Qgen: 
   ;; $Property:"%basic 64" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%ID Object" 
   ;; $Property:"%ID Object" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 64" 
   ;; $Property:"%basic 64" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; genclass:stmt: "inner(Object)" 
   ;; $ObjectGenerator:"inner(Object)" 
   ;; Qgen:OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "inner" superDescNo: 23 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inner(Object)" 
   ;; Qgen: useRtnV:"False" descNo: 23 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inner(Object)" 
   ;; needorigin: "inner(Object)" 
   ;; needOrigin:E: "inner(Object)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
   ;; doNeedOrigin:Ex: "inner(Object)" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inner(Object)" 
   ;; computeAdr: 1 :rec: "none"  E: "inner(Object)" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Function:"inner(Object)" 
   ;; >pushThis: 
   ;; OI:pushThis: "%ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: ref Object;   out V ...}" A ... "i ..." 
   ;; $ObjectInvocation_Function:"inner(Object)" 
   ;; >loadOrigin::on:1 
   ;; $ObjectInvocation_Function:"inner(Object)" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"inner: {   %basic 101;   in inner: ref Object"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inner(Object)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
   ;; computeAdr:isLast:E:  "inner(Object)" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
   ;; rec:  "inner(Object)" E:  "inner(Object)" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inner(Object)" superAdj= 0 
   ;; $ObjectInvocation_Function:"inner(Object)" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  (Object)  hasArg:  pattern 
   ;; inner(Object)   inner: {   %basic 101;   in inner: ref Object} 
   ;; $pattern:"inner: {   %basic 101;   in inner: ref Object"} 
   ;; >loadArgs:E:"inner(Object)":descNo:23:top:0 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inner(Object)" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "inner(Object)" 
   ;; $ObjectInvocation_Function:"inner(Object)" 
   ;; >invoke: rec:"inner(Object)" 
   ;; OI:invoke:isPtn: "inner(Object)" descNo 23  useRTNv: false 
   ;; E.ATd:  "inner" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
   ;; OI:invoke:B: "inner(Object)" E: "inner(Object)"  rec: "inner(Object)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
   ;; $pattern:"inner: {   %basic 101;   in inner: ref Object"} 
   ;; >invoke:E: "inner(Object)" useRTNv: "False" 
   ;; ptn:invoke: "inner" E: "inner(Object)" useRtnV: false 
   ;; inner:hasArgs: inner(Object) 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(Object)"} 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %Object$22* 
   ;; goOrigin:T 
;; innerP  1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%Object$22*]
   %R1 = getelementptr %Object$22,%Object$22 *%R0, i32 0, i32 0
%R2 = load %vdt_type$Object$22*, %vdt_type$Object$22** %R1
   %R3 = getelementptr %vdt_type$Object$22,%vdt_type$Object$22* %R2, i32 0, i32 0
%R4 = load  i8*(i8*)*, i8*(i8*)** %R3
   %V5 = icmp eq i8*(i8*)* %R4, null
   br i1 %V5, label %L6, label %L7
L7:
   ;; inner not null
      %R8 = bitcast %Object$22* %R0 to i8*
call i8* %R4(i8* %R8)
   br label %L6
L6:
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; OI:invoke: inner(Object) :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inner(Object)" 
   br label %L2
L2:
   ;; pushReturn:  "Object" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %Object$22* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%Object$22*]
   ret %Object$22* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdtAdd: inx=1 descInx=22 vDescInx=0 vdtTop: 1
   ;; vdt:vdtTop: 1 0:I
@vdt_data$Object$22 = global %vdt_type$Object$22 {
      i8* (i8* )* null
}

define %vdt_ret$Object$22* @vdt_alloc$Object$22(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$Object$22
   %R10 = tail call i8* @malloc(i64 32)
   %R11 = bitcast i8* %R10 to %vdt_ret$Object$22*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %Object$22 
   ;; alloc %Object$22
   %R12 = tail call i8* @malloc(i64 192)
   %R13 = bitcast i8* %R12 to %Object$22*
   ;; store VDT in object
   %R14 = getelementptr %Object$22, %Object$22* %R13, i32 0, i32 0
   store %vdt_type$Object$22* @vdt_data$Object$22, %vdt_type$Object$22** %R14
   %R15 = getelementptr %vdt_ret$Object$22,%vdt_ret$Object$22* %R11, i32 0, i32 0
   store %Object$22* %R13, %Object$22** %R15
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 13 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETA$2*,13:%Object$22]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: Object 
   ;; after:handleOrigins 
   ret %vdt_ret$Object$22* %R11
}
   ;; ObjStubStackX:gen 
;; class  BETAworld 1 1 Object 22

define %BETAworld$1* @BETAworld$1(%BETAworld$1* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=1 vDescInx=1 vdtTop: 1
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %BETAworld$1* 
   ;; saveBETAworld
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; $Property:"%id "BETAworld"" 
   ;; Qgen: 
   ;; $Property:"%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" 
   ;; Qgen: 
   ;; $obj:"BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   universal: Value;      %ID universal;      %basic 1, 32;      %globals ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic  ..."} 
   ;; Qgen:OGid:"BETA" singular! staticOff=2 descNo=2 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  2   "BETA" 
   ;; OGid: BETA  OGidWdNo:  BETA$2 
;; invoke BETA 2 2 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%BETAworld$1*]
   ;; alloc %BETA$2
   %R1 = tail call i8* @malloc(i64 12)
   %R2 = bitcast i8* %R1 to %BETA$2*
   ;; store VDT in object
   %R3 = getelementptr %BETA$2, %BETA$2* %R2, i32 0, i32 0
   store %vdt_type$BETA$2* @vdt_data$BETA$2, %vdt_type$BETA$2** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BETA$2 this: BETA$2 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BETA$2 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,2:%BETA$2]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,2:%BETA$2]
   %R4 = getelementptr %BETA$2, %BETA$2 * %R2, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R4
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[2:%BETA$2,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,2)=[2:%BETA$2]
   ;; topSuper: 2   BETA$2 
   ;; save object: %BETA$2* dstType: %BETA$2*
   %R5 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 2
   store %BETA$2* %R2,  %BETA$2** %R5
   %R6 = call %BETA$2* @BETA$2(%BETA$2 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   %V9 = icmp eq %BETA$2* %R6, %R2
   br i1 %V9, label %normalRtnLab7, label %breakLab8
breakLab8:
   %R10 = bitcast %BETA$2* %R6 to %BETAworld$1*
   %V11 = icmp eq %BETAworld$1* %R0, %R10
   br i1 %V11, label %selectBreakLab13, label %contBreakLab12
contBreakLab12:
   ret %BETAworld$1* %R10
selectBreakLab13:
   %R14 = bitcast %BETA$2* %R6 to [0 x i32]*
   %R15 = getelementptr [0 x i32], [0 x i32]* %R14, i32 0, i32 0
   %V16 = load i32 , i32* %R15
   %R17 = getelementptr %BETA$2,%BETA$2* %R6, i32 0, i32 0
   store %vdt_type$BETA$2* @vdt_data$BETA$2, %vdt_type$BETA$2** %R17
   %V18 = icmp eq i32 1, %V16
   br i1 %V18, label %X19, label %X20
X19:
   br label %L1 ; restart
X20:
   br label %L2 ; leave
normalRtnLab7:

   ;; vTop(0,0)=[] rTop(1,2)=[2:%BETA$2*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $obj:"LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Cont ..."} 
   ;; Qgen:OGid:"LIB" singular! staticOff=3 descNo=8 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  8   "LIB" 
   ;; OGid: LIB  OGidWdNo:  LIB$8 
;; invoke LIB 8 3 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ;; alloc %LIB$8
   %R21 = tail call i8* @malloc(i64 20)
   %R22 = bitcast i8* %R21 to %LIB$8*
   ;; store VDT in object
   %R23 = getelementptr %LIB$8, %LIB$8* %R22, i32 0, i32 0
   store %vdt_type$LIB$8* @vdt_data$LIB$8, %vdt_type$LIB$8** %R23
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 22 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: LIB$8 this: LIB$8 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 LIB$8 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,22:%LIB$8]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,22:%LIB$8]
   %R24 = getelementptr %LIB$8, %LIB$8 * %R22, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R24
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[22:%LIB$8,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 22 
   ;; vTop(0,0)=[] rTop(1,2)=[22:%LIB$8]
   ;; topSuper: 8   LIB$8 
   ;; save object: %LIB$8* dstType: %LIB$8*
   %R25 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 3
   store %LIB$8* %R22,  %LIB$8** %R25
   %R26 = call %LIB$8* @LIB$8(%LIB$8 * %R22)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 22 
   %V29 = icmp eq %LIB$8* %R26, %R22
   br i1 %V29, label %normalRtnLab27, label %breakLab28
breakLab28:
   %R30 = bitcast %LIB$8* %R26 to %BETAworld$1*
   %V31 = icmp eq %BETAworld$1* %R0, %R30
   br i1 %V31, label %selectBreakLab33, label %contBreakLab32
contBreakLab32:
   ret %BETAworld$1* %R30
selectBreakLab33:
   %R34 = bitcast %LIB$8* %R26 to [0 x i32]*
   %R35 = getelementptr [0 x i32], [0 x i32]* %R34, i32 0, i32 0
   %V36 = load i32 , i32* %R35
   %R37 = getelementptr %LIB$8,%LIB$8* %R26, i32 0, i32 0
   store %vdt_type$LIB$8* @vdt_data$LIB$8, %vdt_type$LIB$8** %R37
   %V38 = icmp eq i32 1, %V36
   br i1 %V38, label %X39, label %X40
X39:
   br label %L1 ; restart
X40:
   br label %L2 ; leave
normalRtnLab27:

   ;; vTop(0,0)=[] rTop(1,2)=[22:%LIB$8*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; Module:genMI:  "QBETA" 
   ;; $obj:"QBETA: obj {   %requires BETA;   %visible BETA;   NewSyntaxIndexed: ;      %globals;      %basic 114;      %public;      in range: var Integer;      in elm:< Object; ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out re ..."} 
   ;; Qgen:OGid:"QBETA" singular! staticOff=4 descNo=16 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  16   "QBETA" 
   ;; OGid: QBETA  OGidWdNo:  QBETA$16 
;; invoke QBETA 16 4 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ;; alloc %QBETA$16
   %R41 = tail call i8* @malloc(i64 8)
   %R42 = bitcast i8* %R41 to %QBETA$16*
   ;; store VDT in object
   %R43 = getelementptr %QBETA$16, %QBETA$16* %R42, i32 0, i32 0
   store %vdt_type$QBETA$16* @vdt_data$QBETA$16, %vdt_type$QBETA$16** %R43
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 42 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: QBETA$16 this: QBETA$16 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 QBETA$16 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,42:%QBETA$16]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,42:%QBETA$16]
   %R44 = getelementptr %QBETA$16, %QBETA$16 * %R42, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R44
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[42:%QBETA$16,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 42 
   ;; vTop(0,0)=[] rTop(1,2)=[42:%QBETA$16]
   ;; topSuper: 16   QBETA$16 
   ;; save object: %QBETA$16* dstType: %QBETA$16*
   %R45 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 4
   store %QBETA$16* %R42,  %QBETA$16** %R45
   %R46 = call %QBETA$16* @QBETA$16(%QBETA$16 * %R42)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 42 
   %V49 = icmp eq %QBETA$16* %R46, %R42
   br i1 %V49, label %normalRtnLab47, label %breakLab48
breakLab48:
   %R50 = bitcast %QBETA$16* %R46 to %BETAworld$1*
   %V51 = icmp eq %BETAworld$1* %R0, %R50
   br i1 %V51, label %selectBreakLab53, label %contBreakLab52
contBreakLab52:
   ret %BETAworld$1* %R50
selectBreakLab53:
   %R54 = bitcast %QBETA$16* %R46 to [0 x i32]*
   %R55 = getelementptr [0 x i32], [0 x i32]* %R54, i32 0, i32 0
   %V56 = load i32 , i32* %R55
   %R57 = getelementptr %QBETA$16,%QBETA$16* %R46, i32 0, i32 0
   store %vdt_type$QBETA$16* @vdt_data$QBETA$16, %vdt_type$QBETA$16** %R57
   %V58 = icmp eq i32 1, %V56
   br i1 %V58, label %X59, label %X60
X59:
   br label %L1 ; restart
X60:
   br label %L2 ; leave
normalRtnLab47:

   ;; vTop(0,0)=[] rTop(1,2)=[42:%QBETA$16*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; Module:genMI:  "workspace" 
   ;; $ModuleItem:"--BETA{"} 
   ;; Qgen: 
   ;; ModuleItem:gen BETA 
   ;; $obj:"BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   universal: Value;      %ID universal;      %basic 1, 32;      %globals ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;universal: Value;   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic  ..."} 
   ;; Qgen:OGid:"BETA" singular! staticOff=2 descNo=2 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  2   "BETA" 
   ;; OGid: BETA  OGidWdNo:  BETA$2 
;; invoke BETA 2 2 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ;; alloc %BETA$2
   %R61 = tail call i8* @malloc(i64 12)
   %R62 = bitcast i8* %R61 to %BETA$2*
   ;; store VDT in object
   %R63 = getelementptr %BETA$2, %BETA$2* %R62, i32 0, i32 0
   store %vdt_type$BETA$2* @vdt_data$BETA$2, %vdt_type$BETA$2** %R63
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 62 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BETA$2 this: BETA$2 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BETA$2 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,62:%BETA$2]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,62:%BETA$2]
   %R64 = getelementptr %BETA$2, %BETA$2 * %R62, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R64
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[62:%BETA$2,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 62 
   ;; vTop(0,0)=[] rTop(1,2)=[62:%BETA$2]
   ;; topSuper: 2   BETA$2 
   ;; save object: %BETA$2* dstType: %BETA$2*
   %R65 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 2
   store %BETA$2* %R62,  %BETA$2** %R65
   %R66 = call %BETA$2* @BETA$2(%BETA$2 * %R62)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 62 
   %V69 = icmp eq %BETA$2* %R66, %R62
   br i1 %V69, label %normalRtnLab67, label %breakLab68
breakLab68:
   %R70 = bitcast %BETA$2* %R66 to %BETAworld$1*
   %V71 = icmp eq %BETAworld$1* %R0, %R70
   br i1 %V71, label %selectBreakLab73, label %contBreakLab72
contBreakLab72:
   ret %BETAworld$1* %R70
selectBreakLab73:
   %R74 = bitcast %BETA$2* %R66 to [0 x i32]*
   %R75 = getelementptr [0 x i32], [0 x i32]* %R74, i32 0, i32 0
   %V76 = load i32 , i32* %R75
   %R77 = getelementptr %BETA$2,%BETA$2* %R66, i32 0, i32 0
   store %vdt_type$BETA$2* @vdt_data$BETA$2, %vdt_type$BETA$2** %R77
   %V78 = icmp eq i32 1, %V76
   br i1 %V78, label %X79, label %X80
X79:
   br label %L1 ; restart
X80:
   br label %L2 ; leave
normalRtnLab67:

   ;; vTop(0,0)=[] rTop(1,2)=[62:%BETA$2*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $ModuleItem:"--DK{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--LIB{"} 
   ;; Qgen: 
   ;; ModuleItem:gen LIB 
   ;; $obj:"LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--Complex;--Cont ..."} 
   ;; Qgen:OGid:"LIB" singular! staticOff=3 descNo=8 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  8   "LIB" 
   ;; OGid: LIB  OGidWdNo:  LIB$8 
;; invoke LIB 8 3 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ;; alloc %LIB$8
   %R81 = tail call i8* @malloc(i64 20)
   %R82 = bitcast i8* %R81 to %LIB$8*
   ;; store VDT in object
   %R83 = getelementptr %LIB$8, %LIB$8* %R82, i32 0, i32 0
   store %vdt_type$LIB$8* @vdt_data$LIB$8, %vdt_type$LIB$8** %R83
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 82 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: LIB$8 this: LIB$8 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 LIB$8 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,82:%LIB$8]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,82:%LIB$8]
   %R84 = getelementptr %LIB$8, %LIB$8 * %R82, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R84
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[82:%LIB$8,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 82 
   ;; vTop(0,0)=[] rTop(1,2)=[82:%LIB$8]
   ;; topSuper: 8   LIB$8 
   ;; save object: %LIB$8* dstType: %LIB$8*
   %R85 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 3
   store %LIB$8* %R82,  %LIB$8** %R85
   %R86 = call %LIB$8* @LIB$8(%LIB$8 * %R82)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 82 
   %V89 = icmp eq %LIB$8* %R86, %R82
   br i1 %V89, label %normalRtnLab87, label %breakLab88
breakLab88:
   %R90 = bitcast %LIB$8* %R86 to %BETAworld$1*
   %V91 = icmp eq %BETAworld$1* %R0, %R90
   br i1 %V91, label %selectBreakLab93, label %contBreakLab92
contBreakLab92:
   ret %BETAworld$1* %R90
selectBreakLab93:
   %R94 = bitcast %LIB$8* %R86 to [0 x i32]*
   %R95 = getelementptr [0 x i32], [0 x i32]* %R94, i32 0, i32 0
   %V96 = load i32 , i32* %R95
   %R97 = getelementptr %LIB$8,%LIB$8* %R86, i32 0, i32 0
   store %vdt_type$LIB$8* @vdt_data$LIB$8, %vdt_type$LIB$8** %R97
   %V98 = icmp eq i32 1, %V96
   br i1 %V98, label %X99, label %X100
X99:
   br label %L1 ; restart
X100:
   br label %L2 ; leave
normalRtnLab87:

   ;; vTop(0,0)=[] rTop(1,2)=[82:%LIB$8*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $ModuleItem:"--OOPM{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--QBETA{"} 
   ;; Qgen: 
   ;; ModuleItem:gen QBETA 
   ;; $obj:"QBETA: obj {   %requires BETA;   %visible BETA;   NewSyntaxIndexed: ;      %globals;      %basic 114;      %public;      in range: var Integer;      in elm:< Object; ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%requires BETA{%visible BETA;NewSyntaxIndexed: ;   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out re ..."} 
   ;; Qgen:OGid:"QBETA" singular! staticOff=4 descNo=16 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  16   "QBETA" 
   ;; OGid: QBETA  OGidWdNo:  QBETA$16 
;; invoke QBETA 16 4 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ;; alloc %QBETA$16
   %R101 = tail call i8* @malloc(i64 8)
   %R102 = bitcast i8* %R101 to %QBETA$16*
   ;; store VDT in object
   %R103 = getelementptr %QBETA$16, %QBETA$16* %R102, i32 0, i32 0
   store %vdt_type$QBETA$16* @vdt_data$QBETA$16, %vdt_type$QBETA$16** %R103
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 102 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: QBETA$16 this: QBETA$16 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 QBETA$16 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,102:%QBETA$16]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,102:%QBETA$16]
   %R104 = getelementptr %QBETA$16, %QBETA$16 * %R102, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R104
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[102:%QBETA$16,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 102 
   ;; vTop(0,0)=[] rTop(1,2)=[102:%QBETA$16]
   ;; topSuper: 16   QBETA$16 
   ;; save object: %QBETA$16* dstType: %QBETA$16*
   %R105 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 4
   store %QBETA$16* %R102,  %QBETA$16** %R105
   %R106 = call %QBETA$16* @QBETA$16(%QBETA$16 * %R102)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 102 
   %V109 = icmp eq %QBETA$16* %R106, %R102
   br i1 %V109, label %normalRtnLab107, label %breakLab108
breakLab108:
   %R110 = bitcast %QBETA$16* %R106 to %BETAworld$1*
   %V111 = icmp eq %BETAworld$1* %R0, %R110
   br i1 %V111, label %selectBreakLab113, label %contBreakLab112
contBreakLab112:
   ret %BETAworld$1* %R110
selectBreakLab113:
   %R114 = bitcast %QBETA$16* %R106 to [0 x i32]*
   %R115 = getelementptr [0 x i32], [0 x i32]* %R114, i32 0, i32 0
   %V116 = load i32 , i32* %R115
   %R117 = getelementptr %QBETA$16,%QBETA$16* %R106, i32 0, i32 0
   store %vdt_type$QBETA$16* @vdt_data$QBETA$16, %vdt_type$QBETA$16** %R117
   %V118 = icmp eq i32 1, %V116
   br i1 %V118, label %X119, label %X120
X119:
   br label %L1 ; restart
X120:
   br label %L2 ; leave
normalRtnLab107:

   ;; vTop(0,0)=[] rTop(1,2)=[102:%QBETA$16*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $ModuleItem:"--no{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--workspace{"} 
   ;; Qgen: 
   ;; ModuleItem:gen workspace 
   ;; $obj:"workspace: obj {   %id "workspace";   %include BETA, LIB, LIB.BasicIO, qbeta;   %domain_boundary;   --AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMu ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMultiCore;--CAStes ..."} 
   ;; Qgen:OGid:"workspace" singular! staticOff=5 descNo=17 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; before objTmpStack:add:  17   "workspace" 
   ;; OGid: workspace  OGidWdNo:  workspace$17 
;; invoke workspace 17 5 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ;; alloc %workspace$17
   %R121 = tail call i8* @malloc(i64 12)
   %R122 = bitcast i8* %R121 to %workspace$17*
   ;; store VDT in object
   %R123 = getelementptr %workspace$17, %workspace$17* %R122, i32 0, i32 0
   store %vdt_type$workspace$17* @vdt_data$workspace$17, %vdt_type$workspace$17** %R123
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 122 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: workspace$17 this: workspace$17 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 workspace$17 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,122:%workspace$17]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETAworld$1*,122:%workspace$17]
   %R124 = getelementptr %workspace$17, %workspace$17 * %R122, i32 0, i32 1
   store %BETAworld$1* %R0, %BETAworld$1** %R124
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[122:%workspace$17,0:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 122 
   ;; vTop(0,0)=[] rTop(1,2)=[122:%workspace$17]
   ;; topSuper: 17   workspace$17 
   ;; save object: %workspace$17* dstType: %workspace$17*
   %R125 = getelementptr %BETAworld$1,%BETAworld$1* %R0, i32 0, i32 5
   store %workspace$17* %R122,  %workspace$17** %R125
   %R126 = call %workspace$17* @workspace$17(%workspace$17 * %R122)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 122 
   %V129 = icmp eq %workspace$17* %R126, %R122
   br i1 %V129, label %normalRtnLab127, label %breakLab128
breakLab128:
   %R130 = bitcast %workspace$17* %R126 to %BETAworld$1*
   %V131 = icmp eq %BETAworld$1* %R0, %R130
   br i1 %V131, label %selectBreakLab133, label %contBreakLab132
contBreakLab132:
   ret %BETAworld$1* %R130
selectBreakLab133:
   %R134 = bitcast %workspace$17* %R126 to [0 x i32]*
   %R135 = getelementptr [0 x i32], [0 x i32]* %R134, i32 0, i32 0
   %V136 = load i32 , i32* %R135
   %R137 = getelementptr %workspace$17,%workspace$17* %R126, i32 0, i32 0
   store %vdt_type$workspace$17* @vdt_data$workspace$17, %vdt_type$workspace$17** %R137
   %V138 = icmp eq i32 1, %V136
   br i1 %V138, label %X139, label %X140
X139:
   br label %L1 ; restart
X140:
   br label %L2 ; leave
normalRtnLab127:

   ;; vTop(0,0)=[] rTop(1,2)=[122:%workspace$17*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "BETAworld"" 
   ;; $Property:"%id "BETAworld"" 
   ;; Qgen: 
   ;; genclass:stmt: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" 
   ;; $Property:"%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "BETAworld" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETAworld$1* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETAworld$1*]
   ret %BETAworld$1* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 1:I
@vdt_data$BETAworld$1 = global %vdt_type$BETAworld$1 {
      %BETAworld$1*(%BETAworld$1*)* @BETAworld$1
}

define %vdt_ret$BETAworld$1* @vdt_alloc$BETAworld$1(%Object$22* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$BETAworld$1
   %R142 = tail call i8* @malloc(i64 32)
   %R143 = bitcast i8* %R142 to %vdt_ret$BETAworld$1*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %BETAworld$1 
   ;; alloc %BETAworld$1
   %R144 = tail call i8* @malloc(i64 192)
   %R145 = bitcast i8* %R144 to %BETAworld$1*
   ;; store VDT in object
   %R146 = getelementptr %BETAworld$1, %BETAworld$1* %R145, i32 0, i32 0
   store %vdt_type$BETAworld$1* @vdt_data$BETAworld$1, %vdt_type$BETAworld$1** %R146
   %R147 = getelementptr %vdt_ret$BETAworld$1,%vdt_ret$BETAworld$1* %R143, i32 0, i32 0
   store %BETAworld$1* %R145, %BETAworld$1** %R147
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: Object thisClassOrgDescNo: 22 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 145 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Object$22*,145:%BETAworld$1]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: BETAworld 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BETAworld$1 this: BETAworld$1 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BETAworld$1 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Object$22*,145:%BETAworld$1]
   ;; lookup:  %Object$22*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Object$22*,145:%BETAworld$1]
   %R148 = getelementptr %BETAworld$1, %BETAworld$1 * %R145, i32 0, i32 1
   store %Object$22* %R1, %Object$22** %R148
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[145:%BETAworld$1,1:%Object$22*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 145 
   ;; vTop(0,0)=[] rTop(1,2)=[145:%BETAworld$1]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$BETAworld$1* %R143
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 2 :top: 1 
   ;; Items:GenClass: BETA descNo: 2 
;; class  BETA 2 1 BETAworld 1

define %BETA$2* @BETA$2(%BETA$2* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=2 vDescInx=2 vdtTop: 1
   ;; $Property:"%ID BETA" 
   ;; Qgen: 
   ;; $Property:"%OSDvisibility disguised" 
   ;; Qgen: 
   ;; $Property:"%module LIB, LIB.StringLib" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $obj:"ascii: obj {   nl: val 10;   cr: val 13;   newline: var char;   isLetter: ;      in ch: var char;      out B: var Boolean;      B := ((('a' <= ch) && (ch <= 'z')) || ..."} 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: false :primNo: 0 
   ;; OGqual: none :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; DI:add:BP4:  ascii 
   ;; $ObjectGenerator:"nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch  ..."} 
   ;; Qgen:OGid:"$S$3" singular! staticOff=2 descNo=3 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %BETA$2* 
   ;; before objTmpStack:add:  3   "$S$3" 
   ;; OGid: $S$3  OGidWdNo:  $S$3$3 
;; invoke $S$3 3 2 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%BETA$2*]
   ;; alloc %$S$3$3
   %R1 = tail call i8* @malloc(i64 20)
   %R2 = bitcast i8* %R1 to %$S$3$3*
   ;; store VDT in object
   %R3 = getelementptr %$S$3$3, %$S$3$3* %R2, i32 0, i32 0
   store %vdt_type$$S$3$3* @vdt_data$$S$3$3, %vdt_type$$S$3$3** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$3$3 this: $S$3$3 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$3$3 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETA$2*,2:%$S$3$3]
   ;; lookup:  %BETA$2*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BETA$2*,2:%$S$3$3]
   %R4 = getelementptr %$S$3$3, %$S$3$3 * %R2, i32 0, i32 1
   store %BETA$2* %R0, %BETA$2** %R4
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[2:%$S$3$3,0:%BETA$2*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,2)=[2:%$S$3$3]
   ;; topSuper: 3   $S$3$3 
   ;; save object: %$S$3$3* dstType: %$S$3$3*
   %R5 = getelementptr %BETA$2,%BETA$2* %R0, i32 0, i32 2
   store %$S$3$3* %R2,  %$S$3$3** %R5
   %R6 = call %$S$3$3* @$S$3$3(%$S$3$3 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   %V9 = icmp eq %$S$3$3* %R6, %R2
   br i1 %V9, label %normalRtnLab7, label %breakLab8
breakLab8:
   %R10 = bitcast %$S$3$3* %R6 to %BETA$2*
   %V11 = icmp eq %BETA$2* %R0, %R10
   br i1 %V11, label %selectBreakLab13, label %contBreakLab12
contBreakLab12:
   ret %BETA$2* %R10
selectBreakLab13:
   %R14 = bitcast %$S$3$3* %R6 to [0 x i32]*
   %R15 = getelementptr [0 x i32], [0 x i32]* %R14, i32 0, i32 0
   %V16 = load i32 , i32* %R15
   %R17 = getelementptr %$S$3$3,%$S$3$3* %R6, i32 0, i32 0
   store %vdt_type$$S$3$3* @vdt_data$$S$3$3, %vdt_type$$S$3$3** %R17
   %V18 = icmp eq i32 1, %V16
   br i1 %V18, label %X19, label %X20
X19:
   br label %L1 ; restart
X20:
   br label %L2 ; leave
normalRtnLab7:

   ;; vTop(0,0)=[] rTop(1,2)=[2:%$S$3$3*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $ModuleItem:"--doTest{"} 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%ID BETA" 
   ;; $Property:"%ID BETA" 
   ;; Qgen: 
   ;; genclass:stmt: "%OSDvisibility disguised" 
   ;; $Property:"%OSDvisibility disguised" 
   ;; Qgen: 
   ;; genclass:stmt: "%module LIB, LIB.StringLib" 
   ;; $Property:"%module LIB, LIB.StringLib" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "BETA" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BETA$2* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BETA$2*]
   ret %BETA$2* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 2:I
@vdt_data$BETA$2 = global %vdt_type$BETA$2 {
      %BETA$2*(%BETA$2*)* @BETA$2
}

define %vdt_ret$BETA$2* @vdt_alloc$BETA$2(%BETAworld$1* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$BETA$2
   %R22 = tail call i8* @malloc(i64 32)
   %R23 = bitcast i8* %R22 to %vdt_ret$BETA$2*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %BETA$2 
   ;; alloc %BETA$2
   %R24 = tail call i8* @malloc(i64 192)
   %R25 = bitcast i8* %R24 to %BETA$2*
   ;; store VDT in object
   %R26 = getelementptr %BETA$2, %BETA$2* %R25, i32 0, i32 0
   store %vdt_type$BETA$2* @vdt_data$BETA$2, %vdt_type$BETA$2** %R26
   %R27 = getelementptr %vdt_ret$BETA$2,%vdt_ret$BETA$2* %R23, i32 0, i32 0
   store %BETA$2* %R25, %BETA$2** %R27
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETAworld thisClassOrgDescNo: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 25 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,25:%BETA$2]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: BETA 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BETA$2 this: BETA$2 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BETA$2 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,25:%BETA$2]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,25:%BETA$2]
   %R28 = getelementptr %BETA$2, %BETA$2 * %R25, i32 0, i32 1
   store %BETAworld$1* %R1, %BETAworld$1** %R28
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[25:%BETA$2,1:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 25 
   ;; vTop(0,0)=[] rTop(1,2)=[25:%BETA$2]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$BETA$2* %R23
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 3 :top: 1 
   ;; Items:GenClass: $S$3 descNo: 3 
;; class  $S$3 3 1 BETA 2

define %$S$3$3* @$S$3$3(%$S$3$3* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=3 vDescInx=3 vdtTop: 1
   ;; $val:"nl: val 10" 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP2:  nl 
   ;; $ObjectGenerator:"10" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"10" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "10" 
   ;; needorigin: "10" 
   ;; needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "10" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "10" E:  "10" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "10" superAdj= 0 
   ;; $ConstLiteral:"10" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "10"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "10" 
   ;; $ConstLiteral:"10" 
   ;; >invoke: 
;; pushc 10
   %V1 = add i32 0, 10
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 0 V: 1 R: 
   ;; invoke:after:E.invoke: "10" 
   ;; dataItem:store:basicValue: off: 1  NewOff: 2 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 0 
   ;; %$S$3$3* 
;; storeg  $S$3$3 2
   %R2 = getelementptr %$S$3$3,%$S$3$3 *%R0, i32 0, i32 2
   store i32 %V1, i32* %R2
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 0 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 1 V: R: 
   ;; $val:"cr: val 13" 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP2:  cr 
   ;; $ObjectGenerator:"13" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"13" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "13" 
   ;; needorigin: "13" 
   ;; needOrigin:E: "13"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "13" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "13" E:  "13" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "13" superAdj= 0 
   ;; $ConstLiteral:"13" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "13"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "13" 
   ;; $ConstLiteral:"13" 
   ;; >invoke: 
;; pushc 13
   %V3 = add i32 0, 13
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 3 R: 
   ;; invoke:after:E.invoke: "13" 
   ;; dataItem:store:basicValue: off: 2  NewOff: 3 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 3 R: 0 
   ;; %$S$3$3* 
;; storeg  $S$3$3 3
   %R4 = getelementptr %$S$3$3,%$S$3$3 *%R0, i32 0, i32 3
   store i32 %V3, i32* %R4
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 0 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 1 V: R: 
   ;; $var:"newline: var char" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 3 
   ;; OGqual: "char" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  newline 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; $ObjectGenerator:"newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; not const:  newline newline: var char 
   ;; needorigin: "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; needOrigin:E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "newline := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; computeAdr: 1 :rec: "none"  E: "newline" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"newline" 
   ;; >pushThis: 
   ;; OI:pushThis: "nl: val 10{cr: val 13;newline: var char;isLetter: ;   in ch: var char;   out B: var Boolean;   B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= ' ...}" A ... "n ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$3$3* 
   ;; $ObjectInvocation_Unary:"newline" 
   ;; >loadOrigin::on:0 
   ;; AdjustOrigin:originOff: 0 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"newline" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"newline: var char" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"newline"}   newline: var char 
   ;; value_prim: false 
   ;; BTX: 6  OG.OGid:  char 
   ;; char 
   ;; before:floatTest:  "newline: var char" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; computeAdr: 2 :rec: "newline"  E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  A.E: "newline" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; computeAdr:isAssign:rec:  "newline"  E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; computeAdr:isLast:E:  ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; rec:  "newline" E:  ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; >loadArgs:staticOff:4 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>  hasArg:  pattern 
   ;; := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; ActArg:  "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; loadArgs:A: "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; $ObjectGenerator:"cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; const literal:  13   ConstLiteral 
;; pushc 13
   %V5 = add i32 0, 13
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 5 R: 0 
   ;; loadArgs:after:Qgen: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; end:loadArgs:NonVirt: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; IV:after:loadArgsOf: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline" ...}   ... false 
   ;; IV:E.invoke:useRTNv: false E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; $ObjectInvocation_Binary:":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; >invoke: rec:"newline" 
   ;; OI:invoke:isPtn: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; OI:invoke:B: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  rec: "newline"   ... false ": ..." 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "newline" from:  ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   ;; assign:dstDI : "newline: var char" isUnitValueObj:  false 
   ;; assign:arg:  "cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf> 
   ;;  arg.super.ATd: "Invocation" "cr: val 13" 
   ;;  arg.super.ATd.isDataItem: true  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "val" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"  rec:  "newline" "$S$3$3" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>"} 
   ;; store: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"newline"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  $S$3$3 4
   %R6 = getelementptr %$S$3$3,%$S$3$3 *%R0, i32 0, i32 4
   store i32 %V5, i32* %R6
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 0 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 1 V: R: 
   ;; OI:invoke: := cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf> :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= cr -- Windows:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygiwn default:<lf>" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$3$3* 
   ;; vTop(0,1)=[] rTop(1,1)=[0:%$S$3$3*]
   ret %$S$3$3* %R0   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 3:I
@vdt_data$$S$3$3 = global %vdt_type$$S$3$3 {
      %$S$3$3*(%$S$3$3*)* @$S$3$3
}

define %vdt_ret$$S$3$3* @vdt_alloc$$S$3$3(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$S$3$3
   %R8 = tail call i8* @malloc(i64 32)
   %R9 = bitcast i8* %R8 to %vdt_ret$$S$3$3*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$S$3$3 
   ;; alloc %$S$3$3
   %R10 = tail call i8* @malloc(i64 192)
   %R11 = bitcast i8* %R10 to %$S$3$3*
   ;; store VDT in object
   %R12 = getelementptr %$S$3$3, %$S$3$3* %R11, i32 0, i32 0
   store %vdt_type$$S$3$3* @vdt_data$$S$3$3, %vdt_type$$S$3$3** %R12
   %R13 = getelementptr %vdt_ret$$S$3$3,%vdt_ret$$S$3$3* %R9, i32 0, i32 0
   store %$S$3$3* %R11, %$S$3$3** %R13
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 2 V: R: 11 
   ;; vTop(0,1)=[] rTop(2,2)=[1:%BETA$2*,11:%$S$3$3]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: $S$3 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$3$3 this: $S$3$3 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$3$3 isValueObjectOrigin: F
   ;; vTop(0,1)=[] rTop(2,2)=[1:%BETA$2*,11:%$S$3$3]
   ;; lookup:  %BETA$2*
   ;; vTop(0,1)=[] rTop(2,2)=[1:%BETA$2*,11:%$S$3$3]
   %R14 = getelementptr %$S$3$3, %$S$3$3 * %R11, i32 0, i32 1
   store %BETA$2* %R1, %BETA$2** %R14
;; rswap  0
   ;; vTop(0,1)=[] rTop(2,2)=[11:%$S$3$3,1:%BETA$2*]
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 11 
   ;; vTop(0,1)=[] rTop(1,2)=[11:%$S$3$3]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$S$3$3* %R9
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 5 :top: 1 
   ;; Items:GenClass: Value descNo: 5 
;; class  Value 5 0 BETA 2 isValueObj

define %Value$5* @Value$5(%Value$5* %R0, i32 %off){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=5 vDescInx=5 vdtTop: 1
   ;; $Property:"%ID Value" 
   ;; Qgen: 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; $Property:"%basic 21" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%ID Value" 
   ;; $Property:"%ID Value" 
   ;; Qgen: 
   ;; genclass:stmt: "%globals" 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 21" 
   ;; $Property:"%basic 21" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "Value" 
   ;; vTop(0,0)=[] rTop(0,0)=[]
   ret %Value$5* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
}
   ;; vdt:vdtTop: 1 5:I
@vdt_data$Value$5 = global %vdt_type$Value$5 {
      %Value$5*(%Value$5*, i32)* @Value$5
}

define %vdt_ret$Value$5* @vdt_alloc$Value$5(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$Value$5
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$Value$5*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %Value$5 
   ;; alloc %Value$5
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %Value$5*
   ;; store VDT in object
   %R6 = getelementptr %Value$5, %Value$5* %R5, i32 0, i32 0
   store %vdt_type$Value$5* @vdt_data$Value$5, %vdt_type$Value$5** %R6
   %R7 = getelementptr %vdt_ret$Value$5,%vdt_ret$Value$5* %R3, i32 0, i32 0
   store %Value$5* %R5, %Value$5** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
;; rpush:rtop: 0
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,1)=[5:%Value$5]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: Value 
   ;; after:handleOrigins 
   ret %vdt_ret$Value$5* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 6 :top: 1 
   ;; Items:GenClass: char descNo: 6 
;; class  char 6 0 BETA 2 isValueObj

define %char$6* @char$6(%char$6* %R0, i32 %off){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=6 vDescInx=6 vdtTop: 1
   ;; $Property:"%id "char"" 
   ;; Qgen: 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; $Property:"%basic 3, 16" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"_thisBasicValue: var Universal" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "universal" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  _thisBasicValue 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "char"" 
   ;; $Property:"%id "char"" 
   ;; Qgen: 
   ;; genclass:stmt: "%globals" 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 3, 16" 
   ;; $Property:"%basic 3, 16" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "char" 
   ;; vTop(0,0)=[] rTop(0,0)=[]
   ret %char$6* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
}
   ;; vdt:vdtTop: 1 6:I
@vdt_data$char$6 = global %vdt_type$char$6 {
      %char$6*(%char$6*, i32)* @char$6
}

define %vdt_ret$char$6* @vdt_alloc$char$6(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$char$6
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$char$6*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %char$6 
   ;; alloc %char$6
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %char$6*
   ;; store VDT in object
   %R6 = getelementptr %char$6, %char$6* %R5, i32 0, i32 0
   store %vdt_type$char$6* @vdt_data$char$6, %vdt_type$char$6** %R6
   %R7 = getelementptr %vdt_ret$char$6,%vdt_ret$char$6* %R3, i32 0, i32 0
   store %char$6* %R5, %char$6** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
;; rpush:rtop: 0
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,1)=[5:%char$6]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: char 
   ;; after:handleOrigins 
   ret %vdt_ret$char$6* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 7 :top: 1 
   ;; Items:GenClass: universal descNo: 7 
;; class  universal 7 0 BETA 2 isValueObj

define %universal$7* @universal$7(%universal$7* %R0, i32 %off){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=7 vDescInx=7 vdtTop: 1
   ;; $Property:"%ID universal" 
   ;; Qgen: 
   ;; $Property:"%basic 1, 32" 
   ;; Qgen: 
   ;; $Property:"%globals" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%ID universal" 
   ;; $Property:"%ID universal" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 1, 32" 
   ;; $Property:"%basic 1, 32" 
   ;; Qgen: 
   ;; genclass:stmt: "%globals" 
   ;; $Property:"%globals" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "universal" 
   ;; vTop(0,0)=[] rTop(0,0)=[]
   ret %universal$7* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
}
   ;; vdt:vdtTop: 1 7:I
@vdt_data$universal$7 = global %vdt_type$universal$7 {
      %universal$7*(%universal$7*, i32)* @universal$7
}

define %vdt_ret$universal$7* @vdt_alloc$universal$7(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$universal$7
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$universal$7*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %universal$7 
   ;; alloc %universal$7
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %universal$7*
   ;; store VDT in object
   %R6 = getelementptr %universal$7, %universal$7* %R5, i32 0, i32 0
   store %vdt_type$universal$7* @vdt_data$universal$7, %vdt_type$universal$7** %R6
   %R7 = getelementptr %vdt_ret$universal$7,%vdt_ret$universal$7* %R3, i32 0, i32 0
   store %universal$7* %R5, %universal$7** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
;; rpush:rtop: 0
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,1)=[5:%universal$7]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: universal 
   ;; after:handleOrigins 
   ret %vdt_ret$universal$7* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 4 :top: 1 
   ;; Items:GenClass: := descNo: 4 
;; class  := 4 1 Value 5

define %_assign$4* @_assign$4(%_assign$4* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: true 
;; store 3 origin.valueOff
   ;; store:ignored 
;; store 2 origin.valueOff
   ;; store:ignored 
   ;; vdtAdd: inx=1 descInx=4 vDescInx=4 vdtTop: 1
   ;; $Property:"%basic 8" 
   ;; Qgen: 
   ;; $var:"in V: var Value{--inner(Value);"} 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: false :primNo: 21 
   ;; OGqual: "Value" :OGqual.isBasicValue: false :OGqual.isValueObj: true 
   ;; DI:add:BP4:  V 
   ;; inArg: in V: var Value{--inner(Value);} 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%basic 8" 
   ;; $Property:"%basic 8" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  ":=" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %_assign$4* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%_assign$4*]
   ret %_assign$4* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 4:I
@vdt_data$_assign$4 = global %vdt_type$_assign$4 {
      %_assign$4*(%_assign$4*)* @_assign$4
}

define %vdt_ret$_assign$4* @vdt_alloc$_assign$4(%Value$5* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$_assign$4
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$_assign$4*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %_assign$4 
   ;; alloc %_assign$4
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %_assign$4*
   ;; store VDT in object
   %R6 = getelementptr %_assign$4, %_assign$4* %R5, i32 0, i32 0
   store %vdt_type$_assign$4* @vdt_data$_assign$4, %vdt_type$_assign$4** %R6
   %R7 = getelementptr %vdt_ret$_assign$4,%vdt_ret$_assign$4* %R3, i32 0, i32 0
   store %_assign$4* %R5, %_assign$4** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: Value thisClassOrgDescNo: 5 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Value$5*,5:%_assign$4]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: := 
   ;; after:handleOrigins 
   ret %vdt_ret$_assign$4* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 8 :top: 1 
   ;; Items:GenClass: LIB descNo: 8 
;; class  LIB 8 1 BETAworld 1

define %LIB$8* @LIB$8(%LIB$8* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=8 vDescInx=8 vdtTop: 1
   ;; $Property:"%id "LIB"" 
   ;; Qgen: 
   ;; $Property:"%module BETA" 
   ;; Qgen: 
   ;; Module:genMI:  "BasicIO" 
   ;; $obj:"BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;     ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop ..."} 
   ;; Qgen:OGid:"BasicIO" singular! staticOff=3 descNo=10 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %LIB$8* 
   ;; before objTmpStack:add:  10   "BasicIO" 
   ;; OGid: BasicIO  OGidWdNo:  BasicIO$10 
;; invoke BasicIO 10 3 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%LIB$8*]
   ;; alloc %BasicIO$10
   %R1 = tail call i8* @malloc(i64 16)
   %R2 = bitcast i8* %R1 to %BasicIO$10*
   ;; store VDT in object
   %R3 = getelementptr %BasicIO$10, %BasicIO$10* %R2, i32 0, i32 0
   store %vdt_type$BasicIO$10* @vdt_data$BasicIO$10, %vdt_type$BasicIO$10** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BasicIO$10 this: BasicIO$10 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BasicIO$10 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,2:%BasicIO$10]
   ;; lookup:  %LIB$8*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,2:%BasicIO$10]
   %R4 = getelementptr %BasicIO$10, %BasicIO$10 * %R2, i32 0, i32 1
   store %LIB$8* %R0, %LIB$8** %R4
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[2:%BasicIO$10,0:%LIB$8*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,2)=[2:%BasicIO$10]
   ;; topSuper: 10   BasicIO$10 
   ;; save object: %BasicIO$10* dstType: %BasicIO$10*
   %R5 = getelementptr %LIB$8,%LIB$8* %R0, i32 0, i32 3
   store %BasicIO$10* %R2,  %BasicIO$10** %R5
   %R6 = call %BasicIO$10* @BasicIO$10(%BasicIO$10 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   %V9 = icmp eq %BasicIO$10* %R6, %R2
   br i1 %V9, label %normalRtnLab7, label %breakLab8
breakLab8:
   %R10 = bitcast %BasicIO$10* %R6 to %LIB$8*
   %V11 = icmp eq %LIB$8* %R0, %R10
   br i1 %V11, label %selectBreakLab13, label %contBreakLab12
contBreakLab12:
   ret %LIB$8* %R10
selectBreakLab13:
   %R14 = bitcast %BasicIO$10* %R6 to [0 x i32]*
   %R15 = getelementptr [0 x i32], [0 x i32]* %R14, i32 0, i32 0
   %V16 = load i32 , i32* %R15
   %R17 = getelementptr %BasicIO$10,%BasicIO$10* %R6, i32 0, i32 0
   store %vdt_type$BasicIO$10* @vdt_data$BasicIO$10, %vdt_type$BasicIO$10** %R17
   %V18 = icmp eq i32 1, %V16
   br i1 %V18, label %X19, label %X20
X19:
   br label %L1 ; restart
X20:
   br label %L2 ; leave
normalRtnLab7:

   ;; vTop(0,0)=[] rTop(1,2)=[2:%BasicIO$10*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; Module:genMI:  "StringLib" 
   ;; $obj:"StringLib: obj {   %id "String module";   %module LIB;   %public;   String: ;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %immutabl ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;    ..."} 
   ;; Qgen:OGid:"StringLib" singular! staticOff=4 descNo=14 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %LIB$8* 
   ;; before objTmpStack:add:  14   "StringLib" 
   ;; OGid: StringLib  OGidWdNo:  StringLib$14 
;; invoke StringLib 14 4 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%LIB$8*]
   ;; alloc %StringLib$14
   %R21 = tail call i8* @malloc(i64 8)
   %R22 = bitcast i8* %R21 to %StringLib$14*
   ;; store VDT in object
   %R23 = getelementptr %StringLib$14, %StringLib$14* %R22, i32 0, i32 0
   store %vdt_type$StringLib$14* @vdt_data$StringLib$14, %vdt_type$StringLib$14** %R23
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 22 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: StringLib$14 this: StringLib$14 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 StringLib$14 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,22:%StringLib$14]
   ;; lookup:  %LIB$8*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,22:%StringLib$14]
   %R24 = getelementptr %StringLib$14, %StringLib$14 * %R22, i32 0, i32 1
   store %LIB$8* %R0, %LIB$8** %R24
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[22:%StringLib$14,0:%LIB$8*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 22 
   ;; vTop(0,0)=[] rTop(1,2)=[22:%StringLib$14]
   ;; topSuper: 14   StringLib$14 
   ;; save object: %StringLib$14* dstType: %StringLib$14*
   %R25 = getelementptr %LIB$8,%LIB$8* %R0, i32 0, i32 4
   store %StringLib$14* %R22,  %StringLib$14** %R25
   %R26 = call %StringLib$14* @StringLib$14(%StringLib$14 * %R22)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 22 
   %V29 = icmp eq %StringLib$14* %R26, %R22
   br i1 %V29, label %normalRtnLab27, label %breakLab28
breakLab28:
   %R30 = bitcast %StringLib$14* %R26 to %LIB$8*
   %V31 = icmp eq %LIB$8* %R0, %R30
   br i1 %V31, label %selectBreakLab33, label %contBreakLab32
contBreakLab32:
   ret %LIB$8* %R30
selectBreakLab33:
   %R34 = bitcast %StringLib$14* %R26 to [0 x i32]*
   %R35 = getelementptr [0 x i32], [0 x i32]* %R34, i32 0, i32 0
   %V36 = load i32 , i32* %R35
   %R37 = getelementptr %StringLib$14,%StringLib$14* %R26, i32 0, i32 0
   store %vdt_type$StringLib$14* @vdt_data$StringLib$14, %vdt_type$StringLib$14** %R37
   %V38 = icmp eq i32 1, %V36
   br i1 %V38, label %X39, label %X40
X39:
   br label %L1 ; restart
X40:
   br label %L2 ; leave
normalRtnLab27:

   ;; vTop(0,0)=[] rTop(1,2)=[22:%StringLib$14*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $Property:"%Include BETA" 
   ;; Qgen: 
   ;; $var:"x_dummy_LIB: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  x_dummy_LIB 
   ;; $ModuleItem:"--AgentSystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Associations{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--BasicIO{"} 
   ;; Qgen: 
   ;; ModuleItem:gen BasicIO 
   ;; $obj:"BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;     ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop ..."} 
   ;; Qgen:OGid:"BasicIO" singular! staticOff=3 descNo=10 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %LIB$8* 
   ;; before objTmpStack:add:  10   "BasicIO" 
   ;; OGid: BasicIO  OGidWdNo:  BasicIO$10 
;; invoke BasicIO 10 3 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%LIB$8*]
   ;; alloc %BasicIO$10
   %R41 = tail call i8* @malloc(i64 16)
   %R42 = bitcast i8* %R41 to %BasicIO$10*
   ;; store VDT in object
   %R43 = getelementptr %BasicIO$10, %BasicIO$10* %R42, i32 0, i32 0
   store %vdt_type$BasicIO$10* @vdt_data$BasicIO$10, %vdt_type$BasicIO$10** %R43
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 42 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BasicIO$10 this: BasicIO$10 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BasicIO$10 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,42:%BasicIO$10]
   ;; lookup:  %LIB$8*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,42:%BasicIO$10]
   %R44 = getelementptr %BasicIO$10, %BasicIO$10 * %R42, i32 0, i32 1
   store %LIB$8* %R0, %LIB$8** %R44
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[42:%BasicIO$10,0:%LIB$8*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 42 
   ;; vTop(0,0)=[] rTop(1,2)=[42:%BasicIO$10]
   ;; topSuper: 10   BasicIO$10 
   ;; save object: %BasicIO$10* dstType: %BasicIO$10*
   %R45 = getelementptr %LIB$8,%LIB$8* %R0, i32 0, i32 3
   store %BasicIO$10* %R42,  %BasicIO$10** %R45
   %R46 = call %BasicIO$10* @BasicIO$10(%BasicIO$10 * %R42)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 42 
   %V49 = icmp eq %BasicIO$10* %R46, %R42
   br i1 %V49, label %normalRtnLab47, label %breakLab48
breakLab48:
   %R50 = bitcast %BasicIO$10* %R46 to %LIB$8*
   %V51 = icmp eq %LIB$8* %R0, %R50
   br i1 %V51, label %selectBreakLab53, label %contBreakLab52
contBreakLab52:
   ret %LIB$8* %R50
selectBreakLab53:
   %R54 = bitcast %BasicIO$10* %R46 to [0 x i32]*
   %R55 = getelementptr [0 x i32], [0 x i32]* %R54, i32 0, i32 0
   %V56 = load i32 , i32* %R55
   %R57 = getelementptr %BasicIO$10,%BasicIO$10* %R46, i32 0, i32 0
   store %vdt_type$BasicIO$10* @vdt_data$BasicIO$10, %vdt_type$BasicIO$10** %R57
   %V58 = icmp eq i32 1, %V56
   br i1 %V58, label %X59, label %X60
X59:
   br label %L1 ; restart
X60:
   br label %L2 ; leave
normalRtnLab47:

   ;; vTop(0,0)=[] rTop(1,2)=[42:%BasicIO$10*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $ModuleItem:"--BasicSystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--COsystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Compiler{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Complex{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Containers{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Dimensions{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--EMC2array{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Embedded{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--FileSys{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ForkJoinSystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--MetaSystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--MonitorSystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--NonBlockingIO{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--SimpleConcurrentProcesses{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Socket{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--SocketSystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--StringLib{"} 
   ;; Qgen: 
   ;; ModuleItem:gen StringLib 
   ;; $obj:"StringLib: obj {   %id "String module";   %module LIB;   %public;   String: ;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %immutabl ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%id "String module"{%module LIB;%public;String: ;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;    ..."} 
   ;; Qgen:OGid:"StringLib" singular! staticOff=4 descNo=14 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %LIB$8* 
   ;; before objTmpStack:add:  14   "StringLib" 
   ;; OGid: StringLib  OGidWdNo:  StringLib$14 
;; invoke StringLib 14 4 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%LIB$8*]
   ;; alloc %StringLib$14
   %R61 = tail call i8* @malloc(i64 8)
   %R62 = bitcast i8* %R61 to %StringLib$14*
   ;; store VDT in object
   %R63 = getelementptr %StringLib$14, %StringLib$14* %R62, i32 0, i32 0
   store %vdt_type$StringLib$14* @vdt_data$StringLib$14, %vdt_type$StringLib$14** %R63
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 62 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: StringLib$14 this: StringLib$14 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 StringLib$14 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,62:%StringLib$14]
   ;; lookup:  %LIB$8*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LIB$8*,62:%StringLib$14]
   %R64 = getelementptr %StringLib$14, %StringLib$14 * %R62, i32 0, i32 1
   store %LIB$8* %R0, %LIB$8** %R64
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[62:%StringLib$14,0:%LIB$8*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 62 
   ;; vTop(0,0)=[] rTop(1,2)=[62:%StringLib$14]
   ;; topSuper: 14   StringLib$14 
   ;; save object: %StringLib$14* dstType: %StringLib$14*
   %R65 = getelementptr %LIB$8,%LIB$8* %R0, i32 0, i32 4
   store %StringLib$14* %R62,  %StringLib$14** %R65
   %R66 = call %StringLib$14* @StringLib$14(%StringLib$14 * %R62)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 62 
   %V69 = icmp eq %StringLib$14* %R66, %R62
   br i1 %V69, label %normalRtnLab67, label %breakLab68
breakLab68:
   %R70 = bitcast %StringLib$14* %R66 to %LIB$8*
   %V71 = icmp eq %LIB$8* %R0, %R70
   br i1 %V71, label %selectBreakLab73, label %contBreakLab72
contBreakLab72:
   ret %LIB$8* %R70
selectBreakLab73:
   %R74 = bitcast %StringLib$14* %R66 to [0 x i32]*
   %R75 = getelementptr [0 x i32], [0 x i32]* %R74, i32 0, i32 0
   %V76 = load i32 , i32* %R75
   %R77 = getelementptr %StringLib$14,%StringLib$14* %R66, i32 0, i32 0
   store %vdt_type$StringLib$14* @vdt_data$StringLib$14, %vdt_type$StringLib$14** %R77
   %V78 = icmp eq i32 1, %V76
   br i1 %V78, label %X79, label %X80
X79:
   br label %L1 ; restart
X80:
   br label %L2 ; leave
normalRtnLab67:

   ;; vTop(0,0)=[] rTop(1,2)=[62:%StringLib$14*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $ModuleItem:"--Units{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Xarray{"} 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "LIB"" 
   ;; $Property:"%id "LIB"" 
   ;; Qgen: 
   ;; genclass:stmt: "%module BETA" 
   ;; $Property:"%module BETA" 
   ;; Qgen: 
   ;; genclass:stmt: "%Include BETA" 
   ;; $Property:"%Include BETA" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "LIB" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %LIB$8* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%LIB$8*]
   ret %LIB$8* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 8:I
@vdt_data$LIB$8 = global %vdt_type$LIB$8 {
      %LIB$8*(%LIB$8*)* @LIB$8
}

define %vdt_ret$LIB$8* @vdt_alloc$LIB$8(%BETAworld$1* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$LIB$8
   %R82 = tail call i8* @malloc(i64 32)
   %R83 = bitcast i8* %R82 to %vdt_ret$LIB$8*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %LIB$8 
   ;; alloc %LIB$8
   %R84 = tail call i8* @malloc(i64 192)
   %R85 = bitcast i8* %R84 to %LIB$8*
   ;; store VDT in object
   %R86 = getelementptr %LIB$8, %LIB$8* %R85, i32 0, i32 0
   store %vdt_type$LIB$8* @vdt_data$LIB$8, %vdt_type$LIB$8** %R86
   %R87 = getelementptr %vdt_ret$LIB$8,%vdt_ret$LIB$8* %R83, i32 0, i32 0
   store %LIB$8* %R85, %LIB$8** %R87
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETAworld thisClassOrgDescNo: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 85 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,85:%LIB$8]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: LIB 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: LIB$8 this: LIB$8 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 LIB$8 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,85:%LIB$8]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,85:%LIB$8]
   %R88 = getelementptr %LIB$8, %LIB$8 * %R85, i32 0, i32 1
   store %BETAworld$1* %R1, %BETAworld$1** %R88
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[85:%LIB$8,1:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 85 
   ;; vTop(0,0)=[] rTop(1,2)=[85:%LIB$8]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$LIB$8* %R83
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 9 :top: 1 
   ;; Items:GenClass: integer descNo: 9 
;; class  integer 9 0 BETA 2 isValueObj

define %integer$9* @integer$9(%integer$9* %R0, i32 %off){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=9 vDescInx=9 vdtTop: 1
   ;; $Property:"%ID integer" 
   ;; Qgen: 
   ;; $Property:"%basic 1, 32" 
   ;; Qgen: 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"_thisBasicValue: var Universal" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "universal" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  _thisBasicValue 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%ID integer" 
   ;; $Property:"%ID integer" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 1, 32" 
   ;; $Property:"%basic 1, 32" 
   ;; Qgen: 
   ;; genclass:stmt: "%globals" 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "integer" 
   ;; vTop(0,0)=[] rTop(0,0)=[]
   ret %integer$9* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
}
   ;; vdt:vdtTop: 1 9:I
@vdt_data$integer$9 = global %vdt_type$integer$9 {
      %integer$9*(%integer$9*, i32)* @integer$9
}

define %vdt_ret$integer$9* @vdt_alloc$integer$9(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$integer$9
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$integer$9*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %integer$9 
   ;; alloc %integer$9
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %integer$9*
   ;; store VDT in object
   %R6 = getelementptr %integer$9, %integer$9* %R5, i32 0, i32 0
   store %vdt_type$integer$9* @vdt_data$integer$9, %vdt_type$integer$9** %R6
   %R7 = getelementptr %vdt_ret$integer$9,%vdt_ret$integer$9* %R3, i32 0, i32 0
   store %integer$9* %R5, %integer$9** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
;; rpush:rtop: 0
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,1)=[5:%integer$9]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: integer 
   ;; after:handleOrigins 
   ret %vdt_ret$integer$9* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 10 :top: 1 
   ;; Items:GenClass: BasicIO descNo: 10 
;; class  BasicIO 10 1 LIB 8

define %BasicIO$10* @BasicIO$10(%BasicIO$10* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=10 vDescInx=10 vdtTop: 1
   ;; $Property:"%module LIB.StringLib" 
   ;; Qgen: 
   ;; $Property:"%Public" 
   ;; Qgen: 
   ;; $obj:"keyboard: obj {   %Public;   readLine: ;      out M: ref LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: ..."} 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: false :primNo: 0 
   ;; OGqual: none :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; DI:add:BP4:  keyboard 
   ;; $ObjectGenerator:"%Public{readLine: ;   out M: ref LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _i ..."} 
   ;; Qgen:OGid:"$S$11" singular! staticOff=2 descNo=11 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %BasicIO$10* 
   ;; before objTmpStack:add:  11   "$S$11" 
   ;; OGid: $S$11  OGidWdNo:  $S$11$11 
;; invoke $S$11 11 2 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%BasicIO$10*]
   ;; alloc %$S$11$11
   %R1 = tail call i8* @malloc(i64 8)
   %R2 = bitcast i8* %R1 to %$S$11$11*
   ;; store VDT in object
   %R3 = getelementptr %$S$11$11, %$S$11$11* %R2, i32 0, i32 0
   store %vdt_type$$S$11$11* @vdt_data$$S$11$11, %vdt_type$$S$11$11** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$11$11 this: $S$11$11 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$11$11 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BasicIO$10*,2:%$S$11$11]
   ;; lookup:  %BasicIO$10*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BasicIO$10*,2:%$S$11$11]
   %R4 = getelementptr %$S$11$11, %$S$11$11 * %R2, i32 0, i32 1
   store %BasicIO$10* %R0, %BasicIO$10** %R4
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[2:%$S$11$11,0:%BasicIO$10*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,2)=[2:%$S$11$11]
   ;; topSuper: 11   $S$11$11 
   ;; save object: %$S$11$11* dstType: %$S$11$11*
   %R5 = getelementptr %BasicIO$10,%BasicIO$10* %R0, i32 0, i32 2
   store %$S$11$11* %R2,  %$S$11$11** %R5
   %R6 = call %$S$11$11* @$S$11$11(%$S$11$11 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   %V9 = icmp eq %$S$11$11* %R6, %R2
   br i1 %V9, label %normalRtnLab7, label %breakLab8
breakLab8:
   %R10 = bitcast %$S$11$11* %R6 to %BasicIO$10*
   %V11 = icmp eq %BasicIO$10* %R0, %R10
   br i1 %V11, label %selectBreakLab13, label %contBreakLab12
contBreakLab12:
   ret %BasicIO$10* %R10
selectBreakLab13:
   %R14 = bitcast %$S$11$11* %R6 to [0 x i32]*
   %R15 = getelementptr [0 x i32], [0 x i32]* %R14, i32 0, i32 0
   %V16 = load i32 , i32* %R15
   %R17 = getelementptr %$S$11$11,%$S$11$11* %R6, i32 0, i32 0
   store %vdt_type$$S$11$11* @vdt_data$$S$11$11, %vdt_type$$S$11$11** %R17
   %V18 = icmp eq i32 1, %V16
   br i1 %V18, label %X19, label %X20
X19:
   br label %L1 ; restart
X20:
   br label %L2 ; leave
normalRtnLab7:

   ;; vTop(0,0)=[] rTop(1,2)=[2:%$S$11$11*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; $obj:"screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free"} 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: false :primNo: 0 
   ;; OGqual: none :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; DI:add:BP4:  screen 
   ;; $ObjectGenerator:"L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free"} 
   ;; Qgen:OGid:"$S$12" singular! staticOff=3 descNo=12 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BasicIO$10* 
   ;; before objTmpStack:add:  12   "$S$12" 
   ;; OGid: $S$12  OGidWdNo:  $S$12$12 
;; invoke $S$12 12 3 1
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BasicIO$10*]
   ;; alloc %$S$12$12
   %R21 = tail call i8* @malloc(i64 12)
   %R22 = bitcast i8* %R21 to %$S$12$12*
   ;; store VDT in object
   %R23 = getelementptr %$S$12$12, %$S$12$12* %R22, i32 0, i32 0
   store %vdt_type$$S$12$12* @vdt_data$$S$12$12, %vdt_type$$S$12$12** %R23
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 22 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$12$12 this: $S$12$12 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$12$12 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BasicIO$10*,22:%$S$12$12]
   ;; lookup:  %BasicIO$10*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%BasicIO$10*,22:%$S$12$12]
   %R24 = getelementptr %$S$12$12, %$S$12$12 * %R22, i32 0, i32 1
   store %BasicIO$10* %R0, %BasicIO$10** %R24
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[22:%$S$12$12,0:%BasicIO$10*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 22 
   ;; vTop(0,0)=[] rTop(1,2)=[22:%$S$12$12]
   ;; topSuper: 12   $S$12$12 
   ;; save object: %$S$12$12* dstType: %$S$12$12*
   %R25 = getelementptr %BasicIO$10,%BasicIO$10* %R0, i32 0, i32 3
   store %$S$12$12* %R22,  %$S$12$12** %R25
   %R26 = call %$S$12$12* @$S$12$12(%$S$12$12 * %R22)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 22 
   %V29 = icmp eq %$S$12$12* %R26, %R22
   br i1 %V29, label %normalRtnLab27, label %breakLab28
breakLab28:
   %R30 = bitcast %$S$12$12* %R26 to %BasicIO$10*
   %V31 = icmp eq %BasicIO$10* %R0, %R30
   br i1 %V31, label %selectBreakLab33, label %contBreakLab32
contBreakLab32:
   ret %BasicIO$10* %R30
selectBreakLab33:
   %R34 = bitcast %$S$12$12* %R26 to [0 x i32]*
   %R35 = getelementptr [0 x i32], [0 x i32]* %R34, i32 0, i32 0
   %V36 = load i32 , i32* %R35
   %R37 = getelementptr %$S$12$12,%$S$12$12* %R26, i32 0, i32 0
   store %vdt_type$$S$12$12* @vdt_data$$S$12$12, %vdt_type$$S$12$12** %R37
   %V38 = icmp eq i32 1, %V36
   br i1 %V38, label %X39, label %X40
X39:
   br label %L1 ; restart
X40:
   br label %L2 ; leave
normalRtnLab27:

   ;; vTop(0,0)=[] rTop(1,2)=[22:%$S$12$12*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%module LIB.StringLib" 
   ;; $Property:"%module LIB.StringLib" 
   ;; Qgen: 
   ;; genclass:stmt: "%Public" 
   ;; $Property:"%Public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "BasicIO" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %BasicIO$10* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%BasicIO$10*]
   ret %BasicIO$10* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 10:I
@vdt_data$BasicIO$10 = global %vdt_type$BasicIO$10 {
      %BasicIO$10*(%BasicIO$10*)* @BasicIO$10
}

define %vdt_ret$BasicIO$10* @vdt_alloc$BasicIO$10(%LIB$8* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$BasicIO$10
   %R42 = tail call i8* @malloc(i64 32)
   %R43 = bitcast i8* %R42 to %vdt_ret$BasicIO$10*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %BasicIO$10 
   ;; alloc %BasicIO$10
   %R44 = tail call i8* @malloc(i64 192)
   %R45 = bitcast i8* %R44 to %BasicIO$10*
   ;; store VDT in object
   %R46 = getelementptr %BasicIO$10, %BasicIO$10* %R45, i32 0, i32 0
   store %vdt_type$BasicIO$10* @vdt_data$BasicIO$10, %vdt_type$BasicIO$10** %R46
   %R47 = getelementptr %vdt_ret$BasicIO$10,%vdt_ret$BasicIO$10* %R43, i32 0, i32 0
   store %BasicIO$10* %R45, %BasicIO$10** %R47
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: LIB thisClassOrgDescNo: 8 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 45 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%LIB$8*,45:%BasicIO$10]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: BasicIO 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: BasicIO$10 this: BasicIO$10 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 BasicIO$10 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%LIB$8*,45:%BasicIO$10]
   ;; lookup:  %LIB$8*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%LIB$8*,45:%BasicIO$10]
   %R48 = getelementptr %BasicIO$10, %BasicIO$10 * %R45, i32 0, i32 1
   store %LIB$8* %R1, %LIB$8** %R48
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[45:%BasicIO$10,1:%LIB$8*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 45 
   ;; vTop(0,0)=[] rTop(1,2)=[45:%BasicIO$10]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$BasicIO$10* %R43
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 11 :top: 1 
   ;; Items:GenClass: $S$11 descNo: 11 
;; class  $S$11 11 1 BasicIO 10

define %$S$11$11* @$S$11$11(%$S$11$11* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=11 vDescInx=11 vdtTop: 1
   ;; $Property:"%Public" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%Public" 
   ;; $Property:"%Public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$11$11* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%$S$11$11*]
   ret %$S$11$11* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 11:I
@vdt_data$$S$11$11 = global %vdt_type$$S$11$11 {
      %$S$11$11*(%$S$11$11*)* @$S$11$11
}

define %vdt_ret$$S$11$11* @vdt_alloc$$S$11$11(%BasicIO$10* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$S$11$11
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$$S$11$11*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$S$11$11 
   ;; alloc %$S$11$11
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %$S$11$11*
   ;; store VDT in object
   %R6 = getelementptr %$S$11$11, %$S$11$11* %R5, i32 0, i32 0
   store %vdt_type$$S$11$11* @vdt_data$$S$11$11, %vdt_type$$S$11$11** %R6
   %R7 = getelementptr %vdt_ret$$S$11$11,%vdt_ret$$S$11$11* %R3, i32 0, i32 0
   store %$S$11$11* %R5, %$S$11$11** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BasicIO thisClassOrgDescNo: 10 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,5:%$S$11$11]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: $S$11 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$11$11 this: $S$11$11 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$11$11 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,5:%$S$11$11]
   ;; lookup:  %BasicIO$10*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,5:%$S$11$11]
   %R8 = getelementptr %$S$11$11, %$S$11$11 * %R5, i32 0, i32 1
   store %BasicIO$10* %R1, %BasicIO$10** %R8
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[5:%$S$11$11,1:%BasicIO$10*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%$S$11$11]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$S$11$11* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 12 :top: 1 
   ;; Items:GenClass: $S$12 descNo: 12 
;; class  $S$12 12 1 BasicIO 10

define %$S$12$12* @$S$12$12(%$S$12$12* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=12 vDescInx=12 vdtTop: 1
   ;; $obj:"L: obj Lock" 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: false :primNo: 0 
   ;; OGqual: "Lock" :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; DI:add:BP4:  L 
   ;; $ObjectGenerator:"Lock" 
   ;; Qgen:OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0 
   ;; OG:gen:super: "Lock" superDescNo: 13 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"Lock" 
   ;; Qgen: useRtnV:"False" descNo: 13 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "Lock" 
   ;; needorigin: "Lock" 
   ;; needOrigin:E: "Lock"  E.ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         di ...}" 
   ;; doNeedOrigin:Ex: "Lock" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "Lock" 
   ;; computeAdr: 1 :rec: "none"  E: "Lock" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"Lock" 
   ;; >pushThis: 
   ;; OI:pushThis: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" ATd: "Lock: {   dummy: var integer;   %Public;   M: var integ ...}" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$12$12* 
   ;; $ObjectInvocation_Unary:"Lock" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$12" newOriginOff: 1 origin: "BasicIO$10" 
   ;; NA: "Lock" origin: "$S$12$12" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$12$12 1
   ;; Rtype.rtop: "%$S$12$12*" typeInfo[rtop,off]=elmType: "%BasicIO$10*" 
   %R1 = getelementptr %$S$12$12,%$S$12$12 *%R0, i32 0, i32 1
   %R2 = load %BasicIO$10* , %BasicIO$10** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"Lock" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res : ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "Lock"  ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;        ...}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"} 
   ;; computeAdr:isLast:E:  "Lock" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"} 
   ;; rec:  "Lock" E:  "Lock" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "Lock" superAdj= 0 
   ;; $ObjectInvocation_Unary:"Lock" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; Lock   Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 1 ...} 
   ;; $pattern:"Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res : ..."} 
   ;; >loadArgs:E:"Lock":descNo:13:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "Lock" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "Lock" 
   ;; $ObjectInvocation_Unary:"Lock" 
   ;; >invoke: rec:"Lock" 
   ;; OI:invoke:isPtn: "Lock" descNo 13  useRTNv: false 
   ;; E.ATd:  "Lock" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"} 
   ;; OI:invoke:B: "Lock" E: "Lock"  rec: "Lock"  useRtnV: false "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var intege ...}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Lock"} 
   ;; $pattern:"Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res : ..."} 
   ;; >invoke:E: "Lock" useRTNv: "False" 
   ;; ptn:invoke: "Lock" E: "Lock" useRtnV: false 
   ;; Pattern:invoke:useRTNv: false descNo: 13  top: 1  rec: "Lock" 
   ;; ptn:invoke: useRtnV: false isValObj: false :rtnValObj: false : "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var in ...}" 
   ;; rec=E: true :rec: "Lock" 
   ;; before:invoke:useReturnValue:  false 
   ;; OGid: Lock  OGidWdNo:  Lock$13 
;; invoke Lock 13 2 1
   ;; vTop(0,0)=[] rTop(1,1)=[2:%BasicIO$10*]
   ;; alloc %Lock$13
   %R3 = tail call i8* @malloc(i64 16)
   %R4 = bitcast i8* %R3 to %Lock$13*
   ;; store VDT in object
   %R5 = getelementptr %Lock$13, %Lock$13* %R4, i32 0, i32 0
   store %vdt_type$Lock$13* @vdt_data$Lock$13, %vdt_type$Lock$13** %R5
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 4 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: Lock$13 this: Lock$13 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 Lock$13 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[2:%BasicIO$10*,4:%Lock$13]
   ;; lookup:  %BasicIO$10*
   ;; vTop(0,0)=[] rTop(2,2)=[2:%BasicIO$10*,4:%Lock$13]
   %R6 = getelementptr %Lock$13, %Lock$13 * %R4, i32 0, i32 1
   store %BasicIO$10* %R2, %BasicIO$10** %R6
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[4:%Lock$13,2:%BasicIO$10*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; vTop(0,0)=[] rTop(1,2)=[4:%Lock$13]
   ;; topSuper: 13   Lock$13 
   ;; save object: %Lock$13* dstType: %Lock$13*
   %R7 = getelementptr %$S$12$12,%$S$12$12* %R0, i32 0, i32 2
   store %Lock$13* %R4,  %Lock$13** %R7
   %R8 = call %Lock$13* @Lock$13(%Lock$13 * %R4)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   %V11 = icmp eq %Lock$13* %R8, %R4
   br i1 %V11, label %normalRtnLab9, label %breakLab10
breakLab10:
   %R12 = bitcast %Lock$13* %R8 to %$S$12$12*
   %V13 = icmp eq %$S$12$12* %R0, %R12
   br i1 %V13, label %selectBreakLab15, label %contBreakLab14
contBreakLab14:
   ret %$S$12$12* %R12
selectBreakLab15:
   %R16 = bitcast %Lock$13* %R8 to [0 x i32]*
   %R17 = getelementptr [0 x i32], [0 x i32]* %R16, i32 0, i32 0
   %V18 = load i32 , i32* %R17
   %R19 = getelementptr %Lock$13,%Lock$13* %R8, i32 0, i32 0
   store %vdt_type$Lock$13* @vdt_data$Lock$13, %vdt_type$Lock$13** %R19
   %V20 = icmp eq i32 1, %V18
   br i1 %V20, label %X21, label %X22
X21:
   br label %L1 ; restart
X22:
   br label %L2 ; leave
normalRtnLab9:

   ;; vTop(0,0)=[] rTop(1,2)=[4:%Lock$13*]
   ;; useRtnVal: false :isVal: false :rtnValObj: false :rec=E: true "Lock" 
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; OI:invoke: Lock :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "Lock" 
   ;; $Property:"%Public" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%Public" 
   ;; $Property:"%Public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %$S$12$12* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%$S$12$12*]
   ret %$S$12$12* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 12:I
@vdt_data$$S$12$12 = global %vdt_type$$S$12$12 {
      %$S$12$12*(%$S$12$12*)* @$S$12$12
}

define %vdt_ret$$S$12$12* @vdt_alloc$$S$12$12(%BasicIO$10* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$S$12$12
   %R24 = tail call i8* @malloc(i64 32)
   %R25 = bitcast i8* %R24 to %vdt_ret$$S$12$12*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$S$12$12 
   ;; alloc %$S$12$12
   %R26 = tail call i8* @malloc(i64 192)
   %R27 = bitcast i8* %R26 to %$S$12$12*
   ;; store VDT in object
   %R28 = getelementptr %$S$12$12, %$S$12$12* %R27, i32 0, i32 0
   store %vdt_type$$S$12$12* @vdt_data$$S$12$12, %vdt_type$$S$12$12** %R28
   %R29 = getelementptr %vdt_ret$$S$12$12,%vdt_ret$$S$12$12* %R25, i32 0, i32 0
   store %$S$12$12* %R27, %$S$12$12** %R29
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BasicIO thisClassOrgDescNo: 10 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 27 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,27:%$S$12$12]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: $S$12 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$12$12 this: $S$12$12 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$12$12 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,27:%$S$12$12]
   ;; lookup:  %BasicIO$10*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,27:%$S$12$12]
   %R30 = getelementptr %$S$12$12, %$S$12$12 * %R27, i32 0, i32 1
   store %BasicIO$10* %R1, %BasicIO$10** %R30
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[27:%$S$12$12,1:%BasicIO$10*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 27 
   ;; vTop(0,0)=[] rTop(1,2)=[27:%$S$12$12]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$S$12$12* %R25
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 13 :top: 1 
   ;; Items:GenClass: Lock descNo: 13 
;; class  Lock 13 1 BasicIO 10

define %Lock$13* @Lock$13(%Lock$13* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=13 vDescInx=13 vdtTop: 1
   ;; $var:"dummy: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  dummy 
   ;; $Property:"%Public" 
   ;; Qgen: 
   ;; $var:"M: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  M 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%Public" 
   ;; $Property:"%Public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "Lock" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %Lock$13* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%Lock$13*]
   ret %Lock$13* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 13:I
@vdt_data$Lock$13 = global %vdt_type$Lock$13 {
      %Lock$13*(%Lock$13*)* @Lock$13
}

define %vdt_ret$Lock$13* @vdt_alloc$Lock$13(%BasicIO$10* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$Lock$13
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$Lock$13*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %Lock$13 
   ;; alloc %Lock$13
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %Lock$13*
   ;; store VDT in object
   %R6 = getelementptr %Lock$13, %Lock$13* %R5, i32 0, i32 0
   store %vdt_type$Lock$13* @vdt_data$Lock$13, %vdt_type$Lock$13** %R6
   %R7 = getelementptr %vdt_ret$Lock$13,%vdt_ret$Lock$13* %R3, i32 0, i32 0
   store %Lock$13* %R5, %Lock$13** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BasicIO thisClassOrgDescNo: 10 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,5:%Lock$13]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: Lock 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: Lock$13 this: Lock$13 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 Lock$13 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,5:%Lock$13]
   ;; lookup:  %BasicIO$10*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BasicIO$10*,5:%Lock$13]
   %R8 = getelementptr %Lock$13, %Lock$13 * %R5, i32 0, i32 1
   store %BasicIO$10* %R1, %BasicIO$10** %R8
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[5:%Lock$13,1:%BasicIO$10*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%Lock$13]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$Lock$13* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 14 :top: 1 
   ;; Items:GenClass: StringLib descNo: 14 
;; class  StringLib 14 1 LIB 8

define %StringLib$14* @StringLib$14(%StringLib$14* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=14 vDescInx=14 vdtTop: 1
   ;; saveStringOrigin
   ;; $Property:"%id "String module"" 
   ;; Qgen: 
   ;; $Property:"%module LIB" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $pattern:"String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @get: ..."} 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "String module"" 
   ;; $Property:"%id "String module"" 
   ;; Qgen: 
   ;; genclass:stmt: "%module LIB" 
   ;; $Property:"%module LIB" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "StringLib" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %StringLib$14* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%StringLib$14*]
   ret %StringLib$14* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 14:I
@vdt_data$StringLib$14 = global %vdt_type$StringLib$14 {
      %StringLib$14*(%StringLib$14*)* @StringLib$14
}

define %vdt_ret$StringLib$14* @vdt_alloc$StringLib$14(%LIB$8* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$StringLib$14
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$StringLib$14*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %StringLib$14 
   ;; alloc %StringLib$14
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %StringLib$14*
   ;; store VDT in object
   %R6 = getelementptr %StringLib$14, %StringLib$14* %R5, i32 0, i32 0
   store %vdt_type$StringLib$14* @vdt_data$StringLib$14, %vdt_type$StringLib$14** %R6
   %R7 = getelementptr %vdt_ret$StringLib$14,%vdt_ret$StringLib$14* %R3, i32 0, i32 0
   store %StringLib$14* %R5, %StringLib$14** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: LIB thisClassOrgDescNo: 8 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%LIB$8*,5:%StringLib$14]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: StringLib 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: StringLib$14 this: StringLib$14 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 StringLib$14 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%LIB$8*,5:%StringLib$14]
   ;; lookup:  %LIB$8*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%LIB$8*,5:%StringLib$14]
   %R8 = getelementptr %StringLib$14, %StringLib$14 * %R5, i32 0, i32 1
   store %LIB$8* %R1, %LIB$8** %R8
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[5:%StringLib$14,1:%LIB$8*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%StringLib$14]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$StringLib$14* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 15 :top: 1 
   ;; Items:GenClass: String descNo: 15 
;; class  String 15 1 StringLib 14

define %String$15* @String$15(%String$15* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=15 vDescInx=15 vdtTop: 1
   ;; $Property:"%id "String pattern"" 
   ;; Qgen: 
   ;; $Property:"%OSDvisibility disguised" 
   ;; Qgen: 
   ;; $Property:"%basic 5" 
   ;; Qgen: 
   ;; $Property:"%immutable" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "String pattern"" 
   ;; $Property:"%id "String pattern"" 
   ;; Qgen: 
   ;; genclass:stmt: "%OSDvisibility disguised" 
   ;; $Property:"%OSDvisibility disguised" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 5" 
   ;; $Property:"%basic 5" 
   ;; Qgen: 
   ;; genclass:stmt: "%immutable" 
   ;; $Property:"%immutable" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "String" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %String$15* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%String$15*]
   ret %String$15* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 15:I
@vdt_data$String$15 = global %vdt_type$String$15 {
      %String$15*(%String$15*)* @String$15
}

define %vdt_ret$String$15* @vdt_alloc$String$15(%StringLib$14* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$String$15
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$String$15*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %String$15 
   ;; alloc %String$15
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %String$15*
   ;; store VDT in object
   %R6 = getelementptr %String$15, %String$15* %R5, i32 0, i32 0
   store %vdt_type$String$15* @vdt_data$String$15, %vdt_type$String$15** %R6
   %R7 = getelementptr %vdt_ret$String$15,%vdt_ret$String$15* %R3, i32 0, i32 0
   store %String$15* %R5, %String$15** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: StringLib thisClassOrgDescNo: 14 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%StringLib$14*,5:%String$15]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: String 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: String$15 this: String$15 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 String$15 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%StringLib$14*,5:%String$15]
   ;; lookup:  %StringLib$14*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%StringLib$14*,5:%String$15]
   %R8 = getelementptr %String$15, %String$15 * %R5, i32 0, i32 1
   store %StringLib$14* %R1, %StringLib$14** %R8
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[5:%String$15,1:%StringLib$14*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%String$15]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$String$15* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 16 :top: 1 
   ;; Items:GenClass: QBETA descNo: 16 
;; class  QBETA 16 1 BETAworld 1

define %QBETA$16* @QBETA$16(%QBETA$16* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=16 vDescInx=16 vdtTop: 1
   ;; $Property:"%requires BETA" 
   ;; Qgen: 
   ;; $Property:"%visible BETA" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%requires BETA" 
   ;; $Property:"%requires BETA" 
   ;; Qgen: 
   ;; genclass:stmt: "%visible BETA" 
   ;; $Property:"%visible BETA" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "QBETA" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %QBETA$16* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%QBETA$16*]
   ret %QBETA$16* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 16:I
@vdt_data$QBETA$16 = global %vdt_type$QBETA$16 {
      %QBETA$16*(%QBETA$16*)* @QBETA$16
}

define %vdt_ret$QBETA$16* @vdt_alloc$QBETA$16(%BETAworld$1* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$QBETA$16
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$QBETA$16*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %QBETA$16 
   ;; alloc %QBETA$16
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %QBETA$16*
   ;; store VDT in object
   %R6 = getelementptr %QBETA$16, %QBETA$16* %R5, i32 0, i32 0
   store %vdt_type$QBETA$16* @vdt_data$QBETA$16, %vdt_type$QBETA$16** %R6
   %R7 = getelementptr %vdt_ret$QBETA$16,%vdt_ret$QBETA$16* %R3, i32 0, i32 0
   store %QBETA$16* %R5, %QBETA$16** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETAworld thisClassOrgDescNo: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,5:%QBETA$16]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: QBETA 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: QBETA$16 this: QBETA$16 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 QBETA$16 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,5:%QBETA$16]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,5:%QBETA$16]
   %R8 = getelementptr %QBETA$16, %QBETA$16 * %R5, i32 0, i32 1
   store %BETAworld$1* %R1, %BETAworld$1** %R8
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[5:%QBETA$16,1:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%QBETA$16]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$QBETA$16* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 17 :top: 1 
   ;; Items:GenClass: workspace descNo: 17 
;; class  workspace 17 1 BETAworld 1

define %workspace$17* @workspace$17(%workspace$17* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=17 vDescInx=17 vdtTop: 1
   ;; $Property:"%id "workspace"" 
   ;; Qgen: 
   ;; $Property:"%include BETA, LIB, LIB.BasicIO, qbeta" 
   ;; Qgen: 
   ;; $Property:"%domain_boundary" 
   ;; Qgen: 
   ;; $ModuleItem:"--AccessEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ApplyPred{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ArduinoEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ArmBasicSys{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ArmLed{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ArmMultiCore{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--CAStest{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--CAStestCore{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--CppEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--DumpObjEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ESP32Ex{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Errors{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ForkGC{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--FuncVirtExVclass{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--FunctionalVirtEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Generic{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--GenericArray{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--GenericList{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--IndexEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Jurgen{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--LLVMex{"} 
   ;; Qgen: 
   ;; ModuleItem:gen LLVMex 
   ;; $ModuleItem:"--Line{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ListLiteralEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--LockTest{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--LockTestCore{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--MVRsystem{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--MapEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--MiniVal{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--NewInner{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--NewKeyWord{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--NewStorage{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--NewSyntax{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--NoneEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ObjectAndValues{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--PTX{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--PointReturn{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--PointSys{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--PtnName{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Qtst{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--QuaValue{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Qual{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Recursive{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--RemoteSuperVC{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Restrictions{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Rtest{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--SlideEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Small{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--SmallVirtEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--StringEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Sub1{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--SubOfInt{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--TST{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--TstBreak{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--UnitLiterals{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--UnitTest{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ValueArray{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ValueConv{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ValueEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ValueItemEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--ValueTypes{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--VirtError{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--VirtualEx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--Visibility{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--cbrtUnit{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--comment{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--demo{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--noglobtst{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--qbetaCmp{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--qenvTest{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--rangetst{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--test{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--testA{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--testB{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--testJ{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--testX{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--testY{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--testZ{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tiny{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyA{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyB{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyC{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyD{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyE{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyF{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyG{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyH{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyI{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyP{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyQ{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyR{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyS{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyT{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyW{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyY{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyZ{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--tinyx{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--xKinds{"} 
   ;; Qgen: 
   ;; $obj:"LLVMex: obj {   %id "LLVMex";   outint: ;      %globals;      S: obj Indexed ( 6 , integer );      in X: var integer;      V: var integer;      V := X /% 10;      S. ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"%id "LLVMex"{outint: ;   %globals;   S: obj Indexed ( 6 , integer );   in X: var integer;   V: var integer;   V := X /% 10;   S.@put V :at 1;   X := X // ..."} 
   ;; Qgen:OGid:"LLVMex" singular! staticOff=2 descNo=18 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %workspace$17* 
   ;; before objTmpStack:add:  18   "LLVMex" 
   ;; OGid: LLVMex  OGidWdNo:  LLVMex$18 
;; invoke LLVMex 18 2 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%workspace$17*]
   ;; alloc %LLVMex$18
   %R1 = tail call i8* @malloc(i64 12)
   %R2 = bitcast i8* %R1 to %LLVMex$18*
   ;; store VDT in object
   %R3 = getelementptr %LLVMex$18, %LLVMex$18* %R2, i32 0, i32 0
   store %vdt_type$LLVMex$18* @vdt_data$LLVMex$18, %vdt_type$LLVMex$18** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: LLVMex$18 this: LLVMex$18 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 LLVMex$18 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%workspace$17*,2:%LLVMex$18]
   ;; lookup:  %workspace$17*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%workspace$17*,2:%LLVMex$18]
   %R4 = getelementptr %LLVMex$18, %LLVMex$18 * %R2, i32 0, i32 1
   store %workspace$17* %R0, %workspace$17** %R4
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[2:%LLVMex$18,0:%workspace$17*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,2)=[2:%LLVMex$18]
   ;; topSuper: 18   LLVMex$18 
   ;; save object: %LLVMex$18* dstType: %LLVMex$18*
   %R5 = getelementptr %workspace$17,%workspace$17* %R0, i32 0, i32 2
   store %LLVMex$18* %R2,  %LLVMex$18** %R5
   %R6 = call %LLVMex$18* @LLVMex$18(%LLVMex$18 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   %V9 = icmp eq %LLVMex$18* %R6, %R2
   br i1 %V9, label %normalRtnLab7, label %breakLab8
breakLab8:
   %R10 = bitcast %LLVMex$18* %R6 to %workspace$17*
   %V11 = icmp eq %workspace$17* %R0, %R10
   br i1 %V11, label %selectBreakLab13, label %contBreakLab12
contBreakLab12:
   ret %workspace$17* %R10
selectBreakLab13:
   %R14 = bitcast %LLVMex$18* %R6 to [0 x i32]*
   %R15 = getelementptr [0 x i32], [0 x i32]* %R14, i32 0, i32 0
   %V16 = load i32 , i32* %R15
   %R17 = getelementptr %LLVMex$18,%LLVMex$18* %R6, i32 0, i32 0
   store %vdt_type$LLVMex$18* @vdt_data$LLVMex$18, %vdt_type$LLVMex$18** %R17
   %V18 = icmp eq i32 1, %V16
   br i1 %V18, label %X19, label %X20
X19:
   br label %L1 ; restart
X20:
   br label %L2 ; leave
normalRtnLab7:

   ;; vTop(0,0)=[] rTop(1,2)=[2:%LLVMex$18*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "workspace"" 
   ;; $Property:"%id "workspace"" 
   ;; Qgen: 
   ;; genclass:stmt: "%include BETA, LIB, LIB.BasicIO, qbeta" 
   ;; $Property:"%include BETA, LIB, LIB.BasicIO, qbeta" 
   ;; Qgen: 
   ;; genclass:stmt: "%domain_boundary" 
   ;; $Property:"%domain_boundary" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "workspace" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %workspace$17* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%workspace$17*]
   ret %workspace$17* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 17:I
@vdt_data$workspace$17 = global %vdt_type$workspace$17 {
      %workspace$17*(%workspace$17*)* @workspace$17
}

define %vdt_ret$workspace$17* @vdt_alloc$workspace$17(%BETAworld$1* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$workspace$17
   %R22 = tail call i8* @malloc(i64 32)
   %R23 = bitcast i8* %R22 to %vdt_ret$workspace$17*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %workspace$17 
   ;; alloc %workspace$17
   %R24 = tail call i8* @malloc(i64 192)
   %R25 = bitcast i8* %R24 to %workspace$17*
   ;; store VDT in object
   %R26 = getelementptr %workspace$17, %workspace$17* %R25, i32 0, i32 0
   store %vdt_type$workspace$17* @vdt_data$workspace$17, %vdt_type$workspace$17** %R26
   %R27 = getelementptr %vdt_ret$workspace$17,%vdt_ret$workspace$17* %R23, i32 0, i32 0
   store %workspace$17* %R25, %workspace$17** %R27
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETAworld thisClassOrgDescNo: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 25 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,25:%workspace$17]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: workspace 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: workspace$17 this: workspace$17 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 workspace$17 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,25:%workspace$17]
   ;; lookup:  %BETAworld$1*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETAworld$1*,25:%workspace$17]
   %R28 = getelementptr %workspace$17, %workspace$17 * %R25, i32 0, i32 1
   store %BETAworld$1* %R1, %BETAworld$1** %R28
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[25:%workspace$17,1:%BETAworld$1*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 25 
   ;; vTop(0,0)=[] rTop(1,2)=[25:%workspace$17]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$workspace$17* %R23
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 18 :top: 1 
   ;; Items:GenClass: LLVMex descNo: 18 
;; class  LLVMex 18 1 workspace 17

define %LLVMex$18* @LLVMex$18(%LLVMex$18* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=18 vDescInx=18 vdtTop: 1
   ;; $Property:"%id "LLVMex"" 
   ;; Qgen: 
   ;; $ModuleItem:"--RefRel{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--mini{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--mini1{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--mini2{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--mini3{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--mini4{"} 
   ;; Qgen: 
   ;; ModuleItem:gen mini4 
   ;; $ModuleItem:"--miniq{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--minix{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--miniy{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--miniz{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--mixed{"} 
   ;; Qgen: 
   ;; $ModuleItem:"--valEx{"} 
   ;; Qgen: 
   ;; $obj:"mini4: obj {   put ( 'Q' );   @for 1 :to 1 :repeat ;      put ( 'Q' + inx )"} 
   ;; Qgen: 
   ;; $ObjectGenerator:"put ( 'Q' ){@for 1 :to 1 :repeat ;   put ( 'Q' + inx )"} 
   ;; Qgen:OGid:"mini4" singular! staticOff=2 descNo=19 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %LLVMex$18* 
   ;; before objTmpStack:add:  19   "mini4" 
   ;; OGid: mini4  OGidWdNo:  mini4$19 
;; invoke mini4 19 2 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%LLVMex$18*]
   ;; alloc %mini4$19
   %R1 = tail call i8* @malloc(i64 8)
   %R2 = bitcast i8* %R1 to %mini4$19*
   ;; store VDT in object
   %R3 = getelementptr %mini4$19, %mini4$19* %R2, i32 0, i32 0
   store %vdt_type$mini4$19* @vdt_data$mini4$19, %vdt_type$mini4$19** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: mini4$19 this: mini4$19 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 mini4$19 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LLVMex$18*,2:%mini4$19]
   ;; lookup:  %LLVMex$18*
   ;; vTop(0,0)=[] rTop(2,2)=[0:%LLVMex$18*,2:%mini4$19]
   %R4 = getelementptr %mini4$19, %mini4$19 * %R2, i32 0, i32 1
   store %LLVMex$18* %R0, %LLVMex$18** %R4
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[2:%mini4$19,0:%LLVMex$18*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,2)=[2:%mini4$19]
   ;; topSuper: 19   mini4$19 
   ;; save object: %mini4$19* dstType: %mini4$19*
   %R5 = getelementptr %LLVMex$18,%LLVMex$18* %R0, i32 0, i32 2
   store %mini4$19* %R2,  %mini4$19** %R5
   %R6 = call %mini4$19* @mini4$19(%mini4$19 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 2 
   %V9 = icmp eq %mini4$19* %R6, %R2
   br i1 %V9, label %normalRtnLab7, label %breakLab8
breakLab8:
   %R10 = bitcast %mini4$19* %R6 to %LLVMex$18*
   %V11 = icmp eq %LLVMex$18* %R0, %R10
   br i1 %V11, label %selectBreakLab13, label %contBreakLab12
contBreakLab12:
   ret %LLVMex$18* %R10
selectBreakLab13:
   %R14 = bitcast %mini4$19* %R6 to [0 x i32]*
   %R15 = getelementptr [0 x i32], [0 x i32]* %R14, i32 0, i32 0
   %V16 = load i32 , i32* %R15
   %R17 = getelementptr %mini4$19,%mini4$19* %R6, i32 0, i32 0
   store %vdt_type$mini4$19* @vdt_data$mini4$19, %vdt_type$mini4$19** %R17
   %V18 = icmp eq i32 1, %V16
   br i1 %V18, label %X19, label %X20
X19:
   br label %L1 ; restart
X20:
   br label %L2 ; leave
normalRtnLab7:

   ;; vTop(0,0)=[] rTop(1,2)=[2:%mini4$19*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%id "LLVMex"" 
   ;; $Property:"%id "LLVMex"" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "LLVMex" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %LLVMex$18* 
   ;; vTop(0,0)=[] rTop(1,2)=[0:%LLVMex$18*]
   ret %LLVMex$18* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 18:I
@vdt_data$LLVMex$18 = global %vdt_type$LLVMex$18 {
      %LLVMex$18*(%LLVMex$18*)* @LLVMex$18
}

define %vdt_ret$LLVMex$18* @vdt_alloc$LLVMex$18(%workspace$17* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$LLVMex$18
   %R22 = tail call i8* @malloc(i64 32)
   %R23 = bitcast i8* %R22 to %vdt_ret$LLVMex$18*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %LLVMex$18 
   ;; alloc %LLVMex$18
   %R24 = tail call i8* @malloc(i64 192)
   %R25 = bitcast i8* %R24 to %LLVMex$18*
   ;; store VDT in object
   %R26 = getelementptr %LLVMex$18, %LLVMex$18* %R25, i32 0, i32 0
   store %vdt_type$LLVMex$18* @vdt_data$LLVMex$18, %vdt_type$LLVMex$18** %R26
   %R27 = getelementptr %vdt_ret$LLVMex$18,%vdt_ret$LLVMex$18* %R23, i32 0, i32 0
   store %LLVMex$18* %R25, %LLVMex$18** %R27
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: workspace thisClassOrgDescNo: 17 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 25 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%workspace$17*,25:%LLVMex$18]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: LLVMex 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: LLVMex$18 this: LLVMex$18 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 LLVMex$18 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%workspace$17*,25:%LLVMex$18]
   ;; lookup:  %workspace$17*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%workspace$17*,25:%LLVMex$18]
   %R28 = getelementptr %LLVMex$18, %LLVMex$18 * %R25, i32 0, i32 1
   store %workspace$17* %R1, %workspace$17** %R28
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[25:%LLVMex$18,1:%workspace$17*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 25 
   ;; vTop(0,0)=[] rTop(1,2)=[25:%LLVMex$18]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$LLVMex$18* %R23
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 19 :top: 1 
   ;; Items:GenClass: mini4 descNo: 19 
;; class  mini4 19 1 LLVMex 18

define %mini4$19* @mini4$19(%mini4$19* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=19 vDescInx=19 vdtTop: 1
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "put ( 'Q' )" 
   ;; $ObjectGenerator:"put ( 'Q' )" 
   ;; Qgen:OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "put" superDescNo: 20 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"put ( 'Q' )" 
   ;; Qgen: useRtnV:"False" descNo: 20 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "put ( 'Q' )" 
   ;; needorigin: "put ( 'Q' )" 
   ;; needOrigin:E: "put ( 'Q' )"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "%globals{%basic 2;in ch: val char}" 
   ;; IV:no:needOrigin:E:  "put ( 'Q' )" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "put ( 'Q' )" E:  "put ( 'Q' )" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "put ( 'Q' )" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"put ( 'Q' )" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  put ( 'Q' )  hasArg:  pattern 
   ;; put ( 'Q' )   put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char} 
   ;; $pattern:"put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char"} 
   ;; >loadArgs:E:"put ( 'Q' )":descNo:20:top:1 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "put ( 'Q' )" 
   ;; ActArg:  "'Q'" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "put ( 'Q' )" 
   ;; loadArgs:not:*:  formalArgOf: "put ( 'Q' )"  isCompositeValueObj: false 
   ;; loadArgs:A: "'Q'" 
   ;; $ObjectGenerator:"'Q'" 
   ;; Qgen:OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"'Q'" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "'Q'" 
   ;; needorigin: "'Q'" 
   ;; needOrigin:E: "'Q'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
   ;; IV:no:needOrigin:E:  "'Q'" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "'Q'" E:  "'Q'" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "'Q'" superAdj= 0 
   ;; $Char::"'Q'" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "'Q'"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "'Q'" 
   ;; $Char::"'Q'" 
   ;; >invoke: 
;; pushc 81
   %V1 = add i32 0, 81
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 0 V: 1 R: 
   ;; invoke:after:E.invoke: "'Q'" 
   ;; loadArgs:after:Qgen: "put ( 'Q' )" 
   ;; formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
   ;; :actArg: "'Q'" :isBasicVal: true 
   ;; 'Q' ObjectGenerator 
   ;; end:loadArgs:NonVirt: "put ( 'Q' )" 
   ;; IV:after:loadArgsOf: "put ( 'Q' )"  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "put ( 'Q' )" 
   ;; $ObjectInvocation_KeyWord:"put ( 'Q' )" 
   ;; >invoke: rec:"put ( 'Q' )" 
   ;; OI:invoke:isPtn: "put ( 'Q' )" descNo 20  useRTNv: false 
   ;; OI:invoke:B: "put ( 'Q' )" E: "put ( 'Q' )"  rec: "put ( 'Q' )"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; adr:none 
   ;; $pattern:"put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char"} 
   ;; >invoke:E: "put ( 'Q' )" useRTNv: "False" 
   ;; ptn:invoke: "put" E: "put ( 'Q' )" useRtnV: false 
   call i32 @putCh(i32 %V1)
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 0 V: R: 

   ;; OI:invoke: put ( 'Q' ) :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "put ( 'Q' )" 
   ;; genclass:stmt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; $ObjectGenerator:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; Qgen:OGid:"@for::to:repeat$S$25" IS.isempty! staticOff=0 descNo=25 superAdj=0 
   ;; OG:gen:super: "@for" superDescNo: 21 super.OG.top: 1 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %mini4$19* 
   ;; before objTmpStack:add:  25   "@for::to:repeat$S$25" 
   ;; OGid: @for::to:repeat$S$25  OGidWdNo:  @for::to:repeat$S$25$25 
;; invoke @for::to:repeat$S$25 25 0 1
   ;; vTop(0,1)=[] rTop(1,1)=[0:%mini4$19*]
   ;; alloc %$for$$to$repeat$S$25$25
   %R2 = tail call i8* @malloc(i64 20)
   %R3 = bitcast i8* %R2 to %$for$$to$repeat$S$25$25*
   ;; store VDT in object
   %R4 = getelementptr %$for$$to$repeat$S$25$25, %$for$$to$repeat$S$25$25* %R3, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$S$25$25* @vdt_data$$for$$to$repeat$S$25$25, %vdt_type$$for$$to$repeat$S$25$25** %R4
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 2 V: R: 3 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$25$25 this: @for::to:repeat$S$25$25 originOff: 4 orgIsValObj: false 
;; rdouble -1
   ;; vTop(0,1)=[] rTop(2,2)=[0:%mini4$19*,3:%$for$$to$repeat$S$25$25]
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 3 rTopMax: 3 V: R: 3 
   ;; vTop(0,1)=[] rTop(3,3)=[0:%mini4$19*,0:%mini4$19*,3:%$for$$to$repeat$S$25$25]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  4 @for::to:repeat$S$25$25 isValueObjectOrigin: F
   ;; vTop(0,1)=[] rTop(3,3)=[0:%mini4$19*,0:%mini4$19*,3:%$for$$to$repeat$S$25$25]
   ;; lookup:  %mini4$19*
   ;; vTop(0,1)=[] rTop(3,3)=[0:%mini4$19*,0:%mini4$19*,3:%$for$$to$repeat$S$25$25]
   %R5 = getelementptr %$for$$to$repeat$S$25$25, %$for$$to$repeat$S$25$25 * %R3, i32 0, i32 4
   store %mini4$19* %R0, %mini4$19** %R5
;; rswap  0
   ;; vTop(0,1)=[] rTop(3,3)=[0:%mini4$19*,3:%$for$$to$repeat$S$25$25,0:%mini4$19*]
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 3 
   ;; vTop(0,1)=[] rTop(2,3)=[0:%mini4$19*,3:%$for$$to$repeat$S$25$25]
   ;; go:super.ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loo ...}" t ... 2 t ... "@ ..." 
   ;; thisOG.IS: origin: "@for::to:repeat$S$25" thisOG.IS: origin: "@for::to:repeat$S$25" 
   ;; vTop(0,1)=[] rTop(2,3)=[0:%mini4$19*,3:%$for$$to$repeat$S$25$25]
;; rswap  0
   ;; goOriginAdr:  "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  @for 1 :to 1 :repeat {   put ( 'Q' + inx )} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "mini4" newOriginOff: 1 origin: "LLVMex$18" 
   ;; NA: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" origin: "mini4$19" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg mini4$19 1
   ;; Rtype.rtop: "%mini4$19*" typeInfo[rtop,off]=elmType: "%LLVMex$18*" 
   %R6 = getelementptr %mini4$19,%mini4$19 *%R0, i32 0, i32 1
   %R7 = load %LLVMex$18* , %LLVMex$18** %R6
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 3 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 7 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "LLVMex" newOriginOff: 1 origin: "workspace$17" 
   ;; NA: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" origin: "mini4$19" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg mini4$19 1
   ;; Rtype.rtop: "%LLVMex$18*" typeInfo[rtop,off]=elmType: "%workspace$17*" 
   %R8 = getelementptr %LLVMex$18,%LLVMex$18 *%R7, i32 0, i32 1
   %R9 = load %workspace$17* , %workspace$17** %R8
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 3 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 9 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; IV:viaIncl:on: 0 "BETA"  org: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMulti ...}" 
   ;; viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
   ;; items:goOrigin: 1 
   ;; goOrigin: "workspace" newOriginOff: 1 origin: "BETAworld$1" 
   ;; NA: "BETA" origin: "workspace$17" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg workspace$17 1
   ;; Rtype.rtop: "%workspace$17*" typeInfo[rtop,off]=elmType: "%BETAworld$1*" 
   %R10 = getelementptr %workspace$17,%workspace$17 *%R9, i32 0, i32 1
   %R11 = load %BETAworld$1* , %BETAworld$1** %R10
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 3 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 11 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
;; rpushg BETA 2
   ;; Rtype.rtop: "%BETAworld$1*" typeInfo[rtop,off]=elmType: "%BETA$2*" 
   %R12 = getelementptr %BETAworld$1,%BETAworld$1 *%R11, i32 0, i32 2
   %R13 = load %BETA$2* , %BETA$2** %R12
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 3 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 13 
   ;; goOriginAdr:not:BracE: ObjectInvocation_KeyWord 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to 1 :repeat ;   put ( 'Q' + inx )"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to 1 :repeat ;   put ( 'Q' + inx )"} 
   ;; vTop(0,1)=[] rTop(2,3)=[3:%$for$$to$repeat$S$25$25,13:%BETA$2*]
   ;; before:E.loadArgs: @for 1 :to 1 :repeat {   put ( 'Q' + inx )} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @for 1 :to 1 :repeat {   put ( 'Q' + inx )}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to 1 :repeat {   put ( 'Q' + inx )}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V14 = add i32 0, 1
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 14 R: 13 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V15 = add i32 0, 1
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 15 R: 13 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; in for: var integer 
   ;; in to: var integer 
;; rswap  0
;; rdouble 0
   ;; vTop(2,2)=[14/0,15/0] rTop(2,3)=[13:%BETA$2*,3:%$for$$to$repeat$S$25$25]
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 3 rTopMax: 3 V: 15 R: 3 
   ;; vTop(2,2)=[14/0,15/0] rTop(3,3)=[13:%BETA$2*,3:%$for$$to$repeat$S$25$25,3:%$for$$to$repeat$S$25$25]
;; storeg  @for::to:repeat$S$25$25 2
   %R16 = getelementptr %$for$$to$repeat$S$25$25,%$for$$to$repeat$S$25$25 *%R3, i32 0, i32 2
   store i32 %V15, i32* %R16
   ;; stack: vpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 3 V: 14 R: 3 
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 14 R: 3 
;; rswap  0
;; rswap  0
;; rdouble 0
   ;; vTop(1,2)=[14/0] rTop(2,3)=[13:%BETA$2*,3:%$for$$to$repeat$S$25$25]
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 3 V: 14 R: 3 
   ;; vTop(1,2)=[14/0] rTop(3,3)=[13:%BETA$2*,3:%$for$$to$repeat$S$25$25,3:%$for$$to$repeat$S$25$25]
;; storeg  @for::to:repeat$S$25$25 1
   %R17 = getelementptr %$for$$to$repeat$S$25$25,%$for$$to$repeat$S$25$25 *%R3, i32 0, i32 1
   store i32 %V14, i32* %R17
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 3 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 3 
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,3)=[3:%$for$$to$repeat$S$25$25,13:%BETA$2*] 
   ;; @for::to:repeat   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$25$25 this: @for::to:repeat$21 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; topSuper: 21   @for::to:repeat$21 
   %R18 = bitcast %$for$$to$repeat$S$25$25* %R3 to %$for$$to$repeat$21*
   %R19 = call %$for$$to$repeat$21* @$for$$to$repeat$21(%$for$$to$repeat$21 * %R18)
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 13 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 18 
   %V22 = icmp eq %$for$$to$repeat$21* %R19, %R18
   br i1 %V22, label %normalRtnLab20, label %breakLab21
breakLab21:
   %R23 = bitcast %$for$$to$repeat$21* %R19 to %mini4$19*
   %V24 = icmp eq %mini4$19* %R0, %R23
   br i1 %V24, label %selectBreakLab26, label %contBreakLab25
contBreakLab25:
   ret %mini4$19* %R23
selectBreakLab26:
   %R27 = bitcast %$for$$to$repeat$21* %R19 to [0 x i32]*
   %R28 = getelementptr [0 x i32], [0 x i32]* %R27, i32 0, i32 0
   %V29 = load i32 , i32* %R28
   %R30 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21* %R19, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$21* @vdt_data$$for$$to$repeat$21, %vdt_type$$for$$to$repeat$21** %R30
   %V31 = icmp eq i32 1, %V29
   br i1 %V31, label %X32, label %X33
X32:
   br label %L1 ; restart
X33:
   br label %L2 ; leave
normalRtnLab20:

   ;; vTop(0,2)=[] rTop(2,3)=[13:%BETA$2*,18:%$for$$to$repeat$21*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 13 
   br label %L2
L2:
   ;; pushReturn:  "mini4" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 0 
   ;; %mini4$19* 
   ;; vTop(0,2)=[] rTop(2,3)=[13:%BETA$2*,0:%mini4$19*]
   ret %mini4$19* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 13 
}
   ;; vdt:vdtTop: 1 19:I
@vdt_data$mini4$19 = global %vdt_type$mini4$19 {
      %mini4$19*(%mini4$19*)* @mini4$19
}

define %vdt_ret$mini4$19* @vdt_alloc$mini4$19(%LLVMex$18* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$mini4$19
   %R35 = tail call i8* @malloc(i64 32)
   %R36 = bitcast i8* %R35 to %vdt_ret$mini4$19*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %mini4$19 
   ;; alloc %mini4$19
   %R37 = tail call i8* @malloc(i64 192)
   %R38 = bitcast i8* %R37 to %mini4$19*
   ;; store VDT in object
   %R39 = getelementptr %mini4$19, %mini4$19* %R38, i32 0, i32 0
   store %vdt_type$mini4$19* @vdt_data$mini4$19, %vdt_type$mini4$19** %R39
   %R40 = getelementptr %vdt_ret$mini4$19,%vdt_ret$mini4$19* %R36, i32 0, i32 0
   store %mini4$19* %R38, %mini4$19** %R40
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: LLVMex thisClassOrgDescNo: 18 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 38 
   ;; vTop(0,2)=[] rTop(3,3)=[13:%BETA$2*,1:%LLVMex$18*,38:%mini4$19]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: mini4 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: mini4$19 this: mini4$19 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 mini4$19 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(3,3)=[13:%BETA$2*,1:%LLVMex$18*,38:%mini4$19]
   ;; lookup:  %LLVMex$18*
   ;; vTop(0,2)=[] rTop(3,3)=[13:%BETA$2*,1:%LLVMex$18*,38:%mini4$19]
   %R41 = getelementptr %mini4$19, %mini4$19 * %R38, i32 0, i32 1
   store %LLVMex$18* %R1, %LLVMex$18** %R41
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,3)=[13:%BETA$2*,38:%mini4$19,1:%LLVMex$18*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 38 
   ;; vTop(0,2)=[] rTop(2,3)=[13:%BETA$2*,38:%mini4$19]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$mini4$19* %R36
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 20 :top: 1 
   ;; Items:GenClass: put descNo: 20 
;; class  put 20 0 BETA 2

define %put$20* @put$20(%put$20* %R0){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=20 vDescInx=20 vdtTop: 1
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; $Property:"%basic 2" 
   ;; Qgen: 
   ;; $val:"in ch: val char" 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: true :primNo: 3 
   ;; OGqual: "char" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  ch 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%globals" 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 2" 
   ;; $Property:"%basic 2" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "put" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %put$20* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%put$20*]
   ret %put$20* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 20:I
@vdt_data$put$20 = global %vdt_type$put$20 {
      %put$20*(%put$20*)* @put$20
}

define %vdt_ret$put$20* @vdt_alloc$put$20(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$put$20
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$put$20*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %put$20 
   ;; alloc %put$20
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %put$20*
   ;; store VDT in object
   %R6 = getelementptr %put$20, %put$20* %R5, i32 0, i32 0
   store %vdt_type$put$20* @vdt_data$put$20, %vdt_type$put$20** %R6
   %R7 = getelementptr %vdt_ret$put$20,%vdt_ret$put$20* %R3, i32 0, i32 0
   store %put$20* %R5, %put$20** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETA$2*,5:%put$20]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: put 
   ;; after:handleOrigins 
   ret %vdt_ret$put$20* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 21 :top: 1 
   ;; Items:GenClass: @for::to:repeat descNo: 21 
;; class  @for::to:repeat 21 0 BETA 2

define %$for$$to$repeat$21* @$for$$to$repeat$21(%$for$$to$repeat$21* %R0){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=21 vDescInx=21 vdtTop: 1
   ;; $Property:"%globals inSub" 
   ;; Qgen: 
   ;; $var:"in for: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  for 
   ;; $var:"in to: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  to 
   ;; $pattern:"in repeat:< Object" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"inx: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  inx 
   ;; $Property:"%private" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%globals inSub" 
   ;; $Property:"%globals inSub" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; genclass:stmt: "%private" 
   ;; $Property:"%private" 
   ;; Qgen: 
   ;; genclass:stmt: "inx := for" 
   ;; $ObjectGenerator:"inx := for" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx := for" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx := for" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx := for" 
   ;; needOrigin:E: ":= for"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= for" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx := for" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;     ...}" A ... "i ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$for$$to$repeat$21* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:0 
   ;; AdjustOrigin:originOff: 0 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr: 2 :rec: "inx"  E: ":= for"  A.E: "inx" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isAssign:rec:  "inx"  E: ":= for" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  ":= for" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  ":= for" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= for" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= for" 
   ;; >loadArgs:staticOff:3 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  for  hasArg:  pattern 
   ;; := for   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= for":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= for" 
   ;; ActArg:  "for" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= for" 
   ;; loadArgs:A: "for" 
   ;; $ObjectGenerator:"for" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"for" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "for" 
   ;; not const:  for in for: var integer 
   ;; needorigin: "for" 
   ;; needOrigin:E: "for"  E.ATd: "in for: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "for" 
   ;; computeAdr: 1 :rec: "none"  E: "for" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"for" 
   ;; >pushThis: 
   ;; OI:pushThis: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;     ...}" A ... "i ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %$for$$to$repeat$21* 
   ;; $ObjectInvocation_Unary:"for" 
   ;; >loadOrigin::on:0 
   ;; AdjustOrigin:originOff: 0 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"for" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"in for: var integer" 
   ;; >getAdr:,newOff:1,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"for"}   in for: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "in for: var integer" ObjectGenerator 
   ;; :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; After:U*U: :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; OI:getAdr:KOKS: :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; computeAdr:isLast:E:  "for" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; rec:  "for" E:  "for" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "for" superAdj= 0 
   ;; $ObjectInvocation_Unary:"for" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; for   in for: var integer 
   ;; $var:"in for: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in for: var integer"  E:  "for" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"for":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "for" :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "for" 
   ;; $ObjectInvocation_Unary:"for" 
   ;; >invoke: rec:"for" 
   ;; E.ATd:  "for" unique:  false 
   ;; adr: :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; OI:invoke:B: "for" E: "for"  rec: "for"  useRtnV: true "in for: var integer" 
   ;; :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; $var:"in for: var integer" 
   ;; >invoke:E: "for" newOff:1 useRTNv: "True" 
   ;; load: :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"for"} 
   ;; isFloat:B:  false 
;; pushg 1 @for::to:repeat$21
   %R1 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R0, i32 0, i32 1
   %V2 = load i32, i32* %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 2 R: 0 
   ;; BOBS! 
   ;; OI:invoke: for :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "for" 
   ;; loadArgs:after:Qgen: ":= for" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; end:loadArgs:NonVirt: ":= for" 
   ;; IV:after:loadArgsOf: ":= for" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= for" 
   ;; $ObjectInvocation_Binary:":= for" 
   ;; >invoke: rec:"inx" 
   ;; OI:invoke:isPtn: ":= for" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: ":= for" E: ":= for"  rec: "inx"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= for"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= for" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= for" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "inx" from:  ":= for" 
   ;; assign:dstDI : "inx: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "for" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: for 
   ;;  arg.super.ATd: "Invocation" "in for: var integer" 
   ;;  arg.super.ATd.isDataItem: true  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "var" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= for"  rec:  "inx" "@for::to:repeat$21" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= for"} 
   ;; store: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  @for::to:repeat$21 3
   %R3 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R0, i32 0, i32 3
   store i32 %V2, i32* %R3
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
   ;; OI:invoke: := for :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= for" 
   ;; genclass:stmt: "_loop: do {   @if inx <= to :then ;      repeat;      inx := inx + 1;      @restart _loop}" 
   ;; $do:"_loop: do {   @if inx <= to :then ;      repeat;      inx := inx + 1;      @restart _loop"} 
   ;; Qgen: 
   ;; $ObjectGenerator:"@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop"} 
   ;; Qgen:OGid:"$S$26" singular! staticOff=0 descNo=26 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %$for$$to$repeat$21* 
   ;; before objTmpStack:add:  26   "$S$26" 
   ;; OGid: $S$26  OGidWdNo:  $S$26$26 
;; invoke $S$26 26 0 1
   ;; vTop(0,1)=[] rTop(1,2)=[0:%$for$$to$repeat$21*]
   ;; alloc %$S$26$26
   %R4 = tail call i8* @malloc(i64 8)
   %R5 = bitcast i8* %R4 to %$S$26$26*
   ;; store VDT in object
   %R6 = getelementptr %$S$26$26, %$S$26$26* %R5, i32 0, i32 0
   store %vdt_type$$S$26$26* @vdt_data$$S$26$26, %vdt_type$$S$26$26** %R6
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 2 V: R: 5 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$26$26 this: $S$26$26 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$26$26 isValueObjectOrigin: F
   ;; vTop(0,1)=[] rTop(2,2)=[0:%$for$$to$repeat$21*,5:%$S$26$26]
   ;; lookup:  %$for$$to$repeat$21*
   ;; vTop(0,1)=[] rTop(2,2)=[0:%$for$$to$repeat$21*,5:%$S$26$26]
   %R7 = getelementptr %$S$26$26, %$S$26$26 * %R5, i32 0, i32 1
   store %$for$$to$repeat$21* %R0, %$for$$to$repeat$21** %R7
;; rswap  0
   ;; vTop(0,1)=[] rTop(2,2)=[5:%$S$26$26,0:%$for$$to$repeat$21*]
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,1)=[] rTop(1,2)=[5:%$S$26$26]
   ;; topSuper: 26   $S$26$26 
   %R8 = call %$S$26$26* @$S$26$26(%$S$26$26 * %R5)
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 5 
   %V11 = icmp eq %$S$26$26* %R8, %R5
   br i1 %V11, label %normalRtnLab9, label %breakLab10
breakLab10:
   %R12 = bitcast %$S$26$26* %R8 to %$for$$to$repeat$21*
   %V13 = icmp eq %$for$$to$repeat$21* %R0, %R12
   br i1 %V13, label %selectBreakLab15, label %contBreakLab14
contBreakLab14:
   ret %$for$$to$repeat$21* %R12
selectBreakLab15:
   %R16 = bitcast %$S$26$26* %R8 to [0 x i32]*
   %R17 = getelementptr [0 x i32], [0 x i32]* %R16, i32 0, i32 0
   %V18 = load i32 , i32* %R17
   %R19 = getelementptr %$S$26$26,%$S$26$26* %R8, i32 0, i32 0
   store %vdt_type$$S$26$26* @vdt_data$$S$26$26, %vdt_type$$S$26$26** %R19
   %V20 = icmp eq i32 1, %V18
   br i1 %V20, label %X21, label %X22
X21:
   br label %L1 ; restart
X22:
   br label %L2 ; leave
normalRtnLab9:

   ;; vTop(0,1)=[] rTop(1,2)=[5:%$S$26$26*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
   ;; genclass:stmt: "inner(for)" 
   ;; $ObjectGenerator:"inner(for)" 
   ;; Qgen:OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "inner" superDescNo: 23 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inner(for)" 
   ;; Qgen: useRtnV:"False" descNo: 23 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inner(for)" 
   ;; needorigin: "inner(for)" 
   ;; needOrigin:E: "inner(for)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
   ;; doNeedOrigin:Ex: "inner(for)" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inner(for)" 
   ;; computeAdr: 1 :rec: "none"  E: "inner(for)" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Function:"inner(for)" 
   ;; >pushThis: 
   ;; OI:pushThis: "%globals inSub{in for: var integer;in to: var integer;in repeat:< Object;%public;inx: var integer;%private;inx := for;_loop: do ;   @if inx <= to :then ;     ...}" A ... "i ..." 
   ;; $ObjectInvocation_Function:"inner(for)" 
   ;; >loadOrigin::on:1 
   ;; $ObjectInvocation_Function:"inner(for)" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"inner: {   %basic 101;   in inner: ref Object"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inner(for)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
   ;; computeAdr:isLast:E:  "inner(for)" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
   ;; rec:  "inner(for)" E:  "inner(for)" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inner(for)" superAdj= 0 
   ;; $ObjectInvocation_Function:"inner(for)" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  (for)  hasArg:  pattern 
   ;; inner(for)   inner: {   %basic 101;   in inner: ref Object} 
   ;; $pattern:"inner: {   %basic 101;   in inner: ref Object"} 
   ;; >loadArgs:E:"inner(for)":descNo:23:top:0 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inner(for)" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "inner(for)" 
   ;; $ObjectInvocation_Function:"inner(for)" 
   ;; >invoke: rec:"inner(for)" 
   ;; OI:invoke:isPtn: "inner(for)" descNo 23  useRTNv: false 
   ;; E.ATd:  "inner" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
   ;; OI:invoke:B: "inner(for)" E: "inner(for)"  rec: "inner(for)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
   ;; $pattern:"inner: {   %basic 101;   in inner: ref Object"} 
   ;; >invoke:E: "inner(for)" useRTNv: "False" 
   ;; ptn:invoke: "inner" E: "inner(for)" useRtnV: false 
   ;; inner:hasArgs: inner(for) 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inner(for)"} 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %$for$$to$repeat$21* 
   ;; goOrigin:T 
;; innerP  3
   ;; vTop(0,1)=[] rTop(1,2)=[0:%$for$$to$repeat$21*]
   %R23 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R0, i32 0, i32 0
%R24 = load %vdt_type$$for$$to$repeat$21*, %vdt_type$$for$$to$repeat$21** %R23
   %R25 = getelementptr %vdt_type$$for$$to$repeat$21,%vdt_type$$for$$to$repeat$21* %R24, i32 0, i32 2
%R26 = load  i8*(i8*)*, i8*(i8*)** %R25
   %V27 = icmp eq i8*(i8*)* %R26, null
   br i1 %V27, label %L28, label %L29
L29:
   ;; inner not null
      %R30 = bitcast %$for$$to$repeat$21* %R0 to i8*
call i8* %R26(i8* %R30)
   br label %L28
L28:
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
   ;; OI:invoke: inner(for) :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inner(for)" 
   br label %L2
L2:
   ;; pushReturn:  "@for::to:repeat" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %$for$$to$repeat$21* 
   ;; vTop(0,1)=[] rTop(1,2)=[0:%$for$$to$repeat$21*]
   ret %$for$$to$repeat$21* %R0   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdtAdd: inx=3 descInx=21 vDescInx=0 vdtTop: 3
   ;; vdtAdd: inx=2 descInx=21 vDescInx=44 vdtTop: 3
   ;; vdt:vdtTop: 3 21:I,44:V,0:I
@vdt_data$$for$$to$repeat$21 = global %vdt_type$$for$$to$repeat$21 {
      %$for$$to$repeat$21*(%$for$$to$repeat$21*)* @$for$$to$repeat$21,
      %vdt_ret$repeat$24$44*(%$for$$to$repeat$21*)* @vdt_alloc$$S$44$44,
      i8* (i8* )* null
}

define %vdt_ret$$for$$to$repeat$21* @vdt_alloc$$for$$to$repeat$21(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$for$$to$repeat$21
   %R32 = tail call i8* @malloc(i64 32)
   %R33 = bitcast i8* %R32 to %vdt_ret$$for$$to$repeat$21*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$for$$to$repeat$21 
   ;; alloc %$for$$to$repeat$21
   %R34 = tail call i8* @malloc(i64 192)
   %R35 = bitcast i8* %R34 to %$for$$to$repeat$21*
   ;; store VDT in object
   %R36 = getelementptr %$for$$to$repeat$21, %$for$$to$repeat$21* %R35, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$21* @vdt_data$$for$$to$repeat$21, %vdt_type$$for$$to$repeat$21** %R36
   %R37 = getelementptr %vdt_ret$$for$$to$repeat$21,%vdt_ret$$for$$to$repeat$21* %R33, i32 0, i32 0
   store %$for$$to$repeat$21* %R35, %$for$$to$repeat$21** %R37
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 2 V: R: 35 
   ;; vTop(0,1)=[] rTop(2,2)=[1:%BETA$2*,35:%$for$$to$repeat$21]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: @for::to:repeat 
   ;; after:handleOrigins 
   ret %vdt_ret$$for$$to$repeat$21* %R33
}
   ;; ObjStubStackX:gen 
;; class  repeat#24 44 0 @for::to:repeat$21 21 isVstub

define %repeat$24$44* @repeat$24$44(%$for$$to$repeat$21* %R1){
   ;; isVstubObject 
   %V0 = add i32 0, 0
   ;; Load origin:OG.isVirtualArg: false 
   %Rx = tail call i8* @malloc(i64 128)
   %R0 = bitcast i8* %Rx to %repeat$24$44*
   ;; cast:  %$for$$to$repeat$21*   %Object$22* 
   %R2 = bitcast %$for$$to$repeat$21* %R1 to %Object$22*
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,1)=[2:%Object$22*]
   ;; OG.super.on/descNo: 1 22 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %repeat$24$44* 
;; rstoreg  %repeat$24$44* 2
   %R3 = getelementptr %repeat$24$44,%repeat$24$44 *%R0, i32 0, i32 2
;; types:dst: %Object$22* src: %Object$22*
   store %Object$22*  %R2, %Object$22* * %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; vTop(0,0)=[] rTop(0,2)=[]
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %repeat$24$44* 
;; rpushg %repeat$24$44* 2
   ;; Rtype.rtop: "%repeat$24$44*" typeInfo[rtop,off]=elmType: "%Object$22*" 
   %R4 = getelementptr %repeat$24$44,%repeat$24$44 *%R0, i32 0, i32 2
   %R5 = load %Object$22* , %Object$22** %R4
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%Object$22*]
   %R6 = bitcast %Object$22* %R5 to %repeat$24$44*
   ret %repeat$24$44* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 0 
@vdt_data$repeat$24$44 = global %vdt_type$repeat$24$44 {
}

define %vdt_ret$repeat$24$44* @vdt_alloc$repeat$24$44(%$for$$to$repeat$21* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$repeat$24$44
   %R8 = tail call i8* @malloc(i64 32)
   %R9 = bitcast i8* %R8 to %vdt_ret$repeat$24$44*
   ;; mkVDTalloc:B: 
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: @for::to:repeat$21 thisClassOrgDescNo: 21 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; vTop(0,0)=[] rTop(1,2)=[1:%@for::to:repeat$21]
   ;; CALL Vstub: %repeat$24$44 
   %R10 = call %repeat$24$44* @repeat$24$44(%$for$$to$repeat$21* %R1)
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 10 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,10:%repeat$24$44]
   ;; Store binding in vdt_ret. Note! types are not correct 
   %R11 = getelementptr %vdt_ret$repeat$24$44,%vdt_ret$repeat$24$44* %R9, i32 0, i32 0
   store %repeat$24$44* %R10, %repeat$24$44** %R11
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,10:%repeat$24$44]
   ;; Vstub:handleOrigins:NEW: repeat#24 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx ...} 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,10:%repeat$24$44]
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[10:%repeat$24$44,1:%@for::to:repeat$21]
   ;; goOriginAdr:  "Object" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadOrigin::on:1 
   ;; goOriginAdr:not:BracE: ObjectInvocation_Unary 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
;; rswap  0
   ;; OriginIsValue: false 
   ;; storeOrigins:main: Object$22 this: Object$22 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; fixTypeOfBinding: "Object$22"  typeOnStack: "%repeat$24$44" 
   %R12 = bitcast %repeat$24$44* %R10 to %Object$22*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,10:%repeat$24$44]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 12 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,12:Object$22]
   ;; OriginIsValue: false 
;; rstoreX  1 Object$22 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,12:Object$22]
   ;; lookup:  %BETA$2*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%@for::to:repeat$21,12:Object$22]
   %R13 = getelementptr %Object$22, %Object$22 * %R12, i32 0, i32 1
   %R14 = bitcast %BETA$2** %R13 to %$for$$to$repeat$21**
   store %$for$$to$repeat$21* %R1, %$for$$to$repeat$21** %R14
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[12:Object$22,1:%@for::to:repeat$21]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 12 
   ;; vTop(0,0)=[] rTop(1,2)=[12:Object$22]
   ;; Vstub:handleOrigins:END:  
   ret %vdt_ret$repeat$24$44* %R9
}
   ;; vdt:a:dNo: 44  newDescNo:  21 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 26 :top: 1 
   ;; Items:GenClass: $S$26 descNo: 26 
;; class  $S$26 26 1 @for::to:repeat 21

define %$S$26$26* @$S$26$26(%$S$26$26* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=26 vDescInx=26 vdtTop: 1
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; $ObjectGenerator:"@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop"} 
   ;; Qgen:OGid:"@ifX::thenX$S$0" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop"} 
   ;; Qgen: useRtnV:"False" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; needorigin: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; needOrigin:E: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}"  E.ATd: "@ifX: {   %globals inSub;   %basic 100;   in ifX: var boolean;   in thenX:< Ob ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "%globals inSub{%basic 100;in ifX: var boolean;in thenX:< Object}" 
   ;; IV:no:needOrigin:E:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" E:  "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" superAdj= 0 
   ;; $IfThen:"@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop"} 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}"  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   ;; $IfThen:"@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop"} 
   ;; >invoke: 
   ;; $IfThen:"@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop"} 
   ;; Qgen: 
   ;; $ObjectGenerator:"inx <= to" 
   ;; Qgen:OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "<=" superDescNo: 27 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx <= to" 
   ;; Qgen: useRtnV:"True" descNo: 27 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx <= to" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx <= to" 
   ;; needOrigin:E: "<= to"  E.ATd: "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" 
   ;; doNeedOrigin:Ex: "<= to" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx <= to" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$26$26* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$26" newOriginOff: 1 origin: "@for::to:repeat$21" 
   ;; NA: "inx" origin: "$S$26$26" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$26$26 1
   ;; Rtype.rtop: "%$S$26$26*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$21*" 
   %R1 = getelementptr %$S$26$26,%$S$26$26 *%R0, i32 0, i32 1
   %R2 = load %$for$$to$repeat$21* , %$for$$to$repeat$21** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr: 2 :rec: "inx"  E: "<= to"  A.E: "inx" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E:notAssign: <= to 
   ;; $ObjectInvocation_Binary:"<= to" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $pattern:"<=  : {   %basic 52;   in V: var integer;   out B: var boolean"} 
   ;; >getAdr: 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "<=" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "<= to"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"<= to"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "<= to" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"<= to"} 
   ;; isFloat:B:  false 
;; pushg 3 $S$26$26
   %R3 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R2, i32 0, i32 3
   %V4 = load i32, i32* %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 4 R: 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "<= to" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"<= to"} 
   ;; rec:  "inx" E:  "<= to" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "<= to" superAdj= 0 
   ;; $ObjectInvocation_Binary:"<= to" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  to  hasArg:  pattern 
   ;; <= to   <=  : {   %basic 52;   in V: var integer;   out B: var boolean} 
   ;; $pattern:"<=  : {   %basic 52;   in V: var integer;   out B: var boolean"} 
   ;; >loadArgs:E:"<= to":descNo:27:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "<= to" 
   ;; ActArg:  "to" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "<= to" 
   ;; loadArgs:not:*:  formalArgOf: "<= to"  isCompositeValueObj: false 
   ;; loadArgs:A: "to" 
   ;; $ObjectGenerator:"to" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"to" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "to" 
   ;; not const:  to in to: var integer 
   ;; needorigin: "to" 
   ;; needOrigin:E: "to"  E.ATd: "in to: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "to" 
   ;; computeAdr: 1 :rec: "none"  E: "to" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"to" 
   ;; >pushThis: 
   ;; OI:pushThis: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" ATd: "in to: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 4 R: 0 
   ;; %$S$26$26* 
   ;; $ObjectInvocation_Unary:"to" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$26" newOriginOff: 1 origin: "@for::to:repeat$21" 
   ;; NA: "to" origin: "$S$26$26" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$26$26 1
   ;; Rtype.rtop: "%$S$26$26*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$21*" 
   %R5 = getelementptr %$S$26$26,%$S$26$26 *%R0, i32 0, i32 1
   %R6 = load %$for$$to$repeat$21* , %$for$$to$repeat$21** %R5
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 4 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 4 R: 6 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"to" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"in to: var integer" 
   ;; >getAdr:,newOff:2,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"to"}   in to: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "in to: var integer" ObjectGenerator 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; After:U*U: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "to"  ATd: "in to: var integer" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; computeAdr:isLast:E:  "to" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; rec:  "to" E:  "to" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "to" superAdj= 0 
   ;; $ObjectInvocation_Unary:"to" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; to   in to: var integer 
   ;; $var:"in to: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in to: var integer"  E:  "to" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"to":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "to" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "to" 
   ;; $ObjectInvocation_Unary:"to" 
   ;; >invoke: rec:"to" 
   ;; E.ATd:  "to" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; OI:invoke:B: "to" E: "to"  rec: "to"  useRtnV: true "in to: var integer" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; $var:"in to: var integer" 
   ;; >invoke:E: "to" newOff:2 useRTNv: "True" 
   ;; load: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"to"} 
   ;; isFloat:B:  false 
;; pushg 2 @for::to:repeat$21
   %R7 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R6, i32 0, i32 2
   %V8 = load i32, i32* %R7
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 4 R: 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 1 V: 8 R: 
   ;; BOBS! 
   ;; OI:invoke: to :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "to" 
   ;; loadArgs:after:Qgen: "<= to" 
   ;; formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "to" :isBasicVal: true 
   ;; to ObjectGenerator 
   ;; end:loadArgs:NonVirt: "<= to" 
   ;; IV:after:loadArgsOf: "<= to" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"<= to"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "<= to" 
   ;; $ObjectInvocation_Binary:"<= to" 
   ;; >invoke: rec:"inx" 
   ;; OI:invoke:isPtn: "<= to" descNo 27  useRTNv: true 
   ;; E.ATd:  "<=" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"<= to"} 
   ;; OI:invoke:B: "<= to" E: "<= to"  rec: "inx"  useRtnV: true "<=  : {   %basic 52;   in V: var integer;   out B: var boolean}" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"<= to"} 
   ;; $pattern:"<=  : {   %basic 52;   in V: var integer;   out B: var boolean"} 
   ;; >invoke:E: "<= to" useRTNv: "True" 
   ;; ptn:invoke: "<=" E: "<= to" useRtnV: true 
   ;; doPrimElse: <= 52 
   %V9 = icmp sle i32 %V4, %V8
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 0 rTopMax: 1 V: 9 R: 
   ;; OI:invoke: <= to :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "<= to" 
;; jmpFalse  L4
   ;; vTop(1,2)=[9/1] rTop(0,1)=[]
   br i1 %V9, label %L3, label %L4
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 1 V: R: 
   br label %L3
L3:
   ;; $ObjectGenerator:"repeat{inx := inx + 1;@restart _loop"} 
   ;; Qgen:OGid:"$S$28" singular! staticOff=0 descNo=28 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$26$26* 
   ;; before objTmpStack:add:  28   "$S$28" 
   ;; OGid: $S$28  OGidWdNo:  $S$28$28 
;; invoke $S$28 28 0 1
   ;; vTop(0,2)=[] rTop(1,1)=[0:%$S$26$26*]
   ;; alloc %$S$28$28
   %R10 = tail call i8* @malloc(i64 8)
   %R11 = bitcast i8* %R10 to %$S$28$28*
   ;; store VDT in object
   %R12 = getelementptr %$S$28$28, %$S$28$28* %R11, i32 0, i32 0
   store %vdt_type$$S$28$28* @vdt_data$$S$28$28, %vdt_type$$S$28$28** %R12
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 2 V: R: 11 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$28$28 this: $S$28$28 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$28$28 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(2,2)=[0:%$S$26$26*,11:%$S$28$28]
   ;; lookup:  %$S$26$26*
   ;; vTop(0,2)=[] rTop(2,2)=[0:%$S$26$26*,11:%$S$28$28]
   %R13 = getelementptr %$S$28$28, %$S$28$28 * %R11, i32 0, i32 1
   store %$S$26$26* %R0, %$S$26$26** %R13
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,2)=[11:%$S$28$28,0:%$S$26$26*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 11 
   ;; vTop(0,2)=[] rTop(1,2)=[11:%$S$28$28]
   ;; topSuper: 28   $S$28$28 
   %R14 = call %$S$28$28* @$S$28$28(%$S$28$28 * %R11)
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 11 
   %V17 = icmp eq %$S$28$28* %R14, %R11
   br i1 %V17, label %normalRtnLab15, label %breakLab16
breakLab16:
   %R18 = bitcast %$S$28$28* %R14 to %$S$26$26*
   %V19 = icmp eq %$S$26$26* %R0, %R18
   br i1 %V19, label %selectBreakLab21, label %contBreakLab20
contBreakLab20:
   ret %$S$26$26* %R18
selectBreakLab21:
   %R22 = bitcast %$S$28$28* %R14 to [0 x i32]*
   %R23 = getelementptr [0 x i32], [0 x i32]* %R22, i32 0, i32 0
   %V24 = load i32 , i32* %R23
   %R25 = getelementptr %$S$28$28,%$S$28$28* %R14, i32 0, i32 0
   store %vdt_type$$S$28$28* @vdt_data$$S$28$28, %vdt_type$$S$28$28** %R25
   %V26 = icmp eq i32 1, %V24
   br i1 %V26, label %X27, label %X28
X27:
   br label %L1 ; restart
X28:
   br label %L2 ; leave
normalRtnLab15:

   ;; vTop(0,2)=[] rTop(1,2)=[11:%$S$28$28*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 2 V: R: 
   br label %L4
L4:
   ;; invoke:after:E.invoke: "@if inx <= to :then {   repeat;   inx := inx + 1;   @restart _loop}" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %$S$26$26* 
   ;; vTop(0,2)=[] rTop(1,2)=[0:%$S$26$26*]
   ret %$S$26$26* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 26:I
@vdt_data$$S$26$26 = global %vdt_type$$S$26$26 {
      %$S$26$26*(%$S$26$26*)* @$S$26$26
}

define %vdt_ret$$S$26$26* @vdt_alloc$$S$26$26(%$for$$to$repeat$21* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$S$26$26
   %R30 = tail call i8* @malloc(i64 32)
   %R31 = bitcast i8* %R30 to %vdt_ret$$S$26$26*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$S$26$26 
   ;; alloc %$S$26$26
   %R32 = tail call i8* @malloc(i64 192)
   %R33 = bitcast i8* %R32 to %$S$26$26*
   ;; store VDT in object
   %R34 = getelementptr %$S$26$26, %$S$26$26* %R33, i32 0, i32 0
   store %vdt_type$$S$26$26* @vdt_data$$S$26$26, %vdt_type$$S$26$26** %R34
   %R35 = getelementptr %vdt_ret$$S$26$26,%vdt_ret$$S$26$26* %R31, i32 0, i32 0
   store %$S$26$26* %R33, %$S$26$26** %R35
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: @for::to:repeat thisClassOrgDescNo: 21 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 2 V: R: 33 
   ;; vTop(0,2)=[] rTop(2,2)=[1:%$for$$to$repeat$21*,33:%$S$26$26]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: $S$26 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$26$26 this: $S$26$26 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$26$26 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(2,2)=[1:%$for$$to$repeat$21*,33:%$S$26$26]
   ;; lookup:  %$for$$to$repeat$21*
   ;; vTop(0,2)=[] rTop(2,2)=[1:%$for$$to$repeat$21*,33:%$S$26$26]
   %R36 = getelementptr %$S$26$26, %$S$26$26 * %R33, i32 0, i32 1
   store %$for$$to$repeat$21* %R1, %$for$$to$repeat$21** %R36
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,2)=[33:%$S$26$26,1:%$for$$to$repeat$21*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 33 
   ;; vTop(0,2)=[] rTop(1,2)=[33:%$S$26$26]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$S$26$26* %R31
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 28 :top: 1 
   ;; Items:GenClass: $S$28 descNo: 28 
;; class  $S$28 28 1 $S$26 26

define %$S$28$28* @$S$28$28(%$S$28$28* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=28 vDescInx=28 vdtTop: 1
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "repeat" 
   ;; $ObjectGenerator:"repeat" 
   ;; Qgen:OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "repeat" superDescNo: 0 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"repeat" 
   ;; Qgen: useRtnV:"False" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "repeat" 
   ;; needorigin: "repeat" 
   ;; needOrigin:E: "repeat"  E.ATd: "in repeat:< Object" 
   ;; doNeedOrigin:Ex: "repeat" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "repeat" 
   ;; computeAdr: 1 :rec: "none"  E: "repeat" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"repeat" 
   ;; >pushThis: 
   ;; OI:pushThis: "repeat{inx := inx + 1;@restart _loop}" ATd: "in repeat:< Object" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$28$28* 
   ;; $ObjectInvocation_Unary:"repeat" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "$S$28" newOriginOff: 1 origin: "$S$26$26" 
   ;; NA: "repeat" origin: "$S$28$28" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$28$28 1
   ;; Rtype.rtop: "%$S$28$28*" typeInfo[rtop,off]=elmType: "%$S$26$26*" 
   %R1 = getelementptr %$S$28$28,%$S$28$28 *%R0, i32 0, i32 1
   %R2 = load %$S$26$26* , %$S$26$26** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$26" newOriginOff: 1 origin: "@for::to:repeat$21" 
   ;; NA: "repeat" origin: "$S$28$28" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$28$28 1
   ;; Rtype.rtop: "%$S$26$26*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$21*" 
   %R3 = getelementptr %$S$26$26,%$S$26$26 *%R2, i32 0, i32 1
   %R4 = load %$for$$to$repeat$21* , %$for$$to$repeat$21** %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 4 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"repeat" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"in repeat:< Object" 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "repeat"  ATd: "in repeat:< Object" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"} 
   ;; computeAdr:isLast:E:  "repeat" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"} 
   ;; rec:  "repeat" E:  "repeat" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "repeat" superAdj= 0 
   ;; $ObjectInvocation_Unary:"repeat" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; repeat   in repeat:< Object 
   ;; $pattern:"in repeat:< Object" 
   ;; >loadArgs:E:"repeat":descNo:0:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "repeat" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "repeat" 
   ;; $ObjectInvocation_Unary:"repeat" 
   ;; >invoke: rec:"repeat" 
   ;; OI:invoke:isPtn: "repeat" descNo 0  useRTNv: false 
   ;; E.ATd:  "repeat" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"} 
   ;; OI:invoke:B: "repeat" E: "repeat"  rec: "repeat"  useRtnV: false "in repeat:< Object" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"repeat"} 
   ;; $pattern:"in repeat:< Object" 
   ;; >invoke:E: "repeat" useRTNv: "False" 
   ;; ptn:invoke: "repeat" E: "repeat" useRtnV: false 
   ;; Pattern:invoke:useRTNv: false descNo: 0  top: 1  rec: "repeat" 
   ;; invokev: Object 
   ;; Using Vstub in vDescNo: 24 repeat 
   ;; invokeV:before: repeat$24$44 
;; invokev 2 0 repeat$24$44 0
   ;; vdt:dinx:  2 
   ;; vTop(0,0)=[] rTop(1,1)=[4:%$for$$to$repeat$21*]
   ;; load pointer to VDT 
   %R5 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R4, i32 0, i32 0
   ;; type of vdt =  %vdt_type$$for$$to$repeat$21* 
   %R6 = load %vdt_type$$for$$to$repeat$21*, %vdt_type$$for$$to$repeat$21** %R5
   ;; %R6  = ptr to VDT 
   ;; N:  repeat$24$44 Nsig: repeat$24$44 
   %R7 = getelementptr %vdt_type$$for$$to$repeat$21,%vdt_type$$for$$to$repeat$21* %R6, i32 0, i32 1
   ;; %R7  = &VDT[ 2 ] 
   ;; T: %vdt_ret$repeat$24$44* 
   ;; vTop(0,0)=[] rTop(1,1)=[4:%$for$$to$repeat$21*]
   %R8 = load %vdt_ret$repeat$24$44*(%$for$$to$repeat$21*)*, %vdt_ret$repeat$24$44*(%$for$$to$repeat$21*)** %R7
   ;; %R8  = obj.VDT[dinx] = [ 1 ] 
   ;; Call:VDT: %vdt_ret$repeat$24$44*  useStub: true 
   %R9 = call %vdt_ret$repeat$24$44* %R8(%$for$$to$repeat$21* %R4)
   ;; vTop(0,0)=[] rTop(1,1)=[4:%$for$$to$repeat$21*]
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 9 
   ;; vTop(0,0)=[] rTop(2,2)=[4:%$for$$to$repeat$21*,9:%vdt_ret$repeat$24$44*]
%R11 = getelementptr %vdt_ret$repeat$24$44, %vdt_ret$repeat$24$44* %R9, i32 0, i32 0
   %R10 = load %repeat$24$44*, %repeat$24$44** %R11
   %R12 = bitcast %repeat$24$44* %R10 to %Object$22*
   %R13 = call %Object$22* @Object$22(%Object$22* %R12)
   ;; useRtnVal: false :isVal: false :rtnValObj: false :rec=E: true "repeat" 
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; OI:invoke: repeat :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "repeat" 
   ;; genclass:stmt: "inx := inx + 1" 
   ;; $ObjectGenerator:"inx := inx + 1" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx := inx + 1" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx := inx + 1" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx := inx + 1" 
   ;; needOrigin:E: ":= inx + 1"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= inx + 1" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx := inx + 1" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "repeat{inx := inx + 1;@restart _loop}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %$S$28$28* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "$S$28" newOriginOff: 1 origin: "$S$26$26" 
   ;; NA: "inx" origin: "$S$28$28" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$28$28 1
   ;; Rtype.rtop: "%$S$28$28*" typeInfo[rtop,off]=elmType: "%$S$26$26*" 
   %R14 = getelementptr %$S$28$28,%$S$28$28 *%R0, i32 0, i32 1
   %R15 = load %$S$26$26* , %$S$26$26** %R14
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 15 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$26" newOriginOff: 1 origin: "@for::to:repeat$21" 
   ;; NA: "inx" origin: "$S$28$28" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$28$28 1
   ;; Rtype.rtop: "%$S$26$26*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$21*" 
   %R16 = getelementptr %$S$26$26,%$S$26$26 *%R15, i32 0, i32 1
   %R17 = load %$for$$to$repeat$21* , %$for$$to$repeat$21** %R16
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 17 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr: 2 :rec: "inx"  E: ":= inx + 1"  A.E: "inx" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isAssign:rec:  "inx"  E: ":= inx + 1" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  ":= inx + 1" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  ":= inx + 1" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= inx + 1" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= inx + 1" 
   ;; >loadArgs:staticOff:3 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  inx + 1  hasArg:  pattern 
   ;; := inx + 1   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= inx + 1":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= inx + 1" 
   ;; ActArg:  "inx + 1" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= inx + 1" 
   ;; loadArgs:A: "inx + 1" 
   ;; $ObjectGenerator:"inx + 1" 
   ;; Qgen:OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "+" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx + 1" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx + 1" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx + 1" 
   ;; needOrigin:E: "+ 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; doNeedOrigin:Ex: "+ 1" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx + 1" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "repeat{inx := inx + 1;@restart _loop}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 0 
   ;; %$S$28$28* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "$S$28" newOriginOff: 1 origin: "$S$26$26" 
   ;; NA: "inx" origin: "$S$28$28" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$28$28 1
   ;; Rtype.rtop: "%$S$28$28*" typeInfo[rtop,off]=elmType: "%$S$26$26*" 
   %R18 = getelementptr %$S$28$28,%$S$28$28 *%R0, i32 0, i32 1
   %R19 = load %$S$26$26* , %$S$26$26** %R18
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 17 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 19 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$26" newOriginOff: 1 origin: "@for::to:repeat$21" 
   ;; NA: "inx" origin: "$S$28$28" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$28$28 1
   ;; Rtype.rtop: "%$S$26$26*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$21*" 
   %R20 = getelementptr %$S$26$26,%$S$26$26 *%R19, i32 0, i32 1
   %R21 = load %$for$$to$repeat$21* , %$for$$to$repeat$21** %R20
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 17 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 21 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr: 2 :rec: "inx"  E: "+ 1"  A.E: "inx" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E:notAssign: + 1 
   ;; $ObjectInvocation_Binary:"+ 1" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >getAdr: 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "+ 1"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ 1"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "+ 1" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ 1"} 
   ;; isFloat:B:  false 
;; pushg 3 $S$28$28
   %R22 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R21, i32 0, i32 3
   %V23 = load i32, i32* %R22
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 17 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 23 R: 17 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "+ 1" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ 1"} 
   ;; rec:  "inx" E:  "+ 1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "+ 1" superAdj= 0 
   ;; $ObjectInvocation_Binary:"+ 1" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  1  hasArg:  pattern 
   ;; + 1   +  : {   %basic 61;   in V: var integer;   out R: var integer} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >loadArgs:E:"+ 1":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "+ 1" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "+ 1" 
   ;; loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V24 = add i32 0, 1
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 24 R: 17 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "+ 1" 
   ;; formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "+ 1" 
   ;; IV:after:loadArgsOf: "+ 1" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ 1"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "+ 1" 
   ;; $ObjectInvocation_Binary:"+ 1" 
   ;; >invoke: rec:"inx" 
   ;; OI:invoke:isPtn: "+ 1" descNo 0  useRTNv: true 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ 1"} 
   ;; OI:invoke:B: "+ 1" E: "+ 1"  rec: "inx"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ 1"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >invoke:E: "+ 1" useRTNv: "True" 
   ;; ptn:invoke: "+" E: "+ 1" useRtnV: true 
   ;; doPrimElse: + 61 
   %V25 = add i32 %V23, %V24
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 17 
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 25 R: 17 
   ;; OI:invoke: + 1 :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "+ 1" 
   ;; loadArgs:after:Qgen: ":= inx + 1" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; BINGO 
   ;; aaaa:  in V: var Value{--inner(Value);} 
   ;; end:loadArgs:NonVirt: ":= inx + 1" 
   ;; IV:after:loadArgsOf: ":= inx + 1" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= inx + 1" 
   ;; $ObjectInvocation_Binary:":= inx + 1" 
   ;; >invoke: rec:"inx" 
   ;; OI:invoke:isPtn: ":= inx + 1" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: ":= inx + 1" E: ":= inx + 1"  rec: "inx"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= inx + 1"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= inx + 1" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= inx + 1" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "inx" from:  ":= inx + 1" 
   ;; assign:dstDI : "inx: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "inx + 1" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: inx + 1 
   ;;  arg.super.ATd: "Invocation" "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= inx + 1"  rec:  "inx" "$S$28$28" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= inx + 1"} 
   ;; store: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  @for::to:repeat$21 3
   %R26 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R17, i32 0, i32 3
   store i32 %V25, i32* %R26
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 17 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 4 
   ;; OI:invoke: := inx + 1 :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= inx + 1" 
   ;; genclass:stmt: "@restart _loop" 
   ;; $ObjectGenerator:"@restart _loop" 
   ;; Qgen:OGid:"@restart:" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "@restart" superDescNo: 29 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"@restart _loop" 
   ;; Qgen: useRtnV:"False" descNo: 29 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "@restart _loop" 
   ;; needorigin: "@restart _loop" 
   ;; needOrigin:E: "@restart _loop"  E.ATd: "@restart: {   %basic 102;   in restart: var integer}" 
   ;; doNeedOrigin:Ex: "@restart _loop" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "@restart _loop" 
   ;; computeAdr: 1 :rec: "none"  E: "@restart _loop" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_KeyWord:"@restart _loop" 
   ;; >pushThis: 
   ;; OI:pushThis: "repeat{inx := inx + 1;@restart _loop}" ATd: "@restart: {   %basic 102;   in restart: var integer}" 
   ;; $ObjectInvocation_KeyWord:"@restart _loop" 
   ;; >loadOrigin::on:3 
   ;; $ObjectInvocation_KeyWord:"@restart _loop" 
   ;; >getAdr::superAdj:0:on:3 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@restart: {   %basic 102;   in restart: var integer"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"} 
   ;; E.on: 3 
   ;; beforeIsValueObj:E: "@restart _loop"  ATd: "@restart: {   %basic 102;   in restart: var integer}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"} 
   ;; computeAdr:isLast:E:  "@restart _loop" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"} 
   ;; rec:  "@restart _loop" E:  "@restart _loop" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@restart _loop" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"@restart _loop" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @restart _loop  hasArg:  pattern 
   ;; @restart _loop   @restart: {   %basic 102;   in restart: var integer} 
   ;; $pattern:"@restart: {   %basic 102;   in restart: var integer"} 
   ;; >loadArgs:E:"@restart _loop":descNo:29:top:0 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "@restart _loop" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "@restart _loop" 
   ;; $ObjectInvocation_KeyWord:"@restart _loop" 
   ;; >invoke: rec:"@restart _loop" 
   ;; OI:invoke:isPtn: "@restart _loop" descNo 29  useRTNv: false 
   ;; E.ATd:  "@restart" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"} 
   ;; OI:invoke:B: "@restart _loop" E: "@restart _loop"  rec: "@restart _loop"  useRtnV: false "@restart: {   %basic 102;   in restart: var integer}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@restart _loop"} 
   ;; $pattern:"@restart: {   %basic 102;   in restart: var integer"} 
   ;; >invoke:E: "@restart _loop" useRTNv: "False" 
   ;; ptn:invoke: "@restart" E: "@restart _loop" useRtnV: false 
;; break  1 1 26 0
   ;; vTop(0,2)=[] rTop(1,3)=[4:%$for$$to$repeat$21*]
   %R27 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21 *%R4, i32 0, i32 0
   %R28 = bitcast %vdt_type$$for$$to$repeat$21** %R27 to i32*
store i32 1, i32* %R28
   %R29 = bitcast %$for$$to$repeat$21* %R4 to %$S$28$28*
   ret %$S$28$28* %R29
   ;; OI:invoke: @restart _loop :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "@restart _loop" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 0 
   ;; %$S$28$28* 
   ;; vTop(0,2)=[] rTop(2,3)=[4:%$for$$to$repeat$21*,0:%$S$28$28*]
   ret %$S$28$28* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 4 
}
   ;; vdt:vdtTop: 1 28:I
@vdt_data$$S$28$28 = global %vdt_type$$S$28$28 {
      %$S$28$28*(%$S$28$28*)* @$S$28$28
}

define %vdt_ret$$S$28$28* @vdt_alloc$$S$28$28(%$S$26$26* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$S$28$28
   %R31 = tail call i8* @malloc(i64 32)
   %R32 = bitcast i8* %R31 to %vdt_ret$$S$28$28*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$S$28$28 
   ;; alloc %$S$28$28
   %R33 = tail call i8* @malloc(i64 192)
   %R34 = bitcast i8* %R33 to %$S$28$28*
   ;; store VDT in object
   %R35 = getelementptr %$S$28$28, %$S$28$28* %R34, i32 0, i32 0
   store %vdt_type$$S$28$28* @vdt_data$$S$28$28, %vdt_type$$S$28$28** %R35
   %R36 = getelementptr %vdt_ret$$S$28$28,%vdt_ret$$S$28$28* %R32, i32 0, i32 0
   store %$S$28$28* %R34, %$S$28$28** %R36
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: $S$26 thisClassOrgDescNo: 26 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 34 
   ;; vTop(0,2)=[] rTop(3,3)=[4:%$for$$to$repeat$21*,1:%$S$26$26*,34:%$S$28$28]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: $S$28 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$28$28 this: $S$28$28 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$28$28 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(3,3)=[4:%$for$$to$repeat$21*,1:%$S$26$26*,34:%$S$28$28]
   ;; lookup:  %$S$26$26*
   ;; vTop(0,2)=[] rTop(3,3)=[4:%$for$$to$repeat$21*,1:%$S$26$26*,34:%$S$28$28]
   %R37 = getelementptr %$S$28$28, %$S$28$28 * %R34, i32 0, i32 1
   store %$S$26$26* %R1, %$S$26$26** %R37
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,3)=[4:%$for$$to$repeat$21*,34:%$S$28$28,1:%$S$26$26*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 34 
   ;; vTop(0,2)=[] rTop(2,3)=[4:%$for$$to$repeat$21*,34:%$S$28$28]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$S$28$28* %R32
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 32 :top: 1 
   ;; Items:GenClass: repeat$S$32 descNo: 32 
;; class  repeat$S$32 32 1 @for::to:repeat$S$25 25

define %repeat$S$32$32* @repeat$S$32$32(%repeat$S$32$32* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=32 vDescInx=32 vdtTop: 1
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "put ( 'Q' + inx )" 
   ;; $ObjectGenerator:"put ( 'Q' + inx )" 
   ;; Qgen:OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "put" superDescNo: 20 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"put ( 'Q' + inx )" 
   ;; Qgen: useRtnV:"False" descNo: 20 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "put ( 'Q' + inx )" 
   ;; needorigin: "put ( 'Q' + inx )" 
   ;; needOrigin:E: "put ( 'Q' + inx )"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "%globals{%basic 2;in ch: val char}" 
   ;; IV:no:needOrigin:E:  "put ( 'Q' + inx )" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "put ( 'Q' + inx )" E:  "put ( 'Q' + inx )" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "put ( 'Q' + inx )" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"put ( 'Q' + inx )" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  put ( 'Q' + inx )  hasArg:  pattern 
   ;; put ( 'Q' + inx )   put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char} 
   ;; $pattern:"put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char"} 
   ;; >loadArgs:E:"put ( 'Q' + inx )":descNo:20:top:1 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "put ( 'Q' + inx )" 
   ;; ActArg:  "'Q' + inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "put ( 'Q' + inx )" 
   ;; loadArgs:not:*:  formalArgOf: "put ( 'Q' + inx )"  isCompositeValueObj: false 
   ;; loadArgs:A: "'Q' + inx" 
   ;; $ObjectGenerator:"'Q' + inx" 
   ;; Qgen:OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "+" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"'Q' + inx" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "'Q' + inx" 
   ;; needorigin: "'Q' + inx" 
   ;; needOrigin:E: "+ inx"  E.ATd: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
   ;; doNeedOrigin:Ex: "+ inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "'Q' + inx" 
   ;; computeAdr: 1 :rec: "none"  E: "'Q'" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $Char::"'Q'" 
   ;; >pushThis: 
   ;; $Char::"'Q'" 
   ;; >loadOrigin: 
   ;; $Char::"'Q'" 
   ;; >getAdr: 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; computeAdr: 2 :rec: "'Q'"  E: "+ inx"  A.E: "'Q'" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; E:notAssign: + inx 
   ;; $ObjectInvocation_Binary:"+ inx" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var char;   out R: var char"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $Char::"'Q'" 
   ;; >loadArgs: 
   ;; $Char::"'Q'" 
   ;; >invoke: 
;; pushc 81
   %V1 = add i32 0, 81
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 0 V: 1 R: 
   ;; computeAdr:isLast:E:  "+ inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; rec:  "'Q'" E:  "+ inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "+ inx" superAdj= 0 
   ;; $ObjectInvocation_Binary:"+ inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  inx  hasArg:  pattern 
   ;; + inx   +  : {   %basic 61;   in V: var char;   out R: var char} 
   ;; $pattern:"+  : {   %basic 61;   in V: var char;   out R: var char"} 
   ;; >loadArgs:E:"+ inx":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "+ inx" 
   ;; ActArg:  "inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "+ inx" 
   ;; loadArgs:not:*:  formalArgOf: "+ inx"  isCompositeValueObj: false 
   ;; loadArgs:A: "inx" 
   ;; $ObjectGenerator:"inx" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx" 
   ;; needOrigin:E: "inx"  E.ATd: "inx: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "put ( 'Q' + inx )" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 0 
   ;; %repeat$S$32$32* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "repeat$S$32" newOriginOff: 1 origin: "@for::to:repeat$S$25$25" 
   ;; NA: "inx" origin: "repeat$S$32$32" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$32$32 1
   ;; Rtype.rtop: "%repeat$S$32$32*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$25$25*" 
   %R2 = getelementptr %repeat$S$32$32,%repeat$S$32$32 *%R0, i32 0, i32 1
   %R3 = load %$for$$to$repeat$S$25$25* , %$for$$to$repeat$S$25$25** %R2
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 3 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  "inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  "inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inx" superAdj= 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "inx" 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "inx" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "inx" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isFloat:B:  false 
;; pushg 3 @for::to:repeat$S$25$25
   %R4 = getelementptr %$for$$to$repeat$S$25$25,%$for$$to$repeat$S$25$25 *%R3, i32 0, i32 3
   %V5 = load i32, i32* %R4
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 1 V: 5 R: 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inx" 
   ;; loadArgs:after:Qgen: "+ inx" 
   ;; formalArg:isPtn: "in V: var char" :isBasicVal: true :valueObj: true 
   ;; :actArg: "inx" :isBasicVal: true 
   ;; inx ObjectGenerator 
   ;; end:loadArgs:NonVirt: "+ inx" 
   ;; IV:after:loadArgsOf: "+ inx" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "+ inx" 
   ;; $ObjectInvocation_Binary:"+ inx" 
   ;; >invoke: rec:"'Q'" 
   ;; OI:invoke:isPtn: "+ inx" descNo 0  useRTNv: true 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"'Q'"} 
   ;; OI:invoke:B: "+ inx" E: "+ inx"  rec: "'Q'"  useRtnV: true "+  : {   %basic 61;   in V: var char;   out R: var char}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"+ inx"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var char;   out R: var char"} 
   ;; >invoke:E: "+ inx" useRTNv: "True" 
   ;; ptn:invoke: "+" E: "+ inx" useRtnV: true 
   ;; doPrimElse: + 61 
   %V6 = add i32 %V1, %V5
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 0 rTopMax: 1 V: 6 R: 
   ;; OI:invoke: + inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "+ inx" 
   ;; loadArgs:after:Qgen: "put ( 'Q' + inx )" 
   ;; formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
   ;; :actArg: "'Q' + inx" :isBasicVal: true 
   ;; 'Q' + inx ObjectGenerator 
   ;; end:loadArgs:NonVirt: "put ( 'Q' + inx )" 
   ;; IV:after:loadArgsOf: "put ( 'Q' + inx )"  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "put ( 'Q' + inx )" 
   ;; $ObjectInvocation_KeyWord:"put ( 'Q' + inx )" 
   ;; >invoke: rec:"put ( 'Q' + inx )" 
   ;; OI:invoke:isPtn: "put ( 'Q' + inx )" descNo 20  useRTNv: false 
   ;; OI:invoke:B: "put ( 'Q' + inx )" E: "put ( 'Q' + inx )"  rec: "put ( 'Q' + inx )"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
   ;; adr:none 
   ;; $pattern:"put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char"} 
   ;; >invoke:E: "put ( 'Q' + inx )" useRTNv: "False" 
   ;; ptn:invoke: "put" E: "put ( 'Q' + inx )" useRtnV: false 
   call i32 @putCh(i32 %V6)
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 1 V: R: 

   ;; OI:invoke: put ( 'Q' + inx ) :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "put ( 'Q' + inx )" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %repeat$S$32$32* 
   ;; vTop(0,2)=[] rTop(1,1)=[0:%repeat$S$32$32*]
   ret %repeat$S$32$32* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 32:I
@vdt_data$repeat$S$32$32 = global %vdt_type$repeat$S$32$32 {
      %repeat$S$32$32*(%repeat$S$32$32*)* @repeat$S$32$32
}

define %vdt_ret$repeat$S$32$32* @vdt_alloc$repeat$S$32$32(%$for$$to$repeat$S$25$25* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$repeat$S$32$32
   %R8 = tail call i8* @malloc(i64 32)
   %R9 = bitcast i8* %R8 to %vdt_ret$repeat$S$32$32*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %repeat$S$32$32 
   ;; alloc %repeat$S$32$32
   %R10 = tail call i8* @malloc(i64 192)
   %R11 = bitcast i8* %R10 to %repeat$S$32$32*
   ;; store VDT in object
   %R12 = getelementptr %repeat$S$32$32, %repeat$S$32$32* %R11, i32 0, i32 0
   store %vdt_type$repeat$S$32$32* @vdt_data$repeat$S$32$32, %vdt_type$repeat$S$32$32** %R12
   %R13 = getelementptr %vdt_ret$repeat$S$32$32,%vdt_ret$repeat$S$32$32* %R9, i32 0, i32 0
   store %repeat$S$32$32* %R11, %repeat$S$32$32** %R13
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: @for::to:repeat$S$25 thisClassOrgDescNo: 25 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 2 V: R: 11 
   ;; vTop(0,2)=[] rTop(2,2)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: repeat$S$32 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$32$32 this: repeat$S$32$32 originOff: 1 orgIsValObj: false 
;; rdouble -1
   ;; vTop(0,2)=[] rTop(2,2)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 11 
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$25$25*,1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 repeat$S$32$32 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$25$25*,1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   ;; lookup:  %$for$$to$repeat$S$25$25*
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$25$25*,1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   %R14 = getelementptr %repeat$S$32$32, %repeat$S$32$32 * %R11, i32 0, i32 1
   store %$for$$to$repeat$S$25$25* %R1, %$for$$to$repeat$S$25$25** %R14
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32,1:%$for$$to$repeat$S$25$25*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 11 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   ;; go:super.ATd: "in repeat:< Object" thisOG.super.on: 0 thisOG.OGid: "repeat$S$32" 
   ;; 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
;; rswap  0
   ;; goOriginAdr:  "" 
   ;; goOriginAdr:isImplSuper: 
   ;; vTop(0,2)=[] rTop(2,3)=[11:%repeat$S$32$32,1:%$for$$to$repeat$S$25$25*]
   ;; vTop(0,2)=[] rTop(2,3)=[11:%repeat$S$32$32,1:%$for$$to$repeat$S$25$25*] 
   ;; Object   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$32$32 this: Object$22 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; go:super.ATd: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;     ...}" t ... 1 t ... "O ..." 
   ;; thisOG.IS: origin: "Object" 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
;; rswap  0
   ;; goOriginAdr:  "Object" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadOrigin::on:1 
   ;; goOriginAdr:not:BracE: ObjectInvocation_Unary 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; vTop(0,2)=[] rTop(2,3)=[11:%repeat$S$32$32,1:%$for$$to$repeat$S$25$25*]
   ;; before:E.loadArgs: Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; Object   Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %bas ...} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >loadArgs:E:"Object":descNo:22:top:1 
   ;; isValueAssign:  false 
   ;; vTop(0,2)=[] rTop(2,3)=[11:%repeat$S$32$32,1:%$for$$to$repeat$S$25$25*] 
   ;; Object   1 
;; rswap  0
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$32$32 this: Object$22 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 repeat$S$32$32 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   ;; lookup:  %$for$$to$repeat$S$25$25*
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$25$25*,11:%repeat$S$32$32]
   %R15 = getelementptr %repeat$S$32$32, %repeat$S$32$32 * %R11, i32 0, i32 1
   store %$for$$to$repeat$S$25$25* %R1, %$for$$to$repeat$S$25$25** %R15
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,3)=[11:%repeat$S$32$32,1:%$for$$to$repeat$S$25$25*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 11 
   ;; vTop(0,2)=[] rTop(1,3)=[11:%repeat$S$32$32]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$repeat$S$32$32* %R9
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 25 :top: 1 
   ;; Items:GenClass: @for::to:repeat$S$25 descNo: 25 
;; class  @for::to:repeat$S$25 25 4 mini4 19

define %$for$$to$repeat$S$25$25* @$for$$to$repeat$S$25$25(%$for$$to$repeat$S$25$25* %R0){
   %V0 = add i32 0, 0
;; rstore  4 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtTableCopy: I:1:21 V:2:44 I:3:0
   ;; vdtAdd: inx=3 descInx=25 vDescInx=25 vdtTop: 3
   ;; push:super.origin: 
   ;; handleSuperArgs:E: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" theIS: "" 
   ;; super.sig:none:superAdj: 4 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 4 
   ;; args:  @for 1 :to 1 :repeat {   put ( 'Q' + inx )}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to 1 :repeat {   put ( 'Q' + inx )}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  4   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  4 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  4 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 4 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 4 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V1 = add i32 0, 1
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 0 V: 1 R: 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  4   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  4 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  4 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 4 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 4 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V2 = add i32 0, 1
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 0 V: 2 R: 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; args:  "in repeat:< Object" "put ( 'Q' + inx )" @for::to:repeat 
   ;; hArgOrg:super: @for::to:repeat 
   ;; vdtAdd: inx=1 descInx=25 vDescInx=21 vdtTop: 3
   ;; $Property:"%globals inSub" 
   ;; Qgen: 
   ;; $var:"in for: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  for 
   ;; $var:"in to: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  to 
   ;; $pattern:"in repeat:< Object" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"inx: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  inx 
   ;; $Property:"%private" 
   ;; Qgen: 
   ;; toSuper
;; do:
   br label %L1
L1:
   br label %L2
L2:
;; rtnInner  M
   ret %$for$$to$repeat$S$25$25 *%R0
}
   ;; Handle VB: "" E: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; vdtAdd: inx=2 descInx=25 vDescInx=32 vdtTop: 3
   ;; vdt:vdtTop: 3 21:I,32:V,25:I
@vdt_data$$for$$to$repeat$S$25$25 = global %vdt_type$$for$$to$repeat$S$25$25 {
      %$for$$to$repeat$21*(%$for$$to$repeat$21*)* @$for$$to$repeat$21,
      %vdt_ret$repeat$S$32$32*(%$for$$to$repeat$S$25$25*)* @vdt_alloc$repeat$S$32$32,
      %$for$$to$repeat$S$25$25*(%$for$$to$repeat$S$25$25*)* @$for$$to$repeat$S$25$25
}

define %vdt_ret$$for$$to$repeat$S$25$25* @vdt_alloc$$for$$to$repeat$S$25$25(%mini4$19* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$for$$to$repeat$S$25$25
   %R4 = tail call i8* @malloc(i64 32)
   %R5 = bitcast i8* %R4 to %vdt_ret$$for$$to$repeat$S$25$25*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$for$$to$repeat$S$25$25 
   ;; alloc %$for$$to$repeat$S$25$25
   %R6 = tail call i8* @malloc(i64 192)
   %R7 = bitcast i8* %R6 to %$for$$to$repeat$S$25$25*
   ;; store VDT in object
   %R8 = getelementptr %$for$$to$repeat$S$25$25, %$for$$to$repeat$S$25$25* %R7, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$S$25$25* @vdt_data$$for$$to$repeat$S$25$25, %vdt_type$$for$$to$repeat$S$25$25** %R8
   %R9 = getelementptr %vdt_ret$$for$$to$repeat$S$25$25,%vdt_ret$$for$$to$repeat$S$25$25* %R5, i32 0, i32 0
   store %$for$$to$repeat$S$25$25* %R7, %$for$$to$repeat$S$25$25** %R9
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: mini4 thisClassOrgDescNo: 19 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 1 V: 2 R: 1 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 2 V: 2 R: 7 
   ;; vTop(2,2)=[1/0,2/0] rTop(2,2)=[1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: @for::to:repeat$S$25 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$25$25 this: @for::to:repeat$S$25$25 originOff: 4 orgIsValObj: false 
;; rdouble -1
   ;; vTop(2,2)=[1/0,2/0] rTop(2,2)=[1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 3 rTopMax: 3 V: 2 R: 7 
   ;; vTop(2,2)=[1/0,2/0] rTop(3,3)=[1:%mini4$19*,1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  4 @for::to:repeat$S$25$25 isValueObjectOrigin: F
   ;; vTop(2,2)=[1/0,2/0] rTop(3,3)=[1:%mini4$19*,1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
   ;; lookup:  %mini4$19*
   ;; vTop(2,2)=[1/0,2/0] rTop(3,3)=[1:%mini4$19*,1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
   %R10 = getelementptr %$for$$to$repeat$S$25$25, %$for$$to$repeat$S$25$25 * %R7, i32 0, i32 4
   store %mini4$19* %R1, %mini4$19** %R10
;; rswap  0
   ;; vTop(2,2)=[1/0,2/0] rTop(3,3)=[1:%mini4$19*,7:%$for$$to$repeat$S$25$25,1:%mini4$19*]
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 2 R: 7 
   ;; vTop(2,2)=[1/0,2/0] rTop(2,3)=[1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
   ;; go:super.ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loo ...}" t ... 2 t ... "@ ..." 
   ;; thisOG.IS: origin: "@for::to:repeat$S$25" thisOG.IS: origin: "@for::to:repeat$S$25" 
   ;; vTop(2,2)=[1/0,2/0] rTop(2,3)=[1:%mini4$19*,7:%$for$$to$repeat$S$25$25]
;; rswap  0
   ;; goOriginAdr:  "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  @for 1 :to 1 :repeat {   put ( 'Q' + inx )} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "mini4" newOriginOff: 1 origin: "LLVMex$18" 
   ;; NA: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" origin: "mini4$19" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg mini4$19 1
   ;; Rtype.rtop: "%mini4$19*" typeInfo[rtop,off]=elmType: "%LLVMex$18*" 
   %R11 = getelementptr %mini4$19,%mini4$19 *%R1, i32 0, i32 1
   %R12 = load %LLVMex$18* , %LLVMex$18** %R11
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 2 R: 7 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 2 R: 12 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "LLVMex" newOriginOff: 1 origin: "workspace$17" 
   ;; NA: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" origin: "mini4$19" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg mini4$19 1
   ;; Rtype.rtop: "%LLVMex$18*" typeInfo[rtop,off]=elmType: "%workspace$17*" 
   %R13 = getelementptr %LLVMex$18,%LLVMex$18 *%R12, i32 0, i32 1
   %R14 = load %workspace$17* , %workspace$17** %R13
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 2 R: 7 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 2 R: 14 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; IV:viaIncl:on: 0 "BETA"  org: "%id "workspace"{%include BETA, LIB, LIB.BasicIO, qbeta;%domain_boundary;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--ArmLed;--ArmMulti ...}" 
   ;; viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
   ;; items:goOrigin: 1 
   ;; goOrigin: "workspace" newOriginOff: 1 origin: "BETAworld$1" 
   ;; NA: "BETA" origin: "workspace$17" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg workspace$17 1
   ;; Rtype.rtop: "%workspace$17*" typeInfo[rtop,off]=elmType: "%BETAworld$1*" 
   %R15 = getelementptr %workspace$17,%workspace$17 *%R14, i32 0, i32 1
   %R16 = load %BETAworld$1* , %BETAworld$1** %R15
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 2 R: 7 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 2 R: 16 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
;; rpushg BETA 2
   ;; Rtype.rtop: "%BETAworld$1*" typeInfo[rtop,off]=elmType: "%BETA$2*" 
   %R17 = getelementptr %BETAworld$1,%BETAworld$1 *%R16, i32 0, i32 2
   %R18 = load %BETA$2* , %BETA$2** %R17
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 2 R: 7 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 2 R: 18 
   ;; goOriginAdr:not:BracE: ObjectInvocation_KeyWord 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to 1 :repeat ;   put ( 'Q' + inx )"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to 1 :repeat ;   put ( 'Q' + inx )"} 
   ;; vTop(2,2)=[1/0,2/0] rTop(2,3)=[7:%$for$$to$repeat$S$25$25,18:%BETA$2*]
   ;; before:E.loadArgs: @for 1 :to 1 :repeat {   put ( 'Q' + inx )} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @for 1 :to 1 :repeat {   put ( 'Q' + inx )}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to 1 :repeat {   put ( 'Q' + inx )}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to 1 :repeat {   put ( 'Q' + inx )":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V19 = add i32 0, 1
   ;; stack: vpush : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 19 R: 18 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V20 = add i32 0, 1
   ;; stack: vpush : vTop: 4 vTopMax: 4 rTop: 2 rTopMax: 3 V: 20 R: 18 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to 1 :repeat {   put ( 'Q' + inx )}" 
   ;; vTop(4,4)=[1/0,2/0,19/0,20/0] rTop(2,3)=[7:%$for$$to$repeat$S$25$25,18:%BETA$2*] 
   ;; @for::to:repeat   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$25$25 this: @for::to:repeat$21 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$for$$to$repeat$S$25$25* %R5
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  true 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 33 :top: 1 
   ;; Items:GenClass: + descNo: 33 
;; class  + 33 1 String 15

define %_add$33* @_add$33(%_add$33* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=33 vDescInx=33 vdtTop: 1
   ;; $ref:"in S: ref String" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: false :primNo: 5 
   ;; OGqual: "String" :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; $ref:"out V: ref String" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: false :primNo: 5 
   ;; OGqual: "String" :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; $var:"L: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  L 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "L := Length" 
   ;; $ObjectGenerator:"L := Length" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"L := Length" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "L := Length" 
   ;; not const:  L L: var integer 
   ;; needorigin: "L := Length" 
   ;; needOrigin:E: ":= Length"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= Length" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "L := Length" 
   ;; computeAdr: 1 :rec: "none"  E: "L" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >pushThis: 
   ;; OI:pushThis: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for ...}" A ... "L ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %_add$33* 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadOrigin::on:0 
   ;; AdjustOrigin:originOff: 0 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"L: var integer" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"L"}   L: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "L: var integer" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr: 2 :rec: "L"  E: ":= Length"  A.E: "L" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr:isAssign:rec:  "L"  E: ":= Length" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr:isLast:E:  ":= Length" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; rec:  "L" E:  ":= Length" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= Length" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= Length" 
   ;; >loadArgs:staticOff:4 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  Length  hasArg:  pattern 
   ;; := Length   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= Length":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= Length" 
   ;; ActArg:  "Length" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= Length" 
   ;; loadArgs:A: "Length" 
   ;; $ObjectGenerator:"Length" 
   ;; Qgen:OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "length" superDescNo: 34 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"Length" 
   ;; Qgen: useRtnV:"True" descNo: 34 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "Length" 
   ;; needorigin: "Length" 
   ;; needOrigin:E: "Length"  E.ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; doNeedOrigin:Ex: "Length" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "Length" 
   ;; computeAdr: 1 :rec: "none"  E: "Length" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"Length" 
   ;; >pushThis: 
   ;; OI:pushThis: "in S: ref String{out V: ref String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for ...}" A ... "l ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %_add$33* 
   ;; $ObjectInvocation_Unary:"Length" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "+" newOriginOff: 1 origin: "String$15" 
   ;; NA: "Length" origin: "+$33" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg +$33 1
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R1 = getelementptr %_add$33,%_add$33 *%R0, i32 0, i32 1
   %R2 = load %String$15* , %String$15** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"Length" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "Length"  ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"} 
   ;; computeAdr:isLast:E:  "Length" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"} 
   ;; rec:  "Length" E:  "Length" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "Length" superAdj= 0 
   ;; $ObjectInvocation_Unary:"Length" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; Length   length: {   out V: var integer;   V := @get 0} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >loadArgs:E:"Length":descNo:34:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "Length" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "Length" 
   ;; $ObjectInvocation_Unary:"Length" 
   ;; >invoke: rec:"Length" 
   ;; OI:invoke:isPtn: "Length" descNo 34  useRTNv: true 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"} 
   ;; OI:invoke:B: "Length" E: "Length"  rec: "Length"  useRtnV: true "length: {   out V: var integer;   V := @get 0}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Length"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >invoke:E: "Length" useRTNv: "True" 
   ;; ptn:invoke: "length" E: "Length" useRtnV: true 
   ;; Pattern:invoke:useRTNv: true descNo: 34  top: 1  rec: "Length" 
   ;; ptn:invoke: useRtnV: true isValObj: false :rtnValObj: true : "length: {   out V: var integer;   V := @get 0}" 
   ;; rec=E: true :rec: "Length" 
   ;; before:invoke:useReturnValue:  true 
   ;; OGid: length  OGidWdNo:  length$34 
;; invoke length 34 0 1
   ;; vTop(0,0)=[] rTop(2,2)=[0:%_add$33*,2:%String$15*]
   ;; alloc %length$34
   %R3 = tail call i8* @malloc(i64 12)
   %R4 = bitcast i8* %R3 to %length$34*
   ;; store VDT in object
   %R5 = getelementptr %length$34, %length$34* %R4, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R5
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 4 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: length$34 this: length$34 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 length$34 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(3,3)=[0:%_add$33*,2:%String$15*,4:%length$34]
   ;; lookup:  %String$15*
   ;; vTop(0,0)=[] rTop(3,3)=[0:%_add$33*,2:%String$15*,4:%length$34]
   %R6 = getelementptr %length$34, %length$34 * %R4, i32 0, i32 1
   store %String$15* %R2, %String$15** %R6
;; rswap  0
   ;; vTop(0,0)=[] rTop(3,3)=[0:%_add$33*,4:%length$34,2:%String$15*]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 4 
   ;; vTop(0,0)=[] rTop(2,3)=[0:%_add$33*,4:%length$34]
   ;; topSuper: 34   length$34 
   %R7 = call %length$34* @length$34(%length$34 * %R4)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 3 V: R: 0 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 4 
   %V10 = icmp eq %length$34* %R7, %R4
   br i1 %V10, label %normalRtnLab8, label %breakLab9
breakLab9:
   %R11 = bitcast %length$34* %R7 to %_add$33*
   %V12 = icmp eq %_add$33* %R0, %R11
   br i1 %V12, label %selectBreakLab14, label %contBreakLab13
contBreakLab13:
   ret %_add$33* %R11
selectBreakLab14:
   %R15 = bitcast %length$34* %R7 to [0 x i32]*
   %R16 = getelementptr [0 x i32], [0 x i32]* %R15, i32 0, i32 0
   %V17 = load i32 , i32* %R16
   %R18 = getelementptr %length$34,%length$34* %R7, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R18
   %V19 = icmp eq i32 1, %V17
   br i1 %V19, label %X20, label %X21
X20:
   br label %L1 ; restart
X21:
   br label %L2 ; leave
normalRtnLab8:

   ;; vTop(0,0)=[] rTop(2,3)=[0:%_add$33*,4:%length$34*]
;; pushg 2 
   %R22 = getelementptr %length$34,%length$34 *%R4, i32 0, i32 2
   %V23 = load i32, i32* %R22
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 3 V: R: 0 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 23 R: 0 
   ;; useRtnVal: true :isVal: false :rtnValObj: true :rec=E: true "Length" 
   ;; OI:invoke: Length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "Length" 
   ;; loadArgs:after:Qgen: ":= Length" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; BINGO 
   ;; aaaa:  in V: var Value{--inner(Value);} 
   ;; end:loadArgs:NonVirt: ":= Length" 
   ;; IV:after:loadArgsOf: ":= Length" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= Length" 
   ;; $ObjectInvocation_Binary:":= Length" 
   ;; >invoke: rec:"L" 
   ;; OI:invoke:isPtn: ":= Length" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:invoke:B: ":= Length" E: ":= Length"  rec: "L"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= Length"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= Length" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= Length" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "L" from:  ":= Length" 
   ;; assign:dstDI : "L: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "Length" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: Length 
   ;;  arg.super.ATd: "Invocation" "length: {   out V: var integer;   V := @get 0}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= Length"  rec:  "L" "+$33" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= Length"} 
   ;; store: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  +$33 4
   %R24 = getelementptr %_add$33,%_add$33 *%R0, i32 0, i32 4
   store i32 %V23, i32* %R24
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 0 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; OI:invoke: := Length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= Length" 
   ;; genclass:stmt: "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 :to L :repeat ;      e := @get inx;      T.@put e :at inx ...}" 
   ;; $do:"doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   @for 1 :to L :repeat ;      e := @get inx;      T.@put e :at inx;   @for 1  ..."} 
   ;; Qgen: 
   ;; $ObjectGenerator:"e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ..."} 
   ;; Qgen:OGid:"$S$35" singular! staticOff=0 descNo=35 superAdj=0 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %_add$33* 
   ;; before objTmpStack:add:  35   "$S$35" 
   ;; OGid: $S$35  OGidWdNo:  $S$35$35 
;; invoke $S$35 35 0 1
   ;; vTop(0,1)=[] rTop(1,3)=[0:%_add$33*]
   ;; alloc %$S$35$35
   %R25 = tail call i8* @malloc(i64 20)
   %R26 = bitcast i8* %R25 to %$S$35$35*
   ;; store VDT in object
   %R27 = getelementptr %$S$35$35, %$S$35$35* %R26, i32 0, i32 0
   store %vdt_type$$S$35$35* @vdt_data$$S$35$35, %vdt_type$$S$35$35** %R27
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 26 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$35$35 this: $S$35$35 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$35$35 isValueObjectOrigin: F
   ;; vTop(0,1)=[] rTop(2,3)=[0:%_add$33*,26:%$S$35$35]
   ;; lookup:  %_add$33*
   ;; vTop(0,1)=[] rTop(2,3)=[0:%_add$33*,26:%$S$35$35]
   %R28 = getelementptr %$S$35$35, %$S$35$35 * %R26, i32 0, i32 1
   store %_add$33* %R0, %_add$33** %R28
;; rswap  0
   ;; vTop(0,1)=[] rTop(2,3)=[26:%$S$35$35,0:%_add$33*]
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; vTop(0,1)=[] rTop(1,3)=[26:%$S$35$35]
   ;; topSuper: 35   $S$35$35 
   %R29 = call %$S$35$35* @$S$35$35(%$S$35$35 * %R26)
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   %V32 = icmp eq %$S$35$35* %R29, %R26
   br i1 %V32, label %normalRtnLab30, label %breakLab31
breakLab31:
   %R33 = bitcast %$S$35$35* %R29 to %_add$33*
   %V34 = icmp eq %_add$33* %R0, %R33
   br i1 %V34, label %selectBreakLab36, label %contBreakLab35
contBreakLab35:
   ret %_add$33* %R33
selectBreakLab36:
   %R37 = bitcast %$S$35$35* %R29 to [0 x i32]*
   %R38 = getelementptr [0 x i32], [0 x i32]* %R37, i32 0, i32 0
   %V39 = load i32 , i32* %R38
   %R40 = getelementptr %$S$35$35,%$S$35$35* %R29, i32 0, i32 0
   store %vdt_type$$S$35$35* @vdt_data$$S$35$35, %vdt_type$$S$35$35** %R40
   %V41 = icmp eq i32 1, %V39
   br i1 %V41, label %X42, label %X43
X42:
   br label %L1 ; restart
X43:
   br label %L2 ; leave
normalRtnLab30:

   ;; vTop(0,1)=[] rTop(1,3)=[26:%$S$35$35*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   br label %L2
L2:
   ;; pushReturn:  "+" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %_add$33* 
   ;; vTop(0,1)=[] rTop(1,3)=[0:%_add$33*]
   ret %_add$33* %R0   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
}
   ;; vdt:vdtTop: 1 33:I
@vdt_data$_add$33 = global %vdt_type$_add$33 {
      %_add$33*(%_add$33*)* @_add$33
}

define %vdt_ret$_add$33* @vdt_alloc$_add$33(%String$15* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$_add$33
   %R45 = tail call i8* @malloc(i64 32)
   %R46 = bitcast i8* %R45 to %vdt_ret$_add$33*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %_add$33 
   ;; alloc %_add$33
   %R47 = tail call i8* @malloc(i64 192)
   %R48 = bitcast i8* %R47 to %_add$33*
   ;; store VDT in object
   %R49 = getelementptr %_add$33, %_add$33* %R48, i32 0, i32 0
   store %vdt_type$_add$33* @vdt_data$_add$33, %vdt_type$_add$33** %R49
   %R50 = getelementptr %vdt_ret$_add$33,%vdt_ret$_add$33* %R46, i32 0, i32 0
   store %_add$33* %R48, %_add$33** %R50
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: String thisClassOrgDescNo: 15 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 48 
   ;; vTop(0,1)=[] rTop(2,3)=[1:%String$15*,48:%_add$33]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: + 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: +$33 this: +$33 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 +$33 isValueObjectOrigin: F
   ;; vTop(0,1)=[] rTop(2,3)=[1:%String$15*,48:%_add$33]
   ;; lookup:  %String$15*
   ;; vTop(0,1)=[] rTop(2,3)=[1:%String$15*,48:%_add$33]
   %R51 = getelementptr %_add$33, %_add$33 * %R48, i32 0, i32 1
   store %String$15* %R1, %String$15** %R51
;; rswap  0
   ;; vTop(0,1)=[] rTop(2,3)=[48:%_add$33,1:%String$15*]
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 48 
   ;; vTop(0,1)=[] rTop(1,3)=[48:%_add$33]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$_add$33* %R46
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 34 :top: 1 
   ;; Items:GenClass: length descNo: 34 
;; class  length 34 1 String 15

define %length$34* @length$34(%length$34* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=34 vDescInx=34 vdtTop: 1
   ;; $var:"out V: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  V 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "V := @get 0" 
   ;; $ObjectGenerator:"V := @get 0" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"V := @get 0" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "V := @get 0" 
   ;; not const:  V out V: var integer 
   ;; needorigin: "V := @get 0" 
   ;; needOrigin:E: ":= @get 0"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= @get 0" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "V := @get 0" 
   ;; computeAdr: 1 :rec: "none"  E: "V" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"V" 
   ;; >pushThis: 
   ;; OI:pushThis: "out V: var integer{V := @get 0}" ATd: "out V: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %length$34* 
   ;; $ObjectInvocation_Unary:"V" 
   ;; >loadOrigin::on:0 
   ;; AdjustOrigin:originOff: 0 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"V" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"out V: var integer" 
   ;; >getAdr:,newOff:2,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"V"}   out V: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "out V: var integer" ObjectGenerator 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; After:U*U: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; computeAdr: 2 :rec: "V"  E: ":= @get 0"  A.E: "V" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; computeAdr:isAssign:rec:  "V"  E: ":= @get 0" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; computeAdr:isLast:E:  ":= @get 0" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; rec:  "V" E:  ":= @get 0" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= @get 0" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= @get 0" 
   ;; >loadArgs:staticOff:2 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @get 0  hasArg:  pattern 
   ;; := @get 0   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= @get 0":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= @get 0" 
   ;; ActArg:  "@get 0" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= @get 0" 
   ;; loadArgs:A: "@get 0" 
   ;; $ObjectGenerator:"@get 0" 
   ;; Qgen:OGid:"@get:" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "@get" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"@get 0" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "@get 0" 
   ;; needorigin: "@get 0" 
   ;; needOrigin:E: "@get 0"  E.ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; doNeedOrigin:Ex: "@get 0" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "@get 0" 
   ;; computeAdr: 1 :rec: "none"  E: "@get 0" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_KeyWord:"@get 0" 
   ;; >pushThis: 
   ;; OI:pushThis: "out V: var integer{V := @get 0}" ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %length$34* 
   ;; $ObjectInvocation_KeyWord:"@get 0" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "length" newOriginOff: 1 origin: "String$15" 
   ;; NA: "@get 0" origin: "length$34" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg length$34 1
   ;; Rtype.rtop: "%length$34*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R1 = getelementptr %length$34,%length$34 *%R0, i32 0, i32 1
   %R2 = load %String$15* , %String$15** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_KeyWord:"@get 0" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "@get 0"  ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"} 
   ;; computeAdr:isLast:E:  "@get 0" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"} 
   ;; rec:  "@get 0" E:  "@get 0" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@get 0" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"@get 0" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @get 0  hasArg:  pattern 
   ;; @get 0   @get: {   %basic 117;   in get: var integer;   out ch: var char} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >loadArgs:E:"@get 0":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@get 0" 
   ;; ActArg:  "0" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@get 0" 
   ;; loadArgs:not:*:  formalArgOf: "@get 0"  isCompositeValueObj: false 
   ;; loadArgs:A: "0" 
   ;; $ObjectGenerator:"0" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"0" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "0" 
   ;; needorigin: "0" 
   ;; needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "0" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "0" E:  "0" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "0" superAdj= 0 
   ;; $ConstLiteral:"0" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "0"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "0" 
   ;; $ConstLiteral:"0" 
   ;; >invoke: 
;; pushc 0
   %V3 = add i32 0, 0
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 2 V: 3 R: 2 
   ;; invoke:after:E.invoke: "0" 
   ;; loadArgs:after:Qgen: "@get 0" 
   ;; formalArg:isPtn: "in get: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "0" :isBasicVal: true 
   ;; 0 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@get 0" 
   ;; IV:after:loadArgsOf: "@get 0" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "@get 0" 
   ;; $ObjectInvocation_KeyWord:"@get 0" 
   ;; >invoke: rec:"@get 0" 
   ;; OI:invoke:isPtn: "@get 0" descNo 0  useRTNv: true 
   ;; E.ATd:  "@get" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"} 
   ;; OI:invoke:B: "@get 0" E: "@get 0"  rec: "@get 0"  useRtnV: true "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get 0"} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >invoke:E: "@get 0" useRTNv: "True" 
   ;; ptn:invoke: "@get" E: "@get 0" useRtnV: true 
;; xpushg  inx 1 0 1
   ;; vTop(1,1)=[3/0] rTop(2,2)=[0:%length$34*,2:%String$15*]
   %R4 = bitcast %String$15* %R2 to i32*
%V5 = call i32 @arrayLength(i32* %R4)
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 3 R: 0 
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 5 R: 0 
   ;; OI:invoke: @get 0 :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "@get 0" 
   ;; loadArgs:after:Qgen: ":= @get 0" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; BINGO 
   ;; aaaa:  in V: var Value{--inner(Value);} 
   ;; end:loadArgs:NonVirt: ":= @get 0" 
   ;; IV:after:loadArgsOf: ":= @get 0" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= @get 0" 
   ;; $ObjectInvocation_Binary:":= @get 0" 
   ;; >invoke: rec:"V" 
   ;; OI:invoke:isPtn: ":= @get 0" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; OI:invoke:B: ":= @get 0" E: ":= @get 0"  rec: "V"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= @get 0"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= @get 0" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= @get 0" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "V" from:  ":= @get 0" 
   ;; assign:dstDI : "out V: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "@get 0" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: @get 0 
   ;;  arg.super.ATd: "Invocation" "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= @get 0"  rec:  "V" "length$34" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= @get 0"} 
   ;; store: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"V"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  length$34 2
   %R6 = getelementptr %length$34,%length$34 *%R0, i32 0, i32 2
   store i32 %V5, i32* %R6
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
   ;; OI:invoke: := @get 0 :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= @get 0" 
   br label %L2
L2:
   ;; pushReturn:  "length" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %length$34* 
   ;; vTop(0,1)=[] rTop(1,2)=[0:%length$34*]
   ret %length$34* %R0   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 1 34:I
@vdt_data$length$34 = global %vdt_type$length$34 {
      %length$34*(%length$34*)* @length$34
}

define %vdt_ret$length$34* @vdt_alloc$length$34(%String$15* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$length$34
   %R8 = tail call i8* @malloc(i64 32)
   %R9 = bitcast i8* %R8 to %vdt_ret$length$34*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %length$34 
   ;; alloc %length$34
   %R10 = tail call i8* @malloc(i64 192)
   %R11 = bitcast i8* %R10 to %length$34*
   ;; store VDT in object
   %R12 = getelementptr %length$34, %length$34* %R11, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R12
   %R13 = getelementptr %vdt_ret$length$34,%vdt_ret$length$34* %R9, i32 0, i32 0
   store %length$34* %R11, %length$34** %R13
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: String thisClassOrgDescNo: 15 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 2 V: R: 11 
   ;; vTop(0,1)=[] rTop(2,2)=[1:%String$15*,11:%length$34]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: length 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: length$34 this: length$34 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 length$34 isValueObjectOrigin: F
   ;; vTop(0,1)=[] rTop(2,2)=[1:%String$15*,11:%length$34]
   ;; lookup:  %String$15*
   ;; vTop(0,1)=[] rTop(2,2)=[1:%String$15*,11:%length$34]
   %R14 = getelementptr %length$34, %length$34 * %R11, i32 0, i32 1
   store %String$15* %R1, %String$15** %R14
;; rswap  0
   ;; vTop(0,1)=[] rTop(2,2)=[11:%length$34,1:%String$15*]
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 2 V: R: 11 
   ;; vTop(0,1)=[] rTop(1,2)=[11:%length$34]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$length$34* %R9
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 35 :top: 1 
   ;; Items:GenClass: $S$35 descNo: 35 
;; class  $S$35 35 1 + 33

define %$S$35$35* @$S$35$35(%$S$35$35* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=35 vDescInx=35 vdtTop: 1
   ;; $var:"e: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  e 
   ;; $var:"i: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  i 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; Qgen: 
   ;; DI:isConst: true :isBasicValue: false :primNo: 114 
   ;; OGqual: "Indexed" :OGqual.isBasicValue: false :OGqual.isValueObj: false 
   ;; DI:add:BP4:  T 
   ;; $ObjectGenerator:"Indexed(L + S.length,Integer)" 
   ;; Qgen:OGid:"Indexed$S$0" IS.isempty! staticOff=4 descNo=0 superAdj=0 
   ;; OG:gen:super: "Indexed" superDescNo: 36 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"Indexed(L + S.length,Integer)" 
   ;; Qgen: useRtnV:"False" descNo: 36 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "Indexed(L + S.length,Integer)" 
   ;; needorigin: "Indexed(L + S.length,Integer)" 
   ;; needOrigin:E: "Indexed(L + S.length,Integer)"  E.ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   i ...}" 
   ;; IV:no:needOrigin:E:  "Indexed(L + S.length,Integer)" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "Indexed(L + S.length,Integer)" E:  "Indexed(L + S.length,Integer)" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "Indexed(L + S.length,Integer)" superAdj= 0 
   ;; $ObjectInvocation_Function:"Indexed(L + S.length,Integer)" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  (L + S.length,Integer)  hasArg:   hasArg:  pattern 
   ;; Indexed(L + S.length,Integer)   Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res ...} 
   ;; $pattern:"Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get 0;   @put: ;  ..."} 
   ;; >loadArgs:E:"Indexed(L + S.length,Integer)":descNo:36:top:1 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "Indexed(L + S.length,Integer)" 
   ;; ActArg:  "L + S.length" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "Indexed(L + S.length,Integer)" 
   ;; loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer)"  isCompositeValueObj: false 
   ;; loadArgs:A: "L + S.length" 
   ;; $ObjectGenerator:"L + S.length" 
   ;; Qgen:OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "+" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"L + S.length" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "L + S.length" 
   ;; not const:  L L: var integer 
   ;; needorigin: "L + S.length" 
   ;; needOrigin:E: "+ S.length"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; doNeedOrigin:Ex: "+ S.length" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "L + S.length" 
   ;; computeAdr: 1 :rec: "none"  E: "L" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "L ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %$S$35$35* 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "L" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R1 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R2 = load %_add$33* , %_add$33** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"L: var integer" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"L"}   L: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "L: var integer" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "L"  ATd: "L: var integer" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr: 2 :rec: "L"  E: "+ S.length"  A.E: "L" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E:notAssign: + S.length 
   ;; $ObjectInvocation_Binary:"+ S.length" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >getAdr: 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; L   L: var integer 
   ;; $var:"L: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "L: var integer"  E:  "L" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"L":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >invoke: rec:"L" 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:invoke:B: "L" E: "+ S.length"  rec: "L"  useRtnV: true "L: var integer" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ S.length"} 
   ;; $var:"L: var integer" 
   ;; >invoke:E: "+ S.length" newOff:4 useRTNv: "True" 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ S.length"} 
   ;; isFloat:B:  false 
;; pushg 4 $S$35$35
   %R3 = getelementptr %_add$33,%_add$33 *%R2, i32 0, i32 4
   %V4 = load i32, i32* %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 4 R: 
   ;; BOBS! 
   ;; OI:invoke: L :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "+ S.length" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ S.length"} 
   ;; rec:  "L" E:  "+ S.length" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "+ S.length" superAdj= 0 
   ;; $ObjectInvocation_Binary:"+ S.length" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  S.length  hasArg:  pattern 
   ;; + S.length   +  : {   %basic 61;   in V: var integer;   out R: var integer} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >loadArgs:E:"+ S.length":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "+ S.length" 
   ;; ActArg:  "S.length" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "+ S.length" 
   ;; loadArgs:not:*:  formalArgOf: "+ S.length"  isCompositeValueObj: false 
   ;; loadArgs:A: "S.length" 
   ;; $ObjectGenerator:"S.length" 
   ;; Qgen:OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "length" superDescNo: 34 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"S.length" 
   ;; Qgen: useRtnV:"True" descNo: 34 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "S.length" 
   ;; not const:  S in S: ref String 
   ;; needorigin: "S.length" 
   ;; needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; doNeedOrigin:Ex: "length" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "S.length" 
   ;; computeAdr: 1 :rec: "none"  E: "S" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "i ..." 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 4 R: 0 
   ;; %$S$35$35* 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "S" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R5 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R6 = load %_add$33* , %_add$33** %R5
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 4 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 4 R: 6 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ref:"in S: ref String" 
   ;; >getAdr:,newOff:2,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"S"}   in S: ref String 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "S"  ATd: "in S: ref String" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "S"  E: "length" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: length 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >getAdr: 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   ref 
   ;; S   in S: ref String 
   ;; $ref:"in S: ref String" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in S: ref String"  E:  "S" 
   ;;  
   ;; $pattern:"String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @get: ..."} 
   ;; >loadArgs:E:"S":descNo:15:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >invoke: rec:"S" 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: ref String" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $ref:"in S: ref String" 
   ;; >invoke:E: "length" newOff:2 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; loadAdr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
;; rpushg $S$35$35 2
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R7 = getelementptr %_add$33,%_add$33 *%R6, i32 0, i32 2
   %R8 = load %String$15* , %String$15** %R7
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 4 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 4 R: 8 
   ;; OI:invoke: S :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "length" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; rec:  "S" E:  "length" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "length" superAdj= 0 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; length   length: {   out V: var integer;   V := @get 0} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >loadArgs:E:"length":descNo:34:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "length" 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >invoke: rec:"S" 
   ;; OI:invoke:isPtn: "length" descNo 34  useRTNv: true 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := @get 0}" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >invoke:E: "length" useRTNv: "True" 
   ;; ptn:invoke: "length" E: "length" useRtnV: true 
   ;; Pattern:invoke:useRTNv: true descNo: 34  top: 1  rec: "S" 
   ;; ComputeVariantX
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; <>var 
   ;; ptn:invoke: useRtnV: true isValObj: false :rtnValObj: true : "length: {   out V: var integer;   V := @get 0}" 
   ;; rec=E: false :rec: "S" 
   ;; before:invoke:useReturnValue:  true 
   ;; OGid: length  OGidWdNo:  length$34 
;; invoke length 34 0 1
   ;; vTop(1,1)=[4/0] rTop(1,1)=[8:%String$15*]
   ;; alloc %length$34
   %R9 = tail call i8* @malloc(i64 12)
   %R10 = bitcast i8* %R9 to %length$34*
   ;; store VDT in object
   %R11 = getelementptr %length$34, %length$34* %R10, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R11
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 2 V: 4 R: 10 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: length$34 this: length$34 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 length$34 isValueObjectOrigin: F
   ;; vTop(1,1)=[4/0] rTop(2,2)=[8:%String$15*,10:%length$34]
   ;; lookup:  %String$15*
   ;; vTop(1,1)=[4/0] rTop(2,2)=[8:%String$15*,10:%length$34]
   %R12 = getelementptr %length$34, %length$34 * %R10, i32 0, i32 1
   store %String$15* %R8, %String$15** %R12
;; rswap  0
   ;; vTop(1,1)=[4/0] rTop(2,2)=[10:%length$34,8:%String$15*]
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 4 R: 10 
   ;; vTop(1,1)=[4/0] rTop(1,2)=[10:%length$34]
   ;; topSuper: 34   length$34 
   %R13 = call %length$34* @length$34(%length$34 * %R10)
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 2 V: 4 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 4 R: 10 
   %V16 = icmp eq %length$34* %R13, %R10
   br i1 %V16, label %normalRtnLab14, label %breakLab15
breakLab15:
   %R17 = bitcast %length$34* %R13 to %$S$35$35*
   %V18 = icmp eq %$S$35$35* %R0, %R17
   br i1 %V18, label %selectBreakLab20, label %contBreakLab19
contBreakLab19:
   ret %$S$35$35* %R17
selectBreakLab20:
   %R21 = bitcast %length$34* %R13 to [0 x i32]*
   %R22 = getelementptr [0 x i32], [0 x i32]* %R21, i32 0, i32 0
   %V23 = load i32 , i32* %R22
   %R24 = getelementptr %length$34,%length$34* %R13, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R24
   %V25 = icmp eq i32 1, %V23
   br i1 %V25, label %X26, label %X27
X26:
   br label %L1 ; restart
X27:
   br label %L2 ; leave
normalRtnLab14:

   ;; vTop(1,1)=[4/0] rTop(1,2)=[10:%length$34*]
;; pushg 2 
   %R28 = getelementptr %length$34,%length$34 *%R10, i32 0, i32 2
   %V29 = load i32, i32* %R28
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 2 V: 4 R: 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 2 V: 29 R: 
   ;; useRtnVal: true :isVal: false :rtnValObj: true :rec=E: false "S" 
   ;; OI:invoke: length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "length" 
   ;; loadArgs:after:Qgen: "+ S.length" 
   ;; formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "S.length" :isBasicVal: true 
   ;; S.length ObjectGenerator 
   ;; end:loadArgs:NonVirt: "+ S.length" 
   ;; IV:after:loadArgsOf: "+ S.length" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ S.length"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "+ S.length" 
   ;; $ObjectInvocation_Binary:"+ S.length" 
   ;; >invoke: rec:"L" 
   ;; OI:invoke:isPtn: "+ S.length" descNo 0  useRTNv: true 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ S.length"} 
   ;; OI:invoke:B: "+ S.length" E: "+ S.length"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ S.length"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >invoke:E: "+ S.length" useRTNv: "True" 
   ;; ptn:invoke: "+" E: "+ S.length" useRtnV: true 
   ;; doPrimElse: + 61 
   %V30 = add i32 %V4, %V29
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 0 rTopMax: 2 V: 30 R: 
   ;; OI:invoke: + S.length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "+ S.length" 
   ;; loadArgs:after:Qgen: "Indexed(L + S.length,Integer)" 
   ;; formalArg:isPtn: "in range: var Integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "L + S.length" :isBasicVal: true 
   ;; L + S.length ObjectGenerator 
   ;; end:loadArgs:NonVirt: "Indexed(L + S.length,Integer)" 
   ;; IV:after:loadArgsOf: "Indexed(L + S.length,Integer)"  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "Indexed(L + S.length,Integer)" 
   ;; $ObjectInvocation_Function:"Indexed(L + S.length,Integer)" 
   ;; >invoke: rec:"Indexed(L + S.length,Integer)" 
   ;; OI:invoke:isPtn: "Indexed(L + S.length,Integer)" descNo 36  useRTNv: false 
   ;; OI:invoke:B: "Indexed(L + S.length,Integer)" E: "Indexed(L + S.length,Integer)"  rec: "Indexed(L + S.length,Integer)"  useRtnV: false "Indexed: {   %globals;   %basic 114; ...}" 
   ;; adr:none 
   ;; $pattern:"Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get 0;   @put: ;  ..."} 
   ;; >invoke:E: "Indexed(L + S.length,Integer)" useRTNv: "False" 
   ;; ptn:invoke: "Indexed" E: "Indexed(L + S.length,Integer)" useRtnV: false 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 1 rTopMax: 2 V: 30 R: 0 
   ;; %$S$35$35* 
   ;; ComputeVariant:A: "Indexed" 
   ;; %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ;   %basic 115;   in put: ref elm;   in at: var i ...} 
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; var is not new: 
   ;; ComputeVariant:B:  "Indexed" 
   ;; ObjTmpStack:add: :genDone: false   "Indexed" : "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := @get 0;@put: ; ...}" 
;; pushc 1
   %V31 = add i32 0, 1
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 2 V: 31 R: 0 
   ;; Indexed(L + S.length,Integer)   Indexed   T: obj Indexed(L + S.length,Integer)   obj   
;; allocIndexed  $S$35$35 36 1 0
   ;; vTop(2,2)=[30/0,31/0] rTop(1,2)=[0:%$S$35$35*]
   ;; eType:  %array$1* 
   %R32 = tail call i32 * @allocIndexed(i32 %V30,i32 %V31)
      %R33 = bitcast i32* %R32 to %array$1*
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 2 V: 31 R: 
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 33 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %$S$35$35* 
;; rstoreg  $S$35$35 4
   %R34 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 4
;; types:dst: %array$1* src: %array$1*
   store %array$1*  %R33, %array$1* * %R34
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 2 V: R: 
   ;; vTop(0,2)=[] rTop(0,2)=[]
   ;; OI:invoke: Indexed(L + S.length,Integer) :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "Indexed(L + S.length,Integer)" 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; $ObjectGenerator:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; Qgen:OGid:"@for::to:repeat$S$38" IS.isempty! staticOff=0 descNo=38 superAdj=0 
   ;; OG:gen:super: "@for" superDescNo: 21 super.OG.top: 1 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %$S$35$35* 
   ;; before objTmpStack:add:  38   "@for::to:repeat$S$38" 
   ;; OGid: @for::to:repeat$S$38  OGidWdNo:  @for::to:repeat$S$38$38 
;; invoke @for::to:repeat$S$38 38 0 1
   ;; vTop(0,2)=[] rTop(1,2)=[0:%$S$35$35*]
   ;; alloc %$for$$to$repeat$S$38$38
   %R35 = tail call i8* @malloc(i64 20)
   %R36 = bitcast i8* %R35 to %$for$$to$repeat$S$38$38*
   ;; store VDT in object
   %R37 = getelementptr %$for$$to$repeat$S$38$38, %$for$$to$repeat$S$38$38* %R36, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$S$38$38* @vdt_data$$for$$to$repeat$S$38$38, %vdt_type$$for$$to$repeat$S$38$38** %R37
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 2 V: R: 36 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$38$38 this: @for::to:repeat$S$38$38 originOff: 4 orgIsValObj: false 
;; rdouble -1
   ;; vTop(0,2)=[] rTop(2,2)=[0:%$S$35$35*,36:%$for$$to$repeat$S$38$38]
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 36 
   ;; vTop(0,2)=[] rTop(3,3)=[0:%$S$35$35*,0:%$S$35$35*,36:%$for$$to$repeat$S$38$38]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  4 @for::to:repeat$S$38$38 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(3,3)=[0:%$S$35$35*,0:%$S$35$35*,36:%$for$$to$repeat$S$38$38]
   ;; lookup:  %$S$35$35*
   ;; vTop(0,2)=[] rTop(3,3)=[0:%$S$35$35*,0:%$S$35$35*,36:%$for$$to$repeat$S$38$38]
   %R38 = getelementptr %$for$$to$repeat$S$38$38, %$for$$to$repeat$S$38$38 * %R36, i32 0, i32 4
   store %$S$35$35* %R0, %$S$35$35** %R38
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,3)=[0:%$S$35$35*,36:%$for$$to$repeat$S$38$38,0:%$S$35$35*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 36 
   ;; vTop(0,2)=[] rTop(2,3)=[0:%$S$35$35*,36:%$for$$to$repeat$S$38$38]
   ;; go:super.ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loo ...}" t ... 4 t ... "@ ..." 
   ;; thisOG.IS: origin: "@for::to:repeat$S$38" thisOG.IS: origin: "@for::to:repeat$S$38" thisOG.IS: origin: "@for::to:repeat$S$38" thisOG.IS: origin: "@for::to:repeat$S$38" 
   ;; vTop(0,2)=[] rTop(2,3)=[0:%$S$35$35*,36:%$for$$to$repeat$S$38$38]
;; rswap  0
   ;; goOriginAdr:  "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >loadOrigin::on:4 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 4 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R39 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R40 = load %_add$33* , %_add$33** %R39
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 40 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 3 
   ;; goOrigin: "+" newOriginOff: 1 origin: "String$15" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R41 = getelementptr %_add$33,%_add$33 *%R40, i32 0, i32 1
   %R42 = load %String$15* , %String$15** %R41
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 42 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "String" newOriginOff: 1 origin: "StringLib$14" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%String$15*" typeInfo[rtop,off]=elmType: "%StringLib$14*" 
   %R43 = getelementptr %String$15,%String$15 *%R42, i32 0, i32 1
   %R44 = load %StringLib$14* , %StringLib$14** %R43
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 44 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "StringLib" newOriginOff: 1 origin: "LIB$8" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%StringLib$14*" typeInfo[rtop,off]=elmType: "%LIB$8*" 
   %R45 = getelementptr %StringLib$14,%StringLib$14 *%R44, i32 0, i32 1
   %R46 = load %LIB$8* , %LIB$8** %R45
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 46 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ...}" 
   ;; viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
   ;; items:goOrigin: 1 
   ;; goOrigin: "LIB" newOriginOff: 1 origin: "BETAworld$1" 
   ;; NA: "BETA" origin: "LIB$8" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg LIB$8 1
   ;; Rtype.rtop: "%LIB$8*" typeInfo[rtop,off]=elmType: "%BETAworld$1*" 
   %R47 = getelementptr %LIB$8,%LIB$8 *%R46, i32 0, i32 1
   %R48 = load %BETAworld$1* , %BETAworld$1** %R47
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 48 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
;; rpushg BETA 2
   ;; Rtype.rtop: "%BETAworld$1*" typeInfo[rtop,off]=elmType: "%BETA$2*" 
   %R49 = getelementptr %BETAworld$1,%BETAworld$1 *%R48, i32 0, i32 2
   %R50 = load %BETA$2* , %BETA$2** %R49
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 50 
   ;; goOriginAdr:not:BracE: ObjectInvocation_KeyWord 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >getAdr::superAdj:0:on:4 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx"} 
   ;; vTop(0,2)=[] rTop(2,3)=[36:%$for$$to$repeat$S$38$38,50:%BETA$2*]
   ;; before:E.loadArgs: @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V51 = add i32 0, 1
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 51 R: 50 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ActArg:  "L" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  isCompositeValueObj: false 
   ;; loadArgs:A: "L" 
   ;; $ObjectGenerator:"L" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"L" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "L" 
   ;; not const:  L L: var integer 
   ;; needorigin: "L" 
   ;; needOrigin:E: "L"  E.ATd: "L: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "L" 
   ;; computeAdr: 1 :rec: "none"  E: "L" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "L ..." 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 3 V: 51 R: 0 
   ;; %$S$35$35* 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "L" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R52 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R53 = load %_add$33* , %_add$33** %R52
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 51 R: 50 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 3 V: 51 R: 53 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"L: var integer" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"L"}   L: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "L: var integer" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "L"  ATd: "L: var integer" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr:isLast:E:  "L" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; rec:  "L" E:  "L" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "L" superAdj= 0 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; L   L: var integer 
   ;; $var:"L: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "L: var integer"  E:  "L" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"L":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "L" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "L" 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >invoke: rec:"L" 
   ;; E.ATd:  "L" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; $var:"L: var integer" 
   ;; >invoke:E: "L" newOff:4 useRTNv: "True" 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; isFloat:B:  false 
;; pushg 4 +$33
   %R54 = getelementptr %_add$33,%_add$33 *%R53, i32 0, i32 4
   %V55 = load i32, i32* %R54
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 51 R: 50 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 55 R: 50 
   ;; BOBS! 
   ;; OI:invoke: L :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "L" 
   ;; loadArgs:after:Qgen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "L" :isBasicVal: true 
   ;; L ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; in for: var integer 
   ;; in to: var integer 
;; rswap  0
;; rdouble 0
   ;; vTop(2,2)=[51/0,55/0] rTop(2,3)=[50:%BETA$2*,36:%$for$$to$repeat$S$38$38]
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 3 rTopMax: 3 V: 55 R: 36 
   ;; vTop(2,2)=[51/0,55/0] rTop(3,3)=[50:%BETA$2*,36:%$for$$to$repeat$S$38$38,36:%$for$$to$repeat$S$38$38]
;; storeg  @for::to:repeat$S$38$38 2
   %R56 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R36, i32 0, i32 2
   store i32 %V55, i32* %R56
   ;; stack: vpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 3 V: 51 R: 36 
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 51 R: 36 
;; rswap  0
;; rswap  0
;; rdouble 0
   ;; vTop(1,2)=[51/0] rTop(2,3)=[50:%BETA$2*,36:%$for$$to$repeat$S$38$38]
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 3 V: 51 R: 36 
   ;; vTop(1,2)=[51/0] rTop(3,3)=[50:%BETA$2*,36:%$for$$to$repeat$S$38$38,36:%$for$$to$repeat$S$38$38]
;; storeg  @for::to:repeat$S$38$38 1
   %R57 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R36, i32 0, i32 1
   store i32 %V51, i32* %R57
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 36 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 36 
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,3)=[36:%$for$$to$repeat$S$38$38,50:%BETA$2*] 
   ;; @for::to:repeat   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$38$38 this: @for::to:repeat$21 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; topSuper: 21   @for::to:repeat$21 
   %R58 = bitcast %$for$$to$repeat$S$38$38* %R36 to %$for$$to$repeat$21*
   %R59 = call %$for$$to$repeat$21* @$for$$to$repeat$21(%$for$$to$repeat$21 * %R58)
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 50 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 58 
   %V62 = icmp eq %$for$$to$repeat$21* %R59, %R58
   br i1 %V62, label %normalRtnLab60, label %breakLab61
breakLab61:
   %R63 = bitcast %$for$$to$repeat$21* %R59 to %$S$35$35*
   %V64 = icmp eq %$S$35$35* %R0, %R63
   br i1 %V64, label %selectBreakLab66, label %contBreakLab65
contBreakLab65:
   ret %$S$35$35* %R63
selectBreakLab66:
   %R67 = bitcast %$for$$to$repeat$21* %R59 to [0 x i32]*
   %R68 = getelementptr [0 x i32], [0 x i32]* %R67, i32 0, i32 0
   %V69 = load i32 , i32* %R68
   %R70 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21* %R59, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$21* @vdt_data$$for$$to$repeat$21, %vdt_type$$for$$to$repeat$21** %R70
   %V71 = icmp eq i32 1, %V69
   br i1 %V71, label %X72, label %X73
X72:
   br label %L1 ; restart
X73:
   br label %L2 ; leave
normalRtnLab60:

   ;; vTop(0,2)=[] rTop(2,3)=[50:%BETA$2*,58:%$for$$to$repeat$21*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 50 
   ;; genclass:stmt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; $ObjectGenerator:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; Qgen:OGid:"@for::to:repeat$S$39" IS.isempty! staticOff=0 descNo=39 superAdj=0 
   ;; OG:gen:super: "@for" superDescNo: 21 super.OG.top: 1 
   ;; OG:Qgen:IS is not empty: 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 0 
   ;; %$S$35$35* 
   ;; before objTmpStack:add:  39   "@for::to:repeat$S$39" 
   ;; OGid: @for::to:repeat$S$39  OGidWdNo:  @for::to:repeat$S$39$39 
;; invoke @for::to:repeat$S$39 39 0 1
   ;; vTop(0,2)=[] rTop(2,3)=[50:%BETA$2*,0:%$S$35$35*]
   ;; alloc %$for$$to$repeat$S$39$39
   %R74 = tail call i8* @malloc(i64 20)
   %R75 = bitcast i8* %R74 to %$for$$to$repeat$S$39$39*
   ;; store VDT in object
   %R76 = getelementptr %$for$$to$repeat$S$39$39, %$for$$to$repeat$S$39$39* %R75, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$S$39$39* @vdt_data$$for$$to$repeat$S$39$39, %vdt_type$$for$$to$repeat$S$39$39** %R76
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 75 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$39$39 this: @for::to:repeat$S$39$39 originOff: 4 orgIsValObj: false 
;; rdouble -1
   ;; vTop(0,2)=[] rTop(3,3)=[50:%BETA$2*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39]
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 4 rTopMax: 4 V: R: 75 
   ;; vTop(0,2)=[] rTop(4,4)=[50:%BETA$2*,0:%$S$35$35*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  4 @for::to:repeat$S$39$39 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(4,4)=[50:%BETA$2*,0:%$S$35$35*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39]
   ;; lookup:  %$S$35$35*
   ;; vTop(0,2)=[] rTop(4,4)=[50:%BETA$2*,0:%$S$35$35*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39]
   %R77 = getelementptr %$for$$to$repeat$S$39$39, %$for$$to$repeat$S$39$39 * %R75, i32 0, i32 4
   store %$S$35$35* %R0, %$S$35$35** %R77
;; rswap  0
   ;; vTop(0,2)=[] rTop(4,4)=[50:%BETA$2*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39,0:%$S$35$35*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 75 
   ;; vTop(0,2)=[] rTop(3,4)=[50:%BETA$2*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39]
   ;; go:super.ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loo ...}" t ... 4 t ... "@ ..." 
   ;; thisOG.IS: origin: "@for::to:repeat$S$39" thisOG.IS: origin: "@for::to:repeat$S$39" thisOG.IS: origin: "@for::to:repeat$S$39" thisOG.IS: origin: "@for::to:repeat$S$39" 
   ;; vTop(0,2)=[] rTop(3,4)=[50:%BETA$2*,0:%$S$35$35*,75:%$for$$to$repeat$S$39$39]
;; rswap  0
   ;; goOriginAdr:  "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >loadOrigin::on:4 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 4 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R78 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R79 = load %_add$33* , %_add$33** %R78
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 4 V: R: 75 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 79 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 3 
   ;; goOrigin: "+" newOriginOff: 1 origin: "String$15" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R80 = getelementptr %_add$33,%_add$33 *%R79, i32 0, i32 1
   %R81 = load %String$15* , %String$15** %R80
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 4 V: R: 75 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 81 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "String" newOriginOff: 1 origin: "StringLib$14" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%String$15*" typeInfo[rtop,off]=elmType: "%StringLib$14*" 
   %R82 = getelementptr %String$15,%String$15 *%R81, i32 0, i32 1
   %R83 = load %StringLib$14* , %StringLib$14** %R82
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 4 V: R: 75 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 83 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "StringLib" newOriginOff: 1 origin: "LIB$8" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%StringLib$14*" typeInfo[rtop,off]=elmType: "%LIB$8*" 
   %R84 = getelementptr %StringLib$14,%StringLib$14 *%R83, i32 0, i32 1
   %R85 = load %LIB$8* , %LIB$8** %R84
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 4 V: R: 75 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 85 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ...}" 
   ;; viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
   ;; items:goOrigin: 1 
   ;; goOrigin: "LIB" newOriginOff: 1 origin: "BETAworld$1" 
   ;; NA: "BETA" origin: "LIB$8" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg LIB$8 1
   ;; Rtype.rtop: "%LIB$8*" typeInfo[rtop,off]=elmType: "%BETAworld$1*" 
   %R86 = getelementptr %LIB$8,%LIB$8 *%R85, i32 0, i32 1
   %R87 = load %BETAworld$1* , %BETAworld$1** %R86
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 4 V: R: 75 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 87 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
;; rpushg BETA 2
   ;; Rtype.rtop: "%BETAworld$1*" typeInfo[rtop,off]=elmType: "%BETA$2*" 
   %R88 = getelementptr %BETAworld$1,%BETAworld$1 *%R87, i32 0, i32 2
   %R89 = load %BETA$2* , %BETA$2** %R88
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 4 V: R: 75 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 4 V: R: 89 
   ;; goOriginAdr:not:BracE: ObjectInvocation_KeyWord 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >getAdr::superAdj:0:on:4 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to S.length :repeat ;   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to S.length :repeat ;   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; vTop(0,2)=[] rTop(3,4)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*]
   ;; before:E.loadArgs: @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< O ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V90 = add i32 0, 1
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 4 V: 90 R: 89 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ActArg:  "S.length" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  isCompositeValueObj: false 
   ;; loadArgs:A: "S.length" 
   ;; $ObjectGenerator:"S.length" 
   ;; Qgen:OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "length" superDescNo: 34 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"S.length" 
   ;; Qgen: useRtnV:"True" descNo: 34 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "S.length" 
   ;; not const:  S in S: ref String 
   ;; needorigin: "S.length" 
   ;; needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; doNeedOrigin:Ex: "length" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "S.length" 
   ;; computeAdr: 1 :rec: "none"  E: "S" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "i ..." 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 4 V: 90 R: 0 
   ;; %$S$35$35* 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "S" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R91 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R92 = load %_add$33* , %_add$33** %R91
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 4 V: 90 R: 89 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 4 V: 90 R: 92 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ref:"in S: ref String" 
   ;; >getAdr:,newOff:2,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"S"}   in S: ref String 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "S"  ATd: "in S: ref String" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "S"  E: "length" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: length 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >getAdr: 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   ref 
   ;; S   in S: ref String 
   ;; $ref:"in S: ref String" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in S: ref String"  E:  "S" 
   ;;  
   ;; $pattern:"String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @get: ..."} 
   ;; >loadArgs:E:"S":descNo:15:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >invoke: rec:"S" 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: ref String" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $ref:"in S: ref String" 
   ;; >invoke:E: "length" newOff:2 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; loadAdr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
;; rpushg $S$35$35 2
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R93 = getelementptr %_add$33,%_add$33 *%R92, i32 0, i32 2
   %R94 = load %String$15* , %String$15** %R93
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 4 V: 90 R: 89 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 4 V: 90 R: 94 
   ;; OI:invoke: S :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "length" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; rec:  "S" E:  "length" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "length" superAdj= 0 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; length   length: {   out V: var integer;   V := @get 0} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >loadArgs:E:"length":descNo:34:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "length" 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >invoke: rec:"S" 
   ;; OI:invoke:isPtn: "length" descNo 34  useRTNv: true 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := @get 0}" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >invoke:E: "length" useRTNv: "True" 
   ;; ptn:invoke: "length" E: "length" useRtnV: true 
   ;; Pattern:invoke:useRTNv: true descNo: 34  top: 1  rec: "S" 
   ;; ComputeVariantX
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; <>var 
   ;; ptn:invoke: useRtnV: true isValObj: false :rtnValObj: true : "length: {   out V: var integer;   V := @get 0}" 
   ;; rec=E: false :rec: "S" 
   ;; before:invoke:useReturnValue:  true 
   ;; OGid: length  OGidWdNo:  length$34 
;; invoke length 34 0 1
   ;; vTop(1,2)=[90/0] rTop(4,4)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*,94:%String$15*]
   ;; alloc %length$34
   %R95 = tail call i8* @malloc(i64 12)
   %R96 = bitcast i8* %R95 to %length$34*
   ;; store VDT in object
   %R97 = getelementptr %length$34, %length$34* %R96, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R97
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 5 rTopMax: 5 V: 90 R: 96 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: length$34 this: length$34 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 length$34 isValueObjectOrigin: F
   ;; vTop(1,2)=[90/0] rTop(5,5)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*,94:%String$15*,96:%length$34]
   ;; lookup:  %String$15*
   ;; vTop(1,2)=[90/0] rTop(5,5)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*,94:%String$15*,96:%length$34]
   %R98 = getelementptr %length$34, %length$34 * %R96, i32 0, i32 1
   store %String$15* %R94, %String$15** %R98
;; rswap  0
   ;; vTop(1,2)=[90/0] rTop(5,5)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*,96:%length$34,94:%String$15*]
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 5 V: 90 R: 96 
   ;; vTop(1,2)=[90/0] rTop(4,5)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*,96:%length$34]
   ;; topSuper: 34   length$34 
   %R99 = call %length$34* @length$34(%length$34 * %R96)
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 5 V: 90 R: 89 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 5 V: 90 R: 96 
   %V102 = icmp eq %length$34* %R99, %R96
   br i1 %V102, label %normalRtnLab100, label %breakLab101
breakLab101:
   %R103 = bitcast %length$34* %R99 to %$S$35$35*
   %V104 = icmp eq %$S$35$35* %R0, %R103
   br i1 %V104, label %selectBreakLab106, label %contBreakLab105
contBreakLab105:
   ret %$S$35$35* %R103
selectBreakLab106:
   %R107 = bitcast %length$34* %R99 to [0 x i32]*
   %R108 = getelementptr [0 x i32], [0 x i32]* %R107, i32 0, i32 0
   %V109 = load i32 , i32* %R108
   %R110 = getelementptr %length$34,%length$34* %R99, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R110
   %V111 = icmp eq i32 1, %V109
   br i1 %V111, label %X112, label %X113
X112:
   br label %L1 ; restart
X113:
   br label %L2 ; leave
normalRtnLab100:

   ;; vTop(1,2)=[90/0] rTop(4,5)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*,96:%length$34*]
;; pushg 2 
   %R114 = getelementptr %length$34,%length$34 *%R96, i32 0, i32 2
   %V115 = load i32, i32* %R114
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 5 V: 90 R: 89 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 3 rTopMax: 5 V: 115 R: 89 
   ;; useRtnVal: true :isVal: false :rtnValObj: true :rec=E: false "S" 
   ;; OI:invoke: length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "length" 
   ;; loadArgs:after:Qgen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "S.length" :isBasicVal: true 
   ;; S.length ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; in for: var integer 
   ;; in to: var integer 
;; rswap  0
;; rdouble 0
   ;; vTop(2,2)=[90/0,115/0] rTop(3,5)=[50:%BETA$2*,89:%BETA$2*,75:%$for$$to$repeat$S$39$39]
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 4 rTopMax: 5 V: 115 R: 75 
   ;; vTop(2,2)=[90/0,115/0] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,75:%$for$$to$repeat$S$39$39,75:%$for$$to$repeat$S$39$39]
;; storeg  @for::to:repeat$S$39$39 2
   %R116 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R75, i32 0, i32 2
   store i32 %V115, i32* %R116
   ;; stack: vpop : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 5 V: 90 R: 75 
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 3 rTopMax: 5 V: 90 R: 75 
;; rswap  0
;; rswap  0
;; rdouble 0
   ;; vTop(1,2)=[90/0] rTop(3,5)=[50:%BETA$2*,89:%BETA$2*,75:%$for$$to$repeat$S$39$39]
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 4 rTopMax: 5 V: 90 R: 75 
   ;; vTop(1,2)=[90/0] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,75:%$for$$to$repeat$S$39$39,75:%$for$$to$repeat$S$39$39]
;; storeg  @for::to:repeat$S$39$39 1
   %R117 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R75, i32 0, i32 1
   store i32 %V90, i32* %R117
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 4 rTopMax: 5 V: R: 75 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 75 
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,5)=[50:%BETA$2*,75:%$for$$to$repeat$S$39$39,89:%BETA$2*] 
   ;; @for::to:repeat   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$39$39 this: @for::to:repeat$21 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; topSuper: 21   @for::to:repeat$21 
   %R118 = bitcast %$for$$to$repeat$S$39$39* %R75 to %$for$$to$repeat$21*
   %R119 = call %$for$$to$repeat$21* @$for$$to$repeat$21(%$for$$to$repeat$21 * %R118)
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 5 V: R: 89 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 118 
   %V122 = icmp eq %$for$$to$repeat$21* %R119, %R118
   br i1 %V122, label %normalRtnLab120, label %breakLab121
breakLab121:
   %R123 = bitcast %$for$$to$repeat$21* %R119 to %$S$35$35*
   %V124 = icmp eq %$S$35$35* %R0, %R123
   br i1 %V124, label %selectBreakLab126, label %contBreakLab125
contBreakLab125:
   ret %$S$35$35* %R123
selectBreakLab126:
   %R127 = bitcast %$for$$to$repeat$21* %R119 to [0 x i32]*
   %R128 = getelementptr [0 x i32], [0 x i32]* %R127, i32 0, i32 0
   %V129 = load i32 , i32* %R128
   %R130 = getelementptr %$for$$to$repeat$21,%$for$$to$repeat$21* %R119, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$21* @vdt_data$$for$$to$repeat$21, %vdt_type$$for$$to$repeat$21** %R130
   %V131 = icmp eq i32 1, %V129
   br i1 %V131, label %X132, label %X133
X132:
   br label %L1 ; restart
X133:
   br label %L2 ; leave
normalRtnLab120:

   ;; vTop(0,2)=[] rTop(3,5)=[50:%BETA$2*,89:%BETA$2*,118:%$for$$to$repeat$21*]
;; rpop 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 5 V: R: 89 
   ;; genclass:stmt: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; $ObjectGenerator:"V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 40 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; Qgen: useRtnV:"False" descNo: 40 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; not const:  V out V: ref String 
   ;; needorigin: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; needOrigin:E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  E.ATd: ":=  : {   %basic 8;   in V: var Value}" 
   ;; doNeedOrigin:Ex: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; computeAdr: 1 :rec: "none"  E: "V" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"V" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "o ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 0 
   ;; %$S$35$35* 
   ;; $ObjectInvocation_Unary:"V" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "V" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R134 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 1
   %R135 = load %_add$33* , %_add$33** %R134
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 5 V: R: 89 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 135 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"V" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ref:"out V: ref String" 
   ;; >getAdr:,newOff:3,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"V"}   out V: ref String 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "V"  ATd: "out V: ref String" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "V"  E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr:isAssign:rec:  "V"  E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr:isLast:E:  ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; rec:  "V" E:  ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; >loadArgs:staticOff:3 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}  hasArg:  pattern 
   ;; := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}   :=  : {   %basic 8;   in V: var Value} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value"} 
   ;; >loadArgs:E:":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];":descNo:40:top:1} 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; ActArg:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; loadArgs:A: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; $ObjectGenerator:"T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; Qgen:OGid:"asString" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "asString" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; needorigin: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; needOrigin:E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  E.ATd: "asString: {   %basic 118;   out S: ref Object}" 
   ;; doNeedOrigin:Ex: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; computeAdr: 1 :rec: "none"  E: "T" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "T ..." 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 4 rTopMax: 5 V: R: 0 
   ;; %$S$35$35* 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >loadOrigin::on:0 
   ;; AdjustOrigin:originOff: 0 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >getAdr:,newOff:4,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"T"}   T: obj Indexed(L + S.length,Integer) 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 0 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "T"  E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];} 
   ;; $ObjectInvocation_Unary:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"asString: {   %basic 118;   out S: ref Object"} 
   ;; >getAdr: 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length] ..."} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   obj 
   ;; T   T: obj Indexed(L + S.length,Integer) 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "T: obj Indexed(L + S.length,Integer)"  E:  "T" 
   ;;  
   ;; $pattern:"Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get 0;   @put: ;  ..."} 
   ;; >loadArgs:E:"T":descNo:36:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >invoke: rec:"T" 
   ;; E.ATd:  "asString" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; OI:invoke:B: "T" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >invoke:E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];" newOff:4 useRTNv: "True"} 
   ;; >Object:unique: false 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
;; rpushg $S$35$35 4
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%array$1*" 
   %R136 = getelementptr %$S$35$35,%$S$35$35 *%R0, i32 0, i32 4
   %R137 = load %array$1* , %array$1** %R136
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 135 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 4 rTopMax: 5 V: R: 137 
   ;; OI:invoke: T :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + ..."} 
   ;; rec:  "T" E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" superAdj= 0 
   ;; $ObjectInvocation_Unary:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  -- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length];} pattern 
   ;; asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}   asString: {   %basic 118;   out S: ref Object} 
   ;; $pattern:"asString: {   %basic 118;   out S: ref Object"} 
   ;; >loadArgs:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];":descNo:0:top:0} 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgI ...}   ... true 
   ;; IV:E.invoke:useRTNv: true E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; $ObjectInvocation_Unary:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; >invoke: rec:"T" 
   ;; OI:invoke:isPtn: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" descNo 0  useRTNv: true 
   ;; E.ATd:  "asString" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; OI:invoke:B: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length]  ...}"   ... "T ..."   ... true "a ..." 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; $pattern:"asString: {   %basic 118;   out S: ref Object"} 
   ;; >invoke:E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];" useRTNv: "True"} 
   ;; ptn:invoke: "asString" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" useRtnV: true 

   ;; OI:invoke: asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];} :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; loadArgs:after:Qgen: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; vAssign:fArg: "in V: var Value" 
   ;; BINGO 
   ;; aaaa:  in V: var Value 
   ;; end:loadArgs:NonVirt: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; IV:after:loadArgsOf: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F ...}   ... false 
   ;; IV:E.invoke:useRTNv: false E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; $ObjectInvocation_Binary:":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; >invoke: rec:"V" 
   ;; OI:invoke:isPtn: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" descNo 40  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; OI:invoke:B: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[ ...}"   ... "V ..."   ... false ": ..." 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:":= T.asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value"} 
   ;; >invoke:E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];" useRTNv: "False"} 
   ;; ptn:invoke: ":=" E: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "V" from:  ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   ;; assign:dstDI : "out V: ref String" isUnitValueObj:  false 
   ;; assign:arg:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];} 
   ;;  arg.super.ATd: "Invocation" "asString: {   %basic 118;   out S: ref Object}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:reference:  "V" 
   ;; assign:before:adr.store:E:  ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}"  rec:  "V" "$S$35$35" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:":= T.asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];"} 
   ;; store: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"V"} 
   ;; isValue: false  isAdr: false  descNo:  0 
;; rswap  0
;; rstoreg  +$33 3
   %R138 = getelementptr %_add$33,%_add$33 *%R135, i32 0, i32 3
;; types:dst: %String$15* src: %array$1*
   %R139 = bitcast %array$1* %R137 to %String$15*
   ;; vTop(0,2)=[] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,137:%array$1*,135:%_add$33*]
   store %String$15* %R139, %String$15* * %R138
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 5 V: R: 89 
   ;; vTop(0,2)=[] rTop(2,5)=[50:%BETA$2*,89:%BETA$2*]
   ;; OI:invoke: := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];} :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length];}" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 0 
   ;; %$S$35$35* 
   ;; vTop(0,2)=[] rTop(3,5)=[50:%BETA$2*,89:%BETA$2*,0:%$S$35$35*]
   ret %$S$35$35* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 5 V: R: 89 
}
   ;; vdt:vdtTop: 1 35:I
@vdt_data$$S$35$35 = global %vdt_type$$S$35$35 {
      %$S$35$35*(%$S$35$35*)* @$S$35$35
}

define %vdt_ret$$S$35$35* @vdt_alloc$$S$35$35(%_add$33* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$S$35$35
   %R141 = tail call i8* @malloc(i64 32)
   %R142 = bitcast i8* %R141 to %vdt_ret$$S$35$35*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$S$35$35 
   ;; alloc %$S$35$35
   %R143 = tail call i8* @malloc(i64 192)
   %R144 = bitcast i8* %R143 to %$S$35$35*
   ;; store VDT in object
   %R145 = getelementptr %$S$35$35, %$S$35$35* %R144, i32 0, i32 0
   store %vdt_type$$S$35$35* @vdt_data$$S$35$35, %vdt_type$$S$35$35** %R145
   %R146 = getelementptr %vdt_ret$$S$35$35,%vdt_ret$$S$35$35* %R142, i32 0, i32 0
   store %$S$35$35* %R144, %$S$35$35** %R146
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: + thisClassOrgDescNo: 33 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 4 rTopMax: 5 V: R: 144 
   ;; vTop(0,2)=[] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,1:%_add$33*,144:%$S$35$35]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: $S$35 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: $S$35$35 this: $S$35$35 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 $S$35$35 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,1:%_add$33*,144:%$S$35$35]
   ;; lookup:  %_add$33*
   ;; vTop(0,2)=[] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,1:%_add$33*,144:%$S$35$35]
   %R147 = getelementptr %$S$35$35, %$S$35$35 * %R144, i32 0, i32 1
   store %_add$33* %R1, %_add$33** %R147
;; rswap  0
   ;; vTop(0,2)=[] rTop(4,5)=[50:%BETA$2*,89:%BETA$2*,144:%$S$35$35,1:%_add$33*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 5 V: R: 144 
   ;; vTop(0,2)=[] rTop(3,5)=[50:%BETA$2*,89:%BETA$2*,144:%$S$35$35]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$S$35$35* %R142
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 36 :top: 1 
   ;; Items:GenClass: Indexed descNo: 36 
;; class  Indexed 36 0 BETA 2

define %Indexed$36* @Indexed$36(%Indexed$36* %R0){
   %V0 = add i32 0, 0
   ;; vdtAdd: inx=1 descInx=36 vDescInx=36 vdtTop: 1
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; $Property:"%basic 114" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"in range: var Integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  range 
   ;; $pattern:"in elm:< Object" 
   ;; Qgen: 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%globals" 
   ;; $Property:"%globals" 
   ;; Qgen: 
   ;; genclass:stmt: "%basic 114" 
   ;; $Property:"%basic 114" 
   ;; Qgen: 
   ;; genclass:stmt: "%public" 
   ;; $Property:"%public" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  "Indexed" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %Indexed$36* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%Indexed$36*]
   ret %Indexed$36* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdtAdd: inx=2 descInx=36 vDescInx=45 vdtTop: 2
   ;; vdt:vdtTop: 2 36:I,45:V
@vdt_data$Indexed$36 = global %vdt_type$Indexed$36 {
      %Indexed$36*(%Indexed$36*)* @Indexed$36,
      %vdt_ret$elm$37$45*(%Indexed$36*)* @vdt_alloc$$S$45$45
}

define %vdt_ret$Indexed$36* @vdt_alloc$Indexed$36(%BETA$2* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$Indexed$36
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$Indexed$36*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %Indexed$36 
   ;; alloc %Indexed$36
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %Indexed$36*
   ;; store VDT in object
   %R6 = getelementptr %Indexed$36, %Indexed$36* %R5, i32 0, i32 0
   store %vdt_type$Indexed$36* @vdt_data$Indexed$36, %vdt_type$Indexed$36** %R6
   %R7 = getelementptr %vdt_ret$Indexed$36,%vdt_ret$Indexed$36* %R3, i32 0, i32 0
   store %Indexed$36* %R5, %Indexed$36** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: BETA thisClassOrgDescNo: 2 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%BETA$2*,5:%Indexed$36]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: Indexed 
   ;; after:handleOrigins 
   ret %vdt_ret$Indexed$36* %R3
}
   ;; ObjStubStackX:gen 
;; class  elm#37 45 0 Indexed$36 36 isVstub

define %elm$37$45* @elm$37$45(%Indexed$36* %R1){
   ;; isVstubObject 
   %V0 = add i32 0, 0
   ;; Load origin:OG.isVirtualArg: false 
   %Rx = tail call i8* @malloc(i64 128)
   %R0 = bitcast i8* %Rx to %elm$37$45*
   ;; cast:  %Indexed$36*   %Object$22* 
   %R2 = bitcast %Indexed$36* %R1 to %Object$22*
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; vTop(0,0)=[] rTop(1,1)=[2:%Object$22*]
   ;; OG.super.on/descNo: 1 22 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %elm$37$45* 
;; rstoreg  %elm$37$45* 2
   %R3 = getelementptr %elm$37$45,%elm$37$45 *%R0, i32 0, i32 2
;; types:dst: %Object$22* src: %Object$22*
   store %Object$22*  %R2, %Object$22* * %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; vTop(0,0)=[] rTop(0,2)=[]
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; %elm$37$45* 
;; rpushg %elm$37$45* 2
   ;; Rtype.rtop: "%elm$37$45*" typeInfo[rtop,off]=elmType: "%Object$22*" 
   %R4 = getelementptr %elm$37$45,%elm$37$45 *%R0, i32 0, i32 2
   %R5 = load %Object$22* , %Object$22** %R4
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(1,2)=[5:%Object$22*]
   %R6 = bitcast %Object$22* %R5 to %elm$37$45*
   ret %elm$37$45* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 2 V: R: 
}
   ;; vdt:vdtTop: 0 
@vdt_data$elm$37$45 = global %vdt_type$elm$37$45 {
}

define %vdt_ret$elm$37$45* @vdt_alloc$elm$37$45(%Indexed$36* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$elm$37$45
   %R8 = tail call i8* @malloc(i64 32)
   %R9 = bitcast i8* %R8 to %vdt_ret$elm$37$45*
   ;; mkVDTalloc:B: 
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: Indexed$36 thisClassOrgDescNo: 36 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; vTop(0,0)=[] rTop(1,2)=[1:%Indexed$36]
   ;; CALL Vstub: %elm$37$45 
   %R10 = call %elm$37$45* @elm$37$45(%Indexed$36* %R1)
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 10 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,10:%elm$37$45]
   ;; Store binding in vdt_ret. Note! types are not correct 
   %R11 = getelementptr %vdt_ret$elm$37$45,%vdt_ret$elm$37$45* %R9, i32 0, i32 0
   store %elm$37$45* %R10, %elm$37$45** %R11
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,10:%elm$37$45]
   ;; Vstub:handleOrigins:NEW: elm#37 %ID Object{%basic 64;%public;:=  : ;   %basic 8;   in V: var Value;:-  : ;   %basic 6;   in R: ref Object;==  : ;   %basic 56;   in objx: r ...} 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,10:%elm$37$45]
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[10:%elm$37$45,1:%Indexed$36]
   ;; goOriginAdr:  "Object" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadOrigin::on:1 
   ;; goOriginAdr:not:BracE: ObjectInvocation_Unary 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
;; rswap  0
   ;; OriginIsValue: false 
   ;; storeOrigins:main: Object$22 this: Object$22 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; fixTypeOfBinding: "Object$22"  typeOnStack: "%elm$37$45" 
   %R12 = bitcast %elm$37$45* %R10 to %Object$22*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,10:%elm$37$45]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 12 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,12:Object$22]
   ;; OriginIsValue: false 
;; rstoreX  1 Object$22 isValueObjectOrigin: F
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,12:Object$22]
   ;; lookup:  %BETA$2*
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Indexed$36,12:Object$22]
   %R13 = getelementptr %Object$22, %Object$22 * %R12, i32 0, i32 1
   %R14 = bitcast %BETA$2** %R13 to %Indexed$36**
   store %Indexed$36* %R1, %Indexed$36** %R14
;; rswap  0
   ;; vTop(0,0)=[] rTop(2,2)=[12:Object$22,1:%Indexed$36]
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 12 
   ;; vTop(0,0)=[] rTop(1,2)=[12:Object$22]
   ;; Vstub:handleOrigins:END:  
   ret %vdt_ret$elm$37$45* %R9
}
   ;; vdt:a:dNo: 45  newDescNo:  36 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 41 :top: 1 
   ;; Items:GenClass: repeat$S$41 descNo: 41 
;; class  repeat$S$41 41 1 @for::to:repeat$S$38 38

define %repeat$S$41$41* @repeat$S$41$41(%repeat$S$41$41* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=41 vDescInx=41 vdtTop: 1
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "e := @get inx" 
   ;; $ObjectGenerator:"e := @get inx" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"e := @get inx" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "e := @get inx" 
   ;; not const:  e e: var integer 
   ;; needorigin: "e := @get inx" 
   ;; needOrigin:E: ":= @get inx"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= @get inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "e := @get inx" 
   ;; computeAdr: 1 :rec: "none"  E: "e" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := @get inx{T.@put e :at inx}" ATd: "e: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %repeat$S$41$41* 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$41" newOriginOff: 1 origin: "@for::to:repeat$S$38$38" 
   ;; NA: "e" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%repeat$S$41$41*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$38$38*" 
   %R1 = getelementptr %repeat$S$41$41,%repeat$S$41$41 *%R0, i32 0, i32 1
   %R2 = load %$for$$to$repeat$S$38$38* , %$for$$to$repeat$S$38$38** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$38" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "e" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$38$38*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R3 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R2, i32 0, i32 4
   %R4 = load %$S$35$35* , %$S$35$35** %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 4 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"e: var integer" 
   ;; >getAdr:,newOff:2,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"e"}   e: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "e: var integer" ObjectGenerator 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; After:U*U: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "e"  ATd: "e: var integer" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr: 2 :rec: "e"  E: ":= @get inx"  A.E: "e" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr:isAssign:rec:  "e"  E: ":= @get inx" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr:isLast:E:  ":= @get inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; rec:  "e" E:  ":= @get inx" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= @get inx" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= @get inx" 
   ;; >loadArgs:staticOff:2 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @get inx  hasArg:  pattern 
   ;; := @get inx   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= @get inx":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= @get inx" 
   ;; ActArg:  "@get inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= @get inx" 
   ;; loadArgs:A: "@get inx" 
   ;; $ObjectGenerator:"@get inx" 
   ;; Qgen:OGid:"@get:" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "@get" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"@get inx" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "@get inx" 
   ;; needorigin: "@get inx" 
   ;; needOrigin:E: "@get inx"  E.ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; doNeedOrigin:Ex: "@get inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "@get inx" 
   ;; computeAdr: 1 :rec: "none"  E: "@get inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := @get inx{T.@put e :at inx}" ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %repeat$S$41$41* 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >loadOrigin::on:4 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 4 
   ;; goOrigin: "repeat$S$41" newOriginOff: 1 origin: "@for::to:repeat$S$38$38" 
   ;; NA: "@get inx" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%repeat$S$41$41*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$38$38*" 
   %R5 = getelementptr %repeat$S$41$41,%repeat$S$41$41 *%R0, i32 0, i32 1
   %R6 = load %$for$$to$repeat$S$38$38* , %$for$$to$repeat$S$38$38** %R5
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 6 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 3 
   ;; goOrigin: "@for::to:repeat$S$38" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "@get inx" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$38$38*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R7 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R6, i32 0, i32 4
   %R8 = load %$S$35$35* , %$S$35$35** %R7
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 8 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "@get inx" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R9 = getelementptr %$S$35$35,%$S$35$35 *%R8, i32 0, i32 1
   %R10 = load %_add$33* , %_add$33** %R9
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 10 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "+" newOriginOff: 1 origin: "String$15" 
   ;; NA: "@get inx" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R11 = getelementptr %_add$33,%_add$33 *%R10, i32 0, i32 1
   %R12 = load %String$15* , %String$15** %R11
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 12 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >getAdr::superAdj:0:on:4 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; E.on: 4 
   ;; beforeIsValueObj:E: "@get inx"  ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; computeAdr:isFirst: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; computeAdr:isLast:E:  "@get inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; rec:  "@get inx" E:  "@get inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@get inx" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @get inx  hasArg:  pattern 
   ;; @get inx   @get: {   %basic 117;   in get: var integer;   out ch: var char} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >loadArgs:E:"@get inx":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@get inx" 
   ;; ActArg:  "inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@get inx" 
   ;; loadArgs:not:*:  formalArgOf: "@get inx"  isCompositeValueObj: false 
   ;; loadArgs:A: "inx" 
   ;; $ObjectGenerator:"inx" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx" 
   ;; needOrigin:E: "inx"  E.ATd: "inx: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := @get inx{T.@put e :at inx}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 0 
   ;; %repeat$S$41$41* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "repeat$S$41" newOriginOff: 1 origin: "@for::to:repeat$S$38$38" 
   ;; NA: "inx" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%repeat$S$41$41*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$38$38*" 
   %R13 = getelementptr %repeat$S$41$41,%repeat$S$41$41 *%R0, i32 0, i32 1
   %R14 = load %$for$$to$repeat$S$38$38* , %$for$$to$repeat$S$38$38** %R13
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 12 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 14 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  "inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  "inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inx" superAdj= 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "inx" 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "inx" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "inx" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isFloat:B:  false 
;; pushg 3 @for::to:repeat$S$38$38
   %R15 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R14, i32 0, i32 3
   %V16 = load i32, i32* %R15
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 12 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 16 R: 12 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inx" 
   ;; loadArgs:after:Qgen: "@get inx" 
   ;; formalArg:isPtn: "in get: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "inx" :isBasicVal: true 
   ;; inx ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@get inx" 
   ;; IV:after:loadArgsOf: "@get inx" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "@get inx" 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >invoke: rec:"@get inx" 
   ;; OI:invoke:isPtn: "@get inx" descNo 0  useRTNv: true 
   ;; E.ATd:  "@get" unique:  false 
   ;; adr: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; OI:invoke:B: "@get inx" E: "@get inx"  rec: "@get inx"  useRtnV: true "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >invoke:E: "@get inx" useRTNv: "True" 
   ;; ptn:invoke: "@get" E: "@get inx" useRtnV: true 
;; xpushg  inx 1 0 1
   ;; vTop(1,1)=[16/0] rTop(2,3)=[4:%$S$35$35*,12:%String$15*]
;; xpusg:String
   %R17 = bitcast %String$15* %R12 to {i32*,i32,[0 x i32]}*
%V18 = add i32 -1, %V16
%R19 = getelementptr inbounds {i32*,i32,[0 x i32]}, {i32*,i32,[0 x i32]}* %R17, i32 0, i32 2
%R20 = getelementptr inbounds [0 x i32], [0 x i32]* %R19, i32 0, i32 %V18
%V21 = load i32 , i32* %R20, align 4
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 16 R: 4 
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 4 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 21 R: 4 
   ;; OI:invoke: @get inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "@get inx" 
   ;; loadArgs:after:Qgen: ":= @get inx" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; BINGO 
   ;; aaaa:  in V: var Value{--inner(Value);} 
   ;; end:loadArgs:NonVirt: ":= @get inx" 
   ;; IV:after:loadArgsOf: ":= @get inx" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= @get inx" 
   ;; $ObjectInvocation_Binary:":= @get inx" 
   ;; >invoke: rec:"e" 
   ;; OI:invoke:isPtn: ":= @get inx" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:invoke:B: ":= @get inx" E: ":= @get inx"  rec: "e"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= @get inx"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= @get inx" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= @get inx" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "e" from:  ":= @get inx" 
   ;; assign:dstDI : "e: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "@get inx" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: @get inx 
   ;;  arg.super.ATd: "Invocation" "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= @get inx"  rec:  "e" "repeat$S$41$41" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= @get inx"} 
   ;; store: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  $S$35$35 2
   %R22 = getelementptr %$S$35$35,%$S$35$35 *%R4, i32 0, i32 2
   store i32 %V21, i32* %R22
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 4 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; OI:invoke: := @get inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= @get inx" 
   ;; genclass:stmt: "T.@put e :at inx" 
   ;; $ObjectGenerator:"T.@put e :at inx" 
   ;; Qgen:OGid:"@put::at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "@put" superDescNo: 42 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"T.@put e :at inx" 
   ;; Qgen: useRtnV:"False" descNo: 42 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "T.@put e :at inx" 
   ;; needorigin: "T.@put e :at inx" 
   ;; needOrigin:E: "@put e :at inx"  E.ATd: "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; doNeedOrigin:Ex: "@put e :at inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "T.@put e :at inx" 
   ;; computeAdr: 1 :rec: "none"  E: "T" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := @get inx{T.@put e :at inx}" ATd: "T: obj Indexed(L + S.length,Integer)" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %repeat$S$41$41* 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$41" newOriginOff: 1 origin: "@for::to:repeat$S$38$38" 
   ;; NA: "T" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%repeat$S$41$41*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$38$38*" 
   %R23 = getelementptr %repeat$S$41$41,%repeat$S$41$41 *%R0, i32 0, i32 1
   %R24 = load %$for$$to$repeat$S$38$38* , %$for$$to$repeat$S$38$38** %R23
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 24 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$38" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "T" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$38$38*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R25 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R24, i32 0, i32 4
   %R26 = load %$S$35$35* , %$S$35$35** %R25
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >getAdr:,newOff:4,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"T"}   T: obj Indexed(L + S.length,Integer) 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "T"  E: "@put e :at inx" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: @put e :at inx 
   ;; $ObjectInvocation_KeyWord:"@put e :at inx" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@put: {   %basic 115;   in put: ref elm;   in at: var integer"} 
   ;; >getAdr: 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   obj 
   ;; T   T: obj Indexed(L + S.length,Integer) 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "T: obj Indexed(L + S.length,Integer)"  E:  "T" 
   ;;  
   ;; $pattern:"Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get 0;   @put: ;  ..."} 
   ;; >loadArgs:E:"T":descNo:36:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >invoke: rec:"T" 
   ;; E.ATd:  "@put" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; OI:invoke:B: "T" E: "@put e :at inx"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >invoke:E: "@put e :at inx" newOff:4 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
;; rpushg repeat$S$41$41 4
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%array$1*" 
   %R27 = getelementptr %$S$35$35,%$S$35$35 *%R26, i32 0, i32 4
   %R28 = load %array$1* , %array$1** %R27
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 28 
   ;; OI:invoke: T :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "@put e :at inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; rec:  "T" E:  "@put e :at inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@put e :at inx" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"@put e :at inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @put e :at inx  hasArg:   hasArg:  pattern 
   ;; @put e :at inx   @put: {   %basic 115;   in put: ref elm;   in at: var integer} 
   ;; $pattern:"@put: {   %basic 115;   in put: ref elm;   in at: var integer"} 
   ;; >loadArgs:E:"@put e :at inx":descNo:42:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@put e :at inx" 
   ;; ActArg:  "e" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@put e :at inx" 
   ;; loadArgs:not:*:  formalArgOf: "@put e :at inx"  isCompositeValueObj: false 
   ;; loadArgs:A: "e" 
   ;; $ObjectGenerator:"e" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"e" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "e" 
   ;; not const:  e e: var integer 
   ;; needorigin: "e" 
   ;; needOrigin:E: "e"  E.ATd: "e: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "e" 
   ;; computeAdr: 1 :rec: "none"  E: "e" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := @get inx{T.@put e :at inx}" ATd: "e: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 0 
   ;; %repeat$S$41$41* 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$41" newOriginOff: 1 origin: "@for::to:repeat$S$38$38" 
   ;; NA: "e" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%repeat$S$41$41*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$38$38*" 
   %R29 = getelementptr %repeat$S$41$41,%repeat$S$41$41 *%R0, i32 0, i32 1
   %R30 = load %$for$$to$repeat$S$38$38* , %$for$$to$repeat$S$38$38** %R29
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 28 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 30 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$38" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "e" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$38$38*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R31 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R30, i32 0, i32 4
   %R32 = load %$S$35$35* , %$S$35$35** %R31
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 28 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 32 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"e: var integer" 
   ;; >getAdr:,newOff:2,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"e"}   e: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "e: var integer" ObjectGenerator 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; After:U*U: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "e"  ATd: "e: var integer" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr:isLast:E:  "e" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; rec:  "e" E:  "e" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "e" superAdj= 0 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; e   e: var integer 
   ;; $var:"e: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "e: var integer"  E:  "e" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"e":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "e" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "e" 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >invoke: rec:"e" 
   ;; E.ATd:  "e" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:invoke:B: "e" E: "e"  rec: "e"  useRtnV: true "e: var integer" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; $var:"e: var integer" 
   ;; >invoke:E: "e" newOff:2 useRTNv: "True" 
   ;; load: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; isFloat:B:  false 
;; pushg 2 $S$35$35
   %R33 = getelementptr %$S$35$35,%$S$35$35 *%R32, i32 0, i32 2
   %V34 = load i32, i32* %R33
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 28 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 34 R: 28 
   ;; BOBS! 
   ;; OI:invoke: e :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "e" 
   ;; loadArgs:after:Qgen: "@put e :at inx" 
   ;; formalArg:isPtn: "in put: ref elm" :isBasicVal: false :valueObj: false 
   ;; :actArg: "e" :isBasicVal: true 
   ;; e ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@put e :at inx" 
   ;; loadArgs:NonVirt: "@put e :at inx" 
   ;; ActArg:  "inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@put e :at inx" 
   ;; loadArgs:not:*:  formalArgOf: "@put e :at inx"  isCompositeValueObj: false 
   ;; loadArgs:A: "inx" 
   ;; $ObjectGenerator:"inx" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx" 
   ;; needOrigin:E: "inx"  E.ATd: "inx: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := @get inx{T.@put e :at inx}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 34 R: 0 
   ;; %repeat$S$41$41* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "repeat$S$41" newOriginOff: 1 origin: "@for::to:repeat$S$38$38" 
   ;; NA: "inx" origin: "repeat$S$41$41" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$41$41 1
   ;; Rtype.rtop: "%repeat$S$41$41*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$38$38*" 
   %R35 = getelementptr %repeat$S$41$41,%repeat$S$41$41 *%R0, i32 0, i32 1
   %R36 = load %$for$$to$repeat$S$38$38* , %$for$$to$repeat$S$38$38** %R35
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 34 R: 28 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 34 R: 36 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  "inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  "inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inx" superAdj= 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "inx" 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "inx" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "inx" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isFloat:B:  false 
;; pushg 3 @for::to:repeat$S$38$38
   %R37 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R36, i32 0, i32 3
   %V38 = load i32, i32* %R37
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 34 R: 28 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 38 R: 28 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inx" 
   ;; loadArgs:after:Qgen: "@put e :at inx" 
   ;; formalArg:isPtn: "in at: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "inx" :isBasicVal: true 
   ;; inx ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@put e :at inx" 
   ;; IV:after:loadArgsOf: "@put e :at inx" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "@put e :at inx" 
   ;; $ObjectInvocation_KeyWord:"@put e :at inx" 
   ;; >invoke: rec:"T" 
   ;; OI:invoke:isPtn: "@put e :at inx" descNo 42  useRTNv: false 
   ;; E.ATd:  "@put" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; OI:invoke:B: "@put e :at inx" E: "@put e :at inx"  rec: "T"  useRtnV: false "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at inx"} 
   ;; $pattern:"@put: {   %basic 115;   in put: ref elm;   in at: var integer"} 
   ;; >invoke:E: "@put e :at inx" useRTNv: "False" 
   ;; ptn:invoke: "@put" E: "@put e :at inx" useRtnV: false 
   ;; invoke:indexedPut:  @put: {   %basic 115;   in put: ref elm;   in at: var integer} 
   ;; Integer 
   ;; primitive:  1 
;; xstoreg  inx 1 0 1
   ;; vTop(2,2)=[34/0,38/0] rTop(1,3)=[28:%array$1*]
%V39 = add i32 -1, %V38
%R40 = getelementptr inbounds %array$1,  %array$1* %R28, i32 0, i32 2
%R41 = getelementptr inbounds [0 x i32], [0 x i32]* %R40, i32 0, i32 %V39
store i32 %V34, i32* %R41, align 4
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 3 V: 38 R: 
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
   ;; OI:invoke: @put e :at inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "@put e :at inx" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %repeat$S$41$41* 
   ;; vTop(0,2)=[] rTop(1,3)=[0:%repeat$S$41$41*]
   ret %repeat$S$41$41* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
}
   ;; vdt:vdtTop: 1 41:I
@vdt_data$repeat$S$41$41 = global %vdt_type$repeat$S$41$41 {
      %repeat$S$41$41*(%repeat$S$41$41*)* @repeat$S$41$41
}

define %vdt_ret$repeat$S$41$41* @vdt_alloc$repeat$S$41$41(%$for$$to$repeat$S$38$38* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$repeat$S$41$41
   %R43 = tail call i8* @malloc(i64 32)
   %R44 = bitcast i8* %R43 to %vdt_ret$repeat$S$41$41*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %repeat$S$41$41 
   ;; alloc %repeat$S$41$41
   %R45 = tail call i8* @malloc(i64 192)
   %R46 = bitcast i8* %R45 to %repeat$S$41$41*
   ;; store VDT in object
   %R47 = getelementptr %repeat$S$41$41, %repeat$S$41$41* %R46, i32 0, i32 0
   store %vdt_type$repeat$S$41$41* @vdt_data$repeat$S$41$41, %vdt_type$repeat$S$41$41** %R47
   %R48 = getelementptr %vdt_ret$repeat$S$41$41,%vdt_ret$repeat$S$41$41* %R44, i32 0, i32 0
   store %repeat$S$41$41* %R46, %repeat$S$41$41** %R48
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: @for::to:repeat$S$38 thisClassOrgDescNo: 38 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 46 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: repeat$S$41 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$41$41 this: repeat$S$41$41 originOff: 1 orgIsValObj: false 
;; rdouble -1
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 46 
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$38$38*,1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 repeat$S$41$41 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$38$38*,1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   ;; lookup:  %$for$$to$repeat$S$38$38*
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$38$38*,1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   %R49 = getelementptr %repeat$S$41$41, %repeat$S$41$41 * %R46, i32 0, i32 1
   store %$for$$to$repeat$S$38$38* %R1, %$for$$to$repeat$S$38$38** %R49
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41,1:%$for$$to$repeat$S$38$38*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 46 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   ;; go:super.ATd: "in repeat:< Object" thisOG.super.on: 0 thisOG.OGid: "repeat$S$41" 
   ;; 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
;; rswap  0
   ;; goOriginAdr:  "" 
   ;; goOriginAdr:isImplSuper: 
   ;; vTop(0,2)=[] rTop(2,3)=[46:%repeat$S$41$41,1:%$for$$to$repeat$S$38$38*]
   ;; vTop(0,2)=[] rTop(2,3)=[46:%repeat$S$41$41,1:%$for$$to$repeat$S$38$38*] 
   ;; Object   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$41$41 this: Object$22 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; go:super.ATd: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;     ...}" t ... 1 t ... "O ..." 
   ;; thisOG.IS: origin: "Object" 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
;; rswap  0
   ;; goOriginAdr:  "Object" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadOrigin::on:1 
   ;; goOriginAdr:not:BracE: ObjectInvocation_Unary 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; vTop(0,2)=[] rTop(2,3)=[46:%repeat$S$41$41,1:%$for$$to$repeat$S$38$38*]
   ;; before:E.loadArgs: Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; Object   Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %bas ...} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >loadArgs:E:"Object":descNo:22:top:1 
   ;; isValueAssign:  false 
   ;; vTop(0,2)=[] rTop(2,3)=[46:%repeat$S$41$41,1:%$for$$to$repeat$S$38$38*] 
   ;; Object   1 
;; rswap  0
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$41$41 this: Object$22 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 repeat$S$41$41 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   ;; lookup:  %$for$$to$repeat$S$38$38*
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$38$38*,46:%repeat$S$41$41]
   %R50 = getelementptr %repeat$S$41$41, %repeat$S$41$41 * %R46, i32 0, i32 1
   store %$for$$to$repeat$S$38$38* %R1, %$for$$to$repeat$S$38$38** %R50
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,3)=[46:%repeat$S$41$41,1:%$for$$to$repeat$S$38$38*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 46 
   ;; vTop(0,2)=[] rTop(1,3)=[46:%repeat$S$41$41]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$repeat$S$41$41* %R44
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 38 :top: 1 
   ;; Items:GenClass: @for::to:repeat$S$38 descNo: 38 
;; class  @for::to:repeat$S$38 38 4 $S$35 35

define %$for$$to$repeat$S$38$38* @$for$$to$repeat$S$38$38(%$for$$to$repeat$S$38$38* %R0){
   %V0 = add i32 0, 0
;; rstore  4 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtTableCopy: I:1:21 V:2:44 I:3:0
   ;; vdtAdd: inx=3 descInx=38 vDescInx=38 vdtTop: 3
   ;; push:super.origin: 
   ;; handleSuperArgs:E: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" theIS: "" 
   ;; super.sig:none:superAdj: 4 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 4 
   ;; args:  @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  4   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  4 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  4 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 4 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 4 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V1 = add i32 0, 1
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 0 V: 1 R: 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ActArg:  "L" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  4   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  isCompositeValueObj: false 
   ;; loadArgs:A: "L" 
   ;; $ObjectGenerator:"L" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  4 
   ;; $Invocation:"L" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  4 
   ;; isConstant: "Invocation" "L" 
   ;; not const:  L L: var integer 
   ;; needorigin: "L" 
   ;; needOrigin:E: "L"  E.ATd: "L: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 4 
   ;; computeAdr:A.superAdj: 4 "L" 
   ;; computeAdr: 1 :rec: "none"  E: "L" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "L ..." 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 0 
   ;; %$for$$to$repeat$S$38$38* 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 4 
;; rpushg $S$35$35 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$38$38*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R2 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R0, i32 0, i32 4
   %R3 = load %$S$35$35* , %$S$35$35** %R2
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 3 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "L" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R4 = getelementptr %$S$35$35,%$S$35$35 *%R3, i32 0, i32 1
   %R5 = load %_add$33* , %_add$33** %R4
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 5 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >getAdr::superAdj:4:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"L: var integer" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUniq:F{ isValue:F orgIsVal:F:E:"L"}   L: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "L: var integer" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "L"  ATd: "L: var integer" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr:isLast:E:  "L" 
   ;; IV:after:computeAdr:superAdj: 4 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; rec:  "L" E:  "L" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "L" superAdj= 4 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 4 
   ;; args:   var 
   ;; L   L: var integer 
   ;; $var:"L: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "L: var integer"  E:  "L" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"L":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "L" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "L" 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >invoke: rec:"L" 
   ;; E.ATd:  "L" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; $var:"L: var integer" 
   ;; >invoke:E: "L" newOff:4 useRTNv: "True" 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; isFloat:B:  false 
;; pushg 4 +$33
   %R6 = getelementptr %_add$33,%_add$33 *%R5, i32 0, i32 4
   %V7 = load i32, i32* %R6
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 1 V: 7 R: 
   ;; BOBS! 
   ;; OI:invoke: L :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "L" 
   ;; loadArgs:after:Qgen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "L" :isBasicVal: true 
   ;; L ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; args:  "in repeat:< Object" "e := @get inx{T.@put e :at inx}" @for::to:repeat 
   ;; hArgOrg:super: @for::to:repeat 
   ;; vdtAdd: inx=1 descInx=38 vDescInx=21 vdtTop: 3
   ;; $Property:"%globals inSub" 
   ;; Qgen: 
   ;; $var:"in for: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  for 
   ;; $var:"in to: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  to 
   ;; $pattern:"in repeat:< Object" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"inx: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  inx 
   ;; $Property:"%private" 
   ;; Qgen: 
   ;; toSuper
;; do:
   br label %L1
L1:
   br label %L2
L2:
;; rtnInner  M
   ret %$for$$to$repeat$S$38$38 *%R0
}
   ;; Handle VB: "" E: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; vdtAdd: inx=2 descInx=38 vDescInx=41 vdtTop: 3
   ;; vdt:vdtTop: 3 21:I,41:V,38:I
@vdt_data$$for$$to$repeat$S$38$38 = global %vdt_type$$for$$to$repeat$S$38$38 {
      %$for$$to$repeat$21*(%$for$$to$repeat$21*)* @$for$$to$repeat$21,
      %vdt_ret$repeat$S$41$41*(%$for$$to$repeat$S$38$38*)* @vdt_alloc$repeat$S$41$41,
      %$for$$to$repeat$S$38$38*(%$for$$to$repeat$S$38$38*)* @$for$$to$repeat$S$38$38
}

define %vdt_ret$$for$$to$repeat$S$38$38* @vdt_alloc$$for$$to$repeat$S$38$38(%$S$35$35* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$for$$to$repeat$S$38$38
   %R9 = tail call i8* @malloc(i64 32)
   %R10 = bitcast i8* %R9 to %vdt_ret$$for$$to$repeat$S$38$38*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$for$$to$repeat$S$38$38 
   ;; alloc %$for$$to$repeat$S$38$38
   %R11 = tail call i8* @malloc(i64 192)
   %R12 = bitcast i8* %R11 to %$for$$to$repeat$S$38$38*
   ;; store VDT in object
   %R13 = getelementptr %$for$$to$repeat$S$38$38, %$for$$to$repeat$S$38$38* %R12, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$S$38$38* @vdt_data$$for$$to$repeat$S$38$38, %vdt_type$$for$$to$repeat$S$38$38** %R13
   %R14 = getelementptr %vdt_ret$$for$$to$repeat$S$38$38,%vdt_ret$$for$$to$repeat$S$38$38* %R10, i32 0, i32 0
   store %$for$$to$repeat$S$38$38* %R12, %$for$$to$repeat$S$38$38** %R14
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: $S$35 thisClassOrgDescNo: 35 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 1 V: 7 R: 1 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 2 V: 7 R: 12 
   ;; vTop(2,2)=[1/0,7/0] rTop(2,2)=[1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: @for::to:repeat$S$38 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$38$38 this: @for::to:repeat$S$38$38 originOff: 4 orgIsValObj: false 
;; rdouble -1
   ;; vTop(2,2)=[1/0,7/0] rTop(2,2)=[1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 3 rTopMax: 3 V: 7 R: 12 
   ;; vTop(2,2)=[1/0,7/0] rTop(3,3)=[1:%$S$35$35*,1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  4 @for::to:repeat$S$38$38 isValueObjectOrigin: F
   ;; vTop(2,2)=[1/0,7/0] rTop(3,3)=[1:%$S$35$35*,1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
   ;; lookup:  %$S$35$35*
   ;; vTop(2,2)=[1/0,7/0] rTop(3,3)=[1:%$S$35$35*,1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
   %R15 = getelementptr %$for$$to$repeat$S$38$38, %$for$$to$repeat$S$38$38 * %R12, i32 0, i32 4
   store %$S$35$35* %R1, %$S$35$35** %R15
;; rswap  0
   ;; vTop(2,2)=[1/0,7/0] rTop(3,3)=[1:%$S$35$35*,12:%$for$$to$repeat$S$38$38,1:%$S$35$35*]
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 12 
   ;; vTop(2,2)=[1/0,7/0] rTop(2,3)=[1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
   ;; go:super.ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loo ...}" t ... 4 t ... "@ ..." 
   ;; thisOG.IS: origin: "@for::to:repeat$S$38" thisOG.IS: origin: "@for::to:repeat$S$38" thisOG.IS: origin: "@for::to:repeat$S$38" thisOG.IS: origin: "@for::to:repeat$S$38" 
   ;; vTop(2,2)=[1/0,7/0] rTop(2,3)=[1:%$S$35$35*,12:%$for$$to$repeat$S$38$38]
;; rswap  0
   ;; goOriginAdr:  "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >loadOrigin::on:4 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 4 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R16 = getelementptr %$S$35$35,%$S$35$35 *%R1, i32 0, i32 1
   %R17 = load %_add$33* , %_add$33** %R16
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 7 R: 12 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 17 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 3 
   ;; goOrigin: "+" newOriginOff: 1 origin: "String$15" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R18 = getelementptr %_add$33,%_add$33 *%R17, i32 0, i32 1
   %R19 = load %String$15* , %String$15** %R18
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 7 R: 12 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 19 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "String" newOriginOff: 1 origin: "StringLib$14" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%String$15*" typeInfo[rtop,off]=elmType: "%StringLib$14*" 
   %R20 = getelementptr %String$15,%String$15 *%R19, i32 0, i32 1
   %R21 = load %StringLib$14* , %StringLib$14** %R20
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 7 R: 12 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 21 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "StringLib" newOriginOff: 1 origin: "LIB$8" 
   ;; NA: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%StringLib$14*" typeInfo[rtop,off]=elmType: "%LIB$8*" 
   %R22 = getelementptr %StringLib$14,%StringLib$14 *%R21, i32 0, i32 1
   %R23 = load %LIB$8* , %LIB$8** %R22
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 7 R: 12 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 23 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ...}" 
   ;; viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
   ;; items:goOrigin: 1 
   ;; goOrigin: "LIB" newOriginOff: 1 origin: "BETAworld$1" 
   ;; NA: "BETA" origin: "LIB$8" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg LIB$8 1
   ;; Rtype.rtop: "%LIB$8*" typeInfo[rtop,off]=elmType: "%BETAworld$1*" 
   %R24 = getelementptr %LIB$8,%LIB$8 *%R23, i32 0, i32 1
   %R25 = load %BETAworld$1* , %BETAworld$1** %R24
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 7 R: 12 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 25 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
;; rpushg BETA 2
   ;; Rtype.rtop: "%BETAworld$1*" typeInfo[rtop,off]=elmType: "%BETA$2*" 
   %R26 = getelementptr %BETAworld$1,%BETAworld$1 *%R25, i32 0, i32 2
   %R27 = load %BETA$2* , %BETA$2** %R26
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 7 R: 12 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 7 R: 27 
   ;; goOriginAdr:not:BracE: ObjectInvocation_KeyWord 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >getAdr::superAdj:0:on:4 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx"} 
   ;; vTop(2,2)=[1/0,7/0] rTop(2,3)=[12:%$for$$to$repeat$S$38$38,27:%BETA$2*]
   ;; before:E.loadArgs: @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V28 = add i32 0, 1
   ;; stack: vpush : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 28 R: 27 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; ActArg:  "L" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}"  isCompositeValueObj: false 
   ;; loadArgs:A: "L" 
   ;; $ObjectGenerator:"L" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"L" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "L" 
   ;; not const:  L L: var integer 
   ;; needorigin: "L" 
   ;; needOrigin:E: "L"  E.ATd: "L: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "L" 
   ;; computeAdr: 1 :rec: "none"  E: "L" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "L ..." 
;; pushThis 
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 3 V: 28 R: 0 
   ;; %$for$$to$repeat$S$38$38* 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "L" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$for$$to$repeat$S$38$38*" typeInfo[rtop,off]=elmType: "i32" 
   %R29 = getelementptr %$for$$to$repeat$S$38$38,%$for$$to$repeat$S$38$38 *%R0, i32 0, i32 1
   %R30 = load i32 , i32* %R29
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 28 R: 27 
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 3 V: 28 R: 30 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"L: var integer" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"L"}   L: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "L: var integer" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "L"  ATd: "L: var integer" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr:isLast:E:  "L" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; rec:  "L" E:  "L" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "L" superAdj= 0 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; L   L: var integer 
   ;; $var:"L: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "L: var integer"  E:  "L" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"L":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "L" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "L" 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >invoke: rec:"L" 
   ;; E.ATd:  "L" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; $var:"L: var integer" 
   ;; >invoke:E: "L" newOff:4 useRTNv: "True" 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; isFloat:B:  false 
;; pushg 4 +$33
   %R31 = getelementptr i32,i32 *%R30, i32 0, i32 4
   %V32 = load i32, i32* %R31
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 28 R: 27 
   ;; stack: vpush : vTop: 4 vTopMax: 4 rTop: 2 rTopMax: 3 V: 32 R: 27 
   ;; BOBS! 
   ;; OI:invoke: L :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "L" 
   ;; loadArgs:after:Qgen: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "L" :isBasicVal: true 
   ;; L ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@for 1 :to L :repeat {   e := @get inx;   T.@put e :at inx}" 
   ;; vTop(4,4)=[1/0,7/0,28/0,32/0] rTop(2,3)=[12:%$for$$to$repeat$S$38$38,27:%BETA$2*] 
   ;; @for::to:repeat   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$38$38 this: @for::to:repeat$21 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$for$$to$repeat$S$38$38* %R10
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 43 :top: 1 
   ;; Items:GenClass: repeat$S$43 descNo: 43 
;; class  repeat$S$43 43 1 @for::to:repeat$S$39 39

define %repeat$S$43$43* @repeat$S$43$43(%repeat$S$43$43* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=43 vDescInx=43 vdtTop: 1
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "e := S.@get inx" 
   ;; $ObjectGenerator:"e := S.@get inx" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"e := S.@get inx" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "e := S.@get inx" 
   ;; not const:  e e: var integer 
   ;; needorigin: "e := S.@get inx" 
   ;; needOrigin:E: ":= S.@get inx"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= S.@get inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "e := S.@get inx" 
   ;; computeAdr: 1 :rec: "none"  E: "e" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "e: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "e" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R1 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R2 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R1
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 2 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "e" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R3 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R2, i32 0, i32 4
   %R4 = load %$S$35$35* , %$S$35$35** %R3
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 4 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"e: var integer" 
   ;; >getAdr:,newOff:2,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"e"}   e: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "e: var integer" ObjectGenerator 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; After:U*U: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "e"  ATd: "e: var integer" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr: 2 :rec: "e"  E: ":= S.@get inx"  A.E: "e" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr:isAssign:rec:  "e"  E: ":= S.@get inx" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr:isLast:E:  ":= S.@get inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; rec:  "e" E:  ":= S.@get inx" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= S.@get inx" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= S.@get inx" 
   ;; >loadArgs:staticOff:2 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  S.@get inx  hasArg:  pattern 
   ;; := S.@get inx   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= S.@get inx":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= S.@get inx" 
   ;; ActArg:  "S.@get inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= S.@get inx" 
   ;; loadArgs:A: "S.@get inx" 
   ;; $ObjectGenerator:"S.@get inx" 
   ;; Qgen:OGid:"@get:" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "@get" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"S.@get inx" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "S.@get inx" 
   ;; not const:  S in S: ref String 
   ;; needorigin: "S.@get inx" 
   ;; needOrigin:E: "@get inx"  E.ATd: "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; doNeedOrigin:Ex: "@get inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "S.@get inx" 
   ;; computeAdr: 1 :rec: "none"  E: "S" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "in S: ref String" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadOrigin::on:3 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 3 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "S" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R5 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R6 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R5
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 6 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "S" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R7 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R6, i32 0, i32 4
   %R8 = load %$S$35$35* , %$S$35$35** %R7
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 8 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "S" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R9 = getelementptr %$S$35$35,%$S$35$35 *%R8, i32 0, i32 1
   %R10 = load %_add$33* , %_add$33** %R9
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 10 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >getAdr::superAdj:0:on:3 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ref:"in S: ref String" 
   ;; >getAdr:,newOff:2,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"S"}   in S: ref String 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 3 
   ;; beforeIsValueObj:E: "S"  ATd: "in S: ref String" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "S"  E: "@get inx" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: @get inx 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >getAdr: 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   ref 
   ;; S   in S: ref String 
   ;; $ref:"in S: ref String" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in S: ref String"  E:  "S" 
   ;;  
   ;; $pattern:"String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @get: ..."} 
   ;; >loadArgs:E:"S":descNo:15:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >invoke: rec:"S" 
   ;; E.ATd:  "@get" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; OI:invoke:B: "S" E: "@get inx"  rec: "S"  useRtnV: true "in S: ref String" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; $ref:"in S: ref String" 
   ;; >invoke:E: "@get inx" newOff:2 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; load: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
;; rpushg repeat$S$43$43 2
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R11 = getelementptr %_add$33,%_add$33 *%R10, i32 0, i32 2
   %R12 = load %String$15* , %String$15** %R11
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 4 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 12 
   ;; OI:invoke: S :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "@get inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; rec:  "S" E:  "@get inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@get inx" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @get inx  hasArg:  pattern 
   ;; @get inx   @get: {   %basic 117;   in get: var integer;   out ch: var char} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >loadArgs:E:"@get inx":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@get inx" 
   ;; ActArg:  "inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@get inx" 
   ;; loadArgs:not:*:  formalArgOf: "@get inx"  isCompositeValueObj: false 
   ;; loadArgs:A: "inx" 
   ;; $ObjectGenerator:"inx" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx" 
   ;; needOrigin:E: "inx"  E.ATd: "inx: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "inx" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R13 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R14 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R13
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 12 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 3 rTopMax: 3 V: R: 14 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  "inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  "inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inx" superAdj= 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "inx" 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "inx" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "inx" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isFloat:B:  false 
;; pushg 3 @for::to:repeat$S$39$39
   %R15 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R14, i32 0, i32 3
   %V16 = load i32, i32* %R15
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 3 V: R: 12 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 16 R: 12 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inx" 
   ;; loadArgs:after:Qgen: "@get inx" 
   ;; formalArg:isPtn: "in get: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "inx" :isBasicVal: true 
   ;; inx ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@get inx" 
   ;; IV:after:loadArgsOf: "@get inx" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "@get inx" 
   ;; $ObjectInvocation_KeyWord:"@get inx" 
   ;; >invoke: rec:"S" 
   ;; OI:invoke:isPtn: "@get inx" descNo 0  useRTNv: true 
   ;; E.ATd:  "@get" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; OI:invoke:B: "@get inx" E: "@get inx"  rec: "S"  useRtnV: true "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@get inx"} 
   ;; $pattern:"@get: {   %basic 117;   in get: var integer;   out ch: var char"} 
   ;; >invoke:E: "@get inx" useRTNv: "True" 
   ;; ptn:invoke: "@get" E: "@get inx" useRtnV: true 
;; xpushg  inx 1 0 1
   ;; vTop(1,1)=[16/0] rTop(2,3)=[4:%$S$35$35*,12:%String$15*]
;; xpusg:String
   %R17 = bitcast %String$15* %R12 to {i32*,i32,[0 x i32]}*
%V18 = add i32 -1, %V16
%R19 = getelementptr inbounds {i32*,i32,[0 x i32]}, {i32*,i32,[0 x i32]}* %R17, i32 0, i32 2
%R20 = getelementptr inbounds [0 x i32], [0 x i32]* %R19, i32 0, i32 %V18
%V21 = load i32 , i32* %R20, align 4
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 16 R: 4 
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 4 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 21 R: 4 
   ;; OI:invoke: @get inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "@get inx" 
   ;; loadArgs:after:Qgen: ":= S.@get inx" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; BINGO 
   ;; aaaa:  in V: var Value{--inner(Value);} 
   ;; end:loadArgs:NonVirt: ":= S.@get inx" 
   ;; IV:after:loadArgsOf: ":= S.@get inx" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= S.@get inx" 
   ;; $ObjectInvocation_Binary:":= S.@get inx" 
   ;; >invoke: rec:"e" 
   ;; OI:invoke:isPtn: ":= S.@get inx" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:invoke:B: ":= S.@get inx" E: ":= S.@get inx"  rec: "e"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= S.@get inx"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= S.@get inx" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= S.@get inx" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "e" from:  ":= S.@get inx" 
   ;; assign:dstDI : "e: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "S.@get inx" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: S.@get inx 
   ;;  arg.super.ATd: "Invocation" "@get: {   %basic 117;   in get: var integer;   out ch: var char}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= S.@get inx"  rec:  "e" "repeat$S$43$43" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= S.@get inx"} 
   ;; store: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  $S$35$35 2
   %R22 = getelementptr %$S$35$35,%$S$35$35 *%R4, i32 0, i32 2
   store i32 %V21, i32* %R22
   ;; stack: vpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 4 
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; OI:invoke: := S.@get inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= S.@get inx" 
   ;; genclass:stmt: "i := L + inx" 
   ;; $ObjectGenerator:"i := L + inx" 
   ;; Qgen:OGid:":=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: ":=" superDescNo: 4 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"i := L + inx" 
   ;; Qgen: useRtnV:"False" descNo: 4 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "i := L + inx" 
   ;; not const:  i i: var integer 
   ;; needorigin: "i := L + inx" 
   ;; needOrigin:E: ":= L + inx"  E.ATd: ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; doNeedOrigin:Ex: ":= L + inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "i := L + inx" 
   ;; computeAdr: 1 :rec: "none"  E: "i" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "i: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "i" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R23 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R24 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R23
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 24 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "i" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R25 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R24, i32 0, i32 4
   %R26 = load %$S$35$35* , %$S$35$35** %R25
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"i: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"i"}   i: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "i: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "i"  ATd: "i: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; computeAdr: 2 :rec: "i"  E: ":= L + inx"  A.E: "i" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; computeAdr:isAssign:rec:  "i"  E: ":= L + inx" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; computeAdr:isLast:E:  ":= L + inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; rec:  "i" E:  ":= L + inx" isValueAssign:  true 
   ;; IV:before:loadArgs:E: ":= L + inx" superAdj= 0 
   ;; $ObjectInvocation_Binary:":= L + inx" 
   ;; >loadArgs:staticOff:3 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  L + inx  hasArg:  pattern 
   ;; := L + inx   :=  : {   %basic 8;   in V: var Value;   --inner(Value);   } 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >loadArgs:E:":= L + inx":descNo:4:top:1 
   ;; isValueAssign:  true 
   ;; loadArgs:NonVirt: ":= L + inx" 
   ;; ActArg:  "L + inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: true 
   ;; loadArgs:isPrim:assign,fmult:  8 ":= L + inx" 
   ;; loadArgs:A: "L + inx" 
   ;; $ObjectGenerator:"L + inx" 
   ;; Qgen:OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "+" superDescNo: 0 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"L + inx" 
   ;; Qgen: useRtnV:"True" descNo: 0 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "L + inx" 
   ;; not const:  L L: var integer 
   ;; needorigin: "L + inx" 
   ;; needOrigin:E: "+ inx"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; doNeedOrigin:Ex: "+ inx" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "L + inx" 
   ;; computeAdr: 1 :rec: "none"  E: "L" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "L: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadOrigin::on:3 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 3 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "L" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R27 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R28 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R27
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 28 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "L" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R29 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R28, i32 0, i32 4
   %R30 = load %$S$35$35* , %$S$35$35** %R29
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 30 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "L" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R31 = getelementptr %$S$35$35,%$S$35$35 *%R30, i32 0, i32 1
   %R32 = load %_add$33* , %_add$33** %R31
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; stack: rpush : vTop: 0 vTopMax: 1 rTop: 2 rTopMax: 3 V: R: 32 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >getAdr::superAdj:0:on:3 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"L: var integer" 
   ;; >getAdr:,newOff:4,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"L"}   L: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "L: var integer" ObjectGenerator 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; After:U*U: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E.on: 3 
   ;; beforeIsValueObj:E: "L"  ATd: "L: var integer" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; computeAdr: 2 :rec: "L"  E: "+ inx"  A.E: "L" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; E:notAssign: + inx 
   ;; $ObjectInvocation_Binary:"+ inx" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >getAdr: 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; L   L: var integer 
   ;; $var:"L: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "L: var integer"  E:  "L" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"L":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"L" 
   ;; >invoke: rec:"L" 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"L"} 
   ;; OI:invoke:B: "L" E: "+ inx"  rec: "L"  useRtnV: true "L: var integer" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ inx"} 
   ;; $var:"L: var integer" 
   ;; >invoke:E: "+ inx" newOff:4 useRTNv: "True" 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ inx"} 
   ;; isFloat:B:  false 
;; pushg 4 repeat$S$43$43
   %R33 = getelementptr %_add$33,%_add$33 *%R32, i32 0, i32 4
   %V34 = load i32, i32* %R33
   ;; stack: rpop : vTop: 0 vTopMax: 1 rTop: 1 rTopMax: 3 V: R: 26 
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 34 R: 26 
   ;; BOBS! 
   ;; OI:invoke: L :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "+ inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ inx"} 
   ;; rec:  "L" E:  "+ inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "+ inx" superAdj= 0 
   ;; $ObjectInvocation_Binary:"+ inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  inx  hasArg:  pattern 
   ;; + inx   +  : {   %basic 61;   in V: var integer;   out R: var integer} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >loadArgs:E:"+ inx":descNo:0:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "+ inx" 
   ;; ActArg:  "inx" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "+ inx" 
   ;; loadArgs:not:*:  formalArgOf: "+ inx"  isCompositeValueObj: false 
   ;; loadArgs:A: "inx" 
   ;; $ObjectGenerator:"inx" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"inx" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "inx" 
   ;; not const:  inx inx: var integer 
   ;; needorigin: "inx" 
   ;; needOrigin:E: "inx"  E.ATd: "inx: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "inx" 
   ;; computeAdr: 1 :rec: "none"  E: "inx" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "inx: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 34 R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "inx" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R35 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R36 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R35
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 34 R: 26 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 3 V: 34 R: 36 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"inx: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"inx"}   inx: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "inx: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; computeAdr:isLast:E:  "inx" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; rec:  "inx" E:  "inx" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "inx" superAdj= 0 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; inx   inx: var integer 
   ;; $var:"inx: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "inx: var integer"  E:  "inx" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"inx":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "inx" 
   ;; $ObjectInvocation_Unary:"inx" 
   ;; >invoke: rec:"inx" 
   ;; E.ATd:  "inx" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; $var:"inx: var integer" 
   ;; >invoke:E: "inx" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"inx"} 
   ;; isFloat:B:  false 
;; pushg 3 @for::to:repeat$S$39$39
   %R37 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R36, i32 0, i32 3
   %V38 = load i32, i32* %R37
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 3 V: 34 R: 26 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 38 R: 26 
   ;; BOBS! 
   ;; OI:invoke: inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "inx" 
   ;; loadArgs:after:Qgen: "+ inx" 
   ;; formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "inx" :isBasicVal: true 
   ;; inx ObjectGenerator 
   ;; end:loadArgs:NonVirt: "+ inx" 
   ;; IV:after:loadArgsOf: "+ inx" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ inx"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "+ inx" 
   ;; $ObjectInvocation_Binary:"+ inx" 
   ;; >invoke: rec:"L" 
   ;; OI:invoke:isPtn: "+ inx" descNo 0  useRTNv: true 
   ;; E.ATd:  "+" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ inx"} 
   ;; OI:invoke:B: "+ inx" E: "+ inx"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"+ inx"} 
   ;; $pattern:"+  : {   %basic 61;   in V: var integer;   out R: var integer"} 
   ;; >invoke:E: "+ inx" useRTNv: "True" 
   ;; ptn:invoke: "+" E: "+ inx" useRtnV: true 
   ;; doPrimElse: + 61 
   %V39 = add i32 %V34, %V38
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 26 
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 1 rTopMax: 3 V: 39 R: 26 
   ;; OI:invoke: + inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "+ inx" 
   ;; loadArgs:after:Qgen: ":= L + inx" 
   ;; vAssign:fArg: "in V: var Value{--inner(Value);}" 
   ;; BINGO 
   ;; aaaa:  in V: var Value{--inner(Value);} 
   ;; end:loadArgs:NonVirt: ":= L + inx" 
   ;; IV:after:loadArgsOf: ":= L + inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: ":= L + inx" 
   ;; $ObjectInvocation_Binary:":= L + inx" 
   ;; >invoke: rec:"i" 
   ;; OI:invoke:isPtn: ":= L + inx" descNo 4  useRTNv: false 
   ;; E.ATd:  ":=" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; OI:invoke:B: ":= L + inx" E: ":= L + inx"  rec: "i"  useRtnV: false ":=  : {   %basic 8;   in V: var Value;   --inner(Value);   }" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= L + inx"} 
   ;; $pattern:":=  : {   %basic 8;   in V: var Value;   --inner(Value);   "} 
   ;; >invoke:E: ":= L + inx" useRTNv: "False" 
   ;; ptn:invoke: ":=" E: ":= L + inx" useRtnV: false 
   ;; AssignPtn:invoke:rec:  "i" from:  ":= L + inx" 
   ;; assign:dstDI : "i: var integer" isUnitValueObj:  false 
   ;; assign:arg:  "L + inx" lab: "ObjectGenerator" UnitValObj : false  ptn:  false 
   ;;  float:  false  DataItem: false  arg.super: L + inx 
   ;;  arg.super.ATd: "Invocation" "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
   ;;  arg.super.ATd.isDataItem: false  arg.super.ATd.isFloat: false 
   ;;  arg.super.ATd.label:  "pattern" 
   ;; assign:simple value:  
   ;; assign:before:adr.store:E:  ":= L + inx"  rec:  "i" "repeat$S$43$43" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:":= L + inx"} 
   ;; store: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; isValue: true  isAdr: false  descNo:  0 
   ;; isFloat:D:  false 
;; storeg  $S$35$35 3
   %R40 = getelementptr %$S$35$35,%$S$35$35 *%R26, i32 0, i32 3
   store i32 %V39, i32* %R40
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 26 
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
   ;; OI:invoke: := L + inx :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: ":= L + inx" 
   ;; genclass:stmt: "T.@put e :at i" 
   ;; $ObjectGenerator:"T.@put e :at i" 
   ;; Qgen:OGid:"@put::at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "@put" superDescNo: 42 super.OG.top: 0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"T.@put e :at i" 
   ;; Qgen: useRtnV:"False" descNo: 42 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "T.@put e :at i" 
   ;; needorigin: "T.@put e :at i" 
   ;; needOrigin:E: "@put e :at i"  E.ATd: "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; doNeedOrigin:Ex: "@put e :at i" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "T.@put e :at i" 
   ;; computeAdr: 1 :rec: "none"  E: "T" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "T: obj Indexed(L + S.length,Integer)" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "T" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R41 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R42 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R41
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 42 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "T" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R43 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R42, i32 0, i32 4
   %R44 = load %$S$35$35* , %$S$35$35** %R43
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 44 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >getAdr:,newOff:4,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"T"}   T: obj Indexed(L + S.length,Integer) 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
   ;; computeAdr:isFirst: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "T"  E: "@put e :at i" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: @put e :at i 
   ;; $ObjectInvocation_KeyWord:"@put e :at i" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@put: {   %basic 115;   in put: ref elm;   in at: var integer"} 
   ;; >getAdr: 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; OI:getAdr:KOKS: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   obj 
   ;; T   T: obj Indexed(L + S.length,Integer) 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "T: obj Indexed(L + S.length,Integer)"  E:  "T" 
   ;;  
   ;; $pattern:"Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := @get 0;   @put: ;  ..."} 
   ;; >loadArgs:E:"T":descNo:36:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"T" 
   ;; >invoke: rec:"T" 
   ;; E.ATd:  "@put" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; OI:invoke:B: "T" E: "@put e :at i"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; $obj:"T: obj Indexed(L + S.length,Integer)" 
   ;; >invoke:E: "@put e :at i" newOff:4 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; load: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%array$1*" 
   %R45 = getelementptr %$S$35$35,%$S$35$35 *%R44, i32 0, i32 4
   %R46 = load %array$1* , %array$1** %R45
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 46 
   ;; OI:invoke: T :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "@put e :at i" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; rec:  "T" E:  "@put e :at i" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "@put e :at i" superAdj= 0 
   ;; $ObjectInvocation_KeyWord:"@put e :at i" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @put e :at i  hasArg:   hasArg:  pattern 
   ;; @put e :at i   @put: {   %basic 115;   in put: ref elm;   in at: var integer} 
   ;; $pattern:"@put: {   %basic 115;   in put: ref elm;   in at: var integer"} 
   ;; >loadArgs:E:"@put e :at i":descNo:42:top:0 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@put e :at i" 
   ;; ActArg:  "e" isValue:  false 
   ;; formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@put e :at i" 
   ;; loadArgs:not:*:  formalArgOf: "@put e :at i"  isCompositeValueObj: false 
   ;; loadArgs:A: "e" 
   ;; $ObjectGenerator:"e" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"e" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "e" 
   ;; not const:  e e: var integer 
   ;; needorigin: "e" 
   ;; needOrigin:E: "e"  E.ATd: "e: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "e" 
   ;; computeAdr: 1 :rec: "none"  E: "e" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "e: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "e" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R47 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R48 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R47
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 46 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 48 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "e" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R49 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R48, i32 0, i32 4
   %R50 = load %$S$35$35* , %$S$35$35** %R49
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 46 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 50 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"e: var integer" 
   ;; >getAdr:,newOff:2,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"e"}   e: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "e: var integer" ObjectGenerator 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; After:U*U: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "e"  ATd: "e: var integer" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; computeAdr:isLast:E:  "e" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; rec:  "e" E:  "e" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "e" superAdj= 0 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; e   e: var integer 
   ;; $var:"e: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "e: var integer"  E:  "e" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"e":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "e" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "e" 
   ;; $ObjectInvocation_Unary:"e" 
   ;; >invoke: rec:"e" 
   ;; E.ATd:  "e" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; OI:invoke:B: "e" E: "e"  rec: "e"  useRtnV: true "e: var integer" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; $var:"e: var integer" 
   ;; >invoke:E: "e" newOff:2 useRTNv: "True" 
   ;; load: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"e"} 
   ;; isFloat:B:  false 
;; pushg 2 $S$35$35
   %R51 = getelementptr %$S$35$35,%$S$35$35 *%R50, i32 0, i32 2
   %V52 = load i32, i32* %R51
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 46 
   ;; stack: vpush : vTop: 1 vTopMax: 2 rTop: 1 rTopMax: 3 V: 52 R: 46 
   ;; BOBS! 
   ;; OI:invoke: e :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "e" 
   ;; loadArgs:after:Qgen: "@put e :at i" 
   ;; formalArg:isPtn: "in put: ref elm" :isBasicVal: false :valueObj: false 
   ;; :actArg: "e" :isBasicVal: true 
   ;; e ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@put e :at i" 
   ;; loadArgs:NonVirt: "@put e :at i" 
   ;; ActArg:  "i" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@put e :at i" 
   ;; loadArgs:not:*:  formalArgOf: "@put e :at i"  isCompositeValueObj: false 
   ;; loadArgs:A: "i" 
   ;; $ObjectGenerator:"i" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"i" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "i" 
   ;; not const:  i i: var integer 
   ;; needorigin: "i" 
   ;; needOrigin:E: "i"  E.ATd: "i: var integer" 
   ;; needOrigin:dataItem:leave 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "i" 
   ;; computeAdr: 1 :rec: "none"  E: "i" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >pushThis: 
   ;; OI:pushThis: "e := S.@get inx{i := L + inx;T.@put e :at i}" ATd: "i: var integer" 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 52 R: 0 
   ;; %repeat$S$43$43* 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >loadOrigin::on:2 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 2 
   ;; goOrigin: "repeat$S$43" newOriginOff: 1 origin: "@for::to:repeat$S$39$39" 
   ;; NA: "i" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 1
   ;; Rtype.rtop: "%repeat$S$43$43*" typeInfo[rtop,off]=elmType: "%$for$$to$repeat$S$39$39*" 
   %R53 = getelementptr %repeat$S$43$43,%repeat$S$43$43 *%R0, i32 0, i32 1
   %R54 = load %$for$$to$repeat$S$39$39* , %$for$$to$repeat$S$39$39** %R53
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 1 rTopMax: 3 V: 52 R: 46 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 52 R: 54 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "@for::to:repeat$S$39" newOriginOff: 4 origin: "$S$35$35" 
   ;; NA: "i" origin: "repeat$S$43$43" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg repeat$S$43$43 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R55 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R54, i32 0, i32 4
   %R56 = load %$S$35$35* , %$S$35$35** %R55
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 1 rTopMax: 3 V: 52 R: 46 
   ;; stack: rpush : vTop: 1 vTopMax: 2 rTop: 2 rTopMax: 3 V: 52 R: 56 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >getAdr::superAdj:0:on:2 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $var:"i: var integer" 
   ;; >getAdr:,newOff:3,isValue:"True",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"i"}   i: var integer 
   ;; value_prim: false 
   ;; BTX: 9  OG.OGid:  integer 
   ;; integer 
   ;; before:floatTest:  "i: var integer" ObjectGenerator 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; After:U*U: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; OI:getAdr:KOKS: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; E.on: 2 
   ;; beforeIsValueObj:E: "i"  ATd: "i: var integer" 
   ;; computeAdr:isFirst: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; computeAdr:isLast:E:  "i" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; rec:  "i" E:  "i" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "i" superAdj= 0 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   var 
   ;; i   i: var integer 
   ;; $var:"i: var integer" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "i: var integer"  E:  "i" 
   ;;  
   ;; $pattern:"integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out ..."} 
   ;; >loadArgs:E:"i":descNo:9:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "i" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "i" 
   ;; $ObjectInvocation_Unary:"i" 
   ;; >invoke: rec:"i" 
   ;; E.ATd:  "i" unique:  false 
   ;; adr: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; OI:invoke:B: "i" E: "i"  rec: "i"  useRtnV: true "i: var integer" 
   ;; :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; $var:"i: var integer" 
   ;; >invoke:E: "i" newOff:3 useRTNv: "True" 
   ;; load: :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:T orgIsVal:F:E:"i"} 
   ;; isFloat:B:  false 
;; pushg 3 $S$35$35
   %R57 = getelementptr %$S$35$35,%$S$35$35 *%R56, i32 0, i32 3
   %V58 = load i32, i32* %R57
   ;; stack: rpop : vTop: 1 vTopMax: 2 rTop: 1 rTopMax: 3 V: 52 R: 46 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 58 R: 46 
   ;; BOBS! 
   ;; OI:invoke: i :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "i" 
   ;; loadArgs:after:Qgen: "@put e :at i" 
   ;; formalArg:isPtn: "in at: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "i" :isBasicVal: true 
   ;; i ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@put e :at i" 
   ;; IV:after:loadArgsOf: "@put e :at i" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"}  useRtnV:  false 
   ;; IV:E.invoke:useRTNv: false E: "@put e :at i" 
   ;; $ObjectInvocation_KeyWord:"@put e :at i" 
   ;; >invoke: rec:"T" 
   ;; OI:invoke:isPtn: "@put e :at i" descNo 42  useRTNv: false 
   ;; E.ATd:  "@put" unique:  false 
   ;; adr: :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; OI:invoke:B: "@put e :at i" E: "@put e :at i"  rec: "T"  useRtnV: false "@put: {   %basic 115;   in put: ref elm;   in at: var integer}" 
   ;; :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@put e :at i"} 
   ;; $pattern:"@put: {   %basic 115;   in put: ref elm;   in at: var integer"} 
   ;; >invoke:E: "@put e :at i" useRTNv: "False" 
   ;; ptn:invoke: "@put" E: "@put e :at i" useRtnV: false 
   ;; invoke:indexedPut:  @put: {   %basic 115;   in put: ref elm;   in at: var integer} 
   ;; Integer 
   ;; primitive:  1 
;; xstoreg  inx 1 0 1
   ;; vTop(2,2)=[52/0,58/0] rTop(1,3)=[46:%array$1*]
%V59 = add i32 -1, %V58
%R60 = getelementptr inbounds %array$1,  %array$1* %R46, i32 0, i32 2
%R61 = getelementptr inbounds [0 x i32], [0 x i32]* %R60, i32 0, i32 %V59
store i32 %V52, i32* %R61, align 4
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 3 V: 58 R: 
   ;; stack: vpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
   ;; OI:invoke: @put e :at i :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "@put e :at i" 
   br label %L2
L2:
   ;; pushReturn:  
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 0 
   ;; %repeat$S$43$43* 
   ;; vTop(0,2)=[] rTop(1,3)=[0:%repeat$S$43$43*]
   ret %repeat$S$43$43* %R0   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 0 rTopMax: 3 V: R: 
}
   ;; vdt:vdtTop: 1 43:I
@vdt_data$repeat$S$43$43 = global %vdt_type$repeat$S$43$43 {
      %repeat$S$43$43*(%repeat$S$43$43*)* @repeat$S$43$43
}

define %vdt_ret$repeat$S$43$43* @vdt_alloc$repeat$S$43$43(%$for$$to$repeat$S$39$39* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$repeat$S$43$43
   %R63 = tail call i8* @malloc(i64 32)
   %R64 = bitcast i8* %R63 to %vdt_ret$repeat$S$43$43*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %repeat$S$43$43 
   ;; alloc %repeat$S$43$43
   %R65 = tail call i8* @malloc(i64 192)
   %R66 = bitcast i8* %R65 to %repeat$S$43$43*
   ;; store VDT in object
   %R67 = getelementptr %repeat$S$43$43, %repeat$S$43$43* %R66, i32 0, i32 0
   store %vdt_type$repeat$S$43$43* @vdt_data$repeat$S$43$43, %vdt_type$repeat$S$43$43** %R67
   %R68 = getelementptr %vdt_ret$repeat$S$43$43,%vdt_ret$repeat$S$43$43* %R64, i32 0, i32 0
   store %repeat$S$43$43* %R66, %repeat$S$43$43** %R68
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: @for::to:repeat$S$39 thisClassOrgDescNo: 39 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 66 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: repeat$S$43 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$43$43 this: repeat$S$43$43 originOff: 1 orgIsValObj: false 
;; rdouble -1
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   ;; stack: rpush : vTop: 0 vTopMax: 2 rTop: 3 rTopMax: 3 V: R: 66 
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$39$39*,1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 repeat$S$43$43 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$39$39*,1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   ;; lookup:  %$for$$to$repeat$S$39$39*
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$39$39*,1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   %R69 = getelementptr %repeat$S$43$43, %repeat$S$43$43 * %R66, i32 0, i32 1
   store %$for$$to$repeat$S$39$39* %R1, %$for$$to$repeat$S$39$39** %R69
;; rswap  0
   ;; vTop(0,2)=[] rTop(3,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43,1:%$for$$to$repeat$S$39$39*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 2 rTopMax: 3 V: R: 66 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   ;; go:super.ATd: "in repeat:< Object" thisOG.super.on: 0 thisOG.OGid: "repeat$S$43" 
   ;; 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
;; rswap  0
   ;; goOriginAdr:  "" 
   ;; goOriginAdr:isImplSuper: 
   ;; vTop(0,2)=[] rTop(2,3)=[66:%repeat$S$43$43,1:%$for$$to$repeat$S$39$39*]
   ;; vTop(0,2)=[] rTop(2,3)=[66:%repeat$S$43$43,1:%$for$$to$repeat$S$39$39*] 
   ;; Object   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$43$43 this: Object$22 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; go:super.ATd: "Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;     ...}" t ... 1 t ... "O ..." 
   ;; thisOG.IS: origin: "Object" 
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
;; rswap  0
   ;; goOriginAdr:  "Object" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadOrigin::on:1 
   ;; goOriginAdr:not:BracE: ObjectInvocation_Unary 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"Object"} 
   ;; vTop(0,2)=[] rTop(2,3)=[66:%repeat$S$43$43,1:%$for$$to$repeat$S$39$39*]
   ;; before:E.loadArgs: Object 
   ;; $ObjectInvocation_Unary:"Object" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; Object   Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %bas ...} 
   ;; $pattern:"Object: {   %ID Object;   %basic 64;   %public;   :=  : ;      %basic 8;      in V: var Value;   :-  : ;      %basic 6;      in R: ref Object;   ==  : ;      %ba ..."} 
   ;; >loadArgs:E:"Object":descNo:22:top:1 
   ;; isValueAssign:  false 
   ;; vTop(0,2)=[] rTop(2,3)=[66:%repeat$S$43$43,1:%$for$$to$repeat$S$39$39*] 
   ;; Object   1 
;; rswap  0
   ;; OriginIsValue: false 
   ;; storeOrigins:main: repeat$S$43$43 this: Object$22 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 repeat$S$43$43 isValueObjectOrigin: F
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   ;; lookup:  %$for$$to$repeat$S$39$39*
   ;; vTop(0,2)=[] rTop(2,3)=[1:%$for$$to$repeat$S$39$39*,66:%repeat$S$43$43]
   %R70 = getelementptr %repeat$S$43$43, %repeat$S$43$43 * %R66, i32 0, i32 1
   store %$for$$to$repeat$S$39$39* %R1, %$for$$to$repeat$S$39$39** %R70
;; rswap  0
   ;; vTop(0,2)=[] rTop(2,3)=[66:%repeat$S$43$43,1:%$for$$to$repeat$S$39$39*]
   ;; stack: rpop : vTop: 0 vTopMax: 2 rTop: 1 rTopMax: 3 V: R: 66 
   ;; vTop(0,2)=[] rTop(1,3)=[66:%repeat$S$43$43]
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$repeat$S$43$43* %R64
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 39 :top: 1 
   ;; Items:GenClass: @for::to:repeat$S$39 descNo: 39 
;; class  @for::to:repeat$S$39 39 4 $S$35 35

define %$for$$to$repeat$S$39$39* @$for$$to$repeat$S$39$39(%$for$$to$repeat$S$39$39* %R0){
   %V0 = add i32 0, 0
;; rstore  4 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtTableCopy: I:1:21 V:2:44 I:3:0
   ;; vdtAdd: inx=3 descInx=39 vDescInx=39 vdtTop: 3
   ;; push:super.origin: 
   ;; handleSuperArgs:E: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" theIS: "" 
   ;; super.sig:none:superAdj: 4 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 4 
   ;; args:  @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< O ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  4   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  4 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  4 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 4 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 4 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V1 = add i32 0, 1
   ;; stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 0 V: 1 R: 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ActArg:  "S.length" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  4   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  isCompositeValueObj: false 
   ;; loadArgs:A: "S.length" 
   ;; $ObjectGenerator:"S.length" 
   ;; Qgen:OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
   ;; OG:gen:super: "length" superDescNo: 34 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  4 
   ;; $Invocation:"S.length" 
   ;; Qgen: useRtnV:"True" descNo: 34 
   ;; Invocation:qgen:superAdj:  4 
   ;; isConstant: "Invocation" "S.length" 
   ;; not const:  S in S: ref String 
   ;; needorigin: "S.length" 
   ;; needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; doNeedOrigin:Ex: "length" 
   ;; IV:needOrigin;superAdj: 4 
   ;; computeAdr:A.superAdj: 4 "S.length" 
   ;; computeAdr: 1 :rec: "none"  E: "S" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "i ..." 
;; pushThis 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 0 
   ;; %$for$$to$repeat$S$39$39* 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 4 
;; rpushg $S$35$35 4
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "%$S$35$35*" 
   %R2 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R0, i32 0, i32 4
   %R3 = load %$S$35$35* , %$S$35$35** %R2
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 3 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "S" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R4 = getelementptr %$S$35$35,%$S$35$35 *%R3, i32 0, i32 1
   %R5 = load %_add$33* , %_add$33** %R4
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 5 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >getAdr::superAdj:4:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ref:"in S: ref String" 
   ;; >getAdr:,newOff:2,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUniq:F{ isValue:F orgIsVal:F:E:"S"}   in S: ref String 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "S"  ATd: "in S: ref String" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "S"  E: "length" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: length 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >getAdr: 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 4 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 4 
   ;; args:   ref 
   ;; S   in S: ref String 
   ;; $ref:"in S: ref String" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in S: ref String"  E:  "S" 
   ;;  
   ;; $pattern:"String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @get: ..."} 
   ;; >loadArgs:E:"S":descNo:15:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >invoke: rec:"S" 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: ref String" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $ref:"in S: ref String" 
   ;; >invoke:E: "length" newOff:2 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; loadAdr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
;; rpushg $S$35$35 2
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R6 = getelementptr %_add$33,%_add$33 *%R5, i32 0, i32 2
   %R7 = load %String$15* , %String$15** %R6
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 1 V: 1 R: 7 
   ;; OI:invoke: S :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "length" 
   ;; IV:after:computeAdr:superAdj: 4 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; rec:  "S" E:  "length" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "length" superAdj= 4 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 4 
   ;; args:   pattern 
   ;; length   length: {   out V: var integer;   V := @get 0} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >loadArgs:E:"length":descNo:34:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "length" 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >invoke: rec:"S" 
   ;; OI:invoke:isPtn: "length" descNo 34  useRTNv: true 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := @get 0}" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >invoke:E: "length" useRTNv: "True" 
   ;; ptn:invoke: "length" E: "length" useRtnV: true 
   ;; Pattern:invoke:useRTNv: true descNo: 34  top: 1  rec: "S" 
   ;; ComputeVariantX
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; <>var 
   ;; ptn:invoke: useRtnV: true isValObj: false :rtnValObj: true : "length: {   out V: var integer;   V := @get 0}" 
   ;; rec=E: false :rec: "S" 
   ;; before:invoke:useReturnValue:  true 
   ;; OGid: length  OGidWdNo:  length$34 
;; invoke length 34 0 1
   ;; vTop(1,1)=[1/0] rTop(1,1)=[7:%String$15*]
   ;; alloc %length$34
   %R8 = tail call i8* @malloc(i64 12)
   %R9 = bitcast i8* %R8 to %length$34*
   ;; store VDT in object
   %R10 = getelementptr %length$34, %length$34* %R9, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R10
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 2 rTopMax: 2 V: 1 R: 9 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: length$34 this: length$34 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 length$34 isValueObjectOrigin: F
   ;; vTop(1,1)=[1/0] rTop(2,2)=[7:%String$15*,9:%length$34]
   ;; lookup:  %String$15*
   ;; vTop(1,1)=[1/0] rTop(2,2)=[7:%String$15*,9:%length$34]
   %R11 = getelementptr %length$34, %length$34 * %R9, i32 0, i32 1
   store %String$15* %R7, %String$15** %R11
;; rswap  0
   ;; vTop(1,1)=[1/0] rTop(2,2)=[9:%length$34,7:%String$15*]
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 1 R: 9 
   ;; vTop(1,1)=[1/0] rTop(1,2)=[9:%length$34]
   ;; topSuper: 34   length$34 
   %R12 = call %length$34* @length$34(%length$34 * %R9)
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 2 V: 1 R: 
   ;; stack: rpush : vTop: 1 vTopMax: 1 rTop: 1 rTopMax: 2 V: 1 R: 9 
   %V15 = icmp eq %length$34* %R12, %R9
   br i1 %V15, label %normalRtnLab13, label %breakLab14
breakLab14:
   %R16 = bitcast %length$34* %R12 to %$for$$to$repeat$S$39$39*
   %V17 = icmp eq %$for$$to$repeat$S$39$39* %R0, %R16
   br i1 %V17, label %selectBreakLab19, label %contBreakLab18
contBreakLab18:
   ret %$for$$to$repeat$S$39$39* %R16
selectBreakLab19:
   %R20 = bitcast %length$34* %R12 to [0 x i32]*
   %R21 = getelementptr [0 x i32], [0 x i32]* %R20, i32 0, i32 0
   %V22 = load i32 , i32* %R21
   %R23 = getelementptr %length$34,%length$34* %R12, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R23
   %V24 = icmp eq i32 1, %V22
   br i1 %V24, label %X25, label %X26
X25:
   br label %L1 ; restart
X26:
   br label %L2 ; leave
normalRtnLab13:

   ;; vTop(1,1)=[1/0] rTop(1,2)=[9:%length$34*]
;; pushg 2 
   %R27 = getelementptr %length$34,%length$34 *%R9, i32 0, i32 2
   %V28 = load i32, i32* %R27
   ;; stack: rpop : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 2 V: 1 R: 
   ;; stack: vpush : vTop: 2 vTopMax: 2 rTop: 0 rTopMax: 2 V: 28 R: 
   ;; useRtnVal: true :isVal: false :rtnValObj: true :rec=E: false "S" 
   ;; OI:invoke: length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "length" 
   ;; loadArgs:after:Qgen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "S.length" :isBasicVal: true 
   ;; S.length ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; args:  "in repeat:< Object" "e := S.@get inx{i := L + inx;T.@put e :at i}" @for::to:repeat 
   ;; hArgOrg:super: @for::to:repeat 
   ;; vdtAdd: inx=1 descInx=39 vDescInx=21 vdtTop: 3
   ;; $Property:"%globals inSub" 
   ;; Qgen: 
   ;; $var:"in for: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  for 
   ;; $var:"in to: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  to 
   ;; $pattern:"in repeat:< Object" 
   ;; Qgen: 
   ;; $Property:"%public" 
   ;; Qgen: 
   ;; $var:"inx: var integer" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: true :primNo: 1 
   ;; OGqual: "integer" :OGqual.isBasicValue: true :OGqual.isValueObj: true 
   ;; DI:add:BP1:  inx 
   ;; $Property:"%private" 
   ;; Qgen: 
   ;; toSuper
;; do:
   br label %L1
L1:
   br label %L2
L2:
;; rtnInner  M
   ret %$for$$to$repeat$S$39$39 *%R0
}
   ;; Handle VB: "" E: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; vdtAdd: inx=2 descInx=39 vDescInx=43 vdtTop: 3
   ;; vdt:vdtTop: 3 21:I,43:V,39:I
@vdt_data$$for$$to$repeat$S$39$39 = global %vdt_type$$for$$to$repeat$S$39$39 {
      %$for$$to$repeat$21*(%$for$$to$repeat$21*)* @$for$$to$repeat$21,
      %vdt_ret$repeat$S$43$43*(%$for$$to$repeat$S$39$39*)* @vdt_alloc$repeat$S$43$43,
      %$for$$to$repeat$S$39$39*(%$for$$to$repeat$S$39$39*)* @$for$$to$repeat$S$39$39
}

define %vdt_ret$$for$$to$repeat$S$39$39* @vdt_alloc$$for$$to$repeat$S$39$39(%$S$35$35* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$$for$$to$repeat$S$39$39
   %R30 = tail call i8* @malloc(i64 32)
   %R31 = bitcast i8* %R30 to %vdt_ret$$for$$to$repeat$S$39$39*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %$for$$to$repeat$S$39$39 
   ;; alloc %$for$$to$repeat$S$39$39
   %R32 = tail call i8* @malloc(i64 192)
   %R33 = bitcast i8* %R32 to %$for$$to$repeat$S$39$39*
   ;; store VDT in object
   %R34 = getelementptr %$for$$to$repeat$S$39$39, %$for$$to$repeat$S$39$39* %R33, i32 0, i32 0
   store %vdt_type$$for$$to$repeat$S$39$39* @vdt_data$$for$$to$repeat$S$39$39, %vdt_type$$for$$to$repeat$S$39$39** %R34
   %R35 = getelementptr %vdt_ret$$for$$to$repeat$S$39$39,%vdt_ret$$for$$to$repeat$S$39$39* %R31, i32 0, i32 0
   store %$for$$to$repeat$S$39$39* %R33, %$for$$to$repeat$S$39$39** %R35
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: $S$35 thisClassOrgDescNo: 35 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 2 V: 28 R: 1 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 2 V: 28 R: 33 
   ;; vTop(2,2)=[1/0,28/0] rTop(2,2)=[1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: @for::to:repeat$S$39 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$39$39 this: @for::to:repeat$S$39$39 originOff: 4 orgIsValObj: false 
;; rdouble -1
   ;; vTop(2,2)=[1/0,28/0] rTop(2,2)=[1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 3 rTopMax: 3 V: 28 R: 33 
   ;; vTop(2,2)=[1/0,28/0] rTop(3,3)=[1:%$S$35$35*,1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  4 @for::to:repeat$S$39$39 isValueObjectOrigin: F
   ;; vTop(2,2)=[1/0,28/0] rTop(3,3)=[1:%$S$35$35*,1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
   ;; lookup:  %$S$35$35*
   ;; vTop(2,2)=[1/0,28/0] rTop(3,3)=[1:%$S$35$35*,1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
   %R36 = getelementptr %$for$$to$repeat$S$39$39, %$for$$to$repeat$S$39$39 * %R33, i32 0, i32 4
   store %$S$35$35* %R1, %$S$35$35** %R36
;; rswap  0
   ;; vTop(2,2)=[1/0,28/0] rTop(3,3)=[1:%$S$35$35*,33:%$for$$to$repeat$S$39$39,1:%$S$35$35*]
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 33 
   ;; vTop(2,2)=[1/0,28/0] rTop(2,3)=[1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
   ;; go:super.ATd: "@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loo ...}" t ... 4 t ... "@ ..." 
   ;; thisOG.IS: origin: "@for::to:repeat$S$39" thisOG.IS: origin: "@for::to:repeat$S$39" thisOG.IS: origin: "@for::to:repeat$S$39" thisOG.IS: origin: "@for::to:repeat$S$39" 
   ;; vTop(2,2)=[1/0,28/0] rTop(2,3)=[1:%$S$35$35*,33:%$for$$to$repeat$S$39$39]
;; rswap  0
   ;; goOriginAdr:  "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; goOriginAdr:not:isImplSuper: 
   ;; goOriginAdr:isFirst:  @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >loadOrigin::on:4 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 4 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$S$35$35*" typeInfo[rtop,off]=elmType: "%_add$33*" 
   %R37 = getelementptr %$S$35$35,%$S$35$35 *%R1, i32 0, i32 1
   %R38 = load %_add$33* , %_add$33** %R37
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 28 R: 33 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 38 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 3 
   ;; goOrigin: "+" newOriginOff: 1 origin: "String$15" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%_add$33*" typeInfo[rtop,off]=elmType: "%String$15*" 
   %R39 = getelementptr %_add$33,%_add$33 *%R38, i32 0, i32 1
   %R40 = load %String$15* , %String$15** %R39
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 28 R: 33 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 40 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 2 
   ;; goOrigin: "String" newOriginOff: 1 origin: "StringLib$14" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%String$15*" typeInfo[rtop,off]=elmType: "%StringLib$14*" 
   %R41 = getelementptr %String$15,%String$15 *%R40, i32 0, i32 1
   %R42 = load %StringLib$14* , %StringLib$14** %R41
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 28 R: 33 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 42 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; items:goOrigin: 1 
   ;; goOrigin: "StringLib" newOriginOff: 1 origin: "LIB$8" 
   ;; NA: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%StringLib$14*" typeInfo[rtop,off]=elmType: "%LIB$8*" 
   %R43 = getelementptr %StringLib$14,%StringLib$14 *%R42, i32 0, i32 1
   %R44 = load %LIB$8* , %LIB$8** %R43
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 28 R: 33 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 44 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystem;--COsystem;--Compiler;--C ...}" 
   ;; viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
   ;; items:goOrigin: 1 
   ;; goOrigin: "LIB" newOriginOff: 1 origin: "BETAworld$1" 
   ;; NA: "BETA" origin: "LIB$8" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg LIB$8 1
   ;; Rtype.rtop: "%LIB$8*" typeInfo[rtop,off]=elmType: "%BETAworld$1*" 
   %R45 = getelementptr %LIB$8,%LIB$8 *%R44, i32 0, i32 1
   %R46 = load %BETAworld$1* , %BETAworld$1** %R45
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 28 R: 33 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 46 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
;; rpushg BETA 2
   ;; Rtype.rtop: "%BETAworld$1*" typeInfo[rtop,off]=elmType: "%BETA$2*" 
   %R47 = getelementptr %BETAworld$1,%BETAworld$1 *%R46, i32 0, i32 2
   %R48 = load %BETA$2* , %BETA$2** %R47
   ;; stack: rpop : vTop: 2 vTopMax: 2 rTop: 1 rTopMax: 3 V: 28 R: 33 
   ;; stack: rpush : vTop: 2 vTopMax: 2 rTop: 2 rTopMax: 3 V: 28 R: 48 
   ;; goOriginAdr:not:BracE: ObjectInvocation_KeyWord 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >getAdr::superAdj:0:on:4 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >getAdr: 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to S.length :repeat ;   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; OI:getAdr:KOKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"@for 1 :to S.length :repeat ;   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; vTop(2,2)=[1/0,28/0] rTop(2,3)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*]
   ;; before:E.loadArgs: @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i} 
   ;; $ObjectInvocation_KeyWord:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i"} 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:  @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}  hasArg:   hasArg:   hasArg:  pattern 
   ;; @for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}   @for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< O ...} 
   ;; $pattern:"@for: {   %globals inSub;   in for: var integer;   in to: var integer;   in repeat:< Object;   %public;   inx: var integer;   %private;   inx := for;   _loop: do ..."} 
   ;; >loadArgs:E:"@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i":descNo:21:top:1} 
   ;; isValueAssign:  false 
   ;; loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ActArg:  "1" isValue:  true 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  isCompositeValueObj: false 
   ;; loadArgs:A: "1" 
   ;; $ObjectGenerator:"1" 
   ;; Qgen:OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"1" 
   ;; Qgen: useRtnV:"True" 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "1" 
   ;; needorigin: "1" 
   ;; needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
   ;; Ex!LoadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
   ;; IV:no:needOrigin:E:  "1" 
   ;; IV:after:computeAdr:superAdj: 0 
   ;; rec:  "1" E:  "1" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "1" superAdj= 0 
   ;; $ConstLiteral:"1" 
   ;; >loadArgs: 
   ;; IV:after:loadArgsOf: "1"  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "1" 
   ;; $ConstLiteral:"1" 
   ;; >invoke: 
;; pushc 1
   %V49 = add i32 0, 1
   ;; stack: vpush : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 49 R: 48 
   ;; invoke:after:E.invoke: "1" 
   ;; loadArgs:after:Qgen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; formalArg:isPtn: "in for: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "1" :isBasicVal: true 
   ;; 1 ObjectGenerator 
   ;; convDone: false 
   ;; end:loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; ActArg:  "S.length" isValue:  false 
   ;; formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
   ;;  formalArg.OG.isNonBasicValueObj: false 
   ;; loadArgs:not::assign:superAdj:  0   "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; loadArgs:not:*:  formalArgOf: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}"  isCompositeValueObj: false 
   ;; loadArgs:A: "S.length" 
   ;; $ObjectGenerator:"S.length" 
   ;; Qgen:OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
   ;; OG:gen:super: "length" superDescNo: 34 super.OG.top: 1 
   ;; OG:Qgen:IS.isEmpty!isCompositeValueObj: false superAdj:  0 
   ;; $Invocation:"S.length" 
   ;; Qgen: useRtnV:"True" descNo: 34 
   ;; Invocation:qgen:superAdj:  0 
   ;; isConstant: "Invocation" "S.length" 
   ;; not const:  S in S: ref String 
   ;; needorigin: "S.length" 
   ;; needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := @get 0}" 
   ;; doNeedOrigin:Ex: "length" 
   ;; IV:needOrigin;superAdj: 0 
   ;; computeAdr:A.superAdj: 0 "S.length" 
   ;; computeAdr: 1 :rec: "none"  E: "S" 
   ;; :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >pushThis: 
   ;; OI:pushThis: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);@for 1 :to L :repeat ;   e := @get inx;   T.@put e :at inx;@for 1 :to S.length :repeat ;   ...}" A ... "i ..." 
;; pushThis 
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 3 V: 49 R: 0 
   ;; %$for$$to$repeat$S$39$39* 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadOrigin::on:1 
   ;; AdjustOrigin:originOff: 0 
   ;; items:goOrigin: 1 
   ;; goOrigin: "$S$35" newOriginOff: 1 origin: "+$33" 
   ;; NA: "S" origin: "$S$35$35" 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rpushg $S$35$35 1
   ;; Rtype.rtop: "%$for$$to$repeat$S$39$39*" typeInfo[rtop,off]=elmType: "i32" 
   %R50 = getelementptr %$for$$to$repeat$S$39$39,%$for$$to$repeat$S$39$39 *%R0, i32 0, i32 1
   %R51 = load i32 , i32* %R50
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 49 R: 48 
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 3 V: 49 R: 51 
   ;; goOrigin:Q 
   ;; goOrigin:W 
   ;; goOrigin:T 
   ;; goOrigin:E 
   ;; goOrigin:R 
   ;; goOrigin:T 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >getAdr::superAdj:0:on:1 
   ;; OI:getAdr:KIKS: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $ref:"in S: ref String" 
   ;; >getAdr:,newOff:2,isValue:"False",A.isValue:"False" 
   ;;  A: :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"S"}   in S: ref String 
   ;; value_prim: false 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E.on: 1 
   ;; beforeIsValueObj:E: "S"  ATd: "in S: ref String" 
   ;; computeAdr:isFirst: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; computeAdr: 2 :rec: "S"  E: "length" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; E:notAssign: length 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >getAdr::superAdj:0:on:0 
   ;; OI:getAdr:KIKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"none"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >getAdr: 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:getAdr:KOKS: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; ptn.isUnitValueObj: false  isFloat:E: false 
   ;; computeAdr:loadArgs:superAdj:D: 0 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   ref 
   ;; S   in S: ref String 
   ;; $ref:"in S: ref String" 
   ;; >loadArgs: 
   ;; DataItem:loadArgs:  "in S: ref String"  E:  "S" 
   ;;  
   ;; $pattern:"String: {   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %immutable;   %public;   length: ;      out V: var integer;      V := @get 0;   @get: ..."} 
   ;; >loadArgs:E:"S":descNo:15:top:1 
   ;; isValueAssign:  false 
   ;; $ObjectInvocation_Unary:"S" 
   ;; >invoke: rec:"S" 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: ref String" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $ref:"in S: ref String" 
   ;; >invoke:E: "length" newOff:2 useRTNv: "True" 
   ;; >Object:unique: false 
   ;; loadAdr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
;; rpushg $S$35$35 2
   ;; {!!!! lookup: no match!  i32 off:2 } 
   ;; Rtype.rtop: "i32" typeInfo[rtop,off]=elmType: "no-match" 
   %R52 = getelementptr i32,i32 *%R51, i32 0, i32 2
   %R53 = load no-match , no-match* %R52
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 3 V: 49 R: 48 
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 3 V: 49 R: 53 
   ;; OI:invoke: S :unit:  -none-  convFactor:  0.000000
   ;; computeAdr:isLast:E:  "length" 
   ;; IV:after:computeAdr:superAdj: 0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; rec:  "S" E:  "length" isValueAssign:  false 
   ;; IV:before:loadArgs:E: "length" superAdj= 0 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >loadArgs:staticOff:0 
   ;; OI:loadArgs:superAdj:F: 0 
   ;; args:   pattern 
   ;; length   length: {   out V: var integer;   V := @get 0} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >loadArgs:E:"length":descNo:34:top:1 
   ;; isValueAssign:  false 
   ;; IV:after:loadArgsOf: "length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"}  useRtnV:  true 
   ;; IV:E.invoke:useRTNv: true E: "length" 
   ;; $ObjectInvocation_Unary:"length" 
   ;; >invoke: rec:"S" 
   ;; OI:invoke:isPtn: "length" descNo 34  useRTNv: true 
   ;; E.ATd:  "length" unique:  false 
   ;; adr: :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := @get 0}" 
   ;; :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUniq:F{ isValue:F orgIsVal:F:E:"length"} 
   ;; $pattern:"length: {   out V: var integer;   V := @get 0"} 
   ;; >invoke:E: "length" useRTNv: "True" 
   ;; ptn:invoke: "length" E: "length" useRtnV: true 
   ;; Pattern:invoke:useRTNv: true descNo: 34  top: 1  rec: "S" 
   ;; ComputeVariantX
   ;; topVarExists:top: 2 
   ;; var alreday exists 
   ;; checkIfTopIsNew:A:topVarExists: true  isEmpty:  false 
   ;; Variant already exists 
   ;; <>var 
   ;; ptn:invoke: useRtnV: true isValObj: false :rtnValObj: true : "length: {   out V: var integer;   V := @get 0}" 
   ;; rec=E: false :rec: "S" 
   ;; before:invoke:useReturnValue:  true 
   ;; OGid: length  OGidWdNo:  length$34 
;; invoke length 34 0 1
   ;; vTop(3,3)=[1/0,28/0,49/0] rTop(3,3)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*,53:no-match]
   ;; alloc %length$34
   %R54 = tail call i8* @malloc(i64 12)
   %R55 = bitcast i8* %R54 to %length$34*
   ;; store VDT in object
   %R56 = getelementptr %length$34, %length$34* %R55, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R56
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 4 rTopMax: 4 V: 49 R: 55 
   ;; store:args 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: length$34 this: length$34 originOff: 1 orgIsValObj: false 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
;; rstoreX  1 length$34 isValueObjectOrigin: F
   ;; vTop(3,3)=[1/0,28/0,49/0] rTop(4,4)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*,53:no-match,55:%length$34]
   ;; lookup:  %String$15*
   ;; vTop(3,3)=[1/0,28/0,49/0] rTop(4,4)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*,53:no-match,55:%length$34]
   %R57 = getelementptr %length$34, %length$34 * %R55, i32 0, i32 1
   %R58 = bitcast %String$15** %R57 to %no-match**
   store %no-match* %R53, %no-match** %R58
;; rswap  0
   ;; vTop(3,3)=[1/0,28/0,49/0] rTop(4,4)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*,55:%length$34,53:no-match]
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 4 V: 49 R: 55 
   ;; vTop(3,3)=[1/0,28/0,49/0] rTop(3,4)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*,55:%length$34]
   ;; topSuper: 34   length$34 
   %R59 = call %length$34* @length$34(%length$34 * %R55)
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 4 V: 49 R: 48 
   ;; stack: rpush : vTop: 3 vTopMax: 3 rTop: 3 rTopMax: 4 V: 49 R: 55 
   %V62 = icmp eq %length$34* %R59, %R55
   br i1 %V62, label %normalRtnLab60, label %breakLab61
breakLab61:
   %R63 = bitcast %length$34* %R59 to %$for$$to$repeat$S$39$39*
   %V64 = icmp eq %$for$$to$repeat$S$39$39* %R0, %R63
   br i1 %V64, label %selectBreakLab66, label %contBreakLab65
contBreakLab65:
   ret %$for$$to$repeat$S$39$39* %R63
selectBreakLab66:
   %R67 = bitcast %length$34* %R59 to [0 x i32]*
   %R68 = getelementptr [0 x i32], [0 x i32]* %R67, i32 0, i32 0
   %V69 = load i32 , i32* %R68
   %R70 = getelementptr %length$34,%length$34* %R59, i32 0, i32 0
   store %vdt_type$length$34* @vdt_data$length$34, %vdt_type$length$34** %R70
   %V71 = icmp eq i32 1, %V69
   br i1 %V71, label %X72, label %X73
X72:
   br label %L1 ; restart
X73:
   br label %L2 ; leave
normalRtnLab60:

   ;; vTop(3,3)=[1/0,28/0,49/0] rTop(3,4)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*,55:%length$34*]
;; pushg 2 
   %R74 = getelementptr %length$34,%length$34 *%R55, i32 0, i32 2
   %V75 = load i32, i32* %R74
   ;; stack: rpop : vTop: 3 vTopMax: 3 rTop: 2 rTopMax: 4 V: 49 R: 48 
   ;; stack: vpush : vTop: 4 vTopMax: 4 rTop: 2 rTopMax: 4 V: 75 R: 48 
   ;; useRtnVal: true :isVal: false :rtnValObj: true :rec=E: false "S" 
   ;; OI:invoke: length :unit:  -none-  convFactor:  0.000000
   ;; invoke:after:E.invoke: "length" 
   ;; loadArgs:after:Qgen: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; formalArg:isPtn: "in to: var integer" :isBasicVal: true :valueObj: true 
   ;; :actArg: "S.length" :isBasicVal: true 
   ;; S.length ObjectGenerator 
   ;; end:loadArgs:NonVirt: "@for 1 :to S.length :repeat {   e := S.@get inx;   i := L + inx;   T.@put e :at i}" 
   ;; vTop(4,4)=[1/0,28/0,49/0,75/0] rTop(2,4)=[33:%$for$$to$repeat$S$39$39,48:%BETA$2*] 
   ;; @for::to:repeat   0 
;; rswap  0
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; storeOrigins:main: @for::to:repeat$S$39$39 this: @for::to:repeat$21 originOff: 0 orgIsValObj: false 
   ;; no:origin:newOriginOff=0 
   ;; handleOrigins:END:  
   ;; after:handleOrigins 
   ret %vdt_ret$$for$$to$repeat$S$39$39* %R31
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  false 
   ;; objTmpStack:next:genClass: 40 :top: 1 
   ;; Items:GenClass: := descNo: 40 
;; class  := 40 1 Object 22

define %_assign$40* @_assign$40(%_assign$40* %R0){
   %V0 = add i32 0, 0
;; rstore  1 origin
   ;; rstore:ignored 
   ;; OriginIsValue: false 
   ;; OriginIsValue: false 
   ;; vdtAdd: inx=1 descInx=40 vDescInx=40 vdtTop: 1
   ;; $Property:"%basic 8" 
   ;; Qgen: 
   ;; $var:"in V: var Value" 
   ;; Qgen: 
   ;; DI:isConst: false :isBasicValue: false :primNo: 21 
   ;; OGqual: "Value" :OGqual.isBasicValue: false :OGqual.isValueObj: true 
   ;; DI:add:BP4:  V 
   ;; inArg: in V: var Value 
;; do:
   br label %L1
L1:
   ;; genclass:stmt: "%basic 8" 
   ;; $Property:"%basic 8" 
   ;; Qgen: 
   br label %L2
L2:
   ;; pushReturn:  ":=" 
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %_assign$40* 
   ;; vTop(0,0)=[] rTop(1,1)=[0:%_assign$40*]
   ret %_assign$40* %R0   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
}
   ;; vdt:vdtTop: 1 40:I
@vdt_data$_assign$40 = global %vdt_type$_assign$40 {
      %_assign$40*(%_assign$40*)* @_assign$40
}

define %vdt_ret$_assign$40* @vdt_alloc$_assign$40(%Object$22* %R1){
   ;; mkVDTalloc:A: 
   ;; alloc %vdt_ret$_assign$40
   %R2 = tail call i8* @malloc(i64 32)
   %R3 = bitcast i8* %R2 to %vdt_ret$_assign$40*
   ;; mkVDTalloc:B: 
   ;; vdt_alloc:alloc  %_assign$40 
   ;; alloc %_assign$40
   %R4 = tail call i8* @malloc(i64 192)
   %R5 = bitcast i8* %R4 to %_assign$40*
   ;; store VDT in object
   %R6 = getelementptr %_assign$40, %_assign$40* %R5, i32 0, i32 0
   store %vdt_type$_assign$40* @vdt_data$_assign$40, %vdt_type$_assign$40** %R6
   %R7 = getelementptr %vdt_ret$_assign$40,%vdt_ret$_assign$40* %R3, i32 0, i32 0
   store %_assign$40* %R5, %_assign$40** %R7
   ;; mkVDTalloc:C: 
   ;; thisClassOrgId: Object thisClassOrgDescNo: 22 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 1 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 5 
   ;; vTop(0,0)=[] rTop(2,2)=[1:%Object$22*,5:%_assign$40]
   ;; before:handleOrigins 
   ;; handleOrigins:NEW: := 
   ;; after:handleOrigins 
   ret %vdt_ret$_assign$40* %R3
}
   ;; ObjStubStackX:gen 
   ;; objTmpStack:next:   : done: false  :var.genDone:  true 
;; class  main 46 0 Object 0

define void @main(i8* %args){
   %V0 = add i32 0, 0
   br label %L1
L1:
;; pushThis 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 1 V: R: 0 
   ;; %main$46* 
;; invoke BETAworld 1 0 1
   ;; vTop(0,0)=[] rTop(1,1)=[0:%main$46*]
   ;; alloc %BETAworld$1
   %R1 = tail call i8* @malloc(i64 24)
   %R2 = bitcast i8* %R1 to %BETAworld$1*
   ;; store VDT in object
   %R3 = getelementptr %BETAworld$1, %BETAworld$1* %R2, i32 0, i32 0
   store %vdt_type$BETAworld$1* @vdt_data$BETAworld$1, %vdt_type$BETAworld$1** %R3
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   %R4 = call %BETAworld$1* @BETAworld$1(%BETAworld$1 * %R2)
   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
   ;; stack: rpush : vTop: 0 vTopMax: 0 rTop: 2 rTopMax: 2 V: R: 2 
   ;; stop
   br label %L2
L2:
   ret void

   ;; stack: rpop : vTop: 0 vTopMax: 0 rTop: 1 rTopMax: 2 V: R: 0 
}
   ;; vdtAdd: inx=2 descInx=25 vDescInx=32 vdtTop: 3
   ;; vdtAdd: inx=2 descInx=38 vDescInx=41 vdtTop: 3
   ;; vdtAdd: inx=2 descInx=39 vDescInx=43 vdtTop: 3
