-- Items:GenClass: BETAworld descNo: 1 isValue: false 
-- Items:GenClass: BETAworld descNo: 22 isValue: false 

CLASS BETAworld dNo:22 topDno:22 orgOff:1 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %ID Object \
-- %basic 64 \
-- %public \
-- =  : 
4:	 allocEventQ 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true inner(Object)
-- OG:before:super.gen: "inner(Object)" 
-- scanInv: "inner(Object) " 0 0 1 
-- doInvoke: inner(Object)0 1 useRtnVal: false 
-- scanInv: "inner(Object) " 0 1 1 
-- doInvoke:X: inner(Object)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(Object) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(Object)
-- koks:Y: "inner(Object) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(Object) " 
11:	 pushThis 
12:	 innerP  2
14:	 rpopThisObj  L2:
15:	 setThisStack  
16:	 pushThis 
17:	 rtn D
19:	 END OSDV:0 objSize:1 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=22 vDescInx=0 vdtTop: 2 
-- 1 33 false 
-- VDTentry: vdtAdd: inx=1 descInx=22 vDescInx=33 vdtTop: 2 

CLASS BETAworld dNo:1 topDno:1 orgOff:1 orgId:Object orgDno:22
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %id "BETAworld" \
-- %modules BETA, LIB, LIB.StringLib, LIB.BasicIo \
-- error:  \
--    %basic 999
4:	 allocEventQ 
-- 1 1 true 
-- VDTentry: vdtAdd: inx=1 descInx=1 vDescInx=1 vdtTop: 1 
6:	 pushThis 
7:	 saveBETAworld 0
10:	 mvStack 
-- OG:gen: false 
-- %ID BETA \
--    %OSDvisibility disguised \
--    %module LIB, LIB.StringLib \
--    %public
-- before:isDerived 
11:	 pushThis 
12:	 invoke BETA 2 2 1
18:	 rpop 
-- OG:gen: false 
-- %id "LIB" \
--    %module BETA \
--    %Include BETA \
--    x_dummy_LIB: var integer
-- before:isDerived 
19:	 pushThis 
20:	 invoke LIB 34 3 1
26:	 rpop 
-- OG:gen: false 
-- %id "workspace" \
--    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib \
--    %domain_boundary \
--    --AbstractEx
-- before:isDerived 
27:	 pushThis 
28:	 invoke workspace 66 4 1
34:	 rpop 
35:	 rtnAlloc 1
DO:
37:	 doEventQ 
38:	 mvStack 
L1:
L2:
39:	 setThisStack  
40:	 pushThis 
41:	 rtn D
43:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: BETA descNo: 2 isValue: false 
-- Items:GenClass: BETA descNo: 22 isValue: false 

CLASS BETA dNo:2 topDno:2 orgOff:1 orgId:BETAworld orgDno:1
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %ID BETA \
-- %OSDvisibility disguised \
-- %module LIB, LIB.StringLib \
-- %public
4:	 allocEventQ 
-- 1 2 true 
-- VDTentry: vdtAdd: inx=1 descInx=2 vDescInx=2 vdtTop: 1 
6:	 mvStack 
-- DI:isConst: ascii 
-- OG:gen: false 
-- asciiFoo:  \
--       msg1:  \
--          _put('F') \
--          asciiBar.msg2
-- before:isDerived 
7:	 pushThis 
8:	 invoke ascii 3 2 1
14:	 rpop 
15:	 rtnAlloc 1
DO:
17:	 doEventQ 
18:	 mvStack 
L1:
L2:
19:	 setThisStack  
20:	 pushThis 
21:	 rtn D
23:	 END OSDV:2 objSize:3 isIndexed:0
-- Items:GenClass: ascii descNo: 3 isValue: false 
-- Items:GenClass: ascii descNo: 22 isValue: false 

CLASS ascii dNo:3 topDno:3 orgOff:1 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- asciiFoo:  \
--    msg1:  \
--       _put('F') \
--       asciiBar.msg2
4:	 allocEventQ 
-- 1 3 true 
-- VDTentry: vdtAdd: inx=1 descInx=3 vDescInx=3 vdtTop: 1 
6:	 mvStack 
-- DI:valueObj: nl 
-- OG:gen: true 10 -- <lf>
-- OG:before:super.gen: "10 -- <lf>" 
7:	 pushc 10
9:	 pushThis 
10:	 storeg nl 2
-- DI:valueObj: cr 
-- OG:gen: true 13
-- OG:before:super.gen: "13" 
12:	 pushc 13
14:	 pushThis 
15:	 storeg cr 3
-- DI:valueObj: null 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
17:	 pushc 0
19:	 pushThis 
20:	 storeg null 4
22:	 rtnAlloc 1
DO:
24:	 doEventQ 
25:	 mvStack 
L1:
26:	 pushThis 
-- scanInv: "newline " 0 0 1 
-- OG:gen: true 
-- nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf> \
--       --asciiFoo.msg1
-- gen:whatIsThis? 
-- OG:before:super.gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin def \
-- ault:<lf> \
--       --asciiFoo.msg1" 
27:	 pushc 10
29:	 storeg char%$7 5
L2:
31:	 setThisStack  
32:	 pushThis 
33:	 rtn D
35:	 END OSDV:0 objSize:5 isIndexed:0
-- Items:GenClass: Value descNo: 4 isValue: true 
-- Items:GenClass: Value descNo: 22 isValue: true 

CLASS Value dNo:4 topDno:4 orgOff:0 orgId:BETA orgDno:2 isValueObj
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %ID Value \
-- %globals \
-- %basic 21 \
-- %public
-- 1 4 true 
-- VDTentry: vdtAdd: inx=1 descInx=4 vDescInx=4 vdtTop: 1 
DO:
L1:
L2:
1:	 setThisStack  
2:	 pushThis 
3:	 rtn D
5:	 END OSDV:0 objSize:0 isIndexed:0
-- 2 11 false 
-- VDTentry: vdtAdd: inx=2 descInx=4 vDescInx=11 vdtTop: 2 
-- 3 43 false 
-- VDTentry: vdtAdd: inx=3 descInx=4 vDescInx=43 vdtTop: 3 
-- Items:GenClass: integer descNo: 5 isValue: true 
-- Items:GenClass: integer descNo: 4 isValue: true 
-- Items:GenClass: Value descNo: 22 isValue: true 

CLASS integer dNo:5 topDno:4 orgOff:0 orgId:BETA orgDno:2 isValueObj
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %ID integer \
-- %basic 1, 32 \
-- %globals \
-- %public
-- 1 5 true 
-- VDTentry: vdtAdd: inx=1 descInx=5 vDescInx=5 vdtTop: 1 
DO:
L1:
L2:
1:	 setThisStack  
2:	 pushThis 
3:	 rtn D
5:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: universal descNo: 6 isValue: true 
-- Items:GenClass: universal descNo: 4 isValue: true 
-- Items:GenClass: Value descNo: 22 isValue: true 

CLASS universal dNo:6 topDno:4 orgOff:0 orgId:BETA orgDno:2 isValueObj
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %ID universal \
-- %basic 1, 32 \
-- %globals \
-- +  : 
-- 1 6 true 
-- VDTentry: vdtAdd: inx=1 descInx=6 vDescInx=6 vdtTop: 1 
DO:
L1:
L2:
1:	 setThisStack  
2:	 pushThis 
3:	 rtn D
5:	 END OSDV:0 objSize:0 isIndexed:0
-- Items:GenClass: char descNo: 7 isValue: true 
-- Items:GenClass: char descNo: 4 isValue: true 
-- Items:GenClass: Value descNo: 22 isValue: true 

CLASS char dNo:7 topDno:4 orgOff:0 orgId:BETA orgDno:2 isValueObj
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %id "char" \
-- %globals \
-- %basic 3, 16 \
-- %public
-- 1 7 true 
-- VDTentry: vdtAdd: inx=1 descInx=7 vDescInx=7 vdtTop: 1 
DO:
L1:
L2:
1:	 setThisStack  
2:	 pushThis 
3:	 rtn D
5:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: ConsoleIF descNo: 8 isValue: false 
-- Items:GenClass: ConsoleIF descNo: 22 isValue: false 

CLASS ConsoleIF dNo:8 topDno:8 orgOff:1 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- put:<  \
--    ... \
-- puttext(T: var LIB.StringLib.String):<  \
--    inner(puttext)
4:	 allocEventQ 
-- 1 8 true 
-- VDTentry: vdtAdd: inx=1 descInx=8 vDescInx=8 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:0
-- 2 9 false 
-- VDTentry: vdtAdd: inx=2 descInx=8 vDescInx=9 vdtTop: 2 
-- 3 64 false 
-- VDTentry: vdtAdd: inx=3 descInx=8 vDescInx=64 vdtTop: 3 
-- 4 65 false 
-- VDTentry: vdtAdd: inx=4 descInx=8 vDescInx=65 vdtTop: 4 
-- Items:GenClass: put descNo: 9 isValue: false 
-- Items:GenClass: put descNo: 22 isValue: false 

CLASS put dNo:9 topDno:9 orgOff:1 orgId:ConsoleIF orgDno:8
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: ...
4:	 allocEventQ 
-- 1 9 true 
-- VDTentry: vdtAdd: inx=1 descInx=9 vDescInx=9 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: String descNo: 10 isValue: false 
-- Items:GenClass: String descNo: 4 isValue: false 
-- Items:GenClass: Value descNo: 22 isValue: true 

CLASS String dNo:10 topDno:4 orgOff:0 orgId:StringLib orgDno:40
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %id "String pattern" \
-- %OSDvisibility disguised \
-- %basic 5 \
--       --%immutable      
1:	 allocEventQ 
-- 1 10 true 
-- VDTentry: vdtAdd: inx=1 descInx=10 vDescInx=10 vdtTop: 1 
3:	 mvStack 
4:	 rtnAlloc 1
DO:
6:	 doEventQ 
7:	 mvStack 
L1:
L2:
8:	 setThisStack  
9:	 pushThis 
10:	 rtn D
12:	 END OSDV:2 objSize:0 isIndexed:1
-- 2 14 false 
-- VDTentry: vdtAdd: inx=2 descInx=10 vDescInx=14 vdtTop: 2 
-- 3 48 false 
-- VDTentry: vdtAdd: inx=3 descInx=10 vDescInx=48 vdtTop: 3 
-- Items:GenClass: = descNo: 14 isValue: false 
-- Items:GenClass: = descNo: 11 isValue: false 
-- Items:GenClass: = descNo: 22 isValue: false 

CLASS = dNo:11 topDno:11 orgOff:1 orgId:Value orgDno:4
-- handleArgumentsAndOrigin: 
1:	 jmpFalse  L3
4:	 pushThis 
5:	 vassign 4 2 0
10:	 jmp L4
L3:
13:	 invokeVal  Veq 32 3
19:	 rpop 
L4:
20:	 tstOriginIsNone 
21:	 rstore  1 origin
-- AllocateSuper: 
-- %basic 50 \
-- in Veq: var this(Value) \
-- out Beq: var boolean \
-- inner(= )
23:	 allocEventQ 
-- 1 11 true 
-- VDTentry: vdtAdd: inx=1 descInx=11 vDescInx=11 vdtTop: 1 
25:	 mvStack 
-- DI:isConst: Veq 
-- inArg: in Veq: var this(Value) 
26:	 rtnAlloc 1
DO:
28:	 doEventQ 
29:	 mvStack 
L1:
-- OG:gen: true inner(= )
-- OG:before:super.gen: "inner(= )" 
-- scanInv: "inner(= ) " 0 0 1 
-- doInvoke: inner(= )0 1 useRtnVal: false 
-- scanInv: "inner(= ) " 0 1 1 
-- doInvoke:X: inner(= )0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(= ) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(= )
-- koks:Y: "inner(= ) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(= ) " 
30:	 pushThis 
31:	 innerP  2
33:	 rpopThisObj  L2:
34:	 setThisStack  
35:	 pushThis 
36:	 rtn D
38:	 END OSDV:0 objSize:5 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=11 vDescInx=0 vdtTop: 2 

CLASS = dNo:14 topDno:11 orgOff:1 orgId:String orgDno:10
-- VDTtableCopy: 11 25 
-- vdtTableCopy: I:1:11 I:2:0 
-- 2 14 true 
-- VDTentry: vdtAdd: inx=2 descInx=14 vDescInx=14 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 rShiftUp  1
3:	 tstOriginIsNone 
4:	 rstore  1 origin
-- AllocateSuper: 
-- loop: do  \
--    c1: var char \
--    c2: var char \
--    L: var integer
6:	 allocEventQ 
-- op:super =
-- push:super.origin: 
8:	 pushThis 
9:	 rpushg iOrigin 1
-- handleSuperArgs:E: "" theIS: 
-- loop: do  \
--    c1: var char \
--    c2: var char \
--    L: var integer
-- super.sig:not:none:superAdj: -1 
11:	 rShiftDown 1
-- handleArgumentsAndOrigin: 
13:	 pushThis 
14:	 rstoreg Veq 2
16:	 tstOriginIsNone 
17:	 rstore  1 origin
-- AllocateSuper: 
-- %basic 50 \
-- in Veq: var this(Value) \
-- out Beq: var boolean \
-- inner(= )
19:	 allocEventQ 
-- 1 11 true 
-- VDTentry: vdtAdd: inx=1 descInx=14 vDescInx=11 vdtTop: 2 
21:	 mvStack 
-- DI:isConst: Veq 
-- inArg: in Veq: var this(Value) 
DO:
22:	 doEventQ 
23:	 mvStack 
L1:
-- OG:gen: false 
-- c1: var char \
--    c2: var char \
--    L: var integer \
--    L := length
-- before:isDerived 
24:	 pushThis 
25:	 invoke loop 15 0 0
31:	 rpop 
L2:
32:	 setThisStack  
33:	 pushThis 
34:	 rtn D
36:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: loop descNo: 15 isValue: false 
-- Items:GenClass: loop descNo: 22 isValue: false 

CLASS loop dNo:15 topDno:15 orgOff:1 orgId:= orgDno:14
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- c1: var char \
-- c2: var char \
-- L: var integer \
-- L := length
4:	 allocEventQ 
-- 1 15 true 
-- VDTentry: vdtAdd: inx=1 descInx=15 vDescInx=15 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
-- scanInv: "L " 0 0 1 
-- OG:gen: true length
-- OG:before:super.gen: "length" 
12:	 pushThis 
13:	 rpushg loop%$15 1
15:	 rpushg =%$14 1
-- scanInv: "length " 0 0 1 
-- doInvoke: length0 1 useRtnVal: true 
-- scanInv: "length " 0 1 1 
-- doInvoke:X: length0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1] -- actually an index error, accessing length
-- OI:newInvoke: "length " 
17:	 invoke length 16 0 0
23:	 pushg 2 
25:	 storeg integer%$5 4
-- OG:gen: true 
-- if (L <> Veq.length) :then  \
--    leave(loop)
-- OG:before:super.gen: "if (L <> Veq.length) :then  \
--    leave(loop)" 
-- doInvoke: 
-- if (L <> Veq.length) :then  \
--    leave(loop)0 1 useRtnVal: false 
-- scanInv: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  0 1 1 
-- doInvoke:X: 
-- if (L <> Veq.length) :then  \
--    leave(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (L <> Veq.length) :then  \
--    leave(loop)
-- koks:Y: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
-- OG:gen: true (L <> Veq.length)
-- OG:before:super.gen: "(L <> Veq.length)" 
27:	 pushThis 
-- scanInv: "(L <> Veq.length) " 0 1 2 
28:	 pushg 4 newInvoke
-- doInvoke: (L <> Veq.length)1 2 useRtnVal: true 
-- scanInv: "(L <> Veq.length) " 1 2 2 
-- doInvoke:X: <> Veq.length1 2 2 pRec: none rec: L ix->next none 
-- checkForProxy:E: "<> Veq.length " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: <> Veq.length
-- koks:Y: "<> Veq.length " 
-- ptn:loadArgs:E: <> Veq.length
-- args: Veq.length
-- E.arg: "ObjectDescriptor" Veq.length 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "<> Veq.length " "ObjectInvocation_Binary " ActArg: "
 --  Veq.length "isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: Veq.length 
-- OG:gen: true Veq.length
-- OG:before:super.gen: "Veq.length" 
30:	 pushThis 
31:	 rpushg loop%$15 1
-- scanInv: "Veq.length " 0 1 2 
33:	 rpushg newInvoke 2
-- doInvoke: Veq.length1 2 useRtnVal: true 
-- scanInv: "Veq.length " 1 2 2 
-- doInvoke:X: length1 2 2 pRec: none rec: Veq ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "Veq " rec.ATd: "
 --  in Veq: var this(Value) " 18 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1] -- actually an index error, accessing length
-- OI:newInvoke: "length " 
35:	 invoke length 16 0 0
41:	 pushg 2 
-- loadArgs:after:actualArg:gen: false false 
-- length:  \
--    out V: var integer \
--    V := get[-1] -- actually an index error, accessing length
-- ptn:loadArgs:end: 
-- <>  :  \
--    %basic 55 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "<> Veq.length " 
43:	 ne 
-- unitConv:after 
44:	 jmpFalse  L4
L3:
-- OG:gen: false leave(loop)
-- before:isDerived 
47:	 pushThis 
48:	 invoke loop>$19 19 0 0
54:	 rpop 
L4:
55:	 pushThis 
56:	 rpushg loop%$15 1
-- scanInv: "beq " 0 0 1 
-- OG:gen: true true
-- OG:before:super.gen: "true" 
-- doInvoke: true0 1 useRtnVal: true 
-- scanInv: "true " 0 1 1 
-- doInvoke:X: true0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "true " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: true
-- koks:Y: "true " 
-- ptn:loadArgs:E: true
-- args: 
-- ptn:loadArgs:end: 
-- True:  \
--    %globals \
--    out B: var boolean \
--    B := 1
-- OI:newInvoke: "true " 
58:	 invoke True 24 0 0
64:	 pushg 1 
66:	 storeg Boolean%$41 3
-- OG:gen: true 
-- for(1):to(length):repeat \
--    c1 := get[inx] \
--    c2 := Veq.get[inx] \
--    if (c1 <> c2) :then 
-- before:isDerived 
68:	 pushThis 
69:	 invoke loop>for:to:repeat$31 31 0 0
75:	 rpop 
L2:
76:	 setThisStack  
77:	 pushThis 
78:	 rtn D
80:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: length descNo: 16 isValue: false 
-- Items:GenClass: length descNo: 22 isValue: false 

CLASS length dNo:16 topDno:16 orgOff:1 orgId:String orgDno:10
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- out V: var integer \
-- V := get[-1] -- actually an index error, accessing length
4:	 allocEventQ 
-- 1 16 true 
-- VDTentry: vdtAdd: inx=1 descInx=16 vDescInx=16 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
-- scanInv: "V " 0 0 1 
-- OG:gen: true get[-1] -- actually an index error, accessing length
-- OG:before:super.gen: "get[-1] -- actually an index error, accessing lengt \
-- h" 
12:	 pushThis 
13:	 rpushg length%$16 1
-- scanInv: "get[-1] " 0 0 1 
-- doInvoke: get[-1]0 1 useRtnVal: true 
-- scanInv: "get[-1] " 0 1 1 
-- doInvoke:X: get[-1]0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "get[-1] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[-1]
-- koks:Y: "get[-1] " 
-- ptn:loadArgs:E: get[-1]
-- args: get[-1]
-- E.arg: "ObjectDescriptor" -1 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[-1] " "ObjectInvocation_KeyWord " ActArg: "-1 "
 --  isValue: true formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: -1 
-- OG:gen: true -1
-- OG:before:super.gen: "-1" 
-- doInvoke: -10 1 useRtnVal: true 
-- scanInv: "-1 " 0 1 1 
-- doInvoke:X: -10 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "-1 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: -1
-- koks:Y: "-1 " 
15:	 pushc 1
17:	 uminus 
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[-1] " 
18:	 xpushg  inx 1 0
21:	 storeg integer%$5 2
L2:
23:	 setThisStack  
24:	 pushThis 
25:	 rtn D
27:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: this descNo: 32 isValue: false 
-- Items:GenClass: this descNo: 22 isValue: false 

CLASS this dNo:32 topDno:32 orgOff:1 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 rstoreg this 2
4:	 tstOriginIsNone 
5:	 rstore  1 origin
-- AllocateSuper: 
-- %basic 18 \
-- in this: ref Object
7:	 allocEventQ 
-- 1 32 true 
-- VDTentry: vdtAdd: inx=1 descInx=32 vDescInx=32 vdtTop: 1 
9:	 mvStack 
10:	 rtnAlloc 1
DO:
12:	 doEventQ 
13:	 mvStack 
L1:
L2:
14:	 setThisStack  
15:	 pushThis 
16:	 rtn D
18:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: X_asString descNo: 33 isValue: false 
-- Items:GenClass: X_asString descNo: 22 isValue: false 

CLASS X_asString dNo:33 topDno:33 orgOff:1 orgId:Object orgDno:22
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- out S: var LIB.StringLib.String \
-- inner(X_asString)
4:	 allocEventQ 
-- 1 33 true 
-- VDTentry: vdtAdd: inx=1 descInx=33 vDescInx=33 vdtTop: 1 
6:	 mvStack 
-- DI:StringVar "out S: var LIB.StringLib.String "
7:	 pushText ""
9:	 pushThis 
10:	 rstoreg S 2
12:	 rtnAlloc 1
DO:
14:	 doEventQ 
15:	 mvStack 
L1:
-- OG:gen: true inner(X_asString)
-- OG:before:super.gen: "inner(X_asString)" 
-- scanInv: "inner(X_asString) " 0 0 1 
-- doInvoke: inner(X_asString)0 1 useRtnVal: false 
-- scanInv: "inner(X_asString) " 0 1 1 
-- doInvoke:X: inner(X_asString)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(X_asString) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(X_asString)
-- koks:Y: "inner(X_asString) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(X_asString) " 
16:	 pushThis 
17:	 innerP  2
19:	 rpopThisObj  L2:
20:	 setThisStack  
21:	 pushThis 
22:	 rtn D
24:	 END OSDV:0 objSize:2 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=33 vDescInx=0 vdtTop: 2 
-- Items:GenClass: LIB descNo: 34 isValue: false 
-- Items:GenClass: LIB descNo: 22 isValue: false 

CLASS LIB dNo:34 topDno:34 orgOff:1 orgId:BETAworld orgDno:1
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %id "LIB" \
-- %module BETA \
-- %Include BETA \
-- x_dummy_LIB: var integer
4:	 allocEventQ 
-- 1 34 true 
-- VDTentry: vdtAdd: inx=1 descInx=34 vDescInx=34 vdtTop: 1 
6:	 mvStack 
-- OG:gen: false 
-- %module LIB.StringLib \
--    %Public \
--    Lock:  \
--       dummy: var integer
-- before:isDerived 
7:	 pushThis 
8:	 invoke BasicIO 35 3 1
14:	 rpop 
-- OG:gen: false 
-- %domain_boundary \
--    %public \
--    Dimension:  \
--       %dimension "-top-"
-- before:isDerived 
15:	 pushThis 
16:	 invoke Dimensions 39 4 1
22:	 rpop 
-- OG:gen: false 
-- %id "String module" \
--    %module LIB \
--    %public \
--    String: Value
-- before:isDerived 
23:	 pushThis 
24:	 invoke StringLib 40 5 1
30:	 rpop 
31:	 rtnAlloc 1
DO:
33:	 doEventQ 
34:	 mvStack 
L1:
L2:
35:	 setThisStack  
36:	 pushThis 
37:	 rtn D
39:	 END OSDV:0 objSize:5 isIndexed:0
-- Items:GenClass: BasicIO descNo: 35 isValue: false 
-- Items:GenClass: BasicIO descNo: 22 isValue: false 

CLASS BasicIO dNo:35 topDno:35 orgOff:1 orgId:LIB orgDno:34
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %module LIB.StringLib \
-- %Public \
-- Lock:  \
--    dummy: var integer
4:	 allocEventQ 
-- 1 35 true 
-- VDTentry: vdtAdd: inx=1 descInx=35 vDescInx=35 vdtTop: 1 
6:	 mvStack 
-- DI:isConst: keyboard 
-- OG:gen: false 
-- %Public \
--    readLine:  \
--       out M: var LIB.StringLib.String \
--       inx: var integer
-- before:isDerived 
7:	 pushThis 
8:	 invoke keyboard 36 2 1
14:	 rpop 
-- DI:isConst: screen 
-- OG:gen: false 
-- L: obj Lock \
--    %Public \
--    init:  \
--       L.get
-- before:isDerived 
15:	 pushThis 
16:	 invoke screen 37 3 1
22:	 rpop 
23:	 rtnAlloc 1
DO:
25:	 doEventQ 
26:	 mvStack 
L1:
L2:
27:	 setThisStack  
28:	 pushThis 
29:	 rtn D
31:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: keyboard descNo: 36 isValue: false 
-- Items:GenClass: keyboard descNo: 22 isValue: false 

CLASS keyboard dNo:36 topDno:36 orgOff:1 orgId:BasicIO orgDno:35
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %Public \
-- readLine:  \
--    out M: var LIB.StringLib.String \
--    inx: var integer
4:	 allocEventQ 
-- 1 36 true 
-- VDTentry: vdtAdd: inx=1 descInx=36 vDescInx=36 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: screen descNo: 37 isValue: false 
-- Items:GenClass: screen descNo: 22 isValue: false 

CLASS screen dNo:37 topDno:37 orgOff:1 orgId:BasicIO orgDno:35
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- L: obj Lock \
-- %Public \
-- init:  \
--    L.get
4:	 allocEventQ 
-- 1 37 true 
-- VDTentry: vdtAdd: inx=1 descInx=37 vDescInx=37 vdtTop: 1 
6:	 mvStack 
-- DI:isConst: L 
-- OG:gen: true Lock
-- OG:before:super.gen: "Lock" 
7:	 pushThis 
8:	 rpushg screen%$37 1
-- scanInv: "Lock " 0 0 1 
-- doInvoke: Lock0 1 useRtnVal: false 
-- scanInv: "Lock " 0 1 1 
-- doInvoke:X: Lock0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "Lock " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 2 rec: none pRec: none E.origin: 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integer
-- kuk:X: Lock
-- koks:Y: "Lock " 
-- ptn:loadArgs:E: Lock
-- args: 
-- ptn:loadArgs:end: 
-- Lock:  \
--    dummy: var integer \
--    %Public \
--    M: var integer
-- OI:newInvoke: "Lock " 
10:	 invoke Lock 38 2 1
16:	 rpop 
17:	 rtnAlloc 1
DO:
19:	 doEventQ 
20:	 mvStack 
L1:
L2:
21:	 setThisStack  
22:	 pushThis 
23:	 rtn D
25:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Lock descNo: 38 isValue: false 
-- Items:GenClass: Lock descNo: 22 isValue: false 

CLASS Lock dNo:38 topDno:38 orgOff:1 orgId:BasicIO orgDno:35
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- dummy: var integer \
-- %Public \
-- M: var integer \
-- init: 
4:	 allocEventQ 
-- 1 38 true 
-- VDTentry: vdtAdd: inx=1 descInx=38 vDescInx=38 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: Dimensions descNo: 39 isValue: false 
-- Items:GenClass: Dimensions descNo: 22 isValue: false 

CLASS Dimensions dNo:39 topDno:39 orgOff:1 orgId:LIB orgDno:34
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %domain_boundary \
-- %public \
-- Dimension:  \
--    %dimension "-top-"
4:	 allocEventQ 
-- 1 39 true 
-- VDTentry: vdtAdd: inx=1 descInx=39 vDescInx=39 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: StringLib descNo: 40 isValue: false 
-- Items:GenClass: StringLib descNo: 22 isValue: false 

CLASS StringLib dNo:40 topDno:40 orgOff:1 orgId:LIB orgDno:34
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %id "String module" \
-- %module LIB \
-- %public \
-- String: Value
4:	 allocEventQ 
-- 1 40 true 
-- VDTentry: vdtAdd: inx=1 descInx=40 vDescInx=40 vdtTop: 1 
6:	 saveStringOrigin 7:	 mvStack 
8:	 rtnAlloc 1
DO:
10:	 doEventQ 
11:	 mvStack 
L1:
L2:
12:	 setThisStack  
13:	 pushThis 
14:	 rtn D
16:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>$19 descNo: 19 isValue: false 
-- Items:GenClass: loop>$19 descNo: 22 isValue: false 

CLASS loop>$19 dNo:19 topDno:19 orgOff:1 orgId:loop orgDno:15
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: leave(loop)
4:	 allocEventQ 
-- 1 19 true 
-- VDTentry: vdtAdd: inx=1 descInx=19 vDescInx=19 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true leave(loop)
-- OG:before:super.gen: "leave(loop)" 
-- scanInv: "leave(loop) " 0 0 1 
-- doInvoke: leave(loop)0 1 useRtnVal: false 
-- scanInv: "leave(loop) " 0 1 1 
-- doInvoke:X: leave(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(loop) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(loop)
-- koks:Y: "leave(loop) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(loop) " 
11:	 break  1 2 15 0
L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: if:then descNo: 21 isValue: false 
-- Items:GenClass: if:then descNo: 22 isValue: false 

CLASS if:then dNo:21 topDno:21 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg Boolean%$41 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %basic 100 \
-- %globals inSub
4:	 allocEventQ 
-- 1 21 true 
-- VDTentry: vdtAdd: inx=1 descInx=21 vDescInx=21 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:1 objSize:1 isIndexed:0
-- 2 23 false 
-- VDTentry: vdtAdd: inx=2 descInx=21 vDescInx=23 vdtTop: 2 

CLASS thenPart#23 dNo:23 topDno:22 orgOff:0 orgId:if:then%$21 orgDno:21 isVstub
1:	 invoke Object 22 0 0
7:	 pushThis 
8:	 rstoreg  2
10:	 setThisStack  
11:	 pushThis 
12:	 rpushg  2
14:	 rtn D
16:	 END OSDV:1 objSize:3 isIndexed:0
-- Items:GenClass: Boolean descNo: 41 isValue: true 
-- Items:GenClass: Boolean descNo: 4 isValue: true 
-- Items:GenClass: Value descNo: 22 isValue: true 

CLASS Boolean dNo:41 topDno:4 orgOff:0 orgId:BETA orgDno:2 isValueObj
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %id "Boolean" \
-- %globals inSub \
-- %basic 4, 8 \
-- %public
-- 1 41 true 
-- VDTentry: vdtAdd: inx=1 descInx=41 vDescInx=41 vdtTop: 1 
DO:
L1:
L2:
1:	 setThisStack  
2:	 pushThis 
3:	 rtn D
5:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: True descNo: 24 isValue: false 
-- Items:GenClass: True descNo: 22 isValue: false 

CLASS True dNo:24 topDno:24 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %globals \
-- out B: var boolean \
-- B := 1
1:	 allocEventQ 
-- 1 24 true 
-- VDTentry: vdtAdd: inx=1 descInx=24 vDescInx=24 vdtTop: 1 
3:	 mvStack 
4:	 rtnAlloc 1
DO:
6:	 doEventQ 
7:	 mvStack 
L1:
8:	 pushThis 
-- scanInv: "B " 0 0 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
9:	 pushc 1
11:	 storeg Boolean%$41 1
L2:
13:	 setThisStack  
14:	 pushThis 
15:	 rtn D
17:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: for:to:repeat descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS for:to:repeat dNo:29 topDno:29 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 2
4:	 pushThis 
5:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
7:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=29 vDescInx=29 vdtTop: 1 
9:	 mvStack 
10:	 rtnAlloc 1
DO:
12:	 doEventQ 
13:	 mvStack 
L1:
14:	 pushThis 
-- scanInv: "inx " 0 0 1 
-- OG:gen: true first
-- gen:whatIsThis? 
-- OG:before:super.gen: "first" 
15:	 pushThis 
-- scanInv: "first " 0 0 1 
-- doInvoke: first0 1 useRtnVal: true 
-- scanInv: "first " 0 1 1 
-- doInvoke:X: first0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "first " isBasicValue: true 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: first
-- koks:Y: "first " 
-- ptn:loadArgs:E: first
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "first " 
-- DI:newInvoke: "first: var integer " off: 1 valueOff: 0 E: "
 --  first " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "first " isAdr: false valueOff: 0 
16:	 pushg 1 newInvoke
18:	 storeg integer%$5 3
-- OG:gen: false 
-- if (inx <= last) :then  \
--       repeat \
--       inx := inx + 1 \
--       restart(_doIt)
-- before:isDerived 
20:	 pushThis 
21:	 invoke _doIt 42 0 0
27:	 rpop 
L2:
28:	 setThisStack  
29:	 pushThis 
30:	 rtn D
32:	 END OSDV:1 objSize:3 isIndexed:0
-- 2 30 false 
-- VDTentry: vdtAdd: inx=2 descInx=29 vDescInx=30 vdtTop: 2 

CLASS repeat#30 dNo:30 topDno:22 orgOff:0 orgId:for:to:repeat%$29 orgDno:29 isVstub
1:	 invoke Object 22 0 0
7:	 pushThis 
8:	 rstoreg  2
10:	 setThisStack  
11:	 pushThis 
12:	 rpushg  2
14:	 rtn D
16:	 END OSDV:1 objSize:3 isIndexed:0
-- Items:GenClass: _doIt descNo: 42 isValue: false 
-- Items:GenClass: _doIt descNo: 22 isValue: false 

CLASS _doIt dNo:42 topDno:42 orgOff:1 orgId:for:to:repeat orgDno:29
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- if (inx <= last) :then  \
--    repeat \
--    inx := inx + 1 \
--    restart(_doIt)
4:	 allocEventQ 
-- 1 42 true 
-- VDTentry: vdtAdd: inx=1 descInx=42 vDescInx=42 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- if (inx <= last) :then  \
--    repeat \
--    inx := inx + 1 \
--    restart(_doIt)
-- OG:before:super.gen: "if (inx <= last) :then  \
--    repeat \
--    inx := inx + 1 \
--    restart(_doIt) \
-- :else  \
--    inx := inx" 
-- doInvoke: 
-- if (inx <= last) :then  \
--    repeat \
--    inx := inx + 1 \
--    restart(_doIt)0 1 useRtnVal: false 
-- scanInv: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)0 1 1 
-- doInvoke:X: 
-- if (inx <= last) :then  \
--    repeat \
--    inx := inx + 1 \
--    restart(_doIt)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (inx <= last) :then  \
--    repeat \
--    inx := inx + 1 \
--    restart(_doIt)
-- koks:Y: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
-- OG:gen: true (inx <= last)
-- OG:before:super.gen: "(inx <= last)" 
11:	 pushThis 
12:	 rpushg _doIt%$42 1
-- scanInv: "(inx <= last) " 0 1 2 
14:	 pushg 3 newInvoke
-- doInvoke: (inx <= last)1 2 useRtnVal: true 
-- scanInv: "(inx <= last) " 1 2 2 
-- doInvoke:X: <= last1 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "<= last " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "inx " rec.ATd: "inx: var integer " 1 
 --  false pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: <= last
-- koks:Y: "<= last " 
-- ptn:loadArgs:E: <= last
-- args: last
-- E.arg: "ObjectDescriptor" last 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "<= last " "ObjectInvocation_Binary " ActArg: "last "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: last 
-- OG:gen: true last
-- gen:whatIsThis? 
-- OG:before:super.gen: "last" 
16:	 pushThis 
17:	 rpushg _doIt%$42 1
-- scanInv: "last " 0 0 1 
-- doInvoke: last0 1 useRtnVal: true 
-- scanInv: "last " 0 1 1 
-- doInvoke:X: last0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "last " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: last
-- koks:Y: "last " 
-- ptn:loadArgs:E: last
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "last " 
-- DI:newInvoke: "last: var integer " off: 2 valueOff: 0 E: "
 --  last " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "last " isAdr: false valueOff: 0 
19:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true last: var integer
-- ptn:loadArgs:end: 
-- <=  :<  \
--    %basic 52 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "<= last " 
21:	 le 
22:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- repeat \
--    inx := inx + 1 \
--    restart(_doIt)
-- before:isDerived 
25:	 pushThis 
26:	 invoke _doIt>$44 44 0 0
32:	 rpop 
33:	 jmp L5
L4:
-- OG:gen: false inx := inx
-- before:isDerived 
36:	 pushThis 
37:	 invoke _doIt>$47 47 0 0
43:	 rpop 
L5:
L2:
44:	 setThisStack  
45:	 pushThis 
46:	 rtn D
48:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: _doIt>$44 descNo: 44 isValue: false 
-- Items:GenClass: _doIt>$44 descNo: 22 isValue: false 

CLASS _doIt>$44 dNo:44 topDno:44 orgOff:1 orgId:_doIt orgDno:42
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- repeat \
-- inx := inx + 1 \
-- restart(_doIt)
4:	 allocEventQ 
-- 1 44 true 
-- VDTentry: vdtAdd: inx=1 descInx=44 vDescInx=44 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true repeat
-- OG:before:super.gen: "repeat" 
11:	 pushThis 
12:	 rpushg _doIt>$44%$44 1
14:	 rpushg _doIt%$42 1
-- scanInv: "repeat " 0 0 1 
-- doInvoke: repeat0 1 useRtnVal: false 
-- scanInv: "repeat " 0 1 1 
-- doInvoke:X: repeat0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "repeat " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: repeat
-- koks:Y: "repeat " 
-- ptn:loadArgs:E: repeat
-- args: 
-- ptn:loadArgs:end: repeat:< object
-- OI:newInvoke: "repeat " 
16:	 invokev 2 0 repeat$30$30 0
20:	 rpop 
21:	 pushThis 
22:	 rpushg _doIt>$44%$44 1
24:	 rpushg _doIt%$42 1
-- scanInv: "inx " 0 0 1 
-- OG:gen: true inx + 1
-- OG:before:super.gen: "inx + 1" 
26:	 pushThis 
27:	 rpushg _doIt>$44%$44 1
29:	 rpushg _doIt%$42 1
-- scanInv: "inx + 1 " 0 1 2 
31:	 pushg 3 newInvoke
-- doInvoke: inx + 11 2 useRtnVal: true 
-- scanInv: "inx + 1 " 1 2 2 
-- doInvoke:X: + 11 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " rec.ATd: "inx: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + 1
-- koks:Y: "+ 1 " 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
33:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ 1 " 
35:	 plus 
-- unitConv:after 
36:	 storeg integer%$5 3
-- OG:gen: true restart(_doIt)
-- OG:before:super.gen: "restart(_doIt)" 
-- scanInv: "restart(_doIt) " 0 0 1 
-- doInvoke: restart(_doIt)0 1 useRtnVal: false 
-- scanInv: "restart(_doIt) " 0 1 1 
-- doInvoke:X: restart(_doIt)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "restart(_doIt) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: restart(_doIt)
-- koks:Y: "restart(_doIt) " 
-- ptn:loadArgs:end: 
-- restart(V: var integer):  -- odd parameter type! \
--    %basic 102
-- OI:newInvoke: "restart(_doIt) " 
38:	 break  1 1 42 0
L2:
45:	 setThisStack  
46:	 pushThis 
47:	 rtn D
49:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: _doIt>$47 descNo: 47 isValue: false 
-- Items:GenClass: _doIt>$47 descNo: 22 isValue: false 

CLASS _doIt>$47 dNo:47 topDno:47 orgOff:1 orgId:_doIt orgDno:42
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: inx := inx
4:	 allocEventQ 
-- 1 47 true 
-- VDTentry: vdtAdd: inx=1 descInx=47 vDescInx=47 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg _doIt>$47%$47 1
14:	 rpushg _doIt%$42 1
-- scanInv: "inx " 0 0 1 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
16:	 pushThis 
17:	 rpushg _doIt>$47%$47 1
19:	 rpushg _doIt%$42 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
21:	 pushg 3 newInvoke
23:	 storeg integer%$5 3
L2:
25:	 setThisStack  
26:	 pushThis 
27:	 rtn D
29:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>for:to:repeat$31>repeat$25 descNo: 25 isValue: false 
-- Items:GenClass: loop>for:to:repeat$31>repeat$25 descNo: 22 isValue: false 

CLASS loop>for:to:repeat$31>repeat$25 dNo:25 topDno:25 orgOff:1 orgId:loop>for:to:repeat$31 orgDno:31
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- c1 := get[inx] \
-- c2 := Veq.get[inx] \
-- if (c1 <> c2) :then  \
--    Beq := false
4:	 allocEventQ 
-- 1 25 true 
-- VDTentry: vdtAdd: inx=1 descInx=25 vDescInx=25 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
14:	 rpushg loop>for:to:repeat$31%$31 4
-- scanInv: "c1 " 0 0 1 
-- OG:gen: true get[inx]
-- OG:before:super.gen: "get[inx]" 
16:	 pushThis 
17:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
19:	 rpushg loop>for:to:repeat$31%$31 4
21:	 rpushg loop%$15 1
23:	 rpushg =%$14 1
-- scanInv: "get[inx] " 0 0 1 
-- doInvoke: get[inx]0 1 useRtnVal: true 
-- scanInv: "get[inx] " 0 1 1 
-- doInvoke:X: get[inx]0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
25:	 pushThis 
26:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
28:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
30:	 xpushg  inx 1 0
33:	 storeg char%$7 2
35:	 pushThis 
36:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
38:	 rpushg loop>for:to:repeat$31%$31 4
-- scanInv: "c2 " 0 0 1 
-- OG:gen: true Veq.get[inx]
-- OG:before:super.gen: "Veq.get[inx]" 
40:	 pushThis 
41:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
43:	 rpushg loop>for:to:repeat$31%$31 4
45:	 rpushg loop%$15 1
-- scanInv: "Veq.get[inx] " 0 1 2 
47:	 rpushg newInvoke 2
-- doInvoke: Veq.get[inx]1 2 useRtnVal: true 
-- scanInv: "Veq.get[inx] " 1 2 2 
-- doInvoke:X: get[inx]1 2 2 pRec: none rec: Veq ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "Veq " rec.ATd: "
 --  in Veq: var this(Value) " 18 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
49:	 pushThis 
50:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
52:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
54:	 xpushg  inx 1 0
57:	 storeg char%$7 3
-- OG:gen: true 
-- if (c1 <> c2) :then  \
--    Beq := false \
--    leave(loop)
-- OG:before:super.gen: "if (c1 <> c2) :then  \
--    Beq := false \
--    leave(loop)" 
-- doInvoke: 
-- if (c1 <> c2) :then  \
--    Beq := false \
--    leave(loop)0 1 useRtnVal: false 
-- scanInv: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  0 1 1 
-- doInvoke:X: 
-- if (c1 <> c2) :then  \
--    Beq := false \
--    leave(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (c1 <> c2) :then  \
--    Beq := false \
--    leave(loop)
-- koks:Y: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
-- OG:gen: true (c1 <> c2)
-- OG:before:super.gen: "(c1 <> c2)" 
59:	 pushThis 
60:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
62:	 rpushg loop>for:to:repeat$31%$31 4
-- scanInv: "(c1 <> c2) " 0 1 2 
64:	 pushg 2 newInvoke
-- doInvoke: (c1 <> c2)1 2 useRtnVal: true 
-- scanInv: "(c1 <> c2) " 1 2 2 
-- doInvoke:X: <> c21 2 2 pRec: none rec: c1 ix->next none 
-- checkForProxy:E: "<> c2 " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "c1 " rec.ATd: "c1: var char " 3 false 
 --  pRec: none E.origin: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
-- kuk:X: <> c2
-- koks:Y: "<> c2 " 
-- ptn:loadArgs:E: <> c2
-- args: c2
-- E.arg: "ObjectDescriptor" c2 
-- arg: in V: var char 1 1 false 
-- E.arg: in V: var char 
-- NonVirt: "<> c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: c2 
-- OG:gen: true c2
-- gen:whatIsThis? 
-- OG:before:super.gen: "c2" 
66:	 pushThis 
67:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
69:	 rpushg loop>for:to:repeat$31%$31 4
-- scanInv: "c2 " 0 0 1 
-- doInvoke: c20 1 useRtnVal: true 
-- scanInv: "c2 " 0 1 1 
-- doInvoke:X: c20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "c2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
-- kuk:X: c2
-- koks:Y: "c2 " 
-- ptn:loadArgs:E: c2
-- args: 
-- ptn:loadArgs:end: 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- OI:newInvoke: "c2 " 
-- DI:newInvoke: "c2: var char " off: 2 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
71:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true c2: var char
-- ptn:loadArgs:end: 
-- <>  :  \
--    %basic 55 \
--    in V: var char \
--    out B: var boolean
-- OI:newInvoke: "<> c2 " 
73:	 ne 
-- unitConv:after 
74:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- Beq := false \
--    leave(loop)
-- before:isDerived 
77:	 pushThis 
78:	 invoke loop>for:to:repeat$31>repeat$25>$27 27 0 0
84:	 rpop 
L4:
L2:
85:	 setThisStack  
86:	 pushThis 
87:	 rtn D
89:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>for:to:repeat$31>repeat$25>$27 descNo: 27 isValue: false 
-- Items:GenClass: loop>for:to:repeat$31>repeat$25>$27 descNo: 22 isValue: false 

CLASS loop>for:to:repeat$31>repeat$25>$27 dNo:27 topDno:27 orgOff:1 orgId:loop>for:to:repeat$31>repeat$25 orgDno:25
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- Beq := false \
-- leave(loop)
4:	 allocEventQ 
-- 1 27 true 
-- VDTentry: vdtAdd: inx=1 descInx=27 vDescInx=27 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop>for:to:repeat$31>repeat$25>$27%$27 1
14:	 rpushg loop>for:to:repeat$31>repeat$25%$25 1
16:	 rpushg loop>for:to:repeat$31%$31 4
18:	 rpushg loop%$15 1
-- scanInv: "Beq " 0 0 1 
-- OG:gen: true false
-- OG:before:super.gen: "false" 
-- doInvoke: false0 1 useRtnVal: true 
-- scanInv: "false " 0 1 1 
-- doInvoke:X: false0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "false " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: false
-- koks:Y: "false " 
-- ptn:loadArgs:E: false
-- args: 
-- ptn:loadArgs:end: 
-- False:  \
--    %globals \
--    out B: var boolean \
--    B := 0
-- OI:newInvoke: "false " 
20:	 invoke False 28 0 0
26:	 pushg 1 
28:	 storeg Boolean%$41 3
-- OG:gen: true leave(loop)
-- OG:before:super.gen: "leave(loop)" 
-- scanInv: "leave(loop) " 0 0 1 
-- doInvoke: leave(loop)0 1 useRtnVal: false 
-- scanInv: "leave(loop) " 0 1 1 
-- doInvoke:X: leave(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(loop) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(loop)
-- koks:Y: "leave(loop) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(loop) " 
30:	 break  3 2 15 0
L2:
37:	 setThisStack  
38:	 pushThis 
39:	 rtn D
41:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: False descNo: 28 isValue: false 
-- Items:GenClass: False descNo: 22 isValue: false 

CLASS False dNo:28 topDno:28 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
-- AllocateSuper: 
-- %globals \
-- out B: var boolean \
-- B := 0
1:	 allocEventQ 
-- 1 28 true 
-- VDTentry: vdtAdd: inx=1 descInx=28 vDescInx=28 vdtTop: 1 
3:	 mvStack 
4:	 rtnAlloc 1
DO:
6:	 doEventQ 
7:	 mvStack 
L1:
8:	 pushThis 
-- scanInv: "B " 0 0 1 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
9:	 pushc 0
11:	 storeg Boolean%$41 1
L2:
13:	 setThisStack  
14:	 pushThis 
15:	 rtn D
17:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>for:to:repeat$31 descNo: 31 isValue: false 
-- Items:GenClass: loop>for:to:repeat$31 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS loop>for:to:repeat$31 dNo:31 topDno:29 orgOff:4 orgId:loop orgDno:15
-- VDTtableCopy: 29 47 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(length):repeat \
--    c1 := get[inx] \
--    c2 := Veq.get[inx] \
--    if (c1 <> c2) :then  \
--       Beq := false \
--       leave(loop) \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(length):repeat \
--    c1 := get[inx] \
--    c2 := Veq.get[inx] \
--    if (c1 <> c2) :then 
-- args: 
-- for(1):to(length):repeat \
--    c1 := get[inx] \
--    c2 := Veq.get[inx] \
--    if (c1 <> c2) :then 
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" length 
-- E.arg: "ObjectDescriptor" c1 := get[inx] \
--    c2 := Veq.get[inx] \
--    if (c1 <> c2) :then  \
--       Beq := false \
--       leave(loop) 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: length 
-- OG:gen: true length
-- OG:before:super.gen: "length" 
6:	 pushThis 
7:	 rpushg loop%$15 4
9:	 rpushg loop%$15 1
11:	 rpushg =%$14 1
-- scanInv: "length " 0 0 1 
-- doInvoke: length0 1 useRtnVal: true 
-- scanInv: "length " 0 1 1 
-- doInvoke:X: length0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: "length " 
13:	 invoke length 16 0 0
19:	 pushg 2 
-- loadArgs:after:actualArg:gen: false false 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
21:	 pushThis 
22:	 storeg integer%$5 2
24:	 pushThis 
25:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
27:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=31 vDescInx=29 vdtTop: 2 
29:	 rtnAlloc 1
31:	 toSuper  29
DO:
34:	 mvStack 
L1:
L2:
35:	 rtnInner  M
36:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 25 false 
-- VDTentry: vdtAdd: inx=2 descInx=31 vDescInx=25 vdtTop: 2 
-- Items:GenClass: <= descNo: 48 isValue: false 
-- Items:GenClass: <= descNo: 43 isValue: false 
-- Items:GenClass: <= descNo: 22 isValue: false 

CLASS <= dNo:43 topDno:43 orgOff:1 orgId:Value orgDno:4
-- handleArgumentsAndOrigin: 
1:	 jmpFalse  L3
4:	 pushThis 
5:	 vassign 4 2 0
10:	 jmp L4
L3:
13:	 invokeVal  Veq 32 3
19:	 rpop 
L4:
20:	 tstOriginIsNone 
21:	 rstore  1 origin
-- AllocateSuper: 
-- %basic 52 \
-- in Veq: var this(Value) \
-- out Beq: var boolean
23:	 allocEventQ 
-- 1 43 true 
-- VDTentry: vdtAdd: inx=1 descInx=43 vDescInx=43 vdtTop: 1 
25:	 mvStack 
-- DI:isConst: Veq 
-- inArg: in Veq: var this(Value) 
26:	 rtnAlloc 1
DO:
28:	 doEventQ 
29:	 mvStack 
L1:
L2:
30:	 setThisStack  
31:	 pushThis 
32:	 rtn D
34:	 END OSDV:0 objSize:5 isIndexed:0

CLASS <= dNo:48 topDno:43 orgOff:1 orgId:String orgDno:10
-- VDTtableCopy: 43 51 
-- vdtTableCopy: I:1:43 
-- handleArgumentsAndOrigin: 
1:	 rShiftUp  1
3:	 tstOriginIsNone 
4:	 rstore  1 origin
-- AllocateSuper: 
-- loop: obj  \
--    matchEq:  \
--       inx: var integer \
--       c1: var char
6:	 allocEventQ 
-- op:super <=
-- push:super.origin: 
8:	 pushThis 
9:	 rpushg iOrigin 1
-- handleSuperArgs:E: "" theIS: 
-- loop: obj  \
--    matchEq:  \
--       inx: var integer \
--       c1: var char
-- super.sig:not:none:superAdj: -1 
11:	 rShiftDown 1
-- handleArgumentsAndOrigin: 
13:	 pushThis 
14:	 rstoreg Veq 2
16:	 tstOriginIsNone 
17:	 rstore  1 origin
-- AllocateSuper: 
-- %basic 52 \
-- in Veq: var this(Value) \
-- out Beq: var boolean
19:	 allocEventQ 
-- 1 43 true 
-- VDTentry: vdtAdd: inx=1 descInx=48 vDescInx=43 vdtTop: 1 
21:	 mvStack 
-- DI:isConst: Veq 
-- inArg: in Veq: var this(Value) 
-- DI:isConst: loop 
-- OG:gen: false 
-- matchEq:  \
--       inx: var integer \
--       c1: var char \
--       c2: var char
-- before:isDerived 
22:	 pushThis 
23:	 invoke loop 49 4 1
29:	 rpop 
DO:
30:	 doEventQ 
31:	 mvStack 
L1:
L2:
32:	 setThisStack  
33:	 pushThis 
34:	 rtn D
36:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: loop descNo: 49 isValue: false 
-- Items:GenClass: loop descNo: 22 isValue: false 

CLASS loop dNo:49 topDno:49 orgOff:1 orgId:<= orgDno:48
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- matchEq:  \
--    inx: var integer \
--    c1: var char \
--    c2: var char
4:	 allocEventQ 
-- 1 49 true 
-- VDTentry: vdtAdd: inx=1 descInx=49 vDescInx=49 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
-- scanInv: "L1 " 0 0 1 
-- OG:gen: true 
-- length \
--            -- min length of this and V
-- OG:before:super.gen: "length \
--            -- min length of this and V" 
12:	 pushThis 
13:	 rpushg loop%$49 1
15:	 rpushg <=%$48 1
-- scanInv: 
 --  length
 --             -- min length of this and V
 --  0 0 1 
-- doInvoke: 
-- length \
--            -- min length of this and V0 1 useRtnVal: true 
-- scanInv: 
 --  length
 --             -- min length of this and V
 --  0 1 1 
-- doInvoke:X: 
-- length \
--            -- min length of this and V0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  length
 --             -- min length of this and V
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: 
-- length \
--            -- min length of this and V
-- koks:Y: 
 --  length
 --             -- min length of this and V
 --  
-- ptn:loadArgs:E: 
-- length \
--            -- min length of this and V
-- args: -- min length of this and V
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: 
 --  length
 --             -- min length of this and V
 --  
17:	 invoke length 16 0 0
23:	 pushg 2 
25:	 storeg integer%$5 3
27:	 pushThis 
-- scanInv: "L2 " 0 0 1 
-- OG:gen: true Veq.length
-- OG:before:super.gen: "Veq.length" 
28:	 pushThis 
29:	 rpushg loop%$49 1
-- scanInv: "Veq.length " 0 1 2 
31:	 rpushg newInvoke 2
-- doInvoke: Veq.length1 2 useRtnVal: true 
-- scanInv: "Veq.length " 1 2 2 
-- doInvoke:X: length1 2 2 pRec: none rec: Veq ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "Veq " rec.ATd: "
 --  in Veq: var this(Value) " 18 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: "length " 
33:	 invoke length 16 0 0
39:	 pushg 2 
41:	 storeg integer%$5 4
-- OG:gen: true 
-- if (L1 < L2) :then  \
--    L := L1 \
-- :else  \
--    L := L2
-- OG:before:super.gen: "if (L1 < L2) :then  \
--    L := L1 \
-- :else  \
--    L := L2" 
-- doInvoke: 
-- if (L1 < L2) :then  \
--    L := L1 \
-- :else  \
--    L := L20 1 useRtnVal: false 
-- scanInv: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  0 1 1 
-- doInvoke:X: 
-- if (L1 < L2) :then  \
--    L := L1 \
-- :else  \
--    L := L20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (L1 < L2) :then  \
--    L := L1 \
-- :else  \
--    L := L2
-- koks:Y: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
-- OG:gen: true (L1 < L2)
-- OG:before:super.gen: "(L1 < L2)" 
43:	 pushThis 
-- scanInv: "(L1 < L2) " 0 1 2 
44:	 pushg 3 newInvoke
-- doInvoke: (L1 < L2)1 2 useRtnVal: true 
-- scanInv: "(L1 < L2) " 1 2 2 
-- doInvoke:X: < L21 2 2 pRec: none rec: L1 ix->next none 
-- checkForProxy:E: "< L2 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L1 " rec.ATd: "L1: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: < L2
-- koks:Y: "< L2 " 
-- ptn:loadArgs:E: < L2
-- args: L2
-- E.arg: "ObjectDescriptor" L2 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "< L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L2 
-- OG:gen: true L2
-- gen:whatIsThis? 
-- OG:before:super.gen: "L2" 
46:	 pushThis 
-- scanInv: "L2 " 0 0 1 
-- doInvoke: L20 1 useRtnVal: true 
-- scanInv: "L2 " 0 1 1 
-- doInvoke:X: L20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: L2
-- koks:Y: "L2 " 
-- ptn:loadArgs:E: L2
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L2 " 
-- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
47:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true L2: var integer
-- ptn:loadArgs:end: 
-- <  :  \
--    %basic 51 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "< L2 " 
49:	 lt 
-- unitConv:after 
50:	 jmpFalse  L4
L3:
-- OG:gen: false L := L1
-- before:isDerived 
53:	 pushThis 
54:	 invoke loop>$51 51 0 0
60:	 rpop 
61:	 jmp L5
L4:
-- OG:gen: false L := L2
-- before:isDerived 
64:	 pushThis 
65:	 invoke loop>$52 52 0 0
71:	 rpop 
L5:
-- OG:gen: true matchEq
-- OG:before:super.gen: "matchEq" 
72:	 pushThis 
-- scanInv: "matchEq " 0 0 1 
-- doInvoke: matchEq0 1 useRtnVal: false 
-- scanInv: "matchEq " 0 1 1 
-- doInvoke:X: matchEq0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "matchEq " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: matchEq
-- koks:Y: "matchEq " 
-- ptn:loadArgs:E: matchEq
-- args: 
-- ptn:loadArgs:end: 
-- matchEq:  \
--    inx: var integer \
--    c1: var char \
--    c2: var char
-- OI:newInvoke: "matchEq " 
73:	 invoke matchEq 53 0 0
79:	 rpop 
L2:
80:	 setThisStack  
81:	 pushThis 
82:	 rtn D
84:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: loop>$51 descNo: 51 isValue: false 
-- Items:GenClass: loop>$51 descNo: 22 isValue: false 

CLASS loop>$51 dNo:51 topDno:51 orgOff:1 orgId:loop orgDno:49
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: L := L1
4:	 allocEventQ 
-- 1 51 true 
-- VDTentry: vdtAdd: inx=1 descInx=51 vDescInx=51 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop>$51%$51 1
-- scanInv: "L " 0 0 1 
-- OG:gen: true L1
-- gen:whatIsThis? 
-- OG:before:super.gen: "L1" 
14:	 pushThis 
15:	 rpushg loop>$51%$51 1
-- scanInv: "L1 " 0 0 1 
-- doInvoke: L10 1 useRtnVal: true 
-- scanInv: "L1 " 0 1 1 
-- doInvoke:X: L10 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L1 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: L1
-- koks:Y: "L1 " 
-- ptn:loadArgs:E: L1
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L1 " 
-- DI:newInvoke: "L1: var integer " off: 2 valueOff: 0 E: "L1 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L1 " isAdr: false valueOff: 0 
17:	 pushg 3 newInvoke
19:	 storeg integer%$5 2
L2:
21:	 setThisStack  
22:	 pushThis 
23:	 rtn D
25:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>$52 descNo: 52 isValue: false 
-- Items:GenClass: loop>$52 descNo: 22 isValue: false 

CLASS loop>$52 dNo:52 topDno:52 orgOff:1 orgId:loop orgDno:49
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: L := L2
4:	 allocEventQ 
-- 1 52 true 
-- VDTentry: vdtAdd: inx=1 descInx=52 vDescInx=52 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop>$52%$52 1
-- scanInv: "L " 0 0 1 
-- OG:gen: true L2
-- gen:whatIsThis? 
-- OG:before:super.gen: "L2" 
14:	 pushThis 
15:	 rpushg loop>$52%$52 1
-- scanInv: "L2 " 0 0 1 
-- doInvoke: L20 1 useRtnVal: true 
-- scanInv: "L2 " 0 1 1 
-- doInvoke:X: L20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: L2
-- koks:Y: "L2 " 
-- ptn:loadArgs:E: L2
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L2 " 
-- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
17:	 pushg 4 newInvoke
19:	 storeg integer%$5 2
L2:
21:	 setThisStack  
22:	 pushThis 
23:	 rtn D
25:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: matchEq descNo: 53 isValue: false 
-- Items:GenClass: matchEq descNo: 22 isValue: false 

CLASS matchEq dNo:53 topDno:53 orgOff:1 orgId:loop orgDno:49
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- inx: var integer \
-- c1: var char \
-- c2: var char \
-- isEmpty: do 
4:	 allocEventQ 
-- 1 53 true 
-- VDTentry: vdtAdd: inx=1 descInx=53 vDescInx=53 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: false 
-- if (L1 = 0) :then  \
--       Beq := L1 <= L2 \
--       leave(matchEq) \
--    if (L2 = 0) :then 
-- before:isDerived 
11:	 pushThis 
12:	 invoke isEmpty 54 0 0
18:	 rpop 
-- OG:gen: false 
-- inx := inx + 1 \
--    c1 := get[inx] \
--    c2 := Veq.get[inx] \
--    if (c1 = c2) :then 
-- before:isDerived 
19:	 pushThis 
20:	 invoke loop 57 0 0
26:	 rpop 
-- OG:gen: false 
-- if (c1 = c2) :then  \
--       Beq \
--                      -- we have inx = L := L1 <= L2 \
--       leave(matchEq)
-- before:isDerived 
27:	 pushThis 
28:	 invoke doit 60 0 0
34:	 rpop 
L2:
35:	 setThisStack  
36:	 pushThis 
37:	 rtn D
39:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: isEmpty descNo: 54 isValue: false 
-- Items:GenClass: isEmpty descNo: 22 isValue: false 

CLASS isEmpty dNo:54 topDno:54 orgOff:1 orgId:matchEq orgDno:53
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- if (L1 = 0) :then  \
--    Beq := L1 <= L2 \
--    leave(matchEq) \
-- if (L2 = 0) :then 
4:	 allocEventQ 
-- 1 54 true 
-- VDTentry: vdtAdd: inx=1 descInx=54 vDescInx=54 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- if (L1 = 0) :then  \
--    Beq := L1 <= L2 \
--    leave(matchEq)
-- OG:before:super.gen: "if (L1 = 0) :then  \
--    Beq := L1 <= L2 \
--    leave(matchEq)" 
-- doInvoke: 
-- if (L1 = 0) :then  \
--    Beq := L1 <= L2 \
--    leave(matchEq)0 1 useRtnVal: false 
-- scanInv: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  0 1 1 
-- doInvoke:X: 
-- if (L1 = 0) :then  \
--    Beq := L1 <= L2 \
--    leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (L1 = 0) :then  \
--    Beq := L1 <= L2 \
--    leave(matchEq)
-- koks:Y: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
-- OG:gen: true (L1 = 0)
-- OG:before:super.gen: "(L1 = 0)" 
11:	 pushThis 
12:	 rpushg isEmpty%$54 1
14:	 rpushg matchEq%$53 1
-- scanInv: "(L1 = 0) " 0 1 2 
16:	 pushg 3 newInvoke
-- doInvoke: (L1 = 0)1 2 useRtnVal: true 
-- scanInv: "(L1 = 0) " 1 2 2 
-- doInvoke:X: = 01 2 2 pRec: none rec: L1 ix->next none 
-- checkForProxy:E: "= 0 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L1 " rec.ATd: "L1: var integer " 1 false 
 --  pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = 0
-- koks:Y: "= 0 " 
-- ptn:loadArgs:E: = 0
-- args: 0
-- E.arg: "ObjectDescriptor" 0 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: 0 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
18:	 pushc 0
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= 0 " 
20:	 eq 
21:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- Beq := L1 <= L2 \
--    leave(matchEq)
-- before:isDerived 
24:	 pushThis 
25:	 invoke isEmpty>$55 55 0 0
31:	 rpop 
L4:
-- OG:gen: true 
-- if (L2 = 0) :then  \
--    Beq := false \
--    leave(matchEq)
-- OG:before:super.gen: "if (L2 = 0) :then  \
--    Beq := false \
--    leave(matchEq)" 
-- doInvoke: 
-- if (L2 = 0) :then  \
--    Beq := false \
--    leave(matchEq)0 1 useRtnVal: false 
-- scanInv: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  0 1 1 
-- doInvoke:X: 
-- if (L2 = 0) :then  \
--    Beq := false \
--    leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (L2 = 0) :then  \
--    Beq := false \
--    leave(matchEq)
-- koks:Y: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
-- OG:gen: true (L2 = 0)
-- OG:before:super.gen: "(L2 = 0)" 
32:	 pushThis 
33:	 rpushg isEmpty%$54 1
35:	 rpushg matchEq%$53 1
-- scanInv: "(L2 = 0) " 0 1 2 
37:	 pushg 4 newInvoke
-- doInvoke: (L2 = 0)1 2 useRtnVal: true 
-- scanInv: "(L2 = 0) " 1 2 2 
-- doInvoke:X: = 01 2 2 pRec: none rec: L2 ix->next none 
-- checkForProxy:E: "= 0 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L2 " rec.ATd: "L2: var integer " 1 false 
 --  pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = 0
-- koks:Y: "= 0 " 
-- ptn:loadArgs:E: = 0
-- args: 0
-- E.arg: "ObjectDescriptor" 0 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: 0 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
39:	 pushc 0
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= 0 " 
41:	 eq 
42:	 jmpFalse  L7
L6:
-- OG:gen: false 
-- Beq := false \
--    leave(matchEq)
-- before:isDerived 
45:	 pushThis 
46:	 invoke isEmpty>$56 56 0 0
52:	 rpop 
L7:
L2:
53:	 setThisStack  
54:	 pushThis 
55:	 rtn D
57:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: isEmpty>$55 descNo: 55 isValue: false 
-- Items:GenClass: isEmpty>$55 descNo: 22 isValue: false 

CLASS isEmpty>$55 dNo:55 topDno:55 orgOff:1 orgId:isEmpty orgDno:54
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- Beq := L1 <= L2 \
-- leave(matchEq)
4:	 allocEventQ 
-- 1 55 true 
-- VDTentry: vdtAdd: inx=1 descInx=55 vDescInx=55 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg isEmpty>$55%$55 1
14:	 rpushg isEmpty%$54 1
16:	 rpushg matchEq%$53 1
18:	 rpushg loop%$49 1
-- scanInv: "Beq " 0 0 1 
-- OG:gen: true L1 <= L2
-- OG:before:super.gen: "L1 <= L2" 
20:	 pushThis 
21:	 rpushg isEmpty>$55%$55 1
23:	 rpushg isEmpty%$54 1
25:	 rpushg matchEq%$53 1
-- scanInv: "L1 <= L2 " 0 1 2 
27:	 pushg 3 newInvoke
-- doInvoke: L1 <= L21 2 useRtnVal: true 
-- scanInv: "L1 <= L2 " 1 2 2 
-- doInvoke:X: <= L21 2 2 pRec: none rec: L1 ix->next none 
-- checkForProxy:E: "<= L2 " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "L1 " rec.ATd: "L1: var integer " 1 
 --  false pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: <= L2
-- koks:Y: "<= L2 " 
-- ptn:loadArgs:E: <= L2
-- args: L2
-- E.arg: "ObjectDescriptor" L2 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: L2 
-- OG:gen: true L2
-- gen:whatIsThis? 
-- OG:before:super.gen: "L2" 
29:	 pushThis 
30:	 rpushg isEmpty>$55%$55 1
32:	 rpushg isEmpty%$54 1
34:	 rpushg matchEq%$53 1
-- scanInv: "L2 " 0 0 1 
-- doInvoke: L20 1 useRtnVal: true 
-- scanInv: "L2 " 0 1 1 
-- doInvoke:X: L20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: L2
-- koks:Y: "L2 " 
-- ptn:loadArgs:E: L2
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L2 " 
-- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
36:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true L2: var integer
-- ptn:loadArgs:end: 
-- <=  :<  \
--    %basic 52 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "<= L2 " 
38:	 le 
39:	 storeg Boolean%$41 3
-- OG:gen: true leave(matchEq)
-- OG:before:super.gen: "leave(matchEq)" 
-- scanInv: "leave(matchEq) " 0 0 1 
-- doInvoke: leave(matchEq)0 1 useRtnVal: false 
-- scanInv: "leave(matchEq) " 0 1 1 
-- doInvoke:X: leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(matchEq)
-- koks:Y: "leave(matchEq) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(matchEq) " 
41:	 break  2 2 53 0
L2:
48:	 setThisStack  
49:	 pushThis 
50:	 rtn D
52:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: isEmpty>$56 descNo: 56 isValue: false 
-- Items:GenClass: isEmpty>$56 descNo: 22 isValue: false 

CLASS isEmpty>$56 dNo:56 topDno:56 orgOff:1 orgId:isEmpty orgDno:54
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- Beq := false \
-- leave(matchEq)
4:	 allocEventQ 
-- 1 56 true 
-- VDTentry: vdtAdd: inx=1 descInx=56 vDescInx=56 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg isEmpty>$56%$56 1
14:	 rpushg isEmpty%$54 1
16:	 rpushg matchEq%$53 1
18:	 rpushg loop%$49 1
-- scanInv: "Beq " 0 0 1 
-- OG:gen: true false
-- OG:before:super.gen: "false" 
-- doInvoke: false0 1 useRtnVal: true 
-- scanInv: "false " 0 1 1 
-- doInvoke:X: false0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "false " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: false
-- koks:Y: "false " 
-- ptn:loadArgs:E: false
-- args: 
-- ptn:loadArgs:end: 
-- False:  \
--    %globals \
--    out B: var boolean \
--    B := 0
-- OI:newInvoke: "false " 
20:	 invoke False 28 0 0
26:	 pushg 1 
28:	 storeg Boolean%$41 3
-- OG:gen: true leave(matchEq)
-- OG:before:super.gen: "leave(matchEq)" 
-- scanInv: "leave(matchEq) " 0 0 1 
-- doInvoke: leave(matchEq)0 1 useRtnVal: false 
-- scanInv: "leave(matchEq) " 0 1 1 
-- doInvoke:X: leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(matchEq)
-- koks:Y: "leave(matchEq) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(matchEq) " 
30:	 break  2 2 53 0
L2:
37:	 setThisStack  
38:	 pushThis 
39:	 rtn D
41:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop descNo: 57 isValue: false 
-- Items:GenClass: loop descNo: 22 isValue: false 

CLASS loop dNo:57 topDno:57 orgOff:1 orgId:matchEq orgDno:53
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- inx := inx + 1 \
-- c1 := get[inx] \
-- c2 := Veq.get[inx] \
-- if (c1 = c2) :then 
4:	 allocEventQ 
-- 1 57 true 
-- VDTentry: vdtAdd: inx=1 descInx=57 vDescInx=57 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop%$57 1
-- scanInv: "inx " 0 0 1 
-- OG:gen: true inx + 1
-- OG:before:super.gen: "inx + 1" 
14:	 pushThis 
15:	 rpushg loop%$57 1
-- scanInv: "inx + 1 " 0 1 2 
17:	 pushg 2 newInvoke
-- doInvoke: inx + 11 2 useRtnVal: true 
-- scanInv: "inx + 1 " 1 2 2 
-- doInvoke:X: + 11 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " rec.ATd: "inx: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + 1
-- koks:Y: "+ 1 " 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
19:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ 1 " 
21:	 plus 
-- unitConv:after 
22:	 storeg integer%$5 2
24:	 pushThis 
25:	 rpushg loop%$57 1
-- scanInv: "c1 " 0 0 1 
-- OG:gen: true get[inx]
-- OG:before:super.gen: "get[inx]" 
27:	 pushThis 
28:	 rpushg loop%$57 1
30:	 rpushg matchEq%$53 1
32:	 rpushg loop%$49 1
34:	 rpushg <=%$48 1
-- scanInv: "get[inx] " 0 0 1 
-- doInvoke: get[inx]0 1 useRtnVal: true 
-- scanInv: "get[inx] " 0 1 1 
-- doInvoke:X: get[inx]0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
36:	 pushThis 
37:	 rpushg loop%$57 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
39:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
41:	 xpushg  inx 1 0
44:	 storeg char%$7 3
46:	 pushThis 
47:	 rpushg loop%$57 1
-- scanInv: "c2 " 0 0 1 
-- OG:gen: true Veq.get[inx]
-- OG:before:super.gen: "Veq.get[inx]" 
49:	 pushThis 
50:	 rpushg loop%$57 1
52:	 rpushg matchEq%$53 1
54:	 rpushg loop%$49 1
-- scanInv: "Veq.get[inx] " 0 1 2 
56:	 rpushg newInvoke 2
-- doInvoke: Veq.get[inx]1 2 useRtnVal: true 
-- scanInv: "Veq.get[inx] " 1 2 2 
-- doInvoke:X: get[inx]1 2 2 pRec: none rec: Veq ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "Veq " rec.ATd: "
 --  in Veq: var this(Value) " 18 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
58:	 pushThis 
59:	 rpushg loop%$57 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
61:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
63:	 xpushg  inx 1 0
66:	 storeg char%$7 4
-- OG:gen: true 
-- if (c1 = c2) :then  \
--    if (inx < L) :then  \
--       restart(loop)
-- OG:before:super.gen: "if (c1 = c2) :then  \
--    if (inx < L) :then  \
--       restart(loop)" 
-- doInvoke: 
-- if (c1 = c2) :then  \
--    if (inx < L) :then  \
--       restart(loop)0 1 useRtnVal: false 
-- scanInv: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  0 1 1 
-- doInvoke:X: 
-- if (c1 = c2) :then  \
--    if (inx < L) :then  \
--       restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (c1 = c2) :then  \
--    if (inx < L) :then  \
--       restart(loop)
-- koks:Y: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
-- OG:gen: true (c1 = c2)
-- OG:before:super.gen: "(c1 = c2)" 
68:	 pushThis 
69:	 rpushg loop%$57 1
-- scanInv: "(c1 = c2) " 0 1 2 
71:	 pushg 3 newInvoke
-- doInvoke: (c1 = c2)1 2 useRtnVal: true 
-- scanInv: "(c1 = c2) " 1 2 2 
-- doInvoke:X: = c21 2 2 pRec: none rec: c1 ix->next none 
-- checkForProxy:E: "= c2 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " rec.ATd: "c1: var char " 3 false pRec: 
 --  none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = c2
-- koks:Y: "= c2 " 
-- ptn:loadArgs:E: = c2
-- args: c2
-- E.arg: "ObjectDescriptor" c2 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: c2 
-- OG:gen: true c2
-- gen:whatIsThis? 
-- OG:before:super.gen: "c2" 
73:	 pushThis 
74:	 rpushg loop%$57 1
-- scanInv: "c2 " 0 0 1 
-- doInvoke: c20 1 useRtnVal: true 
-- scanInv: "c2 " 0 1 1 
-- doInvoke:X: c20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "c2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
-- kuk:X: c2
-- koks:Y: "c2 " 
-- ptn:loadArgs:E: c2
-- args: 
-- ptn:loadArgs:end: 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- OI:newInvoke: "c2 " 
-- DI:newInvoke: "c2: var char " off: 3 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
76:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true c2: var char
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= c2 " 
78:	 eq 
79:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- if (inx < L) :then  \
--       restart(loop)
-- before:isDerived 
82:	 pushThis 
83:	 invoke loop>$58 58 0 0
89:	 rpop 
L4:
L2:
90:	 setThisStack  
91:	 pushThis 
92:	 rtn D
94:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>$58 descNo: 58 isValue: false 
-- Items:GenClass: loop>$58 descNo: 22 isValue: false 

CLASS loop>$58 dNo:58 topDno:58 orgOff:1 orgId:loop orgDno:57
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- if (inx < L) :then  \
--    restart(loop)
4:	 allocEventQ 
-- 1 58 true 
-- VDTentry: vdtAdd: inx=1 descInx=58 vDescInx=58 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- if (inx < L) :then  \
--    restart(loop)
-- OG:before:super.gen: "if (inx < L) :then  \
--    restart(loop)" 
-- doInvoke: 
-- if (inx < L) :then  \
--    restart(loop)0 1 useRtnVal: false 
-- scanInv: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  0 1 1 
-- doInvoke:X: 
-- if (inx < L) :then  \
--    restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (inx < L) :then  \
--    restart(loop)
-- koks:Y: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
-- OG:gen: true (inx < L)
-- OG:before:super.gen: "(inx < L)" 
11:	 pushThis 
12:	 rpushg loop>$58%$58 1
14:	 rpushg loop%$57 1
-- scanInv: "(inx < L) " 0 1 2 
16:	 pushg 2 newInvoke
-- doInvoke: (inx < L)1 2 useRtnVal: true 
-- scanInv: "(inx < L) " 1 2 2 
-- doInvoke:X: < L1 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "< L " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " rec.ATd: "inx: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: < L
-- koks:Y: "< L " 
-- ptn:loadArgs:E: < L
-- args: L
-- E.arg: "ObjectDescriptor" L 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "< L " "ObjectInvocation_Binary " ActArg: "L "isValue: 
 --  false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L 
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
18:	 pushThis 
19:	 rpushg loop>$58%$58 1
21:	 rpushg loop%$57 1
23:	 rpushg matchEq%$53 1
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 1 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
25:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true L: var integer
-- ptn:loadArgs:end: 
-- <  :  \
--    %basic 51 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "< L " 
27:	 lt 
-- unitConv:after 
28:	 jmpFalse  L4
L3:
-- OG:gen: false restart(loop)
-- before:isDerived 
31:	 pushThis 
32:	 invoke loop>$58>$59 59 0 0
38:	 rpop 
L4:
L2:
39:	 setThisStack  
40:	 pushThis 
41:	 rtn D
43:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>$58>$59 descNo: 59 isValue: false 
-- Items:GenClass: loop>$58>$59 descNo: 22 isValue: false 

CLASS loop>$58>$59 dNo:59 topDno:59 orgOff:1 orgId:loop>$58 orgDno:58
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: restart(loop)
4:	 allocEventQ 
-- 1 59 true 
-- VDTentry: vdtAdd: inx=1 descInx=59 vDescInx=59 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true restart(loop)
-- OG:before:super.gen: "restart(loop)" 
-- scanInv: "restart(loop) " 0 0 1 
-- doInvoke: restart(loop)0 1 useRtnVal: false 
-- scanInv: "restart(loop) " 0 1 1 
-- doInvoke:X: restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "restart(loop) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: restart(loop)
-- koks:Y: "restart(loop) " 
-- ptn:loadArgs:end: 
-- restart(V: var integer):  -- odd parameter type! \
--    %basic 102
-- OI:newInvoke: "restart(loop) " 
11:	 break  2 1 57 0
L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: doit descNo: 60 isValue: false 
-- Items:GenClass: doit descNo: 22 isValue: false 

CLASS doit dNo:60 topDno:60 orgOff:1 orgId:matchEq orgDno:53
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- if (c1 = c2) :then  \
--    Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq)
4:	 allocEventQ 
-- 1 60 true 
-- VDTentry: vdtAdd: inx=1 descInx=60 vDescInx=60 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- if (c1 = c2) :then  \
--    Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq)
-- OG:before:super.gen: "if (c1 = c2) :then  \
--    Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq) \
-- :else  \
--    Beq := c1 < c2 \
--    leave(matchEq)" 
-- doInvoke: 
-- if (c1 = c2) :then  \
--    Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq)0 1 useRtnVal: false 
-- scanInv: 
 --  if (c1 = c2) :then 
 --     Beq
 --                       -- we have inx = L := L1 <= L2
 --     leave(matchEq)0 1 1 
-- doInvoke:X: 
-- if (c1 = c2) :then  \
--    Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (c1 = c2) :then 
 --     Beq
 --                       -- we have inx = L := L1 <= L2
 --     leave(matchEq)isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (c1 = c2) :then  \
--    Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq)
-- koks:Y: 
 --  if (c1 = c2) :then 
 --     Beq
 --                       -- we have inx = L := L1 <= L2
 --     leave(matchEq)
-- OG:gen: true (c1 = c2)
-- OG:before:super.gen: "(c1 = c2)" 
11:	 pushThis 
12:	 rpushg doit%$60 1
-- scanInv: "(c1 = c2) " 0 1 2 
14:	 pushg 3 newInvoke
-- doInvoke: (c1 = c2)1 2 useRtnVal: true 
-- scanInv: "(c1 = c2) " 1 2 2 
-- doInvoke:X: = c21 2 2 pRec: none rec: c1 ix->next none 
-- checkForProxy:E: "= c2 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " rec.ATd: "c1: var char " 3 false pRec: 
 --  none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = c2
-- koks:Y: "= c2 " 
-- ptn:loadArgs:E: = c2
-- args: c2
-- E.arg: "ObjectDescriptor" c2 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: c2 
-- OG:gen: true c2
-- gen:whatIsThis? 
-- OG:before:super.gen: "c2" 
16:	 pushThis 
17:	 rpushg doit%$60 1
-- scanInv: "c2 " 0 0 1 
-- doInvoke: c20 1 useRtnVal: true 
-- scanInv: "c2 " 0 1 1 
-- doInvoke:X: c20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "c2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
-- kuk:X: c2
-- koks:Y: "c2 " 
-- ptn:loadArgs:E: c2
-- args: 
-- ptn:loadArgs:end: 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- OI:newInvoke: "c2 " 
-- DI:newInvoke: "c2: var char " off: 3 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
19:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true c2: var char
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= c2 " 
21:	 eq 
22:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- Beq \
--                      -- we have inx = L := L1 <= L2 \
--    leave(matchEq)
-- before:isDerived 
25:	 pushThis 
26:	 invoke doit>$61 61 0 0
32:	 rpop 
33:	 jmp L5
L4:
-- OG:gen: false 
-- Beq := c1 < c2 \
--    leave(matchEq)
-- before:isDerived 
36:	 pushThis 
37:	 invoke doit>$62 62 0 0
43:	 rpop 
L5:
L2:
44:	 setThisStack  
45:	 pushThis 
46:	 rtn D
48:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: doit>$61 descNo: 61 isValue: false 
-- Items:GenClass: doit>$61 descNo: 22 isValue: false 

CLASS doit>$61 dNo:61 topDno:61 orgOff:1 orgId:doit orgDno:60
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- Beq \
--                      -- we have inx = L := L1 <= L2 \
-- leave(matchEq)
4:	 allocEventQ 
-- 1 61 true 
-- VDTentry: vdtAdd: inx=1 descInx=61 vDescInx=61 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg doit>$61%$61 1
14:	 rpushg doit%$60 1
16:	 rpushg matchEq%$53 1
18:	 rpushg loop%$49 1
-- scanInv: 
 --  Beq
 --                       -- we have inx = L
 --  0 0 1 
-- OG:gen: true L1 <= L2
-- OG:before:super.gen: "L1 <= L2" 
20:	 pushThis 
21:	 rpushg doit>$61%$61 1
23:	 rpushg doit%$60 1
25:	 rpushg matchEq%$53 1
-- scanInv: "L1 <= L2 " 0 1 2 
27:	 pushg 3 newInvoke
-- doInvoke: L1 <= L21 2 useRtnVal: true 
-- scanInv: "L1 <= L2 " 1 2 2 
-- doInvoke:X: <= L21 2 2 pRec: none rec: L1 ix->next none 
-- checkForProxy:E: "<= L2 " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "L1 " rec.ATd: "L1: var integer " 1 
 --  false pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: <= L2
-- koks:Y: "<= L2 " 
-- ptn:loadArgs:E: <= L2
-- args: L2
-- E.arg: "ObjectDescriptor" L2 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: L2 
-- OG:gen: true L2
-- gen:whatIsThis? 
-- OG:before:super.gen: "L2" 
29:	 pushThis 
30:	 rpushg doit>$61%$61 1
32:	 rpushg doit%$60 1
34:	 rpushg matchEq%$53 1
-- scanInv: "L2 " 0 0 1 
-- doInvoke: L20 1 useRtnVal: true 
-- scanInv: "L2 " 0 1 1 
-- doInvoke:X: L20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
-- kuk:X: L2
-- koks:Y: "L2 " 
-- ptn:loadArgs:E: L2
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L2 " 
-- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
36:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true L2: var integer
-- ptn:loadArgs:end: 
-- <=  :<  \
--    %basic 52 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "<= L2 " 
38:	 le 
39:	 storeg Boolean%$41 3
-- OG:gen: true leave(matchEq)
-- OG:before:super.gen: "leave(matchEq)" 
-- scanInv: "leave(matchEq) " 0 0 1 
-- doInvoke: leave(matchEq)0 1 useRtnVal: false 
-- scanInv: "leave(matchEq) " 0 1 1 
-- doInvoke:X: leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(matchEq)
-- koks:Y: "leave(matchEq) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(matchEq) " 
41:	 break  2 2 53 0
L2:
48:	 setThisStack  
49:	 pushThis 
50:	 rtn D
52:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: doit>$62 descNo: 62 isValue: false 
-- Items:GenClass: doit>$62 descNo: 22 isValue: false 

CLASS doit>$62 dNo:62 topDno:62 orgOff:1 orgId:doit orgDno:60
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- Beq := c1 < c2 \
-- leave(matchEq)
4:	 allocEventQ 
-- 1 62 true 
-- VDTentry: vdtAdd: inx=1 descInx=62 vDescInx=62 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg doit>$62%$62 1
14:	 rpushg doit%$60 1
16:	 rpushg matchEq%$53 1
18:	 rpushg loop%$49 1
-- scanInv: "Beq " 0 0 1 
-- OG:gen: true c1 < c2
-- OG:before:super.gen: "c1 < c2" 
20:	 pushThis 
21:	 rpushg doit>$62%$62 1
23:	 rpushg doit%$60 1
-- scanInv: "c1 < c2 " 0 1 2 
25:	 pushg 3 newInvoke
-- doInvoke: c1 < c21 2 useRtnVal: true 
-- scanInv: "c1 < c2 " 1 2 2 
-- doInvoke:X: < c21 2 2 pRec: none rec: c1 ix->next none 
-- checkForProxy:E: "< c2 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " rec.ATd: "c1: var char " 3 false pRec: 
 --  none E.origin: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
-- kuk:X: < c2
-- koks:Y: "< c2 " 
-- ptn:loadArgs:E: < c2
-- args: c2
-- E.arg: "ObjectDescriptor" c2 
-- arg: in V: var char 1 1 false 
-- E.arg: in V: var char 
-- NonVirt: "< c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: c2 
-- OG:gen: true c2
-- gen:whatIsThis? 
-- OG:before:super.gen: "c2" 
27:	 pushThis 
28:	 rpushg doit>$62%$62 1
30:	 rpushg doit%$60 1
-- scanInv: "c2 " 0 0 1 
-- doInvoke: c20 1 useRtnVal: true 
-- scanInv: "c2 " 0 1 1 
-- doInvoke:X: c20 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "c2 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
-- kuk:X: c2
-- koks:Y: "c2 " 
-- ptn:loadArgs:E: c2
-- args: 
-- ptn:loadArgs:end: 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- OI:newInvoke: "c2 " 
-- DI:newInvoke: "c2: var char " off: 3 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
32:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true c2: var char
-- ptn:loadArgs:end: 
-- <  :  \
--    %basic 51 \
--    in V: var char \
--    out B: var boolean
-- OI:newInvoke: "< c2 " 
34:	 lt 
-- unitConv:after 
35:	 storeg Boolean%$41 3
-- OG:gen: true leave(matchEq)
-- OG:before:super.gen: "leave(matchEq)" 
-- scanInv: "leave(matchEq) " 0 0 1 
-- doInvoke: leave(matchEq)0 1 useRtnVal: false 
-- scanInv: "leave(matchEq) " 0 1 1 
-- doInvoke:X: leave(matchEq)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(matchEq)
-- koks:Y: "leave(matchEq) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(matchEq) " 
37:	 break  2 2 53 0
L2:
44:	 setThisStack  
45:	 pushThis 
46:	 rtn D
48:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: puttext descNo: 64 isValue: false 
-- Items:GenClass: puttext descNo: 22 isValue: false 

CLASS puttext dNo:64 topDno:64 orgOff:1 orgId:ConsoleIF orgDno:8
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 rstoreg T 2
4:	 tstOriginIsNone 
5:	 rstore  1 origin
-- AllocateSuper: inner(puttext)
7:	 allocEventQ 
-- 1 64 true 
-- VDTentry: vdtAdd: inx=1 descInx=64 vDescInx=64 vdtTop: 1 
9:	 mvStack 
10:	 rtnAlloc 1
DO:
12:	 doEventQ 
13:	 mvStack 
L1:
-- OG:gen: true inner(puttext)
-- OG:before:super.gen: "inner(puttext)" 
-- scanInv: "inner(puttext) " 0 0 1 
-- doInvoke: inner(puttext)0 1 useRtnVal: false 
-- scanInv: "inner(puttext) " 0 1 1 
-- doInvoke:X: inner(puttext)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(puttext) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(puttext)
-- koks:Y: "inner(puttext) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(puttext) " 
14:	 pushThis 
15:	 innerP  2
17:	 rpopThisObj  L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:2 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=64 vDescInx=0 vdtTop: 2 
-- Items:GenClass: putint descNo: 65 isValue: false 
-- Items:GenClass: putint descNo: 22 isValue: false 

CLASS putint dNo:65 topDno:65 orgOff:1 orgId:ConsoleIF orgDno:8
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 2
4:	 tstOriginIsNone 
5:	 rstore  1 origin
-- AllocateSuper: inner(putint)
7:	 allocEventQ 
-- 1 65 true 
-- VDTentry: vdtAdd: inx=1 descInx=65 vDescInx=65 vdtTop: 1 
9:	 mvStack 
10:	 rtnAlloc 1
DO:
12:	 doEventQ 
13:	 mvStack 
L1:
-- OG:gen: true inner(putint)
-- OG:before:super.gen: "inner(putint)" 
-- scanInv: "inner(putint) " 0 0 1 
-- doInvoke: inner(putint)0 1 useRtnVal: false 
-- scanInv: "inner(putint) " 0 1 1 
-- doInvoke:X: inner(putint)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(putint) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(putint)
-- koks:Y: "inner(putint) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(putint) " 
14:	 pushThis 
15:	 innerP  2
17:	 rpopThisObj  L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:2 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=65 vDescInx=0 vdtTop: 2 
-- Items:GenClass: workspace descNo: 66 isValue: false 
-- Items:GenClass: workspace descNo: 22 isValue: false 

CLASS workspace dNo:66 topDno:66 orgOff:1 orgId:BETAworld orgDno:1
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %id "workspace" \
-- %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib \
-- %domain_boundary \
-- --AbstractEx
4:	 allocEventQ 
-- 1 66 true 
-- VDTentry: vdtAdd: inx=1 descInx=66 vDescInx=66 vdtTop: 1 
6:	 mvStack 
-- OG:gen: false 
-- %id "demo" \
--    --AnimalMonitorSystem \
-- --ArrayDemos \
-- --Bank
-- before:isDerived 
7:	 pushThis 
8:	 invoke demo 67 2 1
14:	 rpop 
15:	 rtnAlloc 1
DO:
17:	 doEventQ 
18:	 mvStack 
L1:
L2:
19:	 setThisStack  
20:	 pushThis 
21:	 rtn D
23:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: demo descNo: 67 isValue: false 
-- Items:GenClass: demo descNo: 22 isValue: false 

CLASS demo dNo:67 topDno:67 orgOff:1 orgId:workspace orgDno:66
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %id "demo" \
-- --AnimalMonitorSystem \
-- --ArrayDemos \
-- --Bank
4:	 allocEventQ 
-- 1 67 true 
-- VDTentry: vdtAdd: inx=1 descInx=67 vDescInx=67 vdtTop: 1 
6:	 mvStack 
-- OG:gen: false 
-- %include StringLib \
--    sSwitch: switch \
--       inner(sSwitch) \
--    "Break:\n".print
-- before:isDerived 
7:	 pushThis 
8:	 invoke Break 68 2 1
14:	 rpop 
15:	 rtnAlloc 1
DO:
17:	 doEventQ 
18:	 mvStack 
L1:
L2:
19:	 setThisStack  
20:	 pushThis 
21:	 rtn D
23:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break descNo: 68 isValue: false 
-- Items:GenClass: Break descNo: 22 isValue: false 

CLASS Break dNo:68 topDno:68 orgOff:1 orgId:demo orgDno:67
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %include StringLib \
-- sSwitch: switch \
--    inner(sSwitch) \
-- "Break:\n".print
4:	 allocEventQ 
-- 1 68 true 
-- VDTentry: vdtAdd: inx=1 descInx=68 vDescInx=68 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true "Break:\n".print
-- OG:before:super.gen: "Break:\n.print" 
11:	 pushText "Break:\n"
-- scanInv: ""Break:\n".print " 1 1 2 
-- doInvoke: "Break:\n".print1 2 useRtnVal: false 
-- scanInv: ""Break:\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Break:\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Break:\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
13:	 invoke print 69 0 0
19:	 rpop 
-- OG:gen: false 
-- switch(8) \
--    "Hello: ".print \
--    case(4) \
--       "Case-4\n".print
-- before:isDerived 
20:	 pushThis 
21:	 invoke Break>switch$74 74 0 0
27:	 rpop 
-- OG:gen: true "Done-1\n".print
-- OG:before:super.gen: "Done-1\n.print" 
28:	 pushText "Done-1\n"
-- scanInv: ""Done-1\n".print " 1 1 2 
-- doInvoke: "Done-1\n".print1 2 useRtnVal: false 
-- scanInv: ""Done-1\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Done-1\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Done-1\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
-- OG:gen: false 
-- sSwitch(7) \
--    case(1) \
--       "Case-1\n".print \
--    case(3)
-- before:isDerived 
37:	 pushThis 
38:	 invoke Break>sSwitch$85 85 0 0
44:	 rpop 
-- OG:gen: true "Done-2\n".print
-- OG:before:super.gen: "Done-2\n.print" 
45:	 pushText "Done-2\n"
-- scanInv: ""Done-2\n".print " 1 1 2 
-- doInvoke: "Done-2\n".print1 2 useRtnVal: false 
-- scanInv: ""Done-2\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Done-2\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Done-2\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
47:	 invoke print 69 0 0
53:	 rpop 
-- OG:gen: true 
-- for(1):to(6):repeat \
--    putint(inx) \
--    _put(':') \
--    switch(inx)
-- before:isDerived 
54:	 pushThis 
55:	 invoke Break>for:to:repeat$106 106 0 0
61:	 rpop 
-- OG:gen: true "\nDone-3\n".print
-- OG:before:super.gen: "\nDone-3\n.print" 
62:	 pushText "\nDone-3\n"
-- scanInv: ""\nDone-3\n".print " 1 1 2 
-- doInvoke: "\nDone-3\n".print1 2 useRtnVal: false 
-- scanInv: ""\nDone-3\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "\nDone-3\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""\nDone-3\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
64:	 invoke print 69 0 0
70:	 rpop 
-- OG:gen: true 
-- for(1):to(5):repeat \
--    switch(true) \
--       case(inx = 1) \
--          "inx = 1: ".print
-- before:isDerived 
71:	 pushThis 
72:	 invoke Break>for:to:repeat$111 111 0 0
78:	 rpop 
L2:
79:	 setThisStack  
80:	 pushThis 
81:	 rtn D
83:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: print descNo: 69 isValue: false 
-- Items:GenClass: print descNo: 22 isValue: false 

CLASS print dNo:69 topDno:69 orgOff:1 orgId:String orgDno:10
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- gogo:  \
--    "gogo\n".print \
-- for(1):to(length):repeat \
--    put(get[inx])
4:	 allocEventQ 
-- 1 69 true 
-- VDTentry: vdtAdd: inx=1 descInx=69 vDescInx=69 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- for(1):to(length):repeat \
--    put(get[inx]) \
-- 
-- before:isDerived 
11:	 pushThis 
12:	 invoke print>for:to:repeat$72 72 0 0
18:	 rpop 
L2:
19:	 setThisStack  
20:	 pushThis 
21:	 rtn D
23:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: print>for:to:repeat$72>repeat$70 descNo: 70 isValue: false 
-- Items:GenClass: print>for:to:repeat$72>repeat$70 descNo: 22 isValue: false 

CLASS print>for:to:repeat$72>repeat$70 dNo:70 topDno:70 orgOff:1 orgId:print>for:to:repeat$72 orgDno:72
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: put(get[inx])
4:	 allocEventQ 
-- 1 70 true 
-- VDTentry: vdtAdd: inx=1 descInx=70 vDescInx=70 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true put(get[inx])
-- OG:before:super.gen: "put(get[inx])" 
-- doInvoke: put(get[inx])0 1 useRtnVal: false 
-- scanInv: "put(get[inx]) " 0 1 1 
-- doInvoke:X: put(get[inx])0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "put(get[inx]) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: put(get[inx])
-- koks:Y: "put(get[inx]) " 
-- ptn:loadArgs:E: put(get[inx])
-- args: (get[inx])
-- E.arg: "ObjectDescriptor" get[inx] 
-- arg: in ch: val char 1 1 false 
-- E.arg: in ch: val char 
-- NonVirt: "put(get[inx]) " "ObjectInvocation_Function " ActArg: "
 --  get[inx] "isValue: false formalArg: "in ch: val char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: get[inx] 
-- OG:gen: true get[inx]
-- OG:before:super.gen: "get[inx]" 
11:	 pushThis 
12:	 rpushg print>for:to:repeat$72>repeat$70%$70 1
14:	 rpushg print>for:to:repeat$72%$72 4
16:	 rpushg print%$69 1
-- scanInv: "get[inx] " 0 0 1 
-- doInvoke: get[inx]0 1 useRtnVal: true 
-- scanInv: "get[inx] " 0 1 1 
-- doInvoke:X: get[inx]0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
18:	 pushThis 
19:	 rpushg print>for:to:repeat$72>repeat$70%$70 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
21:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
23:	 xpushg  inx 1 0
-- loadArgs:after:actualArg:gen: false false 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- ptn:loadArgs:end: 
-- put:  \
--    %globals \
--    %basic 2 \
--    in ch: val char
-- OI:newInvoke: "put(get[inx]) " 
26:	 %put 2
L2:
28:	 setThisStack  
29:	 pushThis 
30:	 rtn D
32:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: put descNo: 71 isValue: false 
-- Items:GenClass: put descNo: 22 isValue: false 

CLASS put dNo:71 topDno:71 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg char%$7 1
-- AllocateSuper: 
-- %globals \
-- %basic 2 \
-- in ch: val char
4:	 allocEventQ 
-- 1 71 true 
-- VDTentry: vdtAdd: inx=1 descInx=71 vDescInx=71 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: print>for:to:repeat$72 descNo: 72 isValue: false 
-- Items:GenClass: print>for:to:repeat$72 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS print>for:to:repeat$72 dNo:72 topDno:29 orgOff:4 orgId:print orgDno:69
-- VDTtableCopy: 29 75 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(length):repeat \
--    put(get[inx]) \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(length):repeat \
--    put(get[inx]) \
-- 
-- args: 
-- for(1):to(length):repeat \
--    put(get[inx]) \
-- 
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" length 
-- E.arg: "ObjectDescriptor" put(get[inx]) 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: length 
-- OG:gen: true length
-- OG:before:super.gen: "length" 
6:	 pushThis 
7:	 rpushg print%$69 4
9:	 rpushg print%$69 1
-- scanInv: "length " 0 0 1 
-- doInvoke: length0 1 useRtnVal: true 
-- scanInv: "length " 0 1 1 
-- doInvoke:X: length0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: "length " 
11:	 invoke length 16 0 0
17:	 pushg 2 
-- loadArgs:after:actualArg:gen: false false 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
19:	 pushThis 
20:	 storeg integer%$5 2
22:	 pushThis 
23:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
25:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=72 vDescInx=29 vdtTop: 2 
27:	 rtnAlloc 1
29:	 toSuper  29
DO:
32:	 mvStack 
L1:
L2:
33:	 rtnInner  M
34:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 70 false 
-- VDTentry: vdtAdd: inx=2 descInx=72 vDescInx=70 vdtTop: 2 
-- Items:GenClass: switch descNo: 73 isValue: false 
-- Items:GenClass: switch descNo: 22 isValue: false 

CLASS switch dNo:73 topDno:73 orgOff:1 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 2
4:	 tstOriginIsNone 
5:	 rstore  1 origin
-- AllocateSuper: 
-- in V: var integer \
-- %public \
-- case:  \
--    in x: ref Indexed(1,#Integer)
7:	 allocEventQ 
-- 1 73 true 
-- VDTentry: vdtAdd: inx=1 descInx=73 vDescInx=73 vdtTop: 1 
9:	 mvStack 
10:	 rtnAlloc 1
DO:
12:	 doEventQ 
13:	 mvStack 
L1:
-- OG:gen: true inner(switch)
-- OG:before:super.gen: "inner(switch)" 
-- scanInv: "inner(switch) " 0 0 1 
-- doInvoke: inner(switch)0 1 useRtnVal: false 
-- scanInv: "inner(switch) " 0 1 1 
-- doInvoke:X: inner(switch)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(switch) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(switch)
-- koks:Y: "inner(switch) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(switch) " 
14:	 pushThis 
15:	 innerP  2
17:	 rpopThisObj  L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:2 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=73 vDescInx=0 vdtTop: 2 
-- Items:GenClass: Break>switch$74 descNo: 74 isValue: false 
-- Items:GenClass: Break>switch$74 descNo: 73 isValue: false 
-- Items:GenClass: switch descNo: 22 isValue: false 

CLASS Break>switch$74 dNo:74 topDno:73 orgOff:3 orgId:Break orgDno:68
-- VDTtableCopy: 73 75 
-- vdtTableCopy: I:1:73 I:2:0 
-- 2 74 true 
-- VDTentry: vdtAdd: inx=2 descInx=74 vDescInx=74 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  3 origin
-- AllocateSuper: 
-- "Hello: ".print \
-- case(4) \
--    "Case-4\n".print \
-- "world!\n".print
-- op:super switch
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break%$68 3
7:	 rpushg Break%$68 1
9:	 rpushg demo%$67 1
11:	 rpushg workspace%$66 1
13:	 rpushg BETA 2
-- scanInv: "switch(8) " 0 0 1 
-- handleSuperArgs:E: "switch(8)" theIS: 
-- "Hello: ".print \
-- case(4) \
--    "Case-4\n".print \
-- "world!\n".print
-- super.sig:none:superAdj: 3 
-- ptn:loadArgs:E: switch(8)
-- args: switch(8)
-- E.arg: "ObjectDescriptor" 8 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "switch(8) " "ObjectInvocation_KeyWord " ActArg: "8 "
 --  isValue: true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 8 
-- OG:gen: true 8
-- OG:before:super.gen: "8" 
15:	 pushc 8
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- switch:  \
--    in V: var integer \
--    %public \
--    case: 
-- handleArgumentsAndOrigin: 
17:	 pushThis 
18:	 storeg integer%$5 2
20:	 tstOriginIsNone 
21:	 rstore  1 origin
-- AllocateSuper: 
-- in V: var integer \
-- %public \
-- case:  \
--    in x: ref Indexed(1,#Integer)
23:	 allocEventQ 
-- 1 73 true 
-- VDTentry: vdtAdd: inx=1 descInx=74 vDescInx=73 vdtTop: 2 
25:	 rtnAlloc 1
27:	 toSuper  73
DO:
30:	 mvStack 
L1:
-- OG:gen: true "Hello: ".print
-- OG:before:super.gen: "Hello: .print" 
31:	 pushText "Hello: "
-- scanInv: ""Hello: ".print " 1 1 2 
-- doInvoke: "Hello: ".print1 2 useRtnVal: false 
-- scanInv: ""Hello: ".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Hello: " ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Hello: " " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
33:	 invoke print 69 0 0
39:	 rpop 
-- OG:gen: false 
-- case(4) \
--    "Case-4\n".print
-- before:isDerived 
40:	 pushThis 
41:	 invoke Break>switch$74>case$81 81 0 0
47:	 rpop 
-- OG:gen: true "world!\n".print
-- OG:before:super.gen: "world!\n.print" 
48:	 pushText "world!\n"
-- scanInv: ""world!\n".print " 1 1 2 
-- doInvoke: "world!\n".print1 2 useRtnVal: false 
-- scanInv: ""world!\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "world!\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""world!\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
50:	 invoke print 69 0 0
56:	 rpop 
-- OG:gen: false 
-- case(8) \
--    "Case-8\n".print
-- before:isDerived 
57:	 pushThis 
58:	 invoke Break>switch$74>case$82 82 0 0
64:	 rpop 
-- OG:gen: true "We do not come here\n".print
-- OG:before:super.gen: "We do not come here\n.print" 
65:	 pushText "We do not come here\n"
-- scanInv: ""We do not come here\n".print " 1 1 2 
-- doInvoke: "We do not come here\n".print1 2 useRtnVal: false 
-- scanInv: ""We do not come here\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "We do not come here\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""We do not come here\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
67:	 invoke print 69 0 0
73:	 rpop 
-- OG:gen: false 
-- case(12) \
--    "Case-12\n".print
-- before:isDerived 
74:	 pushThis 
75:	 invoke Break>switch$74>case$83 83 0 0
81:	 rpop 
L2:
82:	 rtnInner  M
83:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: case descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS case dNo:75 topDno:75 orgOff:1 orgId:switch orgDno:73
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 rstoreg x 2
4:	 tstOriginIsNone 
5:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
7:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=75 vDescInx=75 vdtTop: 1 
9:	 mvStack 
10:	 rtnAlloc 1
DO:
12:	 doEventQ 
13:	 mvStack 
L1:
-- OG:gen: true 
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case) \
--       leave(switch)
-- before:isDerived 
14:	 pushThis 
15:	 invoke case>for:to:repeat$80 80 0 0
21:	 rpop 
L2:
22:	 setThisStack  
23:	 pushThis 
24:	 rtn D
26:	 END OSDV:0 objSize:2 isIndexed:0
-- 2 0 true 
-- VDTentry: vdtAdd: inx=2 descInx=75 vDescInx=0 vdtTop: 2 
-- Items:GenClass: Indexed descNo: 91 isValue: false 
-- Items:GenClass: Indexed descNo: 22 isValue: false 

CLASS Indexed dNo:91 topDno:91 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 1
-- AllocateSuper: 
-- %globals \
-- %basic 114 \
-- %public \
-- in range: var Integer
4:	 allocEventQ 
-- 1 91 true 
-- VDTentry: vdtAdd: inx=1 descInx=91 vDescInx=91 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:1
-- Items:GenClass: length descNo: 76 isValue: false 
-- Items:GenClass: length descNo: 22 isValue: false 

CLASS length dNo:76 topDno:76 orgOff:1 orgId:Indexed orgDno:91
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- out res: var integer \
-- res := get[-1]
4:	 allocEventQ 
-- 1 76 true 
-- VDTentry: vdtAdd: inx=1 descInx=76 vDescInx=76 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
-- scanInv: "res " 0 0 1 
-- OG:gen: true get[-1]
-- OG:before:super.gen: "get[-1]" 
12:	 pushThis 
13:	 rpushg length%$76 1
-- scanInv: "get[-1] " 0 0 1 
-- doInvoke: get[-1]0 1 useRtnVal: true 
-- scanInv: "get[-1] " 0 1 1 
-- doInvoke:X: get[-1]0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "get[-1] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: get[-1]
-- koks:Y: "get[-1] " 
-- ptn:loadArgs:E: get[-1]
-- args: get[-1]
-- E.arg: "ObjectDescriptor" -1 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[-1] " "ObjectInvocation_KeyWord " ActArg: "-1 "
 --  isValue: true formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: -1 
-- OG:gen: true -1
-- OG:before:super.gen: "-1" 
-- doInvoke: -10 1 useRtnVal: true 
-- scanInv: "-1 " 0 1 1 
-- doInvoke:X: -10 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "-1 " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: -1
-- koks:Y: "-1 " 
15:	 pushc 1
17:	 uminus 
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- OI:newInvoke: "get[-1] " 
18:	 xpushg  inx 1 0
21:	 storeg integer%$5 2
L2:
23:	 setThisStack  
24:	 pushThis 
25:	 rtn D
27:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: case>for:to:repeat$80>repeat$78 descNo: 78 isValue: false 
-- Items:GenClass: case>for:to:repeat$80>repeat$78 descNo: 22 isValue: false 

CLASS case>for:to:repeat$80>repeat$78 dNo:78 topDno:78 orgOff:1 orgId:case>for:to:repeat$80 orgDno:80
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- if (V = x.get[inx]) :then  \
--    inner(case) \
--    leave(switch)
4:	 allocEventQ 
-- 1 78 true 
-- VDTentry: vdtAdd: inx=1 descInx=78 vDescInx=78 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- if (V = x.get[inx]) :then  \
--    inner(case) \
--    leave(switch)
-- OG:before:super.gen: "if (V = x.get[inx]) :then  \
--    inner(case) \
--    leave(switch)" 
-- doInvoke: 
-- if (V = x.get[inx]) :then  \
--    inner(case) \
--    leave(switch)0 1 useRtnVal: false 
-- scanInv: 
 --  if (V = x.get[inx]) :then 
 --     inner(case)
 --     leave(switch)
 --  0 1 1 
-- doInvoke:X: 
-- if (V = x.get[inx]) :then  \
--    inner(case) \
--    leave(switch)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (V = x.get[inx]) :then 
 --     inner(case)
 --     leave(switch)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (V = x.get[inx]) :then  \
--    inner(case) \
--    leave(switch)
-- koks:Y: 
 --  if (V = x.get[inx]) :then 
 --     inner(case)
 --     leave(switch)
 --  
-- OG:gen: true (V = x.get[inx])
-- OG:before:super.gen: "(V = x.get[inx])" 
11:	 pushThis 
12:	 rpushg case>for:to:repeat$80>repeat$78%$78 1
14:	 rpushg case>for:to:repeat$80%$80 4
16:	 rpushg case%$75 1
-- scanInv: "(V = x.get[inx]) " 0 1 2 
18:	 pushg 2 newInvoke
-- doInvoke: (V = x.get[inx])1 2 useRtnVal: true 
-- scanInv: "(V = x.get[inx]) " 1 2 2 
-- doInvoke:X: = x.get[inx]1 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "= x.get[inx] " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 
 --  false pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = x.get[inx]
-- koks:Y: "= x.get[inx] " 
-- ptn:loadArgs:E: = x.get[inx]
-- args: x.get[inx]
-- E.arg: "ObjectDescriptor" x.get[inx] 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= x.get[inx] " "ObjectInvocation_Binary " ActArg: "
 --  x.get[inx] "isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: x.get[inx] 
-- OG:gen: true x.get[inx]
-- OG:before:super.gen: "x.get[inx]" 
20:	 pushThis 
21:	 rpushg case>for:to:repeat$80>repeat$78%$78 1
23:	 rpushg case>for:to:repeat$80%$80 4
-- scanInv: "x.get[inx] " 0 1 2 
25:	 rpushg newInvoke 2
-- doInvoke: x.get[inx]1 2 useRtnVal: true 
-- scanInv: "x.get[inx] " 1 2 2 
-- doInvoke:X: get[inx]1 2 2 pRec: none rec: x ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "x " rec.ATd: "
 --  in x: ref Indexed(1,#Integer) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
27:	 pushThis 
28:	 rpushg case>for:to:repeat$80>repeat$78%$78 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
30:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- OI:newInvoke: "get[inx] " 
-- getIndexedArgs:rec.ATd: in x: ref Indexed(1,#Integer)
32:	 xpushg  inx 1 0
-- loadArgs:after:actualArg:gen: false false 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= x.get[inx] " 
35:	 eq 
36:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- inner(case) \
--    leave(switch)
-- before:isDerived 
39:	 pushThis 
40:	 invoke case>for:to:repeat$80>repeat$78>$79 79 0 0
46:	 rpop 
L4:
L2:
47:	 setThisStack  
48:	 pushThis 
49:	 rtn D
51:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: case>for:to:repeat$80>repeat$78>$79 descNo: 79 isValue: false 
-- Items:GenClass: case>for:to:repeat$80>repeat$78>$79 descNo: 22 isValue: false 

CLASS case>for:to:repeat$80>repeat$78>$79 dNo:79 topDno:79 orgOff:1 orgId:case>for:to:repeat$80>repeat$78 orgDno:78
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- inner(case) \
-- leave(switch)
4:	 allocEventQ 
-- 1 79 true 
-- VDTentry: vdtAdd: inx=1 descInx=79 vDescInx=79 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true inner(case)
-- OG:before:super.gen: "inner(case)" 
-- scanInv: "inner(case) " 0 0 1 
-- doInvoke: inner(case)0 1 useRtnVal: false 
-- scanInv: "inner(case) " 0 1 1 
-- doInvoke:X: inner(case)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(case) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(case)
-- koks:Y: "inner(case) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(case) " 
11:	 pushThis 
12:	 rpushg case>for:to:repeat$80>repeat$78>$79%$79 1
14:	 rpushg case>for:to:repeat$80>repeat$78%$78 1
16:	 rpushg case>for:to:repeat$80%$80 4
18:	 innerP  2
20:	 rpopThisObj  -- OG:gen: true leave(switch)
-- OG:before:super.gen: "leave(switch)" 
-- scanInv: "leave(switch) " 0 0 1 
-- doInvoke: leave(switch)0 1 useRtnVal: false 
-- scanInv: "leave(switch) " 0 1 1 
-- doInvoke:X: leave(switch)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "leave(switch) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: leave(switch)
-- koks:Y: "leave(switch) " 
-- ptn:loadArgs:end: 
-- leave(V: var integer):  \
--    %basic 103
-- OI:newInvoke: "leave(switch) " 
21:	 break  4 2 73 0
L2:
28:	 setThisStack  
29:	 pushThis 
30:	 rtn D
32:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: case>for:to:repeat$80 descNo: 80 isValue: false 
-- Items:GenClass: case>for:to:repeat$80 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS case>for:to:repeat$80 dNo:80 topDno:29 orgOff:4 orgId:case orgDno:75
-- VDTtableCopy: 29 94 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case) \
--       leave(switch) \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case) \
--       leave(switch)
-- args: 
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case) \
--       leave(switch)
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" x.length 
-- E.arg: "ObjectDescriptor" if (V = x.get[inx]) :then  \
--       inner(case) \
--       leave(switch) 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(x.length):repeat
 --     if (V = x.get[inx]) :then 
 --        inner(case)
 --        leave(switch)"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(x.length):repeat
 --     if (V = x.get[inx]) :then 
 --        inner(case)
 --        leave(switch)"ObjectInvocation_KeyWord " ActArg: "x.length "isValue: false 
 --  formalArg: "last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: x.length 
-- OG:gen: true x.length
-- OG:before:super.gen: "x.length" 
6:	 pushThis 
7:	 rpushg case%$75 4
-- scanInv: "x.length " 0 1 2 
9:	 rpushg newInvoke 2
-- doInvoke: x.length1 2 useRtnVal: true 
-- scanInv: "x.length " 1 2 2 
-- doInvoke:X: length1 2 2 pRec: none rec: x ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "x " rec.ATd: "
 --  in x: ref Indexed(1,#Integer) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out res: var integer \
--    res := get[-1]
-- OI:newInvoke: "length " 
11:	 invoke length 76 0 0
17:	 pushg 2 
-- loadArgs:after:actualArg:gen: false false 
-- length:  \
--    out res: var integer \
--    res := get[-1]
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
19:	 pushThis 
20:	 storeg integer%$5 2
22:	 pushThis 
23:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
25:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=80 vDescInx=29 vdtTop: 2 
27:	 rtnAlloc 1
29:	 toSuper  29
DO:
32:	 mvStack 
L1:
L2:
33:	 rtnInner  M
34:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 78 false 
-- VDTentry: vdtAdd: inx=2 descInx=80 vDescInx=78 vdtTop: 2 
-- Items:GenClass: Break>switch$74>case$81 descNo: 81 isValue: false 
-- Items:GenClass: Break>switch$74>case$81 descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>switch$74>case$81 dNo:81 topDno:75 orgOff:1 orgId:Break>switch$74 orgDno:74
-- VDTtableCopy: 75 94 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 81 true 
-- VDTentry: vdtAdd: inx=2 descInx=81 vDescInx=81 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "Case-4\n".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>switch$74%$74 1
-- scanInv: "case(4) " 0 0 1 
-- handleSuperArgs:E: "case(4)" theIS: "Case-4\n".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(4)
-- args: case(4)
-- E.arg: "ObjectDescriptor" 4 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(4) " "ObjectInvocation_KeyWord " ActArg: "4 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 4 
-- OG:gen: true 4
-- OG:before:super.gen: "4" 
7:	 pushc 4
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  4   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=81 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true "Case-4\n".print
-- OG:before:super.gen: "Case-4\n.print" 
28:	 pushText "Case-4\n"
-- scanInv: ""Case-4\n".print " 1 1 2 
-- doInvoke: "Case-4\n".print1 2 useRtnVal: false 
-- scanInv: ""Case-4\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Case-4\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Case-4\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
L2:
37:	 rtnInner  M
38:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>switch$74>case$82 descNo: 82 isValue: false 
-- Items:GenClass: Break>switch$74>case$82 descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>switch$74>case$82 dNo:82 topDno:75 orgOff:1 orgId:Break>switch$74 orgDno:74
-- VDTtableCopy: 75 94 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 82 true 
-- VDTentry: vdtAdd: inx=2 descInx=82 vDescInx=82 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "Case-8\n".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>switch$74%$74 1
-- scanInv: "case(8) " 0 0 1 
-- handleSuperArgs:E: "case(8)" theIS: "Case-8\n".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(8)
-- args: case(8)
-- E.arg: "ObjectDescriptor" 8 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(8) " "ObjectInvocation_KeyWord " ActArg: "8 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 8 
-- OG:gen: true 8
-- OG:before:super.gen: "8" 
7:	 pushc 8
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  8   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=82 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true "Case-8\n".print
-- OG:before:super.gen: "Case-8\n.print" 
28:	 pushText "Case-8\n"
-- scanInv: ""Case-8\n".print " 1 1 2 
-- doInvoke: "Case-8\n".print1 2 useRtnVal: false 
-- scanInv: ""Case-8\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Case-8\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Case-8\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
L2:
37:	 rtnInner  M
38:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>switch$74>case$83 descNo: 83 isValue: false 
-- Items:GenClass: Break>switch$74>case$83 descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>switch$74>case$83 dNo:83 topDno:75 orgOff:1 orgId:Break>switch$74 orgDno:74
-- VDTtableCopy: 75 94 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 83 true 
-- VDTentry: vdtAdd: inx=2 descInx=83 vDescInx=83 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "Case-12\n".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>switch$74%$74 1
-- scanInv: "case(12) " 0 0 1 
-- handleSuperArgs:E: "case(12)" theIS: "Case-12\n".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(12)
-- args: case(12)
-- E.arg: "ObjectDescriptor" 12 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(12) " "ObjectInvocation_KeyWord " ActArg: "12 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 12 
-- OG:gen: true 12
-- OG:before:super.gen: "12" 
7:	 pushc 12
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  12   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=83 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true "Case-12\n".print
-- OG:before:super.gen: "Case-12\n.print" 
28:	 pushText "Case-12\n"
-- scanInv: ""Case-12\n".print " 1 1 2 
-- doInvoke: "Case-12\n".print1 2 useRtnVal: false 
-- scanInv: ""Case-12\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Case-12\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Case-12\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
L2:
37:	 rtnInner  M
38:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: sSwitch descNo: 84 isValue: false 
-- Items:GenClass: sSwitch descNo: 73 isValue: false 
-- Items:GenClass: switch descNo: 22 isValue: false 

CLASS sSwitch dNo:84 topDno:73 orgOff:3 orgId:Break orgDno:68
-- VDTtableCopy: 73 94 
-- vdtTableCopy: I:1:73 I:2:0 
-- 2 84 true 
-- VDTentry: vdtAdd: inx=2 descInx=84 vDescInx=84 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  3 origin
-- AllocateSuper: inner(sSwitch)
-- op:super switch
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break%$68 3
7:	 rpushg Break%$68 1
9:	 rpushg demo%$67 1
11:	 rpushg workspace%$66 1
13:	 rpushg BETA 2
-- scanInv: "switch " 0 0 1 
-- handleSuperArgs:E: "switch" theIS: inner(sSwitch)
-- super.sig:not:none:superAdj: -3 
-- ptn:loadArgs:E: switch
-- args: 
-- arg: in V: var integer 1 0 false 
-- ptn:loadArgs:end: 
-- switch:  \
--    in V: var integer \
--    %public \
--    case: 
-- handleArgumentsAndOrigin: 
15:	 pushThis 
16:	 storeg integer%$5 2
18:	 tstOriginIsNone 
19:	 rstore  1 origin
-- AllocateSuper: 
-- in V: var integer \
-- %public \
-- case:  \
--    in x: ref Indexed(1,#Integer)
21:	 allocEventQ 
-- 1 73 true 
-- VDTentry: vdtAdd: inx=1 descInx=84 vDescInx=73 vdtTop: 2 
23:	 rtnAlloc 1
25:	 toSuper  73
DO:
28:	 mvStack 
L1:
-- OG:gen: true inner(sSwitch)
-- OG:before:super.gen: "inner(sSwitch)" 
-- scanInv: "inner(sSwitch) " 0 0 1 
-- doInvoke: inner(sSwitch)0 1 useRtnVal: false 
-- scanInv: "inner(sSwitch) " 0 1 1 
-- doInvoke:X: inner(sSwitch)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inner(sSwitch) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: inner(sSwitch)
-- koks:Y: "inner(sSwitch) " 
-- ptn:loadArgs:end: 
-- inner:  \
--    %basic 101 \
--    in inner: ref Object
-- OI:newInvoke: "inner(sSwitch) " 
29:	 pushThis 
30:	 innerP  3
32:	 rpopThisObj  L2:
33:	 rtnInner  M
34:	 END OSDV:0 objSize:3 isIndexed:0
-- 3 0 true 
-- VDTentry: vdtAdd: inx=3 descInx=84 vDescInx=0 vdtTop: 3 
-- Items:GenClass: Break>sSwitch$85 descNo: 85 isValue: false 
-- Items:GenClass: Break>sSwitch$85 descNo: 84 isValue: false 
-- Items:GenClass: sSwitch descNo: 73 isValue: false 
-- Items:GenClass: switch descNo: 22 isValue: false 

CLASS Break>sSwitch$85 dNo:85 topDno:73 orgOff:3 orgId:Break orgDno:68
-- VDTtableCopy: 84 94 
-- vdtTableCopy: I:1:73 I:2:84 I:3:0 
-- 3 85 true 
-- VDTentry: vdtAdd: inx=3 descInx=85 vDescInx=85 vdtTop: 3 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  3 origin
-- AllocateSuper: 
-- case(1) \
--    "Case-1\n".print \
-- case(3) \
--    "Case-3\n".print
-- op:super sSwitch
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break%$68 3
-- scanInv: "sSwitch(7) " 0 0 1 
-- handleSuperArgs:E: "sSwitch(7)" theIS: 
-- case(1) \
--    "Case-1\n".print \
-- case(3) \
--    "Case-3\n".print
-- super.sig:none:superAdj: 3 
-- ptn:loadArgs:E: sSwitch(7)
-- args: sSwitch(7)
-- E.arg: "ObjectDescriptor" 7 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "sSwitch(7) " "ObjectInvocation_KeyWord " ActArg: "7 "
 --  isValue: true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 7 
-- OG:gen: true 7
-- OG:before:super.gen: "7" 
7:	 pushc 7
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- sSwitch: switch \
--    inner(sSwitch)
-- handleArgumentsAndOrigin: 
9:	 tstOriginIsNone 
10:	 rstore  3 origin
-- AllocateSuper: inner(sSwitch)
-- op:super sSwitch
-- push:super.origin: 
12:	 pushThis 
13:	 rpushg Break%$68 3
15:	 rpushg Break%$68 1
17:	 rpushg demo%$67 1
19:	 rpushg workspace%$66 1
21:	 rpushg BETA 2
-- scanInv: "switch " 0 0 1 
-- handleSuperArgs:E: "switch" theIS: inner(sSwitch)
-- super.sig:not:none:superAdj: -3 
-- ptn:loadArgs:E: switch
-- args: 
-- arg: in V: var integer 1 0 false 
-- ptn:loadArgs:end: 
-- switch:  \
--    in V: var integer \
--    %public \
--    case: 
-- handleArgumentsAndOrigin: 
23:	 pushThis 
24:	 storeg integer%$5 2
26:	 tstOriginIsNone 
27:	 rstore  1 origin
-- AllocateSuper: 
-- in V: var integer \
-- %public \
-- case:  \
--    in x: ref Indexed(1,#Integer)
29:	 allocEventQ 
-- 1 73 true 
-- VDTentry: vdtAdd: inx=1 descInx=85 vDescInx=73 vdtTop: 3 
31:	 rtnAlloc 1
33:	 toSuper  73
DO:
36:	 mvStack 
L1:
-- OG:gen: false 
-- case(1) \
--    "Case-1\n".print
-- before:isDerived 
37:	 pushThis 
38:	 invoke Break>sSwitch$85>case$86 86 0 0
44:	 rpop 
-- OG:gen: false 
-- case(3) \
--    "Case-3\n".print
-- before:isDerived 
45:	 pushThis 
46:	 invoke Break>sSwitch$85>case$87 87 0 0
52:	 rpop 
-- OG:gen: false 
-- case(7) \
--    "Case-7\n".print
-- before:isDerived 
53:	 pushThis 
54:	 invoke Break>sSwitch$85>case$88 88 0 0
60:	 rpop 
L2:
61:	 rtnInner  M
62:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: Break>sSwitch$85>case$86 descNo: 86 isValue: false 
-- Items:GenClass: Break>sSwitch$85>case$86 descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>sSwitch$85>case$86 dNo:86 topDno:75 orgOff:1 orgId:Break>sSwitch$85 orgDno:85
-- VDTtableCopy: 75 94 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 86 true 
-- VDTentry: vdtAdd: inx=2 descInx=86 vDescInx=86 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "Case-1\n".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>sSwitch$85%$85 1
-- scanInv: "case(1) " 0 0 1 
-- handleSuperArgs:E: "case(1)" theIS: "Case-1\n".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(1)
-- args: case(1)
-- E.arg: "ObjectDescriptor" 1 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(1) " "ObjectInvocation_KeyWord " ActArg: "1 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
7:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  1   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=86 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true "Case-1\n".print
-- OG:before:super.gen: "Case-1\n.print" 
28:	 pushText "Case-1\n"
-- scanInv: ""Case-1\n".print " 1 1 2 
-- doInvoke: "Case-1\n".print1 2 useRtnVal: false 
-- scanInv: ""Case-1\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Case-1\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Case-1\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
L2:
37:	 rtnInner  M
38:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>sSwitch$85>case$87 descNo: 87 isValue: false 
-- Items:GenClass: Break>sSwitch$85>case$87 descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>sSwitch$85>case$87 dNo:87 topDno:75 orgOff:1 orgId:Break>sSwitch$85 orgDno:85
-- VDTtableCopy: 75 94 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 87 true 
-- VDTentry: vdtAdd: inx=2 descInx=87 vDescInx=87 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "Case-3\n".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>sSwitch$85%$85 1
-- scanInv: "case(3) " 0 0 1 
-- handleSuperArgs:E: "case(3)" theIS: "Case-3\n".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(3)
-- args: case(3)
-- E.arg: "ObjectDescriptor" 3 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(3) " "ObjectInvocation_KeyWord " ActArg: "3 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 3 
-- OG:gen: true 3
-- OG:before:super.gen: "3" 
7:	 pushc 3
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  3   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=87 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true "Case-3\n".print
-- OG:before:super.gen: "Case-3\n.print" 
28:	 pushText "Case-3\n"
-- scanInv: ""Case-3\n".print " 1 1 2 
-- doInvoke: "Case-3\n".print1 2 useRtnVal: false 
-- scanInv: ""Case-3\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Case-3\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Case-3\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
L2:
37:	 rtnInner  M
38:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>sSwitch$85>case$88 descNo: 88 isValue: false 
-- Items:GenClass: Break>sSwitch$85>case$88 descNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>sSwitch$85>case$88 dNo:88 topDno:75 orgOff:1 orgId:Break>sSwitch$85 orgDno:85
-- VDTtableCopy: 75 94 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 88 true 
-- VDTentry: vdtAdd: inx=2 descInx=88 vDescInx=88 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "Case-7\n".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>sSwitch$85%$85 1
-- scanInv: "case(7) " 0 0 1 
-- handleSuperArgs:E: "case(7)" theIS: "Case-7\n".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(7)
-- args: case(7)
-- E.arg: "ObjectDescriptor" 7 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(7) " "ObjectInvocation_KeyWord " ActArg: "7 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 7 
-- OG:gen: true 7
-- OG:before:super.gen: "7" 
7:	 pushc 7
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  7   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=88 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true "Case-7\n".print
-- OG:before:super.gen: "Case-7\n.print" 
28:	 pushText "Case-7\n"
-- scanInv: ""Case-7\n".print " 1 1 2 
-- doInvoke: "Case-7\n".print1 2 useRtnVal: false 
-- scanInv: ""Case-7\n".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "Case-7\n" ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""Case-7\n" " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
30:	 invoke print 69 0 0
36:	 rpop 
L2:
37:	 rtnInner  M
38:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$106>repeat$89 descNo: 89 isValue: false 
-- Items:GenClass: Break>for:to:repeat$106>repeat$89 descNo: 22 isValue: false 

CLASS Break>for:to:repeat$106>repeat$89 dNo:89 topDno:89 orgOff:1 orgId:Break>for:to:repeat$106 orgDno:106
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- putint(inx) \
-- _put(':') \
-- switch(inx) \
--    case(1)
4:	 allocEventQ 
-- 1 89 true 
-- VDTentry: vdtAdd: inx=1 descInx=89 vDescInx=89 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true putint(inx)
-- OG:before:super.gen: "putint(inx)" 
-- doInvoke: putint(inx)0 1 useRtnVal: false 
-- scanInv: "putint(inx) " 0 1 1 
-- doInvoke:X: putint(inx)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "putint(inx) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: putint(inx)
-- koks:Y: "putint(inx) " 
-- ptn:loadArgs:E: putint(inx)
-- args: (inx)
-- E.arg: "ObjectDescriptor" inx 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "putint(inx) " "ObjectInvocation_Function " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
11:	 pushThis 
12:	 rpushg Break>for:to:repeat$106>repeat$89%$89 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
14:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- ptn:loadArgs:end: 
-- putint:  \
--    %globals \
--    in V: var integer \
--    D: obj Indexed(20,#integer)
-- OI:newInvoke: "putint(inx) " 
16:	 invoke putint 90 0 0
22:	 rpop 
-- OG:gen: true _put(':')
-- OG:before:super.gen: "_put(':')" 
-- doInvoke: _put(':')0 1 useRtnVal: false 
-- scanInv: "_put(':') " 0 1 1 
-- doInvoke:X: _put(':')0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "_put(':') " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: _put(':')
-- koks:Y: "_put(':') " 
-- ptn:loadArgs:E: _put(':')
-- args: (':')
-- E.arg: "ObjectDescriptor" ':' 
-- arg: in ch: var char 1 1 false 
-- E.arg: in ch: var char 
-- NonVirt: "_put(':') " "ObjectInvocation_Function " ActArg: "':' "
 --  isValue: true formalArg: "in ch: var char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: ':' 
-- OG:gen: true ':'
-- OG:before:super.gen: "':'" 
23:	 pushc 58
-- loadArgs:after:actualArg:gen: false false 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- ptn:loadArgs:end: 
-- _put:  \
--    %globals \
--    %basic 2 \
--    in ch: var char
-- OI:newInvoke: "_put(':') " 
25:	 %put 2
-- OG:gen: false 
-- switch(inx) \
--    case(1) \
--       put('a') \
--    case(3)
-- before:isDerived 
27:	 pushThis 
28:	 invoke Break>for:to:repeat$106>repeat$89>switch$102 102 0 0
34:	 rpop 
L2:
35:	 setThisStack  
36:	 pushThis 
37:	 rtn D
39:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: putint descNo: 90 isValue: false 
-- Items:GenClass: putint descNo: 22 isValue: false 

CLASS putint dNo:90 topDno:90 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 1
-- AllocateSuper: 
-- %globals \
-- in V: var integer \
-- D: obj Indexed(20,#integer) \
-- L: var integer
4:	 allocEventQ 
-- 1 90 true 
-- VDTentry: vdtAdd: inx=1 descInx=90 vDescInx=90 vdtTop: 1 
6:	 mvStack 
-- DI:isConst: D 
-- OG:gen: true Indexed(20,#integer)
-- OG:before:super.gen: "Indexed(20,#integer)" 
-- doInvoke: Indexed(20,#integer)0 1 useRtnVal: false 
-- scanInv: "Indexed(20,#integer) " 0 1 1 
-- doInvoke:X: Indexed(20,#integer)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "Indexed(20,#integer) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 2 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: Indexed(20,#integer)
-- koks:Y: "Indexed(20,#integer) " 
-- ptn:loadArgs:E: Indexed(20,#integer)
-- args: (20,#integer)
-- E.arg: "ObjectDescriptor" 20 
-- E.arg: "ObjectDescriptor" #integer 
-- arg: in range: var Integer 1 2 false 
-- E.arg: in range: var Integer 
-- NonVirt: "Indexed(20,#integer) " "ObjectInvocation_Function " 
 --  ActArg: "20 "isValue: true formalArg: "in range: var Integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 20 
-- OG:gen: true 20
-- OG:before:super.gen: "20" 
7:	 pushc 20
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: in elm:< Object 2 2 true 
-- ptn:loadArgs:end: 
-- Indexed:  \
--    %globals \
--    %basic 114 \
--    %public
-- OI:newInvoke: "Indexed(20,#integer) " 
9:	 pushThis 
10:	 pushc 1
12:	 allocIndexed putint%$90 91 1 0
17:	 pushThis 
18:	 rstoreg putint%$90 2
20:	 rtnAlloc 1
DO:
22:	 doEventQ 
23:	 mvStack 
L1:
24:	 pushThis 
-- scanInv: "isNeg " 0 0 1 
-- OG:gen: true V < 0
-- OG:before:super.gen: "V < 0" 
25:	 pushThis 
-- scanInv: "V < 0 " 0 1 2 
26:	 pushg 1 newInvoke
-- doInvoke: V < 01 2 useRtnVal: true 
-- scanInv: "V < 0 " 1 2 2 
-- doInvoke:X: < 01 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "< 0 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: < 0
-- koks:Y: "< 0 " 
-- ptn:loadArgs:E: < 0
-- args: 0
-- E.arg: "ObjectDescriptor" 0 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "< 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 0 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
28:	 pushc 0
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- <  :  \
--    %basic 51 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "< 0 " 
30:	 lt 
-- unitConv:after 
31:	 storeg Boolean%$41 4
-- OG:gen: true 
-- if (isNeg) :then  \
--    V := 0 - V
-- OG:before:super.gen: "if (isNeg) :then  \
--    V := 0 - V" 
-- doInvoke: 
-- if (isNeg) :then  \
--    V := 0 - V0 1 useRtnVal: false 
-- scanInv: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  0 1 1 
-- doInvoke:X: 
-- if (isNeg) :then  \
--    V := 0 - V0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (isNeg) :then  \
--    V := 0 - V
-- koks:Y: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
-- OG:gen: true (isNeg)
-- gen:whatIsThis? 
-- OG:before:super.gen: "(isNeg)" 
33:	 pushThis 
-- scanInv: "(isNeg) " 0 0 1 
-- doInvoke: (isNeg)0 1 useRtnVal: true 
-- scanInv: "(isNeg) " 0 1 1 
-- doInvoke:X: isNeg0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "isNeg " isBasicValue: true 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: isNeg
-- koks:Y: "isNeg " 
-- ptn:loadArgs:E: isNeg
-- args: 
-- ptn:loadArgs:end: 
-- Boolean: value \
--    %id "Boolean" \
--    %globals inSub \
--    %basic 4, 8
-- OI:newInvoke: "isNeg " 
-- DI:newInvoke: "isNeg: var Boolean " off: 3 valueOff: 0 E: "
 --  isNeg " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "isNeg " isAdr: false valueOff: 0 
34:	 pushg 4 newInvoke
36:	 jmpFalse  L4
L3:
-- OG:gen: false V := 0 - V
-- before:isDerived 
39:	 pushThis 
40:	 invoke putint>$93 93 0 0
46:	 rpop 
L4:
-- OG:gen: false 
-- L := L + 1 \
--    D.put(V /% 10):at[L] \
--    V := V // 10 \
--    if (V > 0) :then 
-- before:isDerived 
47:	 pushThis 
48:	 invoke loop 112 0 0
54:	 rpop 
-- OG:gen: true 
-- if (isNeg) :then  \
--    put('-')
-- OG:before:super.gen: "if (isNeg) :then  \
--    put('-')" 
-- doInvoke: 
-- if (isNeg) :then  \
--    put('-')0 1 useRtnVal: false 
-- scanInv: 
 --  if (isNeg) :then 
 --     put('-')
 --  0 1 1 
-- doInvoke:X: 
-- if (isNeg) :then  \
--    put('-')0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (isNeg) :then 
 --     put('-')
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (isNeg) :then  \
--    put('-')
-- koks:Y: 
 --  if (isNeg) :then 
 --     put('-')
 --  
-- OG:gen: true (isNeg)
-- gen:whatIsThis? 
-- OG:before:super.gen: "(isNeg)" 
55:	 pushThis 
-- scanInv: "(isNeg) " 0 0 1 
-- doInvoke: (isNeg)0 1 useRtnVal: true 
-- scanInv: "(isNeg) " 0 1 1 
-- doInvoke:X: isNeg0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "isNeg " isBasicValue: true 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: isNeg
-- koks:Y: "isNeg " 
-- ptn:loadArgs:E: isNeg
-- args: 
-- ptn:loadArgs:end: 
-- Boolean: value \
--    %id "Boolean" \
--    %globals inSub \
--    %basic 4, 8
-- OI:newInvoke: "isNeg " 
-- DI:newInvoke: "isNeg: var Boolean " off: 3 valueOff: 0 E: "
 --  isNeg " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "isNeg " isAdr: false valueOff: 0 
56:	 pushg 4 newInvoke
58:	 jmpFalse  L7
L6:
-- OG:gen: false put('-')
-- before:isDerived 
61:	 pushThis 
62:	 invoke putint>$95 95 0 0
68:	 rpop 
L7:
-- OG:gen: false 
-- for(ix) \
--    from:: 1 \
--    to:: L \
--    repeat:: 
-- before:isDerived 
69:	 pushThis 
70:	 invoke putint>for$98 98 0 0
76:	 rpop 
L2:
77:	 setThisStack  
78:	 pushThis 
79:	 rtn D
81:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: putint>$93 descNo: 93 isValue: false 
-- Items:GenClass: putint>$93 descNo: 22 isValue: false 

CLASS putint>$93 dNo:93 topDno:93 orgOff:1 orgId:putint orgDno:90
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: V := 0 - V
4:	 allocEventQ 
-- 1 93 true 
-- VDTentry: vdtAdd: inx=1 descInx=93 vDescInx=93 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg putint>$93%$93 1
-- scanInv: "V " 0 0 1 
-- OG:gen: true 0 - V
-- OG:before:super.gen: "0 - V" 
14:	 pushc 0
-- scanInv: "0 - V " 1 1 2 
-- doInvoke: 0 - V1 2 useRtnVal: true 
-- scanInv: "0 - V " 1 2 2 
-- doInvoke:X: - V1 2 2 pRec: none rec: 0 ix->next none 
-- checkForProxy:E: "- V " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "0 " rec.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals1 false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: - V
-- koks:Y: "- V " 
-- ptn:loadArgs:E: - V
-- args: V
-- E.arg: "ObjectDescriptor" V 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "- V " "ObjectInvocation_Binary " ActArg: "V "isValue: 
 --  false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: V 
-- OG:gen: true V
-- gen:whatIsThis? 
-- OG:before:super.gen: "V" 
16:	 pushThis 
17:	 rpushg putint>$93%$93 1
-- scanInv: "V " 0 0 1 
-- doInvoke: V0 1 useRtnVal: true 
-- scanInv: "V " 0 1 1 
-- doInvoke:X: V0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "V " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: V
-- koks:Y: "V " 
-- ptn:loadArgs:E: V
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "V " 
-- DI:newInvoke: "in V: var integer " off: 1 valueOff: 0 E: "V " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "V " isAdr: false valueOff: 0 
19:	 pushg 1 newInvoke
-- loadArgs:after:actualArg:gen: false true in V: var integer
-- ptn:loadArgs:end: 
-- -  :  \
--    %basic 62 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "- V " 
21:	 minus 
-- unitConv:after 
22:	 storeg integer%$5 1
L2:
24:	 setThisStack  
25:	 pushThis 
26:	 rtn D
28:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop descNo: 112 isValue: false 
-- Items:GenClass: loop descNo: 22 isValue: false 

CLASS loop dNo:112 topDno:112 orgOff:1 orgId:putint orgDno:90
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- L := L + 1 \
-- D.put(V /% 10):at[L] \
-- V := V // 10 \
-- if (V > 0) :then 
4:	 allocEventQ 
-- 1 112 true 
-- VDTentry: vdtAdd: inx=1 descInx=112 vDescInx=112 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop%$112 1
-- scanInv: "L " 0 0 1 
-- OG:gen: true L + 1
-- OG:before:super.gen: "L + 1" 
14:	 pushThis 
15:	 rpushg loop%$112 1
-- scanInv: "L + 1 " 0 1 2 
17:	 pushg 3 newInvoke
-- doInvoke: L + 11 2 useRtnVal: true 
-- scanInv: "L + 1 " 1 2 2 
-- doInvoke:X: + 11 2 2 pRec: none rec: L ix->next none 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + 1
-- koks:Y: "+ 1 " 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
19:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ 1 " 
21:	 plus 
-- unitConv:after 
22:	 storeg integer%$5 3
-- OG:gen: true D.put(V /% 10):at[L]
-- OG:before:super.gen: "D.put(V /% 10):at[L]" 
24:	 pushThis 
25:	 rpushg loop%$112 1
-- scanInv: "D.put(V /% 10):at[L] " 0 1 2 
27:	 rpushg newInvoke 2
-- doInvoke: D.put(V /% 10):at[L]1 2 useRtnVal: false 
-- scanInv: "D.put(V /% 10):at[L] " 1 2 2 
-- doInvoke:X: put(V /% 10):at[L]1 2 2 pRec: none rec: D ix->next none 
-- checkForProxy:E: "put(V /% 10):at[L] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "D " rec.ATd: "
 --  D: obj Indexed(20,#integer) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: put(V /% 10):at[L]
-- koks:Y: "put(V /% 10):at[L] " 
-- ptn:loadArgs:E: put(V /% 10):at[L]
-- args: put(V /% 10):at[L]
-- E.arg: "ObjectDescriptor" V /% 10 
-- E.arg: "ObjectDescriptor" L 
-- arg: V: var integer 1 2 false 
-- E.arg: V: var integer 
-- NonVirt: "put(V /% 10):at[L] " "ObjectInvocation_KeyWord " 
 --  ActArg: "V /% 10 "isValue: false formalArg: "V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: V /% 10 
-- OG:gen: true V /% 10
-- OG:before:super.gen: "V /% 10" 
29:	 pushThis 
30:	 rpushg loop%$112 1
-- scanInv: "V /% 10 " 0 1 2 
32:	 pushg 1 newInvoke
-- doInvoke: V /% 101 2 useRtnVal: true 
-- scanInv: "V /% 10 " 1 2 2 
-- doInvoke:X: /% 101 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "/% 10 " isBasicValue: false 
 --  E.origin.isValueObj: true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 
 --  false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- checkForProxy:rec=None:localInvocation? "V /% 10 " E: "/% 10 " 
 --  rec: "V " 
-- kuk:X: /% 10
-- koks:Y: "/% 10 " 
-- ptn:loadArgs:E: /% 10
-- args: 10
-- E.arg: "ObjectDescriptor" 10 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "/% 10 " "ObjectInvocation_Binary " ActArg: "10 "
 --  isValue: true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 10 
-- OG:gen: true 10
-- OG:before:super.gen: "10" 
34:	 pushc 10
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- /%  :  \
--    %basic 69 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "/% 10 " 
36:	 modd 
-- unitConv:after 
-- loadArgs:after:actualArg:gen: false false 
-- /%  :  \
--    %basic 69 \
--    in V: var integer \
--    out R: var integer
-- arg: inx: var integer 2 2 false 
-- E.arg: inx: var integer 
-- NonVirt: "put(V /% 10):at[L] " "ObjectInvocation_KeyWord " 
 --  ActArg: "L "isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L 
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
37:	 pushThis 
38:	 rpushg loop%$112 1
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 2 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
40:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true L: var integer
-- arg: V: var integer 3 2 false 
-- arg: inx: var integer 4 2 false 
-- arg: V: var integer 5 2 false 
-- arg: inx: var integer 6 2 false 
-- ptn:loadArgs:end: 
-- put(V: var integer):at[inx: var integer]:  \
--    %basic 115
-- OI:newInvoke: "put(V /% 10):at[L] " 
-- getIndexedArgs:rec.ATd: D: obj Indexed(20,#integer)
42:	 xstoreg inx  size:1 isValueObj:0
45:	 pushThis 
46:	 rpushg loop%$112 1
-- scanInv: "V " 0 0 1 
-- OG:gen: true V // 10
-- OG:before:super.gen: "V // 10" 
48:	 pushThis 
49:	 rpushg loop%$112 1
-- scanInv: "V // 10 " 0 1 2 
51:	 pushg 1 newInvoke
-- doInvoke: V // 101 2 useRtnVal: true 
-- scanInv: "V // 10 " 1 2 2 
-- doInvoke:X: // 101 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "// 10 " isBasicValue: false 
 --  E.origin.isValueObj: true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 
 --  false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- checkForProxy:rec=None:localInvocation? "V // 10 " E: "// 10 " 
 --  rec: "V " 
-- kuk:X: // 10
-- koks:Y: "// 10 " 
-- ptn:loadArgs:E: // 10
-- args: 10
-- E.arg: "ObjectDescriptor" 10 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "// 10 " "ObjectInvocation_Binary " ActArg: "10 "
 --  isValue: true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 10 
-- OG:gen: true 10
-- OG:before:super.gen: "10" 
53:	 pushc 10
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- //  :  \
--    %basic 68 \
--    in V: var integer \
--    out B: var integer
-- OI:newInvoke: "// 10 " 
55:	 idiv 
-- unitConv:after 
56:	 storeg integer%$5 1
-- OG:gen: true 
-- if (V > 0) :then  \
--    restart(loop)
-- OG:before:super.gen: "if (V > 0) :then  \
--    restart(loop)" 
-- doInvoke: 
-- if (V > 0) :then  \
--    restart(loop)0 1 useRtnVal: false 
-- scanInv: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  0 1 1 
-- doInvoke:X: 
-- if (V > 0) :then  \
--    restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (V > 0) :then  \
--    restart(loop)
-- koks:Y: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
-- OG:gen: true (V > 0)
-- OG:before:super.gen: "(V > 0)" 
58:	 pushThis 
59:	 rpushg loop%$112 1
-- scanInv: "(V > 0) " 0 1 2 
61:	 pushg 1 newInvoke
-- doInvoke: (V > 0)1 2 useRtnVal: true 
-- scanInv: "(V > 0) " 1 2 2 
-- doInvoke:X: > 01 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "> 0 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: > 0
-- koks:Y: "> 0 " 
-- ptn:loadArgs:E: > 0
-- args: 0
-- E.arg: "ObjectDescriptor" 0 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "> 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 0 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
63:	 pushc 0
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- >  :  \
--    %basic 53 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "> 0 " 
65:	 gt 
-- unitConv:after 
66:	 jmpFalse  L4
L3:
-- OG:gen: false restart(loop)
-- before:isDerived 
69:	 pushThis 
70:	 invoke loop>$117 117 0 0
76:	 rpop 
L4:
L2:
77:	 setThisStack  
78:	 pushThis 
79:	 rtn D
81:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>$117 descNo: 117 isValue: false 
-- Items:GenClass: loop>$117 descNo: 22 isValue: false 

CLASS loop>$117 dNo:117 topDno:117 orgOff:1 orgId:loop orgDno:112
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: restart(loop)
4:	 allocEventQ 
-- 1 117 true 
-- VDTentry: vdtAdd: inx=1 descInx=117 vDescInx=117 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true restart(loop)
-- OG:before:super.gen: "restart(loop)" 
-- scanInv: "restart(loop) " 0 0 1 
-- doInvoke: restart(loop)0 1 useRtnVal: false 
-- scanInv: "restart(loop) " 0 1 1 
-- doInvoke:X: restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "restart(loop) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: restart(loop)
-- koks:Y: "restart(loop) " 
-- ptn:loadArgs:end: 
-- restart(V: var integer):  -- odd parameter type! \
--    %basic 102
-- OI:newInvoke: "restart(loop) " 
11:	 break  1 1 112 0
L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: putint>$95 descNo: 95 isValue: false 
-- Items:GenClass: putint>$95 descNo: 22 isValue: false 

CLASS putint>$95 dNo:95 topDno:95 orgOff:1 orgId:putint orgDno:90
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: put('-')
4:	 allocEventQ 
-- 1 95 true 
-- VDTentry: vdtAdd: inx=1 descInx=95 vDescInx=95 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true put('-')
-- OG:before:super.gen: "put('-')" 
-- doInvoke: put('-')0 1 useRtnVal: false 
-- scanInv: "put('-') " 0 1 1 
-- doInvoke:X: put('-')0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "put('-') " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: put('-')
-- koks:Y: "put('-') " 
-- ptn:loadArgs:E: put('-')
-- args: ('-')
-- E.arg: "ObjectDescriptor" '-' 
-- arg: in ch: val char 1 1 false 
-- E.arg: in ch: val char 
-- NonVirt: "put('-') " "ObjectInvocation_Function " ActArg: "'-' "
 --  isValue: true formalArg: "in ch: val char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: '-' 
-- OG:gen: true '-'
-- OG:before:super.gen: "'-'" 
11:	 pushc 45
-- loadArgs:after:actualArg:gen: false false 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- ptn:loadArgs:end: 
-- put:  \
--    %globals \
--    %basic 2 \
--    in ch: val char
-- OI:newInvoke: "put('-') " 
13:	 %put 2
L2:
15:	 setThisStack  
16:	 pushThis 
17:	 rtn D
19:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: for descNo: 96 isValue: false 
-- Items:GenClass: for descNo: 22 isValue: false 

CLASS for dNo:96 topDno:96 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 3
4:	 pushThis 
5:	 storeg integer%$5 2
7:	 pushThis 
8:	 storeg integer%$5 1
-- AllocateSuper: 
-- @inx:< var integer \
-- from:< var integer \
-- to:< var integer \
-- repeat:< object
10:	 allocEventQ 
-- 1 96 true 
-- VDTentry: vdtAdd: inx=1 descInx=96 vDescInx=96 vdtTop: 1 
12:	 mvStack 
13:	 rtnAlloc 1
DO:
15:	 doEventQ 
16:	 mvStack 
L1:
17:	 pushThis 
-- scanInv: "inx " 0 0 1 
-- OG:gen: true from
-- gen:whatIsThis? 
-- OG:before:super.gen: "from" 
18:	 pushThis 
-- scanInv: "from " 0 0 1 
-- doInvoke: from0 1 useRtnVal: true 
-- scanInv: "from " 0 1 1 
-- doInvoke:X: from0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "from " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  @inx:< var integer
 --     from:< var integer
 --     to:< var integer
 --     repeat:< object
-- kuk:X: from
-- koks:Y: "from " 
-- ptn:loadArgs:E: from
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "from " 
-- DI:newInvoke: "from:< var integer " off: 2 valueOff: 0 E: "
 --  from " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "from " isAdr: false valueOff: 0 
19:	 pushg 2 newInvoke
21:	 storeg integer%$5 1
-- OG:gen: false 
-- if (inx <= to) :then  \
--       repeat \
--             --put('+')	  \
--       inx := inx + 1
-- before:isDerived 
23:	 pushThis 
24:	 invoke _doIt 118 0 0
30:	 rpop 
L2:
31:	 setThisStack  
32:	 pushThis 
33:	 rtn D
35:	 END OSDV:1 objSize:3 isIndexed:0
-- 2 97 false 
-- VDTentry: vdtAdd: inx=2 descInx=96 vDescInx=97 vdtTop: 2 

CLASS repeat#97 dNo:97 topDno:22 orgOff:0 orgId:for%$96 orgDno:96 isVstub
1:	 invoke Object 22 0 0
7:	 pushThis 
8:	 rstoreg  2
10:	 setThisStack  
11:	 pushThis 
12:	 rpushg  2
14:	 rtn D
16:	 END OSDV:1 objSize:3 isIndexed:0
-- Items:GenClass: _doIt descNo: 118 isValue: false 
-- Items:GenClass: _doIt descNo: 22 isValue: false 

CLASS _doIt dNo:118 topDno:118 orgOff:1 orgId:for orgDno:96
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- if (inx <= to) :then  \
--    repeat \
--             --put('+')	  \
--    inx := inx + 1
4:	 allocEventQ 
-- 1 118 true 
-- VDTentry: vdtAdd: inx=1 descInx=118 vDescInx=118 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- if (inx <= to) :then  \
--    repeat \
--             --put('+')	  \
--    inx := inx + 1
-- OG:before:super.gen: "if (inx <= to) :then  \
--    repeat \
--             --put('+')	  \
--    inx := inx + 1 \
--    restart(_doIt) \
--          --put('*')      " 
-- doInvoke: 
-- if (inx <= to) :then  \
--    repeat \
--             --put('+')	  \
--    inx := inx + 10 1 useRtnVal: false 
-- scanInv: 
 --  if (inx <= to) :then 
 --     repeat
 --              --put('+')	 
 --     inx := inx + 10 1 1 
-- doInvoke:X: 
-- if (inx <= to) :then  \
--    repeat \
--             --put('+')	  \
--    inx := inx + 10 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (inx <= to) :then 
 --     repeat
 --              --put('+')	 
 --     inx := inx + 1isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (inx <= to) :then  \
--    repeat \
--             --put('+')	  \
--    inx := inx + 1
-- koks:Y: 
 --  if (inx <= to) :then 
 --     repeat
 --              --put('+')	 
 --     inx := inx + 1
-- OG:gen: true (inx <= to)
-- OG:before:super.gen: "(inx <= to)" 
11:	 pushThis 
12:	 rpushg _doIt%$118 1
-- scanInv: "(inx <= to) " 0 1 2 
14:	 pushg 1 newInvoke
-- doInvoke: (inx <= to)1 2 useRtnVal: true 
-- scanInv: "(inx <= to) " 1 2 2 
-- doInvoke:X: <= to1 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "<= to " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "inx " rec.ATd: "@inx:< var integer " 1 
 --  false pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: <= to
-- koks:Y: "<= to " 
-- ptn:loadArgs:E: <= to
-- args: to
-- E.arg: "ObjectDescriptor" to 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "<= to " "ObjectInvocation_Binary " ActArg: "to "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: to 
-- OG:gen: true to
-- gen:whatIsThis? 
-- OG:before:super.gen: "to" 
16:	 pushThis 
17:	 rpushg _doIt%$118 1
-- scanInv: "to " 0 0 1 
-- doInvoke: to0 1 useRtnVal: true 
-- scanInv: "to " 0 1 1 
-- doInvoke:X: to0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "to " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  @inx:< var integer
 --     from:< var integer
 --     to:< var integer
 --     repeat:< object
-- kuk:X: to
-- koks:Y: "to " 
-- ptn:loadArgs:E: to
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "to " 
-- DI:newInvoke: "to:< var integer " off: 3 valueOff: 0 E: "to " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "to " isAdr: false valueOff: 0 
19:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true to:< var integer
-- ptn:loadArgs:end: 
-- <=  :<  \
--    %basic 52 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "<= to " 
21:	 le 
22:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- repeat \
--             --put('+')	  \
--    inx := inx + 1 \
--    restart(_doIt)
-- before:isDerived 
25:	 pushThis 
26:	 invoke _doIt>$119 119 0 0
32:	 rpop 
L4:
L2:
33:	 setThisStack  
34:	 pushThis 
35:	 rtn D
37:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: _doIt>$119 descNo: 119 isValue: false 
-- Items:GenClass: _doIt>$119 descNo: 22 isValue: false 

CLASS _doIt>$119 dNo:119 topDno:119 orgOff:1 orgId:_doIt orgDno:118
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- repeat \
--             --put('+')	  \
-- inx := inx + 1 \
-- restart(_doIt)
4:	 allocEventQ 
-- 1 119 true 
-- VDTentry: vdtAdd: inx=1 descInx=119 vDescInx=119 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true 
-- repeat \
--             --put('+')	 
-- OG:before:super.gen: "repeat \
--             --put('+')	 " 
11:	 pushThis 
12:	 rpushg _doIt>$119%$119 1
14:	 rpushg _doIt%$118 1
-- scanInv: 
 --  repeat
 --              --put('+')	 
 --  0 0 1 
-- doInvoke: 
-- repeat \
--             --put('+')	 0 1 useRtnVal: false 
-- scanInv: 
 --  repeat
 --              --put('+')	 
 --  0 1 1 
-- doInvoke:X: repeat0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "repeat " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  @inx:< var integer
 --     from:< var integer
 --     to:< var integer
 --     repeat:< object
-- kuk:X: repeat
-- koks:Y: "repeat " 
-- ptn:loadArgs:E: repeat
-- args: 
-- ptn:loadArgs:end: repeat:< object
-- OI:newInvoke: "repeat " 
16:	 invokev 2 0 repeat$97$97 0
20:	 rpop 
21:	 pushThis 
22:	 rpushg _doIt>$119%$119 1
24:	 rpushg _doIt%$118 1
-- scanInv: "inx " 0 0 1 
-- OG:gen: true inx + 1
-- OG:before:super.gen: "inx + 1" 
26:	 pushThis 
27:	 rpushg _doIt>$119%$119 1
29:	 rpushg _doIt%$118 1
-- scanInv: "inx + 1 " 0 1 2 
31:	 pushg 1 newInvoke
-- doInvoke: inx + 11 2 useRtnVal: true 
-- scanInv: "inx + 1 " 1 2 2 
-- doInvoke:X: + 11 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " rec.ATd: "@inx:< var integer " 1 
 --  false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + 1
-- koks:Y: "+ 1 " 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
33:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ 1 " 
35:	 plus 
-- unitConv:after 
36:	 storeg integer%$5 1
-- OG:gen: true restart(_doIt)
-- OG:before:super.gen: "restart(_doIt)" 
-- scanInv: "restart(_doIt) " 0 0 1 
-- doInvoke: restart(_doIt)0 1 useRtnVal: false 
-- scanInv: "restart(_doIt) " 0 1 1 
-- doInvoke:X: restart(_doIt)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "restart(_doIt) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: restart(_doIt)
-- koks:Y: "restart(_doIt) " 
-- ptn:loadArgs:end: 
-- restart(V: var integer):  -- odd parameter type! \
--    %basic 102
-- OI:newInvoke: "restart(_doIt) " 
38:	 break  1 1 118 0
L2:
45:	 setThisStack  
46:	 pushThis 
47:	 rtn D
49:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: putint>for$98 descNo: 98 isValue: false 
-- Items:GenClass: putint>for$98 descNo: 96 isValue: false 
-- Items:GenClass: for descNo: 22 isValue: false 

CLASS putint>for$98 dNo:98 topDno:96 orgOff:4 orgId:putint orgDno:90
-- VDTtableCopy: 96 120 
-- vdtTableCopy: I:1:96 V:2:97 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- from:: 1 \
-- to:: L \
-- repeat::  \
--    i: var integer
-- op:super for
-- push:super.origin: 
-- handleSuperArgs:E: "for(ix)" theIS: 
-- from:: 1 \
-- to:: L \
-- repeat::  \
--    i: var integer
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: for(ix)
-- args: for(ix)
-- E.arg: "ObjectDescriptor" ix 
-- arg: @inx:< var integer 1 1 false 
-- E.arg: @inx:< var integer 
-- NonVirt: "for(ix) " "ObjectInvocation_KeyWord " ActArg: "ix "
 --  isValue: false formalArg: "@inx:< var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
4:	 pushc 0
-- arg: from:< var integer 2 1 false 
-- arg: to:< var integer 3 1 false 
-- ptn:loadArgs:end: 
-- for:  \
--    @inx:< var integer \
--    from:< var integer \
--    to:< var integer
-- finalDI: from:: 1
-- ptn:gen:virtual:DI:newOff: 2 from:: 1
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
6:	 pushc 1
-- finalDI: to:: L
-- ptn:gen:virtual:DI:newOff: 3 to:: L
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
8:	 pushThis 
9:	 rpushg putint>for$98%$98 4
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 2 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
11:	 pushg 3 newInvoke
-- handleArgumentsAndOrigin: 
13:	 pushThis 
14:	 storeg integer%$5 3
16:	 pushThis 
17:	 storeg integer%$5 2
19:	 pushThis 
20:	 storeg integer%$5 1
-- AllocateSuper: 
-- @inx:< var integer \
-- from:< var integer \
-- to:< var integer \
-- repeat:< object
22:	 allocEventQ 
-- 1 96 true 
-- VDTentry: vdtAdd: inx=1 descInx=98 vDescInx=96 vdtTop: 2 
-- ptn:gen:virtual:DI:newOff: 2 from:: 1
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
24:	 pushc 1
-- ptn:gen:virtual:DI:newOff: 3 to:: L
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
26:	 pushThis 
27:	 rpushg putint>for$98%$98 4
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 2 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
29:	 pushg 3 newInvoke
-- Designator:gen: "@ix: integer " 
31:	 rtnAlloc 1
33:	 toSuper  96
DO:
36:	 mvStack 
L1:
L2:
37:	 rtnInner  M
38:	 END OSDV:1 objSize:4 isIndexed:0
-- Virtual:DI: from:: 1 \
-- to:: L \
-- repeat::  \
--    i: var integer \
--    i := L + 1 - ix \
--    put('0' + D.get[i]) \
-- @ix: integer 
-- Virtual:DI: from:: 1 \
-- to:: L \
-- repeat::  \
--    i: var integer \
--    i := L + 1 - ix \
--    put('0' + D.get[i]) \
-- @ix: integer 
-- 2 120 false 
-- VDTentry: vdtAdd: inx=2 descInx=98 vDescInx=120 vdtTop: 2 
-- Items:GenClass: repeat descNo: 120 isValue: false 
-- Items:GenClass: repeat descNo: 22 isValue: false 

CLASS repeat dNo:120 topDno:120 orgOff:1 orgId:putint>for$98 orgDno:98
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- i: var integer \
-- i := L + 1 - ix \
-- put('0' + D.get[i])
4:	 allocEventQ 
-- 1 120 true 
-- VDTentry: vdtAdd: inx=1 descInx=120 vDescInx=120 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
-- scanInv: "i " 0 0 1 
-- OG:gen: true L + 1 - ix
-- OG:before:super.gen: "L + 1 - ix" 
12:	 pushThis 
13:	 rpushg repeat%$120 1
15:	 rpushg putint>for$98%$98 4
-- scanInv: "L + 1 - ix " 0 2 3 
17:	 pushg 3 newInvoke
-- loadAccessor:X: + 1rec: L 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
19:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- Bobs:A: + 1 2 2 rec L rec.ATd L: var integerfalse  - ix 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- After proxy + 1 
-- OI:newInvoke: "+ 1 " 
21:	 plus 
-- unitConv:after 
-- scanInv: "L + 1 - ix " 2 2 3 
-- start>0: L + 1 
-- doInvoke: L + 1 - ix2 3 useRtnVal: true 
-- scanInv: "L + 1 - ix " 2 3 3 
-- start>0: L + 1 
-- doInvoke:X: - ix2 3 3 pRec: L rec: + 1 ix->next none 
-- checkForProxy:E: "- ix " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "+ 1 " rec.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  61 false pRec: "L " E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: - ix
-- koks:Y: "- ix " 
-- ptn:loadArgs:E: - ix
-- args: ix
-- E.arg: "ObjectDescriptor" ix 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "- ix " "ObjectInvocation_Binary " ActArg: "ix "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: ix 
-- OG:gen: true ix
-- gen:whatIsThis? 
-- OG:before:super.gen: "ix" 
-- Designator:pushThis: "@ix: integer " 
22:	 pushThis 
23:	 rpushg repeat%$120 1
-- scanInv: "ix " 0 0 1 
-- doInvoke: ix0 1 useRtnVal: true 
-- scanInv: "ix " 0 1 1 
-- doInvoke:X: ix0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "ix " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
-- kuk:X: ix
-- koks:Y: "ix " 
-- OI:newInvoke: "ix " 
-- Designator:newInvoke: "@ix: integer " 
-- DI:newInvoke: "@inx:< var integer " off: 1 valueOff: 0 E: "
 --  ix " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
25:	 pushg 1 newInvoke
-- loadArgs:after:actualArg:gen: false false @ix: integer
-- ptn:loadArgs:end: 
-- -  :  \
--    %basic 62 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "- ix " 
27:	 minus 
-- unitConv:after 
28:	 storeg integer%$5 2
-- OG:gen: true put('0' + D.get[i])
-- OG:before:super.gen: "put('0' + D.get[i])" 
-- doInvoke: put('0' + D.get[i])0 1 useRtnVal: false 
-- scanInv: "put('0' + D.get[i]) " 0 1 1 
-- doInvoke:X: put('0' + D.get[i])0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "put('0' + D.get[i]) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: put('0' + D.get[i])
-- koks:Y: "put('0' + D.get[i]) " 
-- ptn:loadArgs:E: put('0' + D.get[i])
-- args: ('0' + D.get[i])
-- E.arg: "ObjectDescriptor" '0' + D.get[i] 
-- arg: in ch: val char 1 1 false 
-- E.arg: in ch: val char 
-- NonVirt: "put('0' + D.get[i]) " "ObjectInvocation_Function " 
 --  ActArg: "'0' + D.get[i] "isValue: false formalArg: "in ch: val char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: '0' + D.get[i] 
-- OG:gen: true '0' + D.get[i]
-- OG:before:super.gen: "'0' + D.get[i]" 
30:	 pushc 48
-- scanInv: "'0' + D.get[i] " 1 1 2 
-- doInvoke: '0' + D.get[i]1 2 useRtnVal: true 
-- scanInv: "'0' + D.get[i] " 1 2 2 
-- doInvoke:X: + D.get[i]1 2 2 pRec: none rec: '0' ix->next none 
-- checkForProxy:E: "+ D.get[i] " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "'0' " rec.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 163 false pRec: none E.origin: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
-- kuk:X: + D.get[i]
-- koks:Y: "+ D.get[i] " 
-- ptn:loadArgs:E: + D.get[i]
-- args: D.get[i]
-- E.arg: "ObjectDescriptor" D.get[i] 
-- arg: in V: var char 1 1 false 
-- E.arg: in V: var char 
-- NonVirt: "+ D.get[i] " "ObjectInvocation_Binary " ActArg: "
 --  D.get[i] "isValue: false formalArg: "in V: var char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: D.get[i] 
-- OG:gen: true D.get[i]
-- OG:before:super.gen: "D.get[i]" 
32:	 pushThis 
33:	 rpushg repeat%$120 1
35:	 rpushg putint>for$98%$98 4
-- scanInv: "D.get[i] " 0 1 2 
37:	 rpushg newInvoke 2
-- doInvoke: D.get[i]1 2 useRtnVal: true 
-- scanInv: "D.get[i] " 1 2 2 
-- doInvoke:X: get[i]1 2 2 pRec: none rec: D ix->next none 
-- checkForProxy:E: "get[i] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "D " rec.ATd: "
 --  D: obj Indexed(20,#integer) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: get[i]
-- koks:Y: "get[i] " 
-- ptn:loadArgs:E: get[i]
-- args: get[i]
-- E.arg: "ObjectDescriptor" i 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: i 
-- OG:gen: true i
-- gen:whatIsThis? 
-- OG:before:super.gen: "i" 
39:	 pushThis 
-- scanInv: "i " 0 0 1 
-- doInvoke: i0 1 useRtnVal: true 
-- scanInv: "i " 0 1 1 
-- doInvoke:X: i0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "i " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  i: var integer
 --     i := L + 1 - ix
 --     put('0' + D.get[i])
 --  
-- kuk:X: i
-- koks:Y: "i " 
-- ptn:loadArgs:E: i
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "i " 
-- DI:newInvoke: "i: var integer " off: 1 valueOff: 0 E: "i " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "i " isAdr: false valueOff: 0 
40:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true i: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- OI:newInvoke: "get[i] " 
-- getIndexedArgs:rec.ATd: D: obj Indexed(20,#integer)
42:	 xpushg  inx 1 0
-- loadArgs:after:actualArg:gen: false false 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var char \
--    out R: var char
-- OI:newInvoke: "+ D.get[i] " 
45:	 plus 
-- unitConv:after 
-- loadArgs:after:actualArg:gen: false false 
-- +  :  \
--    %basic 61 \
--    in V: var char \
--    out R: var char
-- ptn:loadArgs:end: 
-- put:  \
--    %globals \
--    %basic 2 \
--    in ch: val char
-- OI:newInvoke: "put('0' + D.get[i]) " 
46:	 %put 2
L2:
48:	 setThisStack  
49:	 pushThis 
50:	 rtn D
52:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: _put descNo: 101 isValue: false 
-- Items:GenClass: _put descNo: 22 isValue: false 

CLASS _put dNo:101 topDno:101 orgOff:0 orgId:BETA orgDno:2
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg char%$7 1
-- AllocateSuper: 
-- %globals \
-- %basic 2 \
-- in ch: var char
4:	 allocEventQ 
-- 1 101 true 
-- VDTentry: vdtAdd: inx=1 descInx=101 vDescInx=101 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
L2:
11:	 setThisStack  
12:	 pushThis 
13:	 rtn D
15:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102 descNo: 102 is \
-- Value: false 
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102 descNo: 73 is \
-- Value: false 
-- Items:GenClass: switch descNo: 22 isValue: false 

CLASS Break>for:to:repeat$106>repeat$89>switch$102 dNo:102 topDno:73 orgOff:3 orgId:Break>for:to:repeat$106>repeat$89 orgDno:89
-- VDTtableCopy: 73 120 
-- vdtTableCopy: I:1:73 I:2:0 
-- 2 102 true 
-- VDTentry: vdtAdd: inx=2 descInx=102 vDescInx=102 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  3 origin
-- AllocateSuper: 
-- case(1) \
--    put('a') \
-- case(3) \
--    put('b')
-- op:super switch
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$106>repeat$89%$89 3
7:	 rpushg Break>for:to:repeat$106>repeat$89%$89 1
9:	 rpushg Break>for:to:repeat$106%$106 4
11:	 rpushg Break%$68 1
13:	 rpushg demo%$67 1
15:	 rpushg workspace%$66 1
17:	 rpushg BETA 2
-- scanInv: "switch(inx) " 0 0 1 
-- handleSuperArgs:E: "switch(inx)" theIS: 
-- case(1) \
--    put('a') \
-- case(3) \
--    put('b')
-- super.sig:none:superAdj: 3 
-- ptn:loadArgs:E: switch(inx)
-- args: switch(inx)
-- E.arg: "ObjectDescriptor" inx 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "switch(inx) " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
19:	 pushThis 
20:	 rpushg Break>for:to:repeat$106>repeat$89%$89 3
22:	 rpushg Break>for:to:repeat$106>repeat$89%$89 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
24:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- ptn:loadArgs:end: 
-- switch:  \
--    in V: var integer \
--    %public \
--    case: 
-- handleArgumentsAndOrigin: 
26:	 pushThis 
27:	 storeg integer%$5 2
29:	 tstOriginIsNone 
30:	 rstore  1 origin
-- AllocateSuper: 
-- in V: var integer \
-- %public \
-- case:  \
--    in x: ref Indexed(1,#Integer)
32:	 allocEventQ 
-- 1 73 true 
-- VDTentry: vdtAdd: inx=1 descInx=102 vDescInx=73 vdtTop: 2 
34:	 rtnAlloc 1
36:	 toSuper  73
DO:
39:	 mvStack 
L1:
-- OG:gen: false 
-- case(1) \
--    put('a')
-- before:isDerived 
40:	 pushThis 
41:	 invoke Break>for:to:repeat$106>repeat$89>switch$102>case$103 103 0 0
47:	 rpop 
-- OG:gen: false 
-- case(3) \
--    put('b')
-- before:isDerived 
48:	 pushThis 
49:	 invoke Break>for:to:repeat$106>repeat$89>switch$102>case$104 104 0 0
55:	 rpop 
-- OG:gen: false 
-- case(6) \
--    put('c')
-- before:isDerived 
56:	 pushThis 
57:	 invoke Break>for:to:repeat$106>repeat$89>switch$102>case$105 105 0 0
63:	 rpop 
L2:
64:	 rtnInner  M
65:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102>case$103 des \
-- cNo: 103 isValue: false 
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102>case$103 des \
-- cNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>for:to:repeat$106>repeat$89>switch$102>case$103 dNo:103 topDno:75 orgOff:1 orgId:Break>for:to:repeat$106>repeat$89>switch$102 orgDno:102
-- VDTtableCopy: 75 120 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 103 true 
-- VDTentry: vdtAdd: inx=2 descInx=103 vDescInx=103 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: put('a')
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$106>repeat$89>switch$102%$102 1
-- scanInv: "case(1) " 0 0 1 
-- handleSuperArgs:E: "case(1)" theIS: put('a')
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(1)
-- args: case(1)
-- E.arg: "ObjectDescriptor" 1 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(1) " "ObjectInvocation_KeyWord " ActArg: "1 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
7:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  1   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=103 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true put('a')
-- OG:before:super.gen: "put('a')" 
-- doInvoke: put('a')0 1 useRtnVal: false 
-- scanInv: "put('a') " 0 1 1 
-- doInvoke:X: put('a')0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "put('a') " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: put('a')
-- koks:Y: "put('a') " 
-- ptn:loadArgs:E: put('a')
-- args: ('a')
-- E.arg: "ObjectDescriptor" 'a' 
-- arg: in ch: val char 1 1 false 
-- E.arg: in ch: val char 
-- NonVirt: "put('a') " "ObjectInvocation_Function " ActArg: "'a' "
 --  isValue: true formalArg: "in ch: val char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 'a' 
-- OG:gen: true 'a'
-- OG:before:super.gen: "'a'" 
28:	 pushc 97
-- loadArgs:after:actualArg:gen: false false 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- ptn:loadArgs:end: 
-- put:  \
--    %globals \
--    %basic 2 \
--    in ch: val char
-- OI:newInvoke: "put('a') " 
30:	 %put 2
L2:
32:	 rtnInner  M
33:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102>case$104 des \
-- cNo: 104 isValue: false 
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102>case$104 des \
-- cNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>for:to:repeat$106>repeat$89>switch$102>case$104 dNo:104 topDno:75 orgOff:1 orgId:Break>for:to:repeat$106>repeat$89>switch$102 orgDno:102
-- VDTtableCopy: 75 120 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 104 true 
-- VDTentry: vdtAdd: inx=2 descInx=104 vDescInx=104 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: put('b')
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$106>repeat$89>switch$102%$102 1
-- scanInv: "case(3) " 0 0 1 
-- handleSuperArgs:E: "case(3)" theIS: put('b')
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(3)
-- args: case(3)
-- E.arg: "ObjectDescriptor" 3 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(3) " "ObjectInvocation_KeyWord " ActArg: "3 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 3 
-- OG:gen: true 3
-- OG:before:super.gen: "3" 
7:	 pushc 3
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  3   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=104 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true put('b')
-- OG:before:super.gen: "put('b')" 
-- doInvoke: put('b')0 1 useRtnVal: false 
-- scanInv: "put('b') " 0 1 1 
-- doInvoke:X: put('b')0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "put('b') " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: put('b')
-- koks:Y: "put('b') " 
-- ptn:loadArgs:E: put('b')
-- args: ('b')
-- E.arg: "ObjectDescriptor" 'b' 
-- arg: in ch: val char 1 1 false 
-- E.arg: in ch: val char 
-- NonVirt: "put('b') " "ObjectInvocation_Function " ActArg: "'b' "
 --  isValue: true formalArg: "in ch: val char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 'b' 
-- OG:gen: true 'b'
-- OG:before:super.gen: "'b'" 
28:	 pushc 98
-- loadArgs:after:actualArg:gen: false false 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- ptn:loadArgs:end: 
-- put:  \
--    %globals \
--    %basic 2 \
--    in ch: val char
-- OI:newInvoke: "put('b') " 
30:	 %put 2
L2:
32:	 rtnInner  M
33:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102>case$105 des \
-- cNo: 105 isValue: false 
-- Items:GenClass: Break>for:to:repeat$106>repeat$89>switch$102>case$105 des \
-- cNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>for:to:repeat$106>repeat$89>switch$102>case$105 dNo:105 topDno:75 orgOff:1 orgId:Break>for:to:repeat$106>repeat$89>switch$102 orgDno:102
-- VDTtableCopy: 75 120 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 105 true 
-- VDTentry: vdtAdd: inx=2 descInx=105 vDescInx=105 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: put('c')
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$106>repeat$89>switch$102%$102 1
-- scanInv: "case(6) " 0 0 1 
-- handleSuperArgs:E: "case(6)" theIS: put('c')
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(6)
-- args: case(6)
-- E.arg: "ObjectDescriptor" 6 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(6) " "ObjectInvocation_KeyWord " ActArg: "6 "
 --  isValue: true formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 6 
-- OG:gen: true 6
-- OG:before:super.gen: "6" 
7:	 pushc 6
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  6   ObjectDescriptor true 1 
9:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
14:	 pushThis 
15:	 rstoreg x 2
17:	 tstOriginIsNone 
18:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
20:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=105 vDescInx=75 vdtTop: 2 
22:	 rtnAlloc 1
24:	 toSuper  75
DO:
27:	 mvStack 
L1:
-- OG:gen: true put('c')
-- OG:before:super.gen: "put('c')" 
-- doInvoke: put('c')0 1 useRtnVal: false 
-- scanInv: "put('c') " 0 1 1 
-- doInvoke:X: put('c')0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "put('c') " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: put('c')
-- koks:Y: "put('c') " 
-- ptn:loadArgs:E: put('c')
-- args: ('c')
-- E.arg: "ObjectDescriptor" 'c' 
-- arg: in ch: val char 1 1 false 
-- E.arg: in ch: val char 
-- NonVirt: "put('c') " "ObjectInvocation_Function " ActArg: "'c' "
 --  isValue: true formalArg: "in ch: val char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 'c' 
-- OG:gen: true 'c'
-- OG:before:super.gen: "'c'" 
28:	 pushc 99
-- loadArgs:after:actualArg:gen: false false 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- ptn:loadArgs:end: 
-- put:  \
--    %globals \
--    %basic 2 \
--    in ch: val char
-- OI:newInvoke: "put('c') " 
30:	 %put 2
L2:
32:	 rtnInner  M
33:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$106 descNo: 106 isValue: false 
-- Items:GenClass: Break>for:to:repeat$106 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS Break>for:to:repeat$106 dNo:106 topDno:29 orgOff:4 orgId:Break orgDno:68
-- VDTtableCopy: 29 120 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(6):repeat \
--    putint(inx) \
--    _put(':') \
--    switch(inx) \
--       case(1) \
--          put('a') \
--       case(3) \
--          put('b') \
--       case(6) \
--          put('c') \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(6):repeat \
--    putint(inx) \
--    _put(':') \
--    switch(inx)
-- args: 
-- for(1):to(6):repeat \
--    putint(inx) \
--    _put(':') \
--    switch(inx)
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" 6 
-- E.arg: "ObjectDescriptor" putint(inx) \
--    _put(':') \
--    switch(inx) \
--       case(1) \
--          put('a') \
--       case(3) \
--          put('b') \
--       case(6) \
--          put('c') 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(6):repeat
 --     putint(inx)
 --     _put(':')
 --     switch(inx)"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(6):repeat
 --     putint(inx)
 --     _put(':')
 --     switch(inx)"ObjectInvocation_KeyWord " ActArg: "6 "isValue: true formalArg: "
 --  last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 6 
-- OG:gen: true 6
-- OG:before:super.gen: "6" 
6:	 pushc 6
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
8:	 pushThis 
9:	 storeg integer%$5 2
11:	 pushThis 
12:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
14:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=106 vDescInx=29 vdtTop: 2 
16:	 rtnAlloc 1
18:	 toSuper  29
DO:
21:	 mvStack 
L1:
L2:
22:	 rtnInner  M
23:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 89 false 
-- VDTentry: vdtAdd: inx=2 descInx=106 vDescInx=89 vdtTop: 2 
-- Items:GenClass: Break>for:to:repeat$111>repeat$107 descNo: 107 isValue: false 
-- Items:GenClass: Break>for:to:repeat$111>repeat$107 descNo: 22 isValue: false 

CLASS Break>for:to:repeat$111>repeat$107 dNo:107 topDno:107 orgOff:1 orgId:Break>for:to:repeat$111 orgDno:111
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- switch(true) \
--    case(inx = 1) \
--       "inx = 1: ".print \
--    case(inx = 4)
4:	 allocEventQ 
-- 1 107 true 
-- VDTentry: vdtAdd: inx=1 descInx=107 vDescInx=107 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: false 
-- switch(true) \
--    case(inx = 1) \
--       "inx = 1: ".print \
--    case(inx = 4)
-- before:isDerived 
11:	 pushThis 
12:	 invoke Break>for:to:repeat$111>repeat$107>switch$108 108 0 0
18:	 rpop 
L2:
19:	 setThisStack  
20:	 pushThis 
21:	 rtn D
23:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$111>repeat$107>switch$108 descNo: 108 i \
-- sValue: false 
-- Items:GenClass: Break>for:to:repeat$111>repeat$107>switch$108 descNo: 73 i \
-- sValue: false 
-- Items:GenClass: switch descNo: 22 isValue: false 

CLASS Break>for:to:repeat$111>repeat$107>switch$108 dNo:108 topDno:73 orgOff:3 orgId:Break>for:to:repeat$111>repeat$107 orgDno:107
-- VDTtableCopy: 73 120 
-- vdtTableCopy: I:1:73 I:2:0 
-- 2 108 true 
-- VDTentry: vdtAdd: inx=2 descInx=108 vDescInx=108 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  3 origin
-- AllocateSuper: 
-- case(inx = 1) \
--    "inx = 1: ".print \
-- case(inx = 4) \
--    "inx = 4: ".print
-- op:super switch
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$111>repeat$107%$107 3
7:	 rpushg Break>for:to:repeat$111>repeat$107%$107 1
9:	 rpushg Break>for:to:repeat$111%$111 4
11:	 rpushg Break%$68 1
13:	 rpushg demo%$67 1
15:	 rpushg workspace%$66 1
17:	 rpushg BETA 2
-- scanInv: "switch(true) " 0 0 1 
-- handleSuperArgs:E: "switch(true)" theIS: 
-- case(inx = 1) \
--    "inx = 1: ".print \
-- case(inx = 4) \
--    "inx = 4: ".print
-- super.sig:none:superAdj: 3 
-- ptn:loadArgs:E: switch(true)
-- args: switch(true)
-- E.arg: "ObjectDescriptor" true 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "switch(true) " "ObjectInvocation_KeyWord " ActArg: "
 --  true "isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: true 
-- OG:gen: true true
-- OG:before:super.gen: "true" 
-- doInvoke: true0 1 useRtnVal: true 
-- scanInv: "true " 0 1 1 
-- doInvoke:X: true0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "true " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: true
-- koks:Y: "true " 
-- ptn:loadArgs:E: true
-- args: 
-- ptn:loadArgs:end: 
-- True:  \
--    %globals \
--    out B: var boolean \
--    B := 1
-- OI:newInvoke: "true " 
19:	 invoke True 24 0 0
25:	 pushg 1 
-- loadArgs:after:actualArg:gen: false false 
-- True:  \
--    %globals \
--    out B: var boolean \
--    B := 1
-- ptn:loadArgs:end: 
-- switch:  \
--    in V: var integer \
--    %public \
--    case: 
-- handleArgumentsAndOrigin: 
27:	 pushThis 
28:	 storeg integer%$5 2
30:	 tstOriginIsNone 
31:	 rstore  1 origin
-- AllocateSuper: 
-- in V: var integer \
-- %public \
-- case:  \
--    in x: ref Indexed(1,#Integer)
33:	 allocEventQ 
-- 1 73 true 
-- VDTentry: vdtAdd: inx=1 descInx=108 vDescInx=73 vdtTop: 2 
35:	 rtnAlloc 1
37:	 toSuper  73
DO:
40:	 mvStack 
L1:
-- OG:gen: false 
-- case(inx = 1) \
--    "inx = 1: ".print
-- before:isDerived 
41:	 pushThis 
42:	 invoke Break>for:to:repeat$111>repeat$107>switch$108>case$109 109 0 0
48:	 rpop 
-- OG:gen: false 
-- case(inx = 4) \
--    "inx = 4: ".print
-- before:isDerived 
49:	 pushThis 
50:	 invoke Break>for:to:repeat$111>repeat$107>switch$108>case$110 110 0 0
56:	 rpop 
-- OG:gen: true "else: {I2S(inx)}: ".print
-- OG:before:super.gen: "else: {I2S(inx)}: .print" 
57:	 pushText "else: "
-- doInvoke: I2S(inx)0 1 useRtnVal: true 
-- scanInv: "I2S(inx) " 0 1 1 
-- doInvoke:X: I2S(inx)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "I2S(inx) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: Value
-- kuk:X: I2S(inx)
-- koks:Y: "I2S(inx) " 
-- ptn:loadArgs:E: I2S(inx)
-- args: (inx)
-- E.arg: "ObjectDescriptor" inx 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "I2S(inx) " "ObjectInvocation_Function " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
59:	 pushThis 
60:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 3
62:	 rpushg Break>for:to:repeat$111>repeat$107%$107 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
64:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- ptn:loadArgs:end: 
-- I2S:  \
--    %id "I2s" \
--    %OSDvisibility disguised \
--    %globals
-- OI:newInvoke: "I2S(inx) " 
66:	 invoke I2S 122 0 0
72:	 rpushg  2
74:	 invoke + 129 0 1
80:	 rpushg else: {I2S(inx)}:  3
82:	 pushText ": "
84:	 invoke + 129 0 1
90:	 rpushg else: {I2S(inx)}:  3
-- scanInv: ""else: {I2S(inx)}: ".print " 1 1 2 
-- doInvoke: "else: {I2S(inx)}: ".print1 2 useRtnVal: false 
-- scanInv: ""else: {I2S(inx)}: ".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "else: {I2S(inx)}: " ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""else: {I2S(inx)}: " " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
92:	 invoke print 69 0 0
98:	 rpop 
L2:
99:	 rtnInner  M
100:	 END OSDV:0 objSize:3 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$111>repeat$107>switch$108>case$109 de \
-- scNo: 109 isValue: false 
-- Items:GenClass: Break>for:to:repeat$111>repeat$107>switch$108>case$109 de \
-- scNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>for:to:repeat$111>repeat$107>switch$108>case$109 dNo:109 topDno:75 orgOff:1 orgId:Break>for:to:repeat$111>repeat$107>switch$108 orgDno:108
-- VDTtableCopy: 75 120 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 109 true 
-- VDTentry: vdtAdd: inx=2 descInx=109 vDescInx=109 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "inx = 1: ".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 1
-- scanInv: "case(inx = 1) " 0 0 1 
-- handleSuperArgs:E: "case(inx = 1)" theIS: "inx = 1: ".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(inx = 1)
-- args: case(inx = 1)
-- E.arg: "ObjectDescriptor" inx = 1 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(inx = 1) " "ObjectInvocation_KeyWord " ActArg: "
 --  inx = 1 "isValue: false formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx = 1 
-- OG:gen: true inx = 1
-- OG:before:super.gen: "inx = 1" 
7:	 pushThis 
8:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 1
10:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 3
12:	 rpushg Break>for:to:repeat$111>repeat$107%$107 1
-- scanInv: "inx = 1 " 0 1 2 
14:	 pushg 3 newInvoke
-- doInvoke: inx = 11 2 useRtnVal: true 
-- scanInv: "inx = 1 " 1 2 2 
-- doInvoke:X: = 11 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "= 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " rec.ATd: "inx: var integer " 1 false 
 --  pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = 1
-- koks:Y: "= 1 " 
-- ptn:loadArgs:E: = 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
16:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= 1 " 
18:	 eq 
-- loadArgs:after:actualArg:gen: false false 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  inx = 1   ObjectDescriptor false 1 
19:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "inx "
 --  Invocation " actualArg.theDesc: false 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  = 1 "ObjectInvocation_Binary " actualArg.theDesc: false 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
24:	 pushThis 
25:	 rstoreg x 2
27:	 tstOriginIsNone 
28:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
30:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=109 vDescInx=75 vdtTop: 2 
32:	 rtnAlloc 1
34:	 toSuper  75
DO:
37:	 mvStack 
L1:
-- OG:gen: true "inx = 1: ".print
-- OG:before:super.gen: "inx = 1: .print" 
38:	 pushText "inx = 1: "
-- scanInv: ""inx = 1: ".print " 1 1 2 
-- doInvoke: "inx = 1: ".print1 2 useRtnVal: false 
-- scanInv: ""inx = 1: ".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "inx = 1: " ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""inx = 1: " " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
40:	 invoke print 69 0 0
46:	 rpop 
L2:
47:	 rtnInner  M
48:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$111>repeat$107>switch$108>case$110 de \
-- scNo: 110 isValue: false 
-- Items:GenClass: Break>for:to:repeat$111>repeat$107>switch$108>case$110 de \
-- scNo: 75 isValue: false 
-- Items:GenClass: case descNo: 22 isValue: false 

CLASS Break>for:to:repeat$111>repeat$107>switch$108>case$110 dNo:110 topDno:75 orgOff:1 orgId:Break>for:to:repeat$111>repeat$107>switch$108 orgDno:108
-- VDTtableCopy: 75 120 
-- vdtTableCopy: I:1:75 I:2:0 
-- 2 110 true 
-- VDTentry: vdtAdd: inx=2 descInx=110 vDescInx=110 vdtTop: 2 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: "inx = 4: ".print
-- op:super case
-- push:super.origin: 
4:	 pushThis 
5:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 1
-- scanInv: "case(inx = 4) " 0 0 1 
-- handleSuperArgs:E: "case(inx = 4)" theIS: "inx = 4: ".print
-- super.sig:none:superAdj: 1 
-- ptn:loadArgs:E: case(inx = 4)
-- args: case(inx = 4)
-- E.arg: "ObjectDescriptor" inx = 4 
-- arg: in x: ref Indexed(1,#Integer) 1 1 false 
-- E.arg: in x: ref Indexed(1,#Integer) 
-- NonVirt: "case(inx = 4) " "ObjectInvocation_KeyWord " ActArg: "
 --  inx = 4 "isValue: false formalArg: "in x: ref Indexed(1,#Integer) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx = 4 
-- OG:gen: true inx = 4
-- OG:before:super.gen: "inx = 4" 
7:	 pushThis 
8:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 1
10:	 rpushg Break>for:to:repeat$111>repeat$107>switch$108%$108 3
12:	 rpushg Break>for:to:repeat$111>repeat$107%$107 1
-- scanInv: "inx = 4 " 0 1 2 
14:	 pushg 3 newInvoke
-- doInvoke: inx = 41 2 useRtnVal: true 
-- scanInv: "inx = 4 " 1 2 2 
-- doInvoke:X: = 41 2 2 pRec: none rec: inx ix->next none 
-- checkForProxy:E: "= 4 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " rec.ATd: "inx: var integer " 1 false 
 --  pRec: none E.origin: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
-- kuk:X: = 4
-- koks:Y: "= 4 " 
-- ptn:loadArgs:E: = 4
-- args: 4
-- E.arg: "ObjectDescriptor" 4 
-- arg: in Veq: var this(Value) 1 1 false 
-- E.arg: in Veq: var this(Value) 
-- NonVirt: "= 4 " "ObjectInvocation_Binary " ActArg: "4 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
-- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
-- loadArgs:before:actual.gen: 4 
-- OG:gen: true 4
-- OG:before:super.gen: "4" 
16:	 pushc 4
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- OI:newInvoke: "= 4 " 
18:	 eq 
-- loadArgs:after:actualArg:gen: false false 
-- =  :<  \
--    %basic 50 \
--    in Veq: var this(Value) \
--    out Beq: var boolean
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "
 --  Indexed(1,#Integer) true superOG.IS.newDescNo: 91 
 --  inx = 4   ObjectDescriptor false 1 
19:	 pushc 1
-- formalArg is indexed: "in x: ref Indexed(1,#Integer) "inx "
 --  Invocation " actualArg.theDesc: false 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  = 4 "ObjectInvocation_Binary " actualArg.theDesc: false 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 mkVindexed 91
-- ptn:loadArgs:end: 
-- case:  \
--    in x: ref Indexed(1,#Integer) \
--    for(1):to(x.length):repeat \
--       if (V = x.get[inx]) :then 
-- handleArgumentsAndOrigin: 
24:	 pushThis 
25:	 rstoreg x 2
27:	 tstOriginIsNone 
28:	 rstore  1 origin
-- AllocateSuper: 
-- in x: ref Indexed(1,#Integer) \
-- for(1):to(x.length):repeat \
--    if (V = x.get[inx]) :then  \
--       inner(case)
30:	 allocEventQ 
-- 1 75 true 
-- VDTentry: vdtAdd: inx=1 descInx=110 vDescInx=75 vdtTop: 2 
32:	 rtnAlloc 1
34:	 toSuper  75
DO:
37:	 mvStack 
L1:
-- OG:gen: true "inx = 4: ".print
-- OG:before:super.gen: "inx = 4: .print" 
38:	 pushText "inx = 4: "
-- scanInv: ""inx = 4: ".print " 1 1 2 
-- doInvoke: "inx = 4: ".print1 2 useRtnVal: false 
-- scanInv: ""inx = 4: ".print " 1 2 2 
-- doInvoke:X: print1 2 2 pRec: none rec: "inx = 4: " ix->next none 
-- checkForProxy:E: "print " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: ""inx = 4: " " rec.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 55 false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: print
-- koks:Y: "print " 
-- ptn:loadArgs:E: print
-- args: 
-- ptn:loadArgs:end: 
-- print:  \
--    gogo:  \
--       "gogo\n".print \
--    for(1):to(length):repeat
-- OI:newInvoke: "print " 
40:	 invoke print 69 0 0
46:	 rpop 
L2:
47:	 rtnInner  M
48:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: I2S descNo: 122 isValue: false 
-- Items:GenClass: I2S descNo: 22 isValue: false 

CLASS I2S dNo:122 topDno:122 orgOff:0 orgId:StringLib orgDno:40
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 storeg integer%$5 1
-- AllocateSuper: 
-- %id "I2s" \
-- %OSDvisibility disguised \
-- %globals \
-- in V: var integer
4:	 allocEventQ 
-- 1 122 true 
-- VDTentry: vdtAdd: inx=1 descInx=122 vDescInx=122 vdtTop: 1 
6:	 mvStack 
-- DI:StringVar "out Si2s: var String "
7:	 pushText ""
9:	 pushThis 
10:	 rstoreg Si2s 2
-- DI:isConst: D 
-- OG:gen: true Indexed(20,char)
-- OG:before:super.gen: "Indexed(20,char)" 
-- doInvoke: Indexed(20,char)0 1 useRtnVal: false 
-- scanInv: "Indexed(20,char) " 0 1 1 
-- doInvoke:X: Indexed(20,char)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "Indexed(20,char) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 3 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: Indexed(20,char)
-- koks:Y: "Indexed(20,char) " 
-- ptn:loadArgs:E: Indexed(20,char)
-- args: (20,char)
-- E.arg: "ObjectDescriptor" 20 
-- E.arg: "ObjectDescriptor" char 
-- arg: in range: var Integer 1 2 false 
-- E.arg: in range: var Integer 
-- NonVirt: "Indexed(20,char) " "ObjectInvocation_Function " 
 --  ActArg: "20 "isValue: true formalArg: "in range: var Integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 20 
-- OG:gen: true 20
-- OG:before:super.gen: "20" 
12:	 pushc 20
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: in elm:< Object 2 2 true 
-- ptn:loadArgs:end: 
-- Indexed:  \
--    %globals \
--    %basic 114 \
--    %public
-- OI:newInvoke: "Indexed(20,char) " 
14:	 pushThis 
15:	 pushc 1
17:	 allocIndexed I2S%$122 91 1 0
22:	 pushThis 
23:	 rstoreg I2S%$122 3
-- DI:isConst: D2 
-- OG:gen: true Indexed(20,char)
-- OG:before:super.gen: "Indexed(20,char)" 
-- doInvoke: Indexed(20,char)0 1 useRtnVal: false 
-- scanInv: "Indexed(20,char) " 0 1 1 
-- doInvoke:X: Indexed(20,char)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "Indexed(20,char) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 4 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: Indexed(20,char)
-- koks:Y: "Indexed(20,char) " 
-- ptn:loadArgs:E: Indexed(20,char)
-- args: (20,char)
-- E.arg: "ObjectDescriptor" 20 
-- E.arg: "ObjectDescriptor" char 
-- arg: in range: var Integer 1 2 false 
-- E.arg: in range: var Integer 
-- NonVirt: "Indexed(20,char) " "ObjectInvocation_Function " 
 --  ActArg: "20 "isValue: true formalArg: "in range: var Integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 20 
-- OG:gen: true 20
-- OG:before:super.gen: "20" 
25:	 pushc 20
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: in elm:< Object 2 2 true 
-- ptn:loadArgs:end: 
-- Indexed:  \
--    %globals \
--    %basic 114 \
--    %public
-- OI:newInvoke: "Indexed(20,char) " 
27:	 pushThis 
28:	 pushc 1
30:	 allocIndexed I2S%$122 91 1 0
35:	 pushThis 
36:	 rstoreg I2S%$122 4
38:	 rtnAlloc 1
DO:
40:	 doEventQ 
41:	 mvStack 
L1:
42:	 pushThis 
-- scanInv: "isNeg " 0 0 1 
-- OG:gen: true V < 0
-- OG:before:super.gen: "V < 0" 
43:	 pushThis 
-- scanInv: "V < 0 " 0 1 2 
44:	 pushg 1 newInvoke
-- doInvoke: V < 01 2 useRtnVal: true 
-- scanInv: "V < 0 " 1 2 2 
-- doInvoke:X: < 01 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "< 0 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: < 0
-- koks:Y: "< 0 " 
-- ptn:loadArgs:E: < 0
-- args: 0
-- E.arg: "ObjectDescriptor" 0 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "< 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 0 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
46:	 pushc 0
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- <  :  \
--    %basic 51 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "< 0 " 
48:	 lt 
-- unitConv:after 
49:	 storeg Boolean%$41 6
-- OG:gen: true 
-- if (isNeg) :then  \
--    V := 0 - V \
--    D.put('-'):at[1] \
--    L := 1
-- OG:before:super.gen: "if (isNeg) :then  \
--    V := 0 - V \
--    D.put('-'):at[1] \
--    L := 1" 
-- doInvoke: 
-- if (isNeg) :then  \
--    V := 0 - V \
--    D.put('-'):at[1] \
--    L := 10 1 useRtnVal: false 
-- scanInv: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --     D.put('-'):at[1]
 --     L := 1
 --  0 1 1 
-- doInvoke:X: 
-- if (isNeg) :then  \
--    V := 0 - V \
--    D.put('-'):at[1] \
--    L := 10 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --     D.put('-'):at[1]
 --     L := 1
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (isNeg) :then  \
--    V := 0 - V \
--    D.put('-'):at[1] \
--    L := 1
-- koks:Y: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --     D.put('-'):at[1]
 --     L := 1
 --  
-- OG:gen: true (isNeg)
-- gen:whatIsThis? 
-- OG:before:super.gen: "(isNeg)" 
51:	 pushThis 
-- scanInv: "(isNeg) " 0 0 1 
-- doInvoke: (isNeg)0 1 useRtnVal: true 
-- scanInv: "(isNeg) " 0 1 1 
-- doInvoke:X: isNeg0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "isNeg " isBasicValue: true 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %id "I2s"
 --     %OSDvisibility disguised
 --     %globals
 --     in V: var integer
-- kuk:X: isNeg
-- koks:Y: "isNeg " 
-- ptn:loadArgs:E: isNeg
-- args: 
-- ptn:loadArgs:end: 
-- Boolean: value \
--    %id "Boolean" \
--    %globals inSub \
--    %basic 4, 8
-- OI:newInvoke: "isNeg " 
-- DI:newInvoke: "isNeg: var Boolean " off: 3 valueOff: 0 E: "
 --  isNeg " next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "isNeg " isAdr: false valueOff: 0 
52:	 pushg 6 newInvoke
54:	 jmpFalse  L4
L3:
-- OG:gen: false 
-- V := 0 - V \
--    D.put('-'):at[1] \
--    L := 1
-- before:isDerived 
57:	 pushThis 
58:	 invoke I2S>$123 123 0 0
64:	 rpop 
L4:
-- OG:gen: false 
-- L := L + 1 \
--    D.put('0' + V /% 10):at[L] \
--    V := V // 10 \
--    if (V > 0) :then 
-- before:isDerived 
65:	 pushThis 
66:	 invoke loop 127 0 0
72:	 rpop 
-- OG:gen: true 
-- for(1):to(L):repeat \
--    D2.put(D.get[L + 1 - inx]):at[inx] \
-- 
-- before:isDerived 
73:	 pushThis 
74:	 invoke I2S>for:to:repeat$125 125 0 0
80:	 rpop 
81:	 pushThis 
-- scanInv: "Si2s " 0 0 1 
-- OG:gen: true D2.asString
-- OG:before:super.gen: "D2.asString" 
82:	 pushThis 
-- scanInv: "D2.asString " 0 1 2 
83:	 rpushg newInvoke 4
-- doInvoke: D2.asString1 2 useRtnVal: true 
-- scanInv: "D2.asString " 1 2 2 
-- doInvoke:X: asString1 2 2 pRec: none rec: D2 ix->next none 
-- checkForProxy:E: "asString " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "D2 " rec.ATd: "
 --  D2: obj Indexed(20,char) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: asString
-- koks:Y: "asString " 
-- ptn:loadArgs:E: asString
-- args: 
-- ptn:loadArgs:end: 
-- asString:  \
--    %basic 118 \
--          -- converts this (indexed) to a String \
--          -- we should move String to here and qualify S as String
-- OI:newInvoke: "asString " 
85:	 %asString 118
87:	 rswap 0
89:	 rstoreg String%$10 2
L2:
91:	 setThisStack  
92:	 pushThis 
93:	 rtn D
95:	 END OSDV:2 objSize:6 isIndexed:0
-- Items:GenClass: I2S>$123 descNo: 123 isValue: false 
-- Items:GenClass: I2S>$123 descNo: 22 isValue: false 

CLASS I2S>$123 dNo:123 topDno:123 orgOff:1 orgId:I2S orgDno:122
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- V := 0 - V \
-- D.put('-'):at[1] \
-- L := 1
4:	 allocEventQ 
-- 1 123 true 
-- VDTentry: vdtAdd: inx=1 descInx=123 vDescInx=123 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg I2S>$123%$123 1
-- scanInv: "V " 0 0 1 
-- OG:gen: true 0 - V
-- OG:before:super.gen: "0 - V" 
14:	 pushc 0
-- scanInv: "0 - V " 1 1 2 
-- doInvoke: 0 - V1 2 useRtnVal: true 
-- scanInv: "0 - V " 1 2 2 
-- doInvoke:X: - V1 2 2 pRec: none rec: 0 ix->next none 
-- checkForProxy:E: "- V " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "0 " rec.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals1 false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: - V
-- koks:Y: "- V " 
-- ptn:loadArgs:E: - V
-- args: V
-- E.arg: "ObjectDescriptor" V 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "- V " "ObjectInvocation_Binary " ActArg: "V "isValue: 
 --  false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: V 
-- OG:gen: true V
-- gen:whatIsThis? 
-- OG:before:super.gen: "V" 
16:	 pushThis 
17:	 rpushg I2S>$123%$123 1
-- scanInv: "V " 0 0 1 
-- doInvoke: V0 1 useRtnVal: true 
-- scanInv: "V " 0 1 1 
-- doInvoke:X: V0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "V " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %id "I2s"
 --     %OSDvisibility disguised
 --     %globals
 --     in V: var integer
-- kuk:X: V
-- koks:Y: "V " 
-- ptn:loadArgs:E: V
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "V " 
-- DI:newInvoke: "in V: var integer " off: 1 valueOff: 0 E: "V " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "V " isAdr: false valueOff: 0 
19:	 pushg 1 newInvoke
-- loadArgs:after:actualArg:gen: false true in V: var integer
-- ptn:loadArgs:end: 
-- -  :  \
--    %basic 62 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "- V " 
21:	 minus 
-- unitConv:after 
22:	 storeg integer%$5 1
-- OG:gen: true D.put('-'):at[1]
-- OG:before:super.gen: "D.put('-'):at[1]" 
24:	 pushThis 
25:	 rpushg I2S>$123%$123 1
-- scanInv: "D.put('-'):at[1] " 0 1 2 
27:	 rpushg newInvoke 3
-- doInvoke: D.put('-'):at[1]1 2 useRtnVal: false 
-- scanInv: "D.put('-'):at[1] " 1 2 2 
-- doInvoke:X: put('-'):at[1]1 2 2 pRec: none rec: D ix->next none 
-- checkForProxy:E: "put('-'):at[1] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "D " rec.ATd: "
 --  D: obj Indexed(20,char) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: put('-'):at[1]
-- koks:Y: "put('-'):at[1] " 
-- ptn:loadArgs:E: put('-'):at[1]
-- args: put('-'):at[1]
-- E.arg: "ObjectDescriptor" '-' 
-- E.arg: "ObjectDescriptor" 1 
-- arg: V: var integer 1 2 false 
-- E.arg: V: var integer 
-- NonVirt: "put('-'):at[1] " "ObjectInvocation_KeyWord " ActArg: "
 --  '-' "isValue: true formalArg: "V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: '-' 
-- OG:gen: true '-'
-- OG:before:super.gen: "'-'" 
29:	 pushc 45
-- loadArgs:after:actualArg:gen: false false 
-- char: value \
--    %id "char" \
--    %globals \
--    %basic 3, 16
-- arg: inx: var integer 2 2 false 
-- E.arg: inx: var integer 
-- NonVirt: "put('-'):at[1] " "ObjectInvocation_KeyWord " ActArg: "1 "
 --  isValue: true formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
31:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: V: var integer 3 2 false 
-- arg: inx: var integer 4 2 false 
-- arg: V: var integer 5 2 false 
-- arg: inx: var integer 6 2 false 
-- ptn:loadArgs:end: 
-- put(V: var integer):at[inx: var integer]:  \
--    %basic 115
-- OI:newInvoke: "put('-'):at[1] " 
-- getIndexedArgs:rec.ATd: D: obj Indexed(20,char)
33:	 xstoreg inx  size:1 isValueObj:0
36:	 pushThis 
37:	 rpushg I2S>$123%$123 1
-- scanInv: "L " 0 0 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
39:	 pushc 1
41:	 storeg integer%$5 5
L2:
43:	 setThisStack  
44:	 pushThis 
45:	 rtn D
47:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop descNo: 127 isValue: false 
-- Items:GenClass: loop descNo: 22 isValue: false 

CLASS loop dNo:127 topDno:127 orgOff:1 orgId:I2S orgDno:122
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- L := L + 1 \
-- D.put('0' + V /% 10):at[L] \
-- V := V // 10 \
-- if (V > 0) :then 
4:	 allocEventQ 
-- 1 127 true 
-- VDTentry: vdtAdd: inx=1 descInx=127 vDescInx=127 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg loop%$127 1
-- scanInv: "L " 0 0 1 
-- OG:gen: true L + 1
-- OG:before:super.gen: "L + 1" 
14:	 pushThis 
15:	 rpushg loop%$127 1
-- scanInv: "L + 1 " 0 1 2 
17:	 pushg 5 newInvoke
-- doInvoke: L + 11 2 useRtnVal: true 
-- scanInv: "L + 1 " 1 2 2 
-- doInvoke:X: + 11 2 2 pRec: none rec: L ix->next none 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + 1
-- koks:Y: "+ 1 " 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
19:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ 1 " 
21:	 plus 
-- unitConv:after 
22:	 storeg integer%$5 5
-- OG:gen: true D.put('0' + V /% 10):at[L]
-- OG:before:super.gen: "D.put('0' + V /% 10):at[L]" 
24:	 pushThis 
25:	 rpushg loop%$127 1
-- scanInv: "D.put('0' + V /% 10):at[L] " 0 1 2 
27:	 rpushg newInvoke 3
-- doInvoke: D.put('0' + V /% 10):at[L]1 2 useRtnVal: false 
-- scanInv: "D.put('0' + V /% 10):at[L] " 1 2 2 
-- doInvoke:X: put('0' + V /% 10):at[L]1 2 2 pRec: none rec: D ix->next none 
-- checkForProxy:E: "put('0' + V /% 10):at[L] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "D " rec.ATd: "
 --  D: obj Indexed(20,char) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: put('0' + V /% 10):at[L]
-- koks:Y: "put('0' + V /% 10):at[L] " 
-- ptn:loadArgs:E: put('0' + V /% 10):at[L]
-- args: put('0' + V /% 10):at[L]
-- E.arg: "ObjectDescriptor" '0' + V /% 10 
-- E.arg: "ObjectDescriptor" L 
-- arg: V: var integer 1 2 false 
-- E.arg: V: var integer 
-- NonVirt: "put('0' + V /% 10):at[L] " "ObjectInvocation_KeyWord " 
 --  ActArg: "'0' + V /% 10 "isValue: false formalArg: "V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: '0' + V /% 10 
-- OG:gen: true '0' + V /% 10
-- OG:before:super.gen: "'0' + V /% 10" 
29:	 pushc 48
-- scanInv: "'0' + V /% 10 " 1 1 2 
-- doInvoke: '0' + V /% 101 2 useRtnVal: true 
-- scanInv: "'0' + V /% 10 " 1 2 2 
-- doInvoke:X: + V /% 101 2 2 pRec: none rec: '0' ix->next none 
-- checkForProxy:E: "+ V /% 10 " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "'0' " rec.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 163 false pRec: none E.origin: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
-- kuk:X: + V /% 10
-- koks:Y: "+ V /% 10 " 
-- ptn:loadArgs:E: + V /% 10
-- args: V /% 10
-- E.arg: "ObjectDescriptor" V /% 10 
-- arg: in V: var char 1 1 false 
-- E.arg: in V: var char 
-- NonVirt: "+ V /% 10 " "ObjectInvocation_Binary " ActArg: "V /% 10 "
 --  isValue: false formalArg: "in V: var char " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: V /% 10 
-- OG:gen: true V /% 10
-- OG:before:super.gen: "V /% 10" 
31:	 pushThis 
32:	 rpushg loop%$127 1
-- scanInv: "V /% 10 " 0 1 2 
34:	 pushg 1 newInvoke
-- doInvoke: V /% 101 2 useRtnVal: true 
-- scanInv: "V /% 10 " 1 2 2 
-- doInvoke:X: /% 101 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "/% 10 " isBasicValue: false 
 --  E.origin.isValueObj: true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 
 --  false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- checkForProxy:rec=None:localInvocation? "V /% 10 " E: "/% 10 " 
 --  rec: "V " 
-- kuk:X: /% 10
-- koks:Y: "/% 10 " 
-- ptn:loadArgs:E: /% 10
-- args: 10
-- E.arg: "ObjectDescriptor" 10 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "/% 10 " "ObjectInvocation_Binary " ActArg: "10 "
 --  isValue: true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 10 
-- OG:gen: true 10
-- OG:before:super.gen: "10" 
36:	 pushc 10
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- /%  :  \
--    %basic 69 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "/% 10 " 
38:	 modd 
-- unitConv:after 
-- loadArgs:after:actualArg:gen: false false 
-- /%  :  \
--    %basic 69 \
--    in V: var integer \
--    out R: var integer
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var char \
--    out R: var char
-- OI:newInvoke: "+ V /% 10 " 
39:	 plus 
-- unitConv:after 
-- loadArgs:after:actualArg:gen: false false 
-- +  :  \
--    %basic 61 \
--    in V: var char \
--    out R: var char
-- arg: inx: var integer 2 2 false 
-- E.arg: inx: var integer 
-- NonVirt: "put('0' + V /% 10):at[L] " "ObjectInvocation_KeyWord " 
 --  ActArg: "L "isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L 
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
40:	 pushThis 
41:	 rpushg loop%$127 1
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %id "I2s"
 --     %OSDvisibility disguised
 --     %globals
 --     in V: var integer
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 2 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
43:	 pushg 5 newInvoke
-- loadArgs:after:actualArg:gen: false true L: var integer
-- arg: V: var integer 3 2 false 
-- arg: inx: var integer 4 2 false 
-- arg: V: var integer 5 2 false 
-- arg: inx: var integer 6 2 false 
-- ptn:loadArgs:end: 
-- put(V: var integer):at[inx: var integer]:  \
--    %basic 115
-- OI:newInvoke: "put('0' + V /% 10):at[L] " 
-- getIndexedArgs:rec.ATd: D: obj Indexed(20,char)
45:	 xstoreg inx  size:1 isValueObj:0
48:	 pushThis 
49:	 rpushg loop%$127 1
-- scanInv: "V " 0 0 1 
-- OG:gen: true V // 10
-- OG:before:super.gen: "V // 10" 
51:	 pushThis 
52:	 rpushg loop%$127 1
-- scanInv: "V // 10 " 0 1 2 
54:	 pushg 1 newInvoke
-- doInvoke: V // 101 2 useRtnVal: true 
-- scanInv: "V // 10 " 1 2 2 
-- doInvoke:X: // 101 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "// 10 " isBasicValue: false 
 --  E.origin.isValueObj: true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 
 --  false pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- checkForProxy:rec=None:localInvocation? "V // 10 " E: "// 10 " 
 --  rec: "V " 
-- kuk:X: // 10
-- koks:Y: "// 10 " 
-- ptn:loadArgs:E: // 10
-- args: 10
-- E.arg: "ObjectDescriptor" 10 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "// 10 " "ObjectInvocation_Binary " ActArg: "10 "
 --  isValue: true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 10 
-- OG:gen: true 10
-- OG:before:super.gen: "10" 
56:	 pushc 10
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- //  :  \
--    %basic 68 \
--    in V: var integer \
--    out B: var integer
-- OI:newInvoke: "// 10 " 
58:	 idiv 
-- unitConv:after 
59:	 storeg integer%$5 1
-- OG:gen: true 
-- if (V > 0) :then  \
--    restart(loop)
-- OG:before:super.gen: "if (V > 0) :then  \
--    restart(loop)" 
-- doInvoke: 
-- if (V > 0) :then  \
--    restart(loop)0 1 useRtnVal: false 
-- scanInv: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  0 1 1 
-- doInvoke:X: 
-- if (V > 0) :then  \
--    restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: 
-- if (V > 0) :then  \
--    restart(loop)
-- koks:Y: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
-- OG:gen: true (V > 0)
-- OG:before:super.gen: "(V > 0)" 
61:	 pushThis 
62:	 rpushg loop%$127 1
-- scanInv: "(V > 0) " 0 1 2 
64:	 pushg 1 newInvoke
-- doInvoke: (V > 0)1 2 useRtnVal: true 
-- scanInv: "(V > 0) " 1 2 2 
-- doInvoke:X: > 01 2 2 pRec: none rec: V ix->next none 
-- checkForProxy:E: "> 0 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "V " rec.ATd: "in V: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: > 0
-- koks:Y: "> 0 " 
-- ptn:loadArgs:E: > 0
-- args: 0
-- E.arg: "ObjectDescriptor" 0 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "> 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 0 
-- OG:gen: true 0
-- OG:before:super.gen: "0" 
66:	 pushc 0
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- >  :  \
--    %basic 53 \
--    in V: var integer \
--    out B: var boolean
-- OI:newInvoke: "> 0 " 
68:	 gt 
-- unitConv:after 
69:	 jmpFalse  L4
L3:
-- OG:gen: false restart(loop)
-- before:isDerived 
72:	 pushThis 
73:	 invoke loop>$128 128 0 0
79:	 rpop 
L4:
L2:
80:	 setThisStack  
81:	 pushThis 
82:	 rtn D
84:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: loop>$128 descNo: 128 isValue: false 
-- Items:GenClass: loop>$128 descNo: 22 isValue: false 

CLASS loop>$128 dNo:128 topDno:128 orgOff:1 orgId:loop orgDno:127
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: restart(loop)
4:	 allocEventQ 
-- 1 128 true 
-- VDTentry: vdtAdd: inx=1 descInx=128 vDescInx=128 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true restart(loop)
-- OG:before:super.gen: "restart(loop)" 
-- scanInv: "restart(loop) " 0 0 1 
-- doInvoke: restart(loop)0 1 useRtnVal: false 
-- scanInv: "restart(loop) " 0 1 1 
-- doInvoke:X: restart(loop)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "restart(loop) " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: restart(loop)
-- koks:Y: "restart(loop) " 
-- ptn:loadArgs:end: 
-- restart(V: var integer):  -- odd parameter type! \
--    %basic 102
-- OI:newInvoke: "restart(loop) " 
11:	 break  1 1 127 0
L2:
18:	 setThisStack  
19:	 pushThis 
20:	 rtn D
22:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: I2S>for:to:repeat$125>repeat$124 descNo: 124 isValue: false 
-- Items:GenClass: I2S>for:to:repeat$125>repeat$124 descNo: 22 isValue: false 

CLASS I2S>for:to:repeat$125>repeat$124 dNo:124 topDno:124 orgOff:1 orgId:I2S>for:to:repeat$125 orgDno:125
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: D2.put(D.get[L + 1 - inx]):at[inx]
4:	 allocEventQ 
-- 1 124 true 
-- VDTentry: vdtAdd: inx=1 descInx=124 vDescInx=124 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
-- OG:gen: true D2.put(D.get[L + 1 - inx]):at[inx]
-- OG:before:super.gen: "D2.put(D.get[L + 1 - inx]):at[inx]" 
11:	 pushThis 
12:	 rpushg I2S>for:to:repeat$125>repeat$124%$124 1
14:	 rpushg I2S>for:to:repeat$125%$125 4
-- scanInv: "D2.put(D.get[L + 1 - inx]):at[inx] " 0 1 2 
16:	 rpushg newInvoke 4
-- doInvoke: D2.put(D.get[L + 1 - inx]):at[inx]1 2 useRtnVal: false 
-- scanInv: "D2.put(D.get[L + 1 - inx]):at[inx] " 1 2 2 
-- doInvoke:X: put(D.get[L + 1 - inx]):at[inx]1 2 2 pRec: none rec: D2 ix->next none 
-- checkForProxy:E: "put(D.get[L + 1 - inx]):at[inx] " 
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 rec: "D2 " 
 --  rec.ATd: "D2: obj Indexed(20,char) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: put(D.get[L + 1 - inx]):at[inx]
-- koks:Y: "put(D.get[L + 1 - inx]):at[inx] " 
-- ptn:loadArgs:E: put(D.get[L + 1 - inx]):at[inx]
-- args: put(D.get[L + 1 - inx]):at[inx]
-- E.arg: "ObjectDescriptor" D.get[L + 1 - inx] 
-- E.arg: "ObjectDescriptor" inx 
-- arg: V: var integer 1 2 false 
-- E.arg: V: var integer 
-- NonVirt: "put(D.get[L + 1 - inx]):at[inx] " "
 --  ObjectInvocation_KeyWord " ActArg: "D.get[L + 1 - inx] "isValue: false formalArg: "
 --  V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: D.get[L + 1 - inx] 
-- OG:gen: true D.get[L + 1 - inx]
-- OG:before:super.gen: "D.get[L + 1 - inx]" 
18:	 pushThis 
19:	 rpushg I2S>for:to:repeat$125>repeat$124%$124 1
21:	 rpushg I2S>for:to:repeat$125%$125 4
-- scanInv: "D.get[L + 1 - inx] " 0 1 2 
23:	 rpushg newInvoke 3
-- doInvoke: D.get[L + 1 - inx]1 2 useRtnVal: true 
-- scanInv: "D.get[L + 1 - inx] " 1 2 2 
-- doInvoke:X: get[L + 1 - inx]1 2 2 pRec: none rec: D ix->next none 
-- checkForProxy:E: "get[L + 1 - inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "D " rec.ATd: "
 --  D: obj Indexed(20,char) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: get[L + 1 - inx]
-- koks:Y: "get[L + 1 - inx] " 
-- ptn:loadArgs:E: get[L + 1 - inx]
-- args: get[L + 1 - inx]
-- E.arg: "ObjectDescriptor" L + 1 - inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[L + 1 - inx] " "ObjectInvocation_KeyWord " ActArg: "
 --  L + 1 - inx "isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L + 1 - inx 
-- OG:gen: true L + 1 - inx
-- OG:before:super.gen: "L + 1 - inx" 
25:	 pushThis 
26:	 rpushg I2S>for:to:repeat$125>repeat$124%$124 1
28:	 rpushg I2S>for:to:repeat$125%$125 4
-- scanInv: "L + 1 - inx " 0 2 3 
30:	 pushg 5 newInvoke
-- loadAccessor:X: + 1rec: L 
-- ptn:loadArgs:E: + 1
-- args: 1
-- E.arg: "ObjectDescriptor" 1 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
32:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- Bobs:A: + 1 2 2 rec L rec.ATd L: var integerfalse  - inx 
-- checkForProxy:E: "+ 1 " isBasicValue: true E.origin.isValueObj: 
 --  true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- After proxy + 1 
-- OI:newInvoke: "+ 1 " 
34:	 plus 
-- unitConv:after 
-- scanInv: "L + 1 - inx " 2 2 3 
-- start>0: L + 1 
-- doInvoke: L + 1 - inx2 3 useRtnVal: true 
-- scanInv: "L + 1 - inx " 2 3 3 
-- start>0: L + 1 
-- doInvoke:X: - inx2 3 3 pRec: L rec: + 1 ix->next none 
-- checkForProxy:E: "- inx " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "+ 1 " rec.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  61 false pRec: "L " E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: - inx
-- koks:Y: "- inx " 
-- ptn:loadArgs:E: - inx
-- args: inx
-- E.arg: "ObjectDescriptor" inx 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "- inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
35:	 pushThis 
36:	 rpushg I2S>for:to:repeat$125>repeat$124%$124 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
38:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- ptn:loadArgs:end: 
-- -  :  \
--    %basic 62 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "- inx " 
40:	 minus 
-- unitConv:after 
-- loadArgs:after:actualArg:gen: false false 
-- -  :  \
--    %basic 62 \
--    in V: var integer \
--    out R: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- OI:newInvoke: "get[L + 1 - inx] " 
-- getIndexedArgs:rec.ATd: D: obj Indexed(20,char)
41:	 xpushg  inx 1 0
-- loadArgs:after:actualArg:gen: false false 
-- get[inx: var integer]:  \
--    %basic 116 \
--    out V: var integer
-- arg: inx: var integer 2 2 false 
-- E.arg: inx: var integer 
-- NonVirt: "put(D.get[L + 1 - inx]):at[inx] " "
 --  ObjectInvocation_KeyWord " ActArg: "inx "isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
44:	 pushThis 
45:	 rpushg I2S>for:to:repeat$125>repeat$124%$124 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
47:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: V: var integer 3 2 false 
-- arg: inx: var integer 4 2 false 
-- arg: V: var integer 5 2 false 
-- arg: inx: var integer 6 2 false 
-- ptn:loadArgs:end: 
-- put(V: var integer):at[inx: var integer]:  \
--    %basic 115
-- OI:newInvoke: "put(D.get[L + 1 - inx]):at[inx] " 
-- getIndexedArgs:rec.ATd: D2: obj Indexed(20,char)
49:	 xstoreg inx  size:1 isValueObj:0
L2:
52:	 setThisStack  
53:	 pushThis 
54:	 rtn D
56:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: I2S>for:to:repeat$125 descNo: 125 isValue: false 
-- Items:GenClass: I2S>for:to:repeat$125 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS I2S>for:to:repeat$125 dNo:125 topDno:29 orgOff:4 orgId:I2S orgDno:122
-- VDTtableCopy: 29 130 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(L):repeat \
--    D2.put(D.get[L + 1 - inx]):at[inx] \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(L):repeat \
--    D2.put(D.get[L + 1 - inx]):at[inx] \
-- 
-- args: 
-- for(1):to(L):repeat \
--    D2.put(D.get[L + 1 - inx]):at[inx] \
-- 
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" L 
-- E.arg: "ObjectDescriptor" D2.put(D.get[L + 1 - inx]):at[inx] 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(L):repeat
 --     D2.put(D.get[L + 1 - inx]):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(L):repeat
 --     D2.put(D.get[L + 1 - inx]):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L 
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
6:	 pushThis 
7:	 rpushg I2S%$122 4
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %id "I2s"
 --     %OSDvisibility disguised
 --     %globals
 --     in V: var integer
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 2 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
9:	 pushg 5 newInvoke
-- loadArgs:after:actualArg:gen: false true L: var integer
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
11:	 pushThis 
12:	 storeg integer%$5 2
14:	 pushThis 
15:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
17:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=125 vDescInx=29 vdtTop: 2 
19:	 rtnAlloc 1
21:	 toSuper  29
DO:
24:	 mvStack 
L1:
L2:
25:	 rtnInner  M
26:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 124 false 
-- VDTentry: vdtAdd: inx=2 descInx=125 vDescInx=124 vdtTop: 2 
-- Items:GenClass: asString descNo: 126 isValue: false 
-- Items:GenClass: asString descNo: 22 isValue: false 

CLASS asString dNo:126 topDno:126 orgOff:1 orgId:Indexed orgDno:91
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- %basic 118 \
--          -- converts this (indexed) to a String \
--          -- we should move String to here and qualify S as String \
--          --%if _cond: var boolean %then% _thenPart:< Object:
4:	 allocEventQ 
-- 1 126 true 
-- VDTentry: vdtAdd: inx=1 descInx=126 vDescInx=126 vdtTop: 1 
6:	 mvStack 
-- DI:StringVar "out S: var LIB.StringLib.String "
7:	 pushText ""
9:	 pushThis 
10:	 rstoreg S 2
12:	 rtnAlloc 1
DO:
14:	 doEventQ 
15:	 mvStack 
L1:
L2:
16:	 setThisStack  
17:	 pushThis 
18:	 rtn D
20:	 END OSDV:0 objSize:2 isIndexed:0
-- Items:GenClass: Break>for:to:repeat$111 descNo: 111 isValue: false 
-- Items:GenClass: Break>for:to:repeat$111 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS Break>for:to:repeat$111 dNo:111 topDno:29 orgOff:4 orgId:Break orgDno:68
-- VDTtableCopy: 29 130 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(5):repeat \
--    switch(true) \
--       case(inx = 1) \
--          inx = 1: .print \
--       case(inx = 4) \
--          inx = 4: .print \
--       else: {I2S(inx)}: .print \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(5):repeat \
--    switch(true) \
--       case(inx = 1) \
--          "inx = 1: ".print
-- args: 
-- for(1):to(5):repeat \
--    switch(true) \
--       case(inx = 1) \
--          "inx = 1: ".print
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" 5 
-- E.arg: "ObjectDescriptor" switch(true) \
--       case(inx = 1) \
--          inx = 1: .print \
--       case(inx = 4) \
--          inx = 4: .print \
--       else: {I2S(inx)}: .print 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(5):repeat
 --     switch(true)
 --        case(inx = 1)
 --           "inx = 1: ".print"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(5):repeat
 --     switch(true)
 --        case(inx = 1)
 --           "inx = 1: ".print"ObjectInvocation_KeyWord " ActArg: "5 "isValue: true formalArg: "
 --  last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 5 
-- OG:gen: true 5
-- OG:before:super.gen: "5" 
6:	 pushc 5
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
8:	 pushThis 
9:	 storeg integer%$5 2
11:	 pushThis 
12:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
14:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=111 vDescInx=29 vdtTop: 2 
16:	 rtnAlloc 1
18:	 toSuper  29
DO:
21:	 mvStack 
L1:
L2:
22:	 rtnInner  M
23:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 107 false 
-- VDTentry: vdtAdd: inx=2 descInx=111 vDescInx=107 vdtTop: 2 
-- Items:GenClass: + descNo: 129 isValue: false 
-- Items:GenClass: + descNo: 22 isValue: false 

CLASS + dNo:129 topDno:129 orgOff:1 orgId:String orgDno:10
-- handleArgumentsAndOrigin: 
1:	 pushThis 
2:	 rstoreg S 2
4:	 tstOriginIsNone 
5:	 rstore  1 origin
-- AllocateSuper: 
-- in S: var String \
-- out V: var String \
-- L: var integer \
-- L := Length
7:	 allocEventQ 
-- 1 129 true 
-- VDTentry: vdtAdd: inx=1 descInx=129 vDescInx=129 vdtTop: 1 
9:	 mvStack 
-- DI:StringVar "out V: var String "
10:	 pushText ""
12:	 pushThis 
13:	 rstoreg V 3
15:	 rtnAlloc 1
DO:
17:	 doEventQ 
18:	 mvStack 
L1:
19:	 pushThis 
-- scanInv: "L " 0 0 1 
-- OG:gen: true Length
-- OG:before:super.gen: "Length" 
20:	 pushThis 
21:	 rpushg +%$129 1
-- scanInv: "Length " 0 0 1 
-- doInvoke: Length0 1 useRtnVal: true 
-- scanInv: "Length " 0 1 1 
-- doInvoke:X: Length0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "Length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: Length
-- koks:Y: "Length " 
-- ptn:loadArgs:E: Length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: "Length " 
23:	 invoke length 16 0 0
29:	 pushg 2 
31:	 storeg integer%$5 4
-- OG:gen: false 
-- e: var integer \
--    i: var integer \
--    T: obj Indexed(L + S.length,Integer) \
--    for(1):to(L):repeat
-- before:isDerived 
33:	 pushThis 
34:	 invoke doplus 130 0 0
40:	 rpop 
L2:
41:	 setThisStack  
42:	 pushThis 
43:	 rtn D
45:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: doplus descNo: 130 isValue: false 
-- Items:GenClass: doplus descNo: 22 isValue: false 

CLASS doplus dNo:130 topDno:130 orgOff:1 orgId:+ orgDno:129
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- e: var integer \
-- i: var integer \
-- T: obj Indexed(L + S.length,Integer) \
-- for(1):to(L):repeat
4:	 allocEventQ 
-- 1 130 true 
-- VDTentry: vdtAdd: inx=1 descInx=130 vDescInx=130 vdtTop: 1 
6:	 mvStack 
-- DI:isConst: T 
-- OG:gen: true Indexed(L + S.length,Integer)
-- OG:before:super.gen: "Indexed(L + S.length,Integer)" 
-- doInvoke: Indexed(L + S.length,Integer)0 1 useRtnVal: false 
-- scanInv: "Indexed(L + S.length,Integer) " 0 1 1 
-- doInvoke:X: Indexed(L + S.length,Integer)0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "Indexed(L + S.length,Integer) " isBasicValue: 
 --  false E.origin.isValueObj: false staticOff: 4 rec: none pRec: none 
 --  E.origin: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
-- kuk:X: Indexed(L + S.length,Integer)
-- koks:Y: "Indexed(L + S.length,Integer) " 
-- ptn:loadArgs:E: Indexed(L + S.length,Integer)
-- args: (L + S.length,Integer)
-- E.arg: "ObjectDescriptor" L + S.length 
-- E.arg: "ObjectDescriptor" Integer 
-- arg: in range: var Integer 1 2 false 
-- E.arg: in range: var Integer 
-- NonVirt: "Indexed(L + S.length,Integer) " "
 --  ObjectInvocation_Function " ActArg: "L + S.length "isValue: false formalArg: "
 --  in range: var Integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L + S.length 
-- OG:gen: true L + S.length
-- OG:before:super.gen: "L + S.length" 
7:	 pushThis 
8:	 rpushg doplus%$130 1
-- scanInv: "L + S.length " 0 1 2 
10:	 pushg 4 newInvoke
-- doInvoke: L + S.length1 2 useRtnVal: true 
-- scanInv: "L + S.length " 1 2 2 
-- doInvoke:X: + S.length1 2 2 pRec: none rec: L ix->next none 
-- checkForProxy:E: "+ S.length " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + S.length
-- koks:Y: "+ S.length " 
-- ptn:loadArgs:E: + S.length
-- args: S.length
-- E.arg: "ObjectDescriptor" S.length 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ S.length " "ObjectInvocation_Binary " ActArg: "
 --  S.length "isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: S.length 
-- OG:gen: true S.length
-- OG:before:super.gen: "S.length" 
12:	 pushThis 
13:	 rpushg doplus%$130 1
-- scanInv: "S.length " 0 1 2 
15:	 rpushg newInvoke 2
-- doInvoke: S.length1 2 useRtnVal: true 
-- scanInv: "S.length " 1 2 2 
-- doInvoke:X: length1 2 2 pRec: none rec: S ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "S " rec.ATd: "in S: var String " 5 
 --  false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: "length " 
17:	 invoke length 16 0 0
23:	 pushg 2 
-- loadArgs:after:actualArg:gen: false false 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ S.length " 
25:	 plus 
-- unitConv:after 
-- loadArgs:after:actualArg:gen: false false 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- arg: in elm:< Object 2 2 true 
-- ptn:loadArgs:end: 
-- Indexed:  \
--    %globals \
--    %basic 114 \
--    %public
-- OI:newInvoke: "Indexed(L + S.length,Integer) " 
26:	 pushThis 
27:	 pushc 1
29:	 allocIndexed doplus%$130 91 1 0
34:	 pushThis 
35:	 rstoreg doplus%$130 4
37:	 rtnAlloc 1
DO:
39:	 doEventQ 
40:	 mvStack 
L1:
-- OG:gen: true 
-- for(1):to(L):repeat \
--    e := get[inx] \
--    T.put(e):at[inx] \
-- 
-- before:isDerived 
41:	 pushThis 
42:	 invoke doplus>for:to:repeat$132 132 0 0
48:	 rpop 
-- OG:gen: true 
-- for(1):to(S.length):repeat \
--    e := S.get[inx] \
--    i := L + inx \
--    T.put(e):at[i]
-- before:isDerived 
49:	 pushThis 
50:	 invoke doplus>for:to:repeat$134 134 0 0
56:	 rpop 
57:	 pushThis 
58:	 rpushg doplus%$130 1
-- scanInv: "V " 0 0 1 
-- OG:gen: true 
-- T.asString \
--          -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]
-- OG:before:super.gen: "T.asString \
--          -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]" 
60:	 pushThis 
-- scanInv: 
 --  T.asString
 --           -- V: obj Indexed(Length + S.length)
 --           -- V := T[1:length] + S.T[1:S.length]
 --  0 1 2 
61:	 rpushg newInvoke 4
-- doInvoke: 
-- T.asString \
--          -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]1 2 useRtnVal: true 
-- scanInv: 
 --  T.asString
 --           -- V: obj Indexed(Length + S.length)
 --           -- V := T[1:length] + S.T[1:S.length]
 --  1 2 2 
-- doInvoke:X: 
-- asString \
--          -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]1 2 2 pRec: none rec: T ix->next none 
-- checkForProxy:E: 
 --  asString
 --           -- V: obj Indexed(Length + S.length)
 --           -- V := T[1:length] + S.T[1:S.length]
 --  isBasicValue: false E.origin.isValueObj: false staticOff: 0 
 --  rec: "T " rec.ATd: "T: obj Indexed(L + S.length,Integer) " 114 true 
 --  pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: 
-- asString \
--          -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]
-- koks:Y: 
 --  asString
 --           -- V: obj Indexed(Length + S.length)
 --           -- V := T[1:length] + S.T[1:S.length]
 --  
-- ptn:loadArgs:E: 
-- asString \
--          -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]
-- args: 
-- -- V: obj Indexed(Length + S.length) \
--          -- V := T[1:length] + S.T[1:S.length]
-- ptn:loadArgs:end: 
-- asString:  \
--    %basic 118 \
--          -- converts this (indexed) to a String \
--          -- we should move String to here and qualify S as String
-- OI:newInvoke: 
 --  asString
 --           -- V: obj Indexed(Length + S.length)
 --           -- V := T[1:length] + S.T[1:S.length]
 --  
63:	 %asString 118
65:	 rswap 0
67:	 rstoreg String%$10 3
L2:
69:	 setThisStack  
70:	 pushThis 
71:	 rtn D
73:	 END OSDV:0 objSize:4 isIndexed:0
-- Items:GenClass: doplus>for:to:repeat$132>repeat$131 descNo: 131 isValue: false 
-- Items:GenClass: doplus>for:to:repeat$132>repeat$131 descNo: 22 isValue: false 

CLASS doplus>for:to:repeat$132>repeat$131 dNo:131 topDno:131 orgOff:1 orgId:doplus>for:to:repeat$132 orgDno:132
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- e := get[inx] \
-- T.put(e):at[inx]
4:	 allocEventQ 
-- 1 131 true 
-- VDTentry: vdtAdd: inx=1 descInx=131 vDescInx=131 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg doplus>for:to:repeat$132>repeat$131%$131 1
14:	 rpushg doplus>for:to:repeat$132%$132 4
-- scanInv: "e " 0 0 1 
-- OG:gen: true get[inx]
-- OG:before:super.gen: "get[inx]" 
16:	 pushThis 
17:	 rpushg doplus>for:to:repeat$132>repeat$131%$131 1
19:	 rpushg doplus>for:to:repeat$132%$132 4
21:	 rpushg doplus%$130 1
23:	 rpushg +%$129 1
-- scanInv: "get[inx] " 0 0 1 
-- doInvoke: get[inx]0 1 useRtnVal: true 
-- scanInv: "get[inx] " 0 1 1 
-- doInvoke:X: get[inx]0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: none pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
25:	 pushThis 
26:	 rpushg doplus>for:to:repeat$132>repeat$131%$131 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
28:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
30:	 xpushg  inx 1 0
33:	 storeg integer%$5 2
-- OG:gen: true T.put(e):at[inx]
-- OG:before:super.gen: "T.put(e):at[inx]" 
35:	 pushThis 
36:	 rpushg doplus>for:to:repeat$132>repeat$131%$131 1
38:	 rpushg doplus>for:to:repeat$132%$132 4
-- scanInv: "T.put(e):at[inx] " 0 1 2 
40:	 rpushg newInvoke 4
-- doInvoke: T.put(e):at[inx]1 2 useRtnVal: false 
-- scanInv: "T.put(e):at[inx] " 1 2 2 
-- doInvoke:X: put(e):at[inx]1 2 2 pRec: none rec: T ix->next none 
-- checkForProxy:E: "put(e):at[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "T " rec.ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: put(e):at[inx]
-- koks:Y: "put(e):at[inx] " 
-- ptn:loadArgs:E: put(e):at[inx]
-- args: put(e):at[inx]
-- E.arg: "ObjectDescriptor" e 
-- E.arg: "ObjectDescriptor" inx 
-- arg: V: var integer 1 2 false 
-- E.arg: V: var integer 
-- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: e 
-- OG:gen: true e
-- gen:whatIsThis? 
-- OG:before:super.gen: "e" 
42:	 pushThis 
43:	 rpushg doplus>for:to:repeat$132>repeat$131%$131 1
45:	 rpushg doplus>for:to:repeat$132%$132 4
-- scanInv: "e " 0 0 1 
-- doInvoke: e0 1 useRtnVal: true 
-- scanInv: "e " 0 1 1 
-- doInvoke:X: e0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "e " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
-- kuk:X: e
-- koks:Y: "e " 
-- ptn:loadArgs:E: e
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "e " 
-- DI:newInvoke: "e: var integer " off: 1 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "e " isAdr: false valueOff: 0 
47:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true e: var integer
-- arg: inx: var integer 2 2 false 
-- E.arg: inx: var integer 
-- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "
 --  inx "isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
49:	 pushThis 
50:	 rpushg doplus>for:to:repeat$132>repeat$131%$131 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
52:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: V: var integer 3 2 false 
-- arg: inx: var integer 4 2 false 
-- arg: V: var integer 5 2 false 
-- arg: inx: var integer 6 2 false 
-- ptn:loadArgs:end: 
-- put(V: var integer):at[inx: var integer]:  \
--    %basic 115
-- OI:newInvoke: "put(e):at[inx] " 
-- getIndexedArgs:rec.ATd: T: obj Indexed(L + S.length,Integer)
54:	 xstoreg inx  size:1 isValueObj:0
L2:
57:	 setThisStack  
58:	 pushThis 
59:	 rtn D
61:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: doplus>for:to:repeat$132 descNo: 132 isValue: false 
-- Items:GenClass: doplus>for:to:repeat$132 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS doplus>for:to:repeat$132 dNo:132 topDno:29 orgOff:4 orgId:doplus orgDno:130
-- VDTtableCopy: 29 134 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(L):repeat \
--    e := get[inx] \
--    T.put(e):at[inx] \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(L):repeat \
--    e := get[inx] \
--    T.put(e):at[inx] \
-- 
-- args: 
-- for(1):to(L):repeat \
--    e := get[inx] \
--    T.put(e):at[inx] \
-- 
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" L 
-- E.arg: "ObjectDescriptor" e := get[inx] \
--    T.put(e):at[inx] 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: L 
-- OG:gen: true L
-- gen:whatIsThis? 
-- OG:before:super.gen: "L" 
6:	 pushThis 
7:	 rpushg doplus%$130 4
9:	 rpushg doplus%$130 1
-- scanInv: "L " 0 0 1 
-- doInvoke: L0 1 useRtnVal: true 
-- scanInv: "L " 0 1 1 
-- doInvoke:X: L0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "L " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
-- kuk:X: L
-- koks:Y: "L " 
-- ptn:loadArgs:E: L
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "L " 
-- DI:newInvoke: "L: var integer " off: 1 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
11:	 pushg 4 newInvoke
-- loadArgs:after:actualArg:gen: false true L: var integer
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
13:	 pushThis 
14:	 storeg integer%$5 2
16:	 pushThis 
17:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
19:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=132 vDescInx=29 vdtTop: 2 
21:	 rtnAlloc 1
23:	 toSuper  29
DO:
26:	 mvStack 
L1:
L2:
27:	 rtnInner  M
28:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 131 false 
-- VDTentry: vdtAdd: inx=2 descInx=132 vDescInx=131 vdtTop: 2 
-- Items:GenClass: doplus>for:to:repeat$134>repeat$133 descNo: 133 isValue: false 
-- Items:GenClass: doplus>for:to:repeat$134>repeat$133 descNo: 22 isValue: false 

CLASS doplus>for:to:repeat$134>repeat$133 dNo:133 topDno:133 orgOff:1 orgId:doplus>for:to:repeat$134 orgDno:134
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  1 origin
-- AllocateSuper: 
-- e := S.get[inx] \
-- i := L + inx \
-- T.put(e):at[i]
4:	 allocEventQ 
-- 1 133 true 
-- VDTentry: vdtAdd: inx=1 descInx=133 vDescInx=133 vdtTop: 1 
6:	 mvStack 
7:	 rtnAlloc 1
DO:
9:	 doEventQ 
10:	 mvStack 
L1:
11:	 pushThis 
12:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
14:	 rpushg doplus>for:to:repeat$134%$134 4
-- scanInv: "e " 0 0 1 
-- OG:gen: true S.get[inx]
-- OG:before:super.gen: "S.get[inx]" 
16:	 pushThis 
17:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
19:	 rpushg doplus>for:to:repeat$134%$134 4
21:	 rpushg doplus%$130 1
-- scanInv: "S.get[inx] " 0 1 2 
23:	 rpushg newInvoke 2
-- doInvoke: S.get[inx]1 2 useRtnVal: true 
-- scanInv: "S.get[inx] " 1 2 2 
-- doInvoke:X: get[inx]1 2 2 pRec: none rec: S ix->next none 
-- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "S " rec.ATd: "in S: var String " 5 
 --  false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: get[inx]
-- koks:Y: "get[inx] " 
-- ptn:loadArgs:E: get[inx]
-- args: get[inx]
-- E.arg: "ObjectDescriptor" inx 
-- arg: inx: var integer 1 1 false 
-- E.arg: inx: var integer 
-- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
25:	 pushThis 
26:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
28:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- arg: inx: var integer 2 1 false 
-- arg: inx: var integer 3 1 false 
-- ptn:loadArgs:end: 
-- get[inx: var integer]:  \
--    %basic 117 -- no globals[], since origin must be there for get \
--    out ch: var char
-- OI:newInvoke: "get[inx] " 
30:	 xpushg  inx 1 0
33:	 storeg integer%$5 2
35:	 pushThis 
36:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
38:	 rpushg doplus>for:to:repeat$134%$134 4
-- scanInv: "i " 0 0 1 
-- OG:gen: true L + inx
-- OG:before:super.gen: "L + inx" 
40:	 pushThis 
41:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
43:	 rpushg doplus>for:to:repeat$134%$134 4
45:	 rpushg doplus%$130 1
-- scanInv: "L + inx " 0 1 2 
47:	 pushg 4 newInvoke
-- doInvoke: L + inx1 2 useRtnVal: true 
-- scanInv: "L + inx " 1 2 2 
-- doInvoke:X: + inx1 2 2 pRec: none rec: L ix->next none 
-- checkForProxy:E: "+ inx " isBasicValue: true 
 --  E.origin.isValueObj: true staticOff: 0 rec: "L " rec.ATd: "L: var integer " 1 false 
 --  pRec: none E.origin: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
-- kuk:X: + inx
-- koks:Y: "+ inx " 
-- ptn:loadArgs:E: + inx
-- args: inx
-- E.arg: "ObjectDescriptor" inx 
-- arg: in V: var integer 1 1 false 
-- E.arg: in V: var integer 
-- NonVirt: "+ inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: inx 
-- OG:gen: true inx
-- gen:whatIsThis? 
-- OG:before:super.gen: "inx" 
49:	 pushThis 
50:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
-- scanInv: "inx " 0 0 1 
-- doInvoke: inx0 1 useRtnVal: true 
-- scanInv: "inx " 0 1 1 
-- doInvoke:X: inx0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "inx " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
-- kuk:X: inx
-- koks:Y: "inx " 
-- ptn:loadArgs:E: inx
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "inx " 
-- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
52:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true inx: var integer
-- ptn:loadArgs:end: 
-- +  :  \
--    %basic 61 \
--    in V: var integer \
--    out R: var integer
-- OI:newInvoke: "+ inx " 
54:	 plus 
-- unitConv:after 
55:	 storeg integer%$5 3
-- OG:gen: true T.put(e):at[i]
-- OG:before:super.gen: "T.put(e):at[i]" 
57:	 pushThis 
58:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
60:	 rpushg doplus>for:to:repeat$134%$134 4
-- scanInv: "T.put(e):at[i] " 0 1 2 
62:	 rpushg newInvoke 4
-- doInvoke: T.put(e):at[i]1 2 useRtnVal: false 
-- scanInv: "T.put(e):at[i] " 1 2 2 
-- doInvoke:X: put(e):at[i]1 2 2 pRec: none rec: T ix->next none 
-- checkForProxy:E: "put(e):at[i] " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "T " rec.ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 114 true pRec: none E.origin: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
-- kuk:X: put(e):at[i]
-- koks:Y: "put(e):at[i] " 
-- ptn:loadArgs:E: put(e):at[i]
-- args: put(e):at[i]
-- E.arg: "ObjectDescriptor" e 
-- E.arg: "ObjectDescriptor" i 
-- arg: V: var integer 1 2 false 
-- E.arg: V: var integer 
-- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: e 
-- OG:gen: true e
-- gen:whatIsThis? 
-- OG:before:super.gen: "e" 
64:	 pushThis 
65:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
67:	 rpushg doplus>for:to:repeat$134%$134 4
-- scanInv: "e " 0 0 1 
-- doInvoke: e0 1 useRtnVal: true 
-- scanInv: "e " 0 1 1 
-- doInvoke:X: e0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "e " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
-- kuk:X: e
-- koks:Y: "e " 
-- ptn:loadArgs:E: e
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "e " 
-- DI:newInvoke: "e: var integer " off: 1 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "e " isAdr: false valueOff: 0 
69:	 pushg 2 newInvoke
-- loadArgs:after:actualArg:gen: false true e: var integer
-- arg: inx: var integer 2 2 false 
-- E.arg: inx: var integer 
-- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: i 
-- OG:gen: true i
-- gen:whatIsThis? 
-- OG:before:super.gen: "i" 
71:	 pushThis 
72:	 rpushg doplus>for:to:repeat$134>repeat$133%$133 1
74:	 rpushg doplus>for:to:repeat$134%$134 4
-- scanInv: "i " 0 0 1 
-- doInvoke: i0 1 useRtnVal: true 
-- scanInv: "i " 0 1 1 
-- doInvoke:X: i0 1 1 pRec: none rec: none ix->next none 
-- checkForProxy:E: "i " isBasicValue: true E.origin.isValueObj: 
 --  false staticOff: 0 rec: none pRec: none E.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
-- kuk:X: i
-- koks:Y: "i " 
-- ptn:loadArgs:E: i
-- args: 
-- ptn:loadArgs:end: 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- OI:newInvoke: "i " 
-- DI:newInvoke: "i: var integer " off: 2 valueOff: 0 E: "i " 
 --  next: none isAdr: false 
-- DI:newInvoke:loadPrimitive: "i " isAdr: false valueOff: 0 
76:	 pushg 3 newInvoke
-- loadArgs:after:actualArg:gen: false true i: var integer
-- arg: V: var integer 3 2 false 
-- arg: inx: var integer 4 2 false 
-- arg: V: var integer 5 2 false 
-- arg: inx: var integer 6 2 false 
-- ptn:loadArgs:end: 
-- put(V: var integer):at[inx: var integer]:  \
--    %basic 115
-- OI:newInvoke: "put(e):at[i] " 
-- getIndexedArgs:rec.ATd: T: obj Indexed(L + S.length,Integer)
78:	 xstoreg inx  size:1 isValueObj:0
L2:
81:	 setThisStack  
82:	 pushThis 
83:	 rtn D
85:	 END OSDV:0 objSize:1 isIndexed:0
-- Items:GenClass: doplus>for:to:repeat$134 descNo: 134 isValue: false 
-- Items:GenClass: doplus>for:to:repeat$134 descNo: 29 isValue: false 
-- Items:GenClass: for:to:repeat descNo: 22 isValue: false 

CLASS doplus>for:to:repeat$134 dNo:134 topDno:29 orgOff:4 orgId:doplus orgDno:130
-- VDTtableCopy: 29 134 
-- vdtTableCopy: I:1:29 V:2:30 
-- handleArgumentsAndOrigin: 
1:	 tstOriginIsNone 
2:	 rstore  4 origin
-- AllocateSuper: 
-- op:super for:to:repeat
-- push:super.origin: 
-- handleSuperArgs:E: "for(1):to(S.length):repeat \
--    e := S.get[inx] \
--    i := L + inx \
--    T.put(e):at[i] \
-- " theIS: 
-- super.sig:none:superAdj: 4 
-- ptn:loadArgs:E: 
-- for(1):to(S.length):repeat \
--    e := S.get[inx] \
--    i := L + inx \
--    T.put(e):at[i]
-- args: 
-- for(1):to(S.length):repeat \
--    e := S.get[inx] \
--    i := L + inx \
--    T.put(e):at[i]
-- E.arg: "ObjectDescriptor" 1 
-- E.arg: "ObjectDescriptor" S.length 
-- E.arg: "ObjectDescriptor" e := S.get[inx] \
--    i := L + inx \
--    T.put(e):at[i] 
-- arg: first: var integer 1 3 false 
-- E.arg: first: var integer 
-- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: 1 
-- OG:gen: true 1
-- OG:before:super.gen: "1" 
4:	 pushc 1
-- loadArgs:after:actualArg:gen: false false 
-- integer: value \
--    %ID integer \
--    %basic 1, 32 \
--    %globals
-- arg: last: var integer 2 3 false 
-- E.arg: last: var integer 
-- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "S.length "isValue: false 
 --  formalArg: "last: var integer " 
-- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
-- loadArgs:before:actual.gen: S.length 
-- OG:gen: true S.length
-- OG:before:super.gen: "S.length" 
6:	 pushThis 
7:	 rpushg doplus%$130 4
9:	 rpushg doplus%$130 1
-- scanInv: "S.length " 0 1 2 
11:	 rpushg newInvoke 2
-- doInvoke: S.length1 2 useRtnVal: true 
-- scanInv: "S.length " 1 2 2 
-- doInvoke:X: length1 2 2 pRec: none rec: S ix->next none 
-- checkForProxy:E: "length " isBasicValue: false 
 --  E.origin.isValueObj: false staticOff: 0 rec: "S " rec.ATd: "in S: var String " 5 
 --  false pRec: none E.origin: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
-- kuk:X: length
-- koks:Y: "length " 
-- ptn:loadArgs:E: length
-- args: 
-- ptn:loadArgs:end: 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- OI:newInvoke: "length " 
13:	 invoke length 16 0 0
19:	 pushg 2 
-- loadArgs:after:actualArg:gen: false false 
-- length:  \
--    out V: var integer \
--    V := get[-1]
-- arg: repeat:< object 3 3 true 
-- arg: first: var integer 4 3 false 
-- arg: last: var integer 5 3 false 
-- arg: repeat:< object 6 3 true 
-- arg: first: var integer 7 3 false 
-- arg: last: var integer 8 3 false 
-- arg: repeat:< object 9 3 true 
-- ptn:loadArgs:end: 
-- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
--    %OSDvisibility skipInternal \
--    %globals inSub \
--    inx: var integer
-- handleArgumentsAndOrigin: 
21:	 pushThis 
22:	 storeg integer%$5 2
24:	 pushThis 
25:	 storeg integer%$5 1
-- AllocateSuper: 
-- %OSDvisibility skipInternal \
-- %globals inSub \
-- inx: var integer \
-- inx := first
27:	 allocEventQ 
-- 1 29 true 
-- VDTentry: vdtAdd: inx=1 descInx=134 vDescInx=29 vdtTop: 2 
29:	 rtnAlloc 1
31:	 toSuper  29
DO:
34:	 mvStack 
L1:
L2:
35:	 rtnInner  M
36:	 END OSDV:1 objSize:4 isIndexed:0
-- 2 133 false 
-- VDTentry: vdtAdd: inx=2 descInx=134 vDescInx=133 vdtTop: 2 

CLASS valProx dNo:135 topDno:1 orgOff:1 orgId:Object orgDno:0
1:	 END OSDV:0 objSize:4 isIndexed:0

CLASS VM dNo:136 topDno:1 orgOff:0 orgId:Object orgDno:0
L1:
1:	 pushThis 
2:	 invoke BETAworld 1 0 1
8:	 stop
 L2:
9:	 rtn D
11:	 END OSDV:0 objSize:2 isIndexed:0

CLASS EventProcessor dNo:137 topDno:1 orgOff:0 orgId:Object orgDno:0
1:	 stop
 2:	 END OSDV:0 objSize:1 isIndexed:0

CLASS ThreadStub dNo:138 topDno:138 orgOff:0 orgId:Object orgDno:0
DO:
1:	 call D ThreadStub
3:	 stop
 4:	 END OSDV:0 objSize:1 isIndexed:0

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld 0
10:	mvStack
allocE: 
11:	pushthis 
12:	invoke 2 2 1
18:	rpop 
19:	pushthis 
20:	invoke 34 3 1
26:	rpop 
27:	pushthis 
28:	invoke 66 4 1
34:	rpop 
35:	rtnAlloc 1
doE: 
37:	doEventQ 
38:	mvStack
39:	setThisStack
40:	pushthis 
41:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	setThisStack
2:	pushthis 
3:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	setThisStack
2:	pushthis 
3:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	setThisStack
2:	pushthis 
3:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	setThisStack
2:	pushthis 
3:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 32 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class = descInx:14 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 15 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:15 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 16 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 16 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 19 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 24 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 31 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:16 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 1
17:	uminus
18:	xpushg 1 0
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class loop>$19 descInx:19 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 15 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:21 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:22 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#23 descInx:23 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 22 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:24 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class loop>for:to:repeat$31>repeat$25 descInx:25 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0
33:	storeg 2
35:	pushthis 
36:	rpushg 1
38:	rpushg 4
40:	pushthis 
41:	rpushg 1
43:	rpushg 4
45:	rpushg 1
47:	rpushg 2
49:	pushthis 
50:	rpushg 1
52:	pushg 3
54:	xpushg 1 0
57:	storeg 3
59:	pushthis 
60:	rpushg 1
62:	rpushg 4
64:	pushg 2
66:	pushthis 
67:	rpushg 1
69:	rpushg 4
71:	pushg 3
73:	ne 
74:	jmpFalse 85
77:	pushthis 
78:	invoke 27 0 0
84:	rpop 
85:	setThisStack
86:	pushthis 
87:	rtn D


Class loop>for:to:repeat$31>repeat$25>$27 descInx:27 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 28 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 15 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:28 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 42 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#30 descInx:30 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 22 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class loop>for:to:repeat$31 descInx:31 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 16 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 29
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:33 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:34 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 3 1
14:	rpop 
15:	pushthis 
16:	invoke 39 4 1
22:	rpop 
23:	pushthis 
24:	invoke 40 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:35 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 36 2 1
14:	rpop 
15:	pushthis 
16:	invoke 37 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:36 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:37 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 38 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:38 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class StringLib descInx:40 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:41 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	setThisStack
2:	pushthis 
3:	rtn D


Class _doIt descInx:42 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 44 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 47 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:43 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 32 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	setThisStack
31:	pushthis 
32:	rtn D


Class _doIt>$44 descInx:44 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 42 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class _doIt>$47 descInx:47 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class <= descInx:48 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 49 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:49 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 16 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 16 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 51 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 52 0 0
71:	rpop 
72:	pushthis 
73:	invoke 53 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class loop>$51 descInx:51 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class loop>$52 descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:53 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 54 0 0
18:	rpop 
19:	pushthis 
20:	invoke 57 0 0
26:	rpop 
27:	pushthis 
28:	invoke 60 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:54 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 55 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 56 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class isEmpty>$55 descInx:55 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 53 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class isEmpty>$56 descInx:56 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 28 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 53 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0
44:	storeg 3
46:	pushthis 
47:	rpushg 1
49:	pushthis 
50:	rpushg 1
52:	rpushg 1
54:	rpushg 1
56:	rpushg 2
58:	pushthis 
59:	rpushg 1
61:	pushg 2
63:	xpushg 1 0
66:	storeg 4
68:	pushthis 
69:	rpushg 1
71:	pushg 3
73:	pushthis 
74:	rpushg 1
76:	pushg 4
78:	eq 
79:	jmpFalse 90
82:	pushthis 
83:	invoke 58 0 0
89:	rpop 
90:	setThisStack
91:	pushthis 
92:	rtn D


Class loop>$58 descInx:58 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 59 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class loop>$58>$59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 57 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:60 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 61 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 62 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class doit>$61 descInx:61 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 53 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class doit>$62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 53 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:64 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:65 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:66 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 67 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class demo descInx:67 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 68 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class Break descInx:68 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushText 1
13:	invoke 69 0 0
19:	rpop 
20:	pushthis 
21:	invoke 74 0 0
27:	rpop 
28:	pushText 9
30:	invoke 69 0 0
36:	rpop 
37:	pushthis 
38:	invoke 85 0 0
44:	rpop 
45:	pushText 17
47:	invoke 69 0 0
53:	rpop 
54:	pushthis 
55:	invoke 106 0 0
61:	rpop 
62:	pushText 25
64:	invoke 69 0 0
70:	rpop 
71:	pushthis 
72:	invoke 111 0 0
78:	rpop 
79:	setThisStack
80:	pushthis 
81:	rtn D


Class print descInx:69 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 72 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class print>for:to:repeat$72>repeat$70 descInx:70 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0
26:	%prim put 2
28:	setThisStack
29:	pushthis 
30:	rtn D


Class put descInx:71 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class print>for:to:repeat$72 descInx:72 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 16 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 29
doE: 
32:	mvStack
33:	rtnInner


Class switch descInx:73 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class Break>switch$74 descInx:74 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 1
11:	rpushg 1
13:	rpushg 2
15:	pushc 8
17:	pushthis 
18:	storeg 2
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
allocE: 
25:	rtnAlloc 1
27:	toSuper 73
doE: 
30:	mvStack
31:	pushText 5
33:	invoke 69 0 0
39:	rpop 
40:	pushthis 
41:	invoke 81 0 0
47:	rpop 
48:	pushText 13
50:	invoke 69 0 0
56:	rpop 
57:	pushthis 
58:	invoke 82 0 0
64:	rpop 
65:	pushText 21
67:	invoke 69 0 0
73:	rpop 
74:	pushthis 
75:	invoke 83 0 0
81:	rpop 
82:	rtnInner


Class case descInx:75 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	invoke 80 0 0
21:	rpop 
22:	setThisStack
23:	pushthis 
24:	rtn D


Class length descInx:76 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 1
17:	uminus
18:	xpushg 1 0
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class case>for:to:repeat$80>repeat$78 descInx:78 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushg 2
20:	pushthis 
21:	rpushg 1
23:	rpushg 4
25:	rpushg 2
27:	pushthis 
28:	rpushg 1
30:	pushg 3
32:	xpushg 1 0
35:	eq 
36:	jmpFalse 47
39:	pushthis 
40:	invoke 79 0 0
46:	rpop 
47:	setThisStack
48:	pushthis 
49:	rtn D


Class case>for:to:repeat$80>repeat$78>$79 descInx:79 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	innerP 2
20:	rpopThisObj
21:	break 4 2 73 0
28:	setThisStack
29:	pushthis 
30:	rtn D


Class case>for:to:repeat$80 descInx:80 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 2
11:	invoke 76 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 29
doE: 
32:	mvStack
33:	rtnInner


Class Break>switch$74>case$81 descInx:81 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 4
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushText 5
30:	invoke 69 0 0
36:	rpop 
37:	rtnInner


Class Break>switch$74>case$82 descInx:82 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 8
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushText 5
30:	invoke 69 0 0
36:	rpop 
37:	rtnInner


Class Break>switch$74>case$83 descInx:83 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 12
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushText 5
30:	invoke 69 0 0
36:	rpop 
37:	rtnInner


Class sSwitch descInx:84 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 1
11:	rpushg 1
13:	rpushg 2
15:	pushthis 
16:	storeg 2
18:	tstOriginNone 
19:	rstore 1
21:	allocEventQ 0
allocE: 
23:	rtnAlloc 1
25:	toSuper 73
doE: 
28:	mvStack
29:	pushthis 
30:	innerP 3
32:	rpopThisObj
33:	rtnInner


Class Break>sSwitch$85 descInx:85 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	pushc 7
9:	tstOriginNone 
10:	rstore 3
12:	pushthis 
13:	rpushg 3
15:	rpushg 1
17:	rpushg 1
19:	rpushg 1
21:	rpushg 2
23:	pushthis 
24:	storeg 2
26:	tstOriginNone 
27:	rstore 1
29:	allocEventQ 0
allocE: 
31:	rtnAlloc 1
33:	toSuper 73
doE: 
36:	mvStack
37:	pushthis 
38:	invoke 86 0 0
44:	rpop 
45:	pushthis 
46:	invoke 87 0 0
52:	rpop 
53:	pushthis 
54:	invoke 88 0 0
60:	rpop 
61:	rtnInner


Class Break>sSwitch$85>case$86 descInx:86 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 1
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushText 5
30:	invoke 69 0 0
36:	rpop 
37:	rtnInner


Class Break>sSwitch$85>case$87 descInx:87 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 3
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushText 5
30:	invoke 69 0 0
36:	rpop 
37:	rtnInner


Class Break>sSwitch$85>case$88 descInx:88 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 7
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushText 5
30:	invoke 69 0 0
36:	rpop 
37:	rtnInner


Class Break>for:to:repeat$106>repeat$89 descInx:89 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	invoke 90 0 0
22:	rpop 
23:	pushc 58
25:	%prim put 2
27:	pushthis 
28:	invoke 102 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class putint descInx:90 objSize:4 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 20
9:	pushthis 
10:	pushc 1
12:	allocIndexed 91 1 0 
17:	pushthis 
18:	rstoreg 2
20:	rtnAlloc 1
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	pushthis 
26:	pushg 1
28:	pushc 0
30:	lt
31:	storeg 4
33:	pushthis 
34:	pushg 4
36:	jmpFalse 47
39:	pushthis 
40:	invoke 93 0 0
46:	rpop 
47:	pushthis 
48:	invoke 112 0 0
54:	rpop 
55:	pushthis 
56:	pushg 4
58:	jmpFalse 69
61:	pushthis 
62:	invoke 95 0 0
68:	rpop 
69:	pushthis 
70:	invoke 98 0 0
76:	rpop 
77:	setThisStack
78:	pushthis 
79:	rtn D


Class Indexed descInx:91 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class putint>$93 descInx:93 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	pushthis 
17:	rpushg 1
19:	pushg 1
21:	-
22:	storeg 1
24:	setThisStack
25:	pushthis 
26:	rtn D


Class putint>$95 descInx:95 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 45
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class for descInx:96 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 3
4:	pushthis 
5:	storeg 2
7:	pushthis 
8:	storeg 1
10:	allocEventQ 0
12:	mvStack
allocE: 
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	pushthis 
18:	pushthis 
19:	pushg 2
21:	storeg 1
23:	pushthis 
24:	invoke 118 0 0
30:	rpop 
31:	setThisStack
32:	pushthis 
33:	rtn D


Class repeat#97 descInx:97 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 22 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class putint>for$98 descInx:98 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 0
6:	pushc 1
8:	pushthis 
9:	rpushg 4
11:	pushg 3
13:	pushthis 
14:	storeg 3
16:	pushthis 
17:	storeg 2
19:	pushthis 
20:	storeg 1
22:	allocEventQ 0
allocE: 
24:	pushc 1
26:	pushthis 
27:	rpushg 4
29:	pushg 3
31:	rtnAlloc 1
33:	toSuper 96
doE: 
36:	mvStack
37:	rtnInner


Class _put descInx:101 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Break>for:to:repeat$106>repeat$89>switch$102 descInx:102 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 4
11:	rpushg 1
13:	rpushg 1
15:	rpushg 1
17:	rpushg 2
19:	pushthis 
20:	rpushg 3
22:	rpushg 1
24:	pushg 3
26:	pushthis 
27:	storeg 2
29:	tstOriginNone 
30:	rstore 1
32:	allocEventQ 0
allocE: 
34:	rtnAlloc 1
36:	toSuper 73
doE: 
39:	mvStack
40:	pushthis 
41:	invoke 103 0 0
47:	rpop 
48:	pushthis 
49:	invoke 104 0 0
55:	rpop 
56:	pushthis 
57:	invoke 105 0 0
63:	rpop 
64:	rtnInner


Class Break>for:to:repeat$106>repeat$89>switch$102>case$103 descInx:103 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 1
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushc 97
30:	%prim put 2
32:	rtnInner


Class Break>for:to:repeat$106>repeat$89>switch$102>case$104 descInx:104 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 3
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushc 98
30:	%prim put 2
32:	rtnInner


Class Break>for:to:repeat$106>repeat$89>switch$102>case$105 descInx:105 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 6
9:	pushc 1
11:	mkVindexed 91 
14:	pushthis 
15:	rstoreg 2
17:	tstOriginNone 
18:	rstore 1
20:	allocEventQ 0
allocE: 
22:	rtnAlloc 1
24:	toSuper 75
doE: 
27:	mvStack
28:	pushc 99
30:	%prim put 2
32:	rtnInner


Class Break>for:to:repeat$106 descInx:106 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushc 6
8:	pushthis 
9:	storeg 2
11:	pushthis 
12:	storeg 1
14:	allocEventQ 0
allocE: 
16:	rtnAlloc 1
18:	toSuper 29
doE: 
21:	mvStack
22:	rtnInner


Class Break>for:to:repeat$111>repeat$107 descInx:107 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 108 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class Break>for:to:repeat$111>repeat$107>switch$108 descInx:108 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 4
11:	rpushg 1
13:	rpushg 1
15:	rpushg 1
17:	rpushg 2
19:	invoke 24 0 0
25:	pushg 1
27:	pushthis 
28:	storeg 2
30:	tstOriginNone 
31:	rstore 1
33:	allocEventQ 0
allocE: 
35:	rtnAlloc 1
37:	toSuper 73
doE: 
40:	mvStack
41:	pushthis 
42:	invoke 109 0 0
48:	rpop 
49:	pushthis 
50:	invoke 110 0 0
56:	rpop 
57:	pushText 5
59:	pushthis 
60:	rpushg 3
62:	rpushg 1
64:	pushg 3
66:	invoke 122 0 0
72:	rpushg 2
74:	invoke 129 0 1
80:	rpushg 3
82:	pushText 12
84:	invoke 129 0 1
90:	rpushg 3
92:	invoke 69 0 0
98:	rpop 
99:	rtnInner


Class Break>for:to:repeat$111>repeat$107>switch$108>case$109 descInx:109 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushthis 
8:	rpushg 1
10:	rpushg 3
12:	rpushg 1
14:	pushg 3
16:	pushc 1
18:	eq 
19:	pushc 1
21:	mkVindexed 91 
24:	pushthis 
25:	rstoreg 2
27:	tstOriginNone 
28:	rstore 1
30:	allocEventQ 0
allocE: 
32:	rtnAlloc 1
34:	toSuper 75
doE: 
37:	mvStack
38:	pushText 5
40:	invoke 69 0 0
46:	rpop 
47:	rtnInner


Class Break>for:to:repeat$111>repeat$107>switch$108>case$110 descInx:110 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushthis 
8:	rpushg 1
10:	rpushg 3
12:	rpushg 1
14:	pushg 3
16:	pushc 4
18:	eq 
19:	pushc 1
21:	mkVindexed 91 
24:	pushthis 
25:	rstoreg 2
27:	tstOriginNone 
28:	rstore 1
30:	allocEventQ 0
allocE: 
32:	rtnAlloc 1
34:	toSuper 75
doE: 
37:	mvStack
38:	pushText 5
40:	invoke 69 0 0
46:	rpop 
47:	rtnInner


Class Break>for:to:repeat$111 descInx:111 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushc 5
8:	pushthis 
9:	storeg 2
11:	pushthis 
12:	storeg 1
14:	allocEventQ 0
allocE: 
16:	rtnAlloc 1
18:	toSuper 29
doE: 
21:	mvStack
22:	rtnInner


Class loop descInx:112 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	pushc 1
21:	+
22:	storeg 3
24:	pushthis 
25:	rpushg 1
27:	rpushg 2
29:	pushthis 
30:	rpushg 1
32:	pushg 1
34:	pushc 10
36:	modd
37:	pushthis 
38:	rpushg 1
40:	pushg 3
42:	xstoreg 1 0
45:	pushthis 
46:	rpushg 1
48:	pushthis 
49:	rpushg 1
51:	pushg 1
53:	pushc 10
55:	idiv
56:	storeg 1
58:	pushthis 
59:	rpushg 1
61:	pushg 1
63:	pushc 0
65:	gt 
66:	jmpFalse 77
69:	pushthis 
70:	invoke 117 0 0
76:	rpop 
77:	setThisStack
78:	pushthis 
79:	rtn D


Class loop>$117 descInx:117 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 1 112 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class _doIt descInx:118 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 1
16:	pushthis 
17:	rpushg 1
19:	pushg 3
21:	le
22:	jmpFalse 33
25:	pushthis 
26:	invoke 119 0 0
32:	rpop 
33:	setThisStack
34:	pushthis 
35:	rtn D


Class _doIt>$119 descInx:119 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 1
33:	pushc 1
35:	+
36:	storeg 1
38:	break 1 1 118 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class repeat descInx:120 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 4
17:	pushg 3
19:	pushc 1
21:	+
22:	pushthis 
23:	rpushg 1
25:	pushg 1
27:	-
28:	storeg 2
30:	pushc 48
32:	pushthis 
33:	rpushg 1
35:	rpushg 4
37:	rpushg 2
39:	pushthis 
40:	pushg 2
42:	xpushg 1 0
45:	+
46:	%prim put 2
48:	setThisStack
49:	pushthis 
50:	rtn D


Class I2S descInx:122 objSize:6 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	pushc 20
14:	pushthis 
15:	pushc 1
17:	allocIndexed 91 1 0 
22:	pushthis 
23:	rstoreg 3
25:	pushc 20
27:	pushthis 
28:	pushc 1
30:	allocIndexed 91 1 0 
35:	pushthis 
36:	rstoreg 4
38:	rtnAlloc 1
doE: 
40:	doEventQ 
41:	mvStack
42:	pushthis 
43:	pushthis 
44:	pushg 1
46:	pushc 0
48:	lt
49:	storeg 6
51:	pushthis 
52:	pushg 6
54:	jmpFalse 65
57:	pushthis 
58:	invoke 123 0 0
64:	rpop 
65:	pushthis 
66:	invoke 127 0 0
72:	rpop 
73:	pushthis 
74:	invoke 125 0 0
80:	rpop 
81:	pushthis 
82:	pushthis 
83:	rpushg 4
85:	%prim asString 118
87:	rswap 0
89:	rstoreg 2
91:	setThisStack
92:	pushthis 
93:	rtn D


Class I2S>$123 descInx:123 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	pushthis 
17:	rpushg 1
19:	pushg 1
21:	-
22:	storeg 1
24:	pushthis 
25:	rpushg 1
27:	rpushg 3
29:	pushc 45
31:	pushc 1
33:	xstoreg 1 0
36:	pushthis 
37:	rpushg 1
39:	pushc 1
41:	storeg 5
43:	setThisStack
44:	pushthis 
45:	rtn D


Class I2S>for:to:repeat$125>repeat$124 descInx:124 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 4
18:	pushthis 
19:	rpushg 1
21:	rpushg 4
23:	rpushg 3
25:	pushthis 
26:	rpushg 1
28:	rpushg 4
30:	pushg 5
32:	pushc 1
34:	+
35:	pushthis 
36:	rpushg 1
38:	pushg 3
40:	-
41:	xpushg 1 0
44:	pushthis 
45:	rpushg 1
47:	pushg 3
49:	xstoreg 1 0
52:	setThisStack
53:	pushthis 
54:	rtn D


Class I2S>for:to:repeat$125 descInx:125 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	pushg 5
11:	pushthis 
12:	storeg 2
14:	pushthis 
15:	storeg 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 29
doE: 
24:	mvStack
25:	rtnInner


Class asString descInx:126 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class loop descInx:127 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 5
19:	pushc 1
21:	+
22:	storeg 5
24:	pushthis 
25:	rpushg 1
27:	rpushg 3
29:	pushc 48
31:	pushthis 
32:	rpushg 1
34:	pushg 1
36:	pushc 10
38:	modd
39:	+
40:	pushthis 
41:	rpushg 1
43:	pushg 5
45:	xstoreg 1 0
48:	pushthis 
49:	rpushg 1
51:	pushthis 
52:	rpushg 1
54:	pushg 1
56:	pushc 10
58:	idiv
59:	storeg 1
61:	pushthis 
62:	rpushg 1
64:	pushg 1
66:	pushc 0
68:	gt 
69:	jmpFalse 80
72:	pushthis 
73:	invoke 128 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class loop>$128 descInx:128 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 1 127 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class + descInx:129 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 16 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 130 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:130 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 16 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 91 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 132 0 0
48:	rpop 
49:	pushthis 
50:	invoke 134 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class doplus>for:to:repeat$132>repeat$131 descInx:131 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0
33:	storeg 2
35:	pushthis 
36:	rpushg 1
38:	rpushg 4
40:	rpushg 4
42:	pushthis 
43:	rpushg 1
45:	rpushg 4
47:	pushg 2
49:	pushthis 
50:	rpushg 1
52:	pushg 3
54:	xstoreg 1 0
57:	setThisStack
58:	pushthis 
59:	rtn D


Class doplus>for:to:repeat$132 descInx:132 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 29
doE: 
26:	mvStack
27:	rtnInner


Class doplus>for:to:repeat$134>repeat$133 descInx:133 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0
33:	storeg 2
35:	pushthis 
36:	rpushg 1
38:	rpushg 4
40:	pushthis 
41:	rpushg 1
43:	rpushg 4
45:	rpushg 1
47:	pushg 4
49:	pushthis 
50:	rpushg 1
52:	pushg 3
54:	+
55:	storeg 3
57:	pushthis 
58:	rpushg 1
60:	rpushg 4
62:	rpushg 4
64:	pushthis 
65:	rpushg 1
67:	rpushg 4
69:	pushg 2
71:	pushthis 
72:	rpushg 1
74:	rpushg 4
76:	pushg 3
78:	xstoreg 1 0
81:	setThisStack
82:	pushthis 
83:	rtn D


Class doplus>for:to:repeat$134 descInx:134 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 16 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 29
doE: 
34:	mvStack
35:	rtnInner


Class valProx descInx:135 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:136 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:137 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:138 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

