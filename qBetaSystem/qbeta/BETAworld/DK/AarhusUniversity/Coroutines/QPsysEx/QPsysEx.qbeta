QPsysEx: obj QuasiParallelSystemLib.QuasiparallelSystem
   %include StringLib
   BufferElement:
      in V: var integer
   BoundedBuffer: Collections.QueueLib.Queue
      n: var integer
      isFull:
         out B: var Boolean
         --n := n + 1
         --B := (n /% 5) = 0
         ("isFull: " + I2S(noOfElm) + "\n").print
         B := noOfElm >= 5
   B: obj BoundedBuffer
   notFull: obj ProcessQueue
   notEmpty: obj ProcessQueue
   Producer: Process("P1:")
      deposit:
         in E: ref BufferElement
         if (B.isFull) :then
             "deposit:full:\n".print
             --"deposit:buffer: ".print
             B.display	     
             wait(notFull)
             "deposit:after:wait:isFull:\n".print	     
         B.insert(E)
         send(notEmpty)
         --"\ndeposit:call:\n".print	 
      inner(Producer)
   Consumer: Process("C1:")
      fetch:      
         out E: ref BufferElement
         --"fetch:\n".print
         --"Buffer:\n".print
         --B.display
         --active.print	 
         if (B.isEmpty) :then
             "fetch:empty:".print
             wait(notEmpty)
             "fetch:after:wait:notEmpty:\n".print     
         E := B.removeNext
         send(notFull)
         --"\nfetch:call:\n".print
      inner(Consumer)
   P1: obj Producer
       for (1) :to (10) :repeat
          ("P1:deposit:" + I2S(inx) + ":\n").print
          deposit(BufferElement(inx * inx))
   C1: obj Consumer
       cycle
          E1: ref BufferElement
          E1 := fetch
          ("C1:fetch: " + I2S(E1.V) + "\n").print
          --send(notFull)
   active.insert(P1)
   active.insert(C1)
   