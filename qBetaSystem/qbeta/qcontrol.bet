ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '~beta/sysutils/time';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'qgenerator';
INCLUDE '../VM/betaVM';
BODY 'qdumpObj'; 
BODY 'unithandlerBody'
---LIB:attributes---
chdir: external
  (# dir: [0] @char; res: @integer
  enter dir
  do callC
  exit res
  #);
system: external
  (# cmd: [0] @char; res: @integer
  enter cmd
  do callC
  exit res
  #);
newProject:
   (# mkDir:
         (# D: @DiskEntry
         do name[] -> D.path; ' "'->puttext; name[] -> puttext; '"\n'->puttext;
            (if D.exists then 
                '\n!!!! A module "'->puttext; name[] -> puttext;
                '" already exists!\n'->putline;
                stop
            else
               'mkdir '-> cmd[];
               name.copy -> cmd.append;
               cmd -> system;
         if)#); 
      cdDir:
         (#
         do '\\'->cDir.put;
            name.copy -> cDir.append;
            cDir -> chdir;
         #); 
      name, cmd,cDir,newDir,FN,qBetaTemplate,qBetaFN: ^Text; F: @File
   enter(cDir[])
   do noOfArguments  -> arguments -> name[];
      mkDir;
      cdDir;
      name.copy -> qBetaFN[]; '.qbeta'->qBetaFN.append;
      cDir.copy -> FN[];
      '\\' -> FN.put; qBetaFN[] -> FN.append;
      FN[] -> F.name;
      F.openWrite;
      name.copy -> qBetaTemplate[];
      ': obj\n   "\\nA new module '-> qBetaTemplate.puttext; 
      name.copy->qBetaTemplate.append; 
      '  has been created!".print\n' -> qBetaTemPlate.puttext;
      qBetaTemplate[] -> F.puttext;
      F.close
    exit name[]
   #)
---program:descriptor---
SystemEnv
(# compile: @generator;
   startCPU,stopCPU: @integer;
   VM: @ betaVM
     (# putCH:: (# do ch -> put #);
        getCh:: (# do get -> ch #);
        putTop::
          (# N,P: ^compile.Node;
          do (if false then
                 '\n\n!!!! putTop: '->puttext; descInx -> putint;
             if);
             descInx -> compile.getObjectDesc -> P[]; 
             
             (if false and (P[] <> none) then
                 '\n!!   P:'->dumpt;
                 P.doPT -> putHeadN;
             if);
             lsc -> P.findNodeAtBCpos -> N[];
             (if N[] = none then '!!!! VM:putTop:N is none'->dumptn if);
             
             '!!   in module: "' -> T.puttext;
             (P.theModule).moduleName -> T.puttext; 
             '" at: '  -> T.putline;
             N[] -> compile.mkContextLines -> T.putline;
          #);
        (*errorEvent:: (# do msg[] -> putline; done #);*)
        scanEvent::
          (#  IS: ^compile.Items; 
          do '\nscanEvent: ' -> puttext; 
             (obj.myObjDesc).descInx -> compile.getObjectDesc -> IS[];
             IS.doPT -> putline
          #);
        dumpObjEvent:: (# <<SLOT dumpObj:doPart>> #);
        done:: 
          (# descInx,objId,lsc: @integer; IS: ^compile.Items
          do (if VM.stopErrors[] <> none then
                 0 -> stopErrors.setPos;
                 stopErrors.getInt -> descInx;
                 stopErrors.getInt -> objId;
                 stopErrors.getInt -> lsc;
                 stopErrors.getLine;
                 newline;
                 stopErrors.scan(#do ch -> put #);
                 newline;
                 descInx -> compile.getObjectDesc -> IS[];
                 '**** at:\n       ' -> puttext;
                 IS.father.doPT -> putline; newline;
             if);
             cpuTime -> stopCPU;
             '\nCPU time: ' -> puttext; stopCPU - startCPU -> putint; ' microseconds'-> putline;
             stop 
          #)
     #);
   setWindowEnv:: (# do myWindowEnv[] -> theWindowEnv[]#);
   myWIndowEnv: @ guienv;
   printArgHelp:
     (#
     do '**** Valid arguments: ' -> putline;
        '\t--new moduleId\n\t\t print create a new module named "moduleId"' -> putline;
        '\t--showUnits\n\t\t print possible unit for each invoation' -> putline;
        '\t--help\n\t\t print this text' -> putline;
        '\t-H, --HTML\n\t\t generate HTML files' -> putline;
        '\t-c\t use C-based interpreter' -> putline;
        '\t-C\t save byte code image for C-based interpreter' -> putline;
        '\t-x\t print lexical tokens of input file' -> putline;
        '\t-d\t set debug options, like -dscp ' -> putline;
        '\t\t p   pretty print input file' -> putline;
        '\t\t P   print AST for input file' -> putline;
        '\t\t c   trace checker' -> putline;
        '\t\t s   trace search' -> putline;
        '\t\t q   trace virtual qua-check' -> putline; 
        '\t\t u   trace units' -> putline;
        '\t\t l   trace parsing ' -> putline;
        '\t\t m   only parse main input file' -> putline;
        newline
     #);
   
   readLongArg:
     (# arg: ^Text; LA: @Text
     enter arg[]
     do (for i: arg.length - 2 repeat
             (i + 2) -> arg.inxGet -> LA.put
        for);
        (if true 
         // 'showUnits' -> LA.equalNCS then
            true -> compile.showUnits;
            'show units'->putline
         // 'new' -> LA.equalNCS then
            'new module: '->puttext; 
            compile.getCurrentDir -> newProject -> FN[]
         // 'help' -> LA.equalNCS then    
            printArgHelp
         // 'LLVM' -> LA.equalNCS then    
            '!!!!  Use lqbeta for generating LLVM IR!' -> putline;
         // 'HTML' -> LA.equalNCS then        
            true -> compile.printHTMLfile
         else
            '\n\n**** Invalid argument: ' -> puttext; arg[] -> putline;
            printArgHelp
        if)
     #);
   readArguments:
     (# arg: ^text
     do run_Beta_INT -> runMode;
        (for i: noOfArguments - 2 repeat
             i + 1 -> arguments -> arg[];
             (if true
              // ('-x' -> arg.equal) then      
                 ' ' -> put;
                 true -> compile.onlyLex
              // ('-c' -> arg.equal) then   
                 run_C_INT -> runMode;
              // ('-C' -> arg.equal) then   
                 save_BC_Image -> runMode;
              // ('-v' -> arg.equalNCS) then   
                 true -> compile.verbose -> VM.verbose
              // ('-t' -> arg.equalNCS) then
                 true -> compile.traceEmbedding
              // ('-f' -> arg.equal) then
                 true -> compile.toFix; 
              // ('-F' -> arg.equal) then
                 true -> compile.newFeature;
              // '-B' -> arg.equal then
                 true -> compile.handleStdBetaModules
              // '-I' -> arg.equal then

              // '-i' -> arg.equal then
                 true -> compile.doPPasDerived
              // '-l' -> arg.equalNCS then
                 '!!!!  Use lqbeta for generating LLVM IR!' -> putline;
              // '-a' -> arg.equalNCS then
                 true -> compile.emitCom
              // '-d' -> arg.equal then
                 true -> compile.traceLLVMcalls
              // '-D' -> arg.equal then
                 true -> compile.traceLLVMcalls -> compile.dumpLLVMobjs
              // '-H' -> arg.equal then
                 true -> compile.printHTMLfile
              // '-S' -> arg.equal then
                 '\n\n!!!OBS!!! MATERIAL OBJECTS ALLOWED IN VAL AND VAR DECLARATIONS\n\n'->putline;
                  true -> compile.freeDIkind
              // '-U' -> arg.equal then
                 true -> compile.allowUnsafe
              // '-P' -> arg.equal then
                 '**** Using new proxy\n'->dumpt;
                 true -> compile.withNewProxy;
              // '-Q' -> arg.equal then
                 '**** Using vdtAlloc\n'->dumpT;
                 true -> compile.useVDTalloc
              // (arg.length > 2) and ('--'-> ((1,2)->arg.sub).equalNCS) then
                 arg[] -> readLongArg
              // (arg.length > 2) and ('-d'-> ((1,2)->arg.sub).equalNCS) 
                 then
                 '\n**** debug:'->puttext; arg[] -> puttext;
                 (for i: arg.length - 2 repeat
                      (if (i + 2) -> arg.inxGet
                       // 'a' then 
                          ':alloc'->puttext; true -> compile.traceAlloc;
                       // 'A' then 
                          ':vdtAlloc'->puttext; true -> compile.traceVDTalloc;
                       // 'c' then 
                          ':checker' -> puttext; true -> compile.traceCheck;
                       // 'e' then
                          ':traceVMevents' -> puttext; 
                          true -> traceEvents
                       // 'g' then 
                          ':generator'-> puttext; true -> compile.traceGen;
                          true -> compile.emitCom
                       // 'i' then 
                          true -> compile.traceInvAsDerived;
                          ':trace invocation as derived'->putline
                       // 'p' then true -> compile.mainPT
                       // 'P' then true -> compile.mainPP
                       // 'q' then
                          ':getVqual' -> puttext; true -> compile.traceGetVqual
                       // 's' then 
                          ':search'->puttext; true -> compile.traceSearch;
                          true -> compile.emitCom
                       // 't' then
                          ':traceInvoke'->puttext; true -> VM.exeTrace
                       // 'T' then
                          true -> compile.trx
                       // 'u' then 
                          ':unit'->puttext; true -> compile.traceUnit;
                          true -> compile.emitCom
                       // 'm' then 
                          ':parse:main'->puttext; true -> compile.parseMain
                       // 'l' then 
                          ':trace:parse'->puttext; true -> compile.traceParse
                       else
                          ':invalid argument: '->puttext; 
                          (i + 2) -> arg.inxGet -> put;
                          newline
                 if)for);
                 newline
              else
                 '\n\n**** Invalid argument: ' -> puttext; 
                 arg[] -> putline;
                 printArgHelp
             if);             
        for);
        (if FN[] = none then
            noOfArguments  -> arguments -> FN[];
        if)
     #);
   linkLLVM:
     (# llvmLib,cmd: ^text; res: @integer;
        system: external
          (# cmd: [0] @char; res: @integer
          enter cmd
          do callC
          exit res
          #)
     do BetaLib -> llvmLib[];
        (*compile.dirCh*) 
        '/qBetaSystem/VM/qbeta_llvm_lib.c' -> llvmLib.append;
        (* Note! clang is a link to clang-8, but system can apparently 
         * not handle links - we thus use clang-8 directly
         *)
        'clang-8 ' -> cmd[];
        (FN[],'.ll') -> mkAuxName -> cmd.append;
        ' '  -> cmd.put;
        llVmlib[] -> cmd.putline;
        cmd[] -> putline;
        cmd -> system -> res
     #);
   initTarget: <<SLOT initTarget:descriptor>>;
   runMode: @integer;
   FN,FNx: ^text;
   F: @file
     (# NoSuchFileError ::< (# do true -> continue; false -> OK #); 
     #);
   OK,traceEvents: @boolean; srcExt,altSrcExt: ^Text
do cpuTime -> startCPU;
   'qBETA COMPILER: ' -> puttext; 
   readArguments;
   ('/qBetaSystem/qbeta/BETAworld/','.qbeta' -> srcExt[],'.xbeta' -> altSrcExt[]) 
     -> compile.initDirectoryModules;
   FN[] -> compile.fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   true -> OK;
   F.openRead; 
   (if not OK then
           FN[] -> FNx[];
           altSrcExt[] -> ((1,FN.length - 6) -> FN.sub).append -> FN[];
           'Trying alternative file: ' -> puttext; FN[] -> putline;
           FN[] -> F.name;
           true -> OK;
           F.openRead;

       (if not ok then
               '\n!!!! No such file: ' -> puttext; FNx[] -> putline;
               '!!   or : ' -> puttext; FN[] -> putline;
           stop
       if)
   if);
   initTarget;
   VM.genEvents -> compile.genEvents;
   (*true -> compile.withNewProxy;*)
   true -> compile.useVDTalloc;
   compile.withNewProxy -> VM.withNewProxy;
   (none,false,none,FN[]) -> compile; 
   (if false then
       compile.dimTable.print;
   if);
   (if compile.emitLLVM then
       linkLLVM;
       stop
    else
       runMode -> VM.init;
       compile.valueProxyDescNo -> VM.valueProxyDescNo;
       (if not compile.onlyLex 
           and not compile.hasSyntaxError
           and not compile.semanticErrors 
           and not compile.parseMain
           then
           (compile.runtimeDescs,compile.mainDescNo,FN[],runMode) 
             -> VM.execute.init;
           traceEvents -> VM.traceEvents;
           cpuTime -> startCPU;
           VM.execute[] -> fork;
        else
           stop
       if)
   if)
#)
