Simulation: @
  (# Process: 
       (# hold: 
            (# T: @ integer
            enter T
            do 'Hold: '.print;
               T -> putint;
               newline;
               (if T > 0 then
                   time + T -> time
               if);
               this(process)[] -> SQS.removeLast;
               this(Process)[] -> SQS.insert;
               this(process).suspend
            #);
          wait: 
            (# Q: ^Queue
            enter Q[]
            do 'Wait:'.print;
               this(Process)[] -> Q.insert;
               this(Process).suspend
            #);
          activate: 
            (# X: ^Process
            enter X[]
            do 'Activate:'.print;
               time -> X.time;
               X[] -> SQS.insert;
               this(Process).suspend
            #);
          display: 
            (# 
            do id.print;
               ':' -> put;
               time -> putint;
               ',' -> put;
               newline
            #);
          id: ^text;
          time: @ integer
       enter (id[],time)
       do this(Process).suspend;
          inner;
          this(process)[] -> SQS.removeLast
       exit this(Process)[]
       #);
     simulate: 
       (# start,active: ^Process;
          finish: @ integer;
          final: ^Process
       enter (start[],finish)
       do 'Simulate: '.print;
          &Queue[] -> SQS[];
          &Process[] -> final[] -> SQS.insert;
          ('Final',finish) -> final;
          start[] -> SQS.insert;
          inner;
          SQS.display;
          L:
            (if not SQS.empty then
                'Current: '.print;
                (current).display;
                current -> active[];
                active;
                restart L
            if);
          'End of simulation'.print
       #);
     current: (#  exit SQS.last[] #);
     SQS: ^Queue;
     Queue: 
       (# insert: 
            (# P: ^Process; Q: ^Queue
            enter P[]
            do &Queue[] -> Q[];
               P[] -> Q.elm[];
               (if next[] = Xnone[] then
                   Q[] -> next[]; P[] -> last[]
                else
                   Q[] -> add; next.last[] -> last[]
               if)
            #);
          add: 
            (# Q: ^Queue
            enter Q[]
            do (if next[] = Xnone[] then
                   Q[] -> next[]; Q.elm[] -> last[]
                else
                   (if (Q.elm.time > next.elm.time) then
                       next[] -> Q.next[];
                       Q[] -> next[]
                    else
                       Q[] -> next.add
                   if);
                   next.last[] -> Q.last[]
               if)
            #);
          first: 
            (# P: ^Process
            do last[] -> P[]; removeLast
            exit P[]
            #);
          removeLast: 
            (# P: ^Process
            enter P[]
            do (if next[] <> Xnone[] then
                   (if P[] = next.elm[] then
                       Xnone[] -> next[];
                       elm[] -> last[]
                    else
                       P[] -> next.removeLast;
                       next.last[] -> last[]
                   if)
               if)
            #);
          empty: BooleanValue
            (# 
            do next[] = Xnone[] -> value
            #);
          display: 
            (# 
            do (if elm[] <> Xnone[] then
                   elm.display
               if);
               (if next[] <> Xnone[] then
                   next.display
               if)
            #);
          elm: ^Process;
          next: ^Queue;
          last: ^Process
       #);
     Xnone: ^Object
  #)