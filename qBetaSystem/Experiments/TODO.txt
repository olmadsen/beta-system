
1.	SSS:  ref Set.Set(#Record) -- accepted by compiler, but dont work
	must be
	Records: Set.Set(Record)
	   print: ...
	SSS: re Set.Set
	SSS:= Records
2.	B := SSS.forAllB({in Y: ref Record; BB: var Boolean; BB := Y.V > 9})
	if no out, compiler thinks this is a sub of pred
	but called as  pred(current), i.e. one argument
	So no new in args for subs of virtuals
3	B := SSS.forAllB({in X: ref Record; BB: var Boolean; BB := Y.V > 9})
	compiler think X is a double declaration
4.	Parser dont catch R..foo - i. two dots

6.	forAllX: ...; (@this forAll).current makes the compiler crash
----------------------------------
reduce({ %arg x,y,z; z := x + y})

Things to be fixed
=================
Recent errors:
=============
1.	Assignment to value should be forbidden
        value: var Boolean -- and dont redeclare Value
	value := bExp
2. 	foo: ref Foo -- crash
3.	in args of type ref in super dont work
5      aSet.insert(none) - crash, perhaps because arg is a ref in super
6.     SSS: obj Set(Period) dont work - Set(#Period) works
7.     select:
         in pred:<
            in IX: ref Object --Domain
            in E: ref Object --Range
            out V: var Boolean
	 out R: obj Set.Set --- no code is generated here!
         must be:	    
         out R: ref Set.Set
         R:= Set.Set(Domain)


Arguments for subpatterns of keyword patterns
=============================================

%do a: ? integer %with% b: ?integer:
   ...

%and c: ?integer %also% d: ?integer: #%do%with%
   ...

%do 111 %with% 222 %and 333 %also% 444

We may be able to parse this!?

Alternative

%do 111 %with% 222 >%and 333 %also% 444

Arguments
--------------
To distingusih


   Q: ?foo
   W: ?foo(e1,e2,e3)
   P: super ...
   S: super(e1,e2,e3) ...

We must use '#' as in
   Q: ?#foo

or simply assume '#' if no arguments. 
But we need t know the context
   - variaable dataitem
   - super of pattern - not singular


SemCheck is called from abstractSytaxTree by scan of all sons 
- we then dont know the context

The context must alos include %this P, %leave P, %restart P,

Should pattern names ( #foo) be a special Lexem?

   PtnId:< Lexem ...

Currently PtnId in ObjectGeneraor is a name 
- could be a property of Name?

INNER P
--------

 foo:
    ...
    fisk:
       ...
       inner foo
      ...
    ...
 bar: foo
      ...

Code for inner foo:
      goOrigin to foo           <----------------
      inner P,off:
           thisStack.rpop -> X; <-------------
           thisObj -> X.push <----------------
           X -> thisObj      <----------------
           thisObj.saveReturn(thisCode.descInx,glsc)
           X.VDT[off] -> descInx
           descs.OD[descInx].BC -> thisCode
           thisCode.doE -> glsc
     thisObj.rpop -> thisObj --------------

Code for Bar:
     A: ...
     DO: ...
         ReturnInner:
           thisObj.restoreReturn -> (descInx,glsc)
           descs.OD[descInx].BC -> thisCode
         
Origin for objectDesc:
----------------------
R: { foo: bar { ...}
   }

R.foo  -- non singular

   LoadOrigin = R
   Alloc foo

Code for foo: bar{ ... }
   store foo.origin
   LoadOrigin Bar
   exe bar.alloc
   
R.foo{ ... } -- singular

   loadOrigin = thisObject
   Alloc foo

Implicit super
---------------
Consider

(1)	V:< { ... }
(2)	V:< A

   	Vf::< { ... } or Vf::  {...}

which both have V/A as an implicit super

We need to compute origin for the implicit super of V

Case (1) is trivial since V and Vf has the same origin

Consider case (2)

     A: {...}
...
     Q: { ... }
...
     QQ: Q{ V:< A; ... }          -- A.on = n
...
     QQQ: QQ{ ... }              -- 
....
     QQQQ: QQQ{ Vf:: {... } ... } --

Given an instance of QQQ, we have
     QQQQ.originOff
     QQQ.originOff
     QQ.originOff
     Q.originOff

Origin for Vf.super may be computed by
     load QQ.originOff
     goOrigin(n)

  
Super
------

Foo: bar { ... }
Foo: R.bar { ... }
Foo: max(1,2) { ... }
Foo(x: @integer, y: @integer): max(x,y) { ... }
Foo(x: @integer): max(x,y + 100) { ... }

Does this work for virtuals?
-----------------------------

%put V: @integer %at inx: @integer :< ...

%put V: @integer %at inx: @integer:: { ... }

%put%at :: { ... }

It must be the same signature - i.e the signature cannot be extended!?

Scope for super
------------------

Foo: R.S.bar{ ... }

R, should be defined in origin of Foo

Foo(x: @integer): R.Bar(x + 2){ ... }

R and Bar has scope  = Foo.origin
Argument of Bar (x) has scope Foo.signature!

So do we ned more than one scope argument:
   thisScope
   enclosingScope = thisScope.origin
   signatureScope

For both R and x (in R.bar(x + 1 )), we must add 1 (one) to origin
(on)

How do we know which scope to search?

Normal invocations

   R.Bar(X + 2)

R and X in thisScope

Boolean: inSuper

(if inSuper then 
    use enclosingScope for an invocation
    use signatureScope for arguments of Binary,Function and KeyWord


LoadAdr/origin
--------------

Foo
   - pushThis
   - foo.ON -> goOrigin

R.S.Foo
   - pushThis
   - R.ON -> goOrigin
   - push R.off
   - push S.off

Consider
--------

R.foo(e1,e2).S.Bar(e3,e4) -- here we must execute foo

   -- pushThis
   -- push R.off
   -- eval e1, e2
   -- Alloc foo - and execute - must return a ref to obj with S attribute
   -- push S.off
   -- eval e3, e4
   -- Alloc Bar
   
Singular

R.foo(e1,e2).S.Bar(e3,e4){ ... } = X

   -- pushThis
   -- push R.off
   -- eval e1, e2
   -- Alloc foo - and execute - must return a ref to obj with S attribute
   -- push S.off
   -- Alloc X - includes alloc of Bar

X: -- store origin
   -- eval e3,e4  - but in context of the call: R.foo(e1,e2) ... 
   -- goSuper Bar

hest(a,b: @integer): R.foo(e1,e2).S.Bar(e3,e4){ ... } = X
   super of X must be evaluated in the context of X, i.e. where hst is declared

hest(f1,f2) 



Recursive patterns
------------------

Consider

   MyPtn:
      ...
      MyPtn
      ...

   MySub: MyPtn
      ...

When executing MySub, a recursive call of MyPtn is invoked.
   * Is this just an instance of MySub
   * Or is this an invocation of MySub!?

How do we implement this!?
   * A copy of thisObject - need to follow origin
   * What if MySub has arguments? We dont know the formal parameters
     but if we just execute Alloc, the code storing the arguments will
     be executed 
   * Perhaps we just skip the origin, argument part
     - make a copy
     - execute starts at enterE!?
   * But MyPtn may have arguments - and then strange not to be able 
     to supply them
     - In principle we may allow MyPtn arguments and just copy MySub
       arguments
     - But more tricky to implement!?
     - Perhaps not! If we execute MyPtn.Alloc, then it seems to work
       Normally we would start at MySub, but by executing MyPtn,
       we just store origin and arguments for MyPtn and then proceed
       to the remaining alocation code and do an innerA

But what is a recursive call?

    MyPtn:
      ...
      foo:
         ... MyPtn   -- through a remote execution, but ok?
      bar:
         ... MyPtn   --  MyPtn is on the stack, so ok
      ...
      MyPtn
      bar

    MySub        -- OK
    R: @ MySub  
    R.foo        -- Seems ok!?
    
Origin search
-------------
As of now ON is counted when we search an enclosing singular

     %foo e %at { x := x + 1} {}

IS is empty for %foo%at ..

%foo%at generates an object so it is probably ok

For 

   %if e %then { x := x + 1}{}

there is no object since %if%then is primitive. We should thus not
increment on here. Cond and thenPart might be referred!?


---

Can we have :

   bar(R: ^T, x: y: ) : R.foo(x,y) { ...}

But then also:

   bar: R.foo(x,y){ R: ^T, x: ...; y: ...}

?? No - will give circular patterns - and be confusing

Functions in path
-----------------

R.foo(e1,e2).S.bar(e4,e5)
   -- R.pushThis
   -- R.goOrigin
   -- R.pushOff
   -- push, e1, e2
   -- invoke foo
   -- S.pushOff
   -- push e4,e4
   -- invoke bar   -- if super, then no invoke/ goSuper instead

Objects: R.pushOff
Patterns: Push arguments + invoke

Seems the same operation

   R.S{ ... }          -- always S.pushOff
   R.foo(e1,e2){ ... } -- always push e1,e2 - no invoke

Return values
--------------
   foo:               - no return specified, this is default
   foo -> V: @integer - return V and not this
   foo -> S: ^bar     - return S and no this

   S: @foo            - must return this
   X := foo 
   foo                - pop return

Return values
--------------

   foo             - return value not used
   R:= foo         - return value used
   foo(e1,e2)      - return value of foo not used, used for e1, e2
   R := foo(e1,e2) - return value of foo used, sed for e1, e2


Reconsider SCOPE
================

  myClass:
     ...
     foo(a: @integer, b: @integer) -> z: @integer:
         ...
     bar(x: @integer, y: @integer) -> v: @integer: foo(x,y)
        { a: @integer ... }

Let G = {..., foo, bar, ...}
    S = {x,y,v}
    M = {a, ...}

foo must be defined in G and its origins
Arguments, x, y must be defined in S and origins

Complicated search and handling of ON

Perhaps 
1. search foo(x,) in M + S
2. check explicit that foo.on > 0
   Not enough - foo may be in local scope and in global scope
   We should bind to global scope
3. codegen with foo.on, x.on, y.on should then be ok!?
 
Argument to search: 
  * not Local and Signature (foo)
  * not local - signature and global (x,y)

Search(local,Sig,inGlobal,inSig,CS)
    if inGlobal, search CS in local.origin, add 1 to on
    if inSig, search CS in SIg and sig.global=local.global
    for Foo(e1,e2)
    (local,Sig,true,true) -> e1.search

Scopes: e1.e2.e3 
where
  e = R
    = foo(a1,a2), %put a1 %at a2, ++ a1
1. local
2. first: R, foo, %put%at, ++
   either local or local.origin
3. arguments:
   either local, local + sig

In R.foo(e1,e2), foo is in R.local, e1,e2 in local
so even if not super, we need to different scopes


mScope = mS: the scope for (first) name in an invocation
aScope = aS, the scope for arguments of an invocation

   check(mS,aS: Scope)

1. Outer level 
   OG.check(local,local)

2. Unary R: R -> mScope.search
3. Function, KW, Bin: foo(e1,e2): 
   foo -> mScope.search,
   e1.check(aS,aS)
4. R.S:  R -> mS.search; S -> R.local.search
   R.E : R.local,aS) -> E.search
5. bar(x,y) : R.S.foo(e1,e2){ ... }
   (local.origin,sig={x,y}) -> super.check

OBS! Remember that scope is also used for storage allocation

SCOPE
=====

 Scope: 
    { local, super, sig, global: ^Items; 
      -- search places
      inLocal, inSuper, inSig, inGlobal: @boolean;
      -- for super we start with global, but arguments alos needs Sig
      search:
         { CS: ^Text enter CS[] do inner }
    }

-- perhaps 2 arguments
   * scope for outer: first in R.A:foo(e1,e2)
   * scope for arguments
        
Pattern:Check: 
      sig.check -- scope = {global,arguments = global}
Items:: check
    super.check -- scope = { global, args = sig + global}
    items.check -- scope = { local, local }
 
    locals = locals + super + sig + global
    sig = sig + global

- Signature: must be a scope like Items - remember Return Value 
- How do we organize search?
-
- local:  local.search, sig.search, super.search, global.search
- global: the same
- sig:    sig.search, no additional sig, no super, global.search
- Perhaps: scope.search. scope.next.search
- Perhaps the socpe object determines 
    - items.next -> sig, super, global
    - sig.next -> global - but not consist with items.next above

- Perhaps:
    items.search = as now
    item.localSearch = as now
    sig.search = called when sig is the scope
               = next = globals. search

scope: 
  { -- common super
    search:< ...
  }

Signature: scope
    { args:
      val:
      search:: ... localSearch
      localSeach: ..., args.search, val.search
    }

Items: scope
   { 
     search:: localSearch, sig.localSearch, super.superSearch, origin.search
     localSearch: ... search this ...
     -- can we have an inner or vArg that at first level serach sig?
     superSearch: .. search super + super.superSearch
   }

-- remaining issue: search order for sig and super!?

-- and remote: S.R.foo
    R in S.local, S.super, ..., no sig or global
- How do we organize search in local - should only search local and
-- super - not global and probably not sig!

Array syntax
===============

A: [l1..u1,l2..u2,l3..u3] integer

---->
A: = Array(list(Range(l1,u1),Range(l2,u2),Range(l3,u3)),integer)

A[e1,e2,e3]:= exp

V := A[e1,e2,e3]

foo(a: ?integer, b: ?integer, c: ?integer) -> res: ?integer:
    ...

V := foo(e1,e2,e3)

foo(e1,e2,e3) := exp

Perhaps we should have VALUE and ASSING like enter/exit
But here on pattern - 

foo(a: ?integer, b: ?integer, c: ?integer) 
                                  -> res: ?integer
                                  := V: ?integer:

    ..


Indexed constants
====================

I : ? Indexed

I := (e1,e2,e3)

I := (e) 

-- in general we evaluate an exp (e)
-- (e1,e2,e3) should evalue to an Indexed object
-- (e) should only if assigned to an Idenxed variable
-- Will this be confusing?

XML syntax
----------------

<\if> x = 0 <\then\> x := 0 <\else\> x := x + 1 
