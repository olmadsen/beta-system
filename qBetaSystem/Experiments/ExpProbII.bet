ORIGIN '~beta/basiclib/betaenv';
---lib:attributes---
LangF:
  (# ThisType:< LangF;
     Visitor:
       (# R:< Object;
          forNum:<
            (# n: @integer; v: ^R
            enter n
            do inner
            exit v[]
            #)
       #);
     Exp:
       (# R:< Object;
          visit:<
            (# T:< Visitor; v: ^T; res: ^R
            enter v
            do inner
            exit res[]
            #)
       #);
     Num: Exp
       (# n_ : @integer;
          visit::
            (#
            do n_ -> v.forNum -> res[]
            #)
       #);
     IntegerVisitor: Visitor(# R:: IntegerObject #);
     Eval: IntegerVisitor
       (# 
          forNum::
            (#
            do &IntegerObject[] -> v[]; n -> v
            #)
       #) 
  #);
(*class Lang2F<This extends Lang2F<This>> extends LangF<This> ... *) 
Lang2F: LangF
  (# ThisType:: Lang2F;
     (* interface Visitor<R> extends LangF<This>.Visitor<R> {
      *    public R forPlus(This.Exp e1, This.Exp e2);
      * }
      *)
     Visitor2F: Visitor
       (# (*R::ThisType;*) 
          forPlus:< 
            (# e1,e2: ^Exp; v: ^R
            enter(e1[],e2[])
            do inner
            exit v[]
            #)
       #);
     Plus: Exp
       (# e1_,e2_: ^Exp;
          (* public <R> R visit(This.Visitor<R> v) {
           *    return v.forPlus(e1_,e2_); } *)

          visit::
            (# T:: Visitor2F
            do (e1_[],e2_[]) -> v.forPlus -> res[]
            #)
       #);
     Eval: Visitor2F
       (# R:: IntegerObject;
          forPlus::
            (#
            do &IntegerObject[] -> v[];
               (*(e1.visit).n + e2.n_ -> V*)
            #)
       #)
  #)
---program:descriptor---
(# L: ^LangF; 
   e: ^L.Exp; e1: ^L.Num; 
do &LangF[] -> L[];
   &L.Num[] -> e[]; 42 -> (e[]->e1[]).n_;
   
#)

     
