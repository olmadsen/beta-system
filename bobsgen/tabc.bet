ORIGIN '~beta/basiclib/v1.5/betaenv';
INCLUDE '~beta/basiclib/v1.5/file';
INCLUDE '~beta/sysutils/v1.5/endian';
--- program : descriptor ---
(*-------------------------------------------------------------------------
 |  Convert parse tables generated by the BOBS parser generator to         |
 |  the binary format used by the BETA version of the skeleton translator  |
 --------------------------------------------------------------------------*)
(* Many constants increased by CN, 4/10/1989.
 * OLM/17.1.93: is converted to basiclib/v1.2.
 * Until now, repetitons have not been extended using extend.
 * This has been initiated in this version. It is, however, not completed!
 * OLM/26.3.94: 
 *  - upgraded to basiclib/v1.4.
 *  - input/out files must now be given on the command line:
 * 
 * 		tabc [-trace] <inputTableFile> <outputTableFile>
 * 
 * 	where 
 * 	   <inputTableFile> is a 'tables' file produced by the bobs 
 * 	                    parser generator (exbobs)
 *	   <outputTableFile> may be on the form
 * 		foo  foo.btab  foo.btabL
 * 	   In any case the suffix is added/replaced by  '.btab' (big endian)
 * 	   or '.btabL' (little endian).
 * 	   I.e. if 'foo.btab' is used on a little endian machine it is changed
 * 	   to 'foo.btabL' and vice versa.
 * - a boolean trace (parameter '-trace') controls output of trace information
 * 
 *)
(# MinCh: (#exit 32 #); maxCh: (#exit 126 #);

   Table:
     (# size:< (# val: @integer do 12000 -> val; inner; exit val #);
        R: [size] @integer; top: @integer;
        Put: 
          (# enter R[top] 
          do (if (top+1->top) > R.range then R.range->R.extend if) 
          #);
     do 1->top
     #);
   
   LxTable: Table
     (***************** lexical tables ***********)
     (# chInx: @ (# ch: @ char enter(ch) exit(4*ch) #);
        NP: @ (# inx: @ integer enter(inx) exit(R[(inx-1)*4+1])#);
        HP: @ (# inx: @ integer enter(inx) exit(R[(inx-1)*4+2])#);
        TV: @ (# inx: @ integer enter(inx) exit(R[(inx-1)*4+3])#);
        CH: @ (# inx: @ integer enter(inx) exit(R[(inx-1)*4+4])#);
        
     #);
   
   LrTable: Table
     (# lrStartState:
          (# goal,start: @integer
          enter goal
          do (if goal=0 then
                 lrStart->start
              else (Goal-nontStart)*5 + lrStart->start
             if)
          exit start
          #);
        
        Chain: @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+1])#);
        Next:  @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+2])#);
        Kind:  @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+3])#);
        Symb:  @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+4])#);
        Err:   @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+5])#);
        RS:    @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+4])#);
        Prod:  @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+5])#);
        LB:    @ (# inx: @ integer enter(inx) exit(R[(inx-1)*5+4])#);
        
     #);
   
   Entry: @LxTable;
   LX: @ LxTable(# size::< (#do 50000->val #); #); (* was 50000 *)
   LR: @ LrTable(# size::< (#do 100000->val #);  #); (* was 100000 *)
   
   GoalSymbol,nontStart,
   lrStart, lrMax, lxMax, errorVal, nameVal, constVal,
   stringVal, comBegin, comLength, symbMax,prodMax,prodFmax,
   lxBase, Lrbase,stringEscape,nontL,nontR,
   RhsI,SpelI: @ integer;
   stringCh: @ char;
   
   comEndStr:  (# c: [1] @ char #);
   comEnd:@ comEndStr;
   
   nonTval,nonTlength: @integer;
   nonTend: [2] @char; 
   
   bobsLab,   (* label->bobsProdNo *)
   LHS,       (*nonterminal on left hand side *)
   rhsLength, (*length of right hand side *)
   rhsIndex,  (*start of RHS in RHS            *)
   labelNo,   (*Fixed no. of production        *)
   labelInx   (*Start of symbolic label in spellTbl *)
   : [1000] @ integer;
   symbIndex : [100] @ integer; (* start of symbolic label *)
   RHS : [5000] @ integer;
   spellTbl: [5000] @ integer;
   
   TT: @ stream(* trace output *)
     (# put::<(# do (if trace then ch->screen.put if) #);
        trace: @boolean
     #);
   
   Initialize:
     (# tables: ^Stream; CHv,NP,HP,TV: @integer
     enter tables[]
     do 'Constants:\n'->TT.putText;
        '\tgoalSymbol='->TT.puttext; 
        tables.getInt->goalSymbol->TT.putInt; 
        '\n\tnontStart='->TT.putText;
        tables.getInt->nontStart->TT.putInt;
        '\n\tsymbMax='->TT.putText;
        tables.getInt->symbMax->TT.putInt;;
        '\n\tprodMax='->TT.putText;
        tables.getInt->prodMax->TT.putInt;;  
        tables.getInt->prodFmax;
        tables.getInt->lrMax;    tables.getInt->lxMax;
        tables.getInt->errorVal; tables.getInt->nameVal;
        tables.getInt->constVal; tables.getInt->stringVal;
        tables.getInt->stringCh; tables.getInt->comBegin;
        tables.getInt->comLength;
        tables.getInt->nontL; tables.getInt->nontR;
        
        (* read commmentEnd *)
        (* & comEndStr ->comEnd; *)
        comlength->comEnd.c.new;
        (for i: comLength repeat
             tables.getInt->comEnd.c[i]
        for);
        (* skip to eol *)
        
        '\nEntry:\n'->TT.puttext; 
        Entry;
        (minCh,maxCh)->forTo
        (#
        do tables.getInt->CHv;
           tables.getInt->NP;
           tables.getInt->HP;
           tables.getInt->TV;
           NP->entry.put; (* NP *)
           HP->entry.put; (* HP *)
           TV->entry.put; (* TV *);
           CHv->entry.put; (* CH *)
        #);
        
        'LX:'->TT.puttext; (LxMax)->TT.putInt; TT.newline;
        LX;
        (for LxMax+1 repeat
             tables.getInt->CHv;  (*CHv->TT.putInt;*)
             tables.getInt->NP;   (*NP->TT.putInt;*)
             tables.getInt->HP;   (*HP->TT.putInt;*)
             tables.getInt->TV;   (*TV->TT.putInt; TT.newLine;*)
             NP->LX.put; (* NP *)
             HP->LX.put; (* HP *)
             TV->LX.put; (* TV *);
             CHv->LX.put; (* CH *)
        for);
        
        (# kind: @integer
        do 'LR:'->TT.putText; (LrMax)->TT.putInt; TT.newline;
           LR;
           (for LrMax+1 repeat
                tables.getInt->LR.put;         (* chain *)
                tables.getInt->LR.put;         (* next *)
                tables.getInt->kind->LR.put;   (* kind *) 
                tables.getInt->LR.put;         (* symb, rs *)
                (if kind=5 then 
                    0->LR.put
                 else tables.getInt->LR.put      (* err, prod *)
        if)for)#);
        
        (* temporary *)
        2->nonTval; 2->nonTlength; '>'->nonTend[1]; '>'->nonTend[2];
        
        (if stringCh=' ' then
            -2->stringEscape; (* no stringCh defined *)
         else
            stringCh->lx.chInx->lx.TV->stringEscape
        if);
        
        InitGram: 
        (* format of grammar part of file tables:        *)
        (* for each prod:                                *)
        (*     prodno  n X0 X1 ... Xn  label labelNo     *)
        (*     label is a nonempty string, ? means dummy *)
        (*     labelNo is a fixed no. ass. with prodno   *)
        (* nontStart  0<= terminal < nontStart <= nonTerminal <=symbMax *)
        (* for each symb: string                         *)
        (#
           ReadLabel: 
             (# start,length: @ integer; ch: @ char;
             do spelI->start; spelI +1->spelI; 0->length;
                tables.get->ch;
                loop: (if ch=' ' then tables.get->ch; restart loop if);
                loop: (* dot = '.' or ' '; see below *)
                  (if (ch <> dot) and (ch > ' ') then 
                      (if (spelI->spelI)>spellTbl.range then
                          spellTbl.range->spellTbl.extend
                      if);
                      ch->spellTbl[spelI]; spelI+1->spelI;
                      tables.get->ch; length +1->length;
                      restart loop
                  if);
                labNotext.clear;
                (*
                (if spellTbl[spelI-1] = '-' then
                    spelI-1->spelI; length-1->length;
                    '-'->labNotext.put;
                if);
                ch->labNoText.put;*)
                length->spellTbl[start];
             exit start 
             #);
           
           p, L,lab: @ integer; labNoText: @text;
           dot: @char;
        do '.'->dot;
           'Initgram:\n'->TT.puttext;
           1->rhsI; 1->spelI; newline;
           prodMax->bobsLab.new;
           (for i: prodMax repeat 0->bobsLab[i] for);
           (for i: prodMax repeat
                tables.getInt->p;
                (if p>LHS.range then
                    LHS.range->LHS.extend;
                    rhsLength.range->rhsLength.extend;
                    rhsIndex.range->rhsIndex.extend;
                    labelInx.range->labelInx.extend;
                    labelNo.range->labelNo.extend
                if);
                tables.getint->rhsLength[p]->L;
                tables.getint->LHS[p];
                rhsI->rhsIndex[p];
                (for j: L repeat
                     (if rhsI>RHS.range then RHS.range->RHS.extend if);
                     tables.getint->RHS[rhsI];
                     rhsI + 1->rhsI;
                for);
                readLabel->labelInx[p];
                (* labNoText[1] = 1. or 2. char after label *)
                     (*tables.getLine(#do ch->labNoText.put #);*)
                tables.scanToNl(#do ch->labNoText.put #);
                ' '->labNoText.put; 
                0->labNoText.setPos;
                labNotext.getInt->lab->labelNo[p];
                (if ((p<11) or (prodMax-11<p)) then
                    (* test output was here! *)
                if);
                (if (1<=lab) and (lab<=bobsLab.range)  then
                    (if bobsLab[lab] = 0 then p->bobsLab[lab] if)if);
           for);
           '/'->TT.put; rhsI->TT.putint; '/'->TT.put;(RHS.range) ->TT.putint; 
           '/'->TT.put; (spelI)->TT.putint;
           '/'->TT.put; (spellTbl.range)->TT.putint;
           '/'->TT.put; (symbMax)->TT.putInt;
           '/'->TT.put; (symbIndex.range)->TT.putint; TT.newline;
           (if symbMax>symbIndex.range then
               symbMax-symbIndex.range+10->symbIndex.extend
           if);
           ' '->dot; (* OBS!! see readLabel *)
           (for i: symbMax repeat
                tables.getint ->p; 
                (if (p<1) or (symbIndex.range<p) then
                    (p-symbIndex.range+100)->symbIndex.extend;
                    'Symbindex out of range:'->TT.putText; 
                    readLabel->TT.putInt; '->symbIndex['->TT.puttext; 
                     p->TT.putint;']'->TT.put; TT.newline;
                 else readLabel->symbIndex[p]
                if);
           for);
           '\nEnd of reading tables'->TT.putLine
     #)#);
   
   (******** end initialization***************************)
   
   Base: @
     (# comEnd,
        nonTend,
        lx,lr,
        lhs,
        rhs,rhsLength, rhsIndex,
        labelNo,
        bobsLab,
        labelInx,
        symbIndex,spellTbl: @integer
     #);
   
   SaveTables:
     (*//////////////////////////////////////////////////////////////////////
      The BOBS tables are stored as follows:
      
      R[1]    : goalSymbol
      R[2]    : nontStart
      : ...
      base.comEnd     R[29]   : base.spellTbl
      R[30]   : comEnd[1]
      : ...
      base.LX         R[xx]   : comEnd[comLength]
      +1              : entry[0].1
      +2              : entry[0].2
      +3              : entry[0].3
      +4              : entry[0].4
      : ...   
      lxBase+255*4            : entry[254].4
      +1              : entry[255].1
      +2              : entry[255].2
      +3              : entry[255].3
      +4              : entry[255].4
      lxBase+256*4            : lx[0].1
      +1              : lx[0].2
      +2              : lx[0].3
      +3              : lx[0].4
      : ...
      : lx[lxmax].1
      : lx[lxmax].2
      : lx[lxmax].3
      base.LR                 : lx[lxmax].4
      +1              : lr[0].1
      +2              : lr[0].2
      +3              : lr[0].3
      +4              : lr[0].4
      +5              : lr[0].5
      : ...
      lrBase+lrMax*5+1        : lr[lrMax].1
      +2              : lr[lrMax].2
      +3              : lr[lrMax].3
      +4              : lr[lrMax].4
      base.LHS                : lr[lrMax].5
      : LHS[1]
      : ...
      base.RHS                : LHS[prodMax]
      : RHS[1]
      : ...
      base.rhsLength          : RHS[prodmax]
      : ...
      /////////////////////////////////////////////////////////////*)
     (#  bin: @Table
          (#  size::< (#do 200000->val #);
             
             save:
               (#
               do (@@R[1],top-1)->out.putRep
               #);
             
          #);
        
        off:
          (# base,n,m,off: @integer
          enter (base,m,n)
          do (if n = 0 then 0->off else base+n*m->off if)
          exit off
          #);
        
        
        out: ^file
     enter out[]
     do bin;
        
        goalSymbol       ->bin.R[1];
        nontStart        ->bin.R[2];
        symbMax          ->bin.R[3];
        prodMax          ->bin.R[4];
        prodFmax         ->bin.R[5];
        lrMax            ->bin.R[6];
        lxMax            ->bin.R[7];
        errorVal         ->bin.R[8];
        nameVal          ->bin.R[9];
        constVal         ->bin.R[10]; 
        stringVal        ->bin.R[11];
        stringCh         ->bin.R[12];
        comBegin         ->bin.R[13];
        comLength        ->bin.R[14];
        nontL            ->bin.R[15]; (* nonTval *)
        nontR            ->bin.R[16];
        stringEscape     ->bin.R[17];
        
        29->base.comEnd                        ->bin.R[18];
        base.comEnd+comLength+256*4->base.lx   ->bin.R[19];
        base.lx +(lxMax+1)*4->base.lr          ->bin.R[20];
        base.lr + (lrMax+1)*5->base.LHS        ->bin.R[21];
        base.LHS + prodMax->base.RHS           ->bin.R[22];
        base.RHS + (rhsI-1)->base.rhsLength    ->bin.R[23];
        base.rhslength + ProdMax->base.rhsIndex->bin.R[24];
        base.rhsIndex+ ProdMax ->base.labelNo  ->bin.R[25];
        base.labelNo + ProdMax->base.bobsLab   ->bin.R[26];
        base.bobsLab + ProdMax ->base.labelInx ->bin.R[27];
        base.labelInx+ ProdMax ->base.symbIndex->bin.R[28];
        base.symbIndex+ SymbMax ->base.spellTbl->bin.R[29];
        
        30->bin.top; 
        (for i: comLength repeat  comEnd.c[i]->bin.put for);
        
        
        (for minCh*4 repeat 0->bin.put for);
        
        (for inx: (maxCh-minCh+1) repeat
             (base.lx,4, inx->entry.NP) ->off->bin.put;
             (base.lx,4, inx->entry.HP) ->off->bin.put;
             inx->entry.TV->bin.put;
             inx->entry.CH->bin.put
        for);
        
        (maxCh+1,255) ->forTo(#do(for 4 repeat 0->bin.put for)#);
        
        (for inx: lxMax+1 repeat
             (base.lx,4, inx->LX.NP) ->off->bin.put;
             (base.lx,4, inx->LX.HP) ->off->bin.put;
             inx->LX.TV->bin.put;
             inx->LX.CH->bin.put
        for);
        
        (for inx: lrMax+1 repeat
             (base.lr,5, inx->LR.chain) ->off-> bin.put;
             (base.lr,5, inx->LR.next) ->off-> bin.put;
             inx->LR.kind-> bin.put;
             (if (inx->LR.kind)=5 then
                 (base.lr,5, inx->LR.LB) ->off-> bin.put
              else inx->LR.symb->bin.put
             if);
             inx->LR.prod-> bin.put;
        for);
        
        (for p: prodMax repeat LHS[p]->bin.put for);
        (for p: rhsI-1 repeat RHS[p]->bin.put for);
        (for p: prodMax repeat rhsLength[p]->bin.put for);
        (for p: prodMax repeat rhsIndex[p]->bin.put for);
        (for p: prodMax repeat labelNo[p]->bin.put for);
        (for p: prodMax repeat bobsLab[p]->bin.put for);
        (for p: prodMax repeat labelInx[p]->bin.put for);
        (for p: symbMax repeat symbIndex[p]->bin.put for);
        (for p: spelI repeat spellTbl[p]->bin.put for);
        bin.save;
        
     #);
   
   argError:
     (#
     do '\n\nUsage: \ttabc  [-trace] <InputTableFile> <OutputTableFile>\n'
          ->puttext;
        stop
     #);
   
   FixOutName:
     (* outname = foo
      *         | foo.tabc
      *         | foo.tabcL
      * A possible suffix '.tabc' or '.tabcL' is deleted.
      * If big endian then '.tabc' is appended
      * If little endian, then '.tabcL' is appended
      *)
     (#
     do outName[]->TT.putline;
        (outName.length-4,outName.length)->outName.sub->suffix[];
        suffix[]->TT.putline;
        (if '.btab'->suffix.equal then
            (outName.length-4,outName.length)->outName.delete;
         else
            (outName.length-5,outName.length)->outName.sub->suffix[];
            suffix[]->TT.putline;
            (if '.btabL'->suffix.equal then
                (outName.length-5,outName.length)->outName.delete
        if)if);
        outName[]->TT.putLine;
        (if isBigEndian then '.btab'->outName.append
         else '.btabL'->outName.append
        if);
        outName[]->TT.putline;
        outName[]->out.name
     #);
   
   
   outName,ARG,suffix: ^text; 
   
   inn: @file;
   out: @file(# binary::< trueObject #)
do (if noOfArguments>=3 then
       2->arguments->ARG[];
       (if '-trace'->ARG.equal then
           true->TT.trace;
           (if noOfArguments>=4 then
               3->arguments->inn.name;
               4->arguments->outName[]
            else argError
           if)
        else
           ARG[]->inn.name;
           3->arguments->outName[]
       if)
    else
       argError
   if);
   FixOutName;
   
   inn.openRead;
   inn[]->initialize;
   
   out.openWrite;
   out[]->saveTables;
   out.close
   
#)
