ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/directory';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/sysutils/envstring'
---Lib:attributes---
DirCh: (# exit '/' #);

BetaLib: (# path: ^text do '$(BETALIB)' -> expandEnvVar -> path[] exit path[] #);
prependPathToBetaWorld:
  (# fn,path,fullPath: ^text
  enter fn[]
  do BetaLib -> path[];
     '/MiniSystem/miniCompiler/BETAworld/' -> path.append;
     fn[] -> path.append -> path[];
     &text[] -> fullPath[];
     path.scanAll
     (#do (if ch = '/' then dirCh -> fullPath.put else ch -> fullPath.put if)#);
  exit fullPath[]
  #);

getCurrentDir:
  (# getCurDir: External
       (# cwd: [1]@char;
       exit cwd
       #);
     cwd: ^text;
  do &text[]->cwd[];
     getCurDir->cwd;
  exit cwd[]
  #);
DirectoryComponents:
  (# D: @directory;
     rpath,dir: ^text;  (* rpath = rpathX/dir *)
     current: ^text
  enter(rpath[],dir[])
  do rpath[] -> D.name;
     (*D.entry.path.name -> putline;*)
     (if D.empty then
         (* 'IS empty' -> putline *)
      else
         (*'XEntries in ' -> puttext; dir[] -> puttext; ':' -> put;*)
         D.scanEntries
         (# T: ^text
         do found.path -> current[]; (* current[] -> putline; *)
            (if true
             // '.' -> current.equal
             // '..' -> current.equal 
             // (current.length -> current.inxGet) = '~' then
             else                
                rpath.copy -> T[];
                dirCh -> T.put;
                (if (('.bet' -> ((current.length-3,current.length) -> current.sub).equal)
                    and ((1,current.length-4) -> current.sub -> dir.equalNCS)) then
                   (* 'Found component file: ' -> puttext; current[] -> putline;*)
                    current[] -> T.append -> current[];
                    inner DirectoryComponents
                if)
            if)
         #)
     if)
  #);
getBETAdirectories:
  (# D: @directory;
     rpath: ^text;
     current: ^text;
     cont: [8] ^text; isFile: [8] @ boolean; top: @integer;
     add:
       (# E: ^text; isF: @boolean
       enter(E[],isF)
       do (if (top + 1 -> top) > cont.range then 
              cont.range -> cont.extend ;
              isFile.range -> isFile.extend
          if);
          E[] -> cont[top][];
          isF -> isFile[top];
       exit E[]
       #);
     scan:
       (# current: ^text; currentIsFile: @boolean
       do (if true then
              (for i: top repeat
                   cont[i][] -> current[];
                   isFile[i] -> currentIsFile;
                   inner
              for)
           else
              (for i: top repeat
                   (if isFile[i] then cont[i][] -> puttext; ' ' -> put if);
              for);
              (for i: top repeat
                   (if not isFile[i] then cont[i][] -> puttext; ' ' -> put if);
              for);
              inner
          if)
       #);
     isBETAdir: booleanValue
       (# dir,RP: ^text
       enter dir[]
       do (* 'IsBETAdir: ' -> puttext; rPath[] -> puttext; ' '->put; dir[] -> putline;*)
          rpath.copy -> RP[]; dirCh -> RP.put; dir[] -> RP.append;
          (RP[],dir[]) -> DirectoryComponents(# do true -> value #)
       #);
     allDir: @boolean
  enter(rpath[],allDir)
  do rpath[] -> D.name;
     (* D.entry.path.name -> putline; *)
     (if D.empty then
         (*'IS empty' -> putline*)
      else
         (* 'Entries in ' -> puttext; dir[] -> puttext; ':' -> put; *)
         D.scanEntries
         (# FN,ext: ^text;
         do found.path -> fn[];
            (if FN.length > 4 then
                (FN.length-3,FN.length) -> FN.sub -> ext[]
             else 
                '' -> ext[]
            if);
            (if true
             // '.' -> FN.equal
             // '..' -> FN.equal
             // (fn.length -> fn.inxGet) = '~' then
             else            
                select
                (# whenFile:: 
                     (# 
                     do (if '.bet' -> ext.equalNCS then 
                            (fn[],true) -> add
                        if)
                     #);
                   whenDir:: 
                     (# 
                     do (if (FN[] -> isBETAdir) or allDir then
                            (FN[],false) -> add
                        if)
                     #);
                #)
            if)
         #);
         inner getBETAdirectories;
     if)
  #);

testAndCreateDir: booleanValue
  (# pathD: @directory;
     path,dirN: ^text
  enter(path[],dirN[])
  do 'TestAndCreateDir:Path: ' -> putline; ' '-> put; path[] -> putline;
     ' Directory: ' -> puttext; dirN[] -> putLine;
     path[] -> pathD.name;
     L:
       (if pathD.entry.exists then
           ' Path exists!' -> putline; 
           dirN[] -> pathD.createDir
           (# exists:: (# do 'Dir exists' -> putline; leave L #)
           #);
           true -> value
        else
           ' Path does not exist' -> putline;
     if)
  #);
testAndCreateFile: 
  (# pathD: @directory;
     F: @file;
     path,FN,fullFN: ^text
  enter(path[],FN[])
  do 'TestAndCreateFile:Path: ' -> putline; ' ' -> put; ; path[] -> putline;
     ' File: ' -> puttext; FN[] -> putline;
     path[] -> pathD.name;
     L:
       (if pathD.entry.exists then
           FN[] ->  pathD.createFile
           (# exists:: (#  do ' File exists'->putline; leave L #)#);
           path.copy -> fullFN[];
           dirCh -> fullFN.put;
           FN[] -> fullFN.append;
           fullFN[] -> F.name;           
        else
           ' Path does not exists' -> putline
       if)
  exit F[]
  #);
deleteDirectory:
  (# path: ^text;
     dir,DF: @directory; F: @file;
  enter path[]
  do 'Delete dir and its files:'->putline;
     path[] -> putline;
     path[] -> dir.name;
     dir.scanEntries
     (# en: ^text
     do foundFullpath -> en[] -> putline;

        (if true
         // '.' -> ((en.length,en.length) -> en.sub).equal then 'found . or ..'->putline 
         else
            select
            (# whenFile::(# do en[] -> F.name; F.delete #);
               whenDir:: (# do 'Delete of local dir: not implemented' -> putline #)
            #)
        if)
     #);
     dir.delete
  #);
fixExtension_bet:
  (# FN: ^text
  enter FN[]
  do (if true
      // (FN.length >= 5) and ('.bet' -> ((FN.length-3,FN.length) -> FN.sub).equal) then
         (* FN = '...x.bet' *)
      // (FN.length -> FN.inxGet) = '.' then
         'bet' -> FN.append
      else
         '.bet' -> FN.append
     if);
  exit FN[]
  #);
fixExtension_xbeta:
  (# FN: ^text
  enter FN[]
  do (if true
      // (FN.length >= 7) and ('.xbeta' -> ((FN.length-5,FN.length) -> FN.sub).equal) then
         (* FN = '...x.bet' *)
      // (FN.length -> FN.inxGet) = '.' then
         'xbeta' -> FN.append
      else
         '.xbeta' -> FN.append
     if);
  exit FN[]
  #)



     
