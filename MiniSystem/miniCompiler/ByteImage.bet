ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/numberio';
---lib:attributes---
ByteImage:
  (* Binary format of object descriptors:
   * -----------------------------------
   * 0        : noOfDescriptors
   * 2        : D1
   * ...      :
   * 2+D1.size: D2
   * ...
   * 
   * Descriptor format:
   * ------------------
   * 0: name - length + chars
   * ..:
   *   : descInx
   *   : originoff
   *   : superObjDesc
   *   : ByteCode
   * 
   * ByteCodeFormat:
   * ---------------
   * 0   : length
   * ....:
   * 4   : c1
   * 5   : c2
   * ...: 
   * 
   * 
   *)
  (# B: [4000] @ int8u; top: @integer;
     strings: [1000] @ int8u; sTop: @integer;
     put:
       (# V: @int8u
       enter V
       do (if (top + 1 -> top) > B.range then B.range -> B.extend if);
          V -> B[top]
       #);
     put2:
       (# V: @integer
       enter V
       do (if (top + 2 -> top) > B.range then
              B.range-> B.extend
          if);
          V div 256 -> B[top - 1];
          V mod 256 -> B[top];
         (* (if V >= 255 then
              '\nput2: top: ' -> screen.puttext; top -> screen.putint;
              ' ' -> screen.put; V -> screen.putint; 
              ' ' -> screen.put; B[top-1]->puthex;
              ' ' -> screen.put; B[top]->puthex; newline
          if)*)
       #);
     put4:
       (# V,bit24,bit16: @integer;
       enter V
       do (if (top + 4 -> top) > B.range then
              B.range-> B.extend
          if);
          V -> split4 -> (B[top - 3],B[top - 2],B[top - 1],B[top]);
       #);
     puttext:
       (# T: ^text; L: @integer
       enter T[]
       do (*sTop -> put2;*)
          (if (sTop + 2 + (T.length -> L)) > strings.range then
              strings.range -> strings.extend
          if);
          (* sTop + 2 -> sTop;
          L div 256 -> strings[sTop - 1];
          L mod 256 -> strings[sTop];*)
          
          T.scanAll(# do sTop + 1 -> sTop; ch -> strings[sTop] #);
          sTop + 1 -> sTop;
          0 -> strings[sTop];
       #);
     setIndex:
       (# inx: @integer
       enter inx
       do top div 256 -> B[descInxStart + (inx - 1) * 2 + 1];    (* 1,3,5,...*)
          top mod 256 -> B[descInxStart + (inx - 1) * 2 + 2];    (* 2,4,6,...*)
         (* inx -> screen.putint;  ':'->screen.put; 
          top -> screen.putint; 
          ' ' -> screen.put;  B[(inx - 1) * 2 + 1] -> screen.putint;
          ' ' -> screen.put;  B[(inx - 1) * 2 + 2] -> screen.putint;
          newline
          *)
       #);
     copyStrings:
       (#
       do top -> split4 -> (B[17],B[18],B[19],B[20]);
          sTop -> put4;
          (for i: sTop repeat strings[i] -> put for)
       #);
     split4:
       (# V,bit24,bit16,B1,B2,B3,B4: @integer;
       enter V
       do 0  -> V.%getByte -> B1;
          1  -> V.%getByte -> B2;
          2  -> V.%getByte -> B3;
          3  -> V.%getByte -> B4;
          (* 'split4: ' -> screen.puttext; 
           V -> screen.putint; ' ' -> screen.put;
           V -> puthex; ' ' -> screen.put; 
           B1 -> puthex; ' ' -> screen.put;
           B2 -> puthex; ' ' -> screen.put;
           B3 -> puthex; ' ' -> screen.put;
           B4 -> puthex; ' ' -> screen.put; newline
           *)
       exit(B1,B2,B3,B4)
       #);
     dump:
       (#
       do ':::'->screen.puttext; top -> screen.putint; screen.newline;
          (for i: top repeat
               i -> screen.putint; ':' -> screen.put;
               B[i] -> putint; newline;
          for)
       #);
     descInxStart: (# exit 8 + 4 + 4 + 4 + 4 #);
  #)
