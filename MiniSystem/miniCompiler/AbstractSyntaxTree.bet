ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../miniEnv/log';
INCLUDE 'lexer'
---lib:attributes---
TrueValue: BooleanValue(# do true -> value #);
AbstractSyntaxTree:
  (# level: @integer;

     lineWidth: @integer;
     
     mark: @boolean;  (* True if beginPos and endPos are updated in AST
                       * mark = True when using doPT for doing PT to
                       *             edit buffer
                       * mark = false when using doPT for debugging purposes
                       *)
     lx: ^text;
     nd : 
       (# father: ^node;
          PP:< (# lx: ^text do inner exit lx[] #);
          doPT:
            (# 
            enter mark
            do &text[] -> lx[]; 
               PT; 
               false -> mark;
            exit lx[]
            #);

          PT:< 
            (# pos: @integer; break: @boolean;
               indent: 
                 (# n: @integer enter n do (for i: n repeat ' ' -> LX.put for)#);
               block:
                 (# pos,width: @integer; break: @boolean
                 enter(pos,width)
                 do lineWidth < (pos + width) -> break;
                    inner
                 #);
               mkBreak:
                 (# pos: @integer; break: @boolean;
                 enter(pos,break)
                 do (if lx.length > 0 then (* no break or space if first line *)
                        (if break then
                            lx.newline;
                            (for i: pos repeat ' ' -> lx.put for)
                         else
                            inner
                    if)if)
                 #);
               mkBreak0: mkBreak(##);
               mkBreak1: mkBreak(# do ' ' -> lx.put #);
               printComment:
                 (# findPos:
                      (# n: @integer; ch: @char
                      do lx.length -> n;
                         true -> onlyLeadingBlanks;
                         L:
                           (# 
                           do (if (n > 0) and ((n -> lx.inxGet -> ch) <>  ascii.newline) then
                                  (if ch > ' ' then false -> onlyLeadingBlanks if);
                                  n - 1 -> n;
                                  restart L
                           if)#);
                         lx.length - n -> cPos
                      #);
                    cPos: @integer; onlyLeadingBlanks: @boolean
                 do findPos;
                    '(' -> lx.put; '*' -> lx.put;
                    comment.scanAll
                    (#
                    do (if ch <> ascii.cr then ch -> lx.put; if);
                       (if ch = ascii.newline then
                           cPos + 1 -> indent
                    if)#);
                    ') ' -> lx.puttext;
                    (if onlyLeadingBlanks  then lx.newline; cPos -> indent if)
                 #)
            enter(pos,break) 
            do (if mark then lx.getpos -> beginPos  if);
               (if comment[] <> none then printComment if);
               inner;
               (if mark then lx.getpos -> endPos if)
            #);
          length:< integerValue(# do inner #);
          getEntries:<
            (* An entry has  the form
             *    entry = (name,sort = (kind,entity))
             * For an objectDesc, a declaration is an entyr:
             *    dcl = (nameDcl, item=(kind,objectSpec))
             *)
            (# add:
                 (# T,N: ^text; E: ^Node
                 enter(T[],E[])
                 do T.copy -> N[];
                    (if E[] <> none then
                        (if true then
                            (*'(' -> N.put; E.xkind -> N.putint; E.PP->N.puttext; ')' -> N.put;*)
                            E.skind -> N.puttext
                         else
                            ':' -> N.put; ' ' -> N.put;                            
                            E.kind -> N.put
                        if)
                     else
                        '%' -> N.put
                    if);
                    1 -> names.extend; 1 -> entries.extend;
                    N[] -> names[names.range][]; 
                    E[] -> entries[entries.range][]
                 #);
               names: [0] ^Text; entries: [0]^Node
            do inner
            exit(names[],entries[])
            #);
          sort:< (# S: ^node do inner exit S[]#);
          entity:< (# E: ^Node do inner; exit E[] #);
          myDesc:< 
            (# OD: ^Node
            do inner;  
               (if OD[] = none then
                   'Trans:myDesc:missing virtual binding in sub: ' -> putline;
                   doPT -> putline ;
                   PP -> putline
               if)
            exit OD[] 
            #);
          kind:< (# ch: @char do '?' -> ch; inner exit ch #);
          xKind:< (# K: @integer do inner exit K #);
          sKind:< 
            (# S: ^text do '?' -> S[]; inner exit S[] #);
          origin: ^Node; 
          handlePrimitives:< (# dcl: ^Node enter dcl[] do inner exit dcl[] #);
          check:< (# do inner #);
          search:< 
            (# N: ^text; dcl,withAd,withP: ^Node; on: @integer  
            enter N[] 
            do inner 
            exit(withAD[],withP[],dcl[],on) 
            #);
          localSearch:< (# N: ^text; dcl: ^Node enter N[] do inner exit dcl[] #);

          hasInner:< (# on,value: @integer enter on do inner exit value #);
          enclosingImperative:<
            (# imp: ^node
            do inner;
               (if imp[] = none then 
                   (if father[] <> none then 
                       father.enclosingImperative -> imp[];
               if)if)
            exit imp[]
            #);
          gen:< (# do inner #);
          emitForFields:< (# forNo: @integer enter forNo do inner #);
          goOrigin:< (# ON: @integer; OD: ^Node enter ON do inner exit OD[] #);
          
          theModule:<
            (* Bindings in parser::module and parser.:nameApl *)
            (# md: ^node
            do 
               inner; 
               (if md[] = none then
                   (if origin[] = none then
                       'thModule:origin is none: ' -> puttext;
                       doPT -> putline
                    else
                       origin.theModule -> md[]; 
               if)if)
            exit md[]
            #);
          changeAttName:< 
            (# oldName,newName: ^text enter(oldName[],newName[]) do inner #);

          theStream: ^stream;
          asText: ^text;
          leadingBlanks: @integer;
          comment: ^text;
          beginPos,endPos: @integer; (* position of this(nd) in .bet file *)
          beginBCP,endBCP: @integer; (* bytecode position at beginning and end of this node
                                      * set by generator::imperative::gen
                                      *)
       do (*lex.oldPos -> beginPos;*)
          lex.skipComment.get -> comment[];
          inner;
          (*lex.oldPos -> endPos*)
       exit this(nd)[]
       #);
       
     type: 
       (# isValue:< booleanValue;
          isRef:< booleanValue;
          isPrimitive:< booleanValue;
          isSingle:< booleanValue;
          print:<  (# out: @text do inner exit out[] #);
          append:<
            (# TP,returnTP: ^type
            enter TP[]
            do (if TP[] <> none then 
                   inner 
                else
                  this(type)[] -> returnTP[]
               if)
            exit returnTP[]
            #);
          appendToList:<
            (# TPx: ^type
            enter TPx[]
            do inner
            exit this(type)[]
            #);
          match:< booleanValue
            (# left: ^type
            enter left[]
            do inner
            #);
          matchList:< booleanValue
            (# TPx: ^Type
            enter TPx[]
            do inner
            #);
       do inner 
       exit this(type)[]
       #);
     
     node: nd
       (# cat: @ integer;
          sons: ^nodeList;
          setUpOrigin:<
            (# org: ^Node 
            enter org[]
            do org[] -> origin[];
               inner
            #);          
          getODorigin: 
            (# OD: ^Node 
            do origin[] -> OD[];
               L:
                 (if not OD.isObjDesc then 
                     OD.getODorigin -> OD[];
                     restart L
                 if)
            exit OD[] 
            #); 
          isObjDesc:< booleanValue;
          hasAttributes:< booleanValue; (* true for all Decl's that define
                                         * attributes: x: @ (# ... #), etc *)
          enterType:< (# TP: ^Type do inner exit TP[] #);
          exitType:< (# TP: ^Type do inner exit TP[] #);
          append:
            (# N: ^Nd
            enter N[]
            do (if sons[] = NONE then &nodeList[] -> sons[] if);
               N[] -> sons.append;
               this(node)[] -> N.father[]
            #);
          insert:
            (# N,atN: ^Node
            enter(N[],atN[])
            do (if sons[] = NONE then &nodeList[] -> sons[] if);
               (N[],atN[]) -> sons.insert
            #);
          doMoveUp:< (#  N: ^node enter N[] do inner #);
          moveUp:
            (* move son[inx] = N[] to son[inx-1]
             * To move down: 
             * son[inx] = N[] to son[inx+1], 
             * call moveUp on N.next
             *)
            (# N: ^node; pos: @integer; pred: ^nodeList
            enter N[]
            do sons[] -> pred[];
               sons.scan
               (#
               do pos + 1 -> pos;
                  (if current[] = N[] then
                      'Found: ' -> puttext; pos -> putint; newline;
                      (if pos > 1 then
                          'Do move' -> putline;
                          (* switch pred and current 
                           * x1 -> x2 -> pred -> current -> xk+2 -> ...
                           * we delete current,and
                           * insert before pred
                           *)
                          NL.next[] -> pred.next[];
                          sons.length - 1 -> sons.length;
                          (N[],pred.son[]) -> insert;
                          doPT -> putline
                      if)
                   else
                      NL[] -> pred[]
                  if)
               #)
            #);
          doInsert:<
            (# N,atN: ^Node;
            enter(N[],atN[])
            do this(node)[] -> N.father[]; inner
            #);
          delete:
            (* assumes N in sons *)
            (# N: ^Node; L: @integer
            enter N[]
            do sons.length - 1 -> L;
               (if true 
                //  N[] = sons.son[] then
                   (* First in list *)              
                    sons.next[] -> sons[];
                   (if sons[] <> none (* L = 0 *) then  L -> sons.length if)
                else 
                   sons.scan (* ????? *)
               if);
               (if sons[] <> none then
                   N[] -> sons.delete;
                   (if sons.length = 0 then none -> sons[] if)
               if)
            #);
          doDelete:<
            (# N: ^text
            enter N[]
            do inner
            #);
          replaceEntity:<
            (# errors: ^stream;
               path2Module,T: ^text
            enter(path2Module[],T[])
            do inner
            exit errors[]
            #);
          objDescEQ:< booleanValue(# dn: @integer enter dn do inner #);
          print:
            (#
            do (for i: level repeat ' ' -> LG.T for);
               PP -> LG.Tn;
               level + 1 -> level;
               (if sons[] <> none then sons.print if);
               level - 1 -> level
            #);
          scanNodes:
            (# break: @boolean;
               current: ^node
            do 
               this(node)[] -> current[]; 
               current.matchNX;
               L: 
                 (if sons[] <> none then 
                     sons.scan
                     (#
                     do 
                        (if &current.scanNodes then leave L if)
                     #)
                 if)
            exit break
            #);
          matchNX:< booleanValue(# break: @boolean do inner #);
          findNodeAtPos:
            (# pos: @integer; N: ^nd;
               trace: (# exit false #)
            enter pos
            do (if trace then
                   'FindNodeAtPos: ' -> puttext; pos -> putint;
                   '('->put; beginPos -> putint; ',' -> put; 
                   endPos -> putint; ')' -> put;
                   doPT -> putline;
               if);
               L:
                 (if (beginPos <= pos) and (pos <= endPos) then
                     (if sons[] <> none then
                         sons.scan(#
                                  do  pos -> current.findNodeAtPos -> N[];
                                     (if N[] <> none then 
                                         (if trace then '>'-> put if);
                                         leave L 
                                     if)
                                  #)
                     if);
                     (if N[] = none then 
                         this(nd)[] -> N[]; 
                         (if trace then
                             newline; 
                             '[' -> put; beginPos -> putint; 
                             ',' -> put; endPos -> putint; ']' -> put;
                         if)
                     if)
                 if)
            exit N[]
            #);
          findNextImp:<
            (# bcp: @integer; impx: ^node
            enter bcp
            do inner
            exit impx[]
            #);
          adjustForSingularImp:< 
            (# bPos,ePos: @integer;
               OD: ^node;
            enter(OD[],bPos,ePos) 
            do inner 
            exit(OD[],bPos,ePos)
            #);
          mapBCposToCharRange: 
            (# bcp: @integer; (* a bytecode position *)
               bPos,ePos,bPos1,ePos1: @integer; (* charposition of node *)
               trace: (# exit false #)
            enter bcp
            do (if trace then
                   'Map: ' ->putline; doPT -> puttext; ' ' -> put;
                   bcp -> putint; ' in: '->puttext;
                   beginBCP -> putint; ','->put; endBCP -> putint; newline;
                if);
               (if (beginBCP < bcp) and (bcp <= endBCP) then
                   (if trace then
                       'Inside: ' -> puttext;
                   if);
                   beginPos -> bPos; endPos -> ePos;
                   (if trace then bPos -> putint; ','->put; ePos -> putint; newline if);
                   L:
                     (if sons[] <> none then
                         sons.scan
                         (#
                         do (if not current.isObjDesc then (* do not go into singular*)
                                bcp -> current.mapBCposToCharRange -> (bPos1,ePos1);
                                (if bPos1 > 0 then 
                                    bPos1 -> bPos; ePos1 -> ePos;
                                    leave L 
                            if)if)
                         #)
                     if)
               if)
            exit(bPos,ePos)
            #);
          isLexem:< BooleanValue;
          LexemSy:< (# L: ^text do inner exit L[] #);
       do inner
(*       exit this(Node)[]*)
       #);
     lexem: Node
       (# item: ^text;
          isLexem:: TrueValue;
          PP:: (# do '\'' -> lx[]; item[] -> lx.puttext; '\'' -> lx.put  #);
          LexemSy:: (# do item[] -> L[] #);
          length:: (# do (if item[] <> none then item.length -> value if) #);
          PT:: (# do (if item[] <> none then item.copy -> lx.append if) #)
       #);
     
     NodeList: nd 
       (# Elm:< Node; (* Not used - we need a top super for Node and NodeList *)
          son: ^ elm (*Node*);
          next, last: ^NodeList;
          length: @integer;
          setFirst:
            (# N: ^Node; S: ^NodeList
            enter N[]
            do N[] -> son[]; 
               this(NodeList)[] -> last[];
               1 -> length
            #);
          append:
            (# N: ^Node; S: ^NodeList
            enter N[]
            do (if last[] = none then
                   (* first element being appended *)
                   N[] -> son[]; 
                   this(NodeList)[] -> last[];
                   1 -> length
                else
                   &NodeList[] -> S[] -> last.next[];
                   N[] -> S.son[];
                   S[] -> last[];
                   length + 1 -> length
               if)
            #);
          insert:
            (# N,atN: ^Node; before,S: ^nodeList
            enter(N[],atN[])
            do ('NodeList:insert',N.doPT) -> LG.TTn;
               
               (if true 
                // last[] = none then
                   N[] -> setFirst
                // atN[] = NONE then
                   (* insert as last *)
                   N[] -> append
                // atN[] = this(nodeList).son[] then
                   (* insert first in list*)
                   &NodeList[] -> S[];
                   son[] -> S.son[];
                   next[] -> S.next[]
                else (* find atN[] *)
                  ('Search: ',atN.doPT) -> LG.TTn;
                   this(nodeList)[] -> before[];
                   L:
                     scan
                     (#
                     do (if current[] = atN[] then
                           'Insert:found:beforeIs:'->putline;
                            before.son.doPT -> putline;
                            leave L
                         else
                            NL[] -> before[]
                        if)
                     #);
                   &NodeList[] -> S[];
                   N[] -> S.son[];
                   before.next[] -> S.next[];
                   S[] -> before.next[];
                   length + 1 -> length
               if)
            #);
          delete:
            (# N: ^node; before: ^nodeList
            enter N[]
            do 'AST:sons:delete:'->puttext;
               this(nodeList)[] -> before[];
               L:
                 scan
                 (#
                 do (if N[] = current[] then (* never the first in list *)
                        'match' -> putline;
                        NL.next[] -> before.next[];
                        (if before.next[] = none then
                            (* deleted last element *)
                            before[] -> last[];
                        if);
                        leave L
                     else
                        NL[] -> before[]
                    if)
                 #)
            #);
          scan:
            (# current: ^elm (*Node*); NL: ^NodeList;
               isLast: BooleanValue(# do NL.next[] = none -> value #)
            do this(Nodelist)[] -> NL[]; 
               L: (if NL[] <> none then 
                      NL.son[] -> current[];
                      inner;
                      NL.next[] -> NL[];
                      restart L
                  if)
            #);
          scanReverse:
            (# current: ^elm (*Node*);
               L: [5] ^elm(*node*); top: @integer
            do scan(# do (if (top+1->top) > L.range then L.range -> L.extend if);
                      current[] -> L[top][]
                   #);
               (for i: top repeat 
                    L[top+1-i][] -> current[];
                    INNER
               for)
            #);
          print:
            (#
            do (if son[] = none then 'Son is none:' -> LG.Tn else son.print;  if);
               (if next[] <> none then next.print if)
            #)
       do inner
       #);
     new:
       (# cat: @integer; N: ^Node
       enter cat
       do &node[] -> N[];
          cat -> N.cat
       exit N[]
       #);
     newLexem: 
       (# sym:^text; N: ^lexem
       enter sym[]
       do &lexem[] -> N[];
          sym[] -> N.item[]
       exit N[]
       #);
     
     lex: ^Lexer;     

     LG: ^LOG
  enter LG[]
  do
     inner
  #)
