ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'lexer';
INCLUDE 'AbstractSyntaxTree';
INCLUDE 'directoryComponents'

---lib:attributes---
parser: AbstractSyntaxTree
  (# thisModuleName: ^text;
     sy: (# do lex.symb -> putint; ' ' -> put #);
     
     syntaxError:
       (# n: @integer; expected,skipTo: [0] @integer
       enter(n,expected,skipTo)
       do 3 -> lex.printLines;
          '\nSyntax error in : "' -> puttext; 
          thisModuleName[] -> puttext;
          '", errorNo: ' -> puttext;
          n -> putint; 
          (if false then
              ' - Symb: "' -> puttext; lex.symb -> lex.symbols.asText -> puttext; 
              '" ('-> puttext; lex.symb-> putint; ') at pos:' -> puttext; 
              lex.oldPos -> putint; ':' -> put;
              lex.nextCh.pos -> putint; ' ' -> put;
           else
              newline;
              'Expected symbols: ' -> puttext;
              (for i: expected.range repeat
                   expected[i] -> lex.symbols.asText -> puttext; 
                   ' '-> put
              for)
          if);          
          newline; newline;
          true -> hasSyntaxError;
          (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
          
          lex.oldPos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;
          lex.nextCh.pos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;
          'Syntax error (' -> lex.errorStream.puttext;
          n -> lex.errorStream.putint;')' -> lex.errorStream.put;
          
          ' expected symbols: ' -> lex.errorStream.puttext;

          (for i: expected.range repeat
               ' ' -> lex.errorStream.put;
               expected[i] -> lex.symbols.asText -> lex.errorStream.putText;
          for);
          lex.errorStream.newline;
          skip:
            (#
            do lex; 
               (* skip to symbol in skipTo *)
               (if lex.symb = lex.symbols.eos then leave skip if);
               (for i: skipTo.range repeat
                    (if lex.Symb = skipTo[i] then 
                        leave skip
                    if)
               for);
               restart skip
            #)
       #);
     hasSyntaxError,withPos: @boolean; (* withPos: called from minienv and positions are included *)
     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          objMd: ^objectModule;
       enter fileName[]
       do (* all the lex setup stuff *) 
          (*'Pos: ' -> puttext; beginPos -> putint; newline;*)
          (*'Module: ' -> puttext; fileName[] -> putline;*)
          (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          inFile[] -> lex.init;
          lex;
          INNER;
          inFile.close;
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# name: ^lexem;
          md: ^Module;
          oldModuleName: ^text;
       do (*lex.markStream -> theStream[]; *)
          (if lex.symb = lex.symbols.idf then
              thisModuleName[] -> oldModuleName[];
              lex.sym[] ->  newLexem -> name[];
              name.lexemSy -> thisModuleName[];
              (* 'Parsing: this:' -> puttext;            
               oldModuleName[] -> puttext; ' new: ' -> puttext;
               thisModuleName[] -> puttext; newline;
               ' lex.pos: '->puttext; lex.nextch.pos -> putint; newline;
               *)
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  (if lex.symb = lex.symbols.object then
                      name[] -> objectModule -> md[] -> objMd[];
                   else
                      (* pattern assumed foo: (# ... do ... #) *)
                      name[] -> ptnModule -> md[]; 
                  if)
               else
                  syntaxError
              if)
           else
              syntaxError
          if);
          pathToFN[] -> md.pathToFN[];
          inFile[] -> md.inFile[];
          oldModuleName[] -> thisModuleName[];
          (* 'restore: ' -> puttext; 
           thisModuleName[] -> putline*)
       exit md[]
       #);
     Module: Node
       (# PP::<
            (#
            do inner;
               (for i: dcTop repeat ':' -> lx.put; dirModuleN[i][] -> lx.append for);
               ':' -> lx.put
            #);
          desc:<
            (# D: ^objectDesc do inner exit D[] #);
          descNo:< (# dn: @integer do inner exit dn #);
          theModule:: (# do this(Module)[] -> md[] #);
          replaceObjectDesc:< 
            (# OD: ^ObjectDesc 
            enter OD[] 
            do inner;
            #);
          replaceEntity::< 
            (# 
            do inner;
               addModuleItems
            #);
          pushObjDesc:< (# do inner #);
          loadOrigin:< (# do inner #);
          doAlloc:< (# ND: ^nameDecl enter ND[] do inner #);
          
          handleDirModules:
            (# 
            do (if false then
                   'HandleDirModules: '->puttext; 
                   name.lexemSy -> puttext; newline; 
               if);
               0 -> dcTop;
               (if (dirCh->(path.append).put) -> locateWorld.CWD.equal then
                   this(Module)[] -> main[]
               if);
               
               findModuleItems;
               
               scanDir 
               (#
               do currentModule.name.lexemSY -> path.push;
                  (if false then
                      'EQ:'->putline; path.append-> putline; 
                      locateWorld.CWD[] -> putline; 
                  if);
                  &currentModule.handleDirModules;
                  path.pop
               #);
            #);
          findModuleItems:
            (# 
            do (*'FindDir: find directories in:\n   ' -> puttext; 
                path.append -> putline; '  ' -> puttext;*)
               (path.append,false) -> getBETAdirectories
               (#
               do scan
                  (#
                  do (if not currentIsFile then
                         (*current[] -> puttext; ' ' -> put;*)
                         current[] -> addDirModuleN;
                     if)
                  #)
               #);
               (* newline;*)
            #);
          
          dirModuleN: [4] ^text; dcTop: @integer;
          addDirModuleN:
            (# dir: ^text
            enter dir[]
            do (if (dcTop + 1 -> dcTop) > dirModuleN.range then 
                   dirModuleN.range -> dirModuleN.extend;
                   dirModule.range -> dirModule.extend
               if);
               dir[] -> dirModuleN[dcTop][]
            #);
          (* Perhaps save ModuleItemDecl instead?
           * Perhaps factor appendModule out of scanDir
           *)
          dirModule: [4] ^ModuleItem;
          scanDir:
            (# currentModule: ^Module;
               N: ^text; (* module on path to ...*)
            do (*'ScanDir:'->putline; dctop->putint; newline;*)
               (for i: dcTop repeat
                    (*dirModuleN[i][] -> N[] -> putline;*)
                    (* See also Checker:ModuleItem:doCheck *)
                    dirModuleN[i][] -> N[] -> ModuleItem -> dirModule[i][];
                    (N[],dirModule[i][]) -> mkModuleItemDecl -> appendModule; 
                    dirModule[i].md[] ->  currentModule[];
                    (if currentModule[] = none then 'currentModule none' -> putline if);
                    true -> dirModule[i].isParsed; (* eliminate *)
                    INNER;
               for);
            #);
          addModuleItems: 
            (#
            do (for i: dcTop repeat
                    (dirModuleN[i][],dirModule[i][]) -> mkModuleItemDecl -> appendModule
               for)
            #);
          appendModule:< (# dcl: ^Decl enter dcl[] do dcl.doPT; inner #);
          
          imports: @
            (# L: [4] ^module; top: @integer;
               init:< (# do 0 -> top;(* ' imports:init ' -> puttext; *) #);
               addM:
                 (# mi: ^module
                 enter mi[]
                 do (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi[] -> L[top][];
                    (*'Add:' -> putline; mi.doPT -> putline*)
                 #);
               add:
                 (# mi: ^moduleItem
                 enter mi[]
                 do (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi.md[] -> L[top][]
                 #);
               
               scan:
                 (# current: ^module
                 do (for i: top repeat
                         L[i][] -> current[]; inner
                 for)#);
               mark: scan
                 (# 
                 do (if trace then
                        current.name.lexemSy -> puttext; ':'->put; 
                        current.DescNo -> putint; ' ' -> put;
                    if);
                    current.mark 
                 #);
            #);
          trace: (# exit false #);
          mark: 
            (# 
            do (if trace then 'MarkImports: '->puttext; name.lexemSy ->putline if);
               (if not isIncluded then (* avoid circularity *)
                   true -> isIncluded; 
                   imports.mark 
               if);
            #); 
          theDecl: ^nameDecl; (* We assume that there is only one nameDecl per module
                               * theDecl is set by mkModuleItemDecl
                               *)
          isIncluded: @boolean;
          name: ^lexem;
          hasPrim: @boolean; 
          pathToFN: ^text; 
          inFile: ^file;
       enter name[]
       do this(Module)[] -> thisModule[]; inner
       #);
     objectModule:< Module
       (# PP:: (# do 'ObjectModule' -> lx[]; #);
          PT::
            (#
            do (0,length) -> block
               (#
               do name.PT; ':' -> lx.put; 
                  (2,break) -> obj.PT
               #)
            #);
          length:: (# do name.length + 1 + 1 + obj.length -> value #);
          getEntries:: (# do obj.OD.getentries -> (names[],entries[]) #);
          Entity:: (# do obj.OD[] -> E[]#);
          kind:: (# do '/' -> ch #);
          replaceObjectDesc::< (# do OD[] -> obj.replaceObjectDesc #);
          appendModule:: 
            (# 
            do (if obj.OD.att[] <> none then (* may be none if syntax errors
                                              * may not be sufficient - OD may alos be done
                                              *)
                   dcl[] -> obj.OD.att.dcls.append
               if)
            #);
          changeAttName:: (# do (oldName[],newName[]) -> obj.OD.changeAttName #);
          doMoveUp:: (# do obj.OD.att.dcls.moveUp #);
          doInsert:: (# do 'objM:doI'->putline; (N[],atN[]) -> obj.OD.att.dcls.insert #);
          doDelete:: (# do N[] -> obj.OD.att.dcls.doDelete #);
          replaceEntity:: (# do (path2Module[],T[]) -> obj.replaceEntity -> errors[] #);
          obj: ^Object
       do object -> obj[] -> Append
       #);
     PtnModule:< Module
       (# PP:: (# do 'PtnModule' -> lx[]; #);
          PT:: 
            (#
            do (0,length) -> block
               (#
               do name.PT; ':' -> lx.put; 
                  (2,break) -> OD.PT
               #)
            #);
          length:: (# do name.length + 1 + OD.length -> value #);
          getEntries:: (# do OD.getentries -> (names[],entries[]) #);
          Entity:: (# do Od[] -> E[]#);
          kind:: (# do '#' -> ch #);
          replaceObjectDesc::< (# do OD[] -> this(PtnModule).OD[] #);
          appendModule:: (# do  'appendPtnModule:' -> putline; dcl[] -> OD.att.dcls.append #);
          changeAttName:: (# do (oldName[],newName[]) -> OD.changeAttName #);
          doMoveUp:: (# do OD.att.dcls.moveUp #);
          doInsert:: (# do (N[],atN[]) -> OD.att.dcls.insert #);
          doDelete:: (# do N[] -> OD.att.dcls.doDelete #);
          replaceEntity:: (# do (path2Module[],T[]) -> OD.replaceEntity -> errors[] #);
          OD: ^objectDesc;
       do PatternDen ->  objectDesc -> OD[] -> Append;
       #);
     
     WithPart:< Node
       (* with <AD>; 
        * perphas not a good idea to insist on a ';'
        * could be 'do' or '#)'
        * But we should allow more than one with and perhaps more ADs in each with?
        *)
       (# PT:: 
            (# 
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do 'with ' -> lx.puttext;
                     (pos,break) -> current.PT;
                     ';' -> lx.put; 
                     (pos,break) -> mkBreak1
               #)#)
            #);
          length::
            (#
            do scanSons(# do 6 + current.length + value -> value #)
            #)
       do L:
            (#
            do AttributeDenotation -> Append;
               (if lex.symb 
                // lex.symbols.semicolon then 
                   lex;
                   (if lex.symb = lex.symbols.with then
                       lex;
                       restart L
                   if)
                // lex.symbols.prim // lex.symbols.end then                  
                else
                   (3,(lex.symbols.semicolon),(lex.symbols.semicolon)) -> SyntaxError
               if)
            #)
       #);
     object:< Node
       (# PP:: (# do 'Object' -> lx[] #);
          PT:: (# 
               do ' '-> lx.put; '@' -> lx.put; 
                  (pos,break) -> OD.PT  
               #);
          length:: (# do 2 + OD.length -> value #);
          replaceObjectDesc: (# enter OD[] #);
          replaceEntity::
            (# 
            do 'object:replaceEntity:' -> putline;
               T[] -> putline;
               L: 
                 (#
                 do T[] -> mkObjectDesc
                    (# xsyntaxError::
                         (#
                         do errorStream[] -> errors[];
                            leave L
                         #)
                       
                    #) -> (errors[],OD[]);
                    none -> sons[];
                    OD[] -> append; (* returns OD? *)
                 #)
            #);
          OD: ^ObjectDesc
       do (if lex.symb = lex.symbols.object then 
              lex;
              PatternDen ->  objectDesc -> OD[] -> Append
           else 
              (4,(lex.symbols.object),(lex.symbols.begin,lex.symbols.semicolon)) 
                ->  SyntaxError;
          if)
       #);
     Attributes:< Node (* can be eliminated *)
       (# PP:: (# do 'Attributes' -> lx[] #);
          length:: (# do dcls.length -> value #);
          PT:: (# do (pos,break) -> dcls.PT  #);
          getEntries::
            (#
            do scanDecls(#do (currentND.lexemSy,currentDcl[]) -> add #)
            #);
          entity:: (# do this(attributes)[] -> E[] #);
          doInsert:: (# do (N[],atN[]) -> dcls.insert #);
          doDelete:: 
            (# 
            do L: 
                 scanDecls
                 (# 
                 do (if (currentND.lexemSy -> N.equalNCS) then
                        'match:'-> putline;
                        dcls.doPT -> putline;
                        currentDcl[] -> dcls.delete;
                        leave L
                    if)
                 #);
            #);
          scanDecls:
            (# currentDcl: ^decl;
               currentND: ^nameDecl
            do (if dcls.sons[] <> none then 
                   dcls.scanSons
                   (#
                   do (if current## <> slot## then
                          current[] -> currentDcl[];
                          currentDcl.NS.scan
                          (#
                          do current[] -> currentND[];
                             inner scanDecls
               #)if)#)if)                    
            #);
          dcls: ^Decls
       do Decls -> dcls[] -> Append
       #);
     Decls:< Node
       (# PP:: (# do 'Dcls' -> lx[] #);
          length::
            (#
            do (if sons[] <> none then
                   scanSons
                   (#
                   do current.length + value -> value;
                      (if not isLast then
                          value + 2 -> value
                      if)
                   #)
               if)
            #);
          PT:: 
            (#
            do (if sons[] <> none then
                   (pos,length) -> block
                   (#
                   do scanSons
                      (# 
                      do (pos,break) -> current.PT;
                         (if not isLast then
                             ';' -> lx.put;
                             (pos,break) -> mkBreak1
                      if)#)
                   #)
               if)
            #)
       do Loop:
            (#D: ^Decl
            do 
               (if lex.symb 
                // lex.symbols.semiColon then (* empty decl *) 
                   lex; 
                   restart Loop
                // lex.symbols.nonTbegin then
                   lex;
                   Slot -> append;
                   restart Loop
                // lex.symbols.doSy
                // lex.symbols.end
                // lex.symbols.enterSy
                // lex.symbols.exitSy 
                // lex.symbols.frag
                // lex.symbols.eos (* obs ok if attributes slot not in objDesc *) then 
                   leave Loop 
               if);
               decl -> D[];
               (if D.IT[] <> none then
                   D[] -> Append
                else 'ModuleItem:not appended ' -> putline
               if);
               restart loop
       #)#);
     Decl:< Node
       (# PP:: (# do 'Decl'->lx[] #);
          length::
            (#
            do NS.length + 2 + IT.length -> value
            #);
          PT::
            (#
            do (if IT## <> ModuleItem## then
                   (pos,break) -> NS.PT ; ':' -> lx.put;
                   (pos,break) -> IT.PT 
                else
                   (pos,break) -> IT.PT 
               if)
            #);
          sort::< (# do IT[] -> S[] #);          
          singularObjectDesc: (# OD: ^objectDesc exit IT.singularObjectDesc #);
          replaceEntity::
            (#
            do (path2Module[],T[]) -> IT.replaceEntity -> errors[];
            #);
          NS: ^NameDecls; IT: ^Item          
       do NameDecls -> NS[] -> Append;
          (if lex.symb = lex.symbols.colon then
              lex;              
              (if lex.symb 
               // lex.symbols.object then
                  lex;
                  StaticItem -> IT[] -> Append;
               // lex.symbols.ref then
                  lex;
                  DynamicItem -> IT[] ->  Append;
               // lex.symbols.objModule // lex.symbols.ptnModule then
                  'Module declaration as attribute is ignored '
                  '(parser::decl)'->putline;
                  (*lex.sym[] -> ModuleItem -> IT[] -> append;*)
                  lex;                          
               // lex.symbols.lt then
                  lex;
                  VirtualPattern -> IT[] -> Append
               // lex.symbols.colon then (* X:: *)
                  lex; 
                  (if lex.symb = lex.symbols.lt then  (* X::< *)
                      lex;
                      FurtherBinding -> IT[] -> Append
                   else (* X :: *)
                      FinalBinding -> IT[] -> Append (* potential syntax problem here 
                                                      *   V: # (# #)
                                                      * does not give a syntax error
                                                      * but should not be caught here
                                                      *)
                  if)
               // lex.symbols.leftSquare then
                  lex;
                  Repetition -> IT[] -> Append
               // lex.symbols.strucVar then
                  lex;
                  varPtn -> IT[] -> Append
               else
                  Pattern -> IT[] -> Append
              If)
           else
              (5,
              (lex.symbols.object,lex.symbols.ref,lex.symbols.objModule,lex.symbols.ptnModule,lex.symbols.lt
              ,lex.symbols.colon),
              (lex.symbols.semicolon)) -> SyntaxError
          if);
       #);
     Slot:< Node
       (# length:: (# do name.length + cat.length + 6 -> value #);
          PT:: 
            (# 
            do '<<' -> lx.puttext; name.PT; ': ' -> lx.puttext; 
               cat.PT; '>>' -> lx.puttext 
            #);
          name,cat: ^Lexem
       do (if lex.symb = lex.symbols.idf then (* <<SLOT *)
              lex;
              (if lex.symb = lex.symbols.idf then (* <<SLOT X *)
                  lex.sym[] -> NewLexem -> name[];
                  lex;                  
                  (if lex.symb = lex.symbols.colon then (* << SLOT X: *)
                      lex;
                      (if lex.symb = lex.symbols.idf then (* << SLOT X:C *)
                          lex;
                          lex.sym[] -> NewLexem -> cat[];
                          (if lex.symb = lex.symbols.nonTend then (* << SLOT X:C>> *)
                              lex;
                           else
                              SyntaxError
                          if)
                       else
                          SyntaxError
                      if)
                   else
                      SyntaxError
                  if)
               else
                  syntaxError
              if)
           else
              SyntaxError
          if)
       #);
     NameDecls:< Node
       (# PP:: (# do 'NameDecls' -> lx[] #);
          length:: 
            (# 
            do scanSons
               (#
               do current.length + value  -> value;
                  (if not isLast then value + 1 -> value if)
               #)
            #);
          PT:: (# 
               do scanSons
                  (# 
                  do (pos,break) -> current.PT ;
                     (if not isLast then ',' -> lx.put if)
                  #)
               #);
          scan: 
            (# current: ^Node;
            do scanSons(# do current[] -> this(scan).current[]; inner scan #)
            #);
          first: (# ND: ^NameDecl do L: scan(#do current[] -> ND[]; leave L #) exit ND[] #)
       do L:
            (#
            do NameDecl -> Append;
               (if Lex.Symb = Lex.Symbols.Comma Then 
                   Lex;
                   restart L
            if)#)
       #);
     NameDecl:< Node
       (# PP:: (#do 'NameDecl' -> lx[] #);
          length:: (# do N.length -> value #);
          PT:: (# do (pos,break) -> N.PT  #);
          lexemSy:: (# do N.lexemSy -> L[] #);
          isDataItem:< booleanValue(# do inner #);
          isPtn:< booleanValue(# do inner #);
          N: ^Lexem;
          isSimple,isForInx: @boolean;
          forNo: @integer
       do (if Lex.Symb = Lex.Symbols.Idf Then
              Lex.sym[] -> newlexem -> N[] -> Append;
              Lex;
           else
              (6,(0),(0)) -> SyntaxError
          if)
       #);
     
     Item: Node
       (# PT::< (# do inner #);
          isSimple: @boolean;
          isModule:< booleanValue(#do inner #);
          desc:< (# D: ^ObjectDesc do inner exit D[] #);
          isObject:< (# NA: ^denotation enter NA[] do inner #);
          gen::< (# ND: ^NameDecl enter ND[] do inner #);
          descInx:< (# inx: @integer do inner exit inx #);
          setImplicitSuper:< (# vdcl: ^NameDecl enter vDcl[] do inner #);
          isVirtual:< BooleanValue;
          isDataItem:< BooleanValue;
          isPtn:< BooleanValue;
          activate:< 
            (# ND: ^NameDecl; LMR: @char; isLocal,isRef: @boolean 
            enter(ND[],LMR,isLocal,isRef)
            do inner 
            #);
          evalIndexed:<
            (# ND: ^NameDecl; LMR: @char; isLocal,isRef: @boolean 
            enter(ND[],LMR,isLocal,isRef) 
            do inner 
            #);
          doAlloc:< (* should be integrated into activate??*)
            (# ND: ^NameDecl
            enter ND[]
            do inner
            #);
          genStrucRef:<
            (# ND: ^nameDecl;  LMR: @char; isLocal: @boolean
            enter(ND[],LMR,isLocal)
            do inner
            #);
          singularObjectDesc:< (# objDsc: ^objectDesc do inner exit objDsc[]#);
          replaceObjectDesc:< (# ODx: ^objectDesc enter ODx[] do inner #);
          isIndexed: @boolean
       do inner 
       #);
     ForImpItem:< Item
       (# PP:: (# do 'ForImpItem' -> lx[] #);
          kind:: (# do 'F' -> ch #); 
       #);
     StaticItem:< Item
       (# PP:: (#do 'StaticItem' -> lx[] #);
          length:: (# do 3 + OS.length -> value #);
          PT:: 
            (# 
            do ' '-> lx.put; '@' -> lx.put; ' ' -> lx.put;  
               (pos + 2,break) -> OS.PT  
            #);
          getEntries:: (# do OS.getentries -> (names[],entries[]) #);
          Entity:: (# do OS[] -> E[]#);
          kind:: (# do '@' -> ch #);
          hasAttributes :: (# do (OS.singularObjectDesc <> none) -> value #);
          singularObjectDesc:: (# do OS.singularObjectDesc -> objDsc[] #);
          replaceObjectDesc:: (# do ODx[] -> OS[] #);
          replaceEntity::
            (# errors: ^Stream
            do 'StaticItem:replaceEntity:' -> puttext;
               T[] -> putline;
               L: 
                 (#
                 do T[] -> mkObjectDesc (* may also be @ interg *)
                    (# xsyntaxError::
                         (#
                         do 'Syntax error' -> putline;
                             errorStream[] -> errors[];
                            leave L
                         #)
                       
                    #) -> (errors[],OS[]) (* returns OD? *)
                 #)
            #);
          doInsert:: (# do (N[],atN[]) -> (singularObjectDesc).att.dcls.insert #);
          lexSy: ^lexem;
          OS: ^ObjectSpecification
       do (if lex.symb = lex.symbols.component then
              lex; (* should mark as Module *)
          if);
          (# PD: ^PatternDen
          do PatternDen -> PD[];
             (if lex.symb = lex.symbols.begin then
                 PD[] -> ObjectDesc -> OS[] -> append
              else
                 PD[] -> OS[] -> append
             if)
          #)
       #);
     ObjectSpecification: Node
       (# PP::< (#do 'ObjectSpec:' -> lx[]; inner #);
          length::<
            (# do  (if PD[] <> none then &PD.length -> value if); inner #);
          PT::< 
            (# 
            do (if PD[] <> none then (pos,break) -> &PD.PT  if); 
               inner 
            #);
          PD: ^PatternDen;
          
          isSimple:< BooleanValue;
          setImplicitSuper:< (# vDcl: ^NameDecl enter vDcl[] do inner#);
          Desc:< (# D: ^ ObjectDesc do inner exit D[] #);
          markReferenced: (# do true -> isReferenced #);
          isReferenced: @boolean; (* instances of this descriptor may be referenced
                                   * as opposed to only being executed as a proc
                                   *)
          markAsSuper: (# do true -> isSuper #);
          isSuper: @boolean; (* this desc is used as a super pattern *)
          isSingular:< booleanValue;
          singularObjectDesc:< (# objDsc: ^objectDesc do inner exit objDsc[]#);
          AddDesc:< (# N: ^text enter N[] do inner #);
          loadOrigin:< (# do inner #);
          activate:< 
            (# ND: ^NameDecl; LMR: @char; isLocal,isRef: @boolean 
            enter(ND[],LMR,isLocal,isRef)
            do inner 
            #);
          doAlloc:< (# ND: ^nameDecl enter ND[] do inner #);
          genStrucRef:< (# LMR: @char; isLocal: @boolean enter(LMR,isLocal) do inner #);
       do INNER
       #);
     DynamicItem:< Item (* should be atribute denotation *)
       (# PP:: (#do 'DynamicItem' -> lx[] #);
          PT:: (#do ' ' -> lx.put; '^' -> lx.put; 
                  (if true then
                      (pos,break) -> AD.PT
                   else
                      (pos,break) -> N.PT 
               if)#);
          length:: (# do 2 + AD.length -> value #);
          entity::(# do AD[] -> E[] #);
          kind:: (# do '^' -> ch #);
          N: ^Lexem;
          AD: ^AttributeDenotation
       do lex.markStream -> theStream[];
          (if lex.symb = lex.symbols.component then
              lex; (* should mark as Module *)
          if);
          (if true then
              (if  lex.symb = lex.symbols.idf then
                  AttributeDenotation -> AD[] -> append	
               else
                  (7,(0),(0)) -> SyntaxError
              if)
           else              
              L:  (if lex.symb = lex.symbols.idf then
                      lex.sym[] -> newLexem -> N[] -> Append;
                      lex;
                      (if lex.symb = lex.symbols.dot then (* hack  to parse std BRTA - must be fixed
                                                           * Should be AttributeDenotation
                                                           *)
                          lex;
                          restart L
                      if)
                   else
                      (if true then AttributeDenotation (* fix this *) 
                       else
                          (7,(0),(0)) -> SyntaxError
                      if)
          if)if)
       #);
     Repetition:< Item
       (# PP:: (#do 'rep' -> lx[] #);
          PT:: 
            (#
            do (pos,break) -> inx.PT ; (pos,break) -> IT.PT  
            #);
          length:: (# do inx.length + IT.length -> value #);
          kind:: (# do '[' -> ch #);
          inx: ^Index;
          IT: ^Item
       do Index -> inx[] -> append;
          (if lex.symb 
           // lex.symbols.object then
              lex;
              StaticItem -> IT[] -> Append;
           // lex.symbols.ref then
              lex;
              DynamicItem -> IT[] ->  Append;
           // lex.symbols.strucVar then
              lex;
              varPtn -> IT[] -> Append              
           else
              (8,(0),(0)) -> SyntaxError
          if);
       #);
     Index:< Node
       (# PP:: (#do 'Index' -> lx[] #);
          PT:: (# do '[' -> lx.put; (pos,break) -> EV.PT ; ']' -> lx.put #);
          length:: (# do 2 + EV.length -> value #);
          EV: ^Evaluation
       do Evaluation -> EV[] -> append;
          (if lex.symb = lex.symbols.rightSquare then
              lex
           else
              (9,(0),(0)) -> SyntaxError
          if)
       #);
     Pattern:< Item
       (# PP:: (#do 'Pattern' -> lx[] #);
          length:: (#do 1 + OD.length -> value #);
          PT:: (#do ' ' -> lx.put; (pos + 2,break) -> OD.PT  #);
          hasAttributes:: TrueValue;
          getEntries:: (# do OD.getentries -> (names[],entries[]) #);
          Entity:: (# do OD[] -> E[]#);
          kind:: (# do ' ' -> ch #);
          singularObjectDesc:: (# do OD[] -> objDsc[] #);
          replaceObjectDesc:: (# do ODx[] -> OD[] #);
          changeAttName::
            (#
            do 'ChangeAttName: pattern: ' -> puttext;
               (oldName[],newName[]) -> OD.changeAttName
            #);
          replaceEntity::
            (# errors: ^Stream
            do 'Pattern:replaceEntity:' -> puttext;
               T[] -> putline;
               L: 
                 (#
                 do T[] -> mkObjectDesc
                    (# xsyntaxError::
                         (#
                         do 'Syntax error' -> putline;
                            errorStream[] -> errors[];
                            leave L
                         #)
                       
                    #) -> (errors[],OD[]) (* returns OD? *)
                 #)
            #);
          doInsert:: (# do (N[],atN[]) -> OD.att.dcls.insert #);
          OD: ^ObjectDesc
       do PatternDen -> ObjectDesc -> OD[] -> Append
       #);
     VirtualPattern:< Item
       (# PP:: (# do 'Virtual' -> lx[] #);
          length:: (# do 2 + OS.length -> value #);
          PT:: (#do '<' -> lx.put; ' '-> lx.put; (pos+2,break) -> OS.PT  #);
          Entity:: (# do OS.entity -> E[]#);
          kind:: (# do '<' -> ch #);
          singularObjectDesc:: (# do OS.singularObjectDesc -> objDsc[] #);
          doInsert:: (# do (N[],atN[]) -> (singularObjectDesc).att.dcls.insert #);
          OS: ^ObjectSpecification;
          IsVirtual:: TrueValue
       do (# PD: ^PatternDen
          do PatternDen -> PD[];
             (if lex.symb = lex.symbols.begin then
                 PD[] -> ObjectDesc -> OS[] -> append
              else
                 PD[] -> OS[]
             if)
          #)
       #);
     FurtherBinding:< Item
       (# PP:: (# do 'further' -> lx[] #);
          length:: (# do 3 + OS.length -> value #);
          kind:: (# do 'F' -> ch #);
          PT:: (#do ':< ' -> lx.append; (pos+3,break) -> OS.PT  #);
          Entity:: (# do OS.entity -> E[]#);
          singularObjectDesc:: (# do OS.singularObjectDesc -> objDsc[] #);
          doInsert:: (# do (N[],atN[]) -> (singularObjectDesc).att.dcls.insert #);
          OS: ^ObjectSpecification;
          IsVirtual:: TrueValue;
          implicitSuperIsSet: @boolean;
       do (# PD: ^PatternDen
          do PatternDen -> PD[];
             (if lex.symb = lex.symbols.begin then
                 PD[] -> ObjectDesc -> OS[] -> append
              else
                 PD[] -> OS[]
             if)
          #)
       #);
     FinalBinding:< Item
       (# PP:: (# do 'further' -> lx[] #);
          length:: (# do 3 + OS.length -> value #);
          PT:: (#do ': ' -> lx.append; (pos+2,break) -> OS.PT  #);
          kind:: (# do '$' -> ch #);
          Entity:: (# do OS.entity -> E[]#);
          singularObjectDesc:: (# do OS.singularObjectDesc -> objDsc[] #);
          doInsert:: (# do (N[],atN[]) -> (singularObjectDesc).att.dcls.insert #);
          OS: ^ObjectSpecification;
          IsVirtual:: TrueValue;
          implicitSuperIsSet: @boolean;
       do (# PD: ^PatternDen
          do PatternDen -> PD[]; 
             (if lex.symb = lex.symbols.begin then
                 PD[] -> ObjectDesc -> OS[] -> append;
              else
                 PD[] -> OS[]
             if)
          #)
       #);
     ModuleItem:< Item
       (# PP:: (#do 'ModuleItem' -> lx[] #);
          length:: (# do 1 -> value #);
          PT:: 
            (# (* no value from a ModuleItem *) 
            do '(' -> lx.put; '*  /'-> lx.append; md.name.lexemSY -> lx.append;
               ' (' -> lx.append; beginPos -> lx.putint; ','-> lx.put; 
               endPos -> lx.putint;
               ') *' -> lx.append; ')' -> lx.put
            #);
          isModule:: (# do true -> value #);
          hasAttributes:: TrueValue;
          getEntries:: (# do md.getEntries -> (names[],entries[]) #);
          Entity:: (# do md.entity -> E[]#);
          kind:: (# do (if true then md.kind -> ch else '/' -> ch if)#);
          changeAttName:: (# do (oldName[],newName[]) -> md.changeAttName #);
          doInsert:: (# do 'ModuleItem:doInsert:'->puttext; (N[],atN[]) -> md.doInsert #);
          replaceEntity:: 
            (# 
            do (path2Module[],T[]) -> md.replaceEntity -> errors[]
            #);
          getDirModules:
            (#
            do (* 'getDirModules: ' -> puttext; path.append -> putline;*)
               (path.append,dir[]) -> DirectoryComponents
               (# 
               do (*'DirElm: ' -> puttext; current[] -> putline;*)
                  current[] -> pModule -> md[] -> append;
                  path.pop (* asymmetri with path.push ?*)
               #);
            #);
          md: ^module;
          dir: ^text;
          isParsed: @boolean; (* not used?*)
       enter dir[] (* the name of the module/directory *)
       do (* is called from scanDir
           * We may have to be able to distinguish two situations
           * 1. We assume a directory with a module - as called from scanDir
           * 2. We have a text
           *      myMod: / @ (# ... #) 
           *    -> create a directory myMod with a new module
           *       but perhaps not here?
           * Perhaps the module syntax should be
           *   myMod: / (# ... #)
           * to be consistent with browser syntax and inline modules
           *   mySys: / (#  mod1: / (# ... #); ... #)
           * That is a module may be defined in a text and then when parsed,
           * the directory will be created
           *)
          (*'\nModuleItem: ' ->puttext; path.append -> putline;dir[] -> putline;*)
          (if lex[] = none then 'lex is none'->putline if);
          (if (lex[] <> none) and 
              ((lex.symb = lex.symbols.objModule)
              or (lex.symb = lex.symbols.object)) then '****'->putline;
              (* if called from scanDir, we apparently do not come here *)
              (* and we dont parse after '/' or '@' ??*)
              '***** Should not happen: ModuleItem: "/@" or "@"' -> putline;
              lex; (* we do not check if the dir-file is consistent with
                    * '/' or '/@'
                    *)
           else 
              dir[] -> path.push;
              getDirModules
          if)
       #);
     VarPtn:< Item
       (# PP: (# do 'VarPtn' -> lx[] #);
          length:: (# do AD.length + 3 -> value #);
          PT:: (# do ' ##' -> lx.append; (pos + 3,break) -> AD.PT #);
          kind:: (# do '*' -> ch #);
          Entity:: (# do AD.entity -> E[] #);
          AD: ^AttributeDenotation
       do AttributeDenotation -> AD[]
       #);
     Actionpart:< Node (* can this be an item or decl? *)
       (# PP:: (#do 'ActionPart' -> lx[] #);
          length::
            (#
            do enterP.length -> value;
               (if imps[] <> none then
                   3 + imps.length + value -> value
               if);
               exitP.length + value -> value
            #);
          PT::
            (#
            do (pos,break) -> enterP.PT ;
               (if imps[] <> none then
                   (pos,break) -> mkBreak1;
                   'do ' -> lx.append;
                   (pos + 3,break) -> imps.PT ;
               if);
               (pos,break) -> exitP.PT ;
            #);
          entity:: (# do this(ActionPart)[] -> E[] #);
          sort:: (# do this(ActionPart)[] -> S[] #);
          kind:: (# do ' ' -> ch #);
          hasDopart: booleanValue(#do imps[] <> none -> value #);
          exitDesc: 
            (# D: ^objectDesc 
            do exitP.exitDesc -> D[]
            exit D[]
            #);
          replaceEntity::
            (#
            do 'ActionPart:replaceEntity:NOT implemented' -> puttext;
               T[] -> putline
            #);
          isEmpty: booleanValue(# do enterP.isEmpty and (imps[] = none) and exitP.isEmpty -> value #);
          enterP: ^ EnterPart;
          imps: ^Imperatives;
          exitP: ^ExitPart
       do lex.markStream -> theStream[];
          EnterPart -> enterP[] -> Append;
          (if lex.symb 
           // lex.symbols.doSy then
              lex;
              Imperatives -> imps[] -> Append
           // lex.symbols.nonTbegin then
              lex;
              Slot -> Append (* we should mark that this is a slot *)
          if);
          ExitPart -> exitP[] -> Append
       #);
     EnterPart:< Node
       (# PP:: (#do 'Enter' -> lx[] #);
          length:: (# do (if eval[] <> none then 6 + eval.length -> value if)#);
          PT::
            (#
            do (if eval[] <> none then
                   (pos,break) -> mkBreak1;
                   'enter' -> lx.append;
                   (pos,false) -> mkBreak1;
                   (pos,break) -> eval.PT 
               if)
            #);
          isEmpty: booleanValue(#do eval[] = none -> value #);
          Eval: ^Evaluation
       do (if lex.symb = lex.symbols.enterSy then
              lex; 
              Evaluation -> eval[] -> Append
          if)
       #);
     ExitPart:< Node
       (# PP:: (#do 'Exit' -> lx[] #);
          length:: (# do (if eval[] <> none then 5 + eval.length -> value if)#);
          PT::
            (#
            do (if eval[] <> none then                   
                   (pos,break) -> mkBreak1;
                   'exit' -> lx.append;
                   (pos,false) -> mkBreak1;
                   (pos,break) -> eval.PT 
               if)
            #);
          isEmpty: booleanValue(#do eval[] = none -> value #);
          exitDesc:
            (# D: ^objectDesc
            do (if not isEmpty then
                   eval.myDesc -> D[]
               if)
            exit D[]
            #);
          Eval: ^Evaluation
       do (if lex.symb = lex.symbols.exitSy then
              lex; 
              Evaluation -> eval[] -> Append;
          if)
       #);
     Imperatives:< Node
       (# PP:: (#do 'Imperatives' -> lx[] #);
          length::
            (# l: @integer
            do (if sons[] <> none then
                   scanSons(# do current.length + 2 + l -> l #);
                   l -> value
               if)
            #);
          PT:: 
            (#
            do (if sons[] <> none then
                   (pos,length) -> block
                   (#
                   do scanSons
                      (#
                      do (pos,break) -> current.PT ;
                         (if not isLast then
                             ';' -> lx.put;
                             (pos,break) -> mkBreak1;                             
                         if)
                      #)
                   #)
               if)
            #)
       do Loop:
            (#
            do (if lex.symb 
                // lex.symbols.semiColon then (* empty imp *) lex; restart Loop 
                // lex.symbols.nonTbegin then
                   lex;
                   Slot -> append
                // lex.symbols.end 
                // lex.symbols.ifSy
                // lex.symbols.alternative
                // lex.symbols.elseSy
                // lex.symbols.forSy 
                // lex.symbols.exitSy 
                // lex.symbols.eos 
                // lex.symbols.frag then leave Loop 
                   (* perhaps we need to test positive for symbols that may
                    * begin en imperative
                    *)
                else
                   imperative -> Append
               if);
               restart Loop
       #)#);
     Imperative:< Node (* we should eliminate this one and make it a super *)
       (# PP:: (#do 'Imp' -> lx[] #);
          length:: (# do imp.length -> value #);
          PT:: 
            (# 
            do (if false then
                   '<' -> lx.put; beginBCP -> lx.putint; '>' -> lx.put;
               if);
               (pos,break) -> imp.PT 
            #);
          enclosingImperative:: (# do this(imperative)[] -> imp[] #);
          imp: ^Node (* this should be better *)
       do (if lex.symb
           // lex.symbols.leftBrack then
              lex;
              (if lex.symb
               // lex.symbols.forSy then
                  lex;
                  ForImp -> imp[] -> append
               // lex.symbols.ifSy then
                  lex;
                  IfImp -> imp[] -> append
               else
                  True -> Evaluation -> imp[] -> append
              if)
           // lex.symbols.leaveSy then
              lex; 
              LeaveImp -> imp[] -> append;
           // lex.symbols.restartSy then
              lex; 
              RestartImp -> imp[] -> append;
              (* LabelledImp?
               * L: 3 -> a;
               * A -> B;
               *)
           // lex.symbols.innerSy then
              lex;
              InnerImp -> imp[] -> append
           // lex.symbols.idf then
              (if lex.peek = ':' then
                  LabelledImp -> imp[] -> append
               else
                  Evaluation -> imp[] -> append
              if)
           else 
              Evaluation -> imp[] -> append
          if); 
       #);
     ForImp:< node
       (# PP:: (#do 'For' -> lx[] #);
          length::
            (#
            do (if true then
                   100000 -> value
                else
                   5 + inx.length + 2 + inxItem.length + 8 + imps.length + 5 -> value
               if)
            #);
          PT::
            (#
            do (pos,length) -> block
               (#
               do '(for ' -> lx.append;
                        (pos,break) -> inx.PT ;
                        ':' -> lx.put; ' ' -> lx.put;
                        (pos,break) -> rangee.PT ; 
                        ' repeat' -> lx.append;
                        (pos + 5,break) -> mkBreak1;
                        (pos + 5,break) -> imps.PT ;
                        (pos,break) -> mkBreak1;
                        'for)' -> lx.append;
               #)
            #);
          inx: ^NameDecl (*Lexem*);
          inxItem: ^ForImpItem;
          rangee: ^Evaluation;
          imps: ^Imperatives;
               (* (for i: E repeat ... for)
                * (for E repeat ... for)
                *)
       do NameDecl -> inx[] -> append; true -> inx.isForInx;
          (if lex.symb 
           // lex.symbols.colon 
           // lex.symbols.repeatSy then
              (if lex.symb = lex.symbols.colon then
                  lex;
                  evaluation -> rangee[] -> append;
              if);
              ForImpItem -> InxItem[] -> append;
              (if lex.symb = lex.symbols.repeatSy then
                  lex; 
                  imperatives -> imps[] -> append;
                  (if lex.symb = lex.symbols.forSy then
                      lex;
                      (if lex.symb = lex.symbols.rightBrack then
                          lex;
                       else
                          (100,(lex.symbols.rightBrack),(0)) -> SyntaxError
                      if)
                   else
                      (101,(lex.symbols.forSy),(0)) -> SyntaxError
                  if)
               else
                  (102,(lex.symbols.repeatSy),(0)) -> SyntaxError
              if)
           else
              (10,(lex.symbols.colon),(0)) -> SyntaxError
          if)
       #);
     IfImp:< Node
       (# PP:: (#do 'If'->lx[] #);
          length::
            (# 
            do (if true then
                   100000 -> value;
                   (* for break imn implist with ifImp *)
                else
                   4 + eval.length -> value;
                   (if thenPart[] <> none then
                       6 + thenPart.length + value -> value
                    else
                       alt.length + value -> value
                   if);
                   (if elsePart[] <> none then
                       5 + elsePart.length + value -> value
                   if);
                   4 + value -> value
               if)
            #);
          PT::
            (#
            do (pos,length) -> block
               (#
               do '(' 'if ' -> lx.append; 
                  (pos,break) -> eval.PT ;
                  (if thenPart[] <> none then
                      ' then' -> lx.append;
                      (pos+4,break) -> mkBreak1;
                      (pos+4,break) -> thenPart.PT
                   else
                      (pos + 1,break) -> mkBreak1;
                      (pos+1,break) -> alt.PT 
                  if);
                  (if elsePart[] <> none then
                      (pos + 1,break) -> mkBreak1;
                      'else' -> lx.append;
                      (pos + 4,break) -> mkBreak1;
                      (pos+4,break) -> elsePart.PT 
                  if);
                  (pos,break) -> mkBreak1;
                  'if' ')' -> lx.append;
               #)
            #);
          Eval: ^Evaluation;
          thenPart,elsePart: ^Imperatives;
          alt: ^Alternatives
       do Evaluation -> eval[] -> Append;
          (if lex.symb 
           // lex.symbols.thenSy then
              lex;
              Imperatives -> thenPart[] -> Append;
           // lex.symbols.alternative then
              lex;
              Alternatives -> alt[] -> append
           else (* // ... then ... *)
              (11,(0),(0)) -> SyntaxError
          if);
          (if lex.symb = lex.symbols.elseSy then
              lex;
              Imperatives -> elsePart[] -> Append;
          if);
          (if lex.symb = lex.symbols.ifSy then
              lex; 
              (if lex.symb = lex.symbols.rightBrack then
                  lex; 
               else
                  (12,(0),(0)) -> syntaxerror
              if)
           else
              (13,(0),(0)) -> syntaxerror
          if)
       #);
     Alternatives:< Node
       (# PP:: (# do 'Alternatives' -> lx[] #);
          length:: 
            (# l: @ integer do scanSons(# do current.length + l -> l #); l -> value #);
          PT::
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then (pos,break) -> mkBreak1 if);
                  #)
               #)
            #)
       do L: (# 
             do Alternative -> Append; 
                (if lex.symb = lex.symbols.alternative then 
                    lex;
                    restart L 
                if)
             #)
       #);
     Alternative:< Node
       (# PP:: (# do 'Alternative' -> lx[] #);
          length::
            (#
            do (if true then
                   10000 -> value (* ensure break at alternatives in if *)
                else
                   (if imps[] = none then
                       sel.length  -> value
                    else
                       sel.length  + 6 + imps.length -> value
                   if)
               if)
            #);
          PT:: (#
               do (pos,length) -> block
                  (#
                  do (pos,break) -> sel.PT;
                     (if imps[] <> none then 
                         ' then' -> lx.append;
                         (pos+3,break) -> mkBreak1;
                         (pos+3,break) -> imps.PT 
                     if);
                  #)
               #);
          sel: ^Selections;
          imps: ^Imperatives
       do Selections -> sel[] -> Append;
          (if lex.symb = lex.symbols.thenSy then
              lex;
              Imperatives -> imps[] -> append
          if)
       #);
     Selections:< Node
       (# PP:: (# do 'Selections' -> lx[] #);
          length::
            (# 
            do scanSons(#do 3 + current.length + value -> value #)
            #);
          PT:: 
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do 
                     '// ' -> lx.append; (pos,break) -> current.PT;
                     (if not isLast then
                         (pos,break) -> mkBreak1
                     if)
                  #)
               #)
            #)
       do L: (#
             do Selection -> append;
                (if lex.symb = lex.symbols.alternative then
                    lex;
                    restart L
                if)
             #)
       #);
     Selection:< Node
       (# PP:: (# do 'Selection' -> lx[] #);
          length:: (# do EV.length -> value #);
          PT:: (# do (pos,break) -> EV.PT  #);
          EV: ^Evaluation
       do Evaluation -> EV[] -> Append
       #);
     LabelledImp:< Node
       (# PP:: (# do 'LabelledImp' -> lx [] #);
          length:: 
            (# 
            do (if true then 
                   100000 -> value 
                else lab.length + 2 + imp.length -> value
               if)
            #);
          PT::
            (#
            do (pos,break) -> lab.PT ; ':' -> lx.put;
               (pos,length) -> block
               (#
               do (pos+2,break) -> mkBreak1;
                  (pos+2,break) -> imp.PT 
               #)
            #);
          lab: ^NameDecl;
          imp: ^Imperative
       do NameDecl -> lab[];
          (if lex.symb = lex.symbols.colon then
              lex
           else
              (14,(0),(0)) -> SyntaxError
          if);
          Imperative -> imp[] -> append
       #);
     Break: Node
       (# PT::< (# do inner; (pos,break) -> lab.PT  #);
          length::< (# do inner; lab.length + value -> value #);
          lab: ^NameApl 
       do NameApl -> lab[] -> Append;
       #);
     LeaveImp:< Break
       (# PP::(#do 'leave '->lx[] #);
          length:: (# do 6 -> value #);
          PT::(#do 'leave ' -> lx.append #)
       #);
     RestartImp:< Break
       (# PP::(#do 'restart'->lx[] #);
          length:: (# do 8 -> value #);
          PT:: (#do 'restart ' -> lx.append #);
       #);
     InnerImp:< Node
       (# length:: 
            (# do 5 -> value; (if N[] <> none then N.length + 1 + value -> value if)#);
          PT:: 
            (# 
            do 'inner' -> lx.append; 
               (if N[] <> none then 
                   ' ' -> lx.put;
                   (pos,break) -> N.PT 
               if)
            #);
          N: ^lexem
       do (if lex.symb = lex.symbols.idf then 
              lex.sym[] -> newLexem -> N[] -> append;
              lex
          if)
       #);

     Evaluation:< Node (* NodeList *)
       (# PP::(#do 'Eval'->lx[] #);
          length::
            (#
            do scanSons
               (#
               do current.length + value -> value; 
                  (if not isLast then 4 + value -> value if)
               #)
            #);
          PT::
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT ;
                     (if not isLast then
                         (pos + 2,break) -> mkBreak0; 
                         ' -> ' -> lx.append;
                     if)
               #)#)
            #);
          (* eval: exp -> trans1 -> trans2 
           * trans: 
           * exp: E1 op E2
           * exp: trans
           *)
          evalList: @boolean;
          gen::< (# LMR: @char enter LMR do inner #); 
          tra: ^Trans
       enter evalList
       do 
          (if false (*evalList*) then 
              evaluationList -> tra[];
              (if lex.symb = lex.symbols.dot then
                  lex;
                  tra[] -> ComputedRemote -> append
              if);
              tra[] -> append
           else 
              evalList -> pExp -> append; 
          if);
          L:
            (if lex.symb 
             // lex.symbols.assign then 
                lex;
                pTransaction -> append;
                restart L
            if);
       #);   
     Trans: Node
       (# PT::< (# do inner #);
          Gen::< (# LMR: @char enter LMR do inner #);     
       do inner
       #);

     Expr: Trans(# PT::< (# do inner #) do inner #); 
     BinaryExp:< Expr 
       (# PP::(#do 'BinExp:'->lx[]; op->lex.symbols.asText -> lx.append #);
          length::
            (#
            do lE.length + 4 + rE.length -> value
            #);
          PT::
            (#
            do (pos,break) -> lE.PT ;
               ' ' -> lx.put;
               op -> lex.symbols.asText -> lx.append;
               ' ' -> lx.put;               
               (pos,break) -> rE.PT ;
            #);
          lE,rE: ^Expr; op: @integer
       enter(lE[],op,rE[]) 
       do lE[] -> append; rE[] -> append
       #);
     UnaryExp:< Expr
       (# PP::(#do 'UnaryExp:'->lx[]; op -> lex.symbols.print #);
          length:: (# do 2 + E.length -> value #);
          PT:: 
            (# 
            do op -> lex.symbols.asText -> lx.append; ' ' -> lx.put;
               (pos,break) -> E.PT  
            #);
          E: ^Expr; op: @integer 
       enter(op,E[]) 
       do E[] -> append
       #);
     Term:< Expr
       (# PP::(#do 'Term'->lx[] #); 
          length:: (# do T.length -> value #);
          PT:: (# do (pos,break) -> T.PT  #);
          T: ^trans
       enter T[] 
       do T[] -> append 
       #);
     
     ExpParser: 
       (# lE,rE: ^Expr; op: @integer; evalList: @boolean
       enter evalList do inner exit lE[] 
       #);
     pExp: ExpParser
       (# 
       do evalList -> pSimpleExp -> lE[];
          (if lex.isRelOp then
              lex.symb -> op;
              lex; 
              pSimpleExp -> rE[];
              (lE[],op,rE[]) -> BinaryExp -> lE[]
          if);
       #);
     pSimpleExp: ExpParser
       (#  
       do (if lex.isAddOrSub (*or (lex.symb = lex.symbols.adr (* @@X *)
              and not evalList then 
              lex.Symb -> op;
              lex;
              pTerm -> lE[];
              (op,lE[]) -> UnaryExp -> lE[]
           else
              evalList -> pTerm -> lE[];
              Loop:
                (if lex.isAddOp then 
                    lex.symb -> op;
                    lex; 
                    pTerm -> rE[];
                    (lE[],op,rE[]) -> BinaryExp -> lE[]; 
                    restart Loop
                if);
          if)
       #);
     pTerm: ExpParser
       (#
       do (*(if (lex.symb = lex.symbols.nott) and not evalList then
           lex.symb -> op;
           lex;
           pFactor -> lE[];
           (op,lE[]) -> UnaryExp -> lE[]
           else*)
          evalList -> pFactor -> lE[];
          Loop:
            (if lex.isMultOp or (lex.symb = lex.symbols.prim) then
                (if lex.symb = lex.symbols.prim then
                    (* we should mark the operator as primitive for PT *)
                    lex;
                    (if lex.symb <> lex.symbols.idf then
                        SyntaxError
                if)if);
                lex.symb -> op;
                lex; 
                pFactor -> rE[];
                (lE[],op,rE[]) -> BinaryExp -> lE[];
                restart Loop
            if)
       #);
     pFactor: ExpParser
       (* textConst, IntegerConst, NoneExp, 
        *          * not EXP, RepetitionSlice,
        *          * Transaction, UnaryPrimitiveExp
        *          * Are they alle sub of exp/term?
        *          *)
       (#
       do evalList -> pTransaction -> term -> lE[]
       #);     

     pTransaction:
       (* T:: ObjEval 
        *   | ComputedEval     - R.S!
        *   | ObjRef           - R.S[]
        *   | EvalList         - (E1, E2,E3)
        *   | StrucRef         - R.S##
        *   | Primitive        - tos foo
        *   | Address          - @@ X
        * ObjEval :: InsItem   - R.P(# ... #) 
        *          |           - (# ... #) 
        *          | Reference 
        * Reference:: ObjDen    - R.P
        *           | DynObjGen - R.P&
        * ObjDen:: AttDen       - R.P
        *)
       (# tra: ^Trans;
          op: @integer; lE: ^expr;
          evalList: @boolean
       enter evalList
       do (if evalList then 
              EvaluationList -> tra[]; 
              (if lex.symb = lex.symbols.dot then 
                  (* we come here in situations like
                   * ... ; (e).f; ...
                   *)
                  lex;
                  tra[] -> ComputedRemote -> tra[]
              if)
           else 
              (if lex.symb 
               // lex.symbols.idf // lex.symbols.begin // lex.symbols.thisObj 
               // lex.symbols.textSy then
                  ObjEval -> tra[];
                  (if lex.symb 
                   // lex.symbols.objRef then
                      tra[] -> Reference -> tra[];
                      lex
                   // lex.symbols.strucVar then
                      tra[] -> StructureRef -> tra[];
                      lex
                  if);
               // lex.symbols.nott then 
                  lex.symb -> op;
                  lex;
                  pFactor -> lE[];
                  (op,lE[]) -> UnaryExp -> tra[]
               // lex.symbols.const then
                  Const -> tra[] 
               // lex.symbols.charSy then
                  aChar -> tra[] 
               // lex.symbols.textSy then
                  aText -> tra[]
               // lex.symbols.noneSy then
                  noneValue -> tra[];
               // lex.symbols.leftBrack then 
                  lex; 
                  EvaluationList -> tra[]; 
                  (if lex.symb = lex.symbols.dot then 
                      (* We come here in sitations like
                       * (if (e).f ...
                       *)
                      lex;
                      tra[] -> ComputedRemote -> tra[]                      
                  if)
               // lex.symbols.new then
                  lex;
                  DynamicObjectGeneration -> tra[]
               // lex.symbols.prim then 
                  lex;
                  (if lex.symb = lex.symbols.idf then
                      lex;
                      pFactor -> tra[]
                  if)
               // lex.symbols.adr then
                  lex;
                  pFactor -> tra[]
               else 
                  (15
                  ,(lex.symbols.idf,lex.symbols.thisObj,lex.symbols.const,lex.symbols.charSy
                  ,lex.symbols.textSy,lex.symbols.leftBrack,lex.symbols.new)
                  ,(lex.symbols.semicolon)) -> syntaxError;
                  &Trans[] -> tra[]
          if)if)
       exit tra[]
       #);
     Reference:< Trans
       (# PP:: (#do 'Reference' -> lx[] #);
          length:: (# do OV.length + 2 -> value #);
          PT:: (# do (pos,break) -> OV.PT ; '[]' -> lx.append #);
          OV:  ^ObjEval
       enter OV[] -> append
       #);
     StructureRef:< Trans
       (# PP:: (#do 'StructureRef' -> lx[] #);
          length:: (# do OV.length + 2 -> value #);
          PT:: (# do (pos,break) -> OV.PT ; '##' -> lx.append #);
          OV:  ^ObjEval
       enter OV[]
       #);
     DynamicObjectGeneration:< Trans
       (# PP:: (#do 'DynObjGen'-> lx[] #);
          length:: (# do 1 + OS.length -> value #);
          PT:: 
            (# 
            do '&' -> lx.put; 
               (pos,break) -> OS.PT;
               (if isRef and (EV[] <> none) then 
                   (pos,break) -> EV.PT
               if);
               (if isRef then '[' -> lx.put; ']' -> lx.put if);
            #);
          OS: ^ObjectSpecification;
          isRef: @boolean;
          EV: ^Evaluation
       do (if lex.symb = lex.symbols.component then
              lex; (* should mark as Module *)
          if);
          (# PD: ^PatternDen
          do PatternDen -> PD[];
             (if lex.symb = lex.symbols.begin then
                 PD[] -> ObjectDesc -> OS[] -> Append
              else
                 PD[] -> OS[] -> Append
             if);
             (if lex.symb = lex.symbols.leftBrack then
                 (if true then
                     evaluation -> EV[] -> append
                  else
                     lex;
                     evaluation -> EV[] -> append;
                     (if lex.symb = lex.symbols.rightBrack then
                         lex
                      else                     
                     syntaxerror
                 if)if)
             if);
             (if lex.symb = lex.symbols.objRef then (* Note: Only &P[], not &P
                                                     * We allow &P to be able to
                                                     * parse std BETA
                                                     *)
                 lex;
                 true -> isRef
                 (* else
                  (16,(0),(0)) -> SyntaxError*)
             if)
          #)
       #);
     ObjEval:< Trans
       (# PP:: (#do 'ObjEval'-> lx[] #);
          length:: (# do OS.length -> value #);
          PT:: (# do (pos,break) -> OS.PT  #);
          OS: ^ObjectSpecification;
       do (if false and (lex.symb = lex.symbols.thisObj) then
              PatternDen -> OS[]
           else
              (# PD: ^PatternDen;
              do PatternDen -> PD[];
                 (if lex.symb = lex.symbols.begin then
                     PD[] -> ObjectDesc -> OS[] -> Append
                  else
                     PD[] -> OS[] -> Append
                 if)
          #)if)
       #);
     EvaluationList:< Trans
       (# PP:: (# do 'EvalList' -> lx[] #);
          length:: 
            (#
            do 2 -> value;
               scanSons
               (#
               do current.length + value -> value;
                  (if not isLast then 1 + value -> value if)
               #)
            #);
          PT:: 
            (#
            do '(' -> lx.put;
               (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then 
                         (pos + 1, break) -> mkBreak0;
                         ',' -> lx.put 
                     if)
                  #);
                  ')' -> lx.put;
               #)
            #);
       do Loop:
            (# do
               Evaluation -> Append;
               (if lex.symb = lex.symbols.comma then
                   lex;
                   restart Loop
            if)#);
          (if lex.symb = lex.symbols.rightBrack then 
              lex
           else 
              (17,(0),(0)) -> syntaxError 
          if)
       #);
     ComputedRemote:< trans (*Should be a denotation*)
       (# PP:: (# do 'ComputedRemote'-> lx[] #);
          length:: (# do tra.length + NA.length -> value (* ??*)#); 
          PT:: 
            (# 
            do 
               tra.PT; 
               '.' -> lx.put;
               NA.PT
            #);
          tra: ^Trans;
          NA: ^NameApl;
          isRef: @boolean
       enter tra[]
       do L: (#
             do (* 'ComputedRemote:'->putline; tra.doPT -> putline; *)
                tra[] -> append;
                NameApl -> NA[] -> append;
                (if lex.symb = lex.symbols.dot then (* hack, hack *)
                    lex;
                    restart L
             if)#);
          (if lex.symb = lex.symbols.objRef then 
              lex; (* more hack *)
              true -> isRef
          if)
       #);
     Const:< Trans
       (# PP:: (#do 'Const' -> lx[] #);
          length:: (# do cst.length -> value #);
          PT:: (# do cst.PT #);
          cst: ^Lexem
       do lex.sym[] -> NewLexem -> cst[] -> Append;
          lex;
          (if lex.symb = lex.symbols.dot then
              (* 3.17 *)
              lex;
              (if lex.symb = lex.symbols.const then
                  (* save float *)
                  lex;
          if)if)
       #);
     aChar:< Trans
       (# PP:: (#do 'Char' -> lx[] #);
          length:: (# do 1 + ch.length + 1 -> value #);
          PT:: (# do '\'' -> lx.put; ch.lexemSy -> lx.append; '\'' -> lx.put #);
          ch: ^Lexem
       do lex.sym[] -> NewLexem -> ch[] -> Append;
          lex
       #);
     aText:< Trans
       (# PP:: (#do 'Text' -> lx[] #);
          length:: (# do 1 + txt.length + 1 -> value #);
          PT:: (# do '\'' -> lx.put; txt.PT ; '\'' -> lx.put #);
          txt: ^Lexem
       do lex.sym[] -> NewLexem -> txt[] -> Append;
          lex;
          L:
            (if lex.symb = lex.symbols.textSy then
                (* Fix save of multiple texts '...' '...' *)
                lex;
                restart L
            if)              
       #);
     noneValue:< Trans
       (# PP:: (# do 'none' -> lx[] #);
          length:: (# do 6 -> value #);
          PT:: (# do ' none' -> lx.puttext #)
       do lex;
       #);
     TextDenotation:< denotation
       (# PT:: (# do T.PT #);
          length:: (# do T.length -> value #);
          T: ^aText;
       do aText -> T[]
       #);
     ObjectDesc:< ObjectSpecification
       (# PP:: (#do 'Objectdesc' -> lx[] #);
          length::
            (#
            do (if slt[] = none then
                   sup.length + 3 -> value;
                   (if with[] <> none then with.length + value -> value if);
                   props.length + value -> value;
                   (if att[] <> none then att.length + value -> value if);
                   value + acp.length + 3 -> value
                else
                   slt.length + 4 -> value
               if)
            #);
          PT::
            (# B: @boolean
            do (if slt[] = none then
                   (pos,break) -> sup.PT;
                   (pos,length) -> block
                   (#
                   do (pos,break) -> mkBreak0;
                      (*'\(\# ' -> lx.append; *) '{ ' -> lx.append;
                      (if with[] <> none then 
                          (pos+2,break) -> with.PT;
                          (pos+2,break) -> mkBreak1;
                      if);
                      (pos+2,break) -> props.PT;
                      (pos+2,break) -> restricts.PT;
                      (if att[] <> none then
                          (pos+2,break) -> att.PT  
                      if);
                      (pos,break) -> acp.PT ;
                      (pos,break) -> mkBreak1; 
                      (*'\#\)' -> lx.append ;*) '}' -> lx.append
                   #);
                else
                   (pos,break) -> slt.PT
               if)
            #);
          getEntries::
            (#
            do (if slt[] = none then
                   scanDecls(#do ((currentND.lexemSy).copy,currentDcl[]) -> add #);
                   (if not acp.isEmpty  then
                       ('Action',acp[]) -> add
               if)if)
            #);
          entity:: (# do this(objectDesc)[] -> E[]#);
          sort:: (# do this(objectDesc)[] -> S[]#);
          isSingular:: trueValue;
          singularObjectDesc:: (# do this(objectDesc)[] -> objDsc[] #);
          scanDecls:
            (# currentDcl: ^decl;
               currentND: ^nameDecl
            do (if att[]<> none then (* none if objectDesc from objectContent.shift *)
                   (if att.dcls.sons[] <> none then 
                       att.dcls.scanSons
                       (#
                       do (if current## <> slot## then
                              current[] -> currentDcl[];
                              currentDcl.NS.scan
                              (#
                              do current[] -> currentND[];
                                 inner scanDecls
               #)if)#)if)if)
            #);
          getOriginOff:< (# off: @integer do inner exit off #);
          scanAllDecls:
            (# origin:<
                 (# name: ^text;
                    off: @integer
                 enter(name[],off)
                 do inner
                 #);
               currentDcl: ^decl;
               currentND: ^nameDecl;
               superDesc,oldDesc: ^objectDesc;
               orgOff,superOrgOff,level: @integer
            do sup.desc -> superDesc[];
               (if (superDesc[] <> superObject[]) 
                   (* We do not show attributes of superObject *) then
                   &superDesc.scanAllDecls
                   (# origin::
                        (# 
                        do (name[],off) 
                             -> this(scanAllDecls).origin 
                        #);
                   do currentDcl[] -> this(scanAllDecls).currentDcl[];
                      currentND[] -> this(scanAllDecls).currentND[];
                      inner scanAllDecls
                   #)
                     -> (superOrgOff,level)
               if);

               (if (getOriginOff -> orgOff) <> superOrgOff then
                   ('origin',orgOff) -> origin;
                   level + 1 -> level
               if);
               (if false then
                   '*****scan: superOrgOff: '->puttext; superorgOff -> putint; 
                   ', orgOff: ' -> puttext; orgOff -> putint; 
                   ', level: ' -> puttext; level -> putint; newline;
               if);
               scanDecls
               (# 
               do currentDcl[] -> this(ScanAllDecls).currentDcl[];
                  currentND[] -> this(ScanAllDecls).currentND[];
                  inner scanAllDecls
               #)
            exit(orgOff,level)
            #);
          hasDoPart: booleanValue
            (# superDesc: ^objectDesc
            do (if (sup.desc ->superDesc[]) <> superObject[] then
                   superDesc.hasDoPart -> value
               if);
               acp.hasDopart or value -> value 
            #);
          changeAttName::
            (#
            do 'ChangeAttName: ' -> puttext; oldName[] -> puttext;
               'To: ' -> puttext; newname[] -> putline;
               L: scanDecls
                 (#
                 do ('IsEQ',currentND.lexemSy) -> LG.TT;
                    (if (currentND.lexemSy -> oldName.equalNCS) then
                        ('Match:','') -> LG.TTn;
                        newName[] -> currentND.N.item[];
                        leave L
                    if)
                 #)
            #);
          replaceActionPart: (# enter acp[] do (* do also replace in sons *)#);
          doMoveUp:: (# do att.dcls.moveUp #);
          doInsert:: (# do (N[],atN[]) -> att.dcls.insert #);
          doDelete:: (# do N[] -> att.dcls.doDelete #);
          sup: ^PatternDen;
          with: ^WithPart;
          props: ^Properties;
          restricts: ^Restrictions;
          att: ^Attributes;
          acp: ^ActionPart;
          slt: ^Slot;
          isPrimitive: (# enter props.isPrimitive exit props.isPrimitive #);
          isCore: (# do exit props.isCore #);
          isThisCore:(# do exit props.isThisCore #);
          hasProps: booleanValue(# do props.prim[] <> none -> value #);
       enter sup[]
       do lex.markStream -> theStream[]; 
          (if lex.symb = lex.symbols.nonTbegin then
              lex;
              Slot -> slt[]; 
              leave ObjectDesc 
          if);
          sup[] -> append;
          true -> sup.isSuper; 
          (if lex.symb = lex.symbols.begin then
              lex;
              (if lex.symb = lex.symbols.with then
                  lex;
                  WithPart -> with[] -> Append;
              if);
              Properties -> props[] -> Append;   
              Restrictions -> restricts[] -> Append;
              (* ad hoc to ensure that att and acp are well defined *)
              Attributes -> att[] -> Append; 
              ActionPart -> acp [] -> Append;
              (if lex.symb = lex.symbols.end then
                  lex;
               else
                  (19,(lex.symbols.end),(lex.symbols.semiColon)) -> SyntaxError  
              if)
           else
              (120,(lex.symbols.begin),(lex.symbols.end)) -> SyntaxError
          if)
       #);
     PatternDen:< ObjectSpecification
       (# (* lex.symb = idf *)
          PP:: (#do 'PatternDen' -> lx[] #);
          length:: (# do AD.length -> value #);
          PT:: (# do (pos,break) -> AD.PT  #);
          name: (# exit AD.name #);
          AD: ^AttributeDenotation;
          isSuper: (# enter AD.isSuper #)
       do true -> AttributeDenotation -> AD[] -> append; 
       #);
     Properties:< node
       (# length:: (# do (if prim[] <> none then prim.length + value -> value if) #);
          PT:: 
            (#
            do (if prim[] <> none then 
                   prim[] -> lx.append;
                   (pos,break) -> mkBreak1;
               if);
            #);
          handleProp:
            (# N,V: ^text
            enter(N[],V[])
            do (if true
                // 'simple' -> N.equalNCS 
                // 'prim' -> N.equalNCS then
                   true -> isPrimitive;
                // 'basic' -> N.equalNCS then
                // 'OSDvisibility' -> N.equalNCS then
                   (if true 
                    // 'SkipInternal' -> V.equalNCS then
                       1 -> OSDvisibility;
                    // 'disguised' -> V.equalNCS then
                       2 -> OSDvisibility
                    else
                       '**** Illegal value for OSDvisibility: ' -> puttext;
                       V[] -> putline
                   if)
                // 'core' -> N.equalNCS then 
                   true -> isCore
                // 'thisCore' -> N.equalNCS then
                   true -> isThisCore
               if)
            #);
          prim: ^text;
          OSDvisibility: @integer;
          isPrimitive,isCore,isThisCore: @boolean
       do (if lex.symb = lex.symbols.prim then
              (# name,val: ^text
              do &text[]-> prim[]; '%' -> prim.put;
                 lex;
                 true -> thisModule.hasPrim;
                 (*true -> isPrimitive;*)
                 (* % prop1 = v1, prop2 = v2, prop3 %
                  * % prop1, prop2 %
                  * % prop1 %
                  *)
                 loop:
                   (if lex.symb // lex.symbols.idf then
                       lex.sym[] -> name[] -> prim.append;
                       lex;
                       (if lex.symb = lex.symbols.eq then
                           lex;
                           '=' -> prim.put;
                           (if lex.symb
                            // lex.symbols.const
                            // lex.symbols.idf then
                               lex.sym[] -> val[] -> prim.append;
                               lex;
                            else
                               SyntaxError
                           if)
                        else 
                           none -> val[]
                       if);
                       (name[],val[]) -> handleProp;
                       (if lex.symb 
                        // lex.symbols.comma then 
                           ',' -> prim.put;
                           lex;
                           restart Loop                        
                        // lex.symbols.prim then
                           ' %' -> prim.append;
                           lex
                        else
                           (18,(lex.symbols.comma,lex.symbols.prim),(lex.symbols.semicolon))
                             -> SyntaxError
                       if)
                    else
                       SyntaxError
                   if);
              #)
          if)
       #);
     Restrictions:< Node
       (# PP:: (# do 'Restrictions' -> lx[]#);
          length:: 
            (# 
            do (if sons[] <> none then
                   scanSons(# do current.length + 1  -> value #);
                   value + 2 -> value
               if)
            #);
            PT:: 
            (# encBreak: @boolean
            do break -> encBreak; 
               (pos,length) -> block
               (#
               do (if sons[] <> none then
                      '[' -> lx.put;
                      scanSons
                      (#
                      do (pos,break) -> current.PT;
                         (if not isLast then 
                             ',' -> lx.put
                         if)
                      #);
                      ']' -> lx.put;
                      (pos,encBreak) -> mkBreak1
                  if)
               #)
            #);
       do (if lex.symb = lex.symbols.leftSquare then
              lex;
              parseRestrictions:
                (if lex.symb = lex.symbols.idf then
                    lex;
                    Restriction -> Append;
                    (if lex.symb = lex.symbols.comma then
                        lex;
                        restart parseRestrictions
                if)if);
              (if lex.symb = lex.symbols.rightSquare then
                  lex
               else
                  syntaxError
              if)
          if)
       #);
     Restriction:< Node
       (# PP::(# do 'Restriction' -> lx[]#);
          length::
            (#
            do name.length -> value;
               (if rQual[] <> none then 
                   rQual.length + value + 2 -> value 
               if)
            #);
          PT:: 
            (# 
            do name.lexemSy -> lx.puttext;
               (if rQual[] <> none then 
                   '[' -> lx.put;
                   (pos,break) -> rQual.PT;
                   ']' -> lx.put
               if)
            #);
          name: ^lexem; rQual: ^RestrictionQualifiers
       do lex.sym[] -> newLexem -> name[] -> Append;
          (if lex.symb
           // lex.symbols.objRef then
              (* in case of globals[] - prtty ad hoc *)
              lex;
              &RestrictionQualifiers[] -> rQual[] -> Append
           // lex.symbols.leftSquare then
              lex;
              RestrictionQualifiers -> rQual[] -> Append;
              (if lex.symb = lex.symbols.rightSquare then
                  lex
               else
                  syntaxerror
          if)if)
       #);
     RestrictionQualifiers:< Node
       (# PP:: (# do' RestrictionQualifiers' -> lx[] #);
          length::
            (#
            do (if sons[] <> none then
                   scanSons
                   (#
                   do current.length + value + 1 -> value
                   #)
               if)
            #);
          PT::
            (#
            do (if sons[] <> none then 
                   scanSons
                   (#
                   do (pos,break) -> current.PT;
                      (if not isLast then
                          ',' -> lx.put;
               if)#)if)                      
            #);
       do Loop:
            (if lex.symb = lex.symbols.idf then
                (if true then
                    NameApl -> Append
                 else
                    lex.sym[] -> newLexem -> Append;
                    lex;
                if);

                (if lex.symb = lex.symbols.comma then
                    lex;
                    restart Loop
            if)if)
       #);
     AttributeDenotation:< Node
       (# PP:: (#do 'AttDen' -> lx[] #);
          length::
            (#
            do scanSons
               (#
               do current.length + value -> value;
                  (if not isLast then 1 + value -> value if)
               #)
            #);
          PT:: 
            (# 
            do scanSons
               (# 
               do (pos,break) -> current.PT ; 
                  (if not isLast then '.' -> lx.put if)
               #) 
            #);
          isSuper: 
            (# isSup: @boolean; NA: ^denotation
            enter isSup 
            do L: scanSons(#do current[] -> NA[]; isSup -> NA.isSuper; leave L #)
            #);
          doAlloc:< (# (*ND: ^nameDecl enter ND[]*) do 'AD:bingo' -> putline; inner #);
          on: integerValue
            (# NA: ^nameApl;
            do L: scanSons
                 (# 
                 do (if current## = nameApl## then 
                        current[] -> NA[] 
                    if); 
                    leave L 
                 #);
               NA.on -> value
            #);

          (* R.foo
           * R[e]
           * R[e].x
           * R.T[e]
           * this(P)
           * this(P).x
           * this(P).R[e].x
           * this(P)[e] -- for index patterns
           * {n {'.','[e]'}n*} | this(P){'.'n)* -- previous
           * (n,this(P))(('[e]')?('.'n))* -- as of now 
           * (this(P) ('.' N ([e]?))*   |  N ([e])? ('.' N ([e]?))* )          
           * -- perhpas we should eliminate R.x[i] with the new repetition system
           *)
          name: (# do exit NA.name #);
          NA: ^denotation;
          isSupPtn: @boolean
       enter isSupPtn
       do (* FIX this and eliminate this(P)[e] *)
          (if lex.symb
           // lex.symbols.idf then
              NameApl -> NA[]
           // lex.symbols.thisObj then
              lex;
              thisObj -> NA[];
           // lex.symbols.textSy then 
              (*'\n***AD:textSy:'-> putline;*)
              TextDenotation -> NA[];
           // lex.symbols.leftSquare then 
              nameApl -> NA[] -> append; 
              leave AttributeDenotation
           // lex.symbols.begin then
              isSupPtn -> nameApl -> NA[] -> append; 
              leave AttributeDenotation
           else
              syntaxerror;
              nameApl -> NA[] -> append;
              leave AttributeDenotation
          if);
          (* lex.symb -> putint; newline;*)
          Loop:
            (#
            do (if lex.symb                    
                // lex.symbols.leftSquare then
                   lex;
                   NA[] -> Indexed -> NA[];
                   (if lex.symb = lex.symbols.dot then 
                       (if lex.symb = lex.symbols.prim then (* as in R[i].%getShort *)
                           lex
                       if);
               if)if);               
               (if lex.symb 
                // lex.symbols.dot then
                   NA[] -> Append;
                   lex;
                   (if lex.symb = lex.symbols.prim then (* as in R.%getShort *)
                       lex
                   if);
                   nameApl -> NA[];
                   restart Loop
                else
                   NA[] -> Append
               if);
            #)
       #);
     Denotation: Node
       (# withAD: ^AttributeDenotation;
          withP: ^WithPart;
          dcl: ^NameDecl;
          on: @integer;
          name:< (# Nm: ^text do inner exit Nm[] #);
          desc:<
            (# theDesc: ^ObjectDesc;
            do inner
            exit theDesc[]
            #);
          checkFirst:< (# do inner #); (* some how a kind of hack *)
          isDataItem:< booleanValue;
          isPtn:< booleanValue;
          (***************************************
           * 14.03.2015: isDataItem and isPtn added
           * isVar and isObject are apparently not used but might have been intended
           * for the same purpose?
           ****************************************)
          isVar:< BooleanValue;          
          isObject:< 
            (# NA: ^denotation enter NA[]
            do '\n***denotation: isObject called'->putline;inner 
            #);
          gen::< 
            (# LMR: @char; isLocal,isRef: @boolean 
            enter(LMR,isLocal,isRef) 
            do inner 
            #);
         (* evalIndexed:<
            (# LMR: @char; isLocal,isRef: @boolean 
            enter(LMR,isLocal,isRef) 
            do inner 
            #);*)
          goOrigin:< 
            (# continue: @boolean; withP: ^withPart; AD: ^AttributeDenotation
            enter(continue,withP[],AD[]) 
            do inner 
            #);
          genStrucRef:< (# LMR: @char; isLocal: @boolean enter(LMR,isLocal) do inner #);
          doAlloc:< (# do inner #);
          isSuper: @boolean;
       do inner
       #);
     NameApl:< Denotation
       (# PP:: (#do  'NameApl'->lx[] #);
          length:: (# do (if N[] <> none then N.length -> value if) #);
          PT:: (# do (if N[] <> none then (if not isImplicitSuper then N.PT if) if) #);
          name:: 
            (# 
            do (if N[] <> none then
                   N.lexemSy -> Nm[] 
                else
                   'NA:name:N none' -> Nm[] -> putline
               if)
            #);
          lexemSy:: (# do N.lexemSy -> L[] #);
          theModule:: 
            (* In attributeDenotations like R.X, X.origin is overwriten by R.desc
             * For this reason we return father.theModule
             * otherwise we get theModule of R.desc
             *)
            (# do father.theModule -> md[] #);
          N: ^Lexem;
          isEmpty: @boolean;
          isImplicitSuper: @boolean;
          isSupPtn: @boolean;
       enter isSupPtn
       do (if lex.symb = lex.symbols.idf then
              lex.sym[] -> newLexem -> N[] -> Append;
              lex;
           else 
              (if not (isSupPtn -> isEmpty)  (* an empty super *) then
                  SynTaxError
              if)
          if)
       #);
     Indexed:< Denotation
       (# PP:: (# do 'Indexed' -> lx[] #);
          PT:: 
            (# 
            do (pos,break) -> NA.PT ;
               '[' -> lx.put; (pos,break) -> inx.PT ; ']' -> lx.put
            #);
          length:: (# do NA.length + 1 + inx.length + 1 -> value #); 
          name::
            (# 
            do (if NA[] <> none then
                   (* (if NA.N[] <> none then
                    NA.N.lexemSy -> Nm[]
                    else
                    'Indexed:NA.N is none' -> Nm[] -> putline
                    if)*)
                   '*******indexed: fix name'->putline
                else
                   'Indexed:NA is none' -> Nm[] -> putline
               if)
            #);
          NA: ^NameApl;
          inx: ^Evaluation
       enter NA[]
       do NA[] -> append;
          Evaluation -> inx[] -> append;
          (if lex.symb = lex.symbols.colon then
              (* R[low:high] *)
              lex;
              Evaluation (* save *)
          if);
          (if lex.symb = lex.symbols.rightSquare then
              lex
           else
              (20,(0),(0)) -> SyntaxError
          if)
       #);
     thisObj:< Denotation
       (# PP:: (# do 'thisObj'-> lx[] #);
          length:: (#do 5 + ptn.length + 1 -> value #);
          PT:: 
            (# 
            do 'this('-> lx.append; (pos,break) -> ptn.PT ; ')' -> lx.put 
            #);
          ptn: ^NameApl
       do (if lex.symb = lex.symbols.leftBrack then
              lex;
              NameApl -> ptn[] -> append;
              (if lex.symb = lex.symbols.rightBrack then
                  lex
               else 
                  (21,(0),(0)) -> SyntaxError
              if)
           else
              (22,(0),(0)) -> SyntaxError
          if);
       #);
     
     path: @
       (# P: [8] ^text;
          top: @integer;
          init:< (# do 0 -> top #);
          push:
            (# dir: ^text
            enter dir[]
            do (if (top + 1 -> top) > P.range then P.range -> P.extend if);
               dir[] -> P[top][];
            #);
          pop: (# do top - 1 -> top #);
          append:
            (# pth: @text
            do (for i: top repeat 
                    P[i][] -> pth.append;
                    (if i < top then dirCh -> pth.put if)
               for)
            exit pth[]
            #)
       #);
     
     locateWorld: @ 
       (# entries: [8] ^text; top,worldPos: @integer;
          
          init:< (# do 0 -> top -> worldPos #);
          
          deComp:
            (# last,worldPosInCWD: @integer
            do (* cwd = .../beta/.../MiniESystem/miniCompiler/BETAworld/.../XXX *)
               
               dirCh -> CWD.put;
               (if false then
                   'deComp: CWD: ' -> puttext; CWD[] -> putline;
               if);

               CWD.setPos;
               CWD.scanAll
               (# pos: @integer; N: ^text
               do pos + 1 -> pos; 
                  (if ch // '/' // dirCh then 
                      (if (top + 1 -> top) > entries.range then
                          entries.range -> entries.extend 
                      if);
                      (if pos > 1 then 
                          (last+1,pos-1) -> CWD.sub -> N[] -> entries[top][];
                          (if 'BETAworld' -> N.equalNCS then
                              top -> worldPos;
                              pos -> worldPosInCWD;
                          if)
                      if);
                      pos -> last;
                  if)
               #);
               (*  (last+1,CWD.length) -> CWD.sub -> entries[top+1][];*)
               (if false then
                   'Entries: ' -> putline;
                   (for i: top repeat entries[i][] -> putline for);
               if);
               (if worldPos = 0 then 'workspace not found' -> putline if); 
               (1,worldPosInCWD - 1) -> CWD.sub -> topPath[];
               topPath.copy -> path.push;
               dirCh -> topPath.put;
               topPath.copy -> pathToBetaWorld[];
               (if false then
                   'pathToWorld: ' -> puttext; topPath[] -> putline;
               if);
               'BETAworld.bet' -> topPath.append;
               (*'Module: ' -> puttext; (last+1,CWD.length) -> CWD.sub -> putline*)
            #);
          scan:
            (# compPath,subDirN: ^text;
               isLast: @boolean
            do (for i: top - worldPos + 1 repeat
                    i -> entry -> compPath[];
                    (if i < (top - worldPos + 1) then
                        i + 1 -> entry -> subDirN[];

                     else (* in this case N and subN are identical,
                           * so what happens in inner?
                           * Apparenltly we need it
                           *)
                        true -> isLast
                    if);
                    inner
               for);
            #);          
          entry: (# inx: @integer enter inx exit entries[worldPos+inx-1][] #);
          CWD: ^text;
          topPath: ^text;
       do (if fullPath then
              FN.copy -> CWD[];
              (if false then
                  'locateWorld: ' ->puttext; CWD[] -> putline;
                  'dirC: "'->puttext; dirCh -> put; '"' -> put; newline;
              if);
              (# pos,lastDir: @integer 
              do (*CWD.setPos;*)
                 CWD.scanAll
                 (# 
                 do pos + 1 -> pos; 
                    (if ch // '/' //  dirCh then pos -> lastDir if)
                 #);
                 (* lastdir -> putint; newline;*)
                 (lastDir,CWD.length) -> CWD.delete;
                 (*CWd[] -> putline;*)
                 deComp;

                 (* deComp defines topPath = ' ...../BETAworld/BETAworld.bet',
                  * since we need to 
                  * compile from BETAworld when using compile foo.bet
                  * Here we need to compile just the module/module
                  * being executed from miniEnv
                  * We thus overwrite topPath as done below
                  *)
                 (*  FN[] -> topPath[]*)
              #)
           else
              getCurrentDir -> CWD[];
              deComp;
          if)
       exit topPath[]
       #);
     kinds: @
       (# simple: (# exit 1 #);
          part: (# exit 2 #);
          ref: (# exit 3 #);
          rep: (# exit 4 #);
          text: (# exit 5 #);
          pattern: (# exit 6 #);
          virtualPattern: (# exit 7 #);
          furtherBind: (# exit 8 #);
          finalBind: (# exit 9 #);
          varPtn: (# exit 10 #);
          forInx: (# exit 11 #);
          objModule: (# exit 12 #);
          ptnModule: (# exit 13 #);
          action: (# exit 14 #);
       #);     
     
     (* parse routines used by minienv *)
     browserItem:
       (# T,N: ^text; kind: @char; xKind: @integer;       
          checkEos: 
            (#
            do lex;
               (if lex.symb <> lex.symbols.eos then
                   (23,(0),(0)) -> syntaxError
               if)
            #);
          oldLex: ^lexer
       enter T[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> T.setPos;
          T[] -> lex.initWithText;
          false -> hasSyntaxError;
          lex;
          (if lex.symb <> lex.symbols.idf then
              (24,(0),(0)) -> syntaxError
           else
              lex.sym[] -> N[];
              lex;
              (if lex.symb <> lex.symbols.colon then
                  (25,(0),(0)) -> syntaxError
               else
                  lex;
                  (if lex.symb
                   // lex.symbols.object then
                      '@' -> kind;
                      kinds.part -> xKind;
                      checkEos
                   // lex.symbols.objModule then
                      '/' -> kind;
                      kinds.objModule -> xKind;                      
                      checkEos
                   // lex.symbols.ptnModule then
                      kinds.ptnModule -> xKind;
                      checkEos
                   // lex.symbols.eos then
                      '' -> kind
                   else
                      (26,(0),(0)) ->syntaxError
          if)if)if);
          oldLex[] -> lex[]
       exit(N[],xKind,kind,hasSyntaxError)
       #);
     
     parseSubText:
       (# xsyntaxError:<
            (# errorStream: ^stream
            do '*** syntax error'->putline;
               (*lex.errorStream.reset;*)
               lex.errorStream[] -> errorStream[] -> putline;
               inner
            exit errorStream[]
            #);               
          inn: ^text; (* the beta text to be parsed *)
          oldLex: ^lexer;
          errs: ^stream
       enter inn[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          false -> hasSyntaxError;
          (*&text[] -> lex.errorStream[]; (* put some of this in lex.init *)
          lex;
          INNER;          
          (if hasSyntaxError then
              xsyntaxError -> errs[] (* check if this is ever used, including
                                        * exit errors[] below
                                        *)
          if);
          oldLex[] -> lex[];
       exit errs[]
       #);
     pDecl: parseSubText (* called from worldWindow:pasteHandler*)
       (# N: ^text; kind: @char; IT: ^Item; dcl: ^Decl
       do (* We cannot juts call Decl here:
           *   decl -> dcl[]
           * since decl assumes a module to have the form: 'M: /;'
           * and just skips the module-decl. Modules are supposed to be 
           * defined by directories.
           * If inn is a module, 'M : / (# ... #)', then
           * paste is supposed to create such a directory 
           * -- se also MiniSystem/ModuleSyntax.txt -- not s simple
           * We might chnage copy to deliver texts on the form
           *  X: @ ...
           *  S: ^T;
           *  P: S(# .. #)
           *  / M: @ P(# ... #)  -- a module
           *  / M: P(# ... #) -- a ptn module
           * Below we may chef for a leading '/' and then call Decl
           *)
          'pDecl: '->puttext; inn[] -> putline;
          (if lex.symb <> lex.symbols.idf then 
               (24,(0),(0)) -> syntaxError (* see below*)
           else
              lex.sym[] -> N[];
              lex;
              (if lex.symb <> lex.symbols.colon then
                  (25,(0),(0)) -> syntaxError (* this needs to be fixed 
                                                    * with respect to marking 
                                                    * the error
                                                    *)
               else
                  lex;
                  (if lex.symb
                   // lex.symbols.object then
                      '@' -> kind;
                      lex;
                      StaticItem -> IT[]
                   // lex.symbols.objModule then
                      '/' -> kind;
                      'Paste of module is NOT implemented ' -> putline;
                   // lex.symbols.eos then
                      '' -> kind
                   else
                      (* should be lexem: then: pattern - parse OD *)
                      'Paste of pattern is NOT implemented ' -> putline;
                      ' ' -> kind;
                      Pattern -> IT[]
          if)if)if)
       exit (N[],kind,IT[],dcl[])
       #);
     mkDecl: parseSubText
       (# dcl: ^decl;
          pathToinn: ^text; (* the current path to inn 
                             * needed for parsing a module 'mod: /' *)
       enter pathToInn[]
       do 'mkDecl of: "' -> puttext; inn[] -> puttext; 
          '" in "' -> puttext; pathToInn[] -> puttext; '"' -> putline;
          path.init;
          pathToInn[] -> path.push;
          decl -> dcl[]
       exit dcl[]
       #);
     parseDecl: parseSubText
       (# dcl: ^Decl;
       do decl -> dcl[];
       exit dcl[]
       #);
     mkModuleItemDecl:
       (# N: ^text;
          MI: ^ModuleItem;
          dcl: ^Decl;
          NDs: ^NameDecls;
          ND: ^NameDecl;
          NL: ^Lexem;
       enter(N[],MI[])
       do &Decl[] -> dcl[]; 
          &NameDecls[] -> NDs[] -> dcl.NS[] -> dcl.append;
          &NameDecl[] -> ND[] -> NDs.append;
          &Lexem[] -> NL[] -> ND.N[] -> ND.append;
          N[] -> NL.item[];
          MI[] -> dcl.IT[] -> dcl.append;
          dcl[] -> MI.father[];
          ND[] -> MI.md.theDecl[];
       exit dcl[]
       #);
     
     mkModuleItemDeclx: 
       (# name: ^text; kind: @char; itemT: ^text; moduleF: ^File;
          pathToModule: ^text;
          NL: @Lexem;
          ND: @NameDecl;
          NS: @NameDecls;

          MI: @moduleItem;
          
          dcl: ^decl;
       enter(name[],kind,itemT[],pathToModule[],moduleF[])
       do 
          name[] -> NL.item[];
          pathToModule[] -> MI.dir[];
          itemT[] -> parseSubText
          (#
          do (if kind = '/' then
                 NL[] -> objectModule -> MI.md[] -> mi.append;
                 lex;
              else 
                 NL[] -> ptnModule -> MI.md[] -> mi.append;
             if);
          #);
	  pathToModule.copy -> MI.md.pathToFn[];
	  name[] -> MI.md.pathToFn.append;

          moduleF[] -> mi.md.inFile[];  
          true -> MI.isParsed;
          (name[],MI[]) -> mkModuleItemDecl -> dcl[];
          'mkModuleItemDecl: ' -> puttext; dcl.doPT -> putline;;
          MI.doPT -> putline;
       exit dcl[]
       #);
     mkObjectDesc: parseSubtext
       (# OD: ^objectDesc
       do PatternDen -> ObjectDesc -> OD[]
       exit OD[]
       #);
     mkActionPart: parseSubText
       (# acp: ^actionPart
       do ActionPart -> acp[]
       exit acp[]
       #);
     ParseStdBeta:
       (# betaLib: ^Node
         <<SLOT ParseStdBetax:dopart>>
       exit betaLib[]
       #);
     <<SLOT parserLib: attributes>>;
     
     superObject: ^ObjectDesc; (* other basic ODs are declared in checker.bet *)
     
     rootModule,    (* Top module being parsed: BETAworld *)
     thisModule,    (* Module currently being parsed      *)
     main: ^Module; (* Module that is argument to compiler and to be executed *)
     
     fullPath: @boolean;
     theModule: ^ Module;
     FN,topPath,pathToBetaWorld: ^text
  enter(fullPath,theModule[],FN[])
  do (* Two situations:
      * 1. theModule[] = none and rootModule[] = none
      *    called from compiler
      *    FN[] is the file to be compiled, fullPath = false
      * 2. theModule[] <> none and rootModule[] <> none
      *    called from miniEnv
      *    FN[] is the name of theModule, fullpath = true,
      *    FN is not used?
      *    In this case we do not parse - important that no new AST's are constructed
      *    since there are refs from the browser to the AST 
      *    - when code is modfied in miniEnv,
      *    the AST should be updated from miniEnv 
      *    - especially directories should nt be parsed
      *    we do checking and generation
      *    OBS! rootModule[]  <> none is the case because the whole BETAworld was
      *    compiled when minienv was started. This is a bad solution
      * 
      * We should do a clean-up of arguments - the situations are currently too indirect
      * Perhaps two methods
      *   * compileFile
      *   * compileModule
      *)
     
     (if false then
         'Parser: ' -> puttext;
         (if fullPath then 'fullpath=true' -> puttext else 'fullpath=false' -> puttext if);
         ' theModule: ' -> puttext;  theModule.name.lexemSy -> putline; newline;
     if);
     
     (if rootModule[] = none then
         60 -> linewidth;
         false -> withPos;
         &lexer[] -> lex[];(* if we remove this one - which is superflous 
                            * - we get ref is none in moduleitem 
                            * - should be cleaned up
                            *)         
         (if false then
             'CurrentDir: ' -> puttext;  getCurrentDir -> putline;
         if);
         path.init;
         locateWorld.init;
         locateWorld -> topPath[];(* -> lex.initWithFile;
                                   lex;*)
         topPath[] -> pModule -> rootModule[];
         (if theModule[] <> none then (* we should never come here *)
             (*'Replacing comp in dir'->putline;*)
             none -> theModule.sons[];
             (*  rootModule[] -> theModule.md[] -> theModule.append;*)
             (if main[] <> rootModule[] then (* why is this the case*)
                 rootModule[] -> main[]
             if) 
         if);
         (if false then parseStdBeta if);
         
         rootModule.handleDirModules;
         (if main[] = none then 'main is none:'->putline if);                      
         
         (if hasSyntaxError then
             '\n*** Syntax error - compiler terminates' -> putline
          else
             inner
         if);
      else 'Called from minienv'->putline;
         none -> lex.errorStream[];
         true -> withPos;
         (if false then 'Main: ' -> putline; main.doPT -> putline; if);
         (if theModule[] <> none then
             (if false then 'TheModule: ' -> putline; theModule.doPT -> putline if);
             theModule[] -> main[];
          else
             '***** ERROR : theModule = none !!! ' -> putline
         if);
         inner
     if);
     (*lex.closeFile*)
  exit(rootModule[],lex.errorStream[])
  #)

