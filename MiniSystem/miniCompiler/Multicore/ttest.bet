origin '~beta/basiclib/systemenv';
(*OBJfile nti_ms 'nti_ms/ctest.obj';*)
(*BUILD default '$$/ctest.o' 'ctest.c' 'c:/cygwin/bin/cc -c $1';*)
BUILD default '$$/ctest.obj' 'ctest.c' 'c:/cygwin/bin/cc -c -o $0 $1';
---lib:attributes---
(*
  hThreadArray[i] = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            MyThreadFunction,       // thread function name
            pDataArray[i],          // argument to thread function 
            0,                      // use default creation flags 
            &dwThreadIdArray[i]);   // returns the thread identifier 
*)
CreateThread: External
(# a,b: @integer;
   F: ##external;
   c,d,e: @integer;
   R: @int64
enter(a,b,F##,c,d,e)
do CallStd 
exit R
#);

WaitForMultipleObjects: external
(# max,X,Y: @integer;
  HT: @integer
enter(max,HT,X,Y)
do CallStd 
#);

(*
    ghSemaphore = CreateSemaphore( 
        NULL,           // default security attributes
        MAX_SEM_COUNT,  // initial count
        MAX_SEM_COUNT,  // maximum count
        NULL);          // unnamed semaphore
*)

CreateSemaphoreA: External
  (# sec: @integer;
     IV: @integer;
     max: @integer;
     name: @integer;
     Res: @integer
  enter(sec,IV,max,name) do CallStd 
  exit Res
  #);
WaitForSingleObject: external
  (# Sem: @integer;
     TO: @integer;
     res: @integer
  enter(Sem,TO)
  do CallStd
  exit Res
  #);
ReleaseSemaphore: External
  (# Sem: @integer;
     cnt: @integer;
     pcnt: @integer;
     B: @integer
  enter(sem,cnt,pcnt)
  do CallStd
  exit B
  #);

(*BOOL WINAPI ReleaseSemaphore(
  _In_       HANDLE hSemaphore,
  _In_       LONG lReleaseCount,
  _Out_opt_  LPLONG lpPreviousCount
);
*)
CS: external(# H: @integer do 'CS' -> CallStd exit H #);
---program:descriptor---
systemEnv
(# xmonitor:
     (# M: @int64;
        init: 
          (# V: @integer
          do (0,1,1,0) -> CreateSemaphoreA -> M ;
             M -> putint; newline
             (* CS -> M*)
          #);
        entry:
          (# V: @integer
          do (M,0) -> WaitForSingleObject -> V;
             inner;
             (M,1,0) -> ReleaseSemaphore -> V
          #)
     #);
   foo: external
     (# X,V: @integer 
     enter X 
     do 'F' -> put
        (*(if true then 'F' -> put
         else
            (M.M,0) -> WaitForSingleObject -> V;
            'Foo is here: '-> puttext; X -> putint;  newline;
            (M.M,1,0) -> ReleaseSemaphore -> V
        if)*)
     #);   
   bar: external
     (# X,V: @integer 
     enter X 
     do 'B' -> put
        (*    (if true then 'B' -> put
         else
            (M.M,0) -> WaitForSingleObject -> V;
            'Bar is here: '-> puttext; X -> putint;  newline; 
            (M.M,1,0) -> ReleaseSemaphore -> V
        if)*)
     #);	
   M: @xmonitor
     (# puttext: entry(# T: ^text enter T[] do T[] -> screen.puttext; #);
        putint: entry(# V: @integer enter V do V -> screen.putint #);
        newline: entry(# do screen.newline #)
     #);
   Q,Q2: @int64; 
   W,W2: @int64;
   fool: external(# do callC #)
do 'Hello world' -> putline;
   fool;
   M.init;
   (0,0,foo##,123,0,@@Q) -> CreateThread -> W;
   (0,0,bar##,321,0,@@Q2) -> CreateThread -> W2;	

   (*WaitForMultipleObjects(MAX_THREADS, hThreadArray, TRUE, INFINITE);*)
   
   'Started'-> M.puttext; M.newline;
   
   (2,W,1,111111111) -> WaitForMultipleObjects;

   'Bye' -> putline
#)

