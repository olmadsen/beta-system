ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/sysutils/envstring'
INCLUDE 'objectImage';
INCLUDE '../miniServices/Service';
---systemlib:attributes---
betaVM:
  (# init:<
       (# stdPath: ^text
       do 'OBS! Check if location of BETA with MiniSystem is correct: ' -> puttext;
          (if true then
              'c:/beta/r5.5'-> stdPath[] -> putline
           else
              '$(BETALIB)' -> expandEnvVar -> stdPath[] -> putline;
          if);
          (if true then
              '/MiniSystem/miniServices/' -> stdPath.append;
              ('FileService'-> (stdPath.copy).Append,5123) -> FS.init;
              ('GUIService' -> (stdPath.copy).Append,5124) -> GS.init;
              5125 -> MS.openSocket
           else
              ('../../../../miniServices/FileService',5123) -> FS.init;
              ('../../../../miniServices/GUIService',5124) -> GS.init;
              5125 -> MS.openSocket
          if)
          #);
     VMevent: 
       (# caller,thisObj,org: ^ObjDesc.template; bcPos: @integer;
          doPause: (# do (if false then pause else suspend if)#);

       enter(caller[],thisObj[],org[],bcPos)
       do (if thisObj[] <> none then 
              inner;
              thisObj.myDescInx -> out.putint; ' '-> out.put;
              thisObj.id -> out.putint; out.newline
          if)
       #);
     set:< (# do inner #); (* ad hoc *)

     startEvent:< VMevent;
     allocEvent:< VMevent(# isObj: @boolean enter isObj do inner ; #);
     doEvent:< VMevent;
     rtnEvent:< VMevent;
     resumeEvent:< VMevent;
     suspendEvent:< VMevent;
     breakEvent:<  VMevent;
     done:< (# do inner #);
     
     thisComp, (* not used? *)
     thisObj,
     thisStack,
     eventProcessor: ^ObjDesc.template;
     
     thisCode: ^ByteCode; 
     
     glsc: @integer;
     
     codes: @ ByteCodes;
     
     fatalError:
       (# errNo: @integer
       enter errNo
       do errNo -> thisObj.fatalError
          (#
          do 'LSC: ' -> puttext; glsc -> putint; newline;          
             inner fatalError
          #)
       #);
     
     out: ^Stream;
     
     FS,GS,MS: @Service;
     mouseListener:  @ | system
       (# T: ^text
       do (if MS.trace or true then 
            (*  'Starting mouseListener:'->putline *)
          if);
          cycle
          (# event,noOfClicks,handle: @integer
          do MS.receive -> T[];
             (*'mouseListener: ' -> puttext; T[] -> putline;*)
             T.setPos;
             T.getInt -> handle;
             T.getint -> event;             
             (if GS.trace then
                 'BETA:event:handle: ' -> puttext; handle -> putint;             
                 (if event
                  // 1 then
                     ' mouseClicked:'->puttext;
                     T.getint -> noOfClicks -> putint;                
                  // 2 then
                     'BETA:Mouse exited' -> putline
             if)if);

             T[] -> execute.selectEventProcessor;
             (* store handle/object in 1 -> thisStack.rstore *)
             execute[] -> fork;
             pause;
            (* 'mouseListener reactivated'->putline*)
          #);
                 
          (if MS.trace or true then 'BETA:mouse: ' -> puttext; T[] -> putline if);
       #);
     
     reActivate: (# do (if true then execute else execute[] -> fork if) #);
     
     execute: @ | system
       (# init:
            (#
            enter(descs[],descInx,out[])
            do mouseListener[] -> fork;
               pause;                
            #);
          selectEventProcessor:
            (# eventSpec: ^text; D: ^objDesc
            enter eventSpec[]
            do eventProcessor[] -> thisComp[] -> thisObj[] -> thisStack[];
               thisObj.myObjDesc -> D[];
              (* '\n===='->putline;
               (thisObj.myObjDesc).literals[1] -> putint; newline;
               eventSpec.length -> putint; newline;
               (eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min -> putint; 
               * newline;
               (for i: D.literals[1] repeat 
                    (thisObj.myObjDesc).literals[1+i] -> put; ' ' -> put
               for); newline;*)
               
               (if eventSpec.length > (thisObj.myObjDesc).literals[1] then 
                   '\n\n**** eventSpec too large: "'->puttext;
                   eventSpec[] -> puttext; '"' -> put
               if);

               (for i:((eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min) repeat
                    i -> eventSpec.inxGet -> (thisObj.myObjDesc).literals[1 + i];
                   (* '<'->put;  i -> eventSpec.inxGet -> put; '>'->put;
                    (thisObj.myObjDesc).literals[1 + i] -> put*)
               for);

               descs.OD[descInx + 1 ].bc[] -> thisCode[];
               newId -> thisObj.id;
               descInx -> thisObj.myDescInx;
               true -> handleEvent;
               1 -> gLsc;
            #);
          handleEvent: @boolean;
          descs: ^RuntimeDescriptors;
          descInx: @integer;
          isObj: @integer;
          newid: @ (# id: @integer do id+1 -> id exit 1000+id #);
          obj: ^ObjDesc.Template;
          break:
            (# descNo,bcPos: @integer
            enter(descNo,bcPos)
            do 'VM:breakIn: ' -> puttext; descNo -> putint; 
               ' at: ' -> puttext; bcPos -> putint; newline;
               'OD.range: ' -> puttext; descs.OD.range -> putint; newline;

               (if descs.OD[descNo][] = none then
                   'bc none ' -> putline
                else 
                   bcPos -> descs.OD[descNo].bc.setBreak
               if)
            #);
          
          sendMsg:
            (# serverId,handle,msgId: @integer; msg: ^objDesc.template; 
               T: @text
            enter(serverId,handle,msgId,msg[])
            do (if FS.trace then
                   'SendMsg: serverId=' -> puttext; serverId->putint; 
                   ' handle=' -> puttext; handle -> putint; 
                   ' msgId='-> puttext; msgId -> putint; ' vields[1]=' -> puttext; 
                   msg.vfields[1] -> putint;
               if);
               (for i: msg.vfields[1] repeat
                    msg.vfields[i+2] -> T.put; 
               for);
               (if FS.trace then
                   ' msg="'->puttext; T[] -> puttext;  '"'->put; newline;
               if);
               (if serverId
                // 1 then
                   (handle,msgId,T[]) -> sendFileMsg
                // 2 then
                   (handle,msgId,T[]) -> sendGuiMsg
               if)
            #);
          doReceive: (# exit true #);
          sendFileMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if FS.trace then 'sendFileMsg: '-> puttext; if);
               (if msgId
                // 1 then 
                   1 -> FS.mkCommand(#do msg[] -> cmd.puttext #);
                   (if doReceive then
                       FS.receive -> h[];
                       (1,h.length-1) -> h.sub -> h[];
                       0 -> h.setpos; h.getint -> thisStack.vPush
                    else
                       1 -> thisStack.vpush
                   if)
                // 2 then
                   2 -> FS.mkCommand(#do handle -> cmd.putint; ' '  -> cmd.put;
                                       msg[] -> cmd.puttext
                                    #);
                   (if doReceive then FS.receive -> h[] if)
                // 3 then
                   3 -> FS.mkCommand(# do handle -> cmd.putint; #);
                   (if doReceive then FS.receive -> h[] if)
               if);
            #);
          sendGuiMsg:
             (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
             do (if GS.trace then
                   'sendGuiMsg: '-> puttext; msgId->putint; ' ' -> put;
                   '"' -> put;  msg[] -> puttext; '"' -> put; newline;
               if);
               (if msgId
                // 1 then
                   1->GS.mkCommand(# do msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (if GS.trace then 'BETA:received: ' -> puttext; h[] -> putline; if);
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush;
                // 2 // 5 // 6 then
                   msgId ->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                   
                // 3 then
                    3->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 4 // 7 // 8 // 10 then
                   msgId -> GS.mkCommand
                   (# do handle -> cmd.putint; ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 9 then
                   msgId -> GS.mkCommand(# do handle -> cmd.putint; 
                                           ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];  
                   h.length 
                     -> mkTextObject(# i: @integer do i + 1 -> i -> h.inxGet -> ch #);
                    (* -> thisStack.rpush;*)
               if);
                (if GS.trace then
                    'betaVM:received: ' -> puttext; h[] -> putline;
                if)
             #);
          mkTextObject:
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do (length+1,3) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               newId -> X.id;
               descs.textDescNo -> X.myDescInx;
               length -> X.vfields[1]; (* pos *)
               length -> X.vfields[2]; (* range *)
               (for i: length  repeat
                    inner;
                    ch -> X.vfields[i + 2];
                   (* ('mkTextObject',true,screen[]) -> X.dump*)
               for);   
            exit X[]
            #);
          mkStrucRefObj:
            (# origin,X: ^ObjDesc.template; 
               inx: @integer;
               isVirtual: @boolean
            enter(origin[],inx,isVirtual)
            do  (* the geeration below is clumsy
                 * currently template is made for textDesc
                 * clean-up
                 *)
               (*('mkVirtualStrucRef',true,screen[]) -> origin.dump;*)
               (0,1) -> descs.OD[descs.structureRefDescNo].template -> X[];
               2 -> X.rfields.new;
               (if isVirtual then
                   (origin.myObjDesc).vdtTable[inx] -> inx
               if);
               inx -> X.vfields[1];
               origin[] -> X.rfields[2][];
               (*('StrucRefObj',true,screen[]) -> X.dump;*)
               X[] -> thisStack.rpush
            #);
          alloc:
            (# origin,callee,Y: ^objDesc.template; descNo: @integer; isObj: @boolean
            enter(origin[],descNo,isObj)
            do (*'Alloc: ' -> puttext; descNo -> putint; newline;*)
               &descs.OD[descNo].template[] -> callee[];
               descNo -> callee.myDescInx;
               newId -> callee.id;
               
               (* '\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                * ' lsc: ' -> puttext; glsc -> putint; newline; *)
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descNo].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> thisStack[] -> thisObj[];
               (if isObj then 
                   (*'object'->putline *)
                else 
                   (*'activation' -> putline *)
               if);
               (Y[],thisObj[],origin[],glsc,isObj) -> allocEvent
            #);
          allocFromStrucRefObj:
            (# X: ^objDesc.template
            enter X[]
            do (*('AllocFromStrucRefObj',true,screen[]) -> X.dump;*)
               (X.rfields[2][],X.vfields[1],true) -> alloc
            #);
          dumpD: 
            (#
            do 'descs:' -> putline;
               (for i: descs.OD.range repeat
                    i -> putint; ':' -> put; 
                    (if descs.OD[i][] = none then ' none' -> putline if);
               for);
               newline
            #);
          isRunning,doTerminate: @Boolean;
          terminate: (# do true -> doTerminate #)
       enter(descs[],descInx,out[])
       do main:
            (#
            do true -> isRunning; (*screen[] -> out[];*)
               false -> doTerminate;
               (if descs.OD[1][] = none then (* not used any more*)
                   'Allocating dummy template in OD[1] for repetitions'
                     -> putline;
                   &ObjDesc[] -> descs.OD[1][];
                   ('ValueRep',1,0,out[]) -> descs.OD[1].init;
               if);
               &descs.OD[descInx].template[] -> thisComp[] -> thisObj[] -> thisStack[];
               descs.OD[descInx].bc[] -> thisCode[];
               newId -> thisObj.id;
               descInx -> thisObj.myDescInx;
               
               &descs.OD[descInx + 1 (* dangerous*)].template[] -> eventProcessor[];
               
               'EXECUTE: ' -> puttext; descs.OD[descInx].name[] -> puttext;
               ' descInx: ' -> puttext; descInx -> putint; newline;
               (* 'TextDescNo: ' -> puttext; descs.textDescNo -> putint; newline;*)
               (* 'StructureReDescNo: ' -> puttext; 
                * descs.structureRefDescNo -> putint;
                * newline;
                *)
               pause; (* apparently we need 2 pause to be sure that 
                       * mouseListener has been started before the VM suspends
                       *)
               1 -> glsc;
               (none,thisObj[],none,glsc) -> startEvent;
               Loop:
                 (# exe: 
                      (# T: ^text ; F: ^file
                      enter T[] 
                      do inner;
                         T[] -> out.puttext; ' '-> out.put; glsc+1 -> glsc; 
                         (if out## = File## then
                             out[] -> F[]; F.flush
                         if)
                      #);
                    exel: exe(# do out.newline #);
                    op1: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.putint; ' ' -> out.put; 
                         glsc+1 -> glsc
                      exit arg
                      #);
                    op1asChar: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.put; ' ' -> out.put; 
                         glsc+1 -> glsc
                      exit arg 
                      #);
                    op2: 
                      (# arg: @integer
                      do thisCode.B[glsc] * 255 + thisCode.B[glsc+1] -> arg -> out.putint; ' ' -> out.put; 
                         glsc + 2 -> glsc
                      exit arg
                      #);
                    descInx,dinx,rangee,inx,length,serverId,handle,msgId: @integer;
                    callee,X,Y: ^ObjDesc.template;
                    R: ^ObjDesc.BasicTemplate;
                    top1,top2: @integer
                 do (if glsc -> (thisObj.myCode).isBreak then
                        (thisObj.myDyn,thisObj[],thisObj.myOrigin,glsc) 
                          -> breakEvent
                    if);
                    (if thisCode.B[glsc]
                     // codes.pushc then
                        'pushc' -> exe;
                        op1 -> thisStack.vpush   
                     // codes.pushc2 then
                        'pushc2' -> exe;
                        op2 -> thisStack.vpush                           
                     // codes.pushthis then
                        'pushthis' -> exe;
                        thisObj[] -> thisStack.rpush;
                     // codes.push then
                        'push' -> exe;
                        thisObj.vfields[op1] -> thisStack.vpush;
                     // codes.rpush then
                        'rpush' -> exe;
                        thisObj.rfields[op1][] -> X[] -> thisStack.rpush;
                        (*(':rpush',true,screen[]) -> X.dump;*)
                        (*(if X[]<> none then
                            ('rpush:',true,screen[]) -> X.dump;
                        if)*)
                     // codes.pushg then
                        'pushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError(#do leave loop #) if);
                        X.vfields[op1] -> thisStack.vpush;
                     // codes.rpushg then
                        'rpushg' -> exe;
                        (if thisCode.descInx = 30 then
                           (* ('Open1:',true,screen[]) -> thisObj.dump*)
                        if);
                        thisStack.rpop -> X[];
                        (*('rpushg:',true,screen[]) -> X.dump;*)
                        (if X[] = none then
                            3 -> fatalError(#do leave loop #);
                         else
                            X.myName -> out.puttext; ';'->out.put;
                        if);
                        X.rfields[op1][] -> Y[] -> thisStack.rpush;
                       (* (if Y[] = none then
                            ' none ' -> out.puttext
                         else
                            Y.myName -> out.puttext; ';'->out.put;
                        if);*)
                         (if thisCode.descInx = 30 then
                           (* ('Open2:',true,screen[]) -> thisObj.dump*)
                        if);
                        
                     // codes.xpush then
                        'xpush' -> exe;
                        thisStack.rpop -> X[]; (* not used *)
                        op1 + thisStack.vpop + 1 -> thisObj.get -> thisStack.vpush
                     // codes.xpushg then
                        'xpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> inx;
                        X[] -> R[];
                        (*'inx: ' -> puttext; inx -> putint; newline;*)
                        (*('xpushg:',true,screen[]) -> X.dump;*)
                        thisStack.vpop + inx(* + 2*) -> R.get -> thisStack.vpush
                     // codes.rstore  then
                        'rstore' -> exe; 
                        thisStack.rpop -> X[]; (* if multiple assignment of X, 
                                                * violation error happens
                                                * compiler error?
                                                *)
                        (*(if X[]<> none then
                            ('rstore:',true,screen[]) -> X.dump;
                        if);*)                                           
                        
                        X[] -> thisObj.rfields[op1][]; 
                     // codes.store  then
                        'store' -> exe;
                        thisStack.vpop -> thisObj.vfields[op1];
                     // codes.storeg  then
                        'storeg' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> X.vfields[op1];
                     // codes.rstoreg  then
                        'rstoreg' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> X.rfields[op1][]
                     // codes.xstore then
                        'xstore' -> exe;
                        (*('xstoreA',true,screen[])  -> thisObj.dump;*)
                        thisStack.rpop -> X[]; (* not used *)
                        (if true then
                            thisStack.vpop -> dinx;;
                            (thisStack.vpop ,op1 + dinx + 1) -> thisObj.assign
                         else
                            (* op1 = adr(rep)
                             * vpop = index in rep
                             * vpop = val to be stored *)
                            thisObj.rfields[op1][] -> R[];
                            thisStack.vpop -> dinx;
                            (thisStack.vpop ,dinx + 2) -> R.assign
                        if);
                        (*('xstoreB',true,screen[])  -> thisObj.dump;*)
                     // codes.xstoreg then
                        'xstoreg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> inx;
                        (if true (*inx = 0*) then 
                            X[] -> R[]
                         else
                            X.rfields[inx][] -> R[];
                        if);
                        thisStack.vpop -> dinx;
                        (thisStack.vpop,dinx + inx (*+ 2*)) -> R.assign
                     // codes.double then
                        'double' -> exe;
                        thisStack.vdub;
                     // codes.rdouble then
                        'rdouble' -> exe;
                        thisStack.rdub;
                     // codes.rpop then
                        'rpop' -> exe;
                        thisStack.rpop;
                     // codes.alloc then
                        'alloc' -> exel; op2 -> descInx; op1 -> isObj;
                        (* ('Alloc:',true,screen[]) -> thisObj.dump;*)
                        thisStack.rpop -> X[]; (* origin *)
                        &descs.OD[descInx].template[] -> callee[];
                        descInx -> callee.myDescInx;
                        newId -> callee.id;

                        (* '\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                         * ' lsc: ' -> puttext; glsc -> putint; newline; *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;

                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> Y[] -> callee.rPush; (* return *)
                        X[] -> callee.rpush;  (* origin *)
                        descs.OD[descInx].BC.allocE -> glsc;
                        callee[] -> thisStack[] -> thisObj[];
                        (if isObj = 1 then 
                            (*'object'->putline *)
                         else (*'activation' -> putline *)
                        if);
                        (Y[],thisObj[],X[],glsc,isObj=1) -> allocEvent
                     // codes.allocIndexed then
                        'allocIndexed' -> exel; op2 -> descInx; op1 -> isObj;
                        thisStack.rpop -> X[]; (* origin *)
                        thisStack.vpop -> dinx;
                        thisStack.vpop -> rangee;
                        (if true then
                            (rangee,dinx) -> descs.OD[descInx].template -> callee[];
                         else
                            &descs.OD[descInx].template[] -> callee[];
                        if);
                        (*('allocIndexed',true,screen[])  -> callee.dump;*)
                        descInx -> callee.myDescInx;
                        newId -> callee.id;

                        (*'\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                         ' lsc: ' -> puttext; glsc -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;

                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> Y[] -> callee.rPush; (* return *)
                        X[] -> callee.rpush;  (* origin *)
                        descs.OD[descInx].BC.allocE -> glsc;
                        callee[] -> thisStack[] -> thisObj[];
                        (if isObj = 1 then 
                            (*'object'->putline *)
                         else (*'activation' -> putline *)
                        if);
                        (Y[],thisObj[],X[],glsc,isObj=1) -> allocEvent
                     // codes.exeAlloc then
                        'exeAlloc' -> exel; op1 -> descInx;
                        (*'exeAlloc'->putline;*)
                        thisStack.rpop -> X[]; (* origin *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> thisObj.rPush; (* return *)
                        X[] -> thisObj.rpush;
                        thisObj[] -> thisStack[];
                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.allocE -> glsc;
                        (if false then
                            (* called if this object has a super
                             * reconsider if/when this is an event
                             * Also the isObject arg should be defined in the code
                             * is currentli 0 (zero)
                             *)
                            (thisObj[],thisObj[],X[],glsc,false) -> allocEvent
                        if)
                     // codes.newVrep then
                        'newVrep' -> exe;
                        (thisStack.vpop,2) -> descs.OD[1].template -> thisStack.rpush;
                     // codes.send then 
                        'send' -> exel; op1 -> descInx;
                        &descs.OD[descInx].template[] -> callee[];
                        newId -> callee.id;
                        descInx -> callee.myDescInx;

                        (* save return *)
                        (if true then
                            (* '\nsend: ' -> puttext;
                             thisCode.descInx -> putint; 
                             ' ' -> put; glsc -> putint; newline;*)
                            (thisCode.descInx,glsc) -> thisObj.saveReturn
                         else
                            glsc -> thisObj.lsc;
                        if);
                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> callee.rPush;
                        callee[] -> thisObj[];
                        descs.OD[descInx].BC.procE -> glsc
                     // codes.sendv then
                        'sendv ' -> exel;
                        op1 -> dinx;
                        thisObj.rpop -> X[];
                        (* ('sendv:',true,screen[]) -> X.dump;*)
                        (X.myObjDesc).vdtTable[dinx] -> descInx;
                        (* descInx -> out.putint; out.newline; *)
                        (* copy of send below *)
                        &descs.OD[descInx].template[] -> callee[];
                        newId -> callee.id;
                        descInx -> callee.myDescInx;
                        (* save return *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        descs.OD[descInx].bc[] -> thisCode[];
                        (*callee[] -> thisStack.rpush;*)
                        thisObj[] -> Y[] -> callee.rPush;
                        X[] -> callee.rpush;
                        callee[] -> thisStack[]  -> thisObj[];
                        descs.OD[descInx].BC.allocE -> glsc;
                        (* we need to distinguish if we generate an object or
                         * an activation. For now we assume an activation
                         *)
                        (Y[],thisObj[],X[],glsc,false(*isObj=1*)) -> allocEvent
                     // codes.mvStack then
                        'mvStack'-> exe;
                        (*('mvstackA',true,screen[])  -> thisObj.dump;*)
                        thisObj[] -> thisStack[];
                        (*('mvstackB',true,screen[])  -> thisObj.dump;*)
                     // codes.call then
                        'call'-> exel; op1asChar -> inx; ' ' -> out.put;
                        ('call',true,out[])  -> thisObj.dump;
                        thisStack.rpop -> callee[];
                        (if callee[] = none then 'callee is none'->putline if);
                        callee.myId -> out.puttext; 
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;

                        (if callee.rstackIsEmpty then 
                            (':first>',false,out[])  -> thisObj.dump;
                            thisObj[] -> Y[] -> callee.rpush;
                            callee[] -> thisObj[];
                            thisObj.myCode -> thisCode[];
                            thisObj.mySuperCode -> thisCode[];
                            (if inx
                             // 'N' then
                                thisObj.myCode -> thisCode[];
                                thisCode.enterE -> glsc
                             // 'D' then
                                thisCode.doE -> glsc
                             // 'X' then
                                thisCode.exitE -> glsc
                             else
                                ' ? ' -> out.puttext; inx -> out.put
                            if);
                            (if glsc = 0 then  (* clumsy *)
                                thisObj[] -> X[];
                                thisObj.rpop -> thisObj[] -> thisStack[];
                                thisObj.restoreReturn -> (descInx,glsc);
                                descs.OD[descInx].bc[] -> thisCode[];
                                X[] -> thisStack.rpush
                            if);
                            (if inx
                             // 'N' then (*'enter:'->puttext*)
                             // 'D' then (*'do:'->puttext;*)
                                ' before:doEvent: ' -> out.puttext;
                                thisObj.myId -> out.puttext;
                                (Y[],thisObj[],thisObj.myOrigin,glsc) -> doEvent  
                             // 'X' then (*'exit:'-> puttext*)
                            if);
                         else (* resume *) 
                            (':resume>',false,out[]) -> thisObj.dump;
                            (thisObj[],callee[],callee.myOrigin,glsc) -> resumeEvent;
                            thisObj[] -> X[];
                            callee.rstack[1][] -> thisObj[] -> thisStack[];
                            X[] -> callee.rstack[1][];
                            thisObj.myCode -> thisCode[]; (* use lscStack *)
                            thisObj.lsc -> glsc;
                        if);                        
                     // codes.susp then
                        'susp'-> exel;
                        thisStack.rpop -> callee[]; (* returnee *)
                        glsc -> thisObj.lsc;
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> X[];
                        callee.rstack[1][] -> thisObj[] -> thisStack[];
                        X[] -> callee.rstack[1][];
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (thisObj[],callee[],thisObj.myOrigin,glsc) -> suspendEvent
                     // codes.doExit then
                        'doExit' -> exe;
                        thisObj.rstackTop -> thisStack[];
                     // codes.rtn then
                        'rtn from:' -> exel; op1asChar -> inx;
                        thisObj.myId -> out.puttext;
                        (*('rtn',true,out[])  -> thisObj.dump;*)
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[];
                        ' to: ' -> out.puttext; thisObj.myId -> out.puttext;
                        thisObj.restoreReturn -> (descInx,glsc);
                        (*'\nrtn: ' -> puttext; descInx -> putint; ' lsc: ' -> puttext;
                         glsc -> putint; newline;*)
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (*'rtn:' -> puttext;*)
                        (if inx = 'D' then
                            (thisObj[],X[],X.myOrigin,glsc) -> rtnEvent
                        if)
                     // codes.rtnC then
                        'rtnC' -> exel;

                        (if true then
                            thisObj.restoreReturn -> (descInx,glsc);
                            (*'\nrtnC: ' -> puttext; descInx -> putint; 
                             * ' ' -> put; gLsc -> putint; newline;*)
                            descs.OD[descInx].bc[] -> thisCode[]
                         else
                            thisObj.vpop -> descInx; newline; descInx -> putint; newline;
                            descs.OD[descInx].bc[] -> thisCode[];
                            thisObj.vpop -> glsc;
                        if);
                        (*'\nend rtnX' ->putline*)
                     // codes.rtnExit then 
                        (* could be rtn, except that thisStack is already updated *)
                        'rtnExit' -> exe;
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[]; (* !*)
                        (if true then
                            thisObj.restoreReturn -> (descInx,glsc);
                            descs.OD[descInx].bc[] -> thisCode[]
                         else
                            thisObj.lsc -> glsc;
                            thisObj.myCode -> thisCode[]
                        if);
                        X[] -> thisStack.rpush;
                        (*(thisObj[],X[],X.myOrigin,glsc) -> rtnEvent;*)
                     // codes.innerx then
                        'inner' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (*'\ninner: ' -> puttext; thisCode.descInx -> putint;
                             ' ' -> put; glsc -> putint; newline;*)
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if)
                     // codes.innerExit then
                        'innerExit' -> exe;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; ' ' -> out.put;
                        (if descInx > 0 then
                            (if true then
                                (thisCode.descInx,glsc) -> thisObj.saveReturn
                             else
                                glsc -> thisObj.vpush;
                                thisCode.descId -> thisObj.vpush;
                            if);
                            
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.exitE -> glsc
                        if)
                     // codes.rtnInner then
                        'rtnInner' -> exel;
                        thisObj.restoreReturn -> (descInx,glsc);
                        (*'\nreturnInner: ' -> puttext;
                         descInx -> putint; ' ' -> put; glsc -> putint; newline;*)
                        ' to: ' -> out.puttext; descInx -> out.putint; out.newline;
                        descs.OD[descInx].BC[] -> thisCode[]
                     // codes.doSuper then
                        'doSuper' -> exel; (* perhaps just a jump? *)
                        op1 -> descInx;
                        (*'doSuper: ' -> puttext; descInx -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        (* thisObj shall not be pushed since we return from super *)
                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.enterE -> glsc; 
                     // codes.stop then
                        'stop' -> exe; out.newline;
                        (* leave Loop*)
                        true -> doTerminate
                     // codes.prim then
                        '%prim' -> exe;
                        (if op1
                         // 1 then
                            thisObj.vpop -> put
                         // 3 then
                            thisStack.rpop -> R[];
                            1 -> R.get -> thisStack.vpush; 
                         // 4 then
                            thisStack.rpop -> R[];
                            (thisStack.vpop,1) -> R.assign
                         // 5 then (* range *)
                            thisStack.rpop -> R[];
                            2 -> R.get -> thisStack.vpush;
                         // 7 then 
                            thisObj.rpop -> X[];
                            (*(':sendMgs:text',true,screen[]) -> X.dump;*)
                            thisObj.vpop -> msgId;
                            thisObj.vpop -> handle;
                            thisObj.vpop -> serverId;
                            (serverId,handle,msgId,X[]) -> sendMsg;
                        if);
                     // codes.jmp then
                        'jmp' -> exe;
                        op2 -> glsc
                     // codes.jmpFalse then
                        'jmpFalse' -> exe;
                        (if thisStack.vpop = 0 then
                            op2 -> glsc
                         else
                            op2
                        if)                   
                     // codes.jmpTrue then
                        'jmpTrue' -> exe;
                        (if thisStack.vpop <> 0 then
                            op2 -> glsc
                         else
                            op2
                        if)                   
                     // codes.jmpGT then
                        'jmpGT' -> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if top2 > top1 then
                            op2 -> glsc
                         else
                            op2
                        if)                   
                     // codes.pushText then
                        'pushText' -> exe; 
                        op1 -> inx; 
                        (thisObj.myObjDesc).literals[inx] 
                          -> mkTextObject
                        (# i: @integer
                        do i + 1 -> i; 
                           (thisObj.myObjDesc).literals[inx+i] -> ch
                        #) -> X[];
                        (* OBS! we use the Text-object as origin of itself;
                         * this is wrong, origin should be the LIB-object
                         *)
                        (if true (* generate allocEvent for &text *) then
                            (* allocEvent calles myLsc, 
                             * which assume that glsc is on the lscStack
                             *)
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (thisObj[],X[],X[],glsc,true) -> allocEvent;
                            thisObj.restoreReturn -> (descInx,glsc);
                            (thisObj[],X[],X[],glsc) -> rtnEvent
                        if)
                     // codes.plus then
                        '+'-> exe; 
                        thisStack.vpop + thisStack.vpop -> thisStack.vpush;
                     // codes.minus then
                        '-'-> exe; 
                        (# l,r: @integer do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r - l -> thisStack.vpush  
                        #);
                     // codes.uminus then
                        'u-' -> exe;
                        - thisstack.vpop -> thisStack.vpush  
                     // codes.mult then
                        '*'-> exe;
                        thisStack.vpop * thisStack.vpop -> thisStack.vpush
                     // codes.modd then
                        'mod' -> exe; 
                        (# l,r: @integer do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r mod l -> thisStack.vpush  
                        #);
                     // codes.idiv then
                        'div' -> exe; 
                        (# l,r: @integer do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r div l -> thisStack.vpush  
                        #);
                     // codes.eq then
                        '='-> exe;
                        (if thisStack.vpop = thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.ne then
                        '<>'-> exe;
                        (if thisStack.vpop <> thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.lt then
                        '<'-> exe;
                        (if thisStack.vpop > thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.le then
                        '<='-> exe;
                        (if thisStack.vpop >= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.gt then
                        '>' -> exe;
                        (if thisStack.vpop < thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.ge then
                        '>='-> exe;
                        (if thisStack.vpop <= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.andd then
                        'and' -> exe;
                        (if (thisstack.vpop = 1) and (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.orr then
                        'or' -> exe;
                        (if (thisStack.vpop = 1) or (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.saveBETAworld then
                        'saveBETAworld' -> exe; 
                        thisStack.rpop -> eventProcessor.rFields[1][]
                     // codes.mkStrucRef then
                        'mkStrucRef' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> descInx;
                       (* ('mkStrucRef',true,screen[]) -> X.dump;*)
                        (X[],descinx,false) -> mkStrucRefObj
                     // codes.mkVirtualStrucRef then
                        'mkVirtualStrucRef' -> exe;
                        (thisObj.rpop,op1,true) -> mkStrucRefObj
                     // codes.allocFromStrucRefObj then
                        'allocFromStrucRefObj' -> exe;
                        thisStack.rpop -> allocFromStrucRefObj                        
                     else
                        5 -> fatalError
                        (#
                        do 'Op-code: ' -> puttext; thisCode.B[glsc] -> putint;
                           newline;
                           thisCode.B[glsc] -> out.putint; glsc+1 -> glsc;
                        #)
                    if);
                    (if (glsc <= thisCode.top) and not doTerminate then
                        restart Loop 
                    if);

                    false -> isRunning;
                    (if false then
                        (if FS.trace then '\nFS.close'->putline if);
                        FS.close; 
                        (if MS.trace then 'MS.close'->putline if);
                        true ->  MS.close;
                        (if GS.trace then 'GS.close'->putline if);
                        GS.close;
                        mouseListener[] -> kill;
                        done;
                    if);
                    (* 'suspend'->putline;*)
                    suspend;
                    (* 'reactivate betaVM'->putline;*)
                    false -> doTerminate;
                    (if handleEvent then 
                        restart Loop 
                     else
                        restart main
                    if)
                 #);
            #)
       #)
  #)
