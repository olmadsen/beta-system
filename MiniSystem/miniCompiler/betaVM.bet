ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE 'objectImage';
INCLUDE '../miniServices/Service';
---systemlib:attributes---
betaVM:
  (# init:<
       (#
       do ('../../../../miniServices/FileService',5123) -> FS.init;
          ('../../../../miniServices/GUIService',5124) -> GS.init;
          5125 -> MS.openSocket
       #);
     VMevent: 
       (# caller,thisObj,org: ^ObjDesc.template; bcPos: @integer;
          doPause: (# do (if false then pause else suspend if)#);

       enter(caller[],thisObj[],org[],bcPos)
       do (if thisObj[] <> none then 
              inner;
              thisObj.myDescInx -> out.putint; ' '-> out.put;
              thisObj.id -> out.putint; out.newline
          if)
       #);
     set:< (# do inner #); (* ad hoc *)

     startEvent:< VMevent;
     allocEvent:< VMevent(# isObj: @boolean enter isObj do inner ; #);
     doEvent:< VMevent;
     rtnEvent:< VMevent;
     resumeEvent:< VMevent;
     suspendEvent:< VMevent;
     breakEvent:<  VMevent;
     
     thisComp, (* not used? *)
     thisObj,
     thisStack: ^ObjDesc.template;
     
     thisCode: ^ByteCode; 
     
     glsc: @integer;
     
     codes: @ ByteCodes;
     
     fatalError:
       (# errNo: @integer
       enter errNo
       do errNo -> thisObj.fatalError
          (#
          do 'LSC: ' -> puttext; glsc -> putint; newline;          
             inner fatalError
          #)
       #);
     
     out: ^Stream;
     
     FS,GS,MS: @Service;
     mouseListener:  @ | system
       (# T: ^text
       do 'Starting mouseListener:'->putline;
          cycle(#do MS.receive -> T[]; 'BETA:mouse: ' -> puttext; T[] -> putline;#)
       #);
     
     reActivate: (# do (if false then execute else execute[] -> fork if) #);
     
     execute: @ | system
       (# init:
            (#
            enter(descs[],descInx,out[])
            #);
          descs: ^RuntimeDescriptors;
          descInx: @integer;
          isObj: @integer;
          newid: @ (# id: @integer do id+1 -> id exit 1000+id #);
          obj: ^ObjDesc.Template;
          break:
            (# descNo,bcPos: @integer
            enter(descNo,bcPos)
            do 'VM:breakIn: ' -> puttext; descNo -> putint; 
               ' at: ' -> puttext; bcPos -> putint; newline;
               'OD.range: ' -> puttext; descs.OD.range -> putint; newline;

               (if descs.OD[descNo][] = none then
                   'bc none ' -> putline
                else 
                   bcPos -> descs.OD[descNo].bc.setBreak
               if)
            #);
          
          sendMsg:
            (# serverId,handle,msgId: @integer; msg: ^objDesc.template; 
               T: @text
            enter(serverId,handle,msgId,msg[])
            do 'SendMsg: ' -> puttext; serverId->putint; ' ' -> put; 
               handle -> putint; ' '-> put;
               msgId -> putint; ' vields[1]=' -> puttext; 
               msg.vfields[1] -> putint; newline;
               (for i: msg.vfields[1] repeat
                    msg.vfields[i+2] -> T.put; 
               for);
               '"'->put; 
               T[] -> puttext;  '"'->put;
               newline;
               (if serverId
                // 1 then
                   (handle,msgId,T[]) -> sendFileMsg
                // 2 then
                   (handle,msgId,T[]) -> sendGuiMsg
               if)
            #);
          doReceive: (# exit true #);
          sendFileMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do 'sendFileMsg: '-> puttext;
               (if msgId
                // 1 then 
                   1 -> FS.mkCommand(#do msg[] -> cmd.puttext #);
                   'after:send:'->puttext;
                   (if doReceive then
                       FS.receive -> h[];
                       ':after receive:'->puttext;
                       (1,h.length-1) -> h.sub -> h[];
                       0 -> h.setpos; h.getint -> thisStack.vPush
                    else
                       1 -> thisStack.vpush
                   if)
                // 2 then
                   2 -> FS.mkCommand(#do handle -> cmd.putint; ' '  -> cmd.put;
                                       msg[] -> cmd.puttext
                                    #);
                   (if doReceive then FS.receive -> h[] if)
                // 3 then
                   3 -> FS.mkCommand(# do handle -> cmd.putint; #);
                   (if doReceive then FS.receive -> h[] if)
               if);
               'Send done: '->puttext; h[] -> putline
            #);
          sendGuiMsg:
             (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
             do 'sendGuiMsg: '-> puttext; msgId->putint; ' ' -> put;
                msg[] -> putline;
               (if msgId
                // 1 then
                   1->GS.mkCommand(# do msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   'BETA:received: ' -> puttext; h[] -> putline;
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush;
                // 2 then
                   2->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 3 then
                    3->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 4 then
                   4->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                   
               if)
             #);
          dumpD: 
            (#
            do 'descs:' -> putline;
               (for i: descs.OD.range repeat
                    i -> putint; ':' -> put; 
                    (if descs.OD[i][] = none then ' none' -> putline if);
               for);
               newline
            #);
          isRunning,doTerminate: @Boolean;
          terminate: (# do true -> doTerminate #)
       enter(descs[],descInx,out[])
       do main:
            (#
            do true -> isRunning; (*screen[] -> out[];*)
               false -> doTerminate;
               (if descs.OD[1][] = none then
                   'Allocating dummy template in OD[1] for repetitions'
                     -> putline;
                   &ObjDesc[] -> descs.OD[1][];
                   ('ValueRep',1,0,out[]) -> descs.OD[1].init;
               if);
               &descs.OD[descInx].template[] -> thisComp[] -> thisObj[] -> thisStack[];
               descs.OD[descInx].bc[] -> thisCode[];
               newId -> thisObj.id;
               descInx -> thisObj.myDescInx;
               
               mouseListener[] -> fork;
               pause; 
               'EXECUTE: ' -> puttext; descs.OD[descInx].name[] -> putline;
               'TextDescNo: ' -> puttext; descs.textDescNo -> putint; newline;
               pause; (* apparently we need 2 pause to be sure that mouseListener 
                       * has been started before the VM suspends
                       *)
               1 -> glsc;
               (none,thisObj[],none,glsc) -> startEvent;
               Loop:
                 (# exe: 
                      (# T: ^text 
                      enter T[] 
                      do inner;
                         T[] -> out.puttext; ' '-> out.put; glsc+1 -> glsc; 
                      #);
                    exel: exe(# do out.newline #);
                    op1: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.putint; ' ' -> out.put; 
                         glsc+1 -> glsc
                      exit arg
                      #);
                    op2: 
                      (# arg: @integer
                      do thisCode.B[glsc] * 255 + thisCode.B[glsc+1] -> arg -> out.putint; ' ' -> out.put; 
                         glsc + 2 -> glsc
                      exit arg
                      #);
                    descInx,dinx,rangee,inx,length,serverId,handle,msgId: @integer;
                    callee,X,Y: ^ObjDesc.template;
                    R: ^ObjDesc.BasicTemplate;
                    top1,top2: @integer
                 do (if glsc -> (thisObj.myCode).isBreak then
                        (thisObj.myDyn,thisObj[],thisObj.myOrigin,glsc) 
                          -> breakEvent
                    if);
                    (if thisCode.B[glsc]
                     // codes.pushc then
                        'pushc' -> exe;
                        op1 -> thisStack.vpush   
                     // codes.pushc2 then
                        'pushc2' -> exe;
                        op2 -> thisStack.vpush                           
                     // codes.pushthis then
                        'pushthis' -> exe;
                        thisObj[] -> thisStack.rpush;
                     // codes.push then
                        'push' -> exe;
                        thisObj.vfields[op1] -> thisStack.vpush;
                     // codes.rpush then
                        'rpush' -> exe;
                        thisObj.rfields[op1][] -> X[] -> thisStack.rpush;
                        (*(':rpush',true,screen[]) -> X.dump;*)
                        (*(if X[]<> none then
                            ('rpush:',true,screen[]) -> X.dump;
                        if)*)
                     // codes.pushg then
                        'pushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError(#do leave loop #) if);
                        X.vfields[op1] -> thisStack.vpush;
                     // codes.rpushg then
                        'rpushg' -> exe;

                        thisStack.rpop -> X[];
                        (*('rpushg:',true,screen[]) -> X.dump;*)
                        (if X[] = none then
                            3 -> fatalError(#do leave loop #);
                         else
                            X.myName -> out.puttext; ';'->out.put;
                        if);
                        X.rfields[op1][] -> Y[] -> thisStack.rpush;
                        (if Y[] = none then
                            ' none ' -> out.puttext
                         else
                            Y.myName -> out.puttext; ';'->out.put;
                        if)
                        
                     // codes.xpush then
                        'xpush' -> exe;
                        thisObj.rfields[op1][] -> R[];
                        thisStack.vpop + 2 -> R.get -> thisStack.vpush                 
                     // codes.xpushg then
                        'xpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> inx;
                        (if true (*inx = 0*) then
                            X[] -> R[]
                         else                            
                            X.rfields[inx][] -> R[];
                        if);
                        (*'inx: ' -> puttext; inx -> putint; newline;*)
                        (*('xpushg:',true,screen[]) -> X.dump;*)
                        thisStack.vpop + inx(* + 2*) -> R.get -> thisStack.vpush
                     // codes.rstore  then
                        'rstore' -> exe; 
                        thisStack.rpop -> X[]; (* if multiple assignment of X, 
                                                * violation error happens
                                                * compiler error?
                                                *)
                        (*(if X[]<> none then
                            ('rstore:',true,screen[]) -> X.dump;
                        if);*)                                           
                        
                        X[] -> thisObj.rfields[op1][]; 
                     // codes.store  then
                        'store' -> exe;
                        thisStack.vpop -> thisObj.vfields[op1];
                     // codes.storeg  then
                        'storeg' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> X.vfields[op1];
                     // codes.rstoreg  then
                        'rstoreg' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> X.rfields[op1][]
                     // codes.xstore then
                        'xstore' -> exe;
                        thisObj.rfields[op1][] -> R[];
                        thisStack.vpop -> dinx;
                        (thisStack.vpop ,dinx + 2) -> R.assign
                     // codes.xstoreg then
                        'xstoreg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> inx;
                        (if true (*inx = 0*) then 
                            X[] -> R[]
                         else
                            X.rfields[inx][] -> R[];
                        if);
                        thisStack.vpop -> dinx;
                        (thisStack.vpop,dinx + inx (*+ 2*)) -> R.assign
                     // codes.double then
                        'double' -> exe;
                        thisStack.vdub;
                     // codes.rdouble then
                        'rdouble' -> exe;
                        thisStack.rdub;
                     // codes.rpop then
                        'rpop' -> exe;
                        thisStack.rpop;
                     // codes.alloc then
                        'alloc' -> exel; op1 -> descInx; op1 -> isObj;
                        thisStack.rpop -> X[]; (* origin *)
                        &descs.OD[descInx].template[] -> callee[];
                        descInx -> callee.myDescInx;
                        newId -> callee.id;

                        (*'\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                         ' lsc: ' -> puttext; glsc -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;

                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> Y[] -> callee.rPush; (* return *)
                        X[] -> callee.rpush;  (* origin *)
                        descs.OD[descInx].BC.allocE -> glsc;
                        callee[] -> thisStack[] -> thisObj[];
                        (if isObj = 1 then 
                            (*'object'->putline *)
                         else (*'activation' -> putline *)
                        if);
                        (Y[],thisObj[],X[],glsc,isObj=1) -> allocEvent
                     // codes.allocIndexed then
                        'allocIndexed' -> exel; op1 -> descInx; op1 -> isObj;
                        thisStack.rpop -> X[]; (* origin *)
                        'allocIndexed: '->puttext;
                        thisStack.vpop -> dinx -> putint; newline;
                        thisStack.vpop -> rangee -> putint;  ','->put;
                        (if true then
                            (rangee,dinx) -> descs.OD[descInx].template -> callee[];
                         else
                            &descs.OD[descInx].template[] -> callee[];
                        if);
                       (* ('allocIndexed',true,screen[])  -> callee.dump;*)
                        descInx -> callee.myDescInx;
                        newId -> callee.id;

                        (*'\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                         ' lsc: ' -> puttext; glsc -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;

                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> Y[] -> callee.rPush; (* return *)
                        X[] -> callee.rpush;  (* origin *)
                        descs.OD[descInx].BC.allocE -> glsc;
                        callee[] -> thisStack[] -> thisObj[];
                        (if isObj = 1 then 
                            (*'object'->putline *)
                         else (*'activation' -> putline *)
                        if);
                        (Y[],thisObj[],X[],glsc,isObj=1) -> allocEvent
                     // codes.exeAlloc then
                        'exeAlloc' -> exel; op1 -> descInx;
                        (*'exeAlloc'->putline;*)
                        thisStack.rpop -> X[]; (* origin *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> thisObj.rPush; (* return *)
                        X[] -> thisObj.rpush;
                        thisObj[] -> thisStack[];
                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.allocE -> glsc;
                        (if false then
                            (* called if this object has a super
                             * reconsider if/when this is an event
                             * Also the isObject arg should be defined in the code
                             * is currentli 0 (zero)
                             *)
                            (thisObj[],thisObj[],X[],glsc,false) -> allocEvent
                        if)
                     // codes.newVrep then
                        'newVrep' -> exe;
                        (thisStack.vpop,2) -> descs.OD[1].template -> thisStack.rpush;
                     // codes.send then 
                        'send' -> exel; op1 -> descInx;
                        &descs.OD[descInx].template[] -> callee[];
                        newId -> callee.id;
                        descInx -> callee.myDescInx;

                        (* save return *)
                        (if true then
                            (* '\nsend: ' -> puttext;
                             thisCode.descInx -> putint; 
                             ' ' -> put; glsc -> putint; newline;*)
                            (thisCode.descInx,glsc) -> thisObj.saveReturn
                         else
                            glsc -> thisObj.lsc;
                        if);
                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> callee.rPush;
                        callee[] -> thisObj[];
                        descs.OD[descInx].BC.procE -> glsc
                     // codes.sendv then
                        'sendv ' -> exel;
                        op1 -> dinx;
                        thisObj.rpop -> X[];
                        (* ('sendv:',true,screen[]) -> X.dump;*)
                        (X.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline;
                        (* copy of send below *)
                        &descs.OD[descInx].template[] -> callee[];
                        newId -> callee.id;
                        descInx -> callee.myDescInx;
                        (* save return *)
                        (if true then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn
                         else
                            glsc -> thisObj.lsc;
                        if);
                        descs.OD[descInx].bc[] -> thisCode[];
                        (if true then 
                            (*callee[] -> thisStack.rpush;*)
                            thisObj[] -> Y[] -> callee.rPush;
                            X[] -> callee.rpush;
                            callee[] -> thisStack[]  -> thisObj[];
                            descs.OD[descInx].BC.allocE -> glsc;
                         else
                            thisObj[] -> callee.rPush;
                            callee[] -> thisStack[] -> thisObj[];
                            descs.OD[descInx].BC.procE -> glsc
                        if);
                        (Y[],thisObj[],X[],glsc,isObj=1) -> allocEvent                        
                     // codes.mvStack then
                        'mvStack'-> exe;
                        thisObj[] -> thisStack[];
                     // codes.call then
                        'call'-> exel; op1 -> inx; inx -> out.put; 
                        thisStack.rpop -> callee[];
                        callee.myId -> out.puttext; '.'-> out.put;
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;

                        (if callee.rstackIsEmpty then 
                            (':first>',false,out[])  -> thisObj.dump;
                            thisObj[] -> Y[] -> callee.rpush;
                            callee[] -> thisObj[];
                            thisObj.myCode -> thisCode[];
                            thisObj.mySuperCode -> thisCode[];
                            (if inx
                             // 'N' then
                                thisObj.myCode -> thisCode[];
                                thisCode.enterE -> glsc
                             // 'D' then
                                thisCode.doE -> glsc
                             // 'X' then
                                thisCode.exitE -> glsc
                             else
                                ' ? ' -> out.puttext; inx -> out.put
                            if);
                            (if glsc = 0 then  (* clumsy *)
                                thisObj[] -> X[];
                                thisObj.rpop -> thisObj[] -> thisStack[];
                                thisObj.restoreReturn -> (descInx,glsc);
                                descs.OD[descInx].bc[] -> thisCode[];
                                X[] -> thisStack.rpush
                            if);
                            (if inx
                             // 'N' then (*'enter:'->puttext*)
                             // 'D' then (*'do:'->puttext;*)
                                (Y[],thisObj[],thisObj.myOrigin,glsc) -> doEvent  
                             // 'X' then (*'exit:'-> puttext*)
                            if)
                         else (* resume *) 
                            (':resume>',false,out[]) -> thisObj.dump;
                            (thisObj[],callee[],callee.myOrigin,glsc) -> resumeEvent;
                            thisObj[] -> X[];
                            callee.rstack[1][] -> thisObj[] -> thisStack[];
                            X[] -> callee.rstack[1][];
                            thisObj.myCode -> thisCode[]; (* use lscStack *)
                            thisObj.lsc -> glsc;
                        if);                        
                     // codes.susp then
                        'susp'-> exel;
                        thisStack.rpop -> callee[]; (* returnee *)
                        glsc -> thisObj.lsc;
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> X[];
                        callee.rstack[1][] -> thisObj[] -> thisStack[];
                        X[] -> callee.rstack[1][];
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (thisObj[],callee[],thisObj.myOrigin,glsc) -> suspendEvent
                     // codes.doExit then
                        'doExit' -> exe;
                        thisObj.rstackTop -> thisStack[];
                     // codes.rtn then
                        'rtn from:' -> exel; thisObj.myId -> out.puttext;
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[];
                        ' to: ' -> out.puttext; thisObj.myId -> out.puttext;
                        thisObj.restoreReturn -> (descInx,glsc);
                        (*'\nrtn: ' -> puttext; descInx -> putint; ' lsc: ' -> puttext;
                         glsc -> putint; newline;*)
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (*'rtn:' -> puttext;*)
                        (if true then
                            (thisObj[],X[],X.myOrigin,glsc) -> rtnEvent
                        if)
                     // codes.rtnC then
                        'rtnC' -> exel;

                        (if true then
                            thisObj.restoreReturn -> (descInx,glsc);
                            (*'\nrtnC: ' -> puttext; descInx -> putint; 
                             * ' ' -> put; gLsc -> putint; newline;*)
                            descs.OD[descInx].bc[] -> thisCode[]
                         else
                            thisObj.vpop -> descInx; newline; descInx -> putint; newline;
                            descs.OD[descInx].bc[] -> thisCode[];
                            thisObj.vpop -> glsc;
                        if);
                        (*'\nend rtnX' ->putline*)
                     // codes.rtnExit then 
                        (* could be rtn, except that thisStack is already updated *)
                        (*'rtnExit' -> exe;*)
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[]; (* !*)
                        (if true then
                            thisObj.restoreReturn -> (descInx,glsc);
                            descs.OD[descInx].bc[] -> thisCode[]
                         else
                            thisObj.lsc -> glsc;
                            thisObj.myCode -> thisCode[]
                        if);
                        X[] -> thisStack.rpush;
                        (thisObj[],X[],X.myOrigin,glsc) -> rtnEvent;
                     // codes.innerx then
                        'inner' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline; 
                        (if descInx > 0 then
                            (if true then
                                (thisCode.descInx,glsc) -> thisObj.saveReturn;
                                (*'\ninner: ' -> puttext; thisCode.descInx -> putint;
                                 ' ' -> put; glsc -> putint; newline;*)
                            if);                      
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if)
                     // codes.innerExit then
                        'innerExit' -> exe;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; ' ' -> out.put;
                        (if descInx > 0 then
                            (if true then
                                (thisCode.descInx,glsc) -> thisObj.saveReturn
                             else
                                glsc -> thisObj.vpush;
                                thisCode.descId -> thisObj.vpush;
                            if);
                            
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.exitE -> glsc
                        if)
                     // codes.rtnInner then
                        'rtnInner' -> exel;
                        (if true then
                            thisObj.restoreReturn -> (descInx,glsc);
                            (*'\nreturnInner: ' -> puttext;
                             descInx -> putint; ' ' -> put; glsc -> putint; newline;*)
                         else
                            thisObj.vpop -> glsc;
                            thisObj.vpop -> descInx;
                        if);
                        ' to: ' -> out.puttext; descInx -> out.putint; out.newline;
                        descs.OD[descInx].BC[] -> thisCode[]
                     // codes.doSuper then
                        'doSuper' -> exel; (* perhaps just a jump? *)
                        op1 -> descInx;
                        (if true then
                            (*'doSuper: ' -> puttext; descInx -> putint; newline;*)
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (* thisObj shall not be pushed since we return from super *)
                         else
                            thisObj.myDescInx -> thisObj.vpush;
                            glsc -> thisObj.vpush;
                        if);
                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.enterE -> glsc; 
                     // codes.stop then
                        'stop' -> exe; (*out.newline;*)
                        leave Loop
                     // codes.prim then
                        '%prim' -> exe;
                        (if op1
                         // 1 then
                            thisObj.vpop -> put
                         // 3 then
                            thisStack.rpop -> R[];
                            1 -> R.get -> thisStack.vpush; 
                         // 4 then
                            thisStack.rpop -> R[];
                            (thisStack.vpop,1) -> R.assign
                         // 5 then (* range *)
                            thisStack.rpop -> R[];
                            2 -> R.get -> thisStack.vpush;
                         // 7 then 
                            'sendMsg: ' -> puttext;
                            thisObj.rpop -> X[];
                           (* (':sendMgs:text',true,screen[]) -> X.dump;*)
                            thisObj.vpop -> msgId;
                            thisObj.vpop -> handle;
                            thisObj.vpop -> serverId;
                            (serverId,handle,msgId,X[]) -> sendMsg
                        if);
                     // codes.jmp then
                        'jmp' -> exe;
                        op2 -> glsc
                     // codes.jmpFalse then
                        'jmpFalse' -> exe;
                        (if thisStack.vpop = 0 then
                            op2 -> glsc
                         else
                            op2
                        if)                   
                     // codes.jmpTrue then
                        'jmpTrue' -> exe;
                        (if thisStack.vpop <> 0 then
                            op2 -> glsc
                         else
                            op2
                        if)                   
                     // codes.jmpGT then
                        'jmpGT' -> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if top2 > top1 then
                            op2 -> glsc
                         else
                            op2
                        if)                   
                     // codes.pushText then
                        'pushText' -> exe; 
                        op1 -> inx; 
                        (thisObj.myObjDesc).literals[inx] -> length;
                        (*'\nPushText: '  -> puttext; inx -> putint;  ' ' -> put;
                         length -> putint; ' ' -> put;*)
                        (if true then
                            (length+1,3) -> descs.OD[descs.textDescNo].template -> X[] -> thisStack.rpush;
                            length -> X.vfields[1]; (* define pos
                                                     * this is a hardcoded index, 
                                                     * should be a parameter *)
                            (for i: length  repeat
                                 (thisObj.myObjDesc).literals[inx+i] -> X.vfields[i + 3] ;
                                 (*('pushText',true,screen[]) -> X.dump*)
                                 (* -> putint; ' ' -> put; *)
                            for);
                            
                         else
                            (* new repetition *)
                            (length,2) -> descs.OD[1].template -> R[] -> thisStack.rpush;
                            length -> R.vfields[1]; (* define index *)
                            (for i: length  repeat
                                 (thisObj.myObjDesc).literals[inx+i] -> R.vfields[i + 2] 
                                 (* -> putint; ' ' -> put; *)
                            for);
                        if)
                       (* '--' -> putline *)
                     // codes.plus then
                        '+'-> exe; 
                        thisStack.vpop + thisStack.vpop -> thisStack.vpush;
                     // codes.minus then
                        '-'-> exe; 
                        (# l,r: @integer do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r - l -> thisStack.vpush  
                        #);
                     // codes.uminus then
                        'u-' -> exe;
                        - thisstack.vpop -> thisStack.vpush  
                     // codes.mult then
                        '*'-> exe;
                        thisStack.vpop * thisStack.vpop -> thisStack.vpush
                     // codes.modd then
                        'mod' -> exe; 
                        (# l,r: @integer do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r mod l -> thisStack.vpush  
                        #);
                     // codes.idiv then
                        'div' -> exe; 
                        (# l,r: @integer do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r div l -> thisStack.vpush  
                        #);
                     // codes.eq then
                        '='-> exe;
                        (if thisStack.vpop = thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.ne then
                        '<>'-> exe;
                        (if thisStack.vpop <> thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.lt then
                        '<'-> exe;
                        (if thisStack.vpop > thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.le then
                        '<='-> exe;
                        (if thisStack.vpop >= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.gt then
                        '>' -> exe;
                        (if thisStack.vpop < thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.ge then
                        '>='-> exe;
                        (if thisStack.vpop <= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.andd then
                        'and' -> exe;
                        (if (thisstack.vpop = 1) and (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.orr then
                        'or' -> exe;
                        (if (thisStack.vpop = 1) or (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     else
                        5 -> fatalError
                        (#
                        do 'Op-code: ' -> puttext; thisCode.B[glsc] -> putint;
                           newline;
                           thisCode.B[glsc] -> out.putint; glsc+1 -> glsc;
                        #)
                    if);
                    (if (glsc <= thisCode.top) and not doTerminate then
                        restart Loop 
                    if)
                 #);
               false -> isRunning;
               '\nFS.close'->putline;
               FS.close; 
               'MS.close'->putline;
               true ->  MS.close;

               'GS.close'->putline;
               GS.close;
               'suspend' -> putline;
               suspend;
               'reactivate betaVM'->putline;
               restart main
            #)
       #)
  #)
