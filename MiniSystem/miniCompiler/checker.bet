ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'parser';
INCLUDE 'Primitives';
---lib:attributes---
checker: Parser
  (# errorModule: ^Module;
     semanticError: 
       (#  msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          n: ^node;
          thisModule: ^module;
       enter n[] 
       do n.theModule -> errorModule[];
          (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
          (if not withPos then
              '\n**** Semantic error in module: "' -> puttext;
              (if n.theModule <> none then
                  (n.theModule->thisModule[]).name.lexemSy -> puttext; 
                  '"' -> put; newline;
                  n.father.doPT -> putline
               else
                  ' ????'->putline
              if);
              '**** ' -> puttext;
              &text[] -> lex.errorStream[]
          if);
          
          (if withPos then
              n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                -> lex.errorStream.putint; 
              ' ' -> lex.errorStream.put;
              n.endPos -> lex.errorStream.putint; 
              ' ' -> lex.errorStream.put;          
          if);
          INNER;
          lex.errorStream.newline;
          (if not withPos then
              lex.errorStream[] -> putline
          if);
          true -> semanticErrors
       #);
     
     checkIfprim:
       (* pDcl is none when called from Object/PtnModule since they are not nameDecl
        * pDcl is not none when called from ObjectDesc
        *)
       (# pDcl: ^nameDecl; T: ^text; desc: ^objectDesc; primNo: @integer; md: ^module
       enter(pdcl[],T[],desc[])
       do (if true
           // 'suspend' -> T.equalNCS then prim.susp -> primNo;
           // 'object' -> T.equalNCS then
              desc[] -> superObject[]
           // 'put' -> T.equalNCS then prim.put -> primNo;
           // 'get' -> T.equalNCS then prim.get -> primNo
           // 'repetition' -> T.equalNCS then
              desc[] -> repetitionDesc[];
              (if repetitionDesc[] = none then 
                  'Defining repdesc: but is none' -> putline 
              if);
           // 'index' -> T.equalNCS then 3 -> primNo (* 3: push, 4: store *)
           // 'range' -> T.equalNCS then 5 -> primNo
           // 'sendMsg' -> T.equalNCS then prim.sendMsg -> primNo
           // 'attach' -> T.equalNCS then prim.attach -> primNo
           // 'disable' -> T.equalNCS then prim.disable -> primNo
           // 'enable' -> T.equalNCS then prim.enable -> primNo
           // 'structureRef' -> T.equalNCS then
              (if (desc[] -> structureRefDesc[]) = none then
                  '\n*** Defining StructureRefDesc, but desc is none!' -> putline
              if);
           // '_break' -> T.equalNCS then prim._break -> primno
           // 'fork' -> T.equalNCS then prim.fork -> primNo
           // 'cmpAndSwap' -> T.equalNCS then prim.cmpAndSwap -> primNo
           // 'sleep' -> T.equalNCS then prim.sleep -> primNo
           // 'core' -> T.equalNCS then
              prim.core -> primNo;
           // 'thisCore' -> T.equalNCS then
              prim.thisCore -> primNo;              
           // 'error' -> T.equalNCS then
              pDcl[] -> errorDecl[];
              (if pDcl[] = none then
                  '***** pDcl is none for "error" in checkIfPrim' -> putline 
              if)
           // 'integer' -> T.equalNCS then
              desc[] -> integerDesc[]
           // 'char' -> T.equalNCS then
              desc[] -> charDesc[]     
           // 'boolean' -> T.equalNCS then
              desc[] -> booleanDesc[]
           // 'Text' -> T.equalNCS then 
              desc[] -> textDesc[]; (* we should import the text module! Needed
                                     * when text literals 'hello' are used  *)
              desc.theModule-> md[] -> md.imports.addM;
           // 'immutable' -> T.equalNCS then
              desc[] -> immutableDesc[];
           // 'processEvent' -> T.equalNCS then
              desc[] -> processEventDesc[];
           // 'BETA' -> T.equalNCS 
           // 'LIB' -> T.equalNCS 
              then
          if);
          (if pDcl[] <> none then primNo -> pDcl.primNo if)
       #);
          
     objectModule::<
       (# handlePrimitives::
            (#
            do (none,name.lexemSy,obj.OD[]) -> checkIfPrim;
               obj.OD.handlePrimitives
            #);
          descno:: (# do obj.OD.descNo -> dn #);
          setupOrigin:: (# do imports.init;  this(objectModule)[] -> obj.setupOrigin #);
          check::
            (# 
            do ('Checking objectModule',name.lexemSy) -> LG.TTn;
               ('DescNo',descno)->LG.TIn;
               (*'Checking objectModule: '->puttext; name.lexemSy -> putline;*)
               (if origin[] = none then
                   'Module.origin is none' -> LG.Tn
               if);
               (if hasPrim then
                   handlePrimitives;
               if);
               obj.check;
            #);  
          Search::
            (#
            do (for i: dcTop repeat
                    (if N[] -> dirModuleN[i].equalNCS then
                        'Found dirModule: ' -> puttext; N[] -> putline;
                        (* parse incrementally and setup dcl, etc and leave *)
                    if)    
               for);
               (if origin[] = none then
                  ('Module.origin is none: ',name.lexemSy) -> LG.TTn
                else
                   N[] -> origin.search -> (withAD[],withP[],dcl[],on)
               if)
            #);
          desc:: (# do obj.OD[] -> D[] #);
          skind:: (# do ': /' -> S[] #);
          xkind:: (# do kinds.objModule -> K #);
          objDescEQ:: (# do(* '\n--objModule.objDescEQ: ' -> puttext; DN -> putint;*)
                         DN -> obj.OD.objDescEQ -> value #);          
       #);
     PtnModule::<
       (# handlePrimitives::
            (#
            do (none,name.lexemSy,OD[]) -> checkIfPrim;
               OD.handlePrimitives
            #);
          setupOrigin:: (# do imports.init; this(ptnModule)[] -> OD.setupOrigin #);
          check::
            (#
            do (*'Checking PtnModule: ' -> puttext; name.lexemSy -> putline;*)
               ('Checking PtnModule',name.lexemSy) -> LG.TTn;
               (if origin[] = none then
                   'PtnModule.origin is none' -> LG.Tn
               if);
               (if hasPrim then
                   handlePrimitives
               if);
            #);  
          skind:: (# do ': /#' -> S[] #); 
          xkind:: (# do kinds.ptnModule -> K #);
          Search::
            (#
            do (for i: dcTop repeat
                    (if N[] -> dirModuleN[i].equalNCS then
                        'Found dirModule: ' -> puttext; N[] -> putline;
                        (* parse incrementally and setup dcl, etc and leave *)
                    if)    
               for);
               (if origin[] = none then
                   ('Module.origin is none: ', name.lexemSy) -> LG.TTn
                else
                   N[] -> origin.search -> (withAD[],withP[],dcl[],on)
               if)
            #);
          desc:: (# do OD.desc -> D[] #);
          descNo :: (# do OD.descNo -> dn #);
          objDescEQ:: (# do DN -> OD.objDescEQ -> value #);          
       #);
     WithPart::<
       (* with q.w.e;
        * with a.b.c.d;
        * with a.s.d
        *)
       (# setupOrigin:: (# do scansons(#do origin[] -> current.setupOrigin #)#);
          check:: 
            (# NA: ^NameApl; first: @boolean
            do (* sons = [[q,w,e],[a,b,c,d],[a,s,d]]
                * e = (origin,on) where on = q.on?               
                *)
               (* 'WithCheck:'-> putline; doPt -> puttext; 'in: ' -> putline;
                * origin.doPT -> putline; *)
               ('Check:withPart',doPT) -> LG.TTn;
               scansons
               (# AD: ^AttributeDenotation
               do current[] -> AD[];
                  (* 'nextWith:'->puttext; AD.dopt -> putline;
                   * (if origin[] = none then 'WP:origin none'->putline if);*)
                  AD.check;
                 
                  (* we must add one to ON, since we search in the enclosing descriptor *)
                  true -> first;
                  L:
                    AD.scansons
                    (# ON: @integer 
                    do current[] -> NA[]; (* NA.on + 1 -> NA.on *)
                       (if true then
                           (if first then
                               NA.on + 1 -> NA.on;
                               leave L
                           if)
                        else
                           (if first then NA.on -> ON; false -> first if);
                           ON + 1 -> NA.on 
                       if)
                    #) 
               #)
            #);
          search:
            (# N: ^text; dcl: ^nameDecl; withAD: ^AttributeDenotation; withP: ^withPart
            enter N[]
            do ('Search in with: ',doPT) -> LG.TT;
              (* 'WP:search:'->puttext; doPT -> putline;*)
               L: 
                 scansons
                 (# AD: ^AttributeDenotation
                 do current[] -> AD[] -> withAd[];(* 'In:'->puttext; current.dopt->putline;*)
                    ('try',AD.doPT) -> LG.TT;
                    (if AD.theDesc[] = none then 'AD.theDesc none' -> LG.Tn if);
                    N[] -> AD.theDesc.localSearch -> dcl[];
                    (if dcl[] <> none then 
                        'Found' -> LG.Tn;
                        this(withPart)[] -> withP[];
                        leave L 
                    if)
                 #);
               LG.N
            exit(dcl[],withAD[],withP[])
            #);
       #);
     object::<
       (# handlePrimitives:: (# do OD.handlePrimitives #);
          setupOrigin:: (# do origin[] -> OD.setupOrigin #);
          check::(#do #)
       #);
     Attributes::<
       (* check double declarations *)
       (# handlePrimitives:: (# do dcls.handlePrimitives #);
          setupOrigin:: (# do origin[] -> dcls.setupOrigin #);
          check::(# do dcls.check #);
          localSearch::
            (#
            do N[] -> dcls.localSearch -> dcl[]
            #)               
       #);
     Decls::<
       (# handlePrimitives::
            (#
            do scansons(# do current.handlePrimitives #)
            #);
          setupOrigin:: 
            (# 
            do scansons(# do origin[] -> current.setupOrigin #)
            #);
          check:: 
            (#
            do scansons(# do current.check #)
            #);
          localSearch::
            (#
            do loop:
                 scansons
                 (#do N[] -> current.localSearch -> dcl[];
                    (if dcl[] <> none then leave loop
                 if)#)
            #);
       #);
     Decl::<
       (* NS: NameDecls : IT: Item *)
       (# handlePrimitives:: 
            (# 
            do NS[] -> IT.handlePrimitives;
            #);
          setupOrigin:: 
            (# 
            do origin[] -> NS.setupOrigin; origin[] -> IT.setupOrigin;
              (origin[],IT[]) -> NS.setItem; (* - implies a search in further/finalBind*)
            #);
          check::
            (# 
            do (if origin[] = none then 
                   'origin none'->putline;
                   doPt -> puttext
               if);
              (* (origin[],IT[]) -> NS.setItem;*)
               NS.checkBindings;
               IT.check; (* switch here - desc is not defined in NS *)
               (IT[],IT.isSimple) -> NS.check;
            #);
          kind:: (# do IT.kind -> ch #);
          skind:: (# do IT.skind -> S[] #);
          xkind:: (# do IT.xkind -> K #);
          localSearch::
            (#
            do N[] -> NS.localSearch -> dcl[]
            #);
          objDescEQ:: (# do DN -> IT.objDescEQ -> value #);          
       #);
     NameDecls::
       (# setupOrigin:: (# do scansons(#do origin[] -> current.setupOrigin #)#);
          check::
            (# itm: ^Item; isSimple: @boolean;
               ND: ^NameDecl
            enter(itm[],isSimple)
            do scansons(#do current[] -> ND[]; (itm[],isSimple) -> ND.check #)
            #);
          
          setItem:
            (# origin: ^ObjectDesc; itm: ^Item; ND: ^NameDecl
            enter(origin[],itm[])
            do scansons(#do current[] -> ND[]; (origin[],itm[]) -> ND.setItem #)
            #);
          checkBindings:
            (# origin: ^ObjectDesc; itm: ^Item; ND: ^NameDecl
            enter(origin[],itm[])
            do scansons(#do current[] -> ND[]; ND.checkBindings #)
            #);
          localSearch::
            (#
            do loop:
                 scansons
                 (# 
                 do N[] -> current.localSearch -> dcl[];
                    (if dcl[] <> none then leave Loop if)
                 #)
            #)
       #);
     NameDecl::<
       (# check::
            (# it: ^Item; org: ^ObjectDesc; T: ^text; 
            enter(it[],isSimple)
            do 
               it[] -> itm[]; 
               isSimple -> this(nameDecl).isSimple;
               (* 'ND:isSImple: ' -> puttext; N.lexemsy -> puttext; 
                * ':'->put; (if isSimple then 'T' -> put else 'F' -> put if); newline;
               *)
               getODorigin -> org[];
               (if '_cons' -> (N.lexemSy).equalNCS then
                   (* '_cons:of:' -> putline;
                   origin.doPT -> putline;*)
                   this(NameDecl)[] -> org.constructor[];
                   true -> (desc).isConstructor
               if);
               (if org.rsize = 0 then
                   '\nND:Check:Org.rsize= ' -> puttext; org.rsize -> putint;
                   ' ' -> put; doPt -> puttext; newline;
                   'Org: '->putline; org.doPt -> putline;
               if);
               (if org[] = none then 'ND:org none' -> putline; doPt->putline if);
               (if itm[] = none then (* for inx *)
                   org.vsize + 1 -> org.vsize -> off
                else 
                   (if itm## 
                    // DynamicItem ## then
                       org.rsize + 1 -> org.rsize -> off
                    // StaticItem ## then
                       (if itm.isSimple then
                           org.vsize + 1 -> org.vsize -> off
                        else
                           org.rsize + 1 -> org.rsize -> off
                       if)
                    // VarPtn## then
                       (*'Alloc VarPtn:'->puttext; dopt -> putline;*)
                       org.rsize + 1 -> org.rsize -> off
                    // ForImpItem## then
                       org.vsize + 1 -> org.vsize -> off 
                    // ModuleItem## then
                       org.rsize + 1 -> org.rsize -> off 
                    // VirtualPattern## then
                       org.dsize + 1 -> org.dsize -> off
                    // FurtherBinding## 
                       (* see setItem *)
                    // FinalBinding## then
                       (* ditto *)
                    // repetition## then
                       (if org.isIndexed then
                           this(node)[] -> SemanticError
                           (#
                           do 'Two or more repetitions:\n\t'->msg;
                              father.father.doPT -> msg
                           #)
                       if);
                       
                       (# rep: ^repetition
                       do itm[] -> rep[];
                          (if rep.IT##
                           // staticItem## then
                              (*'Indexed:staticItem:'->puttext;*)
                              (if rep.IT.isSimple then 
                                  (*'simple' -> putline;*)
                                  true -> isIndexed -> it.isIndexed -> org.isVinxd;
                                  (*org.vsize + 1 -> org.vsize -> off*)
                               else
                                  'non-simple' -> putline;
                                  true -> isIndexed -> it.isIndexed -> org.isRinxd;
                                  (*org.rsize + 1 -> org.rsize -> off*)
                              if)
                           // dynamicItem## then
                              true -> isIndexed -> it.isIndexed -> org.isRinxd;
                              (*org.rsize + 1 -> org.rsize -> off*)
                           else
                              this(node)[] -> SemanticError
                              (# do 'Indexed object: unknown element type' -> msg #)
                          if);
                       #)
                   if)
               if)
            #);
          vdcl: ^NameDecl;
          checkBindings:
            (# org: ^objectDesc
            do origin[] -> org[];
               (if itm##
                // FurtherBinding## 
                // FinalBinding## then
                   N.lexemSy -> org.superSearch -> vDcl[];
                   (if vdcl[] = none then
                       this(node)[] -> SemanticError
                       (#
                       do 'Virtual declaration not found: ' -> msg; N.lexemSy -> msg;
                       #);
                    else
                       vDcl[] -> itm.setImplicitSuper;
                       vdcl.off -> off
               if)if);
            #);
          setItem: 
            (# origin: ^ObjectDesc
            enter(origin[],itm[]) (* reconsider - also done in check *)
            do (if origin[] = none then
                   'SetItem:origin is none'  -> putline;
                   doPt -> putline
               if);
            #); 
          localSearch::
            (# dir: ^ModuleItem
            do '?' -> LG.T; this(NameDecl).N.lexemSy -> LG.T; 
               '=' -> LG.T; N[] -> LG.T;
               (if this(NameDecl).N.lexemSy -> N.equalNCS then
                   ' found!'-> LG.Tn;
                   this(NameDecl)[] -> dcl[];
                else
                   LG.N
               if)
            #);
          desc: 
            (# D: ^ObjectDesc 
            do (if not isForInx then 
                   (if itm[] <> none then
                       itm.desc -> D[];
                    else
                       (* probably empty super *)
                   if)
                else 
                   integerDesc[] -> D[] 
               if) 
            exit D[] 
            #);
           isObject:
            (* In R.foo, R.S.foo, etc., check that R, R:S, etc. are objects *)
            (# NA: ^denotation
            enter NA[]
            do '\n***denotation:isObject called'->putline;
               (if itm[] <> none then
                   NA[] -> itm.isObject
                else
                   '\n***isObject:itm is none'->putline;
                   NA.father.doPT -> putline;
               if)
            #);
          itm: ^Item;
          off: @integer; (* runtime offset of data-item in object *)  
          isIndexed: @boolean;
          descInx:< 
            (# inx: @integer 
            do itm.descInx -> inx 
            exit inx 
            #);
          isVirtual: BooleanValue(# do itm.isVirtual -> value #);
          isDataItem::(# do itm.isDataItem -> value; #);
          isPtn:: (# do itm.isPtn -> value #);
          primNo: @integer (* primitive number
                            * 1: suspend
                            * 2: put
                            * 3: ...
                            *)
       #);
     ForImpItem::<
       (# check::(# do true -> isSimple #);
          sKind:: (# do 'for' -> S[] #);
          xkind:: (# do kinds.forInx -> K #);
          desc:: (# do integerDesc[] -> D[] #);
       #);
     Staticitem::<
       (# handlePrimitives::
            (#
            do dcl[] -> OS.handlePrimitives
            #);
          setupOrigin:: (# do origin[] -> OS.setupOrigin #);
          check::
            (# 
            do (if not (OS##=objectDesc##) then OS.check if);
               OS.markReferenced;
               OS.isSimple -> isSimple; 
               (OS.desc).markReferenced; (* reconsider markReferenced
                                          * - and perhaps OS desc has not be checked?
                                          * Probably not a problem, since we just set
                                          * a boolean in the syntax tree
                                          *)
            #);
          Desc:: (# do OS.desc -> D[] #);
          isDataItem:: (# do (*'SI:isDI'->putline;*) true -> value #);
          sKind::
            (#
            do (if isSimple then ': =' -> S[] else ': @' -> S[] if)
            #);
          xkind:: 
            (# 
            do (if isSimple then kinds.simple -> K else kinds.part -> K if)
               #);
          objDescEQ:: (# do DN -> OS.objDescEQ -> value #);          
       #);
     Dynamicitem::<
       (# setUpOrigin:: (# do origin[] -> AD.setUpOrigin #);
          check:: (#do AD.check #);
          Desc:: (# do AD.desc -> D[] #);
          isDataItem:: (# do (*'DI:isDI'->putline;*) true -> value #);
          xKind:: (# do kinds.ref -> K #);
          sKind:: (# do ': ^' -> S[] #);
          on: @integer;
          withAD: ^AttributeDenotation;
          withP: ^WithPart;
          dcl: ^NameDecl
       #);
     Repetition::<
       (# setupOrigin:: (# do origin[] -> inx.setupOrigin; origin[] -> IT.setupOrigin #);
          check:: 
            (#
            do inx.check;
               IT.check;
            #);
          desc:: 
            (# 
            do (if repetitionDesc[] = none then 
                   'repetitionDesc is none' -> putline;
                else 
                   repetitionDesc[] -> D[]
               if)
            #);
          sKind:: (# do ': [*]' -> S[] #);
          xkind:: (# do kinds.rep -> K #);
       #);
     PatternDen::<
       (# setupOrigin:: (# do origin[] -> AD.setupOrigin #);
          check:: 
            (# 
            do ('PatternDen:check',doPT)->LG.TTn;
               (if origin[] = none then 'PD:origin none' -> LG.Tn if);
               AD.check
            #);
          setImplicitSuper: 
            (# vDcl: ^NameDecl
            enter vDcl[]
            do vDcl[] -> AD.setImplicitSuper
            #);
          isSimple::
            (#
            do AD.isSimple -> value
            #);
          desc:: (# do AD.desc -> D[] #);
          myDesc:: (# do desc -> OD[]#);
          enterType:: (# do AD.enterType -> TP[] #);
          exitType:: (# do AD.exitType -> TP[] #);
          isThisBlockLevel: BooleanValue
            (#
            do (*AD.sons.length -> putint; ' ' -> put; AD.lastDen.on -> putint; newline;*)
               (AD.sons.length  = 1 ) and (AD.lastDen.on = 1) and (AD.lastDen.withAD[] = none)
                 -> value
            #)
       #);
     VirtualPattern::<
       (# setupOrigin:: (# do origin[] -> OS.setupOrigin #);
          check:: (# do (if not (OS##=objectDesc##) then OS.check if) #);
          desc:: (# do OS.desc -> D[] #);
          sKind:: (# do ':<' -> S[] #);
          xkind:: (# do kinds.virtualPattern -> K #);
          objDescEQ:: (# do DN -> OS.objDescEQ -> value #);
       #);
     FurtherBinding::<
       (# setupOrigin:: (# do origin[] -> OS.setupOrigin #);
          check:: 
            (# 
            do (if true or implicitSuperIsSet then (* tricky *);
                   (*'Check: FB:'->puttext; dopt -> putline;*)
                   (if not (OS##=objectDesc##) then OS.check if)
               if)
            #);
          setImplicitSuper:: 
            (# 
            do vDcl[] -> OS.setImplicitSuper; 
               true -> implicitSuperIsSet;
            #);
          desc:: (# do OS.desc -> D[] #);
          sKind:: (# do '::<' -> S[] #);
          xkind:: (# do kinds.furtherBind -> K #);
          objDescEQ:: (# do DN -> OS.objDescEQ -> value #);
          vDcl: ^NameDecl;
       #);
     FinalBinding::<
       (# setupOrigin:: (# do origin[] -> OS.setupOrigin #);
          check:: (# do OS.check #);
          setImplicitSuper:: 
            (# 
            do vDcl[] -> OS.setImplicitSuper; 
               true -> implicitSuperIsSet;
            #);
          desc:: 
            (# 
            do (if true then
                   OS.desc -> D[]
                else
                   (if not (OS##=objectDesc##) then OS.desc -> D[] if)
               if)
            #);
          sKind:: (# do '::' -> S[] #);
          xkind:: (# do kinds.finalBind -> K #);
          objDescEQ:: (# do DN -> OS.objDescEQ -> value #);
       #);
     Const::<
       (# enterType:: (# do null_type -> TP[] #);
          exitType:: (# do integerDesc[] -> value_type -> TP[] #)
       #);
     aChar::<
       (# enterType:: (# do null_type -> TP[] #);
          exitType:: (# do charDesc[] -> value_type -> TP[] #)
       #);
     aText::<
       (# enterType:: (# do null_type -> TP[] #);
          exitType:: (# do textDesc[] -> ref_type -> TP[] #)          
       #);
     textDenotation::<
       (# setUpOrigin:: (# do origin[] -> T.setUpOrigin #);
          checkFirst:: (# do check #);
          check:: 
            (# 
            do &nameDecl[] -> dcl[]; (* hack *)
               &DynamicItem[] -> dcl.itm[]; (* another hack *)
               (* pehaps we could search for text here and thus get ON defined
                * and avoid a special case in attributedenotation::loadOrigin
                *)
            #);
          desc:: (# do textDesc[] -> theDesc[] #);
          myDesc:: (# do desc -> OD[] #);
          enterType:: (# do null_type -> TP[] #);
          exitTYpe:: (# do T.exitType -> TP[] #)
       #);
     noneValue::< 
       (# enterType:: (# do null_type -> TP[] #);
          exitType:: (# do none_type -> TP[] #)
       #);
     ObjectDesc::<
       (# isObjDesc:: TrueValue;
          isSimple:: (# do isPrimitive -> value #);
          handlePrimitives::
            (# NS: ^nameDecls
            do (if hasProps and (dcl[] <> none) then
                   dcl[] -> NS[];
                   NS.scan
                   (# ND: ^NameDecl
                   do current[] -> ND[];
                      (ND[],ND.lexemSy,this(objectDesc)[]) -> checkIfPrim
               #)if);
               (if att[] <> none then att.handleprimitives if)
            #);
          setUpOrigin:: 
            (#
            do false -> isChecked -> beingChecked -> isVinxd -> isRinxd -> done ;
               0 -> descNo -> originOff -> vSize -> rSize -> noOfInner -> dsize -> innerInx;
               this(ObjectDesc)[] -> DS.add;
               origin[] -> sup.setupOrigin; 
               (if with[] <> none then origin[] -> with.setupOrigin if); 
               this(ObjectDesc)[] -> restricts.setUpOrigin;
               (if att[] <> none then this(ObjectDesc)[] -> att.setUpOrigin; if); 
               (if acp[] <> none then this(ObjectDesc)[] -> acp.setUpOrigin; if); 
            #);
          check::
            (# checkDoubleDecls:
                 (#
                 do 
                    scanDecls(*scanAllDecls*)
                    (# thisND: ^nameDecl
                    do currentND[] -> thisND[];
                       L:
                       scanDecls(*scanAllDecls*)
                       (# m: ^module;
                       do (if currentND[] = thisND[] then leave L if);
                          (if (currentND.N.lexemSy -> (thisND.N.lexemSY).equalNCS) then
                              currentND[] -> SemanticError
                              (# do 'Double declaration of: "' -> msg;
                                 currentND.lexemSy -> msg; '"' -> msg
                              #)
                          if)
                 #)#)#)
            do 
               (if isChecked or beingChecked then
                   (* Need to reconsider beingChecked - and recursive calls *)
                   (* '\nisChecked: ' -> puttext; descno -> putint; newline;
                    * doPt -> putline *)
                else
                   true -> beingChecked;
                   ('CHECK',doPT) -> LG.TTn;
                   (if origin[] = none then 'OD:origin none' -> LG.Tn if);
                   CheckDoubleDecls;
                   sup.check; 
                   sup.desc -> superDesc[]; 
                   (if superDesc[] = superObject[] then
                       none -> superDesc[]
                   else
                       (if superDesc.att[] = none then none -> superDesc[] (* hack*) if);
                   if);
                   
                   (if superDesc[] <> none then
                       (if superdesc.isOrBeingChecked = false then
                           ('OD: super not checked: ', superdesc.originoff) -> LG.TIn;
                           (# D: ^objectDesc; T: @text
                           do superDesc.getODorigin -> D[];
                              (if D[] <> none then
                                  (if not D.isChecked then
                                      'super.Origin is not checked:' -> T;
                                      (if D.beingChecked then 'being checked' -> T.puttext if); 
                                      (T[],D.doPT) -> LG.TTn;
                                      (if not D.beingChecked then D.check if)
                           if)if)#);
                           (if not superDesc.beingChecked then superDesc.check if);
                        else
                           (if superDesc.isChecked then ('superDesc','isChecked') -> LG.TTn if);
                           (if superDesc.beingChecked then ('superDesc','beingChecked') -> LG.TTn if);
                       if);
                       superDesc.markAsSuper;
                       superDesc.vsize -> vsize;
                       superDesc.rsize -> rsize;
                       superDesc.dsize -> dsize;
                       (if sup.isThisBlockLevel then
                           superDesc.originOff -> originOff (* may just zero?*)
                        else
                           rsize + 1 -> rsize -> originOff
                       if);
                       (superDesc[] = immutableDesc[]) or superDesc.isImmutable -> isImmutable;
                       superDesc.isUnique  -> isUnique;
                    else
                       rsize + 1 -> rsize -> originOff
                   if);
                   this(objectDesc)[] -> newDesc -> descNo;
                   ('CHECK',descNo) -> LG.TIn;
                   (if descNo > 1 then true -> isReferenced if);
                   
                   (if with[] <> none then with.check if);
                   restricts.check;

                   (* do the same for [immutable] *)
                   (if restricts[] <> none then
                       restricts.isUnique or isUnique -> isUnique
                   if);                   
                   att.check; 
                   
                   (if acp[] <> none then acp.check if); (* allocate forImp index and range before
                                                          * allocating space to a possible indexed object *)
                   (if true
                    // isVinxd then 
                       (* 'isVinxd: ' -> puttext;*)
                       vsize + 1 -> vsize;
                    // isRinxd then
                       rsize + 1 -> rsize;
                       (* 'isRinxd: '-> puttext; rsize -> putint; newline;*)
                   if);
                   
                   true -> isChecked;
                   false -> beingChecked;
               if)
            #);
          isOrBeingChecked: (# exit isChecked or beingChecked #);
          search::
            (# 
            do ('Search in',descNo) -> LG.TIn;
               doPT -> LG.Tn2;
               N[] -> localSearch -> dcl[];
               (if dcl[] = none then
                   (if with[] <> none then
                       N[] -> with.search -> (dcl[],withAD[],withP[]) (* ON = 0 *)
                   if);
                   (if dcl[] <> none then
                       (*with.AD[] -> withAD[]*)
                    else
                       (if superDesc[] <> none then
                           N[] -> superDesc.localsearch -> dcl[]
                        else
                           (if superObject[] <> none then
                               N[] -> superObject.localSearch -> dcl[]
                            else
                               'No superObject:' -> LG.Tn2;
                   if)if)if);
                   (if dcl[] = none then
                       (if origin[] = none then 'OD:origin is none'->LG.Tn ; doPT -> putline if);
                       N[] -> origin.search -> (withAD[],withP[],dcl[],on);
                       on + 1 -> on
               if)if)
            #);
          superSearch:
            (# N: ^Text; dcl: ^NameDecl
            enter N[]
            do (if superDesc[] <> none then 
                   N[] -> superDesc.localSearch -> dcl[]
                else 
                   'Super is none'-> putline;
                   dopt -> puttext
               if)
            exit(dcl[])
            #);
          mainSearch:
            (# N: ^Text; dcl: ^NameDecl
            enter N[]
            do (if att[] = none then 'att none'->putline if); 
               N[] -> att.localSearch -> dcl[];
            exit dcl[]
            #);
          localSearch::
            (#
            do N[] -> mainSearch -> dcl[];
               (if dcl[] = none then 
                   (if superDesc[] <> none then
                       N[] -> superDesc.localSearch -> dcl[];
                    else
                       (if superObject[] <> none then
                           N[] -> superObject.mainSearch -> dcl[]
                        else
                           'No superObject:' -> LG.Tn2
               if)if)if)
            #);
          setImplicitSuper::
            (#
            do vDcl[] -> sup.setImplicitSuper
            #);
          hasInner::
            (#
            do noOfInner + 1 -> noOfInner;
               (if noOfInner = 1 then dsize + 1 -> dsize -> innerInx if);
               innerInx -> value
            #);
          topSuper:
            (# topDesc: ^ObjectDesc
            do (if superDesc[] <> none then
                   superDesc.topSuper -> topDesc[]
                else
                   this(objectDesc)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          objDescEQ:: (# do DN =  descNo -> value #);          
          superDesc: ^ObjectDesc;
          desc:: (# do this(ObjectDesc)[] -> D[] #);
          myDesc:: (# do this(ObjectDesc)[] -> OD[] #);
          getOriginOff::(# do originOff -> off #);
          nxType:
            (# TP,supTP: ^type
            enter TP[]
            do (if isSimple then
                   (if this(objectDesc)[]
                    // integerDesc[] then
                       integerDesc[] -> value_type -> TP[]
                    // charDesc[] then
                       charDesc[] -> value_type -> TP[]
                    // booleanDesc[] then
                       booleanDesc[] -> value_type -> TP[]
                   if)
                else
                   (if not isChecked then
                       ('objectDesc:ncType:notChecked',doPT) -> LG.TTn;
                       check (* we may enter a recursive loop
                              * we should fetch the N/X-part 
                              *)
                   if);
                   inner;
                   (if false then
                       doPT -> putline;
                       'superType: ' -> puttext;
                       (if supTP[] <> none then supTP.print -> putline if);
                       'mainType:' -> puttext;
                       (if (TP[] <> none) then
                           TP.print -> putline;
                        else
                           'none' -> putline
                   if)if);
                   (if supTP[] <> none then
                       TP[] -> supTP.append -> TP[]
                   if);
                   (if false then
                       'All: ' -> puttext; (if TP[] <> none then TP.print -> putline 
                   if)if)
               if)
            exit TP[]
            #);
          enterType:: 
            (# supTP: ^type; 
            do (if false then 'enterType:'->puttext; doPT -> putline; if);
               TP[] -> nxType
               (#
               do sup.enterType -> supTP[];
                  acp.enterType -> TP[]
               #) -> TP[]
            #);
          exitType:: 
            (# 
            do (if false then 'exitType: ' -> puttext; doPT -> putline if);
               TP[] -> nxType
               (#
               do sup.exitType -> supTP[];
                  acp.exitType -> TP[];
               #) -> TP[];
            #);
          exitDesc:
            (# D: ^objectDesc
            do acp.exitDesc -> D[]
            exit D[]
            #);
          constructor: ^NameDecl;
          descNo,originOff: @integer;
          vsize,rsize,noOfInner,dsize,innerInx: @integer;
          isIndexed: booleanValue
            (#
            do (if not (isVinxd or isRinxd -> value) then
                   (if superDesc[] <> none then
                       superDesc.isIndexed -> value
               if)if)
            #);
          isRindexed: booleanValue
            (#
            do (if not (isRinxd -> value) then
                   (if superDesc[] <> none then
                       superDesc.isRindexed -> value
               if)if)
            #);
          isVinxd,isRinxd, (* has indexed: [e] ... *)
          isImmutable,
          isUnique,
          isConstructor,
          beingChecked,isChecked,
          done: @boolean (* codegen done*)
       #);
     Restrictions::<
       (# setUpOrigin::
            (#
            do scansons(# do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (*'Check restrictions' -> putline;*)
               scansons
               (# R: ^Restriction
               do current[] -> R[];
                  R.check;
                  (if true 
                   // R.isImmutable then 
                      R.rQual[] -> immutable[]; true -> isImmutable
                   // R.isUnique then true -> isUnique;
                      'Set unique'->putline
                   // R.isGlobals then R.rQual[] -> globals[]
                   // R.isArguments then R.rQual[] -> arguments[]
                   // R.isInterface then R.rQual[] -> interface[]
                   // R.isKind then R.rQual[] -> kind[]
                  if)
               #)
            #);
          immutable,
          globals,
          arguments,
          interface,
          kind: ^RestrictionQualifiers;
          isImmutable, (*  not used *) isUnique: @boolean
       #);
     Restriction::
       (# setUpOrigin::
            (#
            do (if rQual[] <> none then
                   origin[] -> rQual.setUpOrigin
                   (* empty for immutable, and unique *)
               if);
            #);
          check::
            (# R: ^text
            do name.lexemSy -> R[];
               (if true
                // 'immutable' -> R.equalNCS then
                   (*'Got immutable' -> putline;*)
                   true -> isImmutable
                // 'interface' -> R.equalNCS then
                   (*'Got interface' ->putline;*)
                   true -> isInterface;
                // 'globals' -> R.equalNCS then
                   (*'Got globals' -> putline;*)
                   true -> isGlobals
                // 'arguments' -> R.equalNCS then
                   (*'Got arguments' -> putline;*)
                   true -> isArguments
                // 'kind' -> R.equalNCS then
                   (*'Got kind' -> putline;*)
                   true -> isKind
                // 'unique' -> R.equalNCS then
                   'Got unique' -> putline;
                   true -> isUnique
                else
                   'Restrictions:check:No match'->putline
               if);
               (if rQual[] <> none then rQual.check if)
            #);
          isImmutable,isGlobals,isArguments,isInterface,isKind,isUnique: @boolean
       #);
     RestrictionQualifiers::
       (# setUpOrigin::
            (#
            do scansons
               (#
               do origin[] -> current.setUpOrigin
               #)
            #);
          check::
            (#
            do scansons
               (# D: ^denotation;
               do current[] -> D[]; D.checkFirst
               #)
            #)
       #);
     Pattern::<
       (# handlePrimitives:: (# do  dcl[] -> OD.handlePrimitives #);
          setupOrigin:: (# do origin[] -> OD.setupOrigin #);
          check::
            (#
            do OD.isSimple -> this(Pattern).isSimple  
            #);
          desc:: (# do OD[] -> D[] #);
          isPtn::(# do (*'Pattern:isPtn:'->putline;*) true -> value #);
          isObject::
            (#
            do NA[] -> SemanticError
               (#
               do 'Pattern "'->msg; 
                  NA.doPT -> msg;
                  '" used in remote: "'-> msg;
                  NA.father.doPT -> msg;
                  '"\n' -> msg
               #)
            #);
          sKind:: (# do ': ' -> S[] #);
          xkind:: (# do kinds.pattern -> K #);
          objDescEQ:: (# do DN -> OD.objDescEQ -> value #);          
       #);
     ModuleItem::<
       (# setupOrigin:: (# do origin[] -> md.setUpOrigin #);
          check::
            (# 
            do ('ModuleItem:check',md.name.lexemSy) -> LG.TTn;
               (if isParsed then 
                   true -> isChecked;
                   md.check;
                   true -> isChecked;
                else 
                   (* save arguments for check if referenced *)
               if)
            #);
          doCheck: 
            (* Here should parse (if not already done) and get directoryModuless *)
            (#
            do ('ModuleItem:doCheck',md.name.lexemSy)->LG.TTn;;
               (if (origin[] <> none) and not isChecked then check if)
            #);
          sKind:: (# do md.skind -> S[] #);
          xKind:: (# do md.xkind -> K #);
          isChecked: @boolean;
          myDesc:: (# do desc -> OD[] #);
          desc:: (* perhaps eliminate some levels here?*)
            (# 
            do ('Get ModuleItem desc:',md.name.lexemSy) -> LG.TTn;
               (if not isChecked then
                   true -> isParsed;
                   doCheck
               if);
               md.desc -> D[]
            #); 
          objDescEQ:: (# do DN -> md.objDescEQ -> value #);   
       #);
     VarPtn::<
       (# setUpOrigin:: (# do origin[] -> AD.setUpOrigin #);
          check::
            (#
            do (* 'Check: ' -> puttext; doPt->putline;*)
               AD.check
            #);
          myDesc:: (# do desc -> OD[]#);
          desc::
            (#
            do AD.desc -> D[] 
            #);
          skind:: (# do ': ##' -> S[] #);
          xKind:: (# do kinds.varPtn -> K #);
       #);
     ActionPart::<
       (# setupOrigin:: 
            (# 
            do origin[] -> enterP.setupOrigin;
               (if imps[] <> none then origin[] -> imps.setupOrigin if);
               origin[] -> exitP.setupOrigin; 
            #);
          check:: 
            (# 
            do enterP.check;
               (if imps[] <> none then imps.check if);
               exitP.check;   
            #);
          skind:: (# do '*' -> S[] #);
          xkind:: (# do kinds.action -> K #);
          enterType:: (# do enterP.enterType -> TP[] #);
          exitType:: (# do exitP.exitType -> TP[] #);          
       #);
     EnterPart::<
       (# setupOrigin:: (# do (if eval[] <> none then origin[] -> Eval.setUpOrigin if) #);
          check:: (# do (if eval[] <> none then Eval.check if) #);
          enterType:: (# do (if eval[] <> none then eval.enterType -> TP[] if)#)
       #);
     ExitPart::<
       (# setupOrigin:: (# do (if eval[] <> none then origin[] -> Eval.setUpOrigin if) #);
          Check:: (# do (if eval[] <> none then Eval.check if) #);
          exitType:: (# do (if eval[] <> none then eval.exitType -> TP[] if)#)
       #);
     Imperatives::<
       (# setupOrigin:: 
            (# 
            do (if origin[] = none then 'Imps: ' -> putline if);
               scansons(#do origin[] -> current.setupOrigin #)
            #);
          check:: (# do scansons(#do current.check #)#);
       #);
     Imperative::<
       (# setupOrigin:: (# do origin[] -> imp.setupOrigin #);
          check:: (# do imp.check #);
       #);
     ForImp::<
       (# findEncObjDesc:
            (# OD: ^ObjectDesc; nd: ^node
            do origin[] -> nd[];  (* this probably does not work - ugly *)
               FindOD:
                 (if nd## (* what is this ? *)
                  // objectDesc## then
                     nd[] -> OD[]
                  // ForImp## then
                     nd.origin[] -> nd[];
                     restart FindOD
                  // LabelledImp## then
                     nd.origin[] -> nd[];
                     restart findOD
                  else
                     '??????' -> putline
                 if);
            exit OD[]
            #);
          setupOrigin:: 
            (# 
            do this(ForImp)[] -> imps.setupOrigin;               
               findEncObjDesc -> inx.setUpOrigin;
               origin[] -> rangee.setUpOrigin;
               (origin.getODorigin,inxItem[]) -> inx.setItem
            #);
          check:: 
            (# OD: ^ObjectDesc; nd: ^node
            do origin[] -> nd[];  (* this probably does not work - ugly *)
               FindOD:
                 (if nd## (* what is this ? *)
                  // objectDesc## then
                     nd[] -> OD[]
                  // ForImp## then
                     nd.origin[] -> nd[];
                     restart FindOD
                  // LabelledImp## then
                     nd.origin[] -> nd[];
                     restart findOD
                  else
                     '??????' -> putline
                 if);
               (* probably not the right origin when searching ? *)
               (inxItem[],true) -> inx.check; (* index is a decl, so do not search *)
               rangee.check; 
               inxItem.check;

               OD.vsize + 1 -> OD.vsize; (* space for range *)
               imps.check;
            #);
          search::
            (#
            do ('Search for-inx', N[]) -> LG.TTn;
               (if (N[] -> inx.localSearch -> dcl[]) = none then
                   N[] -> origin.search -> (withAD[],withP[],dcl[],on)
               if)
            #);
          hasInner:: (# do on -> origin.hasInner -> value #);
       #);
     IfImp::<
       (# setupOrigin::
            (#
            do origin[] -> eval.setupOrigin;
               (if thenPart[] <> none then
                   origin[] -> thenPart.setupOrigin
                else (if alt[] <> none then
                         origin[] -> alt.setupOrigin
                      else
                         'setupOrigin:IfImp: no then- or laternatives?' -> putline
               if)if);
               (if elsePart[] <> none then origin[] -> elsePart.setupOrigin if)
            #);
          check::
            (#
            do eval.check;
               (if thenPart[] <> none then
                   thenPart.check
                else (if alt[] <> none then
                         alt.check
                      else
                         'IfImp: no then- or laternatives?' -> putline
               if)if);
               (if elsePart[] <> none then elsePart.check if)
            #)
       #);
     Alternatives::<
       (# setupOrigin::
            (#
            do scansons(#do origin[] -> current.setupOrigin #)
            #);
          check::
            (#
            do scansons(#do current.check #)
            #)
       #);
     Alternative::<
       (# check::
            (#
            do sel.check;
               imps.check
            #);
          setupOrigin::
            (#
            do origin[] -> sel.setupOrigin;
               origin[] -> imps.setupOrigin
            #)
       #);
     Selections::<
       (# setupOrigin::
            (#
            do scansons(# do origin[] -> current.setupOrigin #)
            #);
          check::
            (#
            do scansons(# do current.check #)
            #)
       #);
     Selection::<
       (# check::
            (#
            do EV.check
            #);
          setupOrigin::
            (#
            do origin[] -> EV.setupOrigin
            #)
       #);
     
     LabelledImp::<
       (# setupOrigin:: 
            (# 
            do origin[] -> lab.setUpOrigin; (* should this be labImp?*)
               this(LabelledImp)[] -> imp.setupOrigin;
               (origin.getODorigin,&item[] (* hopefully not used *)) -> lab.setItem;
            #);
          check::
            (#
            do imp.check;
            #);
          search::
            (#
            do (if (N[] -> lab.localSearch -> dcl[]) = none then
                   N[] -> origin.search -> (withAD[],withP[],dcl[],on)
               if)
            #);
          hasInner:: (# do on -> origin.hasInner -> value #);
       #);
     LeaveImp::<
       (# check::
            (#
            do lab.checkFirst
            #);
          setupOrigin::
            (#
            do origin[] -> lab.setupOrigin
            #)
       #);
     RestartImp::<
       (# setupOrigin::
            (#
            do origin[] -> lab.setupOrigin
            #);
          check::
            (#
            do lab.checkFirst
            #)
       #);
     InnerImp::<
       (# check:: 
            (# 
            do origin.hasInner -> innerInx (* hasInner has enter ON - to be used withe inner P *)
            #);
          innerInx: @integer
       #);
     Evaluation::<
       (# setupOrigin::(#do scansons(# do origin[] -> current.setupOrigin #)#);
          check::
            (# 
            do scansons(# do current.check #);
               (* CheckNX - called in Generator::Evaluation::gen *)
            #);
          CheckNX:
            (# md: ^module;
            do scansons
               (# L: ^trans; XT,NT: ^type;
                  msg:
                    (#
                    do theModule -> md[];
                       '*** In module: "' -> puttext; md.name.lexemSy -> puttext;
                       inner;
                       L.doPT -> puttext; ' -> ' -> puttext; current.doPT -> putline;
                       '   ' -> puttext; 
                       (if XT[] <> none then
                           XT.print -> puttext
                        else
                           'no exit-patt' -> putline
                       if); 
                       ' -> ' -> puttext;
                       (if NT[] <> none then
                           NT.print -> putline
                        else
                           'no enter part' -> putline
                       if);
                       newline
                    #);
                  NXmsg: msg
                    (#
                    do '": potential type error in assignment: \n   ' -> puttext;
                    #);
                  QUAmsg: msg
                    (# quaType: @boolean
                    enter quaType
                    do (if quaType then
                           '": potential qualification error in assignment: \n   '
                             -> puttext;
                        else
                           '":\n ** Run-time qualification check needed in assignment: \n   ' 
                             -> puttext;
                       if)
                    #);
                  QUAerrorMsg: msg(# do inner #); 
               do (if L[] <> none then
                      (* ... L -> current ... *)
                      L.exitType -> XT[];
                      current.enterType -> NT[];
                      ('ChkAsg',L.doPT) -> LG.TT;
                      (' -> ',current.doPT) -> LG.TT;
                      ' ==> ' -> LG.T;
                      (if XT[] <> none then XT.print -> LG.T else 'none' -> LG.T if);
                      ' -> ' -> LG.T;
                      (if NT[] <> none then NT.print -> LG.T else 'none' -> LG.T if);
                      (' in: ',doPT) -> LG.TTn;
                      (if NT[] <> none then 
                          (if (XT[] = none) then 
                              NXmsg 
                           else
                              (if (XT[] -> NT.match)
                               // NX_error then NXmsg 
                               // QUA_error then 
                                  this(node)[] -> SemanticError
                                  (#
                                  do ' ** Qualification error in assignment' -> msg;
                                     QUAerrorMsg 
                                  #)
                               // QUA_runTimeCheck then
                                  false -> QUAmsg 
                          if)if)
                       else
                          (if XT[] <> none then NXmsg if)
                      if)                      
                  if);
                  current[] -> L[]
               #);
            #);
          myDesc::
            (# N: ^Node
            do scansons(# do current[] -> N[] #);
               N.myDesc -> OD[]
            #);
          enterType:: 
            (# T: ^trans 
            do L: scansons(# do current[] -> T[]; leave L #); 
               T.enterType -> TP[]
            #);
          exitType:: 
            (# T: ^Trans
            do scansons(# do current[] -> T[] #);
               T.exitType -> TP[]
            #)
       #);
     BinaryExp::<
       (# setupOrigin:: (# do origin[] -> lE.setupOrigin; origin[] -> rE.setupOrigin #);
          check:: (# do lE.check; rE.check #);
          exitType:: (# do value_type -> TP[]#);
       #);
     UnaryExp::<
       (# check:: 
            (#
            do E.check
            #);
          setupOrigin:: 
            (#
            do origin[] -> E.setupOrigin
            #);
          exitType:: (# do value_type -> TP[]#);
       #);
     Term::<
       (# check:: (#do T.check #);
          setupOrigin:: (#do origin[] -> T.setupOrigin #);
          myDesc:: (# do T.myDesc -> OD[] #);          
          enterType:: (# do T.enterType -> TP [] #);
          exitType:: (# do T.exitType -> TP [] #);
       #);
     Reference::<
       (# setupOrigin:: (# do origin[] -> OV.setupOrigin #);
          check:: (# do OV.check #);
          myDesc:: (# do OV.myDesc -> OD[] #);
          enterType:: (# do myDesc -> ref_type -> TP[] #);
          exitType:: (# do myDesc -> ref_type -> TP[] #);
       #);
     StructureRef::<
       (# setUpOrigin:: (# do origin[] -> OV.setUpOrigin #);
          check::
            (#
            do (*'Check:StructureRef ' -> puttext; doPT -> putline;*) OV.check
            #);
          myDesc:: (# do OV.myDesc -> OD[] #);
          enterType:: (# do myDesc -> strucRef_type -> TP[] #);
          exitType:: (# do myDesc -> strucRef_type -> TP[] #);          
       #);
     DynamicObjectGeneration::<
       (# setupOrigin:: 
            (# 
            do origin[] -> OS.setupOrigin;
               (if EV[] <> none then origin[] -> EV.setUpOrigin if)
            #);
          check:: 
            (# 
            do OS.check;
               (OS.desc).markReferenced;
               (if (OS.desc).isIndexed and (EV[] = none) then
                   this(node)[] -> semanticError
                   (#
                   do 'Missing size for dynamic object generation:\n\t' -> msg;
                      doPT -> msg; ' should be ' -> msg; 
                      doPT-> msg; '(eval)' -> msg;
                   #)
               if);
               (if EV[] <> none then EV.check if)
            #);
          exitType:: 
            (# 
            do (if isRef then
                   OS.desc -> ref_type -> TP[] 
                else
                   (OS.desc).exitType -> TP[]
               if);
               (* not correct - here we have
                * &P
                * we need to go into the 
                * descriptor - only ref
                * if &P[]
                *)
            #)
       #);
     ObjEval::<
       (# setupOrigin::
            (#
            do origin[] -> OS.setupOrigin
            #);
          check::
            (#
            do OS.check; OS.isSimple -> isSimple
            #);
          isSimple: @boolean;
          myDesc::(# do OS.myDesc -> OD[] #);
          enterType:: (# do OS.enterType -> TP[] #);
          exitType:: (# do OS.exitType -> TP[] #);
       #);
     EvaluationList::<
       (# setupOrigin::(# do scansons(#do origin[] -> current.setupOrigin #) #);
          check::
            (#
            do scansons(#do current.check #);
            #);
          myDesc::
            (# N: ^Node
            do scansons(# do current[] -> N[] #);
               N.myDesc -> OD[]
            #);
          enterType::
            (# LTP: ^list_type
            do list_type -> LTP[];
               scansons(# T: ^type do current.enterType -> T[] -> LTP.add #);
               LTP[] -> TP[]
            #);
          exitType::
            (# LTP: ^list_type
            do list_type -> LTP[];
               scansons(# do current.exitType -> LTP.add #);
               LTP[] -> TP[]
            #);
          
       #);
     computedRemote::<
       (# setUpOrigin::
            (#
            do origin[] -> tra.setUpOrigin; origin[] -> NA.setUpOrigin
            #);
          check::
            (# OD: ^objectDesc
            do tra.check;
               tra.myDesc -> OD[];
               (if (OD.exitDesc -> OD[]) = none  then
                   this(node)[] -> semanticError
                   (#
                   do 'No exit element with object desc in:\n' -> msg;
                      tra.doPT -> msg
                   #)
                else
                   (*OD.doPT -> putline;*)
                   NA.lexemSy -> OD.localSearch -> NA.dcl[];
                   (if NA.dcl[] = none then
                       this(node)[] -> semanticError
                       (#
                       do 'Computed remote: not found: "' -> msg; 
                          NA.lexemSy -> msg;
                          '"\nin: ' -> msg; tra.doPT -> msg
               #)if)if);
            #);
          enterType::
            (#
            do NA.enterType -> TP[]
            #)
       #);
     AttributeDenotation::<
       (* there may be one NameApl which may be empty *)
       (# setImplicitSuper:
            (# vDcl: ^NameDecl; NA: ^NameApl
            enter vDcl[]
            do (if sons.length = 1 then
                   scansons(#do current[] -> NA[]; vDcl[] -> NA.setImplicitSuper #);
               if)
            #);
          isSimple: BooleanValue
            (# ND: ^Denotation
            do L:
                 (#
                 do scansons
                    (#do (if current## 
                          // thisObj## then
                             'isSimple:incomplete' -> LG.Tn;
                             false -> value; 
                             leave L; 
                          // indexed## then 
                             'isSimple:incomplete' -> LG.Tn;
                             true -> value; 
                             leave L; 
                         if);
                       current[] -> ND[] 
                    #);
                    ND.dcl.isSimple -> value;
                    (* 'AD:isSimple: ' -> puttext; ND.N.lexemSy -> puttext;
                     ':' -> puttext; (if value then 'true' -> putline else 'False'->putline if)
                     *)
                 #)
            #);
          setupOrigin::
            (# (* OBS! origin is not correct for remote names in R.x.y.z *)
            do scansons(#do origin[] -> current.setupOrigin #)
            #);
          check::
            (# first: @boolean; desc: ^ObjectDesc
            do true -> first;
               scansons
               (# (* currently NameApls: N1.N2.N3 *)
                  NA,remote: ^denotation;
               do (if first then (* find in origin *)
                      (if origin[] = none then 'NA:origin none'->putline; dopt->putline if);
                      current[] -> NA[] -> remote[];
                      ('Checkfirst',doPT) -> LG.TTn;
                      NA.checkFirst;
                   else (* find in descriptor *)
                      (if desc[] = none then 
                          ('AttributeDenotation: desc is none',doPt) -> LG.TTn;
                          'desc is none'->putline;
                          doPT -> putline
                       else                          
                          (if not desc.isChecked then
                              (if desc.beingChecked then
                                 (* '***** Fatal error: recursion in cheking: ' -> putline;
                                  desc.doPt -> putline*)
                           else
                                  desc.check
                          if)if);
                          (if (remote.dcl[] <> none) and (remote.dcl.primNo <> prim.thisCore) then
                              (* Gives an error in: R: ^pattern.pattern
                               * remote[] -> remote.isObject;
                               *)
                          if)
                      if);

                      (if not desc.isOrBeingChecked then
                          (* call predDesc[] -> desc.check
                           * where 
                           *   if first: predDesc = origin of R i R.x.y.z
                           *   else preDesc = R.desc for x, etc
                           *)
                          (if true then
                              'AttributeDenotation: "' -> puttext; 
                              doPT -> puttext; '" ' -> puttext;
                              'desc is not checked: descNo = ' -> puttext;
                              desc.descNo -> putint; newline;
                              desc.doPT -> putline;
                          if)
                      if);
                      desc[] -> current.origin[]; (* confuses theModule that assumes
                                                   * the correct origin - problem with
                                                   * semanticError - a fix is made in
                                                   * AbstractSyntaxTree::theModule
                                                   *)
                      current.check;
                  if);
                  current[] -> lastDen[]; 
                  (if (lastDen.desc <>none) and
                      (lastDen.dcl[] <> none) and (lastDen.dcl.primNo = prim.thisCore) then 
                      (# dcl: ^nameDecl; withAD: ^AttributeDenotation; 
                         withP: ^withPart; on: @integer
                      do 'Core' -> origin.search -> (withAD[],withP[],dcl[],on);
                         (if dcl[] <> none then
                            (* 'core: ' -> puttext; lastDen.doPT -> putline;
                             * dcl.doPT -> putline;
                             *)
                             dcl.desc -> desc[] -> theDesc[];
                             (if not desc.isCore then
                                 '\n\n**** Core is not %core%'->putline
                             if);
                             (*desc.doPT -> putline;*)
                          else
                             '\n\n****** No Core pattern defined\n'->putline
                         if);
                      #)
                   else
                      lastDen.desc -> desc[] -> theDesc[]
                  if);
                  false -> first
               #);
               (if theDesc[] = none then 'desc:still:none' -> LG.Tn if)
            #);
          enterType:: 
            (# NA: ^denotation 
            do (if theDesc[] = none then
                   ('AttributeDenotation:not:checked:',doPT) -> LG.TTn;
                   check
               if);
               scansons(# do current[] -> NA[] #); 
               NA.enterType -> TP[]
            #);
          exitType:: 
            (# NA: ^denotation 
            do scansons(# do current[] -> NA[] #); 
               NA.ExitType -> TP[]
            #);
          lastDen: ^Denotation;
          theDesc: ^ObjectDesc;
          desc: 
            (# D: ^ ObjectDesc 
            do (if theDesc[] = none then (* we do come here! *) 
                   ('Attributedenotation','theDesc:IsNone:notChecked') -> LG.TTn;
                   (if true then
                       check
                    else
                       &ObjectDesc[] -> theDesc[];
                   if)
               if);
               theDesc[] -> D[]
            exit D[] 
            #);
          myDesc:: (# do desc -> OD[]#)
       #);
     NameApl::<
       (# setImplicitSuper:
            (# vDcl: ^NameDecl
            enter vDcl[]
            do (if isEmpty then
                   vDcl.lexemSy -> NewLexem -> N[] -> Append;
                   true -> isImplicitSuper;
                   1 -> ON
               if)
            #);
          setuporigin:: 
            (# 
            do (if origin[] = none then 
                   'setUpOrigin:' -> puttext; 
                   doPT -> puttext;  
                   '-origin is none'->putline 
               if)
            #);
          checkFirst::
            (#
            do true -> check
            #);
          check:: (* NameApl:: check must probably have objectDesc as argument for search
                   * in order to handle remote names correctly - see attributeDenotation
                   *)
            (# org: ^ObjectDesc;
               encModule:
                 (# m: ^node; md: ^module
                 do origin[] -> m[];
                    L:
                      (if not (m## <= module##) then
                          m.origin[] -> m[];
                          restart L
                      if);
                    m[] -> md[]
                 exit md[]
                 #);
               first: @boolean
            enter first
            do 
               (if N[] <> none then 
                   ('Search', N.lexemSy) -> LG.TTn;
                   (if origin[] = none then 'NA:origin none'-> LG.Tn if);
                   (if isImplicitSuper then
                       origin[] -> org[];
                       N.lexemSy -> org.superSearch -> dcl[]
                    else
                       (if not first then 
                           ('NotFirst',N.lexemSy) -> LG.TTn;
                           N.lexemSy -> origin.localSearch -> dcl[];
                       else
                           N.lexemSy -> origin.search -> (withAD[],withP[],dcl[],on);
                           (if isSuper then
                               on + 1 -> on
                           if)
                       if)
                   if);
                   (if dcl[] = none then
                       this(node)[] -> SemanticError
                       (#do 'Not found: ' -> msg; N.lexemSy -> msg #);
                       ('Not found',N.lexemSy) -> LG.TTn;
                       errorDecl[] -> dcl[]
                    else
                       (# MI: ^ModuleItem
                       do 
                          (if dcl.itm[] <> none then
                              (if dcl.itm.isModule then
                                  dcl.itm[] -> (encModule).imports.add;
                                  (if false then
                                      dcl.itm[] -> MI[];
                                      'Use: ' -> puttext; MI.md.name.lexemSy -> puttext;
                                      ' in: ' -> puttext;
                                      (encModule).name.lexemSy -> putline
                              if)if)
                           else                              
                              'dcl.itm is none: '->puttext; doPt -> putline;
                              origin.doPt -> putline
                       if)#);
                              
                       ('Found',N.lexemSy) -> LG.TT;
                       ('on',on) -> LG.TI;
                       ('off',dcl.off ) -> LG.TIn;
                   if)
                else
                   ('NameApl:N is none') -> LG.T;
                   (if isEmpty then
                       ('isEmpTy') -> LG.Tn
                    else
                       LG.n
                   if)
               if);
            #);
          isVar:: BooleanValue
            (#
            do not dcl.isSimple -> value
            #);
          isObject:: (# do NA[] -> dcl.isObject #);
          desc::
            (# 
            do (if isEmpty and not isImplicitSuper then
                   ('NA:empty:superPattern',doPT) -> LG.TTn;
                   (if superObject[] = none then
                       'SuperObject:isNone' -> LG.Tn
                   if);
                   (* this implies that superObject has itself as super *)
                   superObject[] -> theDesc[]
                else
                   (if dcl[] <> none then
                       dcl.desc -> theDesc[];
                       (if theDesc[] = none then 
                           ('NameApl:theDesc:none',N.lexemSy) -> LG.TTn;
                           (if false then
                               '\n*** nameApl:Desc is none: ' -> puttext; doPT -> putline
                           if)
                       if)
                    else 
                       (if N[] = none then
                           ('NameApl:desc:dcl none') -> LG.Tn 
                        else
                           ('NameApl:desc:dcl none',N.lexemSy) -> LG.TTn 
                       if);
                       (if false then
                           '\n*** nameApl:Desc is none: "' -> puttext; 
                           doPt -> puttext; '"' ->putline
                   if)
               if)if)
            #);
          myDesc::(# do desc -> OD[] #);
          isDataItem:: (# do dcl.isDataItem -> value #);
          isPtn:: (# do dcl.isPtn -> value #);
          enterType:: 
            (# 
            do (if not isEmpty or isImplicitSuper then
                   (if dcl.primNo 
                    // prim.put // prim.sendMsg // prim._break 
                    // prim.attach //prim.fork // prim.cmpAndSwap 
                       // prim.sleep then
                       primitive_type -> TP[]
                    else
                       (if desc <> none then
                           (desc).enterType -> TP[]
               if)if)if)
            #);
          exitType:: 
            (# 
            do (if not isEmpty or isImplicitSuper then
                   (if dcl.primNo // prim.get // prim.sendMsg // prim.cmpAndSwap then
                       primitive_type -> TP[]
                    else
                       (if desc <> none then
                           (desc).exitType -> TP[] 
               if)if)if)
            #);
       #);
     Indexed::<
       (# setupOrigin::
            (#
            do origin[] -> NA.setupOrigin;
               origin[] -> inx.setupOrigin;
            #); 
          checkFirst:: (# do true -> check #);
          check::
            (# first: @boolean;
            enter first
            do first -> NA.check;
               NA.dcl[] -> dcl[]; (* not so nice *)
               NA.on -> on; (* not either nice *)
               inx.check;
            #);
          desc:: 
            (# repItem: ^repetition
            do (if dcl[] <> none then 
                   dcl.itm[] -> repItem[];
                   repItem.IT.desc -> theDesc[] 
               if);
            #);
          myDesc:: (# do desc -> OD[] #);
          enterType:: (# do value_type -> TP[] #); (* not complete *)
          exitType:: (# do value_type -> TP[] #);
       #);
     thisObj::<
       (# setupOrigin::
            (#
            do origin[] -> ptn.setupOrigin;
            #);
          checkFirst:: (# do true -> check #);
          check::
            (# first: @boolean
            enter first
            do ('thisObj:check',dopt) -> LG.TTn;
               true -> ptn.check;
               ptn.dcl[] -> dcl[]; (* not so nice *)
               ptn.on -> on; (* not either nice *)
            #);
          desc::
            (#
            do (if theDesc[] = none then
                   check;
               if);
               ptn.desc -> theDesc[];
               (if theDesc[] = none then
                   'thisObj:theDescIsNone again:'->putline; dopt->putline;
               if)
            #);
          myDesc:: (# do ptn.myDesc -> OD[]#);          
          enterType:: (# do desc -> ref_type -> TP[] #); (* not correct *)
          exitType:: (# do desc -> ref_type -> TP[] #);
       #);
     single_type: type
       (# OD: ^objectDesc;
          theDesc:: (# do OD[] -> D[] #);
          append::
            (# L_TP: @list_type
            do this(single_type)[] -> L_TP.add;
               L_TP[] -> TP.appendToList
               (*L_TP[] *)-> returnTP[]
            #);
          appendToList::
            (# L_TP: ^list_type
            do TPx[] -> L_TP[];
               this(single_type)[] -> L_TP.add;
               L_TP[] -> returnTP[]
            #);
       enter OD[] 
       #);
     value_type: single_type 
       (# isValue::trueValue;
          print:: (# do'value' -> out.puttext #);
          match:: 
            (# 
            do (if (left[] <> none) and  not left.isValue and not left.isPrimitive then
                   NX_error -> value
               if)
            #)
       #);
     ref_type: single_type
       (# isRef:: trueValue;   
          print:: (# do 'ref' -> out.puttext #);
          match::
            (# 
            do (if (left[] <> none) and not left.isNone and not left.isRef and not left.isPrimitive then
                   NX_error -> value
                else
                   (if not left.isNone and left.isRef then
                      (* '\n*** qua check:'->putline;
                       (left.theDesc).doPT -> putline; '<'->put; OD.doPT -> putline;*)
                       (if ((left.theDesc,OD[]) -> quaCheck) then
                           (if ((OD[],left.theDesc) -> quaCheck) then
                               QUA_error -> value
                            else
                               QUA_runTimeCheck -> value
                           if);
                           (*(left.theDesc).doPT -> putline; OD.doPT -> putline *)
                       if)
               if)if)
            #);
          matchList:: (#do NX_error -> value #)
       #);
     strucRef_type: single_type
       (# isStrucRef:: trueValue;           
          print:: (# do 'struc' -> out.puttext #) ;
          match::
            (# left_R: ^strucRef_type
            do (if (left[] <> none) and not left.isNone and not left.isStrucRef and not left.isPrimitive then
                   NX_error -> value
                else
                   (if left.isStrucRef then
                      (* '\n*** struc: qua check:'->putline;
                       (left.theDesc).doPT -> putline; '<'->put; OD.doPT -> putline*)
                       (if ((left.theDesc,OD[]) -> quaCheck) then
                           (if ((OD[],left.theDesc) -> quaCheck) then
                               QUA_error -> value
                            else
                               QUA_runTimeCheck -> value
                           if);
                           (*(left.theDesc).doPT -> putline; OD.doPT -> putline *)
                       if)
               if)if)
            #);
          matchList:: (#do NX_error -> value #)
       #);
     none_type: single_type
       (# isNone:: trueValue;
          print:: (# do 'none' -> out.puttext #);
          match:: (# do NX_error -> value #);
          matchList:: (#do NX_error -> value #)
       #);
     list_type: type
       (# elms: [3] ^type; top: @integer;
          isValue::
            (#
            do (if top = 1 then elms[1].isValue -> value  if)
            #);
          isRef::
            (#
            do (if top = 1 then elms[1].isRef -> value if)
            #);
          theDesc::(#do (if top = 1 then elms[1].theDesc -> D[] if)#);
          match::
            (#
            do (if top = 1 then
                   left[] -> elms[1].match -> value
                else 
                   this(list_Type)[] -> left.matchList -> value
               if)
            #);
          matchList::
            (# rTP: ^List_Type
            do TPx[] -> rTP[];
               L:
                 (if top = rTP.top then
                     (for i: top repeat 
                          (if (elms[i][] -> rTP.elms[i].match) = NX_error then
                              leave L
                     if)for)
                  else
                     NX_error -> value
                 if)
            #);
          add:
            (# TP: ^type
            enter TP[]
            do (if (top+1-> top) > elms.range then
                   elms.range -> elms.extend
               if);
               TP[] -> elms[top][]
            #);
          scan: 
            (# current: ^type 
            do (for i: top repeat elms[i][] -> current[]; inner for)
            #);
          append::
            (#
            do this(list_type)[] -> TP.appendTolist
               (*this(list_type)[] *)-> returnTP[]
            #);
          appendToList::
            (# L_TP: ^list_type
            do TPx[] -> L_TP[];
               (for i: L_TP.top repeat
                    L_TP.elms[i][] -> add
               for);
               this(list_type)[] -> returnTP[]
            #);
          print:: 
            (# 
            do 'list(' -> out.puttext;
               (for i: top repeat 
                    (if elms[i][] = none then
                        'none' -> out.puttext
                     else
                        elms[i].print -> out.puttext
                    if);
                    (if i < top then ',' -> out.put if)
               for);
               ')' -> out.put
            #)
       #);
     primitive_type : type
       (# isPrimitive:: trueValue;
          print:: (# do 'primitive_type' -> out.puttext #);
       #);
     null_type: type
       (# print:: (#do 'null' -> out.puttext #);
          match:: (# do NX_error -> value #);
       #);
     quaCheck: booleanValue
       (# left,right,OD: ^objectDesc
       enter(left[],right[])
       do left[] -> OD[];
          loop:
            (if OD[] = right[] then (* ok *)
             else 
                (if not (left.isChecked and right.isChecked) then
                    (* OBS! QuaCheck is not complete
                     * 'Not checked' -> putline;*)
                    'OOPS'->putline;
                    leave loop
                if);
                OD.superDesc[] -> OD[]; 
                (if (OD[] = none) or (OD[] = superObject[]) then
                    (if not ((OD[] = none) and (right[] = superObject[])) then
                        true -> value
                    if)
                 else 
                    restart loop
            if)if)
       #);
     (* superObject is declared in parser.bet *)
     repetitionDesc,structureRefDesc, immutableDesc,
     integerDesc,charDesc,booleanDesc,textDesc,
     processEventDesc: ^ObjectDesc;
     errorDecl: ^nameDecl;
     
     newDesc: @
       (# OD: [16] ^ObjectDesc; 
          noOfDescs: @integer;
          anOD: ^ObjectDesc;
          getOD: 
            (# descNo: @integer; anODx: ^ObjectDesc 
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   repetitionDesc[] -> anODx[]
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a ststic item, no enter-part as in genMain
                     * implies thta anOD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #);
     
     MS: @
        (# D: [64] ^module; top: @integer;
          add:
            (# OD: ^module
            enter OD[]
            do (if (top+1 -> top) > D.range then D.range -> D.extend if);
               OD[] -> D[top][]
            #);
          scan:
            (# current: ^module
            do (for i: top repeat
                    D[i][] -> current[];
                    inner
               for)
            #)
       #);
       
     DS: @
       (# D: [64] ^objectDesc; top: @integer;
          add:
            (# OD: ^objectDesc
            enter OD[]
            do (if (top+1 -> top) > D.range then D.range -> D.extend if);
               OD[] -> D[top][];
               ('DS.add',OD.doPT) -> LG.TTn;
            #);
          scan:
            (# current: ^objectDesc
            do (for i: top repeat
                    D[i][] -> current[];
                    inner
               for)
            #)
       #);
     
     prim: @Primitives;
     
     hasErrors: booleanValue(# do hasSyntaxError or semanticErrors -> value #);
     
     semanticErrors: @boolean;     

  do 'CHECKING' -> puttext;
     (if fullPath and false then ': Single module' -> putline else newline if);
     
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     (if false and (theModule[] <> none) then
         'theModule<>none'->putline;
         theModule.origin[] -> rootModule.setUpOrigin;
         rootModule.check; (* dir[] <> none if fullPath, i.e. single component *)
      else
         (if false then
             'Rootmodule: ' -> puttext; rootmodule.name.lexemSy -> putline;
         if);
         none -> rootModule.origin[];
         rootModule.setUpOrigin; 
     if);
     
     DS.scan(# do current.check #); 
     
     textDesc.theModule -> rootModule.imports.addM;
     (if semanticErrors then
         '**** Semantic errors in program - compilation stops' -> putline
      else
         INNER;
     if);
  #)

