ORIGIN 'parser';
INCLUDE '~beta/sysutils/envstring'
---parserlib:attributes---
FragmentDir: FragmentEntry
  (# PP:: (# do 'FragmentDir' -> lx.puttext #);
     length:: (# do 11 (*?*) -> value #);
     PT::
       (#
       do (if not expand then true -> expand; doExpand if);
          (pos,length) -> block
          (#
          do '**** Beta file directory ' -> lx.append;
          #)
       #);
     label:: (#do 'FragmentDir' -> lab[] #);
     getEntries::
       (#
       do (*'**   FragmentDir:getEntries:'->putline;*)
          (if not expand then true -> expand; doExpand if);
          scanSons
          (# F: ^FragmentEntry 
          do current[] -> F[];
             (F.fileName[] ,F[]) -> add 
          #)
       #);
     entity:: (# do  this(fragmentDir)[] -> E[] #);
     sort::
       (#
       do (if not expand then
              true -> expand;
              doExpand
          if);
          this(fragmentDir)[] -> S[]
       #);
     kind:: (# do '/' -> ch #);
     skind:: (# do ': /' -> S[] #);
     isAmodule::
       (#
       do (if BetaBrowser then 
              '**** isBetaBrowser:FragmentDir' -> putline if);
       #);
     doExpand:
       (#
       do (path[],true) -> getBetaDirectories
          (#
          do scan
             (# N: ^lexem; FG: ^FragmentEntry
             do (if currentIsFile then
                    (* 'File: ' -> puttext; 
                     * current[] -> (path.copy).append -> putline;*)
                    (if true then
                        current[] -> newlexem -> N[];
                     else
                        'FragmentFile' -> newlexem -> N[];
                    if);
                    (N[],current[] -> (path.copy).append ,current[])
                      -> FragmentFile -> FG[]
                      -> append;
                    (if FG.inFile[] = none then
                        '**** FG.inFile is none' -> putline;

                    if)
                 else
                    (*'Dir: ' -> puttext;*)
                    (*current[] -> (path.copy).append -> dirs.add;*)
                    'FragmentDir' -> newlexem -> N[];
                    (N[],current[] 
                      -> (path.copy).append,current[],false) 
                      -> FragmentDir -> append
                if);
                (* current[] -> putline*)
          #)#);
          (*'**** FragmentDir:sons:'->putline; 
           * scanSons(#do current.dopt -> putline #)*)
       #);

     expand: @boolean
  enter expand
  do '/' -> path.put; (*path[] -> putline;*)
     (if expand then
         doExpand
     if);
     (* fils.parse;
      dirs.handle     *)
  #);

FragmentFile: FragmentEntry
  (# PP:: (# do 'FragmentFile' -> lx.puttext #);
     PT:: 
       (# 
       do (if false then 
              '**** Beta source file'-> lx.append 
           else
              'properties: ' -> lx.append;
              props.dopt;
              (if frags[] <> none then
                  frags.scanSons
                  (# 
                  do (pos,break) -> current.PT
                  #)
               else
                  '*** frags is none ' -> putline;
              if)              
          if)
       #);
     label:: (#do 'fragmentFile:' -> lab[] #);
     getEntries::
       (#
       do ('Props',props[]) -> add;
          (if frags[] <> none then
              frags.scanSons
              (# F: ^fragment 
              do current[] -> F[]; 
                 (F.name.lexemSy,F[]) -> add 
          #)if)
       #);
     sort:: (# do this(fragmentFile)[] -> S[] #);
     entity:: (# do this(fragmentFile)[] -> E[] #);
     kind:: (# do ' ' -> ch #);
     skind:: (# do ': /' -> S[] #);
     isAmodule::
       (#
       do (if BetaBrowser then 
              '**** isBetaBrowser:FragmentFile' -> putline;
              &iModule[] -> M[]; this(FragmentFile)[] -> M.M[] 
          if);
       #);
     replaceEntity::
       (#
       do '**** FragmentFile: replaceEntry: ' -> putline;
          T[] -> putline;
          T[] -> parseSubtext
          (#
          do Properties -> Props[] -> append;
             (if lex.symb = lex.symbols.frag then 
                 lex;
                 Fragments -> Frags[] -> append
          if)#)
       #);
     Props:  ^Properties;
     Frags: ^Fragments;
  do 'Parse: ' -> puttext; fileName[] -> putline;
     path[] -> superParser
     (#
     do this(superParser).fileName[] -> this(FragmentFile).pathToFN[];
        this(superParser).inFile[] -> this(FragmentFile).inFile[];
        Properties -> Props[] -> append;
        (if lex.symb = lex.symbols.frag then 
            lex;
            Fragments -> Frags[] -> append
     if)#)
  #);
Properties: node
  (# PP:: (# do Label -> lx.puttext #);
     length:: (# do 400 -> value #);
     PT:: (# do scanSons(# do current.PT; ';' -> lx.put; lx.newline #)#);
     label:: (# do 'Properties' -> lab[] #);
     getEntries:: 
       (# do scanSons(# P: ^Property do current[] -> P[]; (P.name,current[]) -> add #)
       #);
     sort:: (# do this(Properties)[] -> S[]#);
     entity:: (# do this(Properties)[] -> E[]#);
     kind:: (# do ' '-> ch #);
     skind:: (# do ': ' -> S[] #);
     replaceEntity::
       (#
       do '**** Properties:replaceEntry: ' -> putline;
          T[] -> putline
       #);
  do L:
       (if lex.symb 
        // lex.symbols.idf then
           Property -> append;
           (if lex.symb = lex.symbols.semicolon then 
               lex;
               restart L
           if)
        // lex.symbols.frag then (* no properties *)
        // lex.symbols.eos then (* empty file *)
        else
           SyntaxError
       if)
  #);
Property: node
  (# PP:: (# do Label -> lx.puttext #);
     length:: (# do 100 -> value #);
     PT:: (# do scanSons (# do current.PT; ' ' -> lx.put  #)#);
     label:: (# do 'Property' -> lab[] #);
     name: 
       (# N: ^text 
       do L: scanSons(# do current.lexemSy -> N[]; leave L #) 
       exit N[] #);
     sort:: (# do this(Property)[] -> S[] #);    
     entity:: (# do this(Property)[] -> E[] #);  
     kind:: (# do ' '-> ch #);
     skind:: (# do ': ' -> S[] #);
     replaceEntity::
       (#
       do '**** Property:replaceEntry: ' -> putline;
          T[] -> putline
       #);
  do L:
       (if lex.symb
        // lex.symbols.textSy then
           aText -> append;
           restart L
        // lex.symbols.charSy then
           aChar -> append;
           restart L
        // lex.symbols.idf 

        // lex.symbols.const then
           lex.sym[] -> newlexem -> append;
           lex;
           restart L
       if);
  #);
Fragments: node
  (# PT:: (# do '--Fragments'-> lx.puttext #);
     label:: (# do 'Fragments:' -> lab[] #);
     sort:: (# do this(Fragments)[] -> S[] #);
     entity:: (# do this(Fragments)[] -> E[] #);
     getEntries::
       (#
       do '**** Fragments:getEntries:' -> putline;
          scanSons(# F: ^Fragment do current[] -> F[]; (F.name.item[],cat[]) -> add #)
       #);
     kind:: (# do '-'-> ch #);
     skind:: (#do ': -' -> S[] #);
     name,cat,language: ^Lexem
  do  loop:
       (if lex.symb = lex.symbols.idf then
          lex.sym[] -> newLexem -> name[];
          lex; 
          (if lex.symb = lex.symbols.colon then
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> newLexem -> cat[];
                  lex;
                  (if lex.symb = lex.symbols.colon then
                      lex;
                      (if lex.symb = lex.symbols.idf then 
                          (* --- x:objectDesc:beta --- *)
                          lex.sym[] -> newLexem -> language[];
                          lex;                          
                       else
                          SyntaxError
                      if)
                   else
                      'BETA'-> newLexem -> language[];
                  if);
                  (if lex.symb = lex.symbols.frag then
                      lex;
                      (if true 
                       // 'descriptor' -> (cat.lexemSy).equalNCS 
                       // 'descriptorForm' -> (cat.lexemSy).equalNCS then
                          (name[],cat[],language[]) -> ObjDescFrag -> append;
                       // 'attributes' -> (cat.lexemSy).equalNCS 
                       // 'attribute' -> (cat.lexemSy).equalNCS then
                          (name[],cat[],language[]) -> AttFrag -> append
                       // 'doPart' -> (cat.lexemSy).equalNCS then 
                          (name[],cat[],language[]) -> doPartFrag -> append
                       // 'mainPart' -> (cat.lexemSy).equalNCS then
                          'MainPart category is not implemented' -> putline
                       else
                          'Unknown category: ' -> puttext; cat.lexemSy -> putline
                      if);
                      (if lex.symb = lex.symbols.frag then 
                          lex;
                          restart loop
                      if);
                   else
                      SyntaxError
                  if)
               else
                  SyntaxError
              if)
           else
              SyntaxError
          if)
       else
          SyntaxError
      if);
  #);
Fragment: node
  (* Super pattern for ObjDescFrag, AttFrag and doPartFrag *)
  (# (*PT:: (# do 'Fragment'-> lx.append #);
     label:: (#do '::fragment'-> lab[] #);*)
     (* entity:: (# do this(Fragment)[] -> E[] #);
     sort:: (# do this(Fragment)[] -> S[] #);*)
     kind:: (# do '-' -> ch #);
     skind:: (# do ': -' -> S[] #);
     replaceEntity::<
       (#
       do '*** Fragment:replaceEntry: ' -> putline;
          inner
       #);
     name,cat,language: ^Lexem
  enter(name[],cat[],language[])
  do inner
  #);
ObjDescFrag: Fragment
  (# PT:: 
       (# 
       do '\n---' -> lx.append; name.item[] -> lx.append;
          ':descriptor---' -> lx.append;
          (pos,break) -> OD.PT
       #);
     label:: (# do 'ObjDescFrag' -> lab[] #);
     getentries::(#do OD.getentries -> (names[],entries[]) #);
     entity:: (# do OD[] -> E[] #);
     sort:: (# do OD[] -> S[] #);
     replaceEntity::
       (#
       do '*** ObjDescFrag:replaceEntry: ' -> putline;
          T[] -> putline;
          inner
       #);
     OD: ^ObjectDesc
  do PatternDen -> ObjectDesc -> OD[]
  #);
AttFrag: Fragment
  (# PT:: 
       (# 
       do '---' -> lx.append; name.item[] -> lx.append;
          ':attributes---\n' -> lx.append;
          (pos,break) -> att.PT
       #);
     label:: (#do 'AttFrag:'->lab[] #);
     length:: (# do att.length -> value #);
     getentries::(#do att.getEntries -> (names[],entries[]) #);
     entity:: (# do att[] -> E[] #);
     sort:: (# do att[] -> S[] #);
     replaceEntity::
       (#
       do '*** AttFrag:replaceEntry: ' -> putline;
          T[] -> putline;
          inner
       #);     
     att: ^Attributes
  do Attributes -> att[]
  #);
doPartFrag: Fragment
  (# PT:: 
       (# 
       do '---' -> lx.append; name.item[] -> lx.append;
          ':doPart---\n' -> lx.append;
          (pos,break) -> ACP.PT 
       #);
     label:: (# do 'doPartFrag' -> lab[] #);
     length::(# #);
     getEntries:: (# do ('Do-part',ACP[]) -> add #);
     replaceEntity::
       (#
       do '*** doPartFrag:replaceEntry: ' -> putline;
          T[] -> putline;
          inner
       #);
     ACP: ^ActionPart
  do ActionPart -> ACP[]
  #)
---parseStdBetax:doPart---
do '\n---ParseStdBeta:'->putline;
   
   (# StdPath: ^text;
      FD: ^FragmentDir;
      name: @Lexem
   do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
      (if stdpath[] = none then 'none'->putline if);
      StdPath[] -> putline;
      'A fragment' -> name.item[];
      (name[],StdPath[],'',true) -> FragmentDir -> FD[];
      (name[],FD[]) -> FragmentModule -> betaLib[];
      (*FD.doPT -> putline*)
   #)
   
