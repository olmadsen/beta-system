ORIGIN 'parser';
INCLUDE '~beta/sysutils/envstring'
---parserlib:attributes---
FragmentDir: FragmentEntry
  (# PP:: (# do 'FragmentDir' -> lx.puttext #);
     length:: (# do 11 (*?*) -> value #);
     PT::
       (#
       do (if not expand then true -> expand; doExpand if);
          (pos,length) -> block
          (#
          do '**** Beta file directory ' -> lx.append;
          #)
       #);
     label:: (#do 'FragmentDir' -> lab[] #);
     getEntries::
       (#
       do (*'**   FragmentDir:getEntries:'->putline;*)
          (if not expand then true -> expand; doExpand if);
          scanSons
          (# F: ^FragmentEntry 
          do current[] -> F[];
             (F.fileName[] ,F[]) -> add 
          #)
       #);
     entity:: (# do  this(fragmentDir)[] -> E[] #);
     sort::
       (#
       do (if not expand then
              true -> expand;
              doExpand
          if);
          this(fragmentDir)[] -> S[]
       #);
     kind:: (# do '/' -> ch #);
     skind:: (# do ': /' -> S[] #);
     isAmodule::
       (#
       do (if BetaBrowser then 
              '**** isBetaBrowser:FragmentDir' -> putline if);
       #);
     doExpand:
       (#
       do (path[],true) -> getBetaDirectories
          (#
          do scan
             (# N: ^lexem; FG: ^FragmentEntry
             do (if currentIsFile then
                    (* 'File: ' -> puttext; 
                     * current[] -> (path.copy).append -> putline;*)
                    current[] -> newlexem -> N[];
                    (N[],current[] -> (path.copy).append ,current[])
                      -> FragmentFile -> FG[]
                      -> append;
                    (if FG.inFile[] = none then
                        '**** FG.inFile is none' -> putline
                    if)
                 else
                    (*'Dir: ' -> puttext;*)
                    (*current[] -> (path.copy).append -> dirs.add;*)
                    'FragmentDir' -> newlexem -> N[];
                    (N[],current[] 
                      -> (path.copy).append,current[],false) 
                      -> FragmentDir -> append
                if);
                (* current[] -> putline*)
          #)#);
       #);

     expand: @boolean
  enter expand
  do '/' -> path.put; (*path[] -> putline;*)
     (if expand then
         doExpand
     if);
     (* fils.parse;
      dirs.handle     *)
  #);

FragmentFile: FragmentEntry
  (# PP:: (# do 'FragmentFile' -> lx.puttext #);
     PT:: 
       (# 
       do (if props[] <> none then (pos,break) -> props.PT; else 'props'->putline; if);
          (if pos > 0 then 
              (* A comment with no linebreak may have been printed in props *)
              (pos,true) -> mkBreak
          if);
          (if frags[] <> none then (pos,break) -> frags.PT else 'frags'->putline if)
       #);
     label:: (#do 'fragmentFile:' -> lab[] #);
     getEntries::
       (#
       do ('Props',props[]) -> add;
          (if frags[] <> none then
              frags.scanSons 
              (# F: ^fragment do current[] -> F[]; (F.name.lexemSy,F[]) -> add #)
          if);
       #);
     sort:: (# do this(fragmentFile)[] -> S[] #);
     entity:: (# do this(fragmentFile)[] -> E[] #);
     kind:: (# do ' ' -> ch #);
     skind:: (# do ': /' -> S[] #);
     isAmodule::
       (#
       do (if BetaBrowser then 
              &iModule[] -> M[]; this(FragmentFile)[] -> M.M[] 
          if);
       #);
     replaceEntity::
       (#
       do '**** FragmentFile:replaceEntry: ' -> putline;
          T[] -> parseSubtext
          (#
          do Properties -> Props[] -> append;
             (if lex.symb = lex.symbols.frag then 
                 lex;
                 Fragments -> Frags[] -> append
          if)#)
       #);
     Props:  ^Properties;
     Frags: ^Fragments;
  do (*'Parse: ' -> puttext; fileName[] -> putline;*)
     path[] -> superParser
     (#
     do this(superParser).fileName[] -> this(FragmentFile).pathToFN[];
        this(superParser).inFile[] -> this(FragmentFile).inFile[];
        Properties -> Props[] -> append;
        (if lex.skipComment.comment.length > 0 then
            '**** FragmentFile:after:props:unused comment: ' -> puttext;
            lex.skipComment.comment[] -> putline
        if);
        (if lex.symb = lex.symbols.frag then 
            lex;
            Fragments -> Frags[] -> append
        if);
     #);
     (if lex.skipComment.comment.length > 1 then
         '**** FragmentFile:unused comment: ' -> puttext; 
         Lex.skipCOmment.comment[] -> putline
     if)
  #);
Properties: node
  (# PP:: (# do Label -> lx.puttext #);
     length:: (# do 400 -> value #);
     PT:: (# do scanSons(# do current.PT; ';' -> lx.put; lx.newline #)#);
     label:: (# do 'Properties' -> lab[] #);
     getEntries:: 
       (# 
       do scanSons(# P: ^Property do current[] -> P[]; (P.name,current[]) -> add #)
       #);
     sort:: (# do this(Properties)[] -> S[]#);
     entity:: (# do this(Properties)[] -> E[]#);
     kind:: (# do ' '-> ch #);
     skind:: (# do ': ' -> S[] #);
     replaceEntity::
       (#
       do '**** Properties:replaceEntry: ' -> putline;
          T[] -> putline
       #);
     prop: ^Property
  do L:
       (if lex.symb 
        // lex.symbols.idf then
           Property -> prop[] -> append;
           (if lex.symb = lex.symbols.semicolon then 
               lex;
               restart L
           if)
        // lex.symbols.frag then (* no properties *)
        // lex.symbols.eos then (* empty file *)
        else
           SyntaxError
       if);
     prop.addCommentAfter
  #);
Property: node
  (# PP:: (# do Label -> lx.puttext #);
     length:: (# do 100 -> value #);
     PT:: 
       (# 
       do breakIfNotAtEol;
          scanSons (# do current.PT; (if not isLast then ' ' -> lx.put if)#)
       #);
     label:: (# do 'Property' -> lab[] #);
     name: 
       (# N: ^text 
       do L: scanSons(# do current.lexemSy -> N[]; leave L #) 
       exit N[] #);
     sort:: (# do this(Property)[] -> S[] #);    
     entity:: (# do this(Property)[] -> E[] #);  
     kind:: (# do ' '-> ch #);
     skind:: (# do ': ' -> S[] #);
     replaceEntity::
       (#
       do '**** Property:replaceEntry: ' -> putline;
          T[] -> putline
       #);
  do L:
       (if lex.symb
        // lex.symbols.textSy then
           aText -> append;
           restart L
        // lex.symbols.charSy then
           aChar -> append;
           restart L
        // lex.symbols.idf 

        // lex.symbols.const then
           lex.sym[] -> newlexem -> append;
           lex;
           restart L
       if);
  #);
Fragments: node
  (# PT:: 
       (# 
       do (if comment[] <> none then
              'Fragments has comment: ' -> lx.puttext; comment[] -> lx.putline
          if);
          scanSons
          (# 
          do (pos,break) -> current.PT
          #) 
       #);
     label:: (# do 'Fragments' -> lab[] #);
     sort:: (# do this(Fragments)[] -> S[] #);
     entity:: (# do this(Fragments)[] -> E[] #);
     getEntries::
       (#
       do scanSons
          (# F: ^Fragment 
          do current[] -> F[]; 
             (F.name.item[],cat[]) -> add; 
          #)
       #);
     kind:: (# do '-'-> ch #);
     skind:: (#do ': -' -> S[] #);
     name,cat,language: ^Lexem;
     frag: ^Fragment
  do  loop:
       (if lex.symb = lex.symbols.idf then
          lex.sym[] -> newLexem -> name[];
          lex; 
          (if lex.symb = lex.symbols.colon then
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> newLexem -> cat[];
                  lex;
                  (if lex.symb = lex.symbols.colon then
                      lex;
                      (if lex.symb = lex.symbols.idf then 
                          (* --- x:objectDesc:beta --- *)
                          lex.sym[] -> newLexem -> language[];
                          lex;                          
                       else
                          SyntaxError
                      if)
                   else
                      'BETA'-> newLexem -> language[];
                  if);
                  (if lex.symb = lex.symbols.frag then
                      lex;
                      (if true 
                       // 'descriptor' -> (cat.lexemSy).equalNCS 
                       // 'descriptorForm' -> (cat.lexemSy).equalNCS then
                          (name[],cat[],language[]) 
                            -> ObjDescFrag -> frag[] -> append;
                       // 'attributes' -> (cat.lexemSy).equalNCS 
                       // 'attribute' -> (cat.lexemSy).equalNCS then
                          (name[],cat[],language[]) 
                            -> AttFrag -> frag[] -> append
                       // 'doPart' -> (cat.lexemSy).equalNCS then 
                          (name[],cat[],language[]) 
                            -> doPartFrag -> frag[] -> append
                       // 'mainPart' -> (cat.lexemSy).equalNCS then
                          '\n!!!! MainPart category is not implemented' 
                            -> putline
                       else
                          'Unknown category: ' -> puttext; 
                          cat.lexemSy -> putline
                      if);
                      (if lex.symb = lex.symbols.frag then 
                          lex;
                          restart loop
                      if);
                   else
                      SyntaxError
                  if)
               else
                  SyntaxError
              if)
           else
              SyntaxError
          if)
       else
          SyntaxError
       if);
     (if frag[] <> none then frag.addCommentAfter if)
  #);
Fragment: node
  (* Super pattern for ObjDescFrag, AttFrag and doPartFrag *)
  (# PT::< (# do breakIfNotAtEol; inner  #);
     (*label:: (#do 'Fragment'-> lab[] #); bound in subpatterns *)
     entity:: (# do this(Fragment)[] -> E[] #);
     sort:: (# do this(Fragment)[] -> S[] #);
     kind:: (# do '-' -> ch #);
     skind:: (# do ': -' -> S[] #);
     replaceEntity::<
       (#
       do '**** Fragment:replaceEntry: ' -> putline;
          inner
       #);
     name,cat,language: ^Lexem
  enter(name[],cat[],language[])
  do inner
  #);
ObjDescFrag: Fragment
  (# PT:: 
       (# 
       do '---' -> lx.append; name.item[] -> lx.append;
          ':descriptor---' -> lx.append;
          (pos,break) -> OD.PT
       #);
     label:: (# do 'ObjDescFrag' -> lab[] #);
     getentries::(#do OD.getentries -> (names[],entries[]) #);
     (*entity:: (# do this(ObjDescFrag)[] -> E[] #);
     sort:: (# do this(ObjDescFrag)[] -> S[] #);*)
     replaceEntity::
       (#
       do '**** ObjDescFrag:replaceEntry: ' -> putline;
          inner
       #);
     OD: ^ObjectDesc
  do PatternDen -> ObjectDesc -> OD[] -> append;
  #);
AttFrag: Fragment
  (# PT:: 
       (# 
       do '---' -> lx.append; 
          name.item[] -> lx.append;
          ':attributes---\n' -> lx.append;
          (pos,break) -> att.PT; 
       #);
     label:: (#do 'AttFrag'->lab[] #);
     length:: (# do att.length -> value #);
     getentries::(#do att.getEntries -> (names[],entries[]) #);
    (* entity:: (# do this(AttFrag)[] -> E[] #);
     sort:: (# do this(AttFrag)[] -> S[] #);*)
     replaceEntity::
       (#
       do '**** AttFrag:replaceEntry: ' -> putline;
          inner
       #);     
     att: ^Attributes
  do Attributes -> att[] -> append
  #);
doPartFrag: Fragment
  (# PT:: 
       (# 
       do '---' -> lx.append; name.item[] -> lx.append;
          ':doPart---\n' -> lx.append;
          (pos,break) -> ACP.PT 
       #);
     label:: (# do 'doPartFrag' -> lab[] #);
     length::(# #);
     getEntries:: (# do ('Do-part',ACP[]) -> add #);
     (*entity:: (# do this(DoPartFrag)[] -> E[] #);
     sort:: (# do this(DoPartFrag)[] -> S[] #);*)
     replaceEntity::
       (#
       do '**** doPartFrag:replaceEntry: ' -> putline;
          inner
       #);
     ACP: ^ActionPart
  do ActionPart -> ACP[] -> append;
  #)
---parseStdBetax:doPart---
do '\n---ParseStdBeta:'->putline;
   
   (# StdPath: ^text;
      FD: ^FragmentDir;
      name: @Lexem
   do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
      (if stdpath[] = none then 'none'->putline if);
      StdPath[] -> putline;
      'A fragment' -> name.item[];
      (name[],StdPath[],'',true) -> FragmentDir -> FD[];
      (name[],FD[]) -> FragmentModule -> betaLib[];
      (*FD.doPT -> putline*)
   #)
   
