parseTst: @
  (# btap: @ (# x: @integer #);
     a,b,c,margin: @integer;
     
     RTX: @
       (# foo:
            (# S: ^Fisk (*this(foo).Fisk; minienv cannot parse! *)
               Fisk: (# do 'W' -> put; inner exit true #);
               hest: (# do 'T' -> put; inner #);
               snorf: Fisk(#do 'a'->put #);
            do 'f' -> put; 'g' -> put
            exit this(foo)[]
            #)
       #);
     hest:
       (# T: ^Torsk;
          R: [3] @integer
       do &torsk[] -> T[]
       exit this(hest)[]
       #);
     Torsk: (# #);
     Reje: (# #);
     F: ##Torsk
  do (* 90 -> b; 7 -> c;
     b + c -> a;
     -b -> a;
     (-b+c) -> a;
     -(-b+c) -> a;
     (+b+c) -> a;
     a -> put;
     (for 3 repeat 
          a + 1 -> a -> put
     for)
     (for inx : 3 repeat
          a + inx -> put
     for);
     (for p : btap.x repeat for);
      (for margin+b repeat for);
      * *)
     
     (RTX.foo).fisk;
     'c'->put;
     newline;
     (*&(RTX.foo).Fisk(# do 'a'->put  #);  - minienv cannot parse *)
     
     '\n---\n'.print
     
     (RTX.foo).Hest(# do 'b'->put  #);
     '\n===\n'.print;
     
     (*(if (RTX.foo).Fisk(# do 'Q'->put  #) then 'T' -> put if); cannot parse*)
     (*(hest).T## -> F##; -- cannot parse *)
     (*(hest).R[2] -- cannot parse *)
  #)

  
