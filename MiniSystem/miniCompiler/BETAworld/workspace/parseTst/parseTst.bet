parseTst: @
  (# btap: @ (# x: @integer #);
     a,b,c,margin: @integer;
     
     RTX: @
       (# foo:
            (# S: ^this(foo).Fisk;
               Fisk: (# do 'W' -> put; inner exit true #);
               hest: (# do 'T' -> put; inner #);
               snorf: Fisk(#do 'a'->put #);
            do 'f' -> put; 'g' -> put
            exit this(foo)[]
            #)
       #);
     hest:
       (# T: ^Torsk;
          R: [3] @integer
       do &torsk[] -> T[]
       exit this(hest)[]
       #);
     Torsk: (# #);
     Reje: (# #);
     F: ##Torsk
  do (* 90 -> b; 7 -> c;
     b + c -> a;
     -b -> a;
     (-b+c) -> a;
     -(-b+c) -> a;
     (+b+c) -> a;
     a -> put;
     (for 3 repeat 
          a + 1 -> a -> put
     for)
     (for inx : 3 repeat
          a + inx -> put
     for);
     (for p : btap.x repeat for);
      (for margin+b repeat for);
      * *)
     
     (RTX.foo).fisk;
     'c'->put;
     newline;
     &(RTX.foo).Fisk(# do 'a'->put  #);
     
     '\n---\n'.print
     
     (RTX.foo).Hest(# do 'b'->put  #);
     '\n===\n'.print;
     
     (if (RTX.foo).Fisk(# do 'Q'->put  #) then 'T' -> put if);
     (hest).T## -> F##;
     (hest).R[2]
  #)

  
