SubPtnRestr: @
  (# (*monitor: 
       (# [interface[entry,entry2],globals[hest]]
          entry: (# [arguments[immutable],kind[method]]  do inner #);
          entry2: (#  do inner #)
       #);
     MyMon: @ Monitor
       (# foo: entry
            (# S: ^complex;
               R: ^text;
               V: @ integer;
               Xnone: ^hest
            enter (S[],R[])
            do 'foo'.print;
               I + 3 -> I;
               3 -> fisk -> V;
               7 -> x.q;
               Xnone[] -> x.T[]
            #);
          fool: (#  do 'fool'.print #);
          bar: entry2(#  R: ^ foo do 'bar'.print; &foo[] -> R[] #)
       #);
     Complex: Immutable
       (# re,im: @ integer;
          _cons: 
            (# x,y: @ integer
            enter (x,y)
            do x -> re; y -> im
            #);
          add: 
            (# C: ^complex;
               x,y: @ integer;
               C1: ^Complex
            enter C[]
            do C.re + re -> x;
               C.im + im -> y;
               &Complex(x,y)[] -> C1[]
            exit C1[]
            #);
          incr: 
            (# _cons: (#  do 17 -> im #)
            do re + 1 -> re; im + 1 -> im
            #);
          display: 
            (# 
            do 'Complex:'.print;
               re -> putint;
               ',' -> put;
               im -> putint;
               newline
            #)
       #);
     fisk: 
       (# V: @ integer
       enter V
       do V + V -> V
       exit V
       #);
     hest: (# ib: @ integer #);
     I: @ integer;
     R: ^Monitor;
     X: @ (# q: @ integer; T: ^hest #);
     C,C1: ^Complex;
     T: ^text;
     Q1: (# x: @integer; #);  Q2: (# y: @integer #); 
     Q3: (# z: @integer #); Q4: (# q: @integer #);
     ViggoS: (# [globals[Q1,Q2,Q4]] do inner #); Viggo: ViggoS(#do 'Viggo: '.print; #);
     TorbenS: (# [globals[Q1,Q3]]do inner #) 
     Torben: TorbenS(# abe: @integer do 'Torben:'.print #);
     Rx: ^Torben;
     XQ: @integer;
     Tim: (# [globals[Q1,Q2,Q4]] do inner #);
     Borge: Tim
       (#
          kuk: (# 
               do Viggo; Torben; 3 -> XQ; 
                  &Torben[] -> Rx[]; 333 -> Rx.abe
               #);
          do 'Borge:'.print; kuk
       #);*)
     uClass: (# [unique] a,b: @integer do inner #);
     testUnique:
       (# R1, R2: ^uClass;
          testNested:
            (# 
            do 100 -> R1.a;
               300  -> R1.b;
               R1[] -> R2[];
               R2.a + R2.b -> putint; 
               (if R1[] = none then 
                   ' OK (R1 is none)\n'.print
                else
                   ' NOT OK (R1 is NO none)\n'.print
               if);
            #);               
       do &uClass[] -> R1[];
          12 -> R1.a;
          13 -> R1.b;
          R1[] -> R2[];
          R2.a + R2.b -> putint; 
          (if R1[] = none then 
              ' OK (R1 is none)\n'.print
           else
              ' NOT OK (R1 is NO none)\n'.print
          if);
          3 -> R2.a; 5 -> R2.b;
          R2[] -> R1[];
          R1.a + R1. b -> putint; newline;
          testNested
       #);
     
  do (*(C[],T[]) -> MyMon.foo;
     newline;
     MyMon.bar;
     newline;
     &Complex(3,4)[] -> C[];
     7 -> C.re;
     newline;
     C.display;
     &Complex(5,5)[] -> C.add -> C1[];
     C1.display;
     &text(123)[] -> T[];
     'Hello\n' -> T.puttext;
     T.print;
     Borge;*)
     testUnique
  #)
