SubPtnRestr: @
  (# monitor: 
       (# [interface[entry,entry2],globals[hest]]
          entry: (# [arguments[immutable]]  do inner #);
          entry2: (#  do inner #)
       #);
     MyMon: @ Monitor
       (# foo: entry
            (# S: ^complex;
               R: ^text;
               V: @ integer;
               Xnone: ^hest
            enter (S[],R[])
            do 'foo'.print;
               I + 3 -> I;
               3 -> fisk -> V;
               7 -> x.q;
               Xnone[] -> x.T[]
            #);
          fool: (#  do 'fool'.print #);
          bar: entry2(#  do 'bar'.print #)
       #);
     Complex: Immutable
       (# re,im: @ integer;
          _cons: 
            (# x,y: @ integer
            enter (x,y)
            do x -> re; y -> im
            #);
          add: 
            (# C: ^complex;
               x,y: @ integer;
               C1: ^Complex
            enter C[]
            do C.re + re -> x;
               C.im + im -> y;
               &Complex(x,y)[] -> C1[]
            exit C1[]
            #);
          incr: 
            (# _cons: (#  do 17 -> im #)
            do re + 1 -> re; im + 1 -> im
            #);
          display: 
            (# 
            do 'Complex:'.print;
               re -> putint;
               ',' -> put;
               im -> putint;
               newline
            #)
       #);
     fisk: 
       (# V: @ integer
       enter V
       do V + V -> V
       exit V
       #);
     hest: (# ib: @ integer #);
     I: @ integer;
     R: ^Monitor;
     X: @ (# q: @ integer; T: ^hest #);
     C,C1: ^Complex;
     T: ^text
  do (C[],T[]) -> MyMon.foo;
     newline;
     MyMon.bar;
     newline;
     &Complex(3,4)[] -> C[];
     7 -> C.re;
     newline;
     C.display;
     &Complex(5,5)[] -> C.add -> C1[];
     C1.display;
     &text(123)[] -> T[];
     'Hello\n' -> T.puttext;
     T.print
  #)
