ControlExp: @
  (# with BASIC;
     
     A,B,C: ^int;
     
     calc: @
       (# sum: ^int;
          
          init: (# do 0 -> Int -> sum[] #);
          
          accumulate:
            (# X: ^Int
            enter X[]
            do  X[] -> sum.add -> sum[]
            exit sum[]
            #);
          max:
            (# x,y,m: ^int
            enter(x[],y[])
            do (if (x[] -> y.lt).B then
                   y[] -> m[]
                else
                   x[] -> m[]
               if)
            exit m[]
            #);
          print: (# do sum.print #)
       #);
     signal: @
       (# go: (# T: ^text do 'go' -> T[]; T.print; 10->put #);
          nogo: (# T: ^text do 'nogo' -> T[]; T.print; 10 -> put #);
       #)
          
  do (*'Hello'.print;*)
     13 -> Int -> A[];
     7 -> Int -> B[];
     A[] -> B.add -> C[];
     '@'->put;
     C.print;
     '?'->put;
     (* (B + 7) = C doIf: [ '!' -> put ] else: [ '?' -> put ] *)
     ( (#do signal.go #)##
     , (#do signal.nogo #)##
     ) -> (7 -> int -> B.add -> C.eq).doIf;
     
     calc.init;
     3 -> Int -> A[];
     A.timesRepeat(# do inx -> Int -> calc.accumulate #);
     (* the folloiwg does not work - we need to handle computedRemote as a denotation
      * and probably fix lexer to operate with a lookahead in order to recognize '(for', etc
      *
      * (3 -> Int).timesRepeat(# do inx -> Int -> calc.accumulate #);
      *)
     '+'->put
     calc.print;
     '*' -> put;
     (15 -> int,25->int) -> calc.max -> A[];
     A.print;
  #)

