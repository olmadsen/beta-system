miniex: @
  (# Complex: Immutable
       (# re,im: @ integer;
          _cons: 
            (# x,y: @ integer
            enter (x,y)
            do x -> re; y -> im
            exit this(Complex)[]
            #);
          add: 
            (# C: ^complex;
               x,y: @ integer;
               C1: ^Complex
            enter C[]
            do C.re + re -> x;
               C.im + im -> y;
               &Complex(x,y)[] -> C1[]
            exit C1[]
            #);
          display: 
            (# 
            do 'Complex:'.print;
               re -> putint;
               ',' -> put;
               im -> putint;
               newline
            #)
       #);
     Message: immutable
       (# _cons: 
            (# T: ^text 
            enter T[] 
            do T[] -> M[]; '*'->put; M.print; newline
            exit this(Message)[]
            #);
          M: ^text;
          print: 
            (#
            do '!'->put;
               (if M[] = none then '?'->put else M.print if); M.print 
               
            #);
       #);
     C,C1: ^Complex;
     msg: ^Message
  do &Complex(3,4)[] -> C[];
     newline;
     C.display;
     &Complex(5,5)[] -> C.add -> C1[];
     C1.display;
     
     &Message('P1')[] -> msg[];
     msg.print
  #)
