Collections: @
  (# List:
       (# first: ^Node;
          last: ^Node;
          Node:
            (# previous: ^Node;
               next: ^Node;
               elm: ^Object;
               isNil:<
                 (# result: @boolean;
                 do INNER;
                 exit result
                 #);
            #);
          Nil: Node
            (# isNil:: 
                 (# do 1 -> result #);
            #);
          init:
            (#
            do &Nil[] -> first[];
               first[] -> last[];
            #);
          append:
            (# elm: ^Object;
               theNode: ^Node;
            enter elm[]
            do &Node[] -> theNode[];
               elm[] -> theNode.elm[];
               (if last.isNil then
                   last[] -> theNode.previous[];
                   &Nil[] -> theNode.next[];
                   theNode[] -> first[];
                   theNode[] -> last[];
                else
                   last[] -> theNode.previous[];
                   theNode[] -> last.next[];
                   theNode[] -> last[];
                   &Nil[] -> theNode.next[];
               if);
            #);
          scan:
            (# marker: ^Node;
               current: ^Object;
            do first[] -> marker[];
               loop:
                 (if not marker.isNil then
                     marker.elm[] -> current[];
                     INNER;
                     marker.next[] -> marker[];
                     restart loop;
                 if);
            #);
       #);
  #)
