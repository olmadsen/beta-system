IntegerTree: @
  (# BinaryTree: 
       (# node: 
            (# insert: 
                 (# V: @ integer
                 enter V
                 do (if V <=  elm then
                        (if left[] =  none then
                            &node[] -> left[]; V -> left.elm
                         else
                            V -> left.insert
                        if)
                     else
                        (if right[] =  none then
                            &node[] -> right[]; V -> right.elm
                         else
                            V -> right.insert
                        if)
                    if)
                 #);
               elm: @ integer;
               left,right: ^node
            #);
          insert: 
            (# V: @ integer
            enter V
            do (if root[] =  none then
                   &node[] -> root[]; V -> root.elm
                else
                   V -> root.insert
               if)
            #);
          enumerate: 
            (# preOrder:< booleanValue;
               inOrder:< booleanValue;
               postOrder:< booleanValue;
               scan: 
                 (# current: ^node
                 enter current[]
                 do (if current[] <>  none then
                        (if preOrder then
                            current.elm -> next;
                            this(enumerate).suspend
                        if);
                        current.left[] -> scan;
                        (if inOrder then
                            current.elm -> next;
                            this(enumerate).suspend
                        if);
                        current.right[] -> scan;
                        (if postOrder then
                            current.elm -> next;
                            this(enumerate).suspend
                        if)
                    if)
                 #);
               next: @ integer
            do root[] -> scan; - 1 -> next
            exit next
            #);
          enumerateAllpre: 
            (# enum: @ enumerate(# preOrder:: TrueValue #);
               V: @ integer
            do L:
                 (if true then
                     enum -> V;
                     inner;
                     (if V <> - 1 then
                         restart L
                     if)
                 if)
            #);
          preOrder: 
            (# scan: 
                 (# current: ^node
                 enter current[]
                 do (if current[] <>  none then
                        current.elm -> next;
                        '>' -> put;
                        this(preOrder).suspend;
                        '<' -> put;
                        current.left[] -> scan;
                        current.right[] -> scan
                    if)
                 #);
               next: @ integer
            do root[] -> scan; - 1 -> next
            exit next
            #);
          inOrder: 
            (# scan: 
                 (# current: ^node
                 enter current[]
                 do (if current[] <>  none then
                        current.left[] -> scan;
                        current.elm -> next;
                        this(preOrder).suspend;
                        current.right[] -> scan
                    if)
                 #);
               next: @ integer
            do root[] -> scan; - 1 -> next
            exit next
            #);
          pOenum: enumerate(# postOrder:: TrueValue #);
          root: ^node
       #);
     BT: @ BinaryTree;
     V: @ integer;
     T,T1: ^BT.preOrder;
     iT: ^BT.inOrder;
     enum: ^BT.enumerate
  do 111 -> BT.insert;
     17 -> BT.insert;
     200 -> BT.insert;
     1 -> BT.insert;
     &BT.preOrder[] -> T[];
     T[] -> T1[];
     (for i: 5 repeat
          T -> V; V -> putint; ' ' -> put
     for);
     newline;
     &BT.inOrder[] -> iT[];
     T[] -> T1[];
     (for i: 5 repeat
          iT -> V; V -> putint; ' ' -> put
     for);
     newline;
     &BT.pOenum[] -> enum[];
     (for i: 5 repeat
          enum -> V; V -> putInt; ' ' -> put
     for);
     newline;
     &BT.enumerate(# postOrder:: TrueValue #)[] -> enum[];
     (for i: 5 repeat
          enum -> V; V -> putInt; ' ' -> put
     for);
     newline;
     BT.enumerateAllpre(#  do V -> putint; ' ' -> put #);
     newline
  #)