ServiceIF: @
  (# add: 
       (# handle: @integer; C: ^Component
       enter(handle,C[])
       do (handle,C[]) -> hMap.add
       #);
     getComponent:
        (# handle: @integer; C: ^Component
        enter handle
        do handle -> hMap.getComponent -> C[]
        exit C[]
        #);
     hMap: @
       (# add:
            (# handle: @integer; C: ^Component; T : ^text
            enter(handle,C[])
            do top+1 -> top;
               (handle,top) -> handles.put;
               (if top
                // 1 then C[] -> components.C1[]
                // 2 then C[] -> components.C2[]
                // 3 then C[] -> components.C3[]
                // 4 then C[] -> components.C4[]
                // 5 then C[] -> components.C5[]
                // 6 then C[] -> components.C6[]
                // 7 then C[] -> components.C7[]
                // 8 then C[] -> components.C8[]
                // 9 then C[] -> components.C9[]
                else
                   '\n********* ServiceIF:hMap:overflow\n' -> T[]; 
               if)
            #);
          getComponent:
            (# handle,h: @integer; C: ^Component; T:^text
            enter handle
            do find:
                 (for i: top repeat
                      i -> handles.get -> h;
                      (if handle = h then
                          (* 'Match'->T[]; T.print; ' '-> put; i -> putint; 10->put;*)
                          (if i
                           // 1 then components.C1[] -> C[]
                           // 2 then components.C2[] -> C[]
                           // 3 then components.C3[] -> C[]
                           // 4 then components.C4[] -> C[]
                           // 5 then components.C5[] -> C[]
                           // 6 then components.C6[] -> C[]
                           // 7 then components.C7[] -> C[]
                           // 8 then components.C8[] -> C[]
                           // 9 then components.C9[] -> C[]
                              
                          if);
                          leave find
                 if)for)
            exit C[]
            #);
                            
          top: @integer;
          handles: @
            (# put:
                 (# handle: @integer; inx: @integer; T: ^text
                 enter(handle,inx)
                 do (* 'handles:put:'->T[]; T.print; 
                    (* handle -> putint; ' ' -> put; inx -> putint; 10 -> put;*)
                    
                    handle -> H[inx];
                 #);
               get: 
                 (# inx,handle: @integer
                 enter inx
                 do H[inx] -> handle
                 exit handle
                 #);
               H: [100] @ integer
            #);
          components: @
            (# c1,c2,c3,c4,c5,c6,c7,c8,c9: ^Component;
              (* C: [100] ^Component - currently not implemented *)
            #)
       #);
     
  #)
