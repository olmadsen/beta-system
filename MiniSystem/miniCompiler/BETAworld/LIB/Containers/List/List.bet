List: @
  (# xxx: @ 
       (# xList: 
            (# append:< (# V: @ integer enter V do inner #);
               print:< (# do inner #);
               enum:< 
                 (# head: ^enum; current: ^xList; print: (# do current.print #)
                 enter head[] 
                 do inner;
                 #);
            do inner; 
            exit this(xList)[] 
            #);
          Nil: xList
            (#  enum:: (# do this(nil)[] -> enum1.current[]; enum1.suspend #) 
            do (* needed*) 
            #);

          Cons: xList
            (# head: @ integer; 
               tail: ^xList; 
               append::<(# #);
               print::< (# do head -> putint; ',' ->put; tail.print #);
               enum::< 
                 (# 
                 do this(Cons)[] -> enum1.current[]; 
                    '<'->put; enum1.suspend; '>' -> put; head[] -> tail.enum
                 #);
            enter (head,tail[])
            do 
            #);
     
          L: ^xList;
          enum1: @ (# current: ^xList do L.enum #)
          scan: 
            (# 
            do Enum1; Enum1.current.print; 
               Enum1; enum1.CURRENT.print;
               Enum1; enum1.CURRENT.print 
            #)
       #);
     
  do 
     (17,(15,XXX.Nil) -> XXX.Cons) -> XXX.Cons -> XXX.L[]; 
     XXX. L.print;
     newline;
     xxx.scan;
     
     newline
  #)
