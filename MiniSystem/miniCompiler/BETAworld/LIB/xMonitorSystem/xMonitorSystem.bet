xMonitorSystem: @
  (# with Containers; 
     test: (#  exit 0 #);
     Lock:
       (# M: @integer;
          get:
            (# 
            do 
               Loop: 
                 (if 1 then
                     disable;
                     (if (1 -> M.cmpAndSwap) = 1 then 
                         enable;
                        (* 500 -> sleep; *)
                         restart Loop 
                 if)if);
            #);
          free: (# do 0 -> M; enable #)
       #);
     System: 
       (# Core: 
            (# %core%
               S: ^Scheduler;
               attach:
                 (#
                 enter S[]
                 do 
                 #);
            do loop:
                 (if S[] <> none then 
                     S                   
                  else
                     100->sleep;
                     restart loop
                 if)
            #);
          core1,core2: @Core;
          
          init_core:
            (#
            do core1[] -> fork; 
               core2[] -> fork; 
            #);
          Process: 
            (# [interface[],globals[monitor]]
               start: 
                 (# 
                 enter id
                 do 'Starting: '.print;
                    id -> putint;
                    newline;
                    this(Process)[] -> SQS.insert
                 #);
               id: @ integer;
               status: @ integer
            do P_status.ACTIVE -> status;
               inner;
               P_status.TERMINATED -> status
            #);
          P_status: @ 
            (# ACTIVE: (#  exit 1 #);
               WAITING: (#  exit 2 #);
               TERMINATED: (#  exit 3 #)
            #);
          Monitor: 
            (# [globals[],interface[entry]]
               init: (#  do mutex.init #);
               entry: 
                 (# [arguments[immutable],kind[method]]
                    theActive: ^Process
                 do mutex.wait;
                    (if test then
                        disable; 
                        thisCore.S.active[] -> theActive[]; 
                        enable;
                        'Enter: '.print;
                        (if theActive[] <> none then 
                            theActive.id -> putint
                        if);
                        ',' -> put;
                    if);
                    inner;
                    (if test then
                        'Exit: '.print; theActive.id -> putint; ' ' -> put;
                    if);
                    mutex.signal
                 #);
               Condition: 
                 (# q: @ semaphore;
                    wait: (#  do  #);
                    signal: (#  do  #)
                 #);
               Wait: 
                 (# cond: @ boolean
                 do Loop:                      
                      (# 
                      do inner;
                         (if not cond then
                             mutex.signal; 
                             (* do not acccess thisCore without disabling interrupt*)
                             P_status.ACTIVE
                                -> thisCore.S.active.status;
                             thisCore.S.active.suspend;
                             mutex.wait;
                             restart Loop
                         if)
                      #)
                 #);
               display: 
                 (# 
                 do 'Monitor:'.print; mutex.display
                 #);
               mutex: @ semaphore
            #);
          Semaphore: 
            (# init: (#  do 1 -> cnt #);
               wait: 
                 (# theActive: ^Process
                 do M.get; (*disable;*)
                    (if test then
                        'Sem:wait:'.print
                    if);
                    cnt - 1 -> cnt;
                    (if cnt < 0 then
                        P_status.WAITING
                          -> thisCore.S.active.status;
                        thisCore.S.active[] -> SQS.remove;
                        SQS.addWaiting;
                        thisCore.S.active[] -> Q.insert;
                        thisCore.S.active[] -> theActive[];
                        M.free; (*enable;*)
                        theActive.suspend
                     else
                        M.free; (* enable*)
                    if)
                 #);
               signal: 
                 (# P: ^Process
                 do M.get; (* disable;*)
                    (if test then
                        'Sem:signal:'.print
                    if);
                    cnt + 1 -> cnt;
                    (if cnt <=  0 then
                        Q.removeNext -> P[];
                        P_status.ACTIVE -> P.status;
                        P[] -> SQS.insert;
                        SQS.dcrWaiting;
                        thisCore.S.active[] -> P[];
                        M.free; (*enable;*)
                        P.suspend
                     else
                        M.free (*enable*)
                    if)
                 #);
               display: 
                 (# 
                 do 'Semaphore: '.print; Q.display
                 #);
               cnt: @ integer;
               M: @Lock;
               Q: @ ProcessQueue
            #);
          scheduler: 
            (# idf: @char; active: ^Process
            enter idf
            do '%'->put;
               SQS.display;
               Loop:                 
                 (# 
                 do (if test then
                        'scheduler:loop: '.print;
                        newline;
                        SQS.display
                    if);
                    SQS.removeNext -> active[]; 
                    (if active[] <> none then
                        (if test then
                            newline;
                            'Scheduler:active:'.print;
                            active.id -> putint;
                            ' ' -> put;
                            SQS.display;
                        if);
                       (* idf->put;*)
                        50 -> active.attach;
                        (if test then
                            'scheduler:after suspend'.print;
                            newline
                        if);
                        (if active.status = P_status.ACTIVE then
                            (if test then
                                'scheduler:insert active'.print;
                                newline
                            if);
                            active[] -> SQS.insert;
                            (if test then
                                SQS.display
                            if)
                        if)
                    if);
                    (if not SQS.isEmpty then
                        restart Loop
                     else
                        (if SQS.hasWaiting then
                            100 -> sleep;
                            restart loop
                        if)
                    if);                    
                 #);
               '?'->put; idf -> put
            exit this(Scheduler)[]
            #);
          ProcessQueue: Queue
            (# display: 
                 (# P: ^Process
                 do 'SQS:head:'.print;
                    (if head[] <> none then
                        head.elm[] -> P[];
                        P.id -> putint
                    if);
                    '[' -> put;
                    scan
                    (# 
                    do current[] -> P[];
                       P.id -> putint;
                       ' ' -> put
                    #);
                    '] last:'.print;
                    (if last[] <> none then
                        last.elm[] -> P[];
                        P.id -> putint
                    if);
                    newline
                 #)
            #);
          XSQS: @ProcessQueue;
          xput: (# ch: @char enter ch do (if false then ch -> put if)#);
          SQS: @ 
            (# Q: @ProcessQueue;
               M: @lock;
               init: (# do  #);
               entry: 
                 (# do M.get; inner; M.free #);
               insert: entry(# P: ^Process enter P[] do '['->xput; P[] -> Q.insert; ']'->xput #);
               remove: entry(# P: ^Process enter P[] do '{'->xput; P[] -> Q.remove; '}'->xput #);
               removeNext: entry(# P: ^Process do '('->xput; Q.removeNext -> P[]; ')'->xput exit P[] #);
               isEmpty: entry(# B: @boolean do Q.isEmpty -> B exit B #);
               display: entry(# do '<'->xput; Q.display; '>'->xput #);
               addWaiting: entry(# do W + 1 -> W #);
               dcrWaiting: entry(# do W - 1 -> W #);
               hasWaiting: entry(# B: @boolean do W > 0 -> B exit B #);
               W: @integer
            #);
          S: ^Scheduler
       do init_core; SQS.init; 
          inner;  
          &scheduler[] -> S[]; 
          '*' -> S.idf; S[] -> core1.attach;
          &scheduler[] -> S[]; 
          '&' -> S.idf; S[] -> core2.attach;
       #)
  #)
