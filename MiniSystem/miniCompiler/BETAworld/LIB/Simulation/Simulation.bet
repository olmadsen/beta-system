Simulation: @
  (#
     Process: 
       (# 
          hold: 
            (# T: @ integer 
            enter T 
            do 'Hold: '.print; T ->putint; newline;
               (if T > 0 then time + T -> time if);  
               this(process)[] -> SQS.removeLast;
               (* SQS.display;*)
               this(Process)[] -> SQS.insert;
               (*SQS.display;*)
               this(process).suspend;
            #);
          wait: 
            (# Q: ^Queue 
            enter Q[] 
            do 'Wait:'.print;
               this(Process)[] -> Q.insert;
               this(Process).suspend
            #);
          activate: 
            (# X: ^Process 
            enter X[] 
            do 'Activate:'.print;
               time -> X.time; 
               X[] -> SQS.insert;
               this(Process).suspend 
            #);
          display: 
            (# 
            do id.print;
               ':' -> put;
               time -> putint;
               ',' -> put;
               newline;
            #);
          id: ^text;
          time: @ integer
       enter(id[],time)
       do (*'NewProcess:'.print; display;*)
          this(Process).suspend; 
          (*'Resume: '.print; display;*)
          inner;
          this(process)[] -> SQS.removeLast; 
       exit this(Process)[]
       #);
     simulate: 
       (# start,active: ^Process; finish: @ integer;
          final: ^Process
       enter (start[],finish)
       do 'Simulate: '.print; 
          &Queue[] -> SQS[];
          &Process[] -> final[] -> SQS.insert;
          ('Final',finish) -> final;
          start[] -> SQS.insert;
          inner;
          SQS.display;          
          L:
            (if not SQS.empty then 
                'Current: '.print; (current).display;
                current -> active[];
                active;
                (*'After active: '.print; newline;*)
                (*SQS.display;*)
                restart L
            if);
          'End of simulation'.print;
       #);
     current: (#  exit SQS.last[] #);
     SQS: ^Queue;
     Queue: 
       (* The  first element, has no elm and represents the head of the Queue
        * P1, P2, .... Pn, Pi.time > Pi+1.time
        *)
       (# insert: 
            (# P: ^Process; Q: ^Queue
            enter P[]
            do &Queue[] -> Q[];
               P[] -> Q.elm[];
               (if next[] = none[] then (* the queue is empty *)
                   Q[] -> next[];
                   P[] -> last[];
                else
                   Q[] -> add;
                   next.last[] -> last[]
               if)
            #);
          add: 
            (# Q: ^Queue
            enter Q[] 
            do 
               (if next[] = none[] then
                   Q[] -> next[];
                   Q.elm[] -> last[]
                else                        
                   (if (Q.elm.time > next.elm.time) then
                       next[] -> Q.next[];
                       Q[] -> next[];
                    else 
                       Q[] -> next.add;
                   if);
                   next.last[] -> Q.last[]   
               if)
            #);
          first:
            (# P: ^Process 
            do last[] -> P[]; removeLast
            exit P[]
            #);
          removeLast: 
            (# P: ^Process 
            enter P[] 
            do (if next[] <> none[] then
                   (if P[] = next.elm[] then 
                       none[] -> next[];
                       elm[] -> last[];
                    else
                       P[] -> next.removeLast;
                       next.last[] -> last[]
               if)if)
            #);
          empty: BooleanValue(# do next[] = none[] -> value #);
          display: 
            (# 
            do (if elm[] <> none[] then
                   elm.display
               if);     
               (if next[] <> none[] then
                   next.display
               if)
            #);
          elm: ^Process;
          next: ^Queue;
          last: ^Process
       #);
     none: ^Object;
  #)
