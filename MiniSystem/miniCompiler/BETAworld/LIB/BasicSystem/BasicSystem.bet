BasicSystem: @
  (# with Containers;     
     System: 
       (# BasicProcess: 
            (# start:< 
                 (# 
                 enter id
                 do '\nStarting: '.print; id -> putint; 
                    P_status.ACTIVE -> status;
                    inner
                 #);
               display:
                 (# msg: ^text
                 enter msg[]
                 do console.display
                    (# do 'BasicProces:'.print; id -> putint; msg.print #)
                 #);
               id: @ integer;
               status: @ integer;
               sch: ^gScheduler (* The activiyScheduler of this(process) ? *)
            do inner;
               disable; (* should not be necessary*)
               P_status.TERMINATED -> status;
               enable
            #);
          P_status: @ 
            (# ACTIVE: (#  exit 1 #);
               WAITING: (#  exit 2 #);
               RESUMED: (# exit 3 #);
               TERMINATED: (#  exit 4 #)
            #);        
          gScheduler: 
            (# init:< (# do inner #); 
               insert:< 
                 (# P: ^BasicProcess enter P[] 
                 do (if test then
                        console.display
                        (# 
                        do ':insert:'.print; idf.print; P.id -> putint;newline #); 
                    if);
                    inner;
                    (if test then SQS.display if)
                 #);
               remove:< (# P: ^BasicProcess enter P[] do inner #);
               SQS: @ ProcessQueue; 
               active: ^BasicProcess;
               idf: ^text;
               display:
                 (# msg: ^text
                 enter msg[]
                 do console.display
                    (#
                    do'\nScheduler:'.print; idf.print; 
                       'active:'.print; 
                       (if active[] <> none[] then 
                           active.id->putint;
                           ':status='.print; 
                           (if active.status
                            // P_status.ACTIVE then 'ACTIVE'.print
                            // P_status.WAITING then 'WAITING'.print
                            // P_status.RESUMED then 'RESUME'.print
                            // P_status.TERMINATED then 'TERMINATED'.print
                            else '???'.print
                           if);
                        else 'none'.print 
                       if);
                       '[' -> put; processId -> putint; ']'->put;
                       ':waiting:'.print; noOfWaiting -> putint;
                       msg.print; ':'->put;
                       SQS.display;
                    #)
                 #);
               processId:< (# id: @integer do inner exit id #);
               waitingActivities:< booleanValue
                 (#
                 do (*disable;*)
                    (if test then ':SQS is empty:' -> display if); 
                    inner;
                    (*enable*)
                 #);
               (* Should really be in aPscheduler *)
               incrWaiting: (# do noOfWaiting + 1 -> noOfWaiting #);
               decrWaiting: (# do noOfWaiting - 1 -> noOfWaiting #);
               noOfWaiting: @integer;
               cTest: (# exit  0 #)
            do (if cTest then ':Initial:'-> display if);
               Loop:
                 (if true then
                     (if cTest then ':scheduler:loop: ' -> display if);
                     disable;
                     SQS.removeNext[] -> active[];
                     (if active[] <> none[] then
                         (if cTest then ':next:' -> display if);
                         P_status.ACTIVE -> active.status;
                         enable
                         inner;
                         disable;
                         (if cTest then ':after suspend:status:' -> display if);
                         (if active.status = P_status.ACTIVE then
                             (if true then
                                 active[] -> SQS.insert
                              else                                 
                                 (if not (active[] -> SQS.find) then
                                     active[] -> SQS.insert
                             if)if);
                             (if cTest then ':scheduler:insert active' -> display if)
                         if);
                      else
                         (if cTest then '\nNo processes in SQS' -> display if)
                     if);
                     (* disable on *)
                     (if SQS.isEmpty then (* The SQS of this scheduler is empty *)
                         (if cTest then ':SQS.isEmpty:' -> display if);
                         (if this(gScheduler).waitingActivities then
                             (* There are waiting activities - only valid if activityScheduler *)
                             (if cTest then ':waiting activities' -> display if);
                             enable;
                             scheduler.active.suspend;
                             (if cTest then
                                 '\nactiviyScheduling resumed after waiting activities'-> display
                             if);
                             restart Loop
                         if)
                         enable
                         (* if SQS is empty and noWaitingActivities, then terminate *)
                      else
                         enable;
                         restart Loop
                     if);
                 if);
               (if cTest then ':terminated'->display; newline if)
            #);
          scheduler: @ gScheduler
            (# init::(# do 'gScheduler'->idf[]; idf.print #);
               insert::< (#  do P[] -> SQS.insert #);
               remove::< (#  do P[] -> SQS.remove #);
               waitingActivities:: (# do#)
            do (if 0 then active else 100 -> active.attach if); (* 20 dont work *)
            #);
          
          (* for debugging *) 
          none: ^Object;
          ProcessQueue: Queue
            (# display: 
                 (# P: ^BasicProcess
                 do console.display
                    (#
                    do 'SQS:head:'.print;
                       (if head[] <> none[] then
                           head.elm[] -> P[];
                           P.id -> putint
                       if);
                       '[' -> put;
                       scan
                       (# 
                       do current[] -> P[];
                          P.id -> putint;
                          ' ' -> put
                       #);
                       '] last:'.print;
                       (if last[] <> none[] then
                           last.elm[] -> P[];
                           P.id -> putint
                       if);
                       newline
                    #)
                 #);
               find: BooleanValue
                 (# P: ^BasicProcess
                 enter P[]
                 do L:
                      scan
                      (# P1: ^BasicProcess
                      do current[] -> P1[];
                         (if P.id = P1.id then true -> value; 
                             '\n************* Process already in Queue: '.print; P.id-> putint;
                             display;
                             leave L
                 if)#)#)
            #);
          console: @stream
            (# putx:: (# do disable; ch -> put; enable #);
               puttext::
                 (# 
                 do disable;
                    T.print;
                    enable
                 #);
               newline: (# do disable; 10->put; enable #);
               display: (# do disable; inner; enable #);
            #);
          doTest: @boolean;
          test: (#  exit dotest  #); (* exit false gives value stack underflow *) 
       do scheduler.init; 
          inner; 
          scheduler
       #)
  #)
