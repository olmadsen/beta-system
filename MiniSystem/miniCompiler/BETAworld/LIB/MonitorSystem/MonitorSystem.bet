MonitorSystem: @ BasicSystem
  (# with Containers; 
     test: (#  exit 0 #);
     System: BasicSystem
       (# Process: BasicProcess
            (# [interface[],globals[monitor]]
               start::< 
                 (# 
                 (*enter id*)
                 do 'Starting: '.print;
                    id -> putint;
                    newline;
                    this(Process)[] -> SQS.insert
                 #);
            do P_status.ACTIVE -> status;
               inner;
               P_status.TERMINATED -> status
            #);
          Monitor: 
            (# [globals[],interface[entry]]
               init: (#  do mutex.init #);
               entry: 
                 (# [arguments[immutable],kind[method]]
                    theActive: ^Process
                 do mutex.wait;
                    (if test then
                        disable; 
                        thisCore.main.active[] -> theActive[]; 
                        enable;
                        'Enter: '.print;
                        (if theActive[] <> none then 
                            theActive.id -> putint
                        if);
                        ',' -> put;
                    if);
                    inner;
                    (if test then
                        'Exit: '.print; theActive.id -> putint; ' ' -> put;
                    if);
                    mutex.signal
                 #);
               Condition: 
                 (# q: @ semaphore;
                    wait: (#  do  #);
                    signal: (#  do  #)
                 #);
               Wait: 
                 (# cond: @ boolean
                 do Loop:                      
                      (# 
                      do inner;
                         (if not cond then
                             mutex.signal; 
                             (* do not acccess thisCore without disabling interrupt*)
                             P_status.ACTIVE
                                -> thisCore.main.active.status;
                             thisCore.main.active.suspend;
                             mutex.wait;
                             restart Loop
                         if)
                      #)
                 #);
               display: 
                 (# 
                 do 'Monitor:'.print; mutex.display
                 #);
               mutex: @ semaphore
            #);
          Semaphore: 
            (# init: (#  do 1 -> cnt #);
               wait: 
                 (# theActive: ^Process
                 do M.get; (*disable;*)
                    (if test then
                        'Sem:wait:'.print
                    if);
                    cnt - 1 -> cnt;
                    (if cnt < 0 then
                        P_status.WAITING
                          -> thisCore.main.active.status;
                        thisCore.main.active[] -> SQS.remove;
                        SQS.addWaiting;
                        thisCore.main.active[] -> Q.insert;
                        thisCore.main.active[] -> theActive[];
                        M.free; (*enable;*)
                        theActive.suspend
                     else
                        M.free; (* enable*)
                    if)
                 #);
               signal: 
                 (# P: ^Process
                 do M.get; (* disable;*)
                    (if test then
                        'Sem:signal:'.print
                    if);
                    cnt + 1 -> cnt;
                    (if cnt <=  0 then
                        Q.removeNext -> P[];
                        P_status.ACTIVE -> P.status;
                        P[] -> SQS.insert;
                        SQS.dcrWaiting;
                        thisCore.main.active[] -> P[];
                        M.free; (*enable;*)
                        P.suspend
                     else
                        M.free (*enable*)
                    if)
                 #);
               display: 
                 (# 
                 do 'Semaphore: '.print; Q.display
                 #);
               cnt: @ integer;
               M: @Lock;
               Q: @ ProcessQueue
            #);
          xscheduler: 
            (# idf: @char; active: ^Process
            enter idf
            do '%'->put;
               SQS.display;
               Loop:                 
                 (# 
                 do SQS.removeNext -> active[]; 
                    (if active[] <> none then
                        50 -> active.attach;
                        (if active.status = P_status.ACTIVE then
                            active[] -> SQS.insert;
                        if)
                    if);
                    (if not SQS.isEmpty then
                        restart Loop
                     else
                        (if SQS.hasWaiting then
                            100 -> sleep;
                            restart loop
                        if)
                    if);                    
                 #);
               '?'->put; idf -> put
            exit this(Scheduler)[]
            #);
          xput: (# ch: @char enter ch do (if false then ch -> put if)#);
          YSQS: @ 
            (# Q: @ProcessQueue;
               M: @lock;
               init: (# do  #);
               entry: (# do M.get; inner; M.free #);
               insert: entry(# P: ^Process enter P[] do '['->xput; P[] -> Q.insert; ']'->xput #);
               remove: entry(# P: ^Process enter P[] do '{'->xput; P[] -> Q.remove; '}'->xput #);
               removeNext: entry(# P: ^Process do '('->xput; Q.removeNext -> P[]; ')'->xput exit P[] #);
               isEmpty: entry
                 (# B: @boolean 
                 do Q.isEmpty and (W = 0) -> B 
                 exit B 
                 #);
               display: entry(# do '<'->xput; Q.display; '>'->xput #);
               addWaiting: entry(# do W + 1 -> W #);
               dcrWaiting: entry(# do W - 1 -> W #);
               hasWaiting: entry(# B: @boolean do W > 0 -> B exit B #);
               W: @integer
            #);
          S: ^xScheduler
       do (*init_core; 
          SQS.init; *)
          inner;  
         (* &xscheduler[] -> S[]; 
          '*' -> S.idf; S[] -> core1.attach;
          &xscheduler[] -> S[]; 
          '&' -> S.idf; S[] -> core2.attach;*)
       #)
  #)
