ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'betaVM';
---lib:attributes---
ObjectCode:
  (# init:<
       (#
       enter out[]
       do inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comment:
       (# T: ^text
       enter T[]
       do '\t-- ' -> out.puttext; T[] -> out.putline
       #);
     newComponent:
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do '\tcomponent ' -> out.puttext;
          N[] -> out.putline;
          noOfDescs + 1 -> descs.OD.new; (* noOfDesc + 1 since an extra
                                          * desc is allocated for main
                                          *)
          noOfDescs + 1 -> descs.top
       #);
     class:
       (# N: ^text; descNo,topDescNo,originOff: @integer;
          procE: @boolean; (* mark start of byte code as proc-entry as well as enter-entry *)
       enter(N[],descNo,procE,topDescNo,originOff)
       do '\n\tclass ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
          descNo -> out.putint; out.newline;
          (N[],descNo,originOff,out[]) -> descs.setCurrent;
          (if descs.OD[topDescNo][]= none then 
              'descs.OD[topDescNo][]= none' -> putline
          if);
          descs.OD[topDescNo].bc[] -> descs.current.setSuperBC;
          descs.markAllocE;
          (if procE then descs.markProcE if);
          labs.init
       #);
     super: 
       (# N: ^text
       enter N[]
       do '\tsuper ' -> out.puttext; N[] -> out.putline;
       #);
     field:
       (#  N: ^text
       enter N[]
       do '\tfield ' -> out.puttext; N[] -> out.putline;
       #);
     rField:
       (#  N: ^text
       enter N[]
       do '\trfield ' -> out.puttext; N[] -> out.putline;
       #);
     staticField:
       (# N: ^text
       enter N[]
       do '\tnew ' -> out.puttext; N[] -> out.putline
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do '\tENTER:' -> out.putline
       #);
     actions:
       (# hasSuper: @boolean
       enter hasSuper
       do '\tDO:'->out.putline;
          descs.markDoE;
          (if not hasSuper then codes.mvstack -> emit if);
       #);
     markExitE: (# do descs.markExitE #);
     exitP:
       (#
       do '\tEXIT:' -> out.putline; codes.doExit -> emit
       #);
     return: (# do '\trtn' -> out.putline; codes.rtn -> emit #);
     returnC: (# do '\trtnc' -> out.putline; codes.rtnc -> emit #);
     returnExit: (# do '\trtnExit' -> out.putline; codes.rtnExit -> emit #);
     returnInner: (# do '\trtnInner' -> out.putline; codes.rtnInner -> emit #);
     stop: (# do '\tstop' -> out.putline; codes.stop -> emit #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          return          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do ' L' -> out.puttext; lab -> out.putint; ':' -> out.put; out.newline;
          lab -> labs.def;
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do '\tjmpIf_GT L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       do '\tjmp L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmp -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpFalse:
       (# lab: @integer 
       enter lab 
       do '\tjmpFalse L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpFalse -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do '\tjmpTrue L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpTrue -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do '\talloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.alloc -> emit; descNo -> emit;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do '\texeAlloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit
       #);
       
     newVrep: (# do '\tnewVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do '\tsend ' -> out.puttext; N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     sendVirtual: 
       (# N: ^text; dinx: @integer 
       enter(N[],dinx) 
       do '\tsendv ' -> out.puttext; N[] -> out.putline;
          codes.sendv -> emit; dinx -> emit;
       #);
     exe: (# N: ^text enter N[] do '\texe ' -> out.puttext; N[] -> out.putline #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do '\tcall(' -> out.puttext; LMR -> out.put; ')' -> out.put;
          N[] -> out.putline; 
          codes.call -> emit;
          LMR -> emit
       #);
     vdtTableCopy:
       (# superDescNo: @integer
       enter superDescNo
       do (*'VdtTable:copy:'-> puttext; superDescNo -> putint; newline;*)
          (for i: descs.OD[superDescNo].vdtTable.range repeat (* range is too large *)
               (* i -> putint; ':' -> put; ' ' -> put; 
                descs.OD[superDescNo].vdtTable[i] -> putint; newline;*)
               (i,descs.OD[superDescNo].vdtTable[i]) -> descs.current.vdtAdd
          for);               
       #);
     vdtTable:
       (# inx,descInx: @integer
       enter(inx,descInx)
       do (inx,descInx) -> descs.current.vdtAdd 
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do '\tinner ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerx -> emit; inx -> emit;
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do '\tinnerExit ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;
       #);
     suspendd: (# do '\tsuspend' -> out.putline; codes.susp -> emit #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do '\tdoSuper' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit;
       #);
     pushThis:
       (# 
       do '\tpushThis ' -> out.putline;
          codes.pushthis -> emit; 
       #);

     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.push -> emit; off -> emit
       #);
     pushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.pushg -> emit; off -> emit
       #);
     
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\trpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit
       #);
     rpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\trpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpushg -> emit; off -> emit
       #);
     xpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpush -> emit; off -> emit
       #);
     xpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpushg -> emit; off -> emit
       #);
     
     pushConst: 
       (# cst: @integer
       enter cst
       do '\tpush.const ' -> out.puttext; cst -> out.putint; out.newline;
          (if true 
           // cst <= 255 then
              codes.pushc -> emit;
              cst -> emit
           // cst <= 255 * 255  then
              codes.pushc2 -> emit;
              cst -> emit2

          if)
       #);
     pushText:
       (# T: ^text; I: @integer
       enter T[]
       do '\tpushText ' -> out.puttext; T[] -> out.putline;
          codes.pushText -> emit;
          T.length -> descs.current.addLiteral
          (#
          do i + 1 -> i -> T.inxGet -> value;
          #) -> emit
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\tstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.store -> emit; off -> emit
       #);
     storeg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\tstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.storeg -> emit; off -> emit
       #);
     rstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\trstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstore -> emit; off -> emit
          if)
       #);
     rstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\trstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstoreg -> emit; off -> emit
          if)
       #);
     xstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\txstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstore -> emit; off -> emit
          if)
       #);
     xstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\txstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstoreg -> emit; off -> emit
          if)
       #);
     double: (# do '\tdouble' -> out.putline; codes.double -> emit #);
     rdouble: (# do '\trdouble' -> out.putline; codes.rdouble -> emit #);
     rPop: (# do '\trpop' -> out.putline; codes.rpop -> emit #);
     CallPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do '\t%' -> out.puttext; P[] -> out.puttext; ' ' -> out.put; op -> out.putint; out.newline;
          codes.prim -> emit; op -> emit
       #);
     op: 
       (# operator: @integer
       enter operator
       do '\t' -> out.put; operator -> out.putint; out.newline;
          operator -> emit
       #);
     uminus: 
       (# 
       do '\tu-\n' -> out.puttext; 
          codes.uminus -> emit
       #);
     endClass: (# do '\tend' -> out.putline #);
     
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (if labNo > loc.range then labNo - loc.range + 4 -> loc.extend if);
               (if labNo > use.range then labNo - use.range + 4 -> use.extend if); (*ugly*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range + 4 -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          loc: [8] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [8] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
     dump: (# do descs.dump #);
     
     out: ^Stream;
     
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     
     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     
  #);

