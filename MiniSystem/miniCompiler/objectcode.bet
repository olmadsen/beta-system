ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'betaVM';
---lib:attributes---
ObjectCode:
  (# init:<
       (#
       enter out[]
       do inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comment:
       (# T: ^text
       enter T[]
       do '\t-- ' -> out.puttext; T[] -> out.putline
       #);
     newComponent:
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do '\tcomponent ' -> out.puttext; N[] -> out.puttext; 
          ' NoOfDescs: ' -> out.puttext; noOfDescs -> out.putint; out.newline;
          noOfDescs + 2 -> descs.top -> descs.OD.new; (* noOfDesc + 2 since an extra
                                                       * desc is allocated for main 
                                                       * and EventProcessor
                                                       *)
       #);
     class:
       (# N: ^text; descNo,topDescNo,originOff: @integer;
          procE: @boolean; (* mark start of byte code as proc-entry as well as enter-entry *)
       enter(N[],descNo,procE,topDescNo,originOff)
       do '\n\tclass ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
          descNo -> out.putint; out.newline;
          (N[],descNo,originOff,out[]) -> descs.setCurrent;
          (if descs.OD[topDescNo][]= none then 
              'Class: ' -> puttext; N[] -> puttext;
              ' descNo='->puttext; descNo -> putint;
              ' descs.OD[topDescNo='->puttext; 
              topDescNo -> putint;
              '][]= none' -> putline
          if);
          descs.OD[topDescNo].bc[] -> descs.current.setSuperBC;
          descs.markAllocE;
          (if procE then descs.markProcE if);
          labs.init
       #);
     super: 
       (# N: ^text; superDescNo: @integer
       enter(N[],superDescNo)
       do '\tsuper ' -> out.puttext; N[] -> out.putline;
          descs.OD[superDescNo][] -> descs.current.superObjDesc[]
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do '\tENTER:' -> out.putline
       #);
     actions:
       (# hasSuper: @boolean
       enter hasSuper
       do '\tDO:'->out.putline;
          descs.markDoE;
          (if not hasSuper then 
              '\tmvStack '->out.putline;
              codes.mvstack -> emit 
          if);
       #);
     markExitE: (# do descs.markExitE #);
     doExit:
       (#
       do '\tEXIT:' -> out.putline; 
          '\tdoExit ' -> out.putline; 
          codes.doExit -> emit
       #);
     rtn: 
       (# LMR: @char
       enter LMR 
       do '\trtn(' -> out.puttext; LMR->out.put; ')' -> out.put; out.newline;
          codes.rtn -> emit ; LMR -> emit
       #);
     rtnC: (# do '\trtnC' -> out.putline; codes.rtnC -> emit #);
     rtnExit: (# do '\trtnExit' -> out.putline; codes.rtnExit -> emit #);
     rtnInner: (# do '\trtnInner' -> out.putline; codes.rtnInner -> emit #);
     rtnEvent: 
       (# hasExit: @integer 
       enter hasExit 
       do '\trtnEvent ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEvent -> emit;
          hasExit -> emit
       #);
     stop: (# do '\tstop' -> out.putline; codes.stop -> emit #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          'D' -> rtn          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do ' L' -> out.puttext; lab -> out.putint; ':' -> out.put; out.newline;
          lab -> labs.def;
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do '\tjmpIf_GT L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       do '\tjmp L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmp -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpFalse:
       (# lab: @integer 
       enter lab 
       do '\tjmpFalse L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpFalse -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do '\tjmpTrue L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpTrue -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     break:
       (# on,lab: @integer
       enter(on,lab)
       do '\tbreak ' -> out.puttext; on -> out.putint; ' ' -> out.put; lab -> out.putint; out.newline;
          codes.break -> emit;
          on -> emit; 
          (if lab = 0 then
              '\n***** Fatal error break: lsc=0' -> putline
          if);
          lab -> emit2
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do '\talloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.alloc -> emit; descNo -> emit2;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     allocIndexed:
         (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do '\tallocIndexed ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.allocIndexed -> emit; descNo -> emit2;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do '\texeAlloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit2
       #);
       
     newVrep: (# do '\tnewVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do '\tsend ' -> out.puttext; inx -> out.putint; ' ' -> out.put;  N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     sendVirtual: 
       (# N: ^text; dinx: @integer 
       enter(N[],dinx) 
       do '\tsendv ' -> out.puttext; dinx -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.sendv -> emit; dinx -> emit;
       #);
     exe: (# N: ^text enter N[] do '\texe ' -> out.puttext; N[] -> out.putline #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do '\tcall(' -> out.puttext; LMR -> out.put; ')' -> out.put;
          N[] -> out.putline; 
          codes.call -> emit;
          LMR -> emit
       #);
     vdtTableCopy:
       (# superDescNo: @integer; T: @text
       enter superDescNo
       do 'VdtTable:copy:'-> T.puttext; superDescNo -> T.putint;
          (for i: descs.OD[superDescNo].vdtTable.range repeat (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[superDescNo].vdtTable[i] -> T.putint; 
               (i,descs.OD[superDescNo].vdtTable[i]) -> descs.current.vdtAdd
          for); 
          T[] -> comment;
          (* copy literals from super to current *)
          descs.OD[superDescNo].literals.range 
            -> descs.current.litTop
            -> descs.current.literals.new;
          (for i: descs.current.litTop repeat
               (*descs.OD[superDescNo].literals[i] -> putint; ',' -> put;*)
               descs.OD[superDescNo].literals[i] -> descs.current.literals[i]
          for);
          (*newline;*)
       #);
     vdtTable:
       (# inx,descInx: @integer
       enter(inx,descInx)
       do (inx,descInx) -> descs.current.vdtAdd -> comment
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do '\tinner ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerx -> emit; inx -> emit;
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do '\tinnerExit ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;
       #);
     suspendd: (# do '\tsuspend' -> out.putline; codes.susp -> emit #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do '\tdoSuper' -> out.puttext; ' ' -> out.put; N[] -> out.puttext; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit2;
       #);
     pushThis:
       (# 
       do '\tpushThis ' -> out.putline;
          codes.pushthis -> emit; 
       #);

     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.push -> emit; off -> emit
       #);
     pushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.pushg -> emit; off -> emit
       #);
     
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\trpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit
       #);
     rpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\trpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpushg -> emit; off -> emit
       #);
     xpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpush -> emit; off -> emit
       #);
     xpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpushg -> emit; off -> emit
       #);
     pushConst: 
       (# cst: @integer
       enter cst
       do '\tpushc ' -> out.puttext; cst -> out.putint; out.newline;
          (if true 
           // cst <= 255 then
              codes.pushc -> emit;
              cst -> emit
           // cst <= 255 * 255  then
              codes.pushc2 -> emit;
              cst -> emit2
           else 
              'OBS! Constant >= 2^16 is not implemented' -> comment
          if)
       #);
     pushText:
       (# T: ^text; I: @integer
       enter T[]
       do '\tpushText ' -> out.puttext; T[] -> out.putline;
          codes.pushText -> emit;
          T.length -> descs.current.addLiteral
          (#
          do i + 1 -> i -> T.inxGet -> value;
          #) -> emit
       #);
     mkStrucRef:
       (# T: ^text
       enter T[]
       do '\tmkStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkStrucRef -> emit
       #);
     mkVirtualStrucRef:
       (# T: ^text; off: @integer
       enter(T[],off)
       do '\tmkVirtualStrucRef ' -> out.puttext; off-> out.putint; out.newline;
          codes.mkVirtualStrucRef -> emit; off -> emit
       #);
     allocFromStrucRefObj:
       (#
       do '\tallocFromStrucRefObj ' -> out.putline;
          codes.allocFromStrucRefObj -> emit;
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\tstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.store -> emit; off -> emit
       #);
     storeg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\tstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.storeg -> emit; off -> emit
       #);
     rstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\trstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstore -> emit; off -> emit
          if)
       #);
     rstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\trstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstoreg -> emit; off -> emit
          if)
       #);
     xstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\txstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstore -> emit; off -> emit
          if)
       #);
     xstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\txstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstoreg -> emit; off -> emit
          if)
       #);
     double: (# do '\tdouble' -> out.putline; codes.double -> emit #);
     rdouble: (# do '\trdouble' -> out.putline; codes.rdouble -> emit #);
     rPop: (# do '\trpop' -> out.putline; codes.rpop -> emit #);
     CallPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do '\t%' -> out.puttext; P[] -> out.puttext; ' ' -> out.put; op -> out.putint; out.newline;
          codes.prim -> emit; op -> emit
       #);
     op: 
       (# operator: @integer
       enter operator
       do '\t' -> out.put; 
          (if operator
           // codes.plus then 'plus' -> out.putline
           // codes.minus then 'minus' -> out.putline
           else
              operator -> out.putint; out.newline
          if);
          operator -> emit
       #);
     req: (# do '\treq' -> out.putline; codes.req -> emit #);
     rne: (# do '\trne' -> out.putline; codes.rne -> emit #);
     uminus: 
       (# 
       do '\tu-' -> out.putline; 
          codes.uminus -> emit
       #);
     nott: (# do '\tnot' -> out.putline; codes.nott -> emit #);
     saveBETAworld: 
       (#
       do '\tsaveBETAworld' -> out.putline; 
          codes.saveBETAworld -> emit
       #);
     endClass: 
       (# OSDvisibility: @integer
       enter OSDvisibility
       do '\tend ' -> out.puttext; OSDvisibility -> out.putint; out.newline;
          OSDvisibility -> descs.current.OSDvisibility;
          labs.saveInImage 
       #);
     
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (if labNo > loc.range then labNo - loc.range + 4 -> loc.extend if);
               (if labNo > use.range then labNo - use.range + 4 -> use.extend if); (*ugly*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range + 4 -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          saveInImage:
            (# 
            do loc.range -> descs.current.labs.new;
               (for i: loc.range repeat
                   loc[i] -> descs.current.labs[i]
               for)
            #);            
          loc: [8] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [8] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
     dump: (# do descs.dump #);
     
     out: ^Stream;
     
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     
     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     
  #);

