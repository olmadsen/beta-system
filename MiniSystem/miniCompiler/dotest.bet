dotest: @
  (# integer:  (# % simple, 32 % #);
     char: (# % simple, 16 % #);
     put: (# % prim % #);
     object:
       (# % simple %
          suspend: (# % prim % #);
       #);
     repetition:
       (# % simple %
          index: (# % simple % #);
          range: (# % simple % #)
       #);
     
     nl: (# exit 10 #);     
     chk:
       (# a,b,c: @integer
       enter(a,b,c)
       do (if a = b then
              c -> put
           else
              63 -> put
          if)
       #);
     last:
       (# ch: @integer
       enter ch
       do 91 -> put; ch -> put; 93 -> put; nl -> put
       #);
     mark:
       (# ch: @integer
       enter ch
       do ch -> put; ':' -> put
       #);
     basic: @
       (# i,j,k: @integer;
          foo: @
            (# q: @integer;
               inc: (# v: @integer enter v do q+v -> q #);
               show: (# do (q,5,'d') -> chk; q + q -> q exit q #)
            #);
          w: @integer;          
          fisk: (# sild: (# do ch -> put #) #);          
          r,s,t: ^fisk;
          ch: @integer;
          sild:
            (# S: ^sild;
               display: (# do 'j' -> put; ch -> put #);
               ch: @integer
            do this(sild)[] -> S[]; 
               'k' -> ch;
               S.display;
               'l' -> this(sild).ch;
               ch -> put
            #);
          pap: (# go: (# do ch -> put; ch + 2 -> ch; 'n' -> put; #);
                  gogo: (# do ch -> put; 'p' -> put #);
               #);          
          flikker:
            (# s,r: ^pap
            enter(s[],r[])          
            do s.go;
               r.gogo
            #);
          q1,q2: ^pap;

       do 97 -> put;
          (12,12,98) -> chk;
          12 -> i;
          3 -> j -> k;
          (i,j+k*3,99) -> chk;
          5 -> foo.inc;
          foo.show -> w;
          (w,10,'e') -> chk;
          (if (w + 1) = 11 then 102 -> put if);
          
          103 -> ch;
          &fisk[] -> r[];
          r.sild;
          ch + 1 -> ch;
          r[] -> s[] -> t[];
          s.sild;
          ch + 1 -> ch;
          t.sild;
          sild;
          'm' -> ch;
          &pap[] -> q1[];
          &pap[] -> q2[];
          (q1[],q2[]) -> flikker;
          'p' -> last;
       #);

     super: @
       (# foo: (# a: @integer do 97 -> a -> put; inner; a -> put #);
          bar: foo(# b: @integer do a + 1 -> b -> put; b+1 -> a #);
          
          fisk: (# a,b: @integer enter(a,b) do a -> put; inner; b -> put exit(104,105) #);
          sild: fisk(# c,d: @integer enter(c,d) do c -> put; d -> put exit(106,107) #)
          
          fool: (# ch: @integer do 'l' -> ch; ch -> put; inner; ch -> put #);
          bart: fool(# do ch + 1 -> ch; ch -> put; inner; ch -> put; ch + 1 -> ch #);
          snorfle: bart(# do ch + 1 -> ch; ch -> put; ch + 1 -> ch #)
          q,w,e,r: @integer        
       do bar;
          (100,103,101,102) -> sild -> (q,w,e,r);
          q -> put; w -> put; e -> put; r -> put;
          snorfle;
          'p' -> last
       #);
     
     coroutine: @
       (# foo: @
            (# a,b: @integer;
               bar: (# x,y: @integer do q+4 -> put; foo.suspend; q+6 -> put;#);
            do q+1 -> put;
               foo.suspend;
               q+3 -> put;
               bar;
               q+7 -> put;
               foo.suspend;
               q+9->put;
            #);
          w,q: @integer
       do 97 -> q;
          q  -> put;  
          foo;
          99 -> put;  
          foo
          102 -> put; 
          foo
          105 -> put; 
          foo;
          q + 10 -> put;
          q + 10 -> q;
          foo;
          109 -> put;
          109 -> last 
       #);
     rep: @
       (# R: [10] @integer;
          S: [3] @integer;
          globalRep:
            (#
            do (for k: 3 repeat 107 + k -> S[k] for);
               (for k: 3 repeat S[k] -> put for);
            #);
          forTst2: @
            (# q,w: @integer
            do 109 -> q;
               (for i: 10 repeat
                    q + i -> put;
                    0 -> w;
                    (for j: 3 repeat w+j -> w for)
               for);
               120 -> put;
               (if w = 6 then 121 -> put else 66 -> put if);
            #);
          
       do 97 -> R[3];
          R[3] -> put;
          (for i: 10 repeat 97 + i -> R[i] for);
          (for i: 10 repeat R[i] -> put for);
          globalRep;
          forTst2;
          121 -> last
       #);
     label: @
       (# a: @integer
       do 'a' -> a;
          a -> put;
          L:
            (if a = 100 then
                leave L
             else
                a + 1 -> a;
                a -> put;
                restart L
            if);
          L: (for i: 10 repeat 
                  a + 1 -> a -> put;
                  (if a = 5 then leave L if)
             for);
          'n' -> last
       #);
     iff: @
       (# a: @integer
       do 2 -> a;
          (if a = 2 then
              a + 95 -> a -> put
           else
              '?' -> put
          if);
          (for i: 5 repeat
               (if i
                // 1 then 'b' -> a -> put
                // 2 then
                   a + 1 -> a -> put
                // 3 then  'd' -> put;
                // 99 then
                   '!' -> put
               if);
          for);
          (for k: 3 repeat
               (if a
                // 96 // 99 then
                   a + 2 -> a -> put
                // 101 // 11 then 
                   'f' -> put;
                   18 -> a;
                // 99 // 100 then
                   '!' -> put
               if);
          for);
          (if a
           // 101 then
           // 102 then
           else
              'g' -> put
          if);
          'g' -> last
       #);
     virt: @
       (# foo:
            (# fisk:< (# do ch -> put; ch + 1 -> ch; inner; ch -> put #);
            #);
          bar: foo
            (# fisk::< (# do ch -> put; ch+1 -> ch; inner; ch -> put; ch + 1 -> ch #);
            #);
          snorf: bar
            (# fisk:: (# do ch -> put; ch + 1 -> ch #)
            #);
          R1: @foo;
          R2: @bar;
          R3: ^snorf;
          ch: @integer
       do 97 -> ch;
          R1.fisk;
          ch + 1 -> ch;
          R2.fisk;
          ch + 1 -> ch;
          &snorf[] -> R3[];
          R3.fisk;
          'k' -> last
       #);
     insItem: @
       (# fooBar: (# z: @integer do x -> put; inner; zz -> put; #);
          R: @ 
            (# scan: (# do (for i: 3 repeat inner; zz -> put for) #)
               doIt: 
                 (# a,b: @integer enter(a,b) do a -> put; b -> put; b+1  -> x; inner exit b+2 #)
            #);
          x,y,zz: @integer
       do 'a' -> x; x + 1 -> y;
          fooBar(# q: @integer do y -> put; y + 1 -> q; q -> put; q+1 -> zz #);
          R.scan(# do zz + 1 -> zz #);
          ('h','i') -> R.doIt(#do x -> put #) -> y;
          y -> put;
          'k' -> last
       #);
     binOp: @
       (# foo: (# do inner #);     
          a,b,c: @integer
       do 1 -> b;
          2 -> a;
          3 -> c; 
          (if (b < a) and (C = 3) then
              'a' -> put
          if);
          (if (b > a) and (C = 3) then
              '!' -> put
           else              
              'b' -> put
          if);
          (if (b > a) or (C = 3) then
              'c' -> put
           else         
              '!' -> put
          if);
          (if (b > a) or (C = 4) then
              '?' -> put
           else         
              'd' -> put
          if);
          
          foo
          (#
          do 11 -> a; 12 -> b;
             (if a < b then 'e'-> put else '?' -> put if);
             (if a <= b then 'f'-> put else '?' -> put if);
             (if a > b then '?' -> put else 'g' -> put if);
             (if a >= b then '?' -> put else 'h' -> put if);
             (if a <> b then 'i' -> put else '?' -> put if);
             (if a = b then '?' -> put else 'j' -> put if);
          #);
          foo
          (#
          do
             12 -> a;
             (if a < b then '?' -> put else 'k' -> put if);
             (if a <= b then 'l' -> put else '?' -> put if);
             (if a > b then '?' -> put else 'm' -> put if);
             (if a >= b then 'n' -> put else '?' -> put if);
             (if a <> b then '?' -> put else 'o' -> put if);
             (if a = b then 'p' -> put else '?' -> put if);
          #);
          'p' -> last
       #);
     block: @
       (# Thea:
            (# hej: @ (# do 'a' -> put #);
            do inner
            #);
          Robin: Thea
            (# du: @ (# do 'b' -> put #)
            do inner; 
            #);
          Linnea: Robin
            (# gamle: @ (# do ch -> put #)
            do hej; du; gamle
            #);
          ch: @integer;
          snaps:
            (# ch: @integer;
               roed: @ (# do ch -> put; ch + 1 -> ch #)
            do 'd'-> ch; inner; ch -> put
            #);
          
          vin:
            (# vand: snaps 
                 (#  chainti: @ (# do ch -> put; ch + 1 -> ch #);
                 do ch -> put; ch +1 -> ch; roed; chainti;
                 #);
               
            do vand
            #)
       do 'c' -> ch;
          Linnea;
          vin;
          'g' -> last
       #);
     SLMR: @
       (# fool:
            (# a,b,c,d,e: @integer;
               single: (# do 0 -> a; 1 -> b; 2 -> c #);
               xit: (# do 6 -> a; 7 -> b; 8 -> c #);
            enter(a,b,c)
            do ch + a -> put; ch + b -> put; ch + c -> put;
               'j' -> d; 'k' -> e
            exit(d,e)
            #);
          F: @fool;
          ch,x,y: @integer
       do 'a' -> ch;
          ch;
          F.single;
          F;
          (3,4,5) -> F;
          F.xit;
          F -> (x,y);
          x -> put;
          y -> put;
          'k' -> last
       #);
     textTst: @
       (# text:
            (# T: [16] @char; (* T.inx: length of this(text) *)
               putx:
                 (# ch: @char
                 enter ch 
                 do pos + 1 -> pos;
                    ch -> T[pos];
                    (if pos > T.index then pos  -> T.index if)
                 #);
               print:
                 (#
                 do (for i: T.index repeat T[i] -> put for)
                 #);          
               scan:
                 (# currentCh: (# enter T[inx] exit T[inx] #);
                    inx: @integer
                 do (for i: T.index repeat i -> inx; inner for)
                 #);
               pos: @integer;
            enter T[]
            exit T[]
            #);     
          S: @text;     
          R: [1] @char;     
          T: ^text;
          S1: @text
       do 'a' -> S.putx;
          (for i: 3 repeat
               'a' + i -> S.putx
          for);
          S.print;
          'efghi' -> R[];
          (for i: 5 repeat
               R[i] -> put 
          for);
          'jkl' -> S;
          S.print;

          S -> S1;
          S1.scan(# do currentCh + 3 -> currentCh #);
          S1.print;
          'o' -> last
       #)
  do 'A' -> mark;
     basic;
     'B' -> mark;
     super;
     'C' -> mark;
     coroutine;
     'D' -> mark;
     rep;
     'E' -> mark;
     label;
     'F' -> mark;
     iff;
     'G' -> mark;
     virt;
     'H' -> mark;
     insItem;
     'I' -> mark;
     binOp;
     'J' -> mark;
     block;
     'K' -> mark;
     SLMR;
     'L' -> mark;
     textTst;
  #)
