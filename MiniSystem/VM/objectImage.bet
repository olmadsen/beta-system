ORIGIN '~beta/basiclib/betaenv'; 
INCLUDE '~beta/basiclib/binfile';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE 'ByteImage';
INCLUDE 'interpreterAPI'
---lib:attributes---
RuntimeDescriptors:
  (# OD: [4] ^ObjDesc; top: @integer;
     newAlloc: @boolean;
     onlyCinterpreter: @boolean;
     setCurrent:
       (# name: ^text; descNo,originOff,originDescNo: @integer; 
          isValueObj: @boolean; out: ^stream
       enter(name[],descNo,originOff,originDescNo,isValueObj,out[])
       do (*'setCurrent: ' -> puttext; descNo -> putint; ' ' -> put;
           OD.range -> putint; newline;*)
          (if descNo > OD.range then
              (* needed for handling of varainst: vDescno for stubs
               * should be fixed: see cd.newComponent
               * which also seems to need a revision
               *)
              descNo - OD.range + 3 -> OD.extend;
              OD.range -> top
          if);
          &ObjDesc[] -> OD[descNo][] -> current[];
          (name[],descNo,originOff,originDescNo,isValueObj
          ,out[],this(RunTimeDescriptors)[]) 
            -> current.init
       #);
     current: ^ObjDesc;
     markAllocE: (# do current.BC.top+1 -> current.BC.allocE #);
     markProcE : (# do current.BC.top+1 -> current.BC.procE #);
     markEnterE: (# do current.BC.top+1 -> current.BC.enterE #);
     markExitE: (# do current.BC.top+1 -> current.BC.exitE #);
     markDoE: (# do current.BC.top+1 -> current.BC.DoE #);
     serialize:
       (# BI: ^ByteImage; descs: @integer;
          emitBinFile:
            (# f: ^binfile; 
            do &binfile[] -> f[];
               BC_FN[] -> f.name;
               f.openwrite;
               (for I: BI.top repeat
                    BI.B[i] -> f.putByte
               for);
               f.close
            #);
          mainDescInx: @integer;
          BC_FN: ^text
       enter(mainDescInx,BC_FN[])
       do &ByteImage[] -> BI[];
          (*allocate desc index table *)
          '-' -> BI.put; 
          'x' -> BI.put; 'B' -> BI.put; 'e' -> BI.put; 't' -> BI.put; 'a' -> BI.put;
          '-' -> BI.put; '-' -> BI.put;
          0  -> BI.put4; (* size of binary image *)
          mainDescInx -> BI.put4;
          textDescNo -> BI.put4;
          structureRefDescNo -> BI.put4;
          0 -> BI.put4; (* index of stringtable *)
          top -> BI.put4;
          (for i: top repeat 0 -> BI.put4 for);
          (for i: top repeat
               (if OD[i][] <> none then
                   i -> BI.setIndex;
                   BI[] -> OD[i].serialize
               if);               
          for);

          BI.copyStrings;
          BI.markTop;

          (*BI.dump;*)
          (if BC_FN[] <> none then
              (* create save byte ode imgae on file *)
              emitBinFile;
              BC_FN[] -> BI.emitCarray;
          if);
          inner; 
          @@BI.B[1] -> descs ; (* MUST be last stmt!
                                * - no GC from here to 
                                * init_interpreter in betaVM
                                *)
       exit descs
       #);
     dump:
       (#
       do (for i: top repeat
               (if OD[i][] = none then  (* primitive descriptor has no code *)
                   (*'dump:none:i:' -> puttext; i -> putint; 
                   ' top:' -> puttext; top -> putint; newline;*) 
                else
                   OD[i].dump     
               if);
          for)
       #);
     textDescNo,structureRefDescNo: @integer;
     mk_cTemplate:
       (# obj: @integer; S: ^objDesc.cTemplate; descNo: @integer
       enter obj
       do (*' mk_cTemplate: ' -> puttext; obj -> putint; newline;*)
          (if obj > 0 then
              obj -> &(*descs.*)OD[obj->descNoOf->descNo].cTemplate -> S[];
              descNo -> S.myDescInx; (* probably superfluous *)
          if)
       exit S[]
       #);
     objPool: @ 
       (# id: @integer; obj: ^objDesc.template;
          pool: [30000] ^objDesc.template
       enter obj[]
       do (if (id + 1 -> id ) > pool.range then
              pool.range -> pool.extend
          if);
          id -> obj.id;
          obj[] -> pool[id][]
       #);
     cObjCache: @
       (# id: [100] @integer; R: [100] ^objDesc.cTemplate; top: @integer;
          get:
            (# obj: @integer; cObj: ^objDesc.cTemplate; objOrg: @integer
            enter obj
            do (if obj > 0 then 
                   L:
                     (#
                     do (for i: top repeat
                             (if id[i] = obj then 
                                 R[i][] -> cObj[]; 
                                 leave L 
                             if)
                        for);
                        (if (top + 1 -> top) > id.range then
                            id.range -> id.extend; R.range -> R.extend
                        if);
                        obj -> id[top]; 
                        obj -> mk_cTemplate -> cObj[];
                        cObj[] -> R[top][];
                        (if cObj[] <> none then 
                            obj -> getIsObj -> cObj.isObj;
                        if);
                     #);
                   (*'\ncObjCache:'->puttext; cobj.myName -> putline;*)
                   (if cObj.theOrg[] = none then
                       obj -> myCorigin -> objOrg; 
                       (if objOrg > 0 then
                           objOrg -> get -> cObj.theOrg[]
               if)if)if)
            exit cObj[]
            #)
       #);
  #);
ObjDesc:
  (# name: ^text; 
     descInx,objSize,isIndexed,originOff,originDescInx: @integer;
     superObjDesc: ^ObjDesc;
     isValueObj: @boolean;
     myId: (* Note, there is also a myId in RunTimeObject *)
       (# T: @text 
       do name[] -> T.puttext; 
          ':descInx:' -> T.puttext; descInx -> T.putint; 
       exit T[]
       #);
     noOfSuper: IntegerValue
       (#
       do (if superObjDesc[] <> none then
              superObjDesc.noOfSuper + 1 -> value
          if)
       #);
     RunTimeObject:
       (* this pattern defines the interface to run-time objects 
        * (template)
        * that is used by minienv (worldWindow,sequencediagram)
        *)
       (# id: @integer;                   
          isObj: @boolean;
          OSDvisibility: @integer;
          myDescInx: @integer; (* set by instructions in betaVM, 
                                * perhaps just use descInx 
                                * in enclosing objDesc
                                *)
          myObjDesc: 
            (# D: ^ObjDesc do this(ObjDesc)[] -> D[] exit D[] #); 
          myName:< (# theName: ^text do inner exit theName[] #);
          myOrigin:< (# org: ^RunTimeObject do inner exit org[]#);
          mkDummyTemplate:
            (# obj: ^Template
            do &template[]  -> obj[];
               4 -> obj.fields.new;
               1 -> obj.myDescInx;
               obj[] -> thisRunTimeDescriptors.objPool;
               true -> obj.isObj
            exit obj[]
            #);
          get:<
            (# inx,V: @integer
            enter inx
            do inner
            exit V
            #);
          put:<
             (# inx,V: @integer
             enter(inx,V)
             do inner
             #);
          rget:<
            (# inx: @integer; R: ^RunTimeObject
            enter inx
            do inner
            exit R[]
            #);
          rput:<
            (# inx: @integer; X: ^RunTimeObject
            enter(inx,X[])
            do inner
            #);
          myLscTop:< (# top: @integer do inner exit top #);
          myLsc:< (# top: @integer do inner exit top #);
          saveReturn:< 
            (# descNo,lsc: @integer enter(descNo,lsc) do inner #);
          restoreReturn:< 
            (# descNo,lsc: @integer do inner exit(descNo,lsc) #);
          topReturn:< 
            (# descInx,lsc: @integer do inner exit(descInx,lsc) #);
       do inner
       #);
     cTemplate: RunTimeObject
       (# myName::
            (# T: @text
            do objId -> nameOf -> T; T[] -> theName[]
            #);
          theOrg: ^cTemplate;
          myOrigin:: 
            (#
            do theOrg[] -> org[];
            #);
          get:: (# do (objId,inx) -> getV -> V #);
          put:: (# do '***** OBS!ctemplate::put called'->putline #);
          rget:: 
            (# 
            do (objId,inx) 
                 -> getR 
                 -> thisRunTimeDescriptors.cObjCache.get -> R[]
            #);
          myLscTop:: 
            (# 
            do objId -> cMyLscTop -> top
            #);
          myLsc:: 
            (#
            do (objId,0) -> topOfLsc -> top 
            #);
          saveReturn:: 
            (# 
            do (objId,descNo,lsc) -> cSaveReturn 
            #);
          restoreReturn:: 
            (# 
            do objId -> cRestoreReturn -> lsc; 
               objId -> cRestoreReturn -> descNo
            #);
          topReturn:: 
            (# 
            do (objId,0) -> topOfLsc -> lsc;
               (objId,-1) -> topOfLsc -> descInx
            #);
          objId: @integer;
       enter objId
       do objId -> getIsObj -> isObj
       exit this(cTemplate)[]
       #);
     Template: RunTimeObject
       (# valOff: @integer;
          fields: [0] @integer;
          vstack: [16] @integer; (* perhaps stacks can be integrated
                                  * with fields *) 
          rstack : [24] ^template;
          vtop,rtop: @integer;
          lscStack: [8] @integer; 
          lscTop: @integer;
          myLscTop:: (# do lscTop -> top #);
          rangee,inx: @integer;
          dumpFields:
            (# msg: @text
            do (for i: fields.range repeat
                    i -> msg.putint; ': ' -> msg.puttext;
                    fields[i] -> msg.putint; msg.newline
               for)
            exit msg[]
            #);          
          get::
            (# 
            do (*'valOff:'->out.puttext; valOff -> out.putint; 
                * out.newline;*)
               valOff + inx -> inx;
               (if (inx < 1) or (inx > (fields.range)) then
                   4 -> fatalError 
                   (#
                   do 'Template:get:index: ' -> msg.puttext; 
                      inx -> msg.putint; 
                      ' range: ' -> msg.puttext; 
                      fields.range -> msg.putint; 
                      msg.newline;                   
                      dumpFields -> msg.puttext;
                   #)
                     -> putline;
               if);
               (*'get: ' -> puttext; inx->putint; ' : ' -> puttext; 
                * fields[inx] -> putint; newline*)
               fields[inx] -> V;
            #);
          put::
            (# 
            do valOff + inx -> inx;
               (if (inx < 1) or (inx > (fields.range)) then
                   '\nTemplate:put:index: ' -> puttext; inx->putint;
                   ' range: ' -> puttext; fields.range -> putint; 
                   newline;
                   dumpFields;
                   4 -> fatalError -> putline;
               if);
               V -> fields[inx]
            #);
          rget::
            (# 
            do (if (inx < 1) or (inx > (fields.range)) then
                   '\nTemplate:rget:index: ' -> puttext; 
                   inx -> putint; 
                   ' range: ' -> puttext; fields.range -> putint; 
                   newline;
                   dumpFields;
                   4 -> fatalError -> putline
               if);
               (if fields[inx] = 0 then
                   none -> R[]
                else 
                   thisRunTimeDescriptors.ObjPool.pool[fields[inx]][] -> R[];
                   (if (fields[inx] > 0) and (R[] = none) then
                       9->FatalError(#do fields[inx]->msg.putint #) 
                         -> putline
               if)if)
            #);
          rput::
            (# 
            do (if (inx < 1) or (inx > (fields.range)) then
                   '\nTemplate:rput:index: ' -> puttext; 
                   inx -> putint; 
                   ' range: ' -> puttext; fields.range -> putint; 
                   newline;
                   dumpFields;
                   4 -> fatalError  -> putline
               if);
               (if X[] = none then
                   0 -> fields[inx]
                else 
                   X.id -> fields[inx]
               if)
            #);
          assign:
            (# val,inx: @integer
            enter(val,inx)
            do (if (inx < 1) or (inx > fields.range) then
                   4 -> fatalError -> putline
               if);
               (*'assign: ' -> puttext; inx -> putint; 
                * ' : ' -> puttext; 
                * val -> putint; newline;*)
               val -> fields[inx]
            #);
          fatalError:
            (# errNo: @integer; msg: @text
            enter errNo
            do '\n\n!!!! betaVM fatal error: ' -> msg.puttext;
               (if errNo
                // 1 then
                   'ValueStack underflow' -> msg.puttext
                // 2 then
                   'ReferenceStack underflow' -> msg.puttext
                // 3 then
                   'Reference is none' -> msg.puttext
                // 4 then
                   'Index error' -> msg.puttext
                // 5 then
                   'Illegal/unimplemented op-code' -> msg.puttext
                // 6 then
                   'Execution of an object reference that is NONE' 
                     -> msg.puttext
                // 7 then
                   'ReferenceStack overflow' -> msg.puttext
                // 8 then
                   'No entry in VDTtable (zero)' -> msg.puttext
                // 9 then
                   'No object corresponding to object index: ' 
                     -> msg.puttext;
                // 10 then
                   'Origin of object invocation is none' 
                     -> msg.puttext
               if);
               '!\n' -> msg.puttext;
               inner;
               '\n!!   In nested object structure:\n      ' -> msg.puttext;
               myFullName -> splitName -> msg.puttext;
               (if false then
                   msg[] -> putline; (* perhaps not what we want!?*)
                   (failureTrace,'Program execution terminates') 
                     -> stop
               if);
            exit msg[]
            #);

          myName:: (# do name[] -> theName[] #);
          myFullName: 
            (# N: ^text; org: ^template;
            do (if myOrigin <> none then
                   myOrigin -> org[];
                   org.myFullName -> N[];
                   ':'-> N.put
                else
                   &text[] -> N[]
               if);
               '"' -> N.put; myName -> N.puttext; 
               '" (descInx = ' -> N.puttext; myDescInx -> N.putint;
               ', objectId = ' -> N.puttext; id -> N.putint;
               ')'  -> N.put
            exit N[] 
            #);
          splitName:
            (# N1,N2: ^text
            enter N1[]
            do &text[] -> N2[];
               N1.scanAll
               (# l: @integer
               do ch -> N2.put; 
                  (if ch = ':' then
                      l + 1 -> l;
                      '\n      ' -> N2.putText;
                      (for i: l repeat ' ' -> N2.put for)
                  if)
               #)
            exit N2[]
            #);
          myCode: (# exit bc[] #);
          mySuperCode: (# exit superBC[] #);

          myOrigin:: 
            (# orgOff,off: @integer; 
            do originOff -> orgOff; 
               (if orgOff > 0 then
                   (* for valueRep, orgOff = 0 *)
                   (*'myOrigin: ' -> puttext; myName -> puttext;
                    ' originOff: ' -> puttext; orgOff -> putint;
                    ' fields: ' -> puttext; fields[orgOff]->putint; 
                    newline;*)
                   (if fields[orgOff] = 0 then
                       none -> org[]
                    else 
                       thisRunTimeDescriptors.ObjPool.pool[fields[orgOff]][] 
                         -> org[]
               if)if)
            #);
          
          myId: 
            (# T: @text 
            do name[] -> T.puttext; 
               ':di:'->T.puttext; myDescInx->T.putint; 
               ':id:'->T.puttext; id -> T.putint; ' ' -> T.put
            exit T[]
            #);
 
          myDyn: (# exit rstack[1][]#);
          myLsc:: (# do lscStack[lscTop] -> top #);

          saveReturn::
            (# 
            do (if false then
                   '\nsaveReturn:' ->out.puttext; 
                   lscTop -> out.putint; 
                   ' ' -> out.put; myId -> out.putline
                if);                
               (if (lscTop + 2 -> lscTop) > lscStack.range then
                   lscStack.range -> lscStack.extend 
               if);
               descNo -> lscStack[lscTop-1];
               lsc -> lscStack[lscTop];
            #);
          topReturn:: (* descInx,lsc - used by miniEnv/WorldWindow*)
            (# 
            do lscStack[lscTop-1] -> descInx; 
               lscStack[lscTop] -> lsc
            #);
          restoreReturn::
            (#
            do lscTop - 2 -> lscTop;
               (if false then
                   '\nrestorereturn: ' -> out.puttext; 
                   lscTop ->out.putint; 
                ' ' -> out.put; myId -> out.putline
                if);
               lscStack[lscTop+1] -> descNo; 
               lscStack[lscTop+2] -> lsc;
            #);
          vstackIsEmpty: (# exit vtop=0 #);
          rstackIsEmpty: (# exit rtop=0 #);
          vpush:
            (# val: @integer
            enter val
            do (if (vtop+1->vtop) > vstack.range then 
                   vstack.range -> vstack.extend if);
               val -> vstack[vtop]
            #);
          fpush:
            (# var: @real; L1,L2: @integer
            enter var
            do %getLongAt(@@var) -> L1;
               %getLongAt(@@var + 4) -> L2;
               L1 -> vpush;
               L2 -> vpush;
            #);
          vpop:
            (# val: @integer
            do (if vtop = 0 then 1 -> fatalError -> putline if);
               vstack[vtop] -> val; vtop-1 -> vtop
            exit val
            #);
          vdub: 
            (# 
            do (if vtop <= 0 then 1 -> fatalError -> putline if); 
               vstack[vtop] -> vpush
            #);
          vTopElm: 
            (# val: @integer 
            do (if vtop = 0 then 1 -> fatalerror -> putline if);
               vstack[vtop] -> val
            exit val
            #);
          fpop: (* float pop *)
            (# val: @real; L1,L2: @integer
            do (if vtop <= 1 then 1 -> fatalerror -> putline if);
               vstack[vtop] -> L2;
               vstack[vtop - 1] -> L1;
               vtop - 2 -> vtop;
               L1 %putLongAT (@@val);
               L2 %putLongAt (@@val + 4);
            exit val
            #);
          rpush:
            (# val: ^template
            enter val[]
            do (if (rtop+1->rtop) > rstack.range then
                   rstack.range -> rstack.extend if);
               val[] -> rstack[rtop][]
            #);
          rpop:
            (# val: ^template
            do (if rtop < 1 then 2 -> fatalError -> putline if);
               (if rtop > rstack.range then 
                   7 -> fatalerror -> putline 
               if);
               rstack[rtop][] -> val[]; rtop-1 -> rtop;
            exit val[]
            #);
          rswap:
            (# obj1,stack1,obj2,stack2: ^template
            enter(obj1[],stack1[])
            do rstack[1][] -> obj2[];
               rstack[2][] -> stack2[];
               obj1[] -> rstack[1][];
               stack1[] -> rstack[2][];
               (if rtop = 0 then 2 -> rtop if);
               (if obj1[] = none then  0 -> rtop if)
            exit(obj2[],stack2[])
            #);
          rswapIndexed:
            (# inx: @integer; obj: ^template
            enter inx
            do
               rstack[rtop - inx][] -> obj[];
               (for i: inx repeat
                   rstack[rtop - i + 1][] -> rstack[rtop - i][]
               for);
               obj[] -> rstack[rtop][]
            #);
          rdub: 
            (# 
            do (if rtop = 0 then 2 -> fatalError -> putline if); 
               rstack[rtop][] -> rpush
            #);
          rTopElm:
            (# off: @integer; val: ^template
            enter off
            do (if rtop = 0 then 2 -> fatalError -> putline if);
               rstack[rtop - off][] -> val[]; 
            exit val[]
            #);
          return:
            (# thisStackCaller,thisObjCaller: ^Template
            do rstack[2][] -> thisStackCaller[];
               rstack[1][] -> thisObjCaller[]
            exit(thisStackCaller[],thisObjCaller[])
            #);
          lscPush:
            (# V: @integer
            enter V
            do (if (lscTop + 1 -> lscTop) > lscStack.range then
                   lscStack.range -> lscStack.extend 
               if);
               V -> lscStack[lscTop];
            #);
          lscPop:
            (# V: @integer
            do 
               lscStack[lscTop] -> V;
               lscTop - 1 -> lscTop;
            exit V
            #);
          
          lsc: @integer;
          dumpObj:
            (# out: ^Stream; head: ^text
            enter(out[],head[])
            do head[] -> out.puttext;
               myId -> out.puttext;
               out[] -> dumpStacks;
               inner dumpObj;
               out.newline
            #);
          dumpObjFull: dumpObj
            (#
            do 'D[' -> out.puttext;
               (for i: vdtTable.range repeat 
                    vdtTable[i] -> out.putint; 
                    (if i < vdtTable.range then 
                        ',' -> out.put 
                     else
                        ']' -> out.put
               if)for);
               'L[' -> out.puttext;
               (for i: lscTop repeat 
                    lscStack[i] -> out.putint; 
                    (if i < lscTop then ',' -> out.put if)
               for);
               ']F[' -> out.puttext;
               (for i: Fields.range repeat 
                    fields[i] -> out.putint; 
                    (if i < Fields.range then ',' -> out.put if);
               for);               
               ']' -> out.put
            #);
          dumpStacks:
            (# out: ^Stream
            enter out[]
            do 'R[' -> out.puttext;
               (for i: rtop repeat
                    (if rstack[i][] <> none then
                        rstack[i].myName -> out.puttext
                     else 
                        'none' -> out.puttext
                    if);
                    (if i < rtop then ',' -> out.put if)
               for);
               ']V[' -> out.puttext;
               (for i: vtop repeat
                    vstack[i] -> out.putint;
                    (if i < vtop then ',' -> out.put if)
               for);
               ']' -> out.put
            #);
          
          dump:
            (# msg: ^text; trace: @boolean; 
               out: ^Stream (* OBS - eliminate global out *)
            enter(msg[],trace,out[])
            do '\n**** ' -> out.puttext;
               msg[] -> out.putline;               
               (if trace then   
                   'Object:"' -> out.puttext; myName -> out.puttext; 
                   '" descNo:' -> out.puttext; myDescInx -> out.putint;
                   '" id:' -> out.puttext; id -> out.putint; 
                   ' lsc: ' -> out.puttext; lsc -> out.putint; out.newline;
                   'Fields: ' -> out.puttext; 
                   (for i: Fields.range repeat fields[i] -> out.putint; ' ' -> out.put for);
                   out.newline;
                   'VStack: ' -> out.puttext;
                   (for i: vtop repeat vstack[i] -> out.putint; ' ' -> out.put for);
                   out.newline;
                   'RStack: ' -> out.puttext;
                   (for i: rtop repeat 
                        (if rstack[i][] <> none then 
                            rstack[i].myname -> out.puttext; ':'->out.put;
                            rstack[i].id -> out.putint 
                         else
                            '*' -> out.put
                        if);
                        ' ' -> out.put 
                   for);
                   out.newline;
                   'VdtTable: ' -> out.puttext;
                   (for i: vdtTable.range repeat vdtTable[i] -> out.putint; ' ' -> out.put for);
                   out.newline;
                   'lscStack: ' -> out.puttext;
                   (for i: lscTop repeat lscStack[i] -> out.putint; ' ' -> out.put for);
                   out.newline;
               if)
            #);
          size,isRindexed: @integer
       enter(size,rangee,inx,isRindexed)
       do (* Only Indexed objects are allocated by executing Template
           * Ordinary objects are allocated by &template[]
           * Should be cleaned up
           *)
          rangee * size + 2 -> fields.new;  
          
          (* fields[1] = origin, but perhaps not used?
           * fields[inx = 2] = range
           * fields[inx + 1]: rep[1]
           * ...
           *)
          rangee -> fields[inx];
       exit this(Template)[]
       #);

     literals: [4] @integer; (* preliminary *) litTop: @integer;
     addLiteral:
       (# value: @integer; (* the value - if text: the length of the text *)
          index,length,inx: @integer
       enter value
       do value -> length; litTop + 1 -> index;
          (if (litTop + length) >= literals.range then 
              literals.range + length -> literals.extend 
          if);
          litTop + 1 -> litTop;
          length -> literals[litTop];
          (for i: length repeat
               INNER addLiteral (* add text possible elements *);
               litTop + 1 -> litTop;
               value -> literals[litTop];
          for)
       exit index
       #);
          
     vdtTable: [4] @integer; (* virtual dispatch table + main parts for inner *)
     isInner: [4] @ boolean; (* the entry is an inner *)
     vdtTop: @integer;
     vdtAdd:
       (# inx,vDescInx: @integer; isInnerEntry: @boolean; T: @text
       enter(inx,vDescInx,isInnerEntry)
       do (if inx > vdtTable.range then 
              (* we should probably calculate and set the range *)
              inx - vdtTable.range -> vdtTable.extend;
              inx - isInner.range -> isInner.extend
          if);
          (if inx > vdtTop then inx -> vdtTop if);
          (if true then
              'vdtAdd: inx=' -> T.puttext; inx -> T.putint; 
              ' descInx='-> T.puttext; descInx -> T.putint; 
              ' vDescInx='-> T.puttext; vDescInx -> T.putint; 
              ' vdtTop: ' -> T.puttext; vdtTop -> T.putint;
          if);
          vDescInx -> vdtTable[inx];
          isInnerEntry -> isInner[inx]
       exit T[]
       #);
     vdtTable_serialize:
       (# BI : ^ByteImage;
          labsStart,litStart,GCinfoStart,BCstart: @integer;
       enter BI[]
       do (* 32 = labIndex, 
           * 16 = size(literal_index, GCinfo_index, BC_index, vdtTable_index)
           * But is this correct?
           *)
          (32 + 16 + vdTtable.range * 4) -> labsStart -> BI.put4;
          labsStart + labs.range * 2 -> litStart -> BI.put4;
          (*litStart + litTop * 2 -> BCstart -> BI.put4;*)
          litStart + litTop * 2 -> GCinfoStart -> BI.put4;
          GCinfoStart + GCinfo.top * 2 -> BCstart -> BI.put4;
          (for i: vdtTable.range repeat vdtTable[i] -> BI.put4 for);
          (for i: labs.range repeat labs[i] -> BI.put2 for);
          (for i: litTop repeat literals[i] -> BI.put2 for);
          BI[] -> GCinfo.serialize;
       #);
     bc: @ByteCode(# descId::(# do descInx -> inx #)#);
     
     labs: [0] @integer;
     
     OSDvisibility: @integer;
     
     GCinfo: @
       (# info: [4] @integer; top: @integer;
          add:
            (# off: @integer
            enter off
            do (if (top + 1 -> top) > info.range then info.range -> info.extend if);
               off -> info[top]
            #);
          serialize:
            (# BI: ^ByteImage
            enter BI[]
            do
               (for i: top repeat info[i] -> BI.put2 for);
            #)
       #); 
       
     setSuperBC: (# enter(topDescNo,superBC[]) #);
     topDescNo: @integer;
     superBC: ^ByteCode;
     serialize:
       (# BI : ^ByteImage
       enter BI[]
       do name[] -> BI.puttext;  
          descInx -> BI.put4; 
          topDescNo -> BI.put4;
          objSize -> BI.put4; 
          isIndexed -> BI.put4;
          originOff -> BI.put2;
          (if isValueObj then 1 -> BI.put2 else 0 -> BI.put2 if);
          BI[] -> BC.serialize(#do BI[]->vdTtable_serialize #)
       #);     
     dump: 
       (# 
       do out.newline;
          'Class ' -> out.puttext; name[] -> out.puttext; 
          ' descInx:'-> out.puttext; descInx -> out.putint; 
          ' objSize:'->out.puttext; objSize -> out.putint;
          ' originOff: '-> out.puttext; originOff -> out.putint; 
          ' visibility: ' -> out.puttext; OSDvisibility -> out.putint;
          out.newline;
          bc.dump
       #);
     init: 
       (# 
       enter(name[],descInx,originOff,originDescInx,isValueObj,
          out[],thisRunTimeDescriptors[])  
       do (descInx,out[]) -> bc.init;
       #);
     thisRunTimeDescriptors: ^RunTimeDescriptors;
     out: ^Stream 
  #);

OSDvisibility_open: (# exit 0 #);
OSDvisibility_SkipInternal: (# exit 1 #);
OSDvisibility_Disguised: (# exit 2 #);

ByteCode: 
  (# B: [8] @int8u; top: @integer;
     init: (# enter(descInx,out[]) #);
     descInx: @integer; (* of this objDesc - and not a possible subpattern af this ObjDesc *)
     descId:< (# inx: @integer do inner exit inx #);
     allocE,enterE,doE,exitE,procE: @ integer;

     out: ^Stream;
     emit:
       (# op: @int8u
       enter op
       do (if (top + 1 -> top) > B.range then
              B.range-> B.extend
          if);
          op -> B[top]
       #);
     emit2:
       (# op: @int16u
       enter op
       do (if (top + 2 -> top) > B.range then
              B.range-> B.extend
          if);
          op div 256 -> B[top - 1];
          op mod 256 -> B[top]
       #);
     emit8:
       (# op: @real
       enter op
       do (if (top + 8 -> top) > B.range then
              B.range-> B.extend
          if);
          (*'emit4 : ' -> puttext; op -> putreal; newline;*)
          (for i: 8 repeat
               %getByteAt(@@op + i - 1) -> B[top - 8 + i];
               (*B[top - 8 + i] -> puthex; newline*)
          for);
       #);
     pos: (# exit top + 1 #);
     breaks: [4] @integer; breakTop: @integer;
     setBreak:
       (# pos: @integer
       enter pos
       do (if false then
              'SetBreak: In: ' -> puttext; descInx -> putint; 
              ' at: ' -> puttext; pos -> putint; newline;
          if);
          (if (breakTop + 1 -> breakTop) > breaks.range then
              breaks.range -> breaks.extend
          if);     
          pos -> breaks[breakTop]
       #);
     isBreak: booleanValue
       (# pos: @integer
       enter pos
       do L:
            (for i: breakTop repeat
                 (if pos = breaks[i] then
                     true -> value;
                     leave L
       if)for)#);
     codes: @ByteCodes;
     patchLab: 
       (# lab,inx: @integer
       enter(lab,inx)
       do (*'Lab: ' -> puttext; lab -> putint; ' in ' -> puttext; inx -> putint; newline;*)
          lab div 256 -> B[inx - 1]; (* should be relative *)
          lab mod 256 -> B[inx] (* should be relative *)
       #);
     serialize:
       (# BI : ^ByteImage
       enter BI[]
       do procE -> BI.put2;
          allocE -> BI.put2;
          enterE -> BI.put2;
          doE -> BI.put2;
          exitE -> BI.put2;
          inner;

          top -> BI.put2;
          (for i: top repeat
               B[i] -> BI.put (* putRep?*)
          for)
       #);
     dump:     
       (# cde:
            (# T: ^text
            enter T[]
            do T[] -> out.puttext; inc;
            #);
          op1:
            (# asChar: @boolean
            enter asChar
            do (if asChar then B[inx] -> out.put else B[inx] -> out.putint if);
               inc;
            #);
          op2:
            (#
            do B[inx]*256 + B[inx+1] -> out.putint; 
               inc; inc
            #);
          op8:
            (# X: @real
            do (for i: 8 repeat
                    (*B[inx + i - 1] -> puthex; newline;*)
                    B[inx + i - 1] %putByteAt (@@X + i - 1)
               for);
               
               (*(B[inx] % sll 24) %bOR X -> X;
               (B[inx + 1] % sll 16) %bOR X -> X;
               (B[inx + 2] % sll 8) %bOR X -> X;
                B[inx + 3] %bOR X -> X;*)
               
               inx + 8 -> inx;
               X -> out.putreal
            #);
          nl: (# do out.newline #);
          inc: (# do inx+1 -> inx #);
          inx: @integer
       do (if false then
              (for i: top repeat
                   B[i] -> putint; 
              for)
           else
              1 -> inx;
              Loop: 
                (# isChar: @boolean
                do (if inx = procE  then 'procE: '  -> out.putline if);
                   (if inx = allocE then 'storeOrgAndArgsE:'  -> out.putline if);
                   (if inx = enterE then 'allocE: ' -> out.putline if);
                   (if inx = doE then 'doE: ' -> out.putline if);
                   (if inx = exitE then 'retE: ' -> out.putline if);
                   inx -> out.putint; ':' -> out.put;
                   (if B[inx]
                    // codes.pushc then
                       '\tpushc ' -> cde;
                       op1;
                       nl 
                    // codes.pushc2 then
                       '\tpushc2 ' -> cde;
                       op2; 
                       nl
                    // codes.pushNone then
                       '\tpushNone ' -> cde; nl
                    // codes.pushthis then
                       '\tpushthis ' -> cde; nl
                    //  codes.pushValId  then
                       '\tpushValId '  -> cde;  nl
                    // codes.rpush then
                       '\trpush ' -> cde;
                       op1;
                       nl
                    // codes.rpushg then
                       '\trpushg ' -> cde;
                       op1;
                       nl
                    // codes.push then
                       '\tpush ' -> cde;
                       op1;
                       nl
                    // codes.pushg then
                       '\tpushg ' -> cde;
                       op1;
                       nl
                    // codes.ovpushg then
                       '\tovpushg ' -> cde;
                       op1;
                       nl  
                    // codes.fovpushg then
                       '\tfovpushg ' -> cde;
                       op1;
                       nl      
                    // codes.ovstoreg then
                       '\tovstoreg ' -> cde;
                       op1;
                       nl  
                    // codes.fovstoreg then
                       '\tfovstoreg ' -> cde; op1; nl                         
                    // codes.xpush then
                       '\txpush ' -> cde; op1; nl
                    // codes.xrpush then
                       '\txrpush ' -> cde; op1; nl                
                    // codes.xpushg then
                       '\txpushg ' -> cde; op1; ' ' -> out.put; 
                       op1; ' ' -> out.put; op1; nl
                    // codes.xrpushg then
                       '\txrpushg ' -> cde; op1; nl  
                    // codes.pushValue then
                       '\tpushValue ' -> cde; op1; nl
                    // codes.vassign then
                       '\tvassign ' -> cde; op1; ' ' -> out.put; op1;  nl
                    // codes.rstore  then
                       '\trstore ' -> cde;
                       op1;
                       nl
                    // codes.rstoreg  then
                       '\trstoreg ' -> cde;
                       op1;
                       nl
                    // codes.store  then
                       '\tstore ' -> cde;
                       op1;
                       nl
                    // codes.storeg  then
                       '\tstoreg ' -> cde;
                       op1;
                       nl
                    // codes.xstore then
                       '\txstore ' -> cde; op1; nl
                    // codes.xrstore then
                       '\txrstore ' -> cde; op1; nl                       
                    // codes.xstoreg then
                       '\txstoreg ' -> cde; op1; ' ' -> out.put; 
                       op1; ' ' -> out.put; op1; ' ' -> out.put; nl
                    // codes.xrstoreg then
                       '\txrstoreg ' -> cde; op1; nl                       
                    // codes.double then
                       '\tdouble ' -> cde; nl
                    // codes.rdouble then
                       '\trdouble ' -> cde; nl
                    // codes.swap then
                       '\tswap ' -> cde; nl
                    // codes.rswap then
                       '\trswap ' -> cde; op1; nl                          
                    // codes.rpop then
                       '\trpop ' -> cde; nl
                    // codes.vpop then
                       '\tvpop ' -> cde; nl 
                    // codes.alloc then
                       '\talloc ' -> cde; op2; ' ' -> out.put; op1; nl
                    // codes.invoke then
                       '\tinvoke ' -> cde; op2; ' ' -> out.put; 
                       op2; ' ' -> out.put; op1; nl
                    // codes.mkVindexed then
                       '\tmkVindexed ' -> cde; op2; nl
                    // codes.mkRindexed then
                       '\tmkRindexed ' -> cde; op2; nl                       
                    // codes.restoreThis then
                       '\trestoreThis ' -> cde; nl                        
                    // codes.saveAndSetThis then
                       '\tsaveAndSetThis ' -> cde; nl
                    // codes.restoreThis then
                       '\trestoreThis ' -> cde; nl                       
                    // codes.invokeVal then
                       '\tinvokeVal ' -> cde; op2; ' ' -> out.put; op2; nl
                    // codes.boxedInvokeVal then
                       '\tboxedInvokeVal ' -> cde; op2; ' ' -> out.put; op2; nl
                    // codes.invokeExternal then
                       '\tinvokeExternal ' -> cde; op1; ' ' -> out.put; nl 
                    // codes.allocIndexed then
                       '\tallocIndexed ' -> cde; op2; ' ' -> out.put; 
                       op1; ' ' -> out.put; op1; ' ' -> out.put; nl
                    // codes.exeAlloc then
                       '\texeAlloc ' -> cde; op2; nl
                    // codes.newVrep then
                       '\tnewVrep ' -> cde; nl
                    // codes.send then
                       '\tsend ' -> cde; op1; nl
                    // codes.invokeV then
                       '\tinvokev ' -> cde; op1; ' ' -> out.put; op1; 
                       ' ' -> out.put; op1;  nl
                    // codes.rtn then
                       '\trtn ' -> cde; true -> op1; nl
                    // codes.rtnExit then
                       '\trtnExit' -> cde; nl
                    // codes.rtnInner then
                       '\trtnInner' -> cde; nl
                    // codes.rtnC then
                       '\trtnC' -> cde; nl
                    // codes.rtnV then
                       '\trtnV' -> cde; nl                       
                    // codes.mvStack then
                       '\tmvStack' -> cde; nl;
                    // codes.setThisStack then
                       '\tsetThisStack' -> cde; nl
                    // codes.rpopThisObj then
                       '\trpopThisObj' -> cde; nl                          
                    // codes.doExit then
                       '\tdoExit' -> cde; nl
                    // codes.susp then
                       '\tsusp ' -> cde; nl;
                    // codes.call then
                       '\tcall ' -> cde; true -> op1; nl;
                    // codes.innerx then
                       '\tinner ' -> cde; op1; nl
                    // codes.innerA then
                       '\tinnera ' -> cde; op1; nl
                    // codes.innerP then
                       '\tinnerP ' -> cde; op1; nl                          
                    // codes.toSuper then
                       '\ttoSuper ' -> cde; op2; nl
                    // codes.innerExit then
                       '\tinnerExit ' -> cde; op1; nl
                    // codes.doSuper then
                       '\tdoSuper ' -> cde; op2; nl
                    // codes.stop then
                       '\tstop ' -> cde; nl;
                    // codes.prim then
                       false -> isChar;
                       (if B[inx+1]
                        // 2 then
                           '\t%prim put ' -> cde 
                        // 3 then
                           '\t%prim pushIndex ' -> cde 
                        // 4 then
                           '\t%prim storeIndex ' -> cde 
                        // 5 then
                           '\t%prim range ' -> cde 
                        // 7 then
                           '\t%sendMsg ' -> cde
                        // 9 then
                           '\t%prim get ' -> cde
                        // 10 then
                           '\t%prim attach ' -> cde; op1; ' ' -> out.put; true -> isChar;
                        // 11 then
                           '\t%prim disable ' -> cde
                        // 12 then
                           '\t%prim enable ' -> cde
                        // 13 then
                           '\t%prim fork ' -> cde
                        // 14 then
                           '\t%prim cmpAndSwap ' -> cde
                        // 15 then
                           '\t%prim sleep ' -> cde
                        // 16 then
                           '\t%prim core ' -> cde
                        // 17 then
                           '\t%prim thisCore ' -> cde    
                        // 141 then
                           '\t%prim log ' -> cde
                        // 142 then
                           '\t%prim printf ' -> cde
                        // 118 then                           
                           '\t%prim asString ' -> cde;
                        else
                           '\t%prim unknown ' -> cde;
                       if);
                       isChar -> op1;
                       nl
                    // codes.jmp then
                       '\tjmp ' -> cde; op2; nl
                    // codes.jmpFalse then
                       '\tjmpFalse ' -> cde; op2; nl
                    // codes.jmpTrue then
                       '\tjmpTrue ' -> cde; op2; nl
                    // codes.jmpGT then
                       '\tjmpGT ' -> cde; op2; nl
                    // codes.pushText then
                       '\tpushText ' -> cde; op1; nl
                    // codes.eq then
                       '\teq ' -> cde; nl
                    // codes.lt then
                       '\tlt' -> cde; nl
                    // codes.le then
                       '\tle' -> cde; nl
                    // codes.gt then
                       '\tgt ' -> cde; nl
                    // codes.ge then
                       '\tge ' -> cde; nl
                    // codes.ne then
                       '\tne ' -> cde; nl
                    // codes.req then
                       '\treq ' -> cde; nl
                    // codes.plus then
                       '\t+'-> cde; nl
                    // codes.minus then
                       '\t-' -> cde; nl
                    // codes.orr then
                       '\torr' -> cde; nl
                    // codes.xorr then
                       '\txorr'-> cde; nl
                    // codes.nott then
                       '\tnott' -> cde; nl
                    // codes.mult then
                       '\t*'-> cde; nl
                    // codes.rdiv then
                       '\trdiv' -> cde; nl
                    // codes.idiv then
                       '\tidiv' -> cde; nl
                    // codes.modd then
                       '\tmodd' -> cde; nl
                    // codes.andd then
                       '\tandd' -> cde; nl
                    // codes.uminus then
                       '\tuminus'-> cde; nl
                    // codes.saveBETAworld then
                       '\tsaveBETAworld' -> cde; nl
                    // codes.saveStringOrigin then
                       '\tsaveStringOrigin' -> cde; nl
                    // codes.mkStrucRef then
                       '\tmkStrucRef' -> cde; nl
                    // codes.mkVirtualStrucRef then
                       '\tmkVirtualStrucRef ' -> cde; op1; nl
                    // codes.allocFromStrucRefObj then
                       '\tallocFromStrucRefObj' -> cde; nl
                    // codes.rtnEvent then
                       '\trtnEvent ' -> cde; op1; nl
                    // codes.rtnEventQ then
                       '\trtnEventQ ' -> cde; op1; nl    
                    // codes.doEventQ then
                       '\tdoEventQ ' -> cde; nl
                    // codes.allocEventQ then
                       '\tallocEventQ ' -> cde; op1; nl
                    // codes.break then
                       '\tbreak ' -> cde; op1; ' ' -> out.put; op2;
                       ' ' -> out.put; op2; ' ' -> out.put; op1; nl
                    // codes.tstOriginNone then
                       '\ttstOriginNone ' -> cde; nl
                    // codes.fplus then
                       '\tfplus ' -> cde; nl
                    // codes.fminus then
                       '\tfminus ' -> cde; nl
                    // codes.fmult then
                       '\tfmult ' -> cde; nl
                    // codes.fdiv then
                       '\tfdiv ' -> cde; nl
                    // codes.pushFloatConst then
                       '\tpushFloatConst ' -> cde; op8; nl
                    // codes.fpushg then
                       '\tfpushg ' -> cde; op1; nl
                    // codes.fstoreg then
                       '\tfstoreg ' -> cde; op1; nl
                    // codes.i2f then
                       '\ti2f' -> cde; nl
                    // codes.f2i then
                       '\tf2i' -> cde; nl                       
                    else
                       '\t' -> out.put;
                       B[inx] -> out.putint;
                       inc;
                       nl
                   if);
                   (if inx <= top then restart Loop if)
                #)
          if);
          out.newline
       #)
  #);

byteCodes: 
  (#
     pushThis: (# exit 1 #);
     pushc: (#exit 2 #);
     
     push: (#exit 3 #);
     rpush: (#exit 4 #);
     pushg: (# exit 5 #);
     rpushg: (# exit 6 #);
     xpush: (# exit 7 #);
     xpushg: (# exit 8 #);     
     
     store: (#exit 9 #);
     rstore: (#exit 10 #);
     storeg: (# exit 11 #);
     rstoreg: (# exit 12 #);     
     xstore: (# exit 13 #);
     xstoreg: (# exit 14#);
     
     double: (#exit 15 #);          
     rdouble: (# exit 16 #);
     
     rtn: (#exit 17 #);
     mvStack: (# exit 18 #);
     stop: (# exit 19 #);
     susp: (# exit 20 #);
     call: (# exit 21 #);
     alloc: (# exit 22 #);

     doExit: (# exit 24 #);
     rtnExit: (# exit 25 #);
     prim: (# exit 26 #);
     
     jmp: (# exit 27 #);
     jmpFalse: (# exit 28 #);
     jmpGT: (# exit 30 #);
     
     pushNone: (# exit 31 #);

     doSuper: (# exit 34 #);
     innerx: (# exit 35 #);
     rtnInner: (# exit 36 #);
     innerExit: (# exit 37 #);
     invokev: (# exit 38 #);
     send: (#exit 39 #);     
     newVrep: (# exit 40 #);
     jmpTrue: (# exit 41 #);
     pushText: (# exit 42 #);
     exeAlloc: (# exit 43 #);
     rtnc: (# exit 44 #);
     rpop: (# exit 45 #);
     vpop: (# exit 46 #);     
     eq: (#exit 50#);
     lt: (#exit 51#);
     le: (#exit 52#);
     gt: (#exit 53#);
     ge: (#exit 54#);
     ne: (#exit 55#);
     req: (#exit 56#);
     rne: (#exit 57#);
     seq: (#exit 58#);
     sne: (#exit 59#);
     
     plus: (#exit 61#);
     minus: (#exit 62#);
     
     orr: (#exit 63#);
     xorr: (#exit 64 #);
     nott: (# exit 65 #);
     
     mult: (#exit 66 #);
     rdiv: (#exit 67 #);
     idiv: (#exit 68 #);
     modd: (#exit 69#);
     andd: (#exit 70#);
     
     uminus: (# exit 71#);
     pushc2: (# exit 72#);
     allocIndexed: (# exit 73 #);
     saveBETAworld: (# exit 74 #);
     mkStrucRef: (# exit 75 #);
     mkVirtualStrucRef: (# exit 76 #);
     allocFromStrucRefObj: (# exit 77 #);
     rtnEvent: (# exit 78 #);
     break: (# exit 79 #);
     mkObjStrucRef: (# exit 80 #);
     
     xrpush: (# exit 81 #);
     xrstore: (# exit 82 #);
     xrpushg: (# exit 83 #);
     xrstoreg: (# exit 84 #);
     
     swap: (# exit 85 #);
     rswap: (# exit 86 #);
     
     (* Only for qbeta, etc *)
     setThisStack: (# exit 87 #);
     toSuper: (# exit 88 #);
     innera: (# exit 89 #);
     invoke: (# exit 90 #);
     boxedInvokeVal: (# exit 91 #);
     innerP: (# exit 92 #);
     rpopThisObj: (# exit 93 #);
     rtnEventQ: (# exit 94 #);
     doEventQ: (# exit 95 #);
     allocEventQ: (# exit 96 #);
     invokeExternal: (# exit 97 #);
     invokeVal: (# exit 98 #);
     rtnV: (#exit 99 #);
     ovpushg: (#exit 101 #);
     ovstoreg: (# exit 102 #);
     vassign: (#exit 103 #);
     saveAndSetThis: (# exit 104 #);
     restoreThis: (# exit 105 #);
     pushValue: (#exit 106 #);
     tstOriginNone: (# exit 107 #);
     saveStringOrigin: (#exit 108 #);
     fplus: (#exit 109 #);
     fminus: (#exit 110 #);
     fmult: (#exit 112 #);
     fdiv: (#exit 121 #);   
     feq: (# exit 122 #);
     flt: (# exit 123 #);
     fle: (# exit 124 #);
     fgt: (# exit 125 #);
     fge: (# exit 126 #);
     fne: (# exit 127 #);
     pushFloatConst: (# exit 113 #);
     fstoreg: (# exit 114 #);
     fpushg: (# exit 115 #);
     i2f: (# exit 116 #);
     f2i: (# exit 117 #);
     fovpushg: (# exit 118 #);
     fovstoreg: (# exit 119 #);
     mkVindexed: (# exit 128 #);
     mkRindexed: (#exit 129 #);
     pushValId: (#exit 130 #)
  #);

     
 
