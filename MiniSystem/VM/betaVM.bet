ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/basiclib/math';
INCLUDE 'objectImage';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'Primitives';
INCLUDE 'interpreterAPI'
INCLUDE '../miniServices/Service';
(*BUILD nti 'interpreter_c.obj' 'interpreter_c.c' 'betacc $0 $1'
      linux 'interpreter_c.obj' 'interpreter_c.c' '$CC -c -pthread -o $0 $1'
      default 'interpreter_c.obj' 'dummyinterpreter_c.c' '$CC -c -o $0  dummyinterpreter_c.c';*)
(*  PA&OLM: 2023-07-11:  we changed for 'nti' below:   
 *    c:/cygwin/bin/gcc -c to gcc -m32 -c
 *  to be able to compile on Windows 11 on Fusion 13 on  Mac-Silicon/Arm
 *)
BUILD nti 'interpreter_c.obj' 'interpreter_c.c' 'gcc -m32 -c -o $0 $1'
      linux 'interpreter_c.obj' 'interpreter_c.c' '$CC -c -pthread -o $0 $1'
      default 'interpreter_c.obj' 'dummyinterpreter_c.c' '$CC -c -o $0 dummyinterpreter_c.c';
---systemlib:attributes---

newVM: (#exit true #);
Run_BETA_INT: (# exit 0 #);
Run_C_INT: (# exit 1 #);
Save_BC_image: (# exit 3 #);
putBoolean: 
  (# B: @boolean 
  enter B do (if B then 'True' -> puttext else 'False'->puttext if)
  #);
intPair2Float:
  (* v1 and v2 are two 32-bit words of a 64-bit float.
   * Combine v1 and v2 to a float in fValue
   *)
  (# v1,v2: @integer; fVal: @Real
  enter(v1,v2)
  do v1 %putLongAT (@@fVal);
     v2 %putLongAt (@@fVal + 4);
  exit fVal
  #);
event: data
  (# type: @integer;
     caller,thisObj,org: @integer;
     isObj: @integer;
     descNo: @integer;
     bcPos: @integer;
  #);
Sleep: external(# milliSec: @int64 enter milliSec do CallC #);
init_interpreter: external
  (# bc,imageS,valProxDescNo: @integer; withValProx: @boolean; E: ^event
  enter(bc,imageS,withValProx,valProxDescNo)
  do callC
  exit E[]
  #);
run_interpreter: external
  (# isXB: @boolean; E: ^event
  enter isXB
  do callC
  exit  E[]
  #);
getEvent: external
  (# first: @boolean; E: ^event
  enter first
  do callC
  exit E[]
  #);
close_interpreter: external(# do callC #);

betaVM:
  (# ready: @boolean;
     mkRunTrace: (#exit false #);
     withDumps: (#exit false #);
     testConc: (# exit false #);
     valueProxyDescNo: @integer;
     noPause: @boolean;
     init:<
       (# stdPath: ^text
       enter runMode
       do (if (runMode = Run_BETA_INT) and runJavaServices then
              BetaLib -> stdPath[];
              '/MiniSystem/miniServices/' -> stdPath.append;
              ('FileService'-> (stdPath.copy).Append,5123) -> FS.init;
              ('GUIService' -> (stdPath.copy).Append,5124) -> GS.init;
              5125 -> MS.openSocket;
              '*** Java services initialized' -> putline;
          if);
	       true -> ready;
          false -> guiProgram;
       #);
     putCh:< (# ch: @char enter ch do inner #);
     getCh:< (# ch: @char do inner exit ch #);
     putTop:< 
       (# descInx,lsc: @integer; T: ^text 
       enter(descInx, lsc) 
       do &text[] ->T[];
          inner 
       exit T[] 
       #);
     (* Note! There is no common super for all VMevents
      * And there is no trace for valueEvent opEvent, etc.
      *)
     eventNest: @integer;
     verbose,traceEvents,exeTrace: @Boolean;
     VMevent: 
       (# caller,thisObj,org: ^ObjDesc.runTimeObject; 
          descNo,bcPos: @integer;
          doPause: (# do (if false then pause else suspend if)#);
          event:< (# tx: ^text do inner exit tx[] #);
          mkTrace:
            (# dump:
                 (# msg: ^text; obj: ^ObjDesc.runTimeObject
                 enter(msg[],obj[])
                 do msg[] -> T.puttext; 
                    L:
                      (if obj[]  <> none then
                          '"' -> T.put;
                          obj.myName -> T.puttext; 
                          (if obj.isObj then '/O' -> T.puttext if);
                          '"' -> T.puttext;
                          (if false then
                              ',' -> T.put;
                              obj.myOrigin -> obj[];
                              restart L
                          if)
                      if);
                 #);
               putEvent:
                 (#
                 do event -> T.puttext;
                    (* 'alloc'length = 5 *)
                    (for i: 3 - (event).length repeat ' ' -> T.put for)
                 #);
               T: @text;
            do (for i: eventNest repeat '.' -> put for);
               (if exeTrace then
                   putEvent; ':' -> T.put; thisObj.myName -> T.puttext
                else
                   'VME:' -> T.puttext; putEvent; ':' -> T.put;
                   (' clr:',caller[]) -> dump;
                   (' this:',thisObj[]) -> dump;
                   (' org:',org[]) -> dump;
                   ' BCP:' -> T.puttext; bcPos -> T.putint;
                   if);
               T.newline;
            exit T[]
            #);
          before:< object;
          after:< object;
       enter(caller[],thisObj[],org[],descNo,bcPos)
       do (if thisObj[] <> none then 
              (if traceEvents or exeTrace then
                  before;
                  (if true then
                      mkTrace -> puttext;
                   else
                      mkTrace -> out.puttext
                  if);
                  after
              if);
              inner;
              (*' descNo:'-> out.puttext; thisObj.myDescInx -> out.putint; 
               ' id:'-> out.puttext; thisObj.id -> out.putint; out.newline *)
          if)
       #);
     set:< (# do inner #); (* ad hoc *)
     scanEvent:<
       (# obj: ^ObjDesc.runTimeObject; items: [0] @integer
       enter obj[]
       do inner
       exit items
       #);
     dumpObjEvent:<
       (# obj: ^ObjDesc.runTimeObject; items: [0] @integer; 
          objKind: @integer; (* 0: plain object, 1: value array, 2: reference array *)
       enter obj[]
       do inner
       exit(items,objKind)
       #);
     startEvent:< VMevent(# event:: (# do 'start'->tx[] #) do inner #);
     allocLevel: @integer; (* Note used? *)
     allocEvent:< VMevent
       (# isObj,isIndexed: @boolean;
          event:: (# do 'alc'->tx[] #);
          before:: (# do eventNest + 1 -> eventNest #);
       enter(isObj,isIndexed) 
       do inner; 
          allocLevel + 1 -> allocLevel
       #);
     doEvent:< VMevent
       (# event:: (# do 'do'->tx[] #);
          preemptive: @boolean;
          before:: (# do eventNest + 1 -> eventNest #);
       enter preemptive
       do (*(thisCode.descInx,glsc) -> thisObj.saveReturn;*)
          inner ;
          (* thisObj.restoreReturn (* we just pop the stack *)
       #);
     doExitEvent:< VMevent
       (# event:: (# do 'doExit'->tx[] #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     rtnEvent:< VMevent
       (# event:: (# do 'rtn'->tx[] #);
          after:: (# do eventNest - 1 -> eventNest #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     rtnAllocEvent:< VMevent
       (# event:: (# do 'rtA'->tx[] #);
          after:: (# do eventNest - 1 -> eventNest #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);     
     resumeEvent:< VMevent
       (# event:: (# do 'resume' -> tx[] #);
          preemptive: @boolean;
       enter preemptive
       do inner;
       #);
     suspendEvent:< VMevent
       (# event::(#do 'suspend' -> tx[] #);
          preemptive: @boolean;
       enter preemptive
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     breakEvent:<  VMevent(# event::(#do 'break'-> tx[] #) do inner #);
     valueEvent:
       (# event:< (# tx: ^text do inner exit tx[] #);
          caller,from,to: ^ObjDesc.template; 
          popRstack: @boolean; 
          off: @integer;
          isIndexed: @boolean;
          inx,descNo,bcPos: @integer;
          doPause: (# do suspend #);
          mkTrace:<
            (# T: ^Text
            do event -> T[]; ':'->T.put;
               inner mkTrace
            exit T[]
            #);
       enter(caller[],from[],popRstack,to[],off,isIndexed,inx,descNo,bcPos)
       do (descNo,bcPos) (*(thisCode.descInx,glsc)*) -> caller.saveReturn;
          (if false then 
              (if false then
                  mkTrace -> putline
               else
                  mkTrace -> out.puttext 
          if)if);
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     pushEvent: valueEvent
       (* from: an object/activation where the value is loaded from
        * to: a stack in the form of an object
        *)
       (# 
       do inner
       #);
     vPushEvent:< pushEvent
       (# event::(#do 'vPush'-> tx[] #);
          mkTrace:: (#do value -> T.putint #);
          value: @integer
       enter value
       do inner
       #);
     rPushEvent:< pushEvent
       (# event::(#do 'rPush'-> tx[] #);
          mkTrace:: (#do '@ref' -> T.puttext #);          
          refValue: ^ObjDesc.template
       enter refValue[]
       do inner
       #);
     fPushEvent:< pushEvent
       (# event::(#do 'fPush'-> tx[] #);
          mkTrace:: (#do fValue -> T.putReal #);          
          fValue: @Real
       enter fValue
       do inner
       #);
     storeEvent: valueEvent
       (* from: a stack in the form of an object
        * to: an object/activation where the value is stored
        *)
       (# 
       do inner
       #);
     vStoreEvent:< storeEvent
       (# event::(#do 'vStore'-> tx[] #);
          mkTrace:: (#do value -> T.putint #);          
          value: @integer
       enter value
       do inner
       #);
     rStoreEvent:< storeEvent
       (# event::(#do 'rStore'-> tx[] #);
          mkTrace:: (#do '@ref' -> T.puttext #);
          refValue: ^ObjDesc.template
       enter refValue[]
       do inner
       #);
     fStoreEvent:< storeEvent
       (# event::(#do 'fStore'-> tx[] #);
          mkTrace:: (#do fValue -> T.putReal #);                    
          fValue: @integer
       enter fValue
       do inner
       #);
     opEvent:
       (# event:< (# tx: ^text do inner exit tx[] #);
          operator: ^text; to: ^ObjDesc.template; 
          descNo,bcPos: @integer
       enter(operator[],to[],descNo,bcPos)
       do (thisCode.descInx,glsc) -> to.saveReturn;
          inner;
          to.restoreReturn (* we just pop the stack *)
       #);
     iOpEvent: opEvent(# value: @integer enter value do inner #);
     
     binOpEvent:< iOpEvent(# event::(#do 'binOP'-> tx[] #) do inner #);
     unOpEvent:< iOpEvent(# event::(#do 'unOP'-> tx[] #) do inner #);
     jmpGTevent:< iOpEvent(# event::(#do 'jmpGT'-> tx[] #) do inner #);
     popEvent:< iOpEvent(# event::(#do 'pop'-> tx[] #) do inner #);
     
     fOpEvent: opEvent(# fValue: @real enter fValue do inner #);
     fBinOpEvent:< fOpEvent(# event::(#do 'binOP'-> tx[] #) do inner #);
     fUnOpEvent:< fOpEvent(# event::(#do 'unOP'-> tx[] #) do inner #);
     
     errorEvent:< 
       (# thisObj: ^ObjDesc.template; bcPos: @integer; msg: ^text
       enter(thisObj[],bcPos,msg[])
       do (thisCode.descInx,glsc) -> thisObj.saveReturn;
          inner;
          thisObj.restoreReturn (* we just pop the stack *)
       #);
     
     done:< (# do inner #);
     
     thisModule, (* not used? *)
     thisObj,
     thisStack,
     eventProcessor: ^ObjDesc.template;
     
     runJavaServices, (* Java services does not work on Linux, so we don't start then *)
     isValObj : @boolean; (* executing a value object *)
     
     thisValObjDesc: ^ObjDesc;
     thisValObjDescInx: @integer;
     
     runMode: @integer;
     
     guiProgram: @boolean;
     
     thisCode: ^ByteCode; 
     
     glsc: @integer;
     
     codes: @ ByteCodes;
     
     prim: @Primitives;
     
     stopErrors: ^text;
     
     fatalError:
       (# errNo: @integer; M: @text; T: ^Text
       enter errNo
       do 
          errNo -> thisObj.fatalError
          (#
          do (if (runMode = run_BETA_INT) and runJavaServices then 
                 closeJavaServices 
             if);
             (thisObj.myDescInx,glsc) -> putTop -> msg.puttext;
             '!!   Before bytecode at LSC: ' -> msg.puttext; 
             glsc -> msg.putint;
             inner fatalError;
             M[] -> msg.puttext
          #) 
            (*-> stopErrors[]*)
            -> putline;
          (thisObj[],glsc,stopErrors[]) -> errorEvent;
       #);
     
     closeJavaServices:
       (#
       do (if not guiProgram then
              (if FS.trace then '\nFS.close'->putline if);
              FS.close; 
              (if MS.trace then 'MS.close'->putline if);
              false ->  MS.close;
              (if GS.trace then 'GS.close'->putline if);
              GS.close;
              mouseListener[] -> kill;
              '\n\n*** Closed all Java services ' -> putline;
          if);
       #);
     
     out: ^Stream;
     
     FS,GS,MS: @Service;
     mouseListener:  @ | system
       (# T: ^text
       do (if MS.trace or true then 
              (*  'Starting mouseListener:'->putline *)
          if);
          cycle
          (# event,noOfClicks,handle: @integer
          do MS.receive -> T[];
             (*'mouseListener: ' -> puttext; T[] -> putline;*)
             T.setPos;
             T.getInt -> handle;
             T.getint -> event;             
             (if GS.trace then
                 'BETA:event:handle: ' -> puttext; handle -> putint;
                 (if event
                  // 1 then
                     ' mouseClicked:'->puttext;
                     T.getint -> noOfClicks -> putint;                
                  // 2 then
                     'BETA:Mouse exited' -> putline
             if)if);

             T[] -> execute.selectEventProcessor;
             (* store handle/object in 1 -> thisStack.rstore *)
             execute[] -> fork;
             pause;
             (* 'mouseListener reactivated'->putline*)
          #);
          
          (if MS.trace or true then 'BETA:mouse: ' -> puttext; T[] -> putline if);
       #);
     
     reActivate: (# do (if true then execute else execute[] -> fork if) #);
     
     execute: @ | system
       (# saveBCimage:
            (* Saves the byte code image on file FN..bc with execution *)
            (# mainDescInx: @integer; FN: ^text
            enter(mainDescInx,FN[])
            do (mainDescInx,(FN[],'..bc') -> mkAuxName) -> descs.serialize;
            #);
          init:
            (# RTT: @File;
            enter(descs[],descInx,FN[],runMode)
            do (if (runMode = run_BETA_INT) and runJavaServices then 
                   mouseListener[] -> fork 
               if);
               (if runMode <> save_BC_Image then
                   (FN[],'..run') -> mkAuxName -> RTT.name;
                   RTT.openWrite;
                   RTT[] -> out[];
               if);
               verbose -> descs.objPool.verbose;
               pause;                
            #);
          selectEventProcessor:
            (# eventSpec: ^text; D: ^objDesc
            enter eventSpec[]
            do eventProcessor[] -> thisModule[] -> thisObj[] -> thisStack[];
               thisObj.myObjDesc -> D[];
               (* '\n===='->putline;
                (thisObj.myObjDesc).literals[1] -> putint; newline;
                eventSpec.length -> putint; newline;
                (eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min -> putint; 
                * newline;
                (for i: D.literals[1] repeat 
                (thisObj.myObjDesc).literals[1+i] -> put; ' ' -> put
                for); newline;*)
               
               (if eventSpec.length > (thisObj.myObjDesc).literals[1] then 
                   '\n\n**** eventSpec too large: "'->puttext;
                   eventSpec[] -> puttext; '"' -> put
               if);

               (for i:((eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min) repeat
                    i -> eventSpec.inxGet -> (thisObj.myObjDesc).literals[1 + i];
                    (* '<'->put;  i -> eventSpec.inxGet -> put; '>'->put;
                     (thisObj.myObjDesc).literals[1 + i] -> put*)
               for);

               descs.OD[descInx + 1 ].bc[] -> thisCode[];
               thisObj[] -> descs.ObjPool;
               descInx -> thisObj.myDescInx;
               true -> handleEvent;
               1 -> gLsc;
            #);               
          decodeEvent:
            (# E: ^event; T: @text; obj: ^objDesc.cTemplate;
               caller,thisObj,org: ^objDesc.cTemplate;
            enter E[]
            do (if E[] <> none then
                   (* ','->put; E.caller -> putint; ','->put;*)
                   (if (1 <= E.type) and (E.type < 18) then 
                       E.caller -> descs.cObjCache.get -> caller[];
                       E.thisObj -> descs.cObjCache.get -> thisObj[];
                       E.org -> descs.cObjCache.get -> org[];
                    else
                       (if (E.type = 19) then (* can probably be handled by 
                                               * code before else *)
                           E.caller -> descs.cObjCache.get -> caller[];
                       if)
                   if);
                   caller[] -> obj[];
                   (* 'cObj: ' -> puttext; 
                    loop:
                    (if obj[]<> none then 
                    obj.myName -> puttext; ' ' -> put;
                    obj.objId -> putint;
                    obj.myOrigin -> obj[];
                    restart loop
                    if);
                    newline;*)
                   (if E.type 
                    // 0 then (*skip*)
                    // 1 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> startEvent
                    // 2 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1,E.isObj=1,false) -> allocEvent
                    // 3 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1,false) -> doEvent
                    // 4 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> doExitEvent
                    // 5 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> rtnEvent
                    // 18 then (* stop *)
                    // 19 then
                       '\n*** Got scan_event'->putline;
                       (caller[]) -> scanEvent
                    else
                       '\n\n*** Event not catched: ' -> puttext;
                       E.type -> putint; newline;
                       stop
                   if);
               if);
               (*newline*)
            exit E.type  <> 18
            #);
          handleEvent: @boolean;
          descs: ^RuntimeDescriptors;
          descInx: @integer;
          isObj: @integer;;
          obj: ^ObjDesc.Template;
          root: ^ObjDesc.Template;
          world: ^ObjDesc.Template;
          stringOrigin: ^ObjDesc.Template;
          betaenvObj: ^ObjDesc.Template;
          
          break:
            (# descNo,bcPos: @integer
            enter(descNo,bcPos)
            do (if false then
                   'betaVM:breakIn: ' -> puttext; descNo -> putint; 
                   ' at: ' -> puttext; bcPos -> putint; newline;
                   (*'OD.range: ' -> puttext; descs.OD.range->putint; newline;*)
               if);               
               (if descs[] = none then ' break:descs i none???'->putline;if);
               (if descs.OD[descNo][] = none then
                   'break:bc none ' -> putline
                else 
                   bcPos -> descs.OD[descNo].bc.setBreak
               if)
            #);
          
          sendMsg:
            (# serverId,handle,msgId: @integer; msg: ^objDesc.template; 
               T: @text
            enter(serverId,handle,msgId,msg[])
            do (if FS.trace then
                   'SendMsg: serverId=' -> puttext; serverId->putint; 
                   ' handle=' -> puttext; handle -> putint; 
                   ' msgId='-> puttext; msgId -> putint; ' vields[1]=' -> puttext; 
                   msg.fields[1] -> putint;
               if);
               (for i: msg.fields[1] repeat
                    msg.fields[i+2] -> T.put; 
               for);
               (if FS.trace then
                   ' msg="'->puttext; T[] -> puttext;  '"'->put; newline;
               if);
               (if serverId
                // 1 then
                   (handle,msgId,T[]) -> sendFileMsg
                // 2 then
                   (handle,msgId,T[]) -> sendGuiMsg
               if)
            #);
          doReceive: (# exit true #);
          sendFileMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if FS.trace then 'sendFileMsg: '-> puttext; if);
               (if msgId
                // 1 then 
                   1 -> FS.mkCommand(#do msg[] -> cmd.puttext #);
                   (if doReceive then
                       FS.receive -> h[];
                       (1,h.length-1) -> h.sub -> h[];
                       0 -> h.setpos; h.getint -> thisStack.vPush
                    else
                       1 -> thisStack.vpush
                   if)
                // 2 then
                   2 -> FS.mkCommand(#do handle -> cmd.putint; ' '  -> cmd.put;
                                       msg[] -> cmd.puttext
                                    #);
                   (if doReceive then FS.receive -> h[] if)
                // 3 then
                   3 -> FS.mkCommand(# do handle -> cmd.putint; #);
                   (if doReceive then FS.receive -> h[] if)
               if);
            #);
          sendGuiMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if GS.trace then
                   'sendGuiMsg: '-> puttext; msgId->putint; ' ' -> put;
                   '"' -> put;  msg[] -> puttext; '"' -> put; newline;
               if);
               (if not guiProgram then
                   '**** GUI program' -> putline;
                   true -> guiProgram; 
               if);
               (if msgId
                // 1 then
                   1->GS.mkCommand(# do msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (if GS.trace then 'BETA:received: ' -> puttext; h[] -> putline; if);
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush;
                // 2 // 5 // 6 then
                   msgId ->GS.mkCommand(# do handle -> cmd.putint; 
                                          ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                   
                // 3 then
                   3->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 4 // 7 // 8 // 10 then
                   msgId -> GS.mkCommand
                   (# do handle -> cmd.putint; ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 9 then
                   msgId -> GS.mkCommand(# do handle -> cmd.putint; 
                                           ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];  
                   h.length 
                     -> mkTextObject(# i: @integer do i + 1 -> i -> h.inxGet -> ch #);
                   (* -> thisStack.rpush;*)
               if);
               (if GS.trace then
                   'betaVM:received: ' -> puttext; h[] -> putline;
               if)
            #);
          mkTextObject:
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do (*'\nmkTextObject:length: ' -> puttext; length -> putint; newline;*)
               (if descs.OD[descs.textDescNo][] = none then
                   'descs.OD[descs.textDescNo][] = none'->putline
               if);
               (1,length + 1 + 100,3,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               X[] -> descs.ObjPool;
               descs.textDescNo -> X.myDescInx;
               true -> X.isObj;
               (if world[] = none then
                   '\n!!! betaVM:mkTextObject: world[] = none '->putline
               if);
               (if (3 -> world.rget) = none then
                   '\n!!! betaVM:mkTextObject: (3 -> world.rget) = none'->putline
               if);
               (if true then
                   (1,stringOrigin[]) -> X.rput
                else
                   (1,(3 -> world.rget)) -> X.rput;
                   (* seems to be a hack 
                    * 3 = LIB = origin
                    *)
               if);
               length -> X.fields[2]; (* pos *)
               length + 100 -> X.fields[3]; (* range *)

               (for i: length  repeat
                    inner;
                    ch -> X.fields[i + 3];
               for);  
               (*('mkTextObject',true,screen[]) -> X.dump*)
            exit X[]
            #);
          QallocTextObject:
            (* Layout for text object: "abc..."
             * fields[0] =
             * fields[1] = origin
             * fields[2] = rangee
             * fields[3] = size
             * fields[4} = 'a'
             * fields[5] = ...
             *)
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do (if mkRunTrace then 
                  'QallocTextObject:length:' -> out.puttext; length -> out.putint; 
                  ' textDescNo: ' -> out.puttext; descs.textDescNo -> out.putint;
               if);
               (if descs.OD[descs.textDescNo][] = none then
                   'descs.OD[descs.textDescNo][] = none'->putline
               if);
               (* perhaps use QallocIndex as in interpreter_c.c *)
               (1,length,arrayStrucSize,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               1 -> X.fields[arrayStrucSize];
               (if withDumps then ('QallocTextObject:I',true,out[]) -> X.dump if);
               X[] -> descs.ObjPool;
               (if verbose then length + descs.objPool.size -> descs.objPool. size if);
               descs.textDescNo -> X.myDescInx;
               true -> X.isObj;
               descs.OD[descs.textDescNo].OSDvisibility -> X.OSDvisibility;
               (if world[] = none then
                   '\n!!! betaVM:QallocTextObject: world[] = none '->putline
               if);
               (if false and ((3 -> world.rget) = none) then
                   '\n!!! betaVM:QallocTextObject: (3 -> world.rget) = none '
                     -> putline
               if);
               (if true then
                   (1,stringOrigin[]) -> X.rput
                else
                   (1, (3 -> world.rget)) -> X.rput;
               if);
               (* seems to be a hack 
                * 3 = LIB = origin *)
               length -> X.fields[arrayStrucSize - 1]; 
               1  ->  X.fields[arrayStrucSize]; (* size = 1 *)
               (*length + 100 -> X.fields[2];  range *)
               (for i: length  repeat 
                    inner;
                    ch -> X.fields[arrayStrucSize + i];
               for);
               (if withDumps then ('QallocTextObject:S',true,out[]) -> X.dump if)
            exit X[]
            #);    
          ConvertIndexedToString:
            (# X,Y: ^ObjDesc.template; length: @integer
            do thisStack.rpop -> X[];
               X.fields[2] -> length;
               (* arrayStrucSize = 3
                * X.fields[0] = origin
                * X.fields[1] = length = range
                * X.fields[2] = size
                * X.fields[3] = indexed[1]
                * ...
                * X.fields[length + 3] = indexed[length]
                *)
                (if withDumps then ('ConvertIndexedToString',true,out[]) -> X.dump if);

               (*(for i: X.fields.range repeat
                    X.fields[i] -> putint; ' '->put
               for);
               newline;*)
               L:
                 cycle
                 (#
                 do (if X.fields[arrayStrucSize + length] = 0 then 
                        length - 1 -> length
                     else
                        leave L
                 if)#);
               (if true then
                   (* should perhpas use allocTemplateï¿½?*)
                   (1,length,arrayStrucSize,0) 
                     -> descs.OD[descs.textDescNo].template 
                     -> Y[] 
                     -> thisStack.rpush;
                   Y[] -> descs.objPool
                else
                   (1,length+1,1,0) 
                     -> descs.OD[descs.textDescNo].template 
                     -> Y[] 
                     -> thisStack.rpush;
               if);
               (if true then
                   (1,stringOrigin[]) -> Y.rput
                else                   
                   (1,(3 -> world.rget)) -> Y.rput(* origin - hack *);
               if);
               (*Y.fields.range -> putint; newline;*)
               (for i: length repeat
                    X.fields[arrayStrucSize + i] -> Y.fields[arrayStrucSize + i]
               for);
                (if withDumps then ('String',true,out[]) -> Y.dump if);
            #);
          
          mkStrucRefObj:
            (# origin,X: ^ObjDesc.template; 
               inx: @integer;
               isVirtual: @boolean
            enter(origin[],inx,isVirtual)
            do (* the generation below is clumsy
                * currently template is made for textDesc
                * clean-up
                *)
               (*  ('mkStrucRefObj:origin',true,screen[]) -> origin.dump;
                'strucrefDescNo:'->puttext; 
                descs.structureRefDescNo -> putint; newline;
                *)
               (1,0,1,0) -> descs.OD[descs.structureRefDescNo].template -> X[];
               descs.structureRefDescNo -> X.myDescInx;
               X[] -> descs.ObjPool;
               (if isVirtual then
                   (origin.myObjDesc).vdtTable[inx] -> inx
               if);
               inx -> X.fields[1];
               (2,origin[]) -> X.rput;
               (*('StrucRefObj',true,screen[]) -> X.dump;*)
               X[] -> thisStack.rpush;
            #);
          
          StacksToOut:
            (# msg:  ^Text
            enter msg[]
            do out.newline;
               (if msg[] <> none then
                   '   **** ' -> out.puttext; msg[] -> out.puttext;
                   ':'->out.put; out.newline
               if);                         
               '   thisObj   = ' -> out.puttext; 
               thisObj.myNameDI -> out.puttext;
               out[] -> thisObj.dumpStacks;
               '\n   thisStack' -> out.puttext; 
               (if thisObj[] = thisStack[] then 
                   ' = thisObj'->out.putline
                else
                   '!= '->out.puttext;
                   thisStack.myNameDI -> out.puttext;
                   out[] -> thisStack.dumpStacks;
            if)#);
          allocTemplate:
            (# descNo,vInxSize,rInxSize: @integer; isObj: @boolean;
               obj: ^objDesc.template
            enter(descNo,isObj,vInxSize,rInxSize)
            do &descs.OD[descNo].template[] -> obj[];
               descs.OD[descNo].objSize  -> obj.fields.new;
               descNo -> obj.myDescInx;
               obj[] -> descs.ObjPool;
               isObj -> obj.isObj;
               descs.OD[descNo].OSDvisibility -> obj.OSDvisibility; 
               (if false then
                   '**** allocTemplate: '->puttext; obj.myNameDI -> puttext;
                   ' visibility:' -> puttext;
                   obj.OSDvisibility -> putint; newline
               if)
            exit obj[]
            #);
          allocValueProxyTemplate:
            (# descNo,vInxSize,rInxSize: @integer; isObj: @boolean;
               obj: ^objDesc.template
            enter(descNo,isObj,vInxSize,rInxSize)
            do (if withDumps then
                   '**** allocValueProxyTemplate:'->out.puttext;
                   descNo->out.putint; 
                   ' '->out.put; vInxSize -> out.putint; ' ' ->out.put;
                   rInxSize -> out.putint; ' ' ->out.put;
               if);
               &descs.OD[descNo].template[] -> obj[];
               descs.OD[valueProxyDescNo].objSize  -> obj.fields.new;
               descNo -> obj.myDescInx;
               obj[] -> descs.ObjPool;
               isObj -> obj.isObj;
               descs.OD[descNo].OSDvisibility -> obj.OSDvisibility; 
               (if withDumps then
                   '**** allocValueProxyTemplate: '->out.puttext; 
                   obj.myNameDI -> out.puttext; ' visibility:'->out.puttext;
                   obj.OSDvisibility -> out.putint; out.newline
               if)
            exit obj[]
            #);
          alloc:
            (# origin,callee,Y: ^objDesc.template; descNo: @integer; 
               isObj: @boolean
            enter(origin[],descNo,isObj)
            do (*'   Alloc: ' -> out.puttext; descNo->out.putint; out.newline;*)
               (if withDumps then 'alloc:before:'->stacksToOut; if);
               (descNo,isObj,0,0) -> allocTemplate -> callee[];
               (if mkRunTrace then '\n   Alloc:callee:'->out.puttext; callee.myNameDI -> out.putline if); 
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descNo].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> thisStack[] -> thisObj[];
               (if withDumps then 'alloc:end:'->stacksToOut; if);
               (if origin[] = root[] then
                   (* Perhaps just handled by saveBETAworld? *)
                   callee[] -> world[];
               if);
               (Y[],thisObj[],origin[],descNo,glsc,isObj,false) -> allocEvent;
            exit callee[]
            #);
          invokeVal:
            (# descNo,staticOff,isValueObj: @integer; 
               callee,Y: ^objDesc.template;
            enter(descNo,staticOff,isValueObj)
            do (if false and (isValueObj = 1) then
                   '\n*** invokeVal:descNo: ' -> puttext; descNo -> putint;
                   ' ' -> put; descs.OD[descNo].myId -> putline;
               if);
                (if withDumps then 
                    ('thisObj',true,out[]) -> thisObj.dump;
                    ('thisStack',true,out[]) -> thisStack.dump
                if);
                   (descNo,false,0,0) 
                     -> allocValueProxyTemplate 
                     -> callee[];
                   (1,none) -> callee.rput; (* no origin *)

                   (if isValueObj = 1 then
                       (4 -> thisObj.get) -> callee.myDescInx;
                       (2,2 -> thisObj.get) -> callee.put; (* holder *)
                       (3,staticOff + (3 -> thisObj.get)) -> callee.Put;
                       (4,descNo) -> callee.put;
                    else
                       descNo -> callee.myDescInx;
                       (2,thisObj[]) -> callee.rput; (* holder *)
                       (3,staticOff) -> callee.Put;
                       (4,descNo) -> callee.put;
                   if);
                (if withDumps then 
                   ('ValueProxy',true,out[]) -> callee.dump;
                   ('holder',true,out[]) -> thisObj.dump;
               if);
                   (thisCode.descInx,glsc) -> thisObj.saveReturn;
                   descs.OD[descNo].bc[] -> thisCode[];
                   thisObj[] -> Y[] -> callee.rPush; (* return *)
                   thisStack[] -> callee.rPush;
                   descs.OD[descNo].BC.allocE -> glsc;
                   callee[] -> thisObj[];
                (if withDumps then 
                   ('thisObj',true,out[]) -> thisObj.dump;
                   ('thisStack',true,out[]) -> thisStack.dump;
               if)
                   (*isObj -> asObjEnabled;*)
            #);
          mkValueProxy:
            (# descNo,off,isValueObj,originIsValueObj,size: @integer;
               origin,holder,valueProxy,Z: ^objDesc.template;
            enter(descNo,off,isValueObj,originIsValueObj)
            do  (if withDumps then  ('thisObj',true,out[]) -> thisObj.dump if);
               thisStack.rPop->origin[]; 
               thisStack.rPop->holder[];
               (if off = 65535 then
                   thisStack.vPop -> off;
                   (if mkRunTrace then '>>  arrayInx:'->out.puttext; off -> out.putint if); 
                   arrayStrucSize -> holder.get -> size; 
                   (if mkRunTrace then ' size:' -> out.puttext; size -> out.putint if) ; 
                   arrayStrucSize +(off - 1) * size -> off; 
                   (if mkRunTrace then ' holderOff:'->out.puttext; off->out.putint; out.newline if)
               if);
               (if withDumps then
                   (if isValueObj = 1 then
                       '\n**** mkValueProxy:valueProxyDescNo: ' -> puttext;
                       valueProxyDescNo -> putint;
                       ' descNo:'->puttext; descNo -> putint;
                       ' off: ' -> puttext; off -> putint; newline;
                   if);
                   ('thisObj',true,out[]) -> thisObj.dump;
                   ('thisStack',true,out[]) -> thisStack.dump;
               if);
               (descNo,false,0,0) -> allocValueProxyTemplate -> valueProxy[];

               (if originIsValueObj = 1 then
                   (if mkRunTrace then 'originIsValueObj:'->out.puttext if);
                   1 -> thisObj.rget -> Z[]; (* assuming orginOff = 1 *)
                   (if withDumps then ('thisObj.origin',true,out[]) -> Z.dump if);
                   (1,origin[]) -> valueProxy.rput; (* is origin ok here? *)
                   (2,2 -> Z.rget) -> valueProxy.rput;
                   (3,(3 -> Z.get) + off) -> valueProxy.Put;
                   (4,descNo) -> valueProxy.put;
                else
                   (1,origin[]) -> valueProxy.rput;
                   (2,holder[]) -> valueProxy.rput;
                   (3, off) -> valueProxy.Put;
                   (4,descNo) -> valueProxy.put;
               if);
               valueProxy[] -> thisStack.rPush;
               (if withDumps then
                   ('ValueProxy',true,out[]) -> valueProxy.dump;
                   (if origin[] <> none then
                       ('ValueOrigin',true,out[]) -> origin.dump;
                   if);
                   (if holder[] <> none then
                       ('Holder',true,out[]) -> holder.dump;
                   if);
                   (if false then
                       ('thisObj',true,out[]) -> thisObj.dump;
                       ('thisStack',true,out[]) -> thisStack.dump;
                   if)
               if);
               (*valueProxy[] -> lastProxy[]; holder[] -> lastHolder[]*)
            #);
          lastProxy,lastHolder: ^objDesc.template;
          returnValue:
            (# staticOff: @integer
            do none -> thisValObjDesc[];
               false -> isValObj;
               thisObj.lscPop -> staticOff;
               thisObj.restoreReturn -> (descInx,glsc); 
               descs.OD[descInx].bc[] -> thisCode[];  
               thisObj.valOff - staticOff -> thisObj.valOff;
               ('ValueObject:',true,out[]) -> thisObj.dump;
            #);
          invoke:
            (# callee,Y: ^objDesc.template; descNo,staticOff: @integer; 
               IsObj: @boolean
            enter(descNo,staticOff,IsObj)
            do (*'Invoke:descNo: ' -> puttext; descNo -> putint; newline;*)
               (descNo,IsObj,0,0) -> allocTemplate -> callee[];
               (if mkRunTrace then callee.myNameDI -> out.puttext if); 
               (if staticOff > 0 then
                   (staticOff,callee[]) -> thisObj.rput
               if);
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               descs.OD[descNo].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               (*origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> thisObj[];
               (* OBS! We may need origin for minienv!
                * And perhaps the same for isObj
                *)
               (*(Y[],thisObj[],(*origin[],* )none,descNo,glsc,asObj,false) 
                                 -> allocEvent;*)
               isObj -> asObjEnabled;
               (if mkRunTrace then  
                   'isValObj: ' -> out.puttext; 
                   (if isValObj then 1 -> out.putint else 0 -> out.putint if);
                   out.newline;
               if);
               false -> isValObj;
            #);
          QallocIndexed:
            (* alloc Indexed object of size arrayStrucSize + rangee *)
            (# callee,Y: ^objDesc.template;
               origin: ^objDesc.template;
               descInx,size,rangee,isRindexed: @integer
            enter(origin[],descInx,size,rangee,isRindexed)
            do (size,rangee,arrayStrucSize,isRindexed) 
                 -> descs.OD[descInx].template 
                 -> callee[];
               (if mkRunTrace then 
                   'QallocIndexed: '->out.puttext; descInx -> out.putint; 
                   ' size:'->out.puttext; size->out.putint;
                   ' range:'-> out.puttext; rangee->out.putint;
                   ' isRindexed:'->out.puttext; isRindexed-> out.putint; 
                   out.newline;
               if);
               descs.OD[descInx].OSDvisibility -> callee.OSDvisibility;
               descInx -> callee.myDescInx;
               callee[] -> descs.ObjPool;
               callee[] -> thisStack.rPush;
               (if withDumps then ('QallocIndexed:',true,out[]) -> callee.dump if);
            exit callee[]
            #);
          mkIndexed:
            (# descInx: @integer;
               isRef: @Boolean; 
               length,V,size,isRindexed: @integer; 
               X,R: ^objDesc.template;
               trace: (# exit false #);
            enter(descInx,isRef)
            do thisStack.vpop -> length;
               (if trace then
                   '\nmkIndexed: ' -> out.puttext; 
                   (if isRef then ' isRef:' -> out.puttext if);
                   ' length: ' -> out.puttext; length -> out.putint;
               if);
               (if isRef then 1 -> isRindexed if);
               
               1 -> size; (* probably size of elements???*)
               
               (X[],descInx,size,length,isRindexed) 
                 -> QallocIndexed -> X[];
               
               (if trace then  ' elem: ' -> out.puttext; if);
               (if isRef then
                   thisStack.rpop; (* X is pushed by QallocIndexed *)
                   (for i: length repeat
                        thisStack.rpop -> R[];
                        (if trace then 
                            ('mkIndex:ref:',true,out[]) ->R.dump;
                            ('mkIndex:ref:',true,screen[]) ->R.dump;
                        if);
                        R.id -> X.fields[1 + length - i + arrayStrucSize];
                   for);
                   X[] -> thisStack.rpush
                else
                   (for i: length repeat
                        thisStack.vpop -> V;
                        (if trace then V -> out.putint; ' ' -> out.put if);
                        V -> X.fields[1 + length - i + arrayStrucSize];
               for)if);
               (if trace then out.newline if)
            #);
          asObjEnabled: @boolean;
          
          allocFromStrucRefObj:
            (# X: ^objDesc.template
            enter X[]
            do (*('AllocFromStrucRefObj',true,screen[]) -> X.dump;*)
               (* We need to handle isObj *)
               (2 -> X.rget,X.fields[1],true) -> alloc
            #);
          doBreak: 
            (# on,lab,actualDescInx
               ,nOfS  (* no of superpatterns of obj being returned to *)
               ,pn: @integer; (* no of super patterns for actualDescInx 
                               * not used - and probably never to be used 
                               *)
               descInx,xlsc,V,sAdj: @integer; 
               X,Y: ^objDesc.template;
               newPopRtn: (# exit true #);
               trace: (# exit false #)
            enter(on,lab,actualDescInx,pn)
            do (if trace then (out[],'\n   Break:FROM:obj = ') -> thisObj.dumpObj if);
               thisObj[] -> X[];               
               (for i: on repeat X.myOrigin -> X[] for);
               (if trace then (out[],'   break:TO  = ') -> X.dumpobj if);
               (* We need to test for none if the stack does not contain X
                * Same  for traversing super
                *)
               popCallStack:
                 (if thisObj[] <> X[] then 
                     thisObj[] -> Y[];
                     (if newPopRtn then
                         thisObj.return -> (thisStack[],thisObj[])
                      else
                         thisObj.rpop -> thisStack[];
                         thisObj.rpop -> thisObj[];
                     if);
                     (if trace then 
                         (out[],'pop:obj   = ') -> thisObj.dumpObj;
                         (out[],'pop:stack = ') -> thisStack.dumpObj;
                     if);
                     (thisObj[],Y[],Y.myOrigin,0,0) -> rtnEvent;
                     restart popCallStack
                 if);
               (if trace then
                   (out[],'dest:obj  = ') -> thisObj.dumpObj;
                   (out[],'dest:stack= ') -> thisStack.dumpObj;
               if);
               thisObj[] -> thisStack[];
               thisObj.restoreReturn -> (descInx,xlsc);
               (if trace then
                   '   dest:descInx:'->out.puttext; 
                   descInx->out.putint;
                   ' dest:super:actualDescInx:' -> out.puttext;
                   actualDescInx -> out.putint;
                   ' xlsc(not to be used):' -> out.puttext; 
                   xlsc->out.putint; out.newline
               if);
               (if false and (pn > 0) then 
                   '**** break:Before:goSuper:pn=' -> out.puttext; 
                   pn -> out.putint;
                   ' rtop=' -> out.puttext; thisObj.rtop -> out.putint;
                   (out[],'Break:before:goSuper: ') -> thisObj.dumpObj;
               if);
               (if (actualDescInx > 0)
                   and (descInx <> actualDescInx) then 
                   findActualSuper:
                     (if descInx <> actualDescInx then 
                         (* break to a ptn level in super chain *)
                         thisObj.restoreReturn -> (descInx,glsc);
                         thisObj.rpop -> thisObj[];
                         (if trace then 
                             'Find:Super:descInx: ' -> out.puttext;
                             descInx -> out.putint; 
                             ' glsc: ' -> out.puttext; 
                             glsc->out.putint; out.newline;
                             (out[],'   obj:') -> thisObj.dumpObj;
                         if);
                         sAdj + 1 -> sAdj;
                         restart findActualSuper
               if)if);
               (if false and (pn > 0) then 
                   '**** break:after:goSuper:pn=' -> out.puttext; 
                   pn -> out.putint;
                   ' rtop: ' -> out.puttext; thisObj.rtop -> out.putint;
                   (out[],'Break:after:goSuper: ') -> thisObj.dumpObj;
               if);         
               descs.OD[descInx].noOfSuper -> nOfS;
               (if trace then
                   '   noOfSuper: ' -> out.puttext;
                   nOfS -> out.putint;
                   ' rtop: ' -> out.puttext; thisObj.rtop -> out.putint;
                   out.newline;
               if);
               (if newPopRtn and (descs.OD[descInx].noOfSuper = 0) then 
                   2 -> thisObj.rtop 
                else
                   (if (nOfS > 0) then
                       (if (thisObj.rtop) <> (nOfS + 2) then
                           '\n!!!! WARNING: break to object with '
                           'references on the rstack oether than '
                           'return references' -> putline
               if)if)if);
               (if trace then 
                  ' range:'->out.puttext; descs.OD[descInx].labs.range->out.putint; out.newline;
               if);
               descs.OD[descInx].bc[] -> thisCode[];
               descs.OD[descInx].labs[lab] -> glsc;
               (if trace then
                   '   ContinueAt: ' -> out.puttext; 
                   descs.OD[descInx].myId -> out.puttext;
                   ' glsc: ' -> out.puttext; glsc->out.putint; out.newline
               if)
            #);
            
          doBreakX:
            (# on,lab,actualDescInx
               ,nOfS  (* no of superpatterns of obj being returned to *)
               ,pn: @integer; (* no of super patterns for actualDescInx 
                               * not used - and probably never to be used 
                               *)
               descInx,xlsc,V,sAdj: @integer; 
               X,Y: ^objDesc.template;
               newPopRtn: (# exit true #);
               trace: (# exit false #)
            enter(on,lab,actualDescInx,pn)
            do (if trace then
                   '\nBREAK:to: ' -> out.puttext; 
                   descs.OD[actualDescInx].myId -> out.puttext;
                   ' on: ' -> out.puttext; on -> out.putint;
                   ' pn: ' -> out.puttext; pn -> out.putint;
                   ' lab: '->out.puttext; lab -> out.putint; 
                   ' from: ' -> out.putline;
                   (out[],'   thisObj   = ') -> thisObj.dumpObjFull;
                   (out[],'   thisStack = ') -> thisStack.dumpObjFull;
               if);
               thisObj[] -> X[];
               (for i: on repeat X.myOrigin -> X[] for);
               (if trace then (out[],'   go:ON: ') -> X.dumpobj if);
               (* We need to test for none if the stack does not contain X
                * Same  for traversing super
                *)
               popCallStack:
                 (if thisObj[] <> X[] then 
                     thisObj[] -> Y[];
                     (if newPopRtn then
                         thisObj.return -> (thisStack[],thisObj[])
                      else
                         thisObj.rpop -> thisStack[];
                         thisObj.rpop -> thisObj[];
                     if);
                     (if trace then 
                         (out[],'pop:obj   = ') -> thisObj.dumpObj;
                         (out[],'pop:stack = ') -> thisStack.dumpObj;
                     if);
                     (thisObj[],Y[],Y.myOrigin,0,0) -> rtnEvent;
                     restart popCallStack
                 if);
               (if trace then
                   (out[],'Dest:obj: ') -> thisObj.dumpObj;
                   (out[],'Dest:stack: ') -> thisStack.dumpObj;
               if);
               thisObj[] -> thisStack[];

               thisObj.restoreReturn -> (descInx,xlsc);
               (if trace then
                   'Dest:descInx: '->out.puttext; 
                   descInx->out.putint;
                   ' dest:super:actualDescInx: ' -> out.puttext;
                   actualDescInx -> out.putint;
                   ' xlsc(not to be used): ' -> out.puttext; 
                   xlsc->out.putint; out.newline
               if);
               (if false and (pn > 0) then 
                   '**** break:Before:goSuper:pn=' -> out.puttext; 
                   pn -> out.putint;
                   ' rtop=' -> out.puttext; thisObj.rtop -> out.putint;
                   (out[],'Break:before:goSuper: ') -> thisObj.dumpObj;
               if);
               (if (descInx <> actualDescInx) then 
                   findActualSuper:
                     (if descInx <> actualDescInx then 
                         (* break to a ptn level in super chain *)
                         thisObj.restoreReturn -> (descInx,glsc);
                         thisObj.rpop -> thisObj[];
                         (if trace then 
                             'Find:Super:descInx: ' -> out.puttext;
                             descInx -> out.putint; 
                             ' glsc: ' -> out.puttext; 
                             glsc->out.putint; out.newline;
                             (out[],'   obj:') -> thisObj.dumpObj;
                         if);
                         sAdj + 1 -> sAdj;
                         restart findActualSuper
               if)if);
               (if false and (pn > 0) then 
                   '**** break:after:goSuper:pn=' -> out.puttext; 
                   pn -> out.putint;
                   ' rtop: ' -> out.puttext; thisObj.rtop -> out.putint;
                   (out[],'Break:after:goSuper: ') -> thisObj.dumpObj;
               if);         
               descs.OD[descInx].noOfSuper -> nOfS;
               (if trace then
                   'noOfSuper: ' -> out.puttext;
                   nOfS -> out.putint;
                   ' rtop: ' -> out.puttext; thisObj.rtop -> out.putint;
                   out.newline;
               if);
               (if newPopRtn and (descs.OD[descInx].noOfSuper = 0) then 
                   2 -> thisObj.rtop 
                else
                   (if (nOfS > 0) then
                       (if (thisObj.rtop) <> (nOfS + 2) then
                           '\n!!!! WARNING: break to object with '
                           'references on the rstack oether than '
                           'return references' -> putline
               if)if)if);
               descs.OD[descInx].bc[] -> thisCode[];
               descs.OD[descInx].labs[lab] -> glsc;

               (if trace then
                   'ContinueAt: ' -> out.puttext; 
                   descs.OD[descInx].myId -> out.puttext;
                   ' glsc: ' -> out.puttext; glsc->out.putint; out.newline
               if)
            #);
          files: @
            (* handle external files *)
            (# F: [4] ^File; top: @integer;
               open:
                 (# N: ^objDesc.template; l,off: @integer;
                    T: @text;
                 enter N[]
                 do arrayStrucSize - 1 -> N.get -> l; 
                    arrayStrucSize -> off;
                    (for i: l repeat
                         i + off -> N.get -> T.put; 
                    for);
                    (if (top + 1 -> top) > F.range then F.range -> F.extend if);
                    &file[] -> F[top][];
                    T[] -> F[top].name;
                    F[top].openRead;
                 exit top
                 #);
               get: (# id: @integer enter id exit F[id].get #);
               eof: 
                 (# id,V: @integer 
                 enter id 
                 do (if F[id].eos then 1 -> V if)
                 exit V #);
               close: (# id: @integer enter id do F[id].close #);                 
            #);
          objSnap:
            (* kind:
             *    0: val primitive
             *    1: var primitive
             *    2: val valueObj
             *    3: var valueObj
             *    4: obj
             *    5: ref
             *)
            (# trace: (# exit false #);
               arrayStrucSize: (#exit 3 #);
               copyToX:
                 (#
                 do 1 -> ix1;
                    scanItems:
                      (# size: @integer
                      do ix1 + 1 -> ix1;
                         skipId:
                           (* zero-terminated string *)
                           (if items[ix1] <> 0 then 
                               (ix1 + arrayStrucSize,items[ix1]) -> X.put;
                               (*items[ix1] -> put;*)
                               ix1 + 1 -> ix1;
                               restart skipId
                           if);
                         (*' ' -> put;*)
                         (for i: 4 repeat
                              (* off, size, kind, descNo *)
                              ix1 + 1 -> ix1;
                              (if i 
                               // 2 then
                                  items[ix1] -> size
                               // 3 then
                                  items[ix1] -> kind
                              if);
                              (ix1 + arrayStrucSize,items[ix1]) -> X.put;
                              (*items[ix1] -> putint;' '-> put*)
                         for);
                         (if kind // 2 // 3 then
                             (*newline;*)
                             restart scanItems
                          else
                             ix1 + 1 -> ix1;
                             ix2 + 1 -> ix2; 
                             (ix1 + arrayStrucSize,ix2 + 1 -> Y.get) -> X.put;
                             (if (kind <= 1) and (size = 2) then
                                 (if trace then
                                     'float: '->puttext; 
                                     ix1 + arrayStrucSize -> X.get -> putint;
                                 if);
                                 ix1 + 1 -> ix1;
                                 ix2 + 1 -> ix2;
                             (ix1 + arrayStrucSize,ix2 + 1 -> Y.get) -> X.put;
                                 (if trace then
                                     ' -- '->puttext;
                                     ix2 - 1 -> Y.get -> putint; ','->put;  
                                     ix2   -> Y.get -> putint; ','->put;  
                                     ix2 + 1 -> Y.get -> putint; ','->put;  
                                     ix2 + 2 -> Y.get -> putint; ';'->put; 
                                     ix1 + arrayStrucSize -> X.get -> putint; newline;
                         if)if)if);
                         (if ix1 < items.range then
                             restart scanItems
                         if);
                         (if trace then
                             '\n**** items.range: ' -> puttext;
                             items.range -> putint; 
                             '\n**** X.range: ' -> puttext;
                             X.fields.range -> putint; newline;
                             (for i: X.fields.range repeat
                                  i -> putint; ':'->put;
                                  i -> X.get -> putint;  ' ' -> put
                         for)if);
                      #);
                 #);
               copyArray:
                  (#
                  do (if false then
                          '**** copyArray:'->puttext; arrayStrucSize - 1 -> X.get -> putint; ' ' -> put; arrayStrucSize -> putint; newline;
                     if);
                     (for i: (arrayStrucSize - 1 -> X.get) - 1 repeat
                           (if false then
                               i -> putint; ':'->put;
                               i-> Y.get -> putint; newline;
                           if);
                          (i + arrayStrucSize,i -> Y.get) -> X.put
                     for)
                  #);
               items: [0] @integer; ix1,ix2,kind,objKind: @integer;
               X,Y: ^objDesc.template;
            do (if false then '\n*** dumpObjPrim:'->putline; if);
               thisStack.rpop -> Y[];
               (if withDumps then  ('dumpObj:Y:',true,out[]) -> Y.dump if);
               Y[] -> dumpObjEvent -> (items,objKind);
               
               (if false then
                   '\nitems:'->putline;
                   (for i: items.range repeat 
                        i -> putint; ':'->put;
                        items[i] -> putint; ' ' -> put
                   for);
                   newline;
               if);
               (none,descs.textDescNo,1,items.range,0) -> QallocIndexed;
               thisStack.rPop -> X[];
               (if withDumps then ('snapA:',true,out[]) -> X.dump if);
               (if objKind  // 1 // 2 then
                  (if false then
                      '**** copyArray'-> putline;
                  if);
                  copyArray;
                  (4,objKind) -> X.put
               else
                  copyToX;
               if);
               (if withDumps then ('snapB:',true,out[]) ->X.dump if);
               (if false then 
                   'items.range: ' -> puttext; 
                   items.range -> putint; 
                   ' thisObj.vinxsize: ' -> puttext;
                   (*thisObj.vinxsize ->putint;*) newline;
                   (for i: items.range repeat
                        i -> X.get -> putint;  ' ' -> put
                   for);
                   newline;
               if);
               X[] -> thisStack.rPush;
               (if withDumps then 
                   ('dumpObj:X:',true,out[]) -> X.dump;
                   ('dumpObj:thisObj:',true,out[]) -> thisObj.dump
               if)
            #);
          dumpD: 
            (#
            do 'descs:' -> putline;
               (for i: descs.OD.range repeat
                    i -> putint; ':' -> put; 
                    (if descs.OD[i][] = none then ' none' -> putline if);
               for);
               newline
            #);
          isRunning,doTerminate: @Boolean;
          terminate: (# do true -> doTerminate #);
          FN: ^text; 
       (*enter(descs[],descInx,out[],FN[])*)
       do (if runMode = save_BC_Image then
              'SAVING BYTE CODE IMAGE - main desc: ' -> puttext; 
              descInx -> putint; newline;
              (descInx,FN[]) -> saveBCimage;
              STOP
          if);
          main:
            (# suspendEnabled: @integer;
               timeToSuspend: @integer;
               enablee: ^ObjDesc.template;
               first: @boolean
            do (*'***VM started:'->puttext; descInx -> putint; newline;*)
               true -> isRunning; (*screen[] -> out[];*)
               false -> doTerminate;
               (if descs.OD[1][] = none then (* not used any more*)
                   'Allocating dummy template in OD[1] for repetitions'
                     -> putline;
                   &ObjDesc[] -> descs.OD[1][];
                   ('ValueRep',1,0,0,false,out[],descs[]) 
                     -> descs.OD[1].init;
               if);
               (for i: descs.OD.range repeat 
                    (* most OD's are not in use since code is only generated
                     * for modules in use. 
                     *)
                    (*(if descs.OD[i][] <> none then
                        ',' -> put; i -> putint;
                        out[] -> descs.OD[i].out[]
                    if)*)
               for);
               (*newline;*)
               (descInx,true,0,0) 
                 -> allocTemplate -> thisModule[] -> thisObj[] -> thisStack[];
               descs.OD[descInx].bc[] -> thisCode[];

               (* dangerous to assume descInx + 1 *)
               (if descs.OD[descInx + 1][] <> none then
                   (descInx + 1, true,0,0) -> allocTemplate -> eventProcessor[];
                else
                     '**** skip allocTemplate for eventProcessor: assuming bvm' ->putline
               if);
               (if verbose then '**** EXECUTE **** ' -> puttext if);
               (if true then
                   newline
                else
                   descs.OD[descInx].name[] -> puttext;
                   ' descInx: ' -> puttext; descInx -> putint; 
                   ' ****\n\n' -> puttext;
               if);
               (if not noPause then
                   (* apparently we need 2 pause to be sure that 
                    * mouseListener has been started before the VM suspends;
                    * 2025-01-20: 
                    * we cannot call pause for qservice.bet;
                    * it seems to work with/aithout pause for qbeta;
                    * it seems not to work with no pause for qenv!?
                    * A mess!
                    *)
                   pause;
               if);
               (if descs.onlyCinterpreter and (runMode <> run_C_INT) then
                   '\n**** The C-interpreter (qbeta -c) has been selected'
                   '\n     since the program uses concurrency instructions'
                   -> putline;
                   run_C_INT -> runMode
               if);
               1 -> glsc;
               thisObj[] -> root[];
               (if runMode
                // run_C_INT then
                   (# BC,imageSize: @integer
                   do (* '*** C interpreter - main desc: '->puttext; 
                       * descInx -> putint;
                       *)
                      (descInx,none) -> descs.serialize
                      (#
                      do BI.top -> imageSize;
                         (* ', imageSize: ' -> puttext; imageSize -> putint;
                          *  newline; 
                          *)
                      #) -> BC;                                           
                      (BC,imageSize,true,valueProxyDescno)
                        -> init_interpreter;
                      true -> run_interpreter;
                      true -> first;
                      L: (if first -> getEvent -> decodeEvent then
                             false -> first;
                             restart L                            
                         if);
                      close_interpreter;
                      (* '\n\n***** end of C interpreter\n' -> puttext;*)
                      stop; (*suspend;*)
                   #)
               if);
               (none,thisObj[],none,thisCode.descInx,glsc) -> startEvent;
               Loop:
                 (# doCall:
                      (# withEnablingSuspend: @boolean
                      enter withEnablingSuspend
                      do 'call'-> exel; op1asChar -> inx;
                         (if withDumps then  'call:A:'->stacksToOut if);
                         thisStack.rpop -> callee[];
                         (if callee[] = none then 
                             6 -> fatalError;
                             leave doCall
                         if);
                         (if withDumps then 'call:B:'->stacksToOut if);
                         (if withDumps then  (out[],'\n   callee : ') -> callee.dumpObj if);
                         (if withEnablingSuspend then
                             callee[] -> enablee[]
                         if);

                         (thisCode.descInx,glsc) -> thisObj.saveReturn;

                         (if callee.rstackIsEmpty then 
                             '   first ' -> out.puttext;
                             inx -> out.put; out.newline;
                             (*(':first>',true,out[])  -> thisObj.dump;
                             (':first>stack',true,out[])  -> thisStack.dump;*)
                             thisObj[] -> Y[] -> callee.rpush;
                             thisStack[] -> callee.rpush;
                             callee[] -> thisObj[];
                             thisObj.myCode -> thisCode[];
                             thisObj.mySuperCode -> thisCode[];
                             (if inx
                              // 'N' then 
                                 (*thisObj.myCode -> thisCode[];*)
                                 thisCode.enterE -> glsc
                              // 'D' then 
                                 thisCode.doE -> glsc;
                                 (Y[],thisObj[],thisObj.myOrigin,0,glsc
                                 ,withEnablingSuspend)
                                   -> doEvent  
                              // 'X' then
                                 thisCode.exitE -> glsc
                              else
                                 ' ? ' -> out.puttext; inx -> out.put
                             if);
                          else 
                             (if mkRunTrace then '   resume:\n' -> out.puttext if);
                             (if inx
                              // 'N' then
                                 (*(':resume:N:',true,screen[])->callee.dump;*)
                                 thisObj[] -> Y[] -> callee.rpush; 
                                 thisStack[] -> callee.rpush;
                                 callee[] -> thisObj[]; 
                                 thisObj.myCode -> thisCode[]; 
                                 (*thisObj.mySuperCode -> thisCode[]; *)
                                 thisCode.enterE -> glsc; 
                              // 'X' then
                                 (if withDumps then (':coroutine:exit',false,out[]) ->thisObj.dump if);
                                 thisObj[] -> Y[] -> callee.rpush;
                                 thisStack[] -> callee.rpush;
                                 callee[] -> thisObj[];
                                 thisObj.myCode -> thisCode[];
                                 thisObj.mySuperCode -> thisCode[];
                                 thisCode.exitE -> glsc
                              else
                                 (thisObj[],callee[],callee.myOrigin
                                 ,0,glsc,withEnablingSuspend) -> resumeEvent;
                                 (if withEnablingSuspend or true (*coArg*) then
                                     (thisObj[],thisStack[]) 
                                       -> callee.rswap 
                                       -> (thisObj[],thisStack[]);
                                  else
                                     (thisObj[],thisStack[]) 
                                       -> callee.rswap 
                                       -> (thisObj[],X[])
                                 if);
                                 (if withDumps then 
                                    (out[],'   after:swap:thisObj:\n     ')
                                   -> thisObj.dumpObj;
                                 if);
                                 (if (thisStack[] <> thisObj[]) and withDumps then
                                     '\n*** resume: thisObj<>thisStack' ->out.puttext;
                                     ('thisObj',true,out[])  -> thisObj.dump;
                                     ('stack',true,out[])  -> thisStack.dump;
                                 if);
                                 thisObj.restoreReturn -> (descInx,glsc);
                                 descs.OD[descInx].bc[] -> thisCode[];   
                                 thisObj.lsc -> glsc; 
                                 (* 'descInx: ' -> puttext; descInx -> putint;
                                  * ' glsc: ' ->puttext; glsc->putint; newline*)
                      if)if)#);
                    doSuspend:
                      (# callee: ^objDesc.template; preemptive: @boolean;
                      enter (callee[], preemptive)
                      do (if mkRunTrace then callee.myNameDI -> out.puttext if);
                        (if withDumps then  stacksToOut if);
                         glsc -> thisObj.lsc; (* why is saveReturn not enough?*)
                         (if (thisObj[] <> thisStack[]) then
                             (if withDumps then 
                                '\n\n**** external suspend: thisObj<>thisStack'
                                  ->out.putline;
                                (out[],'   thisObj   = ') -> thisObj.dumpObjFull;
                                (out[],'   thisStack = ') -> thisStack.dumpObjFull;
                         if)if); 
                         (if withDumps then 
                            out.newline;
                            (out[],'   before:swap:thisObj:\n     ') 
                              -> thisObj.dumpObjFull;
                            (out[],'   before:swap:thisStack:\n     ') 
                              -> thisStack.dumpObjFull;
                         if);
                         (thisCode.descInx,glsc) -> thisObj.saveReturn;
                         (thisObj[],thisStack[]) 
                           -> callee.rswap -> (thisObj[],thisStack[]);
                         (if (thisObj[] <> thisStack[]) then
                             (if withDumps then  '\n\n**** external suspend:return: thisObj<>thisStack'->out.putline if)
                         if);
                         thisObj.restoreReturn -> (descInx,glsc);
                         descs.OD[descInx].bc[] -> thisCode[];
                         callee[] -> thisStack.rpush;
                         (if withDumps then 
                             (out[],'   after:swap:thisObj:\n     ')
                               -> thisObj.dumpObjFull;
                             (out[],'   after:swap:thisStack:\n     ') 
                               -> thisStack.dumpObjFull;
                        if);
                         (thisObj[],callee[],thisObj.myOrigin,thisCode.descInx,glsc, preemptive) 
                           -> suspendEvent;                         
                      #);
                    exe: 
                      (# T: ^text ; F: ^file
                      enter T[] 
                      do inner;
                         (if mkRunTrace then
                             out.newline;
                             thisObj.myName -> out.puttext;'>'-> out.put;
                             glsc -> out.putint;':' -> out.put; '\t' -> out.put;
                             T[] -> out.puttext; ' '-> out.put;
                         if); 
                         glsc+1 -> glsc; 
                         (if false and (out## = File##) then
                             out[] -> F[]; (*F.flush*)
                         if)
                      #);
                    exel: exe(# do (if mkRunTrace then out.newline if) #);
                    op1: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg;
                         (if mkRunTrace then arg -> out.putint; ' ' -> out.put if); 
                         glsc + 1 -> glsc
                      exit arg
                      #);
                    op1asChar: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg;
                         (if mkRunTrace then arg -> out.put; ' ' -> out.put if); 
                         glsc + 1 -> glsc
                      exit arg 
                      #);
                    op2: 
                      (# arg: @integer
                      do thisCode.B[glsc] * 256 + thisCode.B[glsc+1] -> arg;
                      (if mkRunTrace then arg -> out.putint; ' ' -> out.put if); 
                         glsc + 2 -> glsc
                      exit arg
                      #);
                    op8:
                      (# X: @real; L1,L2: @integer
                      do (for i: 8 repeat
                              (*thisCode.B[glsc + i - 1] -> puthex; newline;*)
                              thisCode.B[glsc + i - 1] %putByteAt (@@X + i - 1)
                         for);
                         (for i: 4 repeat
                              thisCode.B[glsc + i - 1] %putByteAt (@@L1 + i -1);
                              thisCode.B[glsc + 4 + i - 1] %putByteAt (@@L2 + i - 1)
                         for);
                         glsc + 8 -> glsc;
                      exit(X,L1,L2)
                      #);
                    VtoOut:
                      (# obj: ^ObjDesc.template; off,val: @integer
                      enter(obj[],off,val)
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                        '=' -> out.put; val -> out.putint;
                      #);
                    FtoOut:
                      (# obj: ^ObjDesc.template; off,L1,L2: @integer; val: @real;
                      enter(obj[],off,L1,L2)
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                         '=' -> out.put; 
                         (if true then
                             L1 %putLongAT (@@val);
                             L2 %putLongAt (@@val + 4);
                             val -> out.putReal; ' ' -> out.put;
                             L2 %putLongAT (@@val);
                             L1 %putLongAt (@@val + 4);
                             val -> out.putReal
                          else
                             L1 -> out.putint; ' ' -> out.put;
                             L2 -> out.putint
                         if)
                      #);
                    RtoOut:
                      (# obj,Ref: ^ObjDesc.template; off,val: @integer
                      enter(obj[],off,Ref[])
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                         '=' -> out.put; 
                         (if Ref[] = none then
                             'none' -> out.puttext
                          else
                             ref.myName -> out.puttext
                         if)
                      #);
                    descInx,size,isValueObj,originIsValueObj,isRindexed
                    ,dinx,rangee,inx,length,serverId,ix
                    ,handle,msgId,rtnVal,off,value,on,lab,pn,top1,top2:
                      @integer;
                    float1,float2: @real;
                    hasRtnVal: @boolean;
                    callee,R,X,Y,rtnRef: ^ObjDesc.Template;
                 do (if glsc -> thisCode.isBreak then
                        (thisObj.myDyn,thisObj[],thisObj.myOrigin,0,glsc) 
                          -> breakEvent
                    if);
                    (if suspendEnabled = 1 then
                        timeToSuspend - 1 -> timeToSuspend;
                        (if (timeToSuspend <= 0) (*and (allocLevel = 0)*) then
                            (*'allocLevel: ' -> puttext; allocLevel -> putint;
                             * newline;*)
                            (if testConc then
                                '\n**** external suspend: ' -> putline;
                            if);
                            (if mkRunTrace then '\n**** external suspend:enablee ' -> out.puttext if);
                            (if enablee[] <> none then
                                (if mkRunTrace then enablee.myNameDI -> out.puttext if);
                                suspendEnabled - 1 -> suspendEnabled;
                                (enablee[], true) -> doSuspend;
                                none -> enablee[]
                             else
                                (* either a compile error
                                 * or disable/eanble used without 
                                 * attach having been called
                                 *)
                                (if mkRunTrace then 'none ' -> out.puttext if);
                            if)
                        if)
                    if);
                    (*'aaaC'->putline;  thisCode.B[glsc] -> putint; ' ' ->put;*)
                    (if thisCode.B[glsc]
                     // codes.pushc then
                        'pushc' -> exe;
                        op1 ->  thisStack.vpush;
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.pushNone then
                        'pushNone' -> exe;
                        none -> thisstack.rpush;
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,none)
                          -> rPushEvent
                     // codes.pushc2 then
                        'pushc2' -> exe;
                        op2 -> thisStack.vpush; 
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.pushthis then
                        'pushthis' -> exe;
                        thisObj[] -> thisStack.rpush;
                        (*StacksToOut;*)
                        (*('pushThis:',true,out[]) -> thisObj.dump;*)
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,thisObj[])
                          -> rPushEvent
                     // codes.push then
                        'push' -> exe;
                        op1 -> off -> thisObj.get -> thisStack.vpush;
                        (thisObj[],thisObj[],false,thisStack[],off,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.rpush then
                        'rpush' -> exe;
                        op1 -> off -> thisObj.rget -> X[];
                        (if mkRunTrace then 
                           ' ' -> out.put; thisObj.myName -> out.puttext;
                           '[' -> out.puttext; off -> out.putint; ']' 
                             -> out.put;
                           '='->out.put; 
                           (if X[] = none then 
                               'none' -> out.puttext
                            else
                               X.myName -> out.puttext;
                        if)if);
                        X[] -> thisStack.rpush;

                        (thisObj[],thisObj[],false,thisStack[],off,false
                        ,thisCode.descInx,glsc,0,thisStack.rTopElm) 
                          -> rPushEvent
                     // codes.pushg then
                        'pushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        op1 -> off;
                        (if mkRunTrace and (thisStack.valOff > 0) then 
                            ' +(' -> out.puttext;
                            thisStack.valOff -> out.putint; 
                            ')' -> out.put;
                        if);
                        off -> X.get -> top1 -> thisStack.vpush;
                        (if mkRunTrace then (X[],off,top1) -> VtoOut if);
                        (thisObj[],X[],true,thisStack[],off,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.vpushg then
                        'vpushg' -> exe; op1 -> off;
                        thisStack.rpop -> X[]; (* this *)
                        (if false then
                            ('thisObj:',true,out[]) -> thisObj.dump;
                            ('X:',true,out[]) -> X.dump;
                        if);
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        2 -> X.rget -> Y[]; (* holder *)
                        (if Y[] = none then
                            '**** Y is none'->putline
                        if);
                        3 -> X.get -> inx;
                        (if mkRunTrace then inx -> out.putint if); 
                        (off + inx ) -> Y.get -> top1 -> thisStack.vpush;
                        (if false then
                            ('vpushg:',true,out[]) -> X.dump;
                            ('holder:',true,out[]) -> Y.dump;
                            (X[],off + inx ,top1) -> VtoOut;
                        if);
                        (thisObj[],X[],true,thisStack[],off,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent
                     // codes.fpushg then
                        'fpushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        op1 -> off;
                        (if mkRunTrace and (thisStack.valOff > 0) then 
                            ' +$ ' -> out.puttext;
                            thisStack.valOff ->out.putint; ' '->out.put;
                        if);
                        off -> X.get -> top1 -> thisStack.vpush;
                        off + 1-> X.get -> top2 -> thisStack.vpush;
                        (if mkRunTrace then  (X[],off,top1,top2) -> FtoOut if);
                        (thisObj[],X[],true,thisStack[],off,false,0
                        ,thisCode.descInx,glsc,(top1,top2) -> intPair2float)
                          -> fPushEvent
                     // codes.fvpushg then
                        'fvpushg' -> exe; op1 -> off;
                        thisStack.rpop -> X[]; 
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        (if withDumps then
                            ('fvpushg:',true,out[]) -> X.dump;
                        if);
                        2 -> X.rget -> Y[]; (* holder *)
                        (if withDumps then
                            ('fvpushg:holder:',true,out[]) -> Y.dump;
                        if);
                        3 -> X.get -> inx;
                        (off + inx) -> Y.get -> top1 -> thisStack.vpush;
                        (off + inx + 1) -> Y.get -> top2 -> thisStack.vpush;
                        (if withDumps then
                            (X[],off,top1,top2) -> FtoOut;
                        if);
                        (thisObj[],X[],true,thisStack[],off,false,0
                        ,thisCode.descInx,glsc,(top1,top2) -> intPair2float)
                          -> fPushEvent
                     // codes.rpushg then
                        'rpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        (*('rpushg:',true,out[]) -> X.dump;*)
                        (if X[] = none then 
                            3 -> fatalError; leave loop if);
                        off -> X.rget -> Y[];
                        Y[]-> thisStack.rpush;
                        (if mkRunTrace then (X[],off,Y[]) -> RtoOut if);
                        (thisObj[],X[],true,thisStack[],off,false,0
                        ,thisCode.descInx,glsc,thisStack.rTopElm) 
                          -> rPushEvent
                     // codes.xpushg then
                        (* rStack: ... X = Array-object
                         * vStack: ... inx = index into array 
                         *    (0 < inx) and (inx <= size)
                         *)
                        (# ix: @integer
                        do 'xpushg' -> exe;  op1 -> size;  op1 -> isValueObj;
                           thisStack.rpop -> X[];
                           thisStack.vpop -> inx;
                           (if mkRunTrace then  ' inx: ' -> out.puttext; inx -> out.putint if);
                           (if size = 0 then
                               arrayStrucSize -> X.get -> size;
                               (if mkRunTrace then ' objSize: ' -> out.puttext; size -> out.putint if)
                           if);   
                           (if (inx <= -2) or (inx > (arrayStrucSize - 1 -> X.get)) then
                               '!!! BetaVM: index error when reading from array of size: ' -> puttext;
                               2 -> X.get -> putint;  
                               ' using index: ' -> puttext; inx -> putint; newline;
                               '!!! index error: ' -> out.puttext;
                               inx -> out.putint; ' > '->out.puttext;
                               2 -> X.get -> out.putint; out.newline;
                           if);
                           arrayStrucSize + (inx - 1) * size -> inx;
                           
                           (if mkRunTrace then  ' inxAdj: '->out.puttext; inx->out.putint; out.newline if);  
                           (if withDumps then ('xpushg:',true,out[]) -> X.dump if);
                           (if (isValueObj = 0) and (size = 1) then
                               inx + 1
                                 -> X.get 
                                 -> value 
                                 -> thisStack.vpush;
                               (if mkRunTrace then (X[],ix,value) -> VtoOut if);
                            else (* valueObject *)
                               (if size > 1 then
                                   (for i: size repeat
                                        inx + i
                                          -> ix 
                                          -> X.get 
                                          -> value
                                          -> thisStack.vPush;
                                        (if mkRunTrace then 
                                           ' val: ' -> out.puttext; ix -> out.putint; ':' -> out.put; value -> out.putint
                                        if); 
                                   for)
                                else (* should never happen: size = '*)
                                   '\n!!! should not happen: size = 0'->putline;
                                   arrayStrucSize + off + 1 - 2  -> ix -> thisStack.vPush;
                                   X[] -> thisStack.rpush
                           if)if);
                           (thisObj[],X[],true,thisStack[],off,true,ix
                           ,thisCode.descInx,glsc,thisStack.vTopElm)
                             -> vPushEvent  
                        #)
                     // codes.xrpushg then
                        'xrpushg' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> inx;
                        arrayStrucSize + inx -> ix;
                        ix -> X.rget -> thisStack.rpush;
                        (thisObj[],R[],true,thisStack[],off,true,ix
                        ,thisCode.descInx,glsc,thisStack.rTopElm)
                          -> rPushEvent                      
                     // codes.rstore  then
                        'rstore' -> exe;  op1->off;
                        thisStack.rpop -> X[]; (* if multiple assignment of X, 
                                                * violation error happens
                                                * compiler error?
                                                *)
                        (if mkRunTrace then 
                            (if X[] = none then
                                'none'->out.puttext
                            else
                                X.myName -> out.puttext
                            if);
                            '->' -> out.puttext;
                            thisObj.myName -> out.puttext;
                            '[' -> out.put; off -> out.putint; ']'-> out.put;
                        if);
                        (off,X[]) -> thisObj.rput;
                        (thisObj[],thisStack[],false,thisObj[],off,false,0,thisCode.descInx,glsc,X[]) 
                          -> rStoreEvent
                     // codes.pushValue then
                        (# size,srcOff,value: @integer;
                           srcObj: ^ObjDesc.template
                        do 'pushValue' -> exe; op2 -> srcOff; op1 -> size; 
                           thisStack.rPop -> srcObj[];
                           (if mkRunTrace then ' srcOff:'->out.puttext; srcOff -> out.putint if);
                           (if withDumps then ('src',true,out[]) -> srcObj.dump if);
                           (for i: size repeat
                                (if mkRunTrace then 
                                   'val:' -> out.puttext; srcOff + i - 1 -> out.putint; '='-> out.put;
                                if);
                                srcOff + i - 1 -> srcObj.get -> value;
                                value -> thisStack.vPush;
                                (if mkRunTrace then value -> out.putint; ',' -> out.put if)
                           for);
                           (if mkRunTrace then out.newline if);
                           (if withDumps then stacksToOut if)
                        #)
                     // codes.vassign then
                        (# size,mode,destOff: @integer; 
                           destObj: ^ObjDesc.template;
                           D: [10] @integer
                        do 'vassign' -> exe; op2 -> destOff; 
                           op1 -> size; op1 -> mode;
                           (*thisStack.vTopElm -> out.putint;*)
                           (if withDumps then  stacksToOut if);
                           (*thisStack.vpop -> destOff;*)
                           thisStack.rpop -> destObj[];
                           (if withDumps then 
                               ('thisStack:before',true,out[]) ->thisStack.dump;
                               ('thisObj:before',true,out[]) -> thisObj.dump;
                           if);
                           (for i: size repeat thisStack.vPop -> D[i] for);
                           
                           (if (mode = 1) then 
                                   destOff + (3->destObj.get) -> destOff;
                                   (if mkRunTrace then destOff -> out.putint; out.newline if);
                                   2 -> destObj.rget -> destObj[]; 
                           if);
                           (if withDumps then ('dest:before',true,out[]) -> destObj.dump if);
                           (for i: size repeat
                                D[i] -> value;
                                (if mkRunTrace then
                                    'copy:' -> out.puttext; value -> out.putint; ',' -> out.put;
                                if);
                                (destOff + size - i, value) -> destObj.put
                           for);
                           (if mkRunTrace then out.newline if);
                           (if withDumps then stacksToOut if);
                           (if withDumps then ('dest:after',true,out[]) -> destObj.dump if);
                           (*(destObj[],3, destOff -> destObj.get
                           , destOff+1 -> destObj.get) -> FtoOut;*)
                        #)
                     // codes.vEq then
                        (# R: [10]@ integer; size, mode, di,off:  @integer;
                           Lobj: ^ObjDesc.template; B: @integer
                        do
                           'veq' -> exe; op2 -> off; op1 -> size;
                          (if withDumps then  stacksToOut if);
                           thisStack.vPop -> mode; (* NO *)
                           (if mkRunTrace then  '\n**** values: ' -> out.puttext if);
                           (for i: size repeat 
                                thisStack.vpop -> R[size - i + 1] ;
                                (if mkRunTrace then R[size - i + 1] -> out.putint; ' ' -> out.put if);
                           for);
                           (if mkRunTrace then  
                               'off/di: ' -> out.puttext; off -> out.putint; ' ' -> out.put; di -> out.putint;
                           if);
                           thisStack.rPop -> Lobj[];
                           (if withDumps then ('veq',true,out[]) -> Lobj.dump if);
                           1 -> B;
                           L:
                             (for i: size repeat
                                  (if Lobj.fields[off + (i - 1)] <> R[i] then
                                      0 -> B;
                                      leave L
                             if)for);
                           B -> thisStack.vPush
                        #);
                        
                     // codes.store  then
                        'store' -> exe;
                        (op1 -> off,thisStack.vpop -> value) -> thisObj.put;
                        (if mkRunTrace then  
                            value -> out.putint; '->' -> out.puttext;
                            thisObj.myName -> out.puttext; 
                            '[' -> out.put; off -> out.putint; ']' -> out.put;
                        if);
                        (thisObj[],thisStack[],false,thisObj[],off,false,thisCode.descInx,glsc,0,value) 
                          -> vStoreEvent
                     // codes.storeg  then
                        'storeg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.vpop -> value;
                        op1 -> off;
                        (if mkRunTrace and (X.valOff > 0) then 
                            '+(' -> out.puttext;
                            thisStack.valOff -> out.putint; ')' -> out.put;
                            (if not isValObj then
                                'isValObj=false ' -> out.puttext
                            if)
                         else
                            (if isValObj then
                                'isValObj=true ' -> out.puttext
                            if)
                        if);
                        (off,value) -> X.put;
                        (if withDumps then  (X[],off,value) -> VtoOut if);
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,value) 
                          -> vStoreEvent
                     // codes.vstoreg  then
                        'vstoreg' -> exe;
                        thisStack.rpop -> X[]; (* this *)
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        thisStack.vpop -> value;
                        op1 -> off;
                        2 -> X.rget -> Y[]; (* holder *)
                        (if Y[] = none then
                            '!!!! Holder = Y is none'->putline;
                        if);
                        3 -> X.get -> inx;
                        (off + inx,value) -> Y.put;
                        (if false then
                            (X[],off + inx,value) -> VtoOut;
                            ('vstoreg:holder',true,out[]) -> Y.dump;
                        if);
                        (thisObj[],Y[],true,thisStack[],off,false
                        ,0,thisCode.descInx,glsc,value)
                          -> vPushEvent;
                     // codes.fstoreg  then
                        'fstoreg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.vpop -> top2;
                        thisStack.vpop -> top1;
                        op1 -> off;
                        (if mkRunTrace and (thisStack.valOff > 0) then 
                            '+$ ' -> out.puttext;
                            thisStack.valOff -> out.putint; ' ' -> out.put
                        if);
                        (off,top1) -> X.put;
                        (off + 1,top2) -> X.put;
                        (if mkRunTrace then (X[],off,top1,top2) -> FtoOut if);
                        (thisObj[],thisStack[],true,X[],off,false,0
                        ,thisCode.descInx,glsc,(top1,top2)->intPair2Float)
                          -> fStoreEvent
                     // codes.fvstoreg  then
                        'fvstoreg' -> exe; op1 -> off;
                        (if withDumps then stacksToOut if);
                        thisStack.rpop -> X[]; (* this *)
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.vpop -> top2;
                        thisStack.vpop -> top1;
                        (if mkRunTrace then (X[],0,top1,top2) -> FtoOut if);
                        2 -> X.rget -> Y[]; (* holder *)
                        3 -> X.get -> inx;
                        (if withDumps then
                            ('fvstoreg:this',true,out[]) -> X.dump;
                            ('fvstoreg:holder',true,out[]) -> Y.dump;
                        if);
                        (off + inx,top1) -> Y.put;
                        (if mkRunTrace then top1 -> out.putint; ' ' -> out.put if);
                        (off + inx + 1,top2) -> Y.put;
                        (if mkRunTrace then
                            top2 -> out.putint;
                            (X[],off + inx ,top1,top2) -> FtoOut;
                        if);
                        (thisObj[],thisStack[],true,X[],off,false,0
                        ,thisCode.descInx,glsc
                        ,(top1,top2)->intPair2Float) -> fStoreEvent
                     // codes.rstoreg then
                        'rstoreg' -> exe; op1 -> off;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.rpop -> Y[];
                        (if mkRunTrace then (X[],off,Y[]) -> rToOut if);;
                        (*('dest',true,out[])  -> X.dump;
                        (if Y[] <> none then ('src',true,out[]) -> Y.dump if);*)
                        (off,Y[]) -> X.rput;
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,Y[]) 
                          -> rStoreEvent                   
                     // codes.xstoreg then
                        'xstoreg' -> exe; op1 -> size; op1 -> isValueObj; 
                        (if mkRunTrace then 
                           ' size: ' -> out.puttext; size -> out.putint;
                           ' isValueObj: '-> out.puttext; isValueObj -> out.putint
                        if);
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.vpop -> inx;
                        (if mkRunTrace then  ' inx: ' -> out.puttext; inx -> out.putint if); 
                        (if size = 0 then
                            arrayStrucSize -> X.get -> size;
                            (if mkRunTrace then ' objSize: ' -> out.puttext; size -> out.putint if)
                        if);
                        (if (inx <= -2) or (inx > (arrayStrucSize - 1 -> X.get)) then
                               '!!! BetaVM: index error when storing into array of size : ' -> puttext;
                               2 -> X.get -> putint;  
                               ' using index: ' -> puttext; inx -> putint; newline;
                               '!!! index error: ' -> out.puttext;
                               inx -> out.putint; ' > '->out.puttext;
                               2 -> X.get -> out.putint; out.newline;
                        if);
                        arrayStrucSize + (inx - 1) * size + size + 1 -> inx;
                        (if mkRunTrace then ' inxAdj: '->out.puttext; inx->out.putint; out.newline if);
                        (if isValueObj = 1 then thisStack.vPop -> value (* not used *) if);
                        (# RX: [2] @integer; top: @integer;
                        do (for i: size repeat
                                inx - i -> ix;
                                thisStack.vPop -> value;
                                (if mkRunTrace then  
                                    ' ix: '->out.puttext; ix -> out.putint; ':'->out.put; value -> out.putint;
                                if);
                                (value,ix) -> X.assign
                           for);
                           (if mkRunTrace and (size = 2) then
                               (X[],off,RX[2],RX[1]) -> FtoOut;
                               out.newline;
                        if)#);
                        (if withDumps then
                           (X[],ix,value) -> VtoOut;
                           ('xstoreg:',true,out[]) -> X.dump;
                        if);
                        (thisObj[],thisStack[],true,X[],off,true,inx,thisCode.descInx,glsc,value) -> vStoreEvent
                       // codes.xrstoreg then
                        'xrstoreg' -> exe;
                        (if withDumps then stacksToOut; out.newline if);
                        thisStack.rpop -> X[];
                        thisStack.vpop -> inx;
                        thisStack.rpop -> Y[];
                        arrayStrucSize + inx  -> ix;
                        (ix,Y[]) -> X.rPut;
                        (if mkRunTrace then (X[],arrayStrucSize + inx,Y[]) -> RtoOut if);
                        (thisObj[],thisStack[],true,X[],off,true,inx,thisCode.descInx,glsc,Y[]) -> rStoreEvent                      
                     // codes.double then
                        'double' -> exe; 
                        (if withDumps then stacksToOut if);
                        thisStack.vdub;
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent
                     // codes.rdouble then
                        'rdouble' -> exe;
                        (if withDumps then stacksToOut if);
                        thisStack.rdub;
                        (if withDumps then stacksToOut if);
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.rTopElm)              
                          -> rPushEvent
                     // codes.rpop then
                        'rpop' -> exe;
                        thisStack.rpop;
                     // codes.vpop then
                        'vpop'-> exe;
                        thisStack.vpop;
                     // codes.swap then
                        (# arg1,arg2: @integer
                        do 'swap' -> exe; op1 -> inx;
                           (if withDumps then stacksToOut if);;
                           (if inx > 0 then
                               (if false then
                                     '*** betaVM:rswap: ' -> puttext; 
                                     inx -> putint;
                                     newline;
                              if);
                              inx -> thisStack.swapIndexed;
                            else
                               thisStack.vPop -> arg1;
                               thisStack.vPop -> arg2;
                               arg1 -> thisStack.vPush;
                               arg2 -> thisStack.vPush;
                           if);
                           (if withDumps then stacksToOut if);
                        #)
                     // codes.rswap then
                        'rswap' -> exe; op1 -> inx;
                        (if withDumps then stacksToOut if);;
                        (if inx > 0 then 
                            inx -> thisStack.rswapIndexed;
                        else
                            thisstack.rpop -> X[];
                            thisstack.rpop -> Y[];
                            X[] -> thisstack.rpush;
                            Y[] -> thisstack.rpush;
                        if);
                        (if withDumps then stacksToOut if);
                     // codes.vShiftUp then
                        'vShiftUp' -> exe; op1 -> inx;
                        (if withDumps then stacksToOut if);;
                        (inx,true) -> thisStack.vShift;
                        (if withDumps then stacksToOut if);;
                     // codes.vShiftDown then
                        'vShiftDown' -> exe; op1 -> inx;
                        (if withDumps then stacksToOut if);;
                        (inx,false) -> thisStack.vShift;
                        (if withDumps then stacksToOut if);;
                     // codes.rShiftUp then
                        'rShiftUp' -> exe; op1 -> inx;
                        (if withDumps then stacksToOut if);;
                        (inx,true) -> thisStack.rShift;
                        (if withDumps then stacksToOut if);;
                     // codes.rShiftDown then
                        'rShiftDown' -> exe; op1 -> inx;
                        (if withDumps then stacksToOut if);;
                        (inx,false) -> thisStack.rShift;
                        (if withDumps then stacksToOut if);;
                     // codes.alloc then
                        'alloc' -> exe; op2 -> descInx; op1 -> isObj;
                        thisStack.rpop -> X[]; (* origin *)
                        (X[],descInx,isObj = 1) -> alloc;
                        (if withDumps then stacksToOut if);;
                     // codes.tstOriginNone then
                        'tstOriginNone' -> exe;
                        (if thisStack.rTopElm = none then
                            10 -> fatalError; leave loop
                        if);
                        (if withDumps then stacksToOut if);
                     // codes.invoke then
                        'invoke' -> exe; op2 -> descInx; op2 -> off; op1 -> isObj;
                        (if false then
                            (if lastProxy[] <> none then
                                ('Invoke:lastProxy:',true,out[])
                                  -> lastProxy.dump;
                                ('Invoke:lastHolder:',true,out[])
                                  -> lastHolder.dump;
                        if)if);
                        (descInx,off,isObj = 1 ) -> invoke;
                        (if withDumps then stacksToOut if);;  
                        (if false then
                            (if lastProxy[] <> none then
                                ('Invoke:lastProxy:X:',true,out[])
                                  -> lastProxy.dump;
                                ('Invoke:lastHolder:X:',true,out[])
                                  -> lastHolder.dump;
                        if)if)
                     // codes.mkVindexed then
                        'mkVindexed' -> exel;
                        (op2,false) -> mkIndexed
                     // codes.mkRindexed then
                        'mkRindexed' -> exel;
                        (op2,true) -> mkIndexed
                     // codes.saveAndSetThis then
                        'saveAndSetThis' -> exel;
                        (*stacksToOut;*)
                        thisStack.rPoP -> X[];
                        thisObj[] -> thisStack.rPush;
                        X[] -> thisObj[]
                     // codes.restoreThis then
                        'restoreThis' -> exel;
                        (if withDumps then stacksToOut if);;
                        thisStack.rPop -> thisObj[];
                        (if withDumps then stacksToOut if);
                     // codes.invokeVal then
                        (if withDumps then stacksToOut if);;
                        'invokeVal' -> exel;
                        op2 -> descInx; op2 -> off; op1 -> isValueObj;
                        (descInx,off,isValueObj) -> invokeVal;   
                        (if withDumps then stacksToOut if);
                     // codes.boxedInvokeVal then
                        'boxedInvokeVal' -> exel;
                        op2 -> descInx; op2 -> rangee;
                        (* The saveReturn is quite tricky. 
                         * We save glsc + 3 to return past
                         *    mvStack
                         *    rtn D
                         * after the call og boxedInvokeVal
                         *)
                        (if withDumps then stacksToOut if);
                        (thisCode.descInx,glsc + 3 ) -> thisObj.saveReturn;
                        (if withDumps then stacksToOut if);
                        (none,descInx,1,rangee,0) -> QallocIndexed;
                        (if withDumps then stacksToOut if);
                        thisStack.rPop -> callee[];
                        thisObj[] -> callee.rPush;
                        thisStack[] -> callee.rPush;
                        callee[] -> thisObj[];
                         (if withDumps then ('BoxedInvokeVal:',true,out[]) -> thisObj.dump if);
                        (descInx,2,0) -> invokeVal; (* Check isValueObj *)
                         (if withDumps then ('BoxedInvokeVal:',true,out[]) -> thisObj.dump if);
                     // codes.allocIndexed then
                        'allocIndexed' -> exel; 
                        op2 -> descInx; op1 -> size; op1 -> isRIndexed;
                        (* a superflous thisObj is pushed by compiler should be eliminated *)
                        thisStack.rpop -> X[]; (* origin *)
                        thisStack.vpop -> dinx;
                        thisStack.vpop -> rangee;
                        (X[],descInx,size,rangee,isRindexed) -> QallocIndexed
                     // codes.exeAlloc then
                        'exeAlloc' -> exel; op2 -> descInx;
                        (if withDumps then 'exeAlloc:before'-> stacksToOut if);;

                        thisStack.rpop -> X[]; (* origin *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> thisObj.rPush; 
                        thisStack[] -> thisObj.rpush;
                        thisObj[] -> thisStack[]; 
                        X[] -> thisObj.rpush;
                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.allocE -> glsc;
                        (if false then
                            (* called if this object has a super
                             * reconsider if/when this is an event
                             * Also arg isObject should be defined in the code
                             * is currentli 0 (zero)
                             *)
                            (thisObj[],thisObj[],X[],thisCode.descInx
                            ,glsc,false,false) -> allocEvent
                        if);
                        allocLevel + 1 -> allocLevel;
                        (if withDumps then'exeAlloc:after'-> stacksToOut if);
                     // codes.newVrep then
                        'newVrep' -> exe;
                        (1,thisStack.vpop,2,0) 
                          -> descs.OD[1].template 
                          -> thisStack.rpush;
                     // codes.send then 
                        'send' -> exel; op1 -> descInx;
                        (descInx,false,0,0) -> allocTemplate -> callee[];
                        (* save return *)
                        '\nsend: ' -> puttext;
                        callee.myNameDI -> puttext;
                         ' ' -> put; glsc -> putint; newline;
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> callee.rPush;
                        callee[] -> thisObj[];
                        descs.OD[descInx].BC.procE -> glsc
                     // codes.invokeV then
                        L:
                          (# R: [10]^ObjDesc.template; top: @integer;
                             recIsValObj: @integer
                          do 'invokeV ' -> exel;
                             op1 -> dinx; op1 -> inx; (* noOfRefArgs*)
                             op1 -> recIsValObj;
                             (if withDumps then stacksToOut if);
                             (if inx > 0 then
                                 (for i: inx repeat
                                      thisStack.rpop -> R[top + 1 -> top][]
                             for)if);
                             thisStack.rpop -> X[]; 
                             (if withDumps then ('invokev:X:',true,out[]) -> X.dump if);
                             (if X[] = none then 
                                 3 -> fatalError;
                                 leave loop 
                             if);
                             (if (inx > 0) and withDumps then
                                 ('invokev:thisObj:',true,out[]) ->thisObj.dump
                             if);
                             (if true
                              // isValObj then
                                 (if mkRunTrace then '\n** Invokev:mainP:in:valueObj'->out.putline if);
                                 thisValObjDesc.vdtTable[dinx] -> descInx; 
                              // (recIsValObj = 1) then
                                 4 -> X.get -> ix;
                                 (if mkRunTrace then 
                                     '\n** Invokev:rec:valueObj:' -> out.putline; 
                                     (X.myObjDesc).myId -> out.puttext;
                                     ' ' -> out.put;
                                     ix -> out.putint; ' ' -> out.put;
                                 if);
                                 descs.OD[ix].vdtTable[dinx] -> descInx;
                                 0 -> ix 
                              else
                                 (X.myObjDesc).vdtTable[dinx] -> descInx; 
                             if);
                             (if mkRunTrace then
                                '\n   vDescInx: ' -> out.puttext; descInx -> out.putint; ' ' -> out.put;
                             if);
                             (if descInx = 0 then 
                                 8 -> fatalError;
                                 leave loop 
                             if);
                             (descInx,false,0,0) -> allocTemplate -> callee[];
                             (if mkRunTrace then 
                                 'callee:'->out.puttext;
                                  callee.myNameDI -> out.putline;
                              if);
                             (thisCode.descInx,glsc) -> thisObj.saveReturn;
                             descs.OD[descInx].bc[] -> thisCode[];
                             thisObj[] -> Y[] -> callee.rPush;
                             thisStack[] -> callee.rPush; 
                             X[] -> thisStack.rpush;
                             callee[] -> thisObj[];
                             descs.OD[descInx].BC.allocE -> glsc;
                             (for i: inx repeat
                                  R[top - i + 1][] -> thisStack.rpush
                             for);
                             (* we need to distinguish if we generate 
                              * an object or an activation. 
                              * For now we assume an activation
                              *)
                             false -> isValObj; 
                          #)
                     // codes.mkValueProxy then
                        'mkValueProxy'-> exe; op2 -> descInx; op2 -> off;
                        op1 -> isValueObj; op1 -> originIsValueObj;
                        (descInx,off,isValueObj,originIsValueObj)
                          -> mkValueProxy
                     // codes.mvStack then
                        'mvStack'-> exe;
                        (if withDumps then 'mvStack:before:'->stacksToOut if);
                        (if false then
                            (if lastProxy[] <> none then
                                ('mvStack:lastProxy:',true,out[])
                                  -> lastProxy.dump;
                                ('mvStack:lastHolder:',true,out[])
                                  -> lastHolder.dump;
                        if)if);
                        thisObj[] -> thisStack[];
                        (if withDumps then 'mvStack:after:'->stacksToOut if);
                     // codes.setThisStack then
                        'setThisStack' -> exe;
                        (*('setThisStack:thisObj',true,screen[])  -> thisObj.dump;*)
                        (*StacksToOut;*)
                        thisObj.rTopElm -> thisStack[];
                        (*StacksToOut*)
                     // codes.rpopThisObj then
                        'rpopThisObj' -> exe;
                        (*stacksToOut;*)
                        thisObj.rpop -> thisObj[];
                        (*stacksToOut;*)
                     // codes.toSuper then
                        'toSuper' -> exe; op2 -> inx;
                        (*stacksToOut;*)
                        descs.OD[inx].bc[] -> thisCode[]; 
                        (if true then
                            thisCode.doE -> glsc;
                         else
                            thisCode.allocE -> glsc;
                        if);
                        (if mkRunTrace then ' glsc: '->out.puttext; glsc->out.putint if);
                     // codes.call then
                        doCall
                     // codes.susp then
                        '*** susp'-> exel;
                        thisStack.rpop -> callee[]; (* returnee *)
                        (if (suspendEnabled = 1) and (callee[] = enablee[]) then
                            (if testConc then
                                '\n***exlicit suspend of suspendee'->putline;
                            if);
                            suspendEnabled - 1 -> suspendEnabled
                        if);
                        (callee[], false) -> doSuspend
                     // codes.doExit then
                        'doExit' -> exe;
                        thisObj.rTopElm-> thisStack[];
                        (thisObj[],thisStack[],thisStack.myOrigin
                        ,thisCode.descInx,glsc)
                          -> doExitEvent;
                     // codes.rtn then
                        'rtn' -> exe; op1asChar -> inx; 
                        (if mkRunTrace then 'FROM:'->out.puttext; thisObj.myNameDI -> out.puttext if); 
                        (if (suspendEnabled = 1) and (thisObj[] = enablee[]) 
                            then
                            (if testConc then
                                'Returning fra enabledSuspend'->putline;
                            if);
                            suspendEnabled - 1 -> suspendEnabled
                        if);
                        (if withDumps then 'rtn:before' ->  stacksToOut if);
                        thisObj[] -> X[];
                        (if false then
                            thisObj.return -> (thisStack[],thisObj[])
                         else
                            thisObj.rpop -> thisStack[];
                            thisObj.rpop -> thisObj[]; 
                        if);
                        (if mkRunTrace then '\n   TO:'->out.puttext; thisObj.myNameDI->out.puttext if);
                        (if false then
                            ('rtn:thisObj',true,out[])  -> thisObj.dump;
                            ('rtn:thisStack',true,out[])  -> thisStack.dump;
                        if);
                        thisObj.restoreReturn -> (descInx,glsc); 
                        descs.OD[descInx].bc[] -> thisCode[]; 
                        descs.OD[descInx].isValueObj ->isValObj;
                        (if (inx = 'a')
                            or (inx = 'd')
                            or (inx = 'n') then
                            (* tricky: 'a', 'd', 'n' are for StdBeta
                             * for StdBeta we must push X, the returning object
                             *)
                            X[] -> thisStack.rpush; 
                        if);
                        (if inx // 'a' // 'D' // 'd' then
                            (if thisObj[] <> X[] then
                                (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc)
                                  -> rtnEvent
                            if);
                            allocLevel - 1 -> allocLevel
                        if);
                        (if withDumps then 'rtn:after' ->  stacksToOut if)
                     // codes.rtnV then
                        'rtnV' -> exe; 
                            thisObj[] -> X[];
                            thisObj.rpop -> thisStack[];
                            thisObj.rpop -> thisObj[];
                            (if mkRunTrace then 
                                ' to: ' -> out.puttext;
                               thisObj.myNameDI -> out.puttext;
                            if);
                            thisObj.restoreReturn -> (descInx,glsc);
                            descs.OD[descInx].bc[] -> thisCode[];
                            descs.OD[descInx].isValueObj ->isValObj;
                            (if inx // 'A' // 'D' then
                                (if thisObj[] <> X[] then
                                    (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;
                                if);
                                allocLevel - 1 -> allocLevel
                            if); 
                        (if withDumps then 
                           stacksToOut;
                           ('rtnV:',true,out[]) -> thisObj.dump;
                        if)
                     // codes.rtnEvent then 
                        'rtnEvent' -> exe; op1 -> inx;
                        (if thisObj.rstackIsEmpty then
                            '\n***rtnEvent : rstack empty'->out.putline
                        if);
                        (if newVM then
                            thisStack.rpop -> X[];  (* ??? *)
                         else
                            thisObj.rpop -> X[]; 
                        if);

                        (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;                        
                     // codes.allocEventQ then
                        'allocEventQ' -> exe; op1 -> isObj;
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc
                        ,asObjEnabled,false)
                          -> allocEvent;
                        false > asObjEnabled
                     // codes.rtnAlloc then
                        'rtnAlloc' -> exe; op1 -> isObj; 
                        (*stacksToOut;*)
                        (# SOD,X: ^objDesc;  (*X: ^objDesc.template;*)
                        do (if mkRunTrace then 
                               '\n\tthisObj: ' -> out.puttext; thisObj.myName -> out.puttext; 
                               ' thisObj.myDescInx: ' -> out.puttext; thisObj.myDescInx -> out.putint;
                               ' thisCode.descInx: ' -> out.puttext; thisCode.descInx -> out.putint;
                               ' glsc: ' -> out.puttext; glsc -> out.putint; 
                           if);
                           (thisObj.myObjDesc).superObjDesc[] -> SOD[];
                           thisObj.myObjDesc -> X[];
                           L:
                           (if SOD[] <> none then
                               (if mkRunTrace then  '\n\tsuper:descInx:'->out.puttext; SOD.descInx -> out.putint; if);
                               (if thisCode.descInx = SOD.descInx then
                                   (if mkRunTrace then 
                                       ' RTN:to:AllocE:sub: ' -> out.puttext;
                                       thisObj.myDescInx -> out.putint;
                                       ' from:'->out.puttext; thisCode.descInx->out.putint; ' ' -> out.put;
                                       SOD.descInx -> out.putint; ' ' -> out.put;
                                   if);
                                   (thisCode.descInx,glsc) -> thisObj.saveReturn;
                                   (if mkRunTrace then  ' allocE: ' -> out.puttext if);
                                   descs.OD[X.descInx].BC.enterE -> glsc;
                                   (if mkRunTrace then  glsc -> out.putint if); 
                                   descs.OD[X.descInx].bc[] -> thisCode[];
                                else
                                   SOD[] -> X[];
                                   SOD.superObjDesc[] -> SOD[];
                                   restart L
                               if)
                           if)
                        #);
                        (1->thisObj.rTopElm,thisObj[],thisObj.myOrigin,thisCode.descInx,glsc)
                          -> rtnAllocEvent;
                     // codes.doEventQ then
                        'doEventQ' -> exe;
                        (if withDumps then
                           (out[],'doEventQ: ') -> thisObj.dumpObjFull;
                        if);
                        (if false then
                            '**** doevent:'->puttext; thisObj.myNameDI->puttext;
                            ' visibility: '->puttext;
                            (thisObj.myObjDesc).OSDvisibility -> putint; 
                            newline;
                        if);
                        (if true or ((thisObj.myObjDesc).OSDvisibility = 0) then
                            (1->thisObj.rTopElm,thisObj[]
                            ,thisObj.myOrigin,thisCode.descInx,glsc
                            ,false(*wihEnablingSuspend*))
                              -> doEvent;
                        if)
                     // codes.rtnC then
                        'rtnC' -> exel;
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[]
                     // codes.rtnExit then 
                        (* could be rtn, except that thisStack is already updated
                         * apparently it is identical to rtn?
                         * Is no eliminated
                         *)
                        'rtnExit' -> exe;
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[]; (* !*)
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (*(thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;*)
                     // codes.innerx then
                        'inner' -> exel; op1 -> dinx;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx;
                        (if mkRunTrace then 
                            ' exe: ' -> out.puttext; descInx -> out.putint; out.newline; 
                        if);
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (if false then
                                '\ninnerx: ' -> puttext; thisCode.descInx -> putint;
                              ' ' -> put; glsc -> putint; newline;
                            if);
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if)
                     // codes.innerP then
                        'innerP' -> exel; op1 -> dinx; 
                        (if mkRunTrace then ' exe: ' -> out.puttext if);
                        thisStack.rpop -> X[];
                        thisObj[] -> X.rpush;
                        X[] -> thisObj[];
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx;
                        (if mkRunTrace then descInx -> out.putint; out.newline if); 
                        (if withDumps then 'innerP:before:'->stacksToOut if);
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (if mkRunTrace then  
                               '\n   innerP: ' -> out.puttext; 
                               thisCode.descInx -> out.putint;
                               ' ' -> out.put; glsc -> out.putint; out.newline;
                           if);
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if);
                       // codes.innera then
                        'innerA' -> exe; op1 -> dinx; 
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx;
                        (if mkRunTrace then ' exe:' -> out.puttext; descInx -> out.putint;  if);
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.enterE -> glsc;
                            (if mkRunTrace then ' glsc: ' -> out.puttext; glsc -> out.putint if)
                        if);
                     // codes.innerExit then
                        'innerExit' -> exe; op1 -> dinx; 
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx;
                        (if mkRunTrace then ' exe: ' -> out.puttext; descInx -> out.putint; ' ' -> out.put if);
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.exitE -> glsc
                        if)
                     // codes.rtnInner then
                        'rtnInner' -> exe;
                        thisObj.restoreReturn -> (descInx,glsc);
                        (if withDumps then 
                           ' to: ' -> out.puttext; descInx -> out.putint; 
                           ' glsc: ' -> out.puttext; glsc -> out.putint;
                        if);
                        descs.OD[descInx].BC[] -> thisCode[];
                        (if withDumps then stacksToOut if);;
                     // codes.doSuper then
                        (* dosuper is the last instruction before rtn N 
                         * in the code for an enter part:
                         * enterN: ...
                         *         dosuper
                         *         rtn N
                         * For this reason we do not save thisObj and thisStack
                         * on the stack. 
                         * This implies that rtn N from the topmost descriptor
                         * returns to the object calling the main-part enter.
                         * We thus do not fall back through a chain of rtn N.
                         * However, it should work pushing thisObj/stack
                         * but it does not
                         * And: saveReturn below fills up lscStack
                         * SaveReturn should be not be done
                         *)
                        'doSuper' -> exel; (* perhaps just a jump? *)
                        op2 -> descInx;
                        (*'doSuper: ' -> puttext; descInx -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        (* thisObj shall not be pushed since we return from super *)
                        descs.OD[descInx].bc[] -> thisCode[]; 
                        descs.OD[descInx].BC.enterE -> glsc;
                     // codes.stop then
                        'stop' -> exe;
                        (if verbose then
                            '\n\nNo of objects: ' -> puttext; 
                            descs.ObjPool.id -> putint; 
                            ' total size: '->puttext;
                            descs.objPool.size -> putint; newline;
                        if);
                        true -> doTerminate
                     // codes.prim then
                        '%prim' -> exe;
                        (if op1
                         // prim.put then 
                            thisStack.vpop -> value -> putCh; 
                            (if mkRunTrace then value -> out.putint; ' ' -> out.put; value -> out.put if);
                            ('put',thisStack[],thisCode.descInx,glsc,1) -> popEvent
                         // prim.get then
                            getCh -> thisStack.vPush;
                            (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                              -> vPushEvent
                         // 3 then
                            thisStack.rpop -> R[];
                            1 -> R.get -> thisStack.vpush; 
                         // 4 then
                            thisStack.rpop -> R[];
                            (thisStack.vpop,1) -> R.assign
                         // 5 then (* range *)
                            thisStack.rpop -> R[];
                             (if withDumps then  ('pushRange',true,out[]) -> R.dump if);
                            2 -> R.get -> thisStack.vpush;
                            (if withDumps then stacksToOut if)
                         // prim.sendMsg then 
                            thisObj.rpop -> X[];
                            (*(':sendMgs:text',true,screen[]) -> X.dump;*)
                            thisObj.vpop -> msgId;
                            thisObj.vpop -> handle;
                            thisObj.vpop -> serverId;
                            (serverId,handle,msgId,X[]) -> sendMsg;
                         // prim.attach then
                            (if mkRunTrace then ' attach: '-> out.puttext if); 
                            thisObj.vpop -> value; 
                            (if mkRunTrace then value -> out.putint; ' '-> out.put if);
                            (if withDumps then stacksToOut if);
                            ('attach',thisStack[],thisCode.descInx,glsc,1) 
                              -> popEvent;
                            (*(if suspendEnabled then
                                '\n***ERROR: attach suspendEnabled = true'->putline
                            if);*)
                            suspendEnabled + 1 -> suspendEnabled; 
                            value -> timeToSuspend;
                            glsc - 1 -> glsc; (* hack since doCall assumes
                                               * a call op and thereby lsc++
                                               *)
                            true -> doCall (* requires 'D' argument *)
                         // prim.disable then 
                           (* (if not suspendEnabled then
                                '\n***ERROR: disable suspendEnabled = false'->putline
                            if);*)
                            suspendEnabled - 1 -> suspendEnabled
                         // prim.enable then
                            (*(if suspendEnabled then
                                '\n***ERROR:enable suspendEnabled = true'->putline
                            if);*)
                            suspendEnabled + 1 -> suspendEnabled
                         // prim.asString then
                            ConvertIndexedToString
                         // prim.file_open_prim then
                            thisStack.rpop -> X[];
                            (X[]) -> files.open -> thisStack.vpush
                         // prim.file_get_prim then
                            thisStack.vpop -> files.get -> thisStack.vpush
                         // prim.file_eof_prim then
                            thisStack.vpop -> files.eof -> thisStack.vpush
                         // prim.file_close_prim then
                            thisstack.vpop -> files.close
                         // prim.log_prim then
                            thisStack.fpop -> float1;
                            (if mkRunTrace then float1 -> out.putReal; ' -> ' -> out.puttext if);
                            float1 -> log -> float1 -> thisStack.fpush;
                            (if mkRunTrace then float1 -> out.putReal if)
                         // prim.sqrt_prim then
                            thisStack.fpop -> float1;
                            (if mkRunTrace then float1 -> out.putReal; ' -> ' -> out.puttext if);
                            float1 -> sqrt -> float1 -> thisStack.fpush;
                            (if mkRunTrace then float1 -> out.putReal if)  
                         // prim.cbrt_prim then
                            thisStack.fpop -> float1;
                            (if mkRunTrace then float1 -> out.putReal; ' -> ' -> out.puttext; if);
                            float1 -> sqrt (*cbrt - gives a linker error *)
                              -> float1 -> thisStack.fpush;
                            (if mkRunTrace then float1 -> out.putReal  if)    
                         // prim.printf_prim then
                            thisStack.fpop -> float1;
                            (if mkRunTrace then 
                                float1 -> out.putReal; ' -> ' -> out.puttext;
                            if);
                            float1 -> putReal(#do 10->width; exp->style; 6->precision; true->upCase #);
                            0 -> thisStack.vpush
                         // prim.floatToString_prim then
                            thisStack.fpop -> float1;
                            (if mkRunTrace then float1 -> out.putReal; ' -> ' -> out.puttext if);
                            (# T: ^Text
                            do float1 -> realASText -> T[];
                               T.length -> QallocTextObject
                               (# i: @integer
                               do i + 1 -> i -> T.inxGet -> ch 
                               #)
                            #)
                         // prim.dumpObj_prim then
                            objSnap
                        if)
                     // codes.prim2 then
                        'prim2'->exe; 
                        (if op1
                         // prim.putWord_prim then
                              ' putWord '->out.puttext; op1 -> off; 
                             (*'*** do putWord: '->puttext;*)
                             thisStack.vPop -> value;
                             thisStack.vPop;
                             thisStack.vPop -> inx;
                             thisStack.rPop -> X[];
                             ' value:'->out.puttext; value -> out.putint; ' ' ->put;
                             ' inx:'->out.puttext; inx -> out.putint; out.newline;
                             (value,off) -> X.fields[inx].%putShort
                         // prim.putLong_prim then
                            ' putLong '->out.puttext; op1 -> off; 
                             (*'\n*** do putLong: '->puttext;*)
                             thisStack.vPop -> value;
                             thisStack.vPop;
                             thisStack.vPop -> inx;
                             thisStack.rPop -> X[];
                             ' value:'->out.puttext; value -> out.putint; ' ' ->out.put;
                             ' inx:'->out.puttext; inx -> out.putint; out.newline;
                             (if false then
                                 ' off: '->puttext; off -> putint;
                                 ' inx:'->puttext; inx -> putint; 
                                 ' value:'->puttext; value -> putint; ' ' ->put; newline;
                                 (* the next ones do not work!?*)
                                 (value,off) -> X.fields[inx].%putLong;
                                 (value,off) -> float1.%putLong;
                                 '>> float1: '->puttext; float1 ->putReal; newline;
                                 (value) %putLongAt(@@float2 + off * 4);
                             if);
                             (value) %putLongAt(@@X.fields[inx] + off * 4);
                             (if false then
                                '>> float2: '->puttext; float2 ->putReal; newline;
                                float1 -> puthex; newline
                             if)
                         else
                            '\n!!!! Illegal argument for bytecode prim2: '->puttext;
                            newline
                        if);
                     // codes.jmp then
                        'jmp' -> exe; op2 -> glsc
                     // codes.jmpFalse then
                        'jmpFalse' -> exe;
                        thisStack.vpop -> top1;
                        (if mkRunTrace then '(' -> out.put; top1 -> out.putint; ')' -> out.put if);
                        (if  top1 = 0 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        (if withDumps then stacksToOut if);;
                        ('jmpFalse',thisStack[],thisCode.descInx,glsc,1) -> popEvent
                     // codes.jmpTrue then
                        'jmpTrue' -> exe;
                        (if thisStack.vpop <> 0 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpTrue',thisStack[],thisCode.descInx,glsc,1) 
                          -> popEvent
                     // codes.jmpGT then
                        'jmpGT' -> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if top2 > top1 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpGT',thisStack[],thisCode.descInx,glsc,2) 
                          -> popEvent
                     // codes.break then
                        'break' -> exe;
                        op1 -> on;
                        op2 -> lab;
                        op2 -> descInx;
                        op1 -> pn;
                        (on,lab,descInx,pn) -> doBreak
                     // codes.pushText then
                        'pushText' -> exe; op1 -> inx; 
                        (if thisValObjDesc[] <> none then
                           thisValObjDesc.literals[inx] -> QallocTextObject
                                (# i: @integer
                                do i + 1 -> i;
                                   thisValObjDesc.literals[inx+i]-> ch;
                                   (if mkRunTrace then ch -> out.put if)
                                #) -> X[]
                         else
                            (thisObj.myObjDesc).literals[inx] -> QallocTextObject
                                (# i: @integer
                                do i + 1 -> i; 
                                   (thisObj.myObjDesc).literals[inx+i] -> ch;
                                   (if mkRunTrace then ch -> out.put if)
                                #) -> X[]
                        if) 
                     // codes.plus then
                        '+'-> exe; 
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if mkRunTrace then top2 -> out.putint; ' ' -> out.put; top1 -> out.putint if);
                        top1 + top2 -> thisStack.vpush;
                        ('+',thisStack[],thisCode.descInx,glsc,thisStack.vTopElm) -> binOpEvent
                     // codes.minus then
                        '-'-> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           (if mkRunTrace then  r -> out.putint; ' ' -> out.put; l -> out.putint if);
                           r - l -> thisStack.vpush  
                        #);
                        ('-',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent
                     // codes.uminus then
                        'u-' -> exe;
                        - thisstack.vpop -> thisStack.vpush;  
                        ('-',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> unOpEvent
                     // codes.mult then
                        '*'-> exe;
                        thisStack.vpop * thisStack.vpop -> thisStack.vpush;
                        ('*',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent
                     // codes.modd then
                        'mod' -> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           (if mkRunTrace then r -> out.putint; ' mod '->out.puttext; l->out.putint if);
                           r mod l -> l -> thisStack.vpush;
                           (if mkRunTrace then ' -> ' -> out.puttext; l->out.putint if);
                           ('mod',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                             -> binOpEvent
                        #);
                     // codes.idiv then
                        'idiv' -> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r div l -> thisStack.vpush;
                           ('div',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                             -> binOpEvent
                        #);
                     // codes.eq then
                        '='-> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        (if mkRunTrace then top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if top1 = top2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('=',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent
                     // codes.ne then
                        '<>'-> exe;
                        (if thisStack.vpop <> thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('<>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) 
                          -> binOpEvent
                     // codes.req then
                        '=[]'-> exe;
                        (if thisStack.rpop = thisStack.rpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (* ('=',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.rne then
                        '<>[]'-> exe;
                        (if thisStack.rpop <> thisStack.rpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*('<>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.seq then
                        '=##'-> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> Y[];
                        (if ((1-> X.get) = (1 -> Y.get))
                            and ((2 -> X.rget) = (2 -> Y.rget)) then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (* ('=',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.sne then
                        '<>##'-> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> Y[];
                        (if true then
                            (if ((1 -> X.get) <> (1 -> Y.get))
                                or ((2 -> X.rget) <> (2 -> Y.rget)) then
                                1 -> thisStack.vpush
                             else
                                0 -> thisStack.vpush
                            if);
                         else
                            (if (X.fields[1] <> Y.fields[1]) 
                                or ((2 -> X.rget) <> (2 -> Y.rget)) then
                                1 -> thisStack.vpush
                             else
                                0 -> thisStack.vpush
                            if);
                        if);
                        (*('<>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.lt then
                        '<'-> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        (if mkRunTrace then
                            top2 -> out.putint; ' lt ' -> out.puttext;top1 -> out.putint
                        if);
                        (if top2 < top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*(if thisStack.vpop > thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);*)
                        ('<',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.le then
                        '<='-> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if mkRunTrace then  
                            top2 -> out.putint;  ' le '-> out.puttext;
                            top1 -> out.putint;  ' '-> out.put;
                        if);
                        (if top2 <= top1 then 
                            1 -> thisStack.vpush;
                            (if mkRunTrace then  'T' -> out.put if);
                         else
                            0 -> thisStack.vpush;
                            (if mkRunTrace then  'F' -> out.put if);
                        if)
                     // codes.gt then
                        '>' -> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        (if mkRunTrace then  top2 -> out.putint; '>' -> out.put; top1 -> out.putint if);
                        (if top2 > top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('>',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent
                     // codes.ge then
                        '>='-> exe;
                        (if thisStack.vpop <= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('>=',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm)
                          -> binOpEvent
                     // codes.andd then
                        'and' -> exe;
                        (if withDumps then stacksToOut if);;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if mkRunTrace then  top2 -> out.putint; '&' -> out.put; top1 -> out.putint if);
                        (if (top2 = 1) and (top1 = 1) then
                            1 -> thisStack.vpush;
                            (if mkRunTrace then  'T' -> out.put if)
                         else
                            0 -> thisStack.vpush;
                           (if mkRunTrace then 'F' -> out.put if)
                        if);
                        (if withDumps then stacksToOut if);;                        
                        ('and',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent
                     // codes.orr then
                        'or' -> exe;
                        (if withDumps then stacksToOut if);
                        
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if mkRunTrace then  top2 -> out.putint; '|' -> out.put; top1 -> out.putint if);
                        (if (top2 = 1) or (top1 = 1 ) then
                            1 -> thisStack.vpush;
                            (if mkRunTrace then  'T' -> out.put  if)                          
                         else
                            0 -> thisStack.vpush;
                            (if mkRunTrace then  'F' -> out.put if)
                        if);
                        ('or',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent
                     // codes.nott then
                        'not' -> exe;
                        (if thisStack.vpop = 0 then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.fplus then
                        'fplus'-> exe; 
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        (if mkRunTrace then 
                            float1 -> out.putreal; ' ' -> out.put;
                            float2 -> out.putreal;
                        if);
                        float1 + float2 -> float1;
                        float1 -> thisStack.fpush;
                        ('fplus',thisStack[],thisCode.descInx,glsc,float1)
                          -> fBinOpEvent                        
                     // codes.fminus then
                        'fminus' -> exe;
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        (if mkRunTrace then 
                            float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal;
                        if);
                        (if false then
                            '*** fminus: ' -> puttext;
                            float1 -> putreal; ' ' -> put; 
                            float2 -> putReal; ' ' -> put;
                        if);
                        float1 - float2 -> float1;
                        float1 -> thisStack.fpush; 
                        ('fminus',thisStack[],thisCode.descInx,glsc,float1)
                          -> fBinOpEvent 
                     // codes.fUnaryMinus then
                        'fUnaryMinus' -> exe;
                        - thisStack.fpop -> thisStack.fpush;
                        ('-',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm)
                          -> unOpEvent
                     // codes.fmult then
                        'fmult' -> exe;
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        (if mkRunTrace then 
                            float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal;
                        if);
                        float1 * float2 -> float1;
                        float1 -> thisStack.fpush;
                         ('fmult',thisStack[],thisCode.descInx,glsc,float1)
                          -> fBinOpEvent 
                     // codes.fdiv then
                        'fdiv' -> exe;
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        
                        (if mkRunTrace then float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal if);
                        (if false then
                            '*** fdiv: ' -> puttext;
                            float1 -> putreal; ' ' -> put; 
                            float2 -> putReal; ' ' -> put;
                        if);
                        float1 / float2 -> float1;
                        float1 -> thisStack.fpush;
                        ('fdiv',thisStack[],thisCode.descInx,glsc,float1)
                          -> fBinOpEvent                          
                     // codes.fexp then
                        'fexp'-> exe;
                        thisStack.vpop -> top1;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then float1 -> out.putreal; ',' -> out.put; top1 -> out.putint if); 
                        float1 -> float2;
                        (if top1 > 0 then
                            (for i: top1 - 1 repeat
                                 float2 * float1 -> float2
                            for)
                         else                            
                            (for i: -top1 - 1 repeat
                                 float2 * float1 -> float2
                            for);
                            1 / float2 -> float2;
                        if);
                        float2 -> thisStack.fpush;
                        ('fexp',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.feq then
                        'feq'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if float1 = float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('feq',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent          
                     // codes.flt then
                        'flt'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if float1 < float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('flt',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) -> binOpEvent             
                     // codes.fle then
                        'fle'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if float1 <= float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fle',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent                                     
                     // codes.fgt then
                        'fgt'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if float1 > float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fgt',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm) 
                          -> binOpEvent             
                     // codes.fge then
                        'fge'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if float1 >= float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fge',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) 
                          -> binOpEvent                                     
                     // codes.fne then
                        'fne'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        (if mkRunTrace then  top1 -> out.putint; ',' -> out.put; top2 -> out.putint if);
                        (if float1 <> float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fne',thisStack[],thisCode.descInx,glsc,thisStack.vtopElm)
                          -> binOpEvent                                     
                     // codes.pushFloatConst then
                        (#  L1,L2: @integer
                        do 'pushFloatConst' -> exe; op8 -> (float1,L1,L2);
                           (if mkRunTrace then float1 -> out.putreal; out.newline if);
                           L1 -> thisStack.vpush;
                           L2 -> thisStack.vpush;
                           (thisObj[],X[],true,thisStack[],off,false,0
                           ,thisCode.descInx,glsc,float1) -> fPushEvent
                        #)
                     // codes.i2f then
                        'i2f' -> exe;
                        thisStack.vpop -> thisStack.fpush
                     // codes.f2i then
                        'f2i' -> exe;  
                        thisStack.fpop -> thisStack.vpush
                     // codes.saveBETAworld then
                        'saveBETAworld' -> exe; 
                        op2 -> descInx;
                        (1,thisStack.rpop) -> eventProcessor.rput;  
                        1 -> eventProcessor.rget -> world[];
                        (if descInx > 0 then
                            '**** alloc betaenv'->putline;
                            (if false then
                                ('thisObj',true,out[]) -> thisObj.dump;
                                ('thisStack',true,out[]) -> thisObj.dump;
                                out.newline;
                            if);
                            (none(*origin*),descInx,true) -> alloc;
                            (if withDumps then  ('betaenv',true,out[]) -> thisObj.dump if) ;
                            thisObj[] -> betaenvObj[];
                            (*thisObj[] -> thisStack.rPush;*)
                            '\n   before:doCall:'->out.putline;
                            (*doCall;
                            '\nafter:doCall:'->out.putline;
                            thisObj.rpop; ( * pop origin = none * )
                            thisObj.rpop -> thisStack[];
                            thisObj.rpop -> thisObj[];*)
                            (if withDumps then  ('BetaWorld',true,out[]) -> thisObj.dump if);
                            (*'   end saveBetaWorld'->out.putline*)
                        if)
                     // codes.pushBetaenvObj then
                        'pushBetaenvObj'->exel;
                        betaenvObj[] -> thisStack.rpush
                     // codes.saveStringOrigin then
                        'saveStringOrigin' -> exe;
                        thisObj[] -> stringOrigin[]
                     // codes.mkStrucRef then
                        'mkStrucRef' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> descInx;
                        (* ('mkStrucRef',true,screen[]) -> X.dump;*)
                        (X[],descinx,false) -> mkStrucRefObj
                     // codes.mkObjStrucRef then
                        'mkObjStrucRef' -> exe;
                        thisStack.rpop -> X[]; (* the object *)
                        (X.myOrigin,X.myDescInx,false) -> mkStrucRefObj
                     // codes.mkVirtualStrucRef then
                        'mkVirtualStrucRef' -> exe;
                        (thisObj.rpop,op1,true) -> mkStrucRefObj
                     // codes.allocFromStrucRefObj then
                        'allocFromStrucRefObj' -> exe;
                        thisStack.rpop -> allocFromStrucRefObj
                     // codes.nop then
                        'nop' -> exe; op1
                     else
                        5 -> fatalError
                        (#
                        do ' Op-code: ' -> M.puttext; 
                           thisCode.B[glsc] -> M.putint;
                           M.newline;
                           M[] -> putline;
                           thisCode.B[glsc] -> out.putint; glsc+1 -> glsc;
                        #);
                        leave loop
                    if);
                    (if stopErrors[] = none then
                        (if (glsc <= thisCode.top) and not doTerminate then
                            restart Loop 
                    if)if);

                    false -> isRunning;
                    (if (runMode = run_Beta_INT) and runJavaServices then 
                        closeJavaServices 
                    if);
                    done; (* Used to be in closeJavaServices 
                           * - but conflicting with fatalError *)
                    (* 'suspend'->putline;*)
                    suspend;
                    (* 'reactivate betaVM'->putline;*)
                    false -> doTerminate;
                    (if handleEvent then 
                        restart Loop 
                     else
                        restart main
                    if)
                 #);
               (* '**** End of betaVM'->putline;*)
               done
            #)
       #)
  #)
