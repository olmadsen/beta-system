ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE 'objectImage';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'Primitives';
INCLUDE 'interpreterAPI'
INCLUDE '../miniServices/Service';
BUILD nti 'interpreter_c.obj' 'interpreter_c.c' 'c:/cygwin/bin/gcc -c -o $0 $1'
      linux 'interpreter_c.obj' 'interpreter_c.c' '$CC -c -pthread -o $0 $1'
      default 'interpreter_c.obj' 'dummyinterpreter_c.c' '$CC -c -o $0 dummyinterpreter_c.c';
---systemlib:attributes---
Run_BETA_INT: (# exit 0 #);
Run_C_INT: (# exit 1 #);
Save_BC_image: (# exit 3 #);

event: data
  (# type: @integer;
     caller,thisObj,org: @integer;
     isObj: @integer;
     descNo: @integer;
     bcPos: @integer;
  #);
Sleep: external(# milliSec: @int64 enter milliSec do CallC #);
init_interpreter: external
  (# bc,imageS: @integer; E: ^event
  enter(bc,imageS)
  do callC
  exit E[]
  #);
run_interpreter: external
  (# isXB: @boolean; E: ^event
  enter isXB
  do callC
  exit  E[]
  #);
getEvent: external
  (# first: @boolean; E: ^event
  enter first
  do callC
  exit E[]
  #);
close_interpreter: external(# do callC #);

betaVM:
  (#ready: @boolean;
     testConc: (# exit false #);
     init:<
       (# stdPath: ^text
       enter(runMode,isXbeta)
       do (if (runMode = Run_BETA_INT) and runJavaServices then
              BetaLib -> stdPath[];
              '/MiniSystem/miniServices/' -> stdPath.append;
              ('FileService'-> (stdPath.copy).Append,5123) -> FS.init;
              ('GUIService' -> (stdPath.copy).Append,5124) -> GS.init;
              5125 -> MS.openSocket;
              '*** Java services initialized' -> putline;
          if);
	  true -> ready;
          false -> guiProgram;
       #);
     putCh:< (# ch: @char enter ch do inner #);
     getCh:< (# ch: @char do inner exit ch #);
     (* Note! There is no common super for all VMevents
      * And there is no trace for valueEvent opEvent, etc.
      *)
     VMevent: 
       (# caller,thisObj,org: ^ObjDesc.runTimeObject; 
          descNo,bcPos: @integer;
          doPause: (# do (if false then pause else suspend if)#);
          trace: (# exit false #);
          event:< (# tx: ^text do inner exit tx[] #);
          mkTrace:
            (# dump:
                 (# msg: ^text; obj: ^ObjDesc.runTimeObject
                 enter(msg[],obj[])
                 do msg[] -> T.puttext; '"' -> T.put;
                    L:
                      (if obj[]  <> none then
                          obj.myName -> T.puttext; 
                          (if obj.isObj then '/O' -> T.puttext if);
                          '"' -> T.puttext; ',' -> T.put;
                          obj.myOrigin -> obj[];
                          restart L
                      if)
                 #);
               T: @text
            do '\nVMevent: ' -> T.puttext; event -> T.puttext; 
               (' caller: ',caller[]) -> dump;
               (' this: ',thisObj[]) -> dump;
               (' org: ',org[]) -> dump;
               '"' -> T.put; 
               ' bcPos: ' -> T.puttext; bcPos -> T.putint;
               (*T.newline;*)
            exit T[]
            #)
       enter(caller[],thisObj[],org[],descNo,bcPos)
       do (if thisObj[] <> none then 
              (if trace then
                  mkTrace -> out.puttext;
              if);
              inner;
             (* thisObj.myDescInx -> out.putint; ' '-> out.put;
              thisObj.id -> out.putint; out.newline*)
          if)
       #);
     set:< (# do inner #); (* ad hoc *)

     startEvent:< VMevent(# event:: (# do 'start'->tx[] #) do inner #);
     allocLevel: @integer; (* Note used? *)
     allocEvent:< VMevent
       (# isObj,isIndexed: @boolean;
          event:: (# do 'alloc'->tx[] #);
       enter(isObj,isIndexed) 
       do inner;              
          allocLevel + 1 -> allocLevel; 
       #);
     doEvent:< VMevent
       (# event:: (# do 'do'->tx[] #);
          preemptive: @boolean;
       enter preemptive
       do (*(thisCode.descInx,glsc) -> thisObj.saveReturn;*)
          inner ;
          (* thisObj.restoreReturn (* we just pop the stack *)
       #);
     doExitEvent:< VMevent
       (# event:: (# do 'doExit'->tx[] #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     rtnEvent:< VMevent
       (# event:: (# do 'rtn'->tx[] #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     resumeEvent:< VMevent
       (# event:: (# do 'resume' -> tx[] #);
          preemptive: @boolean;
       enter preemptive
       do inner;
       #);
     suspendEvent:< VMevent
       (# event::(#do 'suspend' -> tx[] #);
          preemptive: @boolean;
       enter preemptive
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     breakEvent:<  VMevent(# event::(#do 'break'-> tx[] #) do inner #);
     valueEvent:
       (# event:< (# tx: ^text do inner exit tx[] #);
          caller,from,to: ^ObjDesc.template; 
          popRstack: @boolean; 
          off: @integer;
          isIndexed: @boolean;
          inx,descNo,bcPos: @integer;
          doPause: (# do suspend #);
          trace: (# exit true #);
          mkTrace:
            (# T: ^Text
            do (*'\nvalueEvent' -> T[]*)
            exit T[]
            #);
       enter(caller[],from[],popRstack,to[],off,isIndexed,inx,descNo,bcPos)
       do (descNo,bcPos) (*(thisCode.descInx,glsc)*) -> caller.saveReturn;
          (if trace then mkTrace -> out.puttext if);
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     pushEvent: valueEvent
       (* from: an object/activation where the value is loaded from
        * to: a stack in the form of an object
        *)
       (# 
       do
          inner
       #);
     vPushEvent:< pushEvent
       (# event::(#do 'vPush'-> tx[] #);
          value: @integer
       enter value
       do inner
       #);
     rPushEvent:< pushEvent
       (# event::(#do 'rPush'-> tx[] #);
          refValue: ^ObjDesc.template
       enter refValue[]
       do inner
       #);
     storeEvent: valueEvent
       (* from: a stack in the form of an object
        * to: an object/activation where the value is stored
        *)
       (# 
       do 
          inner
       #);
     vStoreEvent:< storeEvent
       (# value: @integer
       enter value
       do inner
       #);
     rStoreEvent:< storeEvent
       (# event::(#do 'rStore'-> tx[] #);
          refValue: ^ObjDesc.template
       enter refValue[]
       do inner
       #);
     opEvent:
       (# event:< (# tx: ^text do inner exit tx[] #);
          operator: ^text; to: ^ObjDesc.template; 
          value,descNo,bcPos: @integer
       enter(operator[],to[],value,descNo,bcPos)
       do (thisCode.descInx,glsc) -> to.saveReturn;
          inner;
          to.restoreReturn (* we just pop the stack *)
       #);
     binOpEvent:< opEvent(# event::(#do 'binOP'-> tx[] #) do inner #);
     unOpEvent:< opEvent(# event::(#do 'unOP'-> tx[] #) do inner #);
     jmpGTevent:< opEvent(# event::(#do 'jmpGT'-> tx[] #) do inner #);
     popEvent:< opEvent(# event::(#do 'pop'-> tx[] #) do inner #);
     
     errorEvent:< 
       (# thisObj: ^ObjDesc.template; bcPos: @integer; msg: ^text
       enter(thisObj[],bcPos,msg[])
       do (thisCode.descInx,glsc) -> thisObj.saveReturn;
          inner;
          thisObj.restoreReturn (* we just pop the stack *)
       #);
     
     done:< (# do inner #);
     
     thisModule, (* not used? *)
     thisObj,
     thisStack,
     eventProcessor: ^ObjDesc.template;
     
     runJavaServices, (* Java services does not wok on Linux, so we don't start then *)
     
     isXbeta: @boolean;
     
     runMode: @integer;
     
     guiProgram: @boolean;
     
     thisCode: ^ByteCode; 
     
     glsc: @integer;
     
     codes: @ ByteCodes;
     
     prim: @Primitives;
     
     fatalError:
       (# errNo: @integer; M: @text
       enter errNo
       do errNo -> thisObj.fatalError
          (#
          do (if (runMode = run_BETA_INT) and runJavaServices then closeJavaServices if);
             'LSC: ' -> msg.puttext; glsc -> msg.putint; msg.newline;
             inner fatalError;
             M[] -> msg.puttext;
             (thisObj[],glsc,msg[]) -> errorEvent;
          #)
       #);
     
     closeJavaServices:
       (#
       do (if not guiProgram then
              (if FS.trace then '\nFS.close'->putline if);
              FS.close; 
              (if MS.trace then 'MS.close'->putline if);
              false ->  MS.close;
              (if GS.trace then 'GS.close'->putline if);
              GS.close;
              mouseListener[] -> kill;
              '\n\n*** Closed all Java services ' -> putline;
          if);
       #);
     
     out: ^Stream;
     
     FS,GS,MS: @Service;
     mouseListener:  @ | system
       (# T: ^text
       do (if MS.trace or true then 
              (*  'Starting mouseListener:'->putline *)
          if);
          cycle
          (# event,noOfClicks,handle: @integer
          do MS.receive -> T[];
             (*'mouseListener: ' -> puttext; T[] -> putline;*)
             T.setPos;
             T.getInt -> handle;
             T.getint -> event;             
             (if GS.trace then
                 'BETA:event:handle: ' -> puttext; handle -> putint;             
                 (if event
                  // 1 then
                     ' mouseClicked:'->puttext;
                     T.getint -> noOfClicks -> putint;                
                  // 2 then
                     'BETA:Mouse exited' -> putline
             if)if);

             T[] -> execute.selectEventProcessor;
             (* store handle/object in 1 -> thisStack.rstore *)
             execute[] -> fork;
             pause;
             (* 'mouseListener reactivated'->putline*)
          #);
          
          (if MS.trace or true then 'BETA:mouse: ' -> puttext; T[] -> putline if);
       #);
     
     reActivate: (# do (if true then execute else execute[] -> fork if) #);
     
     execute: @ | system
       (# saveBCimage:
            (* Saves the byte code image on file FN..bc with execution *)
            (# mainDescInx: @integer; FN: ^text
            enter(mainDescInx,FN[])
            do (mainDescInx,(FN[],'..bc') -> mkAuxName) -> descs.serialize;
            #);
          init:
            (# RTT: @File;
            enter(descs[],descInx,FN[],runMode)
            do (if (runMode = run_BETA_INT) and runJavaServices then 
                   mouseListener[] -> fork 
               if);
               (if runMode <> save_BC_Image then
                   (FN[],'..run') -> mkAuxName -> RTT.name;
                   RTT.openWrite;
                   RTT[] -> out[];
               if);
               pause;                
            #);
          selectEventProcessor:
            (# eventSpec: ^text; D: ^objDesc
            enter eventSpec[]
            do eventProcessor[] -> thisModule[] -> thisObj[] -> thisStack[];
               thisObj.myObjDesc -> D[];
               (* '\n===='->putline;
                (thisObj.myObjDesc).literals[1] -> putint; newline;
                eventSpec.length -> putint; newline;
                (eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min -> putint; 
                * newline;
                (for i: D.literals[1] repeat 
                (thisObj.myObjDesc).literals[1+i] -> put; ' ' -> put
                for); newline;*)
               
               (if eventSpec.length > (thisObj.myObjDesc).literals[1] then 
                   '\n\n**** eventSpec too large: "'->puttext;
                   eventSpec[] -> puttext; '"' -> put
               if);

               (for i:((eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min) repeat
                    i -> eventSpec.inxGet -> (thisObj.myObjDesc).literals[1 + i];
                    (* '<'->put;  i -> eventSpec.inxGet -> put; '>'->put;
                     (thisObj.myObjDesc).literals[1 + i] -> put*)
               for);

               descs.OD[descInx + 1 ].bc[] -> thisCode[];
               newId -> thisObj.id;
               descInx -> thisObj.myDescInx;
               true -> handleEvent;
               1 -> gLsc;
            #);               
          decodeEvent:
            (# E: ^event; T: @text; obj: ^objDesc.cTemplate;
               caller,thisObj,org: ^objDesc.cTemplate;
            enter E[]
            do (if E[] <> none then
                   (*'Event: ' -> puttext; E.type -> putint;*)
                   (* ','->put; E.caller -> putint; ','->put;*)
                   (if (1 <= E.type) and (E.type < 18) then  
                       E.caller -> descs.cObjCache.get -> caller[];
                       E.thisObj -> descs.cObjCache.get -> thisObj[];
                       E.org -> descs.cObjCache.get -> org[];
                   if);
                   caller[] -> obj[];
                   (* 'cObj: ' -> puttext; 
                    loop:
                    (if obj[]<> none then 
                    obj.myName -> puttext; ' ' -> put;
                    obj.objId -> putint;
                    obj.myOrigin -> obj[];
                    restart loop
                    if);
                    newline;*)
                   (if E.type 
                    // 0 then (*skip*)
                    // 1 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> startEvent
                    // 2 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1,E.isObj=1,false) -> allocEvent
                    // 3 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1,false) -> doEvent
                    // 4 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> doExitEvent
                    // 5 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> rtnEvent
                    // 18 then (* stop *)
                    else
                       '\n\n*** Event not catched: ' -> puttext;
                       E.type -> putint; newline;
                       stop
                   if);
               if);
               (*newline*)
            exit E.type  <> 18
            #);
          handleEvent: @boolean;
          descs: ^RuntimeDescriptors;
          descInx: @integer;
          isObj: @integer;
          newid: @ (# id: @integer do id + 1 -> id exit id #);
          obj: ^ObjDesc.Template;
          root: ^ObjDesc.Template;
          world: ^ObjDesc.Template;
          
          break:
            (# descNo,bcPos: @integer
            enter(descNo,bcPos)
            do 'VM:breakIn: ' -> puttext; descNo -> putint; 
               ' at: ' -> puttext; bcPos -> putint; newline;
               (*'OD.range: ' -> puttext; descs.OD.range -> putint; newline;*)
               
               (if descs[]=none then ' descs i none???'->putline;if);
               (if descs.OD[descNo][] = none then
                   'bc none ' -> putline
                else 
                   bcPos -> descs.OD[descNo].bc.setBreak
               if)
            #);
          
          sendMsg:
            (# serverId,handle,msgId: @integer; msg: ^objDesc.template; 
               T: @text
            enter(serverId,handle,msgId,msg[])
            do (if FS.trace then
                   'SendMsg: serverId=' -> puttext; serverId->putint; 
                   ' handle=' -> puttext; handle -> putint; 
                   ' msgId='-> puttext; msgId -> putint; ' vields[1]=' -> puttext; 
                   msg.vfields[1] -> putint;
               if);
               (for i: msg.vfields[1] repeat
                    msg.vfields[i+2] -> T.put; 
               for);
               (if FS.trace then
                   ' msg="'->puttext; T[] -> puttext;  '"'->put; newline;
               if);
               (if serverId
                // 1 then
                   (handle,msgId,T[]) -> sendFileMsg
                // 2 then
                   (handle,msgId,T[]) -> sendGuiMsg
               if)
            #);
          doReceive: (# exit true #);
          sendFileMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if FS.trace then 'sendFileMsg: '-> puttext; if);
               (if msgId
                // 1 then 
                   1 -> FS.mkCommand(#do msg[] -> cmd.puttext #);
                   (if doReceive then
                       FS.receive -> h[];
                       (1,h.length-1) -> h.sub -> h[];
                       0 -> h.setpos; h.getint -> thisStack.vPush
                    else
                       1 -> thisStack.vpush
                   if)
                // 2 then
                   2 -> FS.mkCommand(#do handle -> cmd.putint; ' '  -> cmd.put;
                                       msg[] -> cmd.puttext
                                    #);
                   (if doReceive then FS.receive -> h[] if)
                // 3 then
                   3 -> FS.mkCommand(# do handle -> cmd.putint; #);
                   (if doReceive then FS.receive -> h[] if)
               if);
            #);
          sendGuiMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if GS.trace then
                   'sendGuiMsg: '-> puttext; msgId->putint; ' ' -> put;
                   '"' -> put;  msg[] -> puttext; '"' -> put; newline;
               if);
               (if not guiProgram then
                   '**** GUI program' -> putline;
                   true -> guiProgram; 
               if);
               (if msgId
                // 1 then
                   1->GS.mkCommand(# do msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (if GS.trace then 'BETA:received: ' -> puttext; h[] -> putline; if);
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush;
                // 2 // 5 // 6 then
                   msgId ->GS.mkCommand(# do handle -> cmd.putint; 
                                          ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                   
                // 3 then
                   3->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 4 // 7 // 8 // 10 then
                   msgId -> GS.mkCommand
                   (# do handle -> cmd.putint; ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 9 then
                   msgId -> GS.mkCommand(# do handle -> cmd.putint; 
                                           ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];  
                   h.length 
                     -> mkTextObject(# i: @integer do i + 1 -> i -> h.inxGet -> ch #);
                   (* -> thisStack.rpush;*)
               if);
               (if GS.trace then
                   'betaVM:received: ' -> puttext; h[] -> putline;
               if)
            #);
          mkTextObject:
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do 
               (if descs.OD[descs.textDescNo][] = none then
                   'descs.OD[descs.textDescNo][] = none'->putline
               if);
               (length+1+100,3,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               newId -> X.id;
               descs.textDescNo -> X.myDescInx;
               true -> X.isObj;
               (if world[] = none then
                   'world[] = none '->putline
               if);
               (if (3 -> world.rget) = none then
                   (*world.rfields[3][] = none then*)
                   'world.rfields[3][] = none' -> putline
               if);
               (if true then
                   (1,(3 -> world.rget)) -> X.rput
                else
                   world.rfields[3][] -> X.rfields[1][]; 
               if);
                   (* seems to be a hack 
                    * 3 = LIB = origin *)
               length -> X.vfields[1]; (* pos *)
               length + 100 -> X.vfields[2]; (* range *)
               (for i: length  repeat
                    inner;
                    ch -> X.vfields[i + 2];
                    (* ('mkTextObject',true,screen[]) -> X.dump*)
               for);   
            exit X[]
            #);
          XmkTextObject:
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do 
               (if descs.OD[descs.textDescNo][] = none then
                   'descs.OD[descs.textDescNo][] = none'->putline
               if);
               (length+1,1,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               newId -> X.id;
               descs.textDescNo -> X.myDescInx;
               true -> X.isObj;
               (if world[] = none then
                   'world[] = none '->putline
               if);
               (if (3 -> world.rget) = none then
                   (*world.rfields[3][] = none then*)
                   'world.rfields[3][] = none' -> putline
               if);
               (if true then
                   (1, (3 -> world.rget)) -> X.rput
                else
                   world.rfields[3][] -> X.rfields[1][]
               if);
               (* seems to be a hack 
                * 3 = LIB = origin *)
               length -> X.vfields[1]; (* pos *)
               (*length + 100 -> X.vfields[2];  range *)
               (for i: length  repeat
                    inner;
                    ch -> X.vfields[i + 1];
               for);   
               ('XmkTextObject',true,out[]) -> X.dump               
            exit X[]
            #);    
          ConvertIndexedToString:
            (# X,Y: ^ObjDesc.template; length: @integer
            do thisStack.rpop -> X[];
               X.vfields[1] -> length;
               (* X.vfields[1] = length = range
                * X.vfields[2] = indexed[1]
                * ...
                * X.vfields[length + 1] = indexed[length]
                *)
               (* ('Indexed',true,screen[]) -> X.dump;*)
               L:
                 cycle
                 (#
                 do (if X.vfields[length + 1] = 0 then 
                        length - 1 -> length
                     else
                        leave L
                 if)#);
               (length+1,1,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> Y[] 
                 -> thisStack.rpush;
               (if true then
                   (1,(3 -> world.rget)) -> Y.rput(* origin - hack *)
                else
                   world.rfields[3][] -> Y.rfields[1][]; (* origin - hack *)
               if);
               length -> Y.vfields[1];
               (for i: length repeat
                    X.vfields[i + 1] -> Y.vfields[i + 1]
               for);
               (*('String',true,screen[]) -> X.dump;*)
            #);
          
          mkStrucRefObj:
            (# origin,X: ^ObjDesc.template; 
               inx: @integer;
               isVirtual: @boolean
            enter(origin[],inx,isVirtual)
            do (* the generation below is clumsy
                * currently template is made for textDesc
                * clean-up
                *)
               (* ('mkVirtualStrucRef',true,screen[]) -> origin.dump;
                * 'strucrefDescNo:'->puttext; 
                * descs.structureRefDescNo -> putint; newline;
                *)
               (0,1,0) -> descs.OD[descs.structureRefDescNo].template -> X[];
               (if true then
                   2 -> X.rnew
                else
                   2 -> X.rfields.new
               if);
               (if isVirtual then
                   (origin.myObjDesc).vdtTable[inx] -> inx
               if);
               inx -> X.vfields[1];
               (if true then
                   (2,origin[]) -> X.rput
                else
                   origin[] -> X.rfields[2][]
               if);
               (* ('StrucRefObj',true,screen[]) -> X.dump;*)
               X[] -> thisStack.rpush;
            #);
          allocTemplate:
            (# descNo,vInxSize,rInxSize: @integer; isObj: @boolean;
               obj: ^objDesc.template
            enter(descNo,isObj,vInxSize,rInxSize)
            do &descs.OD[descNo].template[] -> obj[];
               descNo -> obj.myDescInx;
               newId -> obj.id;
               isObj -> obj.isObj;
               descs.OD[descNo].OSDvisibility -> obj.OSDvisibility; 
            exit obj[]
            #);
          alloc:
            (# origin,callee,Y: ^objDesc.template; descNo: @integer; 
               isObj: @boolean
            enter(origin[],descNo,isObj)
            do (*'Alloc: ' -> puttext; descNo -> putint; newline;*)
               (descNo,isObj,0,0) -> allocTemplate -> callee[];
               (* '\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                * ' lsc: ' -> puttext; glsc -> putint; newline; *)
               callee.myId -> out.puttext; 
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descNo].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> thisStack[] -> thisObj[];
               (if origin[] = root[] then
                   (* Perhaps just handled by saveBETAworld? *)
                   callee[] -> world[];
               if);
               (Y[],thisObj[],origin[],descNo,glsc,isObj,false) -> allocEvent;
            #);
          invoke:
            (# callee,Y: ^objDesc.template; descNo,staticOff: @integer; 
               asObj: @boolean
            enter(descNo,staticOff,asObj)
            do (*'Invoke: ' -> puttext; descNo -> putint; newline;*)
               (if descs.OD[descNo][] = none then
                   'descs.OD[descNo][] = none, descNo='->puttext;
                   descNo -> putint; newline
               if);
               (descNo,asObj,0,0) -> allocTemplate -> callee[];
               (if staticOff > 0 then
                   (if true then
                       (staticOff,callee[]) -> thisObj.rput
                    else
                       callee[] -> thisObj.rfields[staticOff][]
                   if)
               if);
               (*'\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                *' lsc: ' -> puttext; glsc -> putint; newline;*)
               callee.myId -> out.puttext; 
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descNo].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               (*origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> (*thisStack[] -> *) thisObj[];
               (* (if origin[] = root[] then
                   callee[] -> world[];
               if);*)
               (* OBS! We may need origin for minienv!
                * And perhaps the same for asObj
                *)
               (*(Y[],thisObj[],(*origin[],* )none,descNo,glsc,asObj,false) 
                                 -> allocEvent;*)
               asObj -> asObjEnabled;
               (* '\nInvoke: ' -> puttext;
                thisObj.myName -> puttext;
                (if asObjEnabled then ' asObjEnabled'->puttext if)*)
            #);
          AllocIndexed:
            (# callee,Y: ^objDesc.template;
               origin: ^objDesc.template;
               descInx,isObj,dinx,rangee,isRindexed: @integer
            enter(origin[],descInx,isObj,dinx,rangee,isRindexed)
            do (*(if isRindexed  = 1 then 'isRindexed' -> putline if);
                rangee -> putint; ' ' -> put;
                dinx -> putint; ' ' -> put;
                descinx -> putint; newline;
                *)
               
               (rangee,dinx,isRindexed) -> descs.OD[descInx].template -> callee[];
               
               descs.OD[descInx].OSDvisibility -> callee.OSDvisibility;
               descInx -> callee.myDescInx;
               newId -> callee.id;
               
               (*'\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                ' lsc: ' -> puttext; glsc -> putint; newline;*)
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descInx].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               (if not isXbeta then
                   origin[] -> callee.rpush;  (* origin *)
               if);
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> (* thisStack[] ->*) thisObj[];
               (if not isXbeta then
                   thisObj[] -> thisStack[]
               if);
               (if isObj = 1 then 
                   true -> thisObj.isObj;
                   true -> asObjEnabled
               if);
               (if not isXbeta then
                   (Y[],thisObj[],origin[],descInx,glsc,isObj=1,true)
                     -> allocEvent
               if);               
            #);
          AllocQ_Indexed:
            (# callee,Y: ^objDesc.template;
               origin: ^objDesc.template;
               descInx,isObj,dinx,rangee,isRindexed: @integer
            enter(origin[],descInx,isObj,dinx,rangee,isRindexed)
            do (rangee,dinx,isRindexed) -> descs.OD[descInx].template -> callee[];
               descs.OD[descInx].OSDvisibility -> callee.OSDvisibility;
               descInx -> callee.myDescInx;
               newId -> callee.id;               
               callee[] -> thisStack.rPush;
               ('AllocQ_indexed:',true,out[]) -> callee.dump;
            #);
          
          asObjEnabled: @boolean;
          
          allocFromStrucRefObj:
            (# X: ^objDesc.template
            enter X[]
            do (*('AllocFromStrucRefObj',true,screen[]) -> X.dump;*)
               (* We need to handle isObj *)
               (2 -> X.rget,X.vfields[1],true) -> alloc
               (*(X.rfields[2][],X.vfields[1],true) -> alloc*)
            #);
          doBreak:
            (# on,lab,actualDescInx,descInx,xlsc,V: @integer; X,Y: ^objDesc.template;
               trace: (# exit false #)
            enter(on,lab,actualDescInx)
            do (if trace then
                   'BREAK:----------------------------' -> putline;
                   ('Break:thisObj',true,screen[]) -> thisObj.dump;
                   ('Break:thisStack',true,screen[]) -> thisStack.dump;
               if);
               thisObj[] -> X[];
               (for i: on repeat
                    X.myOrigin -> X[]
               for);
               (if trace then ('Break:to',true,screen[]) -> X.dump if);
               (* We need to test for none if the stack does not contain X
                * Same  for traversing super
                *)
               popCallStack:
                 (if thisObj[] <> X[] then 
                     thisObj[] -> Y[];
                     thisObj.rpop -> thisStack[];
                     thisObj.rpop -> thisObj[];
                     (if trace then 
                         ('Break:pop',true,screen[]) -> thisObj.dump;
                         ('Break:pop:stack',true,screen[]) -> thisStack.dump;
                     if);
                     (thisObj[],Y[],Y.myOrigin,0,0) -> rtnEvent;
                     restart popCallStack
                 if);
               (if trace then
                   ('Break:pop',true,screen[]) -> thisObj.dump
               if);
               thisObj.restoreReturn -> (descInx,xlsc);
               (if trace then
                   '\nbreakTo:descInx: ' -> puttext; descInx -> putint;
                   ' xlsc: ' -> puttext; xlsc -> putint;
               if);
               findActualSuper:
                 (if descInx <> actualDescInx then
                     (* break is to a ptn level in the super chain *)
                     thisObj.restoreReturn -> (descInx,glsc);
                     thisObj.rpop -> thisObj[];
                     restart findActualSuper
                 if);
               descs.OD[descInx].bc[] -> thisCode[];
               descs.OD[descInx].labs[lab] -> glsc;
               (if trace then
                   ' glsc: ' -> puttext; glsc -> putint; newline;
               if)
            #);
          dumpD: 
            (#
            do 'descs:' -> putline;
               (for i: descs.OD.range repeat
                    i -> putint; ':' -> put; 
                    (if descs.OD[i][] = none then ' none' -> putline if);
               for);
               newline
            #);
          isRunning,doTerminate: @Boolean;
          terminate: (# do true -> doTerminate #);
          FN: ^text; 
       (*enter(descs[],descInx,out[],FN[])*)
       do (if runMode = save_BC_Image then
              'SAVING BYTE CODE IMAGE - main desc: ' -> puttext; 
              descInx -> putint; newline;
              (descInx,FN[]) -> saveBCimage;
              STOP
          if);
          main:
            (# suspendEnabled: @integer;
               timeToSuspend: @integer;
               enablee: ^ObjDesc.template;
               first: @boolean
            do true -> isRunning; (*screen[] -> out[];*)
               false -> doTerminate;
               (if descs.OD[1][] = none then (* not used any more*)
                   'Allocating dummy template in OD[1] for repetitions'
                     -> putline;
                   &ObjDesc[] -> descs.OD[1][];
                   ('ValueRep',1,0,out[],descs[]) -> descs.OD[1].init;
               if);
               (for i: descs.OD.range repeat 
                    (* most OD's are not in use since code is onlut generated
                     * for modules in use. 
                     *)
                    (if descs.OD[i][] <> none then
                        out[] -> descs.OD[i].out[]
                    if)
               for);
               (descInx,true,0,0) 
                 -> allocTemplate -> thisModule[] -> thisObj[] -> thisStack[];
               descs.OD[descInx].bc[] -> thisCode[];

               (* dangerous to assume descInx + 1 *)
               (descInx + 1, true,0,0) -> allocTemplate -> eventProcessor[];

               '**** EXECUTE: ' -> puttext; descs.OD[descInx].name[] -> puttext;
               ' descInx: ' -> puttext; descInx -> putint; 
               ' ****\n\n' -> puttext;
               
               pause; (* apparently we need 2 pause to be sure that 
                       * mouseListener has been started before the VM suspends
                       *)
               1 -> glsc;
               thisObj[] -> root[];
               (if runMode
                // run_C_INT then
                   (# BC,imageSize: @integer
                   do
                      '*** C interpreter - main desc: '->puttext; 
                      descInx -> putint;
                      (descInx,none) -> descs.serialize
                      (#
                      do BI.top -> imageSize;
                         ', imageSize: ' -> puttext; imageSize -> putint;
                      newline;                         
                      #) -> BC;
                      (BC,imageSize) -> init_interpreter;
                      isXbeta -> run_interpreter;
                      true -> first;
                      L: (if first -> getEvent -> decodeEvent then
                             false -> first;
                             restart L                            
                         if);
                      close_interpreter;
                      '\n\n***** end of C interpreter\n' -> puttext;
                      stop; (*suspend;*)
                   #)
               if);
               (none,thisObj[],none,thisCode.descInx,glsc) -> startEvent;
               Loop:
                 (# doCall:
                      (# withEnablingSuspend: @boolean
                      enter withEnablingSuspend
                      do '\n** doCall: ' -> out.puttext;
                         thisCode.B[glsc] -> out.putint; ' ' -> out.put;
                         thisCode.B[glsc + 1] -> out.putint; ' ' -> out.put;
                         'call'-> exel; op1asChar -> inx; 
                         inx -> out.putint; 
                         
                         (* ('call',true,out[])  -> thisObj.dump;*)
                         thisStack.rpop -> callee[];
                         (if callee[] = none then 
                             6 -> fatalError(#do leave loop #)
                         if);                         
                         callee.myId -> out.puttext;
                         (if withEnablingSuspend then
                             callee[] -> enablee[]
                         if);

                         (thisCode.descInx,glsc) -> thisObj.saveReturn;

                         (if callee.rstackIsEmpty then 
                             ':first ' -> out.puttext;
                             inx -> out.put; ' ' -> out.put; 
                             inx -> out.putint; out.newline;
                             (*(':first>',true,out[])  -> thisObj.dump;
                             (':first>stack',true,out[])  -> thisStack.dump;*)
                             thisObj[] -> Y[] -> callee.rpush;
                             thisStack[] -> callee.rpush;
                             callee[] -> thisObj[];
                             thisObj.myCode -> thisCode[];
                             thisObj.mySuperCode -> thisCode[];
                             (if inx
                              // 'N' then 
                                 thisObj.myCode -> thisCode[];
                                 thisCode.enterE -> glsc
                              // 'D' then 
                                 thisCode.doE -> glsc;
                                
                                 (Y[],thisObj[],thisObj.myOrigin,0,glsc, withEnablingSuspend)
                                   -> doEvent  
                              // 'X' then
                                 thisCode.exitE -> glsc
                              else
                                 ' ? ' -> out.puttext; inx -> out.put
                             if);
                          else (* resume *) ':resume:' -> out.puttext;
                             (if inx
                              // 'N' then
                                 (*(':resume:N:',true,screen[]) -> callee.dump;*)
                                 thisObj[] -> Y[] -> callee.rpush; 
                                 thisStack[] -> callee.rpush;
                                 callee[] -> thisObj[]; 
                                 thisObj.myCode -> thisCode[]; 
                                 (*thisObj.mySuperCode -> thisCode[]; *)
                                 thisCode.enterE -> glsc; 
                              // 'X' then
                                 (':coroutine:exit',false,out[]) -> thisObj.dump;
                                 thisObj[] -> Y[] -> callee.rpush;
                                 thisStack[] -> callee.rpush;
                                 callee[] -> thisObj[];
                                 thisObj.myCode -> thisCode[];
                                 thisObj.mySuperCode -> thisCode[];
                                 thisCode.exitE -> glsc
                              else
                                 (':resume:',true,out[]) -> callee.dump;
                                 (thisObj[],callee[],callee.myOrigin,0,glsc,withEnablingSuspend) -> resumeEvent;
                                 (thisObj[],thisStack[]) -> callee.rswap -> (thisObj[],thisStack[]);
                                 (':resume:ThisObj:',true,out[]) -> thisobj.dump;
                                 (if thisStack[] <> thisObj[] then
                                     '\n*** resume: thisObj<>thisStack'->out.puttext;
                                     ('thisObj',true,out[])  -> thisObj.dump;
                                     ('stack',true,out[])  -> thisStack.dump;
                                 if);
                                 thisObj.restoreReturn -> (descInx,glsc);
                                 descs.OD[descInx].bc[] -> thisCode[];   
                                 thisObj.lsc -> glsc; 
                                 (* 'descInx: ' -> puttext; descInx -> putint;
                                  * ' glsc: ' -> puttext; glsc -> putint; newline*)
                             if)
                         if);
                      #);
                    doSuspend:
                      (# callee: ^objDesc.template; dump: @boolean;
		         preemptive: @boolean;
                      enter (callee[], preemptive)
                      do callee.myId -> out.puttext;
                         stacksToOut;
                         (*('suspend',true,out[]) -> callee.dump;*)
                         glsc -> thisObj.lsc; (* why is saveReturn not enough? *)
                         (if (thisObj[] <> thisStack[]) then
                             '\n\n**** external suspend: thisObj<>thisStack'->out.putline;
                             ('doSuspend>',true,out[])  -> thisObj.dump;
                             ('stack',true,out[])  -> thisStack.dump;
                             true -> dump;
                         if); 
                         ('doSuspend>',true,out[])  -> thisObj.dump;
                         ('stack',true,out[])  -> thisStack.dump;
                         (thisCode.descInx,glsc) -> thisObj.saveReturn;
                         (thisObj[],thisStack[]) -> callee.rswap -> (thisObj[],thisStack[]);
                         (if (thisObj[] <> thisStack[]) then
                             '\n\n**** external suspend:return: thisObj<>thisStack'->out.putline
                         if);
                         (*('doSuspend>',true,out[])  -> thisObj.dump;
                          ('doSuspend>stack',true,out[])  -> thisStack.dump;*)
                         thisObj.restoreReturn -> (descInx,glsc);
                         descs.OD[descInx].bc[] -> thisCode[];
                         callee[] -> thisStack.rpush;
                         (if false then
                             ('newThisObj>',true,out[])  -> thisObj.dump;
                             ('newStack',true,out[])  -> thisStack.dump;
                         if);
                         (* ('suspend',true,screen[]) -> X.dump;*)
                         stacksToOut;
                         (thisObj[],callee[],thisObj.myOrigin,thisCode.descInx,glsc, preemptive) 
                           -> suspendEvent;                         
                      #);
                    exe: 
                      (# T: ^text ; F: ^file
                      enter T[] 
                      do inner;
                         out.newline; glsc -> out.putint;':' -> out.put;
                         T[] -> out.puttext; ' '-> out.put; glsc+1 -> glsc; 
                         (if out## = File## then
                             out[] -> F[]; F.flush
                         if)
                      #);
                    exel: exe(# do out.newline #);
                    op1: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.putint; ' ' -> out.put; 
                         glsc+1 -> glsc
                      exit arg
                      #);
                    op1asChar: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.put; ' ' -> out.put; 
                         glsc+1 -> glsc
                      exit arg 
                      #);
                    op2: 
                      (# arg: @integer
                      do thisCode.B[glsc] * 256 + thisCode.B[glsc+1] -> arg -> out.putint; ' ' -> out.put; 
                         glsc + 2 -> glsc
                      exit arg
                      #);
                    rStackElmToOut:
                      (# obj: ^ObjDesc.template;
                      enter obj[]
                      do '[' -> out.put;
                         (for i: obj.rtop repeat
                              (if  obj.rstack[i][] <> none then
                                  obj.rstack[i].myName -> out.puttext
                               else 
                                  'none' -> out.puttext
                              if);
                              (if i < obj.rtop then ',' -> out.put if)
                         for);
                         ']' -> out.put;
                         '[' -> out.put;
                         (for i: obj.vtop repeat
                              obj.vstack[i] -> out.putint;
                              (if i < obj.vtop then ',' -> out.put if)
                         for);
                         ']' -> out.put;                         
                      #);
                    StacksToOut:
                      (#
                      do '\nthisObj   = ' -> out.puttext; 
                         thisObj.myName -> out.puttext;
                         thisObj[] -> rStackElmToOut;
                         '\nthisStack = ' -> out.puttext; 
                         thisStack.myName -> out.puttext;
                         thisStack[] -> rStackElmToOut;
                      #);
                    VtoOut:
                      (# obj: ^ObjDesc.template; off,val: @integer
                      enter(obj[],off,val)
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                        '=' -> out.put; val -> out.putint;
                      #);
                    RtoOut:
                      (# obj,Ref: ^ObjDesc.template; off,val: @integer
                      enter(obj[],off,Ref[])
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                         '=' -> out.put; 
                         (if Ref[] = none then
                             'none' -> out.puttext
                          else
                             ref.myName -> out.puttext
                         if)
                      #);
                    descInx,isRindexed,dinx,rangee,inx,length,serverId
                    ,handle,msgId,rtnVal, off, value,on,lab:
                      @integer;
                    hasRtnVal: @boolean;
                    callee,X,Y,rtnRef: ^ObjDesc.template;
                    R: ^ObjDesc.Template;
                    top1,top2: @integer
                 do (if glsc -> thisCode.isBreak then
                        (thisObj.myDyn,thisObj[],thisObj.myOrigin,0,glsc) 
                          -> breakEvent
                    if);
                    (if suspendEnabled = 1 then
                        timeToSuspend - 1 -> timeToSuspend;
                        (if (timeToSuspend <= 0) (*and (allocLevel = 0)*) then
                            (*'allocLevel: ' -> puttext; allocLevel -> putint;
                             * newline;*)
                            (if testConc then
                                '\n**** external suspend: ' -> putline;
                            if);
                            '\n**** external suspend:enablee ' -> out.puttext;
                            (if enablee[] <> none then
                                enablee.myId -> out.puttext;
                                (*('thisObj',true,out[]) -> thisObj.dump;*)
                                suspendEnabled - 1 -> suspendEnabled;
                                (enablee[], true) -> doSuspend;
                                none -> enablee[]
                             else
                                (* either a compile error
                                 * or disable/eanble used without attach having been called
                                 *)
                                'none ' -> out.puttext;
                            if)
                        if)
                    if);

                    (if thisCode.B[glsc]
                     // codes.pushc then
                        'pushc' -> exe;
                        op1 -> thisStack.vpush;
                        
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.pushNone then
                        'pushNone' -> exe;
                        none -> thisstack.rpush;
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,none)
                          -> rPushEvent
                     // codes.pushc2 then
                        'pushc2' -> exe;
                        op2 -> thisStack.vpush; 
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.pushthis then
                        'pushthis' -> exe;
                        thisObj[] -> thisStack.rpush;
                        StacksToOut;
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisObj[])
                          -> rPushEvent
                     // codes.push then
                        'push' -> exe;
                        thisObj.vfields[op1->off] -> thisStack.vpush;
                        (thisObj[],thisObj[],false,thisStack[],off,false,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.rpush then
                        'rpush' -> exe;
                        (if true then
                            op1 -> off -> thisObj.rget -> X[];
                         else
                            thisObj.rfields[op1->off][] -> X[];
                        if);
                        ' ' -> out.put; thisObj.myName -> out.puttext;
                        '.R[' -> out.puttext; off -> out.putint; ']' -> out.put;
                        '='->out.put; 
                        (if X[] = none then 
                            'none' -> out.puttext
                         else
                            X.myName -> out.puttext;
                        if);
                        X[] -> thisStack.rpush;

                        (thisObj[],thisObj[],false,thisStack[],off,false,thisCode.descInx,glsc,0,thisStack.rTopElm) 
                          -> rPushEvent
                     // codes.pushg then
                        'pushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError(#do leave loop #) if);
                        X.vfields[op1 -> off] -> top1 -> thisStack.vpush;
                        (X[],off,top1) -> VtoOut;
                        (thisObj[],X[],true,thisStack[],off,false,0,thisCode.descInx,glsc,thisStack.vTopElm) -> vPushEvent
                     // codes.rpushg then
                        'rpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        (*('rpushg:',true,screen[]) -> X.dump;*)
                        (if X[] = none then
                            3 -> fatalError(#do leave loop #)
                        if);
                        (if true then
                            off -> X.rget -> Y[]
                         else
                            X.rfields[off][] -> Y[];
                        if);
                        Y[]-> thisStack.rpush;
                        (X[],off,Y[]) -> RtoOut;
                        (thisObj[],X[],true,thisStack[],off,false,0,thisCode.descInx,glsc,thisStack.rTopElm) 
                          -> rPushEvent
                     // codes.xpush then
                        'xpush' -> exe;
                        (*  thisStack.rpop -> X[]; - not used *)
                        op1 -> off;
                        thisStack.vpop -> inx;
                        off + inx 
                          -> thisObj.get 
                          -> thisStack.vpush;
                        (* '\nxpush: off: ' -> puttext; off -> putint;
                         ' inx: ' -> puttext; inx -> putint; newline;*)
                        
                        (thisObj[],thisObj[],false,thisStack[],off,true,inx,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent
                     // codes.xrpush then
                        'xrpush' -> exe;
                        op1 -> off;
                        thisStack.vpop -> inx;
                        (if true then
                            off + inx -> thisObj.rget -> X[]
                         else
                            thisObj.rfields[off + inx][] -> X[];
                        if);
                        X[] -> thisStack.rpush;
                        (thisObj[],thisObj[],false,thisStack[],off,true,inx,thisCode.descInx,glsc,thisStack.rTopElm)
                          -> rPushEvent
                     // codes.xpushg then
                        'xpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        thisStack.vpop -> inx;
                        X[] -> R[];
                        (*'inx: ' -> puttext; inx -> putint; newline;*)
                        (*('xpushg:',true,screen[]) -> X.dump;*)
                        off + inx 
                          -> R.get 
                          -> value
                          -> thisStack.vpush;
                        (*'\nxpushg: off: ' -> puttext; off -> putint;
                         ' inx: ' -> puttext; inx -> putint; newline;*)
                        (R[],off + inx,value) -> VtoOut;
                        ('xpushg:',true,out[]) -> R.dump;
                        (thisObj[],R[],true,thisStack[],off,true,inx,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent  
                        
                        // codes.xrpushg then
                        'xrpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        thisStack.vpop -> inx;
                        X[] -> R[];
                        (*'inx: ' -> puttext; inx -> putint; newline;*)
                        (*('xpushg:',true,screen[]) -> X.dump;*)
                        (if true then
                            off + inx -> R.rget -> thisStack.rpush
                         else
                            R.rfields[off + inx][] -> thisStack.rpush
                        if);
                        (thisObj[],R[],true,thisStack[],off,true,inx,thisCode.descInx,glsc,thisStack.rTopElm)
                          -> rPushEvent                      
                     // codes.rstore  then
                        'rstore' -> exe; 
                        op1->off;
                        thisStack.rpop -> X[]; (* if multiple assignment of X, 
                                                * violation error happens
                                                * compiler error?
                                                *)
                        (if X[] = none then
                            'none'->out.puttext
                         else
                            X.myName -> out.puttext
                        if);
                        '->' -> out.puttext;
                        thisObj.myName -> out.puttext;
                        '[' -> out.put; off -> out.putint; ']'-> out.put;
                        (if true then
                            (off,X[]) -> thisObj.rput
                         else
                            X[] -> thisObj.rfields[off][]; 
                        if);
                        (thisObj[],thisStack[],false,thisObj[],off,false,0,thisCode.descInx,glsc,X[]) 
                          -> rStoreEvent
                     // codes.store  then
                        'store' -> exe;
                        (* ('store:thisStack:',true,screen[]) -> thisStack.dump;
                         * ('store:thisObj:',true,screen[]) -> thisObj.dump;
                         *)
                        thisStack.vpop -> value -> thisObj.vfields[op1 -> off];
                        value -> out.putint; '->' -> out.puttext;
                        thisObj.myName -> out.puttext; 
                        '[' -> out.put; off -> out.putint; ']' -> out.put;
                        (thisObj[],thisStack[],false,thisObj[],off,false,thisCode.descInx,glsc,0,value) 
                          -> vStoreEvent
                     // codes.storeg  then
                        'storeg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then
                            3 -> fatalError(#do leave loop #)
                        if);
                        thisStack.vpop -> value;
                        value -> X.vfields[op1->off];
                        (X[],off,value) -> VtoOut;
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,value) 
                          -> vStoreEvent
                     // codes.rstoreg  then
                        'rstoreg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then
                            3 -> fatalError(#do leave loop #)
                        if);
                        thisStack.rpop -> Y[];
                        (if true then
                            (op1 -> off,Y[]) -> X.rput
                         else
                            Y[] -> X.rfields[op1->off][];
                        if);
                        (X[],off,Y[]) -> rToOut;
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,Y[]) 
                          -> rStoreEvent
                     // codes.xstore then
                        'xstore' -> exe;
                        (*('xstoreA',true,screen[])  -> thisObj.dump;*)
                        (* thisStack.rpop -> X[]; - not used *)
                        op1 -> off;
                        thisStack.vpop -> inx;
                        (thisStack.vpop -> value,off + inx)
                          -> thisObj.assign;
                        ' ' -> out.put; value -> out.putint; 
                        '->' -> out.puttext; 
                        thisObj.myName -> out.puttext;
                        '.V[' -> out.puttext; 
                        off -> out.putint; '+' -> out.put;
                        inx -> out.putint; ']' -> out.put;
                        (*('xstoreB',true,screen[])  -> thisObj.dump;*)
                        (thisObj[],thisStack[],false,thisObj[],off,true,inx,thisCode.descInx,glsc,value) 
                          -> vStoreEvent 
                     // codes.xrstore then
                        'xrstore' -> exe;
                        op1 -> off;
                        thisStack.vpop -> inx;
                        thisStack.rpop -> X[];
                        (if true then
                            (off + inx, X[]) -> thisObj.rput
                         else
                            X[] -> thisObj.rfields[off + inx][]
                        if);
                        (thisObj[],thisStack[],false,thisObj[],off,true,inx,thisCode.descInx,glsc,value) 
                          -> vStoreEvent                        
                     // codes.xstoreg then
                        'xstoreg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        X[] -> R[];
                        thisStack.vpop -> inx;
                        (thisStack.vpop -> value,off + inx) -> R.assign;
                        (X[],off + inx,value) -> VtoOut;
                        ('xstoreg:',true,out[]) -> R.dump;
                        (thisObj[],thisStack[],true,R[],off,true,inx,thisCode.descInx,glsc,value) -> vStoreEvent
                        
                       // codes.xrstoreg then
                        'xrstoreg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        X[] -> R[];
                        thisStack.vpop -> inx;
                        thisStack.rpop -> Y[];
                        (if true then
                            (off + inx,Y[]) -> R.rput
                         else
                            Y[] -> R.rfields[off + inx][]
                        if);
                        (X[],off + inx,Y[]) -> RtoOut;
                        (thisObj[],thisStack[],true,R[],off,true,inx,thisCode.descInx,glsc,Y[]) -> rStoreEvent                      
                     // codes.double then
                        'double' -> exe;
                        thisStack.vdub;
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent
                     // codes.rdouble then
                        'rdouble' -> exe;
                        thisStack.rdub;
                        (thisObj[],thisObj[],false,thisStack[],off,false,0,thisCode.descInx,glsc,thisStack.rTopElm)              
                          -> rPushEvent
                     // codes.rpop then
                        'rpop' -> exe;
                        thisStack.rpop;
                     // codes.vpop then
                        'vpop'-> exe;
                        thisStack.vpop;
                     // codes.rswap then
                        'rswap' -> exe;
                        thisstack.rpop -> X[];
                        thisstack.rpop -> Y[];
                        X[] -> thisstack.rpush;
                        Y[] -> thisstack.rpush;
                     // codes.alloc then
                        'alloc' -> exel; op2 -> descInx; op1 -> isObj;
                        (* ('Alloc:',true,screen[]) -> thisObj.dump;*)
                        thisStack.rpop -> X[]; (* origin *)
                        (X[],descInx,isObj = 1) -> alloc;
                        StacksToOut;
                     // codes.invoke then
                        'invoke' -> exel; 
                        op2 -> descInx; op2 -> off; op1 -> isObj;
                        (* ('Alloc:',true,screen[]) -> thisObj.dump;*)
                        (descInx,off,isObj = 1 ) -> invoke;
                        StacksToOut;                          
                     // codes.allocIndexed then
                        'allocIndexed' -> exel; op2 -> descInx; op1 -> isObj;
                        (if not isXbeta then
                            thisStack.rpop -> X[]; (* origin *)
                         else (* a superflous thisObj is pushed by compiler
                               * should be eliminated
                               *)
                            thisStack.rpop -> X[]; (* origin *)
                        if);
                        thisStack.vpop -> dinx;
                        thisStack.vpop -> isRindexed;
                        thisStack.vpop -> rangee;
                        (if isXbeta then
                            (X[],descInx,isObj,dinx,rangee,isRindexed) 
                              -> AllocQ_Indexed
                         else
                            (X[],descInx,isObj,dinx,rangee,isRindexed) 
                              -> AllocIndexed
                        if)
                     // codes.exeAlloc then
                        'exeAlloc' -> exel; op2 -> descInx;
                        thisStack.rpop -> X[]; (* origin *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> thisObj.rPush; (* return *)
                        (* 30.08.2013: we changed the order of the next two 
                         * statements. The push used to be after the assigment.
                         * Is this correct?
                         *)
                        thisStack[] -> thisObj.rpush;
                        thisObj[] -> thisStack[]; 

                        X[] -> thisObj.rpush;

                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.allocE -> glsc;
                        (if false then
                            (* called if this object has a super
                             * reconsider if/when this is an event
                             * Also the isObject arg should be defined in the code
                             * is currentli 0 (zero)
                             *)
                            (thisObj[],thisObj[],X[],thisCode.descInx,glsc,false,false) -> allocEvent
                        if);
                        allocLevel + 1 -> allocLevel
                     // codes.newVrep then
                        'newVrep' -> exe;
                        (thisStack.vpop,2,0) 
                          -> descs.OD[1].template 
                          -> thisStack.rpush;
                     // codes.send then 
                        'send' -> exel; op1 -> descInx;
                        (if true then
                            (descInx,false,0,0) -> allocTemplate -> callee[];
                         else
                            &descs.OD[descInx].template[] -> callee[];
                            newId -> callee.id;
                            descInx -> callee.myDescInx;
                        if);
                        (* save return *)
                        '\nsend: ' -> puttext;
                        callee.myId -> puttext;
                         ' ' -> put; glsc -> putint; newline;
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> callee.rPush;
                        callee[] -> thisObj[];
                        descs.OD[descInx].BC.procE -> glsc
                     // codes.sendv then
                        StacksToOut;
                        'sendv ' -> exel;
                        op1 -> dinx;
                        thisObj.rpop -> X[]; 

                        (if X[] = none then 3 -> fatalError(#do leave loop #) if);
                        (* ('sendv:',true,screen[]) -> X.dump;*)
                        (*('sendv:',true,screen[]) -> thisObj.dump;*)
                        (X.myObjDesc).vdtTable[dinx] -> descInx; 
                        (* descInx -> out.putint; out.newline; *)
                        (if descInx = 0 then 8 -> fatalError(#do leave loop #) if);
                        (* copy of send below *)
                        (if true then
                            (descInx,false,0,0) -> allocTemplate -> callee[];
                         else
                            &descs.OD[descInx].template[] -> callee[];
                            newId -> callee.id;
                            descInx -> callee.myDescInx;
                        if);
                        callee.myId -> out.puttext; 
                        (* save return *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> Y[] -> callee.rPush;
                        thisStack[] -> callee.rPush;
                        (if isXbeta then
                            X[] -> thisStack.rpush;
                            callee[] -> thisObj[];
                         else
                            X[] -> callee.rpush;
                            callee[] -> thisStack[]  -> thisObj[];
                        if);
                        descs.OD[descInx].BC.allocE -> glsc;
                        (* we need to distinguish if we generate an object or
                         * an activation. For now we assume an activation
                         *)
                        StacksToOut;
                        (Y[],thisObj[],X[],thisCode.descInx,glsc,false,false) -> allocEvent
                     // codes.mvStack then
                        'mvStack'-> exe;
                        (*('mvstackA',true,screen[])  -> thisObj.dump;*)
                        thisObj[] -> thisStack[];
                        StacksToOut;
                        (*('mvstackB',true,screen[])  -> thisObj.dump;*)
                     // codes.setThisStack then
                        'setThisStack' -> exe;
                        (*('setThisStack:thisObj',true,screen[])  -> thisObj.dump;*)
                        thisObj.rTopElm -> thisStack[];
                        StacksToOut
                     // codes.rpopThisObj then
                        'rpopThisObj' -> exe;
                        thisObj.rpop -> thisObj[];
                     // codes.toSuper then
                        'toSuper' -> exe; op2 -> inx -> out.putint; 
                        descs.OD[inx].bc[] -> thisCode[]; 
                        thisCode.allocE -> glsc;
                        ' glsc: '->out.puttext; glsc->out.putint;
                     // codes.call then
                        doCall
                     // codes.susp then
                        '*** susp'-> exel;
                        thisStack.rpop -> callee[]; (* returnee *)
                        (if (suspendEnabled = 1) and (callee[] = enablee[]) then
                            (if testConc then
                                '\n***exlicit suspend of suspendee'->putline;
                            if);
                            suspendEnabled - 1 -> suspendEnabled
                        if);
                        (callee[], false) -> doSuspend
                     // codes.doExit then
                        'doExit' -> exe;
                        thisObj.rTopElm-> thisStack[];
                        (thisObj[],thisStack[],thisStack.myOrigin,thisCode.descInx,glsc)
                          -> doExitEvent;
                     // codes.rtn then
                        'rtn' -> exel; op1asChar -> inx; 
                        thisObj.myId -> out.puttext; 
                        (if (suspendEnabled = 1) and (thisObj[] = enablee[]) then
                            (if testConc then
                                'Returning fra enabledSuspend'->putline;
                            if);
                            suspendEnabled - 1 -> suspendEnabled
                        if);
                        thisObj[] -> X[];                         
                        thisObj.rpop -> thisStack[]; 
                        thisObj.rpop -> thisObj[]; 
                        ' to: ' -> out.puttext; 
                        thisObj.myId -> out.puttext; 
                        thisObj.restoreReturn -> (descInx,glsc); 
                        descs.OD[descInx].bc[] -> thisCode[]; 
                        (if not isXbeta then
                            X[] -> thisStack.rpush; 
                        if);
                        (if inx = 'A' then
                            (if thisObj[] <> X[] then
                                (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;
                            if);
                            allocLevel - 1 -> allocLevel
                        if);
                        stacksToOut
                     // codes.rtnEvent then
                        'rtnEvent' -> exe; op1 -> inx;
                        (if thisObj.rstackIsEmpty then
                            '\n***rtnEvent : rstack empty'->out.putline
                        if);
                        thisObj.rpop -> X[]; 
                        (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;                        
                     // codes.allocEventQ then
                        'allocEventQ' -> exe; op1 -> isObj;
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc,asObjEnabled,false)
                          -> allocEvent;
                        false > asObjEnabled
                     // codes.rtnEventQ then
                        'rtnEventQ' -> exe; op1 -> isObj; 
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc)
                          -> rtnEvent;
                     // codes.doEventQ then
                        'doEventQ' -> exe;
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc
                        ,false(*wihEnablingSuspend*))
                          -> doEvent;                        
                     // codes.rtnC then
                        'rtnC' -> exel;
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[]
                     // codes.rtnExit then 
                        (* could be rtn, except that thisStack is already updated
                         * apparently it is identical to rtn?
                         * Is no eliminated
                         *)
                        'rtnExit' -> exe;
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[]; (* !*)
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (*(thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;*)
                     // codes.innerx then
                        'inner' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (*'\ninner: ' -> puttext; thisCode.descInx -> putint;
                             ' ' -> put; glsc -> putint; newline;*)
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if)
                     // codes.innerP then
                        'inner P' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        thisStack.rpop -> X[];
                        thisObj[] -> X.rpush;
                        X[] -> thisObj[];
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (*'\ninner: ' -> puttext; thisCode.descInx -> putint;
                             ' ' -> put; glsc -> putint; newline;*)
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if)                        
                       // codes.innera then
                        'innerA' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.enterE -> glsc;
                            ' glsc: ' -> out.puttext; glsc -> out.putint
                        if);
                        out.newline; 
                     // codes.innerExit then
                        'innerExit' -> exe;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; ' ' -> out.put;
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.exitE -> glsc
                        if)
                     // codes.rtnInner then
                        'rtnInner' -> exel;
                        thisObj.restoreReturn -> (descInx,glsc);
                        (*'\nreturnInner: ' -> puttext;
                         descInx -> putint; ' ' -> put; glsc -> putint; newline;*)
                        ' to: ' -> out.puttext; descInx -> out.putint; 
                        ' glsc: ' -> out.puttext; glsc -> out.putint;
                        out.newline;
                        descs.OD[descInx].BC[] -> thisCode[]
                     // codes.doSuper then
                        (* dosuper is the last instruction before rtn N 
                         * in the code for an enter part:
                         * enterN: ...
                         *         dosuper
                         *         rtn N
                         * For this reason we do not save thisObj and thisStack
                         * on the stack. 
                         * This implies that rtn N from the topmost descriptor
                         * returns to the object calling the main-part enter.
                         * We thus do not fall back through a chain of rtn N.
                         * However, it should work pushing thisObj/stack
                         * but it does not
                         * And: saveReturn below fills up lscStack
                         * SaveReturn should be not be done
                         *)
                        'doSuper' -> exel; (* perhaps just a jump? *)
                        op2 -> descInx;
                        (*'doSuper: ' -> puttext; descInx -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        (* thisObj shall not be pushed since we return from super *)
                        descs.OD[descInx].bc[] -> thisCode[]; 
                        descs.OD[descInx].BC.enterE -> glsc;
                     // codes.stop then
                        'stop' -> exe; out.newline;
                        (* leave Loop*)
                        true -> doTerminate
                     // codes.prim then
                        '%prim' -> exe;
                        (if op1
                         // prim.put then 
                            thisStack.vpop -> value -> putCh; 
                            value -> out.putint; ' ' -> out.put;
                            value -> out.put;
                            ('put',thisStack[],1,thisCode.descInx,glsc) -> popEvent
                         // prim.get then
                            getCh -> thisStack.vPush;
                            (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                              -> vPushEvent
                         // 3 then
                            thisStack.rpop -> R[];
                            1 -> R.get -> thisStack.vpush; 
                         // 4 then
                            thisStack.rpop -> R[];
                            (thisStack.vpop,1) -> R.assign
                         // 5 then (* range *)
                            thisStack.rpop -> R[];
                            2 -> R.get -> thisStack.vpush;
                         // prim.sendMsg then 
                            thisObj.rpop -> X[];
                            (*(':sendMgs:text',true,screen[]) -> X.dump;*)
                            thisObj.vpop -> msgId;
                            thisObj.vpop -> handle;
                            thisObj.vpop -> serverId;
                            (serverId,handle,msgId,X[]) -> sendMsg;
                         // prim.attach then
                            ' attach: '-> out.puttext; 
                            thisObj.vpop -> value; 
                            value -> out.putint; ' '-> out.put;
                            stacksToOut;
                            ('attach',thisStack[],1,thisCode.descInx,glsc) -> popEvent;
                            (*(if suspendEnabled then
                                '\n***ERROR: attach suspendEnabled = true'->putline
                            if);*)
                            suspendEnabled + 1 -> suspendEnabled; 
                            value -> timeToSuspend;
                            glsc - 1 -> glsc; (* hack since doCall assumes
                                               * a call op and thereby lsc++
                                               *)
                            true -> doCall (* requires 'D' argument *)
                         // prim.disable then 
                           (* (if not suspendEnabled then
                                '\n***ERROR: disable suspendEnabled = false'->putline
                            if);*)
                            suspendEnabled - 1 -> suspendEnabled
                         // prim.enable then
                            (*(if suspendEnabled then
                                '\n***ERROR:enable suspendEnabled = true'->putline
                            if);*)
                            suspendEnabled + 1 -> suspendEnabled
                         // prim.asString then
                            ConvertIndexedToString
                        if);
                     // codes.jmp then
                        'jmp' -> exe;
                        op2 -> glsc
                     // codes.jmpFalse then
                        'jmpFalse' -> exe;
                        thisStack.vpop -> top1;
                        '(' -> out.put; top1 -> out.putint; ')' -> out.put;
                        (if  top1 = 0 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpFalse',thisStack[],1,thisCode.descInx,glsc) -> popEvent
                     // codes.jmpTrue then
                        'jmpTrue' -> exe;
                        (if thisStack.vpop <> 0 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpTrue',thisStack[],1,thisCode.descInx,glsc) -> popEvent
                     // codes.jmpGT then
                        'jmpGT' -> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if top2 > top1 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpGT',thisStack[],2,thisCode.descInx,glsc) -> popEvent
                     // codes.break then
                        'break' -> exe;
                        op1 -> on;
                        op2 -> lab;
                        op2 -> descInx;
                        (on,lab,descInx) -> doBreak
                     // codes.pushText then
                        'pushText' -> exe; 
                        op1 -> inx; 
                        (if isXbeta then
                            (thisObj.myObjDesc).literals[inx] 
                              -> XmkTextObject
                            (# i: @integer
                            do i + 1 -> i; 
                               (thisObj.myObjDesc).literals[inx+i] -> ch
                            #) -> X[]
                         else
                            (thisObj.myObjDesc).literals[inx] 
                              -> mkTextObject
                            (# i: @integer
                            do i + 1 -> i; 
                               (thisObj.myObjDesc).literals[inx+i] -> ch
                            #) -> X[];
                            (* OBS! we use the Text-object as origin of itself;
                             * this is wrong, origin should be the LIB-object
                             *)
                            (* generate allocEvent for &text 
                             * allocEvent calls myLsc, 
                             * which assume that glsc is on the lscStack
                             *)
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (thisObj[],X[],X[],thisCode.descInx,glsc,true,false) -> allocEvent;
                            allocLevel - 1 -> allocLevel;
                            thisObj.restoreReturn -> (descInx,glsc);
                            (thisObj[],X[],X[],thisCode.descInx,glsc) -> rtnEvent
                        if)
                     // codes.plus then
                        '+'-> exe; 
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        top2 -> out.putint; ' ' -> out.put; top1 -> out.putint;
                        top1 + top2 -> thisStack.vpush;
                        ('+',thisStack[],thisStack.vTopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.minus then
                        '-'-> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r -> out.putint; ' ' -> out.put; l -> out.putint;
                           r - l -> thisStack.vpush  
                        #);
                        ('-',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.uminus then
                        'u-' -> exe;
                        - thisstack.vpop -> thisStack.vpush;  
                        ('-',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> unOpEvent
                     // codes.mult then
                        '*'-> exe;
                        thisStack.vpop * thisStack.vpop -> thisStack.vpush;
                        ('*',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.modd then
                        'mod' -> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r mod l -> thisStack.vpush;
                           ('mod',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                        #);
                     // codes.idiv then
                        'div' -> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r div l -> thisStack.vpush;
                           ('div',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                        #);
                     // codes.eq then
                        '='-> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if top1 = top2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('=',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.ne then
                        '<>'-> exe;
                        (if thisStack.vpop <> thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('<>',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.req then
                        '=[]'-> exe;
                        (if thisStack.rpop = thisStack.rpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (* ('=',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.rne then
                        '<>[]'-> exe;
                        (if thisStack.rpop <> thisStack.rpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*('<>',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.seq then
                        '=##'-> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> Y[];
                        (if (X.vfields[1] = Y.vfields[1]) 
                            and ((2 -> X.rget) = (2 -> Y.rget))
                            (*(X.vfields[1] = Y.vfields[1]) 
                             * and (X.rfields[2][] = Y.rfields[2][])
                             *)
                            then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (* ('=',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.sne then
                        '<>##'-> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> Y[];
                        (if (X.vfields[1] <> Y.vfields[1]) 
                            or ((2 -> X.rget) <> (2 -> Y.rget))
                            (*(X.vfields[1] <> Y.vfields[1]) 
                             * or (X.rfields[2][] <> Y.rfields[2][])
                             * *)
                            then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*('<>',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent*)
                        
                        
                     // codes.lt then
                        '<'-> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        top2 -> out.putint; '<' -> out.put; top1 -> out.putint;
                        (if top2 < top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*(if thisStack.vpop > thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);*)
                        ('<',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.le then
                        '<='-> exe;
                        (if thisStack.vpop >= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.gt then
                        '>' -> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        top2 -> out.putint; '>' -> out.put; top1 -> out.putint;
                        (if top2 > top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('>',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.ge then
                        '>='-> exe;
                        (if thisStack.vpop <= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('>=',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.andd then
                        'and' -> exe;
                        (if (thisstack.vpop = 1) and (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('and',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.orr then
                        'or' -> exe;
                        (if (thisStack.vpop = 1) or (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('or',thisStack[],thisStack.vtop,thisCode.descInx,glsc) -> binOpEvent
                     // codes.nott then
                        'not' -> exe;
                        (if thisStack.vpop = 0 then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.saveBETAworld then
                        'saveBETAworld' -> exe; 
                        (if true then 
                            (1,thisStack.rpop) -> eventProcessor.rput
                         else
                            thisStack.rpop -> eventProcessor.rFields[1][];
                        if);
                        (if IsXbeta then
                            (* Why not for not isXbeta? See alos Alloc *)
                            (if true then
                                1 -> eventProcessor.rget -> world[]
                             else
                                eventProcessor.rFields[1][] -> world[]
                            if)
                        if)
                     // codes.mkStrucRef then
                        'mkStrucRef' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> descInx;
                        (* ('mkStrucRef',true,screen[]) -> X.dump;*)
                        (X[],descinx,false) -> mkStrucRefObj
                     // codes.mkObjStrucRef then
                        'mkObjStrucRef' -> exe;
                        thisStack.rpop -> X[]; (* the object *)
                        (X.myOrigin,X.myDescInx,false) -> mkStrucRefObj
                     // codes.mkVirtualStrucRef then
                        'mkVirtualStrucRef' -> exe;
                        (thisObj.rpop,op1,true) -> mkStrucRefObj
                     // codes.allocFromStrucRefObj then
                        'allocFromStrucRefObj' -> exe;
                        thisStack.rpop -> allocFromStrucRefObj                        
                     else
                        5 -> fatalError
                        (#
                        do 'Op-code: ' -> M.puttext; thisCode.B[glsc] -> M.putint;
                           M.newline;
                           thisCode.B[glsc] -> out.putint; glsc+1 -> glsc;
                        #)
                    if);
                    (if (glsc <= thisCode.top) and not doTerminate then
                        restart Loop 
                    if);

                    false -> isRunning;
                    (if (runMode = run_Beta_INT) and runJavaServices then 
                        closeJavaServices 
                    if);
                    done; (* Used to be in closeJavaServices 
                           * - but conflicting with fatalError *)
                    (* 'suspend'->putline;*)
                    suspend;
                    (* 'reactivate betaVM'->putline;*)
                    false -> doTerminate;
                    (if handleEvent then 
                        restart Loop 
                     else
                        restart main
                    if)
                 #);
               'End of betaVM'->putline;
               done
            #)
       #)
  #)
