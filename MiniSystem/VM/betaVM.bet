ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/basiclib/math';
INCLUDE 'objectImage';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'Primitives';
INCLUDE 'interpreterAPI'
INCLUDE '../miniServices/Service';
(*BUILD nti 'interpreter_c.obj' 'interpreter_c.c' 'betacc $0 $1'
      linux 'interpreter_c.obj' 'interpreter_c.c' '$CC -c -pthread -o $0 $1'
      default 'interpreter_c.obj' 'dummyinterpreter_c.c' '$CC -c -o $0  dummyinterpreter_c.c';*)
BUILD nti 'interpreter_c.obj' 'interpreter_c.c' 'c:/cygwin/bin/gcc -c -o $0 $1'
      linux 'interpreter_c.obj' 'interpreter_c.c' '$CC -c -pthread -o $0 $1'
      default 'interpreter_c.obj' 'dummyinterpreter_c.c' '$CC -c -o $0 dummyinterpreter_c.c';
---systemlib:attributes---

newVM: (#exit true #);
Run_BETA_INT: (# exit 0 #);
Run_C_INT: (# exit 1 #);
Save_BC_image: (# exit 3 #);
putBoolean: 
  (# B: @boolean 
  enter B do (if B then 'True' -> puttext else 'False'->puttext if)
  #);
event: data
  (# type: @integer;
     caller,thisObj,org: @integer;
     isObj: @integer;
     descNo: @integer;
     bcPos: @integer;
  #);
Sleep: external(# milliSec: @int64 enter milliSec do CallC #);
init_interpreter: external
  (# bc,imageS: @integer; newAlloc: @boolean; E: ^event
  enter(bc,imageS,newAlloc)
  do callC
  exit E[]
  #);
run_interpreter: external
  (# isXB: @boolean; E: ^event
  enter isXB
  do callC
  exit  E[]
  #);
getEvent: external
  (# first: @boolean; E: ^event
  enter first
  do callC
  exit E[]
  #);
close_interpreter: external(# do callC #);

betaVM:
  (#ready: @boolean;
     testConc: (# exit false #);
     init:<
       (# stdPath: ^text
       enter(runMode,isXbeta)
       do (if (runMode = Run_BETA_INT) and runJavaServices then
              BetaLib -> stdPath[];
              '/MiniSystem/miniServices/' -> stdPath.append;
              ('FileService'-> (stdPath.copy).Append,5123) -> FS.init;
              ('GUIService' -> (stdPath.copy).Append,5124) -> GS.init;
              5125 -> MS.openSocket;
              '*** Java services initialized' -> putline;
          if);
	  true -> ready;
          false -> guiProgram;
       #);
     putCh:< (# ch: @char enter ch do inner #);
     getCh:< (# ch: @char do inner exit ch #);
     (* Note! There is no common super for all VMevents
      * And there is no trace for valueEvent opEvent, etc.
      *)
     VMevent: 
       (# caller,thisObj,org: ^ObjDesc.runTimeObject; 
          descNo,bcPos: @integer;
          doPause: (# do (if false then pause else suspend if)#);
          trace: (# exit false #);
          event:< (# tx: ^text do inner exit tx[] #);
          mkTrace:
            (# dump:
                 (# msg: ^text; obj: ^ObjDesc.runTimeObject
                 enter(msg[],obj[])
                 do msg[] -> T.puttext; 
                    L:
                      (if obj[]  <> none then
                          '"' -> T.put;
                          obj.myName -> T.puttext; 
                          (*(if obj.isObj then '/O' -> T.puttext if);*)
                          '"' -> T.puttext; ',' -> T.put;
                          obj.myOrigin -> obj[];
                          restart L
                      if);
                    T.newline
                 #);
               T: @text
            do '\nVMevent: ' -> T.puttext; event -> T.puttext; T.newline;
               (' caller: ',caller[]) -> dump;
               (' this: ',thisObj[]) -> dump;
               (' org: ',org[]) -> dump;
               ' bcPos:' -> T.puttext; bcPos -> T.putint;
               (*T.newline;*)
            exit T[]
            #)
       enter(caller[],thisObj[],org[],descNo,bcPos)
       do (if thisObj[] <> none then 
              (if trace then
                  mkTrace -> out.puttext;
              if);
              inner;
              (*' descNo:'-> out.puttext; thisObj.myDescInx -> out.putint; 
               ' id:'-> out.puttext;
               thisObj.id -> out.putint; out.newline *)
          if)
       #);
     set:< (# do inner #); (* ad hoc *)
     
     scanEvent:<
       (# obj: ^ObjDesc.runTimeObject; items: [0] @integer
       enter obj[]
       do inner
       exit items
       #);
     dumpObjEvent:<
       (# obj: ^ObjDesc.runTimeObject; items: [0] @integer
       enter obj[]
       do inner
       exit items
       #);
     startEvent:< VMevent(# event:: (# do 'start'->tx[] #) do inner #);
     allocLevel: @integer; (* Note used? *)
     allocEvent:< VMevent
       (# isObj,isIndexed: @boolean;
          event:: (# do 'alloc'->tx[] #);
       enter(isObj,isIndexed) 
       do inner; 
          allocLevel + 1 -> allocLevel; 
       #);
     doEvent:< VMevent
       (# event:: (# do 'do'->tx[] #);
          preemptive: @boolean;
       enter preemptive
       do (*(thisCode.descInx,glsc) -> thisObj.saveReturn;*)
          inner ;
          (* thisObj.restoreReturn (* we just pop the stack *)
       #);
     doExitEvent:< VMevent
       (# event:: (# do 'doExit'->tx[] #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     rtnEvent:< VMevent
       (# event:: (# do 'rtn'->tx[] #);
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     resumeEvent:< VMevent
       (# event:: (# do 'resume' -> tx[] #);
          preemptive: @boolean;
       enter preemptive
       do inner;
       #);
     suspendEvent:< VMevent
       (# event::(#do 'suspend' -> tx[] #);
          preemptive: @boolean;
       enter preemptive
       do (descNo,bcPos) (*thisCode.descInx,glsc*) -> caller.saveReturn;
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     breakEvent:<  VMevent(# event::(#do 'break'-> tx[] #) do inner #);
     valueEvent:
       (# event:< (# tx: ^text do inner exit tx[] #);
          caller,from,to: ^ObjDesc.template; 
          popRstack: @boolean; 
          off: @integer;
          isIndexed: @boolean;
          inx,descNo,bcPos: @integer;
          doPause: (# do suspend #);
          trace: (# exit true #);
          mkTrace:
            (# T: ^Text
            do (*'\nvalueEvent' -> T[]*)
            exit T[]
            #);
       enter(caller[],from[],popRstack,to[],off,isIndexed,inx,descNo,bcPos)
       do (descNo,bcPos) (*(thisCode.descInx,glsc)*) -> caller.saveReturn;
          (if trace then mkTrace -> out.puttext if);
          inner;
          caller.restoreReturn (* we just pop the stack *)
       #);
     pushEvent: valueEvent
       (* from: an object/activation where the value is loaded from
        * to: a stack in the form of an object
        *)
       (# 
       do
          inner
       #);
     vPushEvent:< pushEvent
       (# event::(#do 'vPush'-> tx[] #);
          value: @integer
       enter value
       do inner
       #);
     rPushEvent:< pushEvent
       (# event::(#do 'rPush'-> tx[] #);
          refValue: ^ObjDesc.template
       enter refValue[]
       do inner
       #);
     storeEvent: valueEvent
       (* from: a stack in the form of an object
        * to: an object/activation where the value is stored
        *)
       (# 
       do 
          inner
       #);
     vStoreEvent:< storeEvent
       (# value: @integer
       enter value
       do inner
       #);
     rStoreEvent:< storeEvent
       (# event::(#do 'rStore'-> tx[] #);
          refValue: ^ObjDesc.template
       enter refValue[]
       do inner
       #);
     opEvent:
       (# event:< (# tx: ^text do inner exit tx[] #);
          operator: ^text; to: ^ObjDesc.template; 
          value,descNo,bcPos: @integer
       enter(operator[],to[],value,descNo,bcPos)
       do (thisCode.descInx,glsc) -> to.saveReturn;
          inner;
          to.restoreReturn (* we just pop the stack *)
       #);
     binOpEvent:< opEvent(# event::(#do 'binOP'-> tx[] #) do inner #);
     unOpEvent:< opEvent(# event::(#do 'unOP'-> tx[] #) do inner #);
     jmpGTevent:< opEvent(# event::(#do 'jmpGT'-> tx[] #) do inner #);
     popEvent:< opEvent(# event::(#do 'pop'-> tx[] #) do inner #);
     
     errorEvent:< 
       (# thisObj: ^ObjDesc.template; bcPos: @integer; msg: ^text
       enter(thisObj[],bcPos,msg[])
       do (thisCode.descInx,glsc) -> thisObj.saveReturn;
          inner;
          thisObj.restoreReturn (* we just pop the stack *)
       #);
     
     done:< (# do inner #);
     
     thisModule, (* not used? *)
     thisObj,
     thisStack,
     eventProcessor: ^ObjDesc.template;
     
     runJavaServices, (* Java services does not work on Linux, 
                       * so we don't start then *)
     isValObj, (* executing a value object *)
     isXbeta: @boolean;
     
     thisValObjDesc: ^ObjDesc;
     thisValObjDescInx: @integer;
     
     newAllocOff: @integer;
     
     runMode: @integer;
     
     guiProgram: @boolean;
     
     thisCode: ^ByteCode; 
     
     glsc: @integer;
     
     codes: @ ByteCodes;
     
     prim: @Primitives;
     
     stopErrors: ^text;
     
     fatalError:
       (# errNo: @integer; M: @text
       enter errNo
       do errNo -> thisObj.fatalError
          (#
          do (if (runMode = run_BETA_INT) and runJavaServices then 
                 closeJavaServices 
             if);
             '!!   Before bytecode at LSC: ' -> msg.puttext; 
             glsc -> msg.putint;
             inner fatalError;
             M[] -> msg.puttext
          #) 
            -> stopErrors[]
            -> putline;
          (thisObj[],glsc,stopErrors[]) -> errorEvent;
       #);
     
     closeJavaServices:
       (#
       do (if not guiProgram then
              (if FS.trace then '\nFS.close'->putline if);
              FS.close; 
              (if MS.trace then 'MS.close'->putline if);
              false ->  MS.close;
              (if GS.trace then 'GS.close'->putline if);
              GS.close;
              mouseListener[] -> kill;
              '\n\n*** Closed all Java services ' -> putline;
          if);
       #);
     
     out: ^Stream;
     
     FS,GS,MS: @Service;
     mouseListener:  @ | system
       (# T: ^text
       do (if MS.trace or true then 
              (*  'Starting mouseListener:'->putline *)
          if);
          cycle
          (# event,noOfClicks,handle: @integer
          do MS.receive -> T[];
             (*'mouseListener: ' -> puttext; T[] -> putline;*)
             T.setPos;
             T.getInt -> handle;
             T.getint -> event;             
             (if GS.trace then
                 'BETA:event:handle: ' -> puttext; handle -> putint;
                 (if event
                  // 1 then
                     ' mouseClicked:'->puttext;
                     T.getint -> noOfClicks -> putint;                
                  // 2 then
                     'BETA:Mouse exited' -> putline
             if)if);

             T[] -> execute.selectEventProcessor;
             (* store handle/object in 1 -> thisStack.rstore *)
             execute[] -> fork;
             pause;
             (* 'mouseListener reactivated'->putline*)
          #);
          
          (if MS.trace or true then 'BETA:mouse: ' -> puttext; T[] -> putline if);
       #);
     
     reActivate: (# do (if true then execute else execute[] -> fork if) #);
     
     execute: @ | system
       (# saveBCimage:
            (* Saves the byte code image on file FN..bc with execution *)
            (# mainDescInx: @integer; FN: ^text
            enter(mainDescInx,FN[])
            do (mainDescInx,(FN[],'..bc') -> mkAuxName) -> descs.serialize;
            #);
          init:
            (# RTT: @File;
            enter(descs[],descInx,FN[],runMode)
            do (if (runMode = run_BETA_INT) and runJavaServices then 
                   mouseListener[] -> fork 
               if);
               (if runMode <> save_BC_Image then
                   (FN[],'..run') -> mkAuxName -> RTT.name;
                   RTT.openWrite;
                   RTT[] -> out[];
               if);
               pause;                
            #);
          selectEventProcessor:
            (# eventSpec: ^text; D: ^objDesc
            enter eventSpec[]
            do eventProcessor[] -> thisModule[] -> thisObj[] -> thisStack[];
               thisObj.myObjDesc -> D[];
               (* '\n===='->putline;
                (thisObj.myObjDesc).literals[1] -> putint; newline;
                eventSpec.length -> putint; newline;
                (eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min -> putint; 
                * newline;
                (for i: D.literals[1] repeat 
                (thisObj.myObjDesc).literals[1+i] -> put; ' ' -> put
                for); newline;*)
               
               (if eventSpec.length > (thisObj.myObjDesc).literals[1] then 
                   '\n\n**** eventSpec too large: "'->puttext;
                   eventSpec[] -> puttext; '"' -> put
               if);

               (for i:((eventSpec.length,(thisObj.myObjDesc).literals[1]) -> min) repeat
                    i -> eventSpec.inxGet -> (thisObj.myObjDesc).literals[1 + i];
                    (* '<'->put;  i -> eventSpec.inxGet -> put; '>'->put;
                     (thisObj.myObjDesc).literals[1 + i] -> put*)
               for);

               descs.OD[descInx + 1 ].bc[] -> thisCode[];
               thisObj[] -> descs.ObjPool;
               descInx -> thisObj.myDescInx;
               true -> handleEvent;
               1 -> gLsc;
            #);               
          decodeEvent:
            (# E: ^event; T: @text; obj: ^objDesc.cTemplate;
               caller,thisObj,org: ^objDesc.cTemplate;
            enter E[]
            do (if E[] <> none then
                   (* ','->put; E.caller -> putint; ','->put;*)
                   (if (1 <= E.type) and (E.type < 18) then 
                       E.caller -> descs.cObjCache.get -> caller[];
                       E.thisObj -> descs.cObjCache.get -> thisObj[];
                       E.org -> descs.cObjCache.get -> org[];
                    else
                       (if (E.type = 19) then (* can probably be handled by 
                                               * code before else *)
                           E.caller -> descs.cObjCache.get -> caller[];
                       if)
                   if);
                   caller[] -> obj[];
                   (* 'cObj: ' -> puttext; 
                    loop:
                    (if obj[]<> none then 
                    obj.myName -> puttext; ' ' -> put;
                    obj.objId -> putint;
                    obj.myOrigin -> obj[];
                    restart loop
                    if);
                    newline;*)
                   (if E.type 
                    // 0 then (*skip*)
                    // 1 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> startEvent
                    // 2 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1,E.isObj=1,false) -> allocEvent
                    // 3 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1,false) -> doEvent
                    // 4 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> doExitEvent
                    // 5 then
                       (caller[],thisObj[],org[],E.descNo,E.bcPos + 1) -> rtnEvent
                    // 18 then (* stop *)
                    // 19 then
                       '\n*** Got scan_event'->putline;
                       (caller[]) -> scanEvent
                    else
                       '\n\n*** Event not catched: ' -> puttext;
                       E.type -> putint; newline;
                       stop
                   if);
               if);
               (*newline*)
            exit E.type  <> 18
            #);
          handleEvent: @boolean;
          descs: ^RuntimeDescriptors;
          descInx: @integer;
          isObj: @integer;;
          obj: ^ObjDesc.Template;
          root: ^ObjDesc.Template;
          world: ^ObjDesc.Template;
          stringOrigin: ^ObjDesc.Template;
          
          break:
            (# descNo,bcPos: @integer
            enter(descNo,bcPos)
            do 'VM:breakIn: ' -> puttext; descNo -> putint; 
               ' at: ' -> puttext; bcPos -> putint; newline;
               (*'OD.range: ' -> puttext; descs.OD.range -> putint; newline;*)
               
               (if descs[] = none then ' descs i none???'->putline;if);
               (if descs.OD[descNo][] = none then
                   'bc none ' -> putline
                else 
                   bcPos -> descs.OD[descNo].bc.setBreak
               if)
            #);
          
          sendMsg:
            (# serverId,handle,msgId: @integer; msg: ^objDesc.template; 
               T: @text
            enter(serverId,handle,msgId,msg[])
            do (if FS.trace then
                   'SendMsg: serverId=' -> puttext; serverId->putint; 
                   ' handle=' -> puttext; handle -> putint; 
                   ' msgId='-> puttext; msgId -> putint; ' vields[1]=' -> puttext; 
                   msg.fields[1] -> putint;
               if);
               (for i: msg.fields[1] repeat
                    msg.fields[i+2] -> T.put; 
               for);
               (if FS.trace then
                   ' msg="'->puttext; T[] -> puttext;  '"'->put; newline;
               if);
               (if serverId
                // 1 then
                   (handle,msgId,T[]) -> sendFileMsg
                // 2 then
                   (handle,msgId,T[]) -> sendGuiMsg
               if)
            #);
          doReceive: (# exit true #);
          sendFileMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if FS.trace then 'sendFileMsg: '-> puttext; if);
               (if msgId
                // 1 then 
                   1 -> FS.mkCommand(#do msg[] -> cmd.puttext #);
                   (if doReceive then
                       FS.receive -> h[];
                       (1,h.length-1) -> h.sub -> h[];
                       0 -> h.setpos; h.getint -> thisStack.vPush
                    else
                       1 -> thisStack.vpush
                   if)
                // 2 then
                   2 -> FS.mkCommand(#do handle -> cmd.putint; ' '  -> cmd.put;
                                       msg[] -> cmd.puttext
                                    #);
                   (if doReceive then FS.receive -> h[] if)
                // 3 then
                   3 -> FS.mkCommand(# do handle -> cmd.putint; #);
                   (if doReceive then FS.receive -> h[] if)
               if);
            #);
          sendGuiMsg:
            (# handle,msgId: @integer; msg: ^text; h: ^text
            enter(handle,msgId,msg[])
            do (if GS.trace then
                   'sendGuiMsg: '-> puttext; msgId->putint; ' ' -> put;
                   '"' -> put;  msg[] -> puttext; '"' -> put; newline;
               if);
               (if not guiProgram then
                   '**** GUI program' -> putline;
                   true -> guiProgram; 
               if);
               (if msgId
                // 1 then
                   1->GS.mkCommand(# do msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (if GS.trace then 'BETA:received: ' -> puttext; h[] -> putline; if);
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush;
                // 2 // 5 // 6 then
                   msgId ->GS.mkCommand(# do handle -> cmd.putint; 
                                          ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                   
                // 3 then
                   3->GS.mkCommand(# do handle -> cmd.putint; 
                                     ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 4 // 7 // 8 // 10 then
                   msgId -> GS.mkCommand
                   (# do handle -> cmd.putint; ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];
                   (1,h.length-1) -> h.sub -> h[];
                   0 -> h.setpos; h.getint -> thisStack.vpush; 
                // 9 then
                   msgId -> GS.mkCommand(# do handle -> cmd.putint; 
                                           ' ' -> cmd.put; msg[] -> cmd.puttext #);
                   GS.receive -> h[];  
                   h.length 
                     -> mkTextObject(# i: @integer do i + 1 -> i -> h.inxGet -> ch #);
                   (* -> thisStack.rpush;*)
               if);
               (if GS.trace then
                   'betaVM:received: ' -> puttext; h[] -> putline;
               if)
            #);
          mkTextObject:
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do (*'\nmkTextObject:length: ' -> puttext; length -> putint; newline;*)
               (if descs.OD[descs.textDescNo][] = none then
                   'descs.OD[descs.textDescNo][] = none'->putline
               if);
               (1,length + 1 + 100,3,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               X[] -> descs.ObjPool;
               descs.textDescNo -> X.myDescInx;
               true -> X.isObj;
               (if world[] = none then
                   '\n!!! betaVM:mkTextObject: world[] = none '->putline
               if);
               (if (3 -> world.rget) = none then
                   '\n!!! betaVM:mkTextObject: (3 -> world.rget) = none'->putline
               if);
               (if true then
                   (1,stringOrigin[]) -> X.rput
                else
                   (1,(3 -> world.rget)) -> X.rput;
                   (* seems to be a hack 
                    * 3 = LIB = origin
                    *)
               if);
               length -> X.fields[2]; (* pos *)
               length + 100 -> X.fields[3]; (* range *)

               (for i: length  repeat
                    inner;
                    ch -> X.fields[i + 3];
               for);  
               (*('mkTextObject',true,screen[]) -> X.dump*)
            exit X[]
            #);
          QallocTextObject:
            (* New layout for newAlloc: "abc..."
             * fields[0] =
             * fields[1] = origin
             * fields[2] = rangee
             * fields[3} = 'a'
             * fields[4] = ...
             *)
            (# X: ^ObjDesc.template;
               length: @integer; 
               ch: @char
            enter length
            do (*'QallocTextObject:start: ' -> puttext; length -> putint; 
               ' textDescNo: ' -> puttext; descs.textDescNo -> putint;
               newline;*)
               (if descs.OD[descs.textDescNo][] = none then
                   'descs.OD[descs.textDescNo][] = none'->putline
               if);
               (* perhaps use QallocIndex as in interpreter_c.c *)
               (1,length,1 + newAllocOff,0) 
                 -> descs.OD[descs.textDescNo].template 
                 -> X[] 
                 -> thisStack.rpush;
               X[] -> descs.ObjPool;
               descs.textDescNo -> X.myDescInx;
               true -> X.isObj;
               descs.OD[descs.textDescNo].OSDvisibility -> X.OSDvisibility;
               (if world[] = none then
                   '\n!!! betaVM:QallocTextObject: world[] = none '->putline
               if);
               (if (3 -> world.rget) = none then
                   '\n!!! betaVM:QallocTextObject: (3 -> world.rget) = none '
                     -> putline
               if);
               (if true then
                   (1,stringOrigin[]) -> X.rput
                else
                   (1, (3 -> world.rget)) -> X.rput;
               if);
               (* seems to be a hack 
                * 3 = LIB = origin *)
               length -> X.fields[1 + newAllocOff]; (* pos *)
               (*length + 100 -> X.fields[2];  range *)
               (for i: length  repeat
                    inner;
                    ch -> X.fields[i + 1 + newAllocOff];
               for);   
               (* newline;
               'fields.range: ' ->puttext; 
               X.fields.range -> putint; newline;
               (for i: length + 1 + newAllocOff repeat
                    X.fields[i] -> putint;
                    ' ' -> put
               for);
                newline;*)
               ('QallocTextObject',true,out[]) -> X.dump               
            exit X[]
            #);    
          ConvertIndexedToString:
            (# X,Y: ^ObjDesc.template; length: @integer
            do thisStack.rpop -> X[];
               X.fields[1 + newAllocOff] -> length;
               (* X.fields[1] = length = range
                * X.fields[2] = indexed[1]
                * ...
                * X.fields[length + 1] = indexed[length]
                *)
               ('ConvertIndexedToString',true,out[]) -> X.dump;
               'newAllocOff:'-> out.puttext; newAllocOff -> out.putint; out.newline;
               (*(for i: X.fields.range repeat
                    X.fields[i] -> putint; ' '->put
               for);
               newline;*)
               L:
                 cycle
                 (#
                 do (if X.fields[length + 2] = 0 then 
                        length - 1 -> length
                     else
                        leave L
                 if)#);
               (if true then
                   (* should perhpas use allocTemplate§?*)
                   (1,length,1 + newAllocOff,0) 
                     -> descs.OD[descs.textDescNo].template 
                     -> Y[] 
                     -> thisStack.rpush;
                   Y[] -> descs.objPool
                else
                   (1,length+1,1,0) 
                     -> descs.OD[descs.textDescNo].template 
                     -> Y[] 
                     -> thisStack.rpush;
               if);
               (if true then
                   (1,stringOrigin[]) -> Y.rput
                else                   
                   (1,(3 -> world.rget)) -> Y.rput(* origin - hack *);
               if);
               (*Y.fields.range -> putint; newline;*)
               (for i: length repeat
                    X.fields[i + 1 + newAllocOff] -> Y.fields[i + 1 + newAllocOff]
               for);
               ('String',true,out[]) -> Y.dump;
            #);
          
          mkStrucRefObj:
            (# origin,X: ^ObjDesc.template; 
               inx: @integer;
               isVirtual: @boolean
            enter(origin[],inx,isVirtual)
            do (* the generation below is clumsy
                * currently template is made for textDesc
                * clean-up
                *)
               (*  ('mkStrucRefObj:origin',true,screen[]) -> origin.dump;
                'strucrefDescNo:'->puttext; 
                descs.structureRefDescNo -> putint; newline;
                *)
               (1,0,1,0) -> descs.OD[descs.structureRefDescNo].template -> X[];
               descs.structureRefDescNo -> X.myDescInx;
               X[] -> descs.ObjPool;
               (if isVirtual then
                   (origin.myObjDesc).vdtTable[inx] -> inx
               if);
               inx -> X.fields[1];
               (2,origin[]) -> X.rput;
               (*('StrucRefObj',true,screen[]) -> X.dump;*)
               X[] -> thisStack.rpush;
            #);
          allocTemplate:
            (# descNo,vInxSize,rInxSize: @integer; isObj: @boolean;
               obj: ^objDesc.template
            enter(descNo,isObj,vInxSize,rInxSize)
            do &descs.OD[descNo].template[] -> obj[];
               descs.OD[descNo].objSize  -> obj.fields.new;
               descNo -> obj.myDescInx;
               obj[] -> descs.ObjPool;
               isObj -> obj.isObj;
               descs.OD[descNo].OSDvisibility -> obj.OSDvisibility; 
            exit obj[]
            #);
          alloc:
            (# origin,callee,Y: ^objDesc.template; descNo: @integer; 
               isObj: @boolean
            enter(origin[],descNo,isObj)
            do (*'Alloc: ' -> puttext; descNo -> putint; newline;*)
               (descNo,isObj,0,0) -> allocTemplate -> callee[];
               (* '\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                * ' lsc: ' -> puttext; glsc -> putint; newline; *)
               callee.myId -> out.puttext; 
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descNo].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> thisStack[] -> thisObj[];
               (if origin[] = root[] then
                   (* Perhaps just handled by saveBETAworld? *)
                   callee[] -> world[];
               if);
               (Y[],thisObj[],origin[],descNo,glsc,isObj,false) -> allocEvent;
            #);
          invokeVal:
            (# descNo,staticOff: @integer;
               callee: ^objDesc.template;
            enter(descNo,staticOff)
            do (if false then
                   '\n*** invokeVal:descNo: ' -> puttext; descNo -> putint;
                   ' ' -> put; descs.OD[descNo].myId -> putline
               if);
               (*
                ' :glsc: '-> puttext; glsc -> putint; 
                ' :staticOff: ' -> puttext; staticOff -> putint;
                newline; *)
               
               (if Descs.OD[descNo][] = none then
                   'descs.OD[descNo][] = none, descNo='->puttext;
                   descNo -> putint; newline
               if);
               
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               staticOff -> thisObj.lscPush; (* returnValue below use 
                                              * staticOff to
                                              * adjust thisObj.valOff
                                              * dont work: will be on top of
                                              * possible arguments
                                              * Use lscStack *)
               staticOff + thisObj.valOff -> thisObj.valOff;               
               descs.OD[descNo].bc[] -> thisCode[];
               descs.OD[DescNo].BC.allocE -> glsc;
               true -> isValObj;
               descs.OD[DescNo][] -> thisValObjDesc[];
               descNo -> thisValObjDescInx
            #);
          returnValue:
            (# staticOff: @integer
            do none -> thisValObjDesc[];
               false -> isValObj;
               thisObj.lscPop -> staticOff;
               thisObj.restoreReturn -> (descInx,glsc); 
               (* '*** returnVal:descInx: '->puttext; descInx -> putint; 
                ' :glsc: '-> puttext; glsc -> putint; 
                ' :staticOff: '->puttext; staticOff -> putint;
                newline; *)
               descs.OD[descInx].bc[] -> thisCode[];  
               thisObj.valOff - staticOff -> thisObj.valOff;
               (* thisObj[] -> thisObj .rpush;*)
               ('ValueObject:',true,out[]) -> thisObj.dump;
            #);
          invoke:
            (# callee,Y: ^objDesc.template; descNo,staticOff: @integer; 
               asObj: @boolean
            enter(descNo,staticOff,asObj)
            do (*'Invoke:descNo: ' -> puttext; descNo -> putint; 
                ' asObj:'->puttext; asObj -> putBoolean; newline;*)
               (if descs.OD[descNo][] = none then
                   'descs.OD[descNo][] = none, descNo='->puttext;
                   descNo -> putint; newline
               if);
               (descNo,asObj,0,0) -> allocTemplate -> callee[];
               (if staticOff > 0 then
                   (staticOff,callee[]) -> thisObj.rput
               if);
               (if false (*callee.OSDvisibility > 0*) then
                   '**** Invoke: ' -> puttext; callee.myName -> puttext;
                   ' descInx: ' -> puttext;callee.myDescInx -> putint;
                   ' OSDvisibility: ' -> puttext; 
                   callee.OSDvisibility -> putint;
                   ' lsc: ' -> puttext; glsc -> putint; newline;
               if);
               callee.myId -> out.puttext; 
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descNo].bc[] -> thisCode[];
               (if thisObj[] <> thisStack[] then
                   '\n*** invoke: thisObj[] <> thisStack[]:'-> out.putline;
                   '    thisObj: ' -> out.puttext;
                   thisObj.myId -> out.puttext; 
                   '\n    thisStack: ' -> out.puttext; 
                   thisStack.myId -> out.putline;
               if);
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               (*origin[] -> callee.rpush;  (* origin *)
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> (*thisStack[] -> *) thisObj[];
               (* (if origin[] = root[] then
                   callee[] -> world[];
               if);*)
               (* OBS! We may need origin for minienv!
                * And perhaps the same for asObj
                *)
               (*(Y[],thisObj[],(*origin[],* )none,descNo,glsc,asObj,false) 
                                 -> allocEvent;*)
               asObj -> asObjEnabled;
               'isValObj: ' -> out.puttext; 
               (if isValObj then 1 -> out.putint else 0 -> out.putint if);
               out.newline;
               (if isValObj then
                   (if false then
                       '**** invoke:valueObj:' -> puttext;  
                       thisObj.myName -> puttext; ':'->put;
                       thisValObjDescInx -> putint; newline;
                   if);
                    thisValObjDescInx -> thisStack.vPush
               if);
               false -> isValObj;
                   (*(if asObjEnabled then ' asObjEnabled'->puttext if)*)
            #);
          AllocIndexed:
            (# callee,Y: ^objDesc.template;
               origin: ^objDesc.template;
               descInx,isObj,dinx,rangee,isRindexed: @integer
            enter(origin[],descInx,isObj,dinx,rangee,isRindexed)
            do (* (if isRindexed  = 1 then 'isRindexed' -> putline if);
                rangee -> putint; ' ' -> put;
                dinx -> putint; ' ' -> put;
                descinx -> putint; newline;
                *)
               
               (1,rangee,dinx,isRindexed) -> descs.OD[descInx].template -> callee[];
               
               descs.OD[descInx].OSDvisibility -> callee.OSDvisibility;
               descInx -> callee.myDescInx;
               callee[] -> descs.ObjPool;
               
               (*'\nAlloc: ' -> puttext; thisObj.myDescInx -> putint;
                ' lsc: ' -> puttext; glsc -> putint; newline;*)
               (thisCode.descInx,glsc) -> thisObj.saveReturn;
               
               descs.OD[descInx].bc[] -> thisCode[];
               thisObj[] -> Y[] -> callee.rPush; (* return *)
               thisStack[] -> callee.rPush;
               (if not isXbeta then
                   origin[] -> callee.rpush;  (* origin *)
               if);
               descs.OD[descInx].BC.allocE -> glsc;
               callee[] -> (* thisStack[] ->*) thisObj[];
               (if not isXbeta then
                   thisObj[] -> thisStack[]
               if);
               (if isObj = 1 then 
                   true -> thisObj.isObj;
                   true -> asObjEnabled
               if);
               (if not isXbeta then
                   (Y[],thisObj[],origin[],descInx,glsc,isObj=1,true)
                     -> allocEvent
               if);               
            #);
          QallocIndexed:
            (# callee,Y: ^objDesc.template;
               origin: ^objDesc.template;
               descInx,size,dinx,rangee,isRindexed: @integer
            enter(origin[],descInx,size,dinx,rangee,isRindexed)
            do (* dinx = 1 - always, pushed by generator, but elim!
                * newAllocOff = 1, do elim
                * Elim dinx + newAllocOff, template should always
                * add 2 to rangee
                *)               
               (size,rangee,dinx + newAllocOff,isRindexed) 
                 -> descs.OD[descInx].template 
                 -> callee[];
               'AllocIndexed: '->out.puttext; descInx -> out.putint; 
               ' size:'->out.puttext; size->out.putint;
               ' range:'-> out.puttext; rangee->out.putint;
               ' isRindexed:'->out.puttext; isRindexed-> out.putint; 
               out.newline;
               descs.OD[descInx].OSDvisibility -> callee.OSDvisibility;
               descInx -> callee.myDescInx;
               callee[] -> descs.ObjPool;
               callee[] -> thisStack.rPush;
               ('QallocIndexed:',true,out[]) -> callee.dump;
            exit callee[]
            #);
          mkIndexed:
            (# descInx: @integer;
               isRef: @Boolean; 
               length,V,size,isRindexed: @integer; 
               X: ^objDesc.template;
               trace: (# exit false #);
            enter(descInx,isRef)
            do thisStack.vpop -> length;
               (if trace then
                   '\n**** mkIndexed: ' -> puttext; isRef -> putboolean; newline;
                   '**   length: ' -> puttext; length -> putint;
               if);
               (if isRef then 1 -> isRindexed if);
               
               1 -> size; (* probably size of elements???*)
               
               (X[],descInx,size,1,length,isRindexed) 
                 -> QallocIndexed -> X[];
               
               (if trace then  ' elem: ' -> puttext; if);
               (for i: length repeat
                    thisStack.vpop -> V;
                    (if trace then V -> putint; ' ' -> put; if);
                    V -> X.fields[1 + length - i + 1 + newAllocOff];
               for);
               (if trace then newline if)
            #);
          asObjEnabled: @boolean;
          
          allocFromStrucRefObj:
            (# X: ^objDesc.template
            enter X[]
            do (*('AllocFromStrucRefObj',true,screen[]) -> X.dump;*)
               (* We need to handle isObj *)
               (2 -> X.rget,X.fields[1],true) -> alloc
            #);
          doBreak:
            (# on,lab,actualDescInx
               ,nOfS  (* no of superpatterns of obj being returned to *)
               ,pn: @integer; (* no of super patterns for actualDescInx 
                               * not used - and probably never to be used 
                               *)
               descInx,xlsc,V,sAdj: @integer; 
               X,Y: ^objDesc.template;
               newPopRtn: (# exit true #);
               trace: (# exit true #)
            enter(on,lab,actualDescInx,pn)
            do (if trace then
                   '\nBREAK:to: ' -> out.puttext; 
                   descs.OD[actualDescInx].myId -> out.puttext;
                   ' on: ' -> out.puttext; on -> out.putint;
                   ' pn: ' -> out.puttext; pn -> out.putint;
                   ' lab: '->out.puttext; lab -> out.putint; 
                   ' from: ' -> out.putline;
                   (out[],'   thisObj   = ') -> thisObj.dumpObjFull;
                   (out[],'   thisStack = ') -> thisStack.dumpObjFull;
               if);
               thisObj[] -> X[];
               (for i: on repeat X.myOrigin -> X[] for);
               (if trace then (out[],'   go:ON: ') -> X.dumpobj if);
               (* We need to test for none if the stack does not contain X
                * Same  for traversing super
                *)
               popCallStack:
                 (if thisObj[] <> X[] then 
                     thisObj[] -> Y[];
                     (if newPopRtn then
                         thisObj.return -> (thisStack[],thisObj[])
                      else
                         thisObj.rpop -> thisStack[];
                         thisObj.rpop -> thisObj[];
                     if);
                     (if trace then 
                         (out[],'pop:obj   = ') -> thisObj.dumpObj;
                         (out[],'pop:stack = ') -> thisStack.dumpObj;
                     if);
                     (thisObj[],Y[],Y.myOrigin,0,0) -> rtnEvent;
                     restart popCallStack
                 if);
               (if trace then
                   (out[],'Dest:obj: ') -> thisObj.dumpObj;
                   (out[],'Dest:stack: ') -> thisStack.dumpObj;
               if);
               thisObj[] -> thisStack[];

               thisObj.restoreReturn -> (descInx,xlsc);
               (if trace then
                   'Dest:descInx: '->out.puttext; 
                   descInx->out.putint;
                   ' dest:super:actualDescInx: ' -> out.puttext;
                   actualDescInx -> out.putint;
                   ' xlsc(not to be used): ' -> out.puttext; 
                   xlsc->out.putint; out.newline
               if);
               (if false and (pn > 0) then 
                   '**** break:Before:goSuper:pn=' -> out.puttext; 
                   pn -> out.putint;
                   ' rtop=' -> out.puttext; thisObj.rtop -> out.putint;
                   (out[],'Break:before:goSuper: ') -> thisObj.dumpObj;
               if);
               (if isXbeta and (descInx <> actualDescInx) then 
                   findActualSuper:
                     (if descInx <> actualDescInx then 
                         (* break to a ptn level in super chain *)
                         thisObj.restoreReturn -> (descInx,glsc);
                         thisObj.rpop -> thisObj[];
                         (if trace then 
                             'Find:Super:descInx: ' -> out.puttext;
                             descInx -> out.putint; 
                             ' glsc: ' -> out.puttext; 
                             glsc->out.putint; out.newline;
                             (out[],'   obj:') -> thisObj.dumpObj;
                         if);
                         sAdj + 1 -> sAdj;
                         restart findActualSuper
               if)if);
               (if false and (pn > 0) then 
                   '**** break:after:goSuper:pn=' -> out.puttext; 
                   pn -> out.putint;
                   ' rtop: ' -> out.puttext; thisObj.rtop -> out.putint;
                   (out[],'Break:after:goSuper: ') -> thisObj.dumpObj;
               if);         
               descs.OD[descInx].noOfSuper -> nOfS;
               (if trace then
                   'noOfSuper: ' -> out.puttext;
                   nOfS -> out.putint;
                   ' rtop: ' -> out.puttext; thisObj.rtop -> out.putint;
                   out.newline;
               if);
               (if newPopRtn and (descs.OD[descInx].noOfSuper = 0) then 
                   2 -> thisObj.rtop 
                else
                   (if (nOfS > 0) then
                       (if (thisObj.rtop) <> (nOfS + 2) then
                           '\n!!!! WARNING: break to object with '
                           'references on the rstack oether than '
                           'return references' -> putline
               if)if)if);
               descs.OD[descInx].bc[] -> thisCode[];
               descs.OD[descInx].labs[lab] -> glsc;

               (if trace then
                   'ContinueAt: ' -> out.puttext; 
                   descs.OD[descInx].myId -> out.puttext;
                   ' glsc: ' -> out.puttext; glsc->out.putint; out.newline
               if)
            #);
          files: @
            (* handle external files *)
            (# F: [4] ^File; top: @integer;
               open:
                 (# N: ^objDesc.template; l,off: @integer;
                    T: @text;
                 enter N[]
                 do (if descs.newAlloc then
                        2 -> N.get -> l; 2 -> off
                     else
                        1 -> N.get -> l; 1 -> off
                    if);
                    (for i: l repeat
                         i + off -> N.get -> T.put; 
                    for);
                    (if (top + 1 -> top) > F.range then F.range -> F.extend if);
                    &file[] -> F[top][];
                    T[] -> F[top].name;
                    F[top].openRead;
                 exit top
                 #);
               get: (# id: @integer enter id exit F[id].get #);
               eof: 
                 (# id,V: @integer 
                 enter id 
                 do (if F[id].eos then 1 -> V if)
                 exit V #);
               close: (# id: @integer enter id do F[id].close #);                 
            #);
          
          dumpD: 
            (#
            do 'descs:' -> putline;
               (for i: descs.OD.range repeat
                    i -> putint; ':' -> put; 
                    (if descs.OD[i][] = none then ' none' -> putline if);
               for);
               newline
            #);
          isRunning,doTerminate: @Boolean;
          terminate: (# do true -> doTerminate #);
          FN: ^text; 
       (*enter(descs[],descInx,out[],FN[])*)
       do (if runMode = save_BC_Image then
              'SAVING BYTE CODE IMAGE - main desc: ' -> puttext; 
              descInx -> putint; newline;
              (descInx,FN[]) -> saveBCimage;
              STOP
          if);
          main:
            (# suspendEnabled: @integer;
               timeToSuspend: @integer;
               enablee: ^ObjDesc.template;
               first: @boolean
            do (*'***VM started:'->puttext; descInx -> putint;*)
               true -> isRunning; (*screen[] -> out[];*)
               (if descs.newAlloc then 1 -> newAllocOff if);
               false -> doTerminate;
               (if descs.OD[1][] = none then (* not used any more*)
                   'Allocating dummy template in OD[1] for repetitions'
                     -> putline;
                   &ObjDesc[] -> descs.OD[1][];
                   ('ValueRep',1,0,0,false,out[],descs[]) 
                     -> descs.OD[1].init;
               if);
               (for i: descs.OD.range repeat 
                    (* most OD's are not in use since code is only generated
                     * for modules in use. 
                     *)
                    (*(if descs.OD[i][] <> none then
                        ',' -> put; i -> putint;
                        out[] -> descs.OD[i].out[]
                    if)*)
               for);
               (*newline;*)
               (descInx,true,0,0) 
                 -> allocTemplate -> thisModule[] -> thisObj[] -> thisStack[];
               descs.OD[descInx].bc[] -> thisCode[];

               (* dangerous to assume descInx + 1 *)
               (if descs.OD[descInx + 1][] <> none then
                   (descInx + 1, true,0,0) -> allocTemplate -> eventProcessor[];
                else
                     '**** skip allocTemplate for eventProcessor: assuming bvm'
		     ->putline
               if);
               '**** EXECUTE **** ' -> puttext; 
               (if true then
                   newline
                else
                   descs.OD[descInx].name[] -> puttext;
                   ' descInx: ' -> puttext; descInx -> putint; 
                   ' ****\n\n' -> puttext;
               if);
               
               pause; (* apparently we need 2 pause to be sure that 
                       * mouseListener has been started before the VM suspends
                       *)
               (if descs.onlyCinterpreter and (runMode <> run_C_INT) then
                   '\n**** The C-interpreter (qbeta -c) has been selected'
                   '\n     since the program uses concurrency instructions'
                   -> putline;
                   run_C_INT -> runMode
               if);
               1 -> glsc;
               thisObj[] -> root[];
               (if runMode
                // run_C_INT then
                   (# BC,imageSize: @integer
                   do (* '*** C interpreter - main desc: '->puttext; 
                       * descInx -> putint;
                       *)
                      (descInx,none) -> descs.serialize
                      (#
                      do BI.top -> imageSize;
                         (* ', imageSize: ' -> puttext; imageSize -> putint;
                          *  newline; 
                          *)
                      #) -> BC;                                           
                      (BC,imageSize,true) -> init_interpreter;
                      isXbeta -> run_interpreter;
                      true -> first;
                      L: (if first -> getEvent -> decodeEvent then
                             false -> first;
                             restart L                            
                         if);
                      close_interpreter;
                      (* '\n\n***** end of C interpreter\n' -> puttext;*)
                      stop; (*suspend;*)
                   #)
               if);
               (none,thisObj[],none,thisCode.descInx,glsc) -> startEvent;
               Loop:
                 (# doCall:
                      (# withEnablingSuspend: @boolean
                      enter withEnablingSuspend
                      do 'call'-> exel; op1asChar -> inx; 
                         inx -> out.putint; ' ' -> out.put;
                         
                         thisStack.rpop -> callee[];
                         (if callee[] = none then 
                             6 -> fatalError ;
                             leave doCall
                         if);
                         stacksToOut;
                         (out[],'\n   callee : ') -> callee.dumpObj;
                         (if withEnablingSuspend then
                             callee[] -> enablee[]
                         if);

                         (thisCode.descInx,glsc) -> thisObj.saveReturn;

                         (if callee.rstackIsEmpty then 
                             '   first ' -> out.puttext;
                             inx -> out.put; ' ' -> out.put; 
                             inx -> out.putint; out.newline;
                             (*(':first>',true,out[])  -> thisObj.dump;
                             (':first>stack',true,out[])  -> thisStack.dump;*)
                             thisObj[] -> Y[] -> callee.rpush;
                             thisStack[] -> callee.rpush;
                             callee[] -> thisObj[];
                             thisObj.myCode -> thisCode[];
                             thisObj.mySuperCode -> thisCode[];
                             (if inx
                              // 'N' then 
                                 thisObj.myCode -> thisCode[];
                                 thisCode.enterE -> glsc
                              // 'D' then 
                                 thisCode.doE -> glsc;
                                
                                 (Y[],thisObj[],thisObj.myOrigin,0,glsc, withEnablingSuspend)
                                   -> doEvent  
                              // 'X' then
                                 thisCode.exitE -> glsc
                              else
                                 ' ? ' -> out.puttext; inx -> out.put
                             if);
                          else '   resume:\n' -> out.puttext;
                             (if inx
                              // 'N' then
                                 (*(':resume:N:',true,screen[]) -> callee.dump;*)
                                 thisObj[] -> Y[] -> callee.rpush; 
                                 thisStack[] -> callee.rpush;
                                 callee[] -> thisObj[]; 
                                 thisObj.myCode -> thisCode[]; 
                                 (*thisObj.mySuperCode -> thisCode[]; *)
                                 thisCode.enterE -> glsc; 
                              // 'X' then
                                 (':coroutine:exit',false,out[]) -> thisObj.dump;
                                 thisObj[] -> Y[] -> callee.rpush;
                                 thisStack[] -> callee.rpush;
                                 callee[] -> thisObj[];
                                 thisObj.myCode -> thisCode[];
                                 thisObj.mySuperCode -> thisCode[];
                                 thisCode.exitE -> glsc
                              else
                                 (thisObj[],callee[],callee.myOrigin
                                 ,0,glsc,withEnablingSuspend) -> resumeEvent;
                                 (if withEnablingSuspend or true (*coArg*) then
                                     (thisObj[],thisStack[]) 
                                       -> callee.rswap 
                                       -> (thisObj[],thisStack[]);
                                  else
                                     (thisObj[],thisStack[]) 
                                       -> callee.rswap 
                                       -> (thisObj[],X[])
                                 if);
                                 (out[],'   after:swap:thisObj:\n     ')
                                   -> thisObj.dumpObj;
                                 (if thisStack[] <> thisObj[] then
                                     '\n*** resume: thisObj<>thisStack'
                                       ->out.puttext;
                                     ('thisObj',true,out[])  -> thisObj.dump;
                                     ('stack',true,out[])  -> thisStack.dump;
                                 if);
                                 thisObj.restoreReturn -> (descInx,glsc);
                                 descs.OD[descInx].bc[] -> thisCode[];   
                                 thisObj.lsc -> glsc; 
                                 (* 'descInx: ' -> puttext; descInx -> putint;
                                  * ' glsc: ' ->puttext; glsc->putint; newline*)
                             if)
                         if);
                      #);
                    doSuspend:
                      (# callee: ^objDesc.template;
		         preemptive: @boolean;
                      enter (callee[], preemptive)
                      do callee.myId -> out.puttext;
                         stacksToOut;
                         glsc -> thisObj.lsc; (* why is saveReturn not enough? *)
                         (if (thisObj[] <> thisStack[]) then
                             '\n\n**** external suspend: thisObj<>thisStack'
                               ->out.putline;
                             (out[],'   thisObj   = ') -> thisObj.dumpObjFull;
                             (out[],'   thisStack = ') -> thisStack.dumpObjFull;
                         if); 
                         out.newline;
                         (out[],'   before:swap:thisObj:\n     ') 
                           -> thisObj.dumpObjFull;
                         (out[],'   before:swap:thisStack:\n     ') 
                           -> thisStack.dumpObjFull;
                         (thisCode.descInx,glsc) -> thisObj.saveReturn;
                         (thisObj[],thisStack[]) 
                           -> callee.rswap -> (thisObj[],thisStack[]);
                         (if (thisObj[] <> thisStack[]) then
                             '\n\n**** external suspend:return: thisObj<>thisStack'->out.putline
                         if);
                         thisObj.restoreReturn -> (descInx,glsc);
                         descs.OD[descInx].bc[] -> thisCode[];
                         callee[] -> thisStack.rpush;
                         (out[],'   after:swap:thisObj:\n     ')
                         -> thisObj.dumpObjFull;
                         (out[],'   after:swap:thisStack:\n     ') 
                           -> thisStack.dumpObjFull;
                         (thisObj[],callee[],thisObj.myOrigin,thisCode.descInx,glsc, preemptive) 
                           -> suspendEvent;                         
                      #);
                    exe: 
                      (# T: ^text ; F: ^file
                      enter T[] 
                      do inner;
                         out.newline; 
                         thisObj.myName -> out.puttext;':'-> out.put;
                         glsc -> out.putint;':' -> out.put; '\t' -> out.put;
                         T[] -> out.puttext; ' '-> out.put; glsc+1 -> glsc; 
                         (if out## = File## then
                             out[] -> F[]; F.flush
                         if)
                      #);
                    exel: exe(# do out.newline #);
                    op1: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.putint; ' ' -> out.put; 
                         glsc + 1 -> glsc
                      exit arg
                      #);
                    op1asChar: 
                      (# arg: @integer
                      do thisCode.B[glsc] -> arg -> out.put; ' ' -> out.put; 
                         glsc + 1 -> glsc
                      exit arg 
                      #);
                    op2: 
                      (# arg: @integer
                      do thisCode.B[glsc] * 256 + thisCode.B[glsc+1] -> arg -> out.putint; ' ' -> out.put; 
                         glsc + 2 -> glsc
                      exit arg
                      #);
                    op8:
                      (# X: @real; L1,L2: @integer
                      do (for i: 8 repeat
                              (*thisCode.B[glsc + i - 1] -> puthex; newline;*)
                              thisCode.B[glsc + i - 1] %putByteAt (@@X + i - 1)
                         for);
                         (for i: 4 repeat
                              thisCode.B[glsc + i - 1] %putByteAt (@@L1 + i -1);
                              thisCode.B[glsc + 4 + i - 1] %putByteAt (@@L2 + i - 1)
                         for);
                         glsc + 8 -> glsc;
                      exit(X,L1,L2)
                      #);
                    StacksToOut:
                      (#
                      do '\n\tthisObj   = ' -> out.puttext; 
                         thisObj.myName -> out.puttext; ':'->out.put;
                         out[] -> thisObj.dumpStacks;
                         '\n\tthisStack = ' -> out.puttext; 
                         thisStack.myName -> out.puttext; ':'->out.put;
                         out[] -> thisStack.dumpStacks
                      #);
                    VtoOut:
                      (# obj: ^ObjDesc.template; off,val: @integer
                      enter(obj[],off,val)
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                        '=' -> out.put; val -> out.putint;
                      #);
                    FtoOut:
                      (# obj: ^ObjDesc.template; off,L1,L2: @integer; val: @real;
                      enter(obj[],off,L1,L2)
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                         '=' -> out.put; 
                         (if true then
                             L1 %putLongAT (@@val);
                             L2 %putLongAt (@@val + 4);
                             val -> out.putReal; ' ' -> out.put;
                             L2 %putLongAT (@@val);
                             L1 %putLongAt (@@val + 4);
                             val -> out.putReal
                          else
                             L1 -> out.putint; ' ' -> out.put;
                             L2 -> out.putint
                         if)
                      #);
                    RtoOut:
                      (# obj,Ref: ^ObjDesc.template; off,val: @integer
                      enter(obj[],off,Ref[])
                      do obj.myName -> out.puttext;
                        '['->out.put; off->out.putint; ']' -> out.put;
                         '=' -> out.put; 
                         (if Ref[] = none then
                             'none' -> out.puttext
                          else
                             ref.myName -> out.puttext
                         if)
                      #);
                    descInx,size,isValueObj,isRindexed,dinx,rangee,inx,length,serverId
                    ,handle,msgId,rtnVal, off, value,on,lab,pn:
                      @integer;
                    hasRtnVal: @boolean;
                    callee,R,X,Y,rtnRef: ^ObjDesc.Template;
                    top1,top2: @integer;
                    float1,float2: @real
                 do (if glsc -> thisCode.isBreak then
                        (thisObj.myDyn,thisObj[],thisObj.myOrigin,0,glsc) 
                          -> breakEvent
                    if);
                    (if suspendEnabled = 1 then
                        timeToSuspend - 1 -> timeToSuspend;
                        (if (timeToSuspend <= 0) (*and (allocLevel = 0)*) then
                            (*'allocLevel: ' -> puttext; allocLevel -> putint;
                             * newline;*)
                            (if testConc then
                                '\n**** external suspend: ' -> putline;
                            if);
                            '\n**** external suspend:enablee ' 
                              -> out.puttext;
                            (if enablee[] <> none then
                                enablee.myId -> out.puttext;
                                suspendEnabled - 1 -> suspendEnabled;
                                (enablee[], true) -> doSuspend;
                                none -> enablee[]
                             else
                                (* either a compile error
                                 * or disable/eanble used without 
                                 * attach having been called
                                 *)
                                'none ' -> out.puttext;
                            if)
                        if)
                    if);

                    (if thisCode.B[glsc]
                     // codes.pushc then
                        'pushc' -> exe;
                        op1 ->  thisStack.vpush;
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.pushNone then
                        'pushNone' -> exe;
                        none -> thisstack.rpush;
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,none)
                          -> rPushEvent
                     // codes.pushc2 then
                        'pushc2' -> exe;
                        op2 -> thisStack.vpush; 
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.pushthis then
                        'pushthis' -> exe;
                        thisObj[] -> thisStack.rpush;
                        StacksToOut; 
                        (thisObj[],thisObj[],false,thisStack[],0,false
                        ,0,thisCode.descInx,glsc,thisObj[])
                          -> rPushEvent
                     // codes.push then
                        'push' -> exe;
                        op1 -> off -> thisObj.get -> thisStack.vpush;
                        (thisObj[],thisObj[],false,thisStack[],off,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.rpush then
                        'rpush' -> exe;
                        op1 -> off -> thisObj.rget -> X[];
                        ' ' -> out.put; thisObj.myName -> out.puttext;
                        '[' -> out.puttext; off -> out.putint; ']' 
                          -> out.put;
                        '='->out.put; 
                        (if X[] = none then 
                            'none' -> out.puttext
                         else
                            X.myName -> out.puttext;
                        if);
                        X[] -> thisStack.rpush;

                        (thisObj[],thisObj[],false,thisStack[],off,false
                        ,thisCode.descInx,glsc,0,thisStack.rTopElm) 
                          -> rPushEvent
                     // codes.pushg then
                        'pushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        op1 -> off;
                        (if thisStack.valOff > 0 then 
                            ' +(' -> out.puttext;
                            thisStack.valOff -> out.putint; 
                            ')' -> out.put;
                        if);
                        off -> X.get -> top1 -> thisStack.vpush;
                        (X[],off,top1) -> VtoOut;
                        (thisObj[],X[],true,thisStack[],off,false
                        ,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent
                     // codes.fpushg then
                        'fpushg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then
                            3 -> fatalError; leave loop
                        if);
                        op1 -> off;
                        (if thisStack.valOff > 0 then 
                            ' +$ ' -> out.puttext;
                            thisStack.valOff ->out.putint; ' '->out.put;
                        if);
                        off -> X.get -> top1 -> thisStack.vpush;
                        off + 1-> X.get -> top2 -> thisStack.vpush;
                        (X[],off,top1,top2) -> FtoOut;
                        (thisObj[],X[],true,thisStack[],off,false,0
                        ,thisCode.descInx,glsc,thisStack.vTopElm) 
                          -> vPushEvent                        
                     // codes.ovpushg then
                        (* Object X on stack
                         * with object P embedded at offset inx in X
                         * inx is on vStack
                         * Push P[off] = X[inx + off - 1]
                         *)
                        'ovpushg'-> exe; op1 -> off; 
                        thisStack.vpop -> descInx;
                        thisStack.vpop -> inx;
                        'originAdjust:' -> out.puttext; 
                        inx -> out.putint;
                        ' '-> out.put;
                        thisStack.rpop -> X[];
                        (if X[] = none then 
                            3 -> fatalError; leave loop if);
                        out.newline;
                        (out[],'ovpushg: ') -> X.dumpObjFull;
                        ('ovpushg:',true,out[]) -> X.dump;
                        inx + off - 1 
                          -> X.get -> top1 -> thisStack.vpush;
                        (X[],inx + off - 1 ,top1) -> VtoOut;
                     // codes.fovpushg then
                        'fovpushg'-> exe; op1 -> off; 
                        thisStack.vpop -> descInx;
                        thisStack.vpop -> value; (* not a value, inx?*)
                        'originAdjust:' -> out.puttext; 
                        value -> out.putint; 
                        ' '-> out.put;
                        thisStack.rpop -> X[];
                        (if X[] = none then 
                            3 -> fatalError; leave loop if);
                        off + value - 1 -> X.get 
                          -> top1 -> thisStack.vpush;
                        off + 1 + value - 1 -> X.get 
                          -> top1 -> thisStack.vpush;
                        (X[],off + value - 1 ,top1) -> VtoOut
                        
                     // codes.rpushg then
                        'rpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        (*('rpushg:',true,screen[]) -> X.dump;*)
                        (if X[] = none then 
                            3 -> fatalError; leave loop if);
                        off -> X.rget -> Y[];
                        Y[]-> thisStack.rpush;
                        (X[],off,Y[]) -> RtoOut;
                        (thisObj[],X[],true,thisStack[],off,false,0
                        ,thisCode.descInx,glsc,thisStack.rTopElm) 
                          -> rPushEvent
                     // codes.xpush then
                        'xpush' -> exe;
                        (*  thisStack.rpop -> X[]; - not used *)
                        op1 -> off;
                        thisStack.vpop -> inx;
                        off + inx + newAllocOff
                          -> thisObj.get 
                          -> thisStack.vpush;
                        (* '\nxpush: off: ' -> puttext; off -> putint;
                         ' inx: ' -> puttext; inx -> putint; newline;*)
                        
                        (thisObj[],thisObj[],false,thisStack[],off,true
                        ,inx,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent
                     // codes.xrpush then
                        'xrpush' -> exe;
                        op1 -> off;
                        thisStack.vpop -> inx;
                        off + inx + newAllocOff -> thisObj.rget -> X[];
                        X[] -> thisStack.rpush;
                        (thisObj[],thisObj[],false,thisStack[],off,true,inx,thisCode.descInx,glsc,thisStack.rTopElm)
                          -> rPushEvent
                     // codes.xpushg then
                        (# ix: @integer
                        do 'xpushg' -> exe; op1 -> off; 
                           op1 -> isValueObj; op1 -> size;
                           thisStack.rpop -> X[];
                           thisStack.vpop -> inx;
                           'inx: ' -> out.puttext; inx ->out.putint;
                           out.newline;                           
                           ('xpushg:',true,out[]) -> X.dump;
                           (if (isValueObj = 0) and (size = 1) then
                               (* basic object: imply size = 1
                                * off = 1, probably the same value
                                * as used in QallocIndexed and
                                * off newAllocOff = 2, always!?
                                *)
                               inx + off + newAllocOff -> ix;
                               ix -> X.get -> value -> thisStack.vpush;
                               (X[],ix,value) -> VtoOut;
                            else (* valueObject *)
                               (if size > 1 then
                                   (for i: size repeat
                                        inx + off + newAllocOff + i - 2 
                                          -> ix -> X.get
                                          -> thisStack.vPush;
                                   for)
                                else
                                   inx + off + newAllocOff + 1 - 2  -> ix 
                                     -> thisStack.vPush;
                                   X[] -> thisStack.rpush
                               if);
                               (*X[] -> thisStack.rpush - why ? *)
                           if);
                           ('xpushg:',true,out[]) -> thisStack.dump;
                           (thisObj[],R[],true,thisStack[],off,true,inx
                           ,thisCode.descInx,glsc,thisStack.vTopElm)
                             -> vPushEvent  
                        #)
                     // codes.xrpushg then
                        'xrpushg' -> exe;
                        thisStack.rpop -> X[];
                        op1 -> off;
                        thisStack.vpop -> inx;
                        X[] -> R[];
                        (*'inx: ' -> puttext; inx -> putint; newline;*)
                        (*('xrpushg:',true,screen[]) -> X.dump;*)
                        off + inx + newAllocOff
                          -> R.rget -> thisStack.rpush;
                        (thisObj[],R[],true,thisStack[],off,true,inx
                        ,thisCode.descInx,glsc,thisStack.rTopElm)
                          -> rPushEvent                      
                     // codes.rstore  then
                        'rstore' -> exe; 
                        op1->off;
                        thisStack.rpop -> X[]; (* if multiple assignment of X, 
                                                * violation error happens
                                                * compiler error?
                                                *)
                        (if X[] = none then
                            'none'->out.puttext
                         else
                            X.myName -> out.puttext
                        if);
                        '->' -> out.puttext;
                        thisObj.myName -> out.puttext;
                        '[' -> out.put; off -> out.putint; ']'-> out.put;
                        (off,X[]) -> thisObj.rput;
                        (thisObj[],thisStack[],false,thisObj[],off,false,0,thisCode.descInx,glsc,X[]) 
                          -> rStoreEvent
                     // codes.pushValue then
                        (# size,srcOff,value: @integer;
                           srcObj: ^ObjDesc.template
                        do 'pushValue' -> exe; op1 -> size;
                           thisStack.vPop -> descInx;
                           thisStack.vPop -> srcOff;
                           thisStack.rPop -> srcObj[];
                           ' srcOff:'->out.puttext; srcOff -> out.putint;
                           ('src',true,out[]) -> srcObj.dump;
                           (for i: size repeat
                                'val:' -> out.puttext; srcOff + i - 1 -> out.putint;
                                '='-> out.put;
                                srcOff + i - 1 -> srcObj.get -> value;
                                value -> thisStack.vPush;
                                value -> out.putint; ',' -> out.put
                           for);
                           out.newline;
                           stacksToOut
                        #)
                     // codes.vassign then
                        (# size,mode,destOff: @integer; 
                           destObj: ^ObjDesc.template;
                           D: [10] @integer
                        do 'vassign' -> exe; op1 -> size; op1 -> mode;
                           stacksToOut;
                           thisStack.vpop -> destOff;
                           thisStack.rpop -> destObj[];
                           ('thisStack:before',true,out[]) ->thisStack.dump;
                           ('thisObj:before',true,out[]) -> thisObj.dump;
                           (for i: size repeat thisStack.vPop -> D[i] for);
                           
                           (if (mode = 1) then
                               thisStack.vPop -> descInx;
                               '**** originIsValue:destOff: ' ->out.puttext;
                               destOff + thisStack.vPop - 1 
                                 -> destOff
                                 -> out.putint; 
                           if);
                           out.newline;
                           
                           ('dest:before',true,out[]) -> destObj.dump;
                           (for i: size repeat
                                D[i] -> value;
                                'copy:' -> out.puttext; 
                                value -> out.putint; ',' -> out.put;
                                (destOff + size - i, value) -> destObj.put
                           for);
                           out.newline;
                           stacksToOut;
                           ('dest:after',true,out[]) -> destObj.dump;
                           (destObj[],3, destOff -> destObj.get
                           , destOff+1 -> destObj.get) -> FtoOut;
                        #)
                     // codes.store  then
                        'store' -> exe;
                        (op1 -> off,thisStack.vpop -> value) -> thisObj.put;
                        value -> out.putint; '->' -> out.puttext;
                        thisObj.myName -> out.puttext; 
                        '[' -> out.put; off -> out.putint; ']' -> out.put;
                        (thisObj[],thisStack[],false,thisObj[],off,false
                        ,thisCode.descInx,glsc,0,value) 
                          -> vStoreEvent
                     // codes.storeg  then
                        'storeg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.vpop -> value;
                        op1 -> off;
                        (if X.valOff > 0 then 
                            '+(' -> out.puttext;
                            thisStack.valOff -> out.putint; ')' -> out.put;
                            (if not isValObj then
                                'isValObj=false ' -> out.puttext
                            if)
                         else
                            (if isValObj then
                                'isValObj=true ' -> out.puttext
                            if)
                        if);
                        (off,value) -> X.put;
                        (X[],off,value) -> VtoOut;
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,value) 
                          -> vStoreEvent
                     // codes.fstoreg  then
                        'fstoreg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.vpop -> top2;
                        thisStack.vpop -> top1;
                        op1 -> off;
                        (if thisStack.valOff > 0 then 
                            '+$ ' -> out.puttext;
                            thisStack.valOff -> out.putint; ' ' -> out.put
                        if);
                        (off,top1) -> X.put;
                        (off + 1,top2) -> X.put;
                        (X[],off,top1,top2) -> FtoOut;
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,value) 
                          -> vStoreEvent                        
                     // codes.ovstoreg then
                        'ovstoreg'-> exe; op1 -> off; 
                        thisStack.vpop -> value;
                        'originAdjust:' -> out.puttext; value -> out.putint; ' '-> out.put;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave Loop if);
                        thisStack.vpop -> descInx;
                        thisStack.vpop -> inx;
                        (off + inx - 1,value) -> X.put;
                        (X[],off + value - 1 ,value) -> VtoOut
                     // codes.fovstoreg then
                        'fovstoreg'-> exe; op1 -> off; 
                        thisStack.vpop -> top2;
                        thisStack.vpop -> top1;
                        'originAdjust:' -> out.puttext; value -> out.putint; ' '-> out.put;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave Loop if);
                        thisStack.vpop -> descInx;
                        thisStack.vpop -> inx;
                        (off + inx - 1,top1) -> X.put;
                        (off + 1 + inx - 1,top2) -> X.put;
                        (X[],off + value - 1 ,top1,top2) -> FtoOut
                     // codes.rstoreg  then
                        'rstoreg' -> exe;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        thisStack.rpop -> Y[];
                        (op1 -> off,Y[]) -> X.rput;
                        (X[],off,Y[]) -> rToOut;
                        (thisObj[],thisStack[],true,X[],off,false,0,thisCode.descInx,glsc,Y[]) 
                          -> rStoreEvent
                     // codes.xstore then
                        'xstore' -> exe;
                        (*('xstoreA',true,screen[])  -> thisObj.dump;*)
                        (* thisStack.rpop -> X[]; - not used *)
                        op1 -> off;
                        thisStack.vpop -> inx;
                        (thisStack.vpop -> value,off + inx + newAllocOff)
                          -> thisObj.assign;
                        ' ' -> out.put; value -> out.putint; 
                        '->' -> out.puttext; 
                        thisObj.myName -> out.puttext;
                        '.V[' -> out.puttext; 
                        off -> out.putint; '+' -> out.put;
                        inx -> out.putint; ']' -> out.put;
                        (*('xstoreB',true,screen[])  -> thisObj.dump;*)
                        (thisObj[],thisStack[],false,thisObj[],off,true,inx,thisCode.descInx,glsc,value) 
                          -> vStoreEvent 
                     // codes.xrstore then
                        'xrstore' -> exe;
                        op1 -> off;
                        thisStack.vpop -> inx;
                        thisStack.rpop -> X[];
                        (off + inx + newAllocOff, X[]) -> thisObj.rput;
                        (thisObj[],thisStack[],false,thisObj[],off,true,inx,thisCode.descInx,glsc,value) 
                          -> vStoreEvent                        
                     // codes.xstoreg then
                        'xstoreg' -> exe;op1 -> off; op1 -> isValueObj; op1 -> size;
                        stacksToOut; out.newline;
                        thisStack.rpop -> X[];
                        (if X[] = none then 3 -> fatalError; leave loop if);
                        X[] -> R[];
                        thisStack.vpop -> inx;
                        (if isValueObj = 1 then thisStack.vPop -> value (* not used *) if);
                        (# RX: [2] @integer; top: @integer;
                        do (for i: size repeat
                                (if size = 2 then (*  if true  ?*)
                                    (thisStack.vpop 
                                      -> value -> RX[top + 1 -> top]
                                    ,off + inx + newAllocOff - i + 1)
                                      -> R.assign;
                                 else
                                    (thisStack.vpop -> value,off + inx + newAllocOff - i + 1)
                                      -> R.assign;
                                if);
                           for);
                           (if size = 2 then
                               (X[],off,RX[2],RX[1]) -> FtoOut;
                               out.newline;
                           if);
                        #);
                        (X[],off + inx + newAllocOff,value) -> VtoOut;
                        ('xstoreg:',true,out[]) -> R.dump;
                        (thisObj[],thisStack[],true,R[],off,true,inx,thisCode.descInx,glsc,value) -> vStoreEvent
                       // codes.xrstoreg then
                        'xrstoreg' -> exe; op1 -> off;
                        stacksToOut; out.newline;
                        thisStack.rpop -> X[];
                        X[] -> R[];
                        thisStack.vpop -> inx;
                        thisStack.rpop -> Y[];
                        (off + inx + newAllocOff,Y[]) -> R.rput;
                        (X[],off + inx,Y[]) -> RtoOut;
                        (thisObj[],thisStack[],true,R[],off,true,inx,thisCode.descInx,glsc,Y[]) -> rStoreEvent                      
                     // codes.double then
                        'double' -> exe;
                        thisStack.vdub;
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm)
                          -> vPushEvent
                     // codes.rdouble then
                        'rdouble' -> exe;
                        thisStack.rdub;
                        (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.rTopElm)              
                          -> rPushEvent
                     // codes.rpop then
                        'rpop' -> exe;
                        thisStack.rpop;
                     // codes.vpop then
                        'vpop'-> exe;
                        thisStack.vpop;
                     // codes.swap then
                        (# arg1,arg2: @integer
                        do 'swap' -> exe;
                           thisStack.vPop -> arg1;
                           thisStack.vPop -> arg2;
                           arg1 -> thisStack.vPush;
                           arg2 -> thisStack.vPush;
                        #)
                     // codes.rswap then
                        'rswap' -> exe; op1 -> inx;
                           (* (if inx > 0 then thisstack.rpop if);*)
                        (if inx > 0 then 
                            (if false then
                                '*** betaVM:rswap: ' -> puttext; 
                                inx -> putint;
                                newline;
                            if);
                            stacksToOut;
                            inx -> thisStack.rswapIndexed;
                            stacksToOut;
                        else
                            thisstack.rpop -> X[];
                            thisstack.rpop -> Y[];
                            X[] -> thisstack.rpush;
                            Y[] -> thisstack.rpush;
                        if);
                     // codes.alloc then
                        'alloc' -> exel; op2 -> descInx; op1 -> isObj;
                        (* ('Alloc:',true,screen[]) -> thisObj.dump;*)
                        thisStack.rpop -> X[]; (* origin *)
                        (X[],descInx,isObj = 1) -> alloc;
                        StacksToOut;
                     // codes.tstOriginNone then
                        'tstOriginNone' -> exe;
                        (if thisStack.rTopElm = none then
                            10 -> fatalError; leave loop
                        if);                        
                     // codes.invoke then
                        (* ('Alloc:',true,screen[]) -> thisObj.dump;*)
			(*'\n\nBefore invoke:' -> out.puttext;
                        stacksToOut;*)
                        'invoke' -> exel; 
                        op2 -> descInx; op2 -> off; op1 -> isObj;
                        (descInx,off,isObj = 1 ) -> invoke;
                        StacksToOut;  
                        (*('invoke:thisObj',true,screen[]) -> thisObj.dump;
                         * ('invoke:thisStack',true,screen[]) -> thisStack.dump
                         *)
                     // codes.mkVindexed then
                        'mkVindexed' -> exel;
                        (op2,false) -> mkIndexed
                     // codes.mkRindexed then
                        'mkRindexed' -> exel;
                        (op2,true) -> mkIndexed
                     // codes.saveAndSetThis then
                        'saveAndSetThis' -> exel;
                        stacksToOut;
                        thisStack.rPoP -> X[];
                        thisObj[] -> thisStack.rPush;
                        X[] -> thisObj[]
                     // codes.restoreThis then
                        'restoreThis' -> exel;
                        stacksToOut;
                        thisStack.rPop -> thisObj[];
                        stacksToOut
                     // codes.invokeVal then
                        StacksToOut;
                        'invokeVal' -> exel;
                        op2 -> descInx; op2 -> off;
                        (descInx,off) -> invokeVal;   
                        StacksToOut
                     // codes.boxedInvokeVal then
                        'boxedInvokeVal' -> exel;
                        op2 -> descInx; op2 -> rangee;
                        (* The saveReturn is quite tricky. 
                         * We save glsc + 3 to return past
                         *    mvStack
                         *    rtn D
                         * after the call og boxedInvokeVal
                         *)
                        stacksToOut;
                        (thisCode.descInx,glsc + 3 ) -> thisObj.saveReturn;
                        stacksToOut;
                        (none,descInx,1,1,rangee,0) -> QallocIndexed;
                        stacksToOut;
                        thisStack.rPop -> callee[];
                        thisObj[] -> callee.rPush;
                        thisStack[] -> callee.rPush;
                        callee[] -> thisObj[];
                        ('BoxedInvokeVal:',true,out[]) -> thisObj.dump;
                        (descInx,2) -> invokeVal;
                        ('BoxedInvokeVal:',true,out[]) -> thisObj.dump;
                     // codes.allocIndexed then
                        'allocIndexed' -> exel; 
                        op2 -> descInx; op1 -> size; op1 -> isRIndexed;
                        (if not isXbeta then
                            thisStack.rpop -> X[]; (* origin *)
                         else (* a superflous thisObj is pushed by compiler
                               * should be eliminated
                               *)
                            thisStack.rpop -> X[]; (* origin *)
                        if);
                        thisStack.vpop -> dinx;
                        (if newVM and not isXbeta then
                            thisStack.vpop -> isRindexed;
                        if);
                        thisStack.vpop -> rangee;
                        (if isXbeta then
                            (X[],descInx,size,dinx,rangee,isRindexed) 
                              -> QallocIndexed
                         else
                            (X[],descInx,isObj,dinx,rangee,isRindexed) 
                              -> AllocIndexed
                        if)
                     // codes.exeAlloc then
                        'exeAlloc' -> exel; op2 -> descInx;
                        thisStack.rpop -> X[]; (* origin *)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        thisObj[] -> thisObj.rPush; (* return *)
                        (* 30.08.2013: we changed the order of the next two 
                         * statements. The push used to be after the assigment.
                         * Is this correct?
                         *)
                        thisStack[] -> thisObj.rpush;
                        thisObj[] -> thisStack[]; 

                        X[] -> thisObj.rpush;

                        descs.OD[descInx].bc[] -> thisCode[];
                        descs.OD[descInx].BC.allocE -> glsc;
                        (if false then
                            (* called if this object has a super
                             * reconsider if/when this is an event
                             * Also the isObject arg should be defined in the code
                             * is currentli 0 (zero)
                             *)
                            (thisObj[],thisObj[],X[],thisCode.descInx,glsc,false,false) -> allocEvent
                        if);
                        allocLevel + 1 -> allocLevel
                     // codes.newVrep then
                        'newVrep' -> exe;
                        (1,thisStack.vpop,2,0) 
                          -> descs.OD[1].template 
                          -> thisStack.rpush;
                     // codes.send then 
                        'send' -> exel; op1 -> descInx;
                        (descInx,false,0,0) -> allocTemplate -> callee[];
                        (* save return *)
                        '\nsend: ' -> puttext;
                        callee.myId -> puttext;
                         ' ' -> put; glsc -> putint; newline;
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        descs.OD[descInx].bc[] -> thisCode[];
                        thisObj[] -> callee.rPush;
                        callee[] -> thisObj[];
                        descs.OD[descInx].BC.procE -> glsc
                     // codes.sendv then
                        L:
                          (# R: [10]^ObjDesc.template; top: @integer;
                             recIsValObj: @integer
                          do 'sendv ' -> exel;
                             op1 -> dinx; op1 -> inx; (* noOfRefArgs*)
                             op1 -> recIsValObj;
                           (if inx > 0 then
                               (for i: inx repeat
                                    thisObj.rpop -> R[top + 1 -> top][]
                           for)if);
                           thisObj.rpop -> X[];                            
                           (if X[] = none then 
                               3 -> fatalError;
                               leave loop 
                           if);
                           (if (inx > 0) then
                               ('sendv:X:',true,out[]) -> X.dump;
                               ('sendv:thisObj:',true,out[]) 
                                 -> thisObj.dump;
                           if);
                             (if true
                              // isValObj then
                                 (if false then
                                     '\n** Virtual call in value object:sendv' 
                                       -> putline;
                                     '**** Virtual call in value object:sendv'
                                       -> out.putline;
                                     ('sendv:X:',true,screen[]) -> X.dump;
                                     ('sendv:thisObj:',true,screen[]) 
                                       -> thisObj.dump;
                                 if);
                                 stacksToOut;
                                 thisValObjDesc.vdtTable[dinx] -> descInx; 
                                 thisValObjDescInx -> thisStack.vPush
                              // recIsValObj = 1 then
                                 (if false then
                                     '\n** Virtual call in value object:sendvX' 
                                       -> putline;
                                 if);
                                 descs.OD[thisStack.vTopElm].vdtTable[dinx]
                                   -> descInx
                            else
                               (X.myObjDesc).vdtTable[dinx] -> descInx; 
                           if);
                           descInx -> out.putint; ' ' -> out.put;
                           
                           (if descInx = 0 then 
                               8 -> fatalError;
                               leave loop 
                           if);
                           (* copy of send below *)
                           (descInx,false,0,0) -> allocTemplate -> callee[];
                           callee.myId -> out.putline;
                           (thisCode.descInx,glsc) -> thisObj.saveReturn;
                           descs.OD[descInx].bc[] -> thisCode[];
                           thisObj[] -> Y[] -> callee.rPush;
                           thisStack[] -> callee.rPush;
                           (if isXbeta then
                               X[] -> thisStack.rpush;
                               callee[] -> thisObj[];
                            else
                               X[] -> callee.rpush;
                               callee[] -> thisStack[]  -> thisObj[];
                           if);
                           descs.OD[descInx].BC.allocE -> glsc;
                           (for i: inx repeat
                                R[top - i + 1][] -> thisStack.rpush
                           for);
                           (* we need to distinguish if we generate 
                            * an object or
                            * an activation. For now we assume an activation
                            *)
                           (*StacksToOut;*)
                           false -> isValObj;
                           (if not isXbeta then
                               (Y[],thisObj[],X[],thisCode.descInx,glsc,false,false) 
                                 -> allocEvent
                           if)
                        #)
                     // codes.mvStack then
                        'mvStack'-> exe;
                        (*('mvstackA',true,screen[])  -> thisObj.dump;*)
                        thisObj[] -> thisStack[];
                        (*StacksToOut;*)
                        (*('mvstackB',true,screen[])  -> thisObj.dump;*)
                     // codes.setThisStack then
                        'setThisStack' -> exe;
                        (*('setThisStack:thisObj',true,screen[])  -> thisObj.dump;*)
                        StacksToOut;
                        thisObj.rTopElm -> thisStack[];
                        StacksToOut
                     // codes.rpopThisObj then
                        'rpopThisObj' -> exe;
                        stacksToOut;
                        thisObj.rpop -> thisObj[];
                        stacksToOut;
                     // codes.toSuper then
                        'toSuper' -> exe; op2 -> inx -> out.putint; 
                        stacksToOut;
                        descs.OD[inx].bc[] -> thisCode[]; 
                        thisCode.allocE -> glsc;
                        ' glsc: '->out.puttext; glsc->out.putint;
                     // codes.call then
                        doCall
                     // codes.susp then
                        '*** susp'-> exel;
                        thisStack.rpop -> callee[]; (* returnee *)
                        (if (suspendEnabled = 1) and (callee[] = enablee[]) then
                            (if testConc then
                                '\n***exlicit suspend of suspendee'->putline;
                            if);
                            suspendEnabled - 1 -> suspendEnabled
                        if);
                        (callee[], false) -> doSuspend
                     // codes.doExit then
                        'doExit' -> exe;
                        thisObj.rTopElm-> thisStack[];
                        (thisObj[],thisStack[],thisStack.myOrigin,thisCode.descInx,glsc)
                          -> doExitEvent;
                     // codes.rtn then
                        'rtn' -> exel; op1asChar -> inx; 
                        thisObj.myId -> out.puttext; 
                        (if (suspendEnabled = 1) and (thisObj[] = enablee[]) then
                            (if testConc then
                                'Returning fra enabledSuspend'->putline;
                            if);
                            suspendEnabled - 1 -> suspendEnabled
                        if);
                        (*stacksToOut;*)
                        thisObj[] -> X[];
                        (if false then
                            thisObj.return -> (thisStack[],thisObj[])
                         else
                            thisObj.rpop -> thisStack[]; 
                            thisObj.rpop -> thisObj[]; 
                        if);
                        ' to: ' -> out.puttext; 
                        thisObj.myId -> out.puttext; 
                        thisObj.restoreReturn -> (descInx,glsc); 
                        descs.OD[descInx].bc[] -> thisCode[]; 
                        descs.OD[descInx].isValueObj ->isValObj;
                        (if not isXbeta then
                            X[] -> thisStack.rpush; 
                        if);
                        (if inx = 'A' then
                            (if thisObj[] <> X[] then
                                (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;
                            if);
                            allocLevel - 1 -> allocLevel
                        if);
                        stacksToOut
                     // codes.rtnV then
                        'rtnV' -> exe;
                        (*stacksToOut;*)
                        returnValue;
                        (*StacksToOut;*)
                     // codes.rtnEvent then 
                        'rtnEvent' -> exe; op1 -> inx;
                        (if thisObj.rstackIsEmpty then
                            '\n***rtnEvent : rstack empty'->out.putline
                        if);
                        (if newVM then
                            thisStack.rpop -> X[];  (* ??? *)
                         else
                            thisObj.rpop -> X[]; 
                        if);

                        (thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;                        
                     // codes.allocEventQ then
                        'allocEventQ' -> exe; op1 -> isObj;
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc,asObjEnabled,false)
                          -> allocEvent;
                        false > asObjEnabled
                     // codes.rtnEventQ then
                        'rtnEventQ' -> exe; op1 -> isObj; 
                        (*stacksToOut;*)
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc)
                          -> rtnEvent;
                     // codes.doEventQ then
                        'doEventQ' -> exe;
                        (1->thisObj.rTopElm,thisObj[]
                        ,thisObj.myOrigin,thisCode.descInx,glsc
                        ,false(*wihEnablingSuspend*))
                          -> doEvent;
                     // codes.rtnC then
                        'rtnC' -> exel;
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[]
                     // codes.rtnExit then 
                        (* could be rtn, except that thisStack is already updated
                         * apparently it is identical to rtn?
                         * Is no eliminated
                         *)
                        'rtnExit' -> exe;
                        thisObj[] -> X[];
                        thisObj.rpop -> thisObj[] -> thisStack[]; (* !*)
                        thisObj.restoreReturn -> (descInx,glsc);
                        descs.OD[descInx].bc[] -> thisCode[];
                        X[] -> thisStack.rpush;
                        (*(thisObj[],X[],X.myOrigin,thisCode.descInx,glsc) -> rtnEvent;*)
                     // codes.innerx then
                        'inner' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (*'\ninner: ' -> puttext; thisCode.descInx -> putint;
                             ' ' -> put; glsc -> putint; newline;*)
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if)
                     // codes.innerP then
                        'inner P' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        thisStack.rpop -> X[];
                        thisObj[] -> X.rpush;
                        X[] -> thisObj[];
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; out.newline; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (*'\ninner: ' -> puttext; thisCode.descInx -> putint;
                             ' ' -> put; glsc -> putint; newline;*)
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.doE -> glsc
                        if);
                       // codes.innera then
                        'innerA' -> exel;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; 
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.enterE -> glsc;
                            ' glsc: ' -> out.puttext; glsc -> out.putint
                        if);
                     // codes.innerExit then
                        'innerExit' -> exe;
                        op1 -> dinx; ' exe: ' -> out.puttext;
                        (thisObj.myObjDesc).vdtTable[dinx] -> descInx -> out.putint; ' ' -> out.put;
                        (if descInx > 0 then
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            descs.OD[descInx].BC[] -> thisCode[];
                            thisCode.exitE -> glsc
                        if)
                     // codes.rtnInner then
                        'rtnInner' -> exel;
                        thisObj.restoreReturn -> (descInx,glsc);
                        (*'\nreturnInner: ' -> puttext;
                         descInx -> putint; ' ' -> put; glsc -> putint; newline;*)
                        ' to: ' -> out.puttext; descInx -> out.putint; 
                        ' glsc: ' -> out.puttext; glsc -> out.putint;
                        out.newline;
                        descs.OD[descInx].BC[] -> thisCode[]
                     // codes.doSuper then
                        (* dosuper is the last instruction before rtn N 
                         * in the code for an enter part:
                         * enterN: ...
                         *         dosuper
                         *         rtn N
                         * For this reason we do not save thisObj and thisStack
                         * on the stack. 
                         * This implies that rtn N from the topmost descriptor
                         * returns to the object calling the main-part enter.
                         * We thus do not fall back through a chain of rtn N.
                         * However, it should work pushing thisObj/stack
                         * but it does not
                         * And: saveReturn below fills up lscStack
                         * SaveReturn should be not be done
                         *)
                        'doSuper' -> exel; (* perhaps just a jump? *)
                        op2 -> descInx;
                        (*'doSuper: ' -> puttext; descInx -> putint; newline;*)
                        (thisCode.descInx,glsc) -> thisObj.saveReturn;
                        (* thisObj shall not be pushed since we return from super *)
                        descs.OD[descInx].bc[] -> thisCode[]; 
                        descs.OD[descInx].BC.enterE -> glsc;
                     // codes.stop then
                        'stop' -> exe; out.newline;
                        (* leave Loop*)
                        '\n\nNo of objects: ' -> puttext; descs.ObjPool.id -> putint; newline;
                        true -> doTerminate
                     // codes.prim then
                        '%prim' -> exe;
                        (if op1
                         // prim.put then 
                            thisStack.vpop -> value -> putCh; 
                            value -> out.putint; ' ' -> out.put;
                            value -> out.put;
                            ('put',thisStack[],1,thisCode.descInx,glsc) -> popEvent
                         // prim.get then
                            getCh -> thisStack.vPush;
                            (thisObj[],thisObj[],false,thisStack[],0,false,0,thisCode.descInx,glsc,thisStack.vTopElm) 
                              -> vPushEvent
                         // 3 then
                            thisStack.rpop -> R[];
                            1 -> R.get -> thisStack.vpush; 
                         // 4 then
                            thisStack.rpop -> R[];
                            (thisStack.vpop,1) -> R.assign
                         // 5 then (* range *)
                            thisStack.rpop -> R[];
                            2 -> R.get -> thisStack.vpush;
                         // prim.sendMsg then 
                            thisObj.rpop -> X[];
                            (*(':sendMgs:text',true,screen[]) -> X.dump;*)
                            thisObj.vpop -> msgId;
                            thisObj.vpop -> handle;
                            thisObj.vpop -> serverId;
                            (serverId,handle,msgId,X[]) -> sendMsg;
                         // prim.attach then
                            ' attach: '-> out.puttext; 
                            thisObj.vpop -> value; 
                            value -> out.putint; ' '-> out.put;
                            stacksToOut;
                            ('attach',thisStack[],1,thisCode.descInx,glsc) -> popEvent;
                            (*(if suspendEnabled then
                                '\n***ERROR: attach suspendEnabled = true'->putline
                            if);*)
                            suspendEnabled + 1 -> suspendEnabled; 
                            value -> timeToSuspend;
                            glsc - 1 -> glsc; (* hack since doCall assumes
                                               * a call op and thereby lsc++
                                               *)
                            true -> doCall (* requires 'D' argument *)
                         // prim.disable then 
                           (* (if not suspendEnabled then
                                '\n***ERROR: disable suspendEnabled = false'->putline
                            if);*)
                            suspendEnabled - 1 -> suspendEnabled
                         // prim.enable then
                            (*(if suspendEnabled then
                                '\n***ERROR:enable suspendEnabled = true'->putline
                            if);*)
                            suspendEnabled + 1 -> suspendEnabled
                         // prim.asString then
                            ConvertIndexedToString
                         // prim.file_open_prim then
                            thisStack.rpop -> X[];
                            (X[]) -> files.open -> thisStack.vpush
                         // prim.file_get_prim then
                            thisStack.vpop -> files.get -> thisStack.vpush
                         // prim.file_eof_prim then
                            thisStack.vpop -> files.eof -> thisStack.vpush
                         // prim.file_close_prim then
                            thisstack.vpop -> files.close
                         // prim.log_prim then
                            thisStack.fpop -> float1;
                            float1 -> out.putReal; ' -> ' -> out.puttext;
                            float1 -> log -> float1 -> thisStack.fpush;
                            float1 -> out.putReal
                         // prim.sqrt_prim then
                            thisStack.fpop -> float1;
                            float1 -> out.putReal; ' -> ' -> out.puttext;
                            float1 -> sqrt -> float1 -> thisStack.fpush;
                            float1 -> out.putReal                            
                         // prim.printf_prim then
                            thisStack.fpop -> float1;
                            float1 -> out.putReal; ' -> ' -> out.puttext;
                            float1 -> putReal
                            (#
                            do 10->width; exp->style; 
                               6->precision; true->upCase 
                            #);
                            0 -> thisStack.vpush
                         // prim.dumpObj_prim then
                            (# copyToX:
                                 (#
                                 do scanItems:
                                      (#
                                      do ix1 + 1 -> ix1;
                                         skipId:
                                           (if items[ix1] <> 0 then 
                                               (ix1 + 2,items[ix1]) -> X.put;
                                              (* items[ix1] -> put;*)
                                               ix1 + 1 -> ix1;
                                               restart skipId
                                           if);
                                         (*' ' -> put;*)
                                         (for i: 4 repeat
                                              ix1 + 1 -> ix1;
                                              (if i = 3 then
                                                  items[ix1] -> kind
                                              if);
                                              (ix1 + 2,items[ix1]) -> X.put;
                                              (*items[ix1] -> putint;' '-> put*)
                                         for);
                                         (if kind // 2 // 3 then
                                             (*newline;*)
                                             restart scanItems
                                          else
                                             ix1 + 1 -> ix1;
                                             ix2 + 1 -> ix2;
                                             (ix1 + 2,ix2 + 1 -> Y.get) 
                                               -> X.put;
                                         if);
                                         (*newline;*)
                                         (* ix1 -> putint; ' '->put; 
                                          * ix2 -> putint;
                                          newline; newline;
                                          (for i: items.range repeat
                                          i -> putint; ':'->put;
                                          i -> X.get -> putint;  ' ' -> put
                                          for);
                                          newline;*)
                                         (if ix1 < items.range then 
                                             restart scanItems
                                         if)
                                      #);
                                 #);
                               items: [0] @integer; ix1,ix2,kind: @integer
                            do (if false then
                                   '\n*** dumpObjPrim:'->putline;
                               if);
                               thisStack.rpop -> Y[];
                               ('dumpObj:Y:',true,out[]) -> Y.dump;
                               Y[] -> dumpObjEvent -> items;

                               (if false then
                                   '\nitems:'->putline;
                                   (for i: items.range repeat 
                                        i -> putint; ':'->put;
                                        items[i] -> putint; ' ' -> put
                                   for);
                                   newline;
                               if);
                               (none,descs.textDescNo,1,1,items.range,0) 
                                 -> QallocIndexed;
                               thisStack.rPop -> X[];

                               copyToX;
                               (if false then 
                                   'items.range: ' -> puttext; 
                                   items.range -> putint; 
                                   ' thisObj.vinxsize: ' -> puttext;
                                   (*thisObj.vinxsize ->putint;*) newline;
                                   (for i: items.range repeat
                                        i -> X.get -> putint;  ' ' -> put
                                   for);
                                   newline;
                               if);
                               X[] -> thisStack.rPush;
                               ('dumpObj:X:',true,out[]) -> X.dump;
                               ('dumpObj:thisObj:',true,out[]) -> thisObj.dump;
                            #);
                        if);
                     // codes.jmp then
                        'jmp' -> exe;
                        op2 -> glsc
                     // codes.jmpFalse then
                        'jmpFalse' -> exe;
                        thisStack.vpop -> top1;
                        '(' -> out.put; top1 -> out.putint; ')' -> out.put;
                        (if  top1 = 0 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpFalse',thisStack[],1,thisCode.descInx,glsc) -> popEvent
                     // codes.jmpTrue then
                        'jmpTrue' -> exe;
                        (if thisStack.vpop <> 0 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpTrue',thisStack[],1,thisCode.descInx,glsc) -> popEvent
                     // codes.jmpGT then
                        'jmpGT' -> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        (if top2 > top1 then
                            op2 -> glsc
                         else
                            op2
                        if);
                        ('jmpGT',thisStack[],2,thisCode.descInx,glsc) -> popEvent
                     // codes.break then
                        'break' -> exe;
                        op1 -> on;
                        op2 -> lab;
                        op2 -> descInx;
                        op1 -> pn;
                        (on,lab,descInx,pn) -> doBreak
                     // codes.pushText then
                        'pushText' -> exe; 
                        op1 -> inx; 
                        (if isXbeta then
                            (thisObj.myObjDesc).literals[inx] 
                              -> QallocTextObject
                            (# i: @integer
                            do i + 1 -> i; 
                               (thisObj.myObjDesc).literals[inx+i] -> ch
                            #) -> X[]
                         else
                            (thisObj.myObjDesc).literals[inx] 
                              -> mkTextObject
                            (# i: @integer
                            do i + 1 -> i; 
                               (thisObj.myObjDesc).literals[inx+i] -> ch
                            #) -> X[];
                            (* OBS! we use the Text-object as origin of itself;
                             * this is wrong, origin should be the LIB-object
                             *)
                            (* generate allocEvent for &text 
                             * allocEvent calls myLsc, 
                             * which assume that glsc is on the lscStack
                             *)
                            (thisCode.descInx,glsc) -> thisObj.saveReturn;
                            (thisObj[],X[],X[],thisCode.descInx,glsc,true,false) -> allocEvent;
                            allocLevel - 1 -> allocLevel;
                            thisObj.restoreReturn -> (descInx,glsc);
                            (thisObj[],X[],X[],thisCode.descInx,glsc) -> rtnEvent
                        if)
                     // codes.plus then
                        '+'-> exe; 
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        top2 -> out.putint; ' ' -> out.put; top1 -> out.putint;
                        top1 + top2 -> thisStack.vpush;
                        ('+',thisStack[],thisStack.vTopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.minus then
                        '-'-> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r -> out.putint; ' ' -> out.put; l -> out.putint;
                           r - l -> thisStack.vpush  
                        #);
                        ('-',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.uminus then
                        'u-' -> exe;
                        - thisstack.vpop -> thisStack.vpush;  
                        ('-',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> unOpEvent
                     // codes.mult then
                        '*'-> exe;
                        thisStack.vpop * thisStack.vpop -> thisStack.vpush;
                        ('*',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.modd then
                        'mod' -> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r mod l -> thisStack.vpush;
                           ('mod',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                        #);
                     // codes.idiv then
                        'div' -> exe; 
                        (# l,r: @integer 
                        do thisStack.vpop -> l;
                           thisstack.vpop -> r;
                           r div l -> thisStack.vpush;
                           ('div',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                        #);
                     // codes.eq then
                        '='-> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if top1 = top2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('=',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.ne then
                        '<>'-> exe;
                        (if thisStack.vpop <> thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('<>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.req then
                        '=[]'-> exe;
                        (if thisStack.rpop = thisStack.rpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (* ('=',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.rne then
                        '<>[]'-> exe;
                        (if thisStack.rpop <> thisStack.rpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*('<>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.seq then
                        '=##'-> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> Y[];
                        (if ((1-> X.get) = (1 -> Y.get))
                            and ((2 -> X.rget) = (2 -> Y.rget)) then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (* ('=',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                     // codes.sne then
                        '<>##'-> exe;
                        thisStack.rpop -> X[];
                        thisStack.rpop -> Y[];
                        (if true then
                            (if ((1 -> X.get) <> (1 -> Y.get))
                                or ((2 -> X.rget) <> (2 -> Y.rget)) then
                                1 -> thisStack.vpush
                             else
                                0 -> thisStack.vpush
                            if);
                         else
                            (if (X.fields[1] <> Y.fields[1]) 
                                or ((2 -> X.rget) <> (2 -> Y.rget)) then
                                1 -> thisStack.vpush
                             else
                                0 -> thisStack.vpush
                            if);
                        if);
                        (*('<>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent*)
                        
                        
                     // codes.lt then
                        '<'-> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        top2 -> out.putint; '<' -> out.put; top1 -> out.putint;
                        (if top2 < top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        (*(if thisStack.vpop > thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);*)
                        ('<',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.le then
                        '<='-> exe;
                        thisStack.vpop -> top1;
                        thisStack.vpop -> top2;
                        top1 -> out.putint;  ' le '-> out.puttext;
                        top2 -> out.putint;  ' '-> out.put;
                        (if top2 <= top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.gt then
                        '>' -> exe;
                        thisStack.vpop -> top1;
                        thisstack.vpop -> top2;
                        top2 -> out.putint; '>' -> out.put; top1 -> out.putint;
                        (if top2 > top1 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('>',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent
                     // codes.ge then
                        '>='-> exe;
                        (if thisStack.vpop <= thisStack.vpop then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('>=',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc)
                          -> binOpEvent
                     // codes.andd then
                        'and' -> exe;
                        (if (thisstack.vpop = 1) and (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('and',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) 
                          -> binOpEvent
                     // codes.orr then
                        'or' -> exe;
                        (if (thisStack.vpop = 1) or (thisStack.vpop = 1 ) then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('or',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) 
                          -> binOpEvent
                     // codes.nott then
                        'not' -> exe;
                        (if thisStack.vpop = 0 then
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if)
                     // codes.fplus then
                        'fplus'-> exe; 
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        
                        float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal;
                        (if false then 
                            '*** fplus: ' -> puttext;
                            float1 -> putreal; ' ' -> put; 
                            float2 -> putReal; ' ' -> put;
                        if);
                        
                        float1 + float2 -> float1;
                        
                        (if false then float1 -> putreal; newline; if);
                        
                        float1 -> thisStack.fpush;
                        
                        ('fplus',thisStack[],thisStack.vTopElm,thisCode.descInx,glsc) -> binOpEvent                        
                     // codes.fminus then
                        'fminus' -> exe;
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        
                        float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal;
                        (if false then
                            '*** fminus: ' -> puttext;
                            float1 -> putreal; ' ' -> put; 
                            float2 -> putReal; ' ' -> put;
                        if);
                        float1 - float2 -> float1;
                           
                        (if false then float1 -> putreal; newline if);
                        float1 -> thisStack.fpush;
                     // codes.fmult // codes.rdiv then
                        'fmult' -> exe;
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        
                        float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal;
                        (if false then 
                            '*** fmult: ' -> puttext;
                            float1 -> putreal; ' ' -> put; 
                            float2 -> putReal; ' ' -> put;
                        if);
                        float1 * float2 -> float1;
                        (if false then 
                            float1 -> putreal; newline;
                        if);
                        float1 -> thisStack.fpush
                     // codes.fdiv then
                        'fdiv' -> exe;
                        thisStack.fpop -> float2;
                        thisStack.fpop -> float1;
                        
                        float1 -> out.putreal; ' ' -> out.put; float2 -> out.putreal;
                        (if false then
                            '*** fdiv: ' -> puttext;
                            float1 -> putreal; ' ' -> put; 
                            float2 -> putReal; ' ' -> put;
                        if);
                        float1 / float2 -> float1;
                           
                        (if false then float1 -> putreal; newline; if);
                        float1 -> thisStack.fpush 
                     // codes.feq then
                        'feq'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if float1 = float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('feq',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent          
                     // codes.flt then
                        'flt'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if float1 < float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('flt',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent             
                     // codes.fle then
                        'fle'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if float1 <= float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fle',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent                                     
                     // codes.fgt then
                        'fgt'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if float1 > float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fgt',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent             
                     // codes.fge then
                        'fge'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if float1 >= float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fge',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent                                     
                     // codes.fne then
                        'fne'-> exe;
                        thisStack.fpop -> float2;
                        thisstack.fpop -> float1;
                        top1 -> out.putint; ',' -> out.put; top2 -> out.putint;
                        (if float1 <> float2 then 
                            1 -> thisStack.vpush
                         else
                            0 -> thisStack.vpush
                        if);
                        ('fne',thisStack[],thisStack.vtopElm,thisCode.descInx,glsc) -> binOpEvent                                     
                     // codes.pushFloatConst then
                        (#  L1,L2: @integer
                        do 'pushFloatConst' -> exe; op8 -> (float1,L1,L2);
                           float1 -> out.putreal; out.newline;
                           (if false then
                               'pushFloatConst ' -> puttext;
                               float1 -> putReal; ' '  -> put;
                               L1 -> puthex; ' ' -> put; L2 -> puthex; newline;
                           if);
                           L1 -> thisStack.vpush;
                           L2 -> thisStack.vpush                           
                        #)
                     // codes.i2f then
                        'i2f' -> exe;
                        thisStack.vpop -> thisStack.fpush
                     // codes.f2i then
                        'f2i' -> exe;  
                        thisStack.fpop -> thisStack.vpush
                     // codes.saveBETAworld then
                        'saveBETAworld' -> exe; 
                        (1,thisStack.rpop) -> eventProcessor.rput;
                        (if IsXbeta then
                            (* Why not for not isXbeta? See alos Alloc *)
                            1 -> eventProcessor.rget -> world[]
                        if)
                     // codes.saveStringOrigin then
                        'saveStringOrigin' -> exe;
                        thisObj[] -> stringOrigin[]
                     // codes.mkStrucRef then
                        'mkStrucRef' -> exe;
                        thisStack.rpop -> X[];
                        thisStack.vpop -> descInx;
                        (* ('mkStrucRef',true,screen[]) -> X.dump;*)
                        (X[],descinx,false) -> mkStrucRefObj
                     // codes.mkObjStrucRef then
                        'mkObjStrucRef' -> exe;
                        thisStack.rpop -> X[]; (* the object *)
                        (X.myOrigin,X.myDescInx,false) -> mkStrucRefObj
                     // codes.mkVirtualStrucRef then
                        'mkVirtualStrucRef' -> exe;
                        (thisObj.rpop,op1,true) -> mkStrucRefObj
                     // codes.allocFromStrucRefObj then
                        'allocFromStrucRefObj' -> exe;
                        thisStack.rpop -> allocFromStrucRefObj
                     else
                        5 -> fatalError
                        (#
                        do ' Op-code: ' -> M.puttext; 
                           thisCode.B[glsc] -> M.putint;
                           M.newline;
                           M[] -> putline;
                           thisCode.B[glsc] -> out.putint; glsc+1 -> glsc;
                        #);
                        leave loop
                    if);
                    (if stopErrors[] = none then
                        (if (glsc <= thisCode.top) and not doTerminate then
                            restart Loop 
                    if)if);

                    false -> isRunning;
                    (if (runMode = run_Beta_INT) and runJavaServices then 
                        closeJavaServices 
                    if);
                    done; (* Used to be in closeJavaServices 
                           * - but conflicting with fatalError *)
                    (* 'suspend'->putline;*)
                    suspend;
                    (* 'reactivate betaVM'->putline;*)
                    false -> doTerminate;
                    (if handleEvent then 
                        restart Loop 
                     else
                        restart main
                    if)
                 #);
               (* '**** End of betaVM'->putline;*)
               done
            #)
       #)
  #)
