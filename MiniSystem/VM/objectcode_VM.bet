ORIGIN 'objectcode'
---classDef:doPart---
do
---class:descriptor---
(#
do  (N[],descNo,originOff,originDescNo,isValueObj,out[]) 
     -> descs.setCurrent;
   (if descs.OD[topDescNo][]= none then 
       dumpClass;
       ' descs.OD[topDescNo='->puttext; 
       topDescNo -> putint;
       '][]= none' -> putline
    else
       (topDescNo,descs.OD[topDescNo].bc[]) 
         -> descs.current.setSuperBC;
   if);
   descs.markAllocE;
   (if procE then 
       'procE:' -> puttext; N[] -> putline;
       descs.markProcE 
   if);
   initGCinfo;
   labs.init;
#)
---pushConst:descriptor---
(#
do (if true 
    // cst <= 255 then
       codes.pushc -> emit;
       cst -> emit
    // cst <= 255 * 255  then
       codes.pushc2 -> emit;
       cst -> emit2
    else 
       fcom(#do 'OBS! Constant >= 2^16 is not implemented' ->TT #)
   if)
#)
---rpushg:descriptor---
(#
do codes.rpushg -> emit; off -> emit;
#)
---jmp:doPart---
do ' jmp L' -> out.puttext; lab -> out.putint; out.newline;
   codes.jmp -> emit;
   0 -> emit2;
   lab -> labs.mark;
---jmpFalse:descriptor---
(#
do codes.jmpFalse -> emit;
   0 -> emit2;
   Flab -> labs.mark
#)
---invokev:descriptor---
(#
do codes.invokev -> emit; dinx -> emit; noOfRefArgs -> emit;
   (if recIsValueObj then 1  -> emit else 0 -> emit if);
#)
---callPrim:descriptor---
(#
do codes.prim -> emit; op -> emit;
   (if op 
    // prim.attach then 
       ' ' -> out.put;
       'D' -> out.put;
       'D' -> emit 
    // prim.fork // prim.cmpAndSwap // prim.thisCore then
       (* perhaps more prims require C-mode, 
        * but we are probably shure with the above ones
        *)
       true -> descs.onlyCinterpreter;
   if);
#)
   
