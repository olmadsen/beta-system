ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'Primitives';
INCLUDE 'betaVM';
---lib:attributes---
ObjectCode:
  (# emitLLVM: (#exit false #);
     init:<
       (#
       enter out[]
       do vdtPatch.init;
          inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comment:
       (# T: ^text
       enter T[]
       do ' -- ' -> out.puttext; T[] -> out.putline
       #);
     comB:
       (# T: ^text
       enter T[]
       do ' -- ' -> out.puttext; T[] -> out.puttext
       #);
     comA: 
       (# T: ^text
       enter T[]
       do T[] -> out.puttext
       #);
     comE:
       (# T: ^text
       enter T[]
       do T[] -> out.putline
       #);
     com2:
       (# T1,T2: ^text
       enter(T1[],T2[])
       do ' -- ' -> out.puttext; T1[] -> out.puttext; 
          ' ' -> out.put; T2[] -> out.putline
       #);
     com: 
       (# II: (# enter Tx.putint do ' ' -> Tx.put #);
          TT: 
            (# S: ^text; Q: @text; i: @integer; inText: @boolean
            enter S[]
            do (if S[] <> none then
                   L:
                     S.scanAll
                     (#
                     do (if ch 
                         // '"' then
                            '"' -> Q.put;
                            not inText -> inText
                         // ascii.newline then
                            ' ' -> Q.put; '|' -> Q.put; ' ' -> Q.put 
                         else
                            ch -> Q.put
                        if);
                        (if (i + 1 -> i) > (70 - Tx.length) then 
                            ' ...' -> Q.puttext;     
                            (if inText then '"'-> Q.put if);
                            leave L 
                        if)
                     #)
                else
                   '-none-' -> Tx.puttext
               if);
               Q[] -> Tx.puttext
            #);
          TQ:
            (# S: ^Text
            enter S[]
            do '"' -> Tx.put;
               S[] -> TT;
               '"' -> Tx.put; ' ' -> Tx.put
            #);
          BB: 
            (# Bx: @boolean 
            enter Bx do (if Bx then 'true' -> TX.puttext else 'false' -> TX.puttext if)
            #);
          CC: (# ch: @char enter ch do ch -> Tx.put #);
          FF: (# F: @real enter F do F -> Tx.putreal #);
          nl: (# do emit; Tx.clear #);
          emit: 
            (# 
            do Tx.newline; ' -- ' -> out.puttext; Tx[] -> out.puttext; 
            #);
          print: (# do '***** ' -> puttext; Tx[] -> putline #);
          Tx: @Text
       do inner; emit;
       #);          
     newComponent: (* Not used!? *)
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do ' component ' -> out.puttext; N[] -> out.puttext; 
          ' NoOfDescs: ' -> out.puttext; noOfDescs -> out.putint; out.newline;
          noOfDescs + 3 -> descs.top -> descs.OD.new; (* noOfDesc + 2 since an extra
                                                       * desc is allocated for main 
                                                       * and EventProcessor
                                                       *)
       #);
     stack: @
       (# rTop,vTop,rTopMax,vTopMax: @integer;
          init: (#do 0 -> rTop -> vTop -> rTopMax -> vTopMax #);
          vpush:
            (#
            do (if (vTop + 1 -> vTop) > vTopMax then vTop -> vTopMax if);
               'vpush' -> dump
            #);
          vpop: (# n: @integer enter n do vTop - n -> vTop; 'vpop' -> dump #);
          rpush:
            (#
            do (if (rTop + 1 -> rTop) > rTopMax then rTop -> rTopMax if);
               'rpush' -> dump
            #);
          rpop: (# n: @integer enter n do rTop - n -> rTop; 'rpop' -> dump #);
          print: 
            (# T: @text
            do ' vTop:' -> T.puttext; vTop -> T.putint;
               ' vTopMax:' -> T.puttext; vTopMax -> T.putint;
               ' rTop:' -> T.puttext; rTop -> T.putint;
               ' rTopMax:' -> T.puttext; rTopMax -> T.putint;
            exit T[]
            #);
          dump:
            (# T: ^text
            enter T[]
            do com(#do 'stack:' -> TT; T[] -> TT; ': vTop: ' -> TT; vTop -> II; 
                     ' vTopMax: ' -> TT; vTopMax -> II;
                     '  rTop: ' -> TT; rTop -> II; 
                     ' rTopMax: ' -> TT; rTopMax -> II;
                  #)
            #)
     #);
     class:
       (# dumpClass:
            (#
            do '\n\n*** Fatal error in objectCode: *** Class: ' -> puttext; 
               N[] -> puttext; ' descNo = '->puttext; descNo -> putint;
            #);
          N: ^text; descNo,topDescNo,originOff,originDescNo: @integer;
          procE: @boolean; (* mark start as proc-entry and enter-entry *)
       enter(N[],descNo,procE,topDescNo,originOff,originDescNo)
       do '\nclass ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
          descNo -> out.putint; ' ' -> out.put;
          originOff -> out.putint; ' ' -> out.put;
          originDescNo -> out.putint;
          out.newline;
          (if descNo = 0 then
              dumpClass;
              ' is ZERO!' -> putline
          if);
          (N[],descNo,originOff,originDescNo,out[]) -> descs.setCurrent;
          (if descs.OD[topDescNo][]= none then 
              dumpClass;
              ' descs.OD[topDescNo='->puttext; 
              topDescNo -> putint;
              '][]= none' -> putline
           else
              (topDescNo,descs.OD[topDescNo].bc[]) -> descs.current.setSuperBC;
          if);
          descs.markAllocE;
          (if procE then 
              'procE:' -> puttext; N[] -> putline;
              descs.markProcE if);
          initGCinfo;
          labs.init;
          stack.init;
          (* at entry to an object thisStack contains the arguments of the 
           * object and the origin - here we make one rpush for the origin
           * We need to pass noOfVargs amd noOfRargs and init stack with these
           * See also rtn:
           *)
          stack.rpush;
          (if emitLLVM then
              '\nclass ' -> puttext; N[] -> putline
          if)
       #);
     super: 
       (# N: ^text; superDescNo: @integer
       enter(N[],superDescNo)
       do ' -- super ' -> out.puttext; N[] -> out.putline;
          descs.OD[superDescNo][] -> descs.current.superObjDesc[]
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do 'ENTER:' -> out.putline
       #);
     setThisStack:
       (#
       do ' setThisStack ' -> out.putline;
          codes.setThisStack -> emit
       #);
     rpopThisObj:
       (#
       do ' rpopThisObj ' -> out.putline;
          codes.rpopThisObj -> emit
       #);       
     actions:
       (# hasSuper,genDoEvent: @boolean
       enter(hasSuper,genDoEvent)
       do 'DO:'->out.putline;
          descs.markDoE;
          (if genDoEvent then doEventQ if);          
       #);
     mvStack:
       (#
       do ' mvStack '->out.putline; codes.mvstack -> emit 
       #);
     markExitE: (# do descs.markExitE #);
     doExit:
       (#
       do 'EXIT:' -> out.putline; 
          ' doExit ' -> out.putline; 
          codes.doExit -> emit
       #);
     rtn: 
       (# LMR: @char
       enter LMR 
       do ' rtn(' -> out.puttext; LMR->out.put; ')' -> out.put; out.newline;
          codes.rtn -> emit ; LMR -> emit;
          (* we need to pop the rturn values from the stack, but we dont
           * know its type here - we thus currently assume that a ref is returned
           *)
          1 -> stack.rpop
       #);
     rtnV: (*rtnValue*)(#do ' rtnV\n' -> out.puttext;  codes.rtnV -> emit #);
     rtnC: (# do ' rtnC' -> out.putline; codes.rtnC -> emit #);
     rtnExit: (# do ' rtnExit' -> out.putline; codes.rtnExit -> emit #);
     rtnInner: (# do ' rtnInner' -> out.putline; codes.rtnInner -> emit #);
     rtnEvent: 
       (# hasExit: @integer 
       enter hasExit 
       do ' rtnEvent ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEvent -> emit;
          hasExit -> emit
       #);
     allocEventQ:
       (# asObj: @boolean
       enter asObj
       do ' allocEventQ\n' -> out.puttext;
          codes.allocEventQ -> emit;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     rtnEventQ: 
       (# hasExit: @integer 
       enter hasExit 
       do ' rtnEventQ ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEventQ -> emit;
          hasExit -> emit
       #);
     doEventQ:
       (#
       do ' doEventQ\n' -> out.puttext;
          codes.doEventQ -> emit
       #);
     stop: (# do ' stop' -> out.putline; codes.stop -> emit #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          'D' -> rtn          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do ' L' -> out.puttext; lab -> out.putint; ':' -> out.put; out.newline;
          lab -> labs.def;
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do ' jmpIf_GT L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       do ' jmp L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmp -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpFalse:
       (# lab: @integer 
       enter lab 
       do ' jmpFalse L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpFalse -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do ' jmpTrue L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpTrue -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     break:
       (# on,lab,descInx,pn: @integer
       enter(on,lab,descInx,pn)
       do ' break ' -> out.puttext; on -> out.putint; ' ' -> out.put; 
          lab -> out.putint; ' ' -> out.put; descInx -> out.putint;
          ' ' -> out.put; pn -> out.putint;
          out.newline;
          codes.break -> emit;
          on -> emit; 
          (if lab = 0 then
              '\n***** Fatal error break: lsc=0' -> putline
          if);
          lab -> emit2;
          descInx -> emit2;
          pn -> emit
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do ' alloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.alloc -> emit; descNo -> emit2;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     tstOriginIsNone:
       (#
       do ' tstOriginIsNone ' -> out.putline;
          codes.tstOriginNone -> emit;
       #);
     invoke: 
        (# N: ^text; descNo,staticOff: @integer; asObj: @boolean; iO: @integer
       enter(N[],descNo,staticOff,asObj) 
        do ' invoke ' -> out.puttext; N[] -> out.puttext; 
           ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
           staticOff -> out.putint; ' ' -> out.put;
           (if asObj then 1 -> iO else 0 -> iO if);
           io -> out.putint;
           out.newline;
           codes.invoke -> emit; descNo -> emit2; staticOff -> emit2;
           iO -> emit;
           (* the origin and possible arguments are on the stack
            * As for now we dont know the no of arguments
            * We thus make an rpop for the origin
            * callee returns a value - here we dont know the type so we 
            * assume that a ref to callee is returned
            *)
           1 -> stack.rpop;
           stack.rpush;
           (if emitLLVM then
               'call\t' -> puttext; N[] -> putline
           if)
        #);
     mkVindexed:
       (# descInx: @integer
       enter descInx
       do ' mkVindexed ' -> out.puttext; descInx -> out.putint; out.newline; 
          codes.mkVindexed -> emit; descInx -> emit2;
       #);
     mkRindexed:
       (# descInx: @integer
       enter descInx
       do ' mkRindexed ' -> out.puttext; descInx -> out.putint; out.newline;
          codes.mkRindexed -> emit; descInx -> emit2;
       #);     
     saveAndSetThis:
       (#
       do ' saveAndSetThis ' -> out.putline;
          codes.saveAndSetThis -> emit
       #);
     restoreThis:
       (#
       do  ' restoreThis ' -> out.putline;
          codes.restoreThis -> emit
       #);
     invokeVal:
         (# N: ^text; descNo,staticOff: @integer
       enter(N[],descNo,staticOff) 
         do ' invokeVal ' -> out.puttext; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
           staticOff -> out.putint; out.newline;
           codes.invokeVal -> emit; descNo -> emit2; staticOff -> emit2
         #);
     boxedInvokeVal:
       (# N: ^text; descNo,size: @integer
       enter(N[],descNo,size)
         do ' boxedInvokedVal ' -> out.puttext; N[] -> out.puttext; 
          ' ' -> out.put; descNo -> out.putint; 
          ' ' -> out.put; size -> out.putint; out.newline;
           codes.boxedInvokeval -> emit; descNo -> emit2; size -> emit2
         #);
     invokeExternal:
       (# N: ^text; externalNo: @integer
       enter(N[],externalNo)
       do ' invokeExternal ' -> out.puttext; externalNo -> out.putint; 
          out.newline;
          codes.invokeExternal -> emit; externalNo -> emit
       #);
     allocIndexed:
         (# N: ^text; descNo,size,isRefIndexed: @integer;
       enter(N[],descNo,size,isRefIndexed) 
         do ' allocIndexed ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
            descNo -> out.putint; ' ' -> out.put; 
            size -> out.putint; ' ' -> out.put; 
            isRefIndexed -> out.putint; out.newline;            
            codes.allocIndexed -> emit; descNo -> emit2; size-> emit; isRefIndexed -> emit
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do ' exeAlloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit2
       #);
       
     newVrep: (# do ' newVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do ' send ' -> out.puttext; inx -> out.putint; ' ' -> out.put;  N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     sendVirtual: 
       (# N: ^text; dinx,noOfRefArgs: @integer 
       enter(N[],dinx,noOfRefArgs) 
       do ' sendv ' -> out.puttext; dinx -> out.putint; 
          ' ' -> out.put; noOfRefArgs -> out.putint;
          ' ' -> out.put; N[] -> out.putline;
          codes.sendv -> emit; dinx -> emit; noOfRefArgs -> emit
       #);
     invokev:
       (# N: ^text; dinx: @integer 
       enter(N[],dinx) 
       do '*** objectCode::invokev called'->putline;
          (*' invokev ' -> out.puttext; dinx -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.invokev -> emit; dinx -> emit;*)
       #);
     exe: (# N: ^text enter N[] do ' exe ' -> out.puttext; N[] -> out.putline #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do ' call(' -> out.puttext; LMR -> out.put; ')' -> out.put;
          N[] -> out.putline; 
          codes.call -> emit;
          LMR -> emit
       #);
     vdtTablePrint:
       (# descNo: @integer; T: @text
       enter descNo
       do 'vdtTable:Q: ' -> T.puttext;
          (for i: descs.OD[descNo].vdtTable.range repeat 
               (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[descNo].vdtTable[i] -> T.putint;
               inner
          for); 
          T[] -> comment          
       #);
     vdtTableCopy:
       (# superDescNo: @integer; T: @text
       enter superDescNo
       do (for i: descs.OD[superDescNo].vdtTable.range repeat (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[superDescNo].vdtTable[i] -> T.putint; 
               (i,descs.OD[superDescNo].vdtTable[i]) -> descs.current.vdtAdd
          for); 
          T[] -> comment;
          (* copy literals from super to current *)
          descs.OD[superDescNo].literals.range 
            -> descs.current.litTop
            -> descs.current.literals.new;
          (for i: descs.current.litTop repeat
               (*descs.OD[superDescNo].literals[i] -> putint; ',' -> put;*)
               descs.OD[superDescNo].literals[i] -> descs.current.literals[i]
          for);
          (*newline;*)
       #);
     vdtTable:
       (# inx,descInx: @integer
       enter(inx,descInx)
       do (inx,descInx) -> descs.current.vdtAdd -> comment
       #);
     vdtTableAt:
       (* For OD:descNo, virtual/inner:inx is bound to descInx *)
       (# inx,descInx,descNo: @integer
       enter(inx,descInx,descNo)
       do (if false then
              ' vdtTableAt: ' -> puttext;
              inx -> putint; ' ' -> put;
              descInx -> putint; ' ' -> put;
              descNo -> putint; newline;
          if);
          (inx,descInx,descNo) -> VdtPatch.add
       #);
     VdtPatch: @
       (# index,bindInx,descInx:[5] @ integer; top: @integer;
          init: (# do 0 -> top #);
          add:
            (* For OD:dx, virtual/inner:ix is bound to bx *)
            (# ix,bx,dx: @integer
            enter (ix,bx,dx)
            do (if (top + 1 -> top) > index.range then
                   index.range -> index.extend;
                   bindInx.range -> bindInx.extend;
                   descInx.range -> descInx.extend;
               if);
               ix -> index[top];
               bx -> bindInx[top];
               dx -> descInx[top];
            #);
          patch:
            (#
            do (for i: top repeat
                    (if false then
                        'Patch:range:' -> puttext; index.range -> putint; ' ' -> put;
                        index[i] -> putint; ' ' -> put;
                        bindinx[i] -> putint; ' ' -> put;
                        descInx[i] -> putint;  ' ' -> put;  newline;
                    if);
                    (index[i],bindInx[i]) 
                      -> descs.OD[descInx[i]].vdtAdd -> comment
               for)
            #)
       #);
     toSuper:
       (# descInx: @integer
       enter descInx
       do ' toSuper ' -> out.puttext;
          descInx -> out.putint; out.newline;
          codes.toSuper -> emit; descInx -> emit2
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do ' innerX ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerx -> emit; inx -> emit;
       #);
     innerP: (* Inner P, where P.ON > 1 *)
       (# inx: @integer 
       enter inx
       do ' innerP ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerP -> emit; inx -> emit;
          1 -> stack.rPop
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do ' innerExit ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;

       #);
     innerA:
       (# inx: @integer 
       enter inx
       do ' innerA ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerA -> emit; inx -> emit;
       #);
     suspendd: (# do ' suspend' -> out.putline; codes.susp -> emit #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do ' doSuper' -> out.puttext; ' ' -> out.put; N[] -> out.puttext; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit2;
       #);

     pushThis:
       (# 
       do ' pushThis ' -> out.putline;
          codes.pushthis -> emit; 
          stack.rPush;
          (if emitLLVM then
              'R' -> puttext; stack.rtop -> putint;
              ' = this' -> putline;
          if)
       #);
     addOff:
       (# off: @integer
       enter off
       do ' addOff ' -> out.puttext; off -> out.putint; out.newline;
          codes.addOff -> emit; off -> emit2;
          stack.vPush
       #);
     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' push ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.push -> emit; off -> emit;
          stack.vPush
       #);
     pushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' pushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.pushg -> emit; off -> emit;
          stack.vpush;
          (if emitLLVM then
              'V' -> puttext; stack.vtop -> putint;
              ' = load i32, i32* R' -> puttext; stack.rtop -> putint;
              ', ' -> puttext; off -> putint; newline
          if);
          1 -> stack.rpop
       #);
     fpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.fpushg -> emit; off -> emit;
       #);     
     ovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' ovpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.ovpushg -> emit; off -> emit;
       #);
     fovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.fovpushg -> emit; off -> emit;
       #);     
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' rpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit;
          stack.rPush
       #);
     rpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' rpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpushg -> emit; off -> emit;
       #);
     xpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpush -> emit; off -> emit;
          stack.rPush
       #);
     xpushg:
       (# N: ^text; off,isValueObj,size: @integer
       enter(N[],off,isValueObj,size) 
       do ' xpushg ' -> out.puttext; N[] -> out.puttext;  ' ' -> out.put; 
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;  
          codes.xpushg -> emit; off -> emit; isValueObj -> emit; size -> emit;
          stack.vPush
       #);
     xrpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xrpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xrpush -> emit; off -> emit;
       #);    
     xrpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xrpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xrpushg -> emit; off -> emit;
       #);
     pushConst: 
       (# cst: @integer
       enter cst
       do ' pushc ' -> out.puttext; cst -> out.putint; out.newline;
          (if true 
           // cst <= 255 then
              codes.pushc -> emit;
              cst -> emit
           // cst <= 255 * 255  then
              codes.pushc2 -> emit;
              cst -> emit2
           else 
              'OBS! Constant >= 2^16 is not implemented' -> comment
          if);
          stack.vPush;
          (if emitLLVM then
              'V' -> puttext; stack.vtop -> putint; ' = load i32,  ' -> puttext; 
              cst -> putint; newline
          if)
       #);
     pushFloatConst:
       (# X: @Real
       enter X
       do ' pushFloatConst ' -> out.puttext; X -> out.putReal; out.newline;
          codes.pushFloatConst -> emit;
          X -> emit8
       #);
     pushNone: 
       (# 
       do ' pushNone' -> out.puttext; out.newline;
          codes.pushNone -> emit;
          stack.rPush
       #);
     pushText:
       (# T,T1: ^text; I: @integer
       enter T[]
       do ' pushText ' -> out.puttext; T[] -> out.putline;
          codes.pushText -> emit;
          T[] -> handleEscape -> T1[];
          (* 'PushText: ' -> puttext; T1[] -> putline;*)
          T1.length -> descs.current.addLiteral
          (#
          do i + 1 -> i -> T1.inxGet -> value;
          #) -> emit;
          stack.rPush
       #);
     handleEscape:
       (# T: ^text; T1: @text;
          nextCh: 
            (# 
            do i + 1 -> i;
               (if i <= T.length then
                   i -> T.inxGet -> ch;
                else
                   0 -> ch
               if);               
            #);
          ch: @char;
          i: @integer
       enter T[]
       do 0 -> i;
          nextCh;
          loop:
            (if i <= T.length then 
                (if ch 
                 // '\\' then 
                    nextCh;
                    (if ch
                     // 'n' then
                        ascii.nl -> T1.put;
                        nextch
                     // '\\' then
                        '\\' -> T1.put;
                        nextch;
                     else
                        '\\' -> T1.put
                    if)
                 else
                    ch -> T1.put;
                    nextCh;                    
                if);
                restart loop
            if)
       exit T1[]
       #);
     mkStrucRef:
       (# T: ^text
       enter T[]
       do ' mkStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkStrucRef -> emit
       #);
      mkObjStrucRef:
       (# T: ^text
       enter T[]
       do ' mkObjStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkObjStrucRef -> emit
       #);
     mkVirtualStrucRef:
       (# T: ^text; off: @integer
       enter(T[],off)
       do ' mkVirtualStrucRef ' -> out.puttext; off-> out.putint; out.newline;
          codes.mkVirtualStrucRef -> emit; off -> emit
       #);
     allocFromStrucRefObj:
       (#
       do ' allocFromStrucRefObj ' -> out.putline;
          codes.allocFromStrucRefObj -> emit;
       #);
     pushValue:
       (# size: @integer
       enter size
       do ' pushvalue ' -> out.puttext; size -> out.putint; out.newline;
          codes.pushValue -> emit; size -> emit;
       #);
     vassign:
       (# size,mode: @integer
       enter(size,mode)
       do ' vassign ' -> out.puttext; size -> out.putint; ' ' -> out.put;
          mode -> out.putint; out.newline;
          codes.vassign -> emit; size -> emit; mode -> emit
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' store ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.store -> emit; off -> emit;
          1 -> stack.vpop
       #);
     storeg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' storeg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.storeg -> emit; off -> emit;
          (if emitLLVM then
              'store i32 V' -> puttext; stack.rtop -> putint;
              ', i32* R' -> puttext; stack.vtop -> putint;
              ', ' -> puttext; off -> putint; newline;
          if);
          1 -> stack.vpop;
          1 -> stack.rpop
       #);
     fstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' fstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.fstoreg -> emit; off -> emit;
          1 -> stack.vpop          
       #);     
     ovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' ovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.ovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);
     fovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.fovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);     
     rstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' rstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstore -> emit; off -> emit
          if);
          1 -> stack.rPop
       #);
     rstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' rstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstoreg -> emit; off -> emit
          if);
          2 -> stack.rPop
       #);
     xstore: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xstore ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put;  
          off -> out.putint; out.newline;
          (if off <= 255 then 
              codes.xstore -> emit; off -> emit
          if);
          1 -> stack.vpop
       #);
     xstoreg: 
       (# N: ^text; off,isValueObj,size: @integer
       enter(N[],off,isValueObj,size) 
       do ' xstoreg ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put;
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;          
          off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstoreg -> emit; off -> emit; isValueObj -> emit; size -> emit; 
          if);
          2 -> stack.vpop
       #);     
     xrstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstore -> emit; off -> emit
          if);
          2 -> stack.rpop
       #);
     xrstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstoreg -> emit; off -> emit
          if);
          1 -> stack.rpop
       #);
     double: 
       (# 
       do ' double' -> out.putline; codes.double -> emit; 
          stack.vPush; stack.vpush 
       #);
     rdouble: 
       (# do ' rdouble' -> out.putline; codes.rdouble -> emit;
          stack.rPush; stack.rpush           
       #);
     swap: (# do ' swap' -> out.putline; codes.swap -> emit #); (* not in use*)
     rswap: 
       (# rn: @integer
       enter rn
       do ' rswap ' -> out.puttext; rn -> out.putint; out.newline;
          codes.rswap -> emit; rn -> emit
       #);
     rPop: (# do ' rpop' -> out.putline; codes.rpop -> emit; 1 -> stack.rPop #);
     vPop: (# do ' vpop' -> out.putline; codes.vpop -> emit; 1 -> stack.vPop #);
     CallPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do ' %' -> out.puttext; P[] -> out.puttext; ' ' -> out.put; op -> out.putint;
          codes.prim -> emit; op -> emit;
          (if op 
           // prim.attach then 
              ' ' -> out.put;
              'D' -> out.put;
              'D' -> emit 
           // prim.fork // prim.cmpAndSwap // prim.thisCore then
              (* perhaps more prims require C-mode, 
               * but we are probably shure with the above ones
               *)
              true -> descs.onlyCinterpreter;
          if);
          out.newline;
       #);
     op: 
       (# operator: @integer
       enter operator
       do ' ' -> out.put; 
          (if operator
           // codes.plus then 'plus' -> out.putline; 
              (if emitLLVM then
                  'V' -> puttext; stack.vtop - 1 -> putint;
                  ' = add i32 V' -> puttext; stack.vtop - 1 -> putint;
                  ', V' -> puttext; stack.vtop -> putint; newline
              if);
              1 -> stack.vpop
           // codes.minus then 'minus' -> out.putline
           // codes.mult then 'mult' -> out.putline; 
              (if emitLLVM then
                  'V' -> puttext; stack.vtop - 1 -> putint;                  
                  ' = mult i32 V' -> puttext; stack.vtop - 1 -> putint;
                  ' V' -> puttext; stack.vtop -> putint; newline
              if);
              1 -> stack.vpop;
           // codes.rdiv then 'div' -> out.putline
           // codes.idiv then 'idiv' -> out.putline
           // codes.modd then 'modd' -> out.putline
           // codes.eq then 'eq' -> out.putline
           // codes.lt then 'lt' -> out.putline;
           // codes.le then 'le' -> out.putline;
           // codes.gt then 'gt' -> out.putline
           // codes.ge then 'ge' -> out.putline
           // codes.ne then 'ne' -> out.putline
           // codes.andd then 'andd' -> out.putline
           // codes.orr then 'orr' -> out.putline
           // codes.xorr then 'xorr' -> out.putline
           // codes.req then 'req' -> out.putline
           // codes.rne then 'rne' -> out.putline
           // codes.fplus then 'fplus' -> out.putline
           // codes.fminus then 'fplus' -> out.putline
           // codes.fmult then 'fmult' -> out.putline
           // codes.fdiv then 'fdiv' -> out.putline
           else
              operator -> out.putint; out.newline
          if);
          operator -> emit;
       #);
     i2f: (# do ' i2f' -> out.putline; codes.i2f -> emit #);
     f2i: (# do ' f2i' -> out.putline; codes.f2i -> emit #);
     req: (# do ' req' -> out.putline; codes.req -> emit #);
     rne: (# do ' rne' -> out.putline; codes.rne -> emit #);
     seq: (# do ' req' -> out.putline; codes.seq -> emit #);
     sne: (# do ' rne' -> out.putline; codes.sne -> emit #);    
     uminus: 
       (# 
       do ' u-' -> out.putline; 
          codes.uminus -> emit
       #);
     nott: (# do ' not' -> out.putline; codes.nott -> emit #);
     saveBETAworld: 
       (#
       do ' saveBETAworld' -> out.putline; 
          codes.saveBETAworld -> emit
       #);
     saveStringOrigin:
       (#
       do ' saveStringOrigin' -> out.putline;
          codes.saveStringOrigin -> emit
       #);
     isMarked: [32] @boolean;
     initGCinfo: (#do (for i: isMarked.range repeat false-> isMarked[i] for)#);
     addGCinfo:
       (# add: 
            (# off: @integer 
            enter off 
            do (if off > isMarked.range then
                   isMarked.range -> isMarked.extend 
               if);
               (if not isMarked[off] then
                   off -> descs.current.GCinfo.add;
                   true -> isMarked[off]
               if)
            #);
       do inner
       #);
     endClass: 
       (# objSize,OSDvisibility: @integer;
          isIndexed: @boolean;
          V: @integer
       enter(objSize,isIndexed,OSDvisibility)
       do ' end OSDV:' -> out.puttext; OSDvisibility -> out.putint; 
          ' objSize:'->out.puttext; objSize -> out.putint;  
          ' isIndexed:'->out.puttext; 
          (if isIndexed then 1 -> V else 0 -> V if);
          V -> out.putint;  ' '-> out.put;
          stack.print -> out.puttext;
          out.newline;
          objSize -> descs.current.objSize;
          V -> descs.current.isIndexed; 
          OSDvisibility -> descs.current.OSDvisibility;     
          (if OSDvisibility > 0 then
              (*'\n**** OSDvisibility: ' -> puttext; 
              OSDvisibility -> putint; newline*)
          if);
          labs.saveInImage ;
          (if emitLLVM then
              'end ' -> putline
          if)
       #);
     
     close:
       (#
       do VdtPatch.patch;         
          dump;
       #);
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
               0 -> loc.new; 
               0 -> use.new
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (*'labs.def:labNo: ' -> puttext; labNo -> putint; 
               ' range: ' -> puttext; loc.range -> putint;*)
               (if labNo > loc.range then labNo - loc.range -> loc.extend if);
               (if labNo > use.range then labNo - use.range -> use.extend if); (*ugly*)
               (* ' labs.def:new:range: ' -> puttext; loc.range -> putint;
               newline;*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          saveInImage:
            (# 
            do (*'saveInImage: ' -> puttext; loc.range -> putint; newline;*)
               loc.range -> descs.current.labs.new;
               (for i: loc.range repeat
                   loc[i] -> descs.current.labs[i]
               for)
            #);            
          loc: [0] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [0] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
     dump: (# do descs.dump #);
     
     out: ^Stream;
     
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     emit8: (# enter descs.current.bc.emit8 #);
     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     prim: @ Primitives
  #);

