ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'Primitives';
INCLUDE 'betaVM';
---lib:attributes---
ObjectCode:
  (# notLLVM: @ boolean;
     emitCom: (# exit false #);
     init:<
       (# emitLLVM: @boolean
       enter(out[],emitLLVM)
       do not emitLLVM -> notLLVM;
          vdtPatch.init;
          inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comment:
       (# T: ^text
       enter T[]
       do (if emitCom then
              (if notLLVM then 
                  ' -- ' -> out.puttext;
               else
                  '   ;; ' -> out.puttext;
              if);
              T[] -> out.putline
          if)          
       #);
     comB:
       (# T: ^text
       enter T[]
       do (if emitCom then
              (if notLLVM then
                  ' -- ' -> out.puttext; 
               else
                  ';; ' -> out.puttext;
              if);
              T[] -> out.puttext
          if)
       #);
     comA: 
       (# T: ^text
       enter T[]
       do T[] -> out.puttext
       #);
     comE:
       (# T: ^text
       enter T[]
       do T[] -> out.putline
       #);
     com2:
       (# T1,T2: ^text
       enter(T1[],T2[])
       do (if emitCom then
              (if notLLVM then
                  ' -- ' -> out.puttext;   
               else
                  ';; ' -> out.puttext
              if);        
              T1[] -> out.puttext; T2[] -> out.puttext
          if)
       #);
     com: 
       (# II: (# enter Tx.putint do ' ' -> Tx.put #);
          TT: 
            (# S: ^text; Q: @text; i: @integer; inText: @boolean
            enter S[]
            do (if S[] <> none then
                   L:
                     S.scanAll
                     (#
                     do (if ch 
                         // '"' then
                            '"' -> Q.put;
                            not inText -> inText
                         // ascii.newline then
                            ' ' -> Q.put; '|' -> Q.put; ' ' -> Q.put 
                         else
                            ch -> Q.put
                        if);
                        (if (i + 1 -> i) > (70 - Tx.length) then 
                            ' ...' -> Q.puttext;     
                            (if inText then '"'-> Q.put if);
                            leave L 
                        if)
                     #)
                else
                   '-none-' -> Tx.puttext
               if);
               Q[] -> Tx.puttext
            #);
          TQ:
            (# S: ^Text
            enter S[]
            do '"' -> Tx.put;
               S[] -> TT;
               '"' -> Tx.put; ' ' -> Tx.put
            #);
          BB: 
            (# Bx: @boolean 
            enter Bx do (if Bx then 'true' -> TX.puttext else 'false' -> TX.puttext if)
            #);
          CC: (# ch: @char enter ch do ch -> Tx.put #);
          FF: (# F: @real enter F do F -> Tx.putreal #);
          nl: (# do emit; Tx.clear #);
          emit: 
            (# 
            do Tx.newline; 
               (if notLLVM then
                   ' -- ' -> out.puttext;
                else
                   ';; ' -> out.puttext
               if);
               Tx[] -> out.puttext; 
            #);
          print: (# do '***** ' -> puttext; Tx[] -> putline #);
          Tx: @Text
       do (if emitCom then inner; emit;if)
       #);          
     newComponent: (* Not used!? *)
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do ' component ' -> out.puttext; N[] -> out.puttext; 
          ' NoOfDescs: ' -> out.puttext; noOfDescs -> out.putint; out.newline;
          noOfDescs + 3 -> descs.top -> descs.OD.new; (* noOfDesc + 2 since an extra
                                                       * desc is allocated for main 
                                                       * and EventProcessor
                                                       *)
       #);
     newReg: @
       (# rn: @integer
       do rn + 1 -> rn
       exit rn
       #);
     newVreg:
       (# rN: @integer; T: ^Text
       enter rN
       do '%V' -> T[]; rN -> T.putint
       exit T[]
       #);
     newRreg:
       (# rN: @integer; T: ^Text
       enter rN
       do '%R' -> T[]; rN -> T.putint
       exit T[]
       #);
     vReg:
       (# top: @integer; T: ^text
       enter top
       do '%V' -> T[]; 
          (if top > 0 then
              stack.VregNo[top] -> T.putint
           else
              0 -> T.putint
          if)
       exit T[]
       #);
     rReg:
       (# top: @integer; T: ^text
       enter top
       do 
          (if false and (stack.RregNo[top] = 0) then
              'this' -> T[]
           else
              '%R' -> T[];  
              (if top > 0 then 
                  stack.RregNo[top] -> T.putint 
               else
                  117 -> T.putint 
              if);
          if)
       exit T[]
       #);
     stack: @
       (# rTop,vTop,rTopMax,vTopMax: @integer;
          VregNo: [10] @ integer;
          RregNo: [10] @ integer;
          init: 
            (#
            do 0 -> rTop -> vTop -> rTopMax -> vTopMax;
               0 -> newReg.rN;
            #);
          vpush:
            (# rN: @integer
            enter rN
            do (*';; vpush: ' -> out.putline;*)
               (if (vTop + 1 -> vTop) > vTopMax then vTop -> vTopMax if);
               (if vTop > 0  then
                   (if vTop > vRegNo.range then vRegNo.range->vRegNo.extend if);
                   rN -> VregNo[vTop];
                else
                   (if not notLLVM then
                       ';; vpush:vtop: ' -> out.puttext; vTop ->  out.putint;
                       out.newline
               if)if);
               'vpush' -> dump
            #);
          vpop: (# n: @integer enter n do vTop - n -> vTop; 'vpop' -> dump #);
          rpush:
            (# rN: @integer
            enter rN
            do (if (rTop + 1 -> rTop) > rTopMax then rTop -> rTopMax if);
               (if rTop > 0 then
                   (if rTop > rRegNo.range then rRegNo.range->rRegNo.extend if);
                   rN -> RregNo[rTop];
                else
                   (if not notLLVM then
                       ';; rpush:rtop: ' -> out.puttext; rTop ->  out.putint; out.newline
               if)if);
               'rpush' -> dump
            #);
          rpop: (# n: @integer enter n do rTop - n -> rTop; 'rpop' -> dump #);
          print: 
            (# T: @text
            do ' vTop:' -> T.puttext; vTop -> T.putint;
               ' vTopMax:' -> T.puttext; vTopMax -> T.putint;
               ' rTop:' -> T.puttext; rTop -> T.putint;
               ' rTopMax:' -> T.puttext; rTopMax -> T.putint;
            exit T[]
            #);
          dump:
            (# T: ^text
            enter T[]
            do com(#do 'stack:' -> TT; T[] -> TT; ': vTop: ' -> TT; vTop -> II;
                     ' vTopMax: ' -> TT; vTopMax -> II;
                     '  rTop: ' -> TT; rTop -> II; 
                     ' rTopMax: ' -> TT; rTopMax -> II; 
                     ' V:'->TT; (if vTop > 0 then VregNo[vTop] -> II if);
                     ' R:'->TT; (if rTop > 0 then RregNo[rTop] -> II if);
                  #)
            #);
          dumpVRN:
            (#
            do 'vregNo:vTop: ' -> puttext;  vTop ->  out.putint; ' :: ' -> puttext;
               (for i: vTop repeat
                    VregNo[i] ->  out.putint; ' ' -> out.put
               for);
               out.newline
            #)
       #);
     LLVMstructs: @ Text;
     typeInfo: @
       (# dsc: [100] ^Info; top: @integer;
          current: ^Info;
          Info:
            (# sig: ^text;
               attQs: [10] ^text; attQtop: @integer;
               printStruct:
                 (#
                 do (for i: attQtop repeat
                         (if i > 1 then ',' -> LLVMstructs.put if);
                         (if attQS[i][] = none then
                             (* only for BETAworld origin = null *)
                             'i32*' -> LLVMstructs.puttext;
                          else
                             attQS[i][] -> LLVMstructs.puttext
                         if)                         
                    for)
                 #);
               print:
                 (#
                 do sig[] -> puttext; ' ::' -> puttext;
                    (for i: attQtop repeat 
                         ' i:' -> puttext; i -> putint; 
                         ' '-> put; attQS[i][] -> puttext; 
                    for);
                    newline
                 #) 
            enter sig[]
            exit this(info)[]
            #);
          getID:
            (# T: ^text; inx,dn: @integer
            enter T[]
            do L:
                 T.scanAll
               (# i: @integer
               do i + 1 -> i;
                  (if ch = '$' then i -> inx; leave L if);
               #);
            exit inx
            #);
          patch:
            (# miN,T: ^text; inxA,inxB: @integer; C: ^Info
            enter miN[]
            do (if false then
                   'patch: ' -> puttext; miN[] -> puttext; ' ' -> put;
               if);
               miN[] -> getID -> inxA; 
               (if false then
                   inxA -> putint; newline;
               if);
               (for i: top repeat
                    (if (dsc[i][] -> C[]) <> none then
                        (for j: C.attQtop repeat
                             (if (C.attQS[j][] -> T[]) <> none then
                                 T[] -> getID -> inxB;
                                 (if inxA = inxB then
                                     (if ((1,inxA) -> miN.sub)
                                           ->
                                         ((1,inxB) -> T.sub).equal then
                                         (If false then
                                             'match: ' -> puttext;
                                             miN[] -> puttext;
                                             ' ' -> put;
                                             T[] -> putline;
                                         if);
                                         (if false then
                                             '*** patch:in: ' -> puttext;
                                             C.sig[] -> puttext;
                                             ' old: ' -> puttext;
                                             C.attQS[j][] -> puttext;
                                             ' by: ' -> puttext;
                                             miN[] -> putline;
                                         if);
                                         miN[] -> C.attQS[j][];
                                         leave patch
                             if)if)if)
                        for)
                    if)
               for)
            #);
          addDsc:
            (# descNo: @integer; sig: ^text;
            enter(descNo,sig[])
            do (*'add: ' -> puttext; descNo -> putint;*)
               (if descNo > dsc.range then descNo -> dsc.extend if);
               sig[] -> Info -> dsc[descNo][] -> current[];
               (if descNo > top then descNo -> top if);
               (*' ' -> put; top -> putint; newline;*)
               sig[] -> patch
            #);
          addRoff:
            (# off: @integer; sig: ^text
            enter(off,sig[])
            do (if off > current.attQtop then 
                   current.attQs.range -> current.attQs.extend 
               if);
               sig[] -> current.attQs[off][];
               (if off > current.attQtop then off -> current.attQtop if)
            #);
          lookup:
            (# sig: ^text; inx,off,dn: @integer; attSig: ^text
            enter(sig[],off)
            do (*print;*)
               (*'lookup: ' -> puttext; sig[] -> puttext; ' off:' -> puttext;
               off -> putint; ' ' -> put;*)
               sig.scanAll
               (# i: @integer
               do i + 1 ->i; 
                  (if ch = '$' then i -> inx if);
               #);
               (if inx > 0 then
                   (*'match: ' -> puttext;*)
                   inx ->sig.setPos;
                   sig.getint -> dn; (*dn -> putint; ' ' -> put;*)
                   (*dsc[dn].print;*)
                   (if dsc[dn][] <> none then
                       (*dsc[dn].sig[] -> puttext; ' ' -> put;*)
                       dsc[dn].attQs[off][] -> attSig[];
                    else
                       'none' -> attSig[]
                   if);
                   (*attSig[] -> putline*)
                else
                   'no-match' -> attSig[]
               if)                   
            exit attSig[]
            #);
          printStructs:
            (# D: ^Info
            do ''-> LLVMstructs;
               (for i: top repeat
                    (if (dsc[i][] -> D[]) <> none then
                        D.sig[] -> LLVMstructs.puttext;
                        ' = type {' -> LLVMstructs.puttext;
                        D.printStruct;
                        '}\n' -> LLVMstructs.puttext
                    if)
               for)
            #);
          print:
            (#
            do 'typeInfo: ' -> puttext; top -> putint; newline;
               (for i: top repeat
                    (if dsc[i][] <> none then
                        'off: ' -> puttext; i -> putint; ': ' -> puttext;
                        dsc[i].print
                if)for)
            #)
       #);
     thisClassN: ^Text;
     getThisClass:
       (# classN,T: ^text; rN: @integer
       enter classN[]
       do newReg -> rN -> newRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext; 
          classN[] -> out.puttext; ', ' -> out.puttext;
          (if true then
              classN[] -> out.puttext;
           else
              thisClassN[] -> out.puttext;
          if);
          ' * ' -> out.puttext;
          stack.rtop -> rReg -> out.puttext; 
          ', i32 0 ' -> out.puttext
       exit rN
       #);
     getThisClassX:
       (# classN,T: ^text
       enter classN[]
       do 
          ' = getelementptr ' -> out.puttext; 
          classN[] -> out.puttext; ', ' -> out.puttext;
          (if true then
              classN[] -> out.puttext;
           else
              thisClassN[] -> out.puttext;
          if);
          ' * ' -> out.puttext;
          stack.rtop -> rReg -> out.puttext; 
          ', i32 0 ' -> out.puttext
       #);     
     mkLLVMclassName:
       (# N,T: ^text
       enter N[]
       do N[] -> filter -> T[];
          inner
       exit T[]
       #);
     mkLLVMstructName: mkLLVMclassName
       (#
       do '%obj.' -> T.prepend
       #);
     prepStruct:
       (# N,T: ^text
       enter N[]
       do N[] -> filter -> T[];
          (*'   ;; prepStruct: ' -> out.puttext; N[] -> out.putline;*)
          '%obj.' -> T.prepend
       exit T[]
       #);
     filter:
       (# N,T: ^text
       enter N[]
       do '' -> T[];
          L: 
          N.scanAll
          (#
          do (if ch
              // '@' // '#' // ':' then
                 '$' -> T.put
              // '+'  then
                 '_' -> T.put; 
              else
                 ch -> T.put
             if)#)
       exit T[]
       #);
     classDef:
       (# N: ^text; descNo: @integer; T: ^text;
          add:
            (# off: @integer
            enter off
            do (if not first then ',' -> LLVMstructs.put if);
               false -> first;
               (*off -> putint; ':'->put; *)
               INNER;
            #);
          addR: add
            (# OGid: ^text
            enter OGid[]
            do OGid[] -> filter -> OGid[];
               '%obj.' 
                 -> OGid.prepend 
                 -> OGid[]-> LLVMstructs.puttext; 
               '*' -> LLVMstructs.put;
               (off,'*'->(OGid.copy).put) -> typeInfo.addRoff
            #);
          addV: add
            (# 
            do 'i32'-> LLVMstructs.puttext; 
               (off,'i32') -> typeInfo.addRoff
            #);
          first: @boolean
       enter(N[],descNo)
       do (if not notLLVM then
              (if true
               // ':=' -> N.equal then  '_assign' -> N[]
               // '=' -> N.equal then '_equal' -> N[]
               // '+' = (1 -> N.inxGet) then
                  '_add' -> N[]; (2,N.length) -> N.sub -> N.append;
              if);
              N[] -> filter -> N[];
              
              '%obj.' -> T[]; N[] -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;
              
              (descNo,T[]) -> typeInfo.addDsc;
              
              '%obj.' -> T[]; N[] -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;
              T[] -> thisClassN[];
              T[] -> LLVMstructs.puttext; ' = type {' -> LLVMstructs.puttext;
          true -> first;         
              inner classDef;
              '}'-> LLVMstructs.puttext; LLVMstructs.newline;
          if)
       #);
     class:
       (# dumpClass:
            (#
            do '\n\n*** Fatal error in objectCode: *** Class: ' -> puttext; 
               N[] -> puttext; ' descNo = '->puttext; descNo -> putint;
            #);
          N: ^text; descNo,topDescNo,originOff,originDescNo: @integer;
          procE: @boolean; (* mark start as proc-entry and enter-entry *)
          add:
            (# off: @integer
            enter off
            do (if not first then ',' -> LLVMstructs.put if);
               false -> first;
               (*off -> putint; ':'->put; *)
               INNER;
            #);
          addR: add
            (# OGid: ^text
            enter OGid[]
            do '%obj.' -> LLVMstructs.puttext;
               OGid[] -> filter -> LLVMstructs.puttext; '*' -> LLVMstructs.put;
               (off,OGid[]) -> typeInfo.addRoff
            #);
          addV: add
            (# 
            do 'i32'-> LLVMstructs.puttext; 
            #);
          first: @boolean;
          T: ^Text
       enter(N[],descNo,procE,topDescNo,originOff,originDescNo)
       do stack.init;               
          stack.rpush;
          (if notLLVM then
              '\nclass ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
              descNo -> out.putint; ' ' -> out.put;
              originOff -> out.putint; ' ' -> out.put;
              originDescNo -> out.putint;
              out.newline;
              (if descNo = 0 then
                  dumpClass;
                  ' is ZERO!' -> putline
              if);
              (N[],descNo,originOff,originDescNo,out[]) -> descs.setCurrent;
              (if descs.OD[topDescNo][]= none then 
                  dumpClass;
                  ' descs.OD[topDescNo='->puttext; 
                  topDescNo -> putint;
                  '][]= none' -> putline
               else
                  (topDescNo,descs.OD[topDescNo].bc[]) -> descs.current.setSuperBC;
              if);
              descs.markAllocE;
              (if procE then 
                  'procE:' -> puttext; N[] -> putline;
                  descs.markProcE 
              if);
              initGCinfo;
              labs.init;
           else
              (*typeInfo.print;*)
              (N[],descNo,originOff,originDescNo,out[]) -> descs.setCurrent;
              (topDescNo,descs.OD[topDescNo].bc[]) -> descs.current.setSuperBC;
              (* at entry to an object thisStack contains the arguments of the 
               * object and the origin - here we make one rpush for the origin
               * We need to pass noOfVargs amd noOfRargs and init stack with these
               * See also rtn:
               *)

              (if true
               // ':=' -> N.equal then  '_assign' -> N[]
               // '=' -> N.equal then '_equal' -> N[]
               // '+' = (1 -> N.inxGet) then
                  '_add' -> N[]; (2,N.length) -> N.sub -> N.append;
              if);
              N[] -> filter -> N[];
              
              '%obj.' -> T[]; N[] -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;

              inner;

              '%obj.' -> T[]; N[] -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;
              T[] -> thisClassN[];
              
              '\n@.str.' -> out.puttext; N[] -> out.puttext; 
              '$' -> out.put; descNo -> out.putint;               
              ' = private unnamed_addr constant [' -> out.puttext;
              N.length + 2 -> out.putint;
              ' x i8] c"' -> out.puttext; N[] -> out.puttext;
              '\\0A\\00"\n' -> out.puttext;
              (if 'main' -> N.equal then
                  'define void @main(i8* %args){\n' -> out.puttext;
               else
                  'define ' -> out.puttext; thisClassN[] -> out.puttext; 
                  '* @' -> out.puttext; N[] -> out.puttext;      
                  '$' -> out.put; descNo -> out.putint;
                  '(' -> out.put; 
                  thisClassN[] -> out.puttext;
                  (*'%obj.' -> (N.copy).prepend -> out.puttext;*)
                  ' *%R0' -> out.puttext;
                  '){\n' -> out.puttext;
              if);
              '   %S = getelementptr [' -> out.puttext;
              N.length + 2 -> out.putint;
              ' x i8], [' -> out.puttext;
              N.length + 2 -> out.putint; 
              ' x i8]* @.str.' -> out.puttext; N[] -> out.puttext; 
              '$' -> out.put; descNo -> out.putint;
              ', i64 0, i64 0\n' -> out.puttext;
              
              '   call i32 @puts(i8* %S)\n' -> out.puttext;
              '   %V0 = add i32 0, 0' -> out.putline; (* just a dummy *)
          if)
       #);
     super: 
       (# N: ^text; superDescNo: @integer
       enter(N[],superDescNo)
       do (if notLLVM then
              ' -- super ' -> out.puttext; N[] -> out.putline;
              descs.OD[superDescNo][] -> descs.current.superObjDesc[]
          if)
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do 'ENTER:' -> out.putline
       #);
     setThisStack:
       (#
       do (if notLLVM then
              ' setThisStack ' -> out.putline;
              codes.setThisStack -> emit
          if)
       #);
     rpopThisObj:
       (#
       do (if notLLVM then
              ' rpopThisObj ' -> out.putline;
              codes.rpopThisObj -> emit
           else
          if)
       #);       
     actions:
       (# hasSuper,genDoEvent: @boolean
       enter(hasSuper,genDoEvent)
       do (if notLLVM then
              'DO:'->out.putline;
              descs.markDoE;
              (if genDoEvent then doEventQ if);
          if)
       #);
     mvStack:
       (#
       do (if notLLVM then ' mvStack '->out.putline; codes.mvstack -> emit if)
       #);
     markExitE: (# do descs.markExitE #);
     doExit:
       (#
       do 'EXIT:' -> out.putline; 
          ' doExit ' -> out.putline; 
          codes.doExit -> emit
       #);
     rtn: 
       (# LMR: @char
       enter LMR 
       do (if notLLVM then
              ' rtn(' -> out.puttext; LMR->out.put; ')' -> out.put; out.newline;
              codes.rtn -> emit ; LMR -> emit;
           else
              (* we need to pop the return values from the stack, but we dont
               * know its type here - we thus currently assume that a ref is returned
               *)
              (if 'main' -> ((6,9) -> thisClassN.sub).equal then
                  '   ret void\n' -> out.putline
               else
                  '   ret ' -> out.puttext; 
                  thisClassN[] -> out.puttext; ' *%R0\n' -> out.puttext;
          if)if);
          1 -> stack.rpop;
       #);
     rtnV: (*rtnValue*)
       (#
       do (If notLLVM then
              ' rtnV\n' -> out.puttext;  codes.rtnV -> emit 
           else
          if)
       #);
     rtnC: (# do ' rtnC' -> out.putline; codes.rtnC -> emit #);
     rtnExit: (# do ' rtnExit' -> out.putline; codes.rtnExit -> emit #);
     rtnInner: 
       (# 
       do (if notLLVM then
              ' rtnInner' -> out.putline; codes.rtnInner -> emit
           else
              '   ;; rtnInner\n' -> out.puttext;
              '   ret ' -> out.puttext; thisClassN[] -> out.puttext; 
              ' *%R0\n' -> out.puttext;              
          if)
       #);
     rtnEvent: 
       (# hasExit: @integer 
       enter hasExit 
       do ' rtnEvent ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEvent -> emit;
          hasExit -> emit
       #);
     allocEventQ:
       (# asObj: @boolean
       enter asObj
       do (If notLLVM then
              ' allocEventQ\n' -> out.puttext;
              codes.allocEventQ -> emit;
              (if asObj then 1 -> emit else 0 -> emit if)
          if);
       #);
     rtnEventQ: 
       (# hasExit: @integer 
       enter hasExit 
       do (if notLLVM then
              ' rtnEventQ ' -> out.puttext; hasExit -> out.putint; out.newline;
              codes.rtnEventQ -> emit;
              hasExit -> emit
          if)
       #);
     doEventQ:
       (#
       do (if notLLVM then
              ' doEventQ\n' -> out.puttext;
              codes.doEventQ -> emit
          if);
       #);
     stop: 
       (# 
       do (if notLLVM then
              ' stop' -> out.putline; codes.stop -> emit
           else
              '   ;; stop\n' -> out.puttext
          if)
       #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          'D' -> rtn          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do (if notLLVM then
              ' L' -> out.puttext; lab -> out.putint; ':' ->out.put; out.newline;
              lab -> labs.def;
           else
              '   br label %L' -> out.puttext; lab ->  out.putint;  out.newline;
              'L'-> out.puttext; lab ->  out.putint; ':' -> out.put; out.newline
          if);
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do ' jmpIf_GT L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       do (if notLLVM then
              ' jmp L' -> out.puttext; lab -> out.putint; out.newline;
              codes.jmp -> emit;
              0 -> emit2;
              lab -> labs.mark;
           else
              '   br label %L' -> out.puttext; lab ->  out.putint; out.newline 
          if);          
       #);
     jmpFalse:
       (# Tlab,Flab: @integer 
       enter(Tlab,Flab) 
       do (if notLLVM then
              ' jmpFalse L' -> out.puttext; Flab -> out.putint; out.newline;
              codes.jmpFalse -> emit;
              0 -> emit2;
              Flab -> labs.mark;
           else
              '   br i1 ' -> out.puttext; stack.vtop -> vReg -> out.puttext; 
              ', label %L' -> out.puttext; Tlab ->  out.putint;
              ', label %L' -> out.puttext; Flab ->  out.putint; out.newline 
          if);
          1-> stack.vpop
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do '   jmpTrue L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpTrue -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     break:
       (# on,lab,descInx,pn: @integer
       enter(on,lab,descInx,pn)
       do ' break ' -> out.puttext; on -> out.putint; ' ' -> out.put; 
          lab -> out.putint; ' ' -> out.put; descInx -> out.putint;
          ' ' -> out.put; pn -> out.putint;
          out.newline;
          codes.break -> emit;
          on -> emit; 
          (if lab = 0 then
              '\n***** Fatal error break: lsc=0' -> putline
          if);
          lab -> emit2;
          descInx -> emit2;
          pn -> emit
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do ' alloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.alloc -> emit; descNo -> emit2;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     tstOriginIsNone:
       (#
       do (if notLLVM then
              ' tstOriginIsNone ' -> out.putline;
              codes.tstOriginNone -> emit;
           else
              
          if)
       #);
     invoke: 
       (# N,Ns: ^text; descNo,staticOff: @integer; 
          asObj: @boolean; iO: @integer;
          rN: @integer
       enter(N[],descNo,staticOff,asObj) 
       do (if notLLVM then
              ' invoke ' -> out.puttext; N[] -> out.puttext; 
              ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
              staticOff -> out.putint; ' ' -> out.put;
              (if asObj then 1 -> iO else 0 -> iO if);
              io -> out.putint;
              out.newline;
              codes.invoke -> emit; descNo -> emit2; staticOff -> emit2;
              iO -> emit;
           else
              (* the origin and possible arguments are on the stack
               * As for now we dont know the no of arguments
               * We thus make an rpop for the origin
               * callee returns a value - here we dont know the type so we 
               * assume that a ref to callee is returned
               *)
              '   ;; invoke: "' -> out.puttext; N[] -> out.puttext;
              N[] -> filter -> N[];
              ' ; ' -> out.puttext; N[] -> out.putline;
              1 -> stack.rpop;
              (*stack.rpush;*)
              '   ' -> out.puttext;
              newReg -> rN -> newRreg -> out.puttext; ' = ' -> out.puttext;
              '$' -> N.put; descNo -> N.putint;
              N.copy -> Ns[];
              '%obj.' -> Ns.prepend;

              'alloca ' -> out.puttext; Ns[] -> out.puttext; 
              '   ; new ' -> out.puttext; Ns[] -> out.putline;
              rN -> stack.rpush;
              
              inner invoke;
              
              '   call ' -> out.puttext; Ns[] -> out.puttext;
              '* @' -> out.puttext; N[] -> out.puttext; 
              '(' -> out.put; Ns[] -> out.puttext; ' * ' -> out.puttext;
              rN -> newRreg -> out.puttext; ')' -> out.put;
              out.newline;

          if)
        #);
     mkVindexed:
       (# descInx: @integer
       enter descInx
       do ' mkVindexed ' -> out.puttext; descInx -> out.putint; out.newline; 
          codes.mkVindexed -> emit; descInx -> emit2;
       #);
     mkRindexed:
       (# descInx: @integer
       enter descInx
       do ' mkRindexed ' -> out.puttext; descInx -> out.putint; out.newline;
          codes.mkRindexed -> emit; descInx -> emit2;
       #);     
     saveAndSetThis:
       (#
       do (If notLLVM then
              ' saveAndSetThis ' -> out.putline;
              codes.saveAndSetThis -> emit
          if)
       #);
     restoreThis:
       (#
       do  ' restoreThis ' -> out.putline;
          codes.restoreThis -> emit
       #);
     invokeVal:
         (# N: ^text; descNo,staticOff: @integer
       enter(N[],descNo,staticOff) 
         do ' invokeVal ' -> out.puttext; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
           staticOff -> out.putint; out.newline;
           codes.invokeVal -> emit; descNo -> emit2; staticOff -> emit2
         #);
     boxedInvokeVal:
       (# N: ^text; descNo,size: @integer
       enter(N[],descNo,size)
         do ' boxedInvokedVal ' -> out.puttext; N[] -> out.puttext; 
          ' ' -> out.put; descNo -> out.putint; 
          ' ' -> out.put; size -> out.putint; out.newline;
           codes.boxedInvokeval -> emit; descNo -> emit2; size -> emit2
         #);
     invokeExternal:
       (# N: ^text; externalNo: @integer
       enter(N[],externalNo)
       do ' invokeExternal ' -> out.puttext; externalNo -> out.putint; 
          out.newline;
          codes.invokeExternal -> emit; externalNo -> emit
       #);
     allocIndexed:
         (# N: ^text; descNo,size,isRefIndexed: @integer;
       enter(N[],descNo,size,isRefIndexed) 
         do ' allocIndexed ' -> out.puttext; N[] -> out.puttext; 
            ' ' -> out.put; 
            descNo -> out.putint; ' ' -> out.put; 
            size -> out.putint; ' ' -> out.put; 
            isRefIndexed -> out.putint; out.newline;            
            codes.allocIndexed -> emit; descNo -> emit2; size-> emit; 
            isRefIndexed -> emit
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do ' exeAlloc ' -> out.puttext; descNo -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit2
       #);
       
     newVrep: (# do ' newVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do ' send ' -> out.puttext; inx -> out.putint; 
          ' ' -> out.put;  N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     sendVirtual: 
       (# N: ^text; dinx,noOfRefArgs: @integer 
       enter(N[],dinx,noOfRefArgs) 
       do ' sendv ' -> out.puttext; dinx -> out.putint; 
          ' ' -> out.put; noOfRefArgs -> out.putint;
          ' ' -> out.put; N[] -> out.putline;
          codes.sendv -> emit; dinx -> emit; noOfRefArgs -> emit
       #);
     invokev:
       (# N: ^text; dinx: @integer 
       enter(N[],dinx) 
       do '*** objectCode::invokev called'->putline;
          (*' invokev ' -> out.puttext; dinx -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.invokev -> emit; dinx -> emit;*)
       #);
     exe: 
       (# N: ^text enter N[] do ' exe ' -> out.puttext; N[] -> out.putline #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do ' call(' -> out.puttext; LMR -> out.put; ')' -> out.put;
          N[] -> out.putline; 
          codes.call -> emit;
          LMR -> emit
       #);
     vdtTablePrint:
       (# descNo: @integer; T: @text
       enter descNo
       do 'vdtTable:Q: ' -> T.puttext;
          (for i: descs.OD[descNo].vdtTable.range repeat 
               (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[descNo].vdtTable[i] -> T.putint;
               inner
          for); 
          T[] -> comment          
       #);
     vdtTableCopy:
       (# superDescNo: @integer; T: @text
       enter superDescNo
       do (for i: descs.OD[superDescNo].vdtTable.range repeat (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[superDescNo].vdtTable[i] -> T.putint; 
               (i,descs.OD[superDescNo].vdtTable[i]) -> descs.current.vdtAdd
          for); 
          T[] -> comment;
          (* copy literals from super to current *)
          descs.OD[superDescNo].literals.range 
            -> descs.current.litTop
            -> descs.current.literals.new;
          (for i: descs.current.litTop repeat
               (*descs.OD[superDescNo].literals[i] -> putint; ',' -> put;*)
               descs.OD[superDescNo].literals[i] -> descs.current.literals[i]
          for);
          (*newline;*)
       #);
     vdtTable:
       (# inx,descInx: @integer
       enter(inx,descInx)
       do (inx,descInx) -> descs.current.vdtAdd -> comment
       #);
     vdtTableAt:
       (* For OD:descNo, virtual/inner:inx is bound to descInx *)
       (# inx,descInx,descNo: @integer
       enter(inx,descInx,descNo)
       do (if false then
              ' vdtTableAt: ' -> puttext;
              inx -> putint; ' ' -> put;
              descInx -> putint; ' ' -> put;
              descNo -> putint; newline;
          if);
          (inx,descInx,descNo) -> VdtPatch.add
       #);
     VdtPatch: @
       (# index,bindInx,descInx:[5] @ integer; top: @integer;
          init: (# do 0 -> top #);
          add:
            (* For OD:dx, virtual/inner:ix is bound to bx *)
            (# ix,bx,dx: @integer
            enter (ix,bx,dx)
            do (if (top + 1 -> top) > index.range then
                   index.range -> index.extend;
                   bindInx.range -> bindInx.extend;
                   descInx.range -> descInx.extend;
               if);
               ix -> index[top];
               bx -> bindInx[top];
               dx -> descInx[top];
            #);
          patch:
            (#
            do (for i: top repeat
                    (if false then
                        'Patch:range:' -> puttext; index.range -> putint; ' ' -> put;
                        index[i] -> putint; ' ' -> put;
                        bindinx[i] -> putint; ' ' -> put;
                        descInx[i] -> putint;  ' ' -> put;  newline;
                    if);
                    (index[i],bindInx[i]) 
                      -> descs.OD[descInx[i]].vdtAdd -> comment
               for)
            #)
       #);
     toSuper:
       (# descInx: @integer
       enter descInx
       do (if notLLVM then
              ' toSuper ' -> out.puttext;
              descInx -> out.putint; out.newline;
              codes.toSuper -> emit; descInx -> emit2
           else
              '   ;; toSuper'->out.putline
          if)
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do (if notLLVM then
              ' innerX ' -> out.puttext; ' ' -> out.put; 
              inx -> out.putint; out.newline;
              codes.innerx -> emit; inx -> emit;
           else
             '   ;; innerx\n' -> out.puttext 
          if)
       #);
     innerP: (* Inner P, where P.ON > 1 *)
       (# inx: @integer 
       enter inx
       do (if notLLVM then
              ' innerP ' -> out.puttext; ' ' -> out.put; 
              inx -> out.putint; out.newline;
              codes.innerP -> emit; inx -> emit;

           else
              1 -> stack.rPop              
          if)
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do ' innerExit ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;

       #);
     innerA:
       (# inx: @integer 
       enter inx
       do (if notLLVM then
              ' innerA ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
              codes.innerA -> emit; inx -> emit;
          if)
       #);
     suspendd: (# do ' suspend' -> out.putline; codes.susp -> emit #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do ' doSuper' -> out.puttext; ' ' -> out.put; N[] -> out.puttext; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit2;
       #);

     pushThis:
       (# 
       do (if notLLVM then
              ' pushThis ' -> out.putline;
              codes.pushthis -> emit; 
           else
              0 -> stack.rPush;
          if)
       #);
     addOff:
       (# off: @integer
       enter off
       do ' addOff ' -> out.puttext; off -> out.putint; out.newline;
          codes.addOff -> emit; off -> emit2;
          stack.vPush
       #);
     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' push ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.push -> emit; off -> emit;
          stack.vPush
       #);
     pushg: 
       (# N: ^text; off: @integer; rN,rN2: @integer
       enter(N[],off)
       do (if notLLVM then
              ' pushg ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.pushg -> emit; off -> emit;
           else
              '   ;; pushg "' -> out.puttext; N[] -> out.puttext;
              '"' -> out.put;
              ' ' -> out.put; off -> out.putint; 
              '\n   ' -> out.puttext;
              (if true then
                  N[] -> prepStruct -> getThisClass -> rN;
               else
                  thisClassN[] -> getThisClass -> rN;
              if);
              ', i32 ' -> out.puttext; 
              off - 1 -> out.putint; 
              '\n   ' -> out.puttext;
              newReg -> rN2 -> newVreg -> out.puttext;
              ' = load i32, i32* ' -> out.puttext;
              rN -> newRreg -> out.puttext;
              out.newline
          if);
          1 -> stack.rpop;
          rN2 -> stack.vPush;
       #);
     fpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do (if notLLVM then
              ' fpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fpushg -> emit; off -> emit;
           else
              '   ;; fpushg\n' ->  out.puttext
          if)
       #);     
     ovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' ovpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.ovpushg -> emit; off -> emit;
       #);
     fovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.fovpushg -> emit; off -> emit;
       #);     
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' rpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit;
          stack.rPush
       #);
     rpushg: 
       (# N: ^text; off: @integer; rN,rN2: @integer; T,elmType: ^text
       enter(N[],off)
       do (if notLLVM then
              ' rpushg ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.rpushg -> emit; off -> emit;
           else
              '   ;; rpushg ' -> out.puttext; N[] -> out.puttext; 
              ' ' -> out.put; off -> out.putint; out.newline;
              (N[],off) -> typeInfo.lookup -> elmType[];
              '   ' -> out.puttext;
              (if true then
                  thisClassN[] -> getThisClass -> rN; (* must save current on stack*)
               else
                  '%originClass' -> getThisClass -> rN;
              if);
              ', i32 ' -> out.puttext; 
              off - 1 -> out.putint; out.newline;
              newReg -> rN2 -> newRreg -> out.puttext;
              (if true then
                  ' = load ' -> out.puttext; 
                  (if false then
                      elmType[] -> T[] -> out.puttext;
                   else
                      N[] -> mkLLVMstructName -> T[] -> out.puttext;
                  if);
                  '* , ' -> out.puttext; 
                  T[] -> out.puttext; '** ' -> out.puttext;
               else
                  ' = load i32*, i32** ' -> out.puttext;
              if);
              rN -> newRreg -> out.puttext;
              out.newline;
          if);
          1 -> stack.rpop;
          rN2 -> stack.rPush;          
       #);
     xpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpush -> emit; off -> emit;
          stack.rPush
       #);
     xpushg:
       (# N: ^text; off,isValueObj,size: @integer
       enter(N[],off,isValueObj,size) 
       do ' xpushg ' -> out.puttext; N[] -> out.puttext;  ' ' -> out.put; 
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;  
          codes.xpushg -> emit; off -> emit; isValueObj -> emit; size -> emit;
          stack.vPush
       #);
     xrpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xrpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xrpush -> emit; off -> emit;
       #);    
     xrpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xrpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xrpushg -> emit; off -> emit;
       #);
     pushConst: 
       (# cst: @integer; rn: @integer
       enter cst
       do (if notLLVM then
              ' pushc ' -> out.puttext; cst -> out.putint; out.newline;
              (if true 
               // cst <= 255 then
                  codes.pushc -> emit;
                  cst -> emit
               // cst <= 255 * 255  then
                  codes.pushc2 -> emit;
                  cst -> emit2
               else 
                  'OBS! Constant >= 2^16 is not implemented' -> comment
              if);
           else
              '   ' -> out.puttext;
              newReg -> rN -> newVreg -> out.puttext;
              ' = add i32 0, ' -> out.puttext; cst -> out.putint; out.newline
          if);
          rn -> stack.vPush
       #);
     pushFloatConst:
       (# X: @Real
       enter X
       do (if notLLVM then
              ' pushFloatConst ' -> out.puttext; X -> out.putReal; out.newline;
              codes.pushFloatConst -> emit;
              X -> emit8
           else
              '   ;; pushFloatConst \n' -> out.puttext;
          if)
       #);
     pushNone: 
       (# 
       do ' pushNone' -> out.puttext; out.newline;
          codes.pushNone -> emit;
          stack.rPush
       #);
     pushText:
       (# T,T1: ^text; I: @integer
       enter T[]
       do (if notLLVM then
              ' pushText ' -> out.puttext; T[] -> out.putline;
              codes.pushText -> emit;
              T[] -> handleEscape -> T1[];
              (* 'PushText: ' -> puttext; T1[] -> putline;*)
              T1.length -> descs.current.addLiteral
              (#
              do i + 1 -> i -> T1.inxGet -> value;
              #) -> emit;
              stack.rPush
           else
              ';; pushText \n' -> out.puttext;
          if)
       #);
     handleEscape:
       (# T: ^text; T1: @text;
          nextCh: 
            (# 
            do i + 1 -> i;
               (if i <= T.length then
                   i -> T.inxGet -> ch;
                else
                   0 -> ch
               if);               
            #);
          ch: @char;
          i: @integer
       enter T[]
       do 0 -> i;
          nextCh;
          loop:
            (if i <= T.length then 
                (if ch 
                 // '\\' then 
                    nextCh;
                    (if ch
                     // 'n' then
                        ascii.nl -> T1.put;
                        nextch
                     // '\\' then
                        '\\' -> T1.put;
                        nextch;
                     else
                        '\\' -> T1.put
                    if)
                 else
                    ch -> T1.put;
                    nextCh;                    
                if);
                restart loop
            if)
       exit T1[]
       #);
     mkStrucRef:
       (# T: ^text
       enter T[]
       do ' mkStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkStrucRef -> emit
       #);
      mkObjStrucRef:
       (# T: ^text
       enter T[]
       do ' mkObjStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkObjStrucRef -> emit
       #);
     mkVirtualStrucRef:
       (# T: ^text; off: @integer
       enter(T[],off)
       do ' mkVirtualStrucRef ' -> out.puttext; off-> out.putint; out.newline;
          codes.mkVirtualStrucRef -> emit; off -> emit
       #);
     allocFromStrucRefObj:
       (#
       do ' allocFromStrucRefObj ' -> out.putline;
          codes.allocFromStrucRefObj -> emit;
       #);
     pushValue:
       (# size: @integer
       enter size
       do ' pushvalue ' -> out.puttext; size -> out.putint; out.newline;
          codes.pushValue -> emit; size -> emit;
       #);
     vassign:
       (# size,mode: @integer
       enter(size,mode)
       do ' vassign ' -> out.puttext; size -> out.putint; ' ' -> out.put;
          mode -> out.putint; out.newline;
          codes.vassign -> emit; size -> emit; mode -> emit
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do (if notLLVM then
              ' store ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.store -> emit; off -> emit;
              1 -> stack.vpop
          if)
       #);
     storeg: 
       (# N: ^text; off: @integer; rN: @integer
       enter(N[],off) 
       do (if notLLVM then
              ' storeg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
              codes.storeg -> emit; off -> emit;
           else
              '   ;; storeg "' -> out.puttext; 
              N[] -> out.puttext; '"' -> out.put;
              ' ' -> out.put; off -> out.putint; 
              '\n   ' -> out.puttext;      
              
              newReg -> rN -> newRreg -> out.puttext;
              
              (if true then
                  N[] -> prepStruct -> getThisClassX;
               else
                  ' = getelementptr ' -> out.puttext; 
                  thisClassN[] -> out.puttext; ', ' -> out.puttext;
              if);
              (* from id stack: *)
              (*(if false then                  
                  thisClassN[] -> out.puttext;
               else
                  N[] -> prepStruct -> out.puttext;
              if);
              ' * ' -> out.puttext;
              stack.rtop -> rReg -> out.puttext; 
               ', i32 0, ' -> out.puttexct;
               *)
              ', i32 ' -> out.puttext; off - 1 -> out.putint; out.newline;
              '   store i32 ' -> out.puttext; stack.vtop -> vReg -> out.puttext;
              ', i32* ' -> out.puttext; 
              rN -> newRreg -> out.putline
          if);
          1 -> stack.vpop;
          1 -> stack.rpop
       #);
     fstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do (if notLLVM then
              ' fstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fstoreg -> emit; off -> emit;
           else
              '   ;; fstoreg \n' -> out.puttext;
          if);
          1 -> stack.vpop          
       #);     
     ovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' ovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.ovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);
     fovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.fovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);  
     rstore:
       (# N: ^text; off,rN: @integer
       enter(N[],off) 
       do (if notLLVM  then
              ' rstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
              (if off <= 255 then 
                  codes.rstore -> emit; off -> emit
              if);
           else
              '   ;; rstore ' -> out.putline
          if)
       #);
     rstoreX: 
       (# N: ^text; off,rN: @integer
       enter(N[],off) 
       do (if notLLVM  then
              ' rstore ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              (if off <= 255 then 
                  codes.rstore -> emit; off -> emit
              if);
           else
              '   ;; rstoreX "' -> out.puttext;
              N[] -> out.puttext; '"' -> out.put;
              ' ' -> out.put; off -> out.putint; 
              '\n   ' -> out.puttext;
              (if false then
                  '   store ' -> out.puttext; 
                  stack.rTop -> newRreg -> out.puttext;
                  N[] -> prepStruct -> out.puttext;
                  '* , ' -> out.puttext;
                  thisClassN[] -> out.puttext; 
                  '*, R0' -> out.puttext;
                  out.newline
               else
                  newReg -> rN -> newRreg -> out.puttext;
                  ' = getelementptr ' -> out.puttext; 
                  N[] -> prepStruct -> out.puttext;
                   ', ' -> out.puttext;
                  N[] -> prepStruct -> out.puttext; 
                  ' * ' -> out.puttext;
                  stack.rTop -> rReg -> out.puttext;
                  ', i32 0, i32 ' -> out.puttext; off - 1 -> out.putint; 
                  out.newline;
                  '   store ' -> out.puttext;
                  thisClassN[]  -> out.puttext;
                  '* %R0 , ' -> out.puttext;
                  thisClassN[] -> out.puttext;
                  ' ** ' -> out.puttext;
                  rN -> newRreg -> out.putline
              if)
          if);
          1 -> stack.rPop
       #);
     rstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do (if notLLVM then
              ' rstoreg ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              (if off <= 255 then 
                  codes.rstoreg -> emit; off -> emit
              if);
           else
              ';; rstoreg\n' -> out.putline
          if);
          2 -> stack.rPop
       #);
     xstore: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xstore ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put;  
          off -> out.putint; out.newline;
          (if off <= 255 then 
              codes.xstore -> emit; off -> emit
          if);
          1 -> stack.vpop
       #);
     xstoreg: 
       (# N: ^text; off,isValueObj,size: @integer
       enter(N[],off,isValueObj,size) 
       do ' xstoreg ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put;
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;          
          off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstoreg -> emit; off -> emit; isValueObj -> emit; size -> emit; 
          if);
          2 -> stack.vpop
       #);     
     xrstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstore -> emit; off -> emit
          if);
          2 -> stack.rpop
       #);
     xrstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstoreg -> emit; off -> emit
          if);
          1 -> stack.rpop
       #);
     double: 
       (# 
       do ' double' -> out.putline; codes.double -> emit; 
          stack.vPush; stack.vpush 
       #);
     rdouble: 
       (# do ' rdouble' -> out.putline; codes.rdouble -> emit;
          stack.rPush; stack.rpush           
       #);
     swap: (# do ' swap' -> out.putline; codes.swap -> emit #); (* not in use*)
     rswap: 
       (# rn: @integer
       enter rn
       do (if notLLVM then
              ' rswap ' -> out.puttext; rn -> out.putint; out.newline;
              codes.rswap -> emit; rn -> emit
           else
              ';; rswap\n' -> out.puttext
          if)
       #);
     rPop: 
       (# 
       do (if notLLVM then
              ' rpop' -> out.putline; codes.rpop -> emit; 1 -> stack.rPop 
          if)
       #);
     vPop: 
       (# 
       do (if notLLVM then
              ' vpop' -> out.putline; codes.vpop -> emit; 1 -> stack.vPop 
          if)
       #);
     CallPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do (if notLLVM then
              ' %' -> out.puttext; P[] -> out.puttext; ' ' -> out.put; op -> out.putint;
              codes.prim -> emit; op -> emit;
              (if op 
               // prim.attach then 
                  ' ' -> out.put;
                  'D' -> out.put;
                  'D' -> emit 
               // prim.fork // prim.cmpAndSwap // prim.thisCore then
                  (* perhaps more prims require C-mode, 
                   * but we are probably shure with the above ones
                   *)
                  true -> descs.onlyCinterpreter;
              if);
           else
              (if op 
               // prim.put then
                  ';; call void @putCh(i32 ' -> out.puttext; 
                  stack.vtop -> vReg -> out.puttext;
                  ')\n' ->out.puttext;
                  1 -> stack.vpop
              if)
          if);
          out.newline;
       #);
     op: 
       (# operator: @integer; 
          LLVMvOp:
            (# opT: ^text
            enter opT[]
            do '   ' -> out.puttext;
               newReg -> rN -> newVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' i32 ' -> out.puttext; stack.vtop - 1 -> vReg -> out.puttext;
               ', ' -> out.puttext; stack.vtop -> vReg -> out.putline
            #);
          rn: @integer
       enter operator
       do (if notLLVM then
              ' ' -> out.put; 
              (if operator
               // codes.plus then 'plus' -> out.putline; 
               // codes.minus then 'minus' -> out.putline
               // codes.mult then 'mult' -> out.putline; 
               // codes.rdiv then 'div' -> out.putline
               // codes.idiv then 'idiv' -> out.putline
               // codes.modd then 'modd' -> out.putline
               // codes.eq then 'eq' -> out.putline
               // codes.lt then 'lt' -> out.putline;
               // codes.le then 'le' -> out.putline;
               // codes.gt then 'gt' -> out.putline;
               // codes.ge then 'ge' -> out.putline
               // codes.ne then 'ne' -> out.putline
               // codes.andd then 'andd' -> out.putline
               // codes.orr then 'orr' -> out.putline
               // codes.xorr then 'xorr' -> out.putline
               // codes.req then 'req' -> out.putline
               // codes.rne then 'rne' -> out.putline
               // codes.fplus then 'fplus' -> out.putline
               // codes.fminus then 'fplus' -> out.putline
               // codes.fmult then 'fmult' -> out.putline
               // codes.fdiv then 'fdiv' -> out.putline
               else
                  operator -> out.putint; out.newline
              if);
              operator -> emit;
           else
               (if operator
               // codes.plus then
                  'add' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush;
                // codes.minus then 
                   'minus' -> LLVMvOp
               // codes.mult then 
                  'mul' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush
                // codes.rdiv then 
                   'div' -> out.putline
                // codes.idiv then 
                   'idiv' -> out.putline
                // codes.modd then 
                   'modd' -> out.putline
                // codes.eq then 
                   'eq' -> out.putline
               // codes.lt then 
                  'icmp lt' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush;
               // codes.le then 'le' -> out.putline;
               // codes.gt then
                  'icmp sgt' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush;              
               // codes.ge then 'ge' -> out.putline
               // codes.ne then 'ne' -> out.putline
               // codes.andd then 'andd' -> out.putline
               // codes.orr then 'orr' -> out.putline
               // codes.xorr then 'xorr' -> out.putline
               // codes.req then 'req' -> out.putline
               // codes.rne then 'rne' -> out.putline
               // codes.fplus then 'fplus' -> out.putline
               // codes.fminus then 'fplus' -> out.putline
               // codes.fmult then 'fmult' -> out.putline
               // codes.fdiv then 'fdiv' -> out.putline
               else
                  operator -> out.putint; out.newline
              if);
          if)
       #);
     i2f: (# do ' i2f' -> out.putline; codes.i2f -> emit #);
     f2i: (# do ' f2i' -> out.putline; codes.f2i -> emit #);
     req: (# do ' req' -> out.putline; codes.req -> emit #);
     rne: (# do ' rne' -> out.putline; codes.rne -> emit #);
     seq: (# do ' req' -> out.putline; codes.seq -> emit #);
     sne: (# do ' rne' -> out.putline; codes.sne -> emit #);    
     uminus: 
       (# 
       do ' u-' -> out.putline; 
          codes.uminus -> emit
       #);
     nott: (# do ' not' -> out.putline; codes.nott -> emit #);
     saveBETAworld: 
       (#
       do (if notLLVM then
              ' saveBETAworld' -> out.putline; 
              codes.saveBETAworld -> emit
           else
              '   ;; saveBETAworld\n' -> out.puttext
          if)
       #);
     saveStringOrigin:
       (#
       do (if notLLVM then
              ' saveStringOrigin' -> out.putline;
              codes.saveStringOrigin -> emit
           else
              '   ;; saveStringOrigin' -> out.putline;
          if)
       #);
     isMarked: [32] @boolean;
     initGCinfo: (#do (for i: isMarked.range repeat false-> isMarked[i] for)#);
     addGCinfo:
       (# add: 
            (# off: @integer 
            enter off 
            do (if off > isMarked.range then
                   isMarked.range -> isMarked.extend 
               if);
               (if not isMarked[off] then
                   off -> descs.current.GCinfo.add;
                   true -> isMarked[off]
               if)
            #);
       do inner
       #);
     endClass: 
       (# objSize,OSDvisibility: @integer;
          isIndexed: @boolean;
          V: @integer
       enter(objSize,isIndexed,OSDvisibility)
       do (if notLLVM then
              ' end OSDV:' -> out.puttext; OSDvisibility -> out.putint; 
              ' objSize:'->out.puttext; objSize -> out.putint;  
              ' isIndexed:'->out.puttext; 
              (if isIndexed then 1 -> V else 0 -> V if);
              V -> out.putint;  ' '-> out.put;
              stack.print -> out.puttext;
              out.newline;
              objSize -> descs.current.objSize;
              V -> descs.current.isIndexed; 
              OSDvisibility -> descs.current.OSDvisibility;     
              (if OSDvisibility > 0 then
                  (*'\n**** OSDvisibility: ' -> puttext; 
                   OSDvisibility -> putint; newline*)
              if);
              labs.saveInImage ;
           else
              '}' -> out.putline
          if)
       #);
     
     close:
       (#
       do VdtPatch.patch;         
          (if notLLVM then dump if)
       #);
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
               0 -> loc.new; 
               0 -> use.new
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (*'labs.def:labNo: ' -> puttext; labNo -> putint; 
               ' range: ' -> puttext; loc.range -> putint;*)
               (if labNo > loc.range then labNo - loc.range -> loc.extend if);
               (if labNo > use.range then labNo - use.range -> use.extend if); (*ugly*)
               (* ' labs.def:new:range: ' -> puttext; loc.range -> putint;
               newline;*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          saveInImage:
            (# 
            do (*'saveInImage: ' -> puttext; loc.range -> putint; newline;*)
               loc.range -> descs.current.labs.new;
               (for i: loc.range repeat
                   loc[i] -> descs.current.labs[i]
               for)
            #);            
          loc: [0] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [0] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
     dump: (# do descs.dump #);
     
     out: ^Stream;
     
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     emit8: (# enter descs.current.bc.emit8 #);
     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     prim: @ Primitives
  #);

