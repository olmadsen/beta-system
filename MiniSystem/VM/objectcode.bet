ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'Primitives';
INCLUDE 'betaVM';
INCLUDE 'LLVMlib';
---lib:attributes---

ObjectCode:
  (# newFeature,notLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs: @ boolean;
     init:<
       (# emitLLVM: @boolean
       enter(out[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs)
       do not emitLLVM -> notLLVM;
          vdtPatch.init;
          inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comment:
       (# T: ^text
       enter T[]
       do (if emitCom then
              (if notLLVM then 
                  ' -- ' -> out.puttext;
               else
                  '   ;; ' -> out.puttext;
              if);
              T[] -> out.putline
          if)          
       #);
     com: 
       (# II: (# enter Tx.putint do ' ' -> Tx.put #);
          TT: 
            (# S: ^text; Q: @text; i: @integer; inText: @boolean
            enter S[]
            do (if S[] <> none then
                   L:
                     S.scanAll
                     (#
                     do (if ch 
                         // '"' then
                            '"' -> Q.put;
                            not inText -> inText
                         // ascii.newline then
                            ' ' -> Q.put; '|' -> Q.put; ' ' -> Q.put 
                         else
                            ch -> Q.put
                        if);
                        (if (i + 1 -> i) > (170 - Tx.length) then 
                            ' ...' -> Q.puttext;     
                            (if inText then '"'-> Q.put if);
                            leave L 
                        if)
                     #)
                else
                   '-none-' -> Tx.puttext
               if);
               Q[] -> Tx.puttext
            #);
          TQ:
            (# S: ^Text
            enter S[]
            do '"' -> Tx.put;
               S[] -> TT;
               '"' -> Tx.put; ' ' -> Tx.put
            #);
          BB: 
            (# Bx: @boolean 
            enter Bx do (if Bx then 'true' -> TX.puttext else 'false' -> TX.puttext if)
            #);
          CC: (# ch: @char enter ch do ch -> Tx.put #);
          FF: (# F: @real enter F do F -> Tx.putreal #);
          nl: (# do emit; Tx.clear #);
          emit: 
            (# 
            do Tx.newline; 
               (if notLLVM then
                   ' -- ' -> out.puttext;
                else
                   ';; ' -> out.puttext
               if);
               Tx[] -> out.puttext; 
            #);
          print: (# do '***** ' -> puttext; Tx[] -> putline #);
          Tx: @Text
       do (if emitCom then inner; emit;if)
       #);  
     lcom:
       (# TT: 
            (# T: ^text 
            enter T[] 
            do (if T[] = none then
                   'none' -> S.append
                else
                   T.scanAll
                   (# 
                   do (if  ch = ascii.newline then 
                          '|' -> S.put 
                       else 
                          ch  -> S.put 
               if)#)if)
            #);
          II: (# v: @integer enter v do v -> S.putint #);
          S: ^text
       do (if true and not notLLVM then
              '   ;; ' -> S[];
              inner;
              S[] -> out.putline
          if)
       #);
     emitOp:
       (# op: ^text
       enter op[]
       do (if not notLLVM then
              '   ;; ' -> out.puttext
           else
              ' ' -> out.put; 
          if);
          op[] -> out.puttext; ' ' -> out.put
       #);
     newComponent: (* Not used!? *)
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do ' component ' -> out.puttext; N[] -> out.puttext; 
          ' NoOfDescs: ' -> out.puttext; noOfDescs -> out.putint; out.newline;
          noOfDescs + 3 -> descs.top -> descs.OD.new; (* noOfDesc + 2 since an extra
                                                       * desc is allocated for main 
                                                       * and EventProcessor
                                                       *)
       #);
     allocReg: @
       (# rn: @integer
       do rn + 1 -> rn
       exit rn
       #);
     emitVreg:
       (# rN: @integer; T: ^Text
       enter rN
       do '%V' -> T[]; rN -> T.putint
       exit T[]
       #);
     emitRreg:
       (# rN: @integer; T: ^Text
       enter rN
       do '%R' -> T[]; rN -> T.putint
       exit T[]
       #);
     vRegInStack:
       (# top: @integer; T: ^text
       enter top
       do '%V' -> T[]; 
          (if top > 0 then
              stack.VregNo[top] -> T.putint
           else
              0 -> T.putint
          if)
       exit T[]
       #);
     rReg:
       (# top: @integer; T: ^text
       enter top
       do 
          (if false and (stack.RregNo[top] = 0) then
              'this' -> T[]
           else
              '%R' -> T[];  
              (if top > 0 then 
                  stack.RregNo[top] -> T.putint 
               else
                  117 -> T.putint 
              if);
          if)
       exit T[]
       #);
     typedRreg:
       (# inx: @integer; T: ^text
       enter inx
       do stack.rType[inx].copy -> T[];
          ' ' -> T.put;
          inx -> rReg -> T.puttext;
       exit T[]
       #);
     stack: @
       (# rTop,vTop,rTopMax,vTopMax: @integer;
          VregNo: [10] @ integer;
          RregNo: [10] @ integer;
          Rtype: [10] ^text;
          Vtype: [10] @ integer;
          vVal: [10] ^Value; 
          init: 
            (#
            do 0 -> rTop -> vTop -> rTopMax -> vTopMax;
               0 -> allocReg.rN;
            #);
          value:
            (# V: @integer
            enter V
            exit this(value)[]
            #);
          vpush:
            (# rN: @integer
            enter rN
            do (*';; vpush: ' -> out.putline;*)
               (if (vTop + 1 -> vTop) > vTopMax then vTop -> vTopMax if);
               (if vTop > 0  then
                   (if vTop > vRegNo.range then 
                       vRegNo.range -> vRegNo.extend;
                       vType.range -> vType.extend;
                       vVal.range -> vVal.extend
                   if);
                   rN -> VregNo[vTop]; 0 -> vType[vTop];
                else
                   (if not notLLVM then
                       ';; vpush:vtop: ' -> out.puttext; vTop ->  out.putint;
                       out.newline
               if)if);
               'vpush' -> dump
            #);
          vpop: (# n: @integer enter n do vTop - n -> vTop; 'vpop' -> dump #);
          rpush:
            (# rN: @integer
            enter rN
            do (if (rTop + 1 -> rTop) > rTopMax then rTop -> rTopMax if);
               (if rTop > 0 then
                   (if rTop > rRegNo.range then 
                       rRegNo.range -> rRegNo.extend;
                       rType.range -> rType.extend
                   if);
                   rN -> RregNo[rTop];
                   inner
                else
                   (if not notLLVM then
                       ';; rpush:rtop: ' -> out.puttext; 
                       rTop ->  out.putint; out.newline
               if)if);
               'rpush' -> dump
            #);
          rpushT:
            (# rN: @integer; type: ^text
            enter(rN,type[])
            do rN  -> rpush(#do type[] -> Rtype[rtop][] #)
            #);
          rpop: (# n: @integer enter n do rTop - n -> rTop; 'rpop' -> dump #);
          print: 
            (# T: @text
            do 'vTop(' -> T.puttext; vTop -> T.putint;
               ',' -> T.puttext; vTopMax -> T.putint;
               ')=[' -> T.puttext;
               (for i: vtop repeat 
                    VregNo[i] -> T.putint;  
                    '/' -> T.put;  
                    vType[i] -> T.putint;
                    (if i < vtop then ',' -> T.put if)
               for);
               ']' -> T.put;
               ' rTop(' -> T.puttext; rTop -> T.putint;
               ',' -> T.puttext; rTopMax -> T.putint;
               ')=['->T.puttext;
               (for i: rtop repeat 
                    RregNo[i] -> T.putint;  ':' -> T.put;
                    rType[i][] -> T.puttext; 
                    (if i < rtop then ',' -> T.put if)
               for);
               ']' -> T.put;
            exit T[]
            #);
          put: (#do '   ;; ' -> out.puttext; print -> out.putline #);
          dump:
            (# T: ^text
            enter T[]
            do com(#do 'stack:' -> TT; T[] -> TT; ': vTop: ' -> TT; vTop -> II;
                     ' vTopMax: ' -> TT; vTopMax -> II;
                     '  rTop: ' -> TT; rTop -> II; 
                     ' rTopMax: ' -> TT; rTopMax -> II; 
                     ' V:'->TT; (if vTop > 0 then VregNo[vTop] -> II if);
                     ' R:'->TT; (if rTop > 0 then RregNo[rTop] -> II if);
                  #)
            #);
          dumpVRN:
            (#
            do 'vregNo:vTop: ' -> puttext;  vTop ->  out.putint; ' :: ' -> puttext;
               (for i: vTop repeat
                    VregNo[i] ->  out.putint; ' ' -> out.put
               for);
               out.newline
            #)
       #);
     LLVMstructs: @ Text;
     typeInfo: @
       (# dsc: [100] ^Info; top: @integer;
          arrays: [100] ^text;
          noOfArrays: @integer;
          current: ^Info;
          Info:
            (# sig,orgSig: ^text;
               attQs: [10] ^text; attQtop: @integer;
               vdtType,vdtRet: ^Text;
               printStruct:
                 (#
                 do (for i: attQtop repeat
                         (if i > 1 then ',' -> LLVMstructs.put if);
                         (if attQS[i][] = none then
                             (* only for BETAworld origin = null *)
                             'i32*' -> LLVMstructs.puttext;
                          else
                             attQS[i][] -> LLVMstructs.puttext;
                             (if newFeature then
                                (* ',' -> put;
                                 attQS[i][] ->  puttext*)
                             if)
                         if)                         
                    for)
                 #);
               print:
                 (#
                 do sig[] -> puttext; ' ::' -> puttext;
                    (for i: attQtop repeat 
                         ' i:' -> puttext; i -> putint; 
                         ' '-> put; attQS[i][] -> puttext; 
                    for);
                    newline
                 #) 
            enter(sig[],orgSig[])
            do (if false then
                   '**** info: ' -> puttext; sig[] -> puttext;
                   ' ' -> put; orgSig[] -> putline;
               if)
            exit this(info)[]
            #);
          getID:
            (# T: ^text; inx,dn,V: @integer
            enter T[]
            do L:
                 T.scanAll
               (# i: @integer
               do i + 1 -> i;
                  (if ch = '$' then i -> inx; (*leave L*) if);
               #);
               (if false then 
                   T[] -> putline; 
                   (if inx >0 then
                       inx  -> T.setPos; T.getInt -> V;
                       T[] -> puttext; ' ' -> put; inx -> putint; 
                       ' ' -> put; V -> putint; newline
               if)if)
            exit inx
            #);
          patch:
            (# miN,T: ^text; inxA,inxB: @integer; C: ^Info;
               trace: (# exit true #);
            enter miN[]
            do (if trace then
                   'patch: ' -> puttext; miN[] -> puttext; ' ' -> put;
               if);
               miN[] -> getID -> inxA; 
               (if trace then
                   inxA -> putint; newline;
               if);
               (for i: top repeat
                    (if (dsc[i][] -> C[]) <> none then
                        (for j: C.attQtop repeat
                             (if (C.attQS[j][] -> T[]) <> none then
                                 T[] -> getID -> inxB;
                                 (if inxA = inxB then
                                     (if ((1,inxA) -> miN.sub)
                                           ->
                                         ((1,inxB) -> T.sub).equal then
                                         (If trace then
                                             'match: ' -> puttext;
                                             miN[] -> puttext;
                                             ' ' -> put;
                                             T[] -> putline;
                                         if);
                                         (if trace then
                                             '*** patch:in: ' -> puttext;
                                             C.sig[] -> puttext;
                                             ' old: ' -> puttext;
                                             C.attQS[j][] -> puttext;
                                             ' by: ' -> puttext;
                                             miN[] -> putline;
                                         if);
                                         (if (T.length -> T.inxGet) = '*' then
                                             '*' -> (miN.copy->miN[]).put
                                         if);
                                         miN[] -> C.attQS[j][];
                                         leave patch
                             if)if)if)
                        for)
                    if)
               for)
            #);
          exists: BooleanValue
            (# dn: @integer
            enter dn
            do (if true
                // dn = 0 then
                   '!!!!! TYpeInfo:exists: dn=0' ->  putline
                // dn <= dsc.range then
                   dsc[dn][] <> none -> value
               if)
            #);
          addDsc:
            (# descNo: @integer; sig,orgSig: ^text;
            enter(descNo,sig[],orgSig[])
            do (if descNo > dsc.range then descNo -> dsc.extend if);
               (sig[],orgSig[]) -> Info -> dsc[descNo][] -> current[];
               (if descNo > top then descNo -> top if);
               (*' ' -> put; top -> putint; newline;*)
               (*sig[] -> patch;*)
               descno -> theDn
            #);
          theDn: @integer;
          addRoff:
            (# off: @integer; sig: ^text
            enter(off,sig[])
            do (if (off + 1) > current.attQtop then 
                   current.attQs.range -> current.attQs.extend 
               if);
               sig[] -> current.attQs[off + 1][];
               (if (off + 1) > current.attQtop then 
                   off + 1-> current.attQtop 
               if)
            #);
          lookup:
            (# sig: ^text; inx,off,dn: @integer; attSig: ^text;
               trace: (#exit false #);
               noMatch:
                 (# msg,T: ^text
                 enter msg[]
                 do '\n!!!! lookup:'-> T[]; msg[] -> T.append;
                    ' ' -> T.put; sig[] -> T.puttext;
                    ' off:' -> T.puttext; off -> T.putint;  ' ' -> T.put;
                    inner;
                    T[] -> putline;
                    lcom(#do T[] -> TT #);
                 #);
            enter(sig[],off)
            do (*print;*)
               (if trace then
                   'lookup: ' -> puttext; sig[] -> puttext; 
                   ' off:' -> puttext; off -> putint; ' ' -> put;
               if);
               sig.scanAll
               (# i: @integer
               do i + 1 ->i; 
                  (if ch = '$' then i -> inx if);
               #);
               (if inx > 0 then
                   (if trace then 'match: ' -> puttext;  if);
                   inx ->sig.setPos;
                   sig.getint -> dn; 
                   (if (dn <= 0) or ( dn > dsc.range) then
                       'index out of range' -> noMatch(#do dn -> T.putint#);
                       'index$OutOfRange' -> attSig[];
                       leave lookUp
                   if);
                   (if (off <= 0) or ( off > dsc[dn].attQs.range) then
                       'No off defined (attQS) for ' 
                         -> noMatch
                       (#
                       do ' descNo: '-> T.puttext; dn -> T.putint; 
                          ' attQs.range: ' -> T.puttext; 
                          dsc[dn].attQs.range -> T.putint;
                       #);
                       (*'off$notDefined' -> attSig[];*)
                       leave lookUp
                   if);
                   (if trace then dn -> putint; ' ' -> put; if);
                   (*dsc[dn].print;*)
                   (if dsc[dn][] <> none then
                       (*dsc[dn].sig[] -> puttext; ' ' -> put;*)
                       dsc[dn].attQs[off + 1][] -> attSig[];
                    else
                       'none' -> attSig[];
                        (*print;*)
                       '\n!!!! lookup: none! ' -> putline;
                       sig[] -> puttext; ' off:' -> puttext;
                       off -> putint; newline
                   if);
                   (*attSig[] -> putline*)
                else
                   (*print;*)
                   'no-match' -> attSig[];
                   ' no match! ' ->noMatch
               if);
               (if attSig[] = none then
                   (*print;*)
                   '\n!!!! lookup: noneX! ' -> putline;
                   sig[] -> puttext; ' off:' -> puttext;
                   off -> putint; 
                   ' dn: ' -> puttext; dn -> putint; newline;
                   lcom(#do '!!!! lookup: noneX! ' -> TT;
                          sig[] -> TT; ' off:' -> TT;
                          off -> II; 
                          ' dn: ' -> TT; dn -> II
                       #);
                   '%noneX' -> attSig[] 
               if);
            exit attSig[]
            #);
          get:
            (# descNo: @integer; TI: ^Info; T: ^text
            enter descNo
            do (if (descNo < 1) 
                   or (top < descNo)
                   or ((dsc[descNo][] ->TI[]) = none) then
                   ('NotFound:'-> T[],descNo->T.putint) -> info -> TI[]
               if)
            exit TI[]
            #);
          newArray:
            (# T,type: ^text
            do (if (noOfArrays + 1 -> noOfArrays) > arrays.range then 
                   arrays.range -> arrays.extend
               if);
               '%array$' -> T[]; noOfArrays -> T.putint;
               T.copy -> type[];
               (*'*' -> type.put;*)
               ' = type {i8*, i32, [0 x i32]}\n' -> T.append;
               T[] -> arrays[noOfArrays][];
            exit type[]
            #);
               
          printStructs:
            (# D: ^Info
            do ''-> LLVMstructs;
               (for i: top repeat
                    (if (dsc[i][] -> D[]) <> none then
                        (if false then 
                            '*** printStructs: ' -> puttext;
                            D.sig[] -> puttext; ' = ' -> puttext;
                            newline;
                        if);
                        D.sig[] -> LLVMstructs.puttext;
                        ' = type {' -> LLVMstructs.puttext;
                        D.printStruct;
                        '}\n' -> LLVMstructs.puttext;
                        (if dsc[i].vdtType[] = none then
                            '*** printStructs: none: ' -> puttext;
                            i -> putint; newline
                        if);
                        dsc[i].vdtType[] -> LLVMstructs.puttext;
                        dsc[i].vdtRet[] -> LLVMstructs.putline;
                    if)
               for);
               (for i: noOfArrays repeat arrays[i][] -> LLVMstructs.putline for);
               literals[] -> LLVMstructs.putline
            #);
          print:
            (#
            do 'typeInfo: ' -> puttext; top -> putint; newline;
               (for i: top repeat
                    (if dsc[i][] <> none then
                        'descNo: ' -> puttext; i -> putint; ': ' -> puttext;
                        dsc[i].print
               if)for);
               literals[] -> puttext;
            #)
       #);
     literals: @Text;
     
     vdtType:
       (# cN,T: ^text
       enter cN[]
       do '%vdt_type$' -> T[];
          cN[] -> T.append
       exit T[]
       #);
     funcPtrType:
       (# cN,T,S: ^text; dn: @integer
       enter(cN[],dn)
       do cN.copy -> T[];
          '(' -> T.put; 
          cN[]  -> T.puttext; 
          (if isValueObject then
              ', i32' -> T.puttext
           else
              (if newFeature then
                  (if ((dn -> typeInfo.get).orgSig[] -> S[]) <> none then
                      ', ' ->  T.puttext;
                      S[]  ->  T.puttext
          if)if)if);
          ')*' -> T.puttext
       exit T[]
       #);
     leag:
       (# off,rN: @integer; rnType: ^text
       enter off
       do '   ' -> out.puttext;
          allocReg -> rN -> emitRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext; 
          stack.rType[stack.rTop][] 
            -> deRef ->  rnType[] -> out.puttext;  ',' -> out.put;
          rnType[] -> out.puttext; ' *' -> out.puttext;
          stack.rTop -> rReg -> out.puttext; 
          ', i32 0, i32 ' -> out.puttext; 
          off -> out.putint; 
          '\n   ' -> out.puttext;
       exit rN
       #);
     leaReg:
       (# reg,off,rN: @integer; rnType: ^text
       enter(reg,rnType[],off)
       do '   ' -> out.puttext;
          allocReg -> rN -> emitRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext; 
          rnType[] -> out.puttext;  ',' -> out.put;
          rnType[] -> out.puttext; '* ' -> out.puttext;
          reg -> emitRreg -> out.puttext; 
          ', i32 0, i32 ' -> out.puttext; 
          off -> out.putint; 
          '\n   ' -> out.puttext;
       exit rN
       #);
     iLoad:
       (# rN,rNx: @integer
       enter rN
       do allocReg -> rNx -> emitVreg -> out.puttext;
          ' = load i32, i32* ' -> out.puttext;
          rN -> emitRreg -> out.puttext;
          out.newline
       exit rNx
       #);
     allocObj:
       (# objId: ^text; 
          descNo,size,rNx,rNy,rNz: @integer
       enter(objId[],descNo,size)
       do '   ;; alloc ' -> out.puttext; objId[] -> out.puttext;
          '\n   ' -> out.puttext;
          allocReg -> rNx -> emitRreg -> out.puttext; 
          ' = ' -> out.puttext;
          'tail call i8* @malloc(i64 ' -> out.puttext;
          size * 4 -> out.putint;
          ')\n' -> out.puttext;
          (rNx,'i8*','*'->(objId.copy).put) -> bitCast -> rNy;
          inner allocObj
       exit rNy
       #);
     allocRtobj: allocObj(##);
     allocQbetaObj: allocObj
       (# T,orgT: ^text
       do '   ;; store VDT in object\n   ' -> out.puttext;
          allocReg -> rNz -> emitRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext;  
          objId[] -> out.puttext; 
          ', ' -> out.puttext; objId[] -> out.puttext;
          '* ' -> out.puttext;
          rNy -> emitRreg -> out.puttext;               
          ', i32 0, i32 0' -> out.puttext;
          out.newline;
          (descNo -> typeInfo.get).orgSig[] -> orgT[];
          '   store ' -> out.puttext;
          (2,objId.length) -> objId.sub -> T[] -> vdtType -> out.puttext;
          '* @vdt_data$' -> out.puttext; T[] -> out.puttext;
          ', ' -> out.puttext; 
          T[] -> vdtType -> out.puttext;
          '** ' -> out.puttext;
          rNz -> emitRreg -> out.puttext;
          '\n' -> out.puttext;
       #);
     mkTextConst:
       (# T,id: ^text; range: @integer
       enter T[]
       do textId + 1 -> textId;
          '@Txt$' -> id[]; textId -> id.putint;
          id[] -> literals.puttext;
          ' = private unnamed_addr constant [' -> literals.puttext;
          T.length + 2 -> range -> literals.putint;
          ' x i8] c"' -> literals.puttext; T[] -> literals.puttext;
          '\\0A\\00"\n' -> literals.puttext
       exit(Id[],range)
       #);
     textId: @integer;
     stringType:
       (# stringDescNo: @integer; T: ^text
       enter stringDescNo
       do '%String$' -> T[]; stringDescNo -> T.putint;  
       exit T[]
       #);
     allocString:
       (# T,id,sType: ^text; stringDescNo,rN,rN1,range: @integer
       enter(T[],stringDescNo)
       do 
          stringDescNo -> stringType -> sType[];
          
          
          T[] -> mkTextConst -> (id[],range);
          allocReg -> rN -> emitRreg -> out.puttext;
          ' = getelementptr [' -> out.puttext;
          range -> out.putint;
          ' x i8], [' -> out.puttext;
          range -> out.putint;
          'x i8]* ' -> out.puttext;
          id[] -> out.puttext; ', i64 0, i64 0\n' -> out.puttext;
          
          allocReg -> rN1 -> emitRreg -> out.puttext;
          ' = call i32* @allocString(i8* ' -> out.puttext;
          rN -> emitRreg -> out.puttext; ', i32 ' -> out.puttext;
          range - 2 -> out.putint;
          ')\n' -> out.puttext;
          
          (rn1,'i32*','*'->(sType.copy).put) -> bitCast -> rN;
          (rN,'*' ->sType.put) -> stack.rPushT
       #);
     bitcast:
       (# rNs,rNd: @integer; srcT,dstT: ^text
       enter(rNs,srcT[],dstT[])
       do '   ' -> out.puttext;
          allocReg -> rNd -> emitRreg -> out.puttext; 
          ' = bitcast ' -> out.puttext; 
          srcT[] -> out.puttext; ' ' -> out.put;
          rNs -> emitRreg->out.puttext;
          ' to ' -> out.puttext; 
          dstT[] -> out.puttext; '\n' -> out.puttext; 
       exit rNd
       #);
     notImpl:
       (# op: @integer;
          Tx: ^Text
       enter op
       do 'not implemented: ' -> Tx[];
          inner notImpl;
          lcom(#do Tx[] -> Tt #);
          'call void @notImpl(i32 ' -> out.puttext;
          op -> out.putint;
          ')\n' -> out.putline
       #);
     dumpObj:
       (# rN,rNx: @integer; type: ^text
       enter(rN,type[])
       do allocReg -> rNx -> emitRreg -> out.puttext;
          ' = ptrtoint ' -> out.puttext; type[] -> out.puttext;
          '* ' -> out.puttext; rN -> emitRreg -> out.puttext;
          ' to i32\n' -> out.puttext;
          'call i32 @dumpHex(i32 ' -> out.puttext;
          rNx -> emitRreg -> out.puttext; 
          ',i32 1)\n' -> out.puttext;
       #);
     thisClassDescNo: @integer; 
     thisClassId,        (* className$descNo *)
     thisClassN,         (* %thisClassId     *)
     PthisClassN: ^Text; (* thisClassN*      *)
     isValueObject: @boolean;


     doFilter: (* should be eliminated *)
       (# N,T: ^text
       enter N[]
       do N[] -> filter -> T[]
       exit T[]          
       #);
     classDef:
       (# add:
            (# off: @integer
            enter off
            do (if not first then ',' -> LLVMstructs.put if);
               false -> first;
               (*off -> putint; ':'->put; *)
               INNER;
            #);
          addR: add
            (# OGid: ^text
            enter OGid[]
            do OGid[] -> filter -> OGid[];
               '%' 
                 -> OGid.prepend 
                 -> OGid[]-> LLVMstructs.puttext; 
               '*' -> LLVMstructs.put;
               (off,'*'->(OGid.copy).put) -> typeInfo.addRoff
            #);
          addV: add
            (# 
            do 'i32'-> LLVMstructs.puttext; 
               (off,'i32') -> typeInfo.addRoff
            #);
          addA: add
            (# T:^text
            do typeInfo.newArray -> T[]; '*' -> T.put; 
               (*T[] -> putline;*)
               (off,T[]) -> typeInfo.addRoff
            #);
          first,isValueObj: @boolean;
          N,orgOfN: ^text; descNo,orgDescNo: @integer; T: ^text;          
       enter(N[],descNo,isValueObj,orgOfN[],orgDescNo)
       do (if not notLLVM then
              (if false then
                  '**** classDef: ' -> puttext; N[] -> puttext;
                  ' ' -> put; descNo  -> putint; 
                  ' ' -> put; orgOfN[] -> putline
              if);
              (if descNo -> typeInfo.exists then
                  leave classDef
              if);
              isValueObj -> isValueObject;
              N[] -> filter -> N[];
              
              '%' -> T[]; N[] -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;
              (if orgOfN[] = none then
                  (descNo,T[],none) -> typeInfo.addDsc;
               else
                  (descNo,T[],(orgOfN[],orgDescNo) -> mkTypePtr) 
                    -> typeInfo.addDsc;
              if);
              
              '%' -> T[]; N[] -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;
              
              (* *** LLVMstructs as printed here are apparently not used?
               * T[] -> LLVMstructs.puttext; 
               * ' = type {' -> LLVMstructs.puttext;
               *)
              
              true -> first;  
              'vdt_type$' -> T[];
              N[] -> filter -> T.puttext; 
              '$' -> T.put; descNo -> T.putint;
              ' ' -> T.put;
              (0,T[]) -> AddR; 
              inner classDef;
              
              (* '}'-> LLVMstructs.puttext; LLVMstructs.newline;
               * ';;%vdt_type ' -> LLVMstructs.putline;
               *)
          if)
       #);
     class:
       (# dumpClass:
            (#
            do '\n\n*** Fatal error in objectCode: *** Class: ' 
                 -> puttext; 
               N[] -> puttext; ' descNo = '->puttext; descNo -> putint;
            #);
          N,orgId: ^text; 
          descNo,topDescNo,originOff,originDescNo: @integer;
          procE: @boolean; (* mark start as proc-entry and enter-entry *)
          isValueObj: @boolean;
          first: @boolean;
          T,S: ^Text
       enter(N[],descNo,procE,topDescNo,originOff,orgId[],originDescNo,isValueObj)
       do (if descNo = 0 then
              dumpClass;
              ' is ZERO!' -> putline
          if);
          stack.init;
          (if notLLVM then
              '\nclass ' -> out.puttext; N[] -> out.puttext; ' ' ->out.put; 
              descNo -> out.putint; ' ' -> out.put;
              originOff -> out.putint; ' ' -> out.put;
              originDescNo -> out.putint; 
              (if isValueObj then
                  ' isValueObj' -> out.puttext;
              if);
              out.newline; 
              (N[],descNo,originOff,originDescNo,isValueObj,out[]) 
                -> descs.setCurrent;
              (if descs.OD[topDescNo][]= none then 
                  dumpClass;
                  ' descs.OD[topDescNo='->puttext; 
                  topDescNo -> putint;
                  '][]= none' -> putline
               else
                  (topDescNo,descs.OD[topDescNo].bc[]) 
                    -> descs.current.setSuperBC;
              if);
              descs.markAllocE;
              (if procE then 
                  'procE:' -> puttext; N[] -> putline;
                  descs.markProcE 
              if);
              initGCinfo;
              labs.init;
           else
              (*typeInfo.print;*)
              (N[],descNo,originOff,originDescNo,isValueObj,out[])
                -> descs.setCurrent;
              (topDescNo,descs.OD[topDescNo].bc[]) 
                -> descs.current.setSuperBC;

              N[] -> filter -> N[];
              
              descNo -> thisClassDescNo;
              N.copy -> thisClassId[]; 
              '$' -> thisClassId.put; descNo -> thisClassId.putint;
              '%' -> thisClassN[]; 
              thisClassId[] -> thisClassN.puttext; 
              '*' -> (thisClassN.copy -> PthisClassN[]).put;
              
              (if traceLLVMcalls then
                  '\n@S.' -> out.puttext; N[] -> out.puttext; 
                  '$' -> out.put; descNo -> out.putint;               
                  ' = private unnamed_addr constant [' -> out.puttext;
                  thisClassN.length + 2 -> out.putint;
                  ' x i8] c"' -> out.puttext; thisClassN[] -> out.puttext;
                  '\\0A\\00"\n' -> out.puttext;
              if);

              isValueObj -> isValueObject;
              (if true 
               // 'main' -> N.equal then
                  '\ndefine void @main(i8* %args){\n' -> out.puttext;
               // isValueObj and false then 
                  true -> isValueObject;
                  '\ndefine %Object' -> out.puttext; 
                  '* @' -> out.puttext; N[] -> out.puttext;      
                  '$' -> out.put; descNo -> out.putint;
                  '(%Object* %R0, i32 %off' -> out.puttext;
                  '){\n' -> out.puttext;
               else
                  '\ndefine ' -> out.puttext; thisClassN[] -> out.puttext; 
                  '* @' -> out.puttext; N[] -> out.puttext;      
                  '$' -> out.put; descNo -> out.putint;
                  '(' -> out.put; 
                  thisClassN[] -> out.puttext;
                  (*'%' -> (N.copy).prepend -> out.puttext;*)
                  ' *%R0' -> out.puttext;
                  (if isValueObject then
                      ', i32 %off' -> out.puttext
                   else
                      (if newFeature then
                          allocReg; (* allocate R1 for origin *)
                          (if ((descNo -> typeInfo.get).orgSig[] -> S[]) <> none
                              then
                              ', ' -> out.puttext;
                              S[] -> out.puttext;
                              ' %R1' -> out.puttext;
                          if)
                      if)
                  if);
                  '){\n' -> out.puttext;
              if);
              (if traceLLVMcalls then
                  '   %S = getelementptr [' -> out.puttext;
                  thisClassN.length + 2 -> out.putint;
                  ' x i8], [' -> out.puttext;
                  thisClassN.length + 2 -> out.putint; 
                  ' x i8]* @S.' -> out.puttext; N[] -> out.puttext; 
                  '$' -> out.put; descNo -> out.putint;
                  ', i64 0, i64 0\n' -> out.puttext;
                  
                  '   call i32 @puts(i8* %S)\n' -> out.puttext;
              if);
              (if dumpLLVMobjs and not ('main' -> N.equal) then
                  (0,thisClassN[]) -> dumpObj;
              if);              
              '   %V0 = add i32 0, 0' -> out.putline; (* just a dummy *)
          if)
       #);
     super: 
       (# N: ^text; superDescNo: @integer
       enter(N[],superDescNo)
       do (if notLLVM then
              ' -- super ' -> out.puttext; N[] -> out.putline;
              descs.OD[superDescNo][] -> descs.current.superObjDesc[]
          if)
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do 'ENTER:' -> out.putline
       #);
     setThisStack:
       (#
       do (if notLLVM then
              ' setThisStack ' -> out.putline;
              codes.setThisStack -> emit
          if)
       #);
     rpopThisObj:
       (#
       do (if notLLVM then
              ' rpopThisObj ' -> out.putline;
              codes.rpopThisObj -> emit
           else
          if)
       #);       
     actions:
       (# hasSuper,genDoEvent: @boolean
       enter(hasSuper,genDoEvent)
       do (if notLLVM then
              'DO:'->out.putline;
              descs.markDoE;
              (if genDoEvent then doEventQ if);
          if)
       #);
     mvStack:
       (#
       do (if notLLVM then ' mvStack '->out.putline; codes.mvstack -> emit if)
       #);
     markExitE: (# do descs.markExitE #);
     doExit:
       (#
       do 'EXIT:' -> out.putline; 
          ' doExit ' -> out.putline; 
          codes.doExit -> emit
       #);
     rtn: 
       (# LMR: @char
       enter LMR 
       do (if notLLVM then
              ' rtn(' -> out.puttext; LMR->out.put; ')' -> out.put; out.newline;
              codes.rtn -> emit ; LMR -> emit;
           else
              (if true
               // 'main' -> ((2,5) -> thisClassN.sub).equal then
                  '   ret void\n' -> out.putline
               // false and isValueObject then
                  '   ret %Object* %R0\n' -> out.putline;
                  (*false -> isValueObject*)
               else
                  (*(0,thisClassN[]) -> dumpObj;*)
                  '   ret ' -> out.puttext; 
                  thisClassN[] -> out.puttext; ' *%R0\n' -> out.puttext;
          if)if);
          1 -> stack.rpop;
       #);
     rtnV: (*rtnValue*)
       (#
       do (If notLLVM then
              ' rtnV\n' -> out.puttext;  codes.rtnV -> emit 
           else
          if)
       #);
     rtnC: (# do ' rtnC' -> out.putline; codes.rtnC -> emit #);
     rtnExit: (# do ' rtnExit' -> out.putline; codes.rtnExit -> emit #);
     rtnInner: 
       (# entry: @char (* 'A': rtnInner in alloc-part *)
       enter entry
       do 'rtnInner ' -> emitOp; entry -> out.put; out.newline;
          (if notLLVM then
              codes.rtnInner -> emit
           else
              (if entry <> 'A' then
                  '   ret ' -> out.puttext; thisClassN[] -> out.puttext; 
                  ' *%R0\n' -> out.puttext;
          if)if)
       #);
     rtnEvent: 
       (# hasExit: @integer 
       enter hasExit 
       do ' rtnEvent ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEvent -> emit;
          hasExit -> emit
       #);
     allocEventQ:
       (# asObj: @boolean
       enter asObj
       do (If notLLVM then
              ' allocEventQ\n' -> out.puttext;
              codes.allocEventQ -> emit;
              (if asObj then 1 -> emit else 0 -> emit if)
          if);
       #);
     rtnEventQ: 
       (# hasExit: @integer 
       enter hasExit 
       do (if notLLVM then
              ' rtnEventQ ' -> out.puttext; hasExit -> out.putint; out.newline;
              codes.rtnEventQ -> emit;
              hasExit -> emit
          if)
       #);
     doEventQ:
       (#
       do (if notLLVM then
              ' doEventQ\n' -> out.puttext;
              codes.doEventQ -> emit
          if);
       #);
     stop: 
       (# 
       do (if notLLVM then
              ' stop' -> out.putline; codes.stop -> emit
           else
              '   ;; stop\n' -> out.puttext
          if)
       #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          'D' -> rtn          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do (if notLLVM then
              ' L' -> out.puttext; lab -> out.putint; ':' ->out.put; out.newline;
              lab -> labs.def;
           else
              '   br label %L' -> out.puttext; lab ->  out.putint;  out.newline;
              'L'-> out.puttext; lab ->  out.putint; ':' -> out.put; out.newline
          if);
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do ' jmpIf_GT L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       do (if notLLVM then
              ' jmp L' -> out.puttext; lab -> out.putint; out.newline;
              codes.jmp -> emit;
              0 -> emit2;
              lab -> labs.mark;
           else
              '   br label %L' -> out.puttext; lab ->  out.putint; out.newline 
          if);          
       #);
     jmpFalse:
       (# Tlab,Flab,vN: @integer 
       enter(Tlab,Flab) 
       do 'jmpFalse ' -> emitOp; 'L'->out.put; Flab -> out.putint; out.newline;
          (if notLLVM then              
              codes.jmpFalse -> emit;
              0 -> emit2;
              Flab -> labs.mark;
           else
              stack.put;
              (if stack.vTop = 0 then
                  '   ;; jmpFalse: stack.vTop = 0' -> out.putline;
                  '\n!!!! jmpFalse: stack.vTop = 0' -> putline;
                  leave jmpFalse 
              if);
              (if stack.Vtype[stack.vTop] = 1 then
                  stack.vRegNo[stack.vTop] -> Vn
               else
                  allocReg -> Vn -> emitVreg -> out.puttext;
                  ' = trunc  i32 ' -> out.puttext;
                  stack.vtop -> vRegInStack -> out.puttext; 
                  ' to i1\n' -> out.puttext;
              if);
              
              '   br i1 ' -> out.puttext; 
              Vn -> emitVreg -> out.puttext;
              ', label %L' -> out.puttext; Tlab ->  out.putint;
              ', label %L' -> out.puttext; Flab ->  out.putint; 
              out.newline 
          if);
          1-> stack.vpop
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do 'jmpTrue L' -> emitOp; lab -> out.putint; out.newline;
          (if notLLVM then
              codes.jmpTrue -> emit;
              0 -> emit2;
              lab -> labs.mark
           else
          if)
       #);
     break:
       (# on,lab,descInx,pn,rN,rNx,rNy: @integer; T:^text
       enter(on,lab,descInx,pn)
       do 'break ' -> emitOp; on -> out.putint; ' ' -> out.put; 
          lab -> out.putint; ' ' -> out.put; descInx -> out.putint;
          ' ' -> out.put; pn -> out.putint;
          out.newline;
          (if notLLVM then
              codes.break -> emit;
              on -> emit; 
              (if lab = 0 then
                  '\n***** Fatal error break: lsc=0' -> putline
              if);
              lab -> emit2;
              descInx -> emit2;
              pn -> emit
           else
              stack.put;
              (if true then
                  '%vdt_type$' -> T[];
                  (2,stack.rType[stack.rTop].length)
                    ->stack.rType[stack.rTop].sub -> T.append;
                  '*' -> T.put;
                  0 -> leag -> rNx;
                  (rNx, T[], 'i32*') -> bitCast -> rNy;
                  'store i32 ' -> out.puttext;
                  lab -> out.putint;
                  ', i32* ' -> out.puttext;
                  rNy -> emitRreg -> out.putline;
                  
                  (stack.rRegNo[stack.rTop]
                  , stack.rType[stack.rTop][]
                  ,PthisClassN[])
                    -> bitCast -> rN;
                  '   ret ' -> out.puttext; 
                  PthisClassN[] -> out.puttext;
                  ' '  -> out.put;
                  rN -> emitRreg -> out.putline
              if)
          if)
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do ' alloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.alloc -> emit; descNo -> emit2;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     tstOriginIsNone:
       (#
       do (if notLLVM then
              ' tstOriginIsNone ' -> out.putline;
              codes.tstOriginNone -> emit;
           else
              
          if)
       #);
     invoke: 
       (# N,Ns,Nx,rtnType: ^text; 
          descNo,size,staticOff,superDescNo,io: @integer; 
          asObj: @boolean; 
          calleeReg,rN,rNx,rNy,rNz,rNq,vN,vNx,tLab,fLab,rLab,lLab,rSn
          ,normalRtnLab,breakLab,contBreakLab,selectBreakLab: @integer;
          superN,T,Tx,calleeType: ^text;
          topSuperId:<
            (# superId: ^text; superDescNo: @integer
            do inner
            exit(superId[],superDescNo)
            #);
       enter(N[],descNo,size,staticOff,asObj) 
       do 'invoke' -> emitOp; N[] -> out.puttext; 
          ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
          staticOff -> out.putint; ' ' -> out.put;
          (if asObj then 1 -> iO else 0 -> iO if);
          io -> out.putint;
          out.newline;
          (if notLLVM then              
              codes.invoke -> emit; descNo -> emit2; staticOff -> emit2;
              iO -> emit;
           else
              (* the origin and possible arguments are on the stack
               * As for now we dont know the no of arguments
               * We thus make an rpop for the origin
               * callee returns a value - here we dont know the type so we
               * assume that a ref to callee is returned
               *)
              N[] -> filter -> N[];

              stack.put;
              
              '$' -> N.put; descNo -> N.putint;
              N.copy -> Ns[];'%' -> Ns.prepend;
              Ns.copy -> calleeType[];
              
              (Ns[],descNo,size + 1) -> allocQbetaObj -> calleeReg -> rN;

              (calleeReg,calleeType[]) -> stack.rpushT;

              inner invoke;

              topSuperId -> (superN[],superDescNo);
              (if superN[] = none then
                  '----- topSuperId is none' -> putline;
                  N[] -> putline;
              if);              
              superN[] -> filter -> superN[];
              (if not (superN[] -> N.equal) then 
                  '%' -> Nx[]; superN[] -> Nx.append; 
                  (rN,'*'->(Ns.copy).put,'*'->(Nx.copy).put)
                    -> bitCast -> rNx;
                  Nx[] -> Ns[];
                  superN[] -> N[];  
                  rNx -> rN
              if);
              (if dumpLLVMobjs then
                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = ptrtoint ' -> out.puttext; Ns[] -> out.puttext;
                  '* ' -> out.puttext; rN -> emitRreg -> out.puttext;
                  ' to i32\n' -> out.puttext;
                  'call i32 @dumpHex(i32 ' -> out.puttext;
                  rNx -> emitRreg -> out.puttext; 
                  ',i32 1)\n' -> out.puttext;
              if);
              (if newFeature then
                  ';;**** call: ' -> out.puttext; Ns[] -> out.puttext;
                  ' ' -> out.put; descNo -> out.putint; 
                  ' ' -> out.put; N[] -> out.puttext;
                  ' ' -> out.put; superDescNo -> out.putint; '"'->out.put;
                  (superDescNo -> typeInfo.get).orgSig[] -> out.puttext;
                  '"'->out.put;
                  (if (superDescNo -> typeInfo.get).orgSig[] <> none then
                      ' '-> out.put;
                      (if stack.rtop > 1 then
                          stack.rType[stack.rtop - 1][] -> out.puttext;
                       else
                          ' none: ' -> out.puttext; stack.rtop -> out.putint;
                          ' ' -> out.put; 
                          stack.rType[stack.rtop][] -> out.puttext;
                  if)if);
                  out.newline;
              if);
              
              (if staticOff > 0 then
                  (* we have X: obj / val foo
                   * the new foo object shall be stored in X (staticOff)
                   * If foo returns a value that is not a ref to foo,
                   * then dont store. The return value may be an integer.
                   * The return value is fecthed after the call.
                   * OBS! foo may also return a foo ref that differs from
                   * the new foo object
                   *)
                  (thisClassN[],staticOff) ->  typeInfo.lookup -> rtnType[];
                  '   ;; save object: ' -> out.puttext; 
                  '*'-> (Ns.copy).put -> Tx[] -> out.puttext;
                  ' dstType: '  -> out.puttext; rtnType[] -> out.putline;
                  
                  (if (rtnType[]->deRef) -> calleeType.equal then

                      (0,thisClassN[],staticOff)  -> leaReg -> rNx;

                      '   store ' -> out.puttext; 
                      calleeType[] -> out.puttext;
                      '* ' -> out.puttext;
                      calleeReg -> emitRreg -> out.puttext; 
                      ',  ' -> out.puttext;
                      calleeType[] -> out.puttext; '** ' -> out.puttext;
                      rNx -> emitRreg -> out.putline; 
                   else
                      '   ;; dont save - object computes a return value'
                        -> out.putline;
                      lcom(#do 'thisType: ' -> TT; calleeTYpe[]->TT;
                             ' rtnType: ' -> TT; rtnType[] -> TT 
                          #);
              if)if);

              allocReg -> rNz -> emitRreg -> out.puttext;
              ' = call ' -> out.puttext; Ns[] -> out.puttext;
              '* @' -> out.puttext; N[] -> out.puttext; 
              '(' -> out.put; Ns[] -> out.puttext; ' * ' -> out.puttext;
              rN -> emitRreg -> out.puttext; 
              (if newFeature and ((superDescNo->typeInfo.get).orgSig[] <> none) then
                  ',' -> out.put;
                  stack.rTop - 1 -> typedRreg -> out.puttext;
              if);
              ')' -> out.put;
              out.newline;
              (if newFeature then
                  2 -> stack.rpop
               else
                  1 -> stack.rpop;
              if);
              '*' -> Ns.put;
              rN -> stack.Rpush(#do Ns[] -> stack.Rtype[stack.rtop][]#);
              (if 'main' -> ((2,5) -> thisClassN.sub).equal then
                  leave invoke
              if);
              (* check if normal return og leave or restart *)
              (* rtn = callee  => normal return
               * rtn <> callee =>  break
               *     rtn <> this => continue break, unwind of stack
               *     rtn = this  => end of break; select leave or restart
               *)
              allocReg -> normalRtnLab;
              allocReg -> breakLab;
              (* compare rtn = callee *)
              '   ' -> out.puttext;
              allocReg -> vNx -> emitVreg -> out.puttext;
              ' = icmp eq '  -> out.puttext;
              Ns[] -> out.puttext;
              rNz -> emitRreg -> out.puttext;
              ', ' -> out.puttext;
              rN -> emitRreg -> out.puttext;
              out.newline;
              
              '   br i1 ' -> out.puttext;
              vNx -> emitVreg -> out.puttext;
              ', label %normalRtnLab' -> out.puttext; 
              normalRtnLab -> out.putint;
              ', label %breakLab' -> out.puttext; breakLab -> out.putint;
              out.newline;
              
              'breakLab' -> out.puttext; breakLab -> out.putint; 
              ':' -> out.put; out.newline;
              
              (rNz,Ns[],PthisClassN[])  -> bitCast -> rNq;
              '   ' -> out.puttext;
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = icmp eq ' -> out.puttext;
              PthisClassN[] -> out.puttext;
              ' ' -> out.put; 0 -> emitRreg -> out.puttext; 
              ', ' -> out.puttext;
              rNq -> emitRreg -> out.putline;
              
              '   br i1 ' -> out.puttext;
              vN -> emitVreg -> out.puttext;
              allocReg -> contBreakLab; allocReg -> selectBreakLab;
              ', label %selectBreakLab' -> out.puttext; 
              selectBreakLab -> out.putint;
              ', label %contBreakLab' -> out.puttext; 
              contBreakLab -> out.putint;
              out.newline;
              'contBreakLab' -> out.puttext; contBreakLab -> out.putint; 
              ':' -> out.put; out.newline;
              
              '   ret ' -> out.puttext; PthisClassN[] -> out.puttext;
              ' ' -> out.put;
              rNq -> emitRreg -> out.putline;
              
              'selectBreakLab' -> out.puttext; selectBreakLab -> out.putint;
              ':' -> out.put; out.newline;
              
              (if true then
                  (rNz,'*'->(Ns.copy).put ->deref, '[0 x i32]*')
                    -> bitcast -> rN;
                  
                  '   ' -> out.puttext;
                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = getelementptr [0 x i32], [0 x i32]* ' -> out.puttext;
                  rN -> emitRreg -> out.puttext;
                  ', i32 0, i32 0\n' -> out.puttext;
                  
                  '   ' -> out.puttext;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = load i32 ' -> out.puttext; 
                  ', i32* ' -> out.puttext; 
                  rNx -> emitRreg -> out.putline;
                  
                  (if false then
                      '   call i32 @putHex(i32 ' -> out.puttext; 
                      vN -> emitVreg -> out.puttext;
                      ')\n' -> out.puttext;
                  if);
                  
                  (if false then
                      '   ' -> out.puttext;
                      allocReg -> vNx -> emitVreg -> out.puttext;
                      ' = icmp slt i32 2, ' -> out.puttext;
                      vN -> emitVreg -> out.puttext; out.newline;
                      
                      allocReg -> tLab; allocReg -> fLab;
                      '   br i1 ' -> out.puttext; 
                      vNx -> emitVreg ->out.puttext;
                      ', label %X' -> out.puttext; tLab -> out.putint;
                      ', label %X' -> out.puttext; fLab -> out.putint;
                      out.newline;
                      
                      'X' -> out.put; fLab -> out.putint; ':' -> out.put;
                      out.newline;
                  if);
                  
                  (if traceLLVMcalls then
                      allocReg -> rSn;                  
                      '   %S' -> out.puttext; rSn -> out.putint;
                      '= getelementptr [' -> out.puttext;
                      thisClassN.length + 2 -> out.putint;
                      ' x i8], [' -> out.puttext;
                      thisClassN.length + 2 -> out.putint; 
                      ' x i8]* @S.' -> out.puttext; 
                      thisClassId[] -> out.puttext; 
                      ', i64 0, i64 0\n' -> out.puttext;                  
                      '   call i32 @puts(i8* %S' -> out.puttext;
                      rSn -> out.putint;
                      ')\n' -> out.puttext;
                  if);
                  
                  (* restore vdt *)
                  (rNz,Ns[]->deref,0) -> leaReg -> rNy;
                  '   store ' -> out.puttext;
                  (2,Ns.length) -> Ns.sub  -> vdtType -> out.puttext;
                  ' @vdt_data$' -> out.puttext; 
                  (2,Ns.length - 1) -> Ns.sub -> out.puttext;
                  ', ' -> out.puttext; 
                  (2,Ns.length) -> Ns.sub -> vdtType -> out.puttext;
                  '* ' -> out.puttext;
                  rNy -> emitRreg -> out.puttext;
                  '\n' -> out.puttext;
                  
                  '   ' -> out.puttext;
                  allocReg -> vNx -> emitVreg -> out.puttext;
                  ' = icmp eq i32 1, ' -> out.puttext;
                  vN -> emitVreg -> out.puttext; out.newline;
                  
                  allocReg -> rLab; allocReg -> lLab;
                  '   br i1 ' -> out.puttext; vNx -> emitVreg ->out.puttext;
                  ', label %X' -> out.puttext; rLab -> out.putint;
                  ', label %X' -> out.puttext; lLab -> out.putint;
                  out.newline;
                  
                  'X' -> out.put; rLab -> out.putint; ':' -> out.put;
                  out.newline;
                  '   br label %L1 ; restart' -> out.putline;
                  
                  'X' -> out.put; lLab -> out.putint; ':' -> out.put;
                  out.newline;
                  '   br label %L2 ; leave' -> out.putline;
                  
                  (if false then
                      'X' -> out.puttext; tLab -> out.putint; 
                      ':' -> out.put;
                      out.newline;
                  if);
                  
                  (*'   br label %normalRtnLab' -> out.puttext;
                  normalRtnLab -> out.putint; out.newline;*)
                  'normalRtnLab' -> out.puttext; 
                  normalRtnLab -> out.putint; 
                  ':' -> out.put;
                  out.newline;
              if);
              out.newline;
              stack.put
          if)
        #);
     mkVindexed:
       (# descInx: @integer
       enter descInx
       do ' mkVindexed ' -> out.puttext; descInx -> out.putint; 
          out.newline; 
          codes.mkVindexed -> emit; descInx -> emit2;
       #);
     mkRindexed:
       (# descInx: @integer
       enter descInx
       do ' mkRindexed ' -> out.puttext; descInx -> out.putint; 
          out.newline;
          codes.mkRindexed -> emit; descInx -> emit2;
       #);     
     saveAndSetThis:
       (#
       do (If notLLVM then
              ' saveAndSetThis ' -> out.putline;
              codes.saveAndSetThis -> emit
          if)
       #);
     restoreThis:
       (#
       do  ' restoreThis ' -> emitOp;
          codes.restoreThis -> emit;
          (if notLLVM then
           else
              '!!! restoreThis not implememnted'  -> putline
          if)
       #);
     invokeVal:
         (# N,PN: ^text; descNo,staticOff,rN: @integer
         enter(N[],descNo,staticOff) 
         do 'invokeVal' -> emitOp; ' ' -> out.put; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
            staticOff -> out.putint; out.newline;
            (if notLLVM then
                codes.invokeVal -> emit; descNo -> emit2; staticOff -> emit2
             else;
                (0,PthisClassN[],(N[],descNo) -> mkTypePtr -> PN[])
                  -> BitCast -> rN;
                inner invokeVal;
                
                '   call ' -> out.puttext; PN[] -> out.puttext;
                ' @' -> out.puttext; 
                (2,PN.length-1) -> PN.sub  -> out.puttext; 
                '(' -> out.put; PN[] -> out.puttext; 
                ' ' -> out.puttext;
                rN -> emitRreg -> out.puttext; 
                ', i32 ' -> out.puttext;
                staticOff -> out.putint;
                ')' -> out.put;
                out.newline;
            if)
         #);
     boxedInvokeVal:
       (# N: ^text; descNo,size: @integer
       enter(N[],descNo,size)
       do ' boxedInvokedVal ' -> out.puttext; N[] -> out.puttext; 
          ' ' -> out.put; descNo -> out.putint; 
          ' ' -> out.put; size -> out.putint; out.newline;
          codes.boxedInvokeval -> emit; descNo -> emit2; size -> emit2
       #);
     invokeExternal:
       (# N: ^text; externalNo: @integer
       enter(N[],externalNo)
       do ' invokeExternal ' -> out.puttext; externalNo -> out.putint; 
          out.newline;
          codes.invokeExternal -> emit; externalNo -> emit
       #);
     allocIndexed:
       (# N,eType: ^text; 
          descNo,size,isRefIndexed,staticOff,rN,rNx: @integer;
       enter(N[],descNo,size,isRefIndexed,staticOff) 
         do 'allocIndexed ' -> emitOp; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put; 
            size -> out.putint; ' ' -> out.put; 
            isRefIndexed -> out.putint; out.newline;
            (if notLLVM then
                codes.allocIndexed -> emit; descNo -> emit2; size-> emit; 
                isRefIndexed -> emit
             else
                stack.put;
                (N[],staticOff) -> typeInfo.lookup -> eType[];
                lcom(#do 'eType: ' -> TT; eType[] -> TT #);
                
                '   ' -> out.puttext;
                allocReg -> rN -> emitRreg -> out.puttext;
                ' = tail call i32 * @allocIndexed(i32 ' -> out.puttext;
                stack.vtop - 1 -> vRegInstack -> out.puttext;
                ',i32 ' -> out.puttext;
                stack.vtop -> vRegInstack -> out.puttext;
                ')\n   ' -> out.puttext;
                
                (rN,'i32*',eType[]) -> bitCast -> rNx;
                
                1 -> stack.rPop;
                2 -> stack.vPop;
                (rNx,eType[]) -> stack.rpushT
            if)
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do ' exeAlloc ' -> out.puttext; descNo -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit2
       #);
       
     newVrep: (# do ' newVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do ' send ' -> out.puttext; inx -> out.putint; 
          ' ' -> out.put;  N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     invokeV:
       (# N,T,elmType: ^text; recIsValueObj: @boolean;
          dinx,noOfRefArgs,rNx,rNy,rNz,rNv,rNw,rNq: @integer;
          originOff:<
            (# off: @integer; type: ^text
            do inner;
               off -> orgOff; 
               '%' -> orgType[]; type[] -> orgType.append;
            exit(off ,type)
            #);
          orgOff: @integer; orgType: ^text
       enter(N[],dinx,noOfRefArgs,recIsValueObj) 
       do 'invokev ' -> emitOp; dinx -> out.putint; 
          ' ' -> out.put; noOfRefArgs -> out.putint;
          ' ' -> out.put; N[] -> out.puttext;  ' ' -> out.put;
          (if recIsValueObj then 1 -> out.put else 0 -> out.put if);
          out.newline;
          (if notLLVM then
              codes.invokev -> emit; dinx -> emit; noOfRefArgs -> emit;
              (if recIsValueObj then 1  -> emit else 0 -> emit if);
           else
              lcom(#do 'vdt:dinx: ' -> TT; dinx -> II #);
              stack.put;
              lcom(#do 'load pointer to VDT' -> TT #);
              0 -> leag -> rNx; 
                                          
              '%vdt_type$' -> T[];
              (2,stack.rtype[stack.rtop].length)
                -> stack.rtype[stack.rtop].sub -> T.append;
              
              allocReg -> rNy -> emitRreg -> out.puttext;
              ' = load ' -> out.puttext; T[] -> out.puttext; 
              ', ' -> out.puttext; T[] -> out.puttext; '* ' -> out.puttext; 
              rNx -> emitRreg -> out.putline;
              
              T[] -> deRef -> T[];
              
              lcom(#do 'Load binding at dInx' -> TT #);
              (rNy,T[],dinx - 1) -> leaReg -> rNz;              
              '%vdt_ret$' -> T[]; N[] -> T.append; '*()*' -> T.append;
              allocReg -> rNv -> emitRreg -> out.puttext;
              ' = load ' -> out.puttext; T[] -> out.puttext;
              ', ' -> out.puttext; T[] -> out.puttext; '* ' -> out.puttext; 
              rNz -> emitRreg -> out.puttext; '\n   ' -> out.puttext;
              ';; ' -> out.puttext; rNv -> emitRreg -> out.puttext;
              ' = obj.VDT\n   ' -> out.puttext;
              
              (*(rNv,T[]->deRef) -> dumpObj;*)      
              
              lcom(#do 'Call %vdt_ret' -> TT #);
              '%vdt_ret$' -> T[]; N[] -> T.append; 
              allocReg -> rNw -> emitRreg -> out.puttext;
              ' = call ' -> out.puttext; T[] -> out.puttext;
              '* ' -> out.puttext;
              rNv  -> emitRreg -> out.puttext;
              '()\n' -> out.puttext;
              
              (*(rNw,T[]->deRef) -> dumpObj;*)
              
              lcom(#do 'Load  new virtual object' -> TT #);
              (rNw,T[],0) -> leaReg -> rNq;              
              allocReg -> rNx -> emitRreg -> out.puttext;
              ' = load %' -> out.puttext;
              N[] -> out.puttext; '*, %' -> out.puttext;
              N[] -> out.puttext; '** ' -> out.puttext;
              rNq -> emitRreg -> out.puttext;
              '\n' -> out.puttext;
              
              lcom(#do rNx -> emitRreg -> TT; ' = new virtual object' -> TT #);
              (if not newFeature then
                  lcom(#do 'Store origin in virtual object - FIX it!'->TT #);
                  originOff;
              
                  (*(rNx,'%' -> (N.copy).prepend) -> dumpObj;*)
                  
                  lcom(#do 'store origin:off:' -> TT; orgOff -> II; 
                         ' ' -> TT; orgType[] -> TT #);
                  stack.put;
                  (if orgOff = 0 then
                      '!!!! invokev:originOff = 0 :'  -> puttext;
                      N[] -> putline;
                      lcom(#do '!!!! originOff = 0 '  -> TT; N[] -> TT  #);
                      1 -> orgOff (* a hack !? *)
                  if);
                  (rNx,orgType[],orgOff) -> leaReg -> rNy;
                  
                  (* this is probably wrong! *)
                  (# T: ^text
                  do (orgType[],orgOff) -> typeinfo.lookup -> T[];
                     (rNy,'*' -> (T.copy).put
                     ,'*' -> (stack.rType[stack.rTop].copy).put)
                       -> bitCast -> rNy
                  #);
                  
                  '   store ' -> out.puttext; 
                  stack.rType[stack.rTop][] -> out.puttext; 
                  stack.rTop -> rReg -> out.puttext;
                  ', ' -> out.puttext; 
                  stack.rType[stack.rTop][] -> out.puttext; 
                  '* ' -> out.puttext;
                  rNy -> emitRreg -> out.putline;
              if);
              (if dumpLLVMobjs then
                  (rNx,'%' -> (N.copy).prepend) -> dumpObj;
              if);
              
              (if true then
                  lcom(#do 'FIX: mustr VDT entry' -> TT #);
                  stack.put;
                  '   call %' -> out.puttext; N[] -> out.puttext;
                  '* @' -> out.puttext;
                  N[] -> out.puttext;
                  '(%' -> out.puttext;  N[] -> out.puttext;
                  '* ' -> out.puttext; rNx -> emitRreg -> out.puttext;
                  (if newFeature then
                      ',' -> out.put;
                      (if stack.rTop > 0 then
                          stack.rtop -> typedRreg -> out.puttext
                       else
                          'NULL' -> out.puttext;
                  if)if);
                  ')\n' -> out.puttext;
                  '%' -> T[]; N.copy -> T.append; '*' -> T.put;
                  (rNx,T[]) -> stack.rPushT;
               else
                  (rNw,T[],1) -> leaReg -> rNy;
                  
                  allocReg -> rNz -> emitRreg -> out.puttext;
                  ' = load %' -> out.puttext; N[] -> out.puttext;
                  '* (%' -> out.puttext;  N[] -> out.puttext;
                  '*)*, %' -> out.puttext; N[] -> out.puttext;
                  '* (%' -> out.puttext; N[] -> out.puttext;
                  '*)**' -> out.puttext;
                  rNy -> emitRreg -> out.puttext;
                  
                  '\n   call %' -> out.puttext; N[] -> out.puttext;
                  '* ' -> out.puttext;
                  rNz -> emitRreg  -> out.puttext;
                  '(%' -> out.puttext;  N[] -> out.puttext;
                  '* ' -> out.puttext; rNx -> emitRreg -> out.puttext;
                  ')\n' -> out.puttext
              if);
          if);
       #);
     exe: 
       (# N: ^text enter N[] 
       do ' exe ' -> out.puttext; N[] -> out.putline 
       #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do (if notLLVM then
              ' call(' -> out.puttext; LMR -> out.put; ')' -> out.put;
              N[] -> out.putline; 
              codes.call -> emit;
              LMR -> emit
           else
              codes.call -> notImpl
              (#
              do ' call(' ->Tx.append; LMR -> Tx.put; ')' -> Tx.put;
                 N[] ->Tx.append
              #)
          if)
       #);
     vdtTablePrint:
       (# descNo: @integer; T: @text
       enter descNo
       do 'vdtTable:Q: ' -> T.puttext;
          (for i: descs.OD[descNo].vdtTable.range repeat 
               (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[descNo].vdtTable[i] -> T.putint;
               inner
          for); 
          T[] -> comment          
       #);
     vdtTableCopy:
       (# superDescNo: @integer; T: @text
       enter superDescNo
       do 'vdtTableCopy:' -> T.puttext;
          (for i: descs.OD[superDescNo].vdtTop repeat
               ' ' -> T.put;
               (if descs.OD[superDescNo].isInner[i] then 
                   'I' -> T.put 
                else 
                   'V' -> T.put 
               if);
               ':' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[superDescNo].vdtTable[i] -> T.putint; 
               (i,descs.OD[superDescNo].vdtTable[i]
               ,descs.OD[superDescNo].isInner[i]) 
                 -> descs.current.vdtAdd
          for); 
          T[] -> comment;
          (* copy literals from super to current *)
          descs.OD[superDescNo].literals.range 
            -> descs.current.litTop
            -> descs.current.literals.new;
          (for i: descs.current.litTop repeat
               (*descs.OD[superDescNo].literals[i] -> putint; ',' -> put;*)
               descs.OD[superDescNo].literals[i] -> descs.current.literals[i]
          for);
          (*newline;*)
       #);
     vdtTable:
       (# inx,descInx: @integer; isInner: @boolean
       enter(inx,descInx,isInner)
       do (inx,descInx,isInner) -> descs.current.vdtAdd -> comment
       #);
     vdtTableAt:
       (* For OD:descNo, virtual/inner:inx is bound to descInx *)
       (# inx,descInx,descNo: @integer
       enter(inx,descInx,descNo)
       do (if false then
              '; vdtTableAt: ' -> out.puttext;
              inx -> out.putint; ' ' -> out.put;
              descInx -> out.putint; ' ' -> out.put;
              descNo -> out.putint; out.newline;
          if);
          (inx,descInx,descNo) -> VdtPatch.add
       #);
     VdtPatch: @
       (# index,bindInx,descInx:[5] @ integer; top: @integer;
          init: (# do 0 -> top #);
          add:
            (* For OD:dx, virtual/inner:ix is bound to bx *)
            (# ix,bx,dx: @integer
            enter (ix,bx,dx)
            do (if (top + 1 -> top) > index.range then
                   index.range -> index.extend;
                   bindInx.range -> bindInx.extend;
                   descInx.range -> descInx.extend;
               if);
               ix -> index[top];
               bx -> bindInx[top];
               dx -> descInx[top];
               (if not notLLVM then (ix,bx,false) -> descs.OD[dx].vdtadd if)
            #);
          patch:
            (#
            do (for i: top repeat
                    (if false then
                        'Patch:range:' -> puttext; index.range -> putint; ' ' -> put;
                        index[i] -> putint; ' ' -> put;
                        bindinx[i] -> putint; ' ' -> put;
                        descInx[i] -> putint;  ' ' -> put;  newline;
                    if);
                    (index[i],bindInx[i],false) (* never inner ? *)
                      -> descs.OD[descInx[i]].vdtAdd -> comment
               for)
            #)
       #);
     toSuper:
       (# descInx: @integer
       enter descInx
       do (if notLLVM then
              ' toSuper ' -> out.puttext;
              descInx -> out.putint; out.newline;
              codes.toSuper -> emit; descInx -> emit2
           else
              '   ;; toSuper'->out.putline
          if)
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do (if notLLVM then
              ' innerX ' -> out.puttext; ' ' -> out.put; 
              inx -> out.putint; out.newline;
              codes.innerx -> emit; inx -> emit;
           else
              '   ;; innerx\n' -> out.puttext 
          if)
       #);
     innerP: (* Inner P, where P.ON > 1 *)
       (# inx,rN,rNx,rNy,rNz,vN,vNt,vNf: @integer; elmType: ^text
       enter inx
       do 'innerP' -> emitOp; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          (if notLLVM then             
              codes.innerP -> emit; inx -> emit;
           else
              stack.put;
              (if true then
                  0 -> leag -> rN; (* pointer to vdt *)
                  
                  stack.rType[stack.rtop][] -> elmType[];
                  (2,elmType.length) -> elmType.sub -> elmType[];
                  
                  allocReg -> rNy -> emitRreg -> out.puttext;
                  ' = load ' -> out.puttext;
                  elmType[] -> vdtType -> out.puttext;
                  ', ' -> out.puttext;
                  elmType[] -> vdtType -> out.puttext;
                  '* ' -> out.puttext; 
                  rN -> emitRreg -> out.puttext;
                  '\n' -> out.puttext;
                  
                  (* rN = ptrToVDT; Load vdt[inx - 1] = inner *)
                  (rNy,elmType[] -> vdtType -> deRef,inx - 1) 
                    -> leaReg -> rNx;
                  
               else
                  0 -> leag -> rN; (* pointer to vdt *)
                  
                  allocReg -> rNy -> emitRreg -> out.puttext;
                  ' = load ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '*, ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '** ' -> out.puttext; 
                  rN -> emitRreg -> out.puttext;
                  '\n   ' -> out.puttext;
              
                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = getelementptr ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  ', ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '* ' -> out.puttext; 
                  rNy ->  emitRreg -> out.puttext; 
                  ', i32 0, i32 ' -> out.puttext; inx - 1 -> out.putint;
                  '\n   ' -> out.puttext;
              if);
              allocReg -> rNz -> emitRreg -> out.puttext; 
              ' = load ' -> out.puttext;
              (if true then
                  ' i8*(i8*)*, i8*(i8*)** ' -> out.puttext;
               else
                  thisClassId[] -> vdtType -> out.puttext;
                  ',' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '* ' -> out.puttext;
              if);
              rNx -> emitRreg -> out.puttext;
              '\n   ' -> out.puttext;
              
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = icmp eq i8*(i8*)* ' -> out.puttext; 
              rNz -> emitRreg -> out.puttext;
              ', null\n   ' -> out.puttext;
              allocReg -> vNt; allocReg -> vNf;
              'br i1 ' -> out.puttext; vN -> emitVreg -> out.puttext;
              ', label %L' -> out.puttext; vNt -> out.putint;
              ', label %L' -> out.puttext; vNf -> out.putint;
              out.newline;
              'L' -> out.puttext; vNf -> out.putint; ':\n' ->out.puttext;
              '   ;; inner not null\n   ' -> out.puttext;
              (stack.rRegNo[stack.rTop],stack.rType[stack.rTop][],'i8*')
                -> bitCast -> rNx;
              
              'call i8* '  -> out.puttext; 
              rNz -> emitRreg -> out.puttext;  
              '(i8* ' -> out.puttext;
              rNx -> emitRreg -> out.puttext;              
              ')\n   ' -> out.puttext;
              'br label %L' -> out.puttext; vNt -> out.putint; 
              out.newline;
              'L' -> out.puttext; vNt -> out.putint; ':\n' ->out.puttext;
              1 -> stack.rPop              
          if)
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do 'innerExit' -> emitOp; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;

       #);
     innerA:
       (# inx: @integer 
       enter inx
       do 'innerA ' -> emitOp; ' ' -> out.put; inx -> out.putint; out.newline;
          (if notLLVM then              
              codes.innerA -> emit; inx -> emit;
          if)
       #);
     suspendd: 
       (# 
       do (if notLLVM then
              ' suspend' -> out.putline; codes.susp -> emit 
           else
              codes.susp -> notImpl(#do 'suspend' -> Tx.append #)
          if)
       #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do 'doSuper' -> emitOp; ' ' -> out.put; N[] -> out.puttext; 
          ' ' -> out.put; inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit2;
       #);

     pushThis:
       (# 
       do (if notLLVM then
              ' pushThis ' -> out.putline;
              codes.pushthis -> emit; 
           else
              lcom(#do 'pushThis' ->TT #);
              (0,PthisClassN[]) -> stack.rPushT;
              stack.put
          if)
       #);
     pushValId:
       (# 
       do (if notLLVM  then
             'pushValId'->out.putline; codes.pushValId -> emit
          else
              '\n!!! LLVM: pushValId  nothandled!\n' -> putline;
              1 -> pushConst;
              (* must be thisValObjDescInx below*)
              111 -> pushConst
          if)
       #);
     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do (if notLLVM then
              ' push ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.push -> emit; off -> emit;
              stack.vPush
           else
              '   ;; push ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
          if)
       #);
     pushg: 
       (# N,rNtype: ^text; off: @integer; rN,rN1,rN2: @integer
       enter(N[],off)
       do 'pushg' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then              
              codes.pushg -> emit; off -> emit;
           else

              (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
                  (if false then
                      '*** pushg:in value object: ' -> puttext;
                      N[] -> putline;
                  if);
                  off -> leag -> rN;                  
                  (rN,'i32*','[0 x i32]*') -> bitCast -> rN1;
                  allocReg -> rN2 -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                    -> out.puttext;
                  rN1 -> emitRreg -> out.puttext;
                  ', i32 0, i32 %off\n' -> out.puttext;
                  rN2 -> rN
               else
                  off -> leag -> rN;
              if);

              allocReg -> rN2 -> emitVreg -> out.puttext;
              ' = load i32, i32* ' -> out.puttext;
              rN -> emitRreg -> out.puttext;
              out.newline
          if);
          1 -> stack.rpop; 
          rN2 -> stack.vPush; (* push of value - no type needed *)
       #);
     fpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do (if notLLVM then
              ' fpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fpushg -> emit; off -> emit;
           else
              '   ;; fpushg\n' ->  out.puttext
          if)
       #);     
     ovpushg:
       (* Object X on stack with object P embedded at offset inx in X
        * inx is on vStack
        * Push P[off] = X[inx + off - 1]
        * 'ovpushg'-> exe; op1 -> off; 
        thisStack.vpop -> value;
        thisStack.rpop -> X[];
        off  + value - 1 
        *)
       (# N: ^text; off,rN,rNx,vN,vNx: @integer
       enter(N[],off)
       do 'ovpushg' -> emitOp; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          (if notLLVM then
              codes.ovpushg -> emit; off -> emit;
           else
              stack.put;
              1 -> stack.vpop;
              stack.put;              
              (stack.rRegNo[stack.rTop],stack.rType[stack.rTop][]
              , '[0 x i32]*')
              -> bitCast -> rNx;
              
              allocReg -> vNx -> emitVreg -> out.puttext;
              ' = add i32 ' -> out.puttext;
              off - 1 -> out.putint; ',' -> out.put;
              stack.vTop -> vRegInStack -> out.puttext;
              out.newline;
              
              (if false then
                  'call i32 @putHex(i32 ' -> out.puttext;
                  vNx -> emitVreg -> out.puttext;
                  ')\n' -> out.putline;
              if);
              
              allocReg -> rN  -> emitRreg -> out.puttext;
              ' = getelementptr inbounds ' -> out.puttext;
              ' [0 x i32], ' -> out.puttext;
              ' [0 x i32]* ' -> out.puttext;
              rNx -> emitRreg -> out.puttext;
               ', i32 0, i32 ' -> out.puttext;
              vNx -> emitVreg -> out.puttext;
              out.newline;
              
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = load i32 , i32* ' -> out.puttext; 
              rN -> emitRreg -> out.puttext;
              ', align 4\n' -> out.puttext;
              1 -> stack.vPop;
              vN -> stack.vPush;
              stack.put
          if)
       #);
     fovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.fovpushg -> emit; off -> emit;
       #);     
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' rpush ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit;
          stack.rPush
       #);
     rpushg: 
       (# N: ^text; off: @integer; rN,rN2: @integer; T,elmType: ^text
       enter(N[],off)
       do 'rpushg' -> emitOp; ' ' -> out.put; N[] -> out.puttext; 
          ' ' -> out.put; off -> out.putint; out.newline;
          (if notLLVM then
              codes.rpushg -> emit; off -> emit;
           else
              stack.put;
              (if stack.rtop = 0 then
                  '   ;; rpushg: stack.rtop = 0' -> out.putline;
                  '!!!! rpushg: stack.rtop = 0' -> putline;
                  leave rpushg
              if);
              (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
                  '*** rpushg:in value object: ' -> puttext;
                  N[] -> putline;
              if);
              (stack.rType[stack.rtop][],off) 
                -> typeInfo.lookup -> elmType[];
              
              lcom(#do 'ET:'-> TT; elmType[] -> TT;
                     ' ST:' -> TT; stack.Rtype[stack.rtop][] -> TT; #);
              stack.put;

              off -> leag -> rN;
              allocReg -> rN2 -> emitRreg -> out.puttext;
              ' = load ' -> out.puttext; 
              elmType[] -> out.puttext;
              ' , ' -> out.puttext; 
              elmType[] -> out.puttext; '* ' -> out.puttext;
              rN -> emitRreg -> out.puttext;
              out.newline;
          if);
          1 -> stack.rpop;
          (rN2,elmType[]) -> stack.rPushT;
          (if false then
              stack.put
          if);
       #);
     xpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' xpush ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.xpush -> emit; off -> emit;
          stack.rPush
       #);
     xpushg:
       (# N,xType: ^text; off,isValueObj,size,rN,rNx,vN,vNx: @integer
       enter(N[],off,isValueObj,size) 
       do 'xpushg ' -> emitOp; N[] -> out.puttext;  ' ' -> out.put; 
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;  
          (if notLLVM then
              codes.xpushg -> emit; off -> emit; isValueObj -> emit; 
              size -> emit;
           else
              (* X = rStack[rTop] = adr of Indexed obj; may be a Sring
               * inx = vDtack[vTop]
               * push X[off + inx]
               *)
              stack.put;

              stack.rType[stack.rTop][] -> xType[];
             
              (if ('%String' -> ((1,7) -> xType.sub).equal)
                  and (stack.vVal[stack.vtop][] <> none)
                  and  (stack.vVal[stack.vtop].V = 0) then
                  (if false then
                      '**** xpushg: string[0] = length ' -> putline;
                  if);
                  (stack.rRegNo[stack.rTop]
                  ,stack.rType[stack.rTop][]
                  ,'i32*')  
                    -> bitCast ->rN;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = call i32 @arrayLength(i32* ' -> out.puttext;
                  rN -> emitRreg -> out.puttext;
                  ')\n' -> out.puttext;
               else
                  (if ('%String' -> ((1,7) -> xType.sub).equal) then
                      ';; xpusg:String\n' -> out.puttext;
                      (stack.rRegNo[stack.rTop]
                      , stack.rType[stack.rTop][]
                      ,'{i32*,i32,[0 x i32]}*')
                        -> bitCast
                        -> stack.rRegNo[stack.rTop];
                      '{i32*,i32,[0 x i32]}*' ->  stack.rType[stack.rTop][]
                  if);
                  allocReg -> vNx -> emitVreg -> out.puttext;
                  ' = add i32 -1, ' -> out.puttext;
                  stack.vTop -> vRegInStack -> out.puttext;
                  out.newline;
                  
                  allocReg -> rN  -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds ' -> out.puttext;
                  stack.rType[stack.rTop][] -> deRef -> out.puttext;
                  ', ' -> out.puttext; 
                  stack.rType[stack.rTop][] -> out.puttext;
                  ' ' -> out.puttext;
                  stack.rTop -> rReg -> out.puttext;
                  ', i32 0, i32 2\n' -> out.puttext; 
                  
                  (* rN = adr of Indexed obj
                   * rStack[rTop] = typeOf(rN) *)

                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                    -> out.puttext;
                  rN -> emitRreg -> out.puttext;
                  ', i32 0, i32 ' -> out.puttext;
                  vNx -> emitVreg -> out.puttext;
                  out.newline;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = load i32 , i32* ' -> out.puttext; 
                  rNx -> emitRreg -> out.puttext;
                  ', align 4\n' -> out.puttext;
              if)
          if);
          1 -> stack.rpop;
          1 -> stack.vpop;
          vN -> stack.vPush
       #);
     xrpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do 'xrpush ' -> emitop; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.xrpush -> emit; off -> emit;
       #);    
     xrpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do 'xrpushg ' -> emitop; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then
              codes.xrpushg -> emit; off -> emit;
           else
              codes.xrpushg -> notImpl
          if)
       #);
     pushConst: 
       (# cst: @integer; rn: @integer
       enter cst
       do (if notLLVM then
              ' pushc ' -> out.puttext; cst -> out.putint; out.newline;
              (if true 
               // cst <= 255 then
                  codes.pushc -> emit;
                  cst -> emit
               // cst <= 255 * 255  then
                  codes.pushc2 -> emit;
                  cst -> emit2
               else 
                  'OBS! Constant >= 2^16 is not implemented' -> comment
              if);
           else
              '   ' -> out.puttext;
              allocReg -> rN -> emitVreg -> out.puttext;
              ' = add i32 0, ' -> out.puttext; cst -> out.putint; 
              out.newline;
              rn -> stack.vPush;              
              cst -> stack.value -> stack.vVal[stack.vTop][];
          if);
       #);
     pushFloatConst:
       (# X: @Real
       enter X
       do (if notLLVM then
              ' pushFloatConst ' -> out.puttext; X -> out.putReal; 
              out.newline;
              codes.pushFloatConst -> emit;
              X -> emit8
           else
              '   ;; pushFloatConst \n' -> out.puttext;
          if)
       #);
     pushNone: 
       (# rN: @integer
       do 'pushNone' -> emitOp; out.newline;
          (if notLLVM then
              codes.pushNone -> emit;
              stack.rPush
           else
              (0,'null') -> stack.rPushT
          if);

       #);
     pushText:
       (# T,T1: ^text; stringDescNo,I: @integer
       enter (T[],stringDescNo)
       do (if notLLVM then
              ' pushText ' -> out.puttext; T[] -> out.putline;
              codes.pushText -> emit;
              T[] -> handleEscape -> T1[];
              (* 'PushText: ' -> puttext; T1[] -> putline;*)
              T1.length -> descs.current.addLiteral
              (#
              do i + 1 -> i -> T1.inxGet -> value;
              #) -> emit;
              stack.rPush
           else
              ';; pushText \n' -> out.puttext;
              (T[],stringDescNo) -> AllocString;
          if)
       #);
     handleEscape:
       (# T: ^text; T1: @text;
          nextCh: 
            (# 
            do i + 1 -> i;
               (if i <= T.length then
                   i -> T.inxGet -> ch;
                else
                   0 -> ch
               if);               
            #);
          ch: @char;
          i: @integer
       enter T[]
       do 0 -> i;
          nextCh;
          loop:
            (if i <= T.length then 
                (if ch 
                 // '\\' then 
                    nextCh;
                    (if ch
                     // 'n' then
                        ascii.nl -> T1.put;
                        nextch
                     // '\\' then
                        '\\' -> T1.put;
                        nextch;
                     else
                        '\\' -> T1.put
                    if)
                 else
                    ch -> T1.put;
                    nextCh;                    
                if);
                restart loop
            if)
       exit T1[]
       #);
     mkStrucRef:
       (# T: ^text
       enter T[]
       do ' mkStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkStrucRef -> emit
       #);
      mkObjStrucRef:
       (# T: ^text
       enter T[]
       do ' mkObjStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkObjStrucRef -> emit
       #);
     mkVirtualStrucRef:
       (# T: ^text; off: @integer
       enter(T[],off)
       do ' mkVirtualStrucRef ' -> out.puttext; off-> out.putint; out.newline;
          codes.mkVirtualStrucRef -> emit; off -> emit
       #);
     allocFromStrucRefObj:
       (#
       do ' allocFromStrucRefObj ' -> out.putline;
          codes.allocFromStrucRefObj -> emit;
       #);
     pushValue:
       (# size: @integer
       enter size
       do ' pushvalue ' -> emitop; size -> out.putint; out.newline;
          (if notLLVM then
              codes.pushValue -> emit; size -> emit;
           else
              '!!!! LLVM:pushValue not implemented!' -> putline
          if)
       #);
     vassign:
       (# size,mode: @integer
       enter(size,mode)
       do ' vassign ' -> emitOp; size -> out.putint; ' ' -> out.put;
          mode -> out.putint; out.newline;
          (if notLLVM then
              codes.vassign -> emit; size -> emit; mode -> emit
           else
              '!!!! LLVM:vassign not implemented!' -> putline
          if);
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do 'store' ->emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then
              codes.store -> emit; off -> emit;
              1 -> stack.vpop
           else
              lcom(#do 'store:ignored' -> TT #)
          if)
       #);
     storeX: 
       (# N: ^text; off,rN: @integer
       enter(N[],off) 
       do (if notLLVM then
              ' store ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.store -> emit; off -> emit;
              1 -> stack.vpop
           else
              '   ;; storeX ' -> out.puttext; N[] -> out.puttext;
              ' ' -> out.put; off -> out.putint; out.newline;
              stack.put;
              
              allocReg -> rN -> emitRreg -> out.puttext;
              ' = getelementptr ' -> out.puttext; 
              N[] -> prepStruct -> out.puttext;
              ', ' -> out.puttext;
              N[] -> prepStruct -> out.puttext; 
              ' * ' -> out.puttext;
              stack.rTop -> rReg -> out.puttext;
              ', i32 0, i32 ' -> out.puttext; off -> out.putint; 
              out.newline;
              '   store i32 ' -> out.puttext;
              stack.vTop -> vRegInStack -> out.puttext;
              ', i32* ' -> out.puttext; rN -> emitRreg -> out.putline;
              1 -> stack.vpop
          if)
       #);
     storeg: 
       (# N: ^text; off: @integer; rN,rN1,rN2,vN: @integer
       enter(N[],off) 
       do 'storeg ' -> emitop;  N[] -> out.puttext; 
          ' '-> out.put; off -> out.putint; out.putline;
          (if notLLVM then
              codes.storeg -> emit; off -> emit;
           else
              stack.put;
              
              (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
                  (if false then
                      '*** storeg:in value object: ' -> puttext;
                      N[] -> putline;
                  if);
                  off  -> leag -> rN;                  
                  (rN,'i32*','[0 x i32]*') -> bitCast -> rN1;
                  allocReg -> rN2 -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                    -> out.puttext;
                  rN1 -> emitRreg -> out.puttext;
                  ', i32 0, i32 %off\n' -> out.puttext;
                  rN2 -> rN
               else
                  off -> leag -> rN;
              if);
              
              (if stack.vType[stack.vtop] = 1 then
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = zext i1 ' -> out.puttext;
                  stack.vRegNo[stack.vtop] -> emitVreg -> out.puttext;
                  ' to i32\n' -> out.puttext
               else
                  stack.vRegNo[stack.vtop] -> vN
              if);
              '   store i32 ' -> out.puttext;
              vN -> emitVreg -> out.puttext;
              ', i32* ' -> out.puttext; 
              rN -> emitRreg -> out.putline
          if);
          1 -> stack.vpop;
          1 -> stack.rpop
       #);
     fstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do (if notLLVM then
              ' fstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fstoreg -> emit; off -> emit;
           else
              '   ;; fstoreg \n' -> out.puttext;
          if);
          1 -> stack.vpop          
       #);     
     ovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' ovstoreg ' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then
              codes.ovstoreg -> emit; off -> emit;
           else
              '!!!! LLVM:ovstoreg not implemented!' -> putline;
              1 -> stack.vpop
          if)
       #);
     fovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.fovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);  
     rstore:
       (# N: ^text; off,rN: @integer
       enter(N[],off) 
       do 'rstore ' ->emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM  then              
              (if off <= 255 then 
                  codes.rstore -> emit; off -> emit
              if);
           else
              lcom(#do 'rstore:ignored' -> TT #)
          if)
       #);
     rstoreX: 
       (# N,srcT: ^text; off,rN: @integer; 
          isValueObjectOrigin: @boolean
       enter(N[],off,isValueObjectOrigin) 
       do 'rstoreX ' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.puttext;
          ' isValueObjectOrigin: ' -> out.puttext; 
          (if isValueObjectOrigin then 'T' -> out.put else 'F' ->out.put if);
          out.newline;
          (if notLLVM  then              
              (if off <= 255 then 
                  codes.rstore -> emit; off -> emit
              if);
           else
              stack.put;
              (* rstore rReg[rTop - 1] in rReg[rTop].off *)
              (N[],off) -> typeInfo.lookup -> srcT[];
              '   ;; lookup:  ' -> out.puttext;  srcT[] -> out.putline;
              stack.put;
              
              (if isValueObjectOrigin then
                  '   ;; store origin being value object' ->out.putline;
                  off + 1 -> leag -> rN;   (* offSet in holder *)
                  'store i32 ' -> out.puttext;
                  stack.vRegNo[stack.vtop - 1] -> emitVreg -> out.puttext;
                  ', i32* ' -> out.puttext;
                  rN -> emitRreg -> out.putline;
                  off + 2 -> leag -> rN;   (* descNo of value obj *)
                  'store i32 ' -> out.puttext;
                  stack.vRegNo[stack.vtop] -> emitVreg -> out.puttext;
                  ', i32* ' -> out.puttext;
                  rN -> emitRreg -> out.putline
              if);
              (* leaReg -> rN = rstack[rTop] *)
              allocReg -> rN -> emitRreg -> out.puttext;
              ' = getelementptr ' -> out.puttext; 
              N[] -> prepStruct -> out.puttext;
              ', ' -> out.puttext;
              N[] -> prepStruct -> out.puttext; 
              ' * ' -> out.puttext;
              stack.rTop -> rReg -> out.puttext;
              ', i32 0, i32 ' -> out.puttext; off -> out.putint; 
              out.newline;
              (if stack.rtop < 2 then
                  '\n!!!! rstoreX: stack.rtop < 2' -> putline;
                  '   ;; rstoreX: stack.rtop < 2' -> out.putline;
                  leave rstoreX
              if);
              (*'ccc'->putline;     stack.print;         *)
              (if not (srcT[] -> stack.Rtype[stack.rTop - 1].equal) then
                  (rN,'*' -> (srcT.copy).put
                  ,'*' -> (stack.Rtype[stack.rTop - 1].copy).put
                  )
                    -> bitCast -> rN;
              if);
              '   store ' -> out.puttext;
              stack.Rtype[stack.rTop - 1][]  -> out.puttext; 
              ' ' -> out.puttext;
              stack.rtop - 1 -> rReg -> out.puttext;  
              ', ' -> out.puttexT;
              stack.Rtype[stack.rTop - 1][]  -> out.puttext; 
              '* ' -> out.puttext;
              rN -> emitRreg -> out.putline;
              rswap;
              stack.put;
              1 -> stack.rPop;
              stack.put
          if)
       #);
     rstoreg: 
       (# N: ^text; off,rN,rNd: @integer; srcType,dstType,rNtype: ^text;
          isNull: @boolean
       enter(N[],off) 
       do 'rstoreg ' -> emitOp; N[] -> out.puttext;
          ' ' -> out.put; off -> out.putint; out.newline;
          (if notLLVM then
              (if off <= 255 then 
                  codes.rstoreg -> emit; off -> emit
              if);
           else
              stack.put;

              off -> leag -> rN;
              
              (N[],off) -> typeInfo.lookup -> dstType[];
              
              stack.rType[stack.rTop - 1][] -> srcType[];
              (if 'null' -> srcType.equal then
                  dstType[]
                    -> stack.rType[stack.rTop][] 
                    ->  stack.rType[stack.rTop - 1][]
                    -> srcType[];
                  true -> isNull;
                  ';; isNull: ' -> out.puttext; stack.print -> out.putline
              if);
              ';; types:dst: ' -> out.puttext; dstType[] -> out.puttext; 
              ' src: ' -> out.puttext; srcType[] -> out.putline;
              stack.put;
              (if (dstType[] -> srcType.equal) 
                  then
                  '   store ' -> out.puttext; 
                  (if isNull then
                      srcType[] -> out.puttext;    
                      ' null, ' -> out.puttext;
                       dstType[] -> out.puttext;    
                      ' * ' -> out.puttext;
                   else
                      stack.rType[stack.rTop - 1][] -> out.puttext; 
                      '  ' -> out.puttext;
                      stack.rtop - 1-> rReg -> out.puttext; 
                      ', ' -> out.puttext; 
                      stack.rType[stack.rTop - 1][] -> out.puttext;    
                      ' * ' -> out.puttext;
                  if);
                  rN -> emitRreg -> out.puttext; out.newline;
               else
                  (stack.rRegNo[stack.rTop - 1],srcType[],dstType[]) 
                    ->  bitCast -> rNd;
                  stack.put;
                  '   store ' -> out.puttext; 
                  dstType[] -> out.puttext;
                  ' ' -> out.put; rNd -> emitRreg -> out.puttext;
                  ', ' -> out.puttext;
                  dstType[] -> out.puttext;    
                  ' * ' -> out.puttext;
                  rN -> emitRreg -> out.puttext; out.newline;
          if)if);
          2 -> stack.rPop;
          stack.put;
       #);
     xstore: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do 'xstore ' -> emitOp; N[] -> out.puttext; ' ' -> out.put;  
          off -> out.putint; out.newline;
          (if off <= 255 then 
              codes.xstore -> emit; off -> emit
          if);
          1 -> stack.vpop
       #);
     xstoreg: 
       (# N: ^text; off,isValueObj,size,vN,rN,rNx: @integer
       enter(N[],off,isValueObj,size) 
       do 'xstoreg ' -> emitop; N[] -> out.puttext; ' ' -> out.put;
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;          
          (if notLLVM then
              (if off <= 255 then 
                  codes.xstoreg -> emit; off -> emit; 
                  isValueObj -> emit; size -> emit; 
              if);
           else
              stack.put;
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = add i32 -1, ' -> out.puttext;
              stack.vTop -> vRegInStack -> out.puttext;
              out.newline;
              
              allocReg -> rN  -> emitRreg -> out.puttext;
              ' = getelementptr inbounds ' -> out.puttext;
              stack.rType[stack.rTop][] -> deRef -> out.puttext;
              ',  ' -> out.puttext; 
              stack.rType[stack.rTop][] -> out.puttext;
              ' ' -> out.puttext;
              stack.rTop -> rReg -> out.puttext;
              ', i32 0, i32 2\n' -> out.puttext;
              
              allocReg -> rNx -> emitRreg -> out.puttext;
              ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                -> out.puttext;
              rN -> emitRreg -> out.puttext;
              ', i32 0, i32 ' -> out.puttext;
              vN -> emitVreg -> out.puttext;
              (*stack.vTop -> vRegInStack -> out.puttext;*)
              out.newline;
              
              'store i32 ' -> out.puttext; 
              stack.vTop - 1 -> vRegInStack -> out.puttext;
              ', i32* ' -> out.puttext;
              rNx -> emitRreg -> out.puttext;
              ', align 4\n' -> out.puttext;
          if);
          1 -> stack.rpop;
          2 -> stack.vpop
       #);     
     xrstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstore -> emit; off -> emit
          if);
          2 -> stack.rpop
       #);
     xrstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstoreg -> emit; off -> emit
          if);
          1 -> stack.rpop
       #);
     double: 
       (# 
       do ' double' -> out.putline; codes.double -> emit; 
          stack.vPush; stack.vpush 
       #);
     rdouble: 
       (# off: @integer
       enter off (*currently just used for LLVM *)
       do 'rdouble' -> emitOp; off -> out.putint; out.newline;
          (if notLLVM then
              codes.rdouble -> emit;
           else
              (if (stack.rTop < 1)  then
                  codes.rdouble->notImpl
                  (#do ' rtop:' -> Tx.puttext; stack.rtop ->tx.putint #);
                  leave rdouble
              if);
              stack.put;
              (stack.rRegNo[stack.rtop],stack.rType[stack.rtop][]) 
                -> stack.rpushT;
              (if true
               // off = -1 then
                  (if (stack.rTop < 3)  then
                      codes.rdouble->notImpl
                      (#do ' rtop:' -> Tx.puttext; stack.rtop ->tx.putint #);
                      leave rdouble
                  if);
                  stack.rRegNo[stack.rtop - 2] 
                    -> stack.rRegNo[stack.rtop - 1];
                  stack.rType[stack.rtop - 2][]
                    -> stack.rType[stack.rtop - 1][];
               // off <> 0 then
                  (* we assume that off = - 1 or 0 *)
                  codes.rdouble ->notImpl
                      (#do 'off must be 0 or -1' -> Tx.append #)
              if);
              stack.put;
          if);
       #);
     swap: (#do ' swap' -> out.putline; codes.swap -> emit #); (* not used*)
     rswap: 
       (# rn,R: @integer; T: ^text
       enter rn
       do 'rswap ' -> emitOp; rn -> out.putint; out.newline;
          (if notLLVM then              
              codes.rswap -> emit; rn -> emit
           else
              (if stack.rtop < 2 then
                  '   ;;; rswap: stack.rtop < 2' -> out.putline;
                  '\n!!!! rswap: stack.rtop < 2' -> putline;
                  leave rswap
              if);
              stack.RregNo[stack.rtop] -> R;
              stack.RregNo[stack.rtop - 1] -> stack.RregNo[stack.rtop];
              R -> stack.RregNo[stack.rtop - 1];
              stack.rType[stack.rtop][] -> T[];
              stack.rType[stack.rtop - 1][] 
                -> stack.rType[stack.rtop][];
              T[] -> stack.rType[stack.rtop - 1][]
          if)
       #);
     rPop: 
       (# 
       do 'rpop' -> emitOp; out.newline;
          (if notLLVM then
              codes.rpop -> emit; 1 -> stack.rPop 
           else
              1 -> stack.rPop;
              stack.put
          if)
       #);
     vPop: 
       (# 
       do (if notLLVM then
              ' vpop' -> out.putline; codes.vpop -> emit; 1 -> stack.vPop 
           else
              1 -> stack.vPop
          if)
       #);
     CallPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do (if notLLVM then
              ' %' -> out.puttext; P[] -> out.puttext; ' ' -> out.put; op -> out.putint;
              codes.prim -> emit; op -> emit;
              (if op 
               // prim.attach then 
                  ' ' -> out.put;
                  'D' -> out.put;
                  'D' -> emit 
               // prim.fork // prim.cmpAndSwap // prim.thisCore then
                  (* perhaps more prims require C-mode, 
                   * but we are probably shure with the above ones
                   *)
                  true -> descs.onlyCinterpreter;
              if);
           else
              (if op 
               // prim.put then
                  '   call i32 @putCh(i32 ' -> out.puttext; 
                  stack.vtop -> vRegInStack -> out.puttext;
                  ')\n' ->out.puttext;
                  1 -> stack.vpop
              if)
          if);
          out.newline;
       #);
     op: 
       (# operator: @integer; 
          LLVMvOp:
            (# opT: ^text
            enter opT[]
            do '   ' -> out.puttext;
               allocReg -> rN -> emitVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' i32 ' -> out.puttext; stack.vtop - 1 -> vRegInStack -> out.puttext;
               ', ' -> out.puttext; stack.vtop -> vRegInStack -> out.putline;
               inner
            #);
          LLVMbOp: LLVMvOp
            (#
            do 2 -> stack.vpop;
               rN -> stack.vPush;
               1 -> stack.Vtype[stack.vTop]
            #);
          LLVMboolOp:
            (# opT: ^text
            enter opT[]
            do '   ' -> out.puttext;
               allocReg -> rN -> emitVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' i1 ' -> out.puttext; stack.vtop - 1 -> vRegInStack -> out.puttext;
               ', ' -> out.puttext; stack.vtop -> vRegInStack -> out.putline;
               2 -> stack.vpop;
               rN -> stack.vPush;
               1 -> stack.Vtype[stack.vTop]
            #);
           LLVMRefRElOp:
            (# opT: ^text; rN,rNx: @integer; rIsNull,lIsNull: @boolean
            enter opT[]
            do 
               (if true
                // 'null' -> stack.rType[stack.rTop].equal then
                   true -> rIsNull
                // 'null' -> stack.rType[stack.rTop - 1].equal then
                   true -> lIsNull
                else
                   stack.rRegNo[stack.rtop] -> rNx;
                   (if stack.rType[stack.rtop][] 
                         -> stack.rType[stack.rtop - 1].equal then
                    else
                       (rNx,stack.rType[stack.rtop][]
                       ,stack.rType[stack.rtop - 1][])
                         -> bitCast
                         -> rNx                   
               if)if);
               '   ' -> out.puttext;
               allocReg -> rN -> emitVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' ' -> out.puttext;
               (if true
                // rIsNull then
                   stack.rType[stack.rtop  - 1][] -> out.puttext;
                   ' ' -> out.put;
                   stack.rtop - 1 -> rReg -> out.puttext;
                   ', null\n' -> out.puttext;
                // lIsNull then
                   stack.rType[stack.rtop][] -> out.puttext;
                   ' ' -> out.put;
                   stack.rtop -> rReg -> out.puttext;
                   ', null\n' -> out.puttext;                   
                else
                   stack.rType[stack.rtop  - 1][] -> out.puttext;
                   ' ' -> out.put;
                   stack.rtop - 1 -> rReg -> out.puttext;
                   ', ' -> out.puttext; rNx -> emitrReg -> out.putline;
               if);
               2 -> stack.rpop;
               rN -> stack.vPush;
               1 -> stack.vType[stack.vTop]
            #);
          rn: @integer
       enter operator
       do (if notLLVM then
              ' ' -> out.put; 
              (if operator
               // codes.plus then 'plus' -> out.putline; 
               // codes.minus then 'minus' -> out.putline
               // codes.mult then 'mult' -> out.putline; 
               // codes.rdiv then 'div' -> out.putline (* not used? *)
               // codes.idiv then 'idiv' -> out.putline
               // codes.modd then 'modd' -> out.putline
               // codes.eq then 'eq' -> out.putline
               // codes.lt then 'lt' -> out.putline;
               // codes.le then 'le' -> out.putline;
               // codes.gt then 'gt' -> out.putline;
               // codes.ge then 'ge' -> out.putline
               // codes.ne then 'ne' -> out.putline
               // codes.andd then 'andd' -> out.putline
               // codes.orr then 'orr' -> out.putline
               // codes.xorr then 'xorr' -> out.putline
               // codes.nott then 'nott' -> out.putline
               // codes.req then 'req' -> out.putline
               // codes.rne then 'rne' -> out.putline
               // codes.fplus then 'fplus' -> out.putline
               // codes.fminus then 'fplus' -> out.putline
               // codes.fmult then 'fmult' -> out.putline
               // codes.fdiv then 'fdiv' -> out.putline
               else
                  operator -> out.putint; out.newline
              if);
              operator -> emit;
           else
              (if operator
               // codes.plus then
                  'add' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush;
               // codes.minus then 
                   'sub' -> LLVMvOp;
                   2 -> stack.vpop;
                   rN -> stack.vPush 
               // codes.mult then 
                  'mul' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush
               // codes.rdiv then (* not used? *)
                   'div' -> out.putline
               // codes.idiv then 
                  'sdiv' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush 
               // codes.modd then 
                  'srem' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush
               // codes.eq then 
                   'icmp eq' -> LLVMbOp;
               // codes.lt then 
                  'icmp slt' -> LLVMbOp;
               // codes.le then 
                  'icmp sle' -> LLVMbOp;
               // codes.gt then
                  'icmp sgt' -> LLVMbOp
               // codes.ge then
                  'icmp sge' -> LLVMbOp
               // codes.ne then
                  'icmp ne' -> LLVMbOp                  
               // codes.andd then
                  'and' -> LLVMBoolOp;
               // codes.orr then 
                  'or' -> LLVMBoolOp;
               // codes.xorr then
                  'xor' -> LLVMBoolOp;                  
               // codes.req then 
                  'icmp eq' -> LLVMRefRelOp;
               // codes.rne then 
                  'icmp ne' -> LLVMRefRelOp;
               // codes.fplus then 'fplus' -> out.putline
               // codes.fminus then 'fplus' -> out.putline
               // codes.fmult then 'fmult' -> out.putline
               // codes.fdiv then 'fdiv' -> out.putline
               else
                  operator -> out.putint; out.newline
              if);
          if)
       #);
     i2f: (# do ' i2f' -> out.putline; codes.i2f -> emit #);
     f2i: (# do ' f2i' -> out.putline; codes.f2i -> emit #);
     req: (# do ' req' -> out.putline; codes.req -> emit #);
     rne: (# do ' rne' -> out.putline; codes.rne -> emit #);
     seq: (# do ' req' -> out.putline; codes.seq -> emit #);
     sne: (# do ' rne' -> out.putline; codes.sne -> emit #);    
     uminus: 
       (# 
       do ' u-' -> out.putline; 
          codes.uminus -> emit
       #);
     nott: (# do ' not' -> out.putline; codes.nott -> emit #);
     saveBETAworld: 
       (#
       do (if notLLVM then
              ' saveBETAworld' -> out.putline; 
              codes.saveBETAworld -> emit
           else
              '   ;; saveBETAworld\n' -> out.puttext;
              1 -> stack.rPop
          if)
       #);
     saveStringOrigin:
       (#
       do (if notLLVM then
              ' saveStringOrigin' -> out.putline;
              codes.saveStringOrigin -> emit
           else
              '   ;; saveStringOrigin' -> out.putline;
          if)
       #);
     isMarked: [32] @boolean;
     initGCinfo: (#do (for i: isMarked.range repeat false-> isMarked[i] for)#);
     addGCinfo:
       (# add: 
            (# off: @integer
            enter off 
            do (if off > isMarked.range then
                   isMarked.range -> isMarked.extend 
               if);
               (if not isMarked[off] then
                   off -> descs.current.GCinfo.add;
                   true -> isMarked[off]
               if)
            #);
       do inner
       #);
     endClass: 
       (# objSize,OSDvisibility: @integer;
          isIndexed: @boolean;
          V: @integer
       enter(objSize,isIndexed,OSDvisibility)
       do (if notLLVM then
              ' end OSDV:' -> out.puttext; OSDvisibility -> out.putint; 
              ' objSize:'->out.puttext; objSize -> out.putint;  
              ' isIndexed:'->out.puttext; 
              (if isIndexed then 1 -> V else 0 -> V if);
              V -> out.putint;  ' '-> out.put;
              stack.put;
              out.newline;
              objSize -> descs.current.objSize;
              V -> descs.current.isIndexed; 
              OSDvisibility -> descs.current.OSDvisibility;     
              (if OSDvisibility > 0 then
                  (*'\n**** OSDvisibility: ' -> puttext; 
                   OSDvisibility -> putint; newline*)
              if);
              labs.saveInImage ;
           else
              '}' -> out.putline;
          if)
       #);
     mkLLVMvirtualDefs:
       (# hasVDTorInner:< BooleanValue
            (#
            do (for i: descs.current.vdtTable.range repeat
                    (if (descs.current.vdtTable[i] > 0 -> value) then
                        leave hasVDTorInner
               if)for);
               inner; (* check if inner *)
            #);
          vName:< 
            (# dn: @integer; vN,orgOfVN: ^text 
            enter dn
            do inner;
               vN[] -> filter -> vN[] 
            exit(vN[],orgOfVN[])
            #);
          mkVdtType:
            (# T,N,orgOfN: ^text;
            do '%vdt_type$' -> T[];
               thisClassId[] -> filter -> T.puttext;
               ' = type {' -> T.puttext;
               (for i: descs.current.vdtTop repeat
                    (if (descs.current.vdtTable[i] -> dN) > 0 then
                        (if descs.current.isInner[i] then
                            dN -> vName -> (N[],orgOfN[]);
                            (if newFeature then
                                ('*'->('%'->N.prepend).put,dn) 
                                  -> funcPtrType -> T.puttext
                             else
                                '%' -> T.put;
                                N[] -> T.puttext;
                                '*(%' -> T.puttext;
                                N[] -> T.puttext; '*' -> T.put;
                                (if isValueObject then
                                    ', i32' -> T.puttext;
                                 else
                                    (if newFeature then
                                        ', ' -> T.puttext;
                                        orgOfN[] -> mkLLVMstructName 
                                          -> T.puttext;
                                    '*' -> T.put; 
                                    if)
                                if);
                                ')*' -> T.puttext
                            if);
                         else
                            '%vdt_ret$' -> T.puttext;
                            dn -> vName -> (N[],orgOfN[]);
                            N[] -> T.puttext;
                            '*()*' -> T.puttext;
                        if)
                     else
                        (if isValueObject then
                            'i8*(i8*,i32)*' -> T.puttext
                         else
                            'i8*(i8*)*' -> T.puttext
                        if)
                    if);
                    (if i < descs.current.vdtTop then
                        ',' -> T.put
               if)for);
               '}\n' -> T.puttext;
               (if typeInfo.dsc[descs.current.descInx][] = none then
                   '\n!!!! mkVdtType: '
                   'typeInfo.dsc[descs.current.descInx][] = none' 
                     -> putline;
                   '!!   vdtType: ' -> puttext; T[] -> putline
                else
                   T[] -> typeInfo.dsc[descs.current.descInx].vdtType[];
               if);
            #);
          mkVdtData:
            (# orgOfVN,T: ^text; dM: @integer
            do '\n@vdt_data$' -> out.puttext; thisClassId[] -> out.puttext;
               ' = global %vdt_type$' -> out.puttext;
               thisClassId[] -> filter -> out.puttext;
               ' {' -> out.puttext;
               (for i: descs.current.vdtTop repeat
                    '\n      ' -> out.puttext;
                    (if (descs.current.vdtTable[i] -> dN) > 0 then
                        (if descs.current.isInner[i] then
                            (if newFeature then
                                dN -> vName -> (T[],orgOfVN[]);
                                '*' -> ('%' -> T.prepend).put -> T[];
                                (T[],dN) -> funcPtrType -> out.puttext;
                                
                             else
                                '%' -> out.put;
                                dN -> vName -> (T[],orgOfVN[]);
                                T[] -> out.puttext;
                                '*(%' -> out.puttext;
                                dN -> vName -> (T[],orgOfVN[]);
                                T[] -> out.puttext;
                                '*' -> out.puttext;
                                (if isValueObject then
                                    ', i32' -> out.puttext;
                                if);
                                ')* ' -> out.puttext;
                            if);
                            '@' -> out.puttext;
                            dN -> vName -> (T[],orgOfVN[]);
                            T[] -> out.puttext;
                         else
                            '%vdt_ret$' -> out.puttext; 
                            dN -> vName -> (T[],orgOfVN[]);
                            T[] -> out.puttext;
                            '* ()*' -> out.puttext;
                            ' @vdt_alloc$' -> out.puttext;
                            dN -> vName -> (T[],orgOfVN[]);
                            T[] -> out.puttext;
                        if)
                     else
                        'i8* (i8* )* null' -> out.puttext
                    if);
                    (if i < descs.current.vdtTop then
                        ',' -> out.put
               if)for);
               '\n}\n' -> out.puttext
            #);
          mkVdtRet:
            (# T: ^Text
            do '%vdt_ret$' -> T[];               
               thisClassId[] -> T.puttext;
               ' = type{' -> T.puttext;
               PthisClassN[] -> T.puttext;
               ',' -> T.put;
               (if newFeature then
                   (PthisClassN[],thisClassDescNo) -> funcPtrType -> T.puttext;
                   '}\n' -> T.puttext;
                else
                   PthisClassN[] -> T.puttext; '(' -> T.put;
                   PthisClassN[] -> T.puttext; 
                   (if isValueObject then
                       ', i32' -> T.puttext
                   if);
                   ')*}\n' -> T.puttext;
               if);
               (if typeInfo.dsc[descs.current.descInx][] = none then
                   '\n!!!! mkVdtRet: '
                   'typeInfo.dsc[descs.current.descInx][] = none' -> putline;
                   '!!    vdtRet: ' -> puttext; T[] -> putline
                else
                   T[] -> typeInfo.dsc[descs.current.descInx].vdtRet[]
               if)
            #);
          mkVDTalloc:
            (# rNx,rNy,rNz,rNv: @integer; vdt_ret_type,funcPT: ^text
            do (if traceLLVMcalls then
                   (thisClassId[],'vdt_ret$') -> defTraceString -> out.puttext
               if);
               
               '\ndefine %vdt_ret$' -> out.puttext;
               thisClassId[] -> out.puttext;
               '* @vdt_alloc$' -> out.puttext;
               thisClassId[] -> out.puttext;               
               '(){\n' -> out.puttext;
               
               (if traceLLVMcalls then
                   thisClassId[] -> putTrace -> out.puttext
               if);
               
               '%vdt_ret$' -> vdt_ret_type[];
               thisClassId[] -> vdt_ret_type.append;
               
               (vdt_ret_type[],118,8) -> allocRTObj -> rNx;
               (thisClassN[],thisClassDescNo,48) -> allocQbetaObj -> rNy;
               
               (rNx,vdt_ret_type[],0) -> leaReg -> rNz;

               'store ' -> out.puttext; 
               PthisClassN[]  -> out.puttext;
               ' ' -> out.put;
               rNy -> emitRreg -> out.puttext;
               ', ' -> out.puttext;
               PthisClassN[] -> out.puttext; 
               '* ' -> out.puttext;
               rNz -> emitRreg  -> out.putline;
               
               (rNx,vdt_ret_type[],1) -> leaReg -> rNv;

               (PthisClassN[],thisClassDescNo) -> funcPtrType -> funcPT[];
               '\tstore ' -> out.puttext;
               funcPT[] -> out.puttext; 
               ' @' -> out.puttext; thisClassId[] -> out.puttext;
               ', ' -> out.puttext;
               
               funcPT[] -> out.puttext;
               '* ' -> out.puttext;
               rNv -> emitRreg -> out.puttext;
               
               '\n   ret %vdt_ret$' -> out.puttext;
               thisClassId[] -> out.puttext;
               '* ' -> out.puttext; rNx -> emitRreg -> out.puttext;
               '\n}\n' -> out.puttext;
            #);
          dn: @integer
       do (if not notLLVM then
              (if true or hasVDTorInner then
                  '   ;; vdt:vdtTop: ' -> out.puttext;
                  descs.current.vdtTop -> out.putint; ' ' -> out.put;
                  (for i: descs.current.vdtTop repeat
                       descs.current.vdtTable[i] -> out.putint;
                       ':' -> out.put;
                       (if descs.current.isInner[i] then
                           'I' -> out.put
                        else
                           'V' -> out.put
                       if);
                       (if i < descs.current.vdtTop then 
                           ',' -> out.put
                  if)for);
                  out.newline;
                  mkVdtType;
                  mkVdtData;
                  inner;
              if);
              mkVdtRet;
              mkVDTalloc;
              false -> isValueObject
          if)
       #);
     close:
       (#
       do VdtPatch.patch;         
          (if notLLVM then dump if)
       #);
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
               0 -> loc.new; 
               0 -> use.new
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (*'labs.def:labNo: ' -> puttext; labNo -> putint; 
               ' range: ' -> puttext; loc.range -> putint;*)
               (if labNo > loc.range then labNo - loc.range -> loc.extend if);
               (if labNo > use.range then labNo - use.range -> use.extend if); (*ugly*)
               (* ' labs.def:new:range: ' -> puttext; loc.range -> putint;
               newline;*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          saveInImage:
            (# 
            do (*'saveInImage: ' -> puttext; loc.range -> putint; newline;*)
               loc.range -> descs.current.labs.new;
               (for i: loc.range repeat
                   loc[i] -> descs.current.labs[i]
               for)
            #);            
          loc: [0] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [0] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
     dump: (# do descs.dump #);
     
     out: ^Stream;
     
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     emit8: (# enter descs.current.bc.emit8 #);
     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     prim: @ Primitives
  #);

