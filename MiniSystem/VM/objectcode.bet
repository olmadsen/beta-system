ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'Primitives';
INCLUDE 'betaVM';
---lib:attributes---
ObjectCode:
  (# init:<
       (#
       enter out[]
       do vdtPatch.init;
          inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comment:
       (# T: ^text
       enter T[]
       do '\t-- ' -> out.puttext; T[] -> out.putline
       #);
     comB:
       (# T: ^text
       enter T[]
       do '\t-- ' -> out.puttext; T[] -> out.puttext
       #);
     comA: 
       (# T: ^text
       enter T[]
       do T[] -> out.puttext
       #);
     comE:
       (# T: ^text
       enter T[]
       do T[] -> out.putline
       #);
     com2:
       (# T1,T2: ^text
       enter(T1[],T2[])
       do '\t-- ' -> out.puttext; T1[] -> out.puttext; 
          ' ' -> out.put; T2[] -> out.putline
       #);
     com: 
       (# II: (# enter Tx.putint do ' ' -> Tx.put #);
          TT: 
            (# S: ^text; Q: @text; i: @integer; inText: @boolean
            enter S[]
            do (if S[] <> none then
                   L:
                     S.scanAll
                     (#
                     do (if ch 
                         // '"' then
                            '"' -> Q.put;
                            not inText -> inText
                         // ascii.newline then
                            ' ' -> Q.put; '|' -> Q.put; ' ' -> Q.put 
                         else
                            ch -> Q.put
                        if);
                        (if (i + 1 -> i) > 65 then 
                            ' ...' -> Q.puttext;     
                            (if inText then '"'-> Q.put if);
                            leave L 
                        if)
                     #)
                else
                   '-none-' -> Tx.puttext
               if);
               Q[] -> Tx.puttext
            #);
          TQ:
            (# S: ^Text
            enter S[]
            do '"' -> Tx.put;
               S[] -> TT;
               '"' -> Tx.put; ' ' -> Tx.put
            #);
          BB: 
            (# Bx: @boolean 
            enter Bx do (if Bx then 'true' -> TX.puttext else 'false' -> TX.puttext if)
            #);
          CC: (# ch: @char enter ch do ch -> Tx.put #);
          print: (# do '***** ' -> puttext; Tx[] -> putline #);
          Tx: @Text
       do inner; Tx.newline; '\t-- ' -> out.puttext; Tx[] -> out.puttext;
       #);          
     newComponent:
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do '\tcomponent ' -> out.puttext; N[] -> out.puttext; 
          ' NoOfDescs: ' -> out.puttext; noOfDescs -> out.putint; out.newline;
          noOfDescs + 3 -> descs.top -> descs.OD.new; (* noOfDesc + 2 since an extra
                                                       * desc is allocated for main 
                                                       * and EventProcessor
                                                       *)
       #);
     stack: @
       (# rTop,vTop,rTopMax,vTopMax: @integer;
          init: (#do 0 -> rTop -> vTop -> rTopMax -> vTopMax #);
          vpush:
            (#
            do (if (vTop + 1 -> vTop) > vTopMax then vTop -> vTopMax if)
            #);
          vpop: (# n: @integer enter n do vTop - n -> vTop #);
          rpush:
            (#
            do (if (rTop + 1 -> rTop) > rTopMax then rTop -> rTopMax if)
            #);
          rpop: (# n: @integer enter n do rTop - n -> rTop #);
          print: 
            (# T: @text
            do ' vTop:' -> T.puttext; vTop -> T.putint;
               ' vTopMax:' -> T.puttext; vTopMax -> T.putint;
               ' rTop:' -> T.puttext; rTop -> T.putint;
               ' rTopMax:' -> T.puttext; rTopMax -> T.putint;
            exit T[]
            #)
     #);
     class:
       (# dumpClass:
            (#
            do '\n\n*** Fatal error in objectCode: *** Class: ' -> puttext; 
               N[] -> puttext; ' descNo = '->puttext; descNo -> putint;
            #);
          N: ^text; descNo,topDescNo,originOff: @integer;
          procE: @boolean; (* mark start of byte code as proc-entry and enter-entry *)
       enter(N[],descNo,procE,topDescNo,originOff)
       do '\n\tclass ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
          descNo -> out.putint; ' ' -> out.put;
          originOff -> out.putint; out.newline;
          (if descNo = 0 then
              dumpClass;
              ' is ZERO!' -> putline
          if);
          (N[],descNo,originOff,out[]) -> descs.setCurrent;
          (if descs.OD[topDescNo][]= none then 
              dumpClass;
              ' descs.OD[topDescNo='->puttext; 
              topDescNo -> putint;
              '][]= none' -> putline
           else
              (topDescNo,descs.OD[topDescNo].bc[]) -> descs.current.setSuperBC;
          if);
          descs.markAllocE;
          (if procE then 
              'procE:' -> puttext; N[] -> putline;
              descs.markProcE if);
          initGCinfo;
          labs.init;
          stack.init
       #);
     super: 
       (# N: ^text; superDescNo: @integer
       enter(N[],superDescNo)
       do '\t-- super ' -> out.puttext; N[] -> out.putline;
          descs.OD[superDescNo][] -> descs.current.superObjDesc[]
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do 'ENTER:' -> out.putline
       #);
     setThisStack:
       (#
       do '\tsetThisStack ' -> out.putline;
          codes.setThisStack -> emit
       #);
     rpopThisObj:
       (#
       do '\trpopThisObj ' -> out.putline;
          codes.rpopThisObj -> emit
       #);       
     actions:
       (# hasSuper,genDoEvent: @boolean
       enter(hasSuper,genDoEvent)
       do 'DO:'->out.putline;
          descs.markDoE;
          (if genDoEvent then doEventQ if);          
       #);
     mvStack:
       (#
       do '\tmvStack '->out.putline; codes.mvstack -> emit 
       #);
     markExitE: (# do descs.markExitE #);
     doExit:
       (#
       do 'EXIT:' -> out.putline; 
          '\tdoExit ' -> out.putline; 
          codes.doExit -> emit
       #);
     rtn: 
       (# LMR: @char
       enter LMR 
       do '\trtn(' -> out.puttext; LMR->out.put; ')' -> out.put; out.newline;
          codes.rtn -> emit ; LMR -> emit
       #);
     rtnV: (*rtnValue*)(#do '\trtnV\n' -> out.puttext;  codes.rtnV -> emit #);
     rtnC: (# do '\trtnC' -> out.putline; codes.rtnC -> emit #);
     rtnExit: (# do '\trtnExit' -> out.putline; codes.rtnExit -> emit #);
     rtnInner: (# do '\trtnInner' -> out.putline; codes.rtnInner -> emit #);
     rtnEvent: 
       (# hasExit: @integer 
       enter hasExit 
       do '\trtnEvent ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEvent -> emit;
          hasExit -> emit
       #);
     allocEventQ:
       (# asObj: @boolean
       enter asObj
       do '\tallocEventQ\n' -> out.puttext;
          codes.allocEventQ -> emit;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     rtnEventQ: 
       (# hasExit: @integer 
       enter hasExit 
       do '\trtnEventQ ' -> out.puttext; hasExit -> out.putint; out.newline;
          codes.rtnEventQ -> emit;
          hasExit -> emit
       #);
     doEventQ:
       (#
       do '\tdoEventQ\n' -> out.puttext;
          codes.doEventQ -> emit
       #);
     stop: (# do '\tstop' -> out.putline; codes.stop -> emit #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          'D' -> rtn          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do ' L' -> out.puttext; lab -> out.putint; ':' -> out.put; out.newline;
          lab -> labs.def;
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do '\tjmpIf_GT L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       do '\tjmp L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmp -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpFalse:
       (# lab: @integer 
       enter lab 
       do '\tjmpFalse L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpFalse -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do '\tjmpTrue L' -> out.puttext; lab -> out.putint; out.newline;
          codes.jmpTrue -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     break:
       (# on,lab,descInx: @integer
       enter(on,lab,descInx)
       do '\tbreak ' -> out.puttext; on -> out.putint; ' ' -> out.put; 
          lab -> out.putint; ' ' -> out.put; descInx -> out.putint;
          out.newline;
          codes.break -> emit;
          on -> emit; 
          (if lab = 0 then
              '\n***** Fatal error break: lsc=0' -> putline
          if);
          lab -> emit2;
          descInx -> emit2
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          asObj: @boolean; (* True if a 'real' object; false if method activation *)
       enter(N[],descNo,asObj) 
       do '\talloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if asObj then ' asObj'-> out.puttext if); out.newline;
          codes.alloc -> emit; descNo -> emit2;
          (if asObj then 1 -> emit else 0 -> emit if)
       #);
     invoke: 
        (# N: ^text; descNo,staticOff: @integer; asObj: @boolean; iO: @integer
       enter(N[],descNo,staticOff,asObj) 
        do '\tinvoke ' -> out.puttext; N[] -> out.puttext; 
           ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
           staticOff -> out.putint; ' ' -> out.put;
           (if asObj then 1 -> iO else 0 -> iO if);
           io -> out.putint;
           out.newline;
           codes.invoke -> emit; descNo -> emit2; staticOff -> emit2;
           iO -> emit
        #);
     saveAndSetThis:
       (#
       do '\tsaveAndSetThis ' -> out.putline;
          codes.saveAndSetThis -> emit
       #);
     restoreThis:
       (#
       do  '\trestoreThis ' -> out.putline;
          codes.restoreThis -> emit
       #);
     invokeVal:
         (# N: ^text; descNo,staticOff: @integer
       enter(N[],descNo,staticOff) 
         do '\tinvokeVal ' -> out.puttext; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
           staticOff -> out.putint; out.newline;
           codes.invokeVal -> emit; descNo -> emit2; staticOff -> emit2
        #);
     invokeExternal:
       (# N: ^text; externalNo: @integer
       enter(N[],externalNo)
       do '\tinvokeExternal ' -> out.puttext; externalNo -> out.putint; 
          out.newline;
          codes.invokeExternal -> emit; externalNo -> emit
       #);
     allocIndexed:
         (# N: ^text; descNo,size,isRefIndexed: @integer;
       enter(N[],descNo,size,isRefIndexed) 
         do '\tallocIndexed ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put; 
            descNo -> out.putint; ' ' -> out.put; 
            size -> out.putint; ' ' -> out.put; 
            isRefIndexed -> out.putint; out.newline;            
            codes.allocIndexed -> emit; descNo -> emit2; size-> emit; isRefIndexed -> emit
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do '\texeAlloc ' -> out.puttext; descNo -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit2
       #);
       
     newVrep: (# do '\tnewVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do '\tsend ' -> out.puttext; inx -> out.putint; ' ' -> out.put;  N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     sendVirtual: 
       (# N: ^text; dinx: @integer 
       enter(N[],dinx) 
       do '\tsendv ' -> out.puttext; dinx -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.sendv -> emit; dinx -> emit;
       #);
     invokev:
       (# N: ^text; dinx: @integer 
       enter(N[],dinx) 
       do '\tinvokev ' -> out.puttext; dinx -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.invokev -> emit; dinx -> emit;
       #);
     exe: (# N: ^text enter N[] do '\texe ' -> out.puttext; N[] -> out.putline #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do '\tcall(' -> out.puttext; LMR -> out.put; ')' -> out.put;
          N[] -> out.putline; 
          codes.call -> emit;
          LMR -> emit
       #);
     vdtTablePrint:
       (# descNo: @integer; T: @text
       enter descNo
       do 'vdtTable:Q: ' -> T.puttext;
          (for i: descs.OD[descNo].vdtTable.range repeat 
               (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[descNo].vdtTable[i] -> T.putint;
               inner
          for); 
          T[] -> comment          
       #);
     vdtTableCopy:
       (# superDescNo: @integer; T: @text
       enter superDescNo
       do (for i: descs.OD[superDescNo].vdtTable.range repeat (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[superDescNo].vdtTable[i] -> T.putint; 
               (i,descs.OD[superDescNo].vdtTable[i]) -> descs.current.vdtAdd
          for); 
          T[] -> comment;
          (* copy literals from super to current *)
          descs.OD[superDescNo].literals.range 
            -> descs.current.litTop
            -> descs.current.literals.new;
          (for i: descs.current.litTop repeat
               (*descs.OD[superDescNo].literals[i] -> putint; ',' -> put;*)
               descs.OD[superDescNo].literals[i] -> descs.current.literals[i]
          for);
          (*newline;*)
       #);
     vdtTable:
       (# inx,descInx: @integer
       enter(inx,descInx)
       do (inx,descInx) -> descs.current.vdtAdd -> comment
       #);
     vdtTableAt:
        (# inx,descInx,descNo: @integer
        enter(inx,descInx,descNo)
        do(* ' vdtTableAt: ' -> puttext;
           inx -> putint; ' ' -> put;
           descInx -> putint; ' ' -> put;
           descNo -> putint; newline;*)
           (inx,descInx,descNo) -> VdtPatch.add
        #);
     VdtPatch: @
       (# index,bindInx,descInx:[5] @ integer; top: @integer;
          init: (# do 0 -> top #);
          add:
            (# ix,bx,dx: @integer
            enter (ix,bx,dx)
            do (if (top + 1 -> top) > index.range then
                   index.range -> index.extend;
                   bindInx.range -> bindInx.extend;
                   descInx.range -> descInx.extend;
               if);
               ix -> index[top];
               bx -> bindInx[top];
               dx -> descInx[top];
            #);
          patch:
            (#
            do (for i: top repeat
                  (*'Patch: ' -> puttext; index[i] -> putint; ' ' -> put;
                   * bindinx[i] -> putint; ' ' -> put;
                   * descInx[i] -> putint;  ' ' -> put;  *)                    
                    (index[i],bindInx[i]) 
                      -> descs.OD[descInx[i]].vdtAdd -> comment
               for)
            #)
       #);
     toSuper:
       (# descInx: @integer
       enter descInx
       do '\ttoSuper ' -> out.puttext;
          descInx -> out.putint; out.newline;
          codes.toSuper -> emit; descInx -> emit2
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do '\tinnerX ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerx -> emit; inx -> emit;
       #);
     innerP: (* Inner P, where P.ON > 1 *)
       (# inx: @integer 
       enter inx
       do '\tinnerP ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerP -> emit; inx -> emit;
          1 -> stack.rPop
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do '\tinnerExit ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;

       #);
     innerA:
       (# inx: @integer 
       enter inx
       do '\tinnerA ' -> out.puttext; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerA -> emit; inx -> emit;
       #);
     suspendd: (# do '\tsuspend' -> out.putline; codes.susp -> emit #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do '\tdoSuper' -> out.puttext; ' ' -> out.put; N[] -> out.puttext; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit2;
       #);

     pushThis:
       (# 
       do '\tpushThis ' -> out.putline;
          codes.pushthis -> emit; 
          stack.rPush
       #);
     addOff:
       (# off: @integer
       enter off
       do '\taddOff ' -> out.puttext; off -> out.putint; out.newline;
          codes.addOff -> emit; off -> emit2;
          stack.vPush
       #);
     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.push -> emit; off -> emit;
          stack.vPush
       #);
     pushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.pushg -> emit; off -> emit;
       #);
     ovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tovpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.ovpushg -> emit; off -> emit;
       #);
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\trpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit;
          stack.rPush
       #);
     rpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\trpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.rpushg -> emit; off -> emit;
       #);
     xpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xpush -> emit; off -> emit;
          stack.rPush
       #);
     xpushg:
       (# N: ^text; off,isValueObj,size: @integer
       enter(N[],off,isValueObj,size) 
       do '\txpushg ' -> out.puttext; N[] -> out.puttext;  ' ' -> out.put; 
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;  
          codes.xpushg -> emit; off -> emit; isValueObj -> emit; size -> emit;
          stack.vPush
       #);
     xrpush:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txrpush ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xrpush -> emit; off -> emit;
       #);    
     xrpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txrpushg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.xrpushg -> emit; off -> emit;
       #);
     pushConst: 
       (# cst: @integer
       enter cst
       do '\tpushc ' -> out.puttext; cst -> out.putint; out.newline;
          (if true 
           // cst <= 255 then
              codes.pushc -> emit;
              cst -> emit
           // cst <= 255 * 255  then
              codes.pushc2 -> emit;
              cst -> emit2
           else 
              'OBS! Constant >= 2^16 is not implemented' -> comment
          if);
          stack.vPush
       #);
     pushNone: 
       (# 
       do '\tpushNone' -> out.puttext; out.newline;
          codes.pushNone -> emit;
          stack.rPush
       #);
     pushText:
       (# T,T1: ^text; I: @integer
       enter T[]
       do '\tpushText ' -> out.puttext; T[] -> out.putline;
          codes.pushText -> emit;
          T[] -> handleEscape -> T1[];
          (* 'PushText: ' -> puttext; T1[] -> putline;*)
          T1.length -> descs.current.addLiteral
          (#
          do i + 1 -> i -> T1.inxGet -> value;
          #) -> emit;
          stack.rPush
       #);
     handleEscape:
       (# T: ^text; T1: @text;
          nextCh: 
            (# 
            do i + 1 -> i;
               (if i <= T.length then
                   i -> T.inxGet -> ch;
                else
                   0 -> ch
               if);               
            #);
          ch: @char;
          i: @integer
       enter T[]
       do 0 -> i;
          nextCh;
          loop:
            (if i <= T.length then 
                (if ch 
                 // '\\' then 
                    nextCh;
                    (if ch
                     // 'n' then
                        ascii.nl -> T1.put;
                        nextch
                     // '\\' then
                        '\\' -> T1.put;
                        nextch;
                     else
                        '\\' -> T1.put
                    if)
                 else
                    ch -> T1.put;
                    nextCh;                    
                if);
                restart loop
            if)
       exit T1[]
       #);
     mkStrucRef:
       (# T: ^text
       enter T[]
       do '\tmkStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkStrucRef -> emit
       #);
      mkObjStrucRef:
       (# T: ^text
       enter T[]
       do '\tmkObjStrucRef ' -> out.puttext; T[] -> out.putline;
          codes.mkObjStrucRef -> emit
       #);
     mkVirtualStrucRef:
       (# T: ^text; off: @integer
       enter(T[],off)
       do '\tmkVirtualStrucRef ' -> out.puttext; off-> out.putint; out.newline;
          codes.mkVirtualStrucRef -> emit; off -> emit
       #);
     allocFromStrucRefObj:
       (#
       do '\tallocFromStrucRefObj ' -> out.putline;
          codes.allocFromStrucRefObj -> emit;
       #);
     pushValue:
       (# size: @integer
       enter size
       do '\tpushvalue ' -> out.puttext; size -> out.putint; out.newline;
          codes.pushValue -> emit; size -> emit;
       #);
     vassign:
       (# size,mode: @integer
       enter(size,mode)
       do '\tvassign ' -> out.puttext; size -> out.putint; ' ' -> out.put;
          mode -> out.putint; out.newline;
          codes.vassign -> emit; size -> emit; mode -> emit
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\tstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.store -> emit; off -> emit;
          1 -> stack.vpop
       #);
     storeg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\tstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          codes.storeg -> emit; off -> emit;
          1 -> stack.vpop          
       #);
     ovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\tovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.ovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);
     rstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\trstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstore -> emit; off -> emit
          if);
          1 -> stack.rPop
       #);
     rstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\trstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.rstoreg -> emit; off -> emit
          if);
          2 -> stack.rPop
       #);
     xstore: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do '\txstore ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put;  
          off -> out.putint; out.newline;
          (if off <= 255 then 
              codes.xstore -> emit; off -> emit
          if);
          1 -> stack.vpop
       #);
     xstoreg: 
       (# N: ^text; off,isValueObj,size: @integer
       enter(N[],off,isValueObj,size) 
       do '\txstoreg ' -> out.puttext; N[] -> out.puttext; ' ' -> out.put;
          off -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; ' ' -> out.put; 
          size -> out.putint; out.newline;          
          off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xstoreg -> emit; off -> emit; isValueObj -> emit; size -> emit; 
          if);
          2 -> stack.vpop
       #);     
     xrstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\txrstore ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstore -> emit; off -> emit
          if);
          2 -> stack.rpop
       #);
     xrstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do '\txrstoreg ' -> out.puttext; off -> out.putint; ' ' -> out.put; N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstoreg -> emit; off -> emit
          if);
          1 -> stack.rpop
       #);
     double: 
       (# 
       do '\tdouble' -> out.putline; codes.double -> emit; 
          stack.vPush; stack.vpush 
       #);
     rdouble: 
       (# do '\trdouble' -> out.putline; codes.rdouble -> emit;
          stack.rPush; stack.rpush           
       #);
     swap: (# do '\tswap' -> out.putline; codes.swap -> emit #); (* not in use*)
     rswap: (# do '\trswap' -> out.putline; codes.rswap -> emit #);
     rPop: (# do '\trpop' -> out.putline; codes.rpop -> emit; 1 -> stack.rPop #);
     vPop: (# do '\tvpop' -> out.putline; codes.vpop -> emit; 1 -> stack.vPop #);
     CallPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do '\t%' -> out.puttext; P[] -> out.puttext; ' ' -> out.put; op -> out.putint;
          codes.prim -> emit; op -> emit;
          (if op = prim.attach then 
              ' ' -> out.put;
              'D' -> out.put;
              'D' -> emit 
          if);
          out.newline;
       #);
     op: 
       (# operator: @integer
       enter operator
       do '\t' -> out.put; 
          (if operator
           // codes.plus then 'plus' -> out.putline
           // codes.minus then 'minus' -> out.putline
           // codes.eq then 'eq' -> out.putline
           // codes.lt then 'lt' -> out.putline;
           // codes.le then 'le' -> out.putline;
           // codes.gt then 'gt' -> out.putline
           // codes.ge then 'ge' -> out.putline
           // codes.ne then 'ne' -> out.putline
           // codes.andd then 'andd' -> out.putline
           // codes.req then 'req' -> out.putline
           // codes.rne then 'rne' -> out.putline
           else
              operator -> out.putint; out.newline
          if);
          operator -> emit;
          1 -> stack.vpop
       #);
     req: (# do '\treq' -> out.putline; codes.req -> emit #);
     rne: (# do '\trne' -> out.putline; codes.rne -> emit #);
     seq: (# do '\treq' -> out.putline; codes.seq -> emit #);
     sne: (# do '\trne' -> out.putline; codes.sne -> emit #);    
     uminus: 
       (# 
       do '\tu-' -> out.putline; 
          codes.uminus -> emit
       #);
     nott: (# do '\tnot' -> out.putline; codes.nott -> emit #);
     saveBETAworld: 
       (#
       do '\tsaveBETAworld' -> out.putline; 
          codes.saveBETAworld -> emit
       #);
     isMarked: [32] @boolean;
     initGCinfo: (#do (for i: isMarked.range repeat false-> isMarked[i] for)#);
     addGCinfo:
       (# add: 
            (# off: @integer 
            enter off 
            do (*off -> putint; ' ' -> put;*)
               (if off > isMarked.range then
                   isMarked.range -> isMarked.extend if);
               (if not isMarked[off] then
                   off -> descs.current.GCinfo.add;
                   true -> isMarked[off]
               if)
            #);
       do inner
       #);
     endClass: 
       (# objSize,OSDvisibility: @integer;
          isIndexed: @boolean;
          V: @integer
       enter(objSize,isIndexed,OSDvisibility)
       do '\tend OSDV:' -> out.puttext; OSDvisibility -> out.putint; 
          ' objSize:'->out.puttext; objSize -> out.putint;  
          ' isIndexed:'->out.puttext; 
          (if isIndexed then 1 -> V else 0 -> V if);
          V -> out.putint;  ' '-> out.put;
          stack.print -> out.puttext;
          out.newline;
          objSize -> descs.current.objSize;
          V -> descs.current.isIndexed; 
          OSDvisibility -> descs.current.OSDvisibility;     
          (if OSDvisibility > 0 then
              (*'\n**** OSDvisibility: ' -> puttext; 
              OSDvisibility -> putint; newline*)
          if);
          labs.saveInImage 
       #);
     
     close:
       (#
       do VdtPatch.patch;         
          dump;
       #);
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
               0 -> loc.new; 
               0 -> use.new
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (*'labs.def:labNo: ' -> puttext; labNo -> putint; 
               ' range: ' -> puttext; loc.range -> putint;*)
               (if labNo > loc.range then labNo - loc.range -> loc.extend if);
               (if labNo > use.range then labNo - use.range -> use.extend if); (*ugly*)
               (* ' labs.def:new:range: ' -> puttext; loc.range -> putint;
               newline;*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          saveInImage:
            (# 
            do (*'saveInImage: ' -> puttext; loc.range -> putint; newline;*)
               loc.range -> descs.current.labs.new;
               (for i: loc.range repeat
                   loc[i] -> descs.current.labs[i]
               for)
            #);            
          loc: [0] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [0] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
    dump: (# do descs.dump #);
     
     out: ^Stream;
     
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     
     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     prim: @ Primitives
  #);

