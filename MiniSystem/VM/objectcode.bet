ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectImage';
INCLUDE 'Primitives';
INCLUDE 'betaVM';
INCLUDE 'LLVMlib';
---lib:attributes---

ObjectCode:
  (# newFeature,notLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs: @ boolean;
     init:<
       (# emitLLVM: @boolean
       enter(out[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs)
       do not emitLLVM -> notLLVM;
          vdtPatch.init;
          inner
       #);
     bcPos: (# exit descs.current.bc.pos #);
     comS: 
       (# II: (# enter Tx.putint do ' ' -> Tx.put; i + 3 ->i;  #); i: @integer; 
          TT: 
            (# S: ^text; Q: @text; (*i: @integer;*) inText,hasNL: @boolean;
               noSpace:< BooleanValue
            enter S[]
            do (if S[] <> none then
                   L:
                     S.scanAll
                     (#
                     do (if ch 
                         // '"' then
                            not inText -> inText;
                         // ascii.newline then
                            ' \\\n-- '->Q.puttext; 0 -> i;
                         else
                            ch -> Q.put
                        if);
                        (if (i + 1 -> i) > 70 (*(170 - Tx.length)*) then 
                            ' \\\n-- '->Q.puttext; 0 -> i;
                     if)#);
                else
                   '-none-' -> Tx.puttext
               if);
               Q[] -> Tx.puttext;
               (if not noSpace then ' ' -> Tx.put if)
            #);
          TL:
            (# S: ^text; Q: @text; n: @integer; inText: @Boolean;
               hasNL: BooleanValue
                 (#
                 do L:
                      S.scanAll
                      (#
                      do (if (ch = ascii.newline) -> value then leave L if)#)
                 #); 
            enter S[]
            do (if S[] <> none then
                   (if hasNL then '\n-- '-> Q.puttext if);
                   L:
                     S.scanAll
                     (#
                     do (if ch 
                         // '"' then
                            '"' -> Q.put;
                            not inText -> inText
                         // ascii.newline then
                            (if inText then '"' -> Q.put; false -> inText if);
                            (if (n + 1 -> n) > 3 then leave L if);
                            ' \\\n-- ' -> Q.puttext;
                         else
                            ch -> Q.put
                        if)
                     #);
                   Q[] -> Tx.puttext
               if)
            #);
          TQ:
            (# S: ^Text
            enter S[]
            do '"' -> Tx.put;
               (if S[] <> none then
                   S[] -> TT(# noSpace:: TrueValue #);
                else
                   'none'-> TT(# noSpace:: TrueValue #);
               if);
               '"' -> Tx.put; ' ' -> Tx.put;
               i + 3 -> i
            #);
          BB: 
            (# Bx: @boolean 
            enter Bx 
            do (if Bx then 'true ' -> TX.puttext else 'false '->TX.puttext if);
               i + 6 -> i
            #);
          CC: 
            (# ch: @char 
            enter ch 
            do (if true then
                   ch -> Tx.put;
                else
                   '\'' -> Tx.put; ch -> Tx.put; '\' '->Tx.puttext;
                   i + 4 -> i;
               if);
            #);
          FF: 
            (# F: @real 
            enter F 
            do F -> Tx.putreal; ' ' -> tx.put; i + 8 -> i
            #);
          PT:
            (# T: ^text; R: ^Object
            enter(T[],R[])
            do T[]->TT; (if R[] <> none then inner; ' '->CC else 'none'->TT if);
            #);
          nl: (# do emit; Tx.clear; 0 -> i #);
          emit: 
            (# 
            do Tx.newline; 
               (if notLLVM then
                   '-- ' -> out.puttext;
                else
                   '   ;; ' -> out.puttext
               if);
               Tx[] -> out.puttext; 
            #);
          print:
            (# emit:@boolean
            enter emit
            do (if emit then '**** ' -> puttext; Tx[] -> putline if)
            #);
          Tx: @Text
       do inner
       #);
     com: comS
       (#
       do (if emitCom then inner; emit;if)
       #); 
     fcom: coms(#do inner; emit  #);
     pfcom: fcom(#do inner; true -> print #);
     lcom: comS
       (#
       do (if true and not notLLVM then
              inner;
              emit
          if)
       #);
     emitOp:
       (# op: ^text
       enter op[]
       do (if not notLLVM then
              ';; ' -> out.puttext
           else
              glsc -> out.putint;
              ':\t ' -> out.puttext; 
          if);
          op[] -> out.puttext; ' ' -> out.put;
          inner
       #);
     emitOpL: emitOp(#do out.newline #);
     emitLab:
       (# lab: @integer
       enter lab
       do 'L'->out.put; lab -> out.putint; ':'->out.put; out.newline
       #);
     newComponent: (* Not used!? *)
       (# N: ^text; noOfDescs: @integer
       enter(N[],noOfDescs)
       do ' component ' -> out.puttext; N[] -> out.puttext; 
          ' NoOfDescs: ' -> out.puttext; noOfDescs -> out.putint; out.newline;
          noOfDescs + 3 -> descs.top -> descs.OD.new; (* noOfDesc + 2 since an extra
                                                       * desc is allocated for main 
                                                       * and EventProcessor
                                                       *)
       #);
     allocReg: @
       (# rn: @integer
       do rn + 1 -> rn
       exit rn
       #);

     vRegInStack:
       (# top: @integer; T: ^text
       enter top
       do '%V' -> T[]; 
          (if top > 0 then
              stack.VregNo[top] -> T.putint
           else
              0 -> T.putint
          if)
       exit T[]
       #);
     rReg:
       (# top: @integer; T: ^text
       enter top
       do '%R' -> T[];  
          (if top > 0 then 
              stack.RregNo[top] -> T.putint 
           else
              999 -> T.putint 
          if)
       exit T[]
       #);
     typedRreg:
       (# inx: @integer; T: ^text
       enter inx
       do stack.rType[inx].copy -> T[];
          ' ' -> T.put;
          inx -> rReg -> T.puttext;
       exit T[]
       #);
     stack: @
       (* keeps track of values, register numbers, and types 
        * on the V- and R-stacks 
        *)
       (# rTop,vTop,rTopMax,vTopMax: @integer;
          VregNo: [10] @integer; (* register no holding value *)
          RregNo: [10] @integer; (* register no holding ref *)
          Rtype: [10] ^text;      (* type of ref on stack *)
          Vtype: [10] @integer;  (* type of value on bstack *)
          vVal: [10] ^Value;      (* value in register and on stack *)
          init: 
            (#
            do 0 -> rTop -> vTop -> rTopMax -> vTopMax; 0 -> allocReg.rN
            #);
          value:
            (# V: @integer
            enter V
            exit this(value)[]
            #);
          vpush:
            (# rN: @integer
            enter rN
            do (*';; vpush: ' -> out.putline;*)
               (if (vTop + 1 -> vTop) > vTopMax then vTop -> vTopMax if);
               (if vTop > 0  then
                   (if vTop > vRegNo.range then 
                       vRegNo.range -> vRegNo.extend;
                       vType.range -> vType.extend;
                       vVal.range -> vVal.extend
                   if);
                   rN -> VregNo[vTop]; 0 -> vType[vTop];
                else
                   (if not notLLVM then
                       ';; vpush:vtop: ' -> out.puttext; vTop ->  out.putint;
                       out.newline
               if)if);
               'vpush' -> dump
            #);
          vpop: (# n: @integer enter n do vTop - n -> vTop; 'vpop' -> dump #);
          rpush:
            (# rN: @integer
            enter rN
            do (if (rTop + 1 -> rTop) > rTopMax then rTop -> rTopMax if);
               (if rTop > 0 then
                   (if rTop > rRegNo.range then 
                       rRegNo.range -> rRegNo.extend;
                       rType.range -> rType.extend
                   if);
                   rN -> RregNo[rTop];
                   inner
                else
                   (if not notLLVM then
                       ';; rpush:rtop: ' -> out.puttext; 
                       rTop ->  out.putint; out.newline
               if)if);
               lcom(#do stack.print->TT#) (*'rpush' -> dump*)
            #);
          rpushT:
            (# rN: @integer; type: ^text
            enter(rN,type[])
            do rN -> rpush(#do type[] -> Rtype[rtop][] #)
            #);
          rpop: (# n: @integer enter n do rTop - n -> rTop; 'rpop' -> dump #);
          print: 
            (# T: @text
            do 'vTop(' -> T.puttext; vTop -> T.putint;
               ',' -> T.puttext; vTopMax -> T.putint;
               ')=[' -> T.puttext;
               (for i: vtop repeat 
                    VregNo[i] -> T.putint;  
                    '/' -> T.put;  
                    vType[i] -> T.putint;
                    (if i < vtop then ',' -> T.put if)
               for);
               ']' -> T.put;
               ' rTop(' -> T.puttext; rTop -> T.putint;
               ',' -> T.puttext; rTopMax -> T.putint;
               ')=['->T.puttext;
               (for i: rtop repeat 
                    RregNo[i] -> T.putint;  ':' -> T.put;
                    rType[i][] -> T.puttext; 
                    (if i < rtop then ',' -> T.put if)
               for);
               ']' -> T.put;
            exit T[]
            #);
          put: (#(*do '   ;; ' -> out.puttext; print -> out.putline*) #);
          dump:
            (# T: ^text
            enter T[]
            do com(#do 'stack:' -> TT; T[] -> TT; ': vTop:' -> TT; vTop -> II;
                     'vTopMax:' -> TT; vTopMax -> II;
                     'rTop:' -> TT; rTop -> II; 
                     'rTopMax:' -> TT; rTopMax -> II; 
                     'V:'->TT; (if vTop > 0 then VregNo[vTop] -> II if);
                     'R:'->TT; (if rTop > 0 then RregNo[rTop] -> II if);
                  #)
            #);
          dumpVRN:
            (#
            do 'vregNo:vTop: ' -> puttext;  vTop -> out.putint; ' :: '->puttext;
               (for i: vTop repeat
                    VregNo[i] ->  out.putint; ' ' -> out.put
               for);
               out.newline
            #)
       #);
     LLVMstructs: @ Text;
     typeInfo: @
       (# dsc: [100] ^Info; top: @integer;
          arrays: [100] ^text;
          noOfArrays: @integer;
          current: ^Info;
          Info:
            (# sig,orgSig: ^text;
               attQs: [10] ^text; attQtop: @integer;
               vdtType,vdtRet,newVirt: ^Text;
               printStruct:
                 (#
                 do (for i: attQtop repeat
                         (if i > 1 then ',' -> LLVMstructs.put if);
                         (if attQS[i][] = none then
                             (* only for BETAworld origin = null *)
                             '**** Info:printStruct:none:'->puttext;
                             sig[] -> putline;
                             'i32*' -> LLVMstructs.puttext;
                          else
                             attQS[i][] -> LLVMstructs.puttext;
                             (if newFeature then
                                (* ',' -> put;
                                 attQS[i][] ->  puttext*)
                             if)
                         if)                         
                    for)
                 #);
               print:
                 (#
                 do sig[] -> puttext; ' ::' -> puttext;
                    (for i: attQtop repeat 
                         ' i:' -> puttext; i -> putint; 
                         ' '-> put; attQS[i][] -> puttext; 
                    for);
                    newline
                 #) 
            enter(sig[],orgSig[])
            do (if false then
                   '**** info: ' -> puttext; sig[] -> puttext;
                   ' ' -> put; orgSig[] -> putline;
               if)
            exit this(info)[]
            #);
          getID:
            (# T: ^text; inx,dn,V: @integer
            enter T[]
            do L:
                 T.scanAll
                 (# i: @integer
                 do i + 1 -> i;
                    (if ch = '$' then i -> inx; (*leave L*) if);
                 #);
               (if false then 
                   T[] -> putline; 
                   (if inx >0 then
                       inx  -> T.setPos; T.getInt -> V;
                       T[] -> puttext; ' ' -> put; inx -> putint; 
                       ' ' -> put; V -> putint; newline
               if)if)
            exit inx
            #);
          patch:
            (# miN,T: ^text; inxA,inxB: @integer; C: ^Info;
               trace: (# exit true #);
            enter miN[]
            do (if trace then
                   'patch: ' -> puttext; miN[] -> puttext; ' ' -> put;
               if);
               miN[] -> getID -> inxA; 
               (if trace then
                   inxA -> putint; newline;
               if);
               (for i: top repeat
                    (if (dsc[i][] -> C[]) <> none then
                        (for j: C.attQtop repeat
                             (if (C.attQS[j][] -> T[]) <> none then
                                 T[] -> getID -> inxB;
                                 (if inxA = inxB then
                                     (if ((1,inxA) -> miN.sub)
                                           ->
                                         ((1,inxB) -> T.sub).equal then
                                         (If trace then
                                             'match: ' -> puttext;
                                             miN[] -> puttext;
                                             ' ' -> put;
                                             T[] -> putline;
                                         if);
                                         (if trace then
                                             '*** patch:in: ' -> puttext;
                                             C.sig[] -> puttext;
                                             ' old: ' -> puttext;
                                             C.attQS[j][] -> puttext;
                                             ' by: ' -> puttext;
                                             miN[] -> putline;
                                         if);
                                         (if (T.length -> T.inxGet) = '*' then
                                             '*' -> (miN.copy->miN[]).put
                                         if);
                                         miN[] -> C.attQS[j][];
                                         leave patch
                             if)if)if)
                        for)
                    if)
               for)
            #);
          exists: BooleanValue
            (# dn: @integer
            enter dn
            do (if true
                // dn = 0 then
                   '!!!!! TypeInfo:exists: dn=0' ->  putline
                // dn <= dsc.range then
                   dsc[dn][] <> none -> value
               if)
            #);
          addDsc:
            (# descNo: @integer; sig,orgSig: ^text;
            enter(descNo,sig[],orgSig[])
            do (if descNo > dsc.range then descNo -> dsc.extend if);
               (sig[],orgSig[]) -> Info -> dsc[descNo][] -> current[];
               (if descNo > top then descNo -> top if);
               (*' ' -> put; top -> putint; newline;*)
               (*sig[] -> patch;*)
               descno -> theDn
            #);
          theDn: @integer;
          addRoff:
            (# off: @integer; sig: ^text
            enter(off,sig[])
            do (if (off + 1) > current.attQtop then 
                   current.attQs.range -> current.attQs.extend 
               if);
               sig[] -> current.attQs[off + 1][];
               (if (off + 1) > current.attQtop then 
                   off + 1-> current.attQtop 
               if)
            #);
          lookup:
            (# sig: ^text; inx,off,dn: @integer; attSig: ^text;
               trace: (#exit false #);
               noMatch:
                 (# msg,T: ^text
                 enter msg[]
                 do '\n!!!! lookup:'-> T[]; msg[] -> T.append;
                    ' ' -> T.put; sig[] -> T.puttext;
                    ' off:' -> T.puttext; off -> T.putint;  ' ' -> T.put;
                    inner;
                    T[] -> putline;
                    lcom(#do T[] -> TT #);
                 #);
            enter(sig[],off)
            do (*print;*)
               (if trace then
                   'lookup: ' -> puttext; sig[] -> puttext; 
                   ' off:' -> puttext; off -> putint; ' ' -> put;
               if);
               sig.scanAll
               (# i: @integer
               do i + 1 ->i; 
                  (if ch = '$' then i -> inx if);
               #);
               (if inx > 0 then
                   (if trace then 'match: ' -> puttext;  if);
                   inx ->sig.setPos;
                   sig.getint -> dn; 
                   (if (dn <= 0) or ( dn > dsc.range) then
                       'index out of range' -> noMatch(#do dn -> T.putint#);
                       'index$OutOfRange' -> attSig[];
                       leave lookUp
                   if);
                   (if (off <= 0) or ( off > dsc[dn].attQs.range) then
                       'No off defined (attQS) for ' 
                         -> noMatch
                       (#
                       do ' descNo: '-> T.puttext; dn -> T.putint; 
                          ' attQs.range: ' -> T.puttext; 
                          dsc[dn].attQs.range -> T.putint;
                       #);
                       (*'off$notDefined' -> attSig[];*)
                       leave lookUp
                   if);
                   (if trace then dn -> putint; ' ' -> put; if);
                   (*dsc[dn].print;*)
                   (if dsc[dn][] <> none then
                       (*dsc[dn].sig[] -> puttext; ' ' -> put;*)
                       dsc[dn].attQs[off + 1][] -> attSig[];
                    else
                       'none' -> attSig[];
                        (*print;*)
                       '\n!!!! lookup: none! ' -> putline;
                       sig[] -> puttext; ' off:' -> puttext;
                       off -> putint; newline
                   if);
                   (*attSig[] -> putline*)
                else
                   (*print;*)
                   'no-match' -> attSig[];
                   ' no match! ' ->noMatch
               if);
               (if attSig[] = none then
                   (*print;*)
                   '\n!!!! lookup: noneX! ' -> putline;
                   sig[] -> puttext; ' off:' -> puttext;
                   off -> putint; 
                   ' dn: ' -> puttext; dn -> putint; newline;
                   lcom(#do '!!!! lookup: noneX! ' -> TT;
                          sig[] -> TT; ' off:' -> TT;
                          off -> II; 
                          ' dn: ' -> TT; dn -> II
                       #);
                   '%noneX' -> attSig[] 
               if);
            exit attSig[]
            #);
          get:
            (# descNo: @integer; TI: ^Info; T: ^text
            enter descNo
            do (if (descNo < 1) 
                   or (top < descNo)
                   or ((dsc[descNo][] ->TI[]) = none) then
                   ('NotFound:'-> T[],descNo->T.putint) -> info -> TI[]
               if)
            exit TI[]
            #);
          newArray:
            (# T,type: ^text
            do (if (noOfArrays + 1 -> noOfArrays) > arrays.range then 
                   arrays.range -> arrays.extend
               if);
               '%array$' -> T[]; noOfArrays -> T.putint;
               T.copy -> type[];
               (*'*' -> type.put;*)
               ' = type {i8*, i32, [0 x i32]}\n' -> T.append;
               T[] -> arrays[noOfArrays][];
            exit type[]
            #);
               
          printStructs:
            (# D: ^Info
            do ''-> LLVMstructs;
               (for i: top repeat
                    (if (dsc[i][] -> D[]) <> none then
                        (if false then 
                            '*** printStructs: ' -> puttext;
                            D.sig[] -> puttext; ' = ' -> puttext;
                            newline;
                        if);
                        D.sig[] -> LLVMstructs.puttext;
                        ' = type {' -> LLVMstructs.puttext;
                        D.printStruct;
                        '}\n' -> LLVMstructs.puttext;
                        (if dsc[i].vdtType[] = none then
                            '*** printStructs: none: ' -> puttext;
                            i -> putint; newline
                        if);
                        dsc[i].vdtType[] -> LLVMstructs.puttext;
                        dsc[i].vdtRet[] -> LLVMstructs.putline;
                    if)
               for);
               (for i: noOfArrays repeat arrays[i][] -> LLVMstructs.putline for);
               literals[] -> LLVMstructs.putline
            #);
          print:
            (#
            do 'typeInfo: ' -> puttext; top -> putint; newline;
               (for i: top repeat
                    (if dsc[i][] <> none then
                        'descNo: ' -> puttext; i -> putint; ': ' -> puttext;
                        dsc[i].print
               if)for);
               literals[] -> puttext;
            #)
       #);
     literals: @Text;
     
     vdtType:
       (# cN,T: ^text
       enter cN[]
       do '%vdt_type$' -> T[];
          cN[] -> T.append
       exit T[]
       #);
     funcPtrType:
       (# cN,T,S: ^text; dn: @integer
       enter(cN[],dn)
       do cN.copy -> T[];
          '(' -> T.put; 
          cN[]  -> T.puttext; 
          (if isValueObject then
              ', i32' -> T.puttext
           else
              (if newFeature then
                  (if ((dn -> typeInfo.get).orgSig[] -> S[]) <> none then
                      ', ' ->  T.puttext;
                      S[]  ->  T.puttext
          if)if)if);
          ')*' -> T.puttext
       exit T[]
       #);
     ind: (# do '   ' -> out.puttext #);
     leag:
       (# off,rN: @integer; rnType: ^text
       enter off
       do ind;
          allocReg -> rN -> emitRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext; 
          stack.rType[stack.rTop][] 
            -> deRef ->  rnType[] -> out.puttext;  ',' -> out.put;
          rnType[] -> out.puttext; ' *' -> out.puttext;
          stack.rTop -> rReg -> out.puttext; 
          ', i32 0, i32 ' -> out.puttext; 
          off -> out.putint; 
          '\n' -> out.puttext;
       exit rN
       #);
     leaReg:
       (# reg,off,rN: @integer; rnType: ^text
       enter(reg,rnType[],off)
       do ind;
          allocReg -> rN -> emitRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext; 
          rnType[] -> out.puttext;  ',' -> out.put;
          rnType[] -> out.puttext; '* ' -> out.puttext;
          reg -> emitRreg -> out.puttext; 
          ', i32 0, i32 ' -> out.puttext; 
          off -> out.putint; 
          '\n' -> out.puttext;
       exit rN
       #);
     iLoad:
       (# rN,rNx: @integer
       enter rN
       do allocReg -> rNx -> emitVreg -> out.puttext;
          ' = load i32, i32* ' -> out.puttext;
          rN -> emitRreg -> out.puttext;
          out.newline
       exit rNx
       #);
     LLVMget:
       (# rNoSrc,rNoDst,off,rN: @integer; srcType,dstType,T: ^text
       enter(rNoSrc,srcType[],off,rNoDst,dstType[])
       do allocReg -> rN -> emitRreg -> T[];
          ' = getelementptr ' -> T.puttext; 
          srcType[] -> T.append;
          ', ' -> T.puttext;
          
          srcType[] -> T.append;
          '* ' -> T.append;
          
          rNoSrc -> emitRreg -> T.append;
          
          ', i32 0, i32 ' -> T.puttext; 
          off -> T.putint; 
          '\n   ' -> T.puttext;
          
          rNoDst -> emitRreg -> T.append;
          ' = load ' -> T.append;
          dstType[] -> T.append;
          '*, ' -> T.append;
          dstType[] -> T.append;
          '** ' -> T.append;
          rN -> emitRreg -> T.append
          
       exit T[]
       #);
     LLVMstore:
       (# srcReg,dstReg,off,rN: @integer; srcT,dstT: ^text;
       enter(srcReg,srcT[],dstReg,dstT[],off)
       do (dstReg,dstT[],off) -> leaReg  -> rN;
          '   store ' -> out.puttext; 
          srcT[]  -> out.puttext; '* ' -> out.puttext;
          srcReg -> emitRreg -> out.puttext; ', ' -> out.puttext;
          srcT[] -> out.puttext; '** ' -> out.puttext;
          rN -> emitRreg  -> out.putline;          
       #);
     allocObj:
       (# objId: ^text; 
          descNo,size,rNx,rNy,rNz: @integer
       enter(objId[],descNo,size)
       do '   ;; alloc ' -> out.puttext; objId[] -> out.puttext;
          '\n   ' -> out.puttext;
          allocReg -> rNx -> emitRreg -> out.puttext; 
          ' = ' -> out.puttext;
          'tail call i8* @malloc(i64 ' -> out.puttext;
          size * 4 -> out.putint;
          ')\n' -> out.puttext;
          (rNx,'i8*','*'->(objId.copy).put) -> bitCast -> rNy;
          inner allocObj
       exit rNy
       #);
     allocRtobj: allocObj(##);
     allocQbetaObj: allocObj
       (# T,orgT: ^text
       do '   ;; store VDT in object\n   ' -> out.puttext;
          allocReg -> rNz -> emitRreg -> out.puttext;
          ' = getelementptr ' -> out.puttext;  
          objId[] -> out.puttext; 
          ', ' -> out.puttext; objId[] -> out.puttext;
          '* ' -> out.puttext;
          rNy -> emitRreg -> out.puttext;               
          ', i32 0, i32 0' -> out.puttext;
          out.newline;
          (descNo -> typeInfo.get).orgSig[] -> orgT[];
          '   store ' -> out.puttext;
          (2,objId.length) -> objId.sub -> T[] -> vdtType -> out.puttext;
          '* @vdt_data$' -> out.puttext; T[] -> out.puttext;
          ', ' -> out.puttext; 
          T[] -> vdtType -> out.puttext;
          '** ' -> out.puttext;
          rNz -> emitRreg -> out.puttext;
          '\n' -> out.puttext;
       #);
     mkTextConst:
       (# T,id: ^text; range: @integer
       enter T[]
       do textId + 1 -> textId;
          '@Txt$' -> id[]; textId -> id.putint;
          id[] -> literals.puttext;
          ' = private unnamed_addr constant [' -> literals.puttext;
          T.length + 2 -> range -> literals.putint;
          ' x i8] c"' -> literals.puttext; T[] -> literals.puttext;
          '\\0A\\00"\n' -> literals.puttext
       exit(Id[],range)
       #);
     textId: @integer;
     stringType:
       (# stringDescNo: @integer; T: ^text
       enter stringDescNo
       do '%String$' -> T[]; stringDescNo -> T.putint;  
       exit T[]
       #);
     allocString:
       (# T,id,sType: ^text; stringDescNo,rN,rN1,range: @integer
       enter(T[],stringDescNo)
       do stringDescNo -> stringType -> sType[];
          T[] -> mkTextConst -> (id[],range);
          allocReg -> rN -> emitRreg -> out.puttext;
          ' = getelementptr [' -> out.puttext;
          range -> out.putint;
          ' x i8], [' -> out.puttext;
          range -> out.putint;
          'x i8]* ' -> out.puttext;
          id[] -> out.puttext; ', i64 0, i64 0\n' -> out.puttext;
          
          allocReg -> rN1 -> emitRreg -> out.puttext;
          ' = call i32* @allocString(i8* ' -> out.puttext;
          rN -> emitRreg -> out.puttext; ', i32 ' -> out.puttext;
          range - 2 -> out.putint;
          ')\n' -> out.puttext;
          
          (rn1,'i32*','*'->(sType.copy).put) -> bitCast -> rN;
          (rN,'*' ->sType.put) -> stack.rPushT
       #);
     putString:
       (# id: ^text; range,sNo: @integer
       enter(id[],range)
       do '   %S' -> out.puttext; allocReg -> sNo -> out.putint;
          '= getelementptr [' -> out.puttext;
          range -> out.putint;
          ' x i8], [' -> out.puttext;
          range -> out.putint; 
          ' x i8]* ' -> out.puttext; id[] -> out.puttext; 
          ', i64 0, i64 0\n' -> out.puttext;
          
          '   call i32 @puts(i8* %S' -> out.puttext;
          sNo -> out.putint;
          ')\n' -> out.puttext
       #);
     bitcast:
       (# rNs,rNd: @integer; srcT,dstT: ^text
       enter(rNs,srcT[],dstT[])
       do ind;
          allocReg -> rNd -> emitRreg -> out.puttext; 
          ' = bitcast ' -> out.puttext; 
          srcT[] -> out.puttext; ' ' -> out.put;
          rNs -> emitRreg->out.puttext;
          ' to ' -> out.puttext; 
          dstT[] -> out.puttext; '\n' -> out.puttext; 
       exit rNd
       #);
     notImpl:
       (# op: @integer;
          Tx: ^Text
       enter op
       do 'not implemented: ' -> Tx[];
          inner notImpl;
          lcom(#do Tx[] -> Tt #);
          'call void @notImpl(i32 ' -> out.puttext;
          op -> out.putint;
          ')\n' -> out.putline
       #);
     dumpObj:
       (# rN,rNx: @integer; type: ^text
       enter(rN,type[])
       do ind;
          allocReg -> rNx -> emitRreg -> out.puttext;
          ' = ptrtoint ' -> out.puttext; type[] -> out.puttext;
          '* ' -> out.puttext; rN -> emitRreg -> out.puttext;
          ' to i32\n' -> out.puttext;
          '   call i32 @dumpHex(i32 ' -> out.puttext;
          rNx -> emitRreg -> out.puttext; 
          ',i32 1)\n' -> out.puttext;
       #);
     dumpObjX:
       (# rN,rNx,range: @integer; pre,msg,type,id: ^text
       enter(pre[],msg[],rN,type[])
       do (if false then
              '**** dumpObjX: ' -> puttext; msg[] -> puttext;
              ' ' -> puttext; rn -> putint; ' ' -> put;
              type[] -> putline;
          if); 
          '   call i32 @putCh(i32 10)'->out.putline;
          msg[] -> pre.append -> mkTextConst -> putString;
          ';; ' -> out.puttext; pre[] -> out.putline;
          (rN,type[]) ->  dumpObj
       #);
     
     thisClassDescNo,thisClassOrgDescNo,thisClassOriginOff: @integer; 
     thisClassId,        (* className$descNo *)
     thisClassT,         (* %thisClassId     *)
     thisClassP,         (* thisClassT*      *)
     thisClassOrgId: ^text; (* origin of thisClass *)
     isValueObject,isVstubObject: @boolean;

     doFilter: (* should be eliminated *)
       (# N,T: ^text
       enter N[]
       do N[] -> filter -> T[]
       exit T[]          
       #);
     classDef:
       (# add:
            (# off: @integer
            enter off
            do (if not first then ',' -> LLVMstructs.put if);
               false -> first;
               (*off -> putint; ':'->put; *)
               INNER;
            #);
          addR: add
            (# OGid: ^text
            enter OGid[]
            do OGid[] -> filter -> OGid[];
               '%' 
                 -> OGid.prepend 
                 -> OGid[]-> LLVMstructs.puttext; 
               '*' -> LLVMstructs.put;
               (off,'*'->(OGid.copy).put) -> typeInfo.addRoff
            #);
          addV: add
            (# 
            do 'i32'-> LLVMstructs.puttext; 
               (off,'i32') -> typeInfo.addRoff
            #);
          addA: add
            (# T:^text
            do typeInfo.newArray -> T[]; '*' -> T.put; 
               (*T[] -> putline;*)
               (off,T[]) -> typeInfo.addRoff
            #);
          first,isValueObj: @boolean;
          N,orgOfN: ^text; descNo,orgDescNo: @integer; T: ^text;          
       enter(N[],descNo,isValueObj,orgOfN[],orgDescNo)
       <<SLOT classDef:doPart>>
       #);
     class:
       (# dumpClass:
            (#
            do '\n\n*** Fatal error in objectCode: *** Class: ' 
                 -> puttext; 
               N[] -> puttext; ' descNo = '->puttext; descNo -> putint;
            #);
          N,orgId: ^text; 
          descNo,topDescNo,originOff,originDescNo: @integer;
          procE: @boolean; (* mark start as proc-entry and enter-entry *)
          isValueObj,isVstub: @boolean;
          first: @boolean;
          T,S: ^Text
       enter(N[],descNo,procE,topDescNo,originOff,orgId[],originDescNo
          ,isValueObj,isVstub)
       do (if descNo = 0 then
              dumpClass;
              ' is ZERO!' -> putline
          if);
          stack.init;
          out.newline;
          'CLASS ' -> out.puttext; N[] -> out.puttext; 
          ' dNo:' ->out.puttext; descNo -> out.putint; 
          ' topDno:'->out.puttext; topDescNo -> out.putint;
          ' orgOff:' -> out.puttext; originOff -> out.putint; 
          ' orgId:' -> out.puttext; orgId[] -> out.puttext;
          ' orgDno:' -> out.puttext; originDescNo -> out.putint; 
          (if isValueObj then ' isValueObj' -> out.puttext if);
          (if isVstub -> isVstubObject then ' isVstub' -> out.puttext if);  
          out.newline;          
          <<SLOT class:descriptor>>
       #);
     super: 
       (# N: ^text; superDescNo: @integer
       enter(N[],superDescNo)
       do (if notLLVM then
              '-- op:super ' -> out.puttext; N[] -> out.putline;
              descs.OD[superDescNo][] -> descs.current.superObjDesc[]
          if)
       #);
     markEnterE: (# do descs.markEnterE #);
     enterP:
       (#
       do 'ENTER:' -> out.putline
       #);
     setThisStack:
       (#
       do (if notLLVM then
              'setThisStack ' -> emitOp; out.newline;
              codes.setThisStack -> emit
          if)
       #);
     rpopThisObj:
       (#
       do (if notLLVM then
              'rpopThisObj ' -> emitOp;
              codes.rpopThisObj -> emit
           else
          if)
       #);       
     actions:
       (# genDoEvent: @boolean
       enter genDoEvent
       do (if notLLVM then
              'DO:'->out.putline;
              descs.markDoE;
              (if genDoEvent then doEventQ if);
           else 
              ';; DO:' -> out.putline;
              (if dumpLLVMobjs then
                  ('DO:',thisClassT[],0,thisClassT[]) -> dumpObjX
              if)
          if)
       #);
     mvStack:
       (#
       do (if notLLVM then 
              'mvStack'->emitOp; out.newline;
              codes.mvstack -> emit 
          if)
       #);
     markExitE: (# do descs.markExitE #);
     doExit:
       (#
       do 'EXIT:' -> out.putline; 
          'doExit' -> emitOp; out.newline;
          codes.doExit -> emit
       #);
     rtn: 
       (# LMR: @char; rN: @integer
       enter LMR 
       do (if notLLVM then
              'rtn' -> emitOp;; LMR->out.put;  out.newline;
              codes.rtn -> emit ; LMR -> emit;
           else
              (if true
               // 'main' -> ((2,5) -> thisClassT.sub).equal then
                  '   ret void\n' -> out.putline
               // false and isValueObject then
                  '   ret %Object* %R0\n' -> out.putline;
               else
                  stack.put;
                  (if isVstubObject then
                      (* NB! types are not correct! *)
                      (stack.rRegNo[stack.rtop]
                      ,stack.rType[stack.rtop][],thisClassP[])
                        -> bitcast -> rN;
                      (if dumpLLVMobjs then
                          ('RET:STUB:',thisClassT[],0,thisClassT[]) -> dumpObjX
                      if);
                      (* RTN: binding *)
                   else
                      (if dumpLLVMobjs then
                          ('RET:',thisClassT[],0,thisClassT[]) -> dumpObjX
                      if);
                      (* RTN: this object *)
                  if); 
                  '   ret ' -> out.puttext; 
                  thisClassP[] -> out.puttext; ' %R0' -> out.puttext;
              if);
              1 -> stack.rpop;              
          if)
       #);
     rtnV: (*rtnValue*)
       (#
       do (If notLLVM then
              ' rtnV\n' -> out.puttext;  codes.rtnV -> emit 
           else
          if)
       #);
     rtnC: (# do ' rtnC' -> out.putline; codes.rtnC -> emit #);
     rtnExit: (# do ' rtnExit' -> out.putline; codes.rtnExit -> emit #);
     rtnInner: 
       (# entry: @char (* 'A': rtnInner in alloc-part *)
       enter entry
       do 'rtnInner ' -> emitOp; entry -> out.put; out.newline;
          (if notLLVM then
              codes.rtnInner -> emit
           else
              (if entry <> 'A' then
                  '   ret ' -> out.puttext; thisClassT[] -> out.puttext; 
                  ' *%R0\n' -> out.puttext;
          if)if)
       #);
     rtnEvent: 
       (# hasExit: @integer 
       enter hasExit 
       do 'rtnEvent' -> emitOp; hasExit -> out.putint; out.newline;
          codes.rtnEvent -> emit;
          hasExit -> emit
       #);
     allocEventQ:
       (# isObj: @boolean
       enter isObj
       do (if notLLVM then
              'allocEventQ' -> emitOp; out.newline;
              codes.allocEventQ -> emit;
              (if isObj then 1 -> emit else 0 -> emit if)
          if);
       #);
     rtnAlloc: 
       (# hasExit: @integer 
       enter hasExit 
       do (if notLLVM then
              'rtnAlloc' -> emitOp; hasExit -> out.putint; out.newline;
              codes.rtnAlloc -> emit;
              hasExit -> emit
          if)
       #);
     doEventQ:
       (#
       do (if notLLVM then
              'doEventQ' -> emitOp; out.newline;
              codes.doEventQ -> emit
          if);
       #);
     stop: 
       (# 
       do (if notLLVM then
              'stop\n' -> emitOp; codes.stop -> emit
           else
              '   ;; stop\n' -> out.puttext
          if)
       #);
     makeEmptySub:
       (# N: ^text; descNo: @integer
       enter(N[],descNo)
       do descs.markProcE;
          (N[],descNo) -> exeAlloc;
          (N[],descNo) -> doSuper;
          'D' -> rtn          
       #);
     defLab:
       (# lab: @integer 
       enter lab
       do (if notLLVM then
              lab -> emitLab;
              lab -> labs.def;
           else
              '   br label %L' -> out.puttext; lab ->  out.putint;  out.newline;
              'L'-> out.puttext; lab ->  out.putint; ':' -> out.put; out.newline
          if);
       #);
     jmpGT: 
       (# lab: @integer 
       enter lab 
       do 'jmpIf_GT L' -> emitOp; lab -> out.putint; out.newline;
          codes.jmpGT -> emit;
          0 -> emit2;
          lab -> labs.mark
       #);
     jmp: 
       (# lab: @integer 
       enter lab 
       <<SLOT jmp:doPart>>         
       #);
     jmpFalse:
       (# Tlab,Flab,vN: @integer 
       enter(Tlab,Flab) 
       do 'jmpFalse ' -> emitOp; 'L'->out.put; Flab -> out.putint; out.newline;
          <<SLOT jmpFalse:descriptor>>
       #);
     jmpTrue:
       (# lab: @integer 
       enter lab 
       do 'jmpTrue L' -> emitOp; lab -> out.putint; out.newline;
          (if notLLVM then
              codes.jmpTrue -> emit;
              0 -> emit2;
              lab -> labs.mark
           else
          if)
       #);
     break:
       (# on,lab,descInx,pn,rN,rNx,rNy: @integer; T:^text
       enter(on,lab,descInx,pn)
       do 'break ' -> emitOp; on -> out.putint; ' ' -> out.put; 
          lab -> out.putint; ' ' -> out.put; descInx -> out.putint;
          ' ' -> out.put; pn -> out.putint;
          out.newline;
          (if notLLVM then
              codes.break -> emit;
              on -> emit; 
              (if lab = 0 then
                  '\n!!!! objectCode:break:Fatal error: lab = 0' -> putline
              if);
              lab -> emit2;
              descInx -> emit2;
              pn -> emit
           else
              stack.put;
              '%vdt_type$' -> T[];
              (2,stack.rType[stack.rTop].length)
                ->stack.rType[stack.rTop].sub -> T.append;
              '*' -> T.put;
              0 -> leag -> rNx;
              (rNx, T[], 'i32*') -> bitCast -> rNy;
              'store i32 ' -> out.puttext;
              lab -> out.putint;
              ', i32* ' -> out.puttext;
              rNy -> emitRreg -> out.putline;
              
              (stack.rRegNo[stack.rTop],stack.rType[stack.rTop][],thisClassP[])
                -> bitCast -> rN;
              '   ret ' -> out.puttext; 
              thisClassP[] -> out.puttext;
              ' '  -> out.put;
              rN -> emitRreg -> out.putline
          if)
       #);
     alloc: 
       (# N: ^text; descNo: @integer; 
          isObj: @boolean; (* True if 'real' object; false if method inv. *)
       enter(N[],descNo,isObj) 
       do 'alloc' -> emitOp; descNo -> out.putint; ' ' -> out.put; 
          N[] -> out.puttext; (if isObj then ' isObj'-> out.puttext if);
          out.newline;
          codes.alloc -> emit; descNo -> emit2;
          (if isObj then 1 -> emit else 0 -> emit if)
       #);
     tstOriginIsNone:
       (#
       do (if notLLVM then
              'tstOriginIsNone' -> emitOp; out.newline;
              codes.tstOriginNone -> emit;
           else
              
          if)
       #);
     invoke: 
       (# N,Ns,Nx,rtnType: ^text; 
          descNo,size,staticOff,superDescNo,io: @integer; 
          isObj: @boolean; 
          calleeReg,rN,rNx,rNy,rNz,rNq,vN,vNx,tLab,fLab,rLab,lLab,rSn
          ,normalRtnLab,breakLab,contBreakLab,selectBreakLab: @integer;
          superN,T,Tx,calleeType: ^text;
          topSuperId:<
            (# superId: ^text; superDescNo: @integer
            do inner
            exit(superId[],superDescNo)
            #);
       enter(N[],descNo,size,staticOff,isObj) 
       do 'invoke' -> emitOp; N[] -> out.puttext; 
          ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
          staticOff -> out.putint; ' ' -> out.put;
          (if isObj then 1 -> iO else 0 -> iO if);
          io -> out.putint;
          out.newline;
          (if notLLVM then              
              codes.invoke -> emit; descNo -> emit2; staticOff -> emit2;
              iO -> emit;
           else
              (* the origin and possible arguments are on the stack
               * As for now we dont know the no of arguments
               * We thus make an rpop for the origin
               * callee returns a value - here we dont know the type so we
               * assume that a ref to callee is returned
               *)
              N[] -> filter -> N[];

              stack.put;
              
              '$' -> N.put; descNo -> N.putint;
              N.copy -> Ns[];'%' -> Ns.prepend;
              Ns.copy -> calleeType[];
              
              (Ns[],descNo,size + 1) -> allocQbetaObj -> calleeReg -> rN;

              (calleeReg,calleeType[]) -> stack.rpushT;

              inner invoke;

              topSuperId -> (superN[],superDescNo);
              (if superN[] = none then
                  '----- topSuperId is none' -> putline;
                  N[] -> putline;
              if);              
              superN[] -> filter -> superN[];
              (if not (superN[] -> N.equal) then 
                  '%' -> Nx[]; superN[] -> Nx.append; 
                  (rN,'*'->(Ns.copy).put,'*'->(Nx.copy).put)
                    -> bitCast -> rNx;
                  Nx[] -> Ns[];
                  superN[] -> N[];  
                  rNx -> rN
              if);
              (if dumpLLVMobjs then
                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = ptrtoint ' -> out.puttext; Ns[] -> out.puttext;
                  '* ' -> out.puttext; rN -> emitRreg -> out.puttext;
                  ' to i32\n' -> out.puttext;
                  'call i32 @dumpHex(i32 ' -> out.puttext;
                  rNx -> emitRreg -> out.puttext; 
                  ',i32 1)\n' -> out.puttext;
              if);
              (if newFeature then
                  ';;**** call: ' -> out.puttext; Ns[] -> out.puttext;
                  ' ' -> out.put; descNo -> out.putint; 
                  ' ' -> out.put; N[] -> out.puttext;
                  ' ' -> out.put; superDescNo -> out.putint; '"'->out.put;
                  (superDescNo -> typeInfo.get).orgSig[] -> out.puttext;
                  '"'->out.put;
                  (if (superDescNo -> typeInfo.get).orgSig[] <> none then
                      ' '-> out.put;
                      (if stack.rtop > 1 then
                          stack.rType[stack.rtop - 1][] -> out.puttext;
                       else
                          ' none: ' -> out.puttext; stack.rtop -> out.putint;
                          ' ' -> out.put; 
                          stack.rType[stack.rtop][] -> out.puttext;
                  if)if);
                  out.newline;
              if);
              
              (if staticOff > 0 then
                  (* we have X: obj / val foo
                   * the new foo object shall be stored in X (staticOff)
                   * If foo returns a value that is not a ref to foo,
                   * then dont store. The return value may be an integer.
                   * The return value is fecthed after the call.
                   * OBS! foo may also return a foo ref that differs from
                   * the new foo object
                   *)
                  (thisClassT[],staticOff) ->  typeInfo.lookup -> rtnType[];
                  '   ;; save object: ' -> out.puttext; 
                  '*'-> (Ns.copy).put -> Tx[] -> out.puttext;
                  ' dstType: '  -> out.puttext; rtnType[] -> out.putline;
                  
                  (if (rtnType[]->deRef) -> calleeType.equal then

                      (0,thisClassT[],staticOff)  -> leaReg -> rNx;

                      '   store ' -> out.puttext; 
                      calleeType[] -> out.puttext;
                      '* ' -> out.puttext;
                      calleeReg -> emitRreg -> out.puttext; 
                      ',  ' -> out.puttext;
                      calleeType[] -> out.puttext; '** ' -> out.puttext;
                      rNx -> emitRreg -> out.putline; 
                   else
                      '   ;; dont save - object computes a return value'
                        -> out.putline;
                      lcom(#do 'thisType: ' -> TT; calleeTYpe[]->TT;
                             ' rtnType: ' -> TT; rtnType[] -> TT 
                          #);
              if)if);
              ind;
              allocReg -> rNz -> emitRreg -> out.puttext;
              ' = call ' -> out.puttext; Ns[] -> out.puttext;
              '* @' -> out.puttext; N[] -> out.puttext; 
              '(' -> out.put; Ns[] -> out.puttext; ' * ' -> out.puttext;
              rN -> emitRreg -> out.puttext; 
              (if newFeature and ((superDescNo->typeInfo.get).orgSig[] <> none) then
                  ',' -> out.put;
                  stack.rTop - 1 -> typedRreg -> out.puttext;
              if);
              ')' -> out.put;
              out.newline;
              (if newFeature then
                  2 -> stack.rpop
               else
                  1 -> stack.rpop;
              if);
              '*' -> Ns.put;
              rN -> stack.Rpush(#do Ns[] -> stack.Rtype[stack.rtop][]#);
              (if 'main' -> ((2,5) -> thisClassT.sub).equal then
                  leave invoke
              if);
              (* check if normal return og leave or restart *)
              (* rtn = callee  => normal return
               * rtn <> callee =>  break
               *     rtn <> this => continue break, unwind of stack
               *     rtn = this  => end of break; select leave or restart
               *)
              allocReg -> normalRtnLab;
              allocReg -> breakLab;
              (* compare rtn = callee *)
              ind;
              allocReg -> vNx -> emitVreg -> out.puttext;
              ' = icmp eq '  -> out.puttext;
              Ns[] -> out.puttext; ' ' -> out.put;
              rNz -> emitRreg -> out.puttext;
              ', ' -> out.puttext;
              rN -> emitRreg -> out.puttext;
              out.newline;
              
              '   br i1 ' -> out.puttext;
              vNx -> emitVreg -> out.puttext;
              ', label %normalRtnLab' -> out.puttext; 
              normalRtnLab -> out.putint;
              ', label %breakLab' -> out.puttext; breakLab -> out.putint;
              out.newline;
              
              'breakLab' -> out.puttext; breakLab -> out.putint; 
              ':' -> out.put; out.newline;
              
              (rNz,Ns[],thisClassP[])  -> bitCast -> rNq;
              ind;
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = icmp eq ' -> out.puttext;
              thisClassP[] -> out.puttext;
              ' ' -> out.put; 0 -> emitRreg -> out.puttext; 
              ', ' -> out.puttext;
              rNq -> emitRreg -> out.putline;
              
              '   br i1 ' -> out.puttext;
              vN -> emitVreg -> out.puttext;
              allocReg -> contBreakLab; allocReg -> selectBreakLab;
              ', label %selectBreakLab' -> out.puttext; 
              selectBreakLab -> out.putint;
              ', label %contBreakLab' -> out.puttext; 
              contBreakLab -> out.putint;
              out.newline;
              'contBreakLab' -> out.puttext; contBreakLab -> out.putint; 
              ':' -> out.put; out.newline;
              
              '   ret ' -> out.puttext; thisClassP[] -> out.puttext;
              ' ' -> out.put;
              rNq -> emitRreg -> out.putline;
              
              'selectBreakLab' -> out.puttext; selectBreakLab -> out.putint;
              ':' -> out.put; out.newline;
              
              (if true then
                  (rNz,'*'->(Ns.copy).put ->deref, '[0 x i32]*')
                    -> bitcast -> rN;
                  
                  ind;
                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = getelementptr [0 x i32], [0 x i32]* ' -> out.puttext;
                  rN -> emitRreg -> out.puttext;
                  ', i32 0, i32 0\n' -> out.puttext;
                  
                  ind;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = load i32 ' -> out.puttext; 
                  ', i32* ' -> out.puttext; 
                  rNx -> emitRreg -> out.putline;
                  
                  (if false then
                      '   call i32 @putHex(i32 ' -> out.puttext; 
                      vN -> emitVreg -> out.puttext;
                      ')\n' -> out.puttext;
                  if);
                  
                  (if false then
                      ind;
                      allocReg -> vNx -> emitVreg -> out.puttext;
                      ' = icmp slt i32 2, ' -> out.puttext;
                      vN -> emitVreg -> out.puttext; out.newline;
                      
                      allocReg -> tLab; allocReg -> fLab;
                      '   br i1 ' -> out.puttext; 
                      vNx -> emitVreg ->out.puttext;
                      ', label %X' -> out.puttext; tLab -> out.putint;
                      ', label %X' -> out.puttext; fLab -> out.putint;
                      out.newline;
                      
                      'X' -> out.put; fLab -> out.putint; ':' -> out.put;
                      out.newline;
                  if);
                  
                  (if traceLLVMcalls then
                      allocReg -> rSn;                  
                      '   %S' -> out.puttext; rSn -> out.putint;
                      '= getelementptr [' -> out.puttext;
                      thisClassT.length + 2 -> out.putint;
                      ' x i8], [' -> out.puttext;
                      thisClassT.length + 2 -> out.putint; 
                      ' x i8]* @S.' -> out.puttext; 
                      thisClassId[] -> out.puttext; 
                      ', i64 0, i64 0\n' -> out.puttext;                  
                      '   call i32 @puts(i8* %S' -> out.puttext;
                      rSn -> out.putint;
                      ')\n' -> out.puttext;
                  if);
                  
                  (* restore vdt *)
                  (rNz,Ns[]->deref,0) -> leaReg -> rNy;
                  '   store ' -> out.puttext;
                  (2,Ns.length) -> Ns.sub  -> vdtType -> out.puttext;
                  ' @vdt_data$' -> out.puttext; 
                  (2,Ns.length - 1) -> Ns.sub -> out.puttext;
                  ', ' -> out.puttext; 
                  (2,Ns.length) -> Ns.sub -> vdtType -> out.puttext;
                  '* ' -> out.puttext;
                  rNy -> emitRreg -> out.puttext;
                  '\n' -> out.puttext;
                  
                  ind;
                  allocReg -> vNx -> emitVreg -> out.puttext;
                  ' = icmp eq i32 1, ' -> out.puttext;
                  vN -> emitVreg -> out.puttext; out.newline;
                  
                  allocReg -> rLab; allocReg -> lLab;
                  '   br i1 ' -> out.puttext; vNx -> emitVreg ->out.puttext;
                  ', label %X' -> out.puttext; rLab -> out.putint;
                  ', label %X' -> out.puttext; lLab -> out.putint;
                  out.newline;
                  
                  'X' -> out.put; rLab -> out.putint; ':' -> out.put;
                  out.newline;
                  '   br label %L1 ; restart' -> out.putline;
                  
                  'X' -> out.put; lLab -> out.putint; ':' -> out.put;
                  out.newline;
                  '   br label %L2 ; leave' -> out.putline;
                  
                  (if false then
                      'X' -> out.puttext; tLab -> out.putint; 
                      ':' -> out.put;
                      out.newline;
                  if);
                  
                  (*'   br label %normalRtnLab' -> out.puttext;
                  normalRtnLab -> out.putint; out.newline;*)
                  'normalRtnLab' -> out.puttext; 
                  normalRtnLab -> out.putint; 
                  ':' -> out.put;
                  out.newline;
              if);
              out.newline;
              stack.put
          if)
        #);
     mkVindexed:
       (# descInx: @integer
       enter descInx
       do 'mkVindexed' -> emitOp; descInx -> out.putint; out.newline; 
          codes.mkVindexed -> emit; descInx -> emit2;
       #);
     mkRindexed:
       (# descInx: @integer
       enter descInx
       do 'mkRindexed' -> emitOp; descInx -> out.putint; out.newline;
          codes.mkRindexed -> emit; descInx -> emit2;
       #);     
     saveAndSetThis:
       (#
       do (If notLLVM then
              'saveAndSetThis' -> emitOp;
              codes.saveAndSetThis -> emit
          if)
       #);
     restoreThis:
       (#
       do 'restoreThis' -> emitOp;
          codes.restoreThis -> emit;
          (if notLLVM then
           else
              '!!! restoreThis not implememnted'  -> putline
          if)
       #);
     invokeVal:
       (# N,PN: ^text; descNo,staticOff,rN: @integer; 
          isValueObj: @Boolean
         enter(N[],descNo,staticOff,isValueObj) 
         do 'invokeVal' -> emitOp; ' ' -> out.put; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put;
            staticOff -> out.putint; 
            (if isValueObj then
                ' true' -> out.puttext
            if);
            out.newline;
            (if notLLVM then
                codes.invokeVal -> emit; descNo -> emit2; staticOff -> emit2;
                (if isValueObj then 1 -> emit else 0 -> emit if);
             else;
                (0,thisClassP[],(N[],descNo) -> mkTypePtr -> PN[])
                  -> BitCast -> rN;
                inner invokeVal;
                
                '   call ' -> out.puttext; PN[] -> out.puttext;
                ' @' -> out.puttext; 
                (2,PN.length-1) -> PN.sub  -> out.puttext; 
                '(' -> out.put; PN[] -> out.puttext; 
                ' ' -> out.puttext;
                rN -> emitRreg -> out.puttext; 
                ', i32 ' -> out.puttext;
                staticOff -> out.putint;
                ')' -> out.put;
                out.newline;
            if)
         #);
     mkValueProxy:
       (# descNo,off: @integer; isValueObj,originIsValueObj: @boolean
       enter(descNo,off,isValueObj,originIsValueObj)
       do 'mkValueProxy' -> emitOp; descNo -> out.putint; ' ' ->out.put;
          off -> out.putint; 
          (if isValueObj then ' 1 '->out.puttext else  ' 0 '->out.puttext if); 
          (if originIsValueObj then ' 1 '->out.puttext else ' 0 '->out.puttext if); 
          out.newline;
          (if notLLVM then
              codes.mkValueProxy -> emit; descNo -> emit2; off -> emit2;
              (if isValueObj then 1 -> emit else 0 -> emit if);
              (if originIsValueObj then 1 -> emit else 0 -> emit if);
           else
              
          if)
       #);
     boxedInvokeVal:
       (# N: ^text; descNo,size: @integer
       enter(N[],descNo,size)
       do ' boxedInvokedVal ' -> out.puttext; N[] -> out.puttext; 
          ' ' -> out.put; descNo -> out.putint; 
          ' ' -> out.put; size -> out.putint; out.newline;
          codes.boxedInvokeval -> emit; descNo -> emit2; size -> emit2
       #);
     invokeExternal:
       (# N: ^text; externalNo: @integer
       enter(N[],externalNo)
       do ' invokeExternal ' -> out.puttext; externalNo -> out.putint; 
          out.newline;
          codes.invokeExternal -> emit; externalNo -> emit
       #);
     allocIndexed:
       (# N,eType: ^text; 
          descNo,size,isRefIndexed,staticOff,rN,rNx: @integer;
       enter(N[],descNo,size,isRefIndexed,staticOff) 
         do 'allocIndexed' -> emitOp; N[] -> out.puttext; 
            ' ' -> out.put; descNo -> out.putint; ' ' -> out.put; 
            size -> out.putint; ' ' -> out.put; 
            isRefIndexed -> out.putint; out.newline;
            (if notLLVM then
                codes.allocIndexed -> emit; descNo -> emit2; size-> emit; 
                isRefIndexed -> emit
             else
                stack.put;
                (N[],staticOff) -> typeInfo.lookup -> eType[];
                lcom(#do 'eType: ' -> TT; eType[] -> TT #);
                
                ind;
                allocReg -> rN -> emitRreg -> out.puttext;
                ' = tail call i32 * @allocIndexed(i32 ' -> out.puttext;
                stack.vtop - 1 -> vRegInstack -> out.puttext;
                ',i32 ' -> out.puttext;
                stack.vtop -> vRegInstack -> out.puttext;
                ')\n   ' -> out.puttext;
                
                (rN,'i32*',eType[]) -> bitCast -> rNx;
                
                1 -> stack.rPop;
                2 -> stack.vPop;
                (rNx,eType[]) -> stack.rpushT
            if)
       #);
     exealloc:
       (# N: ^text; descNo: @integer 
       enter(N[],descNo) 
       do 'exeAlloc' -> emitOp; descNo -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.exeAlloc -> emit; descNo -> emit2
       #);
       
     newVrep: (# do ' newVrep ' -> out.putline; codes.newVrep -> emit #);
     send: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do ' send ' -> out.puttext; inx -> out.putint; 
          ' ' -> out.put;  N[] -> out.putline;
          codes.send -> emit; inx -> emit;
       #);
     prepareStub:
       (# stubN,stubOrgN,OGid,stubT,OGt: ^text; stubDescNo,orgDno,rN: @integer
       enter(stubN[],stubDescNo,stubOrgN[],orgDno,OGid[])
       do (if not notLLVM then            
              '%' -> stubT[];
              stubOrgN[] -> stubT.append;
              stubT[] -> doFilter -> stubT[];
              '$' -> stubT.put;
              orgDno -> stubT.putint;
              '*' -> stubT.put;
              '%' -> OGt[];
              OGid[] -> OGt.append;
              '*' -> OGt.put;
              '   %Rx = tail call i8* @malloc(i64 128)\n' -> out.puttext;
              '   %R0 = bitcast i8* %Rx to ' -> out.puttext;
              thisClassP[] -> out.putline;
              lcom(#do 'cast: ' -> TT; stubT[] -> TT; ' ' -> TT; OGt[] -> TT #);
              (1,stubT[],OGt[]) -> bitcast -> rN;
              (rN,OGt[]) -> stack.rpushT;
              stack.put;
              (if false then
                  stubOrgN[] -> puttext;  ' ' -> put; stubT[] -> puttext;
                  ' ' -> put; OGid[] -> puttext; 
              if);
              (if dumpLLVMobjs then
                  ('prepareStub:binding:',stubN[],0,thisClassT[])
                    -> dumpObjX
              if);
              '%' -> stubT[];
              stubN[] -> stubT.append;
              stubT[] -> doFilter -> stubT[];
              '$' -> stubT.put;
              stubDescNo -> stubT.putint;
              '*' -> stubT.put;
              (if false then ' ' -> put; stubT[] -> putline if)
          if)
       exit stubT[]
       #);
     fixTypeOfBinding:
       (* PRE: rstack = [..., binding/callee] *)
       (# bindingType: ^text; rN: @integer
       enter bindingType[]
        do (if not notLLVM and isVstubObject then
               lcom(#do 'fixTypeOfBinding:'->TT; bindingType[] -> TQ;
                      ' typeOnStack:' -> TT; stack.rtype[stack.rtop][] -> TQ;
                   #);
               (stack.rRegNo[stack.rtop],stack.rtype[stack.rtop][]->mkTypePtrX
               ,bindingType[]->mkTypePtrX)
                 -> bitCast -> rN;
               stack.put;
               1 -> stack.rpop;
               (rN,bindingType[]) -> stack.rpushT;
               stack.put
           if)
       #);
     invokeV:
       (# N,T,elmType: ^text; recIsValueObj,useStb: @boolean;
          dinx,noOfRefArgs,rNx,rNy,rNz,rNv,rNw,rNq: @integer;
          originOff:<
            (# off: @integer; topSuperId,type: ^text; useStub: @boolean
            do inner;
               off -> orgOff; useStub -> useStb;
               '%' -> orgType[]; type[] -> orgType.append;
               topsuperId[] -> topId[]
            exit(off ,type,useStub)
            #);
          orgOff: @integer; topId,orgType,Nsig: ^text; isCallVstub: @boolean
       enter(N[],dinx,noOfRefArgs,recIsValueObj) 
          (* OBS! Missing static offset ! *)
       do 'invokev' -> emitOp; dinx -> out.putint; 
          ' ' -> out.put; noOfRefArgs -> out.putint;
          ' ' -> out.put; N[] -> out.puttext;  ' ' -> out.put;
          (if recIsValueObj then '1' -> out.put else '0' -> out.put if);
          out.newline;
         <<SLOT invokev:descriptor>>
       #);
     exe: 
       (# N: ^text enter N[] 
       do ' exe ' -> out.puttext; N[] -> out.putline 
       #);
     call: 
       (# N: ^text; LMR: @char
       enter(N[],LMR)
       do (if notLLVM then
              'call' -> emitOp; LMR -> out.put; ' ' -> out.put; N[] -> out.putline; 
              codes.call -> emit;
              LMR -> emit
           else
              codes.call -> notImpl
              (#
              do ' call(' ->Tx.append; LMR -> Tx.put; ')' -> Tx.put;
                 N[] ->Tx.append
              #)
          if)
       #);
     vdtTablePrint:
       (# descNo: @integer; T: @text
       enter descNo
       do 'vdtTable:Q: ' -> T.puttext;
          (for i: descs.OD[descNo].vdtTable.range repeat 
               (* range is too large *)
               ' ' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[descNo].vdtTable[i] -> T.putint;
               inner
          for); 
          fcom(#do T[] -> TT #);
       #);
     vdtTableCopy:
       (# superDescNo: @integer; T: @text
       enter superDescNo
       do fcom(#do 'VDTtableCopy:'->TT; superDescNo->II; descs.OD.range->II;
                 (*descs.OD[superDescNo].isInner.range -> II;
                 descs.OD[superDescNo].vdtTop -> II*)
              #);
          'vdtTableCopy:' -> T.puttext;
          (for i: descs.OD[superDescNo].vdtTop repeat
               ' ' -> T.put;
               (if descs.OD[superDescNo].isInner[i] then 
                   'I' -> T.put 
                else 
                   'V' -> T.put 
               if);
               ':' -> T.put; i -> T.putint; ':' -> T.put;
               descs.OD[superDescNo].vdtTable[i] -> T.putint; 
               (i,descs.OD[superDescNo].vdtTable[i]
               ,descs.OD[superDescNo].isInner[i]
               ,descs.OD[superDescNo].LLVMsigs[i][]
               ) 
                 -> descs.current.vdtAdd
          for); 
          fcom(#do T[] -> TT #);
          (* copy literals from super to current *)
          descs.OD[superDescNo].literals.range 
            -> descs.current.litTop
            -> descs.current.literals.new;
          (for i: descs.current.litTop repeat
               (*descs.OD[superDescNo].literals[i] -> putint; ',' -> put;*)
               descs.OD[superDescNo].literals[i] -> descs.current.literals[i]
          for);
          (*newline;*)
       #);
     vdtTable:
       (# inx,descInx: @integer; isInner: @boolean; LLVMsig,T: ^text
       enter(inx,descInx,isInner,LLVMsig[])
       do (if not notLLVM then
              (LLVMsig[],thisClassP[],isInner,descInx) -> mkVDTentry -> T[];
          if);
          com(#do inx ->II; descInx->II; isInner->BB #);
          (inx,descInx,isInner,T[]) -> descs.current.vdtAdd -> T[];
          com(#do 'VDTentry:'->TT; T[] -> TT #)
       #);
     vdtTableAt:
       (* For OD:descNo, virtual/inner:inx is bound to descInx *)
       (# inx,descInx,descNo: @integer; LLVMsig,T: ^text
       enter(inx,descInx,descNo,LLVMsig[])
       do (if false then
              '; vdtTableAt: ' -> out.puttext;
              inx -> out.putint; ' ' -> out.put;
              descInx -> out.putint; ' ' -> out.put;
              descNo -> out.putint; out.newline;
          if);
          (if not notLLVM then
              (LLVMsig[],thisClassP[],false,descInx) -> mkVDTentry -> T[];
          if);
          (inx,descInx,descNo,T[]) -> VdtPatch.add
       #);
     VdtPatch: @
       (# index,bindInx,descInx:[5] @ integer; LLVMsigs: [5]^text; top: @integer;
          init: (# do 0 -> top #);
          add:
            (* For OD:dx, virtual/inner:ix is bound to bx *)
            (# ix,bx,dx: @integer; LLVMsig: ^text
            enter (ix,bx,dx,LLVMsig[])
            do (if (top + 1 -> top) > index.range then
                   index.range -> index.extend;
                   bindInx.range -> bindInx.extend;
                   descInx.range -> descInx.extend;
                   LLVMsigs.range -> LLVMsigs.extend
               if);
               ix -> index[top];
               bx -> bindInx[top];
               dx -> descInx[top];
               LLVMsig[] -> LLVMsigs[top][];
               (if not notLLVM then (ix,bx,false,LLVMsig[])
                     -> descs.OD[dx].vdtadd if)
            #);
          patch:
            (# T: ^Text
            do (for i: top repeat
                    (if false then
                        'Patch:range:' -> puttext; index.range -> putint; 
                        ' ' -> put;
                        index[i] -> putint; ' ' -> put;
                        bindinx[i] -> putint; ' ' -> put;
                        descInx[i] -> putint;  ' ' -> put;  newline;
                    if);
                    (index[i],bindInx[i],false,LLVMsigs[i][]) (* never inner? *)
                      -> descs.OD[descInx[i]].vdtAdd -> T[];
                    com(#do T[] -> TT #)
            for)#)
       #);
     toSuper:
       (# descInx: @integer
       enter descInx
       do (if notLLVM then
              'toSuper ' -> emitOp;
              descInx -> out.putint; out.newline;
              codes.toSuper -> emit; descInx -> emit2
           else
              '   ;; toSuper'->out.putline
          if)
       #);
     innerx:
       (# inx: @integer 
       enter inx
       do (if notLLVM then
              'innerX' -> emitOp;
              inx -> out.putint; out.newline;
              codes.innerx -> emit; inx -> emit;
           else
              '   ;; innerx\n' -> out.puttext 
          if)
       #);
     innerP: (* Inner P, where P.ON > 1 *)
       (# inx,rN,rNx,rNy,rNz,vN,vNt,vNf: @integer; elmType: ^text
       enter inx
       do 'innerP' -> emitOp; ' ' -> out.put; 
          inx -> out.putint; out.newline;
          (if notLLVM then             
              codes.innerP -> emit; inx -> emit;
           else
              stack.put;
              (if true then
                  0 -> leag -> rN; (* pointer to vdt *)
                  
                  stack.rType[stack.rtop][] -> elmType[];
                  (2,elmType.length) -> elmType.sub -> elmType[];
                  
                  allocReg -> rNy -> emitRreg -> out.puttext;
                  ' = load ' -> out.puttext;
                  elmType[] -> vdtType -> out.puttext;
                  ', ' -> out.puttext;
                  elmType[] -> vdtType -> out.puttext;
                  '* ' -> out.puttext; 
                  rN -> emitRreg -> out.puttext;
                  '\n' -> out.puttext;
                  
                  (* rN = ptrToVDT; Load vdt[inx - 1] = inner *)
                  (rNy,elmType[] -> vdtType -> deRef,inx - 1) 
                    -> leaReg -> rNx;
                  
               else
                  0 -> leag -> rN; (* pointer to vdt *)
                  
                  allocReg -> rNy -> emitRreg -> out.puttext;
                  ' = load ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '*, ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '** ' -> out.puttext; 
                  rN -> emitRreg -> out.puttext;
                  '\n   ' -> out.puttext;
              
                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = getelementptr ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  ', ' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '* ' -> out.puttext; 
                  rNy ->  emitRreg -> out.puttext; 
                  ', i32 0, i32 ' -> out.puttext; inx - 1 -> out.putint;
                  '\n   ' -> out.puttext;
              if);
              allocReg -> rNz -> emitRreg -> out.puttext; 
              ' = load ' -> out.puttext;
              (if true then
                  ' i8*(i8*)*, i8*(i8*)** ' -> out.puttext;
               else
                  thisClassId[] -> vdtType -> out.puttext;
                  ',' -> out.puttext;
                  thisClassId[] -> vdtType -> out.puttext;
                  '* ' -> out.puttext;
              if);
              rNx -> emitRreg -> out.puttext;
              '\n   ' -> out.puttext;
              
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = icmp eq i8*(i8*)* ' -> out.puttext; 
              rNz -> emitRreg -> out.puttext;
              ', null\n   ' -> out.puttext;
              allocReg -> vNt; allocReg -> vNf;
              'br i1 ' -> out.puttext; vN -> emitVreg -> out.puttext;
              ', label %L' -> out.puttext; vNt -> out.putint;
              ', label %L' -> out.puttext; vNf -> out.putint;
              out.newline;
              'L' -> out.puttext; vNf -> out.putint; ':\n' ->out.puttext;
              '   ;; inner not null\n   ' -> out.puttext;
              (stack.rRegNo[stack.rTop],stack.rType[stack.rTop][],'i8*')
                -> bitCast -> rNx;
              
              'call i8* '  -> out.puttext; 
              rNz -> emitRreg -> out.puttext;  
              '(i8* ' -> out.puttext;
              rNx -> emitRreg -> out.puttext;              
              ')\n   ' -> out.puttext;
              'br label %L' -> out.puttext; vNt -> out.putint; 
              out.newline;
              'L' -> out.puttext; vNt -> out.putint; ':\n' ->out.puttext;
              1 -> stack.rPop              
          if)
       #);
     innerExit:
       (# inx: @integer 
       enter inx
       do 'innerExit' -> emitOp; ' ' -> out.put; inx -> out.putint; out.newline;
          codes.innerExit -> emit; inx -> emit;

       #);
     innerA:
       (# inx: @integer 
       enter inx
       do 'innerA ' -> emitOp; ' ' -> out.put; inx -> out.putint; out.newline;
          (if notLLVM then              
              codes.innerA -> emit; inx -> emit;
          if)
       #);
     suspendd: 
       (# 
       do (if notLLVM then
              'suspend' -> emitOp; codes.susp -> emit 
           else
              codes.susp -> notImpl(#do 'suspend' -> Tx.append #)
          if)
       #);
     doSuper: 
       (# N: ^text; inx: @integer 
       enter(N[],inx) 
       do 'doSuper' -> emitOp; ' ' -> out.put; N[] -> out.puttext; 
          ' ' -> out.put; inx -> out.putint; out.newline;
          codes.doSuper -> emit; inx -> emit2;
       #);

     pushThis:
       (# 
       do 'pushThis' -> emitOp; out.newline;
          (if notLLVM then              
              codes.pushthis -> emit; 
           else
              (0,thisClassP[]) -> stack.rPushT;
              lcom(#do thisClassP[] -> TT #)
          if)
       #);
     pushValId:
       (# 
       do (if notLLVM  then
             'pushValId'->emitOp; out.newline; codes.pushValId -> emit
          else
              '\n!!! LLVM: pushValId  nothandled!\n' -> putline;
              1 -> pushConst;
              (* must be thisValObjDescInx below*)
              111 -> pushConst
          if)
       #);
     push: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do (if notLLVM then
              ' push ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.push -> emit; off -> emit;
              stack.vPush
           else
              '   ;; push ' -> out.puttext; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
          if)
       #);
     pushg: 
       (# N,rNtype: ^text; off: @integer; rN,rN1,rN2: @integer
       enter(N[],off)
       do 'pushg' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then              
              codes.pushg -> emit; off -> emit;
           else
              (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
                  (if false then
                      '*** pushg:in value object: ' -> puttext;
                      N[] -> putline;
                  if);
                  off -> leag -> rN;                  
                  (rN,'i32*','[0 x i32]*') -> bitCast -> rN1;
                  allocReg -> rN2 -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                    -> out.puttext;
                  rN1 -> emitRreg -> out.puttext;
                  ', i32 0, i32 %off\n' -> out.puttext;
                  rN2 -> rN
               else
                  off -> leag -> rN;
              if);
              ind;
              allocReg -> rN2 -> emitVreg -> out.puttext;
              ' = load i32, i32* ' -> out.puttext;
              rN -> emitRreg -> out.puttext;
              out.newline
          if);
          1 -> stack.rpop; 
          rN2 -> stack.vPush; (* push of value - no type needed *)
       #);
     vpushg:
       (# N: ^text; off: @integer;
       enter(N[],off)
       do 'vpushg' -> emitOp; off -> out.putint;
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then
              codes.vpushg -> emit; off -> emit;
          if);
       #);
     fpushg: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do (if notLLVM then
              'fpushg' -> emitOp; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fpushg -> emit; off -> emit;
           else
              '   ;; fpushg\n' ->  out.puttext
          if)
       #);
     fvpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do (if notLLVM then
              'fvpushg' -> emitOp; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fvpushg -> emit; off -> emit;
           else
              '   ;; fvpushg\n' ->  out.puttext
          if)
       #);     
     ovpushg:
       (* Object X on stack with object P embedded at offset inx in X
        * inx is on vStack
        * Push P[off] = X[inx + off - 1]
        * 'ovpushg'-> exe; op1 -> off; 
        thisStack.vpop -> value;
        thisStack.rpop -> X[];
        off  + value - 1 
        *)
       (# N: ^text; off,rN,rNx,vN,vNx: @integer
       enter(N[],off)
       do 'ovpushg' -> emitOp; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          (if notLLVM then
              codes.ovpushg -> emit; off -> emit;
           else
              stack.put;
              1 -> stack.vpop;
              stack.put;              
              (stack.rRegNo[stack.rTop],stack.rType[stack.rTop][]
              , '[0 x i32]*')
              -> bitCast -> rNx;
              
              allocReg -> vNx -> emitVreg -> out.puttext;
              ' = add i32 ' -> out.puttext;
              off - 1 -> out.putint; ',' -> out.put;
              stack.vTop -> vRegInStack -> out.puttext;
              out.newline;
              
              (if false then
                  'call i32 @putHex(i32 ' -> out.puttext;
                  vNx -> emitVreg -> out.puttext;
                  ')\n' -> out.putline;
              if);
              
              allocReg -> rN  -> emitRreg -> out.puttext;
              ' = getelementptr inbounds ' -> out.puttext;
              ' [0 x i32], ' -> out.puttext;
              ' [0 x i32]* ' -> out.puttext;
              rNx -> emitRreg -> out.puttext;
               ', i32 0, i32 ' -> out.puttext;
              vNx -> emitVreg -> out.puttext;
              out.newline;
              
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = load i32 , i32* ' -> out.puttext; 
              rN -> emitRreg -> out.puttext;
              ', align 4\n' -> out.puttext;
              1 -> stack.vPop;
              vN -> stack.vPush;
              stack.put
          if)
       #);
     fovpushg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do 'fovpushg' ->emitOp; off -> out.putint; ' ' -> out.put; 
          N[] -> out.putline;
          codes.fovpushg -> emit; off -> emit;
       #);     
     rpush: 
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' rpush ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.rpush -> emit; off -> emit;
          stack.rPush
       #);
     rpushg: 
       (# N: ^text; off: @integer; rN,rN2: @integer; T,elmType: ^text
       enter(N[],off)
       do 'rpushg' -> emitOp; N[] -> out.puttext; 
          ' ' -> out.put; off -> out.putint; out.newline;
          <<SLOT rpushg:descriptor>>;
       #);
     xpushg:
       (# N,xType: ^text; isValueObj,size,rN,rNx,vN,vNx: @integer
       enter(N[],isValueObj,size) 
       do 'xpushg ' -> emitOp; N[] -> out.puttext;  ' ' -> out.put; 
          size -> out.putint; ' ' -> out.put; 
          isValueObj -> out.putint; out.newline;  
          (if notLLVM then
              codes.xpushg -> emit; size -> emit;  isValueObj -> emit; 
           else
              (* X = rStack[rTop] = adr of Indexed obj; may be a Sring
               * inx = vDtack[vTop]
               * push X[off + inx]
               *)
              stack.put;

              stack.rType[stack.rTop][] -> xType[];
             
              (if ('%String' -> ((1,7) -> xType.sub).equal)
                  and (stack.vVal[stack.vtop][] <> none)
                  and  (stack.vVal[stack.vtop].V = 0) then
                  (if false then
                      '**** xpushg: string[0] = length ' -> putline;
                  if);
                  (stack.rRegNo[stack.rTop]
                  ,stack.rType[stack.rTop][]
                  ,'i32*')  
                    -> bitCast ->rN;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = call i32 @arrayLength(i32* ' -> out.puttext;
                  rN -> emitRreg -> out.puttext;
                  ')\n' -> out.puttext;
               else
                  (if ('%String' -> ((1,7) -> xType.sub).equal) then
                      ';; xpusg:String\n' -> out.puttext;
                      (stack.rRegNo[stack.rTop]
                      , stack.rType[stack.rTop][]
                      ,'{i32*,i32,[0 x i32]}*')
                        -> bitCast
                        -> stack.rRegNo[stack.rTop];
                      '{i32*,i32,[0 x i32]}*' ->  stack.rType[stack.rTop][]
                  if);
                  allocReg -> vNx -> emitVreg -> out.puttext;
                  ' = add i32 -1, ' -> out.puttext;
                  stack.vTop -> vRegInStack -> out.puttext;
                  out.newline;
                  
                  allocReg -> rN  -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds ' -> out.puttext;
                  stack.rType[stack.rTop][] -> deRef -> out.puttext;
                  ', ' -> out.puttext; 
                  stack.rType[stack.rTop][] -> out.puttext;
                  ' ' -> out.puttext;
                  stack.rTop -> rReg -> out.puttext;
                  ', i32 0, i32 2\n' -> out.puttext; 
                  
                  (* rN = adr of Indexed obj
                   * rStack[rTop] = typeOf(rN) *)

                  allocReg -> rNx -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                    -> out.puttext;
                  rN -> emitRreg -> out.puttext;
                  ', i32 0, i32 ' -> out.puttext;
                  vNx -> emitVreg -> out.puttext;
                  out.newline;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = load i32 , i32* ' -> out.puttext; 
                  rNx -> emitRreg -> out.puttext;
                  ', align 4\n' -> out.puttext;
              if)
          if);
          1 -> stack.rpop;
          1 -> stack.vpop;
          vN -> stack.vPush
       #);
     xrpush:
       (# N: ^text;
       enter N[]
       do 'xrpush ' -> emitop; N[] -> out.putline;
          codes.xrpush -> emit;
       #);    
     xrpushg:
       (# N: ^text;
       enter N[]
       do 'xrpushg' -> emitop; N[] -> out.putline;
          (if notLLVM then
              codes.xrpushg -> emit; 
           else
              codes.xrpushg -> notImpl
          if)
       #);
     pushConst: 
       (# cst: @integer; rn: @integer
       enter cst
       do 'pushc' -> emitop; cst -> out.putint; out.newline;
          <<SLOT pushConst:descriptor>>
       #);
     pushFloatConst:
       (# X: @Real
       enter X
       do (if notLLVM then
              'pushFloatConst' -> emitOp; X -> out.putReal; 
              out.newline;
              codes.pushFloatConst -> emit;
              X -> emit8
           else
              '   ;; pushFloatConst \n' -> out.puttext;
          if)
       #);
     pushNone: 
       (# rN: @integer
       do 'pushNone' -> emitOp; out.newline;
          (if notLLVM then
              codes.pushNone -> emit;
              stack.rPush
           else
              (0,'null') -> stack.rPushT
          if);

       #);
     pushText:
       (# T,T1: ^text; stringDescNo,I: @integer
       enter (T[],stringDescNo)
       do (if notLLVM then
              'pushText' -> emitOp; 
              '"' -> out.put; T[] -> out.puttext; '"' -> out.put; out.newline;
              codes.pushText -> emit;
              T[] -> handleEscape -> T1[];
              T1.length -> descs.current.addLiteral
              (#
              do i + 1 -> i -> T1.inxGet -> value;
              #) -> emit;

              stack.rPush
           else
              ';; pushText \n' -> out.puttext;
              (T[],stringDescNo) -> AllocString;
          if)
       #);
     handleEscape:
       (# T: ^text; T1: @text;
          nextCh: 
            (# 
            do i + 1 -> i;
               (if i <= T.length then
                   i -> T.inxGet -> ch;
                else
                   0 -> ch
               if);               
            #);
          ch: @char;
          i: @integer
       enter T[]
       do 0 -> i;
          nextCh;
          loop:
            (if i <= T.length then 
                (if ch 
                 // '\\' then 
                    nextCh;
                    (if ch
                     // 'n' then
                        ascii.nl -> T1.put;
                        nextch
                     // '\\' then
                        '\\' -> T1.put;
                        nextch;
                     // 't' then
                        ascii.ht -> T1.put;
                        nextch;
                     // '{' // '}' then
                        ch -> T1.put;
                        nextCh
                     else
                        '\\' -> T1.put
                    if)
                 else
                    ch -> T1.put;
                    nextCh;                    
                if);
                restart loop
            if)
       exit T1[]
       #);
     mkStrucRef:
       (# T: ^text
       enter T[]
       do 'mkStrucRef' -> emitOp; T[] -> out.putline;
          codes.mkStrucRef -> emit
       #);
      mkObjStrucRef:
       (# T: ^text
       enter T[]
       do 'mkObjStrucRef' -> emitOp; T[] -> out.putline;
          codes.mkObjStrucRef -> emit
       #);
     mkVirtualStrucRef:
       (# T: ^text; off: @integer
       enter(T[],off)
       do 'mkVirtualStrucRef' -> emitOp; off-> out.putint; out.newline;
          codes.mkVirtualStrucRef -> emit; off -> emit
       #);
     allocFromStrucRefObj:
       (#
       do 'allocFromStrucRefObj' -> emitOp; out.newline;
          codes.allocFromStrucRefObj -> emit;
       #);
     pushValue:
       (# off,size,descNo: @integer
       enter(off,size,descNo)
       do 'pushvalue' -> emitop; ' off:'->out.puttext; off->out.putint;
          ' size:'->out.puttext; size -> out.putint; 
          ' descNo: ' -> out.puttext; descno -> out.putint; out.newline;
          (if notLLVM then
              codes.pushValue -> emit; off -> emit2; size -> emit;
           else
              '!!!! LLVM:pushValue not implemented!' -> putline
          if)
       #);
     vassign:
       (# off,size,mode: @integer
       enter(off,size,mode)
       do 'vassign' -> emitOp; off -> out.putint; ' ' -> out.put;
          size -> out.putint; ' ' -> out.put; mode -> out.putint; out.newline;
          (if notLLVM then
              codes.vassign -> emit; off -> emit2; size -> emit; 
              mode -> emit
           else
              '!!!! LLVM:vassign not implemented!' -> putline
          if);
       #);
     vEq:
       (# off,size: @ integer; (* do we need mode her? *)
       enter(off,size)
       do 'vEq' -> emitOp; off -> out.putint; ' ' -> out.put;
          size -> out.putint; out.newline;
          (if notLLVM then
              codes.vEq -> emit; off -> emit2; size -> emit
           else
              '!!!! LLVM:vEq not implemented!' -> putline
          if)
       #);
     store: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do 'store' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then
              codes.store -> emit; off -> emit;
              1 -> stack.vpop
           else
              lcom(#do 'store:ignored' -> TT #)
          if)
       #);
     storeX: 
       (# N: ^text; off,rN: @integer
       enter(N[],off) 
       do (if notLLVM then
              'store' -> emitOp; off -> out.putint; 
              ' ' -> out.put; N[] -> out.putline;
              codes.store -> emit; off -> emit;
              1 -> stack.vpop
           else
              '   ;; storeX ' -> out.puttext; N[] -> out.puttext;
              ' ' -> out.put; off -> out.putint; out.newline;
              stack.put;
              ind;
              allocReg -> rN -> emitRreg -> out.puttext;
              ' = getelementptr ' -> out.puttext; 
              N[] -> prepStruct -> out.puttext;
              ', ' -> out.puttext;
              N[] -> prepStruct -> out.puttext; 
              ' * ' -> out.puttext;
              stack.rTop -> rReg -> out.puttext;
              ', i32 0, i32 ' -> out.puttext; off -> out.putint; 
              out.newline;
              '   store i32 ' -> out.puttext;
              stack.vTop -> vRegInStack -> out.puttext;
              ', i32* ' -> out.puttext; rN -> emitRreg -> out.putline;
              1 -> stack.vpop
          if)
       #);
     storeg: 
       (# N: ^text; off: @integer; rN,rN1,rN2,vN: @integer
       enter(N[],off) 
       do 'storeg' -> emitop;  N[] -> out.puttext; 
          ' '-> out.put; off -> out.putint; out.putline;
          (if notLLVM then
              codes.storeg -> emit; off -> emit;
           else
              (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
                  (if false then
                      '*** storeg:in value object: ' -> puttext;
                      N[] -> putline;
                  if);
                  off  -> leag -> rN;                  
                  (rN,'i32*','[0 x i32]*') -> bitCast -> rN1;
                  allocReg -> rN2 -> emitRreg -> out.puttext;
                  ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                    -> out.puttext;
                  rN1 -> emitRreg -> out.puttext;
                  ', i32 0, i32 %off\n' -> out.puttext;
                  rN2 -> rN
               else
                  off -> leag -> rN;
              if);
              
              (if stack.vType[stack.vtop] = 1 then
                  ind;
                  allocReg -> vN -> emitVreg -> out.puttext;
                  ' = zext i1 ' -> out.puttext;
                  stack.vRegNo[stack.vtop] -> emitVreg -> out.puttext;
                  ' to i32\n' -> out.puttext
               else
                  stack.vRegNo[stack.vtop] -> vN
              if);
              '   store i32 ' -> out.puttext;
              vN -> emitVreg -> out.puttext;
              ', i32* ' -> out.puttext; 
              rN -> emitRreg -> out.putline;
              1 -> stack.vpop;
              1 -> stack.rpop
          if)          
       #);
     vstoreg:
       (# N: ^text; off: @integer; rN,rN1,rN2,vN: @integer
       enter(N[],off)
       do 'vstoreg' -> emitop;  N[] -> out.puttext;
          ' '-> out.put; off -> out.putint; out.putline;
          (if notLLVM then
              codes.vstoreg -> emit; off -> emit;
           else
              '   ;; vstoreg \n' -> out.puttext;
          if)
       #);
     fstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do (if notLLVM then
              'fstoreg' -> emitOp; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fstoreg -> emit; off -> emit;
           else
              '   ;; fstoreg \n' -> out.puttext;
          if);
          1 -> stack.vpop          
       #);   
     fvstoreg: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do (if notLLVM then
              'fvstoreg ' -> emitOp; off -> out.putint; ' ' -> out.put; 
              N[] -> out.putline;
              codes.fvstoreg -> emit; off -> emit;
           else
              '   ;; fvstoreg \n' -> out.puttext;
          if);
          1 -> stack.vpop          
       #);
     ovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' ovstoreg ' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM then
              codes.ovstoreg -> emit; off -> emit;
           else
              '!!!! LLVM:ovstoreg not implemented!' -> putline;
              1 -> stack.vpop
          if)
       #);
     fovstoreg:
       (# N: ^text; off: @integer
       enter(N[],off)
       do ' fovstoreg ' -> out.puttext; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          codes.fovstoreg -> emit; off -> emit;
          1 -> stack.vpop
       #);  
     rstore:
       (# N: ^text; off,rN: @integer
       enter(N[],off) 
       do 'rstore ' ->emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.putline;
          (if notLLVM  then              
              (if off <= 255 then 
                  codes.rstore -> emit; off -> emit
              if);
           else
              lcom(#do 'rstore:ignored' -> TT #)
          if)
       #);
     rstoreX: 
       (# N,srcT: ^text; off,rN: @integer; 
          isValueObjectOrigin: @boolean
       enter(N[],off,isValueObjectOrigin) 
       do 'rstoreX' -> emitOp; off -> out.putint; 
          ' ' -> out.put; N[] -> out.puttext;
          ' isValueObjectOrigin: ' -> out.puttext; 
          (if isValueObjectOrigin then 'T' -> out.put else 'F' ->out.put if);
          out.newline;
          (if notLLVM  then              
              (if off <= 255 then 
                  codes.rstore -> emit; off -> emit
              if);
           else
              stack.put;
              (* rstore rReg[rTop - 1] in rReg[rTop].off *)
              (N[],off) -> typeInfo.lookup -> srcT[];
              '   ;; lookup:  ' -> out.puttext;  srcT[] -> out.putline;
              stack.put;
              (if isValueObjectOrigin then
                  '   ;; store origin being value object' ->out.putline;
                  off + 1 -> leag -> rN;   (* offSet in holder *)

                  (* OBS! Why vTop -1 below? What is in vTop? *)
                  'store i32 ' -> out.puttext;
                  stack.vRegNo[stack.vtop - 1] -> emitVreg -> out.puttext;
                  ', i32* ' -> out.puttext;
                  rN -> emitRreg -> out.putline;
                  off + 2 -> leag -> rN;   (* descNo of value obj *)
                  'store i32 ' -> out.puttext;
                  stack.vRegNo[stack.vtop] -> emitVreg -> out.puttext;
                  ', i32* ' -> out.puttext;
                  rN -> emitRreg -> out.putline;
              if);
              (* leaReg -> rN = rstack[rTop] *)
              ind;
              allocReg -> rN -> emitRreg -> out.puttext;
              ' = getelementptr ' -> out.puttext; 
              N[] -> prepStruct -> out.puttext;
              ', ' -> out.puttext;
              N[] -> prepStruct -> out.puttext; 
              ' * ' -> out.puttext;
              stack.rTop -> rReg -> out.puttext;
              ', i32 0, i32 ' -> out.puttext; off -> out.putint; 
              out.newline;
              (if stack.rtop < 2 then
                  '\n!!!! rstoreX: stack.rtop < 2' -> putline;
                  '   ;; rstoreX: stack.rtop < 2' -> out.putline;
                  leave rstoreX
              if);
              stack.print;        
              (if not (srcT[] -> stack.Rtype[stack.rTop - 1].equal) then
                  (rN,'*' -> (srcT.copy).put
                  (*,'*' -> (stack.Rtype[stack.rTop - 1].copy).put*)
                  ,stack.Rtype[stack.rTop - 1][] -> mkTypePtr2Ptr
                  )
                    -> bitCast -> rN;
              if);
              '   store ' -> out.puttext;
              stack.Rtype[stack.rTop - 1][] -> mkTypePtrX -> out.puttext; 
              ' ' -> out.puttext;
              stack.rtop - 1 -> rReg -> out.puttext;  
              ', ' -> out.puttexT;
              stack.Rtype[stack.rTop - 1][] -> mkTypePtrX -> out.puttext; 
              '* ' -> out.puttext;
              rN -> emitRreg -> out.putline;
              (if false then
                  ('rstorex:',stack.Rtype[stack.rTop][]
                  ,stack.rRegNo[stack.rTop], N[] -> prepStruct) 
                    -> dumpObjX;
              if);
              rswap;
              1 -> stack.rPop;
          if)
       #);
     rstoreg: 
       (# N: ^text; off,rN,rNd: @integer; srcType,dstType,rNtype: ^text;
          isNull: @boolean
       enter(N[],off) 
       do 'rstoreg' -> emitOp; N[] -> out.puttext;
          ' ' -> out.put; off -> out.putint; out.newline;
          (if notLLVM then
              (if off <= 255 then 
                  codes.rstoreg -> emit; off -> emit
              if);
           else
              off -> leag -> rN;
              
              (N[],off) -> typeInfo.lookup -> dstType[];
              
              stack.rType[stack.rTop - 1][] -> srcType[];
              (if 'null' -> srcType.equal then
                  dstType[]
                    -> stack.rType[stack.rTop][] 
                    ->  stack.rType[stack.rTop - 1][]
                    -> srcType[];
                  true -> isNull;
                  ';; isNull: ' -> out.puttext; stack.print -> out.putline
              if);
              ';; types:dst: ' -> out.puttext; dstType[] -> out.puttext; 
              ' src: ' -> out.puttext; srcType[] -> out.putline;
              (if (dstType[] -> srcType.equal) 
                  then
                  '   store ' -> out.puttext; 
                  (if isNull then
                      srcType[] -> out.puttext;    
                      ' null, ' -> out.puttext;
                       dstType[] -> out.puttext;    
                      ' * ' -> out.puttext;
                   else
                      stack.rType[stack.rTop - 1][] -> out.puttext; 
                      '  ' -> out.puttext;
                      stack.rtop - 1-> rReg -> out.puttext; 
                      ', ' -> out.puttext; 
                      stack.rType[stack.rTop - 1][] -> out.puttext;    
                      ' * ' -> out.puttext;
                  if);
                  rN -> emitRreg -> out.puttext; out.newline;
               else
                  (stack.rRegNo[stack.rTop - 1],srcType[],dstType[]) 
                    ->  bitCast -> rNd;
                  stack.put;
                  '   store ' -> out.puttext; 
                  dstType[] -> out.puttext;
                  ' ' -> out.put; rNd -> emitRreg -> out.puttext;
                  ', ' -> out.puttext;
                  dstType[] -> out.puttext;    
                  ' * ' -> out.puttext;
                  rN -> emitRreg -> out.puttext; out.newline;
          if)if);
          2 -> stack.rPop;
          stack.put;
       #);
     xstoreg: 
       (# N: ^text; isValueObj,size,vN,rN,rNx: @integer
       enter(N[],isValueObj,size) 
       do 'xstoreg' -> emitop; N[] -> out.puttext; ' ' -> out.put;
         ' size:' -> out.puttext;  size -> out.putint; 
         ' isValueObj:'->out.puttext; isValueObj -> out.putint; out.newline;
          (if notLLVM then
              codes.xstoreg -> emit; size -> emit; isValueObj -> emit; 
           else
              stack.put;
              allocReg -> vN -> emitVreg -> out.puttext;
              ' = add i32 -1, ' -> out.puttext;
              stack.vTop -> vRegInStack -> out.puttext;
              out.newline;
              
              allocReg -> rN  -> emitRreg -> out.puttext;
              ' = getelementptr inbounds ' -> out.puttext;
              stack.rType[stack.rTop][] -> deRef -> out.puttext;
              ',  ' -> out.puttext; 
              stack.rType[stack.rTop][] -> out.puttext;
              ' ' -> out.puttext;
              stack.rTop -> rReg -> out.puttext;
              ', i32 0, i32 2\n' -> out.puttext;
              
              allocReg -> rNx -> emitRreg -> out.puttext;
              ' = getelementptr inbounds [0 x i32], [0 x i32]* ' 
                -> out.puttext;
              rN -> emitRreg -> out.puttext;
              ', i32 0, i32 ' -> out.puttext;
              vN -> emitVreg -> out.puttext;
              (*stack.vTop -> vRegInStack -> out.puttext;*)
              out.newline;
              
              'store i32 ' -> out.puttext; 
              stack.vTop - 1 -> vRegInStack -> out.puttext;
              ', i32* ' -> out.puttext;
              rNx -> emitRreg -> out.puttext;
              ', align 4\n' -> out.puttext;
          if);
          1 -> stack.rpop;
          2 -> stack.vpop
       #);     
     xrstore: 
       (# N: ^text; off: @integer
       enter(N[],off) 
       do ' xrstore ' -> out.puttext;  N[] -> out.putline;
          (if off <= 255 then 
              codes.xrstore -> emit; 
          if);
          2 -> stack.rpop
       #);
     xrstoreg: 
       (# N: ^text;
       enter N[]
       do ' xrstoreg ' -> out.puttext;  N[] -> out.putline;
          codes.xrstoreg -> emit; 
          1 -> stack.rpop
       #);
     double: 
       (# 
       do 'double' -> emitOpL; codes.double -> emit; 
          stack.vPush; stack.vpush 
       #);
     rdouble: 
       (# off: @integer
       enter off (*currently just used for LLVM *)
       do 'rdouble' -> emitOp; off -> out.putint; out.newline;
          (if notLLVM then
              codes.rdouble -> emit;
           else
              (if (stack.rTop < 1)  then
                  codes.rdouble->notImpl
                  (#do ' rtop:' -> Tx.puttext; stack.rtop ->tx.putint #);
                  leave rdouble
              if);
              stack.put;
              (stack.rRegNo[stack.rtop],stack.rType[stack.rtop][]) 
                -> stack.rpushT;
              (if true
               // off = -1 then
                  (if (stack.rTop < 3)  then
                      codes.rdouble->notImpl
                      (#do ' rtop:' -> Tx.puttext; stack.rtop ->tx.putint #);
                      leave rdouble
                  if);
                  stack.rRegNo[stack.rtop - 2] 
                    -> stack.rRegNo[stack.rtop - 1];
                  stack.rType[stack.rtop - 2][]
                    -> stack.rType[stack.rtop - 1][];
               // off <> 0 then
                  (* we assume that off = - 1 or 0 *)
                  codes.rdouble ->notImpl
                      (#do 'off must be 0 or -1' -> Tx.append #)
              if);
              stack.put;
          if);
       #);
     swap: 
       (# rn: @integer
       enter rn
       do 'swap' -> emitOp; rn -> out.putint; out.newline;
          codes.swap -> emit; rn -> emit
       #); (* not used*)
     rswap: 
       (# rn,R: @integer; T: ^text
       enter rn
       do 'rswap' -> emitOp; rn -> out.putint; out.newline;
          (if notLLVM then              
              codes.rswap -> emit; rn -> emit
           else
              (if stack.rtop < 2 then
                  '   ;;; rswap: stack.rtop < 2' -> out.putline;
                  '\n!!!! rswap: stack.rtop < 2' -> putline;
                  leave rswap
              if);
              stack.RregNo[stack.rtop] -> R;
              stack.RregNo[stack.rtop - 1] -> stack.RregNo[stack.rtop];
              R -> stack.RregNo[stack.rtop - 1];
              stack.rType[stack.rtop][] -> T[];
              stack.rType[stack.rtop - 1][] 
                -> stack.rType[stack.rtop][];
              T[] -> stack.rType[stack.rtop - 1][]
          if)
       #);
     rPop: 
       (# 
       do 'rpop' -> emitOp; out.newline;
          (if notLLVM then
              codes.rpop -> emit; 1 -> stack.rPop 
           else
              1 -> stack.rPop;
          if)
       #);
     vPop: 
       (# 
       do (if notLLVM then
              'vpop' -> emitOp; codes.vpop -> emit; 1 -> stack.vPop 
           else
              1 -> stack.vPop
          if)
       #);
     vShiftUp:
       (# rn: @integer
       enter rn
       do 'vShiftUp' -> emitOp; rn -> out.putint; out.newline;
          (if notLLVM then
              codes.vShiftUp -> emit; rn -> emit
           else
              notImpl(#do 'vShiftUp' -> Tx.append #)
          if);
       #);
     vShiftdown:
       (# rn: @integer
       enter rn
       do 'vShiftDown' -> emitOp; rn -> out.putint; out.newline;
          (if notLLVM then
              codes.vShiftDown -> emit; rn -> emit
           else
              notImpl(#do 'vShiftUp' -> Tx.append #)
          if);
       #);        
     rShiftUp:
       (# rn: @integer
       enter rn
       do 'rShiftUp ' -> emitOp; rn -> out.putint; out.newline;
          (if notLLVM then
              codes.rShiftUp -> emit; rn -> emit
           else
              notImpl(#do 'rShiftUp' -> Tx.append #)
          if);
       #);
     rShiftDown:
       (# rn: @integer
       enter rn
       do 'rShiftDown' -> emitOp; rn -> out.putint; out.newline;
          (if notLLVM then
              codes.rShiftDown -> emit; rn -> emit
           else
              notImpl(#do 'rShiftDown' -> Tx.append #)
          if);
       #);
     callPrim:
       (# P: ^text; op: @integer
       enter(P[],op)
       do '%'->P.prePend -> emitOp; op -> out.putint; out.newline;
          <<SLOT callPrim:descriptor>>
       #);
     callPrim2:
       (# P: ^text; op,arg: @integer
       enter(P[],op,arg)
       do '%'->P.prePend -> emitOp; op -> out.putint; ' '->out.put; 
           arg->out.putint; out.newline;
          <<SLOT callPrim2:descriptor>>
       #);
     op: 
       (# operator: @integer; 
          LLVMvOp:
            (# opT: ^text
            enter opT[]
            do ind;
               allocReg -> rN -> emitVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' i32 ' -> out.puttext; stack.vtop - 1 -> vRegInStack -> out.puttext;
               ', ' -> out.puttext; stack.vtop -> vRegInStack -> out.putline;
               inner
            #);
          LLVMbOp: LLVMvOp
            (#
            do 2 -> stack.vpop;
               rN -> stack.vPush;
               1 -> stack.Vtype[stack.vTop]
            #);
          LLVMboolOp:
            (# opT: ^text
            enter opT[]
            do ind;
               allocReg -> rN -> emitVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' i1 ' -> out.puttext; stack.vtop - 1 -> vRegInStack -> out.puttext;
               ', ' -> out.puttext; stack.vtop -> vRegInStack -> out.putline;
               2 -> stack.vpop;
               rN -> stack.vPush;
               1 -> stack.Vtype[stack.vTop]
            #);
           LLVMRefRelOp:
            (# opT: ^text; rN,rNx: @integer; rIsNull,lIsNull: @boolean
            enter opT[]
            do 
               (if true
                // 'null' -> stack.rType[stack.rTop].equal then
                   true -> rIsNull
                // 'null' -> stack.rType[stack.rTop - 1].equal then
                   true -> lIsNull
                else
                   stack.rRegNo[stack.rtop] -> rNx;
                   (if stack.rType[stack.rtop][] 
                         -> stack.rType[stack.rtop - 1].equal then
                    else
                       (rNx,stack.rType[stack.rtop][]
                       ,stack.rType[stack.rtop - 1][])
                         -> bitCast
                         -> rNx                   
               if)if);
               ind;
               allocReg -> rN -> emitVreg -> out.puttext;
               ' = ' -> out.puttext; opT[] -> out.puttext;
               ' ' -> out.puttext;
               (if true
                // rIsNull then
                   stack.rType[stack.rtop  - 1][] -> out.puttext;
                   ' ' -> out.put;
                   stack.rtop - 1 -> rReg -> out.puttext;
                   ', null\n' -> out.puttext;
                // lIsNull then
                   stack.rType[stack.rtop][] -> out.puttext;
                   ' ' -> out.put;
                   stack.rtop -> rReg -> out.puttext;
                   ', null\n' -> out.puttext;                   
                else
                   stack.rType[stack.rtop  - 1][] -> out.puttext;
                   ' ' -> out.put;
                   stack.rtop - 1 -> rReg -> out.puttext;
                   ', ' -> out.puttext; rNx -> emitrReg -> out.putline;
               if);
               2 -> stack.rpop;
               rN -> stack.vPush;
               1 -> stack.vType[stack.vTop]
            #);
          rn: @integer
       enter operator
       do (if notLLVM then
              (if operator
               // codes.plus then 'plus' -> emitOp; 
               // codes.minus then 'minus' -> emitOp
               // codes.uminus then 'uminus' -> emitOp
               // codes.mult then 'mult' -> emitOp; 
               // codes.rdiv then 'div' -> emitOp (* not used? *)
               // codes.idiv then 'idiv' -> emitOp
               // codes.modd then 'modd' -> emitOp
               // codes.eq then 'eq' -> emitOp
               // codes.lt then 'lt' -> emitOp; 
               // codes.le then 'le' -> emitOp;
               // codes.gt then 'gt' -> emitOp;
               // codes.ge then 'ge' -> emitOp
               // codes.ne then 'ne' -> emitOp
               // codes.andd then 'andd' -> emitOp
               // codes.orr then 'orr' -> emitOp
               // codes.xorr then 'xorr' -> emitOp
               // codes.nott then 'nott' -> emitOp
               // codes.req then 'req' -> emitOp
               // codes.rne then 'rne' -> emitOp
               // codes.fplus then 'fplus' -> emitOp
               // codes.fminus then 'fminus' -> emitOp
               // codes.funaryminus then 'funaryminus' -> emitOp
               // codes.fmult then 'fmult' -> emitOp
               // codes.fdiv then 'fdiv' -> emitOp
               // codes.feq then 'feq' -> emitOp
               // codes.flt then 'flt' -> emitOp 
               // codes.fle then 'fle' -> emitOp
               // codes.fgt then 'fgt' -> emitOp
               // codes.fge then 'fge' -> emitOp
               // codes.fne then 'fne' -> emitOp
               // codes.fexp then 'fexp' -> emitOp
               else
                  operator -> out.putint;
              if);
              out.newline;
              operator -> emit;
           else
              (if operator
               // codes.plus then
                  'add' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush;
               // codes.minus then 
                   'sub' -> LLVMvOp;
                   2 -> stack.vpop;
                   rN -> stack.vPush 
               // codes.mult then 
                  'mul' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush
               // codes.rdiv then (* not used? *)
                   'div' -> out.putline
               // codes.idiv then 
                  'sdiv' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush 
               // codes.modd then 
                  'srem' -> LLVMvOp;
                  2 -> stack.vpop;
                  rN -> stack.vPush
               // codes.eq then 
                   'icmp eq' -> LLVMbOp;
               // codes.lt then 
                  'icmp slt' -> LLVMbOp;
               // codes.le then 
                  'icmp sle' -> LLVMbOp;
               // codes.gt then
                  'icmp sgt' -> LLVMbOp
               // codes.ge then
                  'icmp sge' -> LLVMbOp
               // codes.ne then
                  'icmp ne' -> LLVMbOp                  
               // codes.andd then
                  'and' -> LLVMBoolOp;
               // codes.orr then 
                  'or' -> LLVMBoolOp;
               // codes.xorr then
                  'xor' -> LLVMBoolOp;                  
               // codes.req then 
                  'icmp eq' -> LLVMRefRelOp;
               // codes.rne then 
                  'icmp ne' -> LLVMRefRelOp;
               // codes.fplus then 'fplus' -> out.putline
               // codes.fminus then 'fplus' -> out.putline
               // codes.fmult then 'fmult' -> out.putline
               // codes.fdiv then 'fdiv' -> out.putline
               else
                  operator -> out.putint; out.newline
              if);
          if)
       #);
     i2f: (# do 'i2f' -> emitOpL; codes.i2f -> emit #);
     f2i: (# do 'f2i' -> emitOpL; codes.f2i -> emit #);
     req: (# do 'req' -> emitOpL; codes.req -> emit #);
     rne: (# do 'rne' -> emitOpL; codes.rne -> emit #);
     seq: (# do 'req' -> emitOpL; codes.seq -> emit #);
     sne: (# do 'rne' -> emitOpL; codes.sne -> emit #);    
     uminus: 
       (# 
       do 'uminus' -> emitOpL;
          codes.uminus -> emit
       #);
     nott: (# do 'not' -> emitOp; codes.nott -> emit #);
     saveBETAworld: 
       (# betaenvDescNo: @integer
       enter betaenvDescNo
       do (if notLLVM then
              'saveBETAworld' -> emitOp; betaEnvDescNo->out.putint; 
              out.newline;
              codes.saveBETAworld -> emit;
              betaenvDescNo -> emit2
           else
              '   ;; saveBETAworld\n' -> out.puttext;
              1 -> stack.rPop
          if)
       #);
     pushBetaenvObj:
       (#
       do (if notLLVM then
              'pushBetaEnvObj' -> emitOp; out.newline;
              codes.pushBetaEnvObj -> emit;
           else
              '   ;; pushBetaEnvObj\n' -> out.puttext;
              1 -> stack.rPop
          if)
       #);
     saveStringOrigin:
       (#
       do (if notLLVM then
              'saveStringOrigin' -> emitOp;
              codes.saveStringOrigin -> emit
           else
              '   ;; saveStringOrigin' -> out.putline;
          if)
       #);
     nop:
       (# C: @char
       enter C
       do (if notLLVM then
              'nop'-> emitOp; C -> out.put; out.newline;
              codes.nop -> emit; C -> emit
          if)
       #);
     isMarked: [32] @boolean;
     initGCinfo: (#do (for i: isMarked.range repeat false-> isMarked[i] for)#);
     addGCinfo:
       (# add: 
            (# off: @integer
            enter off 
            do (if off > isMarked.range then
                   isMarked.range -> isMarked.extend 
               if);
               (if not isMarked[off] then
                   off -> descs.current.GCinfo.add;
                   true -> isMarked[off]
               if)
            #);
       do inner
       #);
     endClass: 
       (# objSize,OSDvisibility: @integer;
          isIndexed: @boolean;
          V: @integer
       enter(objSize,isIndexed,OSDvisibility)
       do (if notLLVM then
              'END'->emitOp; 'OSDV:' -> out.puttext; OSDvisibility->out.putint; 
              ' objSize:'->out.puttext; objSize -> out.putint;  
              ' isIndexed:'->out.puttext; 
              (if isIndexed then 1 -> V else 0 -> V if);
              V -> out.putint; out.newline;
              objSize -> descs.current.objSize;
              V -> descs.current.isIndexed; 
              OSDvisibility -> descs.current.OSDvisibility;     
              (if OSDvisibility > 0 then
                  (*'\n**** OSDvisibility: ' -> puttext; 
                   OSDvisibility -> putint; newline*)
              if);
              labs.saveInImage ;
           else
              stack.put;              
              '}' -> out.putline;
           if);
       #);
     newVirtDefs:
       (# sig,vsig: ^text; descNo,vOff,vNo: @integer; 
          sigT,stub,stubT,T: ^text
       enter(sig[],vSig[],vOff,vNo,descNo,stub[])
       do (if not notLLVM then
              (if false then
                  '**** newVirDefs: ' -> puttext; sig[]->puttext; ' '->put;
                  vsig[] -> puttext; ' ' -> put;
                  typeinfo.dsc.range -> putint; ' ' -> put;
                  voff -> putint;  ' ' -> put; vNo -> putint; ' ' -> put;
                  descNo -> putint; ' ' -> put; stub[] -> putline;
              if);
              (if (descNo > 0) and (typeInfo.dsc[descNo][] <> none) then
                  '%' -> sigT[]; sig[]  -> sigT.append;
                  '%' -> stubT[]; stub[]  -> stubT.append;
                  (if (typeInfo.dsc[descNo].newVirt[] = none) then
                      '' -> typeInfo.dsc[descNo].newVirt[] -> T[];
                      '%newVdt_type$' -> T.append;
                      sig[] -> T.append;
                      ' = type{' -> T.append
                   else
                      typeInfo.dsc[descNo].newVirt[] -> T[];
                      ',' -> T.put
                  if);
                  descNo->('$'->stubT.put).putint -> T.append;
                  '*(' -> T.append;
                  sigT[] -> T.append;
                  '*)*' -> T.append;
               else
                  (if descNo > 0 then
                      typeInfo.dsc[descNo][] <> none ->putboolean; newline;
          if)if)if)
       #);
     endNewVirtDefs: 
       (# descNo: @integer
       enter descNo
       do (if not notLLVM then
              (if false then
                  '**** end: ' -> puttext;  typeinfo.dsc.range -> putint; 
                  ' ' -> put;  descNo -> putint; newline;         
              if);
              (if (descNo > 0) and (typeInfo.dsc[descNo][] <> none)
                  and (typeInfo.dsc[descNo].newVirt[] <> none) then
                  '}' -> typeInfo.dsc[descNo].newVirt.put;
                  (if false then
                      '**** newVirDefs:all: ' -> putline;
                      typeInfo.dsc[descNo].newVirt[] -> putline
                  if)
          if)if)
       #);
     mkLLVMvirtualDefs:
       (# hasVDTorInner:< BooleanValue
            (#
            do (for i: descs.current.vdtTable.range repeat
                    (if (descs.current.vdtTable[i] > 0 -> value) then
                        leave hasVDTorInner
               if)for);
               inner; (* check if inner *)
            #);
          handleOrigins:<
            (# descNo: @integer
            enter descNo
            do inner 
            #);
          vName:< 
            (# dn: @integer; vN,orgOfVN: ^text 
            enter dn
            do inner;
               vN[] -> filter -> vN[] 
            exit(vN[],orgOfVN[])
            #);
          mkVdtType:
            (# T,N,orgOfN: ^text;
            do '%vdt_type$' -> T[];
               thisClassId[] -> filter -> T.puttext;
               ' = type {' -> T.puttext;
               (for i: descs.current.vdtTop repeat
                    (if (descs.current.vdtTable[i] -> dN) > 0 then
                        (if descs.current.isInner[i] then
                            dN -> vName -> (N[],orgOfN[]);
                            (if newFeature then
                                ('*'->('%'->N.prepend).put,dn) 
                                  -> funcPtrType -> T.puttext
                             else
                                '%' -> T.put;
                                N[] -> T.puttext;
                                '*(%' -> T.puttext;
                                N[] -> T.puttext; '*' -> T.put;
                                (if isValueObject then
                                    ', i32' -> T.puttext;
                                 else
                                    (if newFeature then
                                        ', ' -> T.puttext;
                                        orgOfN[] -> mkLLVMtype 
                                          -> T.puttext;
                                        '*' -> T.put;
                                    if)
                                if);
                                ')*' -> T.puttext
                            if);
                         else
                            descs.current.LLVMsigs[i][]  -> T.putline
                        if)
                     else
                        (if isValueObject then
                            'i8*(i8*,i32)*' -> T.puttext
                         else
                            'i8*(i8*)*' -> T.puttext
                        if)
                    if);
                    (if i < descs.current.vdtTop then
                        ',' -> T.put
               if)for);
               '}\n' -> T.puttext;
               (if typeInfo.dsc[descs.current.descInx][] = none then
                   '\n!!!! mkVdtType: '
                   'typeInfo.dsc[descs.current.descInx][] = none' 
                     -> putline;
                   '!!   vdtType: ' -> puttext; T[] -> putline
                else
                   T[] -> typeInfo.dsc[descs.current.descInx].vdtType[];
               if);
            #);
          mkVdtData:
            (# orgOfVN,T,S: ^text; dM: @integer
            do (if false then
                   '**** mkVdtData: ' -> puttext; thisClassId[] -> putline;
                   (for i: descs.current.vdtTop repeat
                        '   ' -> puttext;
                        (if descs.current.isInner[i] then
                            'inner: ' -> puttext
                         else
                            'virtual: ' -> puttext
                        if);
                        descs.current.vdtTable[i] -> putint; ' ' -> put;
                        descs.current.LLVMsigs[i][] -> putline
                   for);
               if);
               '\n@vdt_data$' -> out.puttext; thisClassId[] -> out.puttext;
               ' = global %vdt_type$' -> out.puttext;
               thisClassId[] -> filter -> out.puttext;
               ' {' -> out.puttext;
               (for i: descs.current.vdtTop repeat
                    '\n      ' -> out.puttext;
                    (if (descs.current.vdtTable[i] -> dN) > 0 then
                        (if descs.current.isInner[i] then
                            (if newFeature then
                                dN -> vName -> (T[],orgOfVN[]);
                                '*' -> ('%' -> T.prepend).put -> S[];
                                (S[],dN) -> funcPtrType -> out.puttext;
                             else
                                '%' -> out.put;
                                dN -> vName -> (T[],orgOfVN[]);
                                T[] -> out.puttext;
                                '*(%' -> out.puttext;
                                dN -> vName -> (T[],orgOfVN[]);
                                T[] -> out.puttext;
                                '*' -> out.puttext;
                                (if isValueObject then
                                    ', i32' -> out.puttext;
                                if);
                                ')* ' -> out.puttext;
                            if);
                            '@' -> out.puttext;
                            dN -> vName -> (T[],orgOfVN[]);
                            T[] -> out.puttext;
                         else
                            descs.current.LLVMsigs[i][] -> out.puttext;
                            ' @vdt_alloc$' -> out.puttext;
                            dN -> vName -> (T[],orgOfVN[]);
                            T[] -> out.puttext;
                            (*T[] -> puttext; ' ' -> put;  
                            descs.current.LLVMsigs[i][] -> putline;*)
                        if)
                     else
                        'i8* (i8* )* null' -> out.puttext
                    if);
                    (if i < descs.current.vdtTop then
                        ',' -> out.put
               if)for);
               '\n}\n' -> out.puttext;
               (if false then
                   '**** mkVdtData:end: ' -> puttext; thisClassId[] -> putline;
               if);
            #);
          mkVdtRet:
            (# T: ^Text
            do '%vdt_ret$' -> T[];               
               thisClassId[] -> T.puttext;
               ' = type{' -> T.puttext;
               thisClassP[] -> T.puttext;
               ',' -> T.put;
               (if newFeature then
                   (thisClassP[],thisClassDescNo) -> funcPtrType -> T.puttext;
                   '}\n' -> T.puttext;
                else
                   thisClassP[] -> T.puttext; '(' -> T.put;
                   thisClassP[] -> T.puttext; 
                   (if isValueObject then
                       ', i32' -> T.puttext
                   if);
                   ')*}\n' -> T.puttext;
               if);
               (if typeInfo.dsc[descs.current.descInx][] = none then
                   '\n!!!! mkVdtRet: '
                   'typeInfo.dsc[descs.current.descInx][] = none' -> putline;
                   '!!    vdtRet: ' -> puttext; T[] -> putline
                else
                   T[] -> typeInfo.dsc[descs.current.descInx].vdtRet[]
               if)
            #);
          mkVDTalloc:
            (# rNx,rNy,rNz,rNv,range: @integer; thisClassVdtType,funcPT,T,id: ^text
            do (if traceLLVMcalls then
                   '$vdt_alloc$'->(thisClassId.copy).prepend 
                     -> mkTextConst -> (id[],range)
               if);
                '%vdt_ret$' -> thisClassVdtType[];
               thisClassId[] -> thisClassVdtType.append;
               '\ndefine ' -> out.puttext;
               thisClassVdtType[] -> out.puttext;
               '* @vdt_alloc$' -> out.puttext;
               thisClassId[] -> out.puttext;               
               '(' -> out.put;
               (if isVstubObject then (* clean-up here *)
                   thisClassOrgId[] -> mkTypePtrX -> out.puttext
                else
                   (thisClassOrgId[],thisClassOrgDescNo)
                     -> mkTypePtr -> out.puttext;
               if);
               ' %R1' -> out.puttext; 
               '){\n' -> out.puttext;
               allocReg; (* allocate origin reg %R1 *)
               (if traceLLVMcalls then (id[],range) -> putstring if);
               lcom(#do 'mkVDTalloc:isVstubObject:'->TT; isVstubObject -> BB #);
               (thisClassVdtType[],118,8) -> allocRTObj -> rNx;
               lcom(#do 'mkVDTalloc:B:'->TT #);
               (**** OBS! size of obj is 48 below - but is this correct?
                * Probably no, we need the size of the binding
                *)
               (if not isVstubObject then
                   lcom(#do 'vdt_alloc:alloc ' -> TT; thisClassT[] -> TT #);
                   (thisClassT[],thisClassDescNo,48) -> allocQbetaObj -> rNy;
                   
                   (rNx,thisClassVdtType[],0) -> leaReg -> rNz;
                   
                   '   store ' -> out.puttext; 
                   thisClassP[]  -> out.puttext; ' ' -> out.put;
                   rNy -> emitRreg -> out.puttext; ', ' -> out.puttext;
                   thisClassP[] -> out.puttext; '* ' -> out.puttext;
                   rNz -> emitRreg  -> out.putline;
               if);
               lcom(#do 'mkVDTalloc:C:'->TT #);
               (if false then
                   (* here we store the constructor for the binding, 
                    * but we dont use it - can be eliminated
                    *)
                   (rNx,thisClassVdtType[],1) -> leaReg -> rNv;
                   
                   (thisClassP[],thisClassDescNo) -> funcPtrType -> funcPT[];
                   '   store ' -> out.puttext;
                   funcPT[] -> out.puttext; 
                   ' @' -> out.puttext; thisClassId[] -> out.puttext;
                   ', ' -> out.puttext;
                   
                   funcPT[] -> out.puttext;
                   '* ' -> out.puttext;
                   rNv -> emitRreg -> out.puttext;
               if);
               (if false and not isValueObject and (thisClassOriginOff > 0) then
                   lcom(#do 'store origin: ' -> TT; thisClassOriginOff -> II #);
                   (rNy,thisClassT[],thisClassOriginOff) -> leaReg  -> rNz;
                   
                   '   store ' -> out.puttext;
                   (if isVstubObject  then
                       thisClassOrgId[]
                         -> mkTypePtrX -> T[]  -> out.puttext;
                    else
                       (thisClassOrgId[],thisClassOrgDescNo) 
                         -> mkTypePtr -> T[]  -> out.puttext;
                   if);
                   ' %R1, ' -> out.puttext; 
                   T[] -> out.puttext; 
                   '* ' -> out.puttext;
                   rNz -> emitRreg -> out.putline;
               if);
               lcom(#do 'thisClassOrgId:' -> TT; thisClassOrgId[] -> TT;
                      'thisClassOrgDescNo:' -> TT; thisClassOrgDescNo -> II #);
               (if not isVstubObject then
                   (1,(thisClassOrgId[],thisClassOrgDescNo)-> mkTypePtr)
                     -> stack.rpushT;
                else
                   (1,'%'->(thisClassOrgId.copy).prepend) -> stack.rpushT;
               if);

               (if not isVstubObject then
                   (* perhaps move push' below to non Vstub or above?*)
                   (rNy,thisClassT[]) -> stack.rpushT;
               if);
               stack.put;
               (*thisClassDescNo -> handleOrigins;*)
               
               (if isVstubObject then
                   lcom(# do 'CALL Vstub:' -> TT; thisClassT[] -> TT  #);
                   allocReg -> rNy;
                   (thisClassId[],thisClassOrgId[]->filter,1,rNy)
                     -> LLVMcall -> out.putline;
                   (rNy,thisClassT[]) -> stack.rpushT;
                   stack.put;
                   
                   lcom(#do 'Store binding in vdt_ret.' -> TT;
                          'Note! types are not correct' -> TT #);
                   (rNy,thisClassT[],rNx,thisClassVdtType[],0) -> LLVMstore;
                   stack.put;
                   thisClassDescNo -> handleOrigins;
                else
                   lcom(#do 'before:handleOrigins:'->TT; thisClassDescNo ->II#);
                   thisClassDescNo -> handleOrigins;
                   lcom(#do 'after:handleOrigins:'->TT; thisClassDescNo ->II #);
               if);
               (if dumpLLVMobjs then
                   ('vdt_alloc:obj:',thisClassId[]
                   ,rNy,thisClassT[])
                     -> dumpObjX;
                   (*('vdt_alloc:%vdt_ret:RET:obj',thisClassId[],rNx
                   ,thisClassVdtType[]) 
                     -> dumpObjX;*)
               if);
               '   ret %vdt_ret$' -> out.puttext;
               thisClassId[] -> out.puttext;
               '* ' -> out.puttext; rNx -> emitRreg -> out.puttext;
               '\n}\n' -> out.puttext;
            #);
          printVDT:
            (#
            do '   ;; vdt:vdtTop: ' -> out.puttext;
               descs.current.vdtTop -> out.putint; ' ' -> out.put;
               (for i: descs.current.vdtTop repeat
                    descs.current.vdtTable[i] -> out.putint;
                    ':' -> out.put;
                    (if descs.current.isInner[i] then
                        'I' -> out.put
                     else
                        'V' -> out.put
                    if);
                    (if i < descs.current.vdtTop then ',' -> out.put if)
               for);
            #);
          dn: @integer
       do (if not notLLVM then
              (if false then
                  '**** mkLLVMVirtualDefs: ' -> puttext; thisClassT[] ->putline
              if);
              printVDT;
              mkVdtType;
              mkVdtData;
              inner;
              mkVdtRet;
              mkVDTalloc;
              false -> isValueObject;
              (if false then
                  '**** mkLLVMvDefs:end: ' -> puttext; thisClassT[] -> putline
              if)
          if)
       #);
     close:
       (#
       do VdtPatch.patch;         
          (if notLLVM then dump if)
       #);
     labs: @ 
       (# init:
            (#
            do (for i: loc.range repeat 0 -> loc[i] for);
               (for i: use.range repeat none -> use[i][] for);
               0 -> loc.new; 
               0 -> use.new
            #);
          def:
            (# labNo: @integer
            enter labNo
            do (*'Labs:def: ' -> puttext; labNo -> putint; newline;*)
               (*'labs.def:labNo: ' -> puttext; labNo -> putint; 
               ' range: ' -> puttext; loc.range -> putint;*)
               (if labNo > loc.range then labNo - loc.range -> loc.extend if);
               (if labNo > use.range then labNo - use.range -> use.extend if); (*ugly*)
               (* ' labs.def:new:range: ' -> puttext; loc.range -> putint;
               newline;*)
               descs.current.bc.top + 1 -> loc[labNo];
               labNo -> patch
            #);
          mark:
            (# labNo: @integer; lab: ^Label;
            enter labNo
            do (if labNo > loc.range then
                   labNo - loc.range -> loc.extend
               if);
               (if loc[labNo] > 0 then
                   (loc[labNo],descs.current.bc.top) -> descs.current.bc.patchLab;
                else
                   &Label[] ->lab[];
                   (*'Labs:mark: ' -> puttext; labNo -> putint; newline;*)
                   descs.current.bc.top -> lab.use;
                   (if labNo > use.range then LabNo - use.range + 4 -> use.extend if);
                   (if use[labNo][] = none then
                       lab[] -> use[labNo][]
                    else
                       use[labNo][] -> lab.next[];
                       lab[] -> use[labNo][]
                   if);
               if)
            #);
          patch: 
            (# labNo: @integer; labLoc: ^Label
            enter labNo 
            do (if labNo > use.range then 'patch:use: labNo > range' -> putline if);
               use[labNo][]  -> labLoc[];
               Loop:
                 (if labLoc[] <> none then
                     (loc[labNo],labLoc.use) -> descs.current.bc.patchLab;
                     labLoc.next[] -> labLoc[];
                     restart Loop
                 if)
            #);
          saveInImage:
            (# 
            do (*'saveInImage: ' -> puttext; loc.range -> putint; newline;*)
               loc.range -> descs.current.labs.new;
               (for i: loc.range repeat
                   loc[i] -> descs.current.labs[i]
               for)
            #);            
          loc: [0] @integer; (* Location in bytecode of the label - if zero, not defined *)
          use: [0] ^Label; (* list of locations where lable is referred *)
          Label:
            (# use: @integer;
               next: ^Label
            #)
          
       #);
            
     dump: (# do descs.dump #);
     
     out: ^Stream;

     glsc: 
        (# top: @integer
        do (if (descs[] <> none) then
               (if (descs.current[] <> none) then
                   (if  (descs.current.bc[] <> none) then
                       descs.current.bc.top + 1 -> top 
                    else
                       'descs.current.bc is none'->putline;
                   if)
                else
                   'descs.current is none'->putline;
               if)
            else
               'descs is none'->putline;
           if)
        exit top
        #);
     emit: (# enter descs.current.bc.emit #);
     emit2: (# enter descs.current.bc.emit2 #);
     emit8: (# enter descs.current.bc.emit8 #);

     descs: @ RuntimeDescriptors;
            
     codes: @ ByteCodes;
     prim: @ Primitives
  #);

