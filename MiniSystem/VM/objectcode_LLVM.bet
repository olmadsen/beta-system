ORIGIN 'objectcode'
---classDef:doPart---
do (if false then
       '**** classDef: ' -> puttext; N[] -> puttext;
       ' ' -> put; descNo  -> putint; 
       ' ' -> put; orgOfN[] -> putline
   if);
   (if descNo -> typeInfo.exists then
       leave classDef
   if);
   isValueObj -> isValueObject;
   N[] -> filter -> N[];
   
   '%' -> T[]; N[] -> T.puttext; 
   '$' -> T.put; descNo -> T.putint;
   (if orgOfN[] = none then
       (descNo,T[],none) -> typeInfo.addDsc;
    else
       (descNo,T[],(orgOfN[],orgDescNo) -> mkTypePtr) 
         -> typeInfo.addDsc;
   if);
   
   '%' -> T[]; N[] -> T.puttext; 
   '$' -> T.put; descNo -> T.putint;
   
   (* *** LLVMstructs as printed here are apparently not used?
    * T[] -> LLVMstructs.puttext; 
    * ' = type {' -> LLVMstructs.puttext;
    *)
   
   true -> first;  
   'vdt_type$' -> T[];
   N[] -> filter -> T.puttext; 
   '$' -> T.put; descNo -> T.putint;
   ' ' -> T.put;
   (0,T[]) -> AddR; 
   inner classDef;
   
   (* '}'-> LLVMstructs.puttext; LLVMstructs.newline;
    * ';;%vdt_type ' -> LLVMstructs.putline;
    *)
---pushConst:descriptor---
(#
do ind;
   allocReg -> rN -> emitVreg -> out.puttext;
   ' = add i32 0, ' -> out.puttext; cst -> out.putint; 
   out.newline;
   rn -> stack.vPush;
   cst -> stack.value -> stack.vVal[stack.vTop][];
#)
---rpushg:descriptor---
(#
do (if stack.rtop = 0 then
       '   ;; rpushg: stack.rtop = 0' -> out.putline;
       '!!!! rpushg: stack.rtop = 0' -> putline;
    else
       (if (stack.rRegNo[stack.rtop] = 0) and isValueObject then
           '*** rpushg:in value object: ' -> puttext;
           N[] -> putline;
       if);
       (stack.rType[stack.rtop][],off) -> typeInfo.lookup -> elmType[];
       
       lcom(#do 'Rtype.rtop:' -> TT; stack.Rtype[stack.rtop][] -> TQ;
              'typeInfo[Rtype.rtop,off]=elmType:'-> TT; elmType[] -> TQ;
           #);
       off -> leag -> rN;
       ind;
       allocReg -> rN2 -> emitRreg -> out.puttext;
       ' = load ' -> out.puttext; 
       elmType[] -> out.puttext;
       ' , ' -> out.puttext; 
       elmType[] -> out.puttext; '* ' -> out.puttext;
       rN -> emitRreg -> out.puttext;
       out.newline;
       1 -> stack.rpop;
       (rN2,elmType[]) -> stack.rPushT;
   if)
#)
---jmp:doPart---
do '   br label %L' -> out.puttext; lab ->  out.putint; out.newline 
---jmpFalse:descriptor---
(#
do stack.put;
   (if stack.vTop = 0 then
       '   ;; jmpFalse: stack.vTop = 0' -> out.putline;
       '\n!!!! jmpFalse: stack.vTop = 0' -> putline;
    else
       (if stack.Vtype[stack.vTop] = 1 then
           stack.vRegNo[stack.vTop] -> Vn
        else
           allocReg -> Vn -> emitVreg -> out.puttext;
           ' = trunc  i32 ' -> out.puttext;
           stack.vtop -> vRegInStack -> out.puttext; 
           ' to i1\n' -> out.puttext;
       if);
       
       '   br i1 ' -> out.puttext; 
       Vn -> emitVreg -> out.puttext;
       ', label %L' -> out.puttext; Tlab ->  out.putint;
       ', label %L' -> out.puttext; Flab ->  out.putint; 
       out.newline;
       1-> stack.vpop
   if)
#)

 
