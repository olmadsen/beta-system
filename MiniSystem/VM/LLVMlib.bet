ORIGIN '~beta/basiclib/betaenv';
---LIB:attributes---
deRef:
  (# T: ^text
  enter T[]
  do (if (T.length -> T.inxGet) = '*' then
         (1,T.length - 1) -> T.sub -> T[]
     if)
  exit T[]
  #);
mkLLVMclassName:
  (# N,T: ^text
  enter N[]
  do N[] -> filter -> T[];
     inner
  exit T[]
  #);
mkLLVMstructName: mkLLVMclassName
  (#
  do '%' -> T.prepend
  #);
mkTypePtrX:
    (# N,T: ^text
  enter N[]
  do '%' -> T[];
     N[] -> filter -> T.puttext;
     '*' -> T.put
  exit T[]
  #);
mkTypePtr:
  (# N,T: ^text; descNo: @integer
  enter(N[],descNo)
  do '%' -> T[];
     N[] -> filter -> T.puttext;
     '$' -> T.put; descNo -> T.putint;
     '*' -> T.put
  exit T[]
  #);
prepStruct:
  (# N,T: ^text
  enter N[]
  do N[] -> filter -> T[];
     (*'   ;; prepStruct: ' -> out.puttext; N[] -> out.putline;*)
     '%' -> T.prepend
  exit T[]
  #);
mkFuncPtr:
  (# T,S,R: ^text
  enter T[]
  do '%' -> S[]; T[] -> S.append; '*' -> S.put;
     S.copy -> R[]; '('->R.put; S[] -> R.append; ')*'-> R.append;
     R[] ->  putline;
  exit R[]
  #);
mkVDTentry:
  (# LLVMsig,PthisClassN,T: ^text; isInner: @boolean; descInx: @integer
  enter(LLVMsig[],PthisClassN[],isInner,descInx)
  do (if not isinner then
         '%vdt_ret$' -> T[]; 
         LLVMsig[] -> filter -> T.append;
         '$' -> T.put; descInx -> T.putint;
         '*(' -> T.puttext; 
         PthisClassN[] -> T.puttext;
         ')*' -> T.puttext
      else
         PthisClassN.copy -> T[];
         '(' -> T.put; 
         PthisClassN[] -> T.puttext;
         ')*' -> T.puttext             
     if);
  exit T[]
  #);
filter:
  (# N,T: ^text
  enter N[]
  do (if true
      // N[] = none then
         'filter$none' -> T[]
      // ':=' -> N.equal then  '_assign' -> T[]
      // '=' -> N.equal then '_equal' -> T[]
      // '==' -> N.equal then '_requal' -> T[]
      // '<=' -> N.equal then '_lessequal' -> T[]
      // '+' = (1 -> N.inxGet) then
         '_add' -> T[]; (2,N.length) -> N.sub -> T.append;
      // ':=$' -> ((1,3) -> N.sub).equal then
         '_assign$' -> T[]; (4,N.length) -> N.sub -> T.append

      // '<=' -> ((1,2) -> N.sub).equal then
         '_lessequal' -> T[]; (3,N.length) -> N.sub -> T.append
      // '==' -> ((1,2) -> N.sub).equal then
         '_requal' -> T[]; (3,N.length) -> N.sub -> T.append
      // (1 -> N.inxGet) = '=' then
         '_equal' -> T[]; (2,N.length) -> N.sub -> T.append
         
      else
         '' -> T[];          
         L: 
           N.scanAll
           (#
           do (if ch
               // '@' // '#' // ':' then
                  '$' -> T.put
               else
                  ch -> T.put
     if)#)if);
  exit T[]
  #);
defTraceString:
  (# T,pref,out: ^text
  enter(T[],pref[])
  do &text[] -> out[];
     '\n@S.' -> out.puttext;
     pref[] -> out.puttext;                
     T[] -> out.puttext;                
     ' = private unnamed_addr constant [' -> out.puttext;
     T.length + 8  +  2 -> out.putint;
     ' x i8] c"' -> out.puttext;
     pref[]-> out.puttext; 
     T[] -> out.puttext;
     '\\0A\\00"\n' -> out.puttext;
  exit out[]
  #);
putTrace:
  (# T,out: ^text
  enter T[]
  do &text[] -> out[];
     '   %S = getelementptr [' -> out.puttext;
     T.length + 8 + 2 -> out.putint;
     ' x i8], [' -> out.puttext;
     T.length + 8 + 2 -> out.putint; 
     ' x i8]* @S.vdt_ret$' -> out.puttext; 
     T[] -> out.puttext; 
     ', i64 0, i64 0\n' -> out.puttext;                   
     '   call i32 @puts(i8* %S)\n' -> out.puttext;
  exit out[]
  #);
emitVreg:
  (# rN: @integer; T: ^Text
  enter rN
  do '%V' -> T[]; rN -> T.putint
  exit T[]
  #);
emitRreg:
  (# rN: @integer; T: ^Text
  enter rN
  do '%R' -> T[]; rN -> T.putint
  exit T[]
  #);
LLVMcall:
  (# id,argType: ^text; argRno,rtnReg: @integer; inst: ^text
  enter(id[],argType[],argRno,rtnReg)
  do '   ' -> inst[];
     rtnReg -> emitRreg -> inst.puttext;
     ' = call %' -> inst.puttext; 
     id[] -> inst.puttext;
     '* @' -> inst.puttext;
     id[] -> inst.puttext;
     '(%' -> inst.puttext; argType[] -> inst.puttext; '* ' -> inst.puttext; 
     argRno -> emitRreg -> inst.puttext;
     ')' -> inst.puttext;
  exit inst[]
  #);



     
