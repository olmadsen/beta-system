ORIGIN '~beta/basiclib/betaenv';
---LIB:attributes---
deRef:
  (# T: ^text
  enter T[]
  do (if (T.length -> T.inxGet) = '*' then
         (1,T.length - 1) -> T.sub -> T[]
     if)
  exit T[]
  #);
mkLLVMclassName:
  (# N,T: ^text
  enter N[]
  do N[] -> filter -> T[];
     inner
  exit T[]
  #);
mkLLVMstructName: mkLLVMclassName
  (#
  do '%' -> T.prepend
  #);
mkTypePtr:
  (# N,T: ^text; descNo: @integer
  enter(N[],descNo)
  do '%' -> T[];
     N[] -> filter -> T.puttext;
     '$' -> T.put; descNo -> T.putint;
     '*' -> T.put
  exit T[]
  #);
prepStruct:
  (# N,T: ^text
  enter N[]
  do N[] -> filter -> T[];
     (*'   ;; prepStruct: ' -> out.puttext; N[] -> out.putline;*)
     '%' -> T.prepend
  exit T[]
  #);
filter:
  (# N,T: ^text
  enter N[]
  do (if true
      // N[] = none then
         'filter$none' -> T[]
      // ':=' -> N.equal then  '_assign' -> T[]
      // '=' -> N.equal then '_equal' -> T[]
      // '==' -> N.equal then '_requal' -> T[]
      // '<=' -> N.equal then '_lessequal' -> T[]
      // '+' = (1 -> N.inxGet) then
         '_add' -> T[]; (2,N.length) -> N.sub -> T.append;
      // ':=$' -> ((1,3) -> N.sub).equal then
         '_assign$' -> T[]; (4,N.length) -> N.sub -> T.append

      // '<=' -> ((1,2) -> N.sub).equal then
         '_lessequal' -> T[]; (3,N.length) -> N.sub -> T.append
      // '==' -> ((1,2) -> N.sub).equal then
         '_requal' -> T[]; (3,N.length) -> N.sub -> T.append
      // (1 -> N.inxGet) = '=' then
         '_equal' -> T[]; (2,N.length) -> N.sub -> T.append
         
      else
         '' -> T[];          
         L: 
           N.scanAll
           (#
           do (if ch
               // '@' // '#' // ':' then
                  '$' -> T.put
               else
                  ch -> T.put
     if)#)if);
  exit T[]
  #);
defTraceString:
  (# T,pref,out: ^text
  enter(T[],pref[])
  do &text[] -> out[];
     '\n@S.' -> out.puttext;
     pref[] -> out.puttext;                
     T[] -> out.puttext;                
     ' = private unnamed_addr constant [' -> out.puttext;
     T.length + 8  +  2 -> out.putint;
     ' x i8] c"' -> out.puttext;
     pref[]-> out.puttext; 
     T[] -> out.puttext;
     '\\0A\\00"\n' -> out.puttext;
  exit out[]
  #);
putTrace:
  (# T,out: ^text
  enter T[]
  do &text[] -> out[];
     '   %S = getelementptr [' -> out.puttext;
     T.length + 8 + 2 -> out.putint;
     ' x i8], [' -> out.puttext;
     T.length + 8 + 2 -> out.putint; 
     ' x i8]* @S.vdt_ret$' -> out.puttext; 
     T[] -> out.puttext; 
     ', i64 0, i64 0\n' -> out.puttext;                   
     '   call i32 @puts(i8* %S)\n' -> out.puttext;
  exit out[]
  #);
