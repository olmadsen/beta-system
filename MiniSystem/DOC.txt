

Virtual machine
---------------

Stacks
------
ThisObj
ThisStack
are both stacks 

In do-part: ThisObj = ThisStack

Alloc:
------
Origin = top of thisStack

Callee = new object, and is a stack, is allocated

(thisObj,thisStack) -> callee.rpush
Origin -> calleer.push

callee -> thisStack -> thisObj

Call:
-----
thisStack.rpop -> callee
(thisObj,thisStack) -> callee.rpish
callee -> thisObj 
-- i.e. thisStack is untouched
-- enter arguments are on the stack of the caller = thisObj

RTN:
----

thisObj -> X[]

thisObj.rpop -> (thisStack,thisObj)

X[] -> thisStack.rpush

MvStack
-------
thisObj -> thisStack

setThisStack
------------
thisObj.rTopElm -> thisStack



Code example
------------

test: @
  (# R: @ 
       (# put:
            (# x,y,z: @integer
            enter (x,y)
            do x + y -> z
            exit z
            #)          
       #);
     V: @integer
  do (11,22) -> R.put -> V;
  #)

Class put 1186 1
allocE:              -- thisObj = thisStack = put instance
1:	rstore 1     -- Alloc moves origin from caller(test) stack too R-stack
3:	rtn A        -- restore thisObj = thisStack = test
enterE:              -- thisObj = put, thisStack = test
5:	store 2
7:	store 1
9:	rtn N        -- restore thisObj = thisStack = test
doE:                 -- thisObj = put, thisStack = test
11:	mvStack      -- thisObj -> thisStack
12:	push 1
14:	push 2
16:	+
17:	store 3
19:	rtn D
exitE:               -- thisObj = put, thisStack = test
21:	doExit       -- like setThisStack, but is this necessary?
22:	push 3       -- push on test stack
24:	rtn X        -- return and restore test = thisObj = thisStack

15:	pushc 11     -- arguments pushed before origin
17:	pushc 22
19:	rpush 2      -- push of origin
21:	alloc 1186 0 -- on return put instance on R-stack 
25:	call N       -- 
27:	call D
29:	call X
31:	rtnEvent 1   -- pop put instance from R-stack
33:	store 1      -- return vlaue on R-stack


QBETA code skeleton
-------------

Entry:
   rstore 1 -- origin
   setThisStack
   ... save arguments
   mvStack
   ......
   setThisStack
   ... push return values
   rtn

Example
-------

R: @
   foo(a: @integer, T: ^Text, b: @ integer) -> V: @integer:
     ...

Q := R.foo(111,S,222)

class foo
     rstore originOff
     setThisStack
     store b
     rstore T
     store a
 do: mvStack
     ...
     setThisStack
     push V
     rtn

Call
----
   rpush R    -- origin of foo
   push 111
   rpush S
   push 222
   -- stack = [... R,111,S,222   -- Alloc assumes R on top
   Alloc foo
   rpop      -- foo
   store Q   -- return value

Perhaps another Alloc - Invoke

As Alloc, but after Invoke
  thisObj = callee
  thisStack = caller
  
And then
  mvStack -- after save of arguments and origin

Invoke: modify Alloc
   -  dont pop origin from thisStak
   -  dont push origin on callee
   -  dont set thisStack to callee


