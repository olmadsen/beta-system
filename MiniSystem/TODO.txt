Language
--------
1.	Complete BETA/LIB


MINIENV

Implementation
--------------
4.	Get possible super from OD text
5.	For an OD with super and do-part, perhaps a browser entry
8.	Update objectWindows during execution
9.	Location of objectWindows when following references


13.	Set break: on component and/or objectDescriptor
14.	Prettyprinter in the style of BETA mode for emacs
15.	The order of attributes/modules depends on the scanning 
	order of directories
16.	Lock BETALIB, etc. for changes and avoid saving buffers
17.	Call BETA compiler from BETALIB
18.	Add workspace to BETALIB
19.	Step: findNextImp more complicated
	- for): break after for and after repeat
	- (if: break after then, else and perhaps at each //
	- restart L, break at L
	- leave L, break at L
	- R.foo: at Alloc/enter/do in foo
	- #): break after caller
	when step: remember all breakpoints set for next imp
	after step/break, remove step-breaks 

Issues
-------
1.	How do we represent AST and text being modified?
	A text buffer? We must keep positions up-to-date when changing
	elements
2.	Clean-up with respect to kind
	kind: a char - does not scale
	checker::kinds: -- a number, does scale
	sKind: used as icons/labels in objectWindows (seq dia)
	xKind: exit kinds.X - in checker - may be ok
6.	When a component is saved, the positions in the original
	source file may have changed - we thus need to reparse?
7.	Why is a module just not an objectDescriptor
          "foo: /@"   foo.bet: "(# ... #)" // objectModule
          "bar: /#"   bar.bet: "(# ... #)" // pattern module
        we then simplify the syntax and eliminate a name
        The disadvantage is that we cannot see from the file what kind
	of module this is - and how do we parse directories - the
	module kind info is not in the enclosed module - it could be

Method categories
-----------------

Currently for a class module

   LIB: @
     (# Text: / (* pattern module*) #)

Directory
   Text
     File: Text.bet
        Text: (# ... #)


class A:
    method cat M1
       method f1
       method f2
       method f3
    method cat M2
       method g1
       method g2
       method g3
    method cat M3
       method h1
       method h2
       method h3

Directories
   A
     M1
       file M1.bet == M1: @ (# f1: ...; f2: ...; f3: ...; #)
     M2
       file M2.bet == M2: @ (# g1: ...; g2: ...; g3: ...; #)
     M3
       file M3.bet == M3: @ (# h1: ...; h2: ...; h3: ...; #)
     
Or

   A
     M1
       file M1.bet == f1: ...; f2: ...; f3: ...; 
     M2
       file M2.bet == g1: ...; g2: ...; g3: ...; 
     M3
       file M3.bet == h1: ...; h2: ...; h3: ...; 


     


       
   
