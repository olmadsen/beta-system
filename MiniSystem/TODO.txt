Language
--------
1.	Complete BETA/LIB

Compiler
---------
1.	Check enter/exit lists in assignment og comparison
2.	Fix codegeneration for Directory/PtnModule - currently as ObjModule
8.	All operators: xor, not, 
9.	Virtual
	- virtual class
	- both super and main have the same class name - perhaps mangle with descno?
10.	Large constants, and offsets > 16 bit
11.	Repetitions
        - reference reps and non simple reps.
13.	Inner P and more than one inner.
15	P##
16.	Only partial eval of boolean exp
18.	Patterns used both as objects and procedures
21.	Check if desc has been checked when searching - refarg.bet 
22.	Order of attributes does matter: text: T declared after use dont work
23.	When called from minienv, only parse the world once 
	- and only compile component being executed and components
	that have been changed
        - compiler also compiles the whole world
24.	No syntax error for V: #(# #) - results in finalBinding ...
25.	Don't execute empty enter-part
26.	StaticItem: problem with ref: R[]
27.	DynamicItem: problem with execution: R

MINIENV
======
GUI stuff
---------
1.	Pop-up menu at current mouse position
2.	Courier font
3.	Debugger: arrows and lifelines shall follow objects when they are moved
4.	Debugger: show dragging object when creating it and locating it.
5.	Possible to collapse edit pane
6.	Use of graphic icons instead of chars
7.	Horizontal scroll of attribute-panes - or just a backarrow
8.	Nice Self-like look and feel

Functionality
-------------
1.	Copy: should be meaningful, just a doPT to th clipborad
1.b     Paste: meninful if selected attribute is a module/descriptor
         - see filebrowsers: here delete, duplicat, copy
2.	Check move: up/down - detach up if first and down if last
3.	Delete of module directory is not implemented
4.	Show syntax- and semantic errors in browser  

Implementation
--------------
4.	Get possible super from OD text
5.	For an OD with super and do-part, perhaps a browser entry
8.	Update objectWindows during execution
9.	Location of objectWindows when following references
10.	Link from objectWindow to source in browser


13.	Set break: on component and/or objectDescriptor
14.	Prettyprinter in the style of BETA mode for emacs
15.	The order of attributes/modules depends on the scanning 
	order of directories
16.	Lock BETALIB, etc. for changes and avoid saving buffers
17.	Call BETA compiler from BETALIB
18.	Add workspace to BETALIB
19.	Step: findNextImp more complicated
	- for): break after for and after repeat
	- (if: break after then, else and perhaps at each //
	- restart L, break at L
	- leave L, break at L
	- R.foo: at Alloc/enter/do in foo
	- #): break after caller
	when step: remember all breakpoints set for next imp
	after step/break, remove step-breaks 

Issues
-------
1.	How do we represent AST and text being modified?
	A text buffer? We must keep positions up-to-date when changing
	elements
2.	Clean-up with respect to kind
	kind: a char - does not scale
	checker::kinds: -- a number, does scale
	sKind: used as icons/labels in objectWindows (seq dia)
	xKind: exit kinds.X - in checker - may be ok
6.	When a component is saved, the positions in the original
	source file may have changed - we thus need to reparse?
7.	Why is a module just not an objectDescriptor
          "foo: /@"   foo.bet: "(# ... #)" // objectModule
          "bar: /#"   bar.bet: "(# ... #)" // pattern module
        we then simplify the syntax and eliminate a name
        The disadvantage is that we cannot see from the file what kind
	of module this is - and how do we parse directories - the
	module kind info is not in the enclosed module - it could be

Method categories
-----------------

Currently for a class module

   LIB: @
     (# Text: / (* pattern module*) #)

Directory
   Text
     File: Text.bet
        Text: (# ... #)


class A:
    method cat M1
       method f1
       method f2
       method f3
    method cat M2
       method g1
       method g2
       method g3
    method cat M3
       method h1
       method h2
       method h3

Directories
   A
     M1
       file M1.bet == M1: @ (# f1: ...; f2: ...; f3: ...; #)
     M2
       file M2.bet == M2: @ (# g1: ...; g2: ...; g3: ...; #)
     M3
       file M3.bet == M3: @ (# h1: ...; h2: ...; h3: ...; #)
     
Or

   A
     M1
       file M1.bet == f1: ...; f2: ...; f3: ...; 
     M2
       file M2.bet == g1: ...; g2: ...; g3: ...; 
     M3
       file M3.bet == h1: ...; h2: ...; h3: ...; 


     


       
   
