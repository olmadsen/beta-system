ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xlexer';
INCLUDE 'xAbstractSyntaxTree';

---lib:attributes---
parser: AbstractSyntaxTree
  (# pModule:
       (# symb: ^text;
          SO: ^StaticObject
       do (if lex.symb = lex.symbols.idf then 
              lex.sym[] -> symb[];
              lex;
              (if lex.symb = lex.symbols.colon then 
                  lex; 
                  (if lex.symb = lex.symbols.object then
                      lex;
                      pStaticObject -> SO[]
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
          symb[] -> UnarySignature -> SO.sig[];
          none -> Lexem -> SO.res[];
       exit SO[] -> Module
       #);
     pStaticObject:
       (# O: ^ObjectGeneration
       do pObjectGeneration -> O[];
       exit O[] -> StaticObject          
       #);
     pDynamicObject:
       (# pi: ^PatternId
       do pPatternId -> pi[]
       exit pi[] -> DynamicObject
       #);
     pObjectGeneration:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
        (# OI: ^ObjectInvocation;
           MP: ^MainPart;
        do pObjectInvocation -> OI[];
           pMainPart -> MP[]
       exit (OI[],MP[]) -> ObjectGeneration
       #);
     pObjectInvocation:
       (* { <objectId> '.' }* <beginId> ...
        *)
       (# rec: ^Receiver;
          inv: ^Invocation;
          isControl: @boolean;
          pActualArguments:
            (# x: @integer
            enter x
            do (if x
                // 1 then 
                   symb[] -> FuncBracket-> inv.append;
                // 2 then
                   symb[] -> controlBracket -> inv.append;
                else
                   symb[] -> Separator -> inv.append;
               if);
               0 -> x;
               pExp -> inv.append;
               (if lex.symb 
                // lex.symbols.fatComma then
                   lex.sym[] -> symb[];
                   lex;
                   restart pActualArguments
                // lex.symbols.comma then
                   lex;
                   ',' -> symb[];
                   restart pActualArguments;
               if);
               (if lex.symb 
                // lex.symbols.idf then
                   lex.sym[] -> symb[];
                   lex;
                   true -> isControl
                else
                   &text[] -> symb[]
               if);
               (if lex.symb = lex.symbols.rightSquare then
                   ']' -> symb.put;
                   lex;
                   (if isControl then
                       symb[] -> RightControlBracket -> inv.append
                    else
                       symb[] -> FuncBracket -> inv.append
                   if)
                else
                   SyntaxError
               if)
            #);
          symb: ^text;
          exp: ^expression;
          isText: @boolean
       do 
          Invocation -> inv[]; 
          pReceiver -> (rec[],symb[],isText);
          (* <idf> ('.' <idf>)* , <string> ('.' <idf>)*, '(' <exp> ')' 
           * symb <> none: possible unary 
           * exp[] <> none: ??
           *)
          (* if 'R. ' then only keyword and unary below, no binary 
           * Also: we should avoid '.' in  'a.+b' 
           *)
          
          (if lex.symb
           // lex.symbols.leftSquare then (* 'foo[' or 'R.foo[' *) 
              lex.sym[] -> symb[];
              lex;
              (if (1->symb.inxGet) = '[' then (* ad hoc *)
                  2 -> pActualArguments;  
               else
                  1 -> pActualArguments;  
              if)
           // lex.symbols.special then (* binary *) 
              lex.sym[] -> Lexem -> inv.append;
              lex; 
              pExp -> inv.append; 
           else (* unary foo *)
              (if symb[] <> none then
                  (if isText then
                      symb[] -> Lexem -> TextExp -> inv.append
                   else
                      symb[] -> Lexem -> Variable -> inv.append
                  if)
                  (* none in the case of empty super in '{...}' *)
              if)
          if);
          (* 'Receiver: ' -> puttext; rec.doPT -> putline;
           * 'Inv: ' -> puttext; inv.doPT -> putline; *)
       exit (rec[],inv[]) -> ObjectInvocation
       #);
     pReceiver:
       (* (( <idf> | <text> | '(' <exp> ')' ) ('.' <idf>) )? *)
       (# rec: ^Receiver; exp: ^Expression;
          pRemoteList:
            (# kind: @integer;
            enter kind
            do L:
                 (if lex.symb = lex.symbols.dot then
                     lex;
                     (if kind
                      // 1 then
                         symb[] -> Lexem (* -> VarReceiver *) -> rec.append;
                      // 2 then
                         symb[] -> Lexem -> TextReceiver -> rec.append;
                      // 3 then 
                         
                     if);
                     (if lex.symb = lex.symbols.idf then
                         lex.sym[] -> symb[];
                         lex;
                         1 -> kind;
                         restart L
                     if)
                 if)
            #);
          symb: ^text; isText: @boolean    
       do Receiver -> rec[];
          (if lex.symb
           // lex.symbols.idf then
              lex.sym[] -> symb[];
              lex;
              1 -> pRemoteList
           // lex.symbols.textSy // lex.symbols.charSy then
              lex.sym[] -> symb[];
              lex;
              true -> isText;
              2 -> pRemoteList
           // lex.symbols.leftBrack then (* ( exp ) *)
              lex;
              pExp -> exp[];
              (if lex.symb = lex.symbols.rightBrack then
                  lex;
                  3 -> pRemoteList
               else
                  SyntaxError
              if) 
          if);
          (if lex.symb 
           // lex.symbols.leftSquare then
           // lex.symbols.special then
              (if symb[] <> none then
                  symb[] -> Lexem -> Variable -> rec.append;
                  true -> rec.isBinary
              if)
          if);
          (* symb[] <> none : unary method *)
       exit(rec[],symb[],isText)
       #);
     pMainPart: 
       (# mp: ^MainPart; 
       do MainPart -> mp[];
          (if lex.symb = lex.symbols.begin then
              lex;
              pAttributes -> mp.att[];
              pActions -> mp.act[];
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  SyntaxError
              if)
           else 
              true -> mp.isEmpty;
          if)
       exit mp[]
       #);
     pAttributes:
       (# ATS: ^Attributes; att: ^Attribute
       do Attributes -> ATS[];
          Loop:
            (if (pAttribute -> att[]) <> NONE then
                att[] ->  ATS.append;
                (if lex.symb 
                 // lex.symbols.semicolon then
                    lex;
                    restart Loop
                 // lex.symbols.DoSy then
                if)
            if)
       exit ATS[]
       #);
     pAttribute:
       (# sig: ^Signature;
          ATT: ^Attribute;
          symb: ^text;
          ksig: ^KeywordSignature;
          bsig: ^BinarySignature
       do (if lex.symb
           // lex.symbols.doSy // lex.symbols.end then (* perhaps lex here *)
              leave pAttribute
           // lex.symbols.idf then 
              lex.sym[] -> symb[];
              lex;
              (if lex.symb = lex.symbols.leftSquare then (* keyword att *)
                  lex;
                  '[' -> symb.put;
                  
                  symb[] -> KeywordSignature -> ksig[] -> sig[];
                  pParameters -> ksig.par[];
               else (* unary attribute *)
                  symb[] -> UnarySignature -> sig[];
              if) 
           // lex.symbols.special then (* binary attribute *)
              lex.sym[] -> symb[];
              lex;
              symb[] -> BinarySignature -> bsig[] -> sig[];
              pAttribute -> bsig.par[]
           // lex.symbols.leftSquare then (* keyWordAtt *)
              lex.sym[] -> symb[];
              lex;
              symb[] -> KeywordSignature -> ksig[] -> sig[];
              pParameters -> ksig.par[];
           else
              2 -> syntaxError
          if);
          none -> symb[];
          (if lex.symb = lex.symbols.assign then (* result*)
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> symb[];
                  lex
               else
                  syntaxError
              if)
          if);
          (if lex.symb = lex.symbols.colon then
              lex;
              pAttSpec -> ATT[];
              symb[] -> Lexem -> att.res[];
              sig[] -> ATT.sig[];
           else
              SyntaxError
          if);
       exit ATT[]
       #);
     pParameters:
       (# par: ^Parameters; sep: ^text
       do &Parameters[] -> par[]; 
          pAttribute -> par.append;
          L:
            (if lex.symb
             // lex.symbols.fatComma then
                lex.sym[] -> Separator -> par.append;
                lex;
                pAttribute -> par.append;
                restart L
             // lex.symbols.comma then
                lex;
                ',' -> lexem -> par.append;
                pAttribute -> par.append ;
                restart L;
             // lex.symbols.idf then
                lex.sym[] -> sep[];
                lex;
             else
                &text[] -> sep[]
            if);
          (if lex.symb = lex.symbols.rightSquare then
              lex;
              ']' -> sep.put;
              sep[] -> RightControlBracket -> par.append
           else
              SyntaxError
          if);
       exit par[]
       #);
     pAttSpec:
       (# att: ^Attribute
       do (if lex.symb 
           // lex.symbols.object then
              lex;
              pStaticObject -> att[]
           // lex.symbols.ref then
              lex;
              pDynamicObject -> att[]
           // lex.symbols.lt then
              lex;
              pVirtualPattern -> att[];
           // lex.symbols.colon then
              lex;
              (if lex.symb = lex.symbols.lt then
                  lex;
                  pFurtherBinding -> att[]
               else
                  pFinalBinding -> att[]
              if)
           else 
              pPattern -> att[]
          if)
       exit att[]
       #);
     pPattern:
       (# OD: ^objectDescriptor
       do pObjectDescriptor -> OD[]
       exit OD[] -> Pattern
       #);
     pObjectDescriptor:
       (# super: ^PatternId; MP: ^MainPart
       do pPatternId -> super[];
          pMainPart -> MP[];
       exit (super[],MP[]) -> ObjectDescriptor
       #);
     pPatternId:
       (* P
        * foo(,at,)
        * bar(,,)bar
        * (if,then,elseif)
        *)
       (# pi: ^PatternId; symb: ^text
       do &PatternId[] -> pi[];
          (if lex.symb
           // lex.symbols.idf then
              lex.sym[] -> symb[];
              lex;
              (if lex.symb = lex.symbols.leftSquare then
                  lex;
                  '[' -> symb.put;                  
              if);
              symb[] -> Lexem -> pi.append
           // lex.symbols.leftSquare then
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> symb[];
                  '[' -> symb.prepend;
                  symb[] -> Lexem -> pi.append
              if)
           else
          if)
       exit pi[]
       #);
     pVirtualPattern:
       (# OD: ^objectDescriptor
       do pObjectDescriptor -> OD[];
       exit OD[] -> VirtualPattern
       #);
     pFurtherBinding:
       (#
       do
       exit Attribute
       #);
     pFinalBinding:
       (#
       do
       exit Attribute
       #);
     pActions:
       (# act: ^Actions; exp: ^Expression
       do Actions -> act[];
          (if lex.symb = lex.symbols.doSy then
              lex;
              loop:
                (#
                do (if (pExp -> exp[]) <> none then exp[] -> act.append if);
                   (if lex.symb 
                    // lex.symbols.semicolon then
                       lex;
                       restart loop
                   if)
                #)
          if)
       exit act[]
       #);
     
     pExp:
       (# exp: ^Expression
       do (if lex.symb
           // lex.symbols.const then
              lex.sym[] -> Lexem -> Const -> exp[];
              lex;
           else
              pObjectGeneration -> exp[]
          if)
       exit exp[]
       #);
     syntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; newline;
          3 -> lex.printlines;
          (failureTrace (*dumpStack*), 'Syntax error')  -> stop
       #);
     
     lex: @Lexer;
     
     in: ^Stream
  enter in[]
  do in[] -> lex.init;
     
     Loop:
       (# M: ^Module;
       do lex;
          pModule -> M[];
          '\n\nAST:'->putline;
          M.doPT -> putline;
       #)
  #)

