ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xlexer';
INCLUDE 'xAbstractSyntaxTree';

---lib:attributes---
parser: AbstractSyntaxTree
  (# pModule:
       (# symb: ^text;
          sig: ^Signature;
          res: ^Lexem;
          SO: ^StaticObject
       do (if lex.symb = lex.symbols.idf then 
              lex.sym[] -> symb[];
              symb[] -> UnarySignature -> sig[];
              none -> Lexem -> res[];
              lex;
              (if lex.symb = lex.symbols.colon then 
                  lex; 
                  (if lex.symb = lex.symbols.object then
                      lex;
                      (sig[],res[]) -> pStaticObject -> SO[]
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       exit SO[] -> Module
       #);
     pStaticObject:
       (# O: ^ObjectGeneration;
          sig: ^Signature;
          res: ^Lexem;
       enter(sig[],res[])
       do  pObjectGeneration -> O[];
       exit (sig[],res[],O[]) -> StaticObject          
       #);
     pDynamicObject:
       (# pi: ^PatternId;
          sig: ^Signature;
          res: ^Lexem;
       enter(sig[],res[])
       do pPatternId -> pi[]
       exit (sig[],res[],pi[]) -> DynamicObject
       #);
     pObjectGeneration:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
        (# OI: ^ObjectInvocation;
           MP: ^MainPart;
        do pObjectInvocation -> OI[];
           pMainPart -> MP[]
       exit (OI[],MP[]) -> ObjectGeneration
       #);
     pObjectInvocation:
       (* { <objectId> '.' }* <beginId> ...
        *)
       (# rec: ^ReceiverPath;
          inv: ^Invocation;
          isControl: @boolean;
          pActualArguments:
            (# x: @integer;
               KeyW: ^Keyword
            enter x
            do Keyword -> KeyW[];
               (*'Keyword:'->puttext; symb[] -> putline;*)
               Loop:
                 (# E: ^Expression
                 do
                    (if x
                     // 1 then (* 'foo[' *)
                        symb[] -> FuncBracket-> keyW.append;
                     // 2 then (* '[foo' *)
                        symb[] -> ControlBracket -> keyW.append;
                     else (* '%foo' *)
                        symb[] -> Separator -> keyW.append;
                    if);
                    0 -> x;
                    (*'pExp:'->puttext; lex.symb -> putint; ' '->put;
                    lex.sym[] -> putline;*)
                    pExp -> E[] -> keyW.append;
                    (*' exp='->puttext;
                    E.doPT -> puttext; ' '-> put; keyW.doPT -> putline; *)
                    (if lex.symb
                     // lex.symbols.fatComma then
                        lex.sym[] -> symb[] -> compoundSymb.append;;
                        lex;
                        restart Loop
                     // lex.symbols.comma then
                        lex;
                        ',' -> symb[] -> compoundSymb.append;
                        restart Loop;
                    if);
                 #);
               (if lex.symb 
                // lex.symbols.idf then
                   lex.sym[] -> symb[];
                   lex;
                   true -> isControl
                else
                   &text[] -> symb[]
               if);
               (if lex.symb = lex.symbols.rightSquare then
                   ']' -> symb.put;
                   lex;
                   (if isControl then
                       symb[] -> RightControlBracket -> keyW.append
                    else
                       symb[] -> FuncBracket -> keyW.append
                   if);
                   symb[] -> compoundSymb.append;
                   compoundSymb[] -> keyW.compoundSymb[]
                else
                   SyntaxError
               if)
            exit keyW[]
            #);
          compoundSymb: ^text;
          symb: ^text;
          exp: ^expression;
          isText: @boolean
       do 
         (* Invocation -> inv[]; *)
          pReceiverPath -> (rec[],symb[],isText);

          (* <idf> ('.' <idf>)* , <string> ('.' <idf>)*, '(' <exp> ')' 
           * symb <> none: possible unary 
           * exp[] <> none: ??
           *)
          (* if 'R. ' then only keyword and unary below, no binary (No R.+7 )
           * Also: we should avoid '.' in  'a.+b' 
           *)
          (* 'pReceiverPath: ' -> puttext; 
           ' 'rec.doPT -> putline;
           * symb[] -> putline;
           *)
          
          (if lex.symb
           // lex.symbols.leftSquare then (* 'foo[' or 'R.foo[' *) 
              lex.sym[] -> symb[];
              symb.copy -> compoundSymb[];
              lex;
              (if (1->symb.inxGet) = '[' then (* ad hoc *)
                  2 -> pActualArguments -> Invocation -> inv[];
               else
                  1 -> pActualArguments  -> Invocation -> inv[]
              if)
           // lex.symbols.special then (* binary *)
              (# opr: ^Lexem; arg: ^Expression; bin: ^Binary
              do (*'pBin: \n' -> puttext; *)
                 lex.sym[] -> Lexem -> opr[];
                 (*opr.dopp -> puttext; *)
                 lex.sym.copy -> compoundSymb[];
                 lex; 
                 (* 'Arg:\n' -> puttext;
                  * lex.symb -> putint; newline;
                  *)
                 pExp -> arg[];
                 (* arg.doPP -> puttext; *)
                 (compoundSymb[],opr[],arg[] ) -> Binary -> bin[];
                 (*' bin= \n'->puttext; bin.dopp->putline;*)
                 bin[] -> Invocation -> inv[]; 
                 (*'Inv: ' -> putline; inv.doPP -> putline*)
              #)
           else (* unary foo *)
              (if symb[] <> none then
                  (if isText then 
                      symb[] -> Lexem -> TextExp -> Invocation -> inv[]
                   else
                      symb[] -> Lexem -> Variable -> Invocation -> inv[]
                  if);
                  symb.copy -> compoundSymb[];
                      (* none in the case of empty super in '{...}' *)
               else
                  Expression -> Invocation -> inv[]
              if);
              compoundSymb[] -> inv.compoundSymb[];
              compoundSymb[] -> inv.exp.compoundSymb[];
          if);
          (* 'ReceiverPath: ' -> puttext; rec.doPT -> putline;
          'Inv: ' -> puttext; inv.doPT -> putline;
          'CS: ' -> puttext; compoundSymb[] -> putline;*)
       exit (rec[],inv[],compoundSymb[]) -> ObjectInvocation
       #);
     pReceiverPath:
       (* (( <idf> | <text> | '(' <exp> ')' ) ('.' <idf>) )? *)
       (# rec: ^ReceiverPath; exp: ^Expression;
          pRemoteList:
            (* { <idf> '.' }* 
             * { <text> '.' }*
             * { '(' <exp>} ')' }*
             *)
            (# kind: @integer;
            enter kind
            do L:
                 (if lex.symb = lex.symbols.dot then
                     lex;
                     (if kind
                      // 1 then
                         symb[] -> Lexem -> Variable -> rec.append;
                      // 2 then
                         symb[] -> Lexem -> TextExp -> rec.append;
                      // 3 then 
                         '\n**** OBS! xparser:pReceiverPath: No macth'
                           -> putline
                     if);
                     (if lex.symb 
                      // lex.symbols.idf then
                         lex.sym[] -> symb[];
                         lex;
                         1 -> kind;
                         restart L
                      // lex.symbols.special then
                         (* We do not allow  A.+ B *)
                         SyntaxError
                     if)
                 if)
            #);
          symb: ^text; isText: @boolean    
       do ReceiverPath -> rec[];
          (if lex.symb
           // lex.symbols.idf then (* Foo *)            
              lex.sym[] -> symb[];
              lex;
              1 -> pRemoteList
           // lex.symbols.textSy // lex.symbols.charSy then
              (* 'Hello' or '@' *)
              lex.sym[] -> symb[];
              lex;
              true -> isText;
              2 -> pRemoteList
           // lex.symbols.leftBrack then (* ( <exp> ) *)
              lex;
              pExp -> exp[];
              (if lex.symb = lex.symbols.rightBrack then
                  lex;
                  3 -> pRemoteList
               else
                  SyntaxError
              if) 
          if);
         (* 'pReceiverPath:Rec: "' -> puttext; Rec.doPt -> putText;
          '" symb: "' -> puttext; symb[] -> puttext; '"'->put;
          ' lex: "' -> puttext; lex.symb -> lex.symbols.asText -> puttext;
          '" lx.sy: "' -> puttext; lex.sym[] -> puttext;*)
          (* rec = <empty>    symb = none ?
           *                  symb = 'foo'
           *                  symb= "'hello'"
           * rec = R.         symb = 'foo'
           *                       = ? / error
           * rec = R          symb = ?   lex.symb = special
           *)
          (* Rec = <empty>            symb = none      
           *     | foo ´              symb = 'foo'
           *     | X.Y.foo            symb = 'foo'
           *     | 'hello'            symb = 'Hello'
           *     | 'Hello'.X.foo      symb = 'foo'
           *     | ( <exp> )          symb = none
           *     | ( <exp> ).X.foo    symb = 'foo'
           *     | <Path> .           symb = ?
           * where foo = foo
           *           | foo[...]
           *           | ?           
           * lex.sym = 
           *)
          (if lex.symb 
           // lex.symbols.leftSquare then 
              (* a symbol foo[...] is lexed as foo [ ... ] 
               * But what if symb = [foo - can we then get [*
               *)
           // lex.symbols.special then
              (if symb[] <> none then
                  symb[] -> Lexem -> Variable -> rec.append;
                  true -> rec.isBinary
              if);
              lex.sym[] -> symb[]
          if);
          (* Rec = <Path> 
           *     | <Path> &&       symb = ?
           *)
         (* '"\n         exit:Rec: "' -> puttext; Rec.doPt -> putText;
          '" symb: "' -> puttext; symb[] -> puttext; '"'->put;
          ' lex: "' -> puttext; lex.symb -> lex.symbols.asText -> puttext;
          '" lx.sy: "' -> puttext; lex.sym[] -> puttext; '"'->put; newline*)
          (* symb[] <> none : unary method *)
       exit(rec[],symb[],isText)
       #);
     pMainPart: 
       (# mp: ^MainPart; 
       do MainPart -> mp[];
          (if lex.symb = lex.symbols.begin then
              lex;
              pAttributes -> mp.att[] -> mp.append;
              pActions -> mp.act[] -> mp.append;
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  SyntaxError
              if)
           else 
              true -> mp.isEmpty;
          if)
       exit mp[]
       #);
     pAttributes:
       (# ATS: ^Attributes; att: ^Attribute
       do Attributes -> ATS[];
          Loop:
            (if (pAttribute -> att[]) <> NONE then
                att[] ->  ATS.append;
                (if lex.symb 
                 // lex.symbols.semicolon then
                    lex;
                    restart Loop
                 // lex.symbols.DoSy then
                if)
            if)
       exit ATS[]
       #);
     pAttribute:
       (# sig: ^Signature;
          ATT: ^Attribute;
          symb: ^text;
          ksig: ^KeywordSignature;
          bsig: ^BinarySignature;
          compoundSymb: ^text;
          pParameters:
            (# par: ^Parameters; sep: ^text
            do &Parameters[] -> par[]; 
               pAttribute -> par.append;
               L:
                 (if lex.symb
                  // lex.symbols.fatComma then
                     lex.sym[] -> compoundSymb.append;
                     (*'F:'->puttext; compoundSymb[] -> putline;*)
                     lex.sym[] -> Separator -> par.append;
                     lex;
                     pAttribute -> par.append;
                     restart L
                  // lex.symbols.comma then
                     lex;
                     ',' -> compoundSymb.append;
                     ',' -> lexem -> par.append;
                     pAttribute -> par.append ;
                     restart L;
                  // lex.symbols.idf then
                     
                     lex.sym[] -> sep[];
                     (*lex.sym[] -> compoundSymb.append;*)
                     (*'W:'->puttext; compoundSymb[] -> putline;*)
                     lex;
                  else
                     &text[] -> sep[]
                 if);
               (if lex.symb = lex.symbols.rightSquare then
                  (* 'E: ' -> puttext;
                   lex.sym[] -> puttext; '-'->put;*)
                   ']' -> sep.put;
                   sep[] -> compoundSymb.append; (*compoundsymb[]->putline;*)
                   sep[] -> RightControlBracket -> par.append;
                   lex;
                else
                   SyntaxError
               if);
            exit par[]
            #);
       do (if lex.symb
           // lex.symbols.doSy // lex.symbols.end then (* perhaps lex here *)
              leave pAttribute
           // lex.symbols.idf then 
              lex.sym[] -> symb[];
              lex;
              (if lex.symb = lex.symbols.leftSquare then (* keyword att *)
                  lex;
                  '[' -> symb.put;
                  symb.copy -> compoundSymb[];
                  symb[] -> KeywordSignature -> ksig[] -> sig[];
                  pParameters -> ksig.par[];
               else (* unary attribute *)
                  symb.copy -> compoundSymb[];
                  symb[] -> UnarySignature -> sig[];
              if) 
           // lex.symbols.special then (* binary attribute *)
              lex.sym[] -> symb[];
              symb.copy -> compoundSymb[];
              lex;
              symb[] -> compoundSymb[] -> BinarySignature -> bsig[] -> sig[];
              pAttribute -> bsig.par[] -> bsig.append
           // lex.symbols.leftSquare then (* keyWordAtt *)
              lex.sym[] -> symb[];
              lex;
              symb.copy -> compoundSymb[];
              (* 'Q:'->puttext; compoundSymb[] -> putline; *)
              symb[] -> KeywordSignature -> ksig[] -> sig[];
              pParameters -> ksig.par[] -> ksig.append;
           else
              2 -> syntaxError
          if);

          none -> symb[];
          (if lex.symb = lex.symbols.assign then (* result*)
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> symb[];
                  lex
               else
                  syntaxError
              if)
          if);
          (if lex.symb = lex.symbols.colon then
              lex;
              (sig[],''->lexem) -> pAttSpec -> ATT[];
              (* symb[] -> Lexem -> ATT.res[] -> ATT.append;;
               sig[] -> ATT.sig[] -> ATT.append;*)
              compoundSymb[] -> att.compoundSymb[]
           else
              SyntaxError
          if);
       exit ATT[]
       #);

     pAttSpec:
       (# sig: ^Signature;
          res: ^Lexem;
          att: ^Attribute
       enter(sig[],res[])
       do (if lex.symb 
           // lex.symbols.object then
              lex;
              (sig[],res[])-> pStaticObject -> att[]
           // lex.symbols.ref then
              lex;
              (sig[],res[])-> pDynamicObject -> att[]
           // lex.symbols.lt then
              lex;
              (sig[],res[])-> pVirtualPattern -> att[];
           // lex.symbols.colon then
              lex;
              (if lex.symb = lex.symbols.lt then
                  lex;
                  (sig[],res[]) -> pFurtherBinding -> att[]
               else
                  (sig[],res[]) -> pFinalBinding -> att[]
              if)
           else 
              (sig[],res[]) -> pPattern -> att[]
          if)
       exit att[]
       #);
     pPattern:
       (# OD: ^objectDescriptor;
          sig: ^Signature;
          res: ^Lexem;
          att: ^Attribute
       enter(sig[],res[])
       do pObjectDescriptor -> OD[]
       exit (sig[],res[],OD[]) -> Pattern
       #);
     pObjectDescriptor:
       (# super: ^PatternId; MP: ^MainPart
       do pPatternId -> super[];
          pMainPart -> MP[];
       exit (super[],MP[]) -> ObjectDescriptor
       #);
     pPatternId:
       (* Seems we are missing remote : R.S.P
        * P
        * foo(,at,)
        * bar(,,)bar
        * (if,then,elseif)
        *)
       (# PI: ^PatternId; 
          rec: ^receiverPath; symb: ^text; isText: @boolean
       do &PatternId[] -> PI[];
          (* We must check if it works by just calling pReceiverPath here *)
          pReceiverPath -> (rec[],symb[],isText);
          (*   'PatternId: ' -> puttext; rec.doPT -> puttext; 
           *           ' Symb: ' -> puttext;
           *           symb[] -> puttext;  
           *           ' lex.sym: ' -> puttext;
           *           lex.sym[] -> puttext;  '-'->put; lex.symb -> putint;
           *           newline;
           *)
          rec[] -> PI.rec[] -> PI.append;
          (if lex.symb
              (*   // lex.symbols.idf then '*'->put; lex.sym[] -> puttext;
               *               symb[] -> PI.compoundSymb[]; 
               *               lex; lex.symb -> putint; lex.sym[] -> puttext;
               *               (if lex.symb = lex.symbols.leftSquare then 
               *                   {* seems wrong '[' never here ?
               *                    * Apparently foo[ is lexed as foo [
               *                    * And the same  for foo] as foo ]
               *                    *}
               *                   '\n!!! pPatternId: got idf [' -> putline;
               *                   lex;
               *                   '[' -> PI.compoundSymb.put; 
               *                   {* (if lex.symb = lex.symbols.rightSquare then ']'->put;
               *                    * lex;
               *                    * ']' -> PI.compoundSymb.put
               *                    *}
               *               if);
               *               PI.compoundSymb[] -> Lexem -> pi.append;  
               *)            
           // lex.symbols.leftSquare then (* foo[ or [foo *)
              lex.sym[] -> PI.compoundSymb[];
              (*lex.sym[] -> lexem -> PI.append;
              PI.compoundSymb[] -> putline;*)
              lex; 
              (* 'QQ: ' -> puttext; lex.sym[] ->putline;*)
              L:
                (if lex.symb 
                 // lex.symbols.fatComma then 
                   (* 'fat: '->puttext; lex.sym[] ->putline;
                    'PI: '->puttext; PI.doPt -> putline;*)
                    (*lex.sym[] -> Lexem -> PI.append;*)
                    lex.sym[] -> PI.compoundSymb.append;
                    lex;
                    restart L
                 // lex.symbols.rightSquare then 
                   (* '\nBingo: ' -> puttext; lex.sym[] ->putline;
                    'PI: '->puttext; PI.doPt -> putline;*)
                    (*lex.sym[]*)(* ']' -> Lexem -> PI.append; *)
                    (*lex.sym[]*)']' -> PI.compoundSymb.append;
                    (*pi.compoundSymb[] -> putline;*)
                    lex;
                if);
              (* 'rec: '->puttext; rec.doPt -> putline;
              'PI: ' -> puttext; PI.doPT -> putline*)
           else
              (if symb[] <> none then
                  symb[] -> PI.compoundSymb[]; 
               else
                  &text[] -> PI.compoundSymb[]
              if)
          if);
          (*   'After PI:'->puttext; lex.symb -> putint; newline;*)
       exit pi[]
       #);
     pVirtualPattern:
       (# OD: ^objectDescriptor;
          sig: ^Signature;
          res: ^Lexem
       enter(sig[],res[])
       do pObjectDescriptor -> OD[];
       exit (sig[],res[],OD[]) -> VirtualPattern
       #);
     pFurtherBinding:
       (# sig: ^Signature;
          res: ^Lexem
       enter(sig[],res[])
       do '\n***** Parser: fix further binding' -> putline;
       exit Attribute
       #);
     pFinalBinding:
       (# sig: ^Signature;
          res: ^Lexem
       enter(sig[],res[])
       do '\n***** Parser: fix final binding' -> putline;
       exit Attribute
       #);
     pActions:
       (# act: ^Actions; exp: ^Expression
       do Actions -> act[];
          (if lex.symb = lex.symbols.doSy then
              lex;
              loop:
                (#
                do (if (pExp -> exp[]) <> none then exp[] -> act.append if);
                   (if lex.symb 
                    // lex.symbols.semicolon then
                       lex;
                       restart loop
                   if)
                #)
          if)
       exit act[]
       #);
     
     pExp:
       (# exp: ^Expression
       do (if lex.symb
           // lex.symbols.const then 
              lex.sym[] -> Lexem -> Const -> exp[];
              lex;
           else 
              pObjectGeneration -> exp[]
          if)
       exit exp[]
       #);
     syntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; newline;
          3 -> lex.printlines;
          (failureTrace (*dumpStack*), 'Syntax error')  -> stop
       #);
     
     lex: @Lexer;
     M: ^Module;
     
     in: ^Stream;
  enter in[]
  do in[] -> lex.init;
     
     lex;
     pModule -> M[];
     '\n\nAST:'->putline;
     M.doPT -> putline;
     inner;
     (*M.doPT -> putline;*)

  #)

