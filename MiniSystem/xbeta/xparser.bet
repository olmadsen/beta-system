ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xlexer';
INCLUDE 'xAbstractSyntaxTree';

---lib:attributes---
parser: AbstractSyntaxTree
  (# pModule:
       (# N: ^Lexem;
          SO: ^StaticObject
       do (if lex.symb = lex.symbols.idf then 
              lex.sym[] -> Lexem -> N[];
              lex;
              (if lex.symb = lex.symbols.colon then 
                  lex; 
                  (if lex.symb = lex.symbols.object then
                      lex;
                      pStaticObject -> SO[]
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if)
       exit (N[],SO[]) -> Module
       #);
     pStaticObject:
       (# O: ^ObjectGeneration
       do pObjectGeneration -> O[];
       exit O[] -> StaticObject          
       #);
     pObjectGeneration:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
        (# OI: ^ObjectInvocation;
           MP: ^MainPart;
        do pObjectInvocation -> OI[];
           pMainPart -> MP[]
       exit (OI[],MP[]) -> ObjectGeneration
       #);
     pObjectInvocation:
       (* { <objectId> '.' }* <beginId> ...
        *)
       (# rec: ^Receiver;
          inv: ^Invocation;
          isControl: @boolean;
          pActualArguments:
            (# x: @integer
            enter x
            do (if x
                // 1 then 
                   symb[] -> FuncBracket-> inv.append;
                // 2 then
                   symb[] -> controlBracket -> inv.append;
                else
                   symb[] -> Lexem -> inv.append;
               if);
               0    -> x;
               pExp -> inv.append;
               (if lex.symb = lex.symbols.comma then
                   lex;
                   (if lex.symb = lex.symbols.idf then
                       lex.sym[] -> symb[];
                       ',' -> symb.prepend; ' ' -> symb.put;
                       lex;
                       restart pActualArguments
                    else
                       SyntaxError
               if)if);
               (if lex.symb 
                // lex.symbols.idf then
                   lex.sym[] -> symb[];
                   lex;
                   true -> isControl
                else
                   &text[] -> symb[]
               if);
               (if lex.symb = lex.symbols.rightBrack then
                   ')' -> symb.put;
                   lex;
                   (if isControl then
                       symb[] -> RightControlBracket -> inv.append
                    else
                       symb[] -> FuncBracket -> inv.append
                   if)
                else
                   SyntaxError
               if)
            #);
          symb: ^text;
       do Receiver -> rec[];
          Invocation -> inv[];
          L:
            (if lex.symb
             // lex.symbols.idf then
                lex.sym[] -> symb[];
                lex;
                (if lex.symb 
                 // lex.symbols.dot then (* parsing receiver *)
                    symb[] -> Lexem -> rec.append;
                    lex;
                    restart L
                 // lex.symbols.leftBrack then (* 'foo(' *)
                    lex;
                    '(' -> symb.append; 
                    1 -> pActualArguments;  
                 // lex.symbols.special then (* binary *)
                    symb[] -> Lexem -> Variable -> inv.append;
                    lex.sym[] -> Lexem -> inv.append;
                    lex; 
                    pExp -> inv.append
                 else (* unary foo *)
                    lex.sym[] -> Lexem -> Variable -> inv.append
                if) 
             // lex.symbols.special then (* binary *)
                lex.sym[] -> Lexem -> inv.append;
                lex;
                pExp -> inv.append
             // lex.symbols.leftBrack then (* leftId *)
                lex;
                (if lex.symb = lex.symbols.idf then (* (foo *)
                    lex.sym[] -> symb[];
                    '(' -> symb.prepend; 
                    lex;
                    2 -> pActualArguments;                    
                if);
             // lex.symbols.begin then

             else 
                (* empty *)
            if)
       exit (rec[],inv[]) -> ObjectInvocation
       #);
     pMainPart: 
       (# mp: ^MainPart; 
       do MainPart -> mp[];
          (if lex.symb = lex.symbols.begin then
              lex;
              pAttributes -> mp.att[];
              pActions -> mp.act[];
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  SyntaxError
              if)
           else 
              true -> mp.isEmpty;
          if)
       exit mp[]
       #);
     pAttributes:
       (# ATS: ^Attributes; att: ^Attribute
       do Attributes -> ATS[];
          Loop:
            (if (pAttribute -> att[]) <> NONE then
                att[] ->  ATS.append;
                (if lex.symb 
                 // lex.symbols.semicolon then
                    lex;
                    restart Loop
                 // lex.symbols.DoSy then
                if)
            if)
       exit ATS[]
       #);
     pAttribute:
       (# sig: ^Signature;
          ATT: ^Attribute;
          symb: ^text;
          ksig: ^KeywordSignature;
          bsig: ^BinarySignature
       do (if lex.symb
           // lex.symbols.doSy // lex.symbols.end then (* perhaps lex here *)
              leave pAttribute
           // lex.symbols.idf then
              lex.sym[] -> symb[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then (* keyword att *)
                  lex;
                  '(' -> symb.put;
                  
                  symb[] -> KeywordSignature -> ksig[] -> sig[];
                  pParameters -> ksig.par[];
               else (* unary att *)
                  symb[] -> UnarySignature -> sig[];
              if) 
           // lex.symbols.special then
              lex.sym[] -> symb[];
              lex;
              symb[] -> BinarySignature -> bsig[] -> sig[];
              pAttribute -> bsig.par[]
           // lex.symbols.leftBrack then (* keyWordAtt *)
              lex;
              (if lex.symb= lex.symbols.idf then
                  lex.sym[] -> symb[];
                  lex;
                  '(' -> symb.prepend; ' ' -> symb.put;              
                  symb[] -> KeywordSignature -> ksig[] -> sig[];
                  pParameters -> ksig.par[];
              if)
           else
              2 -> syntaxError
          if);
          (if lex.symb = lex.symbols.colon then
              lex;
              pAttSpec -> ATT[]
          if);
          sig[] -> ATT.sig[];
       exit ATT[]
       #);
     pParameters:
       (# par: ^Parameters; sep: ^text
       do &Parameters[] -> par[]; 
          pAttribute -> par.append;
          L:
            (if lex.symb
             // lex.symbols.comma then
                lex;
                (if lex.symb 
                 // lex.symbols.idf then (* ,IDF *) 
                    lex.sym[] -> sep[];
                    ' ,' -> sep.prepend; ' '-> sep.put;
                    sep[] -> lexem -> par.append;
                    lex;
                    pAttribute -> par.append ;
                    restart L
                if)
             // lex.symbols.idf then
                lex.sym[] -> sep[];
                lex;
             else
                &text[] -> sep[]
            if);
          (if lex.symb = lex.symbols.rightBrack then
              lex;
              ')' -> sep.put;
              sep[] -> RightControlBracket -> par.append
           else
              SyntaxError
          if);
       exit par[]
       #);
     pAttSpec:
       (# att: ^Attribute
       do (if lex.symb 
           // lex.symbols.object then
              lex;
              pStaticObject -> att[]
           // lex.symbols.lt then
              lex;
              pVirtualPattern -> att[];
           // lex.symbols.colon then
              lex;
              (if lex.symb = lex.symbols.lt then
                  lex;
                  pFurtherBinding -> att[]
               else
                  pFinalBinding -> att[]
              if)
           else 
              pPattern -> att[]
          if)
       exit att[]
       #);
     pPattern:
       (# OD: ^objectDescriptor
       do pObjectDescriptor -> OD[]
       exit OD[] -> Pattern
       #);
     pObjectDescriptor:
       (# super: ^PatternId; MP: ^MainPart
       do pPatternId -> super[];
          pMainPart -> MP[];
       exit (super[],MP[]) -> ObjectDescriptor
       #);
     pPatternId:
       (* P
        * foo(,at,)
        * bar(,,)bar
        * (if,then,elseif)
        *)
       (# pi: ^PatternId; symb: ^text
       do &PatternId[] -> pi[];
          (if lex.symb
           // lex.symbols.idf then
              lex.sym[] -> symb[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  lex;
                  '(' -> symb.put;                  
              if);
              symb[] -> Lexem -> pi.append
           // lex.symbols.leftBrack then
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> symb[];
                  '(' -> symb.prepend;
                  symb[] -> Lexem -> pi.append
              if)
           else
          if)
       exit pi[]
       #);
     pVirtualPattern:
       (# OD: ^objectDescriptor
       do pObjectDescriptor -> OD[];
       exit OD[] -> VirtualPattern
       #);
     pFurtherBinding:
       (#
       do
       exit Attribute
       #);
     pFinalBinding:
       (#
       do
       exit Attribute
       #);
     pActions:
       (# act: ^Actions; exp: ^Expression
       do Actions -> act[];
          (if lex.symb = lex.symbols.doSy then
              lex;
              loop:
                (#
                do (if (pExp -> exp[]) <> none then exp[] -> act.append if);
                   (if lex.symb 
                    // lex.symbols.semicolon then
                       lex;
                       restart loop
                   if)
                #)
          if)
       exit act[]
       #);
     
     pExp:
       (# exp: ^Expression
       do (if lex.symb
           // lex.symbols.const then
              lex.sym[] -> Lexem -> Const -> exp[];
              lex;
           else
              pObjectGeneration -> exp[]
          if)
       exit exp[]
       #);
     syntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; newline;
          3 -> lex.printlines;
          (dumpStack, 'Syntax error')  -> stop
       #);
     
     lex: @Lexer;
     
     in: ^Stream
  enter in[]
  do in[] -> lex.init;
     
     Loop:
       (# M: ^Module;
       do lex;
          pModule -> M[];
          '\n\nAST:'->putline;
          M.doPT -> putline;
       #)
  #)

