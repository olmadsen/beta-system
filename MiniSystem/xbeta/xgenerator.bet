ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xchecker';
INCLUDE '../miniCompiler/objectcode'
---lib:attributes---
generator: checker
  (# MkCom: (# t1,t2: ^text enter (t1[],t2[]) do t2[] -> T1.append -> cd.comment #);
     Module::
       (# gen::
            (#
            do ('Comp',newDesc.noOfDescs) -> cd.newComponent;
               SO.gen;
               this(Module)[] -> main[]
            #);
       #);
     StaticObject::
       (# gen::
            (# T: @text
            do (* Not for simple patterns like 
                *    X: @integer
                *)
               (if not OG.OI.isSimple then 
                   'not Simple' -> cd.comment;
                   (if origin[] <> none then 
                       OG.OI.gen; 
                       OG.descNo -> T.putint;
                       ('staticObject: alloc: ',T[]) -> cd.com2;
                       cd.pushThis;
                       (sig.name[],OG.descno,true) -> cd.alloc;
                       (sig.name[],this(StaticObject).off) -> cd.rstoreg
                   if);
                   (* only if singular - not for
                    * x:@integer; R: @Foo
                    *)
                   (if not OG.MP.isEmpty then
                       (sig.name[],none,OG[]) ->  ObjTmpStack.add
                   if)
               if)
            #);
          activate:: 
            (* called when Receiver *)
            (# 
            do 'StaticObject:activate: '->puttext; dopt -> putline;
               (if not OG.OI.isSimple then 
                   ('StaticObject:activate: ',dopt) -> cd.com2;
                   (sig.name[],this(StaticObject).off) -> cd.rpushg
               if)
            #);
          load::
            (* called when not eceiver - i.e. value to be pushed *)
            (#
            do 'StaticObject:load: '->puttext; dopt -> putline;
               (sig.name[],off) -> cd.pushg
            #);
          store::
            (* called when var to be stored
             * does not seem to be used since store happens in Binary
             *)
            (#
            do 'StaticObject:store: '->putline; (sig.name[],off) -> cd.push
            #);
       #);
     ObjectGeneration::
       (* OI: ObjectInvocation, MP: MainPart *)
       (# gen::
            (# 
            do (*('OG: ',OI.inv.compoundSymb[]) -> MkCom;*)
               (*OI.inv.ATd.doPT -> putline*)
               OI.gen;
               (if not mp.isEmpty then
                   'OG:add:singular: '-> puttext; doPT -> putline;
                   ('Singular',none,this(ObjectTemplate)[]) -> ObjTmpStack.add
               if)
            #);
          genClass::
            (# 
            do (if true then
                   (N[],sig[],descNo) -> MP.genClass
                else
                   (N[], descNo, false, 1,1) -> cd.class;
                   (* OI? *)
                   (* super ? *)
                   MP.gen;
               if)
            #);
          doCall::
            (#
            do 'doCall'->cd.comment; true -> hasDoPart;
               (if (exitType->TP[]) <> none then
                   (if TP.isRef then
                       2 -> xType
                    else
                       1 -> xType
               if)if);
               (if false then
                   doPt->putline;
                   'exitType: ' -> puttext; xType -> putint; newline;
               if);
               (if LMR
                // 'S' then
                   (if hasDoPart then (N[],'D') -> cd.call if);
                   cd.rtnEvent;                        
                // 'L' then
                   (if hasDoPart then (N[],'D') -> cd.call if);
                   (N[],'X') -> cd.call;
                   xType -> cd.rtnEvent
                // 'M' then
                   (N[],'N') -> cd.call;
                   (if hasDoPart then (N[],'D') -> cd.call if);
                   (N[],'X') -> cd.call;
                   xType -> cd.rtnEvent
                // 'R' then
                   (N[],'N') -> cd.call;
                   (if hasDoPart then (N[],'D') -> cd.call if);
                   cd.rtnEvent;                     
               if);
            #);
       #);
     ObjectDescriptor::
       (# gen:: (# (* never come here*) #);
          genClass::
            (# 
            do (if true then
                   (N[],sig[],descNo) -> MP.genClass                   
                else                   
                   (N[], descNo, false, 1,1) -> cd.class;
                   (* OI? *)
                   (* super ? *)
                   MP.gen;
                   (4,3,1) -> CD.endClass
               if)
            #);
          doCall::
            (#
            do (N[],'D') -> cd.call
            #)
       #);
     MainPart::
       (# gen:: 
            (# 
            do (if not isEmpty then
                   ('origin',originOff) -> cd.rstore; 
                   att.gen;
                   cd.markEnterE;            
                   false (* (superDesc[] <> none)*) -> cd.actions;                   
                   act.gen;
                   (vsize,rsize,1) -> CD.endClass
               if)
            #);
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; T: @text
            enter(N[],sig[],descNo)
            do (N[], descNo, false, 1,1) -> cd.class;
               (* OI? *)
               (* super ? *)
               ('origin',originOff) -> cd.rstore; 
               att.gen;
               cd.markEnterE; 
               (if sig[] <> none then
                   sig.storeParameters;
               if);
               false (* (superDesc[] <> none)*) -> cd.actions;                   
               act.gen;
               (vsize,rsize,1) -> CD.endClass               
            #);
       #);
     Attributes::
       (# gen:: 
            (#
            do scanSons (#do current.gen #);
            #)
       #);
     BinarySignature::
       (# storeParameters:: 
            (# 
            do ('BinarySignature',dopt) -> cd.com2;
               par.doPT -> cd.comment;
               cd.setThisStack;
               (par.sig.name[],par.off) -> cd.store
            #)
       #);
     KeywordSignature::
       (# storeParameters:: 
            (# 
            do ('KeywordSignature',dopt) -> cd.com2;
               cd.setThisStack;
               par.scanReverse
               (# A: ^Attribute; B: @boolean
               do current.doPT -> cd.comment;

                  (if B then
                      current[] -> A[];                      
                      (A.sig.name[],A.off) -> cd.store
                  if);
                  not B -> B;
               #)
            #)
       #);
     Pattern::
       (# gen:: (# do (compoundSymb[],sig[],OD[]) -> objTmpStack.add #);
          activate::
            (#
            do 'Pattern:activate: '->puttext; doPT -> putline;
               (if '+' -> sig.name.equal then 
                   lex.symbols.add -> cd.op 
                else
                   ('Call',doPT) -> cd.com2
               if)
            #);
          load::
            (#
            do 'Pattern:load: '->puttext; doPT -> putline;
               ('Pattern:load: ',doPT) -> cd.com2;
               (if '+' -> sig.name.equal then 
                   lex.symbols.add -> cd.op 
                else
                   (sig.name[],OD.descno,true) -> cd.alloc;
                   cd.rpop; (* depend on the return type *)
                   (*('x','S') -> OD.doCall; *)
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);          
       #);
     Actions::
       (# gen:: 
            (# 
            do scanSons(#do (true,0) -> current.gen #);
               (if false (*superDesc[] <> none *) then 
                   cd.rtnInner 
                else
                   'D' -> cd.rtn
               if)
            #);
       #);
     ObjectInvocation::
       (* a := 17;       a = rec, inv = := 17
        * a := b + 1     a = rec, inv = := b + 1
        *                b = rec, inv = + 1        *                
        * X: @integer - also an object invocation
        *)
       (# gen:: 
            (# 
            do (false,(isReceiver,0) -> rec.gen) -> inv.gen
            #)
       #);
     ReceiverPath::
       (# gen:: 
            (# 
            do 'RP: ' -> cd.comB; scanSons(# do current.doPT -> cd.comA #); cd.comE;
               (* 
                * R.foo     R = receiver 
                * R.S.foo   R.S = receiver
                *)
               cd.pushThis;
               scanSons
               (# 
               do 
                  (true,off) -> current.gen -> off;
                  (if not isLast then
                      ('xxx',off) -> cd.pushg
                  if)
               #)
            #);
       #);
     Invocation:: 
       (# gen:: (# do scanSons(#do (isReceiver,off) -> current.gen #)#)
       #);
     Keyword::
       (# gen::
            (#
            do 'KW:' -> cd.comment;
               scansons(#do ('KW:: ',current.doPT) -> cd.com2; current.gen #);
               (*ATd.activate;*)
               ATd.load;
               cd.comE
            #);
       #);
     Binary::
       (# gen::
            (#
            do ('Binary: ',operator.N[]) -> MkCom;
               (if '+' -> operator.N.equal then 
                   ('$x',off) -> cd.pushg 
               if);
               (true,0) -> argument.gen;
               (if isAssign then 
                   ('var',off) -> cd.storeg
                else
                   'Binary:gen:ATd: '->puttext;
                   (if ATd[] = none then 
                       'none' -> putline
                    else
                       ATd.doPT -> putline;
                       (* ATd.activate*)
                       ATd.load
                   if);
               if)
            #);
       #);
     Unary::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *)
       (# gen:: 
            (# inv: ^invocation
            do ('Unary: ',V.N[]) -> MkCom;
               'Unary: ' -> puttext; doPT -> puttext; ' ' -> put; 
               (if ATd.isSimple then 'isSimple: ' -> puttext if);
               (if isReceiver then
                   'isReceiver: ' -> puttext
                else
                   'is not Receiver: ' -> puttext
               if);
               ATd.doPT -> putline;               
               (if isReceiver then 
                   ATd.activate
                else
                   ATd.load 
               if);
               ATd.off -> off
            #);
       #);
     const::
       (# gen:: (#  do V.N.setpos; V.N.getInt -> cd.pushConst #)
       #);
          
     FuncBracket::
       (# gen:: (# do ('FuncB:',N[]) -> MkCom #)
       #);
     Lexem:: 
       (# gen:: (# do ('Lexem: ',N[]) -> MkCom #)
       #);
     genMain:
       (# descno: @integer
       do ('main',newDesc,false,1,0) -> cd.class;
          cd.pushThis;
          (*  (if false then
           *               'main: topModule: ' -> puttext;
           *               markIncludes.topModule.name.lexemSy -> puttext;
           *           if);
           *           ('BETAworld',(markIncludes.topModule.desc).descno,true) -> cd.alloc;
           *           (for i: markIncludes.top repeat
           *                ('origin',markIncludes.orgOff[markIncludes.top - i + 1]) -> cd.rpushg;
           *           for);
           *
           * ('x','S') -> (markIncludes.main.desc).doCall;          
           *)
          ('BETAworld',1,true) -> cd.alloc;
          (* ('x','S') -> (main.desc).doCall;          *)
          cd.stop; (* we should generate stop here and not in betaVM *)
          
          (*   (if markIncludes.main## <> ObjectModule## then
           *               '\n\n***** Only ObjectModules can be executed *****\n\n' -> putline
           *           if)
           *)
       #);
     genEventProcessor:
       (#
       do ('EventProcessor',newDesc,false,1,0) -> cd.class;
          cd.stop (* we should generate stop here and not in betaVM *)
       #);
     
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate;
            enter(N[],sig[],OT[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate;
            enter(N[],sig[],OT[])
            do (if (top+1-> top) > OTL.range then OTL.range -> OTL.extend if);
               (N[],sig[],OT[]) -> item -> OTL[top][]
            #);          
          next:
            (# inx: @integer
            do Loop:
                 (#
                 do inx +1 -> inx;
                    (if inx <= top then
                        (OTL[inx].N[],OTL[inx].sig[]) -> OTL[inx].OT.genClass;
                        restart Loop
                    if);
                 #)
               #);               
          OTL: [10] ^Item;top: @integer;
       #);
     main: ^Module;
     mainDescNo: (# exit newDesc.noOfDescs -1 (*- 2*) (* ad hoc *) #);
     cd: @ObjectCode;
     descs: ^RunTimeDescriptors;
     bclst: @File;
  do 'GENERATE'->putline;
     (if true then
         'xcode'-> bclst.name;
         bclst.openWrite;
         bclst[] -> cd.init;
         'xbeta'-> cd.comment;
         m.gen;
         ObjTmpStack.next;
         genMain;
         genEventProcessor;
         cd.dump;
         cd.descs[] -> descs[]; (* why ?*)         
         bclst.close;
     if)
  #)
