ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xchecker';
INCLUDE '../miniCompiler/objectcode'
---lib:attributes---
generator: checker
  (# MkCom: (# t1,t2: ^text enter (t1[],t2[]) do t2[] -> T1.append -> cd.comment #);
     Module::
       (# gen::
            (#
            do ('Comp',newDesc.noOfDescs) -> cd.newComponent;
               SO.gen
            #);
       #);
     StaticObject::
       (# gen::
            (#
            do OG.OI.gen;
               (sig.name[],OG[]) ->  ObjTmpStack.add
            #)
       #);
     ObjectGeneration::
       (* OI: ObjectInvocation, MP: MainPart *)
       (# gen::
            (# 
            do (*('OG: ',OI.inv.compoundSymb[]) -> MkCom;*)
               (*OI.inv.ATd.doPT -> putline*)
               OI.gen;
               (if not mp.isEmpty then
                   'OG:add:singular: '-> puttext; doPT -> putline;
                   ('Singular',this(ObjectTemplate)[]) -> ObjTmpStack.add
               if)
            #);
          genClass::
            (# 
            do 
               (N[], descNo, false, 1,1) -> cd.class;
               (* OI? *)
               (* super ? *)
               MP.gen;
               (4,3,1) -> CD.endClass
            #);
       #);
     ObjectDescriptor::
       (# gen:: (# (* never come here*) #);
          genClass::
            (# 
            do 
               (N[], descNo, false, 1,1) -> cd.class;
               (* OI? *)
               (* super ? *)
               MP.gen;
               (4,3,1) -> CD.endClass
            #);
       #);
     MainPart::
       (# gen:: 
            (# 
            do (if not isEmpty then
                   att.gen;
                   act.gen
               if)
            #)
       #);
     Attributes::
       (# gen:: (#do scanSons(#do current.gen #);#)
       #);
     Pattern::
       (# gen:: (# do (compoundSymb[],OD[]) -> objTmpStack.add #)
       #);
     Actions::
       (# gen:: (# do scanSons(#do 'A'->cd.comment; current.gen #)#);
       #);
     ObjectInvocation::
       (# gen:: (# do rec.gen; inv.gen #);
       #);
     ReceiverPath::
       (# gen:: 
            (# 
            do 'RP: ' -> cd.comB; scanSons(# do current.doPT -> cd.comA #); cd.comE
            #);
       #);
     Invocation:: 
       (# gen:: (# do scanSons(#do current.gen #)#)
       #);
     Keyword::
       (# gen::
            (#
            do 'KW:' -> cd.comment;
               scansons(#do ('KW:: ',current.doPT) -> cd.com2; current.gen #);
               cd.comE
            #);
       #);
     Binary::
       (# gen::
            (#
            do ('Bin: ',operator.N[]) -> MkCom;
               argument.gen
            #);
       #);
     Variable::
       (# gen:: (# do ('Var: ',V.N[]) -> MkCom #);
       #);
     FuncBracket::
       (# gen:: (# do ('FuncB:',N[]) -> MkCom #)
       #);
     Lexem:: 
       (# gen:: (# do ('Lexem: ',N[]) -> MkCom #)
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; OT: ^ObjectTemplate;
            enter(N[],OT[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; OT: ^ObjectTemplate;
            enter(N[],OT[])
            do (if (top+1-> top) > OTL.range then OTL.range -> OTL.extend if);
               (N[],OT[]) -> item -> OTL[top][]
            #);          
          next:
            (# inx: @integer
            do Loop:
                 (#
                 do inx +1 -> inx;
                    (if inx <= top then
                        OTL[inx].N[] -> OTL[inx].OT.genClass;
                        restart Loop
                    if);
                 #)
               #);               
          OTL: [10] ^Item;top: @integer;
       #);
     
     cd: @ObjectCode;
     bclst: @File;
  do 'Generate code'->putline;
     (if true then
         'xcode'-> bclst.name;
         bclst.openWrite;
         bclst[] -> cd.init;
         'xbeta'-> cd.comment;
         m.gen;
         ObjTmpStack.next;
         bclst.close;
     if)
  #)
