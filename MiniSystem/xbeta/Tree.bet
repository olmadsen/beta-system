ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/sysutils/objinterface';
---lib:attributes---
Tree:
  (# nd:
       (# doPP:
            (#
            do &text[] -> lx[];
               0 -> ind;
               PP;
               false -> mark;
            exit lx[]
            #);
          PP:< 
            (# 
            do '(' -> lx.put; 
               inner;
               (if son[] = none then 
                   '-' -> lx.put; 
                else
                   lx.newline;
                   (for i: (ind + 1 -> ind) repeat ' ' -> lx.put for);
                   scanSons(# do current.PP  #);
                   lx.newline;
                   (for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);
               if);
               ')' -> lx.put;  lx.newline;
               (for i: ind repeat ' ' -> lx.put for);               
            exit lx[] 
            #);
          doPT:
            (#
            enter mark
            do &text[] -> lx[];
               PT;
               false -> mark;
            exit lx[]
            #);
          length:< integerValue(# do inner #);
          PT:<
            (# pos: @integer; break: @boolean;
               block:
                 (# pos,width: @integer; break: @boolean
                 enter(pos,width)
                 do lineWidth < (pos + width) -> break;
                    inner
                 #);
               mkBreak:
                 (# pos: @integer; break: @boolean;
                 enter(pos,break)
                 do (if lx.length > 0 then (* no break or space if first line *)
                        (if break then
                            lx.newline;
                            (for i: pos repeat ' ' -> lx.put for)
                         else
                            inner
                    if)if)
                 #);
               mkBreak0: mkBreak(##);
               mkBreak1: mkBreak(# do ' ' -> lx.put #);
               printComment: (# do #);
            enter(pos,break) 
            do (if mark then lx.getpos -> beginPos  if);
               (if comment[] <> none then printComment if);
               inner;
               (if mark then lx.getpos -> endPos if)
            exit lx[]
            #);
          son,next,last,father: ^nd;
          append:
            (# N: ^nd
            enter N[]
            do (if N[] = none then 
                   (dumpStack,'Tree.bet::nd::append') -> stop
               if);
               (if son[] = none then
                   N[] -> son[]
                else
                   N[] -> last.next[]
               if);
               N[] -> last[];
               this(nd)[] -> N.father[]
            #);
          scanSons:
            (# current: ^nd;
               isLast: (# exit current.next[] = none #);
            do son[] -> current[];
               Loop:
                 (if current[] <> none then
                     inner;
                     current.next[] -> current[];
                     restart loop
                 if)
            #);
          getComment:<
            (# comm: ^text
            do inner
            exit comm[]
            #);
          adjustForSingularImp:< 
            (# bPos,ePos: @integer;
               OD: ^nd;
            enter(OD[],bPos,ePos) 
            do inner 
            exit(OD[],bPos,ePos)
            #);
          findNodeAtPos:<
            (# pos: @integer; N: ^nd;
               trace: (# exit false #)
            enter pos
            do inner
            exit N[]
            #);
          theModule:<
            (* Bindings in parser::module and parser.:nameApl *)
            (# md: ^nd
            do inner               
            exit md[]
            #);
          changeAttName:< 
            (# oldName,newName: ^text enter(oldName[],newName[]) do inner #); 
          getEntries:<
            (* An entry has  the form
             *    entry = (name,sort = (kind,entity))
             * For an objectDesc, a declaration is an entyr:
             *    dcl = (nameDcl, item=(kind,objectSpec))
             *)
            (# add:
                 (# T,N: ^text; E: ^nd
                 enter(T[],E[])
                 do T.copy -> N[];
                    (if E[] <> none then
                        E.skind -> N.puttext
                     else
                        '%' -> N.put
                    if);
                    1 -> names.extend; 1 -> entries.extend;
                    N[] -> names[names.range][]; 
                    E[] -> entries[entries.range][]
                 #);
               names: [0] ^Text; entries: [0]^Nd
            do inner
            exit(names[],entries[])
            #);
          sort:< (# S: ^nd do inner exit S[]#);
          entity:< (# E: ^Nd do inner; exit E[] #);
          myDesc:< 
            (# OD: ^Nd
            do inner;  
               (if OD[] = none then
                   'Trans:myDesc:missing virtual binding in sub: ' -> putline;
                   doPT -> putline ;
                   PP -> putline
               if)
            exit OD[] 
            #);
          kind:< (# ch: @char do '?' -> ch; inner exit ch #);
          sKind:< 
            (# S: ^text do '?' -> S[]; inner exit S[] #);   
          xKind:< (# K: @integer do inner exit K #);
          enclosingImperative:<
            (# imp: ^nd
            do inner;
               (if imp[] = none then 
                   (if father[] <> none then 
                       father.enclosingImperative -> imp[];
               if)if)
            exit imp[]
            #);
          findNextImp:<
            (# bcp: @integer; impx: ^nd
            enter bcp
            do inner
            exit impx[]
            #);
          comment: ^text;
          beginPos,endPos: @integer; (* position of this(nd) in .bet file *)
          beginBCP,endBCP: @integer; (* bytecode position at beginning and 
                                      * end of this nd set by 
                                      * generator::imperative::gen
                                      *)          
          setUpOrigin:< 
            (# org: ^node
            enter org[]
            do org[] -> origin[]; inner 
            #);
          check:<
            (# elm:< nd; scope: ^elm;
            enter scope[]
            do inner; true -> isChecked
            exit scope[]
            #);
          gen:< (# do inner #);
          isChecked: @boolean;
          origin: ^node   
       do inner
       exit this(nd)[]
       #);
     node:nd
       (# 
       do inner
       #);
     lineWidth: @integer;
     
     mark: @boolean;  (* True if beginPos and endPos are updated in AST
                       * mark = True when using doPT for doing PT to
                       *             edit buffer
                       * mark = false when using doPT for debugging purposes
                       *)
     lx: ^text;
     ind: @ integer
  do 40-> linewidth;
     inner
  #)
