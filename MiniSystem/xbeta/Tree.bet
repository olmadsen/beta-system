ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '../miniCompiler/directoryComponents'
---lib:attributes---
Tree: DirectoryModules
  (# TopNode:
       (# vNode:< TopNode;
          doPP:
            (#
            do &text[] -> lx[];
               0 -> ind;
               PP;
               false -> mark;
            exit lx[]
            #);
          PP:< 
            (# 
            do lx.newline;
               (for i: ind repeat ' ' -> lx.put for);
               '(' -> lx.put; 
               inner;
               (if son[] = none then
                   ')' -> lx.put;
                   (* lx.newline;
                   (for i: ind repeat ' ' -> lx.put for);*)
                else
                   ind + 1 -> ind;
                   (* lx.newline;
                    (for i: (ind + 1 -> ind) repeat ' ' -> lx.put for);*)
                   scanSons(# do current.PP  #);
                   (*lx.newline;*)
                   (*(for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);*)
                   ')' -> lx.put; 
                   (*lx.newline;
                    (for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);*)
                   ind - 1 -> ind
               if);
            exit lx[] 
            #);
          doPT:
            (#
            enter mark
            do &text[] -> lx[];
               PT;
               false -> mark;
            exit lx[]
            #);
          doP:
            (# pos: @integer; break: @boolean;
            enter(pos,break)
            do &text[] -> lx[];
               (0,true) -> PT;
            exit lx[]
            #);
          length:< integerValue(# do inner #);
          PT:<
            (# pos: @integer; break: @boolean;
               block:
                 (# pos,width: @integer; break: @boolean
                 enter(pos,width)
                 do lineWidth < (pos + width) -> break;
                    inner
                 #);
               mkBreak:
                 (# pos: @integer; break: @boolean;
                 enter(pos,break)
                 do (if lx.length > 0 then (* no break or space if first line *)
                        (if break then
                            lx.newline;
                            (for i: pos repeat ' ' -> lx.put for)
                         else
                            inner
                    if)if)
                 #);
               mkBreak0: mkBreak(##);
               mkBreak1: mkBreak(# do ' ' -> lx.put #);
               printComment: (# do #);
            enter(pos,break) 
            do (if mark then lx.getpos -> beginPos  if);
               (if comment[] <> none then printComment if);
               inner;
               (if mark then lx.getpos -> endPos if)
            exit lx[]
            #);
          son,next,last,father: ^TopNode;
          append:
            (# N: ^TopNode
            enter N[]
            do (if N[] = none then 
                   (dumpStack,'Tree.bet::TopNode::append') -> stop
               if);
               (if son[] = none then
                   N[] -> son[]
                else
                   N[] -> last.next[]
               if);
               N[] -> last[];
               this(TopNode)[] -> N.father[]
            #);
          noOfSons: IntegerValue
            (#
            do scanSons(# do value + 1 -> value #)
            #);
          scanSons:
            (# current: ^vNode;
               next: (# exit current.next[] #);
               isFirst: @boolean;
               isLast: (# exit current.next[] = none #);
            do son[] -> current[];
               true -> isFirst;
               Loop:
                 (if current[] <> none then
                     inner;
                     current.next[] -> current[];
                     false -> isFirst;
                     restart loop
                 if)
            #);
          scanReverse:
            (# current: ^TopNode;
               isLast: @boolean;
               L: [5] ^TopNode; top: @integer
            do scanSons
               (# do (if (top+1->top) > L.range then L.range -> L.extend if);
                  current[] -> L[top][]
               #);
               (for i: top repeat 
                    L[top+1-i][] -> current[];
                    i = top -> isLast;
                    INNER
               for)
            #);
          getComment:<
            (# comm: ^text
            do inner
            exit comm[]
            #);
          doInsert:<
            (# N,atN: ^TopNode;
            enter(N[],atN[])
            do inner
            #);
          doDelete:<
            (# N: ^text
            enter N[]
            do inner
            #);
          doMoveUp:< (#  N: ^TopNode enter N[] do inner #);
          adjustForSingularImp:< 
            (# bPos,ePos: @integer;
               OD: ^TopNode;
            enter(OD[],bPos,ePos) 
            do inner 
            exit(OD[],bPos,ePos)
            #);          
          replaceEntity:<
            (# errors: ^stream;
               path2Module,T: ^text
            enter(path2Module[],T[])
            do inner
            exit errors[]
            #);
          objDescEQ:< booleanValue(# dn: @integer enter dn do inner #);
          findNodeAtPos:<
            (# pos: @integer; N: ^TopNode;
               trace: (# exit false #)
            enter pos
            do inner
            exit N[]
            #);
          theModule:<
            (* Bindings in parser::module and parser.:nameApl *)
            (# md: ^TopNode
            do inner               
            exit md[]
            #);
          theImodule:
            (# iM: ^iModule;
               M: ^TopNode
            do (if (theModule -> M[]) <> none then
                   &iModule[] -> iM[];
                   M[] -> iM.M[]
               if)
            exit iM[]
            #);
          isAmodule:< (# M: ^TopNode do inner exit M[] #);
          changeAttName:< 
            (# oldName,newName: ^text enter(oldName[],newName[]) do inner #); 
          getEntries:<
            (* An entry has  the form
             *    entry = (name,sort = (kind,entity))
             * For an objectDesc, a declaration is an entyr:
             *    dcl = (nameDcl, item=(kind,objectSpec))
             *)
            (# add:
                 (# T,N: ^text; E: ^TopNode
                 enter(T[],E[])
                 do T.copy -> N[];
                    (if E[] <> none then
                        E.skind -> N.puttext
                     else
                        '%' -> N.put
                    if);
                    1 -> names.extend; 1 -> entries.extend;
                    N[] -> names[names.range][]; 
                    E[] -> entries[entries.range][]
                 #);
               names: [0] ^Text; entries: [0]^TopNode
            do inner
            exit(names[],entries[])
            #);
          sort:< (# S: ^TopNode do inner exit S[]#);
          entity:< (# E: ^TopNode do inner; exit E[] #);
          myDesc:< 
            (# OD: ^TopNode
            do inner;  
               (if OD[] = none then
                   'Trans:myDesc:missing virtual binding in sub: ' -> putline;
                   doPT -> putline ;
                   PP -> putline
               if)
            exit OD[] 
            #);
          kind:< (# ch: @char do '?' -> ch; inner exit ch #);
          sKind:< 
            (# S: ^text do '?' -> S[]; inner exit S[] #);   
          xKind:< (# K: @integer do inner exit K #);
          enclosingImperative:<
            (# imp: ^TopNode
            do inner;
               (if imp[] = none then 
                   (if father[] <> none then 
                       father.enclosingImperative -> imp[];
               if)if)
            exit imp[]
            #);
          findNextImp:<
            (# bcp: @integer; impx: ^TopNode
            enter bcp
            do inner
            exit impx[]
            #);
          comment: ^text;
          beginPos,endPos: @integer; (* position of this(TopNode) in .bet file *)
          beginBCP,endBCP: @integer; (* bytecode position at beginning and 
                                      * end of this TopNode set by 
                                      * generator::imperative::gen
                                      *)          
          setOSDVisibility:< 
            (# value: @integer enter value do inner #);
          configure:< 
            (# visibility: @integer do inner exit visibility #);
          setUpOrigin:< 
            (# org: ^TopNode
            enter org[]
            do org[] -> origin[]; inner 
            #);
          check:<
            (# elm:< TopNode; basicScope,argScope: ^elm; isFirst: @boolean
            enter(basicScope[],argScope[],isFirst)
            do inner; true -> isChecked
            exit basicScope[]
            #);
          getDescNo:< (# dNo: @integer do inner exit dNo #);
          getOrigin:< (# org: ^TopNode do inner exit org[] #);

          isChecked: @boolean;
          origin: ^vNode; 
       do inner
       exit this(TopNode)[]
       #);
     getObjectDesc:< 
       (# descNo: @integer; D: ^TOPNODE enter descNo do inner exit D[]#);

     theErrorModule:< 
       (# eModule: ^Object; iM: ^iModule
       do inner;
          (if eModule[] <> none then
              &iModule[] -> iM[];
              eModule[] -> IM.M[]
          if)
       exit iM[] 
       #);
     pathToErrorModule:< (# path: ^text do inner exit path[] #);
     mainDescNo:< integerValue;
     runtimeDescs:< 
       (# rtDescs: ^Object do inner exit rtDescs[] #);
     
     iModule:< 
       (# eq: BooleanValue
            (# M1: ^iModule
            enter M1[]
            do M[] = M1.M[] -> value
            #);
          name:< (# exit nm[] #);
          origin: 
            (#
            exit (M.getOrigin).theiModule 
            #);
          nm: ^text;
          M: ^TopNode;
       exit M[] 
       #);
     iRootModule:< (# rootM: ^iModule do inner exit rootM[] #);

     
     lineWidth: @integer;
     
     mark: @boolean;  (* True if beginPos and endPos are updated in AST
                       * mark = True when using doPT for doing PT to
                       *             edit buffer
                       * mark = false when using doPT for debugging purposes
                       *)
     withPos: @boolean; (* called from minienv and positions are included
                         * Elim this var from miniCompiler::parser *)
     lx: ^text;
     ind: @ integer
  do 40-> linewidth;
     inner
  #)
