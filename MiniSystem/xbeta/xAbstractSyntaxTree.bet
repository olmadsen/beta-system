ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'Tree';
---lib:attributes---
AbstractSyntaxTree: Tree
  (#      
     Module:< node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do 
               (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
          PP:: (# do 'Module' -> lx.append #);
       enter SO[] -> append
       #);
     StaticObject:< Attribute
       (# OG: ^ObjectGeneration;
          isSimple:: (# do OG.isSimple -> value #);
          PT:: 
            (# 
            do  ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos + 2,break) -> OG.PT 
            #);
          length:: (# do 3 + OG.length -> value #);
          PP:: (# do 'StaticObject'-> lx.append #)
       enter OG[] -> append
       #);
     DynamicObject:< Attribute
       (# pi: ^PatternId;
          PT:: (# do ' ' -> lx.put; '^' -> lx.put; pi.PT #);
          length:: (# do 2 + pi.length -> value #);
          PP:: (# do 'DynamicObject'-> lx.append #)
       enter pi[] -> append
       #);
     ObjectTemplate: Expression
       (# super:< (# PI: ^PatternId do inner exit PI[] #);
          MP: ^MainPart;
          localSearch:
            (# CS: ^ Text; ATd: ^Attribute
            enter CS[]
            do (if MP.att[] <> none then 
                   search:
                     MP.att.scanSons
                     (# AT: ^Attribute
                     do current[] -> AT[];
                       (* 'Try: ' -> puttext; AT.compoundSymb[] -> putline;*)
                        (if (CS[] -> AT.compoundSymb.equalNCS) then
                           (* 'Found in: ' -> puttext;
                            doPT -> putline;*)
                            AT[] -> ATd[];
                            Leave search
                         (*else
                            'No match:'->puttext; AT.compoundSymb[] -> putline*)
                        if)
               #)if)
            exit ATd[]
            #);      
          searchSuperAndSig:<
            (# CS: ^ Text; ATd: ^Attribute
            enter CS[]
            do inner
            exit ATd[]
            #);    
          search:
            (# CS: ^ Text; org: ^ObjectTemplate; ATd: ^Attribute
            enter CS[]
            do(* 'OT:Search:'->puttext; CS[] -> putline;*)
               (if (cs[] -> localSearch -> ATd[]) = none then
                   (if (CS[] -> SearchSuperAndSig -> ATd[]) = none then
                       (if (origin[] -> org[]) <> none then
                           CS[] -> org.search -> ATd[]
               if)if)if)
            exit ATd[]
            #);    
          genClass:< (# N: ^text enter N[] do inner #);
          type: (# V: @integer; isRef: @boolean enter V exit V #);
          doCall:<
            (# N: ^text; LMR: @char; TP: ^type; xType: @integer
            enter(N[],LMR)
            do inner
            #);
          descNo: @integer;
          exitType: (# TP: ^Type exit TP[] #);
          hasDoPart,isRef: @boolean
       #);
     ObjectGeneration:< ObjectTemplate
       (# super:: 
            (# 
            do 'OG:super' -> putline;
               PatternId-> PI[];
               OI.inv.compoundSymb[] -> PI.compoundSymb[];
               OI.inv.exp.ATd[] -> PI.ATd[];
            #);
          OI: ^ObjectInvocation;
          isSimple: BooleanValue
            (# 
            do (if MP.isEmpty then 
                   OI.isSimple -> value
                else
                   MP.isSimple -> value
               if)
            #);
          isEmpty::
            (#
            do (if OI.inv.exp.isEmp then 
                   'OI.inv.isEmpty: ' -> puttext
                else
                   'Not OI.inv.isEmpty: ' -> puttext
               if);
               (if MP.isEmpty then
                   'MP.isEmpty' -> putline
                else
                   'not MP.isEmpty'->putline
               if);
               OI.inv.exp.isEmp and MP.isEmpty -> VALUE
            #);
          PT:: 
            (# 
            do (if OI[] <> none then (pos,break) -> OI.PT if);
               (if MP[] <> none then (pos,break) -> MP.PT if)
            #);
          length:: 
            (# 
            do (if OI[] <> none then OI.length + value -> value if);
               (if MP[] <> none then MP.length + value -> value if)
            #);
          PP:: (# do 'ObjectGeneration'->lx.append #);
          searchSuperAndSig::
            (#
            do (*'OG:SearchSuperAndSig:'->putline;*)
               (if OI.inv.exp.ATd[] <> none then
                   (*OI.inv.doPt -> putline;*)
                   CS[] -> (OI.inv.exp.ATd.desc).localSearch -> ATd[]
               if)
            #)  
       enter(OI[]->append,MP[]->append)
       #);
     ObjectDescriptor:< ObjectTemplate
       (# superPI: ^PatternId;
          PT:: 
            (# 
            do (if superPI[] <> none then (pos,break) -> superPI.PT if);
               (pos,break) -> MP.PT
            #);
          length::
            (# 
            do (if superPI[] <> none then superPI.length -> value if); 
               MP. length + value -> value
            #);
          PP:: (# do 'ObjectDescriptor'->lx.append #);
          searchSuperAndSig::
            (# P: ^pattern
            do (*'OG:SearchSuperAndSig:'->puttext; *)
               (if father[] <> none then
                   (*father.doPT -> puttext;*)
                   (if father## = pattern## then
                       CS[] -> (father[] -> P[]).searchSig -> ATd[]
                    else
                       '\n!!! searchSuperAndSig: father is not pattern'->putline
                   if)
               if)
            #)             
       enter(superPI[]->append,MP[]->append)
       #);
     ObjectInvocation:< node
       (# PT:: (# do (pos,break) -> rec.PT; (pos,break) -> inv.PT #);
          length:: (# do rec.length + inv.length -> value #);
          PP:: (# do 'ObjectInvocation'->lx.append #);          
          rec: ^receiverPath;
          inv: ^Invocation;
          isSimple: BooleanValue
            (#
            do (if inv.exp.ATd[] <> none then
                   inv.exp.ATd.isSimple -> value 
                else
                   'ATd is none: '->puttext; dopt -> putline;
            if)#);
          compoundSymbol: ^Text;
          desc:<
            (# elm:< node; D: ^elm
            do inner
            exit D[]
            #)            
       enter(rec[]->append,inv[]->append,compoundSymbol[])
       #);
     MainPart:< node
       (# att: ^attributes;
          act: ^actions;
          isSimple: @boolean;
          vsize, rsize,originOff: @integer;
          PT:: 
            (# 
            do (if not isEmpty then
                   (pos,length) -> block
                   (#
                   do (pos,break) -> mkBreak0;
                      '{' -> lx.put; ' '-> lx.put;
                          vsize -> lx.putint; ',' -> lx.put; 
                          rsize -> lx.putint; ' ' -> lx.put;
                      (if att[] <> none then (pos+2,break) -> att.PT if);
                      (if act[] <> none then (pos,break) -> act.PT if);
                      (pos,break) -> mkBreak1;
                      '}' -> lx.put
            #)if)#);
          PP:: (# do 'MainPart'->lx.append #);
          length:: 
            (# 
            do (if not isEmpty then
                   4 -> value;
                   (if att[] <> none then att.length + value -> value if);
                   (if act[] <> none then act.length + value -> value if);
               if)
            #);
          isEmpty: @boolean
       enter(att[]->append,act[]->append)
       #);
     Attributes:< node
       (# PT:: 
            (# 
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT; 
                     (if not isLast then 
                         ';' -> lx.put;
                         (pos,break) -> mkBreak1
               if)#)#)
            #);
          PP:: (# do 'Attributes'->lx.append #);          
          length::
            (#
            do scanSons(#do current.length + value + 1 -> value #);
            #);
       #);
     Attribute: node
       (# sig: ^Signature;
          res: ^Lexem;
          compoundSymb: ^text;
          off: @integer;
          isSimple:< BooleanValue(# do inner #);
          PT::< 
            (# 
            do 
               (pos,break) -> sig.PT; 
               (if res.N[] <> none then
                   ' -> ' -> lx.puttext;
                   res.PT
               if);
               ':' -> lx.put;
               off -> lx.putint;
               inner 
            #);
          length::<
            (#
            do sig.length + 1 -> value; 
               (if res.N[] <> none then 
                   4 + res.length + value -> value
               if);
               inner
            #);
          PP::< (# do 'Att:'->lx.append; inner #);
          desc:<
            (# elm:< node; D: ^objectTemplate
            do inner
            exit D[]
            #);
          SearchSig:
            (# CS: ^text; ATd: ^Attribute
            enter CS[]
            do (* '\nAttribute:SearchSig: '->puttext; CS[] -> puttext; 
                *                '\n in: '->puttext; sig.dopT -> putline;
                *                ' of: ' -> puttext; dopt->putline;
                *                ' father: ' -> puttext; dopt->putline;
                *)
               CS[] -> sig.searchSig -> ATd[]
            exit ATd[]
            #);
          load:< (# do inner #);
          store:< (# do inner #);
          activate:< (# do inner #);
       enter(sig[]->append,res[]->append)
       #);
     Signature: node
       (# name: ^text;

          SearchSig:<
            (# CS: ^text; ATd: ^Attribute
            enter CS[]
            do (*'\Signature:SearchSig:'->puttext; CS[] -> puttext;
               ':'->put; name[] -> putline;*)
               inner
            exit ATd[]
            #);
       enter name[]
       #);
     UnarySignature:< Signature
       (# PT:: (# do name[] -> lx.puttext  #);
          length:: (# do name.length -> value #);  
          PP:: (# do 'UnarySignature '->lx.append; name[] -> lx.append; #);          
          (* SearchSig:: no argumenst - no search here *)
       #);
     BinarySignature:< Signature
       (# par: ^attribute;
          PT:: 
            (# 
            do name[] -> lx.puttext; ' ' -> lx.put; 
               par.PT
            #);
          length:: (# do name.length + 1 + par.length -> value #);
          PP:: (# do 'BinarySignature'->lx.append #);                    
          SearchSig::
            (#
            do par.scanSons
               (# AT: ^Attribute
               do 'BS:SS:'->puttext; current.doPT -> putline;
                  current[] -> AT[];
                  (if CS[] -> AT.compoundSymb.equalNCS then 
                      AT[] -> atD[]
                  if)
               #)
            #);
       #);          
     KeywordSignature:< Signature
       (# par: ^Parameters;
          PT:: 
            (# 
            do name[] -> lx.puttext;  
               (pos,break) -> par.PT;
               (*')' -> lx.put  *)
            #);
          length:: (# do name.length + par.length + 1 -> value #);
          PP:: (# do 'KeywordSignature'->lx.append #);                              
          SearchSig::
            (# B: @boolean
            do L:
                 par.scanSons
                 (# AT: ^Attribute
                 do (*current.doPT -> puttext;*)
                    noT B -> B;
                    (if B then 
                        current[] -> AT[];
                        (if CS[] -> AT.compoundSymb.equalNCS then
                            (*' !Match'->putline;*)
                            AT[] -> ATd[];
                            leave L
                        if)
                    if)
                 #);
            #)
       #);
     Parameters:< node
       (# PT:: (# do scansons(#do (pos,break) -> current.PT #)#);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          PP:: (# do 'Parameters'->lx.append #);                    
       #);
     Pattern:< Attribute
       (# OD: ^ObjectDescriptor;
          isSimple:: (# do OD.MP.isSimple -> value #);
          PT::< 
            (# 
            do inner; ' ' -> lx.put;
               (pos+2,break) -> OD.PT;
            #);
          length::< (# do inner; 1 + OD.length + value -> value #);
          PP:: (# do 'Pattern'->lx.append #);
       enter OD[]->append
       #);
     VirtualPattern:< Attribute
       (# OD: ^ObjectDescriptor;
          PT:: (# do '<' -> lx.put #);
          length:: (# do value + 1 -> value #);
          PP:: (# do 'VirtualPattern'->lx.append #);
       enter OD[]
       #);
     PatternId:< node
       (# PT:: 
            (# 
            do (if rec[] = none then 'PI:rec=none'->putline else rec.PT if);
               compoundSymb[] -> lx.puttext 
            #);
          length:: 
            (# 
            do (if rec[] = none then 
                   'rec:none'->putline; father.doPT -> putline 
               if);
               (if compoundSymb[] = none then 
                   'CS:none'->putline;
                   father.doPT -> putline
               if);
               rec.length + compoundSymb.length -> value 
            #);
          PP:: (# do 'PatternId'->lx.append #);
          isEmpty: booleanValue(# do son[] = none -> value #);
          desc:
            (# D: ^ObjectTemplate
            do ATd.desc -> D[]
            exit D[]
            #);
          rec: ^ReceiverPath;   (* rec.compoundSymb *)          
          compoundSymb: ^Text;
          ATd: ^Attribute
       #);
     Actions:< node
       (# PT:: 
            (#
            do (pos,break) -> mkBreak1;
               'do ' -> lx.puttext;
               (pos + 3,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then 
                         ';' -> lx.put;
                     (pos,break) -> mkBreak1    
                     if)
               #)#)
            #);
          length:: 
            (# 
            do 2 -> value; 
               scanSons(#do current.length + 2 + value -> value #)
            #);          
          PP:: (# do 'Actions'->lx.append #);
       #);

     ReceiverPath:< node
       (# PT:: 
            (# 
            do scanSons
               (#
               do (pos,break) -> current.PT;
                  (if not isBinary then '.' -> lx. put if)
            #)#);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          PP:: (# do 'ReceiverPath'->lx.append #);
          isBinary: @boolean
       #);

     Invocation:< node
       (* <ReceiverPath> <Invocation> 
        * <Invocation> ::= <variable>  -- unary
        *               |  +   -- binary
        *               |  foo[ E1 %bar E2 %fisk E3] -- keyword
        *               |  <TextExp>
        *  <Variable> ::= foo
        * Theere are sons: (foo[, E1, %bar, E2, %fisk, E3, ])
        * CompoundSymb = 'foo[%bar%fisk]'
        * 
        *)
       (# PT::
            (#
            do scanSons
               (#
               do (pos,break) -> current.PT
               #)
            #);
          length:: (#do scanSons(#do current.length + value -> value #)#);
          PP:: (# do 'Invocation'->lx.append #);
          exp: ^Expression;
          compoundSymb: ^Text;
          isAssign: @boolean;
          ATdx: ^Attribute;
          desc:
            (# D: ^ObjectTemplate
            do (*(if not isChecked then check if);*)
               (if ATdx[] <> none then
                   (*'Invocation:desc: ' -> puttext; ATd.doPT -> putline;*)
                   ATdx.desc -> D[]
                else
                   (if exp[] = none then 'Exp:inv none'->putline if);
                   (if (exp.ATd[] -> ATdx[]) <> none then
                       exp.ATd.desc -> D[]
                    else
                       '\n!!! Invocation:desc: no ATd: '->puttext;
                       doPT -> putline;
                       (if not isChecked then '  >>> is not checked' -> putline if);
                       (PatternId,MainPart) -> ObjectDescriptor -> D[]
               if)if)
            exit D[]
            #);
       enter(exp[]->append)
       #);  
     Expression: node
       (# ATd: ^attribute; (* the declaration of this expression *)
          compoundSymb: ^Text;
          isAssign: @boolean;
          isEmp: @boolean;
          isEmpty:< BooleanValue
       #);
     Keyword:< Expression
       (# PT:: 
            (#
            do scanSons
               (#
               do (pos,break) -> current.PT
               #)
            #);
          length:: (# do scanSons(#do current.length + value -> value #) #);
          PP:: (# do 'Keyword'->lx.append #);
       #);
     Binary:< Expression
       (# PT:: (#do (pos,break) -> operator.PT; (pos,break) -> argument.PT #);
          length:: (# do operator.length + argument.length -> value #);
          PP:: (# do 'Binary '->lx.append #);
          operator: ^Lexem;
          argument: ^Expression
       enter(compoundSymb[],operator[]->append,argument[] -> append)
       #);
     Unary:< Expression
         (# PT:: (# do V.PT #);
            length:: 
              (# 
              do (if V[] <> none then V.length -> value 
                  else 'Variable:length=none' -> putline 
              if)#);
            PP:: (# do 'Variable: '->lx.append; V.N[] -> lx.append #);
          V: ^lexem
       enter V[]->append
       #);
     Const:< Expression
       (# PT:: (# do V.PT #);
          length:: (# do V.length -> value #);
            PP:: (# do 'const: '-> lx.append; V.N[]->lx.append #);          
          V: ^lexem
       enter V[]
       #);
     TextExp:< Expression
       (# PT :: (# do '\'' -> lx.put; V.PT; '\'' -> lx.put #);
          length:: (# do 2 + V.length -> value #);
          PP:: 
            (# do 'TextExp: \'' -> lx.append; V.N[]->lx.append; '\'' -> lx.put #);
          V: ^Lexem
       enter V[]
       #);
     lexem:< node 
       (# PT:: (# do N[] -> lx.puttext #);
          length:: 
            (# 
            do (if N[] <> none then N.length -> value else 'N none' -> putline if) #);
          PP:: (# do N[] -> lx.append #);
          N: ^text
       enter N[]
       #); 
     FuncBracket:< node
       (* 'foo[' *)
       (# PT:: 
            (# 
            do N[] -> lx.puttext 
            #);
          N: ^text
       enter N[]
       #);
     ControlBracket:< node
       (* '[foo' *)
       (# PT:: (# do N[] -> lx.puttext; ' ' -> lx.put #);
          N: ^text
       enter N[]
       #);
     RightControlBracket:< node
       (* ']foo' *)
       (# PT:: (# do  ' ' -> lx.put; N[] -> lx.puttext #);
          N: ^text
       enter N[]
       #);
     Separator:< node
       (* '%foo' *)
       (# PT:: (# do  ' ' -> lx.put; N[] -> lx.puttext; ' ' -> lx.put  #);
          length:: (# do 2 + N.length -> value #);
          N: ^text
       enter N[]
       #)
     
  do inner 
  #)

