ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'Tree';
---lib:attributes---
AbstractSyntaxTree: Tree
  (#      
     Module:< node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do 
               (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
       enter SO[] -> append
       #);
     StaticObject:< Attribute
       (# OG: ^ObjectGeneration;
          PT:: 
            (# 
            do  ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos + 2,break) -> OG.PT 
            #);
          length:: (# do 3 + OG.length -> value #)
       enter OG[] -> append
       #);
     DynamicObject:< Attribute
       (# pi: ^PatternId;
          PT:: (# do ' ' -> lx.put; '^' -> lx.put; pi.PT #);
          length:: (# do 2 + pi.length -> value #)
       enter pi[] -> append
       #);
     ObjectTemplate: Expression
       (# MP: ^MainPart;
          localSearch:
            (# CS: ^ Text; ATd: ^Attribute
            enter CS[]
            do (if MP.att[] <> none then 
                   search:
                     MP.att.scanSons
                     (# AT: ^Attribute
                     do current[] -> AT[];
                        (if (CS[] -> AT.compoundSymb.equalNCS) then
                           (* 'Found in: ' -> puttext;
                            doPT -> putline;*)
                            AT[] -> ATd[];
                            Leave search
                         (*else
                            'No match:'->puttext; AT.compoundSymb[] -> putline*)
                        if)
               #)if)
            exit ATd[]
            #);      
          searchSuperAndSig:<
            (# CS: ^ Text; ATd: ^Attribute
            enter CS[]
            do inner
            exit ATd[]
            #);    
          search:
            (# CS: ^ Text; org: ^ObjectTemplate; ATd: ^Attribute
            enter CS[]
            do(* 'OT:Search:'->puttext; CS[] -> putline;*)
               (if (cs[] -> localSearch -> ATd[]) = none then
                   (if (CS[] -> SearchSuperAndSig -> ATd[]) = none then
                       (if (origin[] -> org[]) <> none then
                           CS[] -> org.search -> ATd[]
               if)if)if)
            exit ATd[]
            #);    
       #);
     ObjectGeneration:< ObjectTemplate
       (# OI: ^ObjectInvocation;
          PT:: 
            (# 
            do (if OI[] <> none then (pos,break) -> OI.PT if);
               (if MP[] <> none then (pos,break) -> MP.PT if)
            #);
          length:: 
            (# 
            do (if OI[] <> none then OI.length + value -> value if);
               (if MP[] <> none then MP.length + value -> value if)
            #);
          searchSuperAndSig::
            (#
            do (*'OG:SearchSuperAndSig:'->putline*)
            #)  
       enter(OI[]->append,MP[]->append)
       #);
     ObjectDescriptor:< ObjectTemplate
       (# super: ^PatternId;
          PT:: 
            (# 
            do (if super[] <> none then (pos,break) -> super.PT if);
               (pos,break) -> MP.PT
            #);
          length::
            (# 
            do (if super[] <> none then super.length -> value if); 
               MP. length + value -> value
            #);
          searchSuperAndSig::
            (# P: ^pattern
            do (*'OG:SearchSuperAndSig:'->puttext; *)
               (if father[] <> none then
                   (*father.doPT -> puttext;*)
                   (if father## = pattern## then
                       CS[] -> (father[] -> P[]).searchSig -> ATd[]
                    else
                       '\n!!! searchSuperAndSig: father is not pattern'->putline
                   if)
               if)
            #)             
       enter(super[]->append,MP[]->append)
       #);
     ObjectInvocation:< node
       (# PT:: (# do (pos,break) -> rec.PT; (pos,break) -> inv.PT #);
          length:: (# do rec.length + inv.length -> value #);
          rec: ^receiverPath;
          inv: ^Invocation;
          compoundSymbol: ^Text;
          desc:<
            (# elm:< node; D: ^elm
            do inner
            exit D[]
            #)            
       enter(rec[]->append,inv[]->append,compoundSymbol[])
       #);
     MainPart:< node
       (# att: ^attributes;
          act: ^actions;
          vsize, rsize: @integer;
          PT:: 
            (# 
            do (if not isEmpty then
                   (pos,length) -> block
                   (#
                   do (pos,break) -> mkBreak0;
                      '{' -> lx.put; ' '-> lx.put;
                          vsize -> lx.putint; ',' -> lx.put; 
                          rsize -> lx.putint; ' ' -> lx.put;
                      (if att[] <> none then (pos+2,break) -> att.PT if);
                      (if act[] <> none then (pos,break) -> act.PT if);
                      (pos,break) -> mkBreak1;
                      '}' -> lx.put
            #)if)#);
          length:: 
            (# 
            do (if not isEmpty then
                   4 -> value;
                   (if att[] <> none then att.length + value -> value if);
                   (if act[] <> none then act.length + value -> value if);
               if)
            #);
          isEmpty: @boolean
       enter(att[]->append,act[]->append)
       #);
     Attributes:< node
       (# PT:: 
            (# 
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT; 
                     (if not isLast then 
                         ';' -> lx.put;
                         (pos,break) -> mkBreak1
               if)#)#)
            #);
          length::
            (#
            do scanSons(#do current.length + value + 1 -> value #);
            #);
       #);
     Attribute: node
       (# sig: ^Signature;
          res: ^Lexem;
          compoundSymb: ^text;
          off: @integer;
          PT::< 
            (# 
            do 
               (pos,break) -> sig.PT; 
               (if res.N[] <> none then
                   ' -> ' -> lx.puttext;
                   res.PT
               if);
               ':' -> lx.put;
               off -> lx.putint;
               inner 
            #);
          length::<
            (#
            do sig.length + 1 -> value; 
               (if res.N[] <> none then 
                   4 + res.length + value -> value
               if);
               inner
            #);
          desc:<
            (# elm:< node; D: ^elm
            do inner
            exit D[]
            #);
          SearchSig:
            (# CS: ^text; ATd: ^Attribute
            enter CS[]
            do (*'\nAttribute:SearchSig:'->puttext; CS[] -> puttext; ':'->put;
               compoundSymb[] -> putline;*)
               CS[] -> sig.searchSig -> ATd[]
            exit ATd[]
            #)
       #);
     Signature: node
       (# name: ^text;
          SearchSig:<
            (# CS: ^text; ATd: ^Attribute
            enter CS[]
            do (*'\Signature:SearchSig:'->puttext; CS[] -> puttext;
               ':'->put; name[] -> putline;*)
               inner
            exit ATd[]
            #)
       enter name[]
       #);
     UnarySignature:< Signature
       (# PT:: (# do name[] -> lx.puttext  #);
          length:: (# do name.length -> value #);       
       #);
     BinarySignature:< Signature
       (# par: ^attribute;
          PT:: 
            (# 
            do name[] -> lx.puttext; ' ' -> lx.put; 
               par.PT
            #);
          length:: (# do name.length + 1 + par.length -> value #);
          SearchSig::
            (#
            do par.scanSons
               (# AT: ^Attribute
               do 'BS:SS:'->puttext; current.doPT -> putline;
                  (if CS[] -> AT.compoundSymb.equalNCS then 
                      AT[] -> atD[]
                  if)
               #)
            #);
       #);          
     KeywordSignature:< Signature
       (# par: ^Parameters;
          PT:: 
            (# 
            do name[] -> lx.puttext;  
               (pos,break) -> par.PT;
               (*')' -> lx.put  *)
            #);
          length:: (# do name.length + par.length + 1 -> value #);
          SearchSig::
            (# B: @boolean
            do L:
                 par.scanSons
                 (# AT: ^Attribute
                 do (*current.doPT -> puttext;*)
                    noT B -> B;
                    (if B then 
                        current[] -> AT[];
                        (if CS[] -> AT.compoundSymb.equalNCS then
                            (*' !Match'->putline;*)
                            AT[] -> ATd[];
                            leave L
                        if)
                    if)
                 #);
            #)
       #);
     Parameters:< node
       (# PT:: (# do scansons(#do (pos,break) -> current.PT #)#);
          length:: (# do scanSons(#do current.length + value -> value #)#)
       #);
     Pattern:< Attribute
       (# OD: ^ObjectDescriptor;
          PT::< 
            (# 
            do inner; ' ' -> lx.put;
               (pos+2,break) -> OD.PT;
            #);
          length::< (# do inner; 1 + OD.length + value -> value #);
       enter OD[]->append
       #);
     VirtualPattern:< Attribute
       (# OD: ^ObjectDescriptor;
          PT:: (# do '<' -> lx.put #);
          length:: (# do value + 1 -> value #);
       enter OD[]
       #);
     PatternId:< node
       (# PT:: (# do scanSons(# do (pos,break) -> current.PT #)#);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          isEmpty: booleanValue(# do son[] = none -> value #);
       #);
     Actions:< node
       (# PT:: 
            (#
            do (pos,break) -> mkBreak1;
               'do ' -> lx.puttext;
               (pos + 3,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then 
                         ';' -> lx.put;
                     (pos,break) -> mkBreak1    
                     if)
               #)#)
            #);
          length:: 
            (# 
            do 2 -> value; 
               scanSons(#do current.length + 2 + value -> value #)
            #)
       #);
     Expression: node
       (# ATd: ^attribute; (* the declaration of this expression *)
       #);
     Variable:< Expression
         (# PT:: (# do V.PT #);
            length:: 
              (# 
              do (if V[] <> none then V.length -> value 
                  else 'Variable:length=none' -> putline 
              if)#);
          V: ^lexem
       enter V[]
       #);
     Const:< Expression
       (# PT:: (# do V.PT #);
          length:: (# do V.length -> value #);
          V: ^lexem
       enter V[]
       #);
     TextExp:< Expression
       (# PT :: (# do '\'' -> lx.put; V.PT; '\'' -> lx.put #);
          length:: (# do 2 + V.length -> value #);
          V: ^Lexem
       enter V[]
       #);
     ReceiverPath:< node
       (# PT:: 
            (# 
            do scanSons
               (#
               do (pos,break) -> current.PT;
                  (if not isBinary then '.' -> lx. put if)
            #)#);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          isBinary: @boolean
       #);

     Invocation:< node
       (* <ReceiverPath> <Invocation> 
        * <Invocation> ::= <variable>  -- unary
        *               |  +   -- binary
        *               |  foo[ E1 %bar E2 %fisk E3] -- keyword
        *               |  <TextExp>
        *  <Variable> ::= foo
        * Theere are sons: (foo[, E1, %bar, E2, %fisk, E3, ])
        * CompoundSymb = 'foo[%bar%fisk]'
        * 
        *)
       (# PT::
            (#
            do scanSons
               (#
               do (pos,break) -> current.PT
               #)
            #);
          length:: (#do scanSons(#do current.length + value -> value #)#);
          compoundSymb: ^Text;
          ATd: ^Attribute;
          desc:
            (# D: ^ObjectTemplate
            do (*(if not isChecked then check if);*)
               (if ATd[] <> none then
                   (*'Invocation:desc: ' -> puttext; ATd.doPT -> putline;*)
                   ATd.desc -> D[]
                else
                   '\n!!! Invocation:desc: no ATd: '->puttext;
                   doPT -> putline;
                   (if not isChecked then '  >>> is not checked' -> putline if);
                   (PatternId,MainPart) -> ObjectDescriptor -> D[]
               if)
            exit D[]
            #)
       #);    
     lexem:< node 
       (# PT:: (# do N[] -> lx.puttext #);
          length:: 
            (# 
            do (if N[] <> none then N.length -> value else 'N none' -> putline if) #);
          N: ^text
       enter N[]
       #); 
     FuncBracket:< node
       (* 'foo[' *)
       (# PT:: 
            (# 
            do N[] -> lx.puttext 
            #);
          N: ^text
       enter N[]
       #);
     ControlBracket:< node
       (* '[foo' *)
       (# PT:: (# do N[] -> lx.puttext; ' ' -> lx.put #);
          N: ^text
       enter N[]
       #);
     RightControlBracket:< node
       (* ']foo' *)
       (# PT:: (# do  ' ' -> lx.put; N[] -> lx.puttext #);
          N: ^text
       enter N[]
       #);
     Separator:< node
       (* '%foo' *)
       (# PT:: (# do  ' ' -> lx.put; N[] -> lx.puttext; ' ' -> lx.put  #);
          length:: (# do 2 + N.length -> value #);
          N: ^text
       enter N[]
       #)
     
  do inner 
  #)

