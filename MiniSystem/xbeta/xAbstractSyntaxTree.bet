ORIGIN '~beta/basiclib/betaenv';
---lib:attributes---
AbstractSyntaxTree:
  (#
     node:
       (# doPT:
            (#
            do &text[] -> lx[];
               PT 
            exit lx[]
            #);
          PT:<
            (# 
            do inner
            exit lx[]
            #);
          son,next,last: ^node;
          append:
            (# N: ^node
            enter N[]
            do (if N[] = none then 
                   (dumpStack,'append') -> stop
               if);
               (if son[] = none then '*'->put;
                   N[] -> son[]
                else
                   (if son.next[] = none then '+'->put;
                       N[] -> son.next[]
                    else '?'->put;
                       N[] -> last.next[]
               if)if);
               N[] -> last[]
            #);
          scanSons:
          (# current: ^node
          do son[] -> current[];
             Loop:
               (if current[] <> none then
                   inner;
                   current.next[] -> current[];
                   restart loop
               if)
          #)                
       do inner
       exit this(node)[]
       #);

     lexem: node 
       (# PT:: (# do N[] -> lx.puttext #);
          N: ^text
       enter N[]
       #); 
     Module: node
       (# SO: ^StaticObject;
          PT:: (# do SO.PT #)
       enter SO[]
       #);

     StaticObject: node
       (# name: ^lexem;
          OG: ^ObjectGeneration;
          PT:: (# do name.PT; ':' -> lx.put; 
                  ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; OG.PT #)
       enter(name[],OG[])
       #);
     ObjectGeneration: node
       (# 
          OI: ^ObjectInvocation;
          MP: ^MainPart;
          PT:: 
            (# 
            do (if OI[] <> none then OI.PT if);
               (if MP[] <> none then MP.PT if)
            #);
       enter(OI[],MP[])
       #);
     ObjectInvocation: node
       (# 
       #);
     MainPart: node
       (# att: ^attributes;
          act: ^actions;
          PT:: 
            (# 
            do '{' -> lx.put; 
               (if att[] <> none then att.PT if);
               (if act[] <> none then act.PT if);
               '}' -> lx.put
            #)
       enter(att[],act[])
       #);
     Attributes: node
       (# 
          PT:: 
            (# 
            do scanSons(#do current.PT; ';' -> lx.put #)
            #)
       #);
     Attribute: node
       (# sig: ^Signature;
          PT::< (# do sig.PT; ':' -> lx.put; ' ' -> lx.put; inner #)
       #);
     Signature: node
       (# 
       #);
     UnarySignature: Signature
       (# name: ^text;          
          PT:: (# do name[] -> lx.puttext  #);
       enter name[]
       #);
     KeywordSignature: Signature
       (# name: ^text;  
          par: ^Parameters;
          PT:: 
            (# 
            do name[] -> lx.puttext;  
               par.PT;
               ')' -> lx.put  #);
       enter name[]
       #);
     Parameters: node
       (# PT: (# do scansons(#do current.PT #)#);
       #);
     Parameter: node
       (# N,T: ^text;
          PT:: (# do N[] -> lx.puttext; ':' -> lx.put; ' ' -> lx.put; T[] -> lx.puttext #)
       #);
     Pattern: Attribute
       (# OD: ^ObjectDescriptor;
          PT:: (# do OD.PT #)
       enter OD[]
       #);
     ObjectDescriptor: node
       (# super: ^PatternId;
          MP: ^mainPart;
          PT:: 
            (# 
            do (if super[] <> none then super.PT if);
               MP.PT
            #)
       enter(super[],MP[])
       #);
     PatternId: node
       (#
       #);
     Actions: node
       (#
       #);
     
     lx: ^text
  do inner 
  #)

