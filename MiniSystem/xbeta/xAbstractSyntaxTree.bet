ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'Tree';
---lib:attributes---
AbstractSyntaxTree: Tree
  (#      
     Module:< node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do 
               (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
       enter SO[]
       #);

     StaticObject:< Attribute
       (# OG: ^ObjectGeneration;
          PT:: 
            (# 
            do  ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos + 2,break) -> OG.PT 
            #);
          length:: (# do 3 + OG.length -> value #)
       enter OG[]
       #);
     DynamicObject:< Attribute
       (# pi: ^PatternId;
          PT:: (# do ' ' -> lx.put; '^' -> lx.put; pi.PT #);
          length:: (# do 2 + pi.length -> value #)
       enter pi[]
       #);
     ObjectGeneration:< Expression
       (# 
          OI: ^ObjectInvocation;
          MP: ^MainPart;

          PT:: 
            (# 
            do (if OI[] <> none then (pos,break) -> OI.PT if);
               (if MP[] <> none then (pos,break) -> MP.PT if)
            #);
          length:: 
            (# 
            do (if OI[] <> none then OI.length + value -> value if);
               (if MP[] <> none then MP.length + value -> value if)
            #);
       enter(OI[],MP[])
       #);
     ObjectInvocation:< node
       (# PT:: (# do (pos,break) -> rec.PT; (pos,break) -> inv.PT #);
          length:: (# do rec.length + inv.length -> value #);
          rec: ^receiver;
          inv: ^Invocation
       enter(rec[],inv[])
       #);
     MainPart:< node
       (# att: ^attributes;
          act: ^actions;
          vsize, rsize: @integer;
          PT:: 
            (# 
            do (if not isEmpty then
                   (pos,length) -> block
                   (#
                   do (pos,break) -> mkBreak0;
                      '{' -> lx.put; ' '-> lx.put;
                          vsize -> lx.putint; ',' -> lx.put; 
                          rsize -> lx.putint; ' ' -> lx.put;
                      (if att[] <> none then (pos+2,break) -> att.PT if);
                      (if act[] <> none then (pos,break) -> act.PT if);
                      (pos,break) -> mkBreak1;
                      '}' -> lx.put
            #)if)#);
          length:: 
            (# 
            do (if not isEmpty then
                   4 -> value;
                   (if att[] <> none then att.length + value -> value if);
                   (if act[] <> none then act.length + value -> value if);
               if)
            #);
          isEmpty: @boolean
       enter(att[],act[])
       #);
     Attributes:< node
       (# PT:: 
            (# 
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT; 
                     (if not isLast then 
                         ';' -> lx.put;
                         (pos,break) -> mkBreak1
               if)#)#)
            #);
          length::
            (#
            do scanSons(#do current.length + value + 1 -> value #);
            #);
       #);
     Attribute: node
       (# sig: ^Signature;
          res: ^Lexem;
          off: @integer;
          PT::< 
            (# 
            do 
               (pos,break) -> sig.PT; 
               (if res.N[] <> none then
                   ' -> ' -> lx.puttext;
                   res.PT
               if);
               ':' -> lx.put;
               off -> lx.putint;
               inner 
            #);
          length::<
            (#
            do sig.length + 1 -> value; 
               (if res.N[] <> none then 
                   4 + res.length + value -> value
               if);
               inner
            #)
       #);
     Signature: node
       (# name: ^text;
       enter name[]
       #);
     UnarySignature:< Signature
       (# PT:: (# do name[] -> lx.puttext  #);
          length:: (# do name.length -> value #);       
       #);
     BinarySignature:< Signature
       (# par: ^attribute;
          PT:: 
            (# 
            do name[] -> lx.puttext; ' ' -> lx.put; 
               par.PT
            #);
          length:: (# do name.length + 1 + par.length -> value #);
       #);          
     KeywordSignature:< Signature
       (# par: ^Parameters;
          PT:: 
            (# 
            do name[] -> lx.puttext;  
               (pos,break) -> par.PT;
               (*')' -> lx.put  *)
            #);
          length:: (# do name.length + par.length + 1 -> value #)
       #);
     Parameters:< node
       (# PT:: (# do scansons(#do (pos,break) -> current.PT #)#);
          length:: (# do scanSons(#do current.length + value -> value #)#)
       #);
     Pattern:< Attribute
       (# OD: ^ObjectDescriptor;
          PT::< 
            (# 
            do inner; ' ' -> lx.put;
               (pos+2,break) -> OD.PT;
            #);
          length::< (# do inner; 1 + OD.length + value -> value #);
       enter OD[]
       #);
     VirtualPattern:< Attribute
       (# OD: ^ObjectDescriptor;
          PT:: (# do '<' -> lx.put #);
          length:: (# do value + 1 -> value #);
       enter OD[]
       #);
     ObjectDescriptor:< node
       (# super: ^PatternId;
          MP: ^mainPart;
          PT:: 
            (# 
            do (if super[] <> none then (pos,break) -> super.PT if);
               (pos,break) -> MP.PT
            #);
          length::
            (# 
            do (if super[] <> none then super.length -> value if); 
               MP. length + value -> value
            #);

       enter(super[],MP[])
       #);
     PatternId:< node
       (# PT:: (# do scanSons(# do (pos,break) -> current.PT #)#);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          isEmpty: booleanValue(# do son[] = none -> value #);
       #);
     Actions:< node
       (# PT:: 
            (#
            do (pos,break) -> mkBreak1;
               'do ' -> lx.puttext;
               (pos + 3,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then 
                         ';' -> lx.put;
                     (pos,break) -> mkBreak1    
                     if)
               #)#)
            #);
          length:: 
            (# 
            do 2 -> value; 
               scanSons(#do current.length + 2 + value -> value #)
            #)
       #);
     Expression: node
       (# 
       #);
     Variable:< Expression
         (# PT:: (# do V.PT #);
            length:: 
              (# do (if V[] <> none then V.length -> value 
               else 'Variable:length=none' -> putline if)#);
          V: ^lexem
       enter V[]
       #);
     Const:< Expression
       (# PT:: (# do V.PT #);
          length:: (# do V.length -> value #);
          V: ^lexem
       enter V[]
       #);
     TextExp:< Expression
       (# PT :: (# do '\'' -> lx.put; V.PT; '\'' -> lx.put #);
          length:: (# do 2 + V.length -> value #);
          V: ^Lexem
       enter V[]
       #);
     Receiver:< node
       (# PT:: 
            (# 
            do scanSons
               (#
               do (pos,break) -> current.PT;
                  (if not isBinary then '.' -> lx. put if)
            #)#);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          isBinary: @boolean
       #);
     TextReceiver:< node
       (# PT:: (# do '\'' -> lx.put; L.PT; '\'' -> lx.put #);
          length:: (# do 2 + L.length -> value #);
          L: ^Lexem
       enter L[]
       #);
     Invocation:< node
       (# PT::
            (#
            do scanSons
               (#
               do (pos,break) -> current.PT
               #)
            #);
          length:: (#do scanSons(#do current.length + value -> value #)#)
       #);    
     lexem:< node 
       (# PT:: (# do N[] -> lx.puttext #);
          length:: 
            (# 
            do (if N[] <> none then N.length -> value else 'N none' -> putline if) #);
          N: ^text
       enter N[]
       #); 
     FuncBracket:< node
       (# PT:: 
            (# 
            do N[] -> lx.puttext 
            #);
          N: ^text
       enter N[]
       #);
     ControlBracket:< node
       (# PT:: (# do N[] -> lx.puttext; ' ' -> lx.put #);
          N: ^text
       enter N[]
       #);
      RightControlBracket:< node
       (# PT:: (# do  ' ' -> lx.put; N[] -> lx.puttext #);
          N: ^text
       enter N[]
       #);
     Separator:< node
       (# PT:: (# do  ' ' -> lx.put; N[] -> lx.puttext; ' ' -> lx.put  #);
          length:: (# do 2 + N.length -> value #);
          N: ^text
       enter N[]
       #)
     
  do inner 
  #)

