ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xparser';
(*INCLUDE 'Primitives';*)
---lib:attributes---
checker: Parser
  (# Module::<
       (# setUpOrigin:: (# do SO.setUpOrigin #);
          check::
            (#
            do SO.check;
            #);
       #);
     StaticObject::<
       (# setUpOrigin::
            (#
            do (if origin[] = none then
                   'Setup: origin none: ' -> puttext;
                   sig.doPT -> putline
               if);
               origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# 
            do OG.check; 
              (* newline;
               sig.doPT -> puttext; ':'->put;*)
               (if origin[] <> none then
                   (* origin is none if StaticObject is a Module *)
                   origin[] -> org[];
                   org.vsize + 1 -> org.vsize -> off;
               if);
            #);
          desc::
            (# elm:: MainPart
            do OG.MP[] -> D[]
            #);
          org: ^MainPart
       #);
     DynamicObject::<
       (# setUpOrigin::
            (#
            do (if origin[] = none then
                   'Setup: origin none: ' -> puttext;
                   sig.doPT -> putline
               if);
               origin[] -> sig.setUpOrigin; 
               origin[] -> PI.setUpOrigin
            #);
          check::
            (#
            do PI.check;
              (* newline;
               sig.doPT -> putline;*)
               (if origin[] <> none then 
                   (*origin.doPT -> putline;*)
                   (* origin is none if StaticObject is a Module *)
                   origin[] -> org[];
                   org.rsize + 1 -> org.rsize -> off;
                else
                   'Origin is none' -> putline
               if);
            #);
          org: ^MainPart
       #);
     ObjectGeneration::<
       (# setUpOrigin::
            (#
            do origin[] -> OI.setUpOrigin;
               origin[] -> MP.setUpOrigin;
            #);
          check::
            (#
            do OI.check; MP.check
            #)
       #);
     ObjectInvocation::<
       (# setUpOrigin::
            (#
            do origin[] -> rec.setUpOrigin;
               origin[] -> inv.setUpOrigin;
            #);
          check::
            (#
            do rec.check; inv.check
            #)
       #);
     ObjectDescriptor::<
       (# setUpOrigin:: 
            (# 
            do (if super[] <> none then origin[] -> super.setUpOrigin if);
               origin[] -> MP.setUpOrigin
            #);
          check:: 
            (# 
            do (if super[] <> none then super.check if);
               MP.check
            #);
       #);
     MainPart::<
       (# setUpOrigin::
            (#
            do (if att[] <> none then this(MainPart)[] -> att.setUpOrigin if);
               (if act[] <> none then this(MainPart)[] -> act.setUpOrigin if)
            #);
          check::
            (#
            do (if att[] <> none then att.check if);
               (if act[] <> none then act.check if)
            #);
          localSearch:
             (# CS: ^ Text; ATd: ^Attribute
             enter CS[]
             do search:
                  att.scanSons
                  (# AT: ^Attribute
                  do current[] -> AT[];
                     (if (CS[] -> AT.compoundSymb.equalNCS) then
                         'Found in: ' -> puttext;
                         doPT -> putline;
                         AT[] -> ATd[];
                         Leave search
                      else
                         'No match:'->puttext; AT.compoundSymb[] -> putline
                     if)
                  #)
             exit ATd[]
             #);          
          search:
            (# CS: ^ Text; found: @boolean; org: ^MainPart; ATd: ^Attribute
            enter CS[]
            do 'MP:Search:'->puttext; CS[] -> putline;
               (if (cs[] -> localSearch -> ATd[]) = none then
                   (if (origin[] -> org[]) <> none then
                       
                       CS[] -> org.search -> ATd[]
               if)if)
            exit ATd[]
            #);          
       #);
     Attributes::<
       (# setUpOrigin::
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# do scanSons(# do current.check #)#);          
       #);
     UnarySignature ::< (# #);
     BinarySignature::<
       (# setUpOrigin:: (# do origin[] -> par.setUpOrigin #);
          check:: (# do par.check #);
       #);
     KeyWordSignature::<
       (# setUpOrigin:: (# do origin[] -> par.setUpOrigin #);
          check:: (# do par.check #);
       #);  
     Pattern::< 
       (# setUpOrigin:: 
            (# 
            do origin[] -> sig.setUpOrigin;
               origin[] -> res.setUpOrigin;
               origin[] -> OD.setUpOrigin #);
          check:: 
            (# 
            do 'Pattern: ' -> puttext; compoundSymb[] -> putline;
               sig.doPT -> puttext; ' & ' -> puttext; res.doPt -> putline;
               sig.check;
               res.check;
               OD.check 
            #);
       #);
     VirtualPattern::< 
       (# setUpOrigin:: (# do origin[] -> OD.setUpOrigin #);
          check:: (# do OD.check #);
       #);

     PatternId::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: (# do scanSons(#do current.check #)#)
       #);
     Actions::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: (# do scanSons(#do current.check #)#)
       #);
     Variable::<
       (# setUpOrigin:: (# do origin[] -> V.setUpOrigin #);
          check:: (# do V.check #);          
       #);
     Const::<
       (# setUpOrigin:: (# do origin[] -> V.setUpOrigin #); 
          check:: 
            (# org: ^MainPart
            do origin[] -> org[]; V.n[] -> org.search
            #);          
       #);
     TextExp::<
       (# setUpOrigin:: (# do origin[] -> V.setUpOrigin #); 
          check:: (# do V.check #);          
       #);
     ReceiverPath::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# 
            do scanSons
               (# exp: ^Expression
               do 'Receiver: '->puttext; current.doPT -> puttext; ' ' -> put;
                  (if current ##
                   // lexem## then
                      ' Lexem ' -> puttext
                   // variable## then
                      ' Variable:Lexem ' -> puttext
                   // TextExp## then
                      ' Text:Lexem ' -> puttext  
                   else
                      ' not Lexem '->puttext
                  if);
                  current.check;
                  current[] -> exp[]
               #)
            #)
       #);
 
     Invocation::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# org: ^MainPart; ATd: ^Attribute
            do 'Invocation: '->puttext; compoundSymb[] -> putline;
               (if (origin[] -> org[]) <> none then
                   (if (CompoundSymb[] -> org.search -> ATd[]) = none then
                       '\n*** Did not find: ' -> puttext;
                       CompoundSymb[] -> putline
                    else
                       '\n*** Found : ' -> puttext;
                       ATd.doPT -> putline
                   if)
               if);
               scanSons
               (#
               do 
                  current.check 
            #)#)
       #);
     Lexem::< 
       (# check:: (# do  #);     
       #);
     FuncBracket::<
       (#check:: (# do #);     
       #);
     ControlBracket::<
       (# check:: (# do #);     
       #);
     RightControlBracket::<
       (# check:: (# do  #);     
       #); 
     Separator::<
       (# check:: (# do  #);     
       #); 
  do 'CHECKING'-> putline;
     m.setUpOrigin;
     m.check;
  #)
