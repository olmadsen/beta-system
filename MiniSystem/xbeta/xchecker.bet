ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'xparser';
(*INCLUDE 'Primitives';*)
---lib:attributes---
checker: Parser
  (# Module::<
       (# setUpOrigin:: (# do SO.setUpOrigin #);
          check::
            (#
            do SO.check;
            #);
          desc:
            (# D: ^ObjectTemplate
            do SO.desc -> D[]
            exit D[]
            #);
       #);
     StaticObject::<
       (# setUpOrigin::
            (#
            do (if origin[] = none then
                   'Setup: origin none: ' -> puttext;
                   sig.doPT -> putline
               if);
               origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::ObjectTemplate
            do (* 'Check: ' -> puttext; doPT -> putline;*)
               org[] -> sig.check;
               org[] -> res.check;
               org[] -> OG.check; 
               (if origin[] <> none then
                   (* origin is none if StaticObject is a Module *)
                   origin[] -> org[];
                   org.MP.vsize + 1 -> org.MP.vsize -> off;
               if);
            #);
          desc::
            (# elm:: ObjectTemplate
            do (*'SI:desc:'->puttext; doPT -> putline;*)
               (if OG.mp.isEmpty then
                   OG.OI.desc -> D[]
                else
                   OG[] -> D[]
               if);
            #);
       #);
     DynamicObject::<
       (# setUpOrigin::
            (#
            do (if origin[] = none then
                   'Setup: origin none: ' -> puttext;
                   sig.doPT -> putline
               if);
               origin[] -> sig.setUpOrigin; 
               origin[] -> PI.setUpOrigin
            #);
          check::
            (# elm::objectTemplate
            do org[] -> PI.check;
              (* newline;
               sig.doPT -> putline;*)
               (if origin[] <> none then 
                   (*origin.doPT -> putline;*)
                   (* origin is none if StaticObject is a Module *)
                   origin[] -> org[];
                   org.MP.rsize + 1 -> org.MP.rsize -> off;
                else
                   'Origin is none' -> putline
               if);
            #);
          desc::
            (# elm:: ObjectTemplate
            do (*'DO:desc:'->puttext; doPT -> putline;*)
               (if pi.ATd[] <> none then
                   PI.desc -> D[]
               if);
            #);
       #);
     ObjectGeneration::<
       (# setUpOrigin::
            (#
            do (if mp.isEmpty then
                   origin[] -> OI.setUpOrigin;
                   origin[] -> MP.setUpOrigin;
                else                   
                   this(ObjectTemplate)[] -> OI.setUpOrigin;
                   this(ObjectTemplate)[] -> MP.setUpOrigin;
               if);                   
            #);
          check::
            (#
            do this(ObjectTemplate)[] -> newDesc -> descNo;
              (* 'OG:check:'->puttext; dopt->putline;*)
               org[] -> OI.check; 
               origin[] -> MP.check
            #);
       #);
     ObjectDescriptor::<
       (# setUpOrigin:: 
            (# 
            do (if superPI[] <> none then origin[] -> superPI.setUpOrigin if);
               this(ObjectTemplate)[] -> MP.setUpOrigin
            #);
          check:: 
            (# 
            do this(ObjectTemplate)[] -> newDesc -> descNo;
               (if superPI[] <> none then org[] -> superPI.check if);
               origin[] -> MP.check
            #);       
       #);
     ObjectInvocation::<
       (# setUpOrigin::
            (#
            do origin[] -> rec.setUpOrigin;
               origin[] -> inv.setUpOrigin;
            #);
          check::
            (#
            do (*'ObjectInv: '->puttext; doPT -> putline;
               'org: '->puttext; 
               (if org[] <> none then org.doPT -> putline if);*)
               org[] -> rec.check -> inv.check
            #);
          desc::
            (# elm:: ObjectTemplate
            do (*'ObjectInv: '->puttext; doPT -> putline;
               '---+ '->puttext; inv.doPT -> putline;*)
               inv.desc -> D[];
               (*(if D[] <> none then D.doPT -> putline if)*)
            #)
       #);
     MainPart::<
       (# setUpOrigin::
            (#
            do (if att[] <> none then origin[] -> att.setUpOrigin if);
               (if act[] <> none then origin[] -> act.setUpOrigin if)
            #);
          check::
            (#
            do origin[] -> org[];
               rsize + 1 -> rsize -> originOff;
               (if att[] <> none then org[] -> att.check if);
               (if act[] <> none then org[] -> act.check if)
            #);
      
       #);
     Attributes::<
       (# setUpOrigin::
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# do scanSons(# do org[] -> current.check #)#);          
       #);
     UnarySignature ::< 
       (# check::
            (# elm:: objectTemplate
            #);
       #);
     BinarySignature::<
       (# setUpOrigin:: (# do origin[] -> par.setUpOrigin #);
          check:: (# do org[] -> par.check #);
       #);
     KeyWordSignature::<
       (# setUpOrigin:: (# do origin[] -> par.setUpOrigin #);
          check:: (# do org[] -> par.check #);
       #);  
     Parameters::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (#
            do
               scanSons
               (#do (*'Par:check:'->puttext; current.doPt -> putline;*)
                  org[] -> current.check
               #);
            #)
       #);
     Pattern::< 
       (# setUpOrigin:: 
            (# 
            do origin[] -> sig.setUpOrigin;
               origin[] -> res.setUpOrigin;
               origin[] -> OD.setUpOrigin 
            #);
          check:: 
            (# 
            do (*'Pattern: ' -> puttext; compoundSymb[] -> putline;*)
               (* sig.doPT -> puttext; ' & ' -> puttext; res.doPt -> putline;*)
               org[] -> sig.check;
               org[] -> res.check;
               org[] -> OD.check 
            #);
          desc::
            (# elm:: ObjectTemplate
            do OD[] -> D[]
            #)
       #);
     VirtualPattern::< 
       (# setUpOrigin:: (# do origin[] -> OD.setUpOrigin #);
          check:: (# do org[] -> OD.check #);
       #);

     PatternId::<
       (* used in
        *  myPtn: <PatternId> { ... }
        *  R: ^<PatternId>
        *  <PatternId> ::= super | person[] | record[%with%key]
        *)
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# elm:: ObjectTemplate
            do (if compoundSymb.length > 0 then
                   org[] -> rec.check -> org[];
                   (* 'PI: '->puttext; compoundsymb[] -> putline;*)
                   (*origin[] -> org[];*)
                   (if (compoundSymb[] -> org.search -> ATd[]) <> none then
                       '*** Found patternId: ' -> puttext; compoundSymb[] -> putline
                    else
                       '*** Did not find  patternId: ' -> puttext; compoundSymb[] -> putline;
                       father.doPT -> putline
               if)if)
            #)
       #);
     Actions::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: (# do scanSons(#do org[] -> current.check #)#)
       #);
     Variable::<
       (# setUpOrigin:: 
            (# 
            do (*'Variable:SetUpOrigin: ' -> puttext; V.N[] -> puttext; 
                * ' ' -> put; origin.dopt -> putline;
                *)
               origin[] -> V.setUpOrigin #);
          check:: 
            (# elm:: ObjectTemplate
            do (*'Search: ' -> puttext; V.n[] -> putline;
                * 'Variable: ' -> puttext; org.dopt ->putline;
                *)
               (if org[] <> none then (* ad hoc *)
                   (if (V.N[] -> org.search -> ATd[]) <> none then
                       '*** Found var: '->puttext; V.N[] -> putline
                    else
                       '*** Did NOT find var:'->puttext; V.N[] -> putline
                   if)
               if)
            #);          
       #);
     Const::<
       (# setUpOrigin:: (# do origin[] -> V.setUpOrigin #); 
          check:: 
            (# 
            #);          
       #);
     TextExp::<
       (# setUpOrigin:: (# do origin[] -> V.setUpOrigin #); 
          check:: (# do org[] -> V.check #);          
       #);
     ReceiverPath::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# exp: ^Expression
            do scanSons
               (# 
               do (*'Receiverpath: '->puttext; current.doPT -> puttext; ' ' -> put;*)
                 (*(if current ##
                   // lexem## then
                      'Lexem ' -> puttext
                   // variable## then
                      'Variable:Lexem ' -> puttext
                   // TextExp## then
                      'Text:Lexem ' -> puttext  
                   else
                      'not Lexem '->puttext
                  if);*)
                  (* for R.S.foo, we need
                   * exp[] -> current.check -> exp[]
                   * perhaps always org as enter arg for check
                   *)
                  (*'org: '->puttext; org.doPT -> putline;*)
                  org[] -> current.check;
                  current[] -> exp[];
                  (if (exp.ATd[] <> none) and (exp.ATd.desc <> none) then 
                      (*'desc:'->puttext; (exp.ATd.desc).doPT -> putline;*)
                      exp.ATd.desc -> org[]
                  if);
               #)
            #)
       #);
 
     Invocation::<
       (* See Invocation in xAbstractSyntaxTree *)
       (# setUpOrigin:: 
            (# 
            do (*'Invocation:setUpOrigin: '-> puttext; 
                * origin.dopt -> putline;
                * dopt ->putline;
                *)
               scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# elm:: ObjectTemplate;
               E: ^Expression; (*org: ^ObjectTemplate;*) (*ATd: ^Attribute*)
            do (*'Invocation: '->puttext; compoundSymb[] -> puttext;
                * scansons(#do ' '->put; current.doPT -> puttext  #);
                * newline;
                *)
               L:
                 (# 
                    (* we should not search a Text literal 
                     * - but not very elegant;
                     * perhaps move check to sons: keyword, binary, etc
                     *)
                 do (if false then
                        scanSons(#do (if current## = textExp## then leave L if)#);
                        (if compoundSymb[] <> none then
                            (if (CompoundSymb[] -> org.search -> ATd[]) = none then
                                (if ':=' -> compoundSymb.equal then 
                                    true -> isAssign;
                                    '*** Found := (assign)' -> putline;
                                 else
                                    '*** Did not find invocation: ' -> puttext;
                                    CompoundSymb[] -> putline
                                if)
                             else
                                '*** Found invocation: ' -> puttext;
                                CompoundSymb[] -> putline
                            if)
                    if)if);
                    scanSons
                    (# B: @boolean
                    do (if true then
                           org[] -> current.check 
                       if);
                       not B -> B;
                 #)#)
            #)
       #);
     Keyword::<
       (# setUpOrigin:: (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# elm:: ObjectTemplate
            do (if (compoundSymb[] -> org.search -> ATd[]) <> none then
                   '*** Found Keyword: '->puttext; 
                   compoundSymb[] -> putline
                else
                   '*** Did NOT find Keyword:'->puttext; 
                   compoundSYmb[] -> putline
               if);
               scanSons(#do org[] -> current.check #)
            #);   
       #);
     Binary::<
       (# SetUpOrigin:: 
            (# 
            do (*'Binary:setUpOrigin: '-> puttext; 
                * origin.dopt -> putline;
                * dopt ->putline;
                *)
               origin[] -> argument.setUpOrigin #);
          check:: 
            (# elm:: ObjectTemplate
            do (* 'Binary: '-> puttext; compoundSymb[] -> putline;*)
               (if org[] <> none then (* ad hoc *)
                   (if (compoundSymb[] -> org.search -> ATd[]) <> none then
                       '*** Found binary: '->puttext; 
                       compoundSYmb[] -> putline
                    else
                       (if ':=' -> compoundSymb.equal then 
                           true -> isAssign;
                           '*** Found := (assign)' -> putline;
                        else
                           '*** Did NOT find binary:'->puttext; 
                           compoundSYmb[] -> putline
                       if)
                   if)
                 else                    
                    'binary:check:org none ' -> putline
               if);
               (* 'Arg:'->puttext; argument.doPT -> putline;
                * '  in: ' -> puttext; origin.doPT -> putline;
                *)
               origin[] -> argument.check 
            #)
       #);
     Lexem::< 
       (# check:: (# do  #);     
       #);
     FuncBracket::<
       (# check:: (# do #);     
       #);
     ControlBracket::<
       (# check:: (# do #);     
       #);
     RightControlBracket::<
       (# check:: (# do  #);     
       #); 
     Separator::<
       (# check:: (# do  #);     
       #); 
     newDesc: @
       (# OD: [16] ^ObjectTemplate; 
          noOfDescs: @integer;
          anOD: ^ObjectTemplate;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectTemplate
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that anOD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #);
  do 'CHECKING'-> putline;
     m.setUpOrigin;
     m.check;
     inner
  #)
