ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/basiclib/file';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE '../VM/betaVM';
INCLUDE '~beta/sysutils/objinterface';

---lib:attributes---
traceEdit: (# exit false #);
ObjectContent: 
  (# compile: ^Tree;
     VM: ^ | systemenv.betaVM;
     LG: ^log;
     onlyModulesAndPatterns: @boolean;
       
     init:< (# enter(compile[],VM[],LG[]) #);
     
     handle:
       (* Representation of an Entry of the form
        *    Entry = (theName,sort = (kind,Entity))
        *    theName is declared below at the enter-part
        * An Entry may be one of
        *    ObjectModule, PtnModule, ObjectDesc, Attributes, ActionPart
        * For an objectDesc, a declaration is an entry:
        *    Dcl = (nameDcl, item =(kind,objectSpec))
        * An Entity in turn contains a list of Entries
        * The Entries of Entry are represented in 
        *    L, DCLs, handles
        * 
        *    |   ...   | dclNames[1]              |
        *    |   ...   | ...                      |
        *    | theName | dclNames[i]              |
        *    |  ...    | ...                      | 
        *    |  ...    | dclNames[dclNames.range] |
        *    --------------------------------------
        *    |  Entity                            |
        *    |                                    |
        *    --------------------------------------
        * When dclNames[i] is selected, then a Handle is made for dclNames[i]
        * and and DCLs[i] becomes the Entry in the Handle
        * Actually we use DCLs[i].sort to construct the handle
        * 
        * Representation of 
        * - an objectDesc of a decl represented in 
        * theEntry 
        *    as a module:       theModule -> OD
        *    as an item:           
        *        as a staticItem:  SI, -> OD
        *                              -> non singular?
        *        as a dynamicItem: ?,
        *        as a pattern:     PTN, -> OD
        *        as a directory    DIR -> theModule -> OD
        *    as an actionPart:     ACP
        * shown in
        * - a browser 
        *   Attributes X1, X1, ... Xn, ACP (action part)
        *   represented in 
        *    dclNames -- the names of decl's in OD
        *    DCLs,    -- the decls in OD
        * or
        * - textEditor
        *   represented as theText
        *)
       (# theEntry: ^Tree.topNode;
          dclNames: [0] ^text;
          DCLs: [0] ^Tree.TopNode(*decl*);
          handles: [0] ^handle;
          theText: ^text;
          isComp: @boolean;
          isCompiled: BooleanValue
            (#
            do (if isModule then
                   isComp -> value
                else
                   enclosingHandle.isCompiled -> value
               if)
            #);
          markAsCompiled:
            (#
            do (if isModule then
                   true -> isComp
                else
                   enclosingHandle.markAsCompiled
               if)
            #);
           markAsNotCompiled:
            (#
            do (if isModule then
                   false -> isComp
                else
                   enclosingHandle.markAsNotCompiled
               if)
            #);
          doCompile:
            (# L: ^log; iMain: ^compile.IModule; errors,FN: ^text
            enter L[]
            do '**** MiniENV: Xcompile: ' -> puttext;
               theModule.name -> putline;               
               modulePath -> FN[];
               theModule.name -> FN.append;
               compile.SrcExt[] -> FN.append;
               (* NOTE: theM <> none *)
               (L[],true,theModule.M[],FN[]) 
                 -> compile 
                 -> (imain[],errors[]);
               (if errors[] = none then
                   markAsCompiled
                else
                   '!!!! Errors: ' -> putline; errors[] -> putline
               if)
            exit(iMain[],errors[])
            #);

          extendReps:
            (#
            do 1 -> dclNames.extend;
               1 -> DCLs.extend;
               1 -> handles.extend;
            #);
          getNameAndKind:
            (# str,name: ^text; kind: @char
            enter str[]
            do '!??' -> name[]; '?' -> kind;
               str.reset;
               search: str.scan
                 (# inx: @integer
                 do inx + 1 -> inx;
                    (if ch
                     // ':' then
                        (1, inx - 1) -> str.sub -> name[];
                        str.length -> str.inxGet -> kind;
                        leave search;
                     // '*' then
                        'do' -> name[];
                        '*' -> kind
                    if)
                 #)
            exit(name[],kind)
            #);
          getSize: integerValue
            (# skippedOne:< (#do inner #)
            do (if onlyModulesAndPatterns then
                   scan
                   (# name: ^text; kind: @char
                   do 'Getsize: ' -> puttext; current[] -> putline;
                      current[] -> getNameAndKind -> (name[],kind);
                      (if kind // '/' // ' ' then
                      value + 1 -> value
                       else
                          skippedOne
                   if)#);
                   '**    size: ' -> puttext; value -> putint; 
                   ' length: ' -> puttext; 
                   length -> putint; newline
                else
                   length -> value
               if)
            #);     
          isIncluded: BooleanValue
            (# current,name: ^text; kind: @char
            enter current[]
            do (if onlyModulesAndPatterns then
                    current[] 
                     -> getNameAndKind 
                     -> (name[],kind);
                   (if kind // '/' // ' ' then
                       true -> value
                    else
                       false -> value
                   if)
                else
                   true -> value
               if);
            #);
          adjustIndex:
            (# index,oldIndex,ix: @integer
            enter index
            do (if onlyModulesAndPatterns then
                   '**** adjustIndex:' -> puttext; index -> putint; newline;
                   index -> oldIndex;
                   L:
                     scan
                     (# name: ^text; kind: @char
                     do current[] -> puttext; ' ' -> put;
                        current[] -> getNameAndKind -> (name[],kind);
                        name[] -> puttext; ' \'' -> puttext; 
                        kind -> put; '\'\n' -> puttext;
                        (if kind // '/' // ' ' then
                            ix + 1 -> ix
                         else
                            index + 1 -> index
                        if);
                        (if ix = oldIndex then leave L if)
                     #);
                   (if index > dclNames.range then
                       dclNames.range -> index
                   if);
                   '**    adjustedIndex: ' -> puttext; index -> putint; newline
               if)
            exit index 
            #);
          
          elm:
            (# inx: @integer;
            enter inx
            do inx -> adjustIndex -> inx;
               (if handles[inx][] = none then
                   (if DCLs[inx].sort = NONE then
                       'Handle:DCLs[inx].sort is none' -> puttext;
                       dclNames[inx][] -> putline
                   if);
                   (dclNames[inx][],DCLs[inx].sort,thisModule,this(handle)[]) 
                     -> &Handle -> handles[inx][]
               if);
            exit handles[inx][]
            #);
          addToEntries:
            (# name: ^text; dcl: ^Tree.TopNode; ix,inx: @integer; 
               beforeNode: ^Tree.TopNode;
            enter(name[],dcl[],inx)
            do extendReps; (* range + 1 -> range *)
               (for i: handles.range - inx repeat
                    handles.range - i + 1 -> ix;
                    handles[ix - 1][] -> handles[ix][];
                    DCLs[ix - 1][] -> DCLs[ix][];
                    dclNames[ix - 1][] -> dclNames[ix][];
               for);
               dcl[] -> DCLs[inx][];
               name[] -> dclNames[inx][];                
               (dclNames[inx][],dcl.sort,thisModule,this(handle)[]) 
                 -> &Handle 
                 -> handles[inx][];
               (if inx < DCLs.range then
                   DCLs[inx+1][] -> beforeNode[];
               if);
               (if traceEdit then
                   '**** AddToEntries: "' -> puttext; name[]->puttext; 
                   '"' -> putline;
                   '**   name: '->puttext; 
                   theEntry[] -> getPatternName -> putline;
                   '**   theEntry:\n' -> puttext; theEntry.doPT -> putline;
                   '**   dcl:\n' -> puttext; dcl.doPt -> putline;
                   (if beforeNode[] <> NONE then
                       '** before: ' -> puttext; beforeNode.doPT -> putline;
                   if);
                   '** insert at: ' -> puttext; theEntry.label -> putline;
               if);
               (dcl[],beforeNode[]) -> theEntry.doInsert;
            #);
          
          changeAttName:
            (# oldItem,newItem,oldName,newName: ^text; 
               oldXkind,newXkind: @integer;
               oldKind,newKind: @char; error: @boolean
            enter(oldItem[],newItem[])
            do (if traceEdit then
                   '**** Change Attribute: ' -> puttext;
                   oldItem[] -> puttext;
                   ' to ' -> puttext;
                   newItem[] -> putline;
               if);
               (if true then
                   (oldItem[],newItem[]) ->theEntry.changeAttName;
                   markAsChanged;
                else
                   ('AttributeChanged',oldName[]) -> LG.TT; 
                   ('to',newName[]) -> LG.TTn;
                   oldItem[] -> compile.browserItem 
                     -> (oldName[],oldXkind,oldKind,error);
                   newItem[] -> compile.browserItem 
                     -> (newName[],newXkind,newKind,error);
                   (if not error then
                       (if oldKind <> newkind then
                           ('KindChanged',oldKind) -> LG.TI;
                           ('to',newKind) -> LG.TIn;
                           'Change of kind is not implemented!' -> putline
                       if);
                       (*'CAN: ' -> puttext;theEntry.doPT -> putline;
                        'PP: ' -> puttext;theEntry.PP -> putline;
                        'ON: ' -> puttext; oldName[] -> putline;
                        'NN: ' -> puttext; newName[] -> putline;*)
                       (oldName[],newName[]) ->theEntry.changeAttName;
                       markAsChanged
                   if)
               if);
            exit error
            #);
          checkName:
            (# N: ^Text; ch: @char; msg: ^text;
               filter:
                 (* convert 'xxx: ^' to 'xxx'
                  * should be fixed so we avoid ': ^'
                  *)
                 (# T: ^text; S: @text
                 enter T[]
                 do (for i: T.length repeat
                         i -> T.inxGet -> ch;
                         (if ch = ':' then leave filter if);
                         ch -> S.put
                    for)
                 exit S[] 
                 #)
            enter N[]
            do (if N.length > 0 then
                   (if (1 -> N.inxGet -> ascii.isLetter) then
                       (for i: N.length - 1 repeat
                            i + 1 -> N.inxGet -> ch;
                            (if true
                             // ch -> ascii.isLetter
                             // ch -> ascii.isDigit
                             // (ch = '_') or (ch = '$') or (ch = '%') then
                             else
                                'Illegal character "' -> msg[];
                                ch -> msg.put; '"' -> msg.put;
                                ' in "' -> msg.append;
                                N[] -> msg.append; '"' -> msg.put;
                                leave checkName
                            if)
                       for)
                    else
                       'First letter of "' -> msg[]; N[] -> msg.append;
                       '" must be a letter: ' -> msg.append;
                       leave checkName
                   if)
                else
                   'Name is empty' -> msg[];
                   leave checkName
               if);
               (* check for double decl *)
               (for i: dclNames.range repeat
                    (* 'match: ' -> puttext; dclNames[i][]->filter -> puttext;
                     * ' with: ' -> puttext; N[] -> putline;*)
                    (if (N[] -> (dclNames[i][] -> filter).equalNCS) then
                        '"' -> msg[];
                        N[] -> msg.append;
                        '"' -> msg.put;
                        ' is alreday an attribute' -> msg.append;
                        leave checkName
               if)for)
            exit msg[]
            #);
          pasteModule: (* called from worldWindow:textPasteModuleHandler *)
            (# error:<
                 (# msg: ^text
                 enter msg[]
                 do msg[] -> putline; inner
                 #);
               index: @integer;
               content: ^Text;
               att: ^Text;
            enter (index, content[])
            do body:
                 (# errors: ^Stream;
                    dcl: ^Tree.TopNode;
                    name: ^Text;
                    kind: @char;
                    source: ^File; 
                    path: ^text
                 do (* content must be a constant object X : =^... *)
                    '**** pasteModule:theEntry: ' -> putline; 
                    theEntry.doPT -> putline;
                    content[] 
                      -> compile.parseX_Decl 
                      -> (errors[],dcl[],name[],kind); 
                    (if errors[] <> none then
                        errors[] -> error; leave body
                    if);
                    (if kind <> compile.kinds.objModule then
                        'Item is not an object module' -> error; leave body
                    if);
                    
                    (if traceEdit then
                        '**** PasteModule:name: ' -> puttext; name[] -> putline;
                        '**   kind: '  -> puttext; 
                        kind -> compile.kinds.asText -> putline;
                        '**   content:\n ' -> puttext; content[] -> putline;
                        '**   index: ' -> puttext; index -> putint; newline;
                        '**   in: ' -> puttext; 
                        (thisModule).pathToFN -> putline;
                        '**   dcl: ' -> putline; dcl.doPt -> putline;
                        '**   theEntry: ' -> putline; theEntry.doPT -> putline;
                    if);
                    
                    &Text[] -> att[];
                    name[] -> att.puttext;
                    ': /' -> att.puttext; (* FIX '/' *)
                    
                    (if not ((((thisModule).pathToFN).copy,name[]) 
                          -> compile.testAndCreateDir) then
                        'OBS! Path does not exist or directory already exist' 
                          -> error;
                        leave body
                    if);
                    ((thisModule).pathToFN).copy -> path[];
                    compile.dirCh -> path.put;
                    name[] -> path.append;
                    (path[], compile.srcExt[] -> (name.copy).append)
                          -> compile.testAndCreateFile -> source[];
                    (if source[] = none then
                        'OBS! Cannot create file' -> error;
                        leave body
                    if);
                    source.openWrite;
                    content[] -> source.putline;
                    source.close;
                    
                    (att[],dcl[],index) -> addToEntries;
                    
                    refresh;
                 #)
            exit att[]
            #);
          addDecl:
            (# inx: @integer;
               newDecl: ^Text;
               att: ^Text;
            enter (inx, newDecl[])
            do (# errors: ^Stream;
                  dcl: ^Tree.TopNode;
                  name: ^text;
                  kind: @integer;
                  skind: ^text
               do newDecl[]
                    -> compile.parseX_Decl 
                    -> (errors[], dcl[],name[],kind);                   
                  ': /' (* skind[] *) -> (name.copy).puttext;
                  (att[],dcl[],inx) -> addToEntries
               #);
            exit att[]
            #);
          addItem:
            (* move
             *  reps[inx] -> rep[inx + 1]
             *  ...
             *  reps[reps.range] -> reps[reps.range + 1]
             * Add:
             *  name[] -> asDecl -> reps[inx]
             *)
            (# name: ^text; inx: @integer; kind: @char; 
               att: ^text
            enter(inx,name[],kind)
            do ('AddItem',name[]) -> LG.TT; 
               ('at',inx) -> LG.TI; 
               ('kind',kind) -> LG.TIn;
               &text[] -> att[];
               body:
               (# dcl: ^Tree.TopNode;
                  itemT, path,FN,path1: ^text;
                  F: ^file;
                  errors: ^Stream
               do name -> att; ':' -> att.put; ' ' -> att.put; 
                  (* consider browserItem above : and cons of new/oldName
                   * kind is insufficient - we need to use parser::kinds
                   *)
                  (if kind  (* FIX *)
                   // '@' then
                      '@' -> att.put
                   // '/' then
                      '/' -> att.puttext
                   // '#' then
                      '/' -> att.put
                  if);
                  (if kind (* FIX *)
                   // ' ' // '@' then
                      (name.copy,kind,path1[]) 
                        -> compile.mkDecl -> (errors[],dcl[]);
                      (if errors[] <> none then
                          '*** errors:'->putline; errors[] -> putline
                      if)
                   // '/' // '#' then
                      (* Test if there is a directory 'name' else create it
                       * Test if 'name' has a file 'name.bet/.xbeta' 
                       * else create it
                       * However test for double decl should imply that the 
                       * above may be rare or not happen
                       *)                      
                      ((thisModule).pathToFN).copy -> path[];
                      ('Create module in',path[]) -> LG.TTn;
                      
                      (path[],name.copy) -> compile.testAndCreateDir;
                      (path[],name.copy) -> compile.testAndCreateBetaFile 
                        -> F[];
                      (if F[] = none then
                          '' -> att;
                          leave body
                      if);

                      F.openWrite;                      
                      (name[],kind,path[],F[]) 
                        -> compile.mkModuleItem -> (itemT[],att[],dcl[]);
                      itemT[] -> F.putline;
                      F.close;
                  if);
                  ('addItem',att[]) -> LG.TTn;
                  ('Decl',dcl.doPT) -> LG.TTn;                  
                  (att[],dcl[],inx) -> addToEntries;
                  (if traceEdit then
                      'modified: ' -> puttext;theEntry.doPt -> putline;
                  if);
                  markAsChanged
               #)
            exit att[]
            #); 
          moveUp:
            (# att: ^text; inx: @integer
            enter(att[],inx)
            do ('Move: ',att[]) -> LG.TTn;
               DCLs[inx][] -> theEntry.doMoveUp;
               markAsChanged
            #);
          delete:
            (# att,name,path: ^text; inx,xKind: @integer;
               kind: @char; error: @boolean
            enter(att[],inx)
            do 'objecContent:delete: ' -> puttext;
               att[] -> putline;
               att[] -> compile.browserItem -> (name[],xKind,kind,error);
               name[] -> theEntry.doDelete;
               (if kind // '/' // '#' then
                   (# 
                   do 'Deleting directory: ' -> putline;
                      (* thisCom is module containing the att *)
                      modulePath -> path[];
                      compile.dirCh -> path.put;
                      name[] -> path.append;
                      path[] -> compile.deleteDirectory
                   #)                      
               if);
               (* move: reps[inx+1] -> reps[inx], ... *)
               (for ix: handles.range - inx repeat
                    handles[inx + ix][] -> handles[inx + ix - 1][];
                    DCLs[inx + ix][] -> DCLs[inx + ix - 1][];
                    dclNames[inx + ix][] -> dclNames[inx + ix - 1][];
               for);
               (* range is no more = top *)
               markAsChanged
            #);
          saveBuffer:
            (# T: ^text; errors: ^stream
            enter theText[]
            do ('SaveBuffer',theText[]) -> LG.TTn;
               theText[] -> filter -> T[];
               (if traceEdit then
                   '**** saveBuffer:theEntry.label:' -> puttext; 
                   theEntry.label -> putline;
                   theEntry.doPP -> putline;
                   '**    modulePath: ' -> puttext; modulePath -> putline;
                   '**** new content: ' -> putline;
                   T[] -> putline;
                   '**   saveBuffer:theEntry:old:\n' -> puttext;  
                   theEntry.doPT -> putline;
               if);
               
               (modulePath,T[]) -> theEntry.replaceEntity -> errors[];
               
               (if errors[] = none then
                   markAsChanged;
                   (if false then
                       'saveBuffer:after:'->puttext; theEntry.doPT -> putline;
                   if);
                   setUp;
                else
                   'SaveBuffer: syntax errors: ' -> putline;
                   errors[] -> putline
               if)
            exit errors[]
            #);
          Filter:
            (# inT,outT: ^text
            enter inT[]
            do 0 -> inT.setPos;
               &text[] -> outT[];
               inT.scanAll(# do (if ch <> ascii.cr then ch -> outT.put if)#)
            exit outT[]
            #);
          Filter0:
            (# in, out: ^Text;
            enter in[]
            do &Text[] -> out[];
               in.reset;
               loop:
                 (if not in.eos then
                     in.getline -> out.puttext;
                     ' ' -> out.put;
                     restart loop;
                 if);
            exit out[]
            #);
          getText:
            (# T: ^text; 
            do (if theEntry[] = none then 
                   'theEntry:none'->T[]->putline  
                else 
                   (if theEntry.entity = none then 
                       theEntry.doPT -> putline;
                       'theEntry.entity:none'->T[]->putline
                    else 
                       true -> (theEntry.entity).doPT -> T[];
                   if)
               if);
               ('getText',T[]->tHead) -> LG.TTn
            exit T[]
            #);
          
          length: (# exit dclNames.range #);
          
          scan:
            (# current: ^text; inx: @integer
            do (for i: dclNames.range repeat
                    i -> inx;
                    dclNames[i][] -> current[];
                    (*'Scan: ' -> puttext; current[] -> putline;*)
                    INNER
               for)
            #);
          selectCode:
            (* obj is a run-time object
             * Find the Entity/ObjectDesc that describes 'obj'
             * Path: is the list of indexes in browserItems
             *)
            (# obj: ^objDesc.RunTimeObject;
               descNo: @integer;
               path: ^intList;
               objC: ^handle;
               trace: (# exit false #); 
            enter(obj[],descNo,path[])
            do (if trace then
                   '**** ObjectContent:SelectCode:' -> puttext; 
                   descNo -> putint; 

                   (* Decl of D eliminated to remove dependency of parser
                    * Perhaps theEntry.myDesc.getDescNo can be used!?
                    * (if (theEntry.myDesc-> D[]) <> none then
                   *    D.getDescNo -> putint; newline;
                   * if);
                   *)
                   newline;
                   true-> theEntry.doPT -> putline;
               if);
               (if (*obj.myDescInx*) descNo -> theEntry.objDescEQ then
                   (if trace then
                       'objectContent:selectCode:Found'->putline
                   if);
                   this(handle)[] -> objC[]
                else
                   path.up;
                   L:
                     scan
                     (#
                     do (if ((obj[],descNo,path[]) 
                              -> (inx -> elm).selectCode->objC[])
                            <> none then
                            (if trace then 
                                ':' -> put; current[] -> puttext; 
                            if);
                            inx -> path.add;
                            leave L
                        if)
                     #);
                   path.down
               if)
            exit objC[]
            #);
          findNode:
            (# pos: @integer;
               nd: ^Tree.TopNode;
            enter pos
            do pos -> (theEntry.entity).findNodeAtPos -> nd[];
            exit nd[]
            #);
          setBreak:
            (# pos: @integer; 
               nd: ^Tree.TopNode;
               imp: ^tree.TopNode;
               objD: ^Tree.TopNode;
            enter pos
            do pos -> (theEntry.entity).findNodeAtPos -> nd[];
               (if nd[] <> none then
	           '*** setBreak:found: ' -> puttext;
                   nd[] -> getPatternName -> putline;
                   (if (ND.enclosingImperative -> imp[]) <> none then
                       '*** breakAt: '->puttext; imp.doPT -> putline;
                       imp.getODorigin -> objD[];
                       (if objD[] <> none then
                           '*** breakIn: ' -> putline;objD.dopt -> putline
                        else
                           '!!! setBreak:objD:is none'->putline
                       if);
                       (objD.getDescNo,imp.beginBCP) -> VM.execute.break;
                    else
                       '!!! setBreak:enclosingImperative:not found'->putline;
                   if)
                else
                   '!!! setBreak: not found' -> putline;
               if);
            exit imp[]
            #);
          saveModuleToFile:
            (# F,B: ^BetaFile; betaFN, newText: ^text;
               theModule: ^Tree.iModule;
            do (if isModified then
                   thisModule -> theModule[];
                   ('Save module',theName[]) -> LG.tTn;
                   (if traceEdit then
                       '**** Save module: ' -> puttext; theName[] ->putline;
                   if);
                   (if theModule[] <> none then
                       theModule.doPT -> filter -> newText[];
                       (if traceEdit then
                           '**** new content: ' -> putline; 
                           newText[] -> putline;
                       if);
                       (if traceEdit then
                           '**** theModule: ' -> puttext; 
                           theModule.name -> putline;
                       if);
                       theModule.inFile -> createBackUpFile -> betaFN[];
                       ('BackUp as *.back',betaFN[]) -> LG.tTn;
                       (betaFN[],newText[]) -> newSourceFile -> theModule.inFile
                    else
                       '\n!!!! saveModuleToFile: No module!'->putline
               if)if)
            #);          

          isModified: BooleanValue
            (# wasModified: @boolean
            do (if wasChanged then
                   true -> wasModified;
                   ('isModified',theText[]) -> LG.tTn;
                else
                   scan
                   (# kind: @char;              
                   do (*current[] -> putline;*) 
                      current.length -> current.inxGet -> kind;
                      (if kind (* consider using isCom *) (* FIX *)
                       // '/' // '#' then  
                          ('isModified? /','') -> LG.tT;
                          (if wasChanged then 
                              (* This is not ok! 
                               * If module is changed, then there should
                               * be no sub modules to test for changes *)
                              ('wasChanged:/',theText[]) -> LG.tTn;
                              true -> wasModified 
                          if);
                          (if handles[inx][] <>  none then 
                              (* has been selected, may be modified *)
                              handles[inx].saveModuleToFile
                          if)
                       // '@'
                       // ' ' 
                       // '<'
                       // '!' then (* action-part *) 
                          (if wasChanged then 
                              ('IsModified',theText[]) -> LG.tTn;
                              true -> wasModified 
                          if);
                          (if (theText[] <> none) and wasChanged then
                              true -> wasModified ;
                              ('AndTheTextChanged',theText[]) -> LG.tTn
                           else
                              (if handles[inx][] <>  none then 
                                  (if handles[inx].isModified then
                                      true -> wasModified
                          if)if)if)                      
                       else
                          ('scanModified: unknown kind',current[]) -> LG.tTn;
                      if)
               #)if);
               wasModified -> value
            #);
          enclosingModuleObj:
            (# objC: ^handle
            do (if isModule then
                   this(handle)[] -> objC[]
                else
                   enclosingHandle.enclosingModuleObj -> objC[]
               if)
            exit objC[]
            #);
          thisModule:
            (# cmp: ^Tree.iModule
            do &compile.iModule[] -> cmp[];
               (if isModule then
                   theModule[] -> cmp[]
                else
                   enclosingModule[] -> cmp[]                   
               if)
            exit cmp[]
            #);
          entityPathFromModule:
            (# T: ^text
            do (if isModule then
                   (thisModule).name -> T[]
                else
                   enclosingHandle.entityPathFromModule -> T[];
                   '::'->T.append;
                   theName[] -> T.append
               if)
            exit T[]
            #);
          modulePath:
            (* we should check if this(handle) is actually a module
             * currently it may be any attribute
             *)
            (# path,N: ^text;
            do (if enclosingHandle[] = none then 
                   compile.pathToBetaWorld.copy -> path[]
                else 
                   enclosingHandle.modulePath -> path[];
                   (thisModule).name -> path.append;
                   compile.dirCh -> path.put;
               if)
            exit path[]
            #);
               
          markAsChanged:
            (#
            do true -> wasChanged;
               markAsNotCompiled;
               saveModuleToFile;
            #);
          wasChanged: @boolean; 
          
          getModulePath:
            (# path: ^Text;
            do (theModule.pathToFN).copy -> path[];
               compile.dirCh -> path.put;
               theModule.name -> path.puttext;
               compile.srcExt[] -> path.puttext; 
            exit path[]
            #);
          refresh:
            (# path: ^Text;
               iM: ^Tree.iModule
            do (if isModule then
                   (theModule.pathToFN).copy -> path[];
                   compile.dirCh -> path.put;
                   theModule.name -> path.puttext;
                   compile.srcExt[] -> path.puttext;
                   'refresh: ' -> puttext;
                   path[] -> putline;
                   path[] -> compile.pModuleX -> iM[];
                   (if iM[] <> NONE then
                       'success: ' -> puttext;
                       iM.name -> putline;
                       compile.path.init;
                       (theModule.pathToFN).copy -> compile.path.push;
                       iM.handleDirModules;
                       compile.path.pop;
                       iM.M[] -> theEntry[];
                       setup;
                   if);
               if);
            #);
          setUp:
            (# 
            do (if traceEdit then
                   '**** Handle: ' -> puttext; theName[] -> putline;
                   '**   theEntry:A:\n' -> puttext; theEntry.doPT -> putline;
               if);
               
               (if theEntry[] = none then 
                   '!!!! handle:setup:theEntry: is none! '->putline 
               if);
         
               theEntry.getEntries -> (dclNames[],DCLS[]);
               (if false then
                   (for i: dclNames.range repeat
                        '**** entry: ' -> puttext; 
                        dclNames[i][] -> puttext; ' ' -> put; newline;
                        (if dcls[i][] <> none then
                            dcls[i].dopt -> putline; '---'->putline
                        if)
                   for);
                   newline;
               if);
               dclNames.range -> handles.new;
               (theEntry.isAmodule -> theModule[]) <> none -> isModule;
               (if traceEdit then
                   '**   theEntry:B:\n' -> puttext; theEntry.doPT -> putline;
               if);
            #);
            
          isModule: @boolean;  
          enclosingModule,theModule: ^Tree.iModule;
          enclosingHandle: ^Handle;
          theName: ^text;
       enter(theName[],theEntry[],enclosingModule[],enclosingHandle[])
       do setUp
       exit this(handle)[]
       #);   
  #)
