ORIGIN '~beta/guienv/guienvsystemenv';
(*ORIGIN '~beta/basiclib/betaenv';*)
INCLUDE '~beta/basiclib/file';
INCLUDE '../miniCompiler/generator';
INCLUDE '../miniCompiler/betaVM';
INCLUDE 'log';
INCLUDE '~beta/sysutils/objinterface';

---lib:attributes---
ObjectContent: 
  (# compile: ^generator;
     VM: ^ | systemenv.betaVM;
     LG: ^log;

     init:< (# enter(compile[],VM[],LG[]) #);
     
     handle:
       (* Representation of and Entry of the form
        *    Entry = (theName,sort = (kind,Entity))
        *    theName is declared below at the enter-part
        * An Entry may be one of
        *    ObjectModule, PtnModule, ObjectDesc, Attributes, ActionPart
        * For an objectDesc, a declaration is an entry:
        *    Dcl = (nameDcl, item =(kind,objectSpec))
        * An Entity in turn contains a list of Entries
        * The Entries of Entry are represented in 
        *    L, DCLs, handles
        * 
        *    |   ...   | dclNames[1]              |
        *    |   ...   | ...                      |
        *    | theName | dclNames[i]              |
        *    |  ...    | ...                      | 
        *    |  ...    | dclNames[dclNames.range] |
        *    --------------------------------------
        *    |  Entity                            |
        *    |                                    |
        *    --------------------------------------
        * When dclNames[i] is selected, then a Handle is made for dclNames[i]
        * and and DCLs[i] becomes the Entry in the Handle
        * Actually we use DCLs[i].sort to construct the handle
        * 
        * Representation of 
        * - an objectDesc of a decl represented in 
        * theEntry 
        *    as a module:       theModule -> OD
        *    as an item:           
        *        as a staticItem:  SI, -> OD
        *                              -> non singular?
        *        as a dynamicItem: ?,
        *        as a pattern:     PTN, -> OD
        *        as a directory    DIR -> theModule -> OD
        *    as an actionPart:     ACP
        * shown in
        * - a browser 
        *   Attributes X1, X1, ... Xn, ACP (action part)
        *   represented in 
        *    dclNames -- the names of decl's in OD
        *    DCLs,    -- the decls in OD
        * or
        * - textEditor
        *   represented as theText
        *)
       (# theEntry: ^generator.node; (* used to be N *)
          dclNames: [0] ^text;
          DCLs: [0] ^generator.Node(*decl*);
          handles: [0] ^handle;
          theText: ^text;
          
          extendReps:
            (#
            do 1 -> dclNames.extend;
               1 -> DCLs.extend;
               1 -> handles.extend;
            #);
          
          elm:
            (# inx: @integer;
            enter inx
            do 
               (if handles[inx][] = none then
                   (if DCLs[inx].sort = NONE then
                       'Handle:DCLs[inx].sort is none' -> puttext;
                       dclNames[inx][] -> putline
                   if);
                   (dclNames[inx][],DCLs[inx].sort,thisModule,this(handle)[]) 
                     -> &Handle -> handles[inx][]
               if);
            exit handles[inx][]
            #);
          changeAttName:
            (# oldItem,newItem,oldName,newName: ^text; 
               oldXkind,newXkind: @integer;
               oldKind,newKind: @char; error: @boolean
            enter(oldItem[],newItem[])
            do 'Change Attribute: ' -> puttext;
               oldItem[] -> puttext;
               ' to ' -> puttext;
               newItem[] -> putline;
               
               (if true then
                   (oldItem[],newItem[]) ->theEntry.changeAttName;
                   markAsChanged;
                else
                   ('AttributeChanged',oldName[]) -> LG.TT; 
                   ('to',newName[]) -> LG.TTn;
                   oldItem[] -> compile.browserItem -> (oldName[],oldXkind,oldKind,error);
                   newItem[] -> compile.browserItem -> (newName[],newXkind,newKind,error);
                   (if not error then
                       (if oldKind <> newkind then
                           ('KindChanged',oldKind) -> LG.TI;
                           ('to',newKind) -> LG.TIn;
                           'Change of kind is not implemented!' -> putline
                       if);
                       (*'CAN: ' -> puttext;theEntry.doPT -> putline;
                        'PP: ' -> puttext;theEntry.PP -> putline;
                        'ON: ' -> puttext; oldName[] -> putline;
                        'NN: ' -> puttext; newName[] -> putline;*)
                       (oldName[],newName[]) ->theEntry.changeAttName;
                       markAsChanged
                   if)
               if);
            exit error
            #);
          addModule:
            (# index: @integer;
               name: ^Text;
               content: ^Text;
               owner: ^generator.Module;
               path: ^Text;
               att: ^Text;
            enter (index, content[])
            do (# errors: ^Stream;
                  dcl: ^compile.Decl;
               do content[] -> compile.parseDecl -> (errors[], dcl[]);
                 (dcl.NS.first).N.lexemSy -> name[];
                  'add-module: ' -> puttext;
                  name[] -> puttext;
                  ' @ ' -> puttext;
                  index -> putint;
                  thisModule -> owner[];
                  ' in ' -> puttext;
                  owner.pathToFN[] -> putline;
                  &Text[] -> att[];
                  name[] -> att.puttext;
                  ': /' -> att.puttext;
                  (if true then
                      creation:
                        (# dir: @Directory;
                           failure: @boolean;
                           message: ^Text;
                           source: @File;
                           path1: ^Text;
                        do owner.pathToFN[] -> dir.name;
                           (if dir.entry.exists then
                               create: name[] -> dir.createDir
                               (# exists::
                                    (#
                                    do 'Directory already exists' -> message[];
                                       true -> failure;
                                       leave create;
                                    #);
                               #);
                            else
                               'Parent directory does not exist' -> message[];
                               true -> failure;
                           if);
                           (if failure then
                               'failure: "' -> puttext;
                               message[] -> puttext;
                               '"' -> putline;
                               leave creation;
                           if);
                           owner.pathToFN.copy -> path[];
                           compile.dirCh -> path.put;
                           name[] -> path.puttext;
                           compile.dirCh -> path.put;
                           path.copy -> path1[];
                           name[] -> path.puttext;
                           '.bet' -> path.puttext;
                           path[] -> putline;
                           path[] -> source.name;
                           source.openWrite;
                           content[] -> source.putline;
                           source.close;
                           
                           
                           
                           (# type: @char;
                              kind: @char;
                              mdcl, before: ^compile.Decl;
                              ix: @integer;
                           do (*** Extend Reps ***)
                              extendReps; (* range + 1 -> range *)
                              (for i: handles.range - index repeat
                                   handles.range - i + 1 -> ix;
                                   handles[ix - 1][] -> handles[ix][];
                                   DCLs[ix - 1][] -> DCLs[ix][];
                                   dclNames[ix - 1][] -> dclNames[ix][];
                              for);
                              (dcl.sort).kind -> type;
                              (if type
                               //' ' then
                                  '#' -> kind;
                               //'@' then
                                  '/' -> kind;
                              if);
                              (name[],kind,content[],path1[],source[]) -> compile.mkModuleItemDeclx -> mdcl[];
                              mdcl[] -> DCLs[index][];
                              att[] -> dclNames[index][];
                              (if index < DCLs.range then
                                  DCLs[index + 1][] -> before[];
                               else
                                  NONE -> before[];
                              if);
                              
                              (mdcl[], before[]) -> theEntry.doInsert;
                           #);
                           
                           refresh;
                        #);
                  if);
               #);
            exit att[]
            #);
          addDecl:
            (# inx: @integer;
               newDecl: ^Text;
               att: ^Text;
            enter (inx, newDecl[])
            do (# errors: ^Stream;
                  dcl: ^compile.Decl;
                  ix: @integer;
                  before: ^compile.Decl;
               do newDecl[] -> compile.parseDecl -> (errors[], dcl[]);
                  &Text[] -> att[];
                  (dcl.NS.first).N.lexemSy -> att.puttext;
                  ': ' -> att.puttext;
                  (dcl.sort).skind -> att.puttext;
                  'ATT: ' -> puttext;
                  att[] -> putline;
                  extendReps;
                  (for i: handles.range - inx repeat
                       handles.range - i + 1 -> ix;
                       handles[ix - 1][] -> handles[ix][];
                       DCLs[ix - 1][] -> DCLs[ix][];
                       dclNames[ix - 1][] -> dclNames[ix][];
                  for);
                  
                  dcl[] -> DCLs[inx][];
                  att[] -> dclNames[inx][];
                  
                  
                  (dclNames[inx][], dcl.sort, thisModule, this(handle)[]) 
                    -> &Handle 
                    -> handles[inx][];
                  
                  (if inx < DCLs.range then
                      DCLs[inx + 1][] -> before[];
                   else
                      NONE -> before[];
                  if);
                      
                  (dcl[], before[]) -> theEntry.doInsert;
               #);
            exit att[]
            #);
          addItem:
            (* move
             *  reps[inx] -> rep[inx + 1]
             *  ...
             *  reps[reps.range] -> reps[reps.range + 1]
             * Add:
             *  name[] -> asDecl -> reps[inx]
             *)
            (# name: ^text; inx: @integer; kind: @char; 
               att: @text
            enter(inx,name[],kind)
            do ('AddItem',name[]) -> LG.TT; 
               ('at',inx) -> LG.TI; 
               ('kind',kind) -> LG.TIn;
               (# newDecl: @text;
                  ix: @integer;
                  dcl: ^generator.decl;                  
                  itemT, path,FN,path1: ^text;
                  F: ^file;
                  beforeNode: ^generator.node;
                  errors: ^Stream
               do 
                  extendReps; (* range + 1 -> range *)
                  (for i: handles.range - inx repeat
                       handles.range - i + 1 -> ix;
                       handles[ix - 1][] -> handles[ix][];
                       DCLs[ix - 1][] -> DCLs[ix][];
                       dclNames[ix - 1][] -> dclNames[ix][];
                  for);
                  
                  name -> att; ':' -> att.put; ' ' -> att.put; 
                  (* consider browserItem above : and cons of new/oldName
                   * kind is insufficient - we need to user parser::kinds
                   *)
                  (if kind 
                   // '@' then
                      '@' -> att.put
                   // '/' then
                      '/' -> att.puttext
                   // '#' then
                      '/' -> att.put
                  if);
                  att -> newDecl; 
                  (if kind
                   // ' '
                   // '@' then
                      '(# #)' -> newDecl.append;
                      (newDecl[],path1[]) -> compile.mkDecl -> (errors[],dcl[]);
                   // '/' // '#' then
                      (* name: dir exists -> name/name.bet exists? Error
                       *                     else create name.bet
                       *        else create dir name
                       *             create file name.bet
                       * get path from theModule
                       * Parse
                       *  'pElm: /' -> newDecl
                       *)
                      ('Create module in',(thisModule).pathToFN[]) -> LG.TTn;
                      (thisModule).pathToFN.copy -> path[];
                      (path[],name[]) -> compile.testAndCreateDir;
                      compile.dirCh -> path.put;
                      path.copy -> path1[];
                      name[] -> path.append;
                      name.setPos;
                      name.copy -> FN[];
                      '.bet' -> FN.append;
                      (path[],FN[]) -> compile.testAndCreateFile -> F[];
                      'OPEN FILE' -> putline;
                      F.openWrite;
                      name[] -> F.puttext;
                      (if kind = '/' then (* object module *)
                          '@(# #)' -> itemT[];
                          ': @(# #)' -> F.putline
                       else (* pattern module *)
                          '(# #)' -> itemT[];
                          ': (# #)' -> F.putline
                      if);
                      F.close;
                      (name[],kind,itemT[],path1[],F[]) -> compile.mkModuleItemDeclx -> dcl[]
                  if);
                  ('addItem',newDecl[]) -> LG.TTn;
                  ('Decl',dcl.doPT) -> LG.TTn;
                  dcl[] -> DCLs[inx][];
                  att[] -> dclNames[inx][];

                  (if inx < DCLs.range then
                      DCLs[inx+1][] -> beforeNode[];
                  if);
                  'AddItem: "'->puttext; att[]->puttext; '"' -> putline;
                  (dclNames[inx][],dcl.sort,thisModule,this(handle)[]) 
                    -> &Handle -> handles[inx][];
                  'theEntry: '->puttext; theEntry[] -> getPatternName -> puttext;
                  ' | ' -> puttext;
                  theEntry.doPT -> putline;
                  'dcl: ' -> puttext;
                  dcl.doPt -> putline;
                  (if beforeNode[] <> NONE then
                      'before: ' -> puttext;
                      beforeNode.doPT -> putline;
                  if);
                  (dcl[],beforeNode[]) -> theEntry.doInsert;
                  'modified: ' -> puttext;
                  theEntry.doPt -> putline;
               #); 
               markAsChanged
            exit att[]
            #); 
          moveUp:
            (# att: ^text; inx: @integer
            enter(att[],inx)
            do ('Move: ',att[]) -> LG.TTn;
               DCLs[inx][] -> theEntry.doMoveUp;
               markAsChanged
            #);
          delete:
            (# att,name,path: ^text; inx,xKind: @integer;
               kind: @char; error: @boolean
            enter(att[],inx)
            do 'objecContent:delete: ' -> puttext;
               att[] -> putline;
               att[] -> compile.browserItem -> (name[],xKind,kind,error);
               name[] -> theEntry.doDelete;
               (if kind // '/' // '#' then
                   (# 
                   do 'Deleting directory: ' -> putline;
                      (* thisCom is module containing the att *)
                      modulePath -> path[];
                      compile.dirCh -> path.put;
                      name[] -> path.append;
                      path[] -> compile.deleteDirectory
                   #)
                      
               if);
               (* move: reps[inx+1] -> reps[inx], ... *)
               (for ix: handles.range - inx repeat
                    handles[inx + ix][] -> handles[inx + ix - 1][];
                    DCLs[inx + ix][] -> DCLs[inx + ix - 1][];
                    dclNames[inx + ix][] -> dclNames[inx + ix - 1][];
               for);
               (* range is no more = top *)

               markAsChanged
            #);
          xreplace: (* ??? *)
            (# inx: @integer; aModule: ^generator.Module; objC: ^handle
            enter(inx,aModule[])
            do 'In: ' -> puttext; theName[] -> puttext;
               ' Replace: ' -> puttext; handles[inx].theName[] -> puttext;
               ' at: ' -> puttext; inx -> putint;
               ' descNo: ' -> puttext; aModule.descno -> putint; 
               (handles[inx].theName[],aModule[],enclosingModule[],enclosingHandle[]) 
               (***************************** - are these the right ones? *)
                 -> handle 
                 -> handles[inx][] 
                 -> objC[];
               ' newDescNo: ' -> puttext; aModule.descNo -> putint; newline;
               (* Note: the other reps like dclNames[inx] are undefined *)
               (*saveBuffer - ref is none *)
            exit objC[]
            #);
          saveBuffer:
            (# T: ^text; errors: ^stream
            enter theText[]
            do ('SaveBuffer',theText[]) -> LG.TTn;
               theText[]-> Filter -> T[];
               
               (if false then
                   'saveBuffer:with: ' -> puttext; T[] -> putline;
                   'saveBuffer:current: ' -> puttext;  theEntry.doPT -> putline;
                   modulePath -> putline;
               if);
               
               (modulePath,T[]) -> theEntry.replaceEntity -> errors[];
               
               
               (if errors[] = none then
                   markAsChanged;
                   (if false then
                       'saveBuffer:after:'->puttext; theEntry.doPT -> putline;
                   if);
                   setUp;
                else
                   'SaveBuffer: syntax errors: ' -> putline;
                   errors[] -> putline
               if)
            exit errors[]
            #);
          Filter:
            (# inT,outT: ^text
            enter inT[]
            do 0 -> inT.setPos;
               &text[] -> outT[];
               inT.scanAll(# do (if ch <> ascii.cr then ch -> outT.put if)#)
            exit outT[]
            #);
          Filter0:
            (# in, out: ^Text;
            enter in[]
            do &Text[] -> out[];
               in.reset;
               loop:
                 (if not in.eos then
                     in.getline -> out.puttext;
                     ' ' -> out.put;
                     restart loop;
                 if);
            exit out[]
            #);
          getText:
            (# T: ^text; 
            do (if theEntry[] = none then 
                   'theEntry:none'->T[]->putline  
                else 
                   (if theEntry.entity = none then 
                       theEntry.doPT -> putline;
                       'theEntry.entity:none'->T[]->putline
                    else 
                       true -> (theEntry.entity).doPT -> T[];                        
                   if)
               if);
               ('getText',T[]->tHead) -> LG.TTn
            exit T[]
            #);
          
          length: (# exit dclNames.range #);
          
          scan:
            (# current: ^text; inx: @integer
            do (for i: dclNames.range repeat
                    i -> inx;
                    dclNames[i][] -> current[];
                    (*'Scan: ' -> puttext; current[] -> putline;*)
                    INNER
               for)
            #);
          selectCode:
            (* obj is a run-time object
             * Find the Entity/ObjectDesc that describes 'obj'
             * Path: is the list of indexes in browserItems
             *)
            (# obj: ^objDesc.RunTimeObject;
               descNo: @integer;
               path: ^intList;
               objC: ^handle;
               trace: (# exit false #); D: ^generator.objectDesc
            enter(obj[],descNo,path[])
            do (if trace then
                   'SC: ' -> puttext; descNo -> putint; 
                   ' ' -> put;  

                   (if (theEntry.myDesc-> D[]) <> none then
                       D.descNo -> putint; newline;
                   if);
                   newline;
                   theEntry.doPT -> putline;
                   theEntry.PP -> putline;
               if);
               (if (*obj.myDescInx*) descNo -> theEntry.objDescEQ then
                   (if trace then
                       'objectContent:selectCode:Found'->putline
                   if);
                   this(handle)[] -> objC[]
                else
                   path.up;
                   L:
                     scan
                     (#
                     do (if 'koks: /'-> current.equalNCS then
                            (*'koks found' -> putline*)
                        if);
                        (if ((obj[],descNo,path[]) -> (inx -> elm).selectCode->objC[])
                            <> none then
                            (if trace then 
                                ':' -> put; current[] -> puttext; 
                            if);
                            inx -> path.add;
                            leave L
                        if)
                     #);
                   path.down
               if)
            exit objC[]
            #);
          findNode:
            (# pos: @integer;
               nd: ^generator.node;
            enter pos
            do pos -> (theEntry.entity).findNodeAtPos -> nd[];
            exit nd[]
            #);
          setBreak:
            (# pos: @integer; nd: ^generator.node;
               imp: ^generator.imperative;
               objD: ^generator.objectDesc;
            enter pos
            do pos -> (theEntry.entity).findNodeAtPos -> nd[];
               (if nd[] <> none then
	           'found: ' -> puttext;
                   nd[] -> getPatternName -> putline;
                   (if (ND.enclosingImperative -> imp[]) <> none then
                       'IMP: ' -> puttext;
                       imp[] -> getPatternName -> putline;
                       imp.getODorigin -> objD[];
                       'origin: ' -> puttext;
                       objD.pt -> putline;
                       (objD.descNo,imp.beginBCP) -> VM.execute.break;
                   if);
               if);
            exit imp[]
            #);
          breakAtNextImp:
            (# bcPos: @integer;
               imp: ^generator.imperative
            enter bcPos
            do 'breaAtNextImp: ' -> puttext; bcPos -> putint; newline;
               'in: ' -> puttext; theEntry.doPT -> putline;
               bcPos -> (theEntry.entity).findNextImp -> imp[] 
               (* What if no next imp?
                * I.e. at the end of (nested imps) in a do-part
                *)
            exit imp[]
            #);
          saveModuleToFile:
            (# F,B: ^BetaFile; T,S, newText: ^text;
               theModule: ^generator.Module;
            do (if isModified then
                   thisModule -> theModule[];
                   ('Save module',theName[]) -> LG.tTn;
                   'Save module: ' -> puttext; theName[] ->putline;
                   (if theModule[] <> none then
                       true -> theModule.doPT -> filter -> newText[];
                       ('closeSource',theModule.inFile.name) -> LG.tTn;
                       
                       (* if back-file exists, delete it *)
                       &BetaFile[] -> B[];                       
                       (theModule.inFile.name).copy -> T[]; 
                       '.back' -> T.append;
                       T[] -> B.name;
                       ('Back-file',B.name) -> LG.tTn;
                       (if B.entry.exists then 
                           ('Delete back-file',B.name) -> LG.tTn;
                           B.delete 
                       if);
                       (theModule.inFile.name).copy -> S[];
                       ('Source',S[]) -> LG.tTn;
                       
                       (* rename source to back-file *)
                       ('RenameSourceToBack',T[]) -> LG.tTn;
                       T[] -> theModule.inFile.entry.rename;
                       
                       (* create new source file *)
                       &BetaFile[] -> F[];
                       S[] -> F.name;
                       ('NewSource',S[]) -> LG.tTn;
                       F[] -> theModule.inFile[];
                       F.openWrite;

                       newText[] -> F.puttext; 
                       F.close
                    else
                       'No module!'->putline
                   if)
               if)
            #);          

          isModified: BooleanValue
            (# wasModified: @boolean
            do (if wasChanged then
                   true -> wasModified;
                   ('isModified',theText[]) -> LG.tTn;
                else
                   scan
                   (# kind: @char;              
                   do (*current[] -> putline;*) 
                      current.length -> current.inxGet -> kind;
                      (if kind (* consider using isCom *)
                       // '/' // '#' then  
                          ('isModified? /','') -> LG.tT;
                          (if wasChanged then (* this is not ok - if module is changed, then there should
                                               * be no sub modules to test for changes *)
                              ('wasChanged:/',theText[]) -> LG.tTn;
                              true -> wasModified 
                          if);
                          (if handles[inx][] <>  none then 
                              (* has been selected, may be modified *)
                              handles[inx].saveModuleToFile
                          if)
                       // '@'
                       // ' ' 
                       // '<'
                       // '!' then (* action-part *) 
                          (if wasChanged then 
                              ('IsModified',theText[]) -> LG.tTn;
                              true -> wasModified 
                          if);
                          (if (theText[] <> none) and wasChanged then
                              true -> wasModified ;
                              ('AndTheTextChanged',theText[]) -> LG.tTn
                           else
                              (if handles[inx][] <>  none then 
                                  (if handles[inx].isModified then
                                      true -> wasModified
                                  if)
                              if)
                          if)                      
                       else
                          ('scanModified: unknown kind',current[]) -> LG.tTn;
                      if);
               #)if);
               wasModified -> value
            #);
          enclosingModuleObj:
            (# objC: ^handle
            do (if isModule then
                   this(handle)[] -> objC[]
                else
                   enclosingHandle.enclosingModuleObj -> objC[]
               if)
            exit objC[]
            #);
          thisModule:
            (# cmp: ^generator.Module
            do (if isModule then
                   theModule[] -> cmp[]
                else
                   enclosingModule[] -> cmp[]                   
               if)
            exit cmp[]
            #);
          entityPathFromModule:
            (# T: ^text; md: ^generator.module
            do (if isModule then
                   thisModule -> md[];
                   (md.name.lexemSy).copy -> T[]
                else
                   enclosingHandle.entityPathFromModule -> T[];
                   '::'->T.append;
                   theName[] -> T.append
               if)
            exit T[]
            #);
          modulePath:
            (* we should check if this(handle) is actually a module
             * currently it may be any attribute
             *)
            (# path,N: ^text;
               md: ^generator.Module
            do (if enclosingHandle[] = none then 
                   compile.pathToBetaWorld.copy -> path[]
                else 
                   enclosingHandle.modulePath -> path[];
                   thisModule -> md[];
                   md.name.lexemSy -> path.append;
                   compile.dirCh -> path.put;
               if)
            exit path[]
            #);
               
          markAsChanged:
            (#
            do true -> wasChanged;
               saveModuleToFile;
            #);
          wasChanged: @boolean; 
          
          getModulePath:
            (# path: ^Text;
            do theModule.pathToFN.copy -> path[];
               compile.dirCh -> path.put;
               theModule.name.lexemSy -> path.puttext;
               '.bet' -> path.puttext;
            exit path[]
            #);
          refresh:
            (# path: ^Text;
               md: ^generator.Module;
            do (if isModule then
                   theModule.pathToFN.copy -> path[];
                   compile.dirCh -> path.put;
                   theModule.name.lexemSy -> path.puttext;
                   '.bet' -> path.puttext;
                   'refresh: ' -> puttext;
                   path[] -> putline;
                   path[] -> compile.pModule -> md[];
                   (if md[] <> NONE then
                       'success: ' -> puttext;
                       md.name.lexemSy -> putline;
                       compile.path.init;
                       theModule.pathToFN.copy -> compile.path.push;
                       md.handleDirModules;
                       compile.path.pop;
                       md[] -> theEntry[];
                       setup;
                   if);
               if);
            #);
          setUp:
            (# 
            do (if false then
                   'Handle: ' -> puttext; theName[] -> puttext; 
                   theEntry.doPT -> putline;
                   theEntry.PP -> putline
               if);
               
               (if theEntry[] = none then 'handle:setup:theEntryis:none'->putline if);
         
               theEntry.getEntries -> (dclNames[],DCLS[]);
               dclNames.range -> handles.new;
               
               (if theEntry##
                // compile.ObjectModule## then 
                   theEntry[] -> theModule[];     
                   true -> isModule
                // compile.ModuleItem## then
                   theEntry[] -> dir[]; dir.md[] -> theModule[];
                   true -> isModule
               if)
            #);
            
          dir: ^generator.ModuleItem; (* used by compiler *)
          
          isModule: @boolean;  
          enclosingModule,theModule: ^generator.Module;
          enclosingHandle: ^Handle;
          theName: ^text;          
       enter(theName[],theEntry[],enclosingModule[],enclosingHandle[])
       do setUp
       exit this(handle)[]
       #);   
  #)
