ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE '~beta/guienv/utils/prompts';
INCLUDE 'tableview';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'sequencecanvas';
INCLUDE 'newAttributeBox';
INCLUDE 'prompt';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE '../VM/betaVM';
INCLUDE '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/utils/guienvadds';
INCLUDE 'auxiliary';
---guienvlib:attributes---
SuperWorld:
  (# UserYes: (# exit 1 #);
     UserNo: (# exit 2 #);
     UserCancel: (# exit 3 #);
     
     defaults: @
       (# headH: (# exit 20 #);
          worldWindowW: (# exit 1200(*1420*) #);
          worldWindowH: (# exit 600(*760*) #);
          componentW: (# exit 480 #);
          componentH: (# exit 800 #);
          mainBrowserW: (# exit 380 #);
          mainBrowserH: (# exit 120 #);
          browserW: (# exit 92 #);
          browserH: (# exit 160 - 11 #); (* - 2 * borderWidth *)
          textEditW: (# exit 201 #);
          textEditH: (# exit 650 - 11 #);
       #);
     mkTextStyle:
       (# aTextStyle: ^textStyle
       do &textStyle[] -> aTextStyle[];
          'Times' -> aTextStyle.name;
          11 -> aTextStyle.size;
          inner
       exit aTextStyle[]
       #);
     mkPlainStyle: mkTextStyle
       (#
       do textFaces.plain -> aTextStyle.face;
       #);
     mkItalicStyle: mkTextStyle
       (#
       do textFaces.italic->aTextStyle.face;
       #);
     mkBoldStyle: mkTextStyle
       (#
       do textFaces.bold -> aTextStyle.face;
       #);

     promptUser:
       (# dialog: @PromptDialog
            (# onYes::
                 (#
                 do UserYes -> result;
                    dialog.close;
                 #);
               onNo::
                 (#
                 do UserNo -> result;
                    dialog.close;
                 #);
               onCancel::
                 (#
                 do UserCancel -> result;
                    dialog.close;
                 #);
            #);
          left, top: @integer;
          mainWidth, mainHeight: @integer;
          dialogWidth, dialogHeight: @integer;
          
          message: ^Text;
          title: ^Text;
          result: @integer;
          parent: ^Window;
       enter (parent[], title[], message[])
       do dialog.open;
          parent.position -> (left, top);
          parent.size -> (mainWidth, mainHeight);
          dialog.size -> (dialogWidth, dialogHeight);
          (left + (mainWidth - dialogWidth) div 2, top + 60) -> dialog.position;
          message[] -> dialog.changeLabel;
          title[] -> dialog.title;
          dialog.showModal;
       exit result
       #);
     getIcon:
       (# kind: @char; visibility: @integer;
          icon: ^RichPixMap
       enter(kind,visibility)
       do (if kind 
           // '*' then 
              cogwheel[] -> icon[]
           // '/' // '#' then 
              (if visibility
               //OSDvisibility_Open then
                  publicpackageIcon[] -> icon[]
               //OSDvisibility_SkipInternal then
                  packageIcon[]-> icon[]
               //OSDvisibility_Disguised then
                  privatepackageIcon[] -> icon[]
              if);
           // ' ' then
              patternIcon[] -> icon[]
           // ':'// '<' then
              virtualIcon[] -> icon[]
           // '^' then
              lightrefIcon[] -> icon[]
           // '@' then
              referenceIcon[]-> icon[]
           // '=' then
              simpleIcon[] -> icon[]
           // ']' then
              arrayIcon[] -> icon[]
          if);
       exit icon[]
       #);
     errorIcon: ^RichPixmap;
     patternIcon: ^RichPixmap;
     virtualIcon: ^RichPixmap;
     packageIcon: ^RichPixmap;
     publicpackageIcon: ^RichPixmap;
     privatepackageIcon: ^RichPixmap;
     simpleIcon: ^RichPixmap;
     arrayIcon: ^RichPixmap;
     referenceIcon: ^RichPixmap;
     lightrefIcon: ^RichPixmap;
     cogwheel: ^RichPixmap;
     
  do inner
  #);

BetaIndent:
  (* This pattern makes indentation for Beta code when text editing
   * It should be moved to miniCompiler as it is Beta specific
   * A similar indenter should be made for qbeta and placed in qbeta
   *)
  (# contentsSelectionStart:< (# m: @integer do inner exit m #);
     contentsSelectionSet:< (# a,b: @integer enter(a,b) do inner #);
     contentsSelectionGet:< (# a,b: @integer do inner exit(a,b) #);
     contentsInsert:< (# T: ^text enter T[] do inner #);
     contentsDelete:< (# do inner #);     
     doGetText:< (# B: ^Text do inner exit B[] #);
     
     mark: @integer;
     
     buffer: ^Text;
     
     SIMPLE_BLOCK: (# exit 0 #);
     STD_BLOCK: (# exit 1 #);
     IF_BLOCK: (# exit 2 #);
     FOR_BLOCK: (# exit 3 #);
     
     Array:
       (# storage: [0] ^Text;
          init:
            (# size: @integer;
            enter size
            do size -> storage.new;
            #);
          length:
            (# value: @integer;
            do storage.range -> value;
            exit value
            #);
          at:
            (# inx: @integer;
               value: ^Text;
            enter inx
            do storage[inx][] -> value[];
            exit value[]
            #);
          atPut:
            (# inx: @integer;
               value: ^Text;
            enter (inx, value[])
            do value[] -> storage[inx][];
            #);
       #);
     
     starts: @Array;
     ends: @Array;
     actionkeys: @Array;
     ifKeys: @Array;
     
     prepare:
       (# 
       do 3 -> starts.init;
          3 -> ends.init;
          (STD_BLOCK, '(#') -> starts.atPut; 
                          (STD_BLOCK, '#)') -> ends.atPut;
          (IF_BLOCK, '(if') -> starts.atPut;
                          (IF_BLOCK, 'if)') -> ends.atPut;
          (FOR_BLOCK, '(for') -> starts.atPut;
                            (FOR_BLOCK, 'for)') -> ends.atPut;
          
          7 -> actionkeys.init;
          (1, 'enter') -> actionkeys.atPut;
          (2, 'do') -> actionkeys.atPut;
          (3, 'exit') -> actionkeys.atPut;
          (4, '(#') -> actionkeys.atPut;
                  (5, '#)') -> actionkeys.atPut;
          (6, '(*') -> actionkeys.atPut;
                (7, '*)') -> actionkeys.atPut;
          
          3 -> ifKeys.init;
          (1, '//') -> ifKeys.atPut;
          (2, 'else') -> ifKeys.atPut;
          (3, 'then') -> ifKeys.atPut;
          
          contentsSelectionStart -> mark;
          doGetText -> buffer[];
       #);
     balanceBlock:
       (# end: @integer;
          begin: @integer;
       enter end
       do (# cnt: @integer;
             ch: @char;
             lines: @integer;
          do end -> begin;
             0 -> cnt;
             loop:
               (if cnt >= 0 then
                   begin -> buffer.inxGet -> ch;
                   (if ch = ')' then
                       cnt + 1 -> cnt;
                   if);
                   (if ch = '(' then
                       cnt - 1 -> cnt;
                   if);
                   begin - 1 -> begin;
                   (if begin > 0 then
                       restart loop;
                   if);
               if);
          #);
       exit begin
       #);
     getCurrentBlock:
       (# cnt: @integer;
          ch: @char;
          lines: @integer;
          begin: @integer;
          end: @integer;
       do (if mark > 0 then
              mark -> beginningOfLine -> endOfConstruct 
                -> end;
              end -> begin;
              0 -> cnt;
              loop:
                (if cnt >= 0 then
                    begin -> buffer.inxGet -> ch;
                    (if ch = ')' then
                        cnt + 1 -> cnt;
                    if);
                    (if ch = '(' then
                        cnt - 1 -> cnt;
                    if);
                    (if ch = 10 then
                        lines + 1 -> lines;
                    if);
                    begin - 1 -> begin;
                    (if begin > 0 then
                        restart loop;
                    if);
                 else
                    (if lines = 0 then
                        0 -> cnt;
                        restart loop;
                    if);
                if);
              mark -> endOfLine -> end;
          if);
       exit (begin, end)
       #);
     
     matchWord:
       (# begin: @integer;
          word: ^Text;
          result: @boolean;
       enter (begin, word[])
       do (if (begin + word.length) <= buffer.length then
              true -> result;
              check:
                (for inx: word.length repeat
                     (# ch1, ch2: @char;
                     do begin + inx -> buffer.inxGet -> ch1;
                        inx -> word.inxGet -> ch2;
                        (if ch1 <> ch2 then
                            false -> result;
                            leave check;
                        if);
                     #);
                for);
          if);
       exit result
       #);
     matchWords:
       (# begin: @integer;
          words: ^Array;
          result: @integer;
       enter (begin, words[])
       do search:
            (for inx: words.length repeat
                 (if (begin, inx -> words.at) 
                       -> matchWord then
                     inx -> result;
                     leave search;
                 if);
            for);
       exit result
       #);
     getColumn:
       (# begin: @integer;
          result: @integer;
          ch: @integer;
       enter begin
       do (if begin > 0 then
              begin -> buffer.inxGet -> ch;
              loop:
                (if ch <> 10 then
                    begin - 1 -> begin;
                    result + 1 -> result;
                    (if begin > 0 then
                        begin -> buffer.inxGet -> ch;
                        restart loop;
                    if);
                if);
          if);
       exit result
       #);
     
     beginningOfLine:
       (# current: @integer;
          begin: @integer;
       enter current
       do (# ch: @char;
          do current -> begin;
             (if begin > 0 then
                 begin -> buffer.inxGet -> ch;
                 loop:
                   (if ch <> 10 then
                       begin - 1 -> begin;
                       (if begin > 0 then
                           begin -> buffer.inxGet -> ch;
                           restart loop;
                       if);
                   if);
                 
             if);
          #);
       exit begin
       #);
     endOfConstruct:
       (# begin: @integer;
          end: @integer;
       enter begin
       do (# ch: @char;
             candidate: @boolean;
             marker: @integer;
          do begin + 1 -> end;
             (if end <= buffer.length then
                 end -> buffer.inxGet -> ch;
                 loop:
                   (if ch <> 10 then
                       (if ch = ')' then
                           true -> candidate;
                           end -> marker;
                       if);
                       end + 1 -> end;
                       (if end <= buffer.length then
                           end -> buffer.inxGet -> ch;
                           restart loop;
                       if);
                   if);
                 (if candidate then
                     marker -> end;
                 if);
             if);
             end - 1 -> end;
          #);
       exit end
       #);
     endOfLine:
       (# current: @integer;
          end: @integer;
       enter current
       do (# ch: @char;
          do current + 1 -> end;
             (if end <= buffer.length then
                 end -> buffer.inxGet -> ch;
                 loop:
                   (if ch <> 10 then
                       end + 1 -> end;
                       (if end <= buffer.length then
                           end -> buffer.inxGet -> ch;
                           restart loop;
                       if);
                   if);                                     
             if);
             end - 1 -> end;
          #);
       exit end
       #);
     startOfText:
       (# begin: @integer;
          end: @integer;
          ch: @char;
       enter begin
       do begin + 1 -> end;
          (if end <= buffer.length then
              end -> buffer.inxGet -> ch;
              loop:
                (if ch = 32 then
                    end + 1 -> end;
                    (if end <= buffer.length then
                        end -> buffer.inxGet -> ch;
                        restart loop;
                    if);
                if);
          if);
          end - 1 -> end;
       exit end
       #);
     indentLine:
       (# begin: @integer;
          end: @integer;
          ilevel: @integer;
       enter (begin, end, ilevel)
       do (# clevel: @integer;
             delta: @integer;
             txt: ^Text;
             a, b: @integer;
          do end - begin -> clevel;
             ilevel - clevel -> delta;
             contentsSelectionGet -> (a, b);
             (if begin <= a then
                 a + delta -> a;
                 b + delta -> b;
             if);
             
             (if delta > 0 then
                 (begin, begin) -> contentsSelectionSet;
                 &Text[] -> txt[];
                 (for delta repeat
                      ' ' -> txt.put;
                 for);
                 txt[] -> contentsInsert;
              else
                 (begin, begin - delta) 
                   -> contentsSelectionSet;
                 contentsDelete;
             if);
             (a, b) -> contentsSelectionSet;
          #);
       #);
     lookingAt:
       (# index: @integer;
          ch: @char;
       enter index
       do index -> buffer.inxGet -> ch;
          'LOOK: ' -> puttext;
          ch -> putint;
          newline;
       #);
     processBlock:
       (# begin, end: @integer;
       enter (begin, end)
       do main:
            (# result: @integer;
               line0: @integer;
               line1: @integer;
               ilevel: @integer;
               block: @boolean;
            do end -> beginningOfLine -> line0;
               line0 -> startOfText -> line1;
               begin -> getColumn -> ilevel;
               (begin, starts[]) -> matchWords -> result;
               (if result
                //SIMPLE_BLOCK then
                   ilevel + 1 -> ilevel;
                //STD_BLOCK then
                   (# k: @integer;
                   do (line1, actionkeys[]) 
                        -> matchWords -> k;
                      (if k > 0 then
                          (if k = 4 then
                              ilevel + 3 -> iLevel;
                           else
                              (if k = 6 then
                                  ilevel + 3 -> iLevel;
                               else
                                  true -> block;
                              if);
                          if);
                       else
                          ilevel + 3 -> ilevel;
                      if);
                   #);
                //IF_BLOCK then
                   (# k: @integer
                   do (line1, ends[]) -> matchWords -> k;
                      (if k = 0 then
                          (if ((line1, ifKeys[]) 
                                -> matchWords) <> 0 then
                              ilevel + 1 -> ilevel;
                           else
                              ilevel + 4 -> ilevel;
                          if);
                      if);
                   #);
                //FOR_BLOCK then
                   ilevel + 5 -> ilevel;
               if);
               (if not block then
                   (if (line1, '->') -> matchWord then
                       iLevel + 2 -> iLevel;
                    else
                       (# previous: @integer;
                       do (line1, blanks[]) 
                            -> skipBackwards -> previous;
                          (if previous <= 0 then
                              '\n!!! processBlock: previos <=0'
                                -> putline;
                              leave main
                          if);
                          (if (previous -> buffer.inxGet) 
                              = ')' then
                              previous - 1 -> previous;
                              previous -> balanceBlock 
                                -> previous;
                          if);
                          (if previous > 0 then
                              (previous, blanks[]) 
                                -> skipBackwards -> previous;
                              (previous, identifier[]) 
                                -> skipBackwards -> previous;
                              (previous, blanks[]) 
                                -> skipBackwards -> previous;
                              (previous, specifier[]) 
                                -> skipBackwards -> previous;
                              (previous, blanks[]) 
                                -> skipBackwards -> previous;
                              (if (previous -> buffer.inxGet)
                                  = '<' then
                                  previous - 1 -> previous;
                              if);
                              (if (previous -> buffer.inxGet)
                                  = ':' then
                                  ilevel + 2 -> ilevel;
                              if);
                           else
                              0 -> ilevel;
                          if);
                       #);
                   if);
               if);
               (line0, line1, ilevel) -> indentLine;
            #);
       #);
     getCurrenLine:
       (# begin, end: @integer;
       do mark -> beginningOfLine -> begin;
          mark -> endOfLine -> end;
       exit (begin, end)
       #);
     getCurrentConstruct:
       (# begin, end: @integer
       do mark -> beginningOfLine -> begin;
          begin -> endOfConstruct -> end;
       exit (begin, end)
       #);
     CharacterClass:
       (# match:<
            (# ch: @char;
               result: @boolean;
            enter ch
            do INNER;
            exit result
            #);
       #);
     blanks: @CharacterClass
       (# match::
            (#
            do (ch = ' ') or (ch = 10) -> result;
            #);
       #);
     identifier: @CharacterClass
       (# match::
            (#
            do (if ch -> ascii.isLetter then
                   true -> result;
                else
                   (if ch -> ascii.isDigit then
                       true -> result;
                    else
                       (if ch = '_' then
                           true -> result;
                       if);
                   if);
               if);
            #);
       #);
     specifier: @CharacterClass
       (# match::
            (#
            do (ch = '@') or (ch = '^') -> result;
            #);
       #);
     skipBackwards:
       (# begin: @integer;
          end: @integer;
          chars: ^CharacterClass;
          ch: @integer;
       enter (begin, chars[])
       do begin -> end;
          loop:
            (if end > 0 then
                end -> buffer.inxGet -> ch;
                (if ch -> chars.match then
                    end - 1 -> end;
                    restart loop;
                if)
            if)
       exit end
       #);
  do prepare;
     getCurrentBlock -> processBlock;
  #);
