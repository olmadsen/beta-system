ORIGIN '~beta/postwimp/graphicscanvas/diagram';
INCLUDE '~beta/guienv/controls';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/graphicscanvas/widgets';
INCLUDE  '~beta/guienv/private/datastructures/sequence';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE 'objectContent';
INCLUDE 'dialogs';
INCLUDE 'reflector';
INCLUDE 'SuperSequenceDiagram';
INCLUDE 'sequencediagram';

--windowLib: attributes --

SequenceCanvas: FigureCanvas
  (* Holds the grahic elements of a SequenceDiagram;
   * an instance, interior, is declared in SequenceWindow
   *)
  (# refresh:
       (#
       do sequence.refreshExecution;
       #);
     sequence: @SequenceDiagram
       (# showCode::
            (#
            do caller[] -> THIS(SequenceCanvas).showCode;
            #);
          showDescriptor::
            (#
            do desc[] -> THIS(SequenceCanvas).showDescriptor;
            #);
          showNode::
            (#
            do node[] -> THIS(SequenceCanvas).showNode;
            #);
          showContext::
            (#
            do THIS(SequenceCanvas).showContext;
            #);
          showCurrent::
            (#
            do THIS(SequenceCanvas).showCurrent;
            #);
       #);
     onStart:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart -> pause;
       exit pause
       #);
     onAlloc:       
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (*'**** onAlloc:A:'->putline;*)
          (caller[], self[], origin[], bc, isObj, isIndexed) 
       -> sequence.onAlloc
       -> pause;
          (*'**** onAlloc:Ae:' -> putline;*)
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          preemptive: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) -> sequence.onDo 
            -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn -> pause;
       exit pause
       #);
     onBreak:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onBreak -> pause;
       exit pause
       #);
     onSuspend:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          preemptive: @boolean;
          pause: @boolean;
          
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) -> sequence.onSuspend -> pause;
       exit pause
       #);
     onResume:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          preemptive: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) -> sequence.onResume -> pause;
       exit pause
       #);
     onVPush:
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVPush -> pause;
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.RunTimeObject;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRPush -> pause;
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVStore -> pause;
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.RunTimeObject;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRStore -> pause;
       exit pause
       #);
     onBinOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onBinOp -> pause;
       exit pause
       #);
     onUnOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onUnOp -> pause;
       exit pause
       #);
     onJmpGT:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onJmpGT -> pause;
       exit pause
       #);
     onPop:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onPop -> pause;
       exit pause
       #);
     onError:
       (# msg: ^Text;
       enter msg[]
       do msg[] -> sequence.onError;
       #);
     getMenu::
       (#
       do 0 -> panx;
          update;
       #);
     panner: @Tool
       (# x0: @integer;
          y0: @integer;
          o0: @integer;
          p0: @real;
          onMouseDown::
            (#
            do 
               
               y -> y0;
               x -> x0;
               sequence.offset -> o0;
               panx -> p0;
            #);
          onMouseMove::
            (# dy: @integer;
               dx: @integer;
            do y - y0 -> dy;
               x - x0 -> dx;
               o0 + dy -> sequence.offset;
               p0 + dx -> panx;
               (if sequence.offset > 0 then
                   0 -> sequence.offset;
               if);
               sequence.refresh;
            #);
          onMouseUp::
            (#
            do
            #);
       #);
     
     open::
       (#
       do sequence.init;
          sequence[] -> add;
          panner[] -> clickTool[];
       #);
     eventHandler::
       (# onRefresh::
            (#
            do 
            #);
       #);
     showCode:<
       (# caller: ^objDesc.RunTimeObject;
       enter caller[]
       do INNER;
       #);
     showDescriptor:<
       (# desc: ^ObjDesc;
       enter desc[]
       do INNER;
       #);
     showNode:<
       (# node: ^Tree.TopNode;
       enter node[]
       do INNER;
       #);
     showContext:<
       (#
       do INNER;
       #);
     showCurrent:<
       (#
       do INNER;
       #);
  #);
SequenceWindow: SubWindow
  (* A window enclosing a SequenceDiagram;
   * the local object, interior, is the SequenceCanvas holding the
   * graphical figures of the SrequenceDiagram
   *)
  (# done: @boolean;
     updater: @Timer
       (# count: @integer;
          action:: (# do check #);
       #);
     check:
       (# ready: @boolean;
       do (if not done then
              (if machine[] <> NONE then
                  machine.ready -> ready;
              if);
              (if ready then
                  enable;
                  head.update;
                  true -> done;
              if);
          if);
       #);
     machine: ^| systemenv.betaVM;
     maximum: @integer;
     onClose:
       (#
       do updater.stop;
          (if navi[] <> NONE then
              navi.onClose;              
          if);
       #);
     onExpand::
       (# width, height: @integer;
       do '-- on-expand' -> putline;
          THIS(SubWindow).size -> (width, height);
          (width, maximum) -> THIS(SubWindow).size;
          true -> interior.bindBottom;
          true -> console.bindBottom;
          false -> console.bindTop;
       #);
     onCollapse::
       (# width, height: @integer;
       do false -> interior.bindBottom;
          false -> console.bindBottom;
          true -> console.bindTop;
          THIS(SubWindow).size -> (width, height);
          (width, 20 + 2 * theBorderWidth) -> THIS(SubWindow).size;
          height -> maximum;
       #);
     controls: @Sequence
       (# Element:: Control;
       #);
     disable:
       (#
       do head.row.scan
          (# btn: ^FigureCanvas.IconButton;
          do(if current## <= head.IconButton## then
                 current[] -> btn[];
                 btn.disable;
             if);
          #);
       #);
     enable:
       (#
       do head.row.scan
          (# btn: ^FigureCanvas.IconButton;
          do (if current## <= head.IconButton## then
                 current[] -> btn[];
                 btn.enable;
             if);
          #);
       #);
     heading::
       (# st: @TextStyle;
          ActionButton: IconButton
            (# onAction:<
                 (#
                 do INNER;
                 #);
               onExpand::
                 (#
                 do onAction;
                 #);
               onCollapse::
                 (#
                 do onAction;
                 #);
            #);
          playBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
		        interior.sequence.continue;
                    if);
                 #);
            #);
          stopBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
                        interior.sequence.doClose;
		        onClose;
                    if);
                 #);
            #);
          stepBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
		    	interior.sequence.step;
                    if);
                 #);
            #);
          stepOverBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
                        interior.sequence.stepOver;
                    if);
                 #);
            #);
          stepOutBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
                        interior.sequence.stepOut;
                    if);
                 #);
            #);
          valuesCheckBox: @Toggler
            (# onExpand::
                 (#
                 do on -> interior.sequence.showValues;
                    interior.sequence.refreshExecution;
                 #);
               onCollapse::
                 (#
                 do on -> interior.sequence.showValues;
                    interior.sequence.refreshExecution;
                 #);
            #);
          originsCheckBox: @Toggler
            (#
            #);
          allocationsCheckBox: @Toggler
            (#
            #);
          historyCheckBox: @Toggler
            (#
            #);
          clearHistoryBtn: @CharButton
            (# onClick::
                 (#
                 do interior.sequence.clearHistory;
                 #);
            #);
          saveLogButton: @CharButton
            (# onClick::
                 (# output: @File;
                    i: @integer;
                 do 'log.txt' -> output.name;
                    output.openWrite;
                    events.scan
                    (# 
                    do i + 1 -> i;
                       i -> output.putInt
                       (#
                       do 6 -> width;
                       #);
                       ': ' -> output.puttext;
                       current[] -> output.putline;
                    #);
                    output.close;
                 #);
            #);
          gotoButton: @CharButton
            (# onClick::
                 (# dialog: @GoDialog
                      (# onConfirm::
                           (# value: @integer;
                           do dialog.countFld.integerContents -> value;
                              (if value -> goto then
                                  dialog.close;
                              if);
                           #);
                         onCancel::
                           (#
                           do dialog.close;
                           #);
                      #);
                    value: @integer;
                 do count -> dialog.open;
                    dialog.showModal;
                 #);
            #);
          nextButton: @CharButton
            (# onClick::
                 (#
                 do count + 1 -> goto;
                 #);
            #);
          createImageFigure:
            (# image: ^RichPixmap;
               item: ^ImageFigure;
            enter image[]
            do &ImageFigure[] -> item[];
               item.init;
               image[] -> item.content;
               
            exit item[]
            #);
          playImage: ^RichPixmap;
          playHiliteImage: ^RichPixmap;
          playGreyImage: ^RichPixmap;
          stopImage: ^RichPixmap;
          stopHiliteImage: ^RichPixmap;
          stopGreyImage: ^RichPixmap;
          stepImage: ^RichPixmap;
          stepHiliteImage: ^RichPixmap;
          stepGreyImage: ^RichPixmap;
          stepOverImage: ^RichPixmap;
          stepOverHiliteImage: ^RichPixmap;
          stepOverGreyImage: ^RichPixmap;
          stepOutImage: ^RichPixmap;
          stepOutHiliteImage: ^RichPixmap;
          stepOutGreyImage: ^RichPixmap;
          checkOffImage: ^RichPixmap;
          checkOnImage: ^RichPixmap;
          checkOn: ^ImageFigure;
          checkOff: ^ImageFigure;
          
         
          
          open::
            (# construct: @Construction;
               str1: ^TextFigure;
            do 'Sequence Diagram' -> label;
               24 -> construct.hSpace -> row.add;
               'icons\\play.png' -> loadImage -> playImage[];
               'icons\\play-hilite.png' -> loadImage -> playHiliteImage[];
               'icons\\play-grey.png' -> loadImage -> playGreyImage[];
               (playImage[] -> createImageFigure, 
               playHiliteImage[] -> createImageFigure)
                 -> playBtn.init;
               playGreyImage[] -> createImageFigure -> playBtn.grey[];
               playBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               
	       'icons\\stop.png' -> loadImage -> stopImage[];
               'icons\\stop-hilite.png' -> loadImage -> stopHiliteImage[];
               'icons\\stop-grey.png' -> loadImage -> stopGreyImage[];
               (stopImage[] -> createImageFigure,
               stopHiliteImage[] -> createImageFigure)
                 -> stopBtn.init;
               stopGreyImage[] -> createImageFigure -> stopBtn.grey[];
               stopBtn[] -> row.add;
               16 -> construct.hSpace -> row.add;
               
               'icons\\step-into.png' -> loadImage -> stepImage[];
               'icons\\step-into-hilite.png' -> loadImage -> stepHiliteImage[];
               'icons\\step-into-grey.png' -> loadImage -> stepGreyImage[];
               (stepImage[] -> createImageFigure,
               stepHiliteImage[] -> createImageFigure)
                 -> stepBtn.init;
               stepGreyImage[] -> createImageFigure -> stepBtn.grey[];
               stepBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'icons\\step-over.png' -> loadImage -> stepOverImage[];
               'icons\\step-over-hilite.png' -> loadImage -> stepOverHiliteImage[];
               'icons\\step-over-grey.png' -> loadImage -> stepOverGreyImage[];
               (stepOverImage[] -> createImageFigure,
               stepOverHiliteImage[] -> createImageFigure)
                 -> stepOverBtn.init;
               stepOverGreyImage[] -> createImageFigure -> stepOverBtn.grey[];
               stepOverBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'icons\\step-out.png' -> loadImage -> stepOutImage[];
               'icons\\step-out-hilite.png' -> loadImage -> stepOutHiliteImage[];
               'icons\\step-out-grey.png' -> loadImage -> stepOutGreyImage[];
               (stepOutImage[] -> createImageFigure,
               stepOutHiliteImage[] -> createImageFigure)
                 -> stepOutBtn.init;
               stepOutGreyImage[] -> createImageFigure -> stepOutBtn.grey[];
               stepOutBtn[] -> row.add;
               
               24 -> construct.hSpace -> row.add;
               
               'Verdana' -> st.name;
               8 -> st.size;
               
               
               'icons\\check-off.png' -> loadImage -> checkOffImage[];
               'icons\\check-on.png' -> loadImage -> checkOnImage[];
               
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> valuesCheckBox.init;
               valuesCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'Values' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               
               16 -> construct.hSpace -> row.add;
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> originsCheckBox.init;
               originsCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'Origins' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               
               16 -> construct.hSpace -> row.add;
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> allocationsCheckBox.init;
               allocationsCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'Allocations' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               
               16 -> construct.hSpace -> row.add;
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> historyCheckBox.init;
               historyCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'History' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Clear' -> clearHistoryBtn.init;
               st[] -> clearHistoryBtn.style;
               clearHistoryBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Save' -> saveLogButton.init;
               st[] -> saveLogButton.style;
               saveLogButton[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Go' -> gotoButton.init;
               st[] -> gotoButton.style;
               gotoButton[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Next' -> nextButton.init;
               st[] -> nextButton.style;
               nextButton[] -> row.add;
            #);
       #);
     LOGGING: (# exit false #);
     reflection:
       (# target: ^ObjDesc.RunTimeObject;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.RunTimeObject;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     keepHistory:
       (# value: @boolean;
       enter value
       do value -> interior.sequence.doKeepHistory;
       #);
     clearHistory:
       (#
       do interior.sequence.clearHistory;
       #);
     
     setCompiler:
       (# reference: ^Tree;
       enter reference[]
       do reference[] -> interior.sequence.compiler[];
       #);
     setVM:
       (# reference: ^| systemenv.betaVM;
       enter reference[]
       do reference[] -> machine[];
          reference[] -> interior.sequence.VM[];
       #);
     setLog:
       (# reference: ^Object;
       enter reference[]
       do reference[] -> interior.sequence.L[];
       #);
     
     events: @Sequence
       (# element:: Text;
       #);
     printCurrent:
       (# j: @integer;
       do events.size -> j;
          j -> screen.putInt
          (#
          do 6 -> width;
          #);
          ': ' -> puttext;
          j -> events.get -> putline;
       #);
     printTail:
       (# j: @integer;
          K: @integer;
       do '--- break ---' -> putline;
          (10, events.size) -> min -> K;
          (for i: K repeat
               events.size - K + i -> j;
               j -> screen.putInt
               (#
               do 6 -> width;
               #);
               ': ' -> puttext;
               j -> events.get -> putline;
          for);
       #);
     
     goto:
       (# value: @integer;
          result: @boolean;
       enter value
       do (if value > count then
              value -> breakCount;
              interior.sequence.continue;
              true -> result;
          if);
       exit result
       #);
     
     breakCount: @integer;
     processEvent:
       (# pause: @boolean;
          force:
            (#
            do interior.sequence.refreshExecution;
               true -> pause;
            #);
          description:<
            (# string: ^Text;
            do &Text[] -> string[];
               INNER;
            exit string[]
            #);
          log:
            (#
            do count + 1 -> count;
               description -> events.append;
            #);
       do log;
          INNER;
          (if (not pause) then
              (if count = breakCount then
                  true -> interior.sequence.stepping;
                  force;
              if);
          if);
          (if false then
              printTail;
          if);
          (if false then
	      (if pause then
                  description -> puttext;
                  ' | ' -> puttext;
                  'pause' -> putline;
              if);
          if);
       exit pause
       #);
     
     onStart: processEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          
          description::
            (#
            do '[start ' -> string.puttext;
              'caller: ' -> string.puttext;
              caller[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'self: ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do head.historyCheckBox.on -> keepHistory;
          true -> interior.sequence.solid;
          (caller[], self[], origin[], bc) -> interior.onStart -> pause;
       #);
     onAlloc: processEvent
       (* called from worldVM::onAlloc *)
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          description::
            (#
            do '[alloc ' -> string.puttext;
              'caller: ' -> string.puttext;
              caller[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'self: ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (*'**** onAlloc:from:worldVM' -> putline;*)
          true -> interior.sequence.solid;
          head.historyCheckBox.on -> keepHistory;
          not head.allocationsCheckBox.on -> interior.sequence.skipAllocations;
          (caller[], self[], origin[], bc, isObj, isIndexed) 
            -> interior.onAlloc 
            -> pause;
          (*'**** onAlloc:rtnTo:worldVM' -> putline*)
       #);
     onDo: processEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          preemptive: @boolean;
          bc: @integer;
          description::
            (#
            do '[do ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' | ' -> string.puttext;
               self[] 
                 -> interior.sequence.objectOriginOf 
                 -> nameOf 
                 -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc, preemptive)
       do (* '**** onDo:from:worldVM:'->putline;*)
          true -> interior.sequence.solid;
          head.historyCheckBox.on -> keepHistory;
          not head.allocationsCheckBox.on -> interior.sequence.skipAllocations;
          (caller[], self[], origin[], bc, preemptive) 
            -> interior.onDo 
            -> pause;
          (*'**** onDo:rtnTo:worldVM:'->putline;*)
       #);
     onReturn: processEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          description::
            (#
            do '[return ' -> string.puttext;
               self[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'origin: ' -> string.puttext;
               origin[] -> nameOf -> string.puttext;
               ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do true -> interior.sequence.solid;
          head.historyCheckBox.on -> keepHistory;
          not head.allocationsCheckBox.on -> interior.sequence.skipAllocations;
          (caller[], self[], origin[], bc) -> interior.onReturn -> pause
       #);
     onBreak: processEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          description::
            (#
            do '[break ' -> string.puttext;
               self[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'origin: ' -> string.puttext;
               origin[] -> nameOf -> string.puttext;
               ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> interior.onBreak -> pause;
       #);
     onSuspend: processEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          preemptive: @boolean;
          description::
            (#
            do '[suspend ' -> string.puttext;
               'caller: ' -> string.puttext;
               caller[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'self: ' -> string.puttext;
               self[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'origin: ' -> string.puttext;
               origin[] -> nameOf -> string.puttext;
               ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) 
            -> interior.onSuspend 
            -> pause;
       #);
     onResume: processEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          preemptive: @boolean;
          description::
            (#
            do '[resume ' -> string.puttext;
               'caller: ' -> string.puttext;
               caller[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'self: ' -> string.puttext;
               self[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'origin: ' -> string.puttext;
               origin[] -> nameOf -> string.puttext;
               ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) 
            -> interior.onResume 
            -> pause;
       #);
     printObjectV:
       (# obj: ^ObjDesc.RunTimeObject;
          value: ^Text;
       enter obj[]
       do obj.myName -> value[];
       exit value[]
       #);
     onVPush: processEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          description::
            (#
            do '[push ' -> string.puttext;
               value -> string.putint;
               ' | to: ' -> string.puttext;
               to[] -> printObjectV -> string.puttext;
               (if popRStack then
                   ' | pop' -> string.puttext;
               if);
               ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, isIndexed, inx, value) 
            -> interior.onVPush 
            -> pause;
       #);
     onRPush: processEvent
       (# from, to: ^ObjDesc.RunTimeObject; 
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.RunTimeObject;
          description::
            (#
            do '[push ' -> string.puttext;
               (if refValue[] <> NONE then
                   refValue.myName -> string.puttext;
                else
                   'NONE' -> string.puttext;
               if);
	       ' | to: ' -> string.puttext;
               to[] -> printObjectV -> string.puttext;
               (if popRStack then
                   ' | pop' -> string.puttext;
               if);
               ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, refValue[])
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRPush -> pause;
       #);
     onVStore: processEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          description::
            (#
            do '[store ' -> string.puttext;
              value -> string.putint;
              ' | from: ' -> string.puttext;
              
              from[] -> printObjectV -> string.puttext;
              (if popRStack then
                  ' | pop' -> string.puttext;
              if);
              ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, isIndexed, inx, value) 
            -> interior.onVStore 
            -> pause;
       #);
     onRStore: processEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.RunTimeObject;
          description::
            (#
            do '[store ' -> string.puttext;
               (if refValue[] <> NONE then
                   refValue.myName -> string.puttext;
                else
                   'NONE' -> string.puttext;
               if);
               ' | from: ' -> string.puttext;
               from.myName -> string.puttext;
               (if popRStack then
                   ' | pop' -> string.puttext;
               if);
               ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, refValue[])
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, refValue[]) 
            -> interior.onRStore 
            -> pause;
       #);
     onBinOp: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          description::
            (#
            do '[bin-op  ' -> string.puttext;
              operator[] -> string.puttext;
              ' | ' -> string.puttext;
              to.myName -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onBinOp -> pause;
       #);
     onUnOp: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          description::
            (#
            do '[un-op  ' -> string.puttext;
              operator[] -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onUnOp -> pause;
       #);
     onJmpGT: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          description::
            (#
            do '[jmp-gt  ' -> string.puttext;
               operator[] -> string.puttext;
               ']' -> string.puttext;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onJmpGT -> pause;
       #);
     onPop: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          description::
            (#
            do '[pop  ' -> string.puttext;
               value -> string.putint;
               ']' -> string.puttext;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onPop -> pause;
       #);
     onError:
       (# msg: ^Text;
          line: ^Text;
       enter msg[]
       do '--- ERROR ---' -> putline;
          msg.reset;
          msg.scanWhiteSpace;
          msg.getline -> line[];
          msg.getline -> line[];
          line[] -> putline;
          (if false then
              msg[] -> interior.onError
           else
              line[] -> interior.onError;
          if);
          '-------------' -> putline;
          disable;
          head.stopBtn.enable;
          head.update;
	  interior.refresh;
          (none,msg[],'Fatal error') -> alertUser;
       #);
     execute:
       (# objC: ^ObjectContent.handle; isXbeta: @boolean; runMode: @integer
       enter(objC[],runMode,isXbeta)
       do (objC[],runMode,isXbeta) -> interior.sequence.execute;
       #);
     
     interior: @SequenceCanvas 
       (# showCode::
            (#
            do caller[] -> THIS(SequenceWindow).showCode; 
            #);
          showDescriptor::
            (#
            do desc[] -> THIS(SequenceWindow).showDescriptor;
            #);
          showNode::
            (#
            do node[] -> THIS(SequenceWindow).showNode;
            #);
          showContext::
            (#
            do printTail;
            #);
          showCurrent::
            (#
            do printCurrent;
            #);
       #);
     
     console: @ TextEditor
       (# contentsType::
            (# eventHandler::
                 (# onKeyDown::
                      (#
                      do (if waiting then
                             (if ch//10//13 then
                                 buffer.clear;
                                 (marker, length) -> scanText
                                 (#
                                 do ch -> buffer.put;
                                 #);
                                 buffer.newline;
                                 buffer.reset;
                                 stopWaiting;
                             if);
                         if);
                      #);
                 #);
            #);
          put:
            (# ch: @char;
            enter ch
            do (# length: @integer;
                  txt: ^Text;
               do contents.length -> length;
                  (length, length) -> contents.selection.set;
                  &Text[] -> txt[];
                  ch -> txt.put;
                  txt[] -> contents.insert;
                  contents.selection.scrollIntoView;
               #);
            #);
       #);
     
     MessageCanvas: Canvas
       (# label: @StaticText
            (# st: @TextStyle;
               open::
                 (# 
                 do 'Arial' -> st.name;
                    40 -> st.size;
                    st[] -> style;
                    'Waiting for input in console' -> label;
                 #);
            #);
          open::
            (#
            do label.open;
               label.fitToContents; 
            #);
          layout:
            (# w, h: @integer;
               width, height: @integer;
               x, y: @integer;
            do size -> (w, h);
               label.size -> (width, height);
               (w - width) / 2 -> x;
               (h - height) / 2 -> y;
               (x, y) -> label.position;
             
            #);
       #);
     splash: ^MessageCanvas;
     
     waiting: @boolean;
     marker: @integer;
     buffer: @text;
     
     startWaiting:
       (#
       do THIS(Window).hide;
          disable;
          controls.scan
          (#
          do current.disable;
          #);
          console.contents.length -> marker;
          (marker, marker) -> console.contents.selection.set;
          console.contents[] -> target;
          true -> waiting;
          (# w, h: @integer;
             width, height: @integer;
             margin: @integer;
             y: @integer;
          do &MessageCanvas[] -> splash[];
             interior[] -> splash.open;
             interior.size -> (w, h);
             20 -> margin;
             w - 2 * margin -> width;
             120 -> height;
             (width, height) -> splash.size;
             h / 3 - (height / 2) -> y;
             (if y < margin then
                 margin -> y;
             if);
             (margin, y) -> splash.position;
             splash.layout;
          #);
             
          THIS(Window).showModal;
       #);
     stopWaiting:
       (#
       do false -> waiting;
          THIS(Window).hide;
          splash.close;
          NONE -> splash[];
          controls.scan
          (#
          do current.enable;
          #);
          THIS(SequenceWindow).enable;
          enable;
          THIS(Window).show;
       #);
     
     put:
       (# ch: @char;
       enter ch
       do ch -> console.put;
       #);
     get:
       (# ch: @char;
       do (if not buffer.eos then
              buffer.get -> ch;
           else
              startWaiting;
              buffer.get -> ch;
          if);
       exit ch
       #);
     CONSOLE_HEIGHT: (# exit 120 #);
     open::
       (# w, h: @integer;
          width, height: @integer;
          create::
            (#
            do false -> flexible;
            #);
       do 100 -> updater.start;
          hide;
          THIS(Window).size -> (w, h);
          (640, 480) -> size;
          
          interior.open;
          (2, 22) -> interior.position;
          size -> (width, height);
          (width - 4, height - 24 - CONSOLE_HEIGHT) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
          
          
          console.open;
          (2, height - CONSOLE_HEIGHT) -> console.position;
          (width - 4, CONSOLE_HEIGHT - 2) -> console.size;
          true -> console.bindBottom;
          true -> console.bindRight;
          false -> console.bindTop;
          disable;
       #);
     close::
       (#
       do updater.stop;
       #);
     showCode:
       (# caller: ^objDesc.RunTimeObject;
       enter caller[]
       do (if navi[] <> NONE then
              caller[] -> navi.showCode;
          if);
       #);
     showDescriptor:
       (# desc: ^ObjDesc;
       enter desc[]
       do (if navi[] <> NONE then
              desc[] -> navi.showDescriptor;
          if);
       #);
     showNode:
       (# node: ^Tree.TopNode;
       enter node[]
       do (if node[] <> NONE then
              node[] -> navi.showNode;
          if);
       #);
     navi: ^Navigator;
  #);

