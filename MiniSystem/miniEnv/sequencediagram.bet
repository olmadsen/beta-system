ORIGIN '~beta/postwimp/graphicscanvas/diagram';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/graphicscanvas/widgets';
INCLUDE  '~beta/guienv/private/datastructures/sequence';
INCLUDE '../miniCompiler/generator';
INCLUDE 'objectContent';
INCLUDE 'dialogs';

-- lib: attributes --

Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);
SimpleKind:
  (# exit 1 #);
PatternKind:
  (# exit 2 #);
ReferenceKind:
  (# exit 3 #);
RepetionKind:
  (# exit 4 #);
VirtualKind:
  (# exit 5 #);

ObjectReflector:
  (# template: ^ObjDesc.Template;
     struct: ^Pattern;
     init:
       (# theTemplate: ^ObjDesc.Template;
       enter theTemplate[]
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
     descriptionOf:
       (# template: ^ObjDesc.Template;
          description: ^Text;
       enter template[]
       do (# name: ^Text;
             ch: @char;
          do template.myName -> name[];
             (if name.length < 0 then
                 1 -> name.inxGet -> ch;
                 (if ch//'a'//'A'//'e'//'E'//'i'//'I'//'o'//'O'//'u'//'U' then
                     'an ' -> description[];
                  else
                     'a ' -> description[];
                 if);
                 name[] -> description.append;
             if);
          #);
       exit description[]
       #);
     collectSimples:
       (# compiler: ^generator;
          simples: ^AttributeList;
       enter compiler[]
       do (# descNo: @integer;
             theObjectDesc: ^generator.ObjectDesc;
             isRef: @boolean;
             off: @integer;
          do &AttributeList[] -> simples[];
             template.myDescInx -> descNo;
             descNo -> compiler.newDesc.getOD -> theObjectDesc[];
             (if theObjectDesc[] <> NONE then
                 theObjectDesc.scanAllDecls
                 (# name: ^Text;
                    simple: ^AttributeReflector;
                    kind: @integer;
                    offset: @integer;
		    origin::
                      (#
                      do &AttributeReflector[] -> simple[];
                         (name[], off, ReferenceKind) -> simple.init;
                         simple[] -> simples.append;
                      #);
                 do (currentND.lexemSy).copy -> name[];
                    currentND.off -> off;
                    (if off > 0 then 
                        off -> offset;
                        (if currentDcl.IT.isSimple then
                            SimpleKind -> kind;
                         else
                            (if currentDcl.IT.isVirtual then
                                VirtualKind -> kind;
                             else
                                ReferenceKind -> kind;
                            if);
                        if)            
                     else
                        (if currentDcl.IT.isIndexed then
                            RepetionKind -> kind;
                            offset + 1 -> off;
                         else
                            PatternKind -> kind;
                        if);
                    if);
		    &AttributeReflector[] -> simple[];
                    (name[], off, kind) -> simple.init;
                    simple[] -> simples.append;
                 #);
             if);
          #);
       exit simples[]
       #);

     AttributeList: List
       (# Element:: AttributeReflector;
       #);

     AttributeReflector:
       (# theName: ^Text;
          offset: @integer;
          kind: @integer;
          init:
            (#
            enter (theName[], offset, kind)
            do 
            #);
          owner:
            (# exit THIS(ObjectReflector)[] #);
          name:
            (#
            do 
            exit theName[]
            #);
          reference:
            (# other: ^ObjDesc.Template;
            do (if (kind = ReferenceKind) and (offset > 0) then
                   template.rfields[offset][] -> other[];
               if);
            exit other[]
            #);
          description:
            (# str: ^Text;
            do theName.copy -> str[];
            exit str[]
            #);
          equal:
            (# other: ^AttributeReflector;
               result: @boolean;
            enter other[]
            do (other.kind = kind) AND (other.offset = offset) 
                 -> result;
            exit result
            #);
          textValue:
            (# theDescription: ^Text;
            do (# obj: ^ObjDesc.Template;
                  value: @integer;
               do '' -> theDescription[];
                  (if offset > 0 then
                      (if kind
                       //SimpleKind then
                          offset -> template.get -> theDescription.putint;
                       //RepetionKind then
                          (# n: @integer;
                          do offset -> template.get -> n;
                             (if n > 32 then
                                 32 -> n;
                             if);
                             (for i: n repeat
                                  offset + i -> template.get -> value;
                                  (if (value >= 32) AND (value <= 128) then
                                      value -> theDescription.put;
                                  if);
                             for);
                          #);
                       //ReferenceKind then
                          template.rfields[offset][] -> obj[];
                          (if obj[] = none then
                              'none' -> theDescription.putText;
                           else
                              (# name: ^Text;
                              do 
                                 obj.myName -> name[];
                                 (if name[] <> NONE then
                                     name[] -> theDescription.putText;
                                  else 
                                     '   ' -> theDescription.putText;
                                 if);
                              #);
                          if);
                      if)            
                   else (* pattern *)
                      '  ' -> theDescription.puttext;
                  if);
               #);
               (if theDescription.length = 0 then
                   '   ' -> theDescription.puttext;
               if);
            exit theDescription[]
            #);               
       #);
  #);


-- FigureCanvasLib: attributes --

SequenceDiagram: Diagram
  (# 
     VM: ^| systemenv.betaVM;
     L: ^Object;
     lines: @Composite;
     nodes: @Composite;
     holder: @CenterFigure;
     background: ^RectFigure;
     debugging: @boolean;
     
     floating: @Sequence
       (# Element:: ObjectShape;
       #);
     visibles: @Sequence
       (# Element:: ObjectShape;
       #);
     compiler: ^generator;
     LOGGING: (# exit false #);
     solid: @boolean;
     res: @Resource;
     x, y: @integer;
     doKeepHistory: @boolean;
     
     placard: ^TileSet;
     solidborder: ^TileSet;
     rectsolidborder: ^TileSet;
     
     colon: ^RichPixmap;
     equal: ^RichPixmap;
     up: ^RichPixmap;
     virtual: ^RichPixmap;
     simple: ^RichPixmap;
     array: ^RichPixmap;
     dynamicRef: ^RichPixmap;
     staticRef: ^RichPixmap;
     pattern: ^RichPixmap;
     cogwheel: ^RichPixmap;
     cogwheelgray: ^RichPixmap;
     plus: ^RichPixmap;
     plus_hilite: ^RichPixmap;
     minus: ^RichPixmap;
     minus_hilite: ^RichPixmap;
     
     updateflag: @boolean;
     
     compile:
       (# objC: ^ObjectContent.handle; FN: ^text; 
          main: ^generator.module; errors: ^stream
       enter objC[]
       do '******* MiniENV: compile: ' -> puttext;
          objC.modulePath -> FN[];
          objC.theModule.name.lexemSy -> FN.append;
          '.bet' -> FN.append;
          objC.theModule.name.lexemSy -> putline;
          (L[],true,objC.theModule[],FN[]) -> compiler -> (main[],errors[]);
       exit(compiler.main[],errors[])
       #);
     
     execute:
       (# objC: ^ObjectContent.handle;
       enter objC[]
       do (objC.theModule.inFile.name,'..run') -> mkAuxName -> RTT.name;
          RTT.openWrite;               
          '********* MiniENV: execute: ' -> putline;
          (if not VM.execute.isRunning then
              VM.init; (* why two inits?*)
              (compiler.descs[],compiler.mainDescNo,RTT[]) -> VM.execute.init;
              VM.execute;
              true -> stepping;
           else
              'VM is not terminated' -> putline
          if);   
       #);
     RTT: @File;
     
     
     displayChain:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# current: ^ObjDesc.Template;
          do self.myName -> puttext;
             self.myOrigin -> current[];
             loop:
               (if current[] <> NONE then
                   '<-' -> puttext;
                   current.myName -> puttext;
                   current.myOrigin -> current[];
                   restart loop;
               if);
             newline;
          #);
       #);
     isOrigin:
       (# candidate: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          result: @boolean;
       enter (candidate[], self[])
       do (if self[] <> NONE then
              (if candidate[] = self[] then
                  true -> result;
               else
                  (candidate[], self.myOrigin) -> isOrigin -> result;
              if);
          if);
       exit result
       #);
     commonOrigin:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter (caller[], self[])
       do (if caller[] <> NONE then
              (if (caller[], self[]) -> isOrigin then
                  caller[] -> origin[];
               else
                  (caller.myOrigin, self[]) -> commonOrigin -> origin[];
              if);
          if);
       exit origin[]
       #);
     isObscure:
       (# self: ^ObjDesc.Template;
          shape: ^ObjectShape;
          result: @boolean;
       enter self[]
       do (if self[] <> NONE then
              self[] 
                -> reflection
                -> objectShapes.lookupByTarget 
                -> shape[];
              (if shape[] <> NONE then
                  shape.obscure-> result;
              if);
              (if not result then
                  self.myOrigin -> isObscure -> result;
              if);
          if);
       exit result
       #);
     isSkipping:
       (# origin: ^ObjDesc.Template;
          result: @boolean;
       enter origin[]
       do (if origin[] <> NONE then
              (# shape: ^ObjectShape;
              do origin[] 
                   -> reflection
                   -> objectShapes.lookupByTarget 
                   -> shape[];
                 (if shape[] <> NONE then
                     shape.skip -> result;
                 if);
                 (if NOT result then
                     origin.myOrigin -> isSkipping -> result;
                 if);
              #);
          if);
       exit result
       #);
     
     createBackward:
       (# backward: ^Figure;
          tip: ^Point2d;
          foot: ^Point2d;
          left: ^Point2d;
          right: ^Point2d;
          head: ^PolygonItem;
          arrow: ^Line;
       do &Figure[] -> backward[];
          backward.init;
          
          &Point2d[] -> tip[];
          0 -> tip.x;
          3 -> tip.y;
          &Point2d[] -> left[];
          6 -> left.x;
          6 -> left.y;
          &Point2d[] -> right[];
          6 -> right.x;
          0 -> right.y;
          &PolygonItem[] -> head[];
          head.init;
          left[] -> head.points.append;
          tip[] -> head.points.append;
          right[] -> head.points.append;
          res.black[] -> head.stroke[];
          1 -> head.strokeWidth;
          head[] -> backward.add;
          
          &Line[] -> arrow[];
          tip[] -> arrow.start[];
          &Point2d[] -> foot[];
          12 -> foot.x;
          3 -> foot.y;
          foot[] -> arrow.end[];
          res.black[] -> arrow.stroke[];
          1 -> arrow.strokeWidth;
          arrow[] -> backward.add;
          
          12 -> backward.minimumWidth;
          6 -> backward.minimumHeight;
       exit backward[]
       #);
     createForward:
       (# forward: ^Figure;
          tip: ^Point2d;
          foot: ^Point2d;
          left: ^Point2d;
          right: ^Point2d;
          head: ^PolygonItem;
          arrow: ^Line;
       do &Figure[] -> forward[];
          forward.init;
          
          &Point2d[] -> tip[];
          12 -> tip.x;
          3 -> tip.y;
          &Point2d[] -> left[];
          6 -> left.x;
          6 -> left.y;
          &Point2d[] -> right[];
          6 -> right.x;
          0 -> right.y;
          &PolygonItem[] -> head[];
          head.init;
          left[] -> head.points.append;
          tip[] -> head.points.append;
          right[] -> head.points.append;
          res.black[] -> head.stroke[];
          1 -> head.strokeWidth;
          head[] -> forward.add;
          
          &Line[] -> arrow[];
          tip[] -> arrow.start[];
          &Point2d[] -> foot[];
          0 -> foot.x;
          3 -> foot.y;
          foot[] -> arrow.end[];
          res.black[] -> arrow.stroke[];
          1 -> arrow.strokeWidth;
          arrow[] -> forward.add;
          
          12 -> forward.minimumWidth;
          6 -> forward.minimumHeight;
       exit forward[]
       #);
     createCircle:
       (# theOvalFigure: ^OvalFigure;
          fill: ^Color;
          circle: ^CenterFigure;
       enter fill[]
       do &OvalFigure[] -> theOvalFigure[];
          theOvalFigure.init;
          fill[] -> theOvalFigure.fill;
          true -> theOvalFigure.horizontallyFlexible;
          true -> theOvalFigure.verticallyFlexible;
          &CenterFigure[] -> circle[];
          circle.init;
          theOvalFigure[] -> circle.add;
          up.width -> circle.baseMinimumWidth;
          up.height -> circle.baseMinimumHeight;
          3 -> circle.margin;
       exit circle[]
       #);
     TileSet:
       (# topleft: ^RichPixmap;
          top: ^RichPixmap;
          topright: ^RichPixmap;
          left: ^RichPixmap;
          middle: ^RichPixmap;
          right: ^RichPixmap;
          bottomleft: ^RichPixmap;
          bottom: ^RichPixmap;
          bottomright: ^RichPixmap;
          
          load:
            (# name: ^Text;
            enter name[]
            do '-topleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topleft[];
               '-top.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> top[];
               '-topright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topright[];
               '-left.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> left[];
               '-middle.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> middle[];
               '-right.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> right[];
               '-bottomleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomleft[];
               '-bottom.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottom[];
               '-bottomright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomright[];
            #);
       #);
     
     loadTileSet:
       (# name: ^Text;
          tiles: ^TileSet;
       enter name[]
       do &TileSet[] -> tiles[];
          name[] -> tiles.load;
       exit tiles[]
       #);
     
     
     createBackground:
       (# tiles: ^TileSet;
          background: ^ColumnFigure;
       enter tiles[]
       do &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             topleft: ^ImageFigure;
             top: ^ImageFigure;
             topright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.topleft[]
               -> createImageFigure 
               -> topleft[];
             false -> topleft.horizontallyFlexible;
             false -> topleft.verticallyFlexible;
             topleft[] -> row.add;
             
             tiles.top[]
               -> createImageFigure 
               -> top[];
             true -> top.horizontallyFlexible;
             false -> top.verticallyFlexible;
             top[] -> row.add;
             
             tiles.topright[]
               -> createImageFigure 
               -> topright[];
             false -> topright.horizontallyFlexible;
             false -> topright.verticallyFlexible;
             topright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          (# row: ^RowFigure;
             left: ^ImageFigure;
             middle: ^ImageFigure;
             right: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.left[]
               -> createImageFigure 
               -> left[];
             false -> left.horizontallyFlexible;
             true -> left.verticallyFlexible;
             left[] -> row.add;
             
             tiles.middle[]
               -> createImageFigure 
               -> middle[];
             true -> middle.horizontallyFlexible;
             true -> middle.verticallyFlexible;
             middle[] -> row.add;
             
             tiles.right[]
               -> createImageFigure 
               -> right[];
             false -> right.horizontallyFlexible;
             true -> right.verticallyFlexible;
             right[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
             true -> row.verticallyFlexible;
          #);
          (# row: ^RowFigure;
             bottomleft: ^ImageFigure;
             bottom: ^ImageFigure;
             bottomright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.bottomleft[]
               -> createImageFigure 
               -> bottomleft[];
             false -> bottomleft.horizontallyFlexible;
             false -> bottomleft.verticallyFlexible;
             bottomleft[] -> row.add;
             
             tiles.bottom[]
               -> createImageFigure 
               -> bottom[];
             true -> bottom.horizontallyFlexible;
             false -> bottom.verticallyFlexible;
             bottom[] -> row.add;
             
             tiles.bottomright[]
               -> createImageFigure 
               -> bottomright[];
             false -> bottomright.horizontallyFlexible;
             false -> bottomright.verticallyFlexible;
             bottomright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          background.pack;
       exit background[]
       #);
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.Template;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter template[]
       do (if template[] <> NONE then
              (#
              do template[] -> objectReflectors.lookupByTemplate -> reflect[];
                 (if reflect[] = NONE then
                     &ObjectReflector[] -> reflect[];
                     template[] -> reflect.init;
                     reflect[] -> objectReflectors.append;
                 if);
              #);
           else
              exception (#  #);
          if);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          x + 200 -> x;
       #);
     
     
     clearHistory:
       (#
       do start.clearHistory;
          presentSequenceDiagram;
       #);
     clearSequenceDiagram:
       (# 
       do lines.clear;
          nodes.children.scan
          (# shape: ^ObjectShape;
          do (if current## = ObjectShape## then
                 current[] -> shape[];
                 shape.dismissConnectors;
                 shape[] -> visibles.delete;
             if);
          #);
          nodes.clear;
          floating.scan
          (#
          do current.dismissConnectors;
             current[] -> THIS(SequenceDiagram).remove;
             current[] -> visibles.delete;
          #);
          floating.clear;
          NONE -> start[];
          NONE -> top[];
       #);

     offset: @integer;
     slide: @integer;
     
     presentSequenceDiagram:
       (# present:
            (# x: @integer;
               y: @integer;
               xx: @integer;
               xmax: @integer;
               header: @integer;
               
               flatten:
                 (# 
                 do &ActionList[] -> actions[];
                    actions[] -> start.flatten;
                 #);
               actions: ^ActionList;
               
               start: ^Invocation;
               nodes: @ObjectShapeList;
            enter (start[], x, header)
            do flatten;
               actions.scan
               (# inv: ^Invocation;
               do (if current## <= Invocation## then
                      current[] -> inv[];
                      false -> inv.isComponent;
                      false -> inv.receiver.isComponent;
                  if);
               #);
               true -> start.isComponent;
               true -> start.receiver.isComponent;
               start[] -> start.receiver.invocator[];
               
               
               (if start.isCollapsed then
                   start.prepare -> header;
                else
                   actions.scan
                   (# height: @integer;
                   do current.prepare -> height;
                      (if height > header then
                          height -> header;
                      if);
                   #);
               if);
               
               
               header + 24 -> y;
               y + offset -> y;
               
               (if start.isCollapsed then
                   (mark[], nodes[], x, y, header) -> start.process -> (x, y);
                else
                   actions.scan
                   (# 
                   do (mark[], nodes[], x, y, header) -> current.process -> (x, y); 
                   #);
               if);
               
               
               nodes.scan
               (# right: @integer;
               enter right
               do current.right + 7-> right;
                  (if right > x then
                      right -> x;
                  if);
               #);
               (if start.isSuspended then
                   (x, y) -> start.layoutSuspended;
                   start.arrow[] -> lines.add;
               if);
               (if y > footer then
                   y -> footer;
               if);
               nodes.scan
               (#
               do current[] -> touched.append;
               #);
            exit (x, header)
            #);
          mark: @List;
          
          touched: @ObjectShapeList;
          deletion: @Sequence
            (# Element:: ObjectShape;
            #);
          debug: @boolean;
          footer: @integer;
       do (if start[] <> NONE then
              (# x, y: @integer;
              do lines.clear;
                 24 -> x;
                 0 -> y;
                 600 -> footer;
                 (start[], x, y) -> present -> (x, y);
                 suspended.scan
                 (#
                 do (current[], x + 24, y) -> present -> (x, y);
                 #);
                 lines.children.scan
                 (# l: ^LifeLine;
                    o: ^Lifer;
                 do (if current## = Lifer## then
                        current[] -> o[];
                        o.last -> l[];
                        footer -> l.end.y;
                    if);
                 #);
                 touched.scan
                 (#
                 do (if not (current[] -> visibles.has) then
                        (if current.father[] <> NONE then
                            current[] -> THIS(SequenceDiagram).remove;
                            current[] -> floating.delete;
                        if);
                        current[] -> nodes.add;
                        NONE -> current.fig.theBehaviour[];
                        current[] -> visibles.append;
                    if);
                 #);
                 visibles.scan
                 (# 
                 do (if not (current[] -> touched.has) then
                        current[] -> deletion.append;
                    if);
                 #);
                 deletion.scan
                 (#
                 do current.dismissConnectors;
                    current.refresh;
                    current[] -> nodes.remove;
                    current[] -> visibles.delete;
                    (if current.sticky then
                        &current.Drag[] -> current.fig.theBehaviour[];
                        current[] -> THIS(SequenceDiagram).add;
                        current[] -> floating.append;
                    if);
                 #);
                 update;
              #);
          if);
       #);
     
     
     Decoration: Composite
       (# containsPoint::
            (#
            do NONE -> target[];
            #);
       #);
     ActionList: Sequence
       (# Element:: Action;
       #);
     Action:
       (# transient: @boolean;
          flatten:<
            (#  actions: ^ActionList;
            enter actions[]
            do INNER;
            #);
          prepare:<
            (# height: @integer;
            do INNER;
            exit height
            #);
          process:<
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               header: @integer;
            enter (mark[], nodes[], x, y, header)
            do INNER;
            exit (x, y)
            #);
          finish:<
            (#
            do INNER;
            #);
          clearHistory:<
            (#
            do INNER;
            #);
          description:<
            (# string: ^Text;
            do THIS(Action)[] -> getPatternName -> string[];
               INNER;
            exit string[]
            #);
          createArrow:
            (# lst: ^PointList;
               dash: @boolean;
               head: ^ArrowHead;
               arrow: ^Composite;
            enter (lst[], dash)
            do (# 
               do &Decoration[] -> arrow[];
                  arrow.init;   
                  (# prev: ^Point2d;
                  do lst.scan
                     (# segment: ^Line;
                     do (if prev[] <> NONE then
                            &Line[] -> segment[];
                            segment.init;
                            prev[] -> segment.start[];
                            current[] -> segment.end[];
                            1 -> segment.strokeWidth;
                            res.colors.darkerCoolBrown[] -> segment.stroke[];
                            (if dash then
                                PenDash -> segment.style;
                            if);
                            segment[] -> arrow.add;
                        if);
                        current[] -> prev[];
                     #);
                  #);
                  
                  (# start, end: ^Point2d;
                  do lst.size - 1 -> lst.get -> start[];
                     lst.size -> lst.get -> end[];
                     &ArrowHead[] -> head[];
                     head.init;
                     end[] -> head.to[];
                     start[] -> head.from[];
                     head.refresh;
                     res.colors.darkerCoolBrown[] -> head.stroke[];
                     res.colors.darkerCoolBrown[] -> head.fill[];
                     head[] -> arrow.add;
                  #);
               #);
            exit arrow[]
            #);
       #);
     Invocation: Action
       (# receiver: ^ObjectShape;
          self: ^ObjDesc.Template;
          message: ^ObjectShape;
          
          allocating: ^Invocation;
          allocation: @boolean;
          isObj: @boolean;
          isReturn: @boolean;
          isComponent: @boolean;
          isSuspended: @boolean;
          isCollapsed: @boolean;
          
          history: @List
            (# Element:: Invocation;
            #);
          stack: @Sequence
            (# Element:: Action;
               peek:
                 (# elm: ^Element;
                 do (if NOT empty then
                        last -> elm[];
                    if);
                 exit elm[]
                 #);
               pop:
                 (# elm: ^Element;
                 do (if NOT empty then
                        deleteLast -> elm[];
                    if);
                 exit elm[]
                 #);
               push:
                 (# elm: ^Element;
                 enter elm[]
                 do elm[] -> append;
                 #);
            #);
          
          selectCode:
            (# done: @boolean;
            do (if self[] <> NONE then
                   (if self.lscTop > 0 then
                       self[] -> showCode;
                       true -> done;
                   if);
               if);
               (if not done then
                   (if return[] <> NONE then
                       return.selectCode;
                   if);
               if);
            #);
          
          activate:
            (#
            do (if not allocation then
                   (if message[] <> NONE then
                       message.activate;
                    else
                       receiver.activate;
                   if);
               if);
            #);
          deactivate:
            (#
            do (if not allocation then
                   (if message[] <> NONE then
                       message.deactivate;
                    else
                       receiver.deactivate;
                   if);
               if);
            #);
          peek:
            (# theAction: ^Action;
            do stack.peek -> theAction[];
            exit theAction[]
            #);
          pop:
            (# theAction: ^Action;
            do stack.pop -> theAction[];
            exit theAction[]
            #);
          push:
            (# theAction: ^Action;
            enter theAction[]
            do theAction[] -> stack.push;
            #);
          
          flush:
            (# top: ^Action;
               prepare: @boolean;
            enter prepare
            do peek -> top[];
               (if top[] <> NONE then
                   top.finish;
                   (if prepare then
                       (if top## = PrepareCall## then
                           pop;
                           NONE -> top[];
                       if);
                   if);
               if);
               while:
                 (if top[] <> NONE then
                     (if top.transient then
                         pop;
                         peek -> top[];
                         restart while;
                     if);
                 if);
               
            #);
          copy:
            (# new: ^Invocation;
            do &Invocation[] -> new[];
               receiver[] -> new.receiver[];
               allocation -> new.allocation;
               return[] -> new.return[];
            exit new[]
            #);
          finish::
            (#
            do stack.scan
               (#
               do current.finish;
               #);
               flush;
            #);
          clearHistory::
            (#
            do stack.scan
               (#
               do current.clearHistory;
               #);
               history.scan
               (#
               do current.clearHistory;
               #);
               history.clear;
            #);
          return: ^Invocation;
          pts: ^PointList;
          arrow: ^Composite;
          
          flatten::
            (#
            do THIS(Invocation)[] -> actions.append;
               history.scan
               (#
               do actions[] -> current.flatten; 
               #);
               stack.scan
               (#
               do actions[] -> current.flatten;
               #);
            #);
          prepare::
            (#
            do receiver.refresh;
               (if message[] <> NONE then
                   message.refresh;
               if);
               (if not allocation then
                   receiver.height -> height;
               if);
            #);
          process::
            (# dy: @integer;
               sender: ^ObjectShape;
            do (if not isSuspended then
                   (if return[] <> NONE then
                       return.receiver[] -> sender[];
                   if);
               if);
               (if receiver[] = sender[] then
                   50 -> dy;
                else
                   30 -> dy;
               if);
               (if not (receiver[] -> mark.has) then
                   receiver[] -> mark.append;
                   (# dx: @integer;
                      a: ^Point2d;
                      width: @integer;
                   do (if sender[] <> NONE then
                          sender.bottomAnchor -> a[];
                          ((x + receiver.width / 2) - a.x) - 20 -> dx;
                          sender.maximum -> width;
                          (if message[] <> NONE then
                              (if width < message.width then
                                  message.width -> width;
                              if);
                          if);
                          (if dx < width then
                              width - dx -> dx;
                              x + dx -> x;
                          if);
                      if);
                   #);
                   (if allocation then
                       (x, y) -> receiver.layoutLiveObject;
                       receiver.height + 4 -> dy;
                       (if y > header then
                           receiver[] -> nodes.append;
                           receiver.live[] -> lines.add;
                       if);
                    else
                       (x, 24) -> receiver.layoutLiveObject;
                       receiver[] -> nodes.append;
                       receiver.live[] -> lines.add;
                   if);
                   (if receiver.maximum > receiver.width then
                       x + receiver.maximum + 7 -> x;
                    else
                       x + receiver.width + 7 -> x;
                   if);
                   
                   
               if);
               
               y -> layout;
               (if message[] <> NONE then
                   (if (message.height + 4) > dy then
                       message.height + 4 -> dy;
                   if);
               if);
               
               (if y > (header + 24) then
                   (if arrow[] <> NONE then
                       arrow[] -> lines.add;
                   if);
                   (if message[] <> NONE then
                       message[] -> mark.append;
                       message[] -> nodes.append;
                   if);
               if);
               y + dy -> y;
               
            #);
          swap:
            (# lst: ^PointList;
            do (if pts[] <> NONE then
                   &PointList[] -> lst[];
                   pts.scan
                   (#
                   do current[] -> lst.prepend;
                   #);
                   (lst[], true) -> makeArrow;
                   (* PenDash -> arrowLine.style; *)
               if);
            #);
          
          makeArrow:
            (# lst: ^PointList;
               dash: @boolean;
            enter (lst[], dash)
            do (lst[], dash) -> createArrow -> arrow[];
               (if message[] <> NONE then
                   (# start, end: ^Point2d;
                      mid: ^Point2d;
                   do 1 -> lst.get -> start[];
                      2 -> lst.get -> end[];
                      &Point2d[] -> mid[];
                      (start.x + end.x) / 2 -> mid.x;
                      start.y -> mid.y;
                      mid.x - message.width / 2 -> message.x;
                      mid.y - 10 -> message.y;
                   #);
               if);
               lst[] -> pts[];
            #);
          
          layout:
            (# sender: ^ObjectShape;
               offset: @integer;
               layoutRegular:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if allocation and (not isReturn) then
                        receiver.leftAnchor -> toAnchor[];
                     else
                        receiver.bottomAnchor -> toAnchor[];
                    if);
                    toAnchor.x -> to.x;
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    (lst[], false) -> makeArrow;
                 #);
               layoutSelf:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    lower: ^Point2d;
                    end: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                    width: @integer;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if message[] <> NONE then
                        from.x + message.width + 20 -> to.x;
                     else
                        from.x + 60 -> to.x;
                    if);
                    
                    (to.x - from.x) -> width;
                    (if width > sender.maximum then
                        width -> sender.maximum;
                    if);
                    
                    &Point2d[] -> lower[];
                    to.x -> lower.x;
                    to.y + 30 -> lower.y;
                    &Point2d[] -> end[];
                    from.x -> end.x;
                    from.y + 30 -> end.y;
                    
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    lower[] -> lst.append;
                    end[] -> lst.append;
                    (lst[], false) -> makeArrow;
                 #);
            enter offset
            do (if isSuspended then
                   NONE -> arrow[];
                else
                   (if return[] <> NONE then
                       return.receiver[] -> sender[];
                   if);
                   (if sender[] <> NONE then
                       (if sender[] = receiver[] then
                           layoutSelf;
                           (if isReturn then
                               (pts[], true) -> makeArrow;
                           if);
                        else
                           layoutRegular;
                           (if isReturn then
                               swap;
                           if);
                       if);
                   if);
               if);
            #);
          layoutSuspended:
            (# offset: @integer;
               x: @integer;
            enter (x, offset)
            do (# a1: ^Point2d;
                  a2: ^Point2d;
                  start: ^Point2d;
                  b1: ^Point2d;
                  b2: ^Point2d;
                  b3: ^Point2d;
                  end: ^Point2d;
                  pts: ^PointList;
               do receiver.topAnchor -> a1[];
                  return.receiver.topAnchor -> a2[];
                  &Point2d[] -> start[];
                  a1.x + 20 -> start.x;
                  a1.y -> start.y;
                  &Point2d[] -> b1[];
                  start.x -> b1.x;
                  start.y - 10 -> b1.y;
                  &Point2d[] -> b2[];
                  a1.x - receiver.width / 2 - 7 -> b2.x;
                  b1.y -> b2.y;
                  &Point2d[] -> b3[];
                  b2.x -> b3.x;
                  offset -> b3.y;
                  &Point2d[] -> end[];
		  (if isCollapsed then
                      a1.x -> end.x;
                   else
                      a2.x -> end.x;
                  if);
                  offset -> end.y;
                  &PointList[] -> pts[];
                  pts.init;
                  start[] -> pts.append;
                  b1[] -> pts.append;
                  b2[] -> pts.append;
                  b3[] -> pts.append;
                  end[] -> pts.append;
                  (pts[], false) -> makeArrow;
               #);
            #);
          
          match:
            (# self: ^ObjDesc.Template;
               result: @boolean;
            enter self[]
            do self[] = THIS(Invocation).self[] -> result;;
            exit result
            #);
          matchAny:
            (# self: ^ObjDesc.Template;
               result: @boolean;
            enter self[]
            do (if self[] -> match then
                   true -> result;
                else
                   (if return[] <> NONE then
                       self[] -> return.match -> result;
                    else
                       false -> result;
                   if);
               if);
            exit result
            #);
          find:
            (# self: ^ObjDesc.Template;
               stack: ^Invocation;
            enter self[]
            do (if (self[] -> match) or true then
                   THIS(Invocation)[] -> stack[];
                else
                   (if return[] <> NONE then
                       self[] -> return.find -> stack[];
                   if);
               if);
            exit stack[]
            #);
          description::
            (# sender: ^ObjectShape;
            do '[' -> string[];
               (if message[] <> NONE then
                   message.reflect.name -> string.puttext;
                   ' ' -> string.puttext;
                else
                   'allocate ' -> string.puttext;
                   (if receiver[] <> NONE then
                       receiver.description -> string.puttext;
                   if);
               if);
               (if return[] <> NONE then
                   return.receiver[] -> sender[];
               if);
               (if sender[] <> NONE then
                   ' | ' -> string.puttext;
                   sender.description -> string.puttext;
                else
                   ' | start ' -> string.puttext;
               if);
               ']' -> string.puttext;
            #);
       #);
     ReturnValue: Action
       (#
       #);
     PushValue: Action
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          receiver: ^ObjectShape;
          
          flatten::
            (#
            do (if showValues then
                   THIS(PushValue)[] -> actions.append;
               if);
            #);
          prepare::
            (#
            #);
          
          process::
            (#
            do (mark[], nodes[], x, y, header) -> displayOne -> (x, y);
            #);
          displayOne:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               shape: ^StackShape;
               header: @integer;
            enter (mark[], nodes[], x, y, header)
            do receiver.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], false) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               (if y > (header + 24) then
                   shape[] -> lines.add;
               if);
               y + 22 -> y;
            exit (x, y)
            #);
          displayTwo:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               p1: ^Point2d;
               p2: ^Point2d;
               pts: ^PointList;
               shape: ^ValueShape;
               field: ^FieldReferenceShape;
            enter (mark[], nodes[], x, y)
            do receiver.bottomAnchor -> anchor[];
               
               &ValueShape[] -> shape[];
               value.copy -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
               
               (if where[] <> NONE then
                   &FieldReferenceShape[] -> field[];
                   where[] -> field.init;
                   field.pack;
                   shape.x + shape.width + 20 -> field.x;
                   y - (field.height / 2) -> field.y;
                   field[] -> lines.add;
                   
                   &PointList[] -> pts[];
                   &Point2d[] -> p1[];
                   &Point2d[] -> p2[];
                   shape.x + shape.width -> p1.x;
                   field.x -> p2.x;
                   y -> p1.y;
                   y -> p2.y;
                   p2[] -> pts.append;
                   p1[] -> pts.append;
                   (pts[], true) -> createArrow -> lines.add;
               if);
               y + 22 -> y;
            exit (x, y)
            #);
          finish::
            (#
            do NONE -> where[];
            #);
       #);
     StoreValue: Action
       (# value: ^Text;
          sender: ^ObjectShape;
          where: ^ObjectReflector.AttributeReflector;
          flatten::
            (#
            do (if showValues then
                   THIS(StoreValue)[] -> actions.append;
               if);
            #);
          prepare::
            (#
            do 
            #);
          displayTwo:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
            enter (mark[], nodes[], x, y)
            do (# anchor: ^Point2d;
                  p1: ^Point2d;
                  p2: ^Point2d;
                  pts: ^PointList;
                  shape: ^ValueShape;
                  field: ^FieldReferenceShape;
                  distance: @integer;
               do sender.bottomAnchor -> anchor[];
                  &ValueShape[] -> shape[];
                  value[] -> shape.init;
                  shape.pack;
                  anchor.x - (shape.width / 2) -> shape.x;
                  y - (shape.height / 2) -> shape.y;
                  shape[] -> lines.add;
                  
                  (if where[] <> NONE then
                      &FieldReferenceShape[] -> field[];
                      true -> field.assign;
                      where[] -> field.init;
                      field.pack;
                      shape.x + shape.width + 20 -> field.x;
                      y - (field.height / 2) -> field.y;
                      field[] -> lines.add;
                      
                      (field.x + field.width) - anchor.x -> distance;
                      
                      &PointList[] -> pts[];
                      &Point2d[] -> p1[];
                      &Point2d[] -> p2[];
                      shape.x + shape.width -> p1.x;
                      field.x -> p2.x;
                      y -> p1.y;
                      y -> p2.y;
                      p1[] -> pts.append;
                      p2[] -> pts.append;
                      (pts[], true) -> createArrow -> lines.add;
                      (if false then
                          (# receiver: ^ObjectShape;
                          do where.owner -> objectShapeForTarget -> receiver[];
                             (if not (receiver[] -> mark.has) then
                                 receiver[] -> mark.append;
                                 (# dx: @integer;
                                    a: ^Point2d;
                                    width: @integer;
                                 do (if sender[] <> NONE then
                                        sender.bottomAnchor -> a[];
                                        ((x + receiver.width / 2) - a.x) - 20 -> dx;
                                        sender.maximum -> width;
                                        (if width < distance then
                                            distance -> width;
                                        if);
                                        (if dx < width then
                                            width - dx -> dx;
                                            x + dx -> x;
                                        if);
                                    if);
                                 #);
                                 (x, 24) -> receiver.layoutLiveObject;
                                 x + receiver.width + 7 -> x;
                                 receiver[] -> nodes.append;
                             if);
                          #);
                      if);
                  if);
                  y + 22 -> y;
               #);
            exit (x, y)
            #);
          displayOne:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               header: @integer;
               anchor: ^Point2d;
               shape: ^StackShape;
            enter (mark[], nodes[], x, y, header)
            do sender.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], true) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               (if y > (header + 24) then
                   shape[] -> lines.add;
               if);
               y + 22 -> y;
            exit (x, y)
            #);
          process::
            (# 
            do (mark[], nodes[], x, y, header) -> displayOne -> (x, y);
            #);
       #);
     ErrorMessage: Action
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          receiver: ^ObjectShape;
          
          flatten::
            (#
            do THIS(ErrorMessage)[] -> actions.append;
            #);
          prepare::
            (#
            #);
          
          process::
            (#
            do (mark[], nodes[], x, y, header) -> displayOne -> (x, y);
            #);
          displayOne:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               shape: ^StackShape;
               header: @integer;
            enter (mark[], nodes[], x, y, header)
            do receiver.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], false) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               (if y > (header + 24) then
                   shape[] -> lines.add;
               if);
               y + 22 -> y;
            exit (x, y)
            #);
          displayTwo:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               p1: ^Point2d;
               p2: ^Point2d;
               pts: ^PointList;
               shape: ^ValueShape;
               field: ^FieldReferenceShape;
            enter (mark[], nodes[], x, y)
            do receiver.bottomAnchor -> anchor[];
               
               &ValueShape[] -> shape[];
               value.copy -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
               
               (if where[] <> NONE then
                   &FieldReferenceShape[] -> field[];
                   where[] -> field.init;
                   field.pack;
                   shape.x + shape.width + 20 -> field.x;
                   y - (field.height / 2) -> field.y;
                   field[] -> lines.add;
                   
                   &PointList[] -> pts[];
                   &Point2d[] -> p1[];
                   &Point2d[] -> p2[];
                   shape.x + shape.width -> p1.x;
                   field.x -> p2.x;
                   y -> p1.y;
                   y -> p2.y;
                   p2[] -> pts.append;
                   p1[] -> pts.append;
                   (pts[], true) -> createArrow -> lines.add;
               if);
               y + 22 -> y;
            exit (x, y)
            #);
          finish::
            (#
            do NONE -> where[];
            #);
       #);
     PrepareCall: Action
       (# sender: ^ObjectShape;
          receiver: ^ObjectShape;
          flatten::
            (#
            do THIS(PrepareCall)[] -> actions.append;
            #);
          process::
            (# anchor: ^Point2d;
               pts: ^PointList;
               p1: ^Point2d;
               p2: ^Point2d;
               l: ^Line;
               c: ^Oval;
            do sender.bottomAnchor -> anchor[];
               (if not (receiver[] -> mark.has) then
                   receiver[] -> mark.append;
                   (# dx: @integer;
                      a: ^Point2d;
                      width: @integer;
                   do (if sender[] <> NONE then
                          sender.bottomAnchor -> a[];
                          ((x + receiver.width / 2) - a.x) - 20 -> dx;
                          sender.maximum -> width;
                          (if dx < width then
                              width - dx -> dx;
                              x + dx -> x;
                          if);
                      if);
                   #);
                   (x, y) -> receiver.layoutLiveObject;
                   x + receiver.width + 7 -> x;
                   
                   (if y > (header + 24) then
                       receiver[] -> nodes.append;
                       
                       &Point2d[] -> p1[];
                       &Point2d[] -> p2[];
                       y -> p1.y;
                       y -> p2.y;
                       anchor.x -> p2.x;
                       receiver.x -> p1.x;
                       
                       (if false then
                           &PointList[] -> pts[];
                           p1[] -> pts.append;
                           p2[] -> pts.append;
                           
                           (pts[], true) -> createArrow -> lines.add;
                        else
                           &Line[] -> l[];
                           l.init;
                           p1[] -> l.start[];
                           p2[] -> l.end[];
                           res.colors.darkerCoolBrown[] -> l.stroke[];
                           1 -> l.strokewidth;
                           PenDash -> l.style;
                           l[] -> lines.add;
                           &Oval[] -> c[];
                           c.init;
                           p2.x - 1 -> c.x;
                           p2.y - 2 -> c.y;
                           5 -> c.width;
                           5 -> c.height;
                           res.colors.darkerCoolBrown[] -> c.fill[];
                           c[] -> lines.add;
                       if);
                   if);
               if);
               y + 22 -> y;
            #);
       #);
     
     skipAllocations: @boolean;
     showValues: @boolean;
     showOrigins: @boolean;
     allocating_: ^Invocation;
     allocating:
       (# set:
            (# value: ^Invocation;
            enter value[]
            do value[] -> top.allocating[];
            #);
          get:
            (# value: ^Invocation;
            do top.allocating[] -> value[];
            exit value[]
            #);
       enter set
       exit get
       #);
     skippingOver: ^Invocation;
     mode: @integer;
     
     NormalMode: (# exit 0 #);
     SkipOneMode: (# exit 1 #);
     SearchingMode: (# exit 2 #);
     beginning: @boolean;
     recentlyResumed: ^Invocation;
     
     start: ^Invocation;
     top: ^Invocation;
     suspended: @Sequence
       (# Element:: Invocation;
       #);
     returning: ^Invocation;
     assigning: ^StoreValue;
     started: @boolean;
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do theInvocation.activate;
          (if top[] <> NONE then
              top.flush;
              top[] -> theInvocation.return[];
              theInvocation[] -> top.push;
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          true -> beginning;
          NONE -> recentlyResumed[];
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
          return: ^Invocation;
       do top[] -> returning[];
          top[] -> theInvocation[];
          theInvocation.deactivate;
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          theInvocation.return[] -> top[];
          theInvocation.copy -> return[];
          true -> return.isReturn;
          return[] -> top.push;
       #);
     suspendInvocation:
       (# self: ^ObjDesc.Template;
          skipped: @boolean;
       enter self[]
       do (# current: ^Invocation;
             link: ^Invocation;
          do top[] -> current[];
             while:
               (if current[] <> NONE then
                   (if current[] = skippingOver[] then
                       true ->skipped;
                   if);
                   (if NOT (self[] -> current.match) then
                       current.deactivate;
                       current.return[] -> current[];
                       restart while;
                   if);
               if);
             (if current[] <> NONE then
                 current.deactivate;
                 (if LOGGING then
                     'SUSPEND ' -> puttext;
                     current.description -> putline;
                 if);
                 current.return[] -> link[];
                 top[] -> current.return[];
                 link[] -> top[];
                 (if (top.peek = current[]) then
                     top.pop;
                 if);
                 current[] -> suspended.append;
                 true -> current.isSuspended;
             if);
          #);
       exit skipped
       #);
     resumeInvocation:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# candidate: ^Invocation;
             link: ^Invocation;
             current: ^Invocation;
          do search: suspended.scan
               (#
               do (if self[] -> current.match then
                      current[] -> candidate[];
                      leave search;
                  if);
               #);
             (if candidate[] <> NONE then
                 top.flush;
                 top[] -> link[];
                 candidate.return[] -> top[];
                 link[] -> candidate.return[];
                 candidate[] -> link.push;
                 false -> candidate.transient;
                 candidate[] -> suspended.delete;
                 false -> candidate.isSuspended;
                 
                 top[] -> current[];
                 loop:
                   (if current[] <> candidate[] then
                       current.activate;
                       current.return[] -> current[];
                       restart loop;
                   if);
                 candidate.activate;
                 
                 (if mode = SearchingMode then
                     (if LOGGING then
                         'step-over attach-found: ' -> puttext;
                         candidate.description -> putline;
                     if);
                     candidate[] -> skippingOver[];
                     NormalMode -> mode;
                 if);
                 candidate[] -> recentlyResumed[];
                 (if LOGGING then
                     'RESUME ' -> puttext;
                     candidate.description -> putline;
                 if);
             if);
          #);
       #);
     refreshExecution:
       (#
       do true -> updateFlag;
          refresh;
          false -> updateFlag;
       #);
     refresh:
       (# 
       do presentSequenceDiagram;
          floating.scan
          (#
          do current.refresh;
          #);
          refreshConnectors;
       #);
     
     terminate:
       (#
       do start.finish;
          refreshExecution;
          true -> isTerminated;
       #);
     
     isTerminated: @boolean;
     
     finishPending:
       (# pending: @boolean;
          return: ^Action;
          call: ^Action;
       do (if returning[] <> NONE then
              top.pop -> return[];
              top.pop -> call[];
              (if doKeepHistory then
                  call[] -> top.history.append;
                  return[] -> top.history.append;
              if);
              returning.stack.scan
              (# pv: ^PushValue;
              do (if current## = PushValue## then
                     current[] -> pv[];
                     top.receiver[] -> pv.receiver[];
                     pv[] -> top.push;
                 if);
              #);
              NONE -> returning[];
              refresh;
              true -> pending;
           else 
              (if assigning[] <> NONE then
                  top.pop;
                  NONE -> assigning[];
                  refresh;
                  true -> pending;
              if);
          if);
       exit pending
       #);
     reActivate:
       (#
       do VM.reActivate;
          (if NOT VM.execute.isRunning then
              terminate;
          if);
       #);
     step:
       (# pending: @boolean;
       do finishPending -> pending;
          reActivate;
       #);
     stepOut:
       (#
       do finishPending;
          (if beginning then
              (if top.return[] <> NONE then
                  top.return[] -> skippingOver[];
               else
                  top[] -> skippingOver[];
              if);
           else
              top[] -> skippingOver[];
          if);
          reActivate;
       #);
     stepOver:
       (#
       do finishPending;
          (if beginning then
              top[] -> skippingOver[];
              (if LOGGING then
                  'step-over: ' -> puttext;
                  skippingOver.description -> putline;
              if);
           else
              (if recentlyResumed[] <> NONE then
                  recentlyResumed[] -> skippingOver[];
                  (if LOGGING then
                      'step-over-resumed: ' -> puttext;
                      skippingOver.description -> putline;
                  if);
               else
                  SearchingMode -> mode;
                  (if LOGGING then
                      'step-over search' -> putline;
                  if);
              if);
          if);
          reActivate;
       #);
     continue:
       (#
       do finishPending;
          false -> stepping;
          reActivate;
       #);
     doClose:
       (#
       do (if VM.execute.isRunning then
              VM.execute.terminate;
              VM.reActivate;
          if);
          clearSequenceDiagram;
          update;
          
       #);
     
     getAttName:
       (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
          OD: ^generator.ObjectDesc
       enter(off,obj[],isRef,isIndexed)
       do '?' -> nm[];
          obj.myDescInx -> compiler.newDesc.getOD -> OD[];
          find:
            OD.scanAllDecls
            (# origin:: 
                 (#
                 do (if isRef and (off = this(getAttName).off) then
                        'origin' -> NM[];
                        leave find
                 if)#)
            do (if off = currentND.off then
                   (if true
                    // not isRef and currentDcl.IT.isSimple then 
                       currentND.lexemSy -> NM[];
                       leave find
                    // isRef and not currentDcl.IT.isSimple then
                       currentND.lexemSy -> NM[];
                       leave find
                   if)
                else
                   (* Note: currentND.off may not be defined for an indexed object
                    * but isIndexed then only one repetition so
                    * the code below should work *)
                   (if isIndexed and currentDcl.IT.isIndexed then
                       currentND.lexemSy -> NM[];
                       leave find
                   if)
            if)#)
       exit NM.copy
       #);
     objectOriginOf:
       (# self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter self[]
       do self[] -> origin[];
          search:
            (if not origin.isObj then
                origin.myOrigin -> origin[];
                restart search;
            if);
       exit origin[]
       #);
     
     legit:
       (# stack: ^ObjDesc.Template;
          result: @boolean;
       enter stack[]
       do (if allocating = NONE then
              stack[] -> top.matchAny -> result;
           else
              false -> result;
          if);
       exit result
       #);
     
     stepping: @boolean;
     VMEvent:
       (# doPause: @boolean;
          shouldPause:<
            (# ok: @boolean;
            do (if stepping then
                   (if (skippingOver[] = NONE) then
                       true -> ok;
                       INNER;
                       (if ok then
                           (if mode = SkipOneMode then
                               NormalMode -> mode;
                               finishPending;
                               false -> ok;
                            else
                               (if mode = SearchingMode then
                                   false -> ok;
                               if);
                           if);
                       if);
                    else
                       finishPending;
                   if);
                else
                   finishPending;
               if);
            exit ok
            #);
          pause:
            (#
            do (if shouldPause then
                   true -> doPause;
                   refreshExecution;
               if);
            #);
       do false -> beginning;
          NONE -> recentlyResumed[];
          INNER;
       exit doPause
       #);
     onStart: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^ObjectShape;
             theInvocation: ^Invocation;
          do self[] 
               -> reflection
               -> objectShapeForTarget
               -> receiver[];
             &Invocation[] -> theInvocation[];
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
             pause;
          #);
       #);
     onAlloc: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (# shape: ^ObjectShape;
             receiver: ^ObjectShape;
             theInvocation: ^Invocation;
          do self[]
               -> reflection
               -> objectShapeForTarget
               -> shape[];
             isObj -> shape.isObject;
             isObj -> self.isObj;
             (if allocating = NONE then
                 (if isIndexed then
                     top.pop;
                     top.pop;
                 if);
                 top.pop;    
                 
                 shape[] -> receiver[];
                 &Invocation[] -> theInvocation[];
                 self[] -> theInvocation.self[];
                 true -> theInvocation.allocation;
                 isObj -> theInvocation.isObj;
                 receiver[] -> theInvocation.receiver[];
                 top[] -> theInvocation.return[];
                 theInvocation[] -> allocating;
             if);
             
          #);
       #);
     onDo: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          actual: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if self[] <> NONE then
              (# receiver: ^ObjectShape;
                 shape: ^ObjectShape;
                 message: ^ObjectShape;
                 common: ^ObjDesc.Template;
                 theInvocation: ^Invocation;
                 skip: @boolean;
              do top.flush;
                 top.pop;
                 
                 self[] -> isObscure -> skip;
                 (if NOT skip then
                     (if caller[] <> NONE then
                         (caller[], self[]) -> commonOrigin -> common[];
                         (if common[] <> none then
                             common[] -> isSkipping -> skip;
                         if);
                     if);
                 if);
                 
                 (if NOT skip then
                     self[] -> objectOriginOf -> actual[];
                     self[]
                       -> reflection
                       -> objectShapeForTarget
                       -> shape[];
                     (if (shape.isObject or (actual[] = NONE)) then
                         shape[] -> receiver[];
                      else
                         actual[] 
                           -> reflection
                           -> objectShapeForTarget
                           -> receiver[];
                         shape[] -> message[];
                         false -> message.sticky;
                     if);
                     &Invocation[] -> theInvocation[];
                     self[] -> theInvocation.self[];
                     receiver[] -> theInvocation.receiver[];
                     message[] -> theInvocation.message[];
                     theInvocation[] -> pushInvocation;
                     (if mode = SearchingMode then
                         (if LOGGING then
                             'step-over found: ' -> puttext;
                             theInvocation.description -> putline;
                         if);
                         theInvocation[] -> skippingOver[];
                         NormalMode -> mode;
                         finishPending;
                     if);
                     pause;
                 if);
              #);
          if);
       #);
     onReturn: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if allocating <> NONE then
                 (if self[] -> (allocating).match then
                     top.flush;
                     (# act: ^PrepareCall;
                     do &PrepareCall[] -> act[];
                        (allocating).return.receiver[] -> act.sender[];
                        (allocating).receiver[] -> act.receiver[];
                        act[] -> top.push;
                        (if act.receiver.isObject OR showValues then
                            pause;
                        if);
                     #);
                     NONE -> allocating;
                 if);
              else
                 (if mode = SearchingMode then
                     (if LOGGING then
                         'step-over cancel-search' -> putline;
                     if);
                     NormalMode -> mode;
                 if);
                 (if self[] -> top.match then
                     (if top[] = skippingOver[] then
                         NONE -> skippingOver[];
                         SkipOneMode -> mode;
                     if);
                     popInvocation;
                     pause;
                 if);
                 
             if);
          #);
       #);
     onBreak: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do true -> stepping;
          pause;
       #);
     onSuspend: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          
          preemptive: @boolean;
       enter (caller[], self[], origin[], bc, preemptive)
       do (if not preemptive then
              top.pop;
          if);
          (if self[] -> suspendInvocation then
              (if LOGGING then
                  'step-over suspend-pause: ' -> puttext;
                  skippingOver.description -> putline;
              if);
              NONE -> skippingOver[];
          if);
          pause;
       #);
     onResume: VMEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do top.pop;
          self[] -> resumeInvocation;
          pause;
       #);
     
     ValueEvent: VMEvent
       (# isOriginEvent: @boolean;
          shouldPause::
            (#
            do (if showValues then
                   (if not showOrigins then
                       not isOriginEvent -> OK;
                    else
                       true -> OK;
                   if);
                else
                   false -> OK;
               if);
            #);
       do INNER;
       #);
     onVPush: ValueEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          index: ^PushValue;
          value: @integer;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              (if isIndexed then
                  stack.pop -> index[];
              if);
              (if popRStack then
                  stack.pop;
              if);
              (# push: ^PushValue;
                 str: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
                 name: ^Text;
              do &PushValue[] -> push[];
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> push.value[];
                 (if off > 0 then
                     from[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, from[], false, isIndexed) -> getAttName -> name[];
                     (if index[] <> NONE then
                         '[' -> name.put;
                         index.value[] -> name.puttext;
                         ']' -> name.put;
                     if);
                     (name[], off, SimpleKind) -> att.init;
                     att[] -> push.where[];
                 if);
                 stack.receiver[] -> push.receiver[];
                 push[] -> stack.push;
              #);
              pause;
          if);
       #);
     onRPush: ValueEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, refValue[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              true -> stack.flush;
              (# push: ^PushValue;
                 str: ^Text;
                 name: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
              do (if popRStack then
                     stack.pop;
                 if);
                 &PushValue[] -> push[];
                 (if refvalue[] <> NONE then
                     (refValue.myName).copy -> str[];
                  else
                     'NONE' -> str[];
                 if);
                 '^' -> str.prepend;
                 str[] -> push.value[];
                 (if off > 0 then
                     from[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, from[], true, false) -> getAttName  -> name[];
                     'origin' -> name.equal -> isOriginEvent;
                     '[]' -> name.append;
                     (name[], off, ReferenceKind) -> att.init;
                     att[] -> push.where[];
                 if);
                 stack.receiver[] -> push.receiver[];
                 push[] -> stack.push;
              #);
              pause;
          if);
       #);
     onVStore: ValueEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          isIndexed: @boolean;
          inx: @integer;
          off: @integer;
          value: @integer;
          peek: ^Action;
          index: ^PushValue;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if from[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.peek -> peek[];
              (if peek[] <> NONE then
                  (if peek## = PrepareCall## then
                      (# prep: ^PrepareCall;
                      do peek[] -> prep[];
                         (if NOT prep.receiver.isObject then
                             stack.pop;
                          else
                             NONE -> peek[];
                         if);
                      #);
                   else
                      NONE -> peek[];
                  if);
                  (if isIndexed then
                      stack.pop -> index[];
                  if);
                  (if popRStack then
                      stack.pop;
                  if);
                  stack.pop; (* VALUE *)
               else
                  'STACK ERROR' -> putline;
                  showContext;
              if);
              (if peek[] <> NONE then
                  peek[] -> stack.push;
              if);
              (if showValues then
                  (# store: ^StoreValue;
                     str: ^Text;
                     own: ^ObjectReflector;
                     att: ^ObjectReflector.AttributeReflector;
                     name: ^Text;
                  do &StoreValue[] -> store[];
                     &Text[] -> str[];
                     value -> str.putint;
                     str[] -> store.value[];
                     
                     to[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, to[], false, isIndexed) -> getAttName  -> name[];
                     (if index[] <> NONE then
                         '[' -> name.put;
                         index.value[] -> name.puttext;
                         ']' -> name.put;
                     if);
                     (name[], off, SimpleKind) -> att.init;
                     att[] -> store.where[];
                     stack.receiver[] -> store.sender[];
                     true -> store.transient;
                     store[] -> stack.push;
                     store[] -> assigning[];
                  #);
              if);
              pause;
          if);
       #);
     onRStore: ValueEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          peek: ^Action;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, refValue[])
       do (if from[] -> legit  then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.peek -> peek[];
              (if peek## = PrepareCall## then
                  (# prep: ^PrepareCall;
                  do peek[] -> prep[];
                     (if NOT prep.receiver.isObject then
                         stack.pop;
                      else
                         NONE -> peek[];
                     if);
                  #);
               else
                  NONE -> peek[];
              if);
              (if popRStack then
                  stack.pop;
              if);
              stack.pop; (* VALUE *)
              (if peek[] <> NONE then
                  peek[] -> stack.push;
              if);
              (if showValues then
                  (# store: ^StoreValue;
                     str: ^Text;
                     own: ^ObjectReflector;
                     att: ^ObjectReflector.AttributeReflector;
                     name: ^Text;
                  do &StoreValue[] -> store[];
                     &Text[] -> str[];
                     (if refValue[] <> NONE then
                         refValue.myName -> str.puttext;
                         '^' -> str.prepend;
                      else
                         'NONE' -> str.puttext;
                     if);
                     str[] -> store.value[];
                     
                     to[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, to[], true, false) -> getAttName -> name[];
                     '[]' -> name.append;
                     (name[], off, ReferenceKind) -> att.init;
                     att[] -> store.where[];
                     
                     stack.receiver[] -> store.sender[];
                     true -> store.transient;
                     store[] -> stack.push;
                     store[] -> assigning[];
                  #);
              if);
              pause;
          if);
       #);
     onBinOp: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do 
          (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.pop;
              stack.pop;
              (# push: ^PushValue;
                 str: ^Text;
              do &PushValue[] -> push[];
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> push.value[];
                 stack.receiver[] -> push.receiver[];
                 push[] -> stack.push;
              #);
              pause;
          if);
       #);
     onUnOp: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.pop;
              (if '-' -> operator.equal then
                  (# push: ^PushValue;
                     str: ^Text;
                  do &PushValue[] -> push[];
                     &Text[] -> str[];
                     value -> str.putint;
                     str[] -> push.value[];
                     stack.receiver[] -> push.receiver[];
                     push[] -> stack.push;
                  #);
              if);
              pause;
          if);
       #);
     onJmpGT: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.pop;
              stack.pop;
              pause;
          if);
       #);
     onPop: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              (for value repeat
                   stack.pop;
                   stack.pop;
              for);
              pause;
          if);
       #);
     onError: VMEvent
       (# stack: ^Invocation;
          msg: ^Text;
          shouldPause::
            (#
            do true -> ok;
            #);
       enter msg[]
       do 'push-message: ' -> puttext;
          msg[] -> putline;
          top[] -> stack[];
          (# push: ^ErrorMessage;
             str: ^Text;
          do &ErrorMessage[] -> push[];
             msg[] -> push.value[];
             stack.receiver[] -> push.receiver[];
             push[] -> stack.push;
          #);
          pause;
       #);
     
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
              THIS(SequenceDiagram)[] -> shape.dia[];
          if);
       exit shape[]
       #);
     ObjectShapeList: Sequence
       (# Element:: ObjectShape;
       #);
     
     
     StackShape: CenterFigure
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          assign: @boolean;
          description:
            (# txt: ^Text;
            do value.copy -> txt[];
               (if where[] <> NONE then
                   ' <- ' -> txt.puttext;
                   where.description -> txt.puttext;
               if);
            exit txt[]
            #);
          init::
            (#
            enter (value[], where[], assign)
            do (# construct: @Construction;
                  valueFig: ^TextFigure;
                  whereFig: ^TextFigure;
                  row: ^RowFigure;
                  btn: ^IconButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &RowFigure[] -> row[];
                  row.init;
                  true -> row.horizontallyFlexible;
                  2 -> construct.flexhSpace -> row.add;
                  &TextFigure[] -> valueFig[];
                  valueFig.init;
                  value[] -> valueFig.content;
                  res.smallnicestyle[] -> valueFig.style;
                  res.colors.darkerCoolBrown[] -> valueFig.stroke;
                 
                  (if where[] <> NONE then
                      &TextFigure[] -> whereFig[];
                      whereFig.init;
                      where.description -> whereFig.content;
                      res.smallnicestyle[] -> whereFig.style;
                      res.colors.darkerCoolBrown[] -> whereFig.stroke;
                      valueFig[] -> row.add;
                      3 -> construct.hSpace -> row.add;
                      (if assign then
                          createForward -> row.add;
                       else
                          createBackward -> row.add;
                      if);
                      3 -> construct.hSpace -> row.add;
                      whereFig[] -> row.add;
                   else
                      valueFig[] -> row.add;
                  if);
                  2 -> construct.flexHSpace -> row.add;
                  
                  (*
                  &FieldButton[] -> btn[];
                  up[] -> createImageFigure -> btn.init;
                  6 -> construct.flexHSpace -> row.add;
                  btn[] -> row.add;
                  4 -> construct.hSpace -> row.add;*)
                  row[] -> add;
               #);
            #);
       #);
     FieldReferenceShape: CenterFigure
       (# where: ^ObjectReflector.AttributeReflector;
          assign: @boolean;
          theConnector: ^Connector;
          connectHere:
            (# x, y: @integer;
               shape: ^ObjectShape;
            enter (x, y)
            do where.owner 
                 -> objectShapeForTarget 
                 -> shape[];
               (if shape.father[] = NONE then
                   x + 60 -> shape.x;
                   y -> shape.y;
                   &shape.Drag[] -> shape.fig.theBehaviour[];
                   shape[] -> THIS(SequenceDiagram).add;
                   shape[] -> floating.append;
               if);
               (if assign then
                    (THIS(FieldReferenceShape)[], shape[], HorisontalOrientation, PenDash) 
                     -> connect
                     -> theConnector[];
                else
                   (shape[], THIS(FieldReferenceShape)[], HorisontalOrientation, PenDash) 
                     -> connect
                     -> theConnector[];
               if);
               shape.refresh;
               update;
            #);
          FieldButton: IconButton
            (# click:
                 (# 
                 do (0, 0) -> localToGlobal -> connectHere;
                 #);
               onExpand::
                 (#
                 do click;
                 #);
               onCollapse::
                 (#
                 do click;
                 #);
            #);
          init::
            (#
            enter where[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
                  row: ^RowFigure;
                  btn: ^IconButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &RowFigure[] -> row[];
                  row.init;
                  true -> row.horizontallyFlexible;
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  where.description -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> row.add;
                  
                  &FieldButton[] -> btn[];
                  (staticRef[] -> createImageFigure, NONE) -> btn.init;
                  6 -> construct.flexHSpace -> row.add;
                  btn[] -> row.add;
                  4 -> construct.hSpace -> row.add;
                  row[] -> add;
               #);
            #)
       #);
     ValueShape: CenterFigure
       (# value: ^Text;
          init::
            (#
            enter value[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  value[] -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> add;
               #);
            #);
       #);
     Lifer: Composite
       (# last:
            (# obj: ^Item;
            do (children.last).elm[] -> obj[];
            exit obj[]
            #);
       #);
     ObjectShape: Shape
       (# invocator: ^Invocation;
          live: ^Composite;
          maximum: @integer;
          expanded: @boolean;
          sticky: @boolean;
          isObject: @boolean;
          isComponent: @boolean;
          executing: @boolean;
          active: @boolean;
          reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          pane: ^RowFigure;
          body: ^ColumnFigure;
          
          
          activate:
            (#
            do true -> executing;
               true -> active;
            #);
          deactivate:
            (#
            do false -> active;
            #);
          
	  skip:
	    (# setSkip:
                 (# value: @boolean
                 enter value
                 do (# desc: ^ObjDesc;
                    do reflect.template.myObjDesc -> desc[];
                       (if value then
                           desc.OSDvisibility_SkipInternal -> reflect.template.OSDvisibility;
                        else
                           desc.OSDvisibility_Open -> reflect.template.OSDvisibility;
                       if);
                    #)
                 #);
               getSkip:
                 (# value: @boolean;
                 do (# desc: ^ObjDesc;
                    do reflect.template.myObjDesc -> desc[];
                       reflect.template.OSDvisibility = desc.OSDvisibility_SkipInternal -> value;
                    #);
                 exit value
                 #);
            enter setSkip
            exit getSkip
            #);
          selectCode:
            (# current: ^Invocation;
            do (if reflect.template.lscTop > 0 then
                   reflect.template[] -> showCode;
                else
                   (if top[] <> NONE then
                       top.selectCode;
                   if);
               if);
            #);
          obscure:
            (# setObscure:
                 (# value: @boolean;
                 enter value
                 do (# desc: ^ObjDesc;
                    do reflect.template.myObjDesc -> desc[];
                       (if value then
                           desc.OSDvisibility_Disguised -> reflect.template.OSDvisibility;
                        else
                           desc.OSDvisibility_Open -> reflect.template.OSDvisibility;
                       if);
                    #);
                 #);
               getObscure:
                 (# value: @boolean;
                 do (# desc: ^ObjDesc;
                    do reflect.template.myObjDesc -> desc[];
                       reflect.template.OSDvisibility = desc.OSDvisibility_Disguised -> value;
                    #);
                 exit value
                 #);
            enter setObscure
            exit getObscure
            #);
          
          find:
            (# att: ^ObjectReflector.AttributeReflector;
               shape: ^AttributeShape;
            enter att[]
            do searching: body.scan
                 (# type:: AttributeShape;
                 do (if att[] -> current.target.equal then
                        current[] -> shape[];
                        leave searching;
                    if);
                 #);
            exit shape[]
            #);
          
          init::
            (#
            enter reflect[]
            do (# simples: ^ObjectReflector.AttributeList;
                  space: ^SpaceFigure;
               do &RowFigure[] -> pane[];
                  pane.init;
                  true -> pane.horizontallyFlexible;
                  true -> pane.verticallyFlexible;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  &ColumnFigure[] -> body[];
                  body.init;
                  true -> body.horizontallyFlexible;
                  true -> body.verticallyFlexible;
                  body[] -> pane.add;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  (* 18 -> space.minimumHeight; *)
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  compiler[] -> reflect.collectSimples -> simples[];
                  
                  simples.scan
                  (# row: ^AttributeShape;
                  do &AttributeShape[] -> row[];
                     current[] -> row.init;
                     row[] -> body.add;
                  #);
                  
                  &ObjectFigure[] -> fig[];
                  fig.init;
                  fig[] -> add;
                  pack;
               #);
            #);
          refresh::
            (#
            do fig.title.refresh;
               body.children.scan
               (# attribute: ^AttributeShape;
               do current[] -> attribute[];
                  attribute.refresh;
               #);
               pack;
            #);
          description:
            (# value: ^Text;
            do reflect.name -> value[];
            exit value[]
            #);
          dismissConnectors:
            (# theConnectors: ^ConnectorList;
            do THIS(ObjectShape)[] -> connected -> theConnectors[];
               (if expanded then
                   body.children.scan
                   (# attribute: ^AttributeShape;
                   do current[] -> attribute[];
                      (if attribute.theConnector[] <> NONE then
                          attribute.theConnector[] -> theConnectors.append;
                      if);
                   #);
               if);
               theConnectors.scan
               (#
               do current.dismiss;
                  NONE -> current.destination[];
               #);
            #);
          pack:
            (#
            do fig.configure;
               fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          makeSticky:
            (#
            do true -> sticky;
               refresh;
               update;
            #);
          dismiss:
            (#
            do dismissConnectors;
               (if THIS(ObjectShape)[] -> floating.has then
                   THIS(ObjectShape)[] -> floating.delete;
                   THIS(ObjectShape)[] -> THIS(SequenceDiagram).remove;
               if);
               false -> sticky;
               THIS(ObjectShape).refresh;
               THIS(SequenceDiagram).refresh;
            #);
          layoutLiveObject:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> x;
               dy - 10 -> y; 
               (# top: ^Point2d;
                  p: ^Point2d;
                  bottom: ^Point2d;
                  l: ^LifeLine;
               do &Lifer[] -> live[];
                  live.init;
                  bottomAnchor -> top[];
                  top.copy -> p[];
                  (if offset < 0 then
                      (# t: ^LifeLine;
                         l1: ^LifeLine;
                         l2: ^LifeLine;
                         l3: ^LifeLine;
                         l4: ^LifeLine;
                         l5: ^LifeLine;
                         p0: ^Point2d;
                         p1: ^Point2d;
                         p2: ^Point2d;
                         p3: ^Point2d;
                         p4: ^Point2d;
                         p5: ^Point2d;
                         delta: 
                           (# exit 3 #);
                      do p.y + 5 * delta -> p.y;
                         
                         top.copy -> p0[];
                         
                         &Point2d[] -> p1[];
                         p0.y + delta -> p1.y;
                         p0.x + delta -> p1.x;
                         
                         &Point2d[] -> p2[];
                         p1.y + delta -> p2.y;
                         p0.x - delta -> p2.x;
                         
                         &Point2d[] -> p3[];
                         p2.y + delta -> p3.y;
                         p0.x + delta -> p3.x;
                         
                         &Point2d[] -> p4[];
                         p3.y + delta -> p4.y;
                         p0.x - delta -> p4.x;
                         
                         &Point2d[] -> p5[];
                         p4.y + delta -> p5.y;
                         p0.x -> p5.x;
                         
                         &LifeLine[] -> l1[];
                         l1.init;
                         p0[] -> l1.start[];
                         p1[] -> l1.end[];
                         res.colors.darkerCoolBrown[] -> l1.stroke[];
                         l1[] -> live.add;
                         
                         &LifeLine[] -> l2[];
                         l2.init;
                         p1[] -> l2.start[];
                         p2[] -> l2.end[];
                         res.colors.darkerCoolBrown[] -> l2.stroke[];
                         l2[] -> live.add;
                         
                         &LifeLine[] -> l3[];
                         l3.init;
                         p2[] -> l3.start[];
                         p3[] -> l3.end[];
                         res.colors.darkerCoolBrown[] -> l3.stroke[];
                         l3[] -> live.add;
                         
                         &LifeLine[] -> l4[];
                         l4.init;
                         p3[] -> l4.start[];
                         p4[] -> l4.end[];
                         res.colors.darkerCoolBrown[] -> l4.stroke[];
                         l4[] -> live.add;
                         
                         &LifeLine[] -> l5[];
                         l5.init;
                         p4[] -> l5.start[];
                         p5[] -> l5.end[];
                         res.colors.darkerCoolBrown[] -> l5.stroke[];
                         l5[] -> live.add;
                      #);
                  if);
                  &Point2d[] -> bottom[];
                  top.x -> bottom.x;
                  600 -> bottom.y;
                  
                  
                  &LifeLine[] -> l[];
                  l.init;
                  p[] -> l.start[];
                  bottom[] -> l.end[];
                  res.colors.darkerCoolBrown[] -> l.stroke[];
                  1 -> l.strokewidth;
                  
                  l[] -> live.add;
               #);
               THIS(ObjectShape).width -> THIS(ObjectShape).maximum;
            #);
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y + height -> p.y;
               x + width / 2 -> p.x;
            exit p[]
            #);
          topAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y -> p.y;
               x + width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y + 10 -> p.y;
               x -> p.x;
            exit p[]
            #);
          right:
            (# value: @integer;
            do (if maximum > width then
                   x + maximum -> value;
                else
                   x + width -> value;
               if);
            exit value
            #);
          hasMenu::
            (#
            do true -> yes;
            #);
          getMenu::
            (#
            do &ObjectMenu[] -> theMenu[];
               theMenu.open;
            #);
           finishMenu::
            (#
            do theMenu.close;
            #);
          ObjectMenu: Menu
            (# dismissItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do dismiss;
                           #);
                      #);
                    open::
                      (#
                      do 'Dismiss' -> name;
                      #);
                 #);
               makeStickyItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do makeSticky;
                           #);
                      #);
                    open::
                      (#
                      do 'Make Sticky' -> name;
                      #);
                 #);
               skipInternalItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do not skip -> skip;
                              (if skip then
                                  'Show Internal' -> name;
                               else
                                  'Skip Internal' ->name;
                              if);
                              THIS(ObjectShape).refresh;
                              update;
                           #);
                      #);
                    open::
                      (#
                      do (if skip then
                             'Show Internal' -> name;
                          else
                             'Skip Internal' ->name;
                         if);
                      #);
                 #);
               obscureItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do not obscure -> obscure;
                              (if obscure then
                                  'Reveal' -> name;
                               else
                                  'Disguise' ->name;
                              if);
                              THIS(ObjectShape).refresh;
                              update;
                           #);
                      #);
                    open::
                      (#
                      do (if obscure then
                             'Reveal' -> name;
                          else
                             'Disguise' ->name;
                         if);
                      #);
                 #);
               showCodeItem: @menuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do selectCode;
                           #);
                      #);
                    open::
                      (#
                      do 'Show Code' -> name;
                      #);
                 #);
               open::
                 (#
                 do dismissItem.open;
                    dismissItem[] -> append;
                    makeStickyItem.open;
                    makeStickyItem[] -> append;
                    skipInternalItem.open;
                    skipInternalItem[] -> append;
                    obscureItem.open;
                    obscureItem[] -> append;
                    showCodeItem.open;
                    showCodeItem[] -> append;
                 #);
            #);
          ObjectFigure: AdornFigure
            (# outline: ^ColumnFigure;
               title: ^TitleFigure;
               
               CollapseButton: Toggler
                 (# onCollapse::
                      (#
                      do false -> invocator.isCollapsed;
                         presentSequenceDiagram;
                      #);
                    onExpand::
                      (#
                      do true -> invocator.isCollapsed;
                         presentSequenceDiagram;
                      #);
                 #);
               
               TitleFigure: RowFigure
                 (# txtFig: ^TextFigure;
                    deco1: ^CenterFigure;
                    deco2: ^CenterFigure;
                    deco3: ^CenterFigure;
                    refresh:
                      (#
                      do (if skip then
                             res.colors.skip[] -> txtFig.stroke;
                          else
                             (if obscure then
                                 res.colors.disguised[] -> txtFig.stroke;
                              else
                                 res.colors.darkerCoolBrown[] -> txtFig.stroke;
                             if);
                         if);
                         deco2.clear;
                         (if false then
                             res.green[] 
                               -> createCircle 
                               -> deco2.add;
                         if);
                         deco1.clear;
                         (if executing then
                             (if active then
                                 cogwheel[]
                                   -> createImageFigure
                                   -> deco1.add;
                                 2 -> deco1.margin;
                              else
                                 cogwheelgray[]
                                   -> createImageFigure
                                   -> deco1.add;
                                 2 -> deco1.margin;
                             if);
                             (if isComponent then
                                 (# mn: ^ImageFigure;
                                    mh: ^ImageFigure;
                                    pn: ^ImageFigure;
                                    ph: ^ImageFigure;
                                    btn: ^Toggler;
                                 do minus[] -> createImageFigure -> mn[];
                                    minus_hilite[] -> createImageFigure -> mh[];
                                    plus[] -> createImageFigure -> pn[];
                                    plus_hilite[] -> createImageFigure -> ph[];
                                    &CollapseButton[] -> btn[];
                                    (pn[], ph[], mn[], mh[]) -> btn.init;
                                    invocator.isCollapsed -> btn.on;
                                    btn.refresh;
                                    btn[] -> deco3.add;
                                    2 -> deco3.margin;
                                 #);
                              else
                                 deco3.clear;
                             if);
                         if);
                         
                      #);
                    ExpansionButton: Toggler
                      (# onExpand::
                           (#
                           do true -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeShape;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     attribute[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                         onCollapse::
                           (#
                           do false -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeShape;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     THIS(ObjectShape)[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                      #);
                    
                    oriBtn: ^ExpansionButton;
                    
                    init::
                      (# construct: @Construction;
                      do true -> horizontallyFlexible;
                         (* 18 -> baseMinimumHeight; *)
                         2 -> construct.hSpace -> add;
                         &ExpansionButton[] -> oriBtn[];
                         (res.black[], res.black[]) -> CreateToggler -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &CenterFigure[] -> deco1[];
                         deco1.init;
                         deco1[] -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                         res.heading[] -> txtFig.style;
                         res.colors.darkerCoolBrown[] -> txtFig.stroke;
                         txtFig[] -> add;
                         &CenterFigure[] -> deco2[];
                         deco2.init;
                         deco2[] -> add;
                         4 -> construct.flexHSpace -> add;
                         &CenterFigure[] -> deco3[];
                         deco3.init;
                         deco3[] -> add;
                         2 -> construct.flexHSpace -> add;
                      #);
                 #);
               configure:
                 (# ruler: ^RulerFigure;
                    construct: @Construction;
                 do (* 18 -> baseMinimumHeight; *)
                    outline.clear;
                    title[] -> outline.add;
                    (if expanded then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.colors.darkerCoolBrown[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        8 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        pane[] -> outline.add; 
                       
                    if);
                 #);
               init::
                 (# center: ^CenterFigure;
                    background: ^Figure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                    
                    
                    (if SOLID then
                        solidborder[] -> createBackground -> background[];
                     else
                        placard[] -> createBackground -> background[];
                    if);
                    
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    
                    background[] -> center.add;
                    background[] -> center.background[];
                    -6 -> center.inset;
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    configure;
                 #);
            #);
          
          AttributeShape: RowFigure
            (# target: ^ObjectReflector.AttributeReflector;
               theConnector: ^Connector;
               valueFig: ^TextFigure;
               referenceBtn: ^ReferenceButton;
               refresh:
                 (# old: ^Text;
                    new: ^Text;
                 do valueFig.content -> old[];
                    target.textValue -> new[];
                    new[] -> valueFig.content;
                    (if updateflag then
                        (if not (new[] -> old.equal) then
                            res.red[] -> valueFig.stroke;
                         else
                            res.colors.darkerCoolBrown[] -> valueFig.stroke;
                        if);
                    if);
                    (if referenceBtn[] <> NONE then
                        referenceBtn.clear;
                        (if theConnector[] <> NONE then
                            (if theConnector.destination[] <> NONE then
                                res.green[] -> createCircle -> referenceBtn.add;
                             else
                                NONE -> theConnector[];
                                staticRef[] -> createImageFigure -> referenceBtn.add;
                            if);
                         else
                            staticRef[] -> createImageFigure -> referenceBtn.add;
                        if);
                    if);
                 #);
               
               connectHere:
                 (# other: ^ObjDesc.Template;
                    shape: ^ObjectShape;
                    x, y: @integer;
                 enter (x, y)
                 do (if theConnector[] = NONE then
                        target.reference -> other[];
                        (if other[] <> NONE then
                            other[] -> reflection
                              -> objectShapeForTarget
                              -> shape[];
                            (if shape.father[] = NONE then
                                x + 60 -> shape.x;
                                y -> shape.y;
                                &shape.Drag[] -> shape.fig.theBehaviour[];
                                shape[] -> THIS(SequenceDiagram).add;
                                shape[] -> floating.append;
                            if);
                            (THIS(AttributeShape)[], shape[], HorisontalOrientation, PenSmooth) 
                              -> connect
                              -> theConnector[];
                            true -> shape.sticky;
                            shape.refresh;
                            update;
                        if);
                    if);
                 #);
               disconnect:
                 (#
                 do (if theConnector[] <> NONE then
                        (if theConnector.destination[] <> NONE then
                            theConnector.dismiss;
                            NONE -> theConnector.destination[];
                        if);
                        NONE -> theConnector[];
                    if);
                 #);
               
               ReferenceButton: IconButton
                 (# click:
                      (#
                      do (if theConnector[] = NONE then
                             (0, 0) -> localToGlobal -> connectHere;
                          else
                             
                             disconnect;
                         if);
                         THIS(ObjectShape).refresh;
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               init::
                 (#
                 enter target[]
                 do (# txtFig: ^TextFigure;
                       
                       icon: ^RichPixmap;
                       construct: @Construction;
                       iconBtn: ^IconButton;
                       btn: ^Figure;
                    do true -> horizontallyFlexible;
                       16 -> baseMinimumHeight;
                       &TextFigure[] -> txtFig[];
                       txtFig.init;
                       target.name -> txtFig.content;
                       res.smallstyle[] -> txtFig.style;
                       res.colors.darkerCoolBrown[] -> txtFig.stroke;
                       txtFig[] -> add;
                       
                       24 -> construct.flexHSpace -> add;
                       &TextFigure[] -> valueFig[];
                       valueFig.init;
                       target.textValue -> valueFig.content;
                       res.smallnicestyle[] -> valueFig.style;
                       res.colors.darkerCoolBrown[] -> valueFig.stroke;
                       valueFig[] -> add;
                       8 -> construct.hSpace -> add;
                       (if target.kind 
                        //SimpleKind then
                           simple[] -> createImageFigure -> btn[];
                        //ReferenceKind then
                           &ReferenceButton[] -> iconBtn[] -> referenceBtn[];;
                           (staticRef[] -> createImageFigure, NONE) -> iconBtn.init;
                           iconBtn[] -> btn[];
                        //PatternKind then
                           pattern[] -> createImageFigure -> btn[];
                        //VirtualKind then
                           virtual[] -> createImageFigure -> btn[];
                        //RepetionKind then
                           array[] -> createImageFigure -> btn[];
                       if);
                       btn[] -> add;
                    #)
                 #);
            #);
       #);
     LifeLine: Line
       (#
       #);
    
     init::
       (# 
       do 0 -> offset;
          res.init;
          'thinborder3\\thinborder3' -> loadTileSet -> placard[];
          'solidborder\\solidborder' -> loadTileSet -> solidborder[];
          'rectsolidborder\\rectsolidborder' -> loadTileSet -> rectsolidborder[];
          'icons\\virtual.png' -> loadImage -> virtual[];
          'icons\\lightref.png' -> loadImage -> dynamicRef[];
          'icons\\reference.png' -> loadImage -> staticRef[];
          'icons\\array.png' -> loadImage -> array[];
          'icons\\pattern.png' -> loadImage -> pattern[];
          'icons\\simple.png' -> loadImage -> simple[];
          
          'icons\\colon.png' -> loadImage -> colon[];
          'icons\\equal.png' -> loadImage -> equal[];
          'icons\\up.png' -> loadImage -> up[];
          'icons\\cog.png' -> loadImage -> cogwheel[];
          'icons\\coggray.png' -> loadImage -> cogwheelgray[];
          
          'icons\\plus.png' -> loadImage -> plus[];
          'icons\\plus-hilite.png' -> loadImage -> plus_hilite[];
          'icons\\minus.png' -> loadImage -> minus[];
          'icons\\minus-hilite.png' -> loadImage -> minus_hilite[];
          
          lines.init;
          lines[] -> add;
          nodes.init;
          nodes[] -> add;
          
          holder.init;
          4 -> holder.margin;
          
          &RectFigure[] -> background[];
          background.init;
          res.colors.paleCoolBrown[] -> background.fill;
          true -> background.horizontallyFlexible;
          true -> background.verticallyFlexible;
          background[] -> holder.add;
          background[] -> holder.background[];
          7 -> x;
          7 -> y;
       #);
     showCode:<
       (# caller: ^objDesc.Template;
       enter caller[]
       do INNER;
       #);
     showContext:<
       (#
       do INNER;
       #);
  #);

-- windowLib: attributes --
ConsoleView: TextEditor
  (# put:
       (# ch: @char;
       enter ch
       do (# length: @integer;
             txt: ^Text;
          do contents.length -> length;
             (length, length) -> contents.selection.set;
             &Text[] -> txt[];
             ch -> txt.put;
             txt[] -> contents.insert;
             contents.selection.scrollIntoView;
          #);
       #);
  #);

SequenceCanvas: FigureCanvas
  (# refresh:
       (#
       do sequence.refreshExecution;
       #);
     sequence: @SequenceDiagram
       (# showCode::
            (#
            do caller[] -> THIS(SequenceCanvas).showCode;
            #);
          showContext::
            (#
            do THIS(SequenceCanvas).showContext;
            #);
       #);
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (caller[], self[], origin[], bc, isObj, isIndexed) -> sequence.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn -> pause;
       exit pause
       #);
     onBreak:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onBreak -> pause;
       exit pause
       #);
     onSuspend:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          preemptive: @boolean;
          pause: @boolean;
          
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) -> sequence.onSuspend -> pause;
       exit pause
       #);
     onResume:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onResume -> pause;
       exit pause
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVPush -> pause;
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRPush -> pause;
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVStore -> pause;
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRStore -> pause;
       exit pause
       #);
     onBinOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onBinOp -> pause;
       exit pause
       #);
     onUnOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onUnOp -> pause;
       exit pause
       #);
     onJmpGT:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onJmpGT -> pause;
       exit pause
       #);
     onPop:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onPop -> pause;
       exit pause
       #);
     onError:
       (# msg: ^Text;
       enter msg[]
       do msg[] -> sequence.onError;
       #);
     panner: @Tool
       (# x0: @integer;
          y0: @integer;
          o0: @integer;
          p0: @real;
          onMouseDown::
            (#
            do y -> y0;
               x -> x0;
               sequence.offset -> o0;
               panx -> p0;
            #);
          onMouseMove::
            (# dy: @integer;
               dx: @integer;
            do y - y0 -> dy;
               x - x0 -> dx;
               o0 + dy -> sequence.offset;
               p0 + dx -> panx;
               (if sequence.offset > 0 then
                   0 -> sequence.offset;
               if);
               sequence.refresh;
            #);
          onMouseUp::
            (#
            do
            #);
       #);
     
     open::
       (#
       do sequence.init;
          sequence[] -> add;
          panner[] -> clickTool[];
       #);
     eventHandler::
       (# onRefresh::
            (#
            do 
            #);
       #);
     showCode:<
       (# caller: ^objDesc.Template;
       enter caller[]
       do INNER;
       #);
     showContext:<
       (#
       do INNER;
       #);
  #);
SequenceWindow: SubWindow
  (# updater: @Timer
       (# count: @integer;
          action::
            (#
            do check;
            #);
       #);
     check:
       (# ready: @boolean;
       do (if machine[] <> NONE then
              machine.ready -> ready;
          if);
          (if ready then
              enable;
              head.update;
              updater.stop;
          if);
       #);
     machine: ^| systemenv.betaVM;
     maximum: @integer;
     onClose:<
       (#
       do INNER;
       #);
     onExpand::
       (# width, height: @integer;
       do '-- on-expand' -> putline;
          THIS(SubWindow).size -> (width, height);
          (width, maximum) -> THIS(SubWindow).size;
          true -> interior.bindBottom;
          true -> console.bindBottom;
          false -> console.bindTop;
       #);
     onCollapse::
       (# width, height: @integer;
       do false -> interior.bindBottom;
          false -> console.bindBottom;
          true -> console.bindTop;
          THIS(SubWindow).size -> (width, height);
          (width, 20 + 2 * theBorderWidth) -> THIS(SubWindow).size;
          height -> maximum;
       #);
     controls: @Sequence
       (# Element:: Control;
       #);
     disable:
       (#
       do head.row.scan
          (# btn: ^FigureCanvas.IconButton;
          do(if current## <= head.IconButton## then
                 current[] -> btn[];
                 btn.disable;
             if);
          #);
       #);
     enable:
       (#
       do head.row.scan
          (# btn: ^FigureCanvas.IconButton;
          do (if current## <= head.IconButton## then
                 current[] -> btn[];
                 btn.enable;
             if);
          #);
       #);
     heading::
       (# st: @TextStyle;
          ActionButton: IconButton
            (# onAction:<
                 (#
                 do INNER;
                 #);
               onExpand::
                 (#
                 do onAction;
                 #);
               onCollapse::
                 (#
                 do onAction;
                 #);
            #);
          playBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
		        interior.sequence.continue;
                    if);
                 #);
            #);
          stopBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
                        interior.sequence.doClose;
		        onClose;
                    if);
                 #);
            #);
          stepBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
		    	interior.sequence.step;
                    if);
                 #);
            #);
          stepOverBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
                        interior.sequence.stepOver;
                    if);
                 #);
            #);
          stepOutBtn: @ActionButton
            (# onAction::
                 (#
                 do (if machine.ready then
                        interior.sequence.stepOut;
                    if);
                 #);
            #);
          valuesCheckBox: @Toggler
            (# onExpand::
                 (#
                 do on -> interior.sequence.showValues;
                    interior.sequence.refreshExecution;
                 #);
               onCollapse::
                 (#
                 do on -> interior.sequence.showValues;
                    interior.sequence.refreshExecution;
                 #);
            #);
          originsCheckBox: @Toggler
            (#
            #);
          allocationsCheckBox: @Toggler
            (#
            #);
          historyCheckBox: @Toggler
            (#
            #);
          clearHistoryBtn: @CharButton
            (# onClick::
                 (#
                 do interior.sequence.clearHistory;
                 #);
            #);
          saveLogButton: @CharButton
            (# onClick::
                 (# output: @File;
                    i: @integer;
                 do 'log.txt' -> output.name;
                    output.openWrite;
                    events.scan
                    (# 
                    do i + 1 -> i;
                       i -> output.putInt
                       (#
                       do 6 -> width;
                       #);
                       ': ' -> output.puttext;
                       current[] -> output.putline;
                    #);
                    output.close;
                 #);
            #);
          gotoButton: @CharButton
            (# onClick::
                 (# dialog: @GoDialog
                      (# onConfirm::
                           (# value: @integer;
                           do dialog.countFld.integerContents -> value;
                              (if value -> goto then
                                  dialog.close;
                              if);
                           #);
                         onCancel::
                           (#
                           do dialog.close;
                           #);
                      #);
                    value: @integer;
                 do count -> dialog.open;
                    dialog.showModal;
                 #);
            #);
          nextButton: @CharButton
            (# onClick::
                 (#
                 do count + 1 -> goto;
                 #);
            #);
          createImageFigure:
            (# image: ^RichPixmap;
               item: ^ImageFigure;
            enter image[]
            do &ImageFigure[] -> item[];
               item.init;
               image[] -> item.content;
            exit item[]
            #);
          playImage: ^RichPixmap;
          playHiliteImage: ^RichPixmap;
          playGreyImage: ^RichPixmap;
          stopImage: ^RichPixmap;
          stopHiliteImage: ^RichPixmap;
          stopGreyImage: ^RichPixmap;
          stepImage: ^RichPixmap;
          stepHiliteImage: ^RichPixmap;
          stepGreyImage: ^RichPixmap;
          stepOverImage: ^RichPixmap;
          stepOverHiliteImage: ^RichPixmap;
          stepOverGreyImage: ^RichPixmap;
          stepOutImage: ^RichPixmap;
          stepOutHiliteImage: ^RichPixmap;
          stepOutGreyImage: ^RichPixmap;
          checkOffImage: ^RichPixmap;
          checkOnImage: ^RichPixmap;
          checkOn: ^ImageFigure;
          checkOff: ^ImageFigure;
          
         
          
          open::
            (# construct: @Construction;
               str1: ^TextFigure;
            do 'Sequence Diagram' -> label;
               24 -> construct.hSpace -> row.add;
               'icons\\play.png' -> loadImage -> playImage[];
               'icons\\play-hilite.png' -> loadImage -> playHiliteImage[];
               'icons\\play-grey.png' -> loadImage -> playGreyImage[];
               (playImage[] -> createImageFigure, 
               playHiliteImage[] -> createImageFigure)
                 -> playBtn.init;
               playGreyImage[] -> createImageFigure -> playBtn.grey[];
               playBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               
	       'icons\\stop.png' -> loadImage -> stopImage[];
               'icons\\stop-hilite.png' -> loadImage -> stopHiliteImage[];
               'icons\\stop-grey.png' -> loadImage -> stopGreyImage[];
               (stopImage[] -> createImageFigure,
               stopHiliteImage[] -> createImageFigure)
                 -> stopBtn.init;
               stopGreyImage[] -> createImageFigure -> stopBtn.grey[];
               stopBtn[] -> row.add;
               16 -> construct.hSpace -> row.add;
               
               'icons\\step-into.png' -> loadImage -> stepImage[];
               'icons\\step-into-hilite.png' -> loadImage -> stepHiliteImage[];
               'icons\\step-into-grey.png' -> loadImage -> stepGreyImage[];
               (stepImage[] -> createImageFigure,
               stepHiliteImage[] -> createImageFigure)
                 -> stepBtn.init;
               stepGreyImage[] -> createImageFigure -> stepBtn.grey[];
               stepBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'icons\\step-over.png' -> loadImage -> stepOverImage[];
               'icons\\step-over-hilite.png' -> loadImage -> stepOverHiliteImage[];
               'icons\\step-over-grey.png' -> loadImage -> stepOverGreyImage[];
               (stepOverImage[] -> createImageFigure,
               stepOverHiliteImage[] -> createImageFigure)
                 -> stepOverBtn.init;
               stepOverGreyImage[] -> createImageFigure -> stepOverBtn.grey[];
               stepOverBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'icons\\step-out.png' -> loadImage -> stepOutImage[];
               'icons\\step-out-hilite.png' -> loadImage -> stepOutHiliteImage[];
               'icons\\step-out-grey.png' -> loadImage -> stepOutGreyImage[];
               (stepOutImage[] -> createImageFigure,
               stepOutHiliteImage[] -> createImageFigure)
                 -> stepOutBtn.init;
               stepOutGreyImage[] -> createImageFigure -> stepOutBtn.grey[];
               stepOutBtn[] -> row.add;
               
               24 -> construct.hSpace -> row.add;
               
               'Verdana' -> st.name;
               8 -> st.size;
               
               
               'icons\\check-off.png' -> loadImage -> checkOffImage[];
               'icons\\check-on.png' -> loadImage -> checkOnImage[];
               
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> valuesCheckBox.init;
               valuesCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'Values' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               
               16 -> construct.hSpace -> row.add;
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> originsCheckBox.init;
               originsCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'Origins' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               
               16 -> construct.hSpace -> row.add;
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> allocationsCheckBox.init;
               allocationsCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'Allocations' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               
               16 -> construct.hSpace -> row.add;
               
               checkOnImage[] -> createImageFigure -> checkOn[];
               checkOffImage[] -> createImageFigure -> checkOff[];
               (checkOn[], checkOff[], checkOff[], checkOn[]) 
                 -> historyCheckBox.init;
               historyCheckBox[] -> row.add;
               
               2 -> construct.hSpace -> row.add;
               
               &TextFigure[] -> str1[];
               str1.init;
               'History' -> str1.content;
               white[] -> str1.stroke;
               st[] -> str1.style;
               str1[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Clear' -> clearHistoryBtn.init;
               st[] -> clearHistoryBtn.style;
               clearHistoryBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Save' -> saveLogButton.init;
               st[] -> saveLogButton.style;
               saveLogButton[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Go' -> gotoButton.init;
               st[] -> gotoButton.style;
               gotoButton[] -> row.add;
               8 -> construct.hSpace -> row.add;
               'Next' -> nextButton.init;
               st[] -> nextButton.style;
               nextButton[] -> row.add;
            #);
       #);
     LOGGING: (# exit false #);
     reflection:
       (# target: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.Template;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     keepHistory:
       (# value: @boolean;
       enter value
       do value -> interior.sequence.doKeepHistory;
       #);
     clearHistory:
       (#
       do interior.sequence.clearHistory;
       #);
     
     setCompiler:
       (# reference: ^generator;
       enter reference[]
       do reference[] -> interior.sequence.compiler[];
       #);
     setVM:
       (# reference: ^| systemenv.betaVM;
       enter reference[]
       do reference[] -> machine[];
          reference[] -> interior.sequence.VM[];
       #);
     setLog:
       (# reference: ^Object;
       enter reference[]
       do reference[] -> interior.sequence.L[];
       #);
     
     events: @Sequence
       (# element:: Text;
       #);
     printTail:
       (# j: @integer;
          K: @integer;
       do '--- break ---' -> putline;
          (10, events.size) -> min -> K;
          (for i: K repeat
               events.size - K + i -> j;
               j -> screen.putInt
               (#
               do 6 -> width;
               #);
               ': ' -> puttext;
               j -> events.get -> putline;
          for);
       #);
     
     goto:
       (# value: @integer;
          result: @boolean;
       enter value
       do (if value > count then
              value -> breakCount;
              interior.sequence.continue;
              true -> result;
          if);
       exit result
       #);
     
     breakCount: @integer;
     processEvent:
       (# pause: @boolean;
          force:
            (#
            do interior.sequence.refreshExecution;
               true -> pause;
            #);
          description:<
            (# string: ^Text;
            do &Text[] -> string[];
               INNER;
            exit string[]
            #);
          log:
            (#
            do count + 1 -> count;
               description -> events.append;
            #);
       do log;
          INNER;
          (if (not pause) then
              (if count = breakCount then
                  force;
              if);
          if);
          (if pause then
              printTail;
          if);
       exit pause
       #);
     
     
     
     onStart: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          
          description::
            (#
            do '[start ' -> string.puttext;
              'caller: ' -> string.puttext;
              caller[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'self: ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do head.historyCheckBox.on -> keepHistory;
          true -> interior.sequence.solid;
          (caller[], self[], origin[], bc) -> interior.onStart -> pause;
       #);
     onAlloc: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          description::
            (#
            do '[alloc ' -> string.puttext;
              'caller: ' -> string.puttext;
              caller[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'self: ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do true -> interior.sequence.solid;
          head.historyCheckBox.on -> keepHistory;
          not head.allocationsCheckBox.on -> interior.sequence.skipAllocations;
          (caller[], self[], origin[], bc, isObj, isIndexed) -> interior.onAlloc -> pause;
       #);
     onDo: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          description::
            (#
            do '[do ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' | ' -> string.puttext;
              self[] -> interior.sequence.objectOriginOf -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do true -> interior.sequence.solid;
          head.historyCheckBox.on -> keepHistory;
          not head.allocationsCheckBox.on -> interior.sequence.skipAllocations;
          (caller[], self[], origin[], bc) -> interior.onDo -> pause;
       #);
     onReturn: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          description::
            (#
            do '[return ' -> string.puttext;
               self[] -> nameOf -> string.puttext;
               ' ' -> string.puttext;
               'origin: ' -> string.puttext;
               origin[] -> nameOf -> string.puttext;
               ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do true -> interior.sequence.solid;
          head.historyCheckBox.on -> keepHistory;
          not head.allocationsCheckBox.on -> interior.sequence.skipAllocations;
          (caller[], self[], origin[], bc) -> interior.onReturn -> pause;
       #);
     onBreak: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          description::
            (#
            do  '[break ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> interior.onBreak -> pause;
       #);
     onSuspend: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          preemptive: @boolean;
          description::
            (#
            do '[suspend ' -> string.puttext;
              'caller: ' -> string.puttext;
              caller[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'self: ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc, preemptive)
       do (caller[], self[], origin[], bc, preemptive) -> interior.onSuspend -> pause;
       #);
     onResume: processEvent
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          description::
            (#
            do  '[resume ' -> string.puttext;
              'caller: ' -> string.puttext;
              caller[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'self: ' -> string.puttext;
              self[] -> nameOf -> string.puttext;
              ' ' -> string.puttext;
              'origin: ' -> string.puttext;
              origin[] -> nameOf -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> interior.onResume -> pause;
       #);
     printObjectV:
       (# obj: ^ObjDesc.Template;
          value: ^Text;
       enter obj[]
       do obj.myName -> value[];
       exit value[]
       #);
     onVPush: processEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          description::
            (#
            do  '[push ' -> string.puttext;
              value -> string.putint;
              ' | to: ' -> string.puttext;
              to[] -> printObjectV -> string.puttext;
              (if popRStack then
                  ' | pop' -> string.puttext;
              if);
              ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, isIndexed, inx, value) -> interior.onVPush -> pause;
       #);
     onRPush: processEvent
       (# from, to: ^ObjDesc.Template; 
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          description::
            (#
            do '[push ' -> string.puttext;
               (if refValue[] <> NONE then
                   refValue.myName -> string.puttext;
                else
                   'NONE' -> string.puttext;
               if);
	       ' | to: ' -> string.puttext;
               to[] -> printObjectV -> string.puttext;
               (if popRStack then
                   ' | pop' -> string.puttext;
               if);
               ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, refValue[])
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRPush -> pause;
       #);
     onVStore: processEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          description::
            (#
            do '[store ' -> string.puttext;
              value -> string.putint;
              ' | from: ' -> string.puttext;
              
              from[] -> printObjectV -> string.puttext;
              (if popRStack then
                  ' | pop' -> string.puttext;
              if);
              ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, isIndexed, inx, value) -> interior.onVStore -> pause;
       #);
     onRStore: processEvent
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          description::
            (#
            do '[store ' -> string.puttext;
               (if refValue[] <> NONE then
                   refValue.myName -> string.puttext;
                else
                   'NONE' -> string.putline;
               if);
               ' | from: ' -> string.puttext;
               from.myName -> string.puttext;
               (if popRStack then
                   ' | pop' -> string.puttext;
               if);
               ']' -> string.puttext;
            #);
       enter (from[], popRStack, to[], off, refValue[])
       do head.valuesCheckBox.on -> interior.sequence.showValues;
          head.originsCheckBox.on -> interior.sequence.showOrigins;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRStore -> pause;
       #);
     onBinOp: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          description::
            (#
            do '[bin-op  ' -> string.puttext;
              operator[] -> string.puttext;
              ' | ' -> string.puttext;
              to.myName -> string.puttext;
              ']' -> string.putline;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onBinOp -> pause;
       #);
     onUnOp: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          description::
            (#
            do '[un-op  ' -> string.puttext;
              operator[] -> string.puttext;
              ']' -> string.puttext;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onUnOp -> pause;
       #);
     onJmpGT: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          description::
            (#
            do '[jmp-gt  ' -> string.puttext;
               operator[] -> string.puttext;
               ']' -> string.putline;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onJmpGT -> pause;
       #);
     onPop: processEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          description::
            (#
            do '[pop  ' -> string.puttext;
               value -> string.putint;
               ']' -> string.puttext;
            #);
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> interior.onPop -> pause;
       #);
     onError:
       (# msg: ^Text;
          line: ^Text;
       enter msg[]
       do '--- ERROR ---' -> putline;
          msg.reset;
          msg.scanWhiteSpace;
          msg.getline -> line[];
          line[] -> putline;
          line[] -> interior.onError;
          '-------------' -> putline;
          disable;
          head.stopBtn.enable;
          head.update;
	  interior.refresh;
       #);
     compile:
       (# objC: ^ObjectContent.handle; mainModule: ^generator.Module; errors: ^stream
       enter objC[]
       do objC[] -> interior.sequence.compile -> (mainModule[],errors[])
       exit(mainModule[],errors[])
       #);
     execute:
       (# objC: ^ObjectContent.handle; 
       enter objC[]
       do objC[] -> interior.sequence.execute;
       #);
     
     interior: @SequenceCanvas 
       (# showCode::
            (#
            do caller[] -> THIS(SequenceWindow).showCode; 
            #);
          showContext::
            (#
            do printTail;
            #);
       #);
     
     console: @ConsoleView 
       (# contentsType::
            (# eventHandler::
                 (# onKeyDown::
                      (#
                      do (if waiting then
                             (if ch//10//13 then
                                 buffer.clear;
                                 (marker, length) -> scanText
                                 (#
                                 do ch -> buffer.put;
                                 #);
                                 buffer.newline;
                                 buffer.reset;
                                 false -> waiting;
                                 THIS(Window).hide;
                                 controls.scan
                                 (#
                                 do current.enable;
                                 #);
                                 THIS(SequenceWindow).enable;
                                 enable;
                                 THIS(Window).show;
                             if);
                         if);
                      #);
                 #);
            #);
       #);
     
     
     waiting: @boolean;
     marker: @integer;
     buffer: @text;
     
     
     put:
       (# ch: @char;
       enter ch
       do ch -> console.put;
       #);
     get:
       (# ch: @char;
       do (if not buffer.eos then
              buffer.get -> ch;
           else
              (#
              do THIS(Window).hide;
                 '-- get --' -> putline;
                 disable;
                 controls.scan
                 (#
                 do current.disable;
                 #);
                 console.contents.length -> marker;
                 (marker, marker) -> console.contents.selection.set;
                 console.contents[] -> target;
                 true -> waiting;
                 THIS(Window).showModal;
                 buffer.get -> ch;
              #);
          if);
       exit ch
       #);
     CONSOLE_HEIGHT: (# exit 120 #);
     open::
       (# w, h: @integer;
          width, height: @integer;
          create::
            (#
            do false -> flexible;
            #);
       do 100 -> updater.start;
          hide;
          THIS(Window).size -> (w, h);
          (640, 480) -> size;
          
          interior.open;
          (2, 22) -> interior.position;
          size -> (width, height);
          (width - 4, height - 24 - CONSOLE_HEIGHT) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
          
          
          console.open;
          (2, height - CONSOLE_HEIGHT) -> console.position;
          (width - 4, CONSOLE_HEIGHT - 2) -> console.size;
          true -> console.bindBottom;
          true -> console.bindRight;
          false -> console.bindTop;
          disable;
       #);
     close::
       (#
       do updater.stop;
       #);
     showCode:<
       (# caller: ^objDesc.Template;
       enter caller[]
       do INNER;
       #);
  #);

