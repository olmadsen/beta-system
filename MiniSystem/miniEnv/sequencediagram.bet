ORIGIN '~beta/postwimp/demo/chaos/diagram';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/demo/chaos/widgets';
INCLUDE '../miniCompiler/generator';

-- lib: attributes --


Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);
ObjectReflector:
  (# template: ^ObjDesc.Template;
     struct: ^Pattern;
     init:
       (# theTemplate: ^ObjDesc.Template;
       enter theTemplate[]
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
  #);

-- FigureCanvasLib: attributes --

SequenceDiagram: Diagram
  (# LOGGING: (# exit false #);
     res: @Resource;
     x, y: @integer;
     
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.Template;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter template[]
       do (#
          do template[] -> objectReflectors.lookupByTemplate -> reflect[];
             (if reflect[] = NONE then
                 &ObjectReflector[] -> reflect[];
                 template[] -> reflect.init;
                 reflect[] -> objectReflectors.append;
             if);
          #);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          
          x + 200 -> x;
       #);
     
     presentSequenceDiagram:
       (#
       do (# mark: @List;
             x: @integer;
             y: @integer;
             
             
             current: ^Invocation;
          do clear;
             24 -> x;
             48 -> y;
             start[] -> current[];
             scan:
               (if current[] <> NONE then
                   (if not (current.receiver[] -> mark.has) then
                       current.receiver[] -> mark.append;
                       (# dx: @integer;
                          a: ^Point2d;
                       do (if current.sender[] <> NONE then
                              current.sender.bottomAnchor -> a[];
                              ((x + current.receiver.target.width / 2) - a.x) - 20 -> dx;
                              (if current.action[] <> NONE then
                                  (if dx < current.action.width then
                                      dx - current.action.width -> dx;
                                      x - dx -> x;
                                  if);
                              if);
                          if);
                       #);
                       
                       (if current.allocation then
                           (x, y) -> current.receiver.layout;
                        else
                           (x, 24) -> current.receiver.layout;
                       if);
                       x + current.receiver.target.width + 7 -> x;
                       current.receiver.target[] -> add;
                       current.receiver.live[] -> add;
                   if);
                   y -> current.layout;
                   current.arrow[] -> add;
                   (if current.action[] <> NONE then
                       current.action[] -> add;
                   if);
                   y + 24 -> y;
                   current.active[] -> current[];
                   restart scan;
               if);
             update;
          #);
       #);
     
     liveObjects: @List
       (# Element:: LiveObject;
          lookupByShape:
            (# target: ^ObjectShape;
               live: ^LiveObject;
            enter target[]
            do search: scan
                 (#
                 do (if current.target[] = target[] then
                        current[] -> live[];
                        leave search;
                    if);
                 #);
            exit live[]
            #);
       #);
     liveObjectForObjectShape:
       (# target: ^ObjectShape;
          live: ^LiveObject;
       enter target[]
       do target[] -> liveObjects.lookupByShape -> live[];
          (if live[] = NONE then
              &LiveObject[] -> live[];
              target[] -> live.init;
              live[] -> liveObjects.append;
          if);
       exit live[]
       #);
     LiveObject:
       (# target: ^ObjectShape;
          live: ^Line;
          
          layout:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> target.x;
               dy - 10 -> target.y;
               (# top: ^Point2d;
                  bottom: ^Point2d;
               do bottomAnchor -> top[];
                  &Point2d[] -> bottom[];
                  top.x -> bottom.x;
                  600 -> bottom.y;
                  &Line[] -> live[];
                  live.init;
                  top[] -> live.start[];
                  bottom[] -> live.end[];
                  res.black[] -> live.stroke[];
                  1 -> live.strokewidth;
               #);
            #);
          
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + target.height -> p.y;
               target.x + target.width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + 10 -> p.y;
               target.x -> p.x;
            exit p[]
            #);
          init:
            (#
            enter target[]
            do 
            #);
          template:
            (# result: ^ObjDesc.template;
            do target.reflect.template[] -> result[];
            exit result[]
            #);
          
          description:
            (# string: ^Text;
            do target.reflect.name -> string[];
            exit string[]
            #);
       #);
     Invocation:
       (# sender: ^LiveObject;
          receiver: ^LiveObject;
          caller: ^ObjDesc.Template;
          action: ^ObjectShape;
          allocation: @boolean;
          
          active: ^Invocation;
          return: ^Invocation;
          
          arrow: ^Composite;
          arrowLine: ^Line;
          arrowHead: ^PolygonItem;
          layout:
            (# offset: @integer;
            enter offset
            do (# from: ^Point2d;
                  to: ^Point2d;
                  toAnchor: ^Point2d;
                  fromAnchor: ^Point2d;
                  
                  left: ^Point2d;
                  tip: ^Point2d;
                  right: ^Point2d;
                  mid: ^Point2d;
               do &Point2d[] -> from[];
                  &Point2d[] -> to[];
                  offset -> from.y;
                  offset -> to.y;
                  (if allocation then
                      receiver.leftAnchor -> toAnchor[];
                   else
                      receiver.bottomAnchor -> toAnchor[];
                  if);
                  toAnchor.x -> to.x;
                  
                  (if sender[] <> NONE then
                      sender.bottomAnchor -> fromAnchor[];
                      fromAnchor.x -> from.x;
                  if);
                  
                  &Composite[] -> arrow[];
                  arrow.init;
                  &Line[] -> arrowLine[];
                  arrowLine.init;
                  from[] -> arrowLine.start[];
                  to[] -> arrowLine.end[];
                  1 -> arrowLine.strokewidth;
                  res.black[] -> arrowLine.stroke[];
                  arrowLine[] -> arrow.add;
                  
                  &PolygonItem[] -> arrowHead[];
                  arrowHead.init;
                  &Point2d[] -> left[];
                  &Point2d[] -> tip[];
                  &Point2d[] -> right[];
                  to.x -> tip.x;
                  to.y -> tip.y;
                  tip.x - 5 -> left.x;
                  tip.y - 2 -> left.y;
                  tip.x - 5 -> right.x;
                  tip.y + 2 -> right.y;
                  left[] -> arrowHead.points.append;
                  tip[] -> arrowHead.points.append;
                  right[] -> arrowHead.points.append;
                  left[] -> arrowHead.points.append;
                  res.black[] -> arrowHead.stroke[];
                  res.black[] -> arrowHead.fill[];
                  arrowHead[] -> arrow.add;
                  
                  (if action[] <> NONE then
                      &Point2d[] -> mid[];
                      (from.x + to.x) / 2 -> mid.x;
                      from.y -> mid.y;
                      
                      mid.x - action.width / 2 -> action.x;
                      mid.y - action.height / 2 -> action.y;
                  if);
               #);
            #);
          
          match:
            (# caller: ^ObjDesc.Template;
               self: ^ObjDesc.Template;
               origin: ^ObjDesc.Template;
               result: @boolean;
            enter (caller[], self[], origin[])
            do (if allocation then
                   (caller[] = THIS(Invocation).caller[])
                   AND 
                   (self[] = receiver.template) 
                     -> result;
                else
                   (caller[] = THIS(Invocation).caller[])
                   AND
                   (origin[] = receiver.template)
                   AND
                   (self[] = action.reflect.template[])
                     -> result;
               if);
            exit result
            #);
          description:
            (# string: ^Text;
            do '[' -> string[];
               (if sender[] <> NONE then
                   sender.description -> string.puttext;
                   ' ' -> string.puttext;
                   (if action[] <> NONE then
                       action.reflect.name -> string.puttext;
                       ' ' -> string.puttext;
                    else
                       'allocate ' -> string.puttext;
                   if);
                else
                   'start ' -> string.puttext;
               if);
               
               (if receiver[] <> NONE then
                   receiver.description -> string.puttext;
               if);
               ']' -> string.puttext;
            exit string[]
            #);
       #);
     start: ^Invocation;
     top: ^Invocation;
     started: @boolean;
     
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do 
          (if top[] <> NONE then
              top.receiver[] -> theInvocation.sender[];
              top[] -> theInvocation.return[];
              theInvocation[] -> top.active[];
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
          presentSequenceDiagram;
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
       do top[] -> theInvocation[];
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          theInvocation.return[] -> top[];
          NONE -> top.active[];
          NONE -> theInvocation.return[];
          presentSequenceDiagram;
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do liveObjects.clear;
             self[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             &Invocation[] -> theInvocation[];
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
          #);
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# sender: ^LiveObject;
             receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do self[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             &Invocation[] -> theInvocation[];
             caller[] -> theInvocation.caller[];
             true -> theInvocation.allocation;
             receiver[] -> theInvocation.receiver[];
             theInvocation[] -> pushInvocation;
          #);
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# sender: ^LiveObject;
             receiver: ^LiveObject;
             action: ^ObjectShape;
             theInvocation: ^Invocation;
          do 
             
             
             origin[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             self[]
               -> reflection
               -> objectShapeForTarget
               -> action[];
             
             (if not started then
                 (# sender: ^LiveObject;
                    initial: ^Invocation;
                 do popping:
                      (if not (start[] = top[]) then
                          popInvocation;
                          restart popping;
                      if);
                    
                    caller[] 
                      -> reflection
                      -> objectShapeForTarget
                      -> liveObjectForObjectShape
                      -> sender[];
                    &Invocation[] -> theInvocation[];
                    start.receiver[] -> theInvocation.sender[];
                    sender[] -> theInvocation.receiver[];
                    theInvocation[] -> pushInvocation;
                 #);
                 true -> started;
             if);
             
             &Invocation[] -> theInvocation[];
             caller[] -> theInvocation.caller[];
             receiver[] -> theInvocation.receiver[];
             action[] -> theInvocation.action[];
             theInvocation[] -> pushInvocation;
          #);
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if (caller[], self[], origin[]) -> top.match then
                 popInvocation;
             if);
          #);
       #);
      
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
          if);
       exit shape[]
       #);
     ObjectShape: Shape
       (# reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          width: @integer;
          height : @integer;
          init::
            (#
            enter reflect[]
            do &ObjectFigure[] -> fig[];
               fig.init;
               fig[] -> add;
               pack;
            #);
          
          pack:
            (#
            do fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          ObjectFigure: AdornFigure
            (# navigateReference:
                 (# ref: ^Object;
                 enter ref[]
                 do (***
                     (# theClassDiagram: ^ClassDiagram;
                     do 
                     (if ref[] <> NONE then
                     dia[] -> theClassDiagram[];
                     (ref[], NONE, &Point2d[]) -> theClassDiagram.reflect;
                     if);
                     #);
                     ***)
                 #);
               TitleFigure: RowFigure
                 (# 
                    OriginButton: Toggler
                      (#
                         navigateOrigin:
                           (#
                           do reflect.ori -> navigateReference;
                           #);
                         onExpand::
                           (#
                           do navigateOrigin;
                           #);
                         onCollapse::
                           (#
                           do navigateOrigin;
                           #);
                      #);
                    ClassButton: Toggler
                      (# NavigateMenu: Menu
                           (# goThereItem: @MenuItem
                                (# eventHandler::
                                     (# onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> navigateThere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Go' -> name;
                                     #);
                                #);
                              bringItHereItem: @MenuItem
                                (# eventHandler::
                                     (# onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> navigateHere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Fetch' -> name;
                                     #);
                                #);
                              showArrowItem: @MenuItem
                                (# eventHandler::
                                     (#
                                        onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> connectHere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Connect' -> name;
                                     #);
                                #);
                              open::
                                (#
                                do goThereItem.open;
                                   goThereItem[] -> append;
                                   bringItHereItem.open;
                                   bringItHereItem[] -> append;
                                   showArrowItem.open;
                                   showArrowItem[] -> append;
                                #);
                           #);
                         
                         hasMenu::
                           (#
                           do true -> yes;
                           #);
                         getMenu::
                           (#
                           do &NavigateMenu[] -> theMenu[];
                              theMenu.open;
                           #);
                         finishMenu::
                           (#
                           do theMenu.close;
                           #);
                         navigateThere:
                           (# block: ^Pattern;
                           enter block[]
                           do (***
                               (# theClassDiagram: ^ClassDiagram;
                               do THIS(Shape).dia[] -> theClassDiagram[];
                               (if block.owner[] <> theClassDiagram.thePackage[] then
                               block.owner[] -> theClassDiagram.navi.navigateTo;
                               if);
                               #);
                               ***)
                           #);
                         navigateHere:
                           (# block: ^Pattern;
                              a: ^Point2d;
                              otherShape: ^Shape;
                           enter block[]
                           do (***
                               &Point2d[] -> a[];
                               (0, 0) -> THIS(TitleFigure).localToGlobal -> a;
                               a.x + 20 -> a.x;
                               a.y - 200 -> a.y;
                               (block[], a[]) -> this(ObjectShape).navigateToFull -> otherShape[];
                               ***)
                           exit otherShape[]
                           #);
                         connectHere:
                           (# block: ^Pattern;
                           enter block[]
                           do (***
                               (# otherShape: ^Shape;
                               theClassDiagram: ^ClassDiagram;
                               do THIS(Shape).dia[] -> theClassDiagram[];
                               block[] -> theClassDiagram.lookupPatternShape -> otherShape[];
                               (if otherShape[] = NONE then
                               block[] -> navigateHere -> otherShape[];
                               if);
                               (if otherShape[] <> NONE then
                               (THIS(Shape)[], otherShape[], verticalorientation) 
                               -> theClassDiagram.connect;
                               update;
                               if);
                               #);
                               ***)
                           #);
                         onExpand::
                           (#
                           do (if reflect.struct[] <> NONE then
                                  reflect.struct[] -> navigateHere;
                              if);
                           #);
                         onCollapse::
                           (#
                           do (if reflect.struct[] <> NONE then
                                  reflect.struct[] -> navigateHere;
                              if);
                           #);
                      #);
                    
                    
                    
                    oriBtn: ^OriginButton;
                    
                    init::
                      (# txtFig: ^TextFigure;
                         construct: @Construction;
                      do true -> horizontallyFlexible;
                         18 -> baseMinimumHeight;
                         2 -> construct.hSpace -> add;
                         &OriginButton[] -> oriBtn[];
                         (res.black[], res.black[]) -> CreateBackIcon -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                       (*  res.smallstyle[] -> txtFig.style;*)
                         res.black[] -> txtFig.stroke;
                         txtFig[] -> add;
                         2 -> construct.flexHSpace -> add;
                         
                      #);
                 #);
               init::
                 (# title: ^TitleFigure;
                    center: ^CenterFigure;
                    background: ^BorderFigure;
                    outline: ^ColumnFigure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    12 -> baseMinimumHeight;
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                    
                    &BorderFigure[] -> background[];
                    background.init;
                    BorderRaised -> background.style;
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    background[] -> center.add;
                    background[] -> center.background[];
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    title[] -> outline.add;
                    (if false then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.black[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        6 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        
                        &RowFigure[] -> pane[];
                        pane.init;
                        18 -> pane.baseMinimumHeight;
                        true -> pane.horizontallyFlexible;
                        true -> pane.verticallyFlexible;
                        pane[] -> outline.add;
                    if);
                 #);
            #);
       #);
     Construction:
       (# hSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do (#
               do &SpaceFigure[] -> space[];
                  space.init;
                  minimum -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
               #);
            exit space[]
            #);
          vSpace:
            (# 
            #);
          flexHSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do minimum -> hSpace -> space[];
               true -> space.horizontallyFlexible;
            exit space[]
            #);
          flexVSpace:
            (#
            #);
       #);
     
     init::
       (#
       do res.init;
          7 -> x;
          7 -> y;
       #);
  #);

-- windowLib: attributes --

SequenceCanvas: FigureCanvas
  (#
     sequence: @SequenceDiagram;
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart;
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onAlloc;
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onDo;
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn;
       #);
     open::
       (#
       do sequence.init;
          sequence[] -> add;
       #);
  #);
SequenceWindow: SubWindow
  (# LOGGING: (# exit false #);
     reflection:
       (# target: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.Template;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[start ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onStart;
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[alloc ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          
          (caller[], self[], origin[], bc) -> interior.onAlloc;
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[do ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onDo;
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[return ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onReturn;
       #);
    
     interior: @SequenceCanvas (# #);
     
     open::
       (# width, height: @integer;
       do interior.open;
          (10, 40) -> interior.position;
          size -> (width, height);
          (width - 20, height - 50) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
       #);
  #);

