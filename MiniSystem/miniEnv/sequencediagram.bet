ORIGIN '~beta/postwimp/demo/chaos/diagram';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/demo/chaos/widgets';
INCLUDE '../miniCompiler/generator';
INCLUDE 'objectContent';
-- lib: attributes --

Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);
SimpleKind:
  (# exit 1 #);
PatternKind:
  (# exit 2 #);
ReferenceKind:
  (# exit 3 #);
RepetionKind:
  (# exit 4 #);

ObjectReflector:
  (# template: ^ObjDesc.Template;
     struct: ^Pattern;
     init:
       (# theTemplate: ^ObjDesc.Template;
       enter theTemplate[]
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
     descriptionOf:
       (# template: ^ObjDesc.Template;
          description: ^Text;
       enter template[]
       do (# name: ^Text;
             ch: @char;
          do template.myName -> name[];
             (if name.length < 0 then
                 1 -> name.inxGet -> ch;
                 (if ch//'a'//'A'//'e'//'E'//'i'//'I'//'o'//'O'//'u'//'U' then
                     'an ' -> description[];
                  else
                     'a ' -> description[];
                 if);
                 name[] -> description.append;
             if);
          #);
       exit description[]
       #);
     collectSimples:
       (# compiler: ^generator;
          simples: ^AttributeList;
       enter compiler[]
       do (# descNo: @integer;
             theObjectDesc: ^generator.ObjectDesc;
             isRef: @boolean;
             off: @integer;
          do &AttributeList[] -> simples[];
             template.myDescInx -> descNo;
             descNo -> compiler.newDesc.getOD -> theObjectDesc[];
             (if theObjectDesc[] <> NONE then
                 theObjectDesc.scanAllDecls
                 (# name: ^Text;
                    simple: ^AttributeReflector;
                    kind: @integer;
                    offset: @integer;
		    origin::
                      (#
                      do &AttributeReflector[] -> simple[];
                         (name[], off, ReferenceKind) -> simple.init;
                         simple[] -> simples.append;
                      #);
                 do (currentND.lexemSy).copy -> name[];
                    currentND.off -> off;
                    (if off > 0 then 
                        off -> offset;
                        (if currentDcl.IT.isSimple then
                            SimpleKind -> kind;
                         else
                            ReferenceKind -> kind;
                        if)            
                     else
                        (if currentDcl.IT.isIndexed then
                            RepetionKind -> kind;
                            offset + 1 -> off;
                         else
                            PatternKind -> kind;
                        if);
                    if);
                    &AttributeReflector[] -> simple[];
                    (name[], off, kind) -> simple.init;
                    simple[] -> simples.append;
                 #);
             if);
          #);
       exit simples[]
       #);

     AttributeList: List
       (# Element:: AttributeReflector;
       #);

     AttributeReflector:
       (# theName: ^Text;
          offset: @integer;
          kind: @integer;
          init:
            (#
            enter (theName[], offset, kind)
            do 
            #);
          owner:
            (# exit THIS(ObjectReflector)[] #);
          name:
            (#
            do 
            exit theName[]
            #);
          reference:
            (# other: ^ObjDesc.Template;
            do (if (kind = ReferenceKind) and (offset > 0) then
                   template.rfields[offset][] -> other[];
               if);
            exit other[]
            #);
          description:
            (# str: ^Text;
            do theName.copy -> str[];
            exit str[]
            #);
          equal:
            (# other: ^AttributeReflector;
               result: @boolean;
            enter other[]
            do (other.kind = kind) AND (other.offset = offset) 
                 -> result;
            exit result
            #);
          textValue:
            (# theDescription: ^Text;
            do (# obj: ^ObjDesc.Template;
                  value: @integer;
               do '' -> theDescription[];
                  (if offset > 0 then
                      (if kind
                       //SimpleKind then
                          offset -> template.get -> theDescription.putint;
                       //RepetionKind then
                          (# n: @integer;
                          do offset -> template.get -> n;
                             (if n > 32 then
                                 32 -> n;
                             if);
                             (for i: n repeat
                                  offset + i -> template.get -> value;
                                  (if (value >= 32) AND (value <= 128) then
                                      value -> theDescription.put;
                                  if);
                             for);
                          #);
                       //ReferenceKind then
                          template.rfields[offset][] -> obj[];
                          (if obj[] = none then
                              'none' -> theDescription.putText;
                           else
                              (# name: ^Text;
                              do 
                                 obj.myName -> name[];
                                 (if name[] <> NONE then
                                     name[] -> theDescription.putText;
                                  else 
                                     '   ' -> theDescription.putText;
                                 if);
                              #);
                          if);
                      if)            
                   else (* pattern *)
                      '  ' -> theDescription.puttext;
                  if);
               #);
               (if theDescription.length = 0 then
                   '   ' -> theDescription.puttext;
               if);
            exit theDescription[]
            #);               
       #);
  #);

-- FigureCanvasLib: attributes --

SequenceDiagram: Diagram
  (# 
     VM: ^| systemenv.betaVM;
     L: ^Object;
     lines: @Composite;
     nodes: @Composite;
     floating: @Sequence
       (# Element:: ObjectShape;
       #);
     visibles: @Sequence
       (# Element:: ObjectShape;
       #);
     compiler: ^generator;
     LOGGING: (# exit true #);
     solid: @boolean;
     res: @Resource;
     x, y: @integer;
     doKeepHistory: @boolean;
     
     placard: ^TileSet;
     solidborder: ^TileSet;
     rectsolidborder: ^TileSet;
     
     colon: ^RichPixmap;
     equal: ^RichPixmap;
     up: ^RichPixmap;
     
     updateflag: @boolean;
     
     compile:
       (# objC: ^ObjectContent.handle; FN: ^text
       enter objC[]
       do '****************' -> putline;
          'MiniENV: compile' -> putline;
          (if true then
              objC.modulePath -> FN[];
              objC.aMod.name.lexemSy -> FN.append;
              '.bet' -> FN.append;
              FN[] -> putline;
              (L[],true,none,FN[]) -> compiler;
           else
              objC.aMod.name.lexemSy -> putline;
              (L[],false,none,objC.aMod.inFile.name) -> compiler;
          if);
          (if compiler.hasErrors then none -> compiler.rootModule[] if)
       exit objC.aMod[]
       #);
     
     execute:
       (# objC: ^ObjectContent.handle;
       enter objC[]
       do (objC.aMod.inFile.name,'..run') -> mkAuxName -> RTT.name;
          RTT.openWrite;               
          '****************' -> putline; 
          'MiniENV: execute' -> putline;
          '****************' -> putline; 
          (if not VM.execute.isRunning then
              VM.init; (* why two inits?*)
              'Exe:aMod.descNo: ' -> puttext; objC.aMod.descNo -> putint;
              ' mainDescNo: ' -> puttext; compiler.mainDescNo -> putint; newline;
              (if false then
                  (compiler.descs[],objC.aMod.descNo,RTT[]) -> VM.execute.init;
               else
                  (compiler.descs[],compiler.mainDescNo,RTT[]) -> VM.execute.init;
              if);
              VM.execute;
           else
              'VM is not terminated' -> putline
          if);                       
       #);
     RTT: @File;
     
     
     displayChain:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# current: ^ObjDesc.Template;
          do self.myName -> puttext;
             self.myOrigin -> current[];
             loop:
               (if current[] <> NONE then
                   '<-' -> puttext;
                   current.myName -> puttext;
                   current.myOrigin -> current[];
                   restart loop;
               if);
             newline;
          #);
       #);
     isOrigin:
       (# candidate: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          result: @boolean;
       enter (candidate[], self[])
       do (if self[] <> NONE then
              (if candidate[] = self[] then
                  true -> result;
               else
                  (candidate[], self.myOrigin) -> isOrigin -> result;
              if);
          if);
       exit result
       #);
     commonOrigin:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter (caller[], self[])
       do (if caller[] <> NONE then
              (if (caller[], self[]) -> isOrigin then
                  caller[] -> origin[];
               else
                  (caller.myOrigin, self[]) -> commonOrigin -> origin[];
              if);
          if);
       exit origin[]
       #);
     isSkipping:
       (# origin: ^ObjDesc.Template;
          result: @boolean;
       enter origin[]
       do (if origin[] <> NONE then
              (# shape: ^ObjectShape;
              do origin[] 
                   -> reflection
                   -> objectShapes.lookupByTarget 
                   -> shape[];
                 (if shape[] <> NONE then
                     shape.skip -> result;
                 if);
                 (if NOT result then
                     origin.myOrigin -> isSkipping -> result;
                 if);
              #);
          if);
       exit result
       #);
     
     createBackward:
       (# backward: ^Figure;
          tip: ^Point2d;
          foot: ^Point2d;
          left: ^Point2d;
          right: ^Point2d;
          head: ^PolygonItem;
          arrow: ^Line;
       do &Figure[] -> backward[];
          backward.init;
          
          &Point2d[] -> tip[];
          0 -> tip.x;
          3 -> tip.y;
          &Point2d[] -> left[];
          6 -> left.x;
          6 -> left.y;
          &Point2d[] -> right[];
          6 -> right.x;
          0 -> right.y;
          &PolygonItem[] -> head[];
          head.init;
          left[] -> head.points.append;
          tip[] -> head.points.append;
          right[] -> head.points.append;
          res.black[] -> head.stroke[];
          1 -> head.strokeWidth;
          head[] -> backward.add;
          
          &Line[] -> arrow[];
          tip[] -> arrow.start[];
          &Point2d[] -> foot[];
          12 -> foot.x;
          3 -> foot.y;
          foot[] -> arrow.end[];
          res.black[] -> arrow.stroke[];
          1 -> arrow.strokeWidth;
          arrow[] -> backward.add;
          
          12 -> backward.minimumWidth;
          6 -> backward.minimumHeight;
       exit backward[]
       #);
     createForward:
       (# forward: ^Figure;
          tip: ^Point2d;
          foot: ^Point2d;
          left: ^Point2d;
          right: ^Point2d;
          head: ^PolygonItem;
          arrow: ^Line;
       do &Figure[] -> forward[];
          forward.init;
          
          &Point2d[] -> tip[];
          12 -> tip.x;
          3 -> tip.y;
          &Point2d[] -> left[];
          6 -> left.x;
          6 -> left.y;
          &Point2d[] -> right[];
          6 -> right.x;
          0 -> right.y;
          &PolygonItem[] -> head[];
          head.init;
          left[] -> head.points.append;
          tip[] -> head.points.append;
          right[] -> head.points.append;
          res.black[] -> head.stroke[];
          1 -> head.strokeWidth;
          head[] -> forward.add;
          
          &Line[] -> arrow[];
          tip[] -> arrow.start[];
          &Point2d[] -> foot[];
          0 -> foot.x;
          3 -> foot.y;
          foot[] -> arrow.end[];
          res.black[] -> arrow.stroke[];
          1 -> arrow.strokeWidth;
          arrow[] -> forward.add;
          
          12 -> forward.minimumWidth;
          6 -> forward.minimumHeight;
       exit forward[]
       #);
     createCircle:
       (# theOvalFigure: ^OvalFigure;
          fill: ^Color;
          circle: ^CenterFigure;
       enter fill[]
       do &OvalFigure[] -> theOvalFigure[];
          theOvalFigure.init;
          fill[] -> theOvalFigure.fill;
          true -> theOvalFigure.horizontallyFlexible;
          true -> theOvalFigure.verticallyFlexible;
          &CenterFigure[] -> circle[];
          circle.init;
          theOvalFigure[] -> circle.add;
          up.width -> circle.baseMinimumWidth;
          up.height -> circle.baseMinimumHeight;
          3 -> circle.margin;
       exit circle[]
       #);
     TileSet:
       (# topleft: ^RichPixmap;
          top: ^RichPixmap;
          topright: ^RichPixmap;
          left: ^RichPixmap;
          middle: ^RichPixmap;
          right: ^RichPixmap;
          bottomleft: ^RichPixmap;
          bottom: ^RichPixmap;
          bottomright: ^RichPixmap;
          
          load:
            (# name: ^Text;
            enter name[]
            do '-topleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topleft[];
               '-top.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> top[];
               '-topright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topright[];
               '-left.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> left[];
               '-middle.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> middle[];
               '-right.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> right[];
               '-bottomleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomleft[];
               '-bottom.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottom[];
               '-bottomright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomright[];
            #);
       #);
     
     loadImage:
       (# name: ^Text;
          image: ^RichPixmap;
       enter name[]
       do (# path: ^Text;
          do &RichPixmap[] -> image[];
             'c:\\beta\\r5.5\\postwimp\\images\\' -> path[];
             name[] -> path.append;
             path[] -> image.readAlpha;
             false -> image.transparent;
          #);
       exit image[]
       #);
     loadTileSet:
       (# name: ^Text;
          tiles: ^TileSet;
       enter name[]
       do &TileSet[] -> tiles[];
          name[] -> tiles.load;
       exit tiles[]
       #);
     
     createImageFigure:
       (# image: ^RichPixmap;
          item: ^ImageFigure;
       enter image[]
       do &ImageFigure[] -> item[];
          item.init;
          image[] -> item.content;
       exit item[]
       #);
     
     createBackground:
       (# tiles: ^TileSet;
          background: ^ColumnFigure;
       enter tiles[]
       do &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             topleft: ^ImageFigure;
             top: ^ImageFigure;
             topright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.topleft[]
               -> createImageFigure 
               -> topleft[];
             false -> topleft.horizontallyFlexible;
             false -> topleft.verticallyFlexible;
             topleft[] -> row.add;
             
             tiles.top[]
               -> createImageFigure 
               -> top[];
             true -> top.horizontallyFlexible;
             false -> top.verticallyFlexible;
             top[] -> row.add;
             
             tiles.topright[]
               -> createImageFigure 
               -> topright[];
             false -> topright.horizontallyFlexible;
             false -> topright.verticallyFlexible;
             topright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          (# row: ^RowFigure;
             left: ^ImageFigure;
             middle: ^ImageFigure;
             right: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.left[]
               -> createImageFigure 
               -> left[];
             false -> left.horizontallyFlexible;
             true -> left.verticallyFlexible;
             left[] -> row.add;
             
             tiles.middle[]
               -> createImageFigure 
               -> middle[];
             true -> middle.horizontallyFlexible;
             true -> middle.verticallyFlexible;
             middle[] -> row.add;
             
             tiles.right[]
               -> createImageFigure 
               -> right[];
             false -> right.horizontallyFlexible;
             true -> right.verticallyFlexible;
             right[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
             true -> row.verticallyFlexible;
          #);
          (# row: ^RowFigure;
             bottomleft: ^ImageFigure;
             bottom: ^ImageFigure;
             bottomright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.bottomleft[]
               -> createImageFigure 
               -> bottomleft[];
             false -> bottomleft.horizontallyFlexible;
             false -> bottomleft.verticallyFlexible;
             bottomleft[] -> row.add;
             
             tiles.bottom[]
               -> createImageFigure 
               -> bottom[];
             true -> bottom.horizontallyFlexible;
             false -> bottom.verticallyFlexible;
             bottom[] -> row.add;
             
             tiles.bottomright[]
               -> createImageFigure 
               -> bottomright[];
             false -> bottomright.horizontallyFlexible;
             false -> bottomright.verticallyFlexible;
             bottomright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          background.pack;
       exit background[]
       #);
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.Template;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter template[]
       do (if template[] <> NONE then
              (#
              do template[] -> objectReflectors.lookupByTemplate -> reflect[];
                 (if reflect[] = NONE then
                     &ObjectReflector[] -> reflect[];
                     template[] -> reflect.init;
                     reflect[] -> objectReflectors.append;
                 if);
              #);
           else
              exception (#  #);
          if);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          
          x + 200 -> x;
       #);
     
     clearHistory:
       (# current: ^Invocation;
       do start[] -> current[];
          clearing:
            (if current[] <> NONE then
                current.history.clear;
                current.active[] -> current[];
                restart clearing;
            if);
          presentSequenceDiagram;
       #);
     
     presentSequenceDiagram:
       (# present:
            (# x: @integer;
               y: @integer;
               
               header: @integer;
              
               
               flatten:
                 (# 
                 do &ActionList[] -> actions[];
                    actions[] -> start.flatten;
                 #);
               actions: ^ActionList;
               
               start: ^Invocation;
            enter (start[], x, header)
            do flatten;
               actions.scan
               (# height: @integer;
               do current.prepare -> height;
                  (if height > header then
                      height -> header;
                  if);
               #);
               header + 24 -> y;
               actions.scan
               (#
               do (mark[], touched[], x, y) -> current.process -> (x, y); 
               #);
               
            exit (x, header)
            #);
          mark: @List;
          
          touched: @ObjectShapeList;
          deletion: @Sequence
            (# Element:: ObjectShape;
            #);
       do (# x, y: @integer;
          do lines.clear;
             24 -> x;
             0 -> y;
             (start[], x, y) -> present -> (x, y);
             suspended.scan
             (#
             do (current[], x, y) -> present -> (x, y);
             #);
             touched.scan
             (#
             do (if not (current[] -> visibles.has) then
                    (if current.father[] <> NONE then
                        current[] -> THIS(SequenceDiagram).remove;
                        current[] -> floating.delete;
                    if);
                    current[] -> nodes.add;
                    NONE -> current.fig.theBehaviour[];
                    current[] -> visibles.append;
                if);
             #);
             visibles.scan
             (# 
             do (if not (current[] -> touched.has) then
                    current[] -> deletion.append;
                if);
             #);
             deletion.scan
             (#
             do current.dismissConnectors;
                current.refresh;
                current[] -> nodes.remove;
                current[] -> visibles.delete;
                (if current.sticky then
                    &current.Drag[] -> current.fig.theBehaviour[];
                    current[] -> THIS(SequenceDiagram).add;
                    current[] -> floating.append;
                if);
             #);
             update;
          #);
       #);
     
     
     Decoration: Composite
       (# containsPoint::
            (#
            do NONE -> target[];
            #);
       #);
     ActionList: Sequence
       (# Element:: Action;
       #);
     Action:
       (# transient: @boolean;
          flatten:<
            (#  actions: ^ActionList;
            enter actions[]
            do INNER;
            #);
          prepare:<
            (# height: @integer;
            do INNER;
            exit height
            #);
          process:<
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
            enter (mark[], nodes[], x, y)
            do INNER;
            exit (x, y)
            #);
          finish:<
            (#
            do INNER;
            #);
          
          createArrow:
            (# lst: ^PointList;
               dash: @boolean;
               head: ^ArrowHead;
               arrow: ^Composite;
            enter (lst[], dash)
            do (# 
               do &Decoration[] -> arrow[];
                  arrow.init;   
                  (# prev: ^Point2d;
                  do lst.scan
                     (# segment: ^Line;
                     do (if prev[] <> NONE then
                            &Line[] -> segment[];
                            segment.init;
                            prev[] -> segment.start[];
                            current[] -> segment.end[];
                            1 -> segment.strokeWidth;
                            res.colors.darkerCoolBrown[] -> segment.stroke[];
                            (if dash then
                                PenDash -> segment.style;
                            if);
                            segment[] -> arrow.add;
                        if);
                        current[] -> prev[];
                     #);
                  #);
                  
                  (# start, end: ^Point2d;
                  do lst.size - 1 -> lst.get -> start[];
                     lst.size -> lst.get -> end[];
                     &ArrowHead[] -> head[];
                     head.init;
                     end[] -> head.to[];
                     start[] -> head.from[];
                     head.refresh;
                     res.colors.darkerCoolBrown[] -> head.stroke[];
                     res.colors.darkerCoolBrown[] -> head.fill[];
                     head[] -> arrow.add;
                  #);
               #);
            exit arrow[]
            #);
       #);
     Invocation: Action
       (# receiver: ^ObjectShape;
          self: ^ObjDesc.Template;
          message: ^ObjectShape;
          
          allocation: @boolean;
          isObj: @boolean;
          isReturn: @boolean;
          
          history: @List
            (# Element:: Invocation;
            #);
          stack: @Sequence
            (# Element:: Action;
               peek:
                 (# elm: ^Element;
                 do (if NOT empty then
                        last -> elm[];
                    if);
                 exit elm[]
                 #);
               pop:
                 (# elm: ^Element;
                 do (if NOT empty then
                        deleteLast -> elm[];
                    if);
                 exit elm[]
                 #);
               push:
                 (# elm: ^Element;
                 enter elm[]
                 do elm[] -> append;
                 #);
            #);
          
          peek:
            (# theAction: ^Action;
            do stack.peek -> theAction[];
            exit theAction[]
            #);
          pop:
            (# theAction: ^Action;
            do stack.pop -> theAction[];
            exit theAction[]
            #);
          push:
            (# theAction: ^Action;
            enter theAction[]
            do theAction[] -> stack.push;
            #);
          
          flush:
            (# top: ^Action;
            do peek -> top[];
               (if top[] <> NONE then
                   top.finish;
               if);
               while:
                 (if top[] <> NONE then
                     (if top.transient then
                         pop;
                         peek -> top[];
                         restart while;
                     if);
                 if);
               
            #);
          copy:
            (# new: ^Invocation;
            do &Invocation[] -> new[];
               receiver[] -> new.receiver[];
               allocation -> new.allocation;
               return[] -> new.return[];
            exit new[]
            #);
          finish::
            (#
            do stack.scan
               (#
               do current.finish;
               #);
               flush;
            #);
          active: ^Action;
          return: ^Invocation;
          pts: ^PointList;
          arrow: ^Composite;
          
          flatten::
            (#
            do THIS(Invocation)[] -> actions.append;
               history.scan
               (#
               do actions[] -> current.flatten; 
               #);
               stack.scan
               (#
               do actions[] -> current.flatten;
               #);
            #);
          prepare::
            (#
            do (if not (THIS(Invocation)[] = return[]) then
                   receiver.refresh;
                   (if message[] <> NONE then
                       message.refresh;
                   if);
               if);
               (if not allocation then
                   receiver.height -> height;
               if);
            #);
          process::
            (# dy: @integer;
               sender: ^ObjectShape;
            do 
               (if return[] <> NONE then
                   return.receiver[] -> sender[];
               if);
               (if receiver[] = sender[] then
                   50 -> dy;
                else
                   30 -> dy;
               if);
               (if not (receiver[] -> mark.has) then
                   receiver[] -> mark.append;
                   (# dx: @integer;
                      a: ^Point2d;
                      width: @integer;
                   do (if sender[] <> NONE then
                          sender.bottomAnchor -> a[];
                          ((x + receiver.width / 2) - a.x) - 20 -> dx;
                          sender.maximum -> width;
                          (if message[] <> NONE then
                              (if width < message.width then
                                  message.width -> width;
                              if);
                          if);
                          (if dx < width then
                              width - dx -> dx;
                              x + dx -> x;
                          if);
                      if);
                   #);
                   
                   (if allocation then
                       (x, y) -> receiver.layoutLiveObject;
                       receiver.height + 4 -> dy;
                    else
                       (x, 24) -> receiver.layoutLiveObject;
                   if);
                   x + receiver.width + 7 -> x;
                   receiver[] -> nodes.append;
                   receiver.live[] -> lines.add;
               if);
               
               y -> layout;
               (if message[] <> NONE then
                   (if (message.height + 4) > dy then
                       message.height + 4 -> dy;
                   if);
               if);
               
               (if arrow[] <> NONE then
                   arrow[] -> lines.add;
               if);
               (if message[] <> NONE then
                   message[] -> mark.append;
                   message[] -> nodes.append;
               if);
               y + dy -> y;
            #);
          swap:
            (# lst: ^PointList;
            do (if pts[] <> NONE then
                   &PointList[] -> lst[];
                   pts.scan
                   (#
                   do current[] -> lst.prepend;
                   #);
                   (lst[], true) -> makeArrow;
                   (* PenDash -> arrowLine.style; *)
               if);
            #);
          
          makeArrow:
            (# lst: ^PointList;
               dash: @boolean;
            enter (lst[], dash)
            do (lst[], dash) -> createArrow -> arrow[];
               (if message[] <> NONE then
                   (# start, end: ^Point2d;
                      mid: ^Point2d;
                   do 1 -> lst.get -> start[];
                      2 -> lst.get -> end[];
                      &Point2d[] -> mid[];
                      (start.x + end.x) / 2 -> mid.x;
                      start.y -> mid.y;
                      mid.x - message.width / 2 -> message.x;
                      mid.y - 10 -> message.y;
                   #);
               if);
               lst[] -> pts[];
            #);
          
          layout:
            (# sender: ^ObjectShape;
               offset: @integer;
               layoutRegular:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if allocation and (not isReturn) then
                        receiver.leftAnchor -> toAnchor[];
                     else
                        receiver.bottomAnchor -> toAnchor[];
                    if);
                    toAnchor.x -> to.x;
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    (lst[], false) -> makeArrow;
                 #);
               layoutSelf:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    lower: ^Point2d;
                    end: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                    width: @integer;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if message[] <> NONE then
                        from.x + message.width + 20 -> to.x;
                     else
                        from.x + 60 -> to.x;
                    if);
                    
                    (to.x - from.x) -> width;
                    (if width > sender.maximum then
                        width -> sender.maximum;
                    if);
                    
                    &Point2d[] -> lower[];
                    to.x -> lower.x;
                    to.y + 30 -> lower.y;
                    &Point2d[] -> end[];
                    from.x -> end.x;
                    from.y + 30 -> end.y;
                    
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    lower[] -> lst.append;
                    end[] -> lst.append;
                    (lst[], false) -> makeArrow;
                 #);
            enter offset
            do (if return[] <> NONE then
                   return.receiver[] -> sender[];
               if);
               (if sender[] <> NONE then
                   (if sender[] = receiver[] then
                       layoutSelf;
                       (if isReturn then
                           (pts[], true) -> makeArrow;
                       if);
                    else
                       layoutRegular;
                       (if isReturn then
                           swap;
                       if);
                   if);
               if);
            #);
          
          match:
            (# self: ^ObjDesc.Template;
               result: @boolean;
            enter self[]
            do self[] = THIS(Invocation).self[] -> result;;
            exit result
            #);
          description:
            (# string: ^Text;
               sender: ^ObjectShape;
            do '[' -> string[];
               (if message[] <> NONE then
                   message.reflect.name -> string.puttext;
                   ' ' -> string.puttext;
                else
                   'allocate ' -> string.puttext;
                   (if receiver[] <> NONE then
                       receiver.description -> string.puttext;
                   if);
               if);
               (if return[] <> NONE then
                   return.receiver[] -> sender[];
               if);
               (if sender[] <> NONE then
                   ' | ' -> string.puttext;
                   sender.description -> string.puttext;
                else
                   ' | start ' -> string.puttext;
               if);
               ']' -> string.puttext;
            exit string[]
            #);
       #);
     ReturnValue: Action
       (#
       #);
     PushValue: Action
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          receiver: ^ObjectShape;
          
          flatten::
            (#
            do THIS(PushValue)[] -> actions.append;
            #);
          prepare::
            (#
            #);
          
          process::
            (#
            do (mark[], nodes[], x, y) -> displayOne -> (x, y);
            #);
          displayOne:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               shape: ^StackShape;
            enter (mark[], nodes[], x, y)
            do receiver.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], false) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
               y + 22 -> y;
            exit (x, y)
            #);
          displayTwo:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               p1: ^Point2d;
               p2: ^Point2d;
               pts: ^PointList;
               shape: ^ValueShape;
               field: ^FieldReferenceShape;
            enter (mark[], nodes[], x, y)
            do receiver.bottomAnchor -> anchor[];
               
               &ValueShape[] -> shape[];
               value.copy -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
               
               (if where[] <> NONE then
                   &FieldReferenceShape[] -> field[];
                   where[] -> field.init;
                   field.pack;
                   shape.x + shape.width + 20 -> field.x;
                   y - (field.height / 2) -> field.y;
                   field[] -> lines.add;
                   
                   &PointList[] -> pts[];
                   &Point2d[] -> p1[];
                   &Point2d[] -> p2[];
                   shape.x + shape.width -> p1.x;
                   field.x -> p2.x;
                   y -> p1.y;
                   y -> p2.y;
                   p2[] -> pts.append;
                   p1[] -> pts.append;
                   (pts[], true) -> createArrow -> lines.add;
               if);
               y + 22 -> y;
            exit (x, y)
            #);
          finish::
            (#
            do NONE -> where[];
            #);
       #);
     StoreValue: Action
       (# value: ^Text;
          sender: ^ObjectShape;
          where: ^ObjectReflector.AttributeReflector;
          flatten::
            (#
            do THIS(StoreValue)[] -> actions.append;
            #);
          prepare::
            (#
            do 
            #);
          displayTwo:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
            enter (mark[], nodes[], x, y)
            do (# anchor: ^Point2d;
                  p1: ^Point2d;
                  p2: ^Point2d;
                  pts: ^PointList;
                  shape: ^ValueShape;
                  field: ^FieldReferenceShape;
                  distance: @integer;
               do sender.bottomAnchor -> anchor[];
                  &ValueShape[] -> shape[];
                  value[] -> shape.init;
                  shape.pack;
                  anchor.x - (shape.width / 2) -> shape.x;
                  y - (shape.height / 2) -> shape.y;
                  shape[] -> lines.add;
                  
                  (if where[] <> NONE then
                      &FieldReferenceShape[] -> field[];
                      true -> field.assign;
                      where[] -> field.init;
                      field.pack;
                      shape.x + shape.width + 20 -> field.x;
                      y - (field.height / 2) -> field.y;
                      field[] -> lines.add;
                      
                      (field.x + field.width) - anchor.x -> distance;
                      
                      &PointList[] -> pts[];
                      &Point2d[] -> p1[];
                      &Point2d[] -> p2[];
                      shape.x + shape.width -> p1.x;
                      field.x -> p2.x;
                      y -> p1.y;
                      y -> p2.y;
                      p1[] -> pts.append;
                      p2[] -> pts.append;
                      (pts[], true) -> createArrow -> lines.add;
                      (if false then
                          (# receiver: ^ObjectShape;
                          do where.owner -> objectShapeForTarget -> receiver[];
                             (if not (receiver[] -> mark.has) then
                                 receiver[] -> mark.append;
                                 (# dx: @integer;
                                    a: ^Point2d;
                                    width: @integer;
                                 do (if sender[] <> NONE then
                                        sender.bottomAnchor -> a[];
                                        ((x + receiver.width / 2) - a.x) - 20 -> dx;
                                        sender.maximum -> width;
                                        (if width < distance then
                                            distance -> width;
                                        if);
                                        (if dx < width then
                                            width - dx -> dx;
                                            x + dx -> x;
                                        if);
                                    if);
                                 #);
                                 (x, 24) -> receiver.layoutLiveObject;
                                 x + receiver.width + 7 -> x;
                                 receiver[] -> nodes.append;
                             if);
                          #);
                      if);
                  if);
                  y + 22 -> y;
               #);
            exit (x, y)
            #);
          displayOne:
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
               
               anchor: ^Point2d;
               shape: ^StackShape;
            enter (mark[], nodes[], x, y)
            do sender.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], true) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
               y + 22 -> y;
            exit (x, y)
            #);
          process::
            (# 
            do (mark[], nodes[], x, y) -> displayOne -> (x, y);
            #);
       #);
     PrepareCall: Action
       (# sender: ^ObjectShape;
          receiver: ^ObjectShape;
          flatten::
            (#
            do THIS(PrepareCall)[] -> actions.append;
            #);
          process::
            (# anchor: ^Point2d;
               pts: ^PointList;
               p1: ^Point2d;
               p2: ^Point2d;
            do sender.bottomAnchor -> anchor[];
               (if not (receiver[] -> mark.has) then
                   receiver[] -> mark.append;
                   (# dx: @integer;
                      a: ^Point2d;
                      width: @integer;
                   do (if sender[] <> NONE then
                          sender.bottomAnchor -> a[];
                          ((x + receiver.width / 2) - a.x) - 20 -> dx;
                          sender.maximum -> width;
                          (if dx < width then
                              width - dx -> dx;
                              x + dx -> x;
                          if);
                      if);
                   #);
                   (x, y) -> receiver.layoutLiveObject;
                   x + receiver.width + 7 -> x;
                   receiver[] -> nodes.append;
                   &Point2d[] -> p1[];
                   &Point2d[] -> p2[];
                   y -> p1.y;
                   y -> p2.y;
                   anchor.x -> p2.x;
                   receiver.x -> p1.x;
                   &PointList[] -> pts[];
                   p1[] -> pts.append;
                   p2[] -> pts.append;
                   (pts[], true) -> createArrow -> lines.add;
               if);
               y + 22 -> y;
            #);
       #);
     
     skipAllocations: @boolean;
     showValues: @boolean;
     skippingOver: ^Invocation;
     start: ^Invocation;
     top: ^Invocation;
     suspended: @Sequence
       (# Element:: Invocation;
       #);
     returning: ^Invocation;
     assigning: ^StoreValue;
     started: @boolean;
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do (if top[] <> NONE then
              top.flush;
              top[] -> theInvocation.return[];
              theInvocation[] -> top.push;
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
          return: ^Invocation;
       do top[] -> returning[];
          top[] -> theInvocation[];
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          theInvocation.return[] -> top[];
          theInvocation.copy -> return[];
          true -> return.isReturn;
          return[] -> top.push;
       #);
     suspendInvocation:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# current: ^Invocation;
             link: ^Invocation;
          do top[] -> current[];
             while:
               (if current[] <> NONE then
                   (if NOT (self[] -> current.match) then
                       current.return[] -> current[];
                       restart while;
                   if);
               if);
             (if current[] <> NONE then
                 (if LOGGING then
                     'SUSPEND ' -> puttext;
                     current.description -> putline;
                 if);
                 current.return[] -> link[];
                 top[] -> current.return[];
                 link[] -> top[];
                 (if (top.peek = current[]) then
                     true -> (top.peek).transient;
                 if);
                 current[] -> suspended.append;
             if);
          #);
       #);
     resumeInvocation:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# candidate: ^Invocation;
             link: ^Invocation;
          do search:
               suspended.scan
               (#
               do (if self[] -> current.match then
                      current[] -> candidate[];
                      leave search;
                  if);
               #);
             (if candidate[] <> NONE then
                 top.flush;
                 top[] -> link[];
                 candidate.return[] -> top[];
                 link[] -> candidate.return[];
                 candidate[] -> link.push;
                 false -> candidate.transient;
                 candidate[] -> suspended.delete;
                 (if LOGGING then
                     'RESUME ' -> puttext;
                     candidate.description -> putline;
                 if);
             if);
          #);
       #);
     refreshExecution:
       (#
       do true -> updateFlag;
          refresh;
          false -> updateFlag;
       #);
     refresh:
       (# 
       do presentSequenceDiagram;
          floating.scan
          (#
          do current.refresh;
          #);
          refreshConnectors;
       #);
     
     terminate:
       (#
       do start.finish;
          refreshExecution;
          true -> isTerminated;
       #);
     
     isTerminated: @boolean;
     
     finishPending:
       (# pending: @boolean;
       do (if returning[] <> NONE then
              top.pop;
              top.pop;
              returning.stack.scan
              (# pv: ^PushValue;
              do (if current## = PushValue## then
                     current[] -> pv[];
                     top.receiver[] -> pv.receiver[];
                     pv[] -> top.push;
                 if);
              #);
              NONE -> returning[];
              refresh;
              true -> pending;
           else 
              (if assigning[] <> NONE then
                  top.pop;
                  NONE -> assigning[];
                  refresh;
                  true -> pending;
              if);
          if);
       exit pending
       #);
     reActivate:
       (#
       do VM.reActivate;
          (if NOT VM.execute.isRunning then
              terminate;
          if);
       #);
     step:
       (# pending: @boolean;
       do finishPending -> pending;
          (if NOT pending then
              reActivate;
          if);
       #);
     stepOut:
       (# pending: @boolean;
       do 'STEP OUT ' -> puttext;
          top.description -> putline;
          finishPending -> pending;
          top[] -> skippingOver[];
          popInvocation;
          reActivate;
       #);
     continue:
       (#
       do finishPending;
          reActivate;
       #);
     doClose:
       (#
       #);
     
      getAttName:
       (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
          OD: ^generator.ObjectDesc
       enter(off,obj[],isRef,isIndexed)
       do '?' -> nm[];
          obj.myDescInx -> compiler.newDesc.getOD -> OD[];
          find:
            OD.scanAllDecls
            (# origin:: 
                 (#
                 do (if isRef and (off = this(getAttName).off) then
                        'origin' -> NM[];
                        leave find
                 if)#)
            do (if off = currentND.off then
                   (if true
                    // not isRef and currentDcl.IT.isSimple then 
                       currentND.lexemSy -> NM[];
                       leave find
                    // isRef and not currentDcl.IT.isSimple then
                       currentND.lexemSy -> NM[];
                       leave find
                   if)
                else
                   (* Note: currentND.off may not be defined for an indexed object
                    * but isIndexed then only one repetition so
                    * the code below should work *)
                   (if isIndexed and currentDcl.IT.isIndexed then
                       currentND.lexemSy -> NM[];
                       leave find
                   if)
            if)#)
       exit NM.copy
       #);
     objectOriginOf:
       (# self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter self[]
       do self[] -> origin[];
          search:
            (if not origin.isObj then
                origin.myOrigin -> origin[];
                restart search;
            if);
       exit origin[]
       #);
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^ObjectShape;
             theInvocation: ^Invocation;
          do self[] 
               -> reflection
               -> objectShapeForTarget
               -> receiver[];
             &Invocation[] -> theInvocation[];
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
             refreshExecution;
             true -> pause;
          #);
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (# shape: ^ObjectShape;
             receiver: ^ObjectShape;
             theInvocation: ^Invocation;
          do self[]
               -> reflection
               -> objectShapeForTarget
               -> shape[];
             isObj -> shape.isObject;
             (if skippingOver[] = NONE then
                 (if showValues then
                     (if isIndexed then
                         top.pop;
                         top.pop;
                     if);
                     top.pop;    
                 if);
                 
                 shape[] -> receiver[];
                 &Invocation[] -> theInvocation[];
                 self[] -> theInvocation.self[];
                 true -> theInvocation.allocation;
                 isObj -> theInvocation.isObj;
                 receiver[] -> theInvocation.receiver[];
                 (if skipAllocations then
                     top[] -> theInvocation.return[];
                     theInvocation[] -> skippingOver[];
                  else
                     (if isObj or showValues then
                         theInvocation[] -> pushInvocation;
                         refreshExecution; 
                         true -> pause;
                     if);
                 if);
             if);
	    
          #);
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          actual: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (if skippingOver[] = NONE then
              (if self[] <> NONE then
                  (# receiver: ^ObjectShape;
                     shape: ^ObjectShape;
                     message: ^ObjectShape;
                     common: ^ObjDesc.Template;
                     theInvocation: ^Invocation;
                     skip: @boolean;
                  do 
                     (if showValues or self.isObj then
                         top.pop;
                     if);
                     
                     (if caller[] <> NONE then
                         (caller[], self[]) -> commonOrigin -> common[];
                         (if common[] <> none then
                             common[] -> isSkipping -> skip;
                         if);
                     if);
                     
                     (if NOT skip then
                         self[] -> objectOriginOf -> actual[];
                         self[]
                           -> reflection
                           -> objectShapeForTarget
                           -> shape[];
                         (if (shape.isObject or (actual[] = NONE)) then
                             shape[] -> receiver[];
                          else
                             actual[] 
                               -> reflection
                               -> objectShapeForTarget
                               -> receiver[];
                             shape[] -> message[];
                             false -> message.sticky;
                         if);
                         &Invocation[] -> theInvocation[];
                         self[] -> theInvocation.self[];
                         receiver[] -> theInvocation.receiver[];
                         message[] -> theInvocation.message[];
                         theInvocation[] -> pushInvocation;
                         refreshExecution;
                         true -> pause;
                     if);
                  #);
              if);
          if);
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if skippingOver[] <> NONE then
                 (if self[] -> skippingOver.match then
                     top.flush;
                     (if (skippingOver.isObj OR (showValues AND skippingOver.allocation)) then
                         (# act: ^PrepareCall;
                         do &PrepareCall[] -> act[];
                            skippingOver.return.receiver[] -> act.sender[];
                            skippingOver.receiver[] -> act.receiver[];
                            (if not showValues then
                                skippingOver.isObj -> act.transient;
                            if);
                            act[] -> top.push;
                            true -> pause;
                            refreshExecution;
                         #);
                      else
                         (if NOT skippingOver.allocation then
                             true -> pause;
                             refreshExecution;
                             skippingOver.description -> putline;
                             (if returning[] <> NONE then
                                 returning.description -> putline;
                              else
                                 newline;
                             if);
                         if);
                     if);
                     NONE -> skippingOver[];
                 if);
              else
                 (if self[] -> top.match then
                     popInvocation;
                     true -> pause;
		     refreshExecution;
                 if);
             if);
          #);
       exit pause
       #);
     onSuspend:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do self[] -> suspendInvocation;
          true -> pause;
          refreshExecution;
       exit pause
       #);
     onResume:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do self[] -> resumeInvocation;
          true -> pause;
          refreshExecution;
       exit pause
       #);
     legit:
       (# stack: ^ObjDesc.Template;
          result: @boolean;
       enter stack[]
       do (if showValues then
              (if skippingOver[] = NONE then
                  true -> result;
               else
                  (if NOT skippingOver.allocation then
                      stack[] -> skippingOver.match -> result;
                   else
                      false -> result;
                  if);
              if);
           else
              false -> result;
          if);
       exit result
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          index: ^PushValue;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if to[] -> legit then
              top.flush;
              (if isIndexed then
                  top.pop -> index[];
              if);
              (if popRStack then
                  top.pop;
              if);
              (# push: ^PushValue;
                 str: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
                 name: ^Text;
              do &PushValue[] -> push[];
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> push.value[];
                 (if off > 0 then
                     from[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, from[], false, isIndexed) -> getAttName -> name[];
                     (if index[] <> NONE then
                         '[' -> name.put;
                         index.value[] -> name.puttext;
                         ']' -> name.put;
                     if);
                     (name[], off, SimpleKind) -> att.init;
                     att[] -> push.where[];
                 if);
                 top.receiver[] -> push.receiver[];
                 push[] -> top.push;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
          
       enter (from[], popRStack, to[], off, refValue[])
       do (if to[] -> legit then
              top.flush;
              (# push: ^PushValue;
                 str: ^Text;
                 name: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
              do (if popRStack then
                     top.pop;
                 if);
                 &PushValue[] -> push[];
                 (refValue.myName).copy -> str[];
                 str[] -> push.value[];
                 (if off > 0 then
                     from[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, from[], true, false) -> getAttName  -> name[];
                     (name[], off, ReferenceKind) -> att.init;
                     att[] -> push.where[];
                 if);
                 top.receiver[] -> push.receiver[];
                 push[] -> top.push;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          isIndexed: @boolean;
          inx: @integer;
          off: @integer;
          value: @integer;
          pause: @boolean;
          peek: ^Action;
          index: ^PushValue;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if from[] -> legit then
              top.flush;
              top.peek -> peek[];
              (if peek## = PrepareCall## then
                  top.pop;
               else
                  NONE -> peek[];
              if);
              (if isIndexed then
                  top.pop -> index[];
              if);
              (if popRStack then
                  top.pop;
              if);
              top.pop; (* VALUE *)
              (if peek[] <> NONE then
                  peek[] -> top.push;
              if);
              (# store: ^StoreValue;
                 str: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
                 name: ^Text;
              do &StoreValue[] -> store[];
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> store.value[];
                 
                 to[] 
                   -> reflection
                   -> own[];
                 &own.AttributeReflector[] -> att[];
                 (off, to[], false, isIndexed) -> getAttName  -> name[];
                 (if index[] <> NONE then
                     '[' -> name.put;
                     index.value[] -> name.puttext;
                     ']' -> name.put;
                 if);
                 (name[], off, SimpleKind) -> att.init;
                 att[] -> store.where[];
                 
                 top.receiver[] -> store.sender[];
                 true -> store.transient;
                 store[] -> top.push;
                 store[] -> assigning[];
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if from[] -> legit  then
              top.flush;
              (if popRStack then
                  top.pop;
              if);
              top.pop;
              (# store: ^StoreValue;
                 str: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
                 name: ^Text;
              do &StoreValue[] -> store[];
                 &Text[] -> str[];
                 refValue.myName -> str.puttext;
                 str[] -> store.value[];
                 
                 to[] 
                   -> reflection
                   -> own[];
                 &own.AttributeReflector[] -> att[];
                 (off, to[], true, false) -> getAttName -> name[];
                 (name[], off, SimpleKind) -> att.init;
                 att[] -> store.where[];
                 
                 top.receiver[] -> store.sender[];
                 true -> store.transient;
                 store[] -> top.push;
                 store[] -> assigning[];
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onBinOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              top.flush;
              top.pop;
              top.pop;
              (# push: ^PushValue;
                 str: ^Text;
              do &PushValue[] -> push[];
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> push.value[];
                 top.receiver[] -> push.receiver[];
                 push[] -> top.push;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onUnOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              top.flush;
              top.pop;
              (if '-' -> operator.equal then
                  (# push: ^PushValue;
                     str: ^Text;
                  do &PushValue[] -> push[];
                     &Text[] -> str[];
                     value -> str.putint;
                     str[] -> push.value[];
                     top.receiver[] -> push.receiver[];
                     push[] -> top.push;
                  #);
              if);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onJmpGT:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              top.flush;
              top.pop;
              top.pop;
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
              THIS(SequenceDiagram)[] -> shape.dia[];
          if);
       exit shape[]
       #);
     ObjectShapeList: Sequence
       (# Element:: ObjectShape;
       #);
     
     
     StackShape: CenterFigure
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          assign: @boolean;
          description:
            (# txt: ^Text;
            do value.copy -> txt[];
               (if where[] <> NONE then
                   ' <- ' -> txt.puttext;
                   where.description -> txt.puttext;
               if);
            exit txt[]
            #);
          init::
            (#
            enter (value[], where[], assign)
            do (# construct: @Construction;
                  valueFig: ^TextFigure;
                  whereFig: ^TextFigure;
                  row: ^RowFigure;
                  btn: ^IconButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &RowFigure[] -> row[];
                  row.init;
                  true -> row.horizontallyFlexible;
                  2 -> construct.flexHSpace -> row.add;
                  &TextFigure[] -> valueFig[];
                  valueFig.init;
                  value[] -> valueFig.content;
                  res.smallnicestyle[] -> valueFig.style;
                  res.colors.darkerCoolBrown[] -> valueFig.stroke;
                 
                  (if where[] <> NONE then
                      &TextFigure[] -> whereFig[];
                      whereFig.init;
                      where.description -> whereFig.content;
                      res.smallnicestyle[] -> whereFig.style;
                      res.colors.darkerCoolBrown[] -> whereFig.stroke;
                      valueFig[] -> row.add;
                      3 -> construct.hSpace -> row.add;
                      (if assign then
                          createForward -> row.add;
                       else
                          createBackward -> row.add;
                      if);
                      3 -> construct.hSpace -> row.add;
                      whereFig[] -> row.add;
                   else
                      valueFig[] -> row.add;
                  if);
                  2 -> construct.flexHSpace -> row.add;
                  
                  (*
                  &FieldButton[] -> btn[];
                  up[] -> createImageFigure -> btn.init;
                  6 -> construct.flexHSpace -> row.add;
                  btn[] -> row.add;
                  4 -> construct.hSpace -> row.add;*)
                  row[] -> add;
               #);
            #);
       #);
     FieldReferenceShape: CenterFigure
       (# where: ^ObjectReflector.AttributeReflector;
          assign: @boolean;
          theConnector: ^Connector;
          connectHere:
            (# x, y: @integer;
               shape: ^ObjectShape;
            enter (x, y)
            do where.owner 
                 -> objectShapeForTarget 
                 -> shape[];
               (if shape.father[] = NONE then
                   shape[] -> getPatternName -> putline;
                   x + 60 -> shape.x;
                   y -> shape.y;
                   &shape.Drag[] -> shape.fig.theBehaviour[];
                   shape[] -> THIS(SequenceDiagram).add;
                   shape[] -> floating.append;
               if);
               (if assign then
                    (THIS(FieldReferenceShape)[], shape[], HorisontalOrientation, PenDash) 
                     -> connect
                     -> theConnector[];
                else
                   (shape[], THIS(FieldReferenceShape)[], HorisontalOrientation, PenDash) 
                     -> connect
                     -> theConnector[];
               if);
               shape.refresh;
               update;
            #);
          FieldButton: IconButton
            (# click:
                 (# 
                 do (0, 0) -> localToGlobal -> connectHere;
                 #);
               onExpand::
                 (#
                 do click;
                 #);
               onCollapse::
                 (#
                 do click;
                 #);
            #);
          init::
            (#
            enter where[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
                  row: ^RowFigure;
                  btn: ^IconButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &RowFigure[] -> row[];
                  row.init;
                  true -> row.horizontallyFlexible;
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  where.description -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> row.add;
                  
                  &FieldButton[] -> btn[];
                  up[] -> createImageFigure -> btn.init;
                  6 -> construct.flexHSpace -> row.add;
                  btn[] -> row.add;
                  4 -> construct.hSpace -> row.add;
                  row[] -> add;
               #);
            #)
       #);
     ValueShape: CenterFigure
       (# value: ^Text;
          init::
            (#
            enter value[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  value[] -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> add;
               #);
            #);
       #);
     ObjectShape: Shape
       (# live: ^Line;
          maximum: @integer;
          expanded: @boolean;
          sticky: @boolean;
          isObject: @boolean;
          skip: @boolean;
          reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          pane: ^RowFigure;
          body: ^ColumnFigure;
          
          find:
            (# att: ^ObjectReflector.AttributeReflector;
               shape: ^AttributeShape;
            enter att[]
            do searching: body.scan
                 (# type:: AttributeShape;
                 do (if att[] -> current.target.equal then
                        current[] -> shape[];
                        leave searching;
                    if);
                 #);
            exit shape[]
            #);
          init::
            (#
            enter reflect[]
            do (# simples: ^ObjectReflector.AttributeList;
                  space: ^SpaceFigure;
               do &RowFigure[] -> pane[];
                  pane.init;
                  (* 18 -> pane.baseMinimumHeight; *)
                  true -> pane.horizontallyFlexible;
                  true -> pane.verticallyFlexible;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  (* 18 -> space.minimumHeight; *)
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  &ColumnFigure[] -> body[];
                  body.init;
                  true -> body.horizontallyFlexible;
                  true -> body.verticallyFlexible;
                  body[] -> pane.add;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  (* 18 -> space.minimumHeight; *)
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  compiler[] -> reflect.collectSimples -> simples[];
                  
                  simples.scan
                  (# row: ^AttributeShape;
                  do &AttributeShape[] -> row[];
                     current[] -> row.init;
                     row[] -> body.add;
                  #);
                  
                  &ObjectFigure[] -> fig[];
                  fig.init;
                  fig[] -> add;
                  pack;
               #);
            #);
          refresh::
            (#
            do 
               fig.title.refresh;
               body.children.scan
               (# attribute: ^AttributeShape;
               do current[] -> attribute[];
                  attribute.refresh;
               #);
               pack;
            #);
          description:
            (# value: ^Text;
            do reflect.name -> value[];
            exit value[]
            #);
          dismissConnectors:
            (# theConnectors: ^ConnectorList;
            do THIS(ObjectShape)[] -> connected -> theConnectors[];
               (if expanded then
                   body.children.scan
                   (# attribute: ^AttributeShape;
                   do current[] -> attribute[];
                      (if attribute.theConnector[] <> NONE then
                          attribute.theConnector[] -> theConnectors.append;
                      if);
                   #);
               if);
               theConnectors.scan
               (#
               do current.dismiss;
                  NONE -> current.destination[];
               #);
            #);
          pack:
            (#
            do fig.configure;
               fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          makeSticky:
            (#
            do true -> sticky;
               refresh;
               update;
            #);
          dismiss:
            (#
            do dismissConnectors;
               (if THIS(ObjectShape)[] -> floating.has then
                   THIS(ObjectShape)[] -> floating.delete;
                   THIS(ObjectShape)[] -> THIS(SequenceDiagram).remove;
               if);
               false -> sticky;
               THIS(ObjectShape).refresh;
               THIS(SequenceDiagram).refresh;
            #);
          layoutLiveObject:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> x;
               dy - 10 -> y; 
               (# top: ^Point2d;
                  bottom: ^Point2d;
               do bottomAnchor -> top[];
                  &Point2d[] -> bottom[];
                  top.x -> bottom.x;
                  600 -> bottom.y;
                  &Line[] -> live[];
                  live.init;
                  top[] -> live.start[];
                  bottom[] -> live.end[];
                  res.colors.darkerCoolBrown[] -> live.stroke[];
                  1 -> live.strokewidth;
               #);
            #);
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y + height -> p.y;
               x + width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y + 10 -> p.y;
               x -> p.x;
            exit p[]
            #);
          hasMenu::
            (#
            do true -> yes;
            #);
          getMenu::
            (#
            do &ObjectMenu[] -> theMenu[];
               theMenu.open;
            #);
           finishMenu::
            (#
            do theMenu.close;
            #);
          ObjectMenu: Menu
            (# dismissItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do dismiss;
                           #);
                      #);
                    open::
                      (#
                      do 'Dismiss' -> name;
                      #);
                 #);
               makeStickyItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do makeSticky;
                           #);
                      #);
                    open::
                      (#
                      do 'Make Sticky' -> name;
                      #);
                 #);
               skipInternalItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do not skip -> skip;
                              (if skip then
                                  'Show Internal' -> name;
                               else
                                  'Skip Internal' ->name;
                              if);
                              THIS(ObjectShape).refresh;
                              update;
                           #);
                      #);
                    open::
                      (#
                      do (if skip then
                             'Show Internal' -> name;
                          else
                             'Skip Internal' ->name;
                         if);
                      #);
                 #);
               open::
                 (#
                 do dismissItem.open;
                    dismissItem[] -> append;
                    makeStickyItem.open;
                    makeStickyItem[] -> append;
                    skipInternalItem.open;
                    skipInternalItem[] -> append;
                 #);
            #);
          ObjectFigure: AdornFigure
            (# outline: ^ColumnFigure;
               title: ^TitleFigure;
               
               TitleFigure: RowFigure
                 (# txtFig: ^TextFigure;
                    deco1: ^CenterFigure;
                    deco2: ^CenterFigure;
                    refresh:
                      (#
                      do (if skip then
                             res.yellowish[] -> txtFig.stroke;
                          else
                             res.colors.darkerCoolBrown[] -> txtFig.stroke;
                         if);
                         deco2.clear;
                         (if sticky then
                             res.green[] 
                               -> createCircle 
                               -> deco2.add;
                         if);
                         deco1.clear;
                         (if not isObject then
                             res.colors.pureCyanBlue[] 
                               -> createCircle 
                               -> deco1.add;
                         if);
                      #);
                    ExpansionButton: Toggler
                      (# onExpand::
                           (#
                           do true -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeShape;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     attribute[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                         onCollapse::
                           (#
                           do false -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeShape;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     THIS(ObjectShape)[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                      #);
                    
                    oriBtn: ^ExpansionButton;
                    
                    init::
                      (# construct: @Construction;
                      do true -> horizontallyFlexible;
                         (* 18 -> baseMinimumHeight; *)
                         2 -> construct.hSpace -> add;
                         &ExpansionButton[] -> oriBtn[];
                         (res.black[], res.black[]) -> CreateToggler -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &CenterFigure[] -> deco1[];
                         deco1.init;
                         deco1[] -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                         res.heading[] -> txtFig.style;
                         res.colors.darkerCoolBrown[] -> txtFig.stroke;
                         txtFig[] -> add;
                         &CenterFigure[] -> deco2[];
                         deco2.init;
                         deco2[] -> add;
                         2 -> construct.flexHSpace -> add;
                      #);
                 #);
               configure:
                 (# ruler: ^RulerFigure;
                    construct: @Construction;
                 do (* 18 -> baseMinimumHeight; *)
                    outline.clear;
                    title[] -> outline.add;
                    (if expanded then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.colors.darkerCoolBrown[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        8 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        pane[] -> outline.add; 
                       
                    if);
                 #);
               init::
                 (# center: ^CenterFigure;
                    background: ^Figure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                    
                    
                    (if SOLID then
                        solidborder[] -> createBackground -> background[];
                     else
                        placard[] -> createBackground -> background[];
                    if);
                    
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    
                    background[] -> center.add;
                    background[] -> center.background[];
                    -6 -> center.inset;
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    configure;
                 #);
            #);
          
          AttributeShape: RowFigure
            (# target: ^ObjectReflector.AttributeReflector;
               theConnector: ^Connector;
               valueFig: ^TextFigure;
               referenceBtn: ^ReferenceButton;
               refresh:
                 (# old: ^Text;
                    new: ^Text;
                 do valueFig.content -> old[];
                    target.textValue -> new[];
                    new[] -> valueFig.content;
                    (if updateflag then
                        (if not (new[] -> old.equal) then
                            res.red[] -> valueFig.stroke;
                         else
                            res.colors.darkerCoolBrown[] -> valueFig.stroke;
                        if);
                    if);
                    (if referenceBtn[] <> NONE then
                        referenceBtn.clear;
                        (if theConnector[] <> NONE then
                            (if theConnector.destination[] <> NONE then
                                res.green[] -> createCircle -> referenceBtn.add;
                             else
                                NONE -> theConnector[];
                                up[] -> createImageFigure -> referenceBtn.add;
                            if);
                         else
                            up[] -> createImageFigure -> referenceBtn.add;
                        if);
                    if);
                 #);
               
               connectHere:
                 (# other: ^ObjDesc.Template;
                    shape: ^ObjectShape;
                    x, y: @integer;
                 enter (x, y)
                 do (if theConnector[] = NONE then
                        target.reference -> other[];
                        (if other[] <> NONE then
                            other[] -> reflection
                              -> objectShapeForTarget
                              -> shape[];
                            (if shape.father[] = NONE then
                                shape[] -> getPatternName -> putline;
                                x + 60 -> shape.x;
                                y -> shape.y;
                                &shape.Drag[] -> shape.fig.theBehaviour[];
                                shape[] -> THIS(SequenceDiagram).add;
                                shape[] -> floating.append;
                            if);
                            (THIS(AttributeShape)[], shape[], HorisontalOrientation, PenSmooth) 
                              -> connect
                              -> theConnector[];
                            true -> shape.sticky;
                            shape.refresh;
                            update;
                        if);
                    if);
                 #);
               disconnect:
                 (#
                 do (if theConnector[] <> NONE then
                        (if theConnector.destination[] <> NONE then
                            theConnector.dismiss;
                            NONE -> theConnector.destination[];
                        if);
                        NONE -> theConnector[];
                    if);
                 #);
               
               ReferenceButton: IconButton
                 (# click:
                      (#
                      do (if theConnector[] = NONE then
                             (0, 0) -> localToGlobal -> connectHere;
                          else
                             
                             disconnect;
                         if);
                         THIS(ObjectShape).refresh;
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               init::
                 (#
                 enter target[]
                 do (# txtFig: ^TextFigure;
                       
                       icon: ^RichPixmap;
                       construct: @Construction;
                       iconBtn: ^IconButton;
                       btn: ^Figure;
                    do true -> horizontallyFlexible;
                       16 -> baseMinimumHeight;
                       &TextFigure[] -> txtFig[];
                       txtFig.init;
                       target.name -> txtFig.content;
                       res.smallstyle[] -> txtFig.style;
                       res.colors.darkerCoolBrown[] -> txtFig.stroke;
                       txtFig[] -> add;
                       
                       24 -> construct.flexHSpace -> add;
                       &TextFigure[] -> valueFig[];
                       valueFig.init;
                       target.textValue -> valueFig.content;
                       res.smallnicestyle[] -> valueFig.style;
                       res.colors.darkerCoolBrown[] -> valueFig.stroke;
                       valueFig[] -> add;
                       8 -> construct.hSpace -> add;
                       (if target.kind 
                        //SimpleKind then
                           equal[] -> createImageFigure -> btn[];
                        //ReferenceKind then
                           &ReferenceButton[] -> iconBtn[] -> referenceBtn[];;
                           up[] -> createImageFigure -> iconBtn.init;
                           iconBtn[] -> btn[];
                        //PatternKind then
                           colon[] -> createImageFigure -> btn[];
                        //RepetionKind then
                           equal[] -> createImageFigure -> btn[];
                       if);
                       btn[] -> add;
                    #)
                 #);
            #);
       #);
    
     Construction:
       (# hSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do (#
               do &SpaceFigure[] -> space[];
                  space.init;
                  minimum -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
               #);
            exit space[]
            #);
          vSpace:
            (# 
            #);
          flexHSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do minimum -> hSpace -> space[];
               true -> space.horizontallyFlexible;
            exit space[]
            #);
          flexVSpace:
            (#
            #);
       #);
     
     init::
       (#
       do res.init;
          'thinborder3\\thinborder3' -> loadTileSet -> placard[];
          'solidborder\\solidborder' -> loadTileSet -> solidborder[];
          'rectsolidborder\\rectsolidborder' -> loadTileSet -> rectsolidborder[];
          'icons\\colon.png' -> loadImage -> colon[];
          'icons\\equal.png' -> loadImage -> equal[];
          'icons\\up.png' -> loadImage -> up[];
          lines.init;
          lines[] -> add;
          nodes.init;
          nodes[] -> add;
          7 -> x;
          7 -> y;
       #);
  #);

-- windowLib: attributes --

SequenceCanvas: FigureCanvas
  (# sequence: @SequenceDiagram;
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (caller[], self[], origin[], bc, isObj, isIndexed) -> sequence.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn -> pause;
       exit pause
       #);
     onSuspend:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onSuspend -> pause;
       exit pause
       #);
     onResume:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onResume -> pause;
       exit pause
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVPush -> pause;
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRPush -> pause;
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVStore -> pause;
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRStore -> pause;
       exit pause
       #);
     onBinOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onBinOp -> pause;
       exit pause
       #);
     onUnOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onUnOp -> pause;
       exit pause
       #);
     onJmpGT:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (operator[], value, to[]) -> sequence.onJmpGT -> pause;
       exit pause
       #);
     open::
       (#
       do sequence.init;
          sequence[] -> add;
       #);
     eventHandler::
       (# onRefresh::
            (#
            do 
            #);
       #);
  #);
SequenceWindow: SubWindow
  (# stepBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Step' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.step;
                 #);
            #);
       #);
     stepOutBtn: @PushButton
       (#
          open::
            (#
            do (70, 18) -> size;
               'Step Out' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.stepOut;
                 #);
            #);
       #);
     continueBtn: @PushButton
       (#
          open::
            (#
            do (70, 18) -> size;
               'Continue' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.continue;
                 #);
            #);
       #);
     closeBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Close' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.doClose;
                 #);
            #);
       #);
     clearStacksBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Clear Stacks' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.clearHistory;
                 #);
            #);
       #);
     keepStacksBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Keep Stacks' -> label;
               fitToContents;
            #);
       #);
     skipAllocationsBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Skip Allocations' -> label;
               true -> state;
               fitToContents;
            #);
       #);
     showValuesBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Show Values' -> label;
               fitToContents;
            #);
       #);
     solidBox: @CheckBox
       (# open::
            (#
            do (60, 18) -> size;
               'Solid' -> label;
               true -> state;
               fitToContents;
            #);
       #);
     LOGGING: (# exit true #);
     reflection:
       (# target: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.Template;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     keepHistory:
       (# value: @boolean;
       enter value
       do value -> interior.sequence.doKeepHistory;
       #);
     clearHistory:
       (#
       do interior.sequence.clearHistory;
       #);
     
     setCompiler:
       (# reference: ^generator;
       enter reference[]
       do reference[] -> interior.sequence.compiler[];
       #);
     setVM:
       (# reference: ^| systemenv.betaVM;
       enter reference[]
       do reference[] -> interior.sequence.VM[];
       #);
     setLog:
       (# reference: ^Object;
       enter reference[]
       do reference[] -> interior.sequence.L[];
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do keepStacksBox.state -> keepHistory;
          solidBox.state -> interior.sequence.solid;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[start ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do solidBox.state -> interior.sequence.solid;
          keepStacksBox.state -> keepHistory;
          skipAllocationsBox.state -> interior.sequence.skipAllocations;
          
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[alloc ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          
          (caller[], self[], origin[], bc, isObj, isIndexed) -> interior.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do solidBox.state -> interior.sequence.solid;
          keepStacksBox.state -> keepHistory;
          skipAllocationsBox.state -> interior.sequence.skipAllocations;
       	  (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[do ' -> puttext;
              self[] -> nameOf -> puttext;
              ' | ' -> puttext;
              self[] -> interior.sequence.objectOriginOf -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do solidBox.state -> interior.sequence.solid;
          keepStacksBox.state -> keepHistory;
          skipAllocationsBox.state -> interior.sequence.skipAllocations;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[return ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onReturn -> pause;
       exit pause
       #);
     onSuspend:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[suspend ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onSuspend -> pause;
       exit pause
       #);
     onResume:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[resume ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onResume -> pause;
       exit pause
       #);
     printObjectV:
       (# obj: ^ObjDesc.Template;
       enter obj[]
       do obj.myName -> puttext;
          ' ' -> puttext;
          obj.vtop -> putint;
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[' -> puttext;
              'push ' -> puttext;
              value -> putint;
              ' | ' -> puttext;
              to[] -> printObjectV;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, isIndexed, inx, value) -> interior.onVPush -> pause;
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template; 
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[push ' -> puttext;
              refValue.myName -> puttext;
               ' | ' -> puttext;
              to.myName -> puttext;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRPush -> pause;
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[store ' -> puttext;
              value -> putint;
               ' | ' -> puttext;
              from[] -> printObjectV;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, isIndexed, inx, value) -> interior.onVStore -> pause;
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[store ' -> puttext;
              refValue.myName -> puttext;
              ' | ' -> puttext;
              from.myName -> puttext;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRStore -> pause;
       exit pause
       #);
     onBinOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[bin-op  ' -> puttext;
              operator[] -> puttext;
              ']' -> putline;
          if);
          (operator[], value, to[]) -> interior.onBinOp -> pause;
       exit pause
       #);
      onUnOp:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[un-op  ' -> puttext;
              operator[] -> puttext;
              ']' -> putline;
          if);
          (operator[], value, to[]) -> interior.onUnOp -> pause;
       exit pause
       #);
     onJmpGT:
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.Template;
          pause: @boolean;
       enter (operator[], value, to[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[jmp-gt  ' -> puttext;
              operator[] -> puttext;
              ']' -> putline;
          if);
          (operator[], value, to[]) -> interior.onJmpGT -> pause;
       exit pause
       #);
     compile:
       (# objC: ^ObjectContent.handle
       enter objC[]
       do objC[] -> interior.sequence.compile;
       exit objC.aMod[]
       #);
     execute:
       (# objC: ^ObjectContent.handle; 
       enter objC[]
       do objC[] -> interior.sequence.execute;
       #);
     
     interior: @SequenceCanvas (# #);
     
     open::
       (# w, h: @integer;
          width, height: @integer;
       do hide;
          THIS(Window).size -> (w, h);
          (w - 410 - 5, h - 10) -> size;
          stepBtn.open;
          (80, 7) -> stepBtn.position;
          stepOutBtn.open;
          (80 + 73, 7) -> stepOutBtn.position;
          continueBtn.open;
          (80 + 2*73, 7) -> continueBtn.position;
          closeBtn.open;
          (80 +  (73 * 5), 7) -> closeBtn.position;
          clearStacksBtn.open;
          (90 +  (73 * 6), 7) -> clearStacksBtn.position;
          keepStacksBox.open;
          (90 +  (73 * 7), 7) -> keepStacksBox.position;
          skipAllocationsBox.open;
          (110 +  (73 * 8), 7) -> skipAllocationsBox.position;
          showValuesBox.open;
          (130 +  (73 * 9), 7) -> showValuesBox.position;
          solidBox.open;
          (140 +  (73 * 10), 7) -> solidBox.position;
          
          interior.open;
          (10, 28) -> interior.position;
          size -> (width, height);
          (width - 20, height - 38) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
       #);
  #);

