ORIGIN '~beta/postwimp/demo/chaos/diagram';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/demo/chaos/widgets';
INCLUDE '../miniCompiler/generator';
INCLUDE 'objectContent';
-- lib: attributes --

Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);
SimpleKind:
  (# exit 1 #);
PatternKind:
  (# exit 2 #);
ReferenceKind:
  (# exit 3 #);
RepetionKind:
  (# exit 4 #);

ObjectReflector:
  (# template: ^ObjDesc.Template;
     struct: ^Pattern;
     init:
       (# theTemplate: ^ObjDesc.Template;
       enter theTemplate[]
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
     descriptionOf:
       (# template: ^ObjDesc.Template;
          description: ^Text;
       enter template[]
       do (# name: ^Text;
             ch: @char;
          do template.myName -> name[];
             (if name.length < 0 then
                 1 -> name.inxGet -> ch;
                 (if ch//'a'//'A'//'e'//'E'//'i'//'I'//'o'//'O'//'u'//'U' then
                     'an ' -> description[];
                  else
                     'a ' -> description[];
                 if);
                 name[] -> description.append;
             if);
          #);
       exit description[]
       #);
     collectSimples:
       (# compiler: ^generator;
          simples: ^AttributeList;
       enter compiler[]
       do (# descNo: @integer;
             theObjectDesc: ^generator.ObjectDesc;
             isRef: @boolean;
             off: @integer;
          do &AttributeList[] -> simples[];
             template.myDescInx -> descNo;
             descNo -> compiler.newDesc.getOD -> theObjectDesc[];
             (if theObjectDesc[] <> NONE then
                 theObjectDesc.scanAllDecls
                 (# name: ^Text;
                    simple: ^AttributeReflector;
                    kind: @integer;
                    offset: @integer;
		    origin::
                      (#
                      do &AttributeReflector[] -> simple[];
                         (name[], off, ReferenceKind) -> simple.init;
                         simple[] -> simples.append;
                      #);
                 do (currentND.lexemSy).copy -> name[];
                    currentND.off -> off;
                    (if off > 0 then 
                        off -> offset;
                        (if currentDcl.IT.isSimple then
                            SimpleKind -> kind;
                         else
                            ReferenceKind -> kind;
                        if)            
                     else
                        (if currentDcl.IT.isIndexed then
                            RepetionKind -> kind;
                            offset + 1 -> off;
                         else
                            PatternKind -> kind;
                        if);
                    if);
                    &AttributeReflector[] -> simple[];
                    (name[], off, kind) -> simple.init;
                    simple[] -> simples.append;
                 #);
             if);
          #);
       exit simples[]
       #);
     
     AttributeList: List
       (# Element:: AttributeReflector;
       #);
    

     AttributeReflector:
       (# theName: ^Text;
          offset: @integer;
          kind: @integer;
          init:
            (#
            enter (theName[], offset, kind)
            do 
            #);
          name:
            (#
            do 
            exit theName[]
            #);
          reference:
            (# other: ^ObjDesc.Template;
            do (if (kind = ReferenceKind) and (offset > 0) then
                   template.rfields[offset][] -> other[];
               if);
            exit other[]
            #);
          description:
            (# theDescription: ^Text;
            do (# obj: ^ObjDesc.Template;
               do '' -> theDescription[];
                  (if offset > 0 then
                      (if kind
                       //SimpleKind then
                          offset -> template.get -> theDescription.putint;
                       //RepetionKind then
                          (# n: @integer;
                          do offset -> template.get -> n;
                             (if n > 32 then
                                 32 -> n;
                             if);
                             (for i: n repeat
                                  offset + i -> template.get -> theDescription.put;
                             for);
                          #);
                       //ReferenceKind then
                          template.rfields[offset][] -> obj[];
                          (if obj[] = none then
                              'none' -> theDescription.putText;
                           else
                              (# name: ^Text;
                              do 
                                 obj.myName -> name[];
                                 (if name[] <> NONE then
                                     name[] -> theDescription.putText;
                                  else 
                                     '   ' -> theDescription.putText;
                                 if);
                              #);
                          if);
                      if)            
                   else (* pattern *)
                      '  ' -> theDescription.puttext;
                  if);
               #);
            exit theDescription[]
            #);
               
       #);
  #);


-- FigureCanvasLib: attributes --

SequenceDiagram: Diagram
  (# 
     VM: ^| systemenv.betaVM;
     L: ^Object;
     lines: @Composite;
     nodes: @Composite;
     floating: @Sequence
       (# Element:: ObjectShape;
       #);
     visibles: @Sequence
       (# Element:: ObjectShape;
       #);
     compiler: ^generator;
     LOGGING: (# exit false #);
     solid: @boolean;
     res: @Resource;
     x, y: @integer;
     doKeepHistory: @boolean;
     
     placard: ^TileSet;
     solidborder: ^TileSet;
     rectsolidborder: ^TileSet;
     
     colon: ^RichPixmap;
     equal: ^RichPixmap;
     up: ^RichPixmap;
     
     updateflag: @boolean;
     
     compile:
       (# objC: ^ObjectContent.handle
       enter objC[]
       do '****************' -> putline;
          'MiniENV: compile' -> putline;
          objC.aMod.name.lexemSy -> putline;
          (L[],false,none,objC.aMod.inFile.name) -> compiler;
          (if compiler.hasErrors then none -> compiler.rootModule[] if)
       exit objC.aMod[]
       #);
     
     execute:
       (# objC: ^ObjectContent.handle; 
       enter objC[]
       do (objC.aMod.inFile.name,'..run') -> mkAuxName -> RTT.name;
          RTT.openWrite;               
          '****************' -> putline; 
          'MiniENV: execute' -> putline;
          '****************' -> putline; 
          (if not VM.execute.isRunning then
              VM.init; (* why two inits?*)
              'Exe:aMod.descNo: ' -> puttext; objC.aMod.descNo -> putint;
              ' mainDescNo: ' -> puttext; compiler.mainDescNo -> putint; newline;
              (compiler.descs[],compiler.mainDescNo,RTT[]) -> VM.execute.init;
              VM.execute;
           else
              'VM is not terminated' -> putline
          if);                       
       #);
     RTT: @File;
     
     
     displayChain:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# current: ^ObjDesc.Template;
          do self.myName -> puttext;
             self.myOrigin -> current[];
             loop:
               (if current[] <> NONE then
                   '<-' -> puttext;
                   current.myName -> puttext;
                   current.myOrigin -> current[];
                   restart loop;
               if);
             newline;
          #);
       #);
     isOrigin:
       (# candidate: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          result: @boolean;
       enter (candidate[], self[])
       do (if self[] <> NONE then
              (if candidate[] = self[] then
                  true -> result;
               else
                  (candidate[], self.myOrigin) -> isOrigin -> result;
              if);
          if);
       exit result
       #);
     commonOrigin:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter (caller[], self[])
       do (if caller[] <> NONE then
              (if (caller[], self[]) -> isOrigin then
                  caller[] -> origin[];
               else
                  (caller.myOrigin, self[]) -> commonOrigin -> origin[];
              if);
          if);
       exit origin[]
       #);
     isSkipping:
       (# origin: ^ObjDesc.Template;
          result: @boolean;
       enter origin[]
       do (if origin[] <> NONE then
              (# shape: ^ObjectShape;
              do origin[] 
                   -> reflection
                   -> objectShapes.lookupByTarget 
                   -> shape[];
                 (if shape[] <> NONE then
                     shape.skip -> result;
                 if);
                 (if NOT result then
                     origin.myOrigin -> isSkipping -> result;
                 if);
              #);
          if);
       exit result
       #);
     
     createCircle:
       (# theOvalFigure: ^OvalFigure;
          fill: ^Color;
          circle: ^CenterFigure;
       enter fill[]
       do &OvalFigure[] -> theOvalFigure[];
          theOvalFigure.init;
          fill[] -> theOvalFigure.fill;
          true -> theOvalFigure.horizontallyFlexible;
          true -> theOvalFigure.verticallyFlexible;
          &CenterFigure[] -> circle[];
          circle.init;
          theOvalFigure[] -> circle.add;
          up.width -> circle.baseMinimumWidth;
          up.height -> circle.baseMinimumHeight;
          3 -> circle.margin;
       exit circle[]
       #);
     TileSet:
       (# topleft: ^RichPixmap;
          top: ^RichPixmap;
          topright: ^RichPixmap;
          left: ^RichPixmap;
          middle: ^RichPixmap;
          right: ^RichPixmap;
          bottomleft: ^RichPixmap;
          bottom: ^RichPixmap;
          bottomright: ^RichPixmap;
          
          load:
            (# name: ^Text;
            enter name[]
            do '-topleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topleft[];
               '-top.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> top[];
               '-topright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topright[];
               '-left.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> left[];
               '-middle.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> middle[];
               '-right.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> right[];
               '-bottomleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomleft[];
               '-bottom.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottom[];
               '-bottomright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomright[];
            #);
       #);
     
     loadImage:
       (# name: ^Text;
          image: ^RichPixmap;
       enter name[]
       do (# path: ^Text;
          do &RichPixmap[] -> image[];
             'c:\\beta\\r5.5\\postwimp\\images\\' -> path[];
             name[] -> path.append;
             path[] -> image.readAlpha;
             false -> image.transparent;
          #);
       exit image[]
       #);
     loadTileSet:
       (# name: ^Text;
          tiles: ^TileSet;
       enter name[]
       do &TileSet[] -> tiles[];
          name[] -> tiles.load;
       exit tiles[]
       #);
     
     createImageFigure:
       (# image: ^RichPixmap;
          item: ^ImageFigure;
       enter image[]
       do &ImageFigure[] -> item[];
          item.init;
          image[] -> item.content;
       exit item[]
       #);
     
     createBackground:
       (# tiles: ^TileSet;
          background: ^ColumnFigure;
       enter tiles[]
       do &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             topleft: ^ImageFigure;
             top: ^ImageFigure;
             topright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.topleft[]
               -> createImageFigure 
               -> topleft[];
             false -> topleft.horizontallyFlexible;
             false -> topleft.verticallyFlexible;
             topleft[] -> row.add;
             
             tiles.top[]
               -> createImageFigure 
               -> top[];
             true -> top.horizontallyFlexible;
             false -> top.verticallyFlexible;
             top[] -> row.add;
             
             tiles.topright[]
               -> createImageFigure 
               -> topright[];
             false -> topright.horizontallyFlexible;
             false -> topright.verticallyFlexible;
             topright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          (# row: ^RowFigure;
             left: ^ImageFigure;
             middle: ^ImageFigure;
             right: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.left[]
               -> createImageFigure 
               -> left[];
             false -> left.horizontallyFlexible;
             true -> left.verticallyFlexible;
             left[] -> row.add;
             
             tiles.middle[]
               -> createImageFigure 
               -> middle[];
             true -> middle.horizontallyFlexible;
             true -> middle.verticallyFlexible;
             middle[] -> row.add;
             
             tiles.right[]
               -> createImageFigure 
               -> right[];
             false -> right.horizontallyFlexible;
             true -> right.verticallyFlexible;
             right[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
             true -> row.verticallyFlexible;
          #);
          (# row: ^RowFigure;
             bottomleft: ^ImageFigure;
             bottom: ^ImageFigure;
             bottomright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.bottomleft[]
               -> createImageFigure 
               -> bottomleft[];
             false -> bottomleft.horizontallyFlexible;
             false -> bottomleft.verticallyFlexible;
             bottomleft[] -> row.add;
             
             tiles.bottom[]
               -> createImageFigure 
               -> bottom[];
             true -> bottom.horizontallyFlexible;
             false -> bottom.verticallyFlexible;
             bottom[] -> row.add;
             
             tiles.bottomright[]
               -> createImageFigure 
               -> bottomright[];
             false -> bottomright.horizontallyFlexible;
             false -> bottomright.verticallyFlexible;
             bottomright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          background.pack;
       exit background[]
       #);
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.Template;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter template[]
       do (if template[] <> NONE then
              (#
              do template[] -> objectReflectors.lookupByTemplate -> reflect[];
                 (if reflect[] = NONE then
                     &ObjectReflector[] -> reflect[];
                     template[] -> reflect.init;
                     reflect[] -> objectReflectors.append;
                 if);
              #);
           else
              exception (#  #);
          if);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          
          x + 200 -> x;
       #);
     
     clearHistory:
       (# current: ^Invocation;
       do start[] -> current[];
          clearing:
            (if current[] <> NONE then
                current.history.clear;
                current.active[] -> current[];
                restart clearing;
            if);
          presentSequenceDiagram;
       #);
     presentSequenceDiagram:
       (#
       do (# x: @integer;
             y: @integer;
             
             header: @integer;
             mark: @List;
             
             touched: @ObjectShapeList;
             deletion: @Sequence
               (# Element:: ObjectShape;
               #);
             
             flatten:
               (# 
               do &ActionList[] -> actions[];
                  actions[] -> start.flatten;
               #);
             actions: ^ActionList;
          do lines.clear;
             
             flatten;
             actions.scan
             (# height: @integer;
             do current.prepare -> height;
                (if height > header then
                    height -> header;
                if);
             #);
             24 -> x;
             header + 24 -> y;
             actions.scan
             (#
             do (mark[], touched[], x, y) -> current.process -> (x, y); 
             #);
             touched.scan
             (#
             do (if not (current[] -> visibles.has) then
                    (if current.father[] <> NONE then
                        current[] -> THIS(SequenceDiagram).remove;
                        current[] -> floating.delete;
                    if);
                    current[] -> nodes.add;
                    NONE -> current.fig.theBehaviour[];
                    current[] -> visibles.append;
                if);
             #);
             visibles.scan
             (# 
             do (if not (current[] -> touched.has) then
                    current[] -> deletion.append;
                if);
             #);
             deletion.scan
             (#
             do current.dismissConnectors;
                current.refresh;
                current[] -> nodes.remove;
                current[] -> visibles.delete;
                (if current.sticky then
                    &current.Drag[] -> current.fig.theBehaviour[];
                    current[] -> THIS(SequenceDiagram).add;
                    current[] -> floating.append;
                if);
             #);
             update;
          #);
       #);
     
     liveObjects: @List
       (# Element:: LiveObject;
          lookupByShape:
            (# target: ^ObjectShape;
               live: ^LiveObject;
            enter target[]
            do search: scan
                 (#
                 do (if current.target[] = target[] then
                        current[] -> live[];
                        leave search;
                    if);
                 #);
            exit live[]
            #);
       #);
     liveObjectForObjectShape:
       (# target: ^ObjectShape;
          live: ^LiveObject;
       enter target[]
       do target[] -> liveObjects.lookupByShape -> live[];
          (if live[] = NONE then
              &LiveObject[] -> live[];
              target[] -> live.init;
              live[] -> liveObjects.append;
          if);
       exit live[]
       #);
     LiveObject:
       (# target: ^ObjectShape;
          live: ^Line;
          width: @integer;
            
          layout:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> target.x;
               dy - 10 -> target.y;
               (# top: ^Point2d;
                  bottom: ^Point2d;
               do bottomAnchor -> top[];
                  &Point2d[] -> bottom[];
                  top.x -> bottom.x;
                  600 -> bottom.y;
                  &Line[] -> live[];
                  live.init;
                  top[] -> live.start[];
                  bottom[] -> live.end[];
                  res.colors.darkerCoolBrown[] -> live.stroke[];
                  1 -> live.strokewidth;
               #);
            #);
          
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + target.height -> p.y;
               target.x + target.width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + 10 -> p.y;
               target.x -> p.x;
            exit p[]
            #);
          init:
            (#
            enter target[]
            do 
            #);
          template:
            (# result: ^ObjDesc.template;
            do target.reflect.template[] -> result[];
            exit result[]
            #);
          
          description:
            (# string: ^Text;
            do target.reflect.name -> string[];
            exit string[]
            #);
       #);
     
     Decoration: Composite
       (# containsPoint::
            (#
            do NONE -> target[];
            #);
       #);
     ActionList: Sequence
       (# Element:: Action;
       #);
     Action:
       (# transient: @boolean;
          flatten:<
            (#  actions: ^ActionList;
            enter actions[]
            do INNER;
            #);
          prepare:<
            (# height: @integer;
            do INNER;
            exit height
            #);
          process:<
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               x, y: @integer;
            enter (mark[], nodes[], x, y)
            do INNER;
            exit (x, y)
            #);
          
          finish:<
            (#
            do INNER;
            #);
          createArrow:
            (# lst: ^PointList;
               dash: @boolean;
               head: ^ArrowHead;
               arrow: ^Composite;
            enter (lst[], dash)
            do (# 
               do &Decoration[] -> arrow[];
                  arrow.init;   
                  (# prev: ^Point2d;
                  do lst.scan
                     (# segment: ^Line;
                     do (if prev[] <> NONE then
                            &Line[] -> segment[];
                            segment.init;
                            prev[] -> segment.start[];
                            current[] -> segment.end[];
                            1 -> segment.strokeWidth;
                            res.colors.darkerCoolBrown[] -> segment.stroke[];
                            (if dash then
                                PenDash -> segment.style;
                            if);
                            segment[] -> arrow.add;
                            
                        if);
                        current[] -> prev[];
                     #);
                  #);
                  
                  (# start, end: ^Point2d;
                  do lst.size - 1 -> lst.get -> start[];
                     lst.size -> lst.get -> end[];
                     &ArrowHead[] -> head[];
                     head.init;
                     end[] -> head.to[];
                     start[] -> head.from[];
                     head.refresh;
                     res.colors.darkerCoolBrown[] -> head.stroke[];
                     res.colors.darkerCoolBrown[] -> head.fill[];
                     head[] -> arrow.add;
                  #);
               #);
            exit arrow[]
            #);
       #);
     Invocation: Action
       (# sender: ^LiveObject;
          receiver: ^LiveObject;
          caller: ^ObjDesc.Template;
          message: ^ObjectShape;
          allocation: @boolean;
          isObj: @boolean;
          isReturn: @boolean;
          
          history: @List
            (# Element:: Invocation;
            #);
          stack: @Sequence
            (# Element:: Action;
               peek:
                 (# elm: ^Element;
                 do (if NOT empty then
                        last -> elm[];
                    if);
                 exit elm[]
                 #);
               pop:
                 (# elm: ^Element;
                 do deleteLast -> elm[];
                 exit elm[]
                 #);
               push:
                 (# elm: ^Element;
                 enter elm[]
                 do elm[] -> append;
                 #);
            #);
          
          peek:
            (# theAction: ^Action;
            do stack.peek -> theAction[];
            exit theAction[]
            #);
          pop:
            (# theAction: ^Action;
            do stack.pop -> theAction[];
            exit theAction[]
            #);
          push:
            (# theAction: ^Action;
            enter theAction[]
            do theAction[] -> stack.push;
            #);
          
          flush:
            (# top: ^Action;
            do peek -> top[];
               while:
                 (if top[] <> NONE then
                     (if top.transient then
                         pop;
                         peek -> top[];
                         restart while;
                     if);
                 if);
            #);
         
          finish::
            (#
            do stack.scan
               (#
               do current.finish;
               #);
               flush;
            #);
          active: ^Action;
          return: ^Invocation;
          pts: ^PointList;
          arrow: ^Composite;
          
          flatten::
            (#
            do THIS(Invocation)[] -> actions.append;
               history.scan
               (#
               do actions[] -> current.flatten; 
               #);
               stack.scan
               (#
               do actions[] -> current.flatten;
               #);
            #);
          prepare::
            (#
            do (if not (THIS(Invocation)[] = return[]) then
                   receiver.target.refresh;
                   (if message[] <> NONE then
                       message.refresh;
                   if);
               if);
               (if not allocation then
                   receiver.target.height -> height;
               if);
            #);
          process::
            (# dy: @integer;
            do (if receiver[] = sender[] then
                   50 -> dy;
                else
                   30 -> dy;
               if);
               (if not (receiver[] -> mark.has) then
                   receiver[] -> mark.append;
                   (# dx: @integer;
                      a: ^Point2d;
                      width: @integer;
                   do (if sender[] <> NONE then
                          sender.bottomAnchor -> a[];
                          ((x + receiver.target.width / 2) - a.x) - 20 -> dx;
                          sender.width -> width;
                          (if message[] <> NONE then
                              (if width < message.width then
                                  message.width -> width;
                              if);
                          if);
                          (if dx < width then
                              width - dx -> dx;
                              x + dx -> x;
                          if);
                      if);
                   #);
                   
                   (if allocation then
                       (x, y) -> receiver.layout;
                       receiver.target.height + 4 -> dy;
                    else
                       (x, 24) -> receiver.layout;
                   if);
                   x + receiver.target.width + 7 -> x;
                   receiver.target[] -> nodes.append;
                   receiver.live[] -> lines.add;
               if);
               
               y -> layout;
               (if message[] <> NONE then
                   (if (message.height + 4) > dy then
                       message.height + 4 -> dy;
                   if);
               if);
               
               (if arrow[] <> NONE then
                   arrow[] -> lines.add;
               if);
               (if message[] <> NONE then
                   message[] -> nodes.append;
               if);
               y + dy -> y;
            #);
          swap:
            (# lst: ^PointList;
            do (if pts[] <> NONE then
                   &PointList[] -> lst[];
                   pts.scan
                   (#
                   do current[] -> lst.prepend;
                   #);
                   (lst[], true) -> makeArrow;
                   (* PenDash -> arrowLine.style; *)
               if);
            #);
          
          makeArrow:
            (# lst: ^PointList;
               dash: @boolean;
            enter (lst[], dash)
            do (lst[], dash) -> createArrow -> arrow[];
               (if message[] <> NONE then
                   (# start, end: ^Point2d;
                      mid: ^Point2d;
                   do 1 -> lst.get -> start[];
                      2 -> lst.get -> end[];
                      &Point2d[] -> mid[];
                      (start.x + end.x) / 2 -> mid.x;
                      start.y -> mid.y;
                      mid.x - message.width / 2 -> message.x;
                      mid.y - 10 -> message.y;
                   #);
               if);
               lst[] -> pts[];
            #);
          
          layout:
            (# offset: @integer;
               layoutRegular:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if allocation and (not isReturn) then
                        receiver.leftAnchor -> toAnchor[];
                     else
                        receiver.bottomAnchor -> toAnchor[];
                    if);
                    toAnchor.x -> to.x;
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    (lst[], false) -> makeArrow;
                 #);
               layoutSelf:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    lower: ^Point2d;
                    end: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                    width: @integer;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if message[] <> NONE then
                        from.x + message.width + 20 -> to.x;
                     else
                        from.x + 60 -> to.x;
                    if);
                    
                    (to.x - from.x) -> width;
                    (if width > sender.width then
                        width -> sender.width;
                    if);
                    
                    &Point2d[] -> lower[];
                    to.x -> lower.x;
                    to.y + 30 -> lower.y;
                    &Point2d[] -> end[];
                    from.x -> end.x;
                    from.y + 30 -> end.y;
                    
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    lower[] -> lst.append;
                    end[] -> lst.append;
                    (lst[], false) -> makeArrow;
                 #);
            enter offset
            do (if sender[] = receiver[] then
                   layoutSelf;
                   (if isReturn then
                       (pts[], true) -> makeArrow;
                   if);
                else
                   layoutRegular;
                   (if isReturn then
                       swap;
                   if);
               if);
            #);
          
          match:
            (# caller: ^ObjDesc.Template;
               self: ^ObjDesc.Template;
               origin: ^ObjDesc.Template;
               result: @boolean;
            enter (caller[], self[], origin[])
            do (if allocation then
                   (caller[] = THIS(Invocation).caller[])
                   AND 
                   (self[] = receiver.template) 
                     -> result;
                else
                   (caller[] = THIS(Invocation).caller[])
                   AND
                   (origin[] = receiver.template)
                   AND
                   (self[] = message.reflect.template[])
                     -> result;
               if);
            exit result
            #);
          description:
            (# string: ^Text;
            do '[' -> string[];
               (if sender[] <> NONE then
                   sender.description -> string.puttext;
                   ' ' -> string.puttext;
                   (if message[] <> NONE then
                       message.reflect.name -> string.puttext;
                       ' ' -> string.puttext;
                    else
                       'allocate ' -> string.puttext;
                   if);
                else
                   'start ' -> string.puttext;
               if);
               
               (if receiver[] <> NONE then
                   receiver.description -> string.puttext;
               if);
               ']' -> string.puttext;
            exit string[]
            #);
       #);
     ReturnValue: Action
       (#
       #);
     PushValue: Action
       (# value: ^Text;
          receiver: ^LiveObject;
          
          flatten::
            (#
            do THIS(PushValue)[] -> actions.append;
            #);
          prepare::
            (#
            #);
          process::
            (# anchor: ^Point2d;
               p1: ^Point2d;
               p2: ^Point2d;
               pts: ^PointList;
               shape: ^ValueShape;
            do receiver.bottomAnchor -> anchor[];
               &PointList[] -> pts[];
               &Point2d[] -> p1[];
               &Point2d[] -> p2[];
               anchor.x -> p1.x;
               anchor.x + 20 -> p2.x;
               y -> p1.y;
               y -> p2.y;
               y + 22 -> y;
               p2[] -> pts.append;
               p1[] -> pts.append;
               (pts[], true) -> createArrow -> lines.add;
               &ValueShape[] -> shape[];
               value[] -> shape.init;
               shape.pack;
               p2.x -> shape.x;
               p2.y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
            #);
       #);
     StoreValue: Action
       (# description: ^Text;
          receiver: ^LiveObject;
          
          flatten::
            (#
            do THIS(StoreValue)[] -> actions.append;
            #);
          prepare::
            (#
            #);
          process::
            (# anchor: ^Point2d;
               shape: ^ValueShape;
            do receiver.bottomAnchor -> anchor[];
               &ValueShape[] -> shape[];
               description[] -> shape.init;
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               y - (shape.height / 2) -> shape.y;
               shape[] -> lines.add;
               y + 22 -> y;
            #);
       #);
     skipAllocations: @boolean;
     showValues: @boolean;
     skippingOver: ^Invocation;
     start: ^Invocation;
     top: ^Invocation;
     started: @boolean;
     didReturn: @boolean;
     didAlloc: @boolean;
     flushReturn:
       (# popRStack: @boolean;
       enter popRStack
       do top.flush;
          (if popRStack then
              (if NOT didAlloc then
                  top.pop;
              if);
          if);
          false -> didAlloc;
       #);
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do (if top[] <> NONE then
              top.flush;
              false -> didReturn;
              top.receiver[] -> theInvocation.sender[];
              top[] -> theInvocation.return[];
              theInvocation[] -> top.push;
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
          return: ^Invocation;
       do top.flush;
          true -> didReturn;
          top[] -> theInvocation[];
          true -> top.transient;
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          
          theInvocation.return[] -> top[];
          NONE -> theInvocation.return[];
          
          
          &Invocation[] -> return[];
          theInvocation.sender[] -> return.sender[];
          theInvocation.receiver[] -> return.receiver[];
          theInvocation.allocation -> return.allocation;
          true -> return.isReturn;
          true -> return.transient;
          true -> didReturn;
          
          return[] -> top.push;
       #);
     
     refreshExecution:
       (#
       do true -> updateFlag;
          refresh;
          false -> updateFlag;
       #);
     refresh:
       (# 
       do presentSequenceDiagram;
          floating.scan
          (#
          do current.refresh;
          #);
          refreshConnectors;
       #);
     
     terminate:
       (#
       do start.finish;
          refreshExecution;
          true -> isTerminated;
       #);
     
     isTerminated: @boolean;
     
     call:
       (#
       do (if NOT isTerminated then
              VM.reActivate;
              (if NOT VM.execute.isRunning then
                  terminate;
              if);
          if);
       #);
     callOver:
       (#
       do VM.reActivate;
       #);
     step:
       (#
       do VM.reActivate;
       #);
     stepOver:
       (#
       do VM.reActivate;
       #);
     skipInternal:
       (#
       #);
     continue:
       (#
       #);
     liveLines:
       (#
       #);
     doClose:
       (#
       #);
     
      getAttName:
       (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
          OD: ^generator.ObjectDesc
       enter(off,obj[],isRef,isIndexed)
       do 'xxx'-> nm[];
          obj.myDescInx -> compiler.newDesc.getOD -> OD[];
          find:
            OD.scanAllDecls
            (# origin:: 
                 (#
                 do (if isRef and (off = this(getAttName).off) then
                        'origin' -> NM[];
                        leave find
                 if)#)
            do (if off = currentND.off then
                   (if true
                    // not isRef and currentDcl.IT.isSimple then 
                       currentND.lexemSy -> NM[];
                       leave find
                    // isRef and not currentDcl.IT.isSimple then
                       currentND.lexemSy -> NM[];
                       leave find
                   if)
                else
                   (* Note: currentND.off may not be defined for an indexed object
                    * but isIndexed then only one repetition so
                    * the code below should work *)
                   (if isIndexed and currentDcl.IT.isIndexed then
                       currentND.lexemSy -> NM[];
                       leave find
                   if)
            if)#)
       exit NM[]
       #);
     objectOriginOf:
       (# self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter self[]
       do self[] -> origin[];
          search:
            (if not origin.isObj then
                origin.myOrigin -> origin[];
                restart search;
            if);
       exit origin[]
       #);
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do liveObjects.clear;
             self[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             &Invocation[] -> theInvocation[];
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
             refreshExecution;
             true -> pause;
          #);
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (# shape: ^ObjectShape;
             sender: ^LiveObject;
             receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do self[]
               -> reflection
               -> objectShapeForTarget
               -> shape[];
             isObj -> shape.isObject;
             (if skippingOver[] = NONE then
                 (if showValues then
                     top.pop;
                 if);
                 
                 shape[]
                   -> liveObjectForObjectShape
                   -> receiver[];
                 &Invocation[] -> theInvocation[];
                 caller[] -> theInvocation.caller[];
                 true -> theInvocation.allocation;
                 isObj -> theInvocation.isObj;
                 receiver[] -> theInvocation.receiver[];
                 (if skipAllocations then
                     top.receiver[] -> theInvocation.sender[];
                     theInvocation[] -> skippingOver[];
                  else
                     (if isObj or showValues then
                         theInvocation[] -> pushInvocation;
                         refreshExecution; 
                         true -> pause;
                     if);
                 if);
             if);
	    
          #);
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (if self[] <> NONE then
              (# sender: ^LiveObject;
                 receiver: ^LiveObject;
                 shape: ^ObjectShape;
                 message: ^ObjectShape;
                 common: ^ObjDesc.Template;
                 theInvocation: ^Invocation;
                 skip: @boolean;
              do 
                 (if showValues and self.isObj then
                     top.pop;
                 if);
                 
                 (if caller[] <> NONE then
                     (caller[], self[]) -> commonOrigin -> common[];
                     (if common[] <> none then
                         common[] -> isSkipping -> skip;
                     if);
                 if);
                 
                 (if NOT skip then
                     self[] -> objectOriginOf -> origin[];
                     self[]
                       -> reflection
                       -> objectShapeForTarget
                       -> shape[];
                     (if (shape.isObject or (origin[] = NONE)) then
                         shape[]
                           -> liveObjectForObjectShape
                           -> receiver[];
                      else
                         origin[] 
                           -> reflection
                           -> objectShapeForTarget
                           -> liveObjectForObjectShape
                           -> receiver[];
                         shape[] -> message[];
                     if);
                     &Invocation[] -> theInvocation[];
                     caller[] -> theInvocation.caller[];
                     receiver[] -> theInvocation.receiver[];
                     message[] -> theInvocation.message[];
                     theInvocation[] -> pushInvocation;
                     refreshExecution;
                     true -> pause;
                 if);
              #);
          if);
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if skippingOver[] <> NONE then
                 (if (caller[], self[], origin[]) -> skippingOver.match then
                     (if skippingOver.isObj or showValues then
                         top.flush;
                         not skippingOver.isObj -> skippingOver.transient;
                         skippingOver[] -> top.push;
                         true -> didReturn;
                         true -> pause;
		         refreshExecution;
                     if);
                     NONE -> skippingOver[];
                 if);
              else
                 (if (caller[], self[], origin[]) -> top.match then
                     popInvocation;
                     true -> pause;
		     refreshExecution;
                 if);
             if);
          #);
       exit pause
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, value)
       do (if (skippingOver[] = NONE) and showValues then
              popRStack -> flushReturn;
              (# push: ^PushValue;
                 str: ^Text;
              do &PushValue[] -> push[];
                 &Text[] -> str[];
                 value -> str.putint;
                 (if off > 0 then
                     ' (' -> str.puttext;
                     (off, from[], false, false) -> getAttName -> str.puttext;
                     ')' -> str.puttext;
                 if);
                 str[] -> push.value[];
                 top.receiver[] -> push.receiver[];
                 push[] -> top.push;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if (skippingOver[] = NONE) and showValues then
              popRStack -> flushReturn;
              (# push: ^PushValue;
                 str: ^Text;
              do &PushValue[] -> push[];
                 
                 (refValue.myName).copy -> str[];
                 (if off > 0 then
                     ' (' -> str.puttext;
                     (off, from[], true, false) -> getAttName -> str.puttext;
                     ')' -> str.puttext;
                 if);
                 str[]  -> push.value[];
                 top.receiver[] -> push.receiver[];
                 push[] -> top.push;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, value)
       do (if (skippingOver[] = NONE) and showValues then
              popRStack -> flushReturn;
              top.pop;
              (# store: ^StoreValue;
                 str: ^Text;
              do &StoreValue[] -> store[];
                 &Text[] -> str[];
                 (off, to[], false, false) -> getAttName -> str.puttext;
                 ' := ' -> str.puttext;
                 value -> str.putint;
                 str[] -> store.description[];
                 top.receiver[] -> store.receiver[];
                 true -> store.transient;
                 store[] -> top.push;
                 true -> didReturn;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if (skippingOver[] = NONE) and showValues  then
              popRStack -> flushReturn;
              top.pop;
              (# store: ^StoreValue;
                 str: ^Text;
              do &StoreValue[] -> store[];
                 &Text[] -> str[];
                 (off, to[], true, false) -> getAttName -> str.puttext;
                 ' := ' -> str.puttext;
                 refValue.myName -> str.puttext;
                 str[] -> store.description[];
                 top.receiver[] -> store.receiver[];
                 true -> store.transient;
                 store[] -> top.push;
              #);
              true -> pause;
              refreshExecution;
          if);
       exit pause
       #);
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
              THIS(SequenceDiagram)[] -> shape.dia[];
          if);
       exit shape[]
       #);
     ObjectShapeList: Sequence
       (# Element:: ObjectShape;
       #);
     ValueShape: CenterFigure
       (# value: ^Text;
          init::
            (#
            enter value[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  value[] -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> add;
               #);
            #);
       #);
     ObjectShape: Shape
       (# expanded: @boolean;
          sticky: @boolean;
          isObject: @boolean;
          skip: @boolean;
          reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          pane: ^RowFigure;
          body: ^ColumnFigure;
          
          init::
            (#
            enter reflect[]
            do (# simples: ^ObjectReflector.AttributeList;
                  space: ^SpaceFigure;
               do &RowFigure[] -> pane[];
                  pane.init;
                  (* 18 -> pane.baseMinimumHeight; *)
                  true -> pane.horizontallyFlexible;
                  true -> pane.verticallyFlexible;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  (* 18 -> space.minimumHeight; *)
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  &ColumnFigure[] -> body[];
                  body.init;
                  true -> body.horizontallyFlexible;
                  true -> body.verticallyFlexible;
                  body[] -> pane.add;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  (* 18 -> space.minimumHeight; *)
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  compiler[] -> reflect.collectSimples -> simples[];
                  
                  simples.scan
                  (# row: ^AttributeOutliner;
                  do &AttributeOutliner[] -> row[];
                     current[] -> row.init;
                     row[] -> body.add;
                  #);
                  
                  &ObjectFigure[] -> fig[];
                  fig.init;
                  fig[] -> add;
                  pack;
               #);
            #);
          refresh::
            (#
            do 
               fig.title.refresh;
               body.children.scan
               (# attribute: ^AttributeOutliner;
               do current[] -> attribute[];
                  attribute.refresh;
               #);
               pack;
            #);
          dismissConnectors:
            (# theConnectors: ^ConnectorList;
            do THIS(ObjectShape)[] -> connected -> theConnectors[];
               (if expanded then
                   body.children.scan
                   (# attribute: ^AttributeOutliner;
                   do current[] -> attribute[];
                      (if attribute.theConnector[] <> NONE then
                          attribute.theConnector[] -> theConnectors.append;
                      if);
                   #);
               if);
               theConnectors.scan
               (#
               do current.dismiss;
                  NONE -> current.destination[];
               #);
            #);
          pack:
            (#
            do fig.configure;
               fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          makeSticky:
            (#
            do true -> sticky;
               refresh;
               update;
            #);
          dismiss:
            (#
            do dismissConnectors;
               (if THIS(ObjectShape)[] -> floating.has then
                   THIS(ObjectShape)[] -> floating.delete;
                   THIS(ObjectShape)[] -> THIS(SequenceDiagram).remove;
               if);
               false -> sticky;
               THIS(ObjectShape).refresh;
               THIS(SequenceDiagram).refresh;
            #);
          hasMenu::
            (#
            do true -> yes;
            #);
          getMenu::
            (#
            do &ObjectMenu[] -> theMenu[];
               theMenu.open;
            #);
           finishMenu::
            (#
            do theMenu.close;
            #);
          ObjectMenu: Menu
            (# dismissItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do dismiss;
                           #);
                      #);
                    open::
                      (#
                      do 'Dismiss' -> name;
                      #);
                 #);
               makeStickyItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do makeSticky;
                           #);
                      #);
                    open::
                      (#
                      do 'Make Sticky' -> name;
                      #);
                 #);
               skipInternalItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do not skip -> skip;
                              (if skip then
                                  'Show Internal' -> name;
                               else
                                  'Skip Internal' ->name;
                              if);
                              THIS(ObjectShape).refresh;
                              update;
                           #);
                      #);
                    open::
                      (#
                      do (if skip then
                             'Show Internal' -> name;
                          else
                             'Skip Internal' ->name;
                         if);
                      #);
                 #);
               open::
                 (#
                 do dismissItem.open;
                    dismissItem[] -> append;
                    makeStickyItem.open;
                    makeStickyItem[] -> append;
                    skipInternalItem.open;
                    skipInternalItem[] -> append;
                 #);
            #);
          ObjectFigure: AdornFigure
            (# outline: ^ColumnFigure;
               title: ^TitleFigure;
               
               TitleFigure: RowFigure
                 (# txtFig: ^TextFigure;
                    deco1: ^CenterFigure;
                    deco2: ^CenterFigure;
                    refresh:
                      (#
                      do (if skip then
                             res.yellowish[] -> txtFig.stroke;
                          else
                             res.colors.darkerCoolBrown[] -> txtFig.stroke;
                         if);
                         deco2.clear;
                         (if sticky then
                             res.green[] 
                               -> createCircle 
                               -> deco2.add;
                         if);
                         deco1.clear;
                         (if not isObject then
                             res.colors.pureCyanBlue[] 
                               -> createCircle 
                               -> deco1.add;
                         if);
                      #);
                    ExpansionButton: Toggler
                      (# onExpand::
                           (#
                           do true -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeOutliner;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     attribute[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                         onCollapse::
                           (#
                           do false -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeOutliner;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     THIS(ObjectShape)[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                      #);
                    
                    oriBtn: ^ExpansionButton;
                    
                    init::
                      (# construct: @Construction;
                      do true -> horizontallyFlexible;
                         (* 18 -> baseMinimumHeight; *)
                         2 -> construct.hSpace -> add;
                         &ExpansionButton[] -> oriBtn[];
                         (res.black[], res.black[]) -> CreateToggler -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &CenterFigure[] -> deco1[];
                         deco1.init;
                         deco1[] -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                         res.heading[] -> txtFig.style;
                         res.colors.darkerCoolBrown[] -> txtFig.stroke;
                         txtFig[] -> add;
                         &CenterFigure[] -> deco2[];
                         deco2.init;
                         deco2[] -> add;
                         2 -> construct.flexHSpace -> add;
                      #);
                 #);
               configure:
                 (# ruler: ^RulerFigure;
                    construct: @Construction;
                 do (* 18 -> baseMinimumHeight; *)
                    outline.clear;
                    title[] -> outline.add;
                    (if expanded then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.colors.darkerCoolBrown[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        8 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        pane[] -> outline.add; 
                       
                    if);
                 #);
               init::
                 (# center: ^CenterFigure;
                    background: ^Figure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                    
                    
                    (if SOLID then
                        solidborder[] -> createBackground -> background[];
                     else
                        placard[] -> createBackground -> background[];
                    if);
                    
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    
                    background[] -> center.add;
                    background[] -> center.background[];
                    -6 -> center.inset;
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    configure;
                 #);
            #);
          
          AttributeOutliner: RowFigure
            (# target: ^ObjectReflector.AttributeReflector;
               theConnector: ^Connector;
               valueFig: ^TextFigure;
               referenceBtn: ^ReferenceButton;
               refresh:
                 (# old: ^Text;
                    new: ^Text;
                 do valueFig.content -> old[];
                    target.description -> new[];
                    new[] -> valueFig.content;
                    (if updateflag then
                        (if not (new[] -> old.equal) then
                            res.red[] -> valueFig.stroke;
                         else
                            res.colors.darkerCoolBrown[] -> valueFig.stroke;
                        if);
                    if);
                    (if referenceBtn[] <> NONE then
                        referenceBtn.clear;
                        (if theConnector[] <> NONE then
                            (if theConnector.destination[] <> NONE then
                                res.green[] -> createCircle -> referenceBtn.add;
                             else
                                NONE -> theConnector[];
                                up[] -> createImageFigure -> referenceBtn.add;
                            if);
                         else
                            up[] -> createImageFigure -> referenceBtn.add;
                        if);
                    if);
                 #);
               
               connectHere:
                 (# other: ^ObjDesc.Template;
                    shape: ^ObjectShape;
                    x, y: @integer;
                 enter (x, y)
                 do (if theConnector[] = NONE then
                        target.reference -> other[];
                        (if other[] <> NONE then
                            other[] -> reflection
                              -> objectShapeForTarget
                              -> shape[];
                            (if shape.father[] = NONE then
                                shape[] -> getPatternName -> putline;
                                x + 60 -> shape.x;
                                y -> shape.y;
                                &shape.Drag[] -> shape.fig.theBehaviour[];
                                shape[] -> THIS(SequenceDiagram).add;
                                shape[] -> floating.append;
                            if);
                            (THIS(AttributeOutliner)[], shape[], HorisontalOrientation) 
                              -> connect
                              -> theConnector[];
                            true -> shape.sticky;
                            shape.refresh;
                            update;
                        if);
                    if);
                 #);
               disconnect:
                 (#
                 do (if theConnector[] <> NONE then
                        (if theConnector.destination[] <> NONE then
                            theConnector.dismiss;
                            NONE -> theConnector.destination[];
                        if);
                        NONE -> theConnector[];
                    if);
                 #);
               
               ReferenceButton: IconButton
                 (# click:
                      (#
                      do (if theConnector[] = NONE then
                             (0, 0) -> localToGlobal -> connectHere;
                          else
                             
                             disconnect;
                         if);
                         THIS(ObjectShape).refresh;
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               init::
                 (#
                 enter target[]
                 do (# txtFig: ^TextFigure;
                       
                       icon: ^RichPixmap;
                       construct: @Construction;
                       iconBtn: ^IconButton;
                       btn: ^Figure;
                    do true -> horizontallyFlexible;
                       16 -> baseMinimumHeight;
                       &TextFigure[] -> txtFig[];
                       txtFig.init;
                       target.name -> txtFig.content;
                       res.smallstyle[] -> txtFig.style;
                       res.colors.darkerCoolBrown[] -> txtFig.stroke;
                       txtFig[] -> add;
                       
                       24 -> construct.flexHSpace -> add;
                       &TextFigure[] -> valueFig[];
                       valueFig.init;
                       target.description -> valueFig.content;
                       res.smallnicestyle[] -> valueFig.style;
                       res.colors.darkerCoolBrown[] -> valueFig.stroke;
                       valueFig[] -> add;
                       8 -> construct.hSpace -> add;
                       (if target.kind 
                        //SimpleKind then
                           equal[] -> createImageFigure -> btn[];
                        //ReferenceKind then
                           &ReferenceButton[] -> iconBtn[] -> referenceBtn[];;
                           up[] -> createImageFigure -> iconBtn.init;
                           iconBtn[] -> btn[];
                        //PatternKind then
                           colon[] -> createImageFigure -> btn[];
                        //RepetionKind then
                           equal[] -> createImageFigure -> btn[];
                       if);
                       btn[] -> add;
                    #)
                 #);
            #);
       #);
    
     Construction:
       (# hSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do (#
               do &SpaceFigure[] -> space[];
                  space.init;
                  minimum -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
               #);
            exit space[]
            #);
          vSpace:
            (# 
            #);
          flexHSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do minimum -> hSpace -> space[];
               true -> space.horizontallyFlexible;
            exit space[]
            #);
          flexVSpace:
            (#
            #);
       #);
     
     init::
       (#
       do res.init;
          'thinborder3\\thinborder3' -> loadTileSet -> placard[];
          'solidborder\\solidborder' -> loadTileSet -> solidborder[];
          'rectsolidborder\\rectsolidborder' -> loadTileSet -> rectsolidborder[];
          'icons\\colon.png' -> loadImage -> colon[];
          'icons\\equal.png' -> loadImage -> equal[];
          'icons\\up.png' -> loadImage -> up[];
          lines.init;
          lines[] -> add;
          nodes.init;
          nodes[] -> add;
          7 -> x;
          7 -> y;
       #);
  #);

-- windowLib: attributes --

SequenceCanvas: FigureCanvas
  (# sequence: @SequenceDiagram;
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (caller[], self[], origin[], bc, isObj) -> sequence.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn -> pause;
       exit pause
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, value)
       do (from[], popRStack, to[], off, value) -> sequence.onVPush -> pause;
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRPush -> pause;
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, value)
       do (from[], popRStack, to[], off, value) -> sequence.onVStore -> pause;
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (from[], popRStack, to[], off, refValue[]) -> sequence.onRStore -> pause;
       exit pause
       #);
     open::
       (#
       do sequence.init;
          sequence[] -> add;
       #);
     eventHandler::
       (# onRefresh::
            (#
            do 
            #);
       #);
  #);
SequenceWindow: SubWindow
  (# callBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Call' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.call;
                 #);
            #);
       #);
     callOverBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Call Over' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.callOver;
                 #);
            #);
       #);
     stepBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Step' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.step;
                 #);
            #);
       #);
     stepOverBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Step Over' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.stepOver;
                 #);
            #);
       #);
     skipInternalBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Skip Internal' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.skipInternal;
                 #);
            #);
       #);
     continueBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Continue' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.continue;
                 #);
            #);
       #);
     liveLinesBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Live Lines' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.liveLines;
                 #);
            #);
       #);
     closeBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Close' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.doClose;
                 #);
            #);
       #);
     clearStacksBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Clear Stacks' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.clearHistory;
                 #);
            #);
       #);
     keepStacksBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Keep Stacks' -> label;
               fitToContents;
            #);
       #);
     skipAllocationsBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Skip Allocations' -> label;
               true -> state;
               fitToContents;
            #);
       #);
     showValuesBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Show Values' -> label;
               fitToContents;
            #);
       #);
     solidBox: @CheckBox
       (# open::
            (#
            do (60, 18) -> size;
               'Solid' -> label;
               true -> state;
               fitToContents;
            #);
       #);
     LOGGING: (# exit true #);
     reflection:
       (# target: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.Template;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     keepHistory:
       (# value: @boolean;
       enter value
       do value -> interior.sequence.doKeepHistory;
       #);
     clearHistory:
       (#
       do interior.sequence.clearHistory;
       #);
     
     setCompiler:
       (# reference: ^generator;
       enter reference[]
       do reference[] -> interior.sequence.compiler[];
       #);
     setVM:
       (# reference: ^| systemenv.betaVM;
       enter reference[]
       do reference[] -> interior.sequence.VM[];
       #);
     setLog:
       (# reference: ^Object;
       enter reference[]
       do reference[] -> interior.sequence.L[];
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do keepStacksBox.state -> keepHistory;
          solidBox.state -> interior.sequence.solid;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[start ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do solidBox.state -> interior.sequence.solid;
          keepStacksBox.state -> keepHistory;
          skipAllocationsBox.state -> interior.sequence.skipAllocations;
          
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[alloc ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          
          (caller[], self[], origin[], bc, isObj) -> interior.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do solidBox.state -> interior.sequence.solid;
          keepStacksBox.state -> keepHistory;
          skipAllocationsBox.state -> interior.sequence.skipAllocations;
       	  (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[do ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              
              ' | ' -> puttext;
              self[] -> interior.sequence.objectOriginOf -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do solidBox.state -> interior.sequence.solid;
          keepStacksBox.state -> keepHistory;
          skipAllocationsBox.state -> interior.sequence.skipAllocations;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[return ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onReturn -> pause;
       exit pause
       #);

     printObjectV:
       (# obj: ^ObjDesc.Template;
       enter obj[]
       do obj.myName -> puttext;
          ' ' -> puttext;
          obj.vtop -> putint;
       #);
     onVPush:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, value)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[' -> puttext;
              'push ' -> puttext;
              value -> putint;
              ' | ' -> puttext;
              to[] -> printObjectV;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, value) -> interior.onVPush -> pause;
       exit pause
       #);
     onRPush:
       (# from, to: ^ObjDesc.Template; 
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[push ' -> puttext;
              refValue.myName -> puttext;
               ' | ' -> puttext;
              to.myName -> puttext;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRPush -> pause;
       exit pause
       #);
     onVStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          value: @integer;
          pause: @boolean;
       enter (from[], popRStack, to[], off, value)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[store ' -> puttext;
              value -> putint;
               ' | ' -> puttext;
              from[] -> printObjectV;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, value) -> interior.onVStore -> pause;
       exit pause
       #);
     onRStore:
       (# from, to: ^ObjDesc.Template;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.Template;
          pause: @boolean;
       enter (from[], popRStack, to[], off, refValue[])
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[store ' -> puttext;
              refValue.myName -> puttext;
              ' | ' -> puttext;
              from.myName -> puttext;
              (if popRStack then
                  ' pop' -> puttext;
              if);
              ']' -> putline;
          if);
          showValuesBox.state -> interior.sequence.showValues;
          (from[], popRStack, to[], off, refValue[]) -> interior.onRStore -> pause;
       exit pause
       #);
     
     
     compile:
       (# objC: ^ObjectContent.handle
       enter objC[]
       do objC[] -> interior.sequence.compile;
       exit objC.aMod[]
       #);
     execute:
       (# objC: ^ObjectContent.handle; 
       enter objC[]
       do objC[] -> interior.sequence.execute;
       #);
     
     interior: @SequenceCanvas (# #);
     
     open::
       (# w, h: @integer;
          width, height: @integer;
       do hide;
          THIS(Window).size -> (w, h);
          (w - 410 - 5, h - 10) -> size;
          callBtn.open;
          (80, 7) -> callBtn.position;
          callOverBtn.open;
          (80 +  73, 7) -> callOverBtn.position;
          stepBtn.open;
          (80 +  (73 * 2), 7) -> stepBtn.position;
          stepOverBtn.open;
          (80 +  (73 * 3), 7) -> stepOverBtn.position;
          continueBtn.open;
          (80 +  (73 * 4), 7) -> continueBtn.position;
          closeBtn.open;
          (80 +  (73 * 5), 7) -> closeBtn.position;
          clearStacksBtn.open;
          (90 +  (73 * 6), 7) -> clearStacksBtn.position;
          keepStacksBox.open;
          (90 +  (73 * 7), 7) -> keepStacksBox.position;
          skipAllocationsBox.open;
          (110 +  (73 * 8), 7) -> skipAllocationsBox.position;
          showValuesBox.open;
          (130 +  (73 * 9), 7) -> showValuesBox.position;
          solidBox.open;
          (140 +  (73 * 10), 7) -> solidBox.position;
          
          interior.open;
          (10, 28) -> interior.position;
          size -> (width, height);
          (width - 20, height - 38) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
       #);
  #);

