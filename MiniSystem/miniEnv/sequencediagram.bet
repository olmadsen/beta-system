ORIGIN '~beta/postwimp/graphicscanvas/diagram';
INCLUDE '~beta/guienv/controls';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/graphicscanvas/widgets';
INCLUDE  '~beta/guienv/private/datastructures/sequence';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE 'objectContent';
INCLUDE 'dialogs';
INCLUDE 'reflector';
INCLUDE 'SuperSequenceDiagram';

-- FigureCanvasLib: attributes --

SequenceDiagram: SuperSequenceDiagram
  (# LOGGING: (# exit false #);     
     rrc: @integer;
     L: ^Object; (* ???*)
     lines: @Composite;
     nodes: @Composite;
     holder: @CenterFigure;
     background: ^RectFigure;
     debugging: @boolean;
     solid: @boolean;
     x, y: @integer;
     doKeepHistory: @boolean;     
     placard: ^TileSet;
     solidborder: ^TileSet;
     rectsolidborder: ^TileSet;     
     colon: ^RichPixmap;
     equal: ^RichPixmap;
     virtual: ^RichPixmap;
     simple: ^RichPixmap;
     array: ^RichPixmap;
     dynamicRef: ^RichPixmap;
     staticRef: ^RichPixmap;
     pattern: ^RichPixmap;
     cogwheel: ^RichPixmap;
     cogwheelgray: ^RichPixmap;
     plus: ^RichPixmap;
     plus_hilite: ^RichPixmap;
     minus: ^RichPixmap;
     minus_hilite: ^RichPixmap;
     pause: ^RichPixmap;
     waiting: ^RichPixmap;
     updateflag: @boolean;

     isDisguised:
       (* self or som origin of self is disguised *)
       (# self: ^ObjDesc.RunTimeObject;
          shape: ^ObjectShape;
          result: @boolean;
       enter self[]
       do (if self[] <> NONE then
              '**** isDisguised: ' -> puttext; self.myName -> putline;
              self[] 
                -> reflection
                -> objectShapes.lookupByTarget 
                -> shape[];
              (if shape[] <> NONE then
                  shape.disguised-> result;
              if);
              (if not result then
                  self.myOrigin -> isDisguised -> result;
              if)
          if);
       exit result
       #);
     isSkipInternal:
       (# origin: ^ObjDesc.RunTimeObject;
          result: @boolean;
       enter origin[]
       do (if origin[] <> NONE then
              (# shape: ^ObjectShape;
              do origin[] 
                   -> reflection
                   -> objectShapes.lookupByTarget 
                   -> shape[];
                 (*'**** origin: ' -> puttext; origin.myName -> puttext;*)
                 (if shape[] <> NONE then
                     shape.skipInternal -> result;
                     (*' ** shape.skip: ' -> puttext;*)
                     (*result -> putboolean;*)
                 if); (*newline;*)
                 (if NOT result then
                     origin.myOrigin -> isSkipInternal -> result;
                 if);
              #);
          if);
       exit result
       #);
     
     floating: @Sequence(# Element:: ObjectShape #);
     visibles: @Sequence(# Element:: ObjectShape #);
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.RunTimeObject;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.RunTimeObject;
          reflect: ^ObjectReflector;
       enter template[]
       do (if template[] <> NONE then
              (#
              do template[] -> objectReflectors.lookupByTemplate -> reflect[];
                 (if reflect[] = NONE then
                     &ObjectReflector[] -> reflect[];
                     (compiler[],template[]) -> reflect.init;
                     reflect[] -> objectReflectors.append;
                 if);
              #);
           else
              exception (#  #);
          if);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          x + 200 -> x;
       #);
          
     clearHistory:
       (#
       do start.clearHistory;
          'clear-history' -> presentSequenceDiagram;
       #);
     clearSequenceDiagram:
       (# 
       do lines.clear;
          nodes.children.scan
          (# shape: ^ObjectShape;
          do (if current## = ObjectShape## then
                 current[] -> shape[];
                 shape.dismissConnectors;
                 shape[] -> visibles.delete;
             if);
          #);
          nodes.clear;
          floating.scan
          (#
          do current.dismissConnectors;
             current[] -> THIS(SequenceDiagram).remove;
             current[] -> visibles.delete;
          #);
          floating.clear;
          NONE -> start[];
          NONE -> top[];
       #);

     offset: @integer;
     slide: @integer;
     prc: @integer;
     presentSequenceDiagram:
       (# present:
            (# y: @integer;
               xmax: @integer;
               header: @integer;
               actions: ^ActionList;               
               leaders: ^InvocationList; (* one per coroutine? *)
               nodes: @ObjectShapeList;
               shapes: @ActionShapeList;
               manager: @PositionManager;
               first: @boolean;
            enter (leaders[], header)
            do '*** presentSequenceDiagram:present: '->putline;
               true -> first;
               &ActionList[] -> actions[];
               leaders.scan
               (#
               do current.description -> puttext; ' ' -> put;
                  current[] -> current.receiver.invocator[];
                  actions[] -> current.flatten;
                  (if not first then
                      current.isPreemptive -> (actions.last).isPreemptive;
                      true -> (actions.last).isLastInSuspended;
                  if);
                  true -> current.isRoot;
                  true -> current.receiver.isRoot;
                  false -> first;
               #);
               
               '\n**** actions: ' -> putline;
               actions.scan
               (# height: @integer;
               do current.description -> puttext; 
                  (if not current.isSkipping then
                      ' no skip ' -> putline;
                      manager[] -> current.prepare -> height;
                      (if height > header then
                          height -> header;
                      if);
                   else
                      ' skip ' -> putline;
                  if);
               #);
               
               actions.sort
               (# less::
                    (#
                    do left.id < right.id -> value;
                    #);
               #);
               
               header + 24 -> y;
               y + offset -> y;
               
               actions.scan
               (# 
               do (mark[], nodes[], shapes[], y, header, manager[]) 
                    -> current.process -> y; 
               #);
               nodes.scan
               (#
               do 'present' -> current.refresh;
               #);
               manager.layout;
               '*** manager.apply'->putline;
               manager.apply;
               shapes.scan
               (#
               do current.refresh;
                  (if current.offset > (header + 24) then
                      current[] -> lines.add;
                  if);
               #);
               (if y > footer then
                   y -> footer;
               if);
               nodes.scan
               (#
               do 'present' -> current.refresh;
                  current[] -> touched.append;
               #);
            exit header
            #);
          mark: @List;
          
          touched: @ObjectShapeList;
          deletion: @Sequence (# Element:: ObjectShape #);
          debug: @boolean;
          footer: @integer;
          where: ^Text;
       enter where[]
       do (if false then
              prc + 1 -> prc;
              'present: ' -> puttext;
              prc -> putint;
              ' | ' -> puttext;
              where[] -> puttext;
              newline;
          if);
          
          (if start[] <> NONE then
              (# x, y: @integer;
              do lines.clear;
                 24 -> x;
                 0 -> y;
                 600 -> footer;
                 
                 (# leaders: ^InvocationList;
                 do &InvocationList[] -> leaders[];
                    start[] -> leaders.append;
                    suspended.scan
                    (#
                    do current[] -> leaders.append; 
                    #);
                    (leaders[], y) -> present-> y;
                 #);
                 
                 lines.children.scan
                 (# l: ^LifeLine;
                    o: ^Lifer;
                 do (if current## = Lifer## then
                        current[] -> o[];
                        o.last -> l[];
                        footer -> l.end.y;
                    if);
                 #);
                 touched.scan
                 (#
                 do (if not (current[] -> visibles.has) then
                        (if current.father[] <> NONE then
                            current[] -> THIS(SequenceDiagram).remove;
                            current[] -> floating.delete;
                        if);
                        current[] -> nodes.add;
                        NONE -> current.fig.theBehaviour[];
                        current[] -> visibles.append;
                    if);
                 #);
                 visibles.scan
                 (# 
                 do (if not (current[] -> touched.has) then
                        current[] -> deletion.append;
                    if);
                 #);
                 deletion.scan
                 (#
                 do current.dismissConnectors;
                    current.refresh;
                    current[] -> nodes.remove;
                    current[] -> visibles.delete;
                    (if current.sticky then
                        &current.Drag[] -> current.fig.theBehaviour[];
                        current[] -> THIS(SequenceDiagram).add;
                        current[] -> floating.append;
                    if);
                 #);
                 'present' -> repaint;
              #);
          if);
       #);     

     ActionList: Sequence
       (# Element:: Action;
       #);
     Action:
       (# id: @integer;
       	  y: @integer;
          transient: @boolean;
          isLastInSuspended: @boolean;
          isPreemptive: @boolean;
          isSkipping: @boolean;
          
          skipping:<
            (# value: @boolean;
            do INNER;
            exit value
            #);
          init:<
            (#
            do global_id + 1 -> global_id;
               global_id -> id;
               INNER;
            #);
          flatten:<
            (#  actions: ^ActionList;
            enter actions[]
            do false -> isLastInSuspended;
               INNER;
            #);
          prepare:<
            (# height: @integer;
               manager: ^PositionManager;
            enter manager[]
            do INNER;
            exit height
            #);
          process:<
            (# mark: ^List;
               nodes: ^ObjectShapeList;
               y: @integer;
               header: @integer;
               manager: ^PositionManager;
               shapes: ^ActionShapeList;
               addShape:
                 (# shape: ^ActionShape;
                 enter shape[]
                 do (if shape[] <> NONE then
                        THIS(Action).y -> shape.offset;
                        shape[] -> shapes.append;
                    if);
                 #);
            enter (mark[], nodes[], shapes[], y, header, manager[])
            do y -> THIS(Action).y;
               INNER;
            exit y
            #);
          makeShape:<
            (# result: ^ActionShape;
            do INNER;
            exit result[]
            #);
          finish:<
            (#
            do INNER;
            #);
          
          activate:<
            (# do INNER #);
          deactivate:<
            (# do INNER #);
          
          clearHistory:<
            (#
            do INNER;
            #);
          description:<
            (# string: ^Text;
            do THIS(Action)[] -> getPatternName -> string[];
               INNER;
            exit string[]
            #);
       #);          
     global_id: @integer;
     
     markProblem: @
       (# cnt1,cnt2: @integer;
          msg:
            (# no: @integer
            enter no
            do (if no
                // 1 then
                   (if cnt1 = 0 then
                       '*** OBS! PositionManager:layout:current.target is none '
                         -> putline;
                       '*** Only one instance of this error message is shown' 
                         -> putline;
                       cnt1 + 1 -> cnt1
                   if);
                // 2 then
                   (if cnt2 = 0 then
                       '\n***** OBS! objectOriginOf: origin is NONE!' 
                         -> putline;
                       inner;
                       '*** Only one instance of this error message is shown' 
                         -> putline;                  
                       cnt2 + 1 -> cnt2;
               if)if)
            #)
       #);
     PositionManager:
       (# positions: @Sequence(# element:: Position #);
          fixed: @Sequence(# element:: FixedRelation #);
          print:
            (#
            do '--- positions ---' -> putline;
               positions.scan
               (#
               do current.description -> putline;
               #);
            #);
          layout:
            (# x: @integer;
               y: @integer;
            do 24 -> x;
               24 -> y;
               positions.scan
               (# 
               do x -> current.x;
                  (if current.target[] = none then
                      1 -> markProblem.msg;
                      x + 24 -> x (* just a hack - dont know what goes on here*)
                   else                      
                      x + current.target.width + 24 -> x;
                  if);                  
                  y -> current.y;
               #);
               positions.scan
               (# 
               do current.layout;
               #);
               24 -> x;
               positions.scan
               (# 
               do (if current.x < x then
                      x -> current.x;
                   else
                      current.x -> x;
                  if);
                  (if current.target[] = none then
                      x + 24 -> x;
                   else
                      x + current.target.maximum + 24 -> x;
                  if)
               #);
               (if false then
                   '== positions ==' -> putline;
                   positions.scan
                   (#
                   do '  ' -> puttext;
                      current.description -> putline;
                   #);
               if);
            #);
          apply:
            (#
            do positions.scan
               (#
               do current.apply;
               #);
               fixed.scan
               (#
               do current.apply;
               #);
            #);
          lookup:
            (# target: ^ObjectShape;
               pos: ^Position;
            enter target[]
            do search: positions.scan
                 (#
                 do (if current.target[] = target[] then
                        current[] -> pos[];
                        leave search;
                    if);
                 #);
            exit pos[]
            #);
          register:
            (# target: ^ObjectShape;
               pos: ^Position;
            enter target[]
            do &Position[] -> pos[];
               target[] -> pos.target[];
               pos[] -> positions.append;
            exit pos[]
            #);
          ensure:
            (# target: ^ObjectShape;
               pos: ^Position;
            enter target[]
            do target[] -> lookup -> pos[];
               (if pos[] = NONE then
                   target[] -> register -> pos[];
               if);
            exit pos[]
            #);          
          set:
            (# target: ^ObjectShape;
               x, y: @integer;
            enter (target[], x, y)
            do (# pos: ^Position;
               do target[] -> ensure -> pos[];
                  x -> pos.x;
                  y -> pos.y;
               #);
            #);          
          relate:
            (# from, to: ^ObjectShape;
               distance: @integer;
            enter (from[], to[], distance)
            do (# p1, p2: ^Position;
                  r1: ^Relation;
                  r2: ^Relation;
               do from[] -> ensure -> p1[];
                  to[] -> ensure -> p2[];
                  &Relation[] -> r1[];
                  p2[] -> r1.to[];
                  distance -> r1.distance;
                  r1[] -> p1.relations.append;
                  &Relation[] -> r2[];
                  p1[] -> r2.to[];
                  distance -> r2.distance;
                  r2[] -> p2.relations.append;
               #);
            #);
          fix:
            (# from, to: ^ObjectShape;
               x, y: @integer;
            enter (from[], to[], x, y)
            do (# rel: ^FixedRelation;
               do &FixedRelation[] -> rel[];
                  from[] -> rel.from[];
                  to[] -> rel.to[];
                  x -> rel.distance;
                  y -> rel.y;
                  rel[] -> fixed.append; 
               #);
            #);
          
          Position:
            (# target: ^ObjectShape;
               x: @integer;
               y: @integer;
               mark: @boolean;
               
               relations: @Sequence(# element:: Relation #);
               
               middle:
                 (# value: @integer;
                 do (if target[] <> none then
                        x + target.width / 2 -> value
                     else
                        (* dont know what goes on if target = none!?*)
                        x -> value
                    if)
                 exit value
                 #);
               description:
                 (# value: ^Text;
                 do (target.description).copy -> value[];
                    ' ' -> value.puttext;
                    x -> value.putint;
                    ' | ' -> value.puttext;
                    target.maximum -> value.putint;
                 exit value[]
                 #);
               layout:
                 (#
                 do true -> mark;
                    relations.scan
                    (#
                    do THIS(Position)[] -> current.apply;
                    #);
                 #);
               apply:
                 (#
                 do (if target[] <> none then
                        (x, y) -> target.layoutLiveObject;
                        target.live[] -> lines.add;
                     else
                        '!!!! Position:apply:' -> putline;
                        (* OLM: dont know what goes on if target = none!? *)
                    if)
                 #);
            #);
          Relation:
            (# to: ^Position;
               distance: @integer;
               
               apply:
                 (# from: ^Position;
                 enter from[]
                 do (# d: @integer;
                       dx: @integer;
                    do to.middle - from.middle -> d;		       
                       (if d < 0 then
                           -d -> d;
                           (if d < distance then
                               distance - d -> dx;
                               to.x - dx -> to.x;
                           if);
                        else
                           (if d < distance then
                               distance - d -> dx;
                               to.x + dx -> to.x;
                           if);
                       if);
                    #);
                 #);
            #);
          FixedRelation:
            (# from: ^ObjectShape;
               to: ^ObjectShape;
               distance: @integer;
               y: @integer;
               apply:
                 (# pos: ^Position;
                 do '**** FixedRelation:apply:'->puttext;
                    (if from[] = none then '!!!! from is none' -> putline if);
                    (if to[] = none then '!!!! to is none' -> putline if);
                    from[] -> lookup -> pos[];
                    (if pos[] = none then 
                        '!!!! pos is none' -> putline
                     else                         
                        (pos.x + distance, y) -> to.layoutLiveObject;
                    if)
                 #);
            #);         
       #);

     Invocation: Action
       (# receiver: ^ObjectShape;
          self: ^ObjDesc.RunTimeObject;
          message: ^ObjectShape;
          common: ^ObjDesc.RunTimeObject;          
          allocating: ^Invocation;
          allocation: @boolean;
          isObj: @boolean;
          isReturn: @boolean;
          isRoot: @boolean;
          isComponent: @boolean;
          isSuspended: @boolean;
          isCollapsed: @boolean;
          
          history: @List(# Element:: Invocation #);
          stack: @Sequence
            (# Element:: Action;
               peek:
                 (# elm: ^Element;
                 do (if NOT empty then
                        last -> elm[];
                    if);
                 exit elm[]
                 #);
               pop:
                 (# elm: ^Element;
                 do (if NOT empty then
                        deleteLast -> elm[];
                    if);
                 exit elm[]
                 #);
               push:
                 (# elm: ^Element;
                 enter elm[]
                 do elm[] -> append;
                 #);
            #);
          
          selectCode:
            (# done: @boolean;
            do (if false then
                   '**** Invocation:select-code: ' -> puttext;
                   description -> putline;
               if);               
               (if self[] <> NONE then
                   (if self.myLscTop > 0 then
                       self[] -> showCode;
                       true -> done;
                   if);
               if);
               (if not done then
                   (if return[] <> NONE then
                       return.selectCode;
                   if);
               if);
            #);
          
          activate::
            (#
            do (if not allocation then
                   (if message[] <> NONE then
                       message.activate;
                    else
                       receiver.activate;
                   if);
               if);
            #);
          deactivate::
            (#
            do (if not allocation then
                   (if message[] <> NONE then
                       message.deactivate;
                    else
                       receiver.deactivate;
                   if);
               if);
            #);
          peek:
            (# theAction: ^Action;
            do stack.peek -> theAction[];
            exit theAction[]
            #);
          pop:
            (# theAction: ^Action;
            do stack.pop -> theAction[];
            exit theAction[]
            #);
          push:
            (# theAction: ^Action;
            enter theAction[]
            do theAction[] -> stack.push;
            #);          
          flush:
            (# top: ^Action;
               prepare: @boolean;
            enter prepare
            do peek -> top[];
               (if top[] <> NONE then
                   top.finish;
                   (if prepare then
                       (if top## = PrepareCall## then
                           pop;
                           NONE -> top[];
                       if);
                   if);
               if);
               while:
                 (if top[] <> NONE then
                     (if top.transient then
                         pop;
                         peek -> top[];
                         restart while;
                     if);
                 if);
            #);
          copy:
            (# new: ^Invocation;
            do &Invocation[] -> new[];
               new.init;
               receiver[] -> new.receiver[];
               allocation -> new.allocation;
               return[] -> new.return[];
               isSkipping -> new.isSkipping;
            exit new[]
            #);
          finish::
            (#
            do stack.scan
               (#
               do current.finish;
               #);
               flush;
            #);
          clearHistory::
            (#
            do stack.scan
               (#
               do current.clearHistory;
               #);
               history.scan
               (#
               do current.clearHistory;
               #);
               history.clear;
            #);
          return: ^Invocation;
          
          skipping::
            (# 
            do isSkipping -> value;
            #);
          flatten::
            (#
            do false -> isRoot;
               false -> receiver.isRoot;
               THIS(Invocation)[] -> actions.append;
	       (if not isCollapsed then
                   history.scan
                   (#
                   do actions[] -> current.flatten; 
                   #);
                   stack.scan
                   (#
                   do actions[] -> current.flatten;
                   #);
               if);
            #);
          prepare::
            (# actual: ^ObjectShape;
            do receiver.visibleOrigin -> actual[];
               actual[] -> manager.ensure;
               (*** 'prepare' -> receiver.refresh; ***)
               (if message[] <> NONE then
                   'message' -> message.refresh;
               if);
               (if not allocation then
                   actual.height -> height;
               if);
               isComponent -> receiver.isComponent;
            #);
          process::
            (# dy: @integer;
               sender: ^ObjectShape;
               actual: ^ObjectShape;
               extra: @integer;
            do (if not skipping then
                   receiver.visibleOrigin -> actual[];
                   (if not isSuspended then
                       (if return[] <> NONE then
                           return.receiver[] -> sender[];
                           sender.visibleOrigin -> sender[];
                       if);
                   if);
                   (if actual[] = sender[] then
                       50 -> dy;
                    else
                       30 -> dy;
                   if);
                   (if not (actual[] -> mark.has) then
                       actual[] -> mark.append;
                       (if allocation then
                           actual.height + 4 -> dy;
                           (if y > header then
                               (sender[], actual[], actual.width / 2 + 60, y) 
                                 -> manager.fix;
                               actual[] -> nodes.append;
                           if);
                        else
                           actual[] -> nodes.append;
                           actual.width -> actual.maximum;
                       if);
                   if);
                   (if sender[] <> NONE then
                       (if not (sender[] -> mark.has) then
                           sender[] -> mark.append;
                           sender[] -> nodes.append;
                       if);
                   if);
                       
                   (if message[] <> NONE then
                       (if not allocation then
                           (if actual[] <> receiver[] then
                               30 -> extra;
                           if);
                           (if return[] <> NONE then
                               (if return.receiver[] <> sender[] then
                                   extra + 30 -> extra;
                               if);
                           if);
                           (if sender[] <> actual[] then
                               (sender[], actual[], message.width + 30 + extra) 
                                 -> manager.relate;
                            else
                               (# width: @integer;
                               do (if message[] <> NONE then
                                      message.width + 20 -> width;
                                   else
                                      60 -> width;
                                  if);
                                  (if width > actual.maximum then
                                      width -> actual.maximum;
                                  if);
                               #);
                           if);
                       if);
                       (if (message.height + 4) > dy then
                           message.height + 4 -> dy;
                       if);
                   if);
                   (if y > (header + 24) then
                       (if message[] <> NONE then
                           message[] -> mark.append;
                           message[] -> nodes.append;
                       if);
                   if);
                   y + dy -> y;
                   makeShape -> addShape;
               if);
            #);
          
          makeShape::
            (# sender: ^ObjectShape;
               actual: ^ObjectShape;
               layoutRegular:
                 (# shape: ^MessageShape;
                 do &MessageShape[] -> shape[];
                    sender[] -> shape.sender[];
                    actual[] -> shape.receiver[];
                    message[] -> shape.message[];
                    isReturn -> shape.isReturn;
                    isLastInSuspended -> shape.isLastInSuspended;
                    isPreemptive -> shape.isPreemptive;
                    (if not isReturn then
                        (if receiver[] <> actual[] then
                            receiver[] -> shape.part2[];
                        if);
                        (if return[] <> NONE then
                            (if return.receiver[] <> sender[] then
                                return.receiver[] -> shape.part1[];
                            if);
                        if);
                    if);
                    shape[] -> result[];
                 #);
               layoutSelf:
                 (# shape: ^SelfMessageShape;
                 do &SelfMessageShape[] -> shape[];
                    sender[] -> shape.sender[];
                    message[] -> shape.message[];
                    isReturn -> shape.isReturn;
                    shape[] -> result[];
                 #);
            do 
               (if isSuspended then
                   NONE -> result[];
                else
                   receiver.visibleOrigin -> actual[];
                   (if return[] <> NONE then
                       return.receiver[] -> sender[];
                       sender.visibleOrigin -> sender[];
                   if);
                   (if sender[] <> NONE then
                       (if sender[] = actual[] then
                           layoutSelf;
                        else
                           layoutRegular;
                       if);
                   if);
               if);
            #);
          
          match:
            (# self: ^ObjDesc.RunTimeObject;
               result: @boolean;
            enter self[]
            do self[] = THIS(Invocation).self[] -> result;;
            exit result
            #);
          matchAny:
            (# self: ^ObjDesc.RunTimeObject;
               result: @boolean;
            enter self[]
            do (if self[] -> match then
                   true -> result;
                else
                   (if return[] <> NONE then
                       self[] -> return.match -> result;
                    else
                       false -> result;
                   if);
               if);
            exit result
            #);
          find:
            (# self: ^ObjDesc.RunTimeObject;
               stack: ^Invocation;
            enter self[]
            do (if (self[] -> match) or true then
                   THIS(Invocation)[] -> stack[];
                else
                   (if return[] <> NONE then
                       self[] -> return.find -> stack[];
                   if);
               if);
            exit stack[]
            #);
          description::
            (# sender: ^ObjectShape;
            do '[' -> string[];
               (if return[] <> NONE then
                   return.receiver[] -> sender[];
               if);
               (if sender[] <> NONE then
                   'sender: ' -> string.puttext;
                   sender.description -> string.puttext;
                else
                   'BetaStart ' -> string.puttext;
               if);
               (if message[] <> NONE then
                   ' | message: ' -> string.puttext;
                   message.reflect.name -> string.puttext;
                   ' ' -> string.puttext;
                else
                   ' | allocate: ' -> string.puttext;
                   (if receiver[] <> NONE then
                       receiver.description -> string.puttext;
                   if);
               if);               
               (if receiver[] <> NONE then
                   ' | receiver: ' -> string.puttext;
                   receiver.description -> string.puttext;
                else
                   ' | no receiver? ' -> string.puttext;
               if);               
               ']' -> string.puttext;
            #);
       #);
     PushValue: Action
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          receiver: ^ObjectShape;          
          skipping::
            (#
               self: ^ObjDesc.RunTimeObject;
               origin: ^ObjDesc.RunTimeObject;
            do receiver.reflect.template[] -> self[];
               self[] -> visibleOriginOf -> origin[];
               (if origin[] <> NONE then
                   true -> value;
               if);
            #);
          flatten::
            (#
            do (if showValues then
                   (if not skipping then
                       THIS(PushValue)[] -> actions.append;
                   if);
               if);
            #);
          prepare::
            (#
            #);
          
          process::
            (#
            do y + 22 -> y;
               makeShape -> addShape;
            #);
          makeShape::
            (# shape: ^PushValueShape;
            do &PushValueShape[] -> shape[];
               receiver[] -> shape.receiver[];
               value[] -> shape.value[];
               where[] -> shape.where[];
               shape[] -> result[];
            #);
          finish::
            (#
            do NONE -> where[];
            #);
       #);
     StoreValue: Action
       (# value: ^Text;
          sender: ^ObjectShape;
          where: ^ObjectReflector.AttributeReflector;
          skipping::
            (#
               self: ^ObjDesc.RunTimeObject;
               origin: ^ObjDesc.RunTimeObject;
            do sender.reflect.template[] -> self[];
               self[] -> visibleOriginOf -> origin[];
               (if origin[] <> NONE then
                   true -> value;
               if);
            #);
          flatten::
            (#
            do (if showValues then
                   (if not skipping then
                       THIS(StoreValue)[] -> actions.append;
                   if);
               if);
            #);
          prepare:: (# #);
          process::
            (#
            do y + 22 -> y;
               makeShape -> addShape;
            #);
          makeShape::
            (# shape: ^StoreValueShape;
            do &StoreValueShape[] -> shape[];
               sender[] -> shape.sender[];
               where[] -> shape.where[];
               value[] -> shape.value[];
               shape[] -> result[];
            #);
          
       #);
     ErrorMessage: Action
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          receiver: ^ObjectShape;          
          flatten::
            (#
            do THIS(ErrorMessage)[] -> actions.append;
            #);
          prepare:: (# #);          
          process::
            (#
            do y + 22 -> y;
               makeShape -> addShape;
            #);
          makeShape::
            (# shape: ^ErrorMessageShape;
            do &ErrorMessageShape[] -> shape[];
               value[] -> shape.value[];
               where[] -> shape.where[];
               receiver[] -> shape.receiver[];
               shape[] -> result[];
            #);
          finish::
            (#
            do NONE -> where[];
            #);
       #);
     PrepareCall: Action
       (# sender: ^ObjectShape;
          receiver: ^ObjectShape;
          flatten::
            (#
            do THIS(PrepareCall)[] -> actions.append;
            #);
          process::
            (# actual: ^ObjectShape;
            do sender.visibleOrigin -> actual[];
               (if not (receiver[] -> mark.has) then
                   receiver[] -> mark.append;
                   (actual[], receiver[], receiver.width / 2 + 60, y)
                     -> manager.fix;
                   (if y > (header + 24) then
                       receiver[] -> nodes.append;
                   if);
               if);
               y + 22 -> y;
               makeShape -> addShape;
            #);
          makeShape::
            (# shape: ^PrepareCallShape;
               actual: ^ObjectShape;
            do &PrepareCallShape[] -> shape[];
               sender.visibleOrigin -> shape.sender[];
               receiver[] -> shape.receiver[];
               shape[] -> result[];
            #);
       #);
     
     skipAllocations: @boolean;
     showValues: @boolean;
     showOrigins: @boolean;
     allocating_: ^Invocation;
     allocating:
       (# set:
            (# value: ^Invocation;
            enter value[]
            do value[] -> top.allocating[];
            #);
          get:
            (# value: ^Invocation;
            do top.allocating[] -> value[];
            exit value[]
            #);
       enter set
       exit get
       #);
     skippingOver: ^Invocation;
     mode: @integer;
     
     NormalMode: (# exit 0 #);
     SkipOneMode: (# exit 1 #);
     SearchingMode: (# exit 2 #);
     SkipOverMode: (# exit 3 #);
     BreakMode: (# exit 4 #);
     beginning: @boolean;
     recentlyResumed: ^Invocation;
     
     start: ^Invocation;
     top: ^Invocation;
     
     InvocationList: Sequence(# Element:: Invocation #);
     
     suspended: @InvocationList;
     returning: ^Invocation;
     assigning: ^StoreValue;
     started: @boolean;
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do '**** pushInvocation:'->puttext; theInvocation.description -> putline;
          theInvocation.activate;
          (if top[] <> NONE then
              top.flush;
              top[] -> theInvocation.return[];
              theInvocation[] -> top.push;
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          true -> beginning;
          NONE -> recentlyResumed[];
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
          return: ^Invocation;
       do top[] -> returning[];
          top[] -> theInvocation[];
          '**** popInvocation:'->puttext; theInvocation.description -> putline;
          (*** theInvocation.deactivate; ***)
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          theInvocation.return[] -> top[];
          theInvocation.copy -> return[];
          true -> return.isReturn;
          return[] -> top.push;
       #);
     suspendInvocation:
       (# self: ^ObjDesc.RunTimeObject;
          skipped: @boolean;
	  preemptive: @boolean;
       enter (self[], preemptive)
       do (# current: ^Invocation;
             link: ^Invocation;
          do top[] -> current[];
             while:
               (if current[] <> NONE then
                   (if current[] = skippingOver[] then
                       true ->skipped;
                   if);
                   (if NOT (self[] -> current.match) then
                       current.deactivate;
                       current.return[] -> current[];
                       restart while;
                   if);
               if);
             (if current[] <> NONE then
                 current.deactivate;
                 (if LOGGING then
                     'SUSPEND ' -> puttext;
                     current.description -> putline;
                 if);
                 current.return[] -> link[];
                 top[] -> current.return[];
                 link[] -> top[];
                 (if (top.peek = current[]) then
                     top.pop;
                 if);
                 current[] -> suspended.append;
                 true -> current.isSuspended;
                 preemptive -> current.isPreemptive;
              else
                 top[] -> current[];
                 while:
                   (if current[] <> NONE then
                       current.activate;
                       current.return[] -> current[];
                       restart while;
                   if);
             if);
          #);
       exit skipped
       #);
     resumeInvocation:
       (# self: ^ObjDesc.RunTimeObject;
       enter self[]
       do (# candidate: ^Invocation;
             link: ^Invocation;
             current: ^Invocation;
          do search: suspended.scan
               (#
               do (if self[] -> current.match then
                      current[] -> candidate[];
                      leave search;
                  if);
               #);
             (if candidate[] <> NONE then
                 true -> candidate.isComponent;
                 top.flush;
                 top[] -> link[];
                 candidate.return[] -> top[];
                 link[] -> candidate.return[];
                 candidate[] -> link.push;
                 false -> candidate.transient;
                 candidate[] -> suspended.delete;
                 false -> candidate.isSuspended;
                 
                 top[] -> current[];
                 loop:
                   (if current[] <> candidate[] then
                       current.activate;
                       current.return[] -> current[];
                       restart loop;
                   if);
                 candidate.activate;
                 
                 (if mode = SearchingMode then
                     (if LOGGING then
                         'step-over attach-found: ' -> puttext;
                         candidate.description -> putline;
                     if);
                     candidate[] -> skippingOver[];
                     NormalMode -> mode;
                 if);
                 candidate[] -> recentlyResumed[];
                 (if LOGGING then
                     'RESUME ' -> puttext;
                     candidate.description -> putline;
                 if);
             if);
          #);
       #);
     refreshExecution:
       (#
       do true -> updateFlag;
          'refresh-execution' -> refresh;
          false -> updateFlag;
       #);
     rp: @integer;
     refresh:
       (# where: ^Text;
       enter where[]
       do (if false then
              rp + 1 -> rp;
              'refresh: ' -> puttext;
              rp -> putint;
              ' | ' -> puttext;
              where[] -> putline;
          if);
          'refresh' -> presentSequenceDiagram;
          floating.scan
          (#
          do current.refresh;
          #);
          refreshConnectors;
       #);
     
     terminate:
       (#
       do start.finish;
          refreshExecution;
          true -> isTerminated;
       #);
     
     isTerminated: @boolean;
     
     finishPending:
       (# pending: @boolean;
          return: ^Action;
          call: ^Action;
       do (*'**** finishPending: '->puttext; 
           * returning[] <> NONE -> putboolean;*)
          (if returning[] <> NONE then
              top.pop -> return[];
              top.pop -> call[];
              (if doKeepHistory then
                  call.deactivate;
                  call[] -> top.history.append;
                  return[] -> top.history.append;
              if);
              returning.stack.scan
              (# pv: ^PushValue;
              do (if current## = PushValue## then
                     current[] -> pv[];
                     top.receiver[] -> pv.receiver[];
                     pv[] -> top.push;
                 if);
              #);
              NONE -> returning[];
              'finish-pending' -> refresh;
              true -> pending;
           else 
              (if assigning[] <> NONE then
                  top.pop;
                  NONE -> assigning[];
                  'finish-pending' -> refresh;
                  true -> pending;
              if);
          if);
       exit pending
       #);
     reActivate:
       (#
       do VM.reActivate;
          (if NOT VM.execute.isRunning then
              terminate;
          if);
       #);
     step:
       (# pending: @boolean;
       do finishPending -> pending;
          reActivate;
       #);
     stepOut:
       (#
       do finishPending;
          (if beginning then
              (if true then
                  top[] -> skippingOver[];
               else
                  (if top.return[] <> NONE then
                      top.return[] -> skippingOver[];
                   else
                      top[] -> skippingOver[];
                  if);
              if);
           else
              top[] -> skippingOver[];
          if);
          reActivate;
       #);
     stepOver:
       (#
       do finishPending;
          (if beginning then
              top[] -> skippingOver[];
              SkipOverMode -> mode;
              (if LOGGING then
                  'step-over: ' -> puttext;
                  skippingOver.description -> putline;
              if);
           else
              (if recentlyResumed[] <> NONE then
                  recentlyResumed[] -> skippingOver[];
                  SkipOverMode -> mode;
                  (if LOGGING then
                      'step-over-resumed: ' -> puttext;
                      skippingOver.description -> putline;
                  if);
               else
                  SearchingMode -> mode;
                  (if LOGGING then
                      'step-over search' -> putline;
                  if);
              if);
          if);
          reActivate;
       #);
     continue:
       (#
       do finishPending;
          false -> stepping;
          reActivate;
       #);
     doClose:
       (#
       do (if VM.execute.isRunning then
              VM.execute.terminate;
              VM.reActivate;
          if);
          clearSequenceDiagram;
          'close' -> repaint;
       #);
     
     getAttName:
       (# obj: ^ObjDesc.RunTimeObject; off: @integer; 
          isRef,isIndexed: @boolean; NM: ^text;
          OD: ^Tree.TopNode
       enter(off,obj[],isRef,isIndexed)
       do obj.myDescInx -> compiler.getObjectDesc -> OD[];
          (off,obj.myDescInx,isRef,isIndexed) -> OD.getNameForOff -> nm[];
       exit NM.copy
       #);
     objectOriginOf:
       (# self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
       enter self[]
       do self[] -> origin[];
          search:
            (if not origin.isObj then
                origin.myOrigin -> origin[];
                (if origin[] <> none then
                    restart search
                 else
                    2 -> markProblem.msg
                    (#
                    do ' descInx: '->puttext; self.myDescInx -> putint; newline
                    #);
                    self.mkDummyTemplate  -> origin[];
                if)
            if);
          (if SKIP_INTERNAL then
              (# visible: ^ObjDesc.RunTimeObject;
              do origin[] -> visibleOriginOf -> visible[];
                 (if visible[] <> NONE then
                     visible[] -> origin[];
                 if);
              #);
          if);
       exit origin[]
       #);
     
     legit:
       (# stack: ^ObjDesc.RunTimeObject;
          result: @boolean;
       enter stack[]
       do (if allocating = NONE then
              stack[] -> top.matchAny -> result;
           else
              false -> result;
          if);
       exit result
       #);
     
     VMEvent:
       (# doPause: @boolean;
          shouldPause:<
            (# ok: @boolean;
            do (if stepping then
                   (if (skippingOver[] = NONE) then
                       true -> ok;
                       INNER;
                       (if ok then
                           (if mode = SkipOneMode then
                               NormalMode -> mode;
                               finishPending;
                               false -> ok;
                            else
                               (if mode = SearchingMode then
                                   false -> ok;
                               if);
                           if);
                       if);
                    else
                       finishPending;
                   if);
                else
                   (if mode = BreakMode then
                       NormalMode -> mode;
                       true -> stepping;
                       true -> OK;
                   if);
                   finishPending;
               if);
            exit ok
            #);
          pause:
            (#
            do (if shouldPause then
                   true -> doPause;
                   '*** VMevent:pause:' -> putline;
                   refreshExecution;
               if);
            #);
       do false -> beginning;
          NONE -> recentlyResumed[];
          INNER
       exit doPause
       #);
     onStart: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^ObjectShape;
             theInvocation: ^Invocation;
          do self[] 
               -> reflection
               -> objectShapeForTarget
               -> receiver[];
             &Invocation[] -> theInvocation[];
             theInvocation.init;
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
             pause;
          #);
       #);
     onAlloc: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          isObj: @boolean;
          isIndexed: @boolean;
       enter (caller[], self[], origin[], bc, isObj, isIndexed)
       do (# shape: ^ObjectShape;
             receiver: ^ObjectShape;
             theInvocation: ^Invocation;             
          do              
             (if true or (self.OSDvisibility > 0) then
                 '\n**** onAlloc: caller: ' -> puttext;
                 (if caller[] <> none then
                     caller.myName -> puttext;
                  else
                     'none' -> puttext
                 if);
                 ' self: ' -> puttext; self.myName -> puttext; 
                 ' visibility: ' -> puttext; self.OSDvisibility -> putint; 
                 ' visibilityOf: ' -> puttext;
                 self.myObjDesc -> visibilityOf ->  putint;
                 ' allocating: ' -> puttext; allocating <> none -> putBoolean;
                 '\n** visibilityOf:again:'-> putline
             if);
             (* set visibility of self to visibility of enclosing module!
              * Elim of this imp makws qbeta&Formater work
              * Test of this also work for minienv
              self.myObjDesc -> visibilityOf -> self.OSDvisibility;
              *)
             self[]
               -> reflection
               -> objectShapeForTarget
               -> shape[];
             isObj -> shape.isObject;
             shape.refresh;
             isObj -> self.isObj;
             
             (if allocating = NONE then
                 (if isIndexed then
                     top.pop;
                     top.pop;
                 if);
                 top.pop;    
                 shape[] -> receiver[];

                 &Invocation[] -> theInvocation[];
                 theInvocation.init;
                 self[] -> theInvocation.self[];
                 true -> theInvocation.allocation;
                 isObj -> theInvocation.isObj;
                 receiver[] -> theInvocation.receiver[];
                 top[] -> theInvocation.return[];
                 theInvocation[] -> allocating;
             if);             
          #);
       #);
     onDo: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          actual: ^ObjDesc.RunTimeObject;
          preemptive: @boolean;
          bc: @integer;
       enter (caller[], self[], origin[], bc, preemptive)
       do (if self[] <> NONE then
              (# receiver: ^ObjectShape;
                 shape: ^ObjectShape;
                 message: ^ObjectShape;
                 common: ^ObjDesc.RunTimeObject;
                 theInvocation: ^Invocation;
                 skip: @boolean;
                 doSkip: @boolean;
              do (if true or (self.OSDvisibility > 0) then
                     '**** onDo:caller: ' -> puttext;
                     (if caller[] <> none then
                         caller.myName -> puttext;
                      else
                         'none' -> puttext
                     if);
                     ' self: ' -> puttext; self.myName -> puttext;
                     ' visibility: ' -> puttext;
                     self.OSDvisibility -> putint; newline;
                 if);
                 
                 top.flush;
                 top.pop;
                 
                 self[] -> isDisguised -> skip;
                 '**   isDisguised: ' -> puttext; skip -> putBoolean; newline;
                 (if NOT skip then
                     (if caller[] <> NONE then
                         (caller[], self[]) -> commonOrigin -> common[];
                         (if common[] <> none then
                             '**** commonOrigin[Caller: "' -> puttext;
                             caller.myName -> puttext;
                             '", self: "' -> puttext; self.myName -> puttext;
                             '"]: "' -> puttext;
                             common.myName -> puttext; '"\n' -> puttext;
                             (if SKIP_INTERNAL then (* false const *)
                                 common[] -> isSkipInternal -> skip;
                              else
                                 common[] -> isSkipInternal -> doSkip;
                             if);
                             '**   doSkip: ' -> puttext; 
                             doSkip -> putBoolean; newline
                          else
                             '**** theCommonOrigin: none'->putline
                         if);
                     if);
                 if);
                 
                 (if NOT skip then
                     self[] -> objectOriginOf -> actual[];
                     self[]
                       -> reflection
                       -> objectShapeForTarget
                       -> shape[];
                     '**   (shape) = none: ' -> puttext;
                     shape[] = none -> putboolean;
                     ' (actual = none): ' -> puttext;
                     actual[] = none -> putboolean;
                     ' (shape.isObject): ' -> puttext; 
                     shape.isObject -> putBoolean;
                     (if (shape.isObject or (actual[] = NONE)) then
                         shape[] -> receiver[];
                      else
                         actual[] 
                           -> reflection
                           -> objectShapeForTarget
                           -> receiver[];
                         shape[] -> message[];
                         false -> message.sticky;
                     if);
                     &Invocation[] -> theInvocation[];
                     theInvocation.init;
                     
                     '\n**** invocation: self: ' -> puttext; 
                     self.myName -> puttext;
                     ' receiver: ' -> puttext; receiver.description -> puttext;
                     ' message: ' -> puttext;
                     (if message[] <> none then
                         message.description -> putline;
                      else
                         'none' -> putline
                     if);
                     self[] -> theInvocation.self[];
                     receiver[] -> theInvocation.receiver[];
                     message[] -> theInvocation.message[];
                     preemptive -> theInvocation.isComponent;
                     preemptive -> theInvocation.receiver.isComponent;
                     doSkip -> theInvocation.isSkipping;
                     theInvocation[] -> pushInvocation;
                     
                     (if mode = SearchingMode then
                         (if LOGGING then
                             'step-over found: ' -> puttext;
                             theInvocation.description -> putline;
                         if);
                         theInvocation[] -> skippingOver[];
                         SkipOverMode -> mode;
                         finishPending;
                     if);
                     (if (self.myOrigin, self[]) -> breaks.isBreak then
                         BreakMode -> mode;
                     if);
                     (if not theInvocation.isSkipping then
                         '**** end:onDo:not skipping:show diagram\n'->putline;
                         pause;
                      else
                         '**** end:onDo:skipping: no diagram shown\n' -> putline
                     if);
                 if);
              #);
          if);
       #);
     onReturn: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          isSkipping: @boolean;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if true or (self.OSDvisibility > 0) then
                 '**** onReturn: caller: ' -> puttext;
                 (if caller[] <> none then
                     caller.myName -> puttext;
                  else
                     'none' -> puttext
                 if);
                 ' self: ' -> puttext; 
                 self.myName -> puttext; ' visibility: ' -> puttext;
                 self.OSDvisibility -> putint;
                 ' allocating: ' -> puttext; allocating <> none ->putBoolean;
                 newline;
             if);
             (if allocating <> NONE then
                 (if self[] -> (allocating).match then
                     top.flush;
                     (# act: ^PrepareCall;
                     do &PrepareCall[] -> act[];
                        act.init;
                        (allocating).return.receiver[] -> act.sender[];
                        (allocating).receiver[] -> act.receiver[];
                        act[] -> top.push;
                        (if act.receiver.isObject OR showValues then
                            (if not (self.OSDvisibility 
                                = OSDvisibility_Disguised) then
                                '\n*** onReturn:pause:'->puttext;
                                self.myName -> putline;
                                pause;
                        if)if);
                     #);
                     NONE -> allocating;
                 if);
              else
                 (if mode = SearchingMode then
                     (if LOGGING then
                         'step-over cancel-search' -> putline;
                     if);
                     NormalMode -> mode;
                 if);
                 (if self[] -> top.match then
                     top.isSkipping -> isSkipping;
                     (if top[] = skippingOver[] then
                         NONE -> skippingOver[];
                         (if mode = SkipOverMode then
                             SkipOneMode -> mode;
                         if);
                     if);
                     popInvocation;
                     (if NOT isSkipping then
                         pause;
                     if);
                 if);
             if);
          #);
       #);
     onBreak: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do true -> stepping;
          pause;
       #);
     onSuspend: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          
          preemptive: @boolean;
       enter (caller[], self[], origin[], bc, preemptive)
       do (if not preemptive then
              top.pop;
          if);
          (if (self[], preemptive) -> suspendInvocation then
              (if LOGGING then
                  'step-over suspend-pause: ' -> puttext;
                  skippingOver.description -> putline;
              if);
          if);
       #);
     onResume: VMEvent
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
          bc: @integer;
          preemptive: @boolean;
       enter (caller[], self[], origin[], bc, preemptive)
       do top.pop;
          self[] -> resumeInvocation;
	  (if not preemptive then
              pause;
          if);
       #);
     
     ValueEvent: VMEvent
       (# isOriginEvent: @boolean;
          shouldPause::
            (#
            do (if showValues then
                   (if not showOrigins then
                       not isOriginEvent -> OK;
                    else
                       true -> OK;
                   if);
                else
                   false -> OK;
               if);
            #);
       do INNER;
       #);
     onVPush: ValueEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          isIndexed: @boolean;
          inx: @integer;
          index: ^PushValue;
          value: @integer;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              (if isIndexed then
                  stack.pop -> index[];
              if);
              (if popRStack then
                  stack.pop;
              if);
              (# push: ^PushValue;
                 str: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
                 name: ^Text;
              do &PushValue[] -> push[];
                 push.init;
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> push.value[];
                 (if off > 0 then
                     from[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, from[], false, isIndexed) -> getAttName -> name[];
                     (if index[] <> NONE then
                         '[' -> name.put;
                         index.value[] -> name.puttext;
                         ']' -> name.put;
                     if);
                     (name[], off, compiler.SimpleKind, NONE) -> att.init;
                     att[] -> push.where[];
                 if);
                 stack.receiver[] -> push.receiver[];
                 push[] -> stack.push;
                 (if not push.skipping then
                     pause;
                 if);
              #);             
          if);
       #);
     onRPush: ValueEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.RunTimeObject;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, refValue[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              true -> stack.flush;
              (# push: ^PushValue;
                 str: ^Text;
                 name: ^Text;
                 own: ^ObjectReflector;
                 att: ^ObjectReflector.AttributeReflector;
              do (if popRStack then
                     stack.pop;
                 if);
                 &PushValue[] -> push[];
                 push.init;
                 (if refvalue[] <> NONE then
                     (refValue.myName).copy -> str[];
                  else
                     'NONE' -> str[];
                 if);
                 '^' -> str.prepend;
                 str[] -> push.value[];
                 (if off > 0 then
                     from[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, from[], true, false) -> getAttName  -> name[];
                     'origin' -> name.equal -> isOriginEvent;
                     '[]' -> name.append;
                     (name[], off, compiler.ReferenceKind, NONE) -> att.init;
                     att[] -> push.where[];
                 if);
                 stack.receiver[] -> push.receiver[];
                 push[] -> stack.push;
                 (if not push.skipping then
                     pause;
                 if);
              #);              
          if);
       #);
     onVStore: ValueEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          isIndexed: @boolean;
          inx: @integer;
          off: @integer;
          value: @integer;
          peek: ^Action;
          index: ^PushValue;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, isIndexed, inx, value)
       do (if from[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.peek -> peek[];
              (if peek[] <> NONE then
                  (if peek## = PrepareCall## then
                      (# prep: ^PrepareCall;
                      do peek[] -> prep[];
                         (if NOT prep.receiver.isObject then
                             stack.pop;
                          else
                             NONE -> peek[];
                         if);
                      #);
                   else
                      NONE -> peek[];
                  if);
                  (if isIndexed then
                      stack.pop -> index[];
                  if);
                  (if popRStack then
                      stack.pop;
                  if);
                  stack.pop; (* VALUE *)
               else
                  'STACK ERROR' -> putline;
                  showContext;
              if);
              (if peek[] <> NONE then
                  peek[] -> stack.push;
              if);
              (if showValues then
                  (# store: ^StoreValue;
                     str: ^Text;
                     own: ^ObjectReflector;
                     att: ^ObjectReflector.AttributeReflector;
                     name: ^Text;
                  do &StoreValue[] -> store[];
                     store.init;
                     &Text[] -> str[];
                     value -> str.putint;
                     str[] -> store.value[];
                     
                     to[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, to[], false, isIndexed) -> getAttName  -> name[];
                     (if index[] <> NONE then
                         '[' -> name.put;
                         index.value[] -> name.puttext;
                         ']' -> name.put;
                     if);
                     (name[], off, compiler.SimpleKind, NONE) -> att.init;
                     att[] -> store.where[];
                     stack.receiver[] -> store.sender[];
                     true -> store.transient;
                     store[] -> stack.push;
                     store[] -> assigning[];
                     (if not store.skipping then
                         pause;
                     if);
                  #);
              if);             
          if);
       #);
     onRStore: ValueEvent
       (# from, to: ^ObjDesc.RunTimeObject;
          popRStack: @boolean;
          off: @integer;
          refValue: ^ObjDesc.RunTimeObject;
          peek: ^Action;
          stack: ^Invocation;
       enter (from[], popRStack, to[], off, refValue[])
       do (if from[] -> legit then 
              to[] -> top.find -> stack[];
              stack.flush;
              stack.peek -> peek[];
              (if peek[] = none then 
                  '\n*** sequencediagram::onRstore:peek is none'->putline;
                  leave onRstore
              if);
              (if peek## = PrepareCall## then
                  (# prep: ^PrepareCall;
                  do peek[] -> prep[];
                     (if NOT prep.receiver.isObject then
                         stack.pop;
                      else
                         NONE -> peek[];
                     if);
                  #);
               else
                  NONE -> peek[];
              if);
              (if popRStack then
                  stack.pop;
              if);
              stack.pop; (* VALUE *)
              (if peek[] <> NONE then
                  peek[] -> stack.push;
              if);
              (if showValues then
                  (# store: ^StoreValue;
                     str: ^Text;
                     own: ^ObjectReflector;
                     att: ^ObjectReflector.AttributeReflector;
                     name: ^Text;
                  do &StoreValue[] -> store[];
                     store.init;
                     &Text[] -> str[];
                     (if refValue[] <> NONE then
                         refValue.myName -> str.puttext;
                         '^' -> str.prepend;
                      else
                         'NONE' -> str.puttext;
                     if);
                     str[] -> store.value[];
                     
                     to[] 
                       -> reflection
                       -> own[];
                     &own.AttributeReflector[] -> att[];
                     (off, to[], true, false) -> getAttName -> name[];
                     '[]' -> name.append;
                     (name[], off, compiler.ReferenceKind, NONE) -> att.init;
                     att[] -> store.where[];
                     
                     stack.receiver[] -> store.sender[];
                     true -> store.transient;
                     store[] -> stack.push;
                     store[] -> assigning[];
                     (if not store.skipping then
                         pause;
                     if);
                  #);
              if);
          if);
       #);
     onBinOp: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do 
          (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.pop;
              stack.pop;
              (# push: ^PushValue;
                 str: ^Text;
              do &PushValue[] -> push[];
                 push.init;
                 &Text[] -> str[];
                 value -> str.putint;
                 str[] -> push.value[];
                 stack.receiver[] -> push.receiver[];
                 push[] -> stack.push;
              #);
              pause;
          if);
       #);
     onUnOp: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.pop;
              (if '-' -> operator.equal then
                  (# push: ^PushValue;
                     str: ^Text;
                  do &PushValue[] -> push[];
                     push.init;
                     &Text[] -> str[];
                     value -> str.putint;
                     str[] -> push.value[];
                     stack.receiver[] -> push.receiver[];
                     push[] -> stack.push;
                  #);
              if);
              pause;
          if);
       #);
     onJmpGT: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              stack.pop;
              stack.pop;
              pause;
          if);
       #);
     onPop: ValueEvent
       (# operator: ^text;
          value: @integer;
          to: ^ObjDesc.RunTimeObject;
          stack: ^Invocation;
       enter (operator[], value, to[])
       do (if to[] -> legit then
              to[] -> top.find -> stack[];
              stack.flush;
              (for value repeat
                   stack.pop;
                   stack.pop;
              for);
              pause;
          if);
       #);
     onError: VMEvent
       (# stack: ^Invocation;
          msg: ^Text;
          shouldPause::
            (#
            do true -> ok;
            #);
       enter msg[]
       do (if false then
              'push-message: ' -> puttext;
              msg[] -> putline;
          if);
          top[] -> stack[];
          (# push: ^ErrorMessage;
             str: ^Text;
          do &ErrorMessage[] -> push[];
             push.init;
             msg[] -> push.value[];
             stack.receiver[] -> push.receiver[];
             push[] -> stack.push;
          #);
          pause;
       #);
     
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
              THIS(SequenceDiagram)[] -> shape.dia[];
          if);
       exit shape[]
       #);
     ObjectShapeList: Sequence
       (# Element:: ObjectShape;
       #);
     
     PartObjectShape: CenterFigure
       (# part: ^ObjectShape;
          connectHere:
            (# x, y: @integer;
               shape: ^ObjectShape;
            enter (x, y)
            do part[] -> shape[];
               (if shape.father[] = NONE then
                   x + 30 -> shape.x;
                   y -> shape.y;
                   &shape.Drag[] -> shape.fig.theBehaviour[];
                   shape[] -> THIS(SequenceDiagram).add;
                   shape[] -> floating.append;
               if);
               shape.refresh;
               'connect-here' -> repaint;
            #);
          FieldButton: IconButton
            (# click:
                 (# 
                 do (0, 0) -> localToGlobal -> connectHere;
                 #);
               onExpand::
                 (#
                 do click;
                 #);
               onCollapse::
                 (#
                 do click;
                 #);
            #);
          init::
            (#
            do (# construct: @Construction;
                  row: ^RowFigure;
                  btn: ^FieldButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  0 -> margin;
                  &RowFigure[] -> row[];
                  row.init;
                  row[] -> add;
                  &FieldButton[] -> btn[];
                  (staticRef[] -> createImageFigure, NONE) -> btn.init;
                  btn[] -> row.add;
               #);
            #);
       #);
     StackShape: CenterFigure
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          assign: @boolean;
          description:
            (# txt: ^Text;
            do value.copy -> txt[];
               (if where[] <> NONE then
                   ' <- ' -> txt.puttext;
                   where.description -> txt.puttext;
               if);
            exit txt[]
            #);
          init::
            (#
            enter (value[], where[], assign)
            do (# construct: @Construction;
                  valueFig: ^TextFigure;
                  whereFig: ^TextFigure;
                  row: ^RowFigure;
                  btn: ^IconButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &RowFigure[] -> row[];
                  row.init;
                  true -> row.horizontallyFlexible;
                  2 -> construct.flexhSpace -> row.add;
                  &TextFigure[] -> valueFig[];
                  valueFig.init;
                  value[] -> valueFig.content;
                  res.smallnicestyle[] -> valueFig.style;
                  res.colors.darkerCoolBrown[] -> valueFig.stroke;
                 
                  (if where[] <> NONE then
                      &TextFigure[] -> whereFig[];
                      whereFig.init;
                      where.description -> whereFig.content;
                      res.smallnicestyle[] -> whereFig.style;
                      res.colors.darkerCoolBrown[] -> whereFig.stroke;
                      valueFig[] -> row.add;
                      3 -> construct.hSpace -> row.add;
                      (if assign then
                          createForward -> row.add;
                       else
                          createBackward -> row.add;
                      if);
                      3 -> construct.hSpace -> row.add;
                      whereFig[] -> row.add;
                   else
                      valueFig[] -> row.add;
                  if);
                  2 -> construct.flexHSpace -> row.add;
                  
                  (*
                  &FieldButton[] -> btn[];
                  up[] -> createImageFigure -> btn.init;
                  6 -> construct.flexHSpace -> row.add;
                  btn[] -> row.add;
                  4 -> construct.hSpace -> row.add;*)
                  row[] -> add;
               #);
            #);
       #);
     FieldReferenceShape: CenterFigure
       (# where: ^ObjectReflector.AttributeReflector;
          assign: @boolean;
          theConnector: ^Connector;
          connectHere:
            (# x, y: @integer;
               shape: ^ObjectShape;
            enter (x, y)
            do where.owner 
                 -> objectShapeForTarget 
                 -> shape[];
               (if shape.father[] = NONE then
                   x + 60 -> shape.x;
                   y -> shape.y;
                   &shape.Drag[] -> shape.fig.theBehaviour[];
                   shape[] -> THIS(SequenceDiagram).add;
                   shape[] -> floating.append;
               if);
               (if assign then
                   (THIS(FieldReferenceShape)[], shape[]
                   , HorisontalOrientation, PenDash) 
                     -> connect
                     -> theConnector[];
                else
                   (shape[], THIS(FieldReferenceShape)[]
                   , HorisontalOrientation, PenDash) 
                     -> connect
                     -> theConnector[];
               if);
               shape.refresh;
               'connect-here' -> repaint;
            #);
          FieldButton: IconButton
            (# click:
                 (# 
                 do (0, 0) -> localToGlobal -> connectHere;
                 #);
               onExpand::
                 (#
                 do click;
                 #);
               onCollapse::
                 (#
                 do click;
                 #);
            #);
          init::
            (#
            enter where[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
                  row: ^RowFigure;
                  btn: ^IconButton;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &RowFigure[] -> row[];
                  row.init;
                  true -> row.horizontallyFlexible;
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  where.description -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> row.add;
                  
                  &FieldButton[] -> btn[];
                  (staticRef[] -> createImageFigure, NONE) -> btn.init;
                  6 -> construct.flexHSpace -> row.add;
                  btn[] -> row.add;
                  4 -> construct.hSpace -> row.add;
                  row[] -> add;
               #);
            #)
       #);
     ValueShape: CenterFigure
       (# value: ^Text;
          init::
            (#
            enter value[]
            do (# construct: @Construction;
                  txtFig: ^TextFigure;
               do rectsolidborder[] -> createBackground -> background[];
                  true -> background.horizontallyFlexible;
                  true -> background.verticallyFlexible;
                  background[] -> add;
                  -6 -> inset;
                  2 -> margin;
                  
                  &TextFigure[] -> txtFig[];
                  txtFig.init;
                  value[] -> txtFig.content;
                  res.smallnicestyle[] -> txtFig.style;
                  res.colors.darkerCoolBrown[] -> txtFig.stroke;
                  txtFig[] -> add;
               #);
            #);
       #);
     Lifer: Composite
       (# last:
            (# obj: ^Item;
            do (children.last).elm[] -> obj[];
            exit obj[]
            #);
       #);
     
     ActionShapeList: Sequence(# element:: ActionShape #);
     ActionShape: Composite
       (# offset: @integer;
          createArrow:
            (# lst: ^PointList;
               dash: @boolean;
               head: ^ArrowHead;
               arrow: ^Composite;
            enter (lst[], dash)
            do (# 
               do &Decoration[] -> arrow[];
                  arrow.init;   
                  (# prev: ^Point2d;
                  do lst.scan
                     (# segment: ^Line;
                     do (if prev[] <> NONE then
                            &Line[] -> segment[];
                            segment.init;
                            prev[] -> segment.start[];
                            current[] -> segment.end[];
                            1 -> segment.strokeWidth;
                            res.colors.darkerCoolBrown[] -> segment.stroke[];
                            (if dash then
                                PenDash -> segment.style;
                            if);
                            segment[] -> arrow.add;
                        if);
                        current[] -> prev[];
                     #);
                  #);
                  
                  (# start, end: ^Point2d;
                  do lst.size - 1 -> lst.get -> start[];
                     lst.size -> lst.get -> end[];
                     &ArrowHead[] -> head[];
                     head.init;
                     end[] -> head.to[];
                     start[] -> head.from[];
                     head.refresh;
                     res.colors.darkerCoolBrown[] -> head.stroke[];
                     res.colors.darkerCoolBrown[] -> head.fill[];
                     head[] -> arrow.add;
                  #);
               #);
            exit arrow[]
            #);
          
          refresh:< (# do INNER #);
       #);
     ErrorMessageShape: ActionShape
       (# value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          receiver: ^ObjectShape;
          
          refresh::
            (# anchor: ^Point2d;
               shape: ^StackShape;
            do receiver.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], false) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               offset - (shape.height / 2) -> shape.y;
               shape[] -> add;
            #);
       #);
     StoreValueShape: ActionShape
       (# value: ^Text;
          sender: ^ObjectShape;
          where: ^ObjectReflector.AttributeReflector;
          refresh::
            (# anchor: ^Point2d;
               shape: ^StackShape;
            do sender.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], true) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               offset - (shape.height / 2) -> shape.y;
               shape[] -> add;
            #);
       #);
     PushValueShape: ActionShape
       (# receiver: ^ObjectShape;
          value: ^Text;
          where: ^ObjectReflector.AttributeReflector;
          refresh::
            (# anchor: ^Point2d;
               shape: ^StackShape;
            do receiver.bottomAnchor -> anchor[];
               
               &StackShape[] -> shape[];
               (value.copy, where[], false) -> shape.init;
               
               shape.pack;
               anchor.x - (shape.width / 2) -> shape.x;
               offset - (shape.height / 2) -> shape.y;
               shape[] -> add;
            #);
       #);
     PrepareCallShape: ActionShape
       (# sender: ^ObjectShape;
          receiver: ^ObjectShape;
          
          refresh::
            (# anchor: ^Point2d;
               pts: ^PointList;
               p1: ^Point2d;
               p2: ^Point2d;
               l: ^Line;
               c: ^Oval;
            do sender.bottomAnchor -> anchor[];
               &Point2d[] -> p1[];
               &Point2d[] -> p2[];
               offset -> p1.y;
               offset -> p2.y;
               anchor.x -> p2.x;
               receiver.x -> p1.x;
               
               &Line[] -> l[];
               l.init;
               p1[] -> l.start[];
               p2[] -> l.end[];
               res.colors.darkerCoolBrown[] -> l.stroke[];
               1 -> l.strokewidth;
               PenDash -> l.style;
               l[] -> add;
               &Oval[] -> c[];
               c.init;
               p2.x - 1 -> c.x;
               p2.y - 2 -> c.y;
               5 -> c.width;
               5 -> c.height;
               res.colors.darkerCoolBrown[] -> c.fill[];
               c[] -> add;
            #);
       #);
     SelfMessageShape: ActionShape
       (# sender: ^ObjectShape;
          message: ^ObjectShape;
          pts: ^PointList;
          isReturn: @boolean;
          makeArrow:
            (# lst: ^PointList;
               dash: @boolean;
            enter (lst[], dash)
            do (lst[], dash) -> createArrow -> add;
               (if message[] <> NONE then
                   (# start, end: ^Point2d;
                      mid: ^Point2d;
                   do 1 -> lst.get -> start[];
                      2 -> lst.get -> end[];
                      &Point2d[] -> mid[];
                      (start.x + end.x) / 2 -> mid.x;
                      start.y -> mid.y;
                      mid.x - message.width / 2 -> message.x;
                      mid.y - 10 -> message.y;
                   #);
               if);
               lst[] -> pts[];
            #);
          refresh::
            (# from: ^Point2d;
               to: ^Point2d;
               lower: ^Point2d;
               end: ^Point2d;
               toAnchor: ^Point2d;
               fromAnchor: ^Point2d;
               lst: ^PointList;
               width: @integer;
            do &Point2d[] -> from[];
               &Point2d[] -> to[];
               offset -> from.y;
               offset -> to.y;
               sender.bottomAnchor -> fromAnchor[];
               fromAnchor.x -> from.x;
               (if message[] <> NONE then
                   from.x + message.width + 20 -> to.x;
                else
                   from.x + 60 -> to.x;
               if);
               
               (to.x - from.x) -> width;
               (if width > sender.maximum then
                   width -> sender.maximum;
               if);
               
               &Point2d[] -> lower[];
               to.x -> lower.x;
               to.y + 30 -> lower.y;
               &Point2d[] -> end[];
               from.x -> end.x;
               from.y + 30 -> end.y;
               
               &PointList[] -> lst[];
               lst.init;
               from[] -> lst.append;
               to[] -> lst.append;
               lower[] -> lst.append;
               end[] -> lst.append;
               (lst[], isReturn) -> makeArrow;
            #);
       #);
     MessageShape: ActionShape
       (# sender: ^ObjectShape;
          receiver: ^ObjectShape;
          message: ^ObjectShape;
          part1: ^ObjectShape;
          part2: ^ObjectShape;
          isReturn: @boolean;
          isLastInSuspended: @boolean;
          isPreemptive: @boolean;

          pts: ^PointList;
          
          makeArrow:
            (# lst: ^PointList;
               dash: @boolean;
            enter (lst[], dash)
            do (lst[], dash) -> createArrow -> add;
               (if message[] <> NONE then
                   (# start, end: ^Point2d;
                      mid: ^Point2d;
                   do 1 -> lst.get -> start[];
                      2 -> lst.get -> end[];
                      &Point2d[] -> mid[];
                      (start.x + end.x) / 2 -> mid.x;
                      start.y -> mid.y;
                      mid.x - message.width / 2 -> message.x;
                      mid.y - 10 -> message.y;
                   #);
               if);
               lst[] -> pts[];
            #);
          
          refresh::<
            (# from: ^Point2d;
               to: ^Point2d;
               toAnchor: ^Point2d;
               fromAnchor: ^Point2d;
               lst: ^PointList;
               reverse: @boolean;
               
            do &Point2d[] -> from[];
               &Point2d[] -> to[];
               offset -> from.y;
               offset -> to.y;
               sender.bottomAnchor -> fromAnchor[];
               fromAnchor.x -> from.x;
               receiver.bottomAnchor -> toAnchor[];
               toAnchor.x -> to.x;
               
               to.x < from.x -> reverse;
                              
               (if part1[] <> NONE then
                   (# po: ^PartObjectShape;
                   do &PartObjectShape[] -> po[];
                      po.init;
                      po.pack;
                      part1[] -> po.part[];
                      from.x - (po.width div 2) -> po.x;
                      (if not reverse then
                          po.x + po.width -> from.x;
                       else
                          po.x -> from.x;
                      if);
                      
                      from.y - (po.height div 2) -> po.y;
                      po[] -> add;
                   #);
               if);
               
               (if part2[] <> NONE then
                   (# po: ^PartObjectShape;
                   do &PartObjectShape[] -> po[];
                      po.init;
                      po.pack;
                      part2[] -> po.part[];
                      to.x - (po.width div 2) -> po.x;
                      (if reverse then
                          po.x + po.width -> to.x;
                       else
                          po.x -> to.x;
                      if);
                      
                      to.y - (po.height div 2) -> po.y;
                      po[] -> add;
                   #);
               if);               
               
               (if isLastInSuspended then
                   (# im: ^ImageFigure;
                   do (if isPreemptive then
                          pause[] -> createImageFigure -> im[];
                       else
                          waiting[] -> createImageFigure -> im[];
                      if);
                      im.pack;
                      to.y - 6 -> im.y;
                      
                      (if part2[] <> NONE then
                          (if reverse then
                              to.x -> im.x;
                           else
                              to.x - 12 -> im.x;
                          if);
                       else
                          to.x - 6 -> im.x;
                      if);
                      
                      (if reverse then
                          im.x + 12 -> to.x;
                       else
                          im.x -> to.x;
                      if);
                      im[] -> add;
                   #);
               if);
               
               &PointList[] -> lst[];
               lst.init;
               (if isReturn then
                   to[] -> lst.append;
                   from[] -> lst.append;
                else
                   from[] -> lst.append;
                   to[] -> lst.append;
               if);
               (lst[], isReturn) -> makeArrow;
            #);
       #);
     
     ObjectShape: Shape
       (# invocator: ^Invocation;
          live: ^Composite;
          maximum: @integer;
          expanded: @boolean;
          sticky: @boolean;
          isObject: @boolean;
          isRoot: @boolean;
          isComponent: @boolean;
          executing: @boolean;
          active: @boolean;
          reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          pane: ^RowFigure;
          body: ^ColumnFigure;
          activate:
            (#
            do true -> executing;
               true -> active;
            #);
          deactivate:
            (#
            do false -> active;
            #);
          origin:
            (# result: ^ObjectShape;
            do (if reflect.template.myOrigin <> NONE then
                   reflect.template.myOrigin
                     -> reflection
                     -> objectShapeForTarget
                     -> result[];
               if);
            exit result[]
            #);
          visibleOrigin:
            (# result: ^ObjectShape;
               candidate: ^ObjectShape;
               visible: ^ObjDesc.RunTimeObject;
            do THIS(ObjectShape)[] -> candidate[];
               candidate.reflect.template[]
                 -> visibleOriginOf
                 -> visible[];
               (if visible[] <> NONE then
                   '** skipInternalOf: ' ->puttext; visible.myName -> putline;
                   visible[]
                     -> reflection
                     -> objectShapeForTarget
                     -> result[];
                else
                   candidate[] -> result[];
               if);
            exit result[]
            #);
          selectCode:
            (# current: ^Invocation;
            do (if false then
                   '**** ObjectShape:selectCode:'->putline;
               if);
               
               (if reflect.template.myLscTop > 0 then
                   reflect.template[] -> showCode;
                else
                   (if executing then
                       (if top[] <> NONE then
                           top.selectCode;
                       if);
                    else
                       reflect.template.myObjDesc -> showDescriptor;
                   if);
               if);
            #);
          skipInternal:
	    (# setSkip:
                 (# value: @boolean
                 enter value
                 do (if value then
                        OSDvisibility_SkipInternal -> visibility;
                     else
                        OSDvisibility_Open -> visibility;
                    if);
                 #);
               getSkip:
                 (# value: @boolean;
                 do visibility = OSDvisibility_SkipInternal -> value;
                 exit value
                 #);
            enter setSkip
            exit getSkip
            #);
          disguised:
            (# setDisguised:
                 (# value: @boolean;
                 enter value
                 do (if value then
                        OSDvisibility_Disguised -> visibility;
                     else
                        OSDvisibility_Open -> visibility;
                    if);
                 #);
               getDisguised:
                 (# value: @boolean;
                 do visibility = OSDvisibility_Disguised -> value;
                 exit value
                 #);
            enter setDisguised
            exit getDisguised
            #);
          visibility:
            (# setVisibility:
                 (# value: @integer;
                 enter value
                 do value -> reflect.template.OSDvisibility;
                 #);
               getVisibility:
                 (# value: @integer;
                 do reflect.template.OSDvisibility -> value;
                 exit value
                 #);
            enter setVisibility
            exit getVisibility
            #);
          find:
            (# att: ^ObjectReflector.AttributeReflector;
               shape: ^AttributeShape;
            enter att[]
            do searching: body.scan
                 (# type:: AttributeShape;
                 do (if att[] -> current.target.equal then
                        current[] -> shape[];
                        leave searching;
                    if);
                 #);
            exit shape[]
            #);
          
          init::
            (#
            enter reflect[]
            do (# simples: ^ObjectReflector.AttributeList;
                  space: ^SpaceFigure;
               do &RowFigure[] -> pane[];
                  pane.init;
                  true -> pane.horizontallyFlexible;
                  true -> pane.verticallyFlexible;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  &ColumnFigure[] -> body[];
                  body.init;
                  true -> body.horizontallyFlexible;
                  true -> body.verticallyFlexible;
                  body[] -> pane.add;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  (* 18 -> space.minimumHeight; *)
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  compiler[] -> reflect.collectSimples -> simples[];
                  
                  simples.scan
                  (# row: ^AttributeShape;
                  do &AttributeShape[] -> row[];
                     current[] -> row.init;
                     row[] -> body.add;
                  #);
                  
                  &ObjectFigure[] -> fig[];
                  fig.init;
                  fig[] -> add;
                  pack;
               #);
            #);
          refresh::
            (# where: ^Text;
            enter where[]
            do (if false then
                   rrc + 1 -> rrc;
                   'REFRESH: ' -> puttext;
                   rrc -> putint;
                   ' | ' -> puttext;
                   fig.title.txtFig.content -> puttext;
                   ' <= ' -> puttext;
                   where[] -> puttext;
                   newline;
               if);
               fig.title.refresh;
               body.children.scan
               (# attribute: ^AttributeShape;
               do current[] -> attribute[];
                  attribute.refresh;
               #);
               pack;
            #);
          description:
            (# value: ^Text;
            do reflect.name -> value[];
            exit value[]
            #);
          dismissConnectors:
            (# theConnectors: ^ConnectorList;
            do THIS(ObjectShape)[] -> connected -> theConnectors[];
               (if expanded then
                   body.children.scan
                   (# attribute: ^AttributeShape;
                   do current[] -> attribute[];
                      (if attribute.theConnector[] <> NONE then
                          attribute.theConnector[] -> theConnectors.append;
                      if);
                   #);
               if);
               theConnectors.scan
               (#
               do current.dismiss;
                  NONE -> current.destination[];
               #);
            #);
          pack:
            (#
            do fig.configure;
               fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          makeSticky:
            (#
            do true -> sticky;
               'make-sticky' -> repaint;
            #);
          dismiss:
            (#
            do dismissConnectors;
               (if THIS(ObjectShape)[] -> floating.has then
                   THIS(ObjectShape)[] -> floating.delete;
                   THIS(ObjectShape)[] -> THIS(SequenceDiagram).remove;
               if);
               false -> sticky;
               THIS(ObjectShape).refresh;
               'dismiss' -> THIS(SequenceDiagram).refresh;
            #);
          layoutLiveObject:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> x;
               dy - 10 -> y; 
               (# top: ^Point2d;
                  p: ^Point2d;
                  bottom: ^Point2d;
                  l: ^LifeLine;
                  mkPoint2d:
                    (# x,y: @integer; p: ^Point2d
                    enter(x,y)
                    do &Point2d[] -> p[];
                       x -> p.x;
                       y -> p.y
                    exit p[]
                    #);
                  mkLifeLine:
                    (# ps,pe: ^Point2d; l: ^LifeLine
                    enter(ps[],pe[])
                    do &LifeLine[] -> l[];
                       l.init;
                       ps[] -> l.start[];
                       pe[] -> l.end[];
                       res.colors.darkerCoolBrown[] -> l.stroke[];
                    exit l[]
                    #)
               do &Lifer[] -> live[];
                  live.init;
                  bottomAnchor -> top[];
                  top.copy -> p[];
                  (if offset < 0 then
                      (# delta: (# exit 3 #);
                         p0: ^Point2d;
                         p1: ^Point2d;
                         p2: ^Point2d;
                         p3: ^Point2d;
                         p4: ^Point2d;
                         p5: ^Point2d;
                      do p.y + 5 * delta -> p.y;                         
                         top.copy -> p0[];
                         (p0.x + delta,p0.y + delta) -> mkPoint2d -> p1[];
                         (p0.x - delta,p1.y + delta) -> mkPoint2d -> p2[];
                         (p0.x + delta,p2.y + delta) -> mkPoint2d -> p3[];
                         (p0.x - delta,p3.y + delta) -> mkPoint2d -> p4[];
                         (p0.x        ,p4.y + delta) -> mkPoint2d -> p5[];
                         (p0[],p1[]) -> mkLifeLine -> live.add;
                         (p1[],p2[]) -> mkLifeLine -> live.add;
                         (p2[],p3[]) -> mkLifeLine -> live.add;
                         (p3[],p4[]) -> mkLifeLine -> live.add;
                         (p4[],p5[]) -> mkLifeLine -> live.add;
                      #);
                  if);
                  (top.x,600) -> mkPoint2d -> bottom[];
                  (p[],bottom[]) -> mkLifeLine -> l[];
                  1 -> l.strokewidth;                  
                  l[] -> live.add;
               #);
               THIS(ObjectShape).width -> THIS(ObjectShape).maximum;
            #);
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y + height -> p.y;
               x + width / 2 -> p.x;
            exit p[]
            #);
          topAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y -> p.y;
               x + width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               y + 10 -> p.y;
               x -> p.x;
            exit p[]
            #);
          right:
            (# value: @integer;
            do (if maximum > width then
                   x + maximum -> value;
                else
                   x + width -> value;
               if);
            exit value
            #);
          hasMenu::
            (#
            do true -> yes;
            #);
          getMenu::
            (#
            do &ObjectMenu[] -> theMenu[];
               theMenu.open;
            #);
           finishMenu::
            (#
            do theMenu.close;
            #);
          ObjectMenu: Menu
            (# dismissItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do dismiss;
                           #);
                      #);
                    open::
                      (#
                      do 'Dismiss' -> name;
                      #);
                 #);
               makeStickyItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do makeSticky;
                           #);
                      #);
                    open::
                      (#
                      do 'Make Sticky' -> name;
                      #);
                 #);
               showCodeItem: @menuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do selectCode;
                           #);
                      #);
                    open::
                      (#
                      do 'Show Code' -> name;
                      #);
                 #);
               visibilityItem: @MenuItem
                 (#
                    choises: @Menu
                      (# showAllItem: @MenuItem
                           (# open::
                                (#
                                do 'Show All' -> name;
                                #);
                              eventHandler::
                                (# onSelect::
                                     (#
                                     do OSDvisibility_Open -> visibility;
                                        THIS(ObjectShape).refresh;
                                        'choices' -> presentSequenceDiagram;
                                     #);
                                #);
                           #);
                         skipInternalItem: @MenuItem
                           (# open::
                                (#
                                do 'Skip Internal' -> name;
                                #);
                               eventHandler::
                                (# onSelect::
                                     (#
                                     do OSDvisibility_SkipInternal
                                          -> visibility;
                                        THIS(ObjectShape).refresh;
                                        'skip-internal' 
                                          -> presentSequenceDiagram;
                                     #);
                                #);
                           #);
                         skipAllItem: @MenuItem
                           (# open::
                                (#
                                do 'Skip All' -> name;
                                #);
                              eventHandler::
                                (# onSelect::
                                     (#
                                     do OSDvisibility_Disguised -> visibility;
                                        THIS(ObjectShape).refresh;
                                        'skip-all' -> repaint;
                                     #);
                                #);
                           #);
                         open::
                           (#
                           do showAllItem.open;
                              showAllItem[] -> append;
                              skipInternalItem.open;
                              skipInternalItem[] -> append;
                              skipAllItem.open;
                              skipAllItem[] -> append;
                           #);
                      #);
                    open::
                      (#
                      do 'Visibility' -> name;
                         choises.open;
                         choises[] -> subMenu;
                      #);
                 #);
               open::
                 (#
                 do dismissItem.open;
                    dismissItem[] -> append;
                    makeStickyItem.open;
                    makeStickyItem[] -> append;
                    visibilityItem.open;
                    visibilityItem[] -> append;
                    showCodeItem.open;
                    showCodeItem[] -> append;
                 #);
            #);
          ObjectFigure: AdornFigure
            (# outline: ^ColumnFigure;
               title: ^TitleFigure;
               
               CollapseButton: Toggler
                 (# onCollapse::
                      (#
                      do false -> invocator.isCollapsed;
                         'collapse' -> presentSequenceDiagram;
                      #);
                    onExpand::
                      (#
                      do true -> invocator.isCollapsed;
                         'collapse' -> presentSequenceDiagram;
                      #);
                 #);
               
               TitleFigure: RowFigure
                 (# txtFig: ^TextFigure;
                    deco1: ^CenterFigure;
                    deco2: ^CenterFigure;
                    deco3: ^CenterFigure;
                    refresh:
                      (#
                      do (if skipInternal then
                             res.colors.skip[] -> txtFig.stroke;
                          else
                             (if disguised then
                                 res.colors.disguised[] -> txtFig.stroke;
                              else
                                 res.colors.darkerCoolBrown[] -> txtFig.stroke;
                             if);
                         if);
                         deco2.clear;
                         (if isComponent then
                             res.green[] 
                               -> createCircle 
                               -> deco2.add;
                         if);
                         deco1.clear;
                         (if executing then
                             (if active then
                                 cogwheel[]
                                   -> createImageFigure
                                   -> deco1.add;
                                 2 -> deco1.margin;
                              else
                                 cogwheelgray[]
                                   -> createImageFigure
                                   -> deco1.add;
                                 2 -> deco1.margin;
                             if);
                             (if isRoot then
                                 (# mn: ^ImageFigure;
                                    mh: ^ImageFigure;
                                    pn: ^ImageFigure;
                                    ph: ^ImageFigure;
                                    btn: ^Toggler;
                                 do minus[] -> createImageFigure -> mn[];
                                    minus_hilite[] -> createImageFigure -> mh[];
                                    plus[] -> createImageFigure -> pn[];
                                    plus_hilite[] -> createImageFigure -> ph[];
                                    &CollapseButton[] -> btn[];
                                    (pn[], ph[], mn[], mh[]) -> btn.init;
                                    invocator.isCollapsed -> btn.on;
                                    btn.refresh;
                                    btn[] -> deco3.add;
                                    2 -> deco3.margin;
                                 #);
                              else
                                 deco3.clear;
                             if);
                         if);
                         
                      #);
                    ExpansionButton: Toggler
                      (# onExpand::
                           (#
                           do true -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeShape;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     attribute[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              'expansion' -> presentSequenceDiagram;
                              refreshConnectors;
                           #);
                         onCollapse::
                           (#
                           do false -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeShape;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     THIS(ObjectShape)[] 
                                       -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              'collapsion' -> presentSequenceDiagram;
                              refreshConnectors;
                           #);
                      #);
                    
                    oriBtn: ^ExpansionButton;
                    
                    init::
                      (# construct: @Construction;
                      do true -> horizontallyFlexible;
                         (* 18 -> baseMinimumHeight; *)
                         2 -> construct.hSpace -> add;
                         &ExpansionButton[] -> oriBtn[];
                         (res.black[], res.black[]) 
                           -> CreateToggler -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &CenterFigure[] -> deco1[];
                         deco1.init;
                         deco1[] -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                         res.heading[] -> txtFig.style;
                         res.colors.darkerCoolBrown[] -> txtFig.stroke;
                         txtFig[] -> add;
                         &CenterFigure[] -> deco2[];
                         deco2.init;
                         deco2[] -> add;
                         4 -> construct.flexHSpace -> add;
                         &CenterFigure[] -> deco3[];
                         deco3.init;
                         deco3[] -> add;
                         2 -> construct.flexHSpace -> add;
                      #);
                 #);
               configure:
                 (# ruler: ^RulerFigure;
                    construct: @Construction;
                 do (* 18 -> baseMinimumHeight; *)
                    outline.clear;
                    title[] -> outline.add;
                    (if expanded then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.colors.darkerCoolBrown[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        8 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        pane[] -> outline.add; 
                       
                    if);
                 #);
               init::
                 (# center: ^CenterFigure;
                    background: ^Figure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                                        
                    (if SOLID then
                        solidborder[] -> createBackground -> background[];
                     else
                        placard[] -> createBackground -> background[];
                    if);
                    
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    
                    background[] -> center.add;
                    background[] -> center.background[];
                    -6 -> center.inset;
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    configure;
                 #);
            #);
          
          AttributeShape: RowFigure
            (# target: ^ObjectReflector.AttributeReflector;
               theConnector: ^Connector;
               valueFig: ^TextFigure;
               referenceBtn: ^ReferenceButton;
               codeBtn: ^IconButton;
               break: ^BreakPoint;
               deco1: ^CenterFigure;
               
               toggleBreak:
                 (# (* This code is apparently not used - has been commented out
                     * in order to eliminate dependenceies of miniCompiler
                     * 
                     * nameDcl: ^p arser.NameDecl;
                     * nameDcls: ^p arser.;
                     * dcl: ^p arser.Decl;
                     * desc: ^p arser.ObjectDesc;
                     *)
                 do '\n!!! OBS! We did come here: Toggle-break: ' -> putline;
                    target.dcl.doPT -> putline;
                    (*target.dcl[] -> nameDcl[];
                     * nameDcl.father[] -> nameDcls[];
                     * nameDcls.father[] -> dcl[];
                     * (if dcl.IT[] <> NONE then
                     *     (if break[] <> NONE then
                     *         break[] -> breaks.delete;
                     *         NONE -> break[];
                     *       else
                     *          dcl.IT.desc -> desc[];
                     *          (reflect.template[], desc[]) 
                     *           -> &BreakPoint -> break[];
                     *           break[] -> breaks.append;
                     *      if);
                     *       THIS(ObjectShape).refresh;
                     *       'toggle-break' -> repaint;
                     * if);
                     *)
                 #);
               
               AttributeMenu: Menu
                 (# breakItem: @MenuItem
                      (# eventHandler::
                           (# onSelect::
                                (# 
                                do toggleBreak;
                                #);
                           #);
                         open::
                           (#
                           do 'Break' -> name;
                           #);
                      #);
                    open::
                      (#
                      do 'Open:breakItem'->putline;
                         breakItem.open;
                         breakItem[] -> append;
                      #);
                 #);
               showMenu:
                 (# x, y: @integer;
                 enter (x, y)
                 do (# menu: @AttributeMenu;
                    do menu.open;
                       (1, (x, y), THIS(FigureCanvas)[]) -> menu.popup;
                       menu.close;
                    #);
                 #);
               Chooser: Behaviour
                 (# onMouseDown::
                      (# 
                      do (if codeBtn[] <> NONE then
                             toggleBreak;
                         if);
                      #);
                 #);
               
               refresh:
                 (# old: ^Text;
                    new: ^Text;
                 do valueFig.content -> old[];
                    target.textValue -> new[];
                    new[] -> valueFig.content;
                    (if updateflag then
                        (if not (new[] -> old.equal) then
                            res.red[] -> valueFig.stroke;
                         else
                            res.colors.darkerCoolBrown[] -> valueFig.stroke;
                        if);
                    if);
                    deco1.clear;
                    (if break[] <> NONE then
                        2 -> deco1.margin;
                        res.red[] 
                          -> createCircle 
                          -> deco1.add;
                    if);
                    
                    (if referenceBtn[] <> NONE then
                        referenceBtn.clear;
                        (if theConnector[] <> NONE then
                            (if theConnector.destination[] <> NONE then
                                res.green[] -> createCircle -> referenceBtn.add;
                             else
                                NONE -> theConnector[];
                                staticRef[] 
                                  -> createImageFigure -> referenceBtn.add;
                            if);
                         else
                            staticRef[] 
                              -> createImageFigure -> referenceBtn.add;
                        if);
                    if);
                    &Chooser[] -> theBehaviour[];
                 #);
               
               connectHere:
                 (# other: ^ObjDesc.RunTimeObject;
                    shape: ^ObjectShape;
                    x, y: @integer;
                 enter (x, y)
                 do (if theConnector[] = NONE then
                        target.reference -> other[];
                        (if other[] <> NONE then
                            other[] -> reflection
                              -> objectShapeForTarget
                              -> shape[];
                            (if shape.father[] = NONE then
                                x + 60 -> shape.x;
                                y -> shape.y;
                                &shape.Drag[] -> shape.fig.theBehaviour[];
                                shape[] -> THIS(SequenceDiagram).add;
                                shape[] -> floating.append;
                            if);
                            (THIS(AttributeShape)[]
                            , shape[], HorisontalOrientation, PenSmooth) 
                              -> connect
                              -> theConnector[];
                            true -> shape.sticky;
                            shape.refresh;
                            'connect-here' -> repaint;
                        if);
                    if);
                 #);
               disconnect:
                 (#
                 do (if theConnector[] <> NONE then
                        (if theConnector.destination[] <> NONE then
                            theConnector.dismiss;
                            NONE -> theConnector.destination[];
                        if);
                        NONE -> theConnector[];
                    if);
                 #);
               
               CodeButton: IconButton
                 (# click:
                      (#
                      do target.dcl[] -> showNode;
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               ReferenceButton: IconButton
                 (# click:
                      (#
                      do (if theConnector[] = NONE then
                             (0, 0) -> localToGlobal -> connectHere;
                          else
                             disconnect;
                         if);
                         THIS(ObjectShape).refresh;
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               init::
                 (#
                 enter target[]
                 do (# txtFig: ^TextFigure;
                       
                       icon: ^RichPixmap;
                       construct: @Construction;
                       iconBtn: ^IconButton;
                       
                       btn: ^Figure;
                       fig: ^Figure;
                    do true -> horizontallyFlexible;
                       16 -> baseMinimumHeight;
                       &TextFigure[] -> txtFig[];
                       txtFig.init;
                       target.name -> txtFig.content;
                       res.smallstyle[] -> txtFig.style;
                       res.colors.darkerCoolBrown[] -> txtFig.stroke;
                       txtFig[] -> add;
                       &CenterFigure[] -> deco1[];
                       deco1.init;
                       deco1[] -> add;
                       24 -> construct.flexHSpace -> add;
                       &TextFigure[] -> valueFig[];
                       valueFig.init;
                       target.textValue -> valueFig.content;
                       res.smallnicestyle[] -> valueFig.style;
                       res.colors.darkerCoolBrown[] -> valueFig.stroke;
                       valueFig[] -> add;
                       8 -> construct.hSpace -> add;
                       (if target.kind 
                        // compiler.SimpleKind then
                           simple[] -> createImageFigure -> btn[];
                        // compiler.ReferenceKind then
                           &ReferenceButton[] -> iconBtn[] -> referenceBtn[];;
                           (staticRef[] -> createImageFigure, NONE) 
                             -> iconBtn.init;
                           iconBtn[] -> btn[];
                        // compiler.PatternKind then
                           pattern[] -> createImageFigure -> fig[];
                        // compiler.VirtualKind then
                           virtual[] -> createImageFigure -> fig[];
                        // compiler.RepetionKind then
                           array[] -> createImageFigure -> btn[];
                       if);
                       (if fig[] <> NONE then
                           &CodeButton[] -> codeBtn[] -> btn[];
                           (fig[], NONE) -> codeBtn.init;
                       if);
                       btn[] -> add;
                    #)
                 #);
            #);
       #);
     LifeLine: Line(# #);
    
     init::
       (# 
       do 0 -> offset;
          res.init;
          'thinborder3\\thinborder3' -> loadTileSet -> placard[];
          'solidborder\\solidborder' -> loadTileSet -> solidborder[];
          'rectsolidborder\\rectsolidborder' 
            -> loadTileSet -> rectsolidborder[];
          'icons\\virtual.png' -> loadImage -> virtual[];
          'icons\\lightref.png' -> loadImage -> dynamicRef[];
          'icons\\reference.png' -> loadImage -> staticRef[];
          'icons\\array.png' -> loadImage -> array[];
          'icons\\pattern.png' -> loadImage -> pattern[];
          'icons\\simple.png' -> loadImage -> simple[];
          
          'icons\\colon.png' -> loadImage -> colon[];
          'icons\\equal.png' -> loadImage -> equal[];
          'icons\\up.png' -> loadImage -> up[];
          'icons\\cog.png' -> loadImage -> cogwheel[];
          'icons\\coggray.png' -> loadImage -> cogwheelgray[];
          
          'icons\\plus.png' -> loadImage -> plus[];
          'icons\\plus-hilite.png' -> loadImage -> plus_hilite[];
          'icons\\minus.png' -> loadImage -> minus[];
          'icons\\minus-hilite.png' -> loadImage -> minus_hilite[];
          'icons\\pause.png' -> loadImage -> pause[];
          'icons\\waiting.png' -> loadImage -> waiting[];
          
          lines.init;
          lines[] -> add;
          nodes.init;
          nodes[] -> add;
          
          holder.init;
          4 -> holder.margin;
          
          &RectFigure[] -> background[];
          background.init;
          res.colors.paleCoolBrown[] -> background.fill;
          true -> background.horizontallyFlexible;
          true -> background.verticallyFlexible;
          background[] -> holder.add;
          background[] -> holder.background[];
          7 -> x;
          7 -> y;
       #);
     showCode:<
       (# caller: ^objDesc.RunTimeObject;
       enter caller[]
       do INNER;
       #);
     showDescriptor:<
       (# desc: ^ObjDesc;
       enter desc[]
       do INNER;
       #);
     showNode:<
       (# node: ^Tree.TopNode;
       enter node[]
       do INNER;
       #);
     showContext:< (# do INNER #);
     showCurrent:< (# do INNER #);
  #);



