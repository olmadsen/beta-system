ORIGIN '~beta/postwimp/demo/chaos/diagram';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/demo/chaos/widgets';
INCLUDE '../miniCompiler/generator';

-- lib: attributes --


Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);
SimpleKind:
  (# exit 1 #);
PatternKind:
  (# exit 2 #);
ReferenceKind:
  (# exit 3 #);
RepetionKind:
  (# exit 4 #);

ObjectReflector:
  (# template: ^ObjDesc.Template;
     struct: ^Pattern;
     init:
       (# theTemplate: ^ObjDesc.Template;
       enter theTemplate[]
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
     descriptionOf:
       (# template: ^ObjDesc.Template;
          description: ^Text;
       enter template[]
       do (# name: ^Text;
             ch: @char;
          do template.myName -> name[];
             (if name.length < 0 then
                 1 -> name.inxGet -> ch;
                 (if ch//'a'//'A'//'e'//'E'//'i'//'I'//'o'//'O'//'u'//'U' then
                     'an ' -> description[];
                  else
                     'a ' -> description[];
                 if);
                 name[] -> description.append;
             if);
          #);
       exit description[]
       #);
     collectSimples:
       (# compile: ^generator;
          simples: ^AttributeList;
       enter compile[]
       do (# descNo: @integer;
             theObjectDesc: ^generator.ObjectDesc;
             isRef: @boolean;
             off: @integer;
          do &AttributeList[] -> simples[];
             template.myDescInx -> descNo;
             descNo -> compile.newDesc.getOD -> theObjectDesc[];
             theObjectDesc.scanAllDecls
             (# name: ^Text;
                simple: ^AttributeReflector;
                kind: @integer;
                offset: @integer;
             do (currentND.lexemSy).copy -> name[];
                currentND.off -> off;
                
                (if off > 0 then 
                    off -> offset;
                    (if currentDcl.IT.isSimple then
                        SimpleKind -> kind;
                     else
                        ReferenceKind -> kind;
                    if)            
                 else
                    (if currentDcl.IT.isIndexed then
                        RepetionKind -> kind;
                        offset + 1 -> off;
                     else
                        PatternKind -> kind;
                    if);
                if);
                &AttributeReflector[] -> simple[];
                (name[], off, kind) -> simple.init;
                simple[] -> simples.append;
             #);
          #);
       exit simples[]
       #);
     
     AttributeList: List
       (# Element:: AttributeReflector;
       #);
    

     AttributeReflector:
       (# theName: ^Text;
          offset: @integer;
          kind: @integer;
          init:
            (#
            enter (theName[], offset, kind)
            do 
            #);
          name:
            (#
            do 
            exit theName[]
            #);
          reference:
            (# other: ^ObjDesc.Template;
            do (if (kind = ReferenceKind) and (offset > 0) then
                   template.rfields[offset][] -> other[];
               if);
            exit other[]
            #);
          description:
            (# theDescription: ^Text;
            do (# obj: ^ObjDesc.Template;
               do '' -> theDescription[];
                  (if offset > 0 then
                      (if kind
                       //SimpleKind then
                          offset -> template.get -> theDescription.putint;
                       //RepetionKind then
                          (# n: @integer;
                          do offset -> template.get -> n;
                             (if n > 32 then
                                 32 -> n;
                             if);
                             (for i: n repeat
                                  offset + i -> template.get -> theDescription.put;
                             for);
                          #);
                       //ReferenceKind then
                          template.rfields[offset][] -> obj[];
                          (if obj[] = none then
                              'none' -> theDescription.putText;
                           else
                              (# name: ^Text;
                              do 
                                 obj.myName -> name[];
                                 (if name[] <> NONE then
                                     name[] -> theDescription.putText;
                                  else 
                                     '   ' -> theDescription.putText;
                                 if);
                              #);
                          if);
                      if)            
                   else (* pattern *)
                      '  ' -> theDescription.puttext;
                  if);
               #);
            exit theDescription[]
            #);
               
       #);
  #);


-- FigureCanvasLib: attributes --

SequenceDiagram: Diagram
  (# lines: @Composite;
     nodes: @Composite;
     floating: @Sequence
       (# Element:: ObjectShape;
       #);
     visibles: @Sequence
       (# Element:: ObjectShape;
       #);
     compile: ^generator;
     LOGGING: (# exit false #);
     res: @Resource;
     x, y: @integer;
     doKeepHistory: @boolean;
     placard: ^TileSet;
     colon: ^RichPixmap;
     equal: ^RichPixmap;
     up: ^RichPixmap;
     
     updateflag: @boolean;
     
     TileSet:
       (# topleft: ^RichPixmap;
          top: ^RichPixmap;
          topright: ^RichPixmap;
          left: ^RichPixmap;
          middle: ^RichPixmap;
          right: ^RichPixmap;
          bottomleft: ^RichPixmap;
          bottom: ^RichPixmap;
          bottomright: ^RichPixmap;
          
          load:
            (# name: ^Text;
            enter name[]
            do '-topleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topleft[];
               '-top.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> top[];
               '-topright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topright[];
               '-left.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> left[];
               '-middle.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> middle[];
               '-right.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> right[];
               '-bottomleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomleft[];
               '-bottom.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottom[];
               '-bottomright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomright[];
            #);
       #);
     
     loadImage:
       (# name: ^Text;
          image: ^RichPixmap;
       enter name[]
       do (# path: ^Text;
          do &RichPixmap[] -> image[];
             'c:\\beta\\r5.5\\postwimp\\images\\' -> path[];
             name[] -> path.append;
             path[] -> image.readAlpha;
             false -> image.transparent;
          #);
       exit image[]
       #);
     loadTileSet:
       (# name: ^Text;
          tiles: ^TileSet;
       enter name[]
       do &TileSet[] -> tiles[];
          name[] -> tiles.load;
       exit tiles[]
       #);
     
     createImageFigure:
       (# image: ^RichPixmap;
          item: ^ImageFigure;
       enter image[]
       do &ImageFigure[] -> item[];
          item.init;
          image[] -> item.content;
       exit item[]
       #);
     
     createBackground:
       (# tiles: ^TileSet;
          background: ^ColumnFigure;
       enter tiles[]
       do &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             topleft: ^ImageFigure;
             top: ^ImageFigure;
             topright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.topleft[]
               -> createImageFigure 
               -> topleft[];
             false -> topleft.horizontallyFlexible;
             false -> topleft.verticallyFlexible;
             topleft[] -> row.add;
             
             tiles.top[]
               -> createImageFigure 
               -> top[];
             true -> top.horizontallyFlexible;
             false -> top.verticallyFlexible;
             top[] -> row.add;
             
             tiles.topright[]
               -> createImageFigure 
               -> topright[];
             false -> topright.horizontallyFlexible;
             false -> topright.verticallyFlexible;
             topright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          (# row: ^RowFigure;
             left: ^ImageFigure;
             middle: ^ImageFigure;
             right: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.left[]
               -> createImageFigure 
               -> left[];
             false -> left.horizontallyFlexible;
             true -> left.verticallyFlexible;
             left[] -> row.add;
             
             tiles.middle[]
               -> createImageFigure 
               -> middle[];
             true -> middle.horizontallyFlexible;
             true -> middle.verticallyFlexible;
             middle[] -> row.add;
             
             tiles.right[]
               -> createImageFigure 
               -> right[];
             false -> right.horizontallyFlexible;
             true -> right.verticallyFlexible;
             right[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
             true -> row.verticallyFlexible;
          #);
          (# row: ^RowFigure;
             bottomleft: ^ImageFigure;
             bottom: ^ImageFigure;
             bottomright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.bottomleft[]
               -> createImageFigure 
               -> bottomleft[];
             false -> bottomleft.horizontallyFlexible;
             false -> bottomleft.verticallyFlexible;
             bottomleft[] -> row.add;
             
             tiles.bottom[]
               -> createImageFigure 
               -> bottom[];
             true -> bottom.horizontallyFlexible;
             false -> bottom.verticallyFlexible;
             bottom[] -> row.add;
             
             tiles.bottomright[]
               -> createImageFigure 
               -> bottomright[];
             false -> bottomright.horizontallyFlexible;
             false -> bottomright.verticallyFlexible;
             bottomright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          background.pack;
       exit background[]
       #);
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.Template;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter template[]
       do (#
          do template[] -> objectReflectors.lookupByTemplate -> reflect[];
             (if reflect[] = NONE then
                 &ObjectReflector[] -> reflect[];
                 template[] -> reflect.init;
                 reflect[] -> objectReflectors.append;
             if);
          #);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          
          x + 200 -> x;
       #);
     
     clearHistory:
       (# current: ^Invocation;
       do start[] -> current[];
          clearing:
            (if current[] <> NONE then
                current.history.clear;
                current.active[] -> current[];
                restart clearing;
            if);
          presentSequenceDiagram;
       #);
     presentSequenceDiagram:
       (#
       do (# mark: @List;
             x: @integer;
             y: @integer;
             header: @integer;
             prepareOne:
               (# inv: ^Invocation;
               enter inv[]
               do inv.receiver.target.refresh;
                  (if inv.action[] <> NONE then
                      inv.action.refresh;
                  if);
                  (if not inv.allocation then
                      (if inv.receiver.target.height > header then
                          inv.receiver.target.height -> header;
                      if);
                  if);
               #);
             prepare:
               (# inv: ^Invocation;
               enter inv[]
               do inv[] -> prepareOne;
                  inv.scan
                  (#
                  do current[] -> prepare;
                  #);
               #);
             processOne:
               (# inv: ^Invocation;
                  dy: @integer;
                  addNode:
                    (# node: ^ObjectShape;
                    enter node[]
                    do node[] -> touched.append;
                       (if not (node[] -> visibles.has) then
                           
                           (if node.father[] <> NONE then
                               node[] -> THIS(SequenceDiagram).remove;
                               node[] -> floating.delete;
                           if);
                           node[] -> nodes.add;
                           NONE -> node.fig.theBehaviour[];
                           node[] -> visibles.append;
                       if);
                    #);
                  back: @boolean;
               enter (inv[], back)
               do 24 -> dy;
                  (if not (inv.receiver[] -> mark.has) then
                      inv.receiver[] -> mark.append;
                      (# dx: @integer;
                         a: ^Point2d;
                      do (if inv.sender[] <> NONE then
                             inv.sender.bottomAnchor -> a[];
                             ((x + inv.receiver.target.width / 2) - a.x) - 20 -> dx;
                             (if inv.action[] <> NONE then
                                 (if dx < inv.action.width then
                                     dx - inv.action.width -> dx;
                                     x - dx -> x;
                                 if);
                             if);
                         if);
                      #);
                      
                      (if inv.allocation then
                          (x, y) -> inv.receiver.layout;
                          inv.receiver.target.height -> dy;
                       else
                          (x, 24) -> inv.receiver.layout;
                      if);
                      x + inv.receiver.target.width + 7 -> x;
                      inv.receiver.target[] -> addNode;
                      inv.receiver.live[] -> lines.add;
                  if);
                  y -> inv.layout;
                  (if inv.action[] <> NONE then
                      (if inv.action.height > dy then
                          inv.action.height -> dy;
                      if);
                  if);
                  
                  (if back then
                      inv.swap;
                  if);
                  inv.arrow[] -> lines.add;
                  (if not back then
                      (if inv.action[] <> NONE then
                          inv.action[] -> addNode;
                      if);
                  if);
                  y + dy -> y;
               #);
             process:
               (# inv: ^Invocation;
               enter inv[]
               do (inv[], false) -> processOne;
                  inv.scan
                  (#
                  do current[] -> process;
                  #);
               #);
             touched: @Sequence
               (# Element:: ObjectShape;
               #);
             deletion: @Sequence
               (# Element:: ObjectShape;
               #);
          do lines.clear;
             24 -> x;
             start[] -> prepare;
             (if return[] <> NONE then
                 return[] -> prepareOne;
             if);
             header + 24 -> y;
             start[] -> process;
             (if return[] <> NONE then
                 (return[], true) -> processOne;
             if);
             visibles.scan
             (# shape: ^ObjectShape;
             do (if not (current[] -> touched.has) then
                    current[] -> deletion.append;
                 else
                    current[] -> shape[];
                if);
             #);
             deletion.scan
             (#
             do current.close;
                current[] -> nodes.remove;
                current[] -> visibles.delete;
             #);
             update;
          #);
       #);
     
     liveObjects: @List
       (# Element:: LiveObject;
          lookupByShape:
            (# target: ^ObjectShape;
               live: ^LiveObject;
            enter target[]
            do search: scan
                 (#
                 do (if current.target[] = target[] then
                        current[] -> live[];
                        leave search;
                    if);
                 #);
            exit live[]
            #);
       #);
     liveObjectForObjectShape:
       (# target: ^ObjectShape;
          live: ^LiveObject;
       enter target[]
       do target[] -> liveObjects.lookupByShape -> live[];
          (if live[] = NONE then
              &LiveObject[] -> live[];
              target[] -> live.init;
              live[] -> liveObjects.append;
          if);
       exit live[]
       #);
     LiveObject:
       (# target: ^ObjectShape;
          live: ^Line;
          
          layout:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> target.x;
               dy - 10 -> target.y;
               (# top: ^Point2d;
                  bottom: ^Point2d;
               do bottomAnchor -> top[];
                  &Point2d[] -> bottom[];
                  top.x -> bottom.x;
                  600 -> bottom.y;
                  &Line[] -> live[];
                  live.init;
                  top[] -> live.start[];
                  bottom[] -> live.end[];
                  res.black[] -> live.stroke[];
                  1 -> live.strokewidth;
               #);
            #);
          
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + target.height -> p.y;
               target.x + target.width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + 10 -> p.y;
               target.x -> p.x;
            exit p[]
            #);
          init:
            (#
            enter target[]
            do 
            #);
          template:
            (# result: ^ObjDesc.template;
            do target.reflect.template[] -> result[];
            exit result[]
            #);
          
          description:
            (# string: ^Text;
            do target.reflect.name -> string[];
            exit string[]
            #);
       #);
     Invocation:
       (# sender: ^LiveObject;
          receiver: ^LiveObject;
          caller: ^ObjDesc.Template;
          action: ^ObjectShape;
          allocation: @boolean;
          
          history: @List
            (# Element:: Invocation;
            #);
          active: ^Invocation;
          return: ^Invocation;
          
          arrow: ^Composite;
          arrowLine: ^Line;
          head: ^ArrowHead;
          
          scan:
            (# current: ^Invocation;
            do history.scan
               (#
               do current[] -> THIS(scan).current[];
                  INNER scan;
               #);
               (if active[] <> NONE then
                   active[] -> current[];
                   INNER scan;
               if);
            #);
          swap:
            (# from, to: ^Point2d;
            do arrowLine.start[] -> from[];
               arrowLine.end[] -> to[];
               (to[], from[]) -> computeArrowHead;
               PenDash -> arrowLine.style;
            #);
          computeArrowHead:
            (# from, to: ^Point2d;
            enter (from[], to[])
            do (# mid: ^Point2d;
               do &Composite[] -> arrow[];
                  arrow.init;
                  &Line[] -> arrowLine[];
                  arrowLine.init;
                  from[] -> arrowLine.start[];
                  to[] -> arrowLine.end[];
                  1 -> arrowLine.strokewidth;
                  res.black[] -> arrowLine.stroke[];
                  arrowLine[] -> arrow.add;
                  
                  &ArrowHead[] -> head[];
                  head.init;
                  to[] -> head.to[];
                  from[] -> head.from[];
                  head.refresh;
                  
                  res.black[] -> head.stroke[];
                  res.black[] -> head.fill[];
                  head[] -> arrow.add;
                  
                  (if action[] <> NONE then
                      &Point2d[] -> mid[];
                      (from.x + to.x) / 2 -> mid.x;
                      from.y -> mid.y;
                      
                      mid.x - action.width / 2 -> action.x;
                      mid.y - 10 -> action.y;
                  if);
               #);
            #);
          layout:
            (# offset: @integer;
            enter offset
            do (# from: ^Point2d;
                  to: ^Point2d;
                  toAnchor: ^Point2d;
                  fromAnchor: ^Point2d;
                  
                  
               do &Point2d[] -> from[];
                  &Point2d[] -> to[];
                  offset -> from.y;
                  offset -> to.y;
                  (if allocation then
                      receiver.leftAnchor -> toAnchor[];
                   else
                      receiver.bottomAnchor -> toAnchor[];
                  if);
                  toAnchor.x -> to.x;
                  
                  (if sender[] <> NONE then
                      sender.bottomAnchor -> fromAnchor[];
                      fromAnchor.x -> from.x;
                  if);
                  (from[], to[]) -> computeArrowHead;
               #);
            #);
          
          match:
            (# caller: ^ObjDesc.Template;
               self: ^ObjDesc.Template;
               origin: ^ObjDesc.Template;
               result: @boolean;
            enter (caller[], self[], origin[])
            do (if allocation then
                   (caller[] = THIS(Invocation).caller[])
                   AND 
                   (self[] = receiver.template) 
                     -> result;
                else
                   (caller[] = THIS(Invocation).caller[])
                   AND
                   (origin[] = receiver.template)
                   AND
                   (self[] = action.reflect.template[])
                     -> result;
               if);
            exit result
            #);
          description:
            (# string: ^Text;
            do '[' -> string[];
               (if sender[] <> NONE then
                   sender.description -> string.puttext;
                   ' ' -> string.puttext;
                   (if action[] <> NONE then
                       action.reflect.name -> string.puttext;
                       ' ' -> string.puttext;
                    else
                       'allocate ' -> string.puttext;
                   if);
                else
                   'start ' -> string.puttext;
               if);
               
               (if receiver[] <> NONE then
                   receiver.description -> string.puttext;
               if);
               ']' -> string.puttext;
            exit string[]
            #);
       #);
     start: ^Invocation;
     top: ^Invocation;
     return: ^Invocation;
     started: @boolean;
     
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do NONE -> return[];
          (if top[] <> NONE then
              top.receiver[] -> theInvocation.sender[];
              top[] -> theInvocation.return[];
              theInvocation[] -> top.active[];
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
          
       do top[] -> theInvocation[];
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          
          theInvocation.return[] -> top[];
          (if doKeepHistory then
              theInvocation[] -> top.history.append;
          if);
          NONE -> top.active[];
          NONE -> theInvocation.return[];
          
          
          &Invocation[] -> return[];
          theInvocation.sender[] -> return.sender[];
          theInvocation.receiver[] -> return.receiver[];
          theInvocation.allocation -> return.allocation;
       #);
     
     refresh:
       (#
       do 
          presentSequenceDiagram;
          floating.scan
          (#
          do current.refresh;
          #);
          refreshConnectors;
          true -> updateflag;
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do liveObjects.clear;
             self[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             &Invocation[] -> theInvocation[];
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
             refresh;
          #);
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (# sender: ^LiveObject;
             receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do (if isObj then
                 self[] 
                   -> reflection
                   -> objectShapeForTarget
                   -> liveObjectForObjectShape
                   -> receiver[];
                 &Invocation[] -> theInvocation[];
                 caller[] -> theInvocation.caller[];
                 true -> theInvocation.allocation;
                 receiver[] -> theInvocation.receiver[];
                 theInvocation[] -> pushInvocation;
             if);
             refresh;
          #);
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (# sender: ^LiveObject;
             receiver: ^LiveObject;
             action: ^ObjectShape;
             theInvocation: ^Invocation;
          do 
             origin[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             self[]
               -> reflection
               -> objectShapeForTarget
               -> action[];
             
             
             &Invocation[] -> theInvocation[];
             caller[] -> theInvocation.caller[];
             receiver[] -> theInvocation.receiver[];
             action[] -> theInvocation.action[];
             theInvocation[] -> pushInvocation;
             refresh;
          #);
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if (caller[], self[], origin[]) -> top.match then
                 popInvocation;
             if);
             refresh;
          #);
       #);
      
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
              THIS(SequenceDiagram)[] -> shape.dia[];
          if);
       exit shape[]
       #);
     ObjectShape: Shape
       (# expanded: @boolean;
          reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          pane: ^RowFigure;
          body: ^ColumnFigure;
          
          init::
            (#
            enter reflect[]
            do (# simples: ^ObjectReflector.AttributeList;
                  space: ^SpaceFigure;
               do &RowFigure[] -> pane[];
                  pane.init;
                  18 -> pane.baseMinimumHeight;
                  true -> pane.horizontallyFlexible;
                  true -> pane.verticallyFlexible;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  18 -> space.minimumHeight;
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  &ColumnFigure[] -> body[];
                  body.init;
                  true -> body.horizontallyFlexible;
                  true -> body.verticallyFlexible;
                  body[] -> pane.add;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  18 -> space.minimumHeight;
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  compile[] -> reflect.collectSimples -> simples[];
                  
                  simples.scan
                  (# row: ^AttributeOutliner;
                  do &AttributeOutliner[] -> row[];
                     current[] -> row.init;
                     row[] -> body.add;
                  #);
                  
                  &ObjectFigure[] -> fig[];
                  fig.init;
                  fig[] -> add;
                  pack;
               #);
            #);
          refresh::
            (#
            do body.children.scan
               (# attribute: ^AttributeOutliner;
               do current[] -> attribute[];
                  attribute.refresh;
               #);
               pack;
            #);
          close:
            (# theConnectors: ^ConnectorList;
            do THIS(ObjectShape)[] -> connected -> theConnectors[];
               theConnectors.scan
               (# theConnector: ^Connector;
                  theObjectShape: ^ObjectShape;
               do current[] -> theConnector[];
                  current.source.theShape[] -> theObjectShape[];
                  theObjectShape.body.children.scan
                  (# attribute: ^AttributeOutliner;
                  do current[] -> attribute[];
                     (if attribute.theConnector[] = theConnector[] then
                         NONE -> attribute.theConnector[];
                     if);
                  #);
                  current.dismiss;
               #);
            #);
          pack:
            (#
            do fig.configure;
               fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          ObjectFigure: AdornFigure
            (# outline: ^ColumnFigure;
               title: ^TitleFigure;
               
               navigateReference:
                 (# ref: ^Object;
                 enter ref[]
                 do (***
                     (# theClassDiagram: ^ClassDiagram;
                     do 
                     (if ref[] <> NONE then
                     dia[] -> theClassDiagram[];
                     (ref[], NONE, &Point2d[]) -> theClassDiagram.reflect;
                     if);
                     #);
                     ***)
                 #);
               TitleFigure: RowFigure
                 (# OriginButton: Toggler
                      (# onExpand::
                           (#
                           do true -> expanded;
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                         onCollapse::
                           (#
                           do false -> expanded;
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                      #);
                    ClassButton: Toggler
                      (# NavigateMenu: Menu
                           (# goThereItem: @MenuItem
                                (# eventHandler::
                                     (# onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> navigateThere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Go' -> name;
                                     #);
                                #);
                              bringItHereItem: @MenuItem
                                (# eventHandler::
                                     (# onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> navigateHere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Fetch' -> name;
                                     #);
                                #);
                              showArrowItem: @MenuItem
                                (# eventHandler::
                                     (#
                                        onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> connectHere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Connect' -> name;
                                     #);
                                #);
                              open::
                                (#
                                do goThereItem.open;
                                   goThereItem[] -> append;
                                   bringItHereItem.open;
                                   bringItHereItem[] -> append;
                                   showArrowItem.open;
                                   showArrowItem[] -> append;
                                #);
                           #);
                         
                         hasMenu::
                           (#
                           do true -> yes;
                           #);
                         getMenu::
                           (#
                           do &NavigateMenu[] -> theMenu[];
                              theMenu.open;
                           #);
                         finishMenu::
                           (#
                           do theMenu.close;
                           #);
                         navigateThere:
                           (# block: ^Pattern;
                           enter block[]
                           do (***
                               (# theClassDiagram: ^ClassDiagram;
                               do THIS(Shape).dia[] -> theClassDiagram[];
                               (if block.owner[] <> theClassDiagram.thePackage[] then
                               block.owner[] -> theClassDiagram.navi.navigateTo;
                               if);
                               #);
                               ***)
                           #);
                         navigateHere:
                           (# block: ^Pattern;
                              a: ^Point2d;
                              otherShape: ^Shape;
                           enter block[]
                           do (***
                               &Point2d[] -> a[];
                               (0, 0) -> THIS(TitleFigure).localToGlobal -> a;
                               a.x + 20 -> a.x;
                               a.y - 200 -> a.y;
                               (block[], a[]) -> this(ObjectShape).navigateToFull -> otherShape[];
                               ***)
                           exit otherShape[]
                           #);
                         connectHere:
                           (# block: ^Pattern;
                           enter block[]
                           do (***
                               (# otherShape: ^Shape;
                               theClassDiagram: ^ClassDiagram;
                               do THIS(Shape).dia[] -> theClassDiagram[];
                               block[] -> theClassDiagram.lookupPatternShape -> otherShape[];
                               (if otherShape[] = NONE then
                               block[] -> navigateHere -> otherShape[];
                               if);
                               (if otherShape[] <> NONE then
                               (THIS(Shape)[], otherShape[], verticalorientation) 
                               -> theClassDiagram.connect;
                               update;
                               if);
                               #);
                               ***)
                           #);
                         onExpand::
                           (#
                           do (if reflect.struct[] <> NONE then
                                  reflect.struct[] -> navigateHere;
                              if);
                           #);
                         onCollapse::
                           (#
                           do (if reflect.struct[] <> NONE then
                                  reflect.struct[] -> navigateHere;
                              if);
                           #);
                      #);
                    
                    
                    
                    oriBtn: ^OriginButton;
                    
                    init::
                      (# txtFig: ^TextFigure;
                         construct: @Construction;
                      do true -> horizontallyFlexible;
                         18 -> baseMinimumHeight;
                         2 -> construct.hSpace -> add;
                         &OriginButton[] -> oriBtn[];
                         (res.black[], res.black[]) -> CreateToggler -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                         res.heading[] -> txtFig.style;
                         res.black[] -> txtFig.stroke;
                         txtFig[] -> add;
                         2 -> construct.flexHSpace -> add;
                      #);
                 #);
               configure:
                 (# ruler: ^RulerFigure;
                    construct: @Construction;
                 do 12 -> baseMinimumHeight;
                    outline.clear;
                    title[] -> outline.add;
                    (if expanded then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.black[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        8 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        pane[] -> outline.add; 
                       
                    if);
                 #);
               init::
                 (# center: ^CenterFigure;
                    background: ^Figure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    
                    'pack.with: ' -> puttext;
                    baseMinimumHeight -> putint;
                    newline;
                    
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                    
                    
                    
                    placard[] -> createBackground -> background[];
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    background[] -> center.add;
                    background[] -> center.background[];
                    -6 -> center.inset;
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    configure;
                 #);
            #);
          
          AttributeOutliner: RowFigure
            (# target: ^ObjectReflector.AttributeReflector;
               theConnector: ^Connector;
               valueFig: ^TextFigure;
               refresh:
                 (# old: ^Text;
                    new: ^Text;
                 do valueFig.content -> old[];
                    target.description -> new[];
                    new[] -> valueFig.content;
                    (if not updateflag then
                        (if not (new[] -> old.equal) then
                            res.red[] -> valueFig.stroke;
                         else
                            res.black[] -> valueFig.stroke;
                        if);
                    if);
                 #);
               
               connectHere:
                 (# other: ^ObjDesc.Template;
                    shape: ^ObjectShape;
                    x, y: @integer;
                 enter (x, y)
                 do (if theConnector[] = NONE then
                        target.reference -> other[];
                        (if other[] <> NONE then
                            other[] -> reflection
                              -> objectShapeForTarget
                              -> shape[];
                            (if shape.father[] = NONE then
                                shape[] -> getPatternName -> putline;
                                x + 60 -> shape.x;
                                y -> shape.y;
                                &shape.Drag[] -> shape.fig.theBehaviour[];
                                shape[] -> THIS(SequenceDiagram).add;
                                shape[] -> floating.append;
                            if);
                            (THIS(ObjectShape)[], shape[], HorisontalOrientation) 
                              -> connect
                              -> theConnector[];
                            update;
                        if);
                    if);
                 #);
               disconnect:
                 (#
                 do (if theConnector[] <> NONE then
                        theConnector.dismiss;
                        NONE -> theConnector[];
                    if);
                 #);
               
               ReferenceButton: IconButton
                 (# click:
                      (#
                      do (if theConnector[] = NONE then
                             (0, 0) -> localToGlobal -> connectHere;
                          else
                             disconnect;
                         if);
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               init::
                 (#
                 enter target[]
                 do (# txtFig: ^TextFigure;
                       
                       icon: ^RichPixmap;
                       construct: @Construction;
                       iconBtn: ^IconButton;
                       btn: ^Figure;
                    do true -> horizontallyFlexible;
                       16 -> baseMinimumHeight;
                       &TextFigure[] -> txtFig[];
                       txtFig.init;
                       target.name -> txtFig.content;
                       res.smallstyle[] -> txtFig.style;
                       res.black[] -> txtFig.stroke;
                       txtFig[] -> add;
                       
                       24 -> construct.flexHSpace -> add;
                       &TextFigure[] -> valueFig[];
                       valueFig.init;
                       target.description -> valueFig.content;
                       res.smallnicestyle[] -> valueFig.style;
                       res.black[] -> valueFig.stroke;
                       valueFig[] -> add;
                       8 -> construct.hSpace -> add;
                       (if target.kind 
                        //SimpleKind then
                           equal[] -> createImageFigure -> btn[];
                        //ReferenceKind then
                           &ReferenceButton[] -> iconBtn[];
                           up[] -> iconBtn.init;
                           iconBtn[] -> btn[];
                        //PatternKind then
                           colon[] -> createImageFigure -> btn[];
                        //RepetionKind then
                           equal[] -> createImageFigure -> btn[];
                       if);
                       btn[] -> add;
                    #)
                 #);
            #);
          
       #);
     
    
     Construction:
       (# hSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do (#
               do &SpaceFigure[] -> space[];
                  space.init;
                  minimum -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
               #);
            exit space[]
            #);
          vSpace:
            (# 
            #);
          flexHSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do minimum -> hSpace -> space[];
               true -> space.horizontallyFlexible;
            exit space[]
            #);
          flexVSpace:
            (#
            #);
       #);
     
     init::
       (#
       do res.init;
          'placard\\placard' -> loadTileSet -> placard[];
          'icons\\colon.png' -> loadImage -> colon[];
          'icons\\equal.png' -> loadImage -> equal[];
          'icons\\up.png' -> loadImage -> up[];
          lines.init;
          lines[] -> add;
          nodes.init;
          nodes[] -> add;
          7 -> x;
          7 -> y;
       #);
  #);

-- windowLib: attributes --

SequenceCanvas: FigureCanvas
  (#
     sequence: @SequenceDiagram;
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart;
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (caller[], self[], origin[], bc, isObj) -> sequence.onAlloc;
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onDo;
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn;
       #);
     open::
       (#
       do sequence.init;
          sequence[] -> add;
       #);
     eventHandler::
       (# onRefresh::
            (#
            do false -> sequence.updateflag;
            #);
       #);
  #);
SequenceWindow: SubWindow
  (# LOGGING: (# exit false #);
     reflection:
       (# target: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.Template;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     keepHistory:
       (# value: @boolean;
       enter value
       do value -> interior.sequence.doKeepHistory;
       #);
     clearHistory:
       (#
       do interior.sequence.clearHistory;
       #);
     
     setCompiler:
       (# reference: ^generator;
       enter reference[]
       do reference[] -> interior.sequence.compile[];
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[start ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onStart;
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[alloc ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          
          (caller[], self[], origin[], bc, isObj) -> interior.onAlloc;
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[do ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onDo;
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
       enter (caller[], self[], origin[], bc)
       do (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[return ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onReturn;
       #);
    
     interior: @SequenceCanvas (# #);
     
     open::
       (# width, height: @integer;
       do interior.open;
          (10, 40) -> interior.position;
          size -> (width, height);
          (width - 20, height - 50) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
       #);
  #);

