ORIGIN '~beta/postwimp/demo/chaos/diagram';
INCLUDE 'subwindow';
INCLUDE  '~beta/postwimp/demo/chaos/widgets';
INCLUDE '../miniCompiler/generator';
INCLUDE 'objectContent';
-- lib: attributes --


Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);
SimpleKind:
  (# exit 1 #);
PatternKind:
  (# exit 2 #);
ReferenceKind:
  (# exit 3 #);
RepetionKind:
  (# exit 4 #);

ObjectReflector:
  (# template: ^ObjDesc.Template;
     struct: ^Pattern;
     init:
       (# theTemplate: ^ObjDesc.Template;
       enter theTemplate[]
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
     descriptionOf:
       (# template: ^ObjDesc.Template;
          description: ^Text;
       enter template[]
       do (# name: ^Text;
             ch: @char;
          do template.myName -> name[];
             (if name.length < 0 then
                 1 -> name.inxGet -> ch;
                 (if ch//'a'//'A'//'e'//'E'//'i'//'I'//'o'//'O'//'u'//'U' then
                     'an ' -> description[];
                  else
                     'a ' -> description[];
                 if);
                 name[] -> description.append;
             if);
          #);
       exit description[]
       #);
     collectSimples:
       (# compiler: ^generator;
          simples: ^AttributeList;
       enter compiler[]
       do (# descNo: @integer;
             theObjectDesc: ^generator.ObjectDesc;
             isRef: @boolean;
             off: @integer;
          do &AttributeList[] -> simples[];
             template.myDescInx -> descNo;
             descNo -> compiler.newDesc.getOD -> theObjectDesc[];
             (if theObjectDesc[] <> NONE then
                 theObjectDesc.scanAllDecls
                 (# name: ^Text;
                    simple: ^AttributeReflector;
                    kind: @integer;
                    offset: @integer;
		    origin::
                      (#
                      do &AttributeReflector[] -> simple[];
                         (name[], off, ReferenceKind) -> simple.init;
                         simple[] -> simples.append;
                      #);
                 do (currentND.lexemSy).copy -> name[];
                    currentND.off -> off;
                    (if off > 0 then 
                        off -> offset;
                        (if currentDcl.IT.isSimple then
                            SimpleKind -> kind;
                         else
                            ReferenceKind -> kind;
                        if)            
                     else
                        (if currentDcl.IT.isIndexed then
                            RepetionKind -> kind;
                            offset + 1 -> off;
                         else
                            PatternKind -> kind;
                        if);
                    if);
                    &AttributeReflector[] -> simple[];
                    (name[], off, kind) -> simple.init;
                    simple[] -> simples.append;
                 #);
             if);
          #);
       exit simples[]
       #);
     
     AttributeList: List
       (# Element:: AttributeReflector;
       #);
    

     AttributeReflector:
       (# theName: ^Text;
          offset: @integer;
          kind: @integer;
          init:
            (#
            enter (theName[], offset, kind)
            do 
            #);
          name:
            (#
            do 
            exit theName[]
            #);
          reference:
            (# other: ^ObjDesc.Template;
            do (if (kind = ReferenceKind) and (offset > 0) then
                   template.rfields[offset][] -> other[];
               if);
            exit other[]
            #);
          description:
            (# theDescription: ^Text;
            do (# obj: ^ObjDesc.Template;
               do '' -> theDescription[];
                  (if offset > 0 then
                      (if kind
                       //SimpleKind then
                          offset -> template.get -> theDescription.putint;
                       //RepetionKind then
                          (# n: @integer;
                          do offset -> template.get -> n;
                             (if n > 32 then
                                 32 -> n;
                             if);
                             (for i: n repeat
                                  offset + i -> template.get -> theDescription.put;
                             for);
                          #);
                       //ReferenceKind then
                          template.rfields[offset][] -> obj[];
                          (if obj[] = none then
                              'none' -> theDescription.putText;
                           else
                              (# name: ^Text;
                              do 
                                 obj.myName -> name[];
                                 (if name[] <> NONE then
                                     name[] -> theDescription.putText;
                                  else 
                                     '   ' -> theDescription.putText;
                                 if);
                              #);
                          if);
                      if)            
                   else (* pattern *)
                      '  ' -> theDescription.puttext;
                  if);
               #);
            exit theDescription[]
            #);
               
       #);
  #);


-- FigureCanvasLib: attributes --

SequenceDiagram: Diagram
  (# 
     VM: ^| systemenv.betaVM;
     L: ^Object;
     lines: @Composite;
     nodes: @Composite;
     floating: @Sequence
       (# Element:: ObjectShape;
       #);
     visibles: @Sequence
       (# Element:: ObjectShape;
       #);
     compiler: ^generator;
     LOGGING: (# exit false #);
     res: @Resource;
     x, y: @integer;
     doKeepHistory: @boolean;
     placard: ^TileSet;
     colon: ^RichPixmap;
     equal: ^RichPixmap;
     up: ^RichPixmap;
     
     updateflag: @boolean;
     
     compile:
       (# objC: ^ObjectContent.handle
       enter objC[]
       do '****************' -> putline;
          'MiniENV: compile' -> putline;
          objC.aMod.name.lexemSy -> putline;
          (L[],false,none,objC.aMod.inFile.name) -> compiler;
          (if compiler.hasErrors then none -> compiler.rootComp[] if)
       exit objC.aMod[]
       #);
     
     execute:
       (# objC: ^ObjectContent.handle; 
       enter objC[]
       do (objC.aMod.inFile.name,'..run') -> mkAuxName -> RTT.name;
          RTT.openWrite;               
          '****************' -> putline; 
          'MiniENV: execute' -> putline;
          '****************' -> putline; 
          (if not VM.execute.isRunning then
              VM.init; (* why two inits?*)
              'Exe:aMod.descNo: ' -> puttext; objC.aMod.descNo -> putint;
              ' mainDescNo: ' -> puttext; compiler.mainDescNo -> putint; newline;
              (compiler.descs[],compiler.mainDescNo,RTT[]) -> VM.execute.init;
              VM.execute;
           else
              'VM is not terminated' -> putline
          if);                       
       #);
     RTT: @File;
     
     
     displayChain:
       (# self: ^ObjDesc.Template;
       enter self[]
       do (# current: ^ObjDesc.Template;
          do self.myName -> puttext;
             self.myOrigin -> current[];
             loop:
               (if current[] <> NONE then
                   '<-' -> puttext;
                   current.myName -> puttext;
                   current.myOrigin -> current[];
                   restart loop;
               if);
             newline;
          #);
       #);
     isOrigin:
       (# candidate: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          result: @boolean;
       enter (candidate[], self[])
       do (if self[] <> NONE then
              (if candidate[] = self[] then
                  true -> result;
               else
                  (candidate[], self.myOrigin) -> isOrigin -> result;
              if);
          if);
       exit result
       #);
     commonOrigin:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
       enter (caller[], self[])
       do (if caller[] <> NONE then
              (if (caller[], self[]) -> isOrigin then
                  caller[] -> origin[];
               else
                  (caller.myOrigin, self[]) -> commonOrigin -> origin[];
              if);
          if);
       exit origin[]
       #);
     isSkipping:
       (# origin: ^ObjDesc.Template;
          result: @boolean;
       enter origin[]
       do (if origin[] <> NONE then
              (# shape: ^ObjectShape;
              do origin[] 
                   -> reflection
                   -> objectShapes.lookupByTarget 
                   -> shape[];
                 (if shape[] <> NONE then
                     shape.skip -> result;
                 if);
                 (if NOT result then
                     origin.myOrigin -> isSkipping -> result;
                 if);
              #);
          if);
       exit result
       #);
     
     createCircle:
       (# theOvalFigure: ^OvalFigure;
          fill: ^Color;
          circle: ^CenterFigure;
       enter fill[]
       do &OvalFigure[] -> theOvalFigure[];
          theOvalFigure.init;
          fill[] -> theOvalFigure.fill;
          true -> theOvalFigure.horizontallyFlexible;
          true -> theOvalFigure.verticallyFlexible;
          &CenterFigure[] -> circle[];
          circle.init;
          theOvalFigure[] -> circle.add;
          up.width -> circle.baseMinimumWidth;
          up.height -> circle.baseMinimumHeight;
          3 -> circle.margin;
       exit circle[]
       #);
     TileSet:
       (# topleft: ^RichPixmap;
          top: ^RichPixmap;
          topright: ^RichPixmap;
          left: ^RichPixmap;
          middle: ^RichPixmap;
          right: ^RichPixmap;
          bottomleft: ^RichPixmap;
          bottom: ^RichPixmap;
          bottomright: ^RichPixmap;
          
          load:
            (# name: ^Text;
            enter name[]
            do '-topleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topleft[];
               '-top.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> top[];
               '-topright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topright[];
               '-left.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> left[];
               '-middle.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> middle[];
               '-right.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> right[];
               '-bottomleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomleft[];
               '-bottom.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottom[];
               '-bottomright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomright[];
            #);
       #);
     
     loadImage:
       (# name: ^Text;
          image: ^RichPixmap;
       enter name[]
       do (# path: ^Text;
          do &RichPixmap[] -> image[];
             'c:\\beta\\r5.5\\postwimp\\images\\' -> path[];
             name[] -> path.append;
             path[] -> image.readAlpha;
             false -> image.transparent;
          #);
       exit image[]
       #);
     loadTileSet:
       (# name: ^Text;
          tiles: ^TileSet;
       enter name[]
       do &TileSet[] -> tiles[];
          name[] -> tiles.load;
       exit tiles[]
       #);
     
     createImageFigure:
       (# image: ^RichPixmap;
          item: ^ImageFigure;
       enter image[]
       do &ImageFigure[] -> item[];
          item.init;
          image[] -> item.content;
       exit item[]
       #);
     
     createBackground:
       (# tiles: ^TileSet;
          background: ^ColumnFigure;
       enter tiles[]
       do &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             topleft: ^ImageFigure;
             top: ^ImageFigure;
             topright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.topleft[]
               -> createImageFigure 
               -> topleft[];
             false -> topleft.horizontallyFlexible;
             false -> topleft.verticallyFlexible;
             topleft[] -> row.add;
             
             tiles.top[]
               -> createImageFigure 
               -> top[];
             true -> top.horizontallyFlexible;
             false -> top.verticallyFlexible;
             top[] -> row.add;
             
             tiles.topright[]
               -> createImageFigure 
               -> topright[];
             false -> topright.horizontallyFlexible;
             false -> topright.verticallyFlexible;
             topright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          (# row: ^RowFigure;
             left: ^ImageFigure;
             middle: ^ImageFigure;
             right: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.left[]
               -> createImageFigure 
               -> left[];
             false -> left.horizontallyFlexible;
             true -> left.verticallyFlexible;
             left[] -> row.add;
             
             tiles.middle[]
               -> createImageFigure 
               -> middle[];
             true -> middle.horizontallyFlexible;
             true -> middle.verticallyFlexible;
             middle[] -> row.add;
             
             tiles.right[]
               -> createImageFigure 
               -> right[];
             false -> right.horizontallyFlexible;
             true -> right.verticallyFlexible;
             right[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
             true -> row.verticallyFlexible;
          #);
          (# row: ^RowFigure;
             bottomleft: ^ImageFigure;
             bottom: ^ImageFigure;
             bottomright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.bottomleft[]
               -> createImageFigure 
               -> bottomleft[];
             false -> bottomleft.horizontallyFlexible;
             false -> bottomleft.verticallyFlexible;
             bottomleft[] -> row.add;
             
             tiles.bottom[]
               -> createImageFigure 
               -> bottom[];
             true -> bottom.horizontallyFlexible;
             false -> bottom.verticallyFlexible;
             bottom[] -> row.add;
             
             tiles.bottomright[]
               -> createImageFigure 
               -> bottomright[];
             false -> bottomright.horizontallyFlexible;
             false -> bottomright.verticallyFlexible;
             bottomright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          background.pack;
       exit background[]
       #);
     
     objectReflectors: @List
       (# Element:: ObjectReflector;
          lookupByTemplate:
            (# target: ^ObjDesc.Template;
               reflect: ^ObjectReflector;
            enter target[]
            do search: scan
                 (#
                 do (if current.template[] = target[] then
                        current[] -> reflect[];
                        leave search;
                    if);
                 #);
            exit reflect[]
            #);
       #);
     reflection:
       (# template: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter template[]
       do (if template[] <> NONE then
              (#
              do template[] -> objectReflectors.lookupByTemplate -> reflect[];
                 (if reflect[] = NONE then
                     &ObjectReflector[] -> reflect[];
                     template[] -> reflect.init;
                     reflect[] -> objectReflectors.append;
                 if);
              #);
           else
              exception (#  #);
          if);
       exit reflect[]
       #);
     
     reset:
       (#
       do clear;
          7 -> x;
       #);
     present:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do &ObjectShape[] -> shape[];
          target[] -> shape.init;
          shape[] -> add;
          x -> shape.x;
          y -> shape.y;
          
          x + 200 -> x;
       #);
     
     clearHistory:
       (# current: ^Invocation;
       do start[] -> current[];
          clearing:
            (if current[] <> NONE then
                current.history.clear;
                current.active[] -> current[];
                restart clearing;
            if);
          presentSequenceDiagram;
       #);
     presentSequenceDiagram:
       (#
       do (# mark: @List;
             x: @integer;
             y: @integer;
             header: @integer;
             prepareOne:
               (# inv: ^Invocation;
               enter inv[]
               do inv.receiver.target.refresh;
                  (if inv.action[] <> NONE then
                      inv.action.refresh;
                  if);
                  (if not inv.allocation then
                      (if inv.receiver.target.height > header then
                          inv.receiver.target.height -> header;
                      if);
                  if);
               #);
             prepare:
               (# inv: ^Invocation;
               enter inv[]
               do inv[] -> prepareOne;
                  inv.scan
                  (#
                  do current[] -> prepare;
                  #);
               #);
             processOne:
               (# inv: ^Invocation;
                  dy: @integer;
                  addNode:
                    (# node: ^ObjectShape;
                    enter node[]
                    do node[] -> touched.append;
                       (if not (node[] -> visibles.has) then
                           
                           (if node.father[] <> NONE then
                               node[] -> THIS(SequenceDiagram).remove;
                               node[] -> floating.delete;
                           if);
                           node[] -> nodes.add;
                           NONE -> node.fig.theBehaviour[];
                           node[] -> visibles.append;
                       if);
                    #);
                  back: @boolean;
               enter (inv[], back)
               do 24 -> dy;
                  (if not (inv.receiver[] -> mark.has) then
                      inv.receiver[] -> mark.append;
                      (# dx: @integer;
                         a: ^Point2d;
                      do (if inv.sender[] <> NONE then
                             inv.sender.bottomAnchor -> a[];
                             ((x + inv.receiver.target.width / 2) - a.x) - 20 -> dx;
                             (if inv.action[] <> NONE then
                                 (if dx < inv.action.width then
                                     dx - inv.action.width -> dx;
                                     x - dx -> x;
                                 if);
                             if);
                         if);
                      #);
                      
                      (if inv.allocation then
                          (x, y) -> inv.receiver.layout;
                          inv.receiver.target.height -> dy;
                       else
                          (x, 24) -> inv.receiver.layout;
                      if);
                      x + inv.receiver.target.width + 7 -> x;
                      inv.receiver.target[] -> addNode;
                      inv.receiver.live[] -> lines.add;
                  if);
                  y -> inv.layout;
                  (if inv.action[] <> NONE then
                      (if inv.action.height > dy then
                          inv.action.height -> dy;
                      if);
                  if);
                  
                  (if back then
                      inv.swap;
                  if);
                  (if inv.arrow[] <> NONE then
                      inv.arrow[] -> lines.add;
                  if);
                  (if not back then
                      (if inv.action[] <> NONE then
                          inv.action[] -> addNode;
                      if);
                  if);
                  y + dy -> y;
               #);
             process:
               (# inv: ^Invocation;
               enter inv[]
               do (inv[], false) -> processOne;
                  inv.scan
                  (#
                  do current[] -> process;
                  #);
               #);
             touched: @Sequence
               (# Element:: ObjectShape;
               #);
             deletion: @Sequence
               (# Element:: ObjectShape;
               #);
          do lines.clear;
             24 -> x;
             start[] -> prepare;
             (if return[] <> NONE then
                 return[] -> prepareOne;
             if);
             header + 24 -> y;
             start[] -> process;
             (if return[] <> NONE then
                 (return[], true) -> processOne;
             if);
             visibles.scan
             (# shape: ^ObjectShape;
             do (if not (current[] -> touched.has) then
                    current[] -> deletion.append;
                 else
                    current[] -> shape[];
                if);
             #);
             deletion.scan
             (#
             do current.dismissConnectors;
                current.refresh;
                current[] -> nodes.remove;
                current[] -> visibles.delete;
                (if current.sticky then
                    &current.Drag[] -> current.fig.theBehaviour[];
                    current[] -> THIS(SequenceDiagram).add;
                    current[] -> floating.append;
                if);
             #);
             update;
          #);
       #);
     
     liveObjects: @List
       (# Element:: LiveObject;
          lookupByShape:
            (# target: ^ObjectShape;
               live: ^LiveObject;
            enter target[]
            do search: scan
                 (#
                 do (if current.target[] = target[] then
                        current[] -> live[];
                        leave search;
                    if);
                 #);
            exit live[]
            #);
       #);
     liveObjectForObjectShape:
       (# target: ^ObjectShape;
          live: ^LiveObject;
       enter target[]
       do target[] -> liveObjects.lookupByShape -> live[];
          (if live[] = NONE then
              &LiveObject[] -> live[];
              target[] -> live.init;
              live[] -> liveObjects.append;
          if);
       exit live[]
       #);
     LiveObject:
       (# target: ^ObjectShape;
          live: ^Line;
          
          layout:
            (# dx, dy: @integer;
            enter (dx, dy)
            do dx -> target.x;
               dy - 10 -> target.y;
               (# top: ^Point2d;
                  bottom: ^Point2d;
               do bottomAnchor -> top[];
                  &Point2d[] -> bottom[];
                  top.x -> bottom.x;
                  600 -> bottom.y;
                  &Line[] -> live[];
                  live.init;
                  top[] -> live.start[];
                  bottom[] -> live.end[];
                  res.black[] -> live.stroke[];
                  1 -> live.strokewidth;
               #);
            #);
          
          bottomAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + target.height -> p.y;
               target.x + target.width / 2 -> p.x;
            exit p[]
            #);
          leftAnchor:
            (# p: ^Point2d;
            do &Point2d[] -> p[];
               target.y + 10 -> p.y;
               target.x -> p.x;
            exit p[]
            #);
          init:
            (#
            enter target[]
            do 
            #);
          template:
            (# result: ^ObjDesc.template;
            do target.reflect.template[] -> result[];
            exit result[]
            #);
          
          description:
            (# string: ^Text;
            do target.reflect.name -> string[];
            exit string[]
            #);
       #);
     
     Decoration: Composite
       (# containsPoint::
            (#
            do NONE -> target[];
            #);
       #);
     Invocation:
       (# sender: ^LiveObject;
          receiver: ^LiveObject;
          caller: ^ObjDesc.Template;
          action: ^ObjectShape;
          allocation: @boolean;
          
          history: @List
            (# Element:: Invocation;
            #);
          active: ^Invocation;
          return: ^Invocation;
          pts: ^PointList;
          arrow: ^Composite;
          head: ^ArrowHead;
          
          
          scan:
            (# current: ^Invocation;
            do history.scan
               (#
               do current[] -> THIS(scan).current[];
                  INNER scan;
               #);
               (if active[] <> NONE then
                   active[] -> current[];
                   INNER scan;
               if);
            #);
          swap:
            (# lst: ^PointList;
            do (if pts[] <> NONE then
                   &PointList[] -> lst[];
                   pts.scan
                   (#
                   do current[] -> lst.prepend;
                   #);
                   (lst[], true) -> createArrow;
                   (* PenDash -> arrowLine.style; *)
               if);
            #);
          
          createArrow:
            (# lst: ^PointList;
               dash: @boolean;
            enter (lst[], dash)
            do (#
               do lst[] -> pts[];
                  &Decoration[] -> arrow[];
                  arrow.init;   
                  (# prev: ^Point2d;
                  do pts.scan
                     (# segment: ^Line;
                     do (if prev[] <> NONE then
                            &Line[] -> segment[];
                            segment.init;
                            prev[] -> segment.start[];
                            current[] -> segment.end[];
                            1 -> segment.strokeWidth;
                            res.black[] -> segment.stroke[];
                            (if dash then
                                PenDash -> segment.style;
                            if);
                            segment[] -> arrow.add;
                            
                        if);
                        current[] -> prev[];
                     #);
                  #);
                  
                  (# start, end: ^Point2d;
                  do lst.size - 1 -> lst.get -> start[];
                     lst.size -> lst.get -> end[];
                     &ArrowHead[] -> head[];
                     head.init;
                     end[] -> head.to[];
                     start[] -> head.from[];
                     head.refresh;
                     res.black[] -> head.stroke[];
                     res.black[] -> head.fill[];
                     head[] -> arrow.add;
                  #);
                  
                  (if action[] <> NONE then
                      (# start, end: ^Point2d;
                         mid: ^Point2d;
                      do 1 -> lst.get -> start[];
                         2 -> lst.get -> end[];
                         &Point2d[] -> mid[];
                         (start.x + end.x) / 2 -> mid.x;
                         start.y -> mid.y;
                         mid.x - action.width / 2 -> action.x;
                         mid.y - 10 -> action.y;
                      #);
                  if);
               #);
            #);
          
          layout:
            (# offset: @integer;
               layoutRegular:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if allocation then
                        receiver.leftAnchor -> toAnchor[];
                     else
                        receiver.bottomAnchor -> toAnchor[];
                    if);
                    toAnchor.x -> to.x;
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    (lst[], false) -> createArrow;
                 #);
               layoutSelf:
                 (# from: ^Point2d;
                    to: ^Point2d;
                    lower: ^Point2d;
                    end: ^Point2d;
                    toAnchor: ^Point2d;
                    fromAnchor: ^Point2d;
                    lst: ^PointList;
                 do &Point2d[] -> from[];
                    &Point2d[] -> to[];
                    offset -> from.y;
                    offset -> to.y;
                    (if sender[] <> NONE then
                        sender.bottomAnchor -> fromAnchor[];
                        fromAnchor.x -> from.x;
                    if);
                    (if action[] <> NONE then
                        from.x + action.width + 20 -> to.x;
                     else
                        from.x + 60 -> to.x;
                    if);
                    &Point2d[] -> lower[];
                    to.x -> lower.x;
                    to.y + 30 -> lower.y;
                    &Point2d[] -> end[];
                    from.x -> end.x;
                    from.y + 30 -> end.y;
                    
                    &PointList[] -> lst[];
                    lst.init;
                    from[] -> lst.append;
                    to[] -> lst.append;
                    lower[] -> lst.append;
                    end[] -> lst.append;
                    (lst[], false) -> createArrow;
                 #);
            enter offset
            do (if sender[] = receiver[] then
                   layoutSelf;
                else
                   layoutRegular;
               if);
            #);
          
          match:
            (# caller: ^ObjDesc.Template;
               self: ^ObjDesc.Template;
               origin: ^ObjDesc.Template;
               result: @boolean;
            enter (caller[], self[], origin[])
            do (if allocation then
                   (caller[] = THIS(Invocation).caller[])
                   AND 
                   (self[] = receiver.template) 
                     -> result;
                else
                   (caller[] = THIS(Invocation).caller[])
                   AND
                   (origin[] = receiver.template)
                   AND
                   (self[] = action.reflect.template[])
                     -> result;
               if);
            exit result
            #);
          description:
            (# string: ^Text;
            do '[' -> string[];
               (if sender[] <> NONE then
                   sender.description -> string.puttext;
                   ' ' -> string.puttext;
                   (if action[] <> NONE then
                       action.reflect.name -> string.puttext;
                       ' ' -> string.puttext;
                    else
                       'allocate ' -> string.puttext;
                   if);
                else
                   'start ' -> string.puttext;
               if);
               
               (if receiver[] <> NONE then
                   receiver.description -> string.puttext;
               if);
               ']' -> string.puttext;
            exit string[]
            #);
       #);
     start: ^Invocation;
     top: ^Invocation;
     return: ^Invocation;
     started: @boolean;
     
     pushInvocation:
       (# theInvocation: ^Invocation;
       enter theInvocation[]
       do NONE -> return[];
          (if top[] <> NONE then
              top.receiver[] -> theInvocation.sender[];
              top[] -> theInvocation.return[];
              theInvocation[] -> top.active[];
              theInvocation[] -> top[];
           else
              theInvocation[] -> start[] -> top[];
          if);
          (if LOGGING then
              'PUSH ' -> puttext;
              theInvocation.description -> putline;
          if);
       #);
     popInvocation:
       (# theInvocation: ^Invocation;
          
       do top[] -> theInvocation[];
          (if LOGGING then
              'POP ' -> puttext;
              theInvocation.description -> putline;
          if);
          
          theInvocation.return[] -> top[];
          (if doKeepHistory then
              theInvocation[] -> top.history.append;
          if);
          NONE -> top.active[];
          NONE -> theInvocation.return[];
          
          
          &Invocation[] -> return[];
          theInvocation.sender[] -> return.sender[];
          theInvocation.receiver[] -> return.receiver[];
          theInvocation.allocation -> return.allocation;
       #);
     
     refresh:
       (#
       do 
          presentSequenceDiagram;
          floating.scan
          (#
          do current.refresh;
          #);
          refreshConnectors;
          true -> updateflag;
       #);
     
     
     call:
       (#
       do VM.reActivate;
       #);
     callOver:
       (#
       do VM.reActivate;
       #);
     step:
       (#
       do VM.reActivate;
       #);
     stepOver:
       (#
       do VM.reActivate;
       #);
     skipInternal:
       (#
       #);
     continue:
       (#
       #);
     liveLines:
       (#
       #);
     doClose:
       (#
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (# receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do liveObjects.clear;
             self[] 
               -> reflection
               -> objectShapeForTarget
               -> liveObjectForObjectShape
               -> receiver[];
             &Invocation[] -> theInvocation[];
             receiver[] -> theInvocation.receiver[];
             false -> theInvocation.allocation;
             theInvocation[] -> pushInvocation;
             refresh;
             true -> pause;
          #);
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (# sender: ^LiveObject;
             receiver: ^LiveObject;
             theInvocation: ^Invocation;
          do (if isObj then
                 self[]
                   -> reflection
                   -> objectShapeForTarget
                   -> liveObjectForObjectShape
                   -> receiver[];
                 &Invocation[] -> theInvocation[];
                 caller[] -> theInvocation.caller[];
                 true -> theInvocation.allocation;
                 receiver[] -> theInvocation.receiver[];
                 theInvocation[] -> pushInvocation;
                 true -> pause;
             if);
             refresh;
          #);
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (if self[] <> NONE then
              (# sender: ^LiveObject;
                 receiver: ^LiveObject;
                 action: ^ObjectShape;
                 common: ^ObjDesc.Template;
                 theInvocation: ^Invocation;
                 skip: @boolean;
              do (if caller[] <> NONE then
                     (caller[], self[]) -> commonOrigin -> common[];
                     (if common[] <> none then
                         common[] -> displayChain;
                         common[] -> isSkipping -> skip;
                     if);
                 if);
                 
                 (if NOT skip then
                     (if origin[] <> NONE then
                         origin[] 
                           -> reflection
                           -> objectShapeForTarget
                           -> liveObjectForObjectShape
                           -> receiver[];
                         self[]
                           -> reflection
                           -> objectShapeForTarget
                           -> action[];
                      else
                         self[]
                           -> reflection
                           -> objectShapeForTarget
                           -> liveObjectForObjectShape
                           -> receiver[];
                     if);
                     &Invocation[] -> theInvocation[];
                     caller[] -> theInvocation.caller[];
                     receiver[] -> theInvocation.receiver[];
                     action[] -> theInvocation.action[];
                     theInvocation[] -> pushInvocation;
                     refresh;
                     true -> pause;
                  else
                     'SKIP ' -> puttext;
                     self.myName -> putline;
                 if);
              #);
          if);
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (#
          do (if (caller[], self[], origin[]) -> top.match then
                 popInvocation;
                 true -> pause;
             if);
             refresh;
          #);
       exit pause
       #);
      
     objectShapes: @List
       (# Element:: ObjectShape;
          lookupByTarget:
            (# target: ^ObjectReflector;
               shape: ^ObjectShape;
            enter target[]
            do search: scan
                 (# 
                 do (if current.reflect[] = target[] then
                        current[] -> shape[];
                        leave search;
                    if);
                 #);
            exit shape[]
            #);
       #);
     objectShapeForTarget:
       (# target: ^ObjectReflector;
          shape: ^ObjectShape;
       enter target[]
       do target[] -> objectShapes.lookupByTarget -> shape[];
          (if shape[] = NONE then
              &ObjectShape[] -> shape[];
              target[] -> shape.init;
              shape[] -> objectShapes.append;
              THIS(SequenceDiagram)[] -> shape.dia[];
          if);
       exit shape[]
       #);
     ObjectShape: Shape
       (# expanded: @boolean;
          sticky: @boolean;
          skip: @boolean;
          reflect: ^ObjectReflector;
          fig: ^ObjectFigure;
          pane: ^RowFigure;
          body: ^ColumnFigure;
          
          init::
            (#
            enter reflect[]
            do (# simples: ^ObjectReflector.AttributeList;
                  space: ^SpaceFigure;
               do &RowFigure[] -> pane[];
                  pane.init;
                  18 -> pane.baseMinimumHeight;
                  true -> pane.horizontallyFlexible;
                  true -> pane.verticallyFlexible;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  18 -> space.minimumHeight;
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  &ColumnFigure[] -> body[];
                  body.init;
                  true -> body.horizontallyFlexible;
                  true -> body.verticallyFlexible;
                  body[] -> pane.add;
                  
                  &SpaceFigure[] -> space[];
                  space.init;
                  3 -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
                  18 -> space.minimumHeight;
                  false -> space.verticallyFlexible;
                  space[] -> pane.add;
                  
                  compiler[] -> reflect.collectSimples -> simples[];
                  
                  simples.scan
                  (# row: ^AttributeOutliner;
                  do &AttributeOutliner[] -> row[];
                     current[] -> row.init;
                     row[] -> body.add;
                  #);
                  
                  &ObjectFigure[] -> fig[];
                  fig.init;
                  fig[] -> add;
                  pack;
               #);
            #);
          refresh::
            (#
            do (if skip then
                   res.yellowish[] -> fig.title.txtFig.stroke;
                else
                   res.black[] -> fig.title.txtFig.stroke;
               if);
               body.children.scan
               (# attribute: ^AttributeOutliner;
               do current[] -> attribute[];
                  attribute.refresh;
               #);
               pack;
            #);
          dismissConnectors:
            (# theConnectors: ^ConnectorList;
            do THIS(ObjectShape)[] -> connected -> theConnectors[];
               (if expanded then
                   body.children.scan
                   (# attribute: ^AttributeOutliner;
                   do current[] -> attribute[];
                      (if attribute.theConnector[] <> NONE then
                          attribute.theConnector[] -> theConnectors.append;
                      if);
                   #);
               if);
               theConnectors.scan
               (#
               do current.dismiss;
                  NONE -> current.destination[];
               #);
            #);
          pack:
            (#
            do fig.configure;
               fig.pack;
               fig.width -> width;
               fig.height -> height;
            #);
          dismiss:
            (#
            do dismissConnectors;
               (if THIS(ObjectShape)[] -> floating.has then
                   THIS(ObjectShape)[] -> floating.delete;
                   THIS(ObjectShape)[] -> THIS(SequenceDiagram).remove;
               if);
               false -> sticky;
               THIS(ObjectShape).refresh;
               THIS(SequenceDiagram).refresh;
            #);
          hasMenu::
            (#
            do true -> yes;
            #);
          getMenu::
            (#
            do &ObjectMenu[] -> theMenu[];
               theMenu.open;
            #);
           finishMenu::
            (#
            do theMenu.close;
            #);
          ObjectMenu: Menu
            (# dismissItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do dismiss;
                           #);
                      #);
                    open::
                      (#
                      do 'Dismiss' -> name;
                      #);
                 #);
               skipInternalItem: @MenuItem
                 (# eventHandler::
                      (# onSelect::
                           (#
                           do not skip -> skip;
                              (if skip then
                                  'Show Internal' -> name;
                               else
                                  'Skip Internal' ->name;
                              if);
                              THIS(ObjectShape).refresh;
                              update;
                           #);
                      #);
                    open::
                      (#
                      do (if skip then
                             'Show Internal' -> name;
                          else
                             'Skip Internal' ->name;
                         if);
                      #);
                 #);
               open::
                 (#
                 do dismissItem.open;
                    dismissItem[] -> append;
                    skipInternalItem.open;
                    skipInternalItem[] -> append;
                 #);
            #);
          ObjectFigure: AdornFigure
            (# outline: ^ColumnFigure;
               title: ^TitleFigure;
               
               navigateReference:
                 (# ref: ^Object;
                 enter ref[]
                 do (***
                     (# theClassDiagram: ^ClassDiagram;
                     do 
                     (if ref[] <> NONE then
                     dia[] -> theClassDiagram[];
                     (ref[], NONE, &Point2d[]) -> theClassDiagram.reflect;
                     if);
                     #);
                     ***)
                 #);
               TitleFigure: RowFigure
                 (# txtFig: ^TextFigure;
                    ExpansionButton: Toggler
                      (# onExpand::
                           (#
                           do true -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeOutliner;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     attribute[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                         onCollapse::
                           (#
                           do false -> expanded;
                              body.children.scan
                              (# attribute: ^AttributeOutliner;
                                 theConnector: ^Connector;
                              do current[] -> attribute[];
                                 attribute.theConnector[] -> theConnector[];
                                 (if theConnector[] <> NONE then
                                     THIS(ObjectShape)[] -> theConnector.setSource;
                                 if);
                              #);
                              THIS(ObjectShape).refresh;
                              presentSequenceDiagram;
                              refreshConnectors;
                           #);
                      #);
                    ClassButton: Toggler
                      (# NavigateMenu: Menu
                           (# goThereItem: @MenuItem
                                (# eventHandler::
                                     (# onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> navigateThere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Go' -> name;
                                     #);
                                #);
                              bringItHereItem: @MenuItem
                                (# eventHandler::
                                     (# onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> navigateHere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Fetch' -> name;
                                     #);
                                #);
                              showArrowItem: @MenuItem
                                (# eventHandler::
                                     (#
                                        onSelect::
                                          (#
                                          do (if reflect.struct[] <> NONE then
                                                 reflect.struct[] -> connectHere;
                                             if);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do 'Connect' -> name;
                                     #);
                                #);
                              open::
                                (#
                                do goThereItem.open;
                                   goThereItem[] -> append;
                                   bringItHereItem.open;
                                   bringItHereItem[] -> append;
                                   showArrowItem.open;
                                   showArrowItem[] -> append;
                                #);
                           #);
                         
                         hasMenu::
                           (#
                           do true -> yes;
                           #);
                         getMenu::
                           (#
                           do &NavigateMenu[] -> theMenu[];
                              theMenu.open;
                           #);
                         finishMenu::
                           (#
                           do theMenu.close;
                           #);
                         navigateThere:
                           (# block: ^Pattern;
                           enter block[]
                           do (***
                               (# theClassDiagram: ^ClassDiagram;
                               do THIS(Shape).dia[] -> theClassDiagram[];
                               (if block.owner[] <> theClassDiagram.thePackage[] then
                               block.owner[] -> theClassDiagram.navi.navigateTo;
                               if);
                               #);
                               ***)
                           #);
                         navigateHere:
                           (# block: ^Pattern;
                              a: ^Point2d;
                              otherShape: ^Shape;
                           enter block[]
                           do (***
                               &Point2d[] -> a[];
                               (0, 0) -> THIS(TitleFigure).localToGlobal -> a;
                               a.x + 20 -> a.x;
                               a.y - 200 -> a.y;
                               (block[], a[]) -> this(ObjectShape).navigateToFull -> otherShape[];
                               ***)
                           exit otherShape[]
                           #);
                         connectHere:
                           (# block: ^Pattern;
                           enter block[]
                           do (***
                               (# otherShape: ^Shape;
                               theClassDiagram: ^ClassDiagram;
                               do THIS(Shape).dia[] -> theClassDiagram[];
                               block[] -> theClassDiagram.lookupPatternShape -> otherShape[];
                               (if otherShape[] = NONE then
                               block[] -> navigateHere -> otherShape[];
                               if);
                               (if otherShape[] <> NONE then
                               (THIS(Shape)[], otherShape[], verticalorientation) 
                               -> theClassDiagram.connect;
                               update;
                               if);
                               #);
                               ***)
                           #);
                         onExpand::
                           (#
                           do (if reflect.struct[] <> NONE then
                                  reflect.struct[] -> navigateHere;
                              if);
                           #);
                         onCollapse::
                           (#
                           do (if reflect.struct[] <> NONE then
                                  reflect.struct[] -> navigateHere;
                              if);
                           #);
                      #);
                    
                    
                    
                    oriBtn: ^ExpansionButton;
                    
                    init::
                      (# construct: @Construction;
                      do true -> horizontallyFlexible;
                         18 -> baseMinimumHeight;
                         2 -> construct.hSpace -> add;
                         &ExpansionButton[] -> oriBtn[];
                         (res.black[], res.black[]) -> CreateToggler -> oriBtn.init;
                         oriBtn[] -> add;
                         2 -> construct.flexHSpace -> add;
                         &TextFigure[] -> txtFig[];
                         txtFig.init;
                         reflect.name -> txtFig.content;
                         res.heading[] -> txtFig.style;
                         res.black[] -> txtFig.stroke;
                         txtFig[] -> add;
                         2 -> construct.flexHSpace -> add;
                      #);
                 #);
               configure:
                 (# ruler: ^RulerFigure;
                    construct: @Construction;
                 do 12 -> baseMinimumHeight;
                    outline.clear;
                    title[] -> outline.add;
                    (if expanded then
                        &RulerFigure[] -> ruler[];
                        ruler.init;
                        res.black[] -> ruler.stroke;
                        13 -> ruler.minimumWidth;
                        8 -> ruler.minimumHeight;
                        true -> ruler.horizontallyFlexible;
                        ruler[] -> outline.add;
                        pane[] -> outline.add; 
                       
                    if);
                 #);
               init::
                 (# center: ^CenterFigure;
                    background: ^Figure;
                    ruler: ^RulerFigure;
                    pane: ^RowFigure;
                 do 60 -> baseMinimumWidth;
                    &CenterFigure[] -> center[] -> main[];
                    center.init;
                    2 -> center.margin;
                    true -> center.verticallyFlexible;
                    true -> center.horizontallyFlexible;
                    center[] -> add;
                    
                    
                    
                    placard[] -> createBackground -> background[];
                    true -> background.horizontallyFlexible;
                    true -> background.verticallyFlexible;
                    background[] -> center.add;
                    background[] -> center.background[];
                    -6 -> center.inset;
                    
                    &ColumnFigure[] -> outline[];
                    outline.init;
                    true -> outline.horizontallyFlexible;
                    true -> outline.verticallyFlexible;
                    outline[] -> center.add;
                    
                    &TitleFigure[] -> title[];
                    title.init;
                    configure;
                 #);
            #);
          
          AttributeOutliner: RowFigure
            (# target: ^ObjectReflector.AttributeReflector;
               theConnector: ^Connector;
               valueFig: ^TextFigure;
               referenceBtn: ^ReferenceButton;
               refresh:
                 (# old: ^Text;
                    new: ^Text;
                 do valueFig.content -> old[];
                    target.description -> new[];
                    new[] -> valueFig.content;
                    (if not updateflag then
                        (if not (new[] -> old.equal) then
                            res.red[] -> valueFig.stroke;
                         else
                            res.black[] -> valueFig.stroke;
                        if);
                    if);
                    (if referenceBtn[] <> NONE then
                        referenceBtn.clear;
                        (if theConnector[] <> NONE then
                            (if theConnector.destination[] <> NONE then
                                res.green[] -> createCircle -> referenceBtn.add;
                             else
                                NONE -> theConnector[];
                                up[] -> createImageFigure -> referenceBtn.add;
                            if);
                         else
                            up[] -> createImageFigure -> referenceBtn.add;
                        if);
                    if);
                 #);
               
               connectHere:
                 (# other: ^ObjDesc.Template;
                    shape: ^ObjectShape;
                    x, y: @integer;
                 enter (x, y)
                 do (if theConnector[] = NONE then
                        target.reference -> other[];
                        (if other[] <> NONE then
                            other[] -> reflection
                              -> objectShapeForTarget
                              -> shape[];
                            (if shape.father[] = NONE then
                                shape[] -> getPatternName -> putline;
                                x + 60 -> shape.x;
                                y -> shape.y;
                                &shape.Drag[] -> shape.fig.theBehaviour[];
                                shape[] -> THIS(SequenceDiagram).add;
                                shape[] -> floating.append;
                            if);
                            (THIS(AttributeOutliner)[], shape[], HorisontalOrientation) 
                              -> connect
                              -> theConnector[];
                            true -> shape.sticky;
                            update;
                        if);
                    if);
                 #);
               disconnect:
                 (#
                 do (if theConnector[] <> NONE then
                        (if theConnector.destination[] <> NONE then
                            theConnector.dismiss;
                            NONE -> theConnector.destination[];
                        if);
                        NONE -> theConnector[];
                    if);
                 #);
               
               ReferenceButton: IconButton
                 (# click:
                      (#
                      do (if theConnector[] = NONE then
                             (0, 0) -> localToGlobal -> connectHere;
                          else
                             
                             disconnect;
                         if);
                         THIS(ObjectShape).refresh;
                      #);
                    onExpand::
                      (#
                      do click;
                      #);
                    onCollapse::
                      (#
                      do click;
                      #);
                 #);
               init::
                 (#
                 enter target[]
                 do (# txtFig: ^TextFigure;
                       
                       icon: ^RichPixmap;
                       construct: @Construction;
                       iconBtn: ^IconButton;
                       btn: ^Figure;
                    do true -> horizontallyFlexible;
                       16 -> baseMinimumHeight;
                       &TextFigure[] -> txtFig[];
                       txtFig.init;
                       target.name -> txtFig.content;
                       res.smallstyle[] -> txtFig.style;
                       res.black[] -> txtFig.stroke;
                       txtFig[] -> add;
                       
                       24 -> construct.flexHSpace -> add;
                       &TextFigure[] -> valueFig[];
                       valueFig.init;
                       target.description -> valueFig.content;
                       res.smallnicestyle[] -> valueFig.style;
                       res.black[] -> valueFig.stroke;
                       valueFig[] -> add;
                       8 -> construct.hSpace -> add;
                       (if target.kind 
                        //SimpleKind then
                           equal[] -> createImageFigure -> btn[];
                        //ReferenceKind then
                           &ReferenceButton[] -> iconBtn[] -> referenceBtn[];;
                           up[] -> createImageFigure -> iconBtn.init;
                           iconBtn[] -> btn[];
                        //PatternKind then
                           colon[] -> createImageFigure -> btn[];
                        //RepetionKind then
                           equal[] -> createImageFigure -> btn[];
                       if);
                       btn[] -> add;
                    #)
                 #);
            #);
       #);
    
     Construction:
       (# hSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do (#
               do &SpaceFigure[] -> space[];
                  space.init;
                  minimum -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
               #);
            exit space[]
            #);
          vSpace:
            (# 
            #);
          flexHSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do minimum -> hSpace -> space[];
               true -> space.horizontallyFlexible;
            exit space[]
            #);
          flexVSpace:
            (#
            #);
       #);
     
     init::
       (#
       do res.init;
          'thinborder3\\thinborder3' -> loadTileSet -> placard[];
          'icons\\colon.png' -> loadImage -> colon[];
          'icons\\equal.png' -> loadImage -> equal[];
          'icons\\up.png' -> loadImage -> up[];
          lines.init;
          lines[] -> add;
          nodes.init;
          nodes[] -> add;
          7 -> x;
          7 -> y;
       #);
  #);

-- windowLib: attributes --

SequenceCanvas: FigureCanvas
  (# sequence: @SequenceDiagram;
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do (caller[], self[], origin[], bc, isObj) -> sequence.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do (caller[], self[], origin[], bc) -> sequence.onReturn -> pause;
       exit pause
       #);
     open::
       (#
       do sequence.init;
          sequence[] -> add;
       #);
     eventHandler::
       (# onRefresh::
            (#
            do false -> sequence.updateflag;
            #);
       #);
  #);
SequenceWindow: SubWindow
  (# callBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Call' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.call;
                 #);
            #);
       #);
     callOverBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Call Over' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.callOver;
                 #);
            #);
       #);
     stepBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Step' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.step;
                 #);
            #);
       #);
     stepOverBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Step Over' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.stepOver;
                 #);
            #);
       #);
     skipInternalBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Skip Internal' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.skipInternal;
                 #);
            #);
       #);
     continueBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Continue' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.continue;
                 #);
            #);
       #);
     liveLinesBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Live Lines' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.liveLines;
                 #);
            #);
       #);
     closeBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Close' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.doClose;
                 #);
            #);
       #);
     clearStacksBtn: @PushButton
       (# open::
            (#
            do (70, 18) -> size;
               'Clear Stacks' -> label;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do interior.sequence.clearHistory;
                 #);
            #);
       #);
     keepStacksBox: @CheckBox
       (# open::
            (#
            do (70, 18) -> size;
               'Keep Stacks' -> label;
               fitToContents;
            #);
       #);
     LOGGING: (# exit false #);
     reflection:
       (# target: ^ObjDesc.Template;
          reflect: ^ObjectReflector;
       enter target[]
       do target[] -> interior.sequence.reflection -> reflect[];
       exit reflect[]
       #);
     nameOf:
       (# target: ^ObjDesc.Template;
          name: ^Text;
       enter target[]
       do (# reflect: ^ObjectReflector;
          do (if target[] <> NONE then
                 target[] -> reflection -> reflect[];
                 reflect.name -> name[];
              else
                 'NONE' -> name[];
             if);
          #);
       exit name[]
       #);
     
     count: @integer;
     
     keepHistory:
       (# value: @boolean;
       enter value
       do value -> interior.sequence.doKeepHistory;
       #);
     clearHistory:
       (#
       do interior.sequence.clearHistory;
       #);
     
     setCompiler:
       (# reference: ^generator;
       enter reference[]
       do reference[] -> interior.sequence.compiler[];
       #);
     setVM:
       (# reference: ^| systemenv.betaVM;
       enter reference[]
       do reference[] -> interior.sequence.VM[];
       #);
     setLog:
       (# reference: ^Object;
       enter reference[]
       do reference[] -> interior.sequence.L[];
       #);
     
     onStart:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do keepStacksBox.state -> keepHistory;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[start ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onStart -> pause;
       exit pause
       #);
     onAlloc:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          isObj: @boolean;
          pause: @boolean;
       enter (caller[], self[], origin[], bc, isObj)
       do keepStacksBox.state -> keepHistory;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[alloc ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          
          (caller[], self[], origin[], bc, isObj) -> interior.onAlloc -> pause;
       exit pause
       #);
     onDo:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do keepStacksBox.state -> keepHistory;
       	  (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[do ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onDo -> pause;
       exit pause
       #);
     onReturn:
       (# caller: ^ObjDesc.Template;
          self: ^ObjDesc.Template;
          origin: ^ObjDesc.Template;
          bc: @integer;
          pause: @boolean;
       enter (caller[], self[], origin[], bc)
       do keepStacksBox.state -> keepHistory;
          (if LOGGING then
              count + 1 -> count;
              count -> screen.putInt
              (#
              do 4 -> width;
              #);
              ': ' -> puttext;
              '[return ' -> puttext;
              'caller: ' -> puttext;
              caller[] -> nameOf -> puttext;
              ' ' -> puttext;
              'self: ' -> puttext;
              self[] -> nameOf -> puttext;
              ' ' -> puttext;
              'origin: ' -> puttext;
              origin[] -> nameOf -> puttext;
              ']' -> putline;
          if);
          (caller[], self[], origin[], bc) -> interior.onReturn -> pause;
       exit pause
       #);
     
     compile:
       (# objC: ^ObjectContent.handle
       enter objC[]
       do objC[] -> interior.sequence.compile;
       exit objC.aMod[]
       #);
     execute:
       (# objC: ^ObjectContent.handle; 
       enter objC[]
       do objC[] -> interior.sequence.execute;
       #);
     
     interior: @SequenceCanvas (# #);
     
     open::
       (# w, h: @integer;
          width, height: @integer;
       do hide;
          THIS(Window).size -> (w, h);
          (w - 410 - 5, h - 10) -> size;
          callBtn.open;
          (80, 7) -> callBtn.position;
          callOverBtn.open;
          (80 +  73, 7) -> callOverBtn.position;
          stepBtn.open;
          (80 +  (73 * 2), 7) -> stepBtn.position;
          stepOverBtn.open;
          (80 +  (73 * 3), 7) -> stepOverBtn.position;
          skipInternalBtn.open;
          (80 +  (73 * 4), 7) -> skipInternalBtn.position;
          continueBtn.open;
          (80 +  (73 * 5), 7) -> continueBtn.position;
          liveLinesBtn.open;
          (80 +  (73 * 6), 7) -> liveLinesBtn.position;
          closeBtn.open;
          (80 +  (73 * 7), 7) -> closeBtn.position;
          clearStacksBtn.open;
          
          (90 +  (73 * 8), 7) -> clearStacksBtn.position;
          keepStacksBox.open;
          (90 +  (73 * 9), 7) -> keepStacksBox.position;
          
          interior.open;
          (10, 28) -> interior.position;
          size -> (width, height);
          (width - 20, height - 38) -> interior.size;
          true -> interior.bindBottom;
          true -> interior.bindRight;
       #);
  #);

