ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE 'tableview';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'sequencediagram';
INCLUDE 'log';
INCLUDE 'newAttributeBox';
INCLUDE '../miniCompiler/generator';
INCLUDE '../miniCompiler/betaVM'
INCLUDE '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/utils/guienvadds';

---guienvlib:attributes---
worldWindow: window 
  (# 
     layoutFlag: @boolean;
     updater: @Timer
       (# action::
            (#
            do (if layoutFlag then
                   false -> layoutFlag;
                   mainLayout.layout;
               if);
            #);
       #);
     defaults: @
       (# headH: (# exit 20 #);
          worldWindowW: (# exit 1420 #);
          worldWindowH: (# exit 860 #);
          componentW: (# exit 480 #);
          componentH: (# exit 800 #);
          mainBrowserW: (# exit 380 #);
          mainBrowserH: (# exit 120 #);
          browserW: (# exit 92 #); 
          browserH: (# exit 120 - 11 #); (* - 2 * borderWidth *)
          textEditW: (# exit 201 #);
          textEditH: (# exit 650 - 11 #);   
       #);
     open:: 
       (# frame: @Rectangle;
          width, height: @integer;
       do ('minienv..log',false) -> L.open; (* we may move this to main program *)
          (compile[],VM[],L[]) -> ObjCont.init;
          
          screenRectangle -> frame;
          frame.size -> (width, height);
          
          (width - 20, height - 35 - 50) -> size;
          (10,35) -> position;
          popUp.open;
          'BETAworld' -> title;
          
          'BETAworld.bet' -> prependPathToBetaWorld -> FN[];
          'BETAworld.bet' -> FN.append -> FN[];
          (L[],true,none,FN[]) -> compile;

          (if false then
              'Setup: ' -> puttext; FN[] -> putline;
              'Root: ' -> puttext; compile.rootModule.name.lexemSy -> putline;
          if);
          
          theBETAworld.setup;
          100 -> updater.start;
       #);
     
     objContRoot: ^objCont.handle;
     eventHandler::
       (# onAboutToClose:: (# do terminate #);
          onMouseDown::
            (# P: @point
            do (if buttonState = 3 then
                   localPosition -> P;                  
                   popUp.enable;
                   (1,(P.H,P.V), contents) -> popUp.popUp
               if);
            #);
       #);     
     mainLayout: @HorizontalLayoutManager
       (# changed::
            (#
            do true -> layoutFlag;
            #);
       #);
     leftLayout: @VerticalLayoutManager;
     
     
     components: @Sequence
       (# element:: ComponentWindow;
       #);
     
     addByIndex:
       (# inx: @integer;
          name: ^Text;
          width, height: @integer;
          component: ^ComponentWindow;
       enter inx
       do (if inx = 0 then
              'BETA world' -> name[];
           else
              objContRoot.dclNames[inx][] -> name[];
          if);
          &ComponentWindow[] -> component[];
          (NONE, name[], inx, objContRoot[]) -> component.open;
          name[] -> puttext;
          component.size -> (width, height);
          ': ' -> puttext;
          width -> putint;
          ' ' -> puttext;
          height -> putint;
          newline;
          (width, height / 5) -> component.size;
          component.layout[] -> leftLayout.add;
          component[] -> components.append;
       #);
     closeAll:
       (#
       do components.scan
          (#
          do current.layout[] -> leftLayout.remove;
             current.close;
          #);
          components.clear;
       #);
     initialLayout:
       (#
       do THIS(Window).size -> leftLayout.size;
          480 -> leftLayout.width;
          leftLayout.layout;
       #);
     combine:
       (#
       do closeAll;
          0 -> addByIndex;
          initialLayout;
       #);
     split:
       (#
       do closeAll;
          (for inx: objContRoot.dclNames.range repeat
               inx -> addByIndex;
          for);
          initialLayout;
       #);
     
     theBETAworld: @
       (# setUp:
            (# 
            do mainLayout.init;
               THIS(Window).size -> mainLayout.size;
               leftLayout.init;
               leftLayout[] -> mainLayout.add;
               placeholder[] -> mainLayout.add;
               (compile.rootModule.name.lexemSy,compile.rootModule[],none,none)
                 -> ObjCont.handle
                 -> objContRoot[];
               combine;
            #);
          scan: 
            (# current: ^ComponentWindow; inx: @integer
            do components.scan
               (#
               do current[] -> THIS(Scan).current[];
                  inx + 1 -> inx;
                  INNER scan;
               #);
            #);
          selectCode:
            (# obj: ^objDesc.template; 
               path: ^intList; 
               descNo, beginPos, endPos: @integer;
               objC: ^objCont.handle;
            enter (obj[], descNo, path[], beginPos, endPos)
            do path.up;
               L: scan
                 (#
                 do (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) <> none then
                        (path[], 2, beginPos, endPos) -> current.select;
                        leave L;
                    if);
                 #);
            exit objC[]
            #);
       #);

     popUp: @menu
       (# iSave: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do 'SaveAll' -> putline;
                         theBETAworld.scan(# do current.saveEditBuffers #);
                         objContRoot.saveModuleToFile
                 #)#);
               open:: (# do 'Save All' -> name; iSave[] -> append; #);
            #);
          iQuit: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do terminate 
                      #)
                 #);
               open:: (# do 'Quit' -> name; iQuit[] -> append #);
            #);
          open::
            (#
            do iSave.open;
               iQuit.open
            #);
       #);
     displayWindow:
       (* Super pattern for static item in ComponentWindow, Items and TextEditor  *)
       (# enclosingObjCont: ^objCont.handle;
          left,right: ^displayWindow;
          setUpBrowser:< (# do inner #);
          position:< (# pos: @point do inner exit pos #);
          size:< (# width,height: @integer do inner exit(width,height) #);
          reDisplay:< (# do inner #);
          hasEditChanges:< BooleanValue (# do inner #);
          select:< (# do inner #);
          showErrors:< (# errors: ^stream enter errors[] do inner #);
          close:< (# do inner #);
          closeEditor:< (# do inner #);
          save:< (# errors: ^text do inner exit errors[] #);
          print:< (# T: @text do inner exit T[] #)
       #);
     
     componentWindow:  subwindow
       (# fixed: ^TextStyle;
          root: @boolean;
          index: @integer;
          
          maximum: @integer;
          onExpand::
            (# width, height: @integer;
            do THIS(SubWindow).size -> (width, height);
               (width, maximum) -> THIS(SubWindow).size;
               grow.show;
            #);
          onCollapse::
            (# width, height: @integer;
            do THIS(SubWindow).size -> (width, height);
               (width, 20 + 2 * theBorderWidth) -> THIS(SubWindow).size;
               height -> maximum;
               grow.hide;
            #);
          
          open::
            (# objC: ^ObjCont.handle;
               width, height: @integer;
            enter (index,objC[])
            do 'icons\\error.png' -> loadImage -> errorIcon[];
               'icons\\package.png' -> loadImage -> packageIcon[];
               'icons\\publicpackage.png' -> loadImage -> publicpackageIcon[];
               'icons\\privatepackage.png' -> loadImage -> privatepackageIcon[];
               'icons\\pattern.png' -> loadImage -> patternIcon[];
               'icons\\virtual.png' -> loadImage -> virtualIcon[];
               'icons\\reference.png' -> loadImage -> referenceIcon[];
               'icons\\lightref.png' -> loadImage -> lightrefIcon[];
               'icons\\simple.png' -> loadImage -> simpleIcon[];
               'icons\\array.png' -> loadImage -> arrayIcon[];
               'icons\\cog.png' -> loadImage -> cogwheel[];
               
               &TextStyle[] -> fixed[];
               'Courier' -> fixed.name;
               8 -> fixed.size;
               textFaces.plain -> fixed.face;
               (if index = 0 then (* currently never index = 0 *)
                   true -> root;
                   1 -> thisIndex;
                   objC[] -> asDW.enclosingObjCont[];
                else
                   (* move this imp to theBETAworld.setUp
                    * and perhaps also where we say split
                    * to handle 1 or more CWs
                    *)
                   index 
                     -> thisIndex 
                     -> objC.elm 
                     -> asDW.enclosingObjCont[];
               if);
               scroller.open;
               scroller[] -> browser.open;
               (theBorderWidth, defaults.headH + theBorderWidth)
                 -> scroller.position;
               (480, defaults.browserH) -> browser.size;
               browser.size -> scroller.size;
               true -> flexible;
               (NONE, 1, asDW.enclosingObjCont[])
                 -> (&BrowserItems[] -> theItems[]).setUpBrowser;
               false -> flexible;
               (0, 0) -> position;
               scroller.layout;
               THIS(Window).size -> (width, height);
               (defaults.componentW, height) -> size;
               fitToContents;
            #);
          asDW: @ displayWindow
            (# size:: (# do this(componentWindow).size -> (width,height) #);
               position:: (# do this(componentWindow).position -> pos #);
               reDisplay:: (#do 'componentWindow.asDW:reDisplay:shouldNotHappen' -> putline #);
               hasEditChanges:: (# do 'componentWindow.asDW:hasEditChanges:shouldNotHappen' -> putline #);
               save:: (# do 'componentWindow.asDW:save:shouldNotHappen' -> putline #);

            #);
          onOpenClose::
            (# w, h: @integer
            do (if true then
                   true -> THIS(ComponentWindow).sizeToFit;
                else
                   (if miniSize then
                       'OpenClose:Grow'->putline;
                       (fullW,fullH) -> this(componentWindow).size
                    else
                       'OpenClose:Reduce' -> putline;
                       this(componentWindow).size -> (fullW,fullH);
                       head.size -> (w,h);
                       (50,h)
                         -> this(componentWindow).size;
                       w-> putint; ' ' -> put; h -> putint; newline
                   if);
                   not miniSize -> miniSize;
               if)
            #);

          miniSize: @ boolean;
          fullW,fullH: @integer;
          selectCode: 
            (# obj: ^objDesc.template; descNo: @integer; path: ^intList; objC: ^objCont.handle
            enter(obj[],descNo,path[])
            do (obj[],descNo,path[]) -> asDW.enclosingObjCont.selectCode -> objC[]
            exit objC[]
            #);
          select:
            (# path: ^intList; inx,beginPos,endPos: @integer
            enter(path[],inx,beginPos,endPos)
            do (path[],inx,beginPos,endPos) -> theItems.select
            #);
          Heading::<
            (# open::
                 (#
                 do headingPopUp.open
                 #);
               eventHandler::<
                 (# onMouseUp::
                      (# P: @point
                      do (if buttonState = 3 then
                             localPosition -> P;
                             (1,(P.h,P.v),this(Heading)[]) -> headingPopUp.popUp
                         if)
                      #);                       
                    onMouseEnter:: (# #);
                 #);
               headingPopUp: @menu
                 (# iSplit: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do (if root then
                                       split;
                                    else
                                       combine;
                                   if);
                                #)
                           #);
                         open:: 
                           (# 
                           do (if index = 0 then
                                  'Split' -> name;
                               else
                                  'Assemble' -> name;
                              if);
                              iSplit[] -> append;
                           #)
                      #);
                    iClose: @MenuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do layout[] -> leftLayout.remove;
                                   THIS(ComponentWindow).close;
                                   THIS(ComponentWindow)[] -> components.delete;
                                   leftLayout.layout;
                                #)
                           #);
                         open:: 
                           (# 
                           do 'Close' -> name; 
                              iClose[] -> append;
                           #);
                      #);
                    open::
                      (#
                      do iSplit.open;
                         iClose.open;
                      #)
                 #);
            #);
          eventHandler::
            (# count: @integer;
               onFatherFrameChanged::
                 (#
                 do THIS(WorldWindow).size -> mainLayout.size;
                    mainLayout.layout;
                    
                 #);
               onMouseDown::
                 (# 
                 do trackMouse
                    (# mouseMove:: 
                         (#
                         do (h, v) -> move;
                            true -> this(SubWindow).update
                         #)
                    #)
                 #);
            #);
          scroller: @Canvas
            (# count: @integer;
               visible: @boolean;
               theScrollBar: @ScrollBar
                 (# count: @integer;
                    eventHandler::
                      (# onValueChanged::
                           (#
                           do theScrollBar.value -> scroll;
                           #);
                      #);
                 #);
               scroll:
                 (# value: @integer;
                    x, y: @integer;
                 enter value
                 do browser.position -> (x, y);
                    (-value, y) -> browser.position;
                 #);
               getScroll:
                 (# x, y: @integer;
                 do browser.position -> (x, y);
                 exit -x
                 #);
               
               layout:
                 (# width, height: @integer;
                    w, h: @integer;
                    x, y: @integer;
                 do position -> (x, y);
                    THIS(SubWindow)[] -> theScrollBar.open;
                    size -> (width, height);
                    theScrollBar.size -> (w, h);
                    (width, h) -> theScrollBar.size;
                    (0, y + height - h) -> theScrollBar.position;
                    true -> theScrollBar.bindRight;
                    theScrollBar.hide;
                    true -> browser.bindBottom;
                 #);
               checking: @boolean;
               checkScrollValues:
                 (# page: @integer;
                    port: @integer;
                    excess: @integer;
                    h1: @integer;
                    h2: @integer;
                    h, w: @integer;
                    value: @integer;
                    checkit: @boolean;
                 do (if NOT checking then
                        true -> checking;
                        browser.size -> (page, h1);
                        scroller.size -> (port, h2);
                        theScrollBar.size -> (w, h);
                        (if page <= port then
                            (if visible then
                                theScrollBar.hide;
                                false -> visible;
                            if);
                            (port, defaults.browserH) -> scroller.size;
                            0 -> scroll;
                         else
                            page - port -> excess;
                            (if not visible then
                                theScrollBar.show;
                                true -> visible;
                            if);
                            (port, defaults.browserH - h) -> scroller.size;
                            excess -> theScrollBar.maxValue;
                            (if true then
                                excess -> theScrollBar.value;
                             else
                                (if theScrollBar.value > excess then
                                    excess -> theScrollBar.value;
                                if);
                            if);
                            getScroll -> value;
                            (if value <> theScrollBar.value then
                                theScrollBar.value -> scroll;
                            if);
                            browser.scrollIntoView;
                        if);
                        false -> checking;
                    if);
                 #);
               eventHandler::
                 (# onFrameChanged::
                      (#
                      do checkScrollValues;
                         (if false then
                             (if rightEditor[] <> NONE then
                                 rightEditor.adjustLineWidth;
                             if);
                         if);
                      #);
                 #);
            #);
          browser: @Canvas
            (# sizeToFit:
                 (# current: ^BrowserItems;
                    x, y: @integer;
                    w, h: @integer;	
                    minimum: @integer;
                    width, height: @integer;
                 do (if theItems[] <> NONE then
                        theItems[] -> current[];
                        loop:
                          (if current.right[] <> NONE then
                              current.right[] -> current[];
                              restart loop;
                          if);
                        current.position -> (x, y);
                        current.size -> (w, h);
                        size -> (width, height);
                        x + w + 1 -> width;
                        (width, height) -> size;
                    if);
                 #);
               scrollIntoView:
                 (# current: ^BrowserItems;
                 do theItems[] -> current[];
                    loop:
                      (if current[] <> NONE then
                          current.scrollIntoView;
                          current.right[] -> current[];
                          restart loop;
                      if);
                 #);
            #);
          theItems: ^BrowserItems; (* top Items of this(ComponentWindow) *)
          currentSelection: ^DisplayWindow; (* Current selection *)
          
          saveEditBuffers: (# do theItems.saveEditBuffers #);
          
          sizeToFit:
            (# current: ^BrowserItems;
               x, y: @integer;
               w, h: @integer;
               minimum: @integer;
               width, height: @integer;
               resize: @boolean;
            enter resize
            do browser.sizeToFit;
               browser.size -> (w, h);
               (w, h) -> scroller.size;
               false -> scroller.bindRight;
               size -> (width, height);
               w + theBorderwidth*2 -> minimum;
               (if (minimum > width) and resize then
                   (minimum, height) -> size;
                else
                   (width - theBorderwidth*2, h) -> scroller.size;
               if);
               true -> scroller.bindRight;
               scroller.checkScrollValues;
            #);
          
          BrowserItems: TableView
            (# open::
                 (# v: @point; h: @integer;
                    lWidth,lHeight: @integer;
                      
                 do (if asDW.left[] <> none then
                        asDW.left.position -> v;
                        asDW.left.size -> (lWidth,lHeight);
                        v.h + lWidth -> h
                     else 
                        1 -> h;
                        defaults.browserW -> lWidth;
                        defaults.browserH -> lHeight
                    if);
                    (h, 1) -> position;
                    (if scroller.visible then
                        (defaults.browserW, defaults.browserH - 16) -> size;
                     else
                        (defaults.browserW, defaults.browserH) -> size;
                    if);
                    fixed[] -> style;
                    true -> bindLeft;
                    itemPopUp.open; 
                    
                 #);
               asDW: @DisplayWindow
                 (* objC is an entry of the form
                  *    E = (X1,X2,... Xn)
                  * where X1, X2, ..., Xn
                  * are displayed in the item-list
                  *)
                 (# size:: (# do this(BrowserItems).size -> (width,height) #);
                    position:: (# do this(BrowserItems).position -> pos #);
                    thisInx: @integer;
                    thisObjCont:
                      (# objC: ^objCont.Handle
                      do thisInx -> enclosingObjCont.elm -> objC[]
                      exit objC[]
                      #);
                    reDisplay:: (# do (thisInx,0,0,true) -> display#);
                    hasEditChanges:: 
                      (# do (rightEditor[]<> none) and rightEditor.wasChanged -> value #);
                    closeEditor:: (# do none -> rightEditor[] #);
                    showErrors:: (# do errors[] -> this(browserItems).showErrors #);
                    save::
                      (# right: ^BrowserItems
                      do 'save: ' -> puttext;
                         ((thisObjCont).enclosingModuleObj).theName[] -> putline;
                         
                         (if hasEditChanges then
                             'Must save: ' -> puttext; print -> putline;
                             saveEditBuffers -> errors[];
                             
                             'errors: "' -> puttext;
                             errors[] -> puttext;
                             '"' -> putline;
                             
                             ((thisObjCont).enclosingModuleObj).saveModuleToFile;
                             (* closeRight;  --- if called from TextEdit::onTab, we
                              * should not close the textEditor
                              * Some redundancy with display below
                              *)
                             &BrowserItems[] -> right[];
                             right.asDW[] -> asDW.right[];
                             (asDW[],thisInx,thisObjCont) -> right.setUpBrowser;
                         if)                      
                      #);
                    print::
                      (# 
                      do (if thisInx > 0 then
                             (thisObjCont).entityPathFromModule -> T.puttext
                          else
                             'No selection' -> T.puttext
                         if);
                      #)
                 #);
               
               process:
                 (# event: ^EventHandler.MouseEvent;
                    P: @point
                 enter event[]
                 do (if selection.first > 0 then
                        (if event.doubleClick then 
                            (* selection.first -> gettext -> putline;
                             * 'Edit field' -> putline;
                             *)
                            selection.first -> editField;
                            event.LocalPosition -> P;
                            (* 'mouse.V: ' -> puttext; P.V -> putint; 
                             * ' mouse.H: ' -> puttext; P.H -> putint; newline;
                             *)
                         else                             
                            (if event.buttonState
                             // 1 then 
                                (selection.first,0,0,true) -> display
                             // 3 then
                                (if ((selection.first 
                                      -> asDW.thisInx 
                                      -> asDW.enclosingObjCont.elm).theEntry.kind)
                                    = '/' then
                                    itemPopUp.saveHandler[] -> itemPopUp.iSave.attach;
                                    (* Perhaps also insist on a do-part for iExe?*)
                                    itemPopUp.exeHandler[] -> itemPopUp.iExe.attach
                                if);
                                (if clipboard.hasText then
                                    (* And selection must be of the form
                                     * X: * P(# ... #)
                                     * where '*' may be define at pattern, part-object or module
                                     *)
                                    (if (selection.first 
                                          -> asDW.thisInx 
                                          -> asDW.enclosingObjCont.elm).theEntry.hasAttributes then
                                        itemPopUp.pasteHandler[] -> itemPopUp.iPaste.attach
                                    if);
                                    itemPopUp.myPasteHandler[] -> itemPopUp.iPaste.attach;
                                if);
                                (1,(0,0),this(BrowserItems)[]) -> itemPopUp.popUp;
                            if)
                        if)
                    if)
                 #);
               onMouseDown::
                 (#
                 do event[] -> process;
                 #);
               eventHandler::
                 (# onMouseUp::
                      (#
                      do THIS(MouseEvent)[] -> process;
                      #)
                 #);
               editField:
                 (# no: @integer; 
                    oldCont,oldName,newName: ^text; 
                    oldKind,newKind: @char;
                    P: @point; R: @rectangle;
                    TE: @editText
                      (# open::
                           (# 
                           do this(BrowserItems).style -> style;
                              borderStyles.simple -> border.style;
                              false -> border.visible;
                              (P.H + 1,P.V + R.top + 2) -> position;
                              (R.right-R.left+5,R.bottom-R.top+5) -> size; 
                              (* must add 5 to height for text cursor to be visible *)
                              no -> gettext -> oldCont[] -> contents;
                           #);
                         eventHandler::<
                           (# onKeyDown:: 
                                (# error: @boolean
                                do (* 'Key down: ' -> puttext; ch -> put; 
                                    ch -> putint; newline; ascii.nl -> putint; newline;
                                    *)
                                   (if ch = 13 (* nl on Windows?*) then
                                       (if not (contents -> oldCont.equal) then
                                           (oldCont[],contents) -> asDW.enclosingObjCont.changeAttName -> error;
                                           (if error then
                                               'Syntax error in browser item: '-> puttext;
                                               contents -> putline
                                            else
                                               (no,contents) -> setText;
                                           if)
                                       if);
                                       close
                                   if)
                                #)
                           #)
                      #)
                 enter no
                 do no -> getItemRectangle -> R;
                    this(BrowserItems).position -> P;
                    browser[] -> TE.open
                 #);
               display:
                 (* for asDW where E = (X1,X2, ..., Xn)
                  * Xinx has been selected2
                  *)
                 (# inx,beginPos,endPos: @integer; 
                    mkTxtEditor: @boolean
                 enter(inx,beginPos,endPos,mkTxtEditor)
                 do L:
                      (# objCx: ^ObjCont.handle;
                      do (if currentSelection[] <> none then
                             (*'CurrentSelection: ' -> puttext; currentSelection.print;*)
                             (if currentSelection.save <> none then
                                 (* syntax errors in edit buffer og currentSelection *)
                                 leave L
                             if)
                         if);
                         closeRight;
                         asDW[] -> currentSelection[];
                         inx -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objCx[];
                         
                         (if objCx[] <> none then (* should never be none ! *)
                             (if pred[] <> none then (* why? *) pred.closeEditor if);
                             (*** items-create ***)
                             &BrowserItems[] -> right[];
                             right.asDW[] -> asDW.right[];
                             (asDW[],index,objCx[]) -> right.setUpBrowser;
                             (if mkTxtEditor then
                                 &textEdit[] -> rightEditor[];
                                 (asDW[],objCx[],beginPos,endPos) -> rightEditor.setUpEditor 
                             if);
                         if);
                      #)
                 #);
               showErrors:
                 (# x, y: @integer;
                    width, height: @integer;
                    errors: ^Stream;
                 enter errors[]
                 do '-----' -> putline;
                    errors.reset;
                    errors[] -> putline;
                    '-----' -> putline;
                    (if rightEditor[] <> NONE then
                        rightEditor.size -> (width, height);
                        rightEditor.position -> (x, y);
                        (width, height - 320) -> rightEditor.size;
                        &ErrorList[] -> errorView[];
                        errorView.open;
                        (x, y + (height - 320)) -> errorView.position;
                        (width, 320) -> errorView.size;
                        true -> errorView.bindRight;
                        true -> errorView.bindBottom;
                        errors[] -> errorView.display;
                        errors[] -> rightEditor.handleErrors;
                    if);
                 #);
               itemPopUp: @menu
                 (# iAdd: @menuItem
                      (# open:: (#do 'Add' -> name; iAdd[] -> append #);
                         eventHandler::
                           (# onSelect::
                                (# x: @newAttributeBox;
                                do x.open;
                                   (if not x.isCanceled then 
                                       (if X.name.length = 0 then
                                           '*** Missing name!'-> putline
                                        else
                                           (if false then
                                               'add module: ' -> puttext;
                                               x.name[] -> putline;
                                               (selection.first, x.name[]) -> asDW.enclosingObjCont.addModule;
                                               reload;
                                            else
                                               (selection.first,x.name[],x.kind,x.before) -> addItem;
                                           if);
                                       if);
                                   if)
                                #);
                           #);
                         addItem:
                           (# inx,kind: @integer; N,att: ^text; before: @boolean; 
                              objCx: ^ObjCont.handle
                           enter(inx,N[],kind,before)
                           do (if not before then inx + 1 -> inx if);
                              (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                              
                              '*** AddItem: "' -> puttext; N[] -> puttext; ' ' ->put; kind -> put;
                              ' "*** OBS! Missing check of syntax and double declaration' -> putline;

                              ('selection',inx) -> L.TIn;
                              (inx,N[],kind)  -> asDW.enclosingObjCont.addItem -> att[];
                              
                              (inx,att[]) -> configure;
                              (inx,false) -> selection.select;
                              closeRight;
                              (if false then
                                  inx -> asDW.enclosingObjCont.elm -> objCx[];
                                  ('addItem:ObjX',objCx.theName[]) -> L.TTn;
                              if);
                              ('addItem:enclosingObjCont',asDW.enclosingObjCont.theName[]) 
                                -> L.TTn;
                              (inx, 0,0,true) -> display
                           #);
                      #);
                    iMove: @menuItem
                      (# eventHandler:: 
                           (# onSelect:: (* never called - has submenu *)
                                (# 
                                do 'Move' -> putline;
                                   (1,(0,0),this(BrowserItems)[]) -> UD.popUp
                           #)#);
                         open:: 
                           (# 
                           do 'Move' -> name; iMove[] -> append;
                              UD.open; 
                              UD[] -> subMenu
                           #);
                         UD: @menu
                           (# iUp: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Up' -> putline; 
                                             (if 1 < (selection.first -> inx) then
                                                 inx -> gettext -> T[];
                                                 (inx, inx - 1 -> gettext) -> setText;
                                                 (inx - 1, T[]) -> setText;
                                                 (T[],inx) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Up' -> name; 
                                        iUp[] -> append; 
                                     #);
                                #);
                              iDown: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Down' -> putline; 
                                             (if (selection.first ->inx) < numberOfItems then
                                                 inx -> gettext -> T[];
                                                 (inx, inx + 1 -> gettext) -> setText;
                                                 (inx + 1 , T[]) -> setText;
                                                 (T[],inx + 1) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Down' -> name; 
                                        iDown[] -> append; 
                                     #);
                                #);
                              open:: (# do iUp.open; iDown.open #)
                           #)
                      #);      
                    iCopy: @menuItem
                      (# eventHandler::
                           (# onselect::
                                (# inx: @integer;
                                   T: ^text
                                do (if (selection.first ->inx) <= numberOfItems then
                                       'Copy: ' -> puttext;
                                       inx -> gettext -> T[]; ' '-> T.put;
                                       
                                       (if true then
                                           (# dcl: ^generator.Node;
                                           do asDW.enclosingObjCont.DCLs[inx][] -> dcl[];
                                              dcl.doPt -> T[];
                                           #);
                                        else
                                           (selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm ).gettext -> T.append;
                                       if);
                                       T[] -> clipBoard.textContents;
                                       T[] -> putline
                                   if)
                                #)
                           #);
                         open::(#do 'Copy' -> name; iCopy[] -> append #)
                      #);
                    iPaste: @dynamicMenuItem
                      (# open:: (# do 'Paste'-> name; iPaste[] -> append #)
                      #);
                    myPasteHandler: @menuAction
                      (# onSelect::
                           (# inx: @integer;
                              att: ^Text;
                           do '-- PASTE --' -> putline;
                              clipBoard.textContents -> putline;
                              '-----------' -> putline;
                              (if selection.first = 0 then
                                  1 -> inx;
                               else
                                  selection.first -> inx;
                              if);
                              (inx, clipBoard.textContents)  
                                -> asDW.enclosingObjCont.addDecl 
                                -> att[];
                              (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                              (inx,att[]) -> configure;
                              (inx,false) -> selection.select;
                              closeRight;
                              (inx, 0,0,true) -> display
                           #);
                      #);
                    pasteHandler: @menuAction
                      (# onSelect::
                           (# inx: @integer; N,T,att: ^text; kind: @integer;
                              IT: ^generator.Item; objX: ^objCont.handle;
                              dcl: ^generator.Decl;
                              errors: ^stream
                           do (*     1: X1  |
                               *     2: X2  |
                               *     3: ... |
                               * first: Foo |
                               *      : ... |
                               * clipBoard: "bar: ..." is parsed 
                               * and if ok, bar becomes an attribute of Foo
                               *)
                              L:
                                (#
                                do 'Paste: at:' -> puttext; selection.first -> inx -> gettext -> putline;
                                   clipboard.textcontents -> putline;
                                   clipboard.textcontents 
                                     -> compile.pDecl 
                                   (# xsyntaxError::
                                        (# 
                                        do '**** Syntax error in paste buffer'-> putline;
                                           leave L
                                        #)
                                   #) -> (errors[],N[],kind,IT[],dcl[]);
                                   'Paste: ' -> puttext; N[] -> puttext; ' ' -> put; kind -> put; newline;
                                   (if IT[] <> none then 'a'->put;
                                       IT.doPT -> T[]; 0 -> t.setpos;
                                       (if T.get = ' ' then 'b'->put;
                                           (if T.get = '@' then 'c'->put;
                                               (1,2) -> T.delete;
                                           if);
                                           '"' -> put; T[] -> putline; '"' -> put;
                                        else 'd'->put;
                                           (1,1) -> T.delete; T[] -> putline
                                       if)
                                    else 'e' -> put;
                                       (if dcl[] <> none then
                                           dcl.doPT -> T[]
                                        else
                                           'pasteHandler: IT and dcl are none'->putline
                                       if)
                                   if); 'f'->put; newline;
                                   selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objX[];
                                   (* objX = (Foo, atributes of Foo) *)
                                   'objX: '->puttext; objX.theName[] -> putline;
                                   (1,N[],kind) -> objX.addItem -> att[]; (* add item N=bar 
                                                                           * as an attribute of Foo
                                                                           * Note: empty desc here
                                                                           *)
                                   1 -> objX.elm -> objX[]; (*objX = (bar, atts of Bar) *)
                                   'objX:2: '->puttext; objX.theName[] -> putline;
                                   (* Should we call asDW/currentSelection.save?
                                    * OBS! AddItem above also calls save?
                                    * But another objX?? And empty desc!
                                    *)
                                   T[]  -> objX.saveBuffer; (* desc of bar is defined *)
                           #)#)
                      #);
                    iDelete: @menuItem  
                      (# eventHandler::
                           (# onSelect:: 
                                (# inx: @integer
                                do 'iDelete: ' -> puttext;
                                   selection.first -> inx;
                                   asDW.enclosingObjCont.dclNames[inx][] -> putline;
                                   (asDW.enclosingObjCont.dclNames[inx][],selection.first)
                                     -> asDW.enclosingObjCont.delete;
                                   (inx,1) -> this(TableView).delete;
                                   (if inx > this(TableView).numberOfItems then inx - 1 -> inx if);
                                   (inx,false) -> selection.select;
                                   (selection.first,0,0,true) -> display
                           #)#); 
                         open:: 
                           (# do 'Delete' -> name; iDelete[] -> append; #);
                      #);
                    iSave: @dynamicMenuItem
                      (# open:: (# do 'Save'-> name; iSave[] -> append #);
                      #);
                    saveHandler:  @menuAction
                      (# onSelect:: (# do asDW.save #);
                      #);
                    iExe: @dynamicMenuItem
                      (# open:: (# do 'Execute' -> name; iExe[] -> append #);
                      #);
                    exeHandler: @menuAction
                      (# onSelect:: 
                           (# objX: ^ObjCont.handle;
                              comp: ^generator.Module;
                              x, y: @integer;
                              errors: ^stream
                           do (if (asDW.save -> errors[]) <> none then
                                  (* Save checks for syntax errors only
                                   * Semantic errors are not captured by Save
                                   *)
                                  '\n\n***** Syntax errors in module' -> putline;
                                  errors[] -> showErrors;
                               else
                                  ('Do execute',index) -> L.TI;
                                  (asDW.enclosingObjCont.theName[], selection.first) -> L.TI;
                                  
                                  &WorldSequenceWindow[] -> execution[];
                                  execution.open;
                                  placeholder[] -> mainLayout.remove;
                                  execution.layout[] -> mainLayout.add;
                                  
                                  'laying out: ' -> putline;
                                  mainLayout.layout;                                  
                                  compile[] -> execution.setCompiler;
                                  L[] -> execution.setLog;
                                  &|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;
                                  selection.first 
                                    -> asDW.enclosingObjCont.elm 
                                    -> objX[] 
                                    -> execution.compile 
                                    -> (comp[],errors[]);
                                  (if errors[] <> none then
                                      (* syntax errors have already been checked by Save
                                       * semantic errors are caught here
                                       *)
                                      '\n\n***** Errors in module' -> putline;
                                      errors[] -> putline;
                                      errors[] -> rightEditor.handleErrors;
                                      errors[] -> showErrors;
                                   else
                                      execution.show;
                                      objX[] -> execution.execute;
                              if)if)
                           #)
                      #);
                    open::
                      (#
                      do iAdd.open;
                         iCopy.open;
                         iPaste.open;
                         iMove.open;
                         iDelete.open;
                         iExe.open;
                         iSave.open;
                      #);
                 #);
               saveEditBuffers: 
                 (* Check the use of this one
                  * When called from display:currentSelection.save, 
                  * only the current buffer needs to be saved;
                  * there are no rightmost buffers that need to be saved
                  * Check othher calls - perhaps only the call above is needed 
                  * since we then always save the edit buffer
                  * Also update comments in textEditor about wasChanged,
                  * we never reselect a buffer with changed elements
                  *)
                 (# errors: ^text
                 do ('SaveEditBuffers',asDW.print) -> L.TTn;
                    (if rightEditor[] <> none then 
                        (if rightEditor.wasChanged then
                            true -> rightEditor.asDW.enclosingObjCont.wasChanged;
                            ('SaveEditBuffer',rightEditor.contents.contents) -> L.TTn;
                            rightEditor.contents.contents 
                              -> rightEditor.asDW.enclosingObjCont.saveBuffer
                              -> rightEditor.handleErrors
                              -> errors[]
                        if);
                        (if not rightEditor.asDW.enclosingObjCont.wasChanged then
                            (* may be true from a previous selection *)
                            ('SaveEditBuffer:not changed',rightEditor.contents.contents) ->  L.TTn
                        if)
                     else 
                        (if asDW.right[] <> none then 
                            right.saveEditBuffers (* never bound ...?*)
                    if)if)
                 exit errors[]
                 #);
               closeRight: 
                 (* close all Item-panes to the right and rightEditor *)
                 (# 
                 do ('CloseRight',asDW.print) -> L.TTn;
                    (if asDW.right[] <> none then 
                        right.closeRight;
                        right.close ;
                        none -> right[]; 
                        none -> asDW.right[]
                    if);
                    (if rightEditor[] <> none then
                        rightEditor.close
                    if);
                    (if errorView[] <> NONE then
                        errorView.close;
                        NONE -> errorView[];
                    if);
                    none -> rightEditor[]
                 #);
               pinx: @integer; 
               
               configure:
                 (# index: @integer;
                    str: ^Text;
                    visibility: @integer;
                 enter (index, str[])
                 do (# dcl: ^generator.Node;
                       obj: ^Object;
                       item: ^generator.ModuleItem;
                       desc: ^generator.ObjectDesc;
                       
                    do asDW.enclosingObjCont.DCLs[index][] -> dcl[];
                       dcl.sort -> obj[];
                       (if obj[] <> NONE then
                           (if obj## = compile.ModuleItem## then
                               obj[] -> item[];
                               item.desc -> desc[];
                               (if desc.props[] <> NONE then
                                   desc.props.OSDvisibility -> visibility;
                               if);
                           if);
                       if);
                    #);
                    
                    (# colon: @integer;
                       name: ^Text;
                       kind: @char;
                    do str.reset;
                       search: ':' -> str.find 
                       (#
                       do inx -> colon;
                          leave search;
                       #);
                       (1, colon - 1) -> str.sub -> name[];
                       (index, name[]) -> setText;
                       
                       str.length -> str.inxGet -> kind;
                       (if 'Action*' -> str.equal then
                           (index, cogwheel[]) -> setImage;
                        else
                           (if kind
                            //'/'
                            //'#' then
                               (if visibility
                                //0 then
                                   (index, publicpackageIcon[]) -> setImage;
                                //1 then
                                   (index, packageIcon[]) -> setImage;
                                //2 then
                                   (index, privatepackageIcon[]) -> setImage;
                               if);
                            //' ' then
                               (index, patternIcon[]) -> setImage;
                            //'<' then
                               (index, virtualIcon[]) -> setImage;
                            //'^' then
                               (index, lightrefIcon[]) -> setImage;
                            //'@' then
                               (index, referenceIcon[]) -> setImage;
                            //'=' then
                               (index, simpleIcon[]) -> setImage;
                            //']' then
                               (index, arrayIcon[]) -> setImage;
                            else
                               name[] -> puttext;
                               ' kind: ' -> puttext;
                               kind -> put;
                               newline;
                               ' name: "' -> puttext;
                               str[] -> puttext;
                               '"' -> putline;
                           if);
                       if);
                    #);
                 #);
               reload:
                 (# width: @integer;
                    height: @integer;
                    
                 do clear;
                    asDW.enclosingObjCont.length -> append;
                    size -> (width, height);
                    asDW.enclosingObjCont.scan
                    (# w: @integer;
                    do current[] -> fixed.widthOfText -> w;
                       w + 16 + 16 -> w;
                       (inx,current[]) -> configure;
                       (if w > width then
                           w -> width;
                       if);
                    #);
                    (width, height) -> size;
                 #);
               setUpBrowser:
                 (# p: @point; 
                 enter(pred[],pinx,asDW.enclosingObjCont[])
                 do pred[] -> asDW.left[];
                    pinx + 1 -> index;
                    browser[] -> open;
                    reload;
                    true -> bindBottom;
                    (if execution[] = NONE then
                        true -> THIS(ComponentWindow).sizeToFit;
                     else
                        flexible -> THIS(ComponentWindow).sizeToFit;
                    if);
                 #);
               select:
                 (# path: ^intList; inx,beginPos,endPos: @integer
                 enter(path[],inx,beginPos,endPos)
                 do (if false then
                        'Select: ' -> puttext; inx -> putint; '['->put; 
                        path.scan(# do current -> putint; ' ' -> put #);
                        ']' -> put; ' ' -> put;
                    if);
                    (if (inx -> path.inRange) then
                        (if false then
                            inx -> path.get -> gettext -> puttext;
                            ' ' -> put; inx -> path.get -> putint; ' ' -> put;
                        if);
                        (inx -> path.get,false) -> selection.select;
                        (inx -> path.get,beginPos,endPos,false) -> display;
                        (if (asDW.right[] <> none) and (inx + 1 -> path.inRange) then
                            (inx -> path.get,beginPos,endPos,false) -> display;
                            (path[],inx + 1,beginPos,endPos) -> right.select
                         else
                            (inx -> path.get,beginPos,endPos,true) -> display
                        if)
                    if);
                 #);
               pred: ^displayWindow;
               right: ^Browseritems;
               index: @integer;
            #);
          rightEditor: ^textEdit;
          errorView: ^ErrorList;
          TextEdit: TextEditor
            (# aTextStyle: ^textStyle;
               open::
                 (# compW,compH,width,height: @integer;
                    
                 do this(componentWindow).size -> (compW,compH);
                    this(componentWindow).height - 20 - defaults.browserH - theBorderwidth*2 -> height;
                    this(componentWindow).width - theBorderwidth*2 -> width; 
                    (theBorderwidth, defaults.browserH + 20 + theBorderwidth) -> position;
                    (width, height) -> size;
                    &textStyle[] -> aTextStyle[]; 
                    'Courier' -> aTextStyle.name;
                    8 -> aTextStyle.size;
                    textFaces.plain -> aTextStyle.face;
                    aTextStyle[] -> contents.defaultstyle;
                    (if false then
                        'Linewidth: pixels: ' -> puttext; width -> putint;
                        ' maxChWidth: ' -> puttext; aTextStyle.maxChWidth -> putint; 
                        ' chars: ' -> puttext; width div aTextStyle.maxChWidth - 3 -> putint; newline;
                    if);
                    adjustLineWidth;
                    true -> bindBottom;
                    true -> bindRight;
                    editMenu.open
                 #);
               
               adjustLineWidth:
                 (# width, height: @integer;
                 do size -> (width, height);
                    width - 15 -> width;
                    width div aTextStyle.maxChWidth - 3 -> compile.lineWidth;
                    (if compile.lineWidth > 70 then
                        70 -> compile.lineWidth;
                    if);
                 #);
               asDW: @ displayWindow
                 (# size:: (# do this(textEdit).size -> (width,height) #);
                    position:: (# do this(textEdit).position -> pos #);
                    hasEditChanges:: (# do wasChanged -> value #);
                 #);

               init:< 
                 (# Tx: ^text; t: @styledText
                 enter Tx[]
                 do 
                    Tx -> T;
                    false -> realChange;
                    T[] -> contents.contents;
                    true -> realChange;
                 #);                
               setUpEditor:
                 (# left: ^displayWindow; (*items;*)
                    width,height,beginPos,endPos: @integer; 
                    P: @point;
                 enter(left[],asDW.enclosingObjCont[],beginPos,endPos)
                 do left[] -> asDW.left[];
                    asDW.left.position -> P; 
                    asDW.left.size -> (width,height);
                    open;
                    asDW.enclosingObjCont.getText -> init;
                    (* 'setUpEditor: ' -> puttext;
                     * beginPos -> putint; ' ' -> put; endPos -> putint; newline;*)
                    
                    (if (beginPos <> 0) and (endPos <> 0) then
                        (beginPos,endPos) -> contents.selection.set; 
                        contents.update; (* perhaps not needed *)
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if);
                    contents.selection.scrollIntoView;
                    grow.bringToFront;
                 #);           
               realChange,wasChanged: @ Boolean; 
               contentsType:: textField
                 (# eventHandler::<
                      (# onTab::
                           (# errors: ^text;
                              i, j: @integer;
                              startAdjusted, endAdjusted: @integer;
                           do (if (currentSelection.save -> errors[]) <> none then
                                  'OnTab: syntax errors'->putline;
                                  errors[] -> putline;
                                  (if true then
                                      errors[] -> asDW.left.showErrors
                                   else
                                      errors[] -> handleErrors
                                  if)
                               else
                                  selection.get -> (i, j);
                                  loop: all -> scanText
                                  (# inx: @integer;
                                     count: @integer;
                                  do inx + 1 -> inx;
                                     (if ch > 32 then
                                         count + 1 -> count;
                                     if);
                                     (if inx = i then
                                         count - 1 -> startAdjusted;
                                     if);
                                     (if inx = j then
                                         count - 1 -> endAdjusted;
                                     if);
                                  #);
                                  asDW.enclosingObjCont.getText -> init;
                                  loop: all -> scanText
                                  (# inx: @integer;
                                     count: @integer;
                                  do inx + 1 -> inx;
                                     (if ch > 32 then
                                         count + 1 -> count;
                                     if);
                                     (if count = startAdjusted then
                                         inx + 1 -> i;
                                     if);
                                     (if count = endAdjusted then
                                         inx + 1 -> j;
                                     if);
                                  #);
                                  (i, j) -> selection.set;
                                  selection.scrollIntoView;
                              if);
                           #);
                         onTextChanged:: 
                           (# 
                           do (if realChange then true -> wasChanged if)
                           #);
                         onMouseDown:: 
                           (# p: @point;
                           do (if buttonState = 3 then
                                  localPosition -> p;
                                  (1,p,THIS(InterfaceObject)[]) -> editMenu.popUp
                              if)
                           #)
                      #);
                 #);
               editMenu: @menu
                 (# iCompile: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do 'Compile and doPT ' -> putline;
                                   currentSelection.save;
                                   asDW.enclosingObjCont.getText -> init
                                #)
                           #);
                         open::
                           (# 
                           do 'Compile' -> name;
                              iCompile[] -> append;
                           #);
                      #);
                    iSetBreak: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do (* 'SetBreak' -> putline ;*)
                                   contents.selection.start 
                                     -> asDW.enclosingObjCont.setBreak -> breaks.add
                                #)
                           #);
                         open::
                           (# 
                           do 'Set break' -> name; 
                              iSetBreak[] -> append;
                           #)
                      #);
                    open:: (# do iCompile.open; iSetBreak.open #);
                 #);                              
               
               handleErrors:
                 (# S: ^stream; start,end: @integer
                 enter S[]
                 do (if S[] <> none then 
                        S[] -> putline;
                        S.reset;    
                        S.getint - 1 -> start; S.getint -> end;
                        (start,end) -> contents.selection.set;
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if)
                 exit S[]
                 #);
            #);
          ErrorList0: TableView
            (# display:
                 (# errors: ^Stream;
                 enter errors[]
                 do 1 -> append;
                    (1, 'Hello, World') -> setText;
                 #);
            #);
          errorIcon: ^RichPixmap;
          patternIcon: ^RichPixmap;
          virtualIcon: ^RichPixmap;
          packageIcon: ^RichPixmap;
          publicpackageIcon: ^RichPixmap;
          privatepackageIcon: ^RichPixmap;
          simpleIcon: ^RichPixmap;
          arrayIcon: ^RichPixmap;
          referenceIcon: ^RichPixmap;
          lightrefIcon: ^RichPixmap;
          cogwheel: ^RichPixmap;
          
          ErrorList: TableView
            (# items: @Sequence
                 (# Element:: ErrorItem;
                 #);
               
               open::
                 (#
                 do items.init;
                 #);
               
               ErrorItem:
                 (# start: @integer;
                    end: @integer;
                    what: ^Text;
                    
                    description:
                      (# value: ^Text;
                      do what.copy -> value[];
                         ' (' -> value.puttext;
                         start -> value.putint;
                         ' to ' -> value.puttext;
                         end -> value.putint;
                         ')' -> value.puttext;
                      exit value[]
                      #);
                    range:
                      (#
                      exit (start, end)
                      #);
                 #);
               display:
                 (# errors: ^Stream;
                    start, end: @integer;
                    what: ^Text;
                    counter: @integer;
                    item: ^ErrorItem;
                 enter errors[]
                 do (if errors[] <> NONE then
                        errors.reset;
                        loop:
                          (if NOT errors.eos then
                              counter + 1 -> counter;
                              errors.getint - 1 -> start; errors.getint -> end;
                              errors.getline -> what[];
                              &ErrorItem[] -> item[];
                              start -> item.start;
                              end -> item.end;
                              what[] -> item.what[];
                              1 -> append;
                              (counter, item.description) -> setText;
                              (counter, errorIcon[]) -> setImage;
                              item[] -> items.append;
                              restart loop;
                          if);
                    if);
                 #);
               
               displayError:
                 (# item: @integer;
                 enter item
                 do (# selected: ^ErrorItem;
                    do item -> items.get -> selected[];
                       selected.range -> rightEditor.contents.selection.set;
                       rightEditor.contents[] -> target;
                    #);
                 #);
               
               onMouseDown::
                 (#
                 do selection.first -> displayError;
                 #);
               
               (***
               eventHandler::
                 (# onSelect::
                      (#
                      do item -> displayError;
                      #);
                #);
               ***)
            #);
          thisIndex: @integer
       #);
     
     execution: ^SequenceWindow;
     placeholder: @SpaceLayout;
     
     WorldSequenceWindow: SequenceWindow
       (# onClose::
            (#
            do execution.layout[] -> mainLayout.remove;
               execution.close;
               NONE -> execution[];
               placeholder[] -> mainLayout.add;
            #);
       #);
     
     theSystemEnv: ^systemenv;
     
     worldVM: theSystemEnv.betaVM
       (# selectCode:
            (# caller: ^ObjDesc.Template; 
               descNo: @integer;
               objD: ^objDesc;
               bc: ^byteCode;
               trace: (# exit false #);
            enter caller[]
            do (# desc: ^generator.ObjectDesc;
                  lsc,beginPos, endPos: @integer;
                  path: ^IntList;
               do &IntList[] -> path[];                                   
                  (if trace then
                      'Select code:' -> puttext;  caller.myName -> puttext;
                      ','->put; caller.myDescInx -> putint; 
                      ' lsc: '->puttext; caller.myLsc -> putint;
                  if);
                  (if caller.lscTop > 0 then (* preliminary hack *)
                      (if false then
                          caller.myCode -> bc[];
                          caller.myObjDesc -> objD[];
                          '------------'->putline;
                          
                          Loop:
                            (#
                            do                            
                               (if thisCode[] <> objD.bc[] then
                                   'thisCode/objD.bc: '->puttext;
                                   thisCode.descinx -> putint; '/'->put; objD.bc.descInx -> putint; newline;
                                   objD.superObjDesc[] -> objD[]; 
                                   (if objD[] = none then
                                       caller.myObjDesc -> objD[]
                                    else
                                       restart Loop
                               if)if)
                            #);
                          caller.myDescInx -> descNo;
                          objD.descInx -> descNo;
                       else
                          (if caller.myDescInx = compile.mainDescNo then 
                              caller.myDescInx -> descNo;
                              caller.myLsc -> lsc
                           else caller.topReturn -> (descNo,lsc)
                          if)
                      if);
                      descNo -> compile.newDesc.getOD -> desc[];
                      true -> desc.doPT->putline ; (* OBS! true is needed to update charPos in desc *)
                      descNo -> putint; ' ' -> put; caller.myLsc -> putint; newline;
                      lsc (*caller.myLsc *)
                        -> desc.acp.mapBCposToCharRange 
                        -> (beginPos,endPos);
                      beginPos -> putint; ','->put; endPos -> putint; newline;
                      (if caller.myDescInx = compile.mainDescNo then 
                          caller.myDescInx -> descNo 
                       else 
                          (desc[],beginPos,endPos)
                            -> desc.father.adjustForSingularImp
                            -> (desc[],beginPos,endPos);
                          desc.descNo -> descNo
                      if);
                      (if trace then
                          ' new:descNo: ' -> puttext; descNo -> putint;
                          ' pos: ' -> puttext;
                          beginPos -> putint; ','->put; endPos -> putint;  
                          newline
                      if);
                      (caller[], descNo,path[], beginPos, endPos) -> theBETAworld.selectCode;
               if)#);
            #);
          putCh:: (# do ch -> execution.put #);
          getCh:: (# do execution.get -> ch #);
          startEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onStart then
                   doPause;
               if);
            #);
          allocEvent::
            (#
            do (if thisObj.OSDvisibility > 0 then
                   'Alloc: ' -> puttext; 
                   thisObj.myName -> puttext;
                   ': OSDvisibility='->puttext;
                   (if thisObj.OSDvisibility = 1 then 'SkipInternal'->putline
                    else 'disguised' -> putline
               if)if);
               (if (caller[], thisObj[], org[], bcpos, isObj, isIndexed) -> execution.onAlloc then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onDo then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doExitEvent::
            (#
            do 
            #);
          rtnEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onReturn then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onBreak then
                   bcPos -> breaks.astPos -> (beginPos,endPos);
                   &intList[] -> path[];
                   (thisObj[],thisObj.myDescInx,path[],beginPos,endPos) -> theBETAworld.selectCode;
                   doPause;
               if);
            #);
          display:
            (# event: ^text;
               push,popRstack: @boolean;
               from,to: ^ObjDesc.template; off: @integer; attNM: ^text; 
               isIndexed: @boolean; inx: @integer;
               offIsZero:< (# do inner #);
               field:
                 (# 
                 do ' field: "' -> puttext; attNM[] -> puttext; 
                    (if isIndexed then
                        '[' -> put; inx -> putint; ']' -> put
                    if);
                    '"' -> put;
                    ' off: ' -> puttext; off -> putint;
                 #);
               
            enter(event[],push,from[],popRstack,to[],off,attNM[],isIndexed,inx)
            do event[] -> puttext; 
               (if push then
                   'From: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   (if off = 0 then
                       offIsZero
                    else
                       field
                   if);
                   inner;                       
                   ' push on: "' -> puttext; to.myName -> puttext; '"' -> put;
                else
                   'Pop from: "' -> puttext;  from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   inner;
                   ' store at: "' -> puttext; to.myName -> puttext; '"' -> put;
                   (if off = 0 then
                       offIsZero
                    else
                       field
               if)if);
               newline
            #);
          vDisplay: display
            (# offIsZero::(# do ' const:' -> puttext #);
               value: @integer;               
            enter value
            do ' value: ' -> puttext; value -> putint; 
            #);
          rDisplay: display
            (# offisZero:: (# do ' this:' -> puttext #);
               refValue: ^ObjDesc.template
            enter refValue[]
            do ' ref: ' -> puttext; refValue.myName -> puttext
            #);
          getAttName:
            (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
               OD: ^generator.ObjectDesc
            enter(off,obj[],isRef,isIndexed)
            do 'xxx'-> nm[];
               obj.myDescInx -> compile.newDesc.getOD -> OD[];
               find:
                 OD.scanAllDecls
                 (# origin:: 
                      (#
                      do (if isRef and (off = this(getAttName).off) then
                             'origin' -> NM[];
                             leave find
                      if)#)
                 do (if off = currentND.off then
                        (if true
                         // not isRef and not isIndexed and currentDcl.IT.isSimple then 
                            currentND.lexemSy -> NM[];
                            leave find
                         // isRef and not isIndexed and not currentDcl.IT.isSimple then
                            currentND.lexemSy -> NM[];
                            leave find
                         // not isRef and isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                     else
                        (if isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                 if)#)
            exit NM[]
            #);
          vPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> execution.onVPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          vStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> execution.onVStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rPushEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> execution.onRPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rStoreEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> execution.onRStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
	  suspendEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onSuspend then
                   caller[] -> selectCode;
                   doPause;
               if); 
            #);
          resumeEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onResume then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          binOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onBinOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          unOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onUnOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          jmpGTevent::
            (#
            do (if (operator[], value, to[]) -> execution.onJmpGT then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          popEvent::
	    (#
            do (if (operator[], value, to[]) -> execution.onPop then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
       #);
     
     breaks: @
       (# IMPs: [4] ^generator.imperative; top: @integer;
          clear: (# do 0 -> top #);
          add:
            (# imp: ^generator.imperative
            enter imp[]
            do (if (top + 1 -> top) > IMPs.range then
                   IMPs.range -> IMPS.extend
               if);
               imp[] -> IMPS[top][]
            #);
          astPos:
            (# bcPos,beginPos,endPos: @integer
            enter bcPos
            do L: (for i: top repeat
                       (if bcPos = IMPs[i].beginBCP then
                           IMPS[i].beginPos -> beginPos;
                           IMPS[i].endPos -> endPos;
                           (if false then
                               'found astPos: ' -> puttext; beginPos -> putint;
                               ',' -> put; endPos -> putint; newline;
                           if);
                           leave L
                  if)for)
            exit(beginPos,endPos)
            #);                      
       #);
     
     
     ObjCont: @ObjectContent;
     compile: ^generator;
     VM: ^ | systemenv.betaVM;
     L: ^Log;
     stepCalls,callOver: @boolean;
     FN: ^text
  #);        
